{"file_name": "/home/qj213/afp-2021-10-22/thys/Factored_Transition_System_Bounding/TopologicalProps.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Factored_Transition_System_Bounding", "problem_names": ["lemma finite_PLS: \"finite (PLS s as)\"", "lemma expanded_problem_plan_bound_thm_1: \n  fixes PROB\n  shows \" \n    (problem_plan_bound PROB) = Sup (\n      (\\<lambda>(s,as). Inf (PLS s as)) `\n      {(s, as). (s \\<in> (valid_states PROB)) \\<and> (as \\<in> valid_plans PROB)}\n    )  \n  \"", "lemma expanded_problem_plan_bound_thm: \n  fixes PROB :: \"(('a, 'b) fmap \\<times> ('a, 'b) fmap) set\"\n  shows \"\n    problem_plan_bound PROB = Sup ({Inf (PLS s as) | s as. \n      (s \\<in> valid_states PROB) \n      \\<and> (as \\<in> valid_plans PROB)\n    })\n  \"", "lemma valid_path_ITP2015: \"\n  (valid_path Pi [] \\<longleftrightarrow> True)\n  \\<and> (valid_path Pi [s] \\<longleftrightarrow> (s \\<in> valid_states Pi))\n  \\<and> (valid_path Pi (s1 # s2 # rest) \\<longleftrightarrow>\n      (s1 \\<in> valid_states Pi) \n      \\<and> (\\<exists>a. \n        (a \\<in> Pi)\n        \\<and> (exec_plan s1 [a] = s2)\n      ) \n      \\<and> (valid_path Pi (s2 # rest))\n  )\n\"", "lemma in_PLS_leq_2_pow_n: \n  fixes PROB :: \"'a problem\" and s :: \"'a state\" and as\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\" \n  shows \"(\\<exists>x. \n    (x \\<in> PLS s as) \n    \\<and> (x \\<le> (2 ^ card (prob_dom PROB)) - 1)\n  )\"", "lemma in_MPLS_leq_2_pow_n: \n  fixes PROB :: \"'a problem\" and x\n  assumes \"finite PROB\" \"(x \\<in> MPLS PROB)\"\n  shows \"(x \\<le> 2 ^ card (prob_dom PROB) - 1)\"", "lemma FINITE_MPLS: \n  assumes \"finite (Pi :: 'a problem)\"\n  shows \"finite (MPLS Pi)\"", "lemma LENGTH_statelist': \n  fixes as s\n  shows \"length (statelist' s as) = (length as + 1)\"", "lemma valid_path_statelist': \n  fixes as and s :: \"('a, 'b) fmap\"\n  assumes \"(as \\<in> valid_plans Pi)\" \"(s \\<in> valid_states Pi)\"\n  shows \"(valid_path Pi (statelist' s as))\"", "lemma statelist'_exec_plan: \n  fixes a s p\n  assumes \"(statelist' s as = p)\"\n  shows \"(exec_plan s as = last p)\"", "lemma statelist'_EQ_NIL: \"statelist' s as \\<noteq> []\"", "lemma statelist'_TAKE_i:\n  assumes \"Suc m \\<le> length (a # as)\"\n  shows \"m \\<le> length as\"", "lemma statelist'_TAKE: \n  fixes as s p\n  assumes \"(statelist' s as = p)\"\n  shows \"(\\<forall>n. n \\<le> length as \\<longrightarrow> (exec_plan s (take n as)) = (p ! n))\"", "lemma MPLS_nempty: \n  fixes PROB :: \"(('a, 'b) fmap \\<times> ('a, 'b) fmap) set\" \n  assumes \"finite PROB\"\n  shows \"MPLS PROB \\<noteq> {}\"", "theorem bound_main_lemma: \n  fixes PROB :: \"'a problem\" \n  assumes \"finite PROB\"\n  shows \"(problem_plan_bound PROB \\<le> (2 ^ (card (prob_dom PROB))) - 1)\"", "lemma bound_child_parent_card_state_set_cons: \n  fixes P f\n  assumes \"(\\<forall>(PROB :: 'a problem) as (s :: 'a state). \n    (P PROB) \n    \\<and> (as \\<in> valid_plans PROB) \n    \\<and> (s \\<in> valid_states PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as) \n      \\<and> (length as' < f PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB s as. \n    (P PROB)\n    \\<and> (as \\<in> valid_plans PROB)\n    \\<and> (s \\<in> (valid_states PROB))\n    \\<longrightarrow> (\\<exists>x. \n      (x \\<in> PLS s as) \n      \\<and> (x < f PROB)\n    )\n  )\"", "lemma bound_on_all_plans_bounds_MPLS: \n  fixes P f\n  assumes \"(\\<forall>(PROB :: 'a problem) as (s :: 'a state).\n    (P PROB) \n    \\<and> (s \\<in> valid_states PROB) \n    \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as) \n      \\<and> (length as' < f PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB x. P PROB\n    \\<longrightarrow> (x \\<in> MPLS(PROB)) \n    \\<longrightarrow> (x < f PROB)\n  )\"", "lemma bound_child_parent_card_state_set_cons_finite: \n  fixes P f\n  assumes \"(\\<forall>PROB as s.\n    P PROB \\<and> finite PROB \\<and> as \\<in> (valid_plans PROB) \\<and> s \\<in> (valid_states PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> subseq as' as \n      \\<and> length as' < f(PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB s as. \n    P PROB \\<and> finite PROB \\<and> as \\<in> (valid_plans PROB) \\<and> (s \\<in> (valid_states PROB))\n    \\<longrightarrow> (\\<exists>x. (x \\<in> PLS s as) \\<and> x < f PROB)\n  )\"", "lemma bound_on_all_plans_bounds_MPLS_finite: \n  fixes P f\n  assumes \"(\\<forall>PROB as s. \n    P PROB \\<and> finite PROB \\<and> s \\<in> (valid_states PROB) \\<and> as \\<in> (valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> subseq as' as \n      \\<and> length as' < f(PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB x. \n    P PROB \\<and> finite PROB \n    \\<longrightarrow> (x \\<in> MPLS PROB)\n    \\<longrightarrow> x < f PROB\n  )\"", "lemma bound_on_all_plans_bounds_problem_plan_bound: \n  fixes P f\n  assumes \"(\\<forall>PROB as s. \n    (P PROB) \n    \\<and> finite PROB\n    \\<and> (s \\<in> valid_states PROB) \n    \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as')\n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB. \n    (P PROB) \n    \\<and> finite PROB\n    \\<longrightarrow> (problem_plan_bound PROB < f PROB)\n  )\"", "lemma bound_child_parent_card_state_set_cons_thesis: \n  assumes \"finite PROB\" \"(\\<forall>as s. \n    as \\<in> (valid_plans PROB) \n    \\<and> s \\<in> (valid_states PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as')\n      \\<and> subseq as' as \n      \\<and> length as' < k\n    ) \n  )\" \"as \\<in> (valid_plans PROB)\" \"(s \\<in> (valid_states PROB))\" \n  shows \"(\\<exists>x. (x \\<in> PLS s as) \\<and> x < k)\"", "lemma x_in_MPLS_if: \n  fixes x PROB \n  assumes \"x \\<in> MPLS PROB\"  \n  shows \"\\<exists>s as. s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB \\<and> x = Inf (PLS s as)\"", "lemma bound_on_all_plans_bounds_MPLS_thesis: \n  assumes \"finite PROB\" \"(\\<forall>as s. \n    (s \\<in> valid_states PROB) \n    \\<and> (as \\<in> valid_plans PROB)\n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' < k)\n    )\n  )\" \"(x \\<in> MPLS PROB)\" \n  shows \"(x < k)\"", "lemma bounded_MPLS_contains_supremum: \n  fixes PROB\n  assumes \"finite PROB\" \"(\\<exists>k. \\<forall>x \\<in> MPLS PROB. x < k)\" \n  shows \"Sup (MPLS PROB) \\<in> MPLS PROB\"", "lemma bound_on_all_plans_bounds_problem_plan_bound_thesis': \n  assumes \"finite PROB\" \"(\\<forall>as s. \n      s \\<in> (valid_states PROB) \n      \\<and> as \\<in> (valid_plans PROB)\n      \\<longrightarrow> (\\<exists>as'. \n        (exec_plan s as = exec_plan s as') \n        \\<and> subseq as' as \n        \\<and> length as' < k\n      )\n    )\"\n  shows \"problem_plan_bound PROB < k\"", "lemma bound_on_all_plans_bounds_problem_plan_bound_thesis: \n  assumes \"finite PROB\" \"(\\<forall>as s. \n      (s \\<in> valid_states PROB) \n      \\<and> (as \\<in> valid_plans PROB) \n      \\<longrightarrow> (\\<exists>as'. \n        (exec_plan s as = exec_plan s as') \n        \\<and> (subseq as' as)\n        \\<and> (length as' \\<le> k)\n      )\n    )\"\n  shows \"(problem_plan_bound PROB \\<le> k)\"", "lemma  bound_on_all_plans_bounds_problem_plan_bound_: \n  fixes P f PROB\n  assumes \"(\\<forall>PROB' as s. \n      finite PROB \\<and> (P PROB') \\<and> (s \\<in> valid_states PROB') \\<and> (as \\<in> valid_plans PROB') \n      \\<longrightarrow> (\\<exists>as'. \n        (exec_plan s as = exec_plan s as') \n        \\<and> (subseq as' as)\n        \\<and> (length as' < f PROB')\n      )\n    )\" \"(P PROB)\" \"finite PROB\" \n  shows \"(problem_plan_bound PROB < f PROB)\"", "lemma S_VALID_AS_VALID_IMP_MIN_IN_PLS: \n  fixes PROB s as\n  assumes \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\" \n  shows \"(Inf (PLS s as) \\<in> (MPLS PROB))\"", "lemma problem_plan_bound_ge_min_pls: \n  fixes PROB :: \"'a problem\" and s :: \"'a state\" and as k\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\" \n    \"(problem_plan_bound PROB \\<le> k)\"\n  shows \"(Inf (PLS s as) \\<le> problem_plan_bound PROB)\"", "lemma  PLS_NEMPTY: \n  fixes s as \n  shows \"PLS s as \\<noteq> {}\"", "lemma  PLS_nempty_and_has_min: \n  fixes s as \n  shows \"(\\<exists>x. (x \\<in> PLS s as) \\<and> (x = Inf (PLS s as)))\"", "lemma  PLS_works: \n  fixes x s as\n  assumes \"(x \\<in> PLS s as)\" \n  shows\"(\\<exists>as'. \n      (exec_plan s as = exec_plan s as')\n      \\<and> (length as' = x) \n      \\<and> (subseq as' as)\n    )\"", "lemma problem_plan_bound_works: \n  fixes PROB :: \"'a problem\" and as and s :: \"'a state\"\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\" \n  shows \"(\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' \\<le> problem_plan_bound PROB)\n    )\"", "lemma bound_main_lemma_s_3: \n  fixes PROB :: \"(('a, 'b) fmap \\<times> ('a, 'b) fmap) set\" and s\n  shows \"MPLS_s PROB s \\<noteq> {}\"", "lemma  bound_on_all_plans_bounds_PLS_s: \n  fixes P f \n  assumes \"(\\<forall>PROB as s.  \n    finite PROB \\<and> (P PROB) \\<and> (as \\<in> valid_plans PROB) \\<and> (s \\<in> valid_states PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as')\n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB s)\n    )\n  )\"\n  shows \"(\\<forall>PROB s as. \n    finite PROB \\<and> (P PROB) \\<and> (as \\<in> valid_plans PROB) \\<and> (s \\<in> valid_states PROB)\n    \\<longrightarrow> (\\<exists>x. \n      (x \\<in> PLS s as) \n      \\<and> (x < f PROB s)\n    )\n  )\"", "lemma bound_on_all_plans_bounds_MPLS_s_i:\n  fixes PROB s x\n  assumes \"s \\<in> valid_states PROB\" \"x \\<in> MPLS_s PROB s\" \n  shows \"\\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB\"", "lemma bound_on_all_plans_bounds_MPLS_s: \n  fixes P f\n  assumes \"(\\<forall>PROB as s.\n    finite PROB \\<and> (P PROB) \\<and> (as \\<in> valid_plans PROB)  \\<and> (s \\<in> valid_states PROB)\n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB s)\n    )\n  )\"\n  shows \"(\\<forall>PROB x s. \n    finite PROB \\<and> (P PROB) \\<and> (s \\<in> valid_states PROB) \\<longrightarrow> (x \\<in> MPLS_s PROB s) \n     \\<longrightarrow> (x < f PROB s)\n  )\"", "lemma Sup_MPLS_s_lt_if: \n  fixes PROB s k\n  assumes \"(\\<forall>x\\<in>MPLS_s PROB s. x < k)\"\n  shows \"Sup (MPLS_s PROB s) < k\"", "lemma bound_child_parent_lemma_s_2: \n  fixes PROB :: \"'a problem\" and P :: \"'a problem \\<Rightarrow> bool\" and s f\n  assumes \"(\\<forall>(PROB :: 'a problem) as s. \n    finite PROB \\<and> (P PROB) \\<and> (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB s)\n    )\n  )\"\n  shows \"(\n    finite PROB \\<and> (P PROB) \\<and> (s \\<in> valid_states PROB)\n    \\<longrightarrow> problem_plan_bound_s PROB s < f PROB s\n  )\"", "theorem bound_main_lemma_reachability_s: \n  fixes PROB :: \"'a problem\" and s\n  assumes \"finite PROB\" \"s \\<in> valid_states PROB\" \n  shows \"(problem_plan_bound_s PROB s < card (reachable_s PROB s))\"", "lemma  problem_plan_bound_s_LESS_EQ_problem_plan_bound_thm: \n  fixes PROB :: \"'a problem\" and s :: \"'a state\"\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\"\n  shows \"(problem_plan_bound_s PROB s < problem_plan_bound PROB + 1)\"", "lemma AS_VALID_MPLS_VALID: \n  fixes PROB as \n  assumes \"(as \\<in> valid_plans PROB)\" \n  shows \"(Inf (PLS s as) \\<in> MPLS_s PROB s)\"", "lemma bound_main_lemma_s_1: \n  fixes PROB :: \"'a problem\" and s :: \"'a state\" and x\n  assumes \"finite PROB\" \"s \\<in> (valid_states PROB)\" \"x \\<in> MPLS_s PROB s\"\n  shows \"(x \\<le> (2 ^ card (prob_dom PROB)) - 1)\"", "lemma problem_plan_bound_s_ge_min_pls: \n  fixes PROB :: \"'a problem\" and as k s\n  assumes \"finite PROB\" \"s \\<in> (valid_states PROB)\" \"as \\<in> (valid_plans PROB)\" \n    \"problem_plan_bound_s PROB s \\<le> k\"\n  shows \"(Inf (PLS s as) \\<le> problem_plan_bound_s PROB s)\"", "theorem bound_main_lemma_s:\n  fixes PROB :: \"'a problem\" and s\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\"\n  shows \"(problem_plan_bound_s PROB s \\<le> 2 ^ (card (prob_dom PROB)) - 1)\"", "lemma problem_plan_bound_s_works:\n  fixes PROB :: \"'a problem\" and as s\n  assumes \"finite PROB\" \"(as \\<in> valid_plans PROB)\" \"(s \\<in> valid_states PROB)\"\n  shows \"(\\<exists>as'. \n    (exec_plan s as = exec_plan s as') \n    \\<and> (subseq as' as) \n    \\<and> (length as' \\<le> problem_plan_bound_s PROB s)\n  )\"", "lemma PLS_def_ITP2015: \n  fixes s as\n  shows \"PLS s as = {length as' | as'. (exec_plan s as' = exec_plan s as) \\<and> (subseq as' as)}\"", "lemma expanded_problem_plan_bound_charles_thm: \n  fixes PROB :: \"'a problem\" \n  shows \" \n    problem_plan_bound_charles PROB \n    = Sup (\n      {\n        Inf (PLS_charles (fst p) (snd p) PROB) \n        | p. (fst p \\<in> valid_states PROB) \\<and> (snd p \\<in> valid_plans PROB)})\n  \"", "lemma bound_main_lemma_charles_3:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\"\n  shows \"MPLS_charles PROB \\<noteq> {}\"", "lemma in_PLS_charles_leq_2_pow_n: \n  fixes PROB :: \"'a problem\" and s as\n  assumes \"finite PROB\" \"s \\<in> valid_states PROB\" \"as \\<in> valid_plans PROB\"\n  shows \"(\\<exists>x. \n    (x \\<in> PLS_charles s as PROB) \n    \\<and> (x \\<le> 2 ^ card (prob_dom PROB) - 1))\n  \"", "lemma x_in_MPLS_charles_then: \n  fixes PROB s as\n  assumes \"x \\<in> MPLS_charles PROB\"\n  shows \"\\<exists>s as. \n    s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB \\<and> x = Inf (PLS_charles s as PROB)\n  \"", "lemma in_MPLS_charles_leq_2_pow_n:\n  fixes PROB :: \"'a problem\" and x\n  assumes \"finite PROB\" \"x \\<in> MPLS_charles PROB\"\n  shows \"x \\<le> 2 ^ card (prob_dom PROB) - 1\"", "lemma bound_main_lemma_charles:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\"\n  shows \"problem_plan_bound_charles PROB \\<le> 2 ^ (card (prob_dom PROB)) - 1\"", "lemma bound_on_all_plans_bounds_PLS_charles:\n  fixes P and f\n  assumes \"\\<forall>(PROB :: 'a problem) as s.\n    (P PROB) \\<and> finite PROB \\<and> (as \\<in> valid_plans PROB) \\<and> (s \\<in> valid_states PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \\<and> (subseq as' as)\\<and> (length as' < f PROB))\n  \"\n  shows \"(\\<forall>PROB s as. \n    (P PROB) \\<and> finite PROB \\<and> (as \\<in> valid_plans PROB)  \\<and> (s \\<in> valid_states PROB)\n    \\<longrightarrow> (\\<exists>x. \n      (x \\<in> PLS_charles s as PROB) \n      \\<and> (x < f PROB)))\n  \"", "lemma bound_on_all_plans_bounds_MPLS_charles_i:\n  assumes \"\\<forall>(PROB :: 'a problem) s as.\n    (P PROB) \\<and> finite PROB \\<and> (as \\<in> valid_plans PROB) \\<and> (s \\<in> valid_states PROB)\n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \\<and> (subseq as' as) \\<and> (length as' < f PROB))\n  \"\n  shows \"\\<forall>(PROB :: 'a problem) s as.\n    P PROB \\<and> finite PROB \\<and> as \\<in> valid_plans PROB \\<and> s \\<in> valid_states PROB\n    \\<longrightarrow> Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n  \"", "lemma bound_on_all_plans_bounds_MPLS_charles:\n  fixes P f\n  assumes \"(\\<forall>(PROB :: 'a problem) as s. \n    (P PROB) \\<and> finite PROB \\<and> (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB x. \n    (P PROB) \\<and> finite PROB\n    \\<longrightarrow> (x \\<in> MPLS_charles PROB) \n    \\<longrightarrow> (x < f PROB)\n  )\"", "lemma bound_on_all_plans_bounds_problem_plan_bound_charles_i: \n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"\\<forall>x \\<in> MPLS_charles PROB. x < k\"\n  shows \"Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB\"", "lemma bound_on_all_plans_bounds_problem_plan_bound_charles: \n  fixes P f\n  assumes \"(\\<forall>(PROB :: 'a problem) as s. \n    (P PROB) \\<and> finite PROB \\<and> (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB)))\n  \"\n  shows \"(\\<forall>PROB. \n    (P PROB) \\<and> finite PROB \\<longrightarrow> (problem_plan_bound_charles PROB < f PROB))\n  \"", "lemma sublistD_bounds_D:  \n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\"\n  shows \"problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB\"", "lemma MAX_SET_ELIM':\n  fixes P Q\n  assumes \"finite P\" \"P \\<noteq> {}\" \"(\\<forall>x. (\\<forall>y. y \\<in> P \\<longrightarrow> y \\<le> x) \\<and> x \\<in> P \\<longrightarrow> R x)\"\n  shows \"R (Max P)\"", "lemma MIN_SET_ELIM':\n  fixes P Q\n  assumes \"finite P\" \"P \\<noteq> {}\" \"\\<forall>x. (\\<forall>y. y \\<in> P \\<longrightarrow> x \\<le> y) \\<and> x \\<in> P \\<longrightarrow> Q x\"\n  shows \"Q (Min P)\"", "lemma RD_bounds_sublistD_i_a:\n  fixes Pi :: \"'a problem\" \n  assumes \"finite Pi\"\n  shows \"finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}\"", "lemma RD_bounds_sublistD_i_b:\n  fixes Pi :: \"'a problem\" \n  shows \"{length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}\"", "lemma RD_bounds_sublistD_i_c:\n  fixes Pi :: \"'a problem\" and as :: \"(('a, bool) fmap \\<times> ('a, bool) fmap) list\" and x \n    and s :: \"('a, bool) fmap\" \n  assumes \"s \\<in> valid_states Pi\" \"as \\<in> valid_plans Pi\" \n    \"(\\<forall>y. y \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<longrightarrow> y \\<le> x)\" \n    \"x \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}\"\n  shows \"Min (PLS s as) \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\"", "lemma RD_bounds_sublistD_i:\n  fixes Pi :: \"'a problem\" and x\n  assumes \"finite Pi\" \"(\\<forall>y. y \\<in> MPLS Pi \\<longrightarrow> y \\<le> x)\" \"x \\<in> MPLS Pi\" \n  shows \"x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\"", "lemma RD_bounds_sublistD: \n  fixes Pi :: \"'a problem\"\n  assumes \"finite Pi\"\n  shows \"problem_plan_bound Pi \\<le> RD Pi\"", "theorem sublistD_bounds_D_and_RD_bounds_sublistD: \n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\"\n  shows \"\n    problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB \n    \\<and> problem_plan_bound PROB \\<le> RD PROB\n  \"", "lemma empty_problem_bound: \n  fixes PROB :: \"'a problem\"\n  assumes \"(prob_dom PROB = {})\"\n  shows \"(problem_plan_bound PROB = 0)\"", "lemma problem_plan_bound_works':\n  fixes PROB :: \"'a problem\" and as s\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'. \n    (exec_plan s as' = exec_plan s as) \n    \\<and> (subseq as' as)\n    \\<and> (length as' \\<le> problem_plan_bound PROB) \n    \\<and> (sat_precond_as s as')\n  )\"", "lemma problem_plan_bound_UBound: \n  assumes \"(\\<forall>as s.\n    (s \\<in> valid_states PROB) \n    \\<and> (as \\<in> valid_plans PROB)\n    \\<longrightarrow> (\\<exists>as'.\n      (exec_plan s as = exec_plan s as') \n      \\<and> subseq as' as \n      \\<and> (length as' < f PROB)\n    )\n  )\" \"finite PROB\"\n  shows \"(problem_plan_bound PROB < f PROB)\"", "lemma finite_traversed_states: \"finite (traversed_states s as)\"", "lemma traversed_states_nempty: \"traversed_states s as \\<noteq> {}\"", "lemma traversed_states_geq_1: \n  fixes s\n  shows \"1 \\<le> card (traversed_states s as)\"", "lemma init_is_traversed: \"s \\<in> traversed_states s as\"", "lemma traversed_states_rem_condless_act: \"\\<And>s. \n  traversed_states s (rem_condless_act s [] as) = traversed_states s as\n\"", "lemma td_UBound_i: \n  fixes PROB :: \"(('a, 'b) fmap \\<times> ('a, 'b) fmap) set\"\n  assumes \"finite PROB\" \n  shows \"\n  {\n    (card (traversed_states (fst p) (snd p))) - 1 \n    | p. (fst p \\<in> valid_states PROB) \\<and> (snd p \\<in> valid_plans PROB)}\n  \\<noteq> {}\n  \"", "lemma td_UBound: \n  fixes PROB :: \"(('a, 'b) fmap \\<times> ('a, 'b) fmap) set\" \n  assumes \"finite PROB\" \"(\\<forall>s as. \n    (sat_precond_as s as) \\<and> (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (card (traversed_states s as) \\<le> k)\n  )\"\n  shows \"(td PROB \\<le> k - 1)\""], "translations": [["", "lemma finite_PLS: \"finite (PLS s as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (PLS s as)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (PLS s as)", "let ?S = \"{as'. (exec_plan s as' = exec_plan s as) \\<and> (subseq as' as)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (PLS s as)", "let ?S1 = \"length ` {as'. (exec_plan s as' = exec_plan s as) }\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (PLS s as)", "let ?S2 = \"length ` {as'. (subseq as' as)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (PLS s as)", "let ?n = \"length as + 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (PLS s as)", "have \"finite ?S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (length ` {as'. subseq as' as})", "using bounded_nat_set_is_finite[where n = ?n and N = ?S2]"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>length ` {as'. subseq as' as}.\n     i < length as + 1 \\<Longrightarrow>\n  finite (length ` {as'. subseq as' as})\n\ngoal (1 subgoal):\n 1. finite (length ` {as'. subseq as' as})", "by fastforce"], ["proof (state)\nthis:\n  finite (length ` {as'. subseq as' as})\n\ngoal (1 subgoal):\n 1. finite (PLS s as)", "moreover"], ["proof (state)\nthis:\n  finite (length ` {as'. subseq as' as})\n\ngoal (1 subgoal):\n 1. finite (PLS s as)", "have \"length ` ?S \\<subseteq> (?S1 \\<inter> ?S2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}\n    \\<subseteq> length ` {as'. exec_plan s as' = exec_plan s as} \\<inter>\n                length ` {as'. subseq as' as}", "by blast"], ["proof (state)\nthis:\n  length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}\n  \\<subseteq> length ` {as'. exec_plan s as' = exec_plan s as} \\<inter>\n              length ` {as'. subseq as' as}\n\ngoal (1 subgoal):\n 1. finite (PLS s as)", "ultimately"], ["proof (chain)\npicking this:\n  finite (length ` {as'. subseq as' as})\n  length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}\n  \\<subseteq> length ` {as'. exec_plan s as' = exec_plan s as} \\<inter>\n              length ` {as'. subseq as' as}", "have \"finite (length ` ?S)\""], ["proof (prove)\nusing this:\n  finite (length ` {as'. subseq as' as})\n  length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}\n  \\<subseteq> length ` {as'. exec_plan s as' = exec_plan s as} \\<inter>\n              length ` {as'. subseq as' as}\n\ngoal (1 subgoal):\n 1. finite\n     (length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as})", "using infinite_super"], ["proof (prove)\nusing this:\n  finite (length ` {as'. subseq as' as})\n  length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}\n  \\<subseteq> length ` {as'. exec_plan s as' = exec_plan s as} \\<inter>\n              length ` {as'. subseq as' as}\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. finite\n     (length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as})", "by auto"], ["proof (state)\nthis:\n  finite\n   (length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as})\n\ngoal (1 subgoal):\n 1. finite (PLS s as)", "then"], ["proof (chain)\npicking this:\n  finite\n   (length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as})", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   (length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as})\n\ngoal (1 subgoal):\n 1. finite (PLS s as)", "unfolding PLS_def"], ["proof (prove)\nusing this:\n  finite\n   (length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as})\n\ngoal (1 subgoal):\n 1. finite\n     (length ` {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as})", "by blast"], ["proof (state)\nthis:\n  finite (PLS s as)\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE name shortened.\\<close>"], ["", "definition MPLS where\n  \"MPLS PROB \\<equiv>\n    (\\<lambda> (s, as). Inf (PLS s as)) \n    ` {(s, as). (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB)}\n  \"\n\n\n\\<comment> \\<open>NOTE name shortened.\\<close>"], ["", "definition problem_plan_bound where\n  \"problem_plan_bound PROB \\<equiv> Sup (MPLS PROB)\""], ["", "lemma expanded_problem_plan_bound_thm_1: \n  fixes PROB\n  shows \" \n    (problem_plan_bound PROB) = Sup (\n      (\\<lambda>(s,as). Inf (PLS s as)) `\n      {(s, as). (s \\<in> (valid_states PROB)) \\<and> (as \\<in> valid_plans PROB)}\n    )  \n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    (SUP (s,\n        as)\\<in>{(s, as).\n                 s \\<in> valid_states PROB \\<and>\n                 as \\<in> valid_plans PROB}.\n        Inf (PLS s as))", "unfolding problem_plan_bound_def MPLS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP (s,\n        as)\\<in>{(s, as).\n                 s \\<in> valid_states PROB \\<and>\n                 as \\<in> valid_plans PROB}.\n        Inf (PLS s as)) =\n    (SUP (s,\n        as)\\<in>{(s, as).\n                 s \\<in> valid_states PROB \\<and>\n                 as \\<in> valid_plans PROB}.\n        Inf (PLS s as))", "by blast"], ["", "lemma expanded_problem_plan_bound_thm: \n  fixes PROB :: \"(('a, 'b) fmap \\<times> ('a, 'b) fmap) set\"\n  shows \"\n    problem_plan_bound PROB = Sup ({Inf (PLS s as) | s as. \n      (s \\<in> valid_states PROB) \n      \\<and> (as \\<in> valid_plans PROB)\n    })\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "have \"(\n        {Inf (PLS s as) | s as. (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB)}\n      ) = ((\\<lambda>(s, as). Inf (PLS s as)) ` {(s, as).\n        (s \\<in> valid_states PROB) \n        \\<and> (as \\<in> valid_plans PROB)\n      })\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Inf (PLS s as) |s as.\n     s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n    (\\<lambda>(s, as). Inf (PLS s as)) `\n    {(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "by fast"], ["proof (state)\nthis:\n  {Inf (PLS s as) |s as.\n   s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n  (\\<lambda>(s, as). Inf (PLS s as)) `\n  {(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "also"], ["proof (state)\nthis:\n  {Inf (PLS s as) |s as.\n   s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n  (\\<lambda>(s, as). Inf (PLS s as)) `\n  {(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "have \"\\<dots> = \n      (\\<lambda>(s, as). Inf (PLS s as)) ` \n      ({s. fmdom' s = prob_dom PROB} \\<times> {as. set as \\<subseteq> PROB})\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(s, as). Inf (PLS s as)) `\n    {(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n    (\\<lambda>(s, as). Inf (PLS s as)) `\n    ({s. fmdom' s = prob_dom PROB} \\<times> {as. set as \\<subseteq> PROB})", "unfolding valid_states_def valid_plans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(s, as). Inf (PLS s as)) `\n    {(s, as).\n     s \\<in> {s. fmdom' s = prob_dom PROB} \\<and>\n     as \\<in> {as. set as \\<subseteq> PROB}} =\n    (\\<lambda>(s, as). Inf (PLS s as)) `\n    ({s. fmdom' s = prob_dom PROB} \\<times> {as. set as \\<subseteq> PROB})", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>(s, as). Inf (PLS s as)) `\n  {(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n  (\\<lambda>(s, as). Inf (PLS s as)) `\n  ({s. fmdom' s = prob_dom PROB} \\<times> {as. set as \\<subseteq> PROB})\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "finally"], ["proof (chain)\npicking this:\n  {Inf (PLS s as) |s as.\n   s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n  (\\<lambda>(s, as). Inf (PLS s as)) `\n  ({s. fmdom' s = prob_dom PROB} \\<times> {as. set as \\<subseteq> PROB})", "have \"\n      Sup ({Inf (PLS s as) | s as. (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB)})\n      = Sup (\n        (\\<lambda>(s, as). Inf (PLS s as)) ` \n        ({s. fmdom' s = prob_dom PROB} \\<times> {as. set as \\<subseteq> PROB})\n      )\n    \""], ["proof (prove)\nusing this:\n  {Inf (PLS s as) |s as.\n   s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n  (\\<lambda>(s, as). Inf (PLS s as)) `\n  ({s. fmdom' s = prob_dom PROB} \\<times> {as. set as \\<subseteq> PROB})\n\ngoal (1 subgoal):\n 1. Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n    (SUP (s,\n        as)\\<in>{s. fmdom' s = prob_dom PROB} \\<times>\n                {as. set as \\<subseteq> PROB}.\n        Inf (PLS s as))", "by argo"], ["proof (state)\nthis:\n  Sup {Inf (PLS s as) |s as.\n       s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n  (SUP (s,\n      as)\\<in>{s. fmdom' s = prob_dom PROB} \\<times>\n              {as. set as \\<subseteq> PROB}.\n      Inf (PLS s as))\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "}"], ["proof (state)\nthis:\n  Sup {Inf (PLS s as) |s as.\n       s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n  (SUP (s,\n      as)\\<in>{s. fmdom' s = prob_dom PROB} \\<times>\n              {as. set as \\<subseteq> PROB}.\n      Inf (PLS s as))\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "moreover"], ["proof (state)\nthis:\n  Sup {Inf (PLS s as) |s as.\n       s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n  (SUP (s,\n      as)\\<in>{s. fmdom' s = prob_dom PROB} \\<times>\n              {as. set as \\<subseteq> PROB}.\n      Inf (PLS s as))\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "have \"\n    problem_plan_bound PROB \n    = \n      Sup ((\\<lambda>(s, as). Inf (PLS s as)) ` \n      ({s. fmdom' s = prob_dom PROB} \\<times> {as. set as \\<subseteq> PROB}))\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    (SUP (s,\n        as)\\<in>{s. fmdom' s = prob_dom PROB} \\<times>\n                {as. set as \\<subseteq> PROB}.\n        Inf (PLS s as))", "unfolding problem_plan_bound_def MPLS_def valid_states_def valid_plans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP (s,\n        as)\\<in>{(s, as).\n                 s \\<in> {s. fmdom' s = prob_dom PROB} \\<and>\n                 as \\<in> {as. set as \\<subseteq> PROB}}.\n        Inf (PLS s as)) =\n    (SUP (s,\n        as)\\<in>{s. fmdom' s = prob_dom PROB} \\<times>\n                {as. set as \\<subseteq> PROB}.\n        Inf (PLS s as))", "by fastforce"], ["proof (state)\nthis:\n  problem_plan_bound PROB =\n  (SUP (s,\n      as)\\<in>{s. fmdom' s = prob_dom PROB} \\<times>\n              {as. set as \\<subseteq> PROB}.\n      Inf (PLS s as))\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "ultimately"], ["proof (chain)\npicking this:\n  Sup {Inf (PLS s as) |s as.\n       s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n  (SUP (s,\n      as)\\<in>{s. fmdom' s = prob_dom PROB} \\<times>\n              {as. set as \\<subseteq> PROB}.\n      Inf (PLS s as))\n  problem_plan_bound PROB =\n  (SUP (s,\n      as)\\<in>{s. fmdom' s = prob_dom PROB} \\<times>\n              {as. set as \\<subseteq> PROB}.\n      Inf (PLS s as))", "show \"\n    problem_plan_bound PROB \n    = Sup ({Inf (PLS s as) | s as. \n      (s \\<in> valid_states PROB) \n      \\<and> (as \\<in> valid_plans PROB)\n    })\n  \""], ["proof (prove)\nusing this:\n  Sup {Inf (PLS s as) |s as.\n       s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} =\n  (SUP (s,\n      as)\\<in>{s. fmdom' s = prob_dom PROB} \\<times>\n              {as. set as \\<subseteq> PROB}.\n      Inf (PLS s as))\n  problem_plan_bound PROB =\n  (SUP (s,\n      as)\\<in>{s. fmdom' s = prob_dom PROB} \\<times>\n              {as. set as \\<subseteq> PROB}.\n      Inf (PLS s as))\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB =\n    Sup {Inf (PLS s as) |s as.\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "by argo"], ["proof (state)\nthis:\n  problem_plan_bound PROB =\n  Sup {Inf (PLS s as) |s as.\n       s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Recurrence Diameter\""], ["", "text \\<open> The recurrence diameter---defined as the longest simple path in the digraph modelling the\nstate space---provides a loose upper bound on the system diameter. [Abdulaziz et al., Definition 9, \np.15] \\<close>\n\n\\<comment> \\<open>NOTE name shortened.\\<close>\n\\<comment> \\<open>NOTE 'fun' because of multiple defining equations, pattern matches.\\<close>"], ["", "fun valid_path where\n  \"valid_path Pi [] = True\"\n| \"valid_path Pi [s] = (s \\<in> valid_states Pi)\"\n| \"valid_path Pi (s1 # s2 # rest) = (\n  (s1 \\<in> valid_states Pi) \n  \\<and> (\\<exists>a. (a \\<in> Pi) \\<and> (exec_plan s1 [a] = s2))\n  \\<and> (valid_path Pi (s2 # rest))\n)\""], ["", "lemma valid_path_ITP2015: \"\n  (valid_path Pi [] \\<longleftrightarrow> True)\n  \\<and> (valid_path Pi [s] \\<longleftrightarrow> (s \\<in> valid_states Pi))\n  \\<and> (valid_path Pi (s1 # s2 # rest) \\<longleftrightarrow>\n      (s1 \\<in> valid_states Pi) \n      \\<and> (\\<exists>a. \n        (a \\<in> Pi)\n        \\<and> (exec_plan s1 [a] = s2)\n      ) \n      \\<and> (valid_path Pi (s2 # rest))\n  )\n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path Pi [] = True \\<and>\n    valid_path Pi [s] = (s \\<in> valid_states Pi) \\<and>\n    valid_path Pi (s1 # s2 # rest) =\n    (s1 \\<in> valid_states Pi \\<and>\n     (\\<exists>a. a \\<in> Pi \\<and> exec_plan s1 [a] = s2) \\<and>\n     valid_path Pi (s2 # rest))", "using valid_states_def"], ["proof (prove)\nusing this:\n  valid_states ?prob \\<equiv> {s. fmdom' s = prob_dom ?prob}\n\ngoal (1 subgoal):\n 1. valid_path Pi [] = True \\<and>\n    valid_path Pi [s] = (s \\<in> valid_states Pi) \\<and>\n    valid_path Pi (s1 # s2 # rest) =\n    (s1 \\<in> valid_states Pi \\<and>\n     (\\<exists>a. a \\<in> Pi \\<and> exec_plan s1 [a] = s2) \\<and>\n     valid_path Pi (s2 # rest))", "by simp\n\n\n\\<comment> \\<open>NOTE name shortened.\\<close>\n\\<comment> \\<open>NOTE second declaration skipped (declared twice in source).\\<close>"], ["", "definition RD where\n  \"RD Pi \\<equiv> (Sup {length p - 1 | p. valid_path Pi p \\<and> distinct p})\"\nfor Pi :: \"'a problem\""], ["", "lemma in_PLS_leq_2_pow_n: \n  fixes PROB :: \"'a problem\" and s :: \"'a state\" and as\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\" \n  shows \"(\\<exists>x. \n    (x \\<in> PLS s as) \n    \\<and> (x \\<le> (2 ^ card (prob_dom PROB)) - 1)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x \\<le> 2 ^ card (prob_dom PROB) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x \\<le> 2 ^ card (prob_dom PROB) - 1", "obtain as' where 1:\n    \"exec_plan s as = exec_plan s as'\" \"subseq as' as\" \"length as' \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' \\<le> 2 ^ card (prob_dom PROB) - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms main_lemma"], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s ?as = exec_plan ?s as' \\<and>\n                       subseq as' ?as \\<and>\n                       length as' \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' \\<le> 2 ^ card (prob_dom PROB) - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x \\<le> 2 ^ card (prob_dom PROB) - 1", "let ?x=\"length as'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"?x \\<in> PLS s as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as' \\<in> PLS s as", "unfolding PLS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length as'\n    \\<in> length `\n          {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}", "using 1"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. length as'\n    \\<in> length `\n          {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}", "by simp"], ["proof (state)\nthis:\n  length as' \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x \\<le> 2 ^ card (prob_dom PROB) - 1", "moreover"], ["proof (state)\nthis:\n  length as' \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"?x \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as' \\<le> 2 ^ card (prob_dom PROB) - 1", "using 1(3)"], ["proof (prove)\nusing this:\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. length as' \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast"], ["proof (state)\nthis:\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x \\<le> 2 ^ card (prob_dom PROB) - 1", "ultimately"], ["proof (chain)\npicking this:\n  length as' \\<in> PLS s as\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1", "show \"(\\<exists>x. \n    (x \\<in> PLS s as) \n    \\<and> (x \\<le> (2 ^ card (prob_dom PROB)) - 1)\n  )\""], ["proof (prove)\nusing this:\n  length as' \\<in> PLS s as\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x \\<le> 2 ^ card (prob_dom PROB) - 1", "unfolding PLS_def"], ["proof (prove)\nusing this:\n  length as'\n  \\<in> length `\n        {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> length `\n               {as'.\n                exec_plan s as' = exec_plan s as \\<and>\n                subseq as' as} \\<and>\n       x \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> PLS s as \\<and> x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_MPLS_leq_2_pow_n: \n  fixes PROB :: \"'a problem\" and x\n  assumes \"finite PROB\" \"(x \\<in> MPLS PROB)\"\n  shows \"(x \\<le> 2 ^ card (prob_dom PROB) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "let ?mpls = \"MPLS PROB\"\n    \\<comment> \\<open>NOTE obtain p = (s, as) where 'x = Inf (PLS s as)' from premise.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"?mpls = \n    (\\<lambda> (s, as). Inf (PLS s as)) ` \n    {(s, as).  (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB)}\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPLS PROB =\n    (\\<lambda>(s, as). Inf (PLS s as)) `\n    {(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "using MPLS_def"], ["proof (prove)\nusing this:\n  MPLS ?PROB \\<equiv>\n  (\\<lambda>(s, as). Inf (PLS s as)) `\n  {(s, as). s \\<in> valid_states ?PROB \\<and> as \\<in> valid_plans ?PROB}\n\ngoal (1 subgoal):\n 1. MPLS PROB =\n    (\\<lambda>(s, as). Inf (PLS s as)) `\n    {(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "by blast"], ["proof (state)\nthis:\n  MPLS PROB =\n  (\\<lambda>(s, as). Inf (PLS s as)) `\n  {(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  MPLS PROB =\n  (\\<lambda>(s, as). Inf (PLS s as)) `\n  {(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "obtain s :: \"('a, bool) fmap\" and as :: \"(('a, bool) fmap \\<times> ('a, bool) fmap) list\" \n    where obtain_s_as: \"x \\<in> \n      ((\\<lambda> (s, as). Inf (PLS s as)) ` \n      {(s, as). (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB)})\n    \""], ["proof (prove)\nusing this:\n  MPLS PROB =\n  (\\<lambda>(s, as). Inf (PLS s as)) `\n  {(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. (x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n             {(s, as).\n              s \\<in> valid_states PROB \\<and>\n              as \\<in> valid_plans PROB} \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  MPLS PROB =\n  (\\<lambda>(s, as). Inf (PLS s as)) `\n  {(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n  x \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. (x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n             {(s, as).\n              s \\<in> valid_states PROB \\<and>\n              as \\<in> valid_plans PROB} \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as).\n           s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as).\n           s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "have \n    \"x \\<in> {Inf (PLS (fst p) (snd p)) | p. (fst p \\<in> valid_states PROB) \\<and> (snd p \\<in> valid_plans PROB)}\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as).\n           s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. x \\<in> {Inf (PLS (fst p) (snd p)) |p.\n             fst p \\<in> valid_states PROB \\<and>\n             snd p \\<in> valid_plans PROB}", "using assms(1) obtain_s_as"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as).\n           s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n  finite PROB\n  x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as).\n           s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. x \\<in> {Inf (PLS (fst p) (snd p)) |p.\n             fst p \\<in> valid_states PROB \\<and>\n             snd p \\<in> valid_plans PROB}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {Inf (PLS (fst p) (snd p)) |p.\n           fst p \\<in> valid_states PROB \\<and>\n           snd p \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  x \\<in> {Inf (PLS (fst p) (snd p)) |p.\n           fst p \\<in> valid_states PROB \\<and>\n           snd p \\<in> valid_plans PROB}", "have \n    \"\\<exists> p. x = Inf (PLS (fst p) (snd p)) \\<and> (fst p \\<in> valid_states PROB) \\<and> (snd p \\<in> valid_plans PROB)\""], ["proof (prove)\nusing this:\n  x \\<in> {Inf (PLS (fst p) (snd p)) |p.\n           fst p \\<in> valid_states PROB \\<and>\n           snd p \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       x = Inf (PLS (fst p) (snd p)) \\<and>\n       fst p \\<in> valid_states PROB \\<and> snd p \\<in> valid_plans PROB", "by blast"], ["proof (state)\nthis:\n  \\<exists>p.\n     x = Inf (PLS (fst p) (snd p)) \\<and>\n     fst p \\<in> valid_states PROB \\<and> snd p \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  \\<exists>p.\n     x = Inf (PLS (fst p) (snd p)) \\<and>\n     fst p \\<in> valid_states PROB \\<and> snd p \\<in> valid_plans PROB", "obtain p :: \"('a, bool) fmap \\<times> (('a, bool) fmap \\<times> ('a, bool) fmap) list\" where obtain_p:\n    \"x = Inf (PLS (fst p) (snd p))\" \"(fst p \\<in> valid_states PROB)\" \"(snd p \\<in> valid_plans PROB)\""], ["proof (prove)\nusing this:\n  \\<exists>p.\n     x = Inf (PLS (fst p) (snd p)) \\<and>\n     fst p \\<in> valid_states PROB \\<and> snd p \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>x = Inf (PLS (fst p) (snd p));\n         fst p \\<in> valid_states PROB;\n         snd p \\<in> valid_plans PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = Inf (PLS (fst p) (snd p))\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  x = Inf (PLS (fst p) (snd p))\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB", "have \"fst p \\<in> valid_states PROB\" \"snd p \\<in> valid_plans PROB\""], ["proof (prove)\nusing this:\n  x = Inf (PLS (fst p) (snd p))\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. fst p \\<in> valid_states PROB &&& snd p \\<in> valid_plans PROB", "using obtain_p"], ["proof (prove)\nusing this:\n  x = Inf (PLS (fst p) (snd p))\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n  x = Inf (PLS (fst p) (snd p))\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. fst p \\<in> valid_states PROB &&& snd p \\<in> valid_plans PROB", "by blast+"], ["proof (state)\nthis:\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB", "obtain x' :: nat where obtain_x':\n    \"x' \\<in> PLS (fst p) (snd p) \\<and> x' \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\nusing this:\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        x' \\<in> PLS (fst p) (snd p) \\<and>\n        x' \\<le> 2 ^ card (prob_dom PROB) - 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(1) in_PLS_leq_2_pow_n[where s = \"fst p\" and as = \"snd p\"]"], ["proof (prove)\nusing this:\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n  finite PROB\n  \\<lbrakk>finite ?PROB; fst p \\<in> valid_states ?PROB;\n   snd p \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       x \\<in> PLS (fst p) (snd p) \\<and>\n                       x \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        x' \\<in> PLS (fst p) (snd p) \\<and>\n        x' \\<le> 2 ^ card (prob_dom PROB) - 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x' \\<in> PLS (fst p) (snd p) \\<and> x' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  x' \\<in> PLS (fst p) (snd p) \\<and> x' \\<le> 2 ^ card (prob_dom PROB) - 1", "have 1: \"x' \\<le> 2 ^ card (prob_dom PROB) - 1\" \"x' \\<in> PLS (fst p) (snd p)\" \n    \"x = Inf (PLS (fst p) (snd p))\" \"finite (PLS (fst p) (snd p))\""], ["proof (prove)\nusing this:\n  x' \\<in> PLS (fst p) (snd p) \\<and> x' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. (x' \\<le> 2 ^ card (prob_dom PROB) - 1 &&&\n     x' \\<in> PLS (fst p) (snd p)) &&&\n    x = Inf (PLS (fst p) (snd p)) &&& finite (PLS (fst p) (snd p))", "using obtain_x' obtain_p finite_PLS"], ["proof (prove)\nusing this:\n  x' \\<in> PLS (fst p) (snd p) \\<and> x' \\<le> 2 ^ card (prob_dom PROB) - 1\n  x' \\<in> PLS (fst p) (snd p) \\<and> x' \\<le> 2 ^ card (prob_dom PROB) - 1\n  x = Inf (PLS (fst p) (snd p))\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n  finite (PLS ?s ?as)\n\ngoal (1 subgoal):\n 1. (x' \\<le> 2 ^ card (prob_dom PROB) - 1 &&&\n     x' \\<in> PLS (fst p) (snd p)) &&&\n    x = Inf (PLS (fst p) (snd p)) &&& finite (PLS (fst p) (snd p))", "by blast+"], ["proof (state)\nthis:\n  x' \\<le> 2 ^ card (prob_dom PROB) - 1\n  x' \\<in> PLS (fst p) (snd p)\n  x = Inf (PLS (fst p) (snd p))\n  finite (PLS (fst p) (snd p))\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "moreover"], ["proof (state)\nthis:\n  x' \\<le> 2 ^ card (prob_dom PROB) - 1\n  x' \\<in> PLS (fst p) (snd p)\n  x = Inf (PLS (fst p) (snd p))\n  finite (PLS (fst p) (snd p))\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"x \\<le> x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x'", "using 1(2, 4) obtain_p(1) cInf_le_finite"], ["proof (prove)\nusing this:\n  x' \\<in> PLS (fst p) (snd p)\n  finite (PLS (fst p) (snd p))\n  x = Inf (PLS (fst p) (snd p))\n  \\<lbrakk>finite ?X; ?x \\<in> ?X\\<rbrakk> \\<Longrightarrow> Inf ?X \\<le> ?x\n\ngoal (1 subgoal):\n 1. x \\<le> x'", "by blast"], ["proof (state)\nthis:\n  x \\<le> x'\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "ultimately"], ["proof (chain)\npicking this:\n  x' \\<le> 2 ^ card (prob_dom PROB) - 1\n  x' \\<in> PLS (fst p) (snd p)\n  x = Inf (PLS (fst p) (snd p))\n  finite (PLS (fst p) (snd p))\n  x \\<le> x'", "show \"(x \\<le> 2 ^ card (prob_dom PROB) - 1)\""], ["proof (prove)\nusing this:\n  x' \\<le> 2 ^ card (prob_dom PROB) - 1\n  x' \\<in> PLS (fst p) (snd p)\n  x = Inf (PLS (fst p) (snd p))\n  finite (PLS (fst p) (snd p))\n  x \\<le> x'\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "by linarith"], ["proof (state)\nthis:\n  x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FINITE_MPLS: \n  assumes \"finite (Pi :: 'a problem)\"\n  shows \"finite (MPLS Pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (MPLS Pi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (MPLS Pi)", "have \"\\<forall>x \\<in> MPLS Pi. x \\<le> 2 ^ card (prob_dom Pi) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS Pi. x \\<le> 2 ^ card (prob_dom Pi) - 1", "using assms in_MPLS_leq_2_pow_n"], ["proof (prove)\nusing this:\n  finite Pi\n  \\<lbrakk>finite ?PROB; ?x \\<in> MPLS ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS Pi. x \\<le> 2 ^ card (prob_dom Pi) - 1", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>MPLS Pi. x \\<le> 2 ^ card (prob_dom Pi) - 1\n\ngoal (1 subgoal):\n 1. finite (MPLS Pi)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>MPLS Pi. x \\<le> 2 ^ card (prob_dom Pi) - 1", "show \"finite (MPLS Pi)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS Pi. x \\<le> 2 ^ card (prob_dom Pi) - 1\n\ngoal (1 subgoal):\n 1. finite (MPLS Pi)", "using mems_le_finite[of \"MPLS Pi\" \"2 ^ card (prob_dom Pi) - 1\"]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS Pi. x \\<le> 2 ^ card (prob_dom Pi) - 1\n  \\<forall>x.\n     x \\<in> MPLS Pi \\<longrightarrow>\n     x \\<le> 2 ^ card (prob_dom Pi) - 1 \\<Longrightarrow>\n  finite (MPLS Pi)\n\ngoal (1 subgoal):\n 1. finite (MPLS Pi)", "by blast"], ["proof (state)\nthis:\n  finite (MPLS Pi)\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE 'fun' because of multiple defining equations.\\<close>"], ["", "fun statelist' where\n  \"statelist' s [] = [s]\"\n| \"statelist' s (a # as) = (s # statelist' (state_succ s a) as)\""], ["", "lemma LENGTH_statelist': \n  fixes as s\n  shows \"length (statelist' s as) = (length as + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (statelist' s as) = length as + 1", "by (induction as arbitrary: s) auto"], ["", "lemma valid_path_statelist': \n  fixes as and s :: \"('a, 'b) fmap\"\n  assumes \"(as \\<in> valid_plans Pi)\" \"(s \\<in> valid_states Pi)\"\n  shows \"(valid_path Pi (statelist' s as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s as)", "using assms"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans Pi\n  s \\<in> valid_states Pi\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s as)", "proof (induction as arbitrary: s Pi)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s Pi.\n       \\<lbrakk>[] \\<in> valid_plans Pi; s \\<in> valid_states Pi\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s [])\n 2. \\<And>a as s Pi.\n       \\<lbrakk>\\<And>s Pi.\n                   \\<lbrakk>as \\<in> valid_plans Pi;\n                    s \\<in> valid_states Pi\\<rbrakk>\n                   \\<Longrightarrow> valid_path Pi (statelist' s as);\n        a # as \\<in> valid_plans Pi; s \\<in> valid_states Pi\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "case cons: (Cons a as)"], ["proof (state)\nthis:\n  \\<lbrakk>as \\<in> valid_plans ?Pi; ?s \\<in> valid_states ?Pi\\<rbrakk>\n  \\<Longrightarrow> valid_path ?Pi (statelist' ?s as)\n  a # as \\<in> valid_plans Pi\n  s \\<in> valid_states Pi\n\ngoal (2 subgoals):\n 1. \\<And>s Pi.\n       \\<lbrakk>[] \\<in> valid_plans Pi; s \\<in> valid_states Pi\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s [])\n 2. \\<And>a as s Pi.\n       \\<lbrakk>\\<And>s Pi.\n                   \\<lbrakk>as \\<in> valid_plans Pi;\n                    s \\<in> valid_states Pi\\<rbrakk>\n                   \\<Longrightarrow> valid_path Pi (statelist' s as);\n        a # as \\<in> valid_plans Pi; s \\<in> valid_states Pi\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>as \\<in> valid_plans ?Pi; ?s \\<in> valid_states ?Pi\\<rbrakk>\n  \\<Longrightarrow> valid_path ?Pi (statelist' ?s as)\n  a # as \\<in> valid_plans Pi\n  s \\<in> valid_states Pi", "have 1: \"a \\<in> Pi\" \"as \\<in> valid_plans Pi\""], ["proof (prove)\nusing this:\n  \\<lbrakk>as \\<in> valid_plans ?Pi; ?s \\<in> valid_states ?Pi\\<rbrakk>\n  \\<Longrightarrow> valid_path ?Pi (statelist' ?s as)\n  a # as \\<in> valid_plans Pi\n  s \\<in> valid_states Pi\n\ngoal (1 subgoal):\n 1. a \\<in> Pi &&& as \\<in> valid_plans Pi", "using valid_plan_valid_head valid_plan_valid_tail"], ["proof (prove)\nusing this:\n  \\<lbrakk>as \\<in> valid_plans ?Pi; ?s \\<in> valid_states ?Pi\\<rbrakk>\n  \\<Longrightarrow> valid_path ?Pi (statelist' ?s as)\n  a # as \\<in> valid_plans Pi\n  s \\<in> valid_states Pi\n  ?h # ?as \\<in> valid_plans ?PROB \\<Longrightarrow> ?h \\<in> ?PROB\n  ?h # ?as \\<in> valid_plans ?PROB \\<Longrightarrow>\n  ?as \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. a \\<in> Pi &&& as \\<in> valid_plans Pi", "by metis+"], ["proof (state)\nthis:\n  a \\<in> Pi\n  as \\<in> valid_plans Pi\n\ngoal (2 subgoals):\n 1. \\<And>s Pi.\n       \\<lbrakk>[] \\<in> valid_plans Pi; s \\<in> valid_states Pi\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s [])\n 2. \\<And>a as s Pi.\n       \\<lbrakk>\\<And>s Pi.\n                   \\<lbrakk>as \\<in> valid_plans Pi;\n                    s \\<in> valid_states Pi\\<rbrakk>\n                   \\<Longrightarrow> valid_path Pi (statelist' s as);\n        a # as \\<in> valid_plans Pi; s \\<in> valid_states Pi\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "then"], ["proof (chain)\npicking this:\n  a \\<in> Pi\n  as \\<in> valid_plans Pi", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> Pi\n  as \\<in> valid_plans Pi\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s (a # as))", "proof (cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = []\\<rbrakk>\n    \\<Longrightarrow> valid_path Pi (statelist' s (a # as))\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = []\\<rbrakk>\n    \\<Longrightarrow> valid_path Pi (statelist' s (a # as))\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "{"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = []\\<rbrakk>\n    \\<Longrightarrow> valid_path Pi (statelist' s (a # as))\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "have \"state_succ s a \\<in> valid_states Pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_succ s a \\<in> valid_states Pi", "using 1 cons.prems(2) valid_action_valid_succ"], ["proof (prove)\nusing this:\n  a \\<in> Pi\n  as \\<in> valid_plans Pi\n  s \\<in> valid_states Pi\n  \\<lbrakk>?h \\<in> ?PROB; ?s \\<in> valid_states ?PROB\\<rbrakk>\n  \\<Longrightarrow> state_succ ?s ?h \\<in> valid_states ?PROB\n\ngoal (1 subgoal):\n 1. state_succ s a \\<in> valid_states Pi", "by blast"], ["proof (state)\nthis:\n  state_succ s a \\<in> valid_states Pi\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = []\\<rbrakk>\n    \\<Longrightarrow> valid_path Pi (statelist' s (a # as))\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "then"], ["proof (chain)\npicking this:\n  state_succ s a \\<in> valid_states Pi", "have \"valid_path Pi [state_succ s a]\""], ["proof (prove)\nusing this:\n  state_succ s a \\<in> valid_states Pi\n\ngoal (1 subgoal):\n 1. valid_path Pi [state_succ s a]", "using 1 cons.prems(2) cons.IH"], ["proof (prove)\nusing this:\n  state_succ s a \\<in> valid_states Pi\n  a \\<in> Pi\n  as \\<in> valid_plans Pi\n  s \\<in> valid_states Pi\n  \\<lbrakk>as \\<in> valid_plans ?Pi; ?s \\<in> valid_states ?Pi\\<rbrakk>\n  \\<Longrightarrow> valid_path ?Pi (statelist' ?s as)\n\ngoal (1 subgoal):\n 1. valid_path Pi [state_succ s a]", "by force"], ["proof (state)\nthis:\n  valid_path Pi [state_succ s a]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = []\\<rbrakk>\n    \\<Longrightarrow> valid_path Pi (statelist' s (a # as))\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "moreover"], ["proof (state)\nthis:\n  valid_path Pi [state_succ s a]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = []\\<rbrakk>\n    \\<Longrightarrow> valid_path Pi (statelist' s (a # as))\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "have \"(\\<exists>aa. aa \\<in> Pi \\<and> exec_plan s [aa] = state_succ s a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>aa. aa \\<in> Pi \\<and> exec_plan s [aa] = state_succ s a", "using 1(1)"], ["proof (prove)\nusing this:\n  a \\<in> Pi\n\ngoal (1 subgoal):\n 1. \\<exists>aa. aa \\<in> Pi \\<and> exec_plan s [aa] = state_succ s a", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>aa. aa \\<in> Pi \\<and> exec_plan s [aa] = state_succ s a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = []\\<rbrakk>\n    \\<Longrightarrow> valid_path Pi (statelist' s (a # as))\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "ultimately"], ["proof (chain)\npicking this:\n  valid_path Pi [state_succ s a]\n  \\<exists>aa. aa \\<in> Pi \\<and> exec_plan s [aa] = state_succ s a", "have \"valid_path Pi (statelist' s [a])\""], ["proof (prove)\nusing this:\n  valid_path Pi [state_succ s a]\n  \\<exists>aa. aa \\<in> Pi \\<and> exec_plan s [aa] = state_succ s a\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s [a])", "using cons.prems(2)"], ["proof (prove)\nusing this:\n  valid_path Pi [state_succ s a]\n  \\<exists>aa. aa \\<in> Pi \\<and> exec_plan s [aa] = state_succ s a\n  s \\<in> valid_states Pi\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s [a])", "by simp"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s [a])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = []\\<rbrakk>\n    \\<Longrightarrow> valid_path Pi (statelist' s (a # as))\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "}"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s [a])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = []\\<rbrakk>\n    \\<Longrightarrow> valid_path Pi (statelist' s (a # as))\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "then"], ["proof (chain)\npicking this:\n  valid_path Pi (statelist' s [a])", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path Pi (statelist' s [a])\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s (a # as))", "using Nil"], ["proof (prove)\nusing this:\n  valid_path Pi (statelist' s [a])\n  as = []\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s (a # as))", "by blast"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s (a # as))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "case (Cons b list)"], ["proof (state)\nthis:\n  as = b # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "{"], ["proof (state)\nthis:\n  as = b # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "have \"s \\<in> valid_states Pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> valid_states Pi", "using cons.prems(2)"], ["proof (prove)\nusing this:\n  s \\<in> valid_states Pi\n\ngoal (1 subgoal):\n 1. s \\<in> valid_states Pi", "by simp\n          \\<comment> \\<open>TODO this step is inefficient (~5s).\\<close>"], ["proof (state)\nthis:\n  s \\<in> valid_states Pi\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "then"], ["proof (chain)\npicking this:\n  s \\<in> valid_states Pi", "have \n        \"valid_path Pi (state_succ s a # statelist' (state_succ (state_succ s a) b) list)\""], ["proof (prove)\nusing this:\n  s \\<in> valid_states Pi\n\ngoal (1 subgoal):\n 1. valid_path Pi\n     (state_succ s a # statelist' (state_succ (state_succ s a) b) list)", "using 1 cons.IH cons.prems(2) Cons lemma_1_i"], ["proof (prove)\nusing this:\n  s \\<in> valid_states Pi\n  a \\<in> Pi\n  as \\<in> valid_plans Pi\n  \\<lbrakk>as \\<in> valid_plans ?Pi; ?s \\<in> valid_states ?Pi\\<rbrakk>\n  \\<Longrightarrow> valid_path ?Pi (statelist' ?s as)\n  s \\<in> valid_states Pi\n  as = b # list\n  \\<lbrakk>?s \\<in> valid_states ?PROB; ?a \\<in> ?PROB\\<rbrakk>\n  \\<Longrightarrow> state_succ ?s ?a \\<in> valid_states ?PROB\n\ngoal (1 subgoal):\n 1. valid_path Pi\n     (state_succ s a # statelist' (state_succ (state_succ s a) b) list)", "by fastforce"], ["proof (state)\nthis:\n  valid_path Pi\n   (state_succ s a # statelist' (state_succ (state_succ s a) b) list)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "moreover"], ["proof (state)\nthis:\n  valid_path Pi\n   (state_succ s a # statelist' (state_succ (state_succ s a) b) list)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "have \n        \"(\\<exists>aa b. (aa, b) \\<in> Pi \\<and> state_succ s (aa, b) = state_succ s a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>aa b.\n       (aa, b) \\<in> Pi \\<and> state_succ s (aa, b) = state_succ s a", "using 1(1) surjective_pairing"], ["proof (prove)\nusing this:\n  a \\<in> Pi\n  ?t = (fst ?t, snd ?t)\n\ngoal (1 subgoal):\n 1. \\<exists>aa b.\n       (aa, b) \\<in> Pi \\<and> state_succ s (aa, b) = state_succ s a", "by metis"], ["proof (state)\nthis:\n  \\<exists>aa b.\n     (aa, b) \\<in> Pi \\<and> state_succ s (aa, b) = state_succ s a\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "ultimately"], ["proof (chain)\npicking this:\n  valid_path Pi\n   (state_succ s a # statelist' (state_succ (state_succ s a) b) list)\n  \\<exists>aa b.\n     (aa, b) \\<in> Pi \\<and> state_succ s (aa, b) = state_succ s a", "have \"valid_path Pi (statelist' s (a # b # list))\""], ["proof (prove)\nusing this:\n  valid_path Pi\n   (state_succ s a # statelist' (state_succ (state_succ s a) b) list)\n  \\<exists>aa b.\n     (aa, b) \\<in> Pi \\<and> state_succ s (aa, b) = state_succ s a\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s (a # b # list))", "using cons.prems(2)"], ["proof (prove)\nusing this:\n  valid_path Pi\n   (state_succ s a # statelist' (state_succ (state_succ s a) b) list)\n  \\<exists>aa b.\n     (aa, b) \\<in> Pi \\<and> state_succ s (aa, b) = state_succ s a\n  s \\<in> valid_states Pi\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s (a # b # list))", "by auto"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s (a # b # list))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "}"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s (a # b # list))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>a \\<in> Pi; as \\<in> valid_plans Pi; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s (a # as))", "then"], ["proof (chain)\npicking this:\n  valid_path Pi (statelist' s (a # b # list))", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path Pi (statelist' s (a # b # list))\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s (a # as))", "using Cons"], ["proof (prove)\nusing this:\n  valid_path Pi (statelist' s (a # b # list))\n  as = b # list\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s (a # as))", "by blast"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s (a # as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s (a # as))\n\ngoal (1 subgoal):\n 1. \\<And>s Pi.\n       \\<lbrakk>[] \\<in> valid_plans Pi; s \\<in> valid_states Pi\\<rbrakk>\n       \\<Longrightarrow> valid_path Pi (statelist' s [])", "qed simp\n\n\n\\<comment> \\<open>TODO explicit proof.\\<close>"], ["", "lemma statelist'_exec_plan: \n  fixes a s p\n  assumes \"(statelist' s as = p)\"\n  shows \"(exec_plan s as = last p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_plan s as = last p", "using assms"], ["proof (prove)\nusing this:\n  statelist' s as = p\n\ngoal (1 subgoal):\n 1. exec_plan s as = last p", "apply(induction as arbitrary: s p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s p. statelist' s [] = p \\<Longrightarrow> exec_plan s [] = last p\n 2. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   exec_plan s as = last p;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> exec_plan s (a # as) = last p", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b as s.\n       \\<lbrakk>\\<And>s. exec_plan s as = last (statelist' s as);\n        statelist' (state_succ s (a, b)) as = []\\<rbrakk>\n       \\<Longrightarrow> last [] = s", "apply(cases \"as\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b asa s.\n       \\<lbrakk>\\<And>s. exec_plan s asa = last (statelist' s asa);\n        statelist' (state_succ s (a, b)) asa = []; as = []\\<rbrakk>\n       \\<Longrightarrow> last [] = s\n 2. \\<And>a b asa s aa list.\n       \\<lbrakk>\\<And>s. exec_plan s asa = last (statelist' s asa);\n        statelist' (state_succ s (a, b)) asa = []; as = aa # list\\<rbrakk>\n       \\<Longrightarrow> last [] = s", "by \n    (metis LENGTH_statelist' One_nat_def add_Suc_right list.size(3) nat.simps(3))\n    (metis (no_types) LENGTH_statelist' One_nat_def add_Suc_right list.size(3) nat.simps(3))"], ["", "lemma statelist'_EQ_NIL: \"statelist' s as \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. statelist' s as \\<noteq> []", "by (cases as) auto\n\n\n\\<comment> \\<open>NOTE added lemma.\\<close>"], ["", "lemma statelist'_TAKE_i:\n  assumes \"Suc m \\<le> length (a # as)\"\n  shows \"m \\<le> length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> length as", "using assms"], ["proof (prove)\nusing this:\n  Suc m \\<le> length (a # as)\n\ngoal (1 subgoal):\n 1. m \\<le> length as", "by (induction as arbitrary: a m) auto"], ["", "lemma statelist'_TAKE: \n  fixes as s p\n  assumes \"(statelist' s as = p)\"\n  shows \"(\\<forall>n. n \\<le> length as \\<longrightarrow> (exec_plan s (take n as)) = (p ! n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<le>length as. exec_plan s (take n as) = p ! n", "using assms"], ["proof (prove)\nusing this:\n  statelist' s as = p\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<le>length as. exec_plan s (take n as) = p ! n", "proof (induction as arbitrary: s p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s p.\n       statelist' s [] = p \\<Longrightarrow>\n       \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n\n 2. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "case Nil"], ["proof (state)\nthis:\n  statelist' s [] = p\n\ngoal (2 subgoals):\n 1. \\<And>s p.\n       statelist' s [] = p \\<Longrightarrow>\n       \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n\n 2. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "{"], ["proof (state)\nthis:\n  statelist' s [] = p\n\ngoal (2 subgoals):\n 1. \\<And>s p.\n       statelist' s [] = p \\<Longrightarrow>\n       \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n\n 2. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s p.\n       statelist' s [] = p \\<Longrightarrow>\n       \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n\n 2. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "assume P1: \"n \\<le> length []\""], ["proof (state)\nthis:\n  n \\<le> length []\n\ngoal (2 subgoals):\n 1. \\<And>s p.\n       statelist' s [] = p \\<Longrightarrow>\n       \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n\n 2. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "then"], ["proof (chain)\npicking this:\n  n \\<le> length []", "have \"exec_plan s (take n []) = s\""], ["proof (prove)\nusing this:\n  n \\<le> length []\n\ngoal (1 subgoal):\n 1. exec_plan s (take n []) = s", "by simp"], ["proof (state)\nthis:\n  exec_plan s (take n []) = s\n\ngoal (2 subgoals):\n 1. \\<And>s p.\n       statelist' s [] = p \\<Longrightarrow>\n       \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n\n 2. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "moreover"], ["proof (state)\nthis:\n  exec_plan s (take n []) = s\n\ngoal (2 subgoals):\n 1. \\<And>s p.\n       statelist' s [] = p \\<Longrightarrow>\n       \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n\n 2. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "have \"p ! 0 = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! 0 = s", "using Nil.prems"], ["proof (prove)\nusing this:\n  statelist' s [] = p\n\ngoal (1 subgoal):\n 1. p ! 0 = s", "by force"], ["proof (state)\nthis:\n  p ! 0 = s\n\ngoal (2 subgoals):\n 1. \\<And>s p.\n       statelist' s [] = p \\<Longrightarrow>\n       \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n\n 2. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "ultimately"], ["proof (chain)\npicking this:\n  exec_plan s (take n []) = s\n  p ! 0 = s", "have \"exec_plan s (take n []) = p ! n\""], ["proof (prove)\nusing this:\n  exec_plan s (take n []) = s\n  p ! 0 = s\n\ngoal (1 subgoal):\n 1. exec_plan s (take n []) = p ! n", "using P1"], ["proof (prove)\nusing this:\n  exec_plan s (take n []) = s\n  p ! 0 = s\n  n \\<le> length []\n\ngoal (1 subgoal):\n 1. exec_plan s (take n []) = p ! n", "by simp"], ["proof (state)\nthis:\n  exec_plan s (take n []) = p ! n\n\ngoal (2 subgoals):\n 1. \\<And>s p.\n       statelist' s [] = p \\<Longrightarrow>\n       \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n\n 2. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "}"], ["proof (state)\nthis:\n  ?n2 \\<le> length [] \\<Longrightarrow> exec_plan s (take ?n2 []) = p ! ?n2\n\ngoal (2 subgoals):\n 1. \\<And>s p.\n       statelist' s [] = p \\<Longrightarrow>\n       \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n\n 2. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "then"], ["proof (chain)\npicking this:\n  ?n2 \\<le> length [] \\<Longrightarrow> exec_plan s (take ?n2 []) = p ! ?n2", "show ?case"], ["proof (prove)\nusing this:\n  ?n2 \\<le> length [] \\<Longrightarrow> exec_plan s (take ?n2 []) = p ! ?n2\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n", "by blast"], ["proof (state)\nthis:\n  \\<forall>n\\<le>length []. exec_plan s (take n []) = p ! n\n\ngoal (1 subgoal):\n 1. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "case (Cons a as)"], ["proof (state)\nthis:\n  statelist' ?s as = ?p \\<Longrightarrow>\n  \\<forall>n\\<le>length as. exec_plan ?s (take n as) = ?p ! n\n  statelist' s (a # as) = p\n\ngoal (1 subgoal):\n 1. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "{"], ["proof (state)\nthis:\n  statelist' ?s as = ?p \\<Longrightarrow>\n  \\<forall>n\\<le>length as. exec_plan ?s (take n as) = ?p ! n\n  statelist' s (a # as) = p\n\ngoal (1 subgoal):\n 1. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "assume P2: \"n \\<le> length (a # as)\""], ["proof (state)\nthis:\n  n \\<le> length (a # as)\n\ngoal (1 subgoal):\n 1. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "then"], ["proof (chain)\npicking this:\n  n \\<le> length (a # as)", "have \"exec_plan s (take n (a # as)) = p ! n\""], ["proof (prove)\nusing this:\n  n \\<le> length (a # as)\n\ngoal (1 subgoal):\n 1. exec_plan s (take n (a # as)) = p ! n", "using Cons.prems"], ["proof (prove)\nusing this:\n  n \\<le> length (a # as)\n  statelist' s (a # as) = p\n\ngoal (1 subgoal):\n 1. exec_plan s (take n (a # as)) = p ! n", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n\n 2. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n\n 2. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "obtain m where a: \"n = Suc m\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using not0_implies_Suc"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  ?n \\<noteq> 0 \\<Longrightarrow> \\<exists>m. ?n = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by presburger"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n\n 2. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "moreover"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n\n 2. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "have b: \"statelist' s (a # as) ! n = statelist' (state_succ s a) as ! m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. statelist' s (a # as) ! n = statelist' (state_succ s a) as ! m", "using a nth_Cons_Suc"], ["proof (prove)\nusing this:\n  n = Suc m\n  (?x # ?xs) ! Suc ?n = ?xs ! ?n\n\ngoal (1 subgoal):\n 1. statelist' s (a # as) ! n = statelist' (state_succ s a) as ! m", "by simp"], ["proof (state)\nthis:\n  statelist' s (a # as) ! n = statelist' (state_succ s a) as ! m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n\n 2. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "moreover"], ["proof (state)\nthis:\n  statelist' s (a # as) ! n = statelist' (state_succ s a) as ! m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n\n 2. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "have c: \"exec_plan s (take n (a # as)) = exec_plan (state_succ s a) (take m as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_plan s (take n (a # as)) = exec_plan (state_succ s a) (take m as)", "using a"], ["proof (prove)\nusing this:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. exec_plan s (take n (a # as)) = exec_plan (state_succ s a) (take m as)", "by force"], ["proof (state)\nthis:\n  exec_plan s (take n (a # as)) = exec_plan (state_succ s a) (take m as)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n\n 2. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "moreover"], ["proof (state)\nthis:\n  exec_plan s (take n (a # as)) = exec_plan (state_succ s a) (take m as)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n\n 2. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "have \"m \\<le> length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> length as", "using a P2 statelist'_TAKE_i"], ["proof (prove)\nusing this:\n  n = Suc m\n  n \\<le> length (a # as)\n  Suc ?m \\<le> length (?a # ?as) \\<Longrightarrow> ?m \\<le> length ?as\n\ngoal (1 subgoal):\n 1. m \\<le> length as", "by simp"], ["proof (state)\nthis:\n  m \\<le> length as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n\n 2. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "moreover"], ["proof (state)\nthis:\n  m \\<le> length as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n\n 2. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "have \n        \"exec_plan (state_succ s a) (take m as) = statelist' (state_succ s a) as ! m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_plan (state_succ s a) (take m as) =\n    statelist' (state_succ s a) as ! m", "using calculation(2, 3, 4) Cons.IH"], ["proof (prove)\nusing this:\n  statelist' s (a # as) ! n = statelist' (state_succ s a) as ! m\n  exec_plan s (take n (a # as)) = exec_plan (state_succ s a) (take m as)\n  m \\<le> length as\n  statelist' ?s as = ?p \\<Longrightarrow>\n  \\<forall>n\\<le>length as. exec_plan ?s (take n as) = ?p ! n\n\ngoal (1 subgoal):\n 1. exec_plan (state_succ s a) (take m as) =\n    statelist' (state_succ s a) as ! m", "by blast"], ["proof (state)\nthis:\n  exec_plan (state_succ s a) (take m as) =\n  statelist' (state_succ s a) as ! m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n\n 2. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "ultimately"], ["proof (chain)\npicking this:\n  n = Suc m\n  statelist' s (a # as) ! n = statelist' (state_succ s a) as ! m\n  exec_plan s (take n (a # as)) = exec_plan (state_succ s a) (take m as)\n  m \\<le> length as\n  exec_plan (state_succ s a) (take m as) =\n  statelist' (state_succ s a) as ! m", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Suc m\n  statelist' s (a # as) ! n = statelist' (state_succ s a) as ! m\n  exec_plan s (take n (a # as)) = exec_plan (state_succ s a) (take m as)\n  m \\<le> length as\n  exec_plan (state_succ s a) (take m as) =\n  statelist' (state_succ s a) as ! m\n\ngoal (1 subgoal):\n 1. exec_plan s (take n (a # as)) = p ! n", "using Cons.prems"], ["proof (prove)\nusing this:\n  n = Suc m\n  statelist' s (a # as) ! n = statelist' (state_succ s a) as ! m\n  exec_plan s (take n (a # as)) = exec_plan (state_succ s a) (take m as)\n  m \\<le> length as\n  exec_plan (state_succ s a) (take m as) =\n  statelist' (state_succ s a) as ! m\n  statelist' s (a # as) = p\n\ngoal (1 subgoal):\n 1. exec_plan s (take n (a # as)) = p ! n", "by argo"], ["proof (state)\nthis:\n  exec_plan s (take n (a # as)) = p ! n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length (a # as); statelist' s (a # as) = p;\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> exec_plan s (take n (a # as)) = p ! n", "qed fastforce"], ["proof (state)\nthis:\n  exec_plan s (take n (a # as)) = p ! n\n\ngoal (1 subgoal):\n 1. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "}"], ["proof (state)\nthis:\n  ?n2 \\<le> length (a # as) \\<Longrightarrow>\n  exec_plan s (take ?n2 (a # as)) = p ! ?n2\n\ngoal (1 subgoal):\n 1. \\<And>a as s p.\n       \\<lbrakk>\\<And>s p.\n                   statelist' s as = p \\<Longrightarrow>\n                   \\<forall>n\\<le>length as.\n                      exec_plan s (take n as) = p ! n;\n        statelist' s (a # as) = p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<le>length (a # as).\n                            exec_plan s (take n (a # as)) = p ! n", "then"], ["proof (chain)\npicking this:\n  ?n2 \\<le> length (a # as) \\<Longrightarrow>\n  exec_plan s (take ?n2 (a # as)) = p ! ?n2", "show ?case"], ["proof (prove)\nusing this:\n  ?n2 \\<le> length (a # as) \\<Longrightarrow>\n  exec_plan s (take ?n2 (a # as)) = p ! ?n2\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<le>length (a # as). exec_plan s (take n (a # as)) = p ! n", "by blast"], ["proof (state)\nthis:\n  \\<forall>n\\<le>length (a # as). exec_plan s (take n (a # as)) = p ! n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma MPLS_nempty: \n  fixes PROB :: \"(('a, 'b) fmap \\<times> ('a, 'b) fmap) set\" \n  assumes \"finite PROB\"\n  shows \"MPLS PROB \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "let ?S=\"{(s, as). s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\"\n    \\<comment> \\<open>NOTE type of 's' had to be fixed for 'valid\\_states\\_nempty'.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "obtain s :: \"('a, 'b) fmap\"  where \"s \\<in> valid_states PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> valid_states PROB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms valid_states_nempty"], ["proof (prove)\nusing this:\n  finite PROB\n  finite ?PROB \\<Longrightarrow> \\<exists>s. s \\<in> valid_states ?PROB\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> valid_states PROB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  s \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "have \"[] \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> valid_plans PROB", "using empty_plan_is_valid"], ["proof (prove)\nusing this:\n  [] \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. [] \\<in> valid_plans PROB", "by auto"], ["proof (state)\nthis:\n  [] \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> valid_states PROB\n  [] \\<in> valid_plans PROB", "have \"(s, []) \\<in> ?S\""], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  [] \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. (s, [])\n    \\<in> {(s, as).\n           s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "by blast"], ["proof (state)\nthis:\n  (s, [])\n  \\<in> {(s, as).\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  (s, [])\n  \\<in> {(s, as).\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "show ?thesis"], ["proof (prove)\nusing this:\n  (s, [])\n  \\<in> {(s, as).\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "unfolding MPLS_def"], ["proof (prove)\nusing this:\n  (s, [])\n  \\<in> {(s, as).\n         s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. (\\<lambda>(s, as). Inf (PLS s as)) `\n    {(s, as).\n     s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB} \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  MPLS PROB \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem bound_main_lemma: \n  fixes PROB :: \"'a problem\" \n  assumes \"finite PROB\"\n  shows \"(problem_plan_bound PROB \\<le> (2 ^ (card (prob_dom PROB))) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"MPLS PROB \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "using assms MPLS_nempty"], ["proof (prove)\nusing this:\n  finite PROB\n  finite ?PROB \\<Longrightarrow> MPLS ?PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  MPLS PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "moreover"], ["proof (state)\nthis:\n  MPLS PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"(\\<forall>x. x \\<in> MPLS PROB \\<longrightarrow> x \\<le> 2 ^ card (prob_dom PROB) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> MPLS PROB \\<longrightarrow>\n       x \\<le> 2 ^ card (prob_dom PROB) - 1", "using assms in_MPLS_leq_2_pow_n"], ["proof (prove)\nusing this:\n  finite PROB\n  \\<lbrakk>finite ?PROB; ?x \\<in> MPLS ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> MPLS PROB \\<longrightarrow>\n       x \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in> MPLS PROB \\<longrightarrow>\n     x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "ultimately"], ["proof (chain)\npicking this:\n  MPLS PROB \\<noteq> {}\n  \\<forall>x.\n     x \\<in> MPLS PROB \\<longrightarrow>\n     x \\<le> 2 ^ card (prob_dom PROB) - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  MPLS PROB \\<noteq> {}\n  \\<forall>x.\n     x \\<in> MPLS PROB \\<longrightarrow>\n     x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "unfolding problem_plan_bound_def"], ["proof (prove)\nusing this:\n  MPLS PROB \\<noteq> {}\n  \\<forall>x.\n     x \\<in> MPLS PROB \\<longrightarrow>\n     x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<le> 2 ^ card (prob_dom PROB) - 1", "using cSup_least"], ["proof (prove)\nusing this:\n  MPLS PROB \\<noteq> {}\n  \\<forall>x.\n     x \\<in> MPLS PROB \\<longrightarrow>\n     x \\<le> 2 ^ card (prob_dom PROB) - 1\n  \\<lbrakk>?X \\<noteq> {};\n   \\<And>x. x \\<in> ?X \\<Longrightarrow> x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> Sup ?X \\<le> ?z\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE types in premise had to be fixed to be able to match `valid\\_as\\_valid\\_exec`.\\<close>"], ["", "lemma bound_child_parent_card_state_set_cons: \n  fixes P f\n  assumes \"(\\<forall>(PROB :: 'a problem) as (s :: 'a state). \n    (P PROB) \n    \\<and> (as \\<in> valid_plans PROB) \n    \\<and> (s \\<in> valid_states PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as) \n      \\<and> (length as' < f PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB s as. \n    (P PROB)\n    \\<and> (as \\<in> valid_plans PROB)\n    \\<and> (s \\<in> (valid_states PROB))\n    \\<longrightarrow> (\\<exists>x. \n      (x \\<in> PLS s as) \n      \\<and> (x < f PROB)\n    )\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "fix PROB :: \"'a problem\" and as and s :: \"'a state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "assume P1: \"(P PROB)\" \n      \"(as \\<in> valid_plans PROB)\"\n      \"(s \\<in> valid_states PROB)\" \n      \"(\\<exists>as'. \n        (exec_plan s as = exec_plan s as') \n        \\<and> (subseq as' as) \n        \\<and> (length as' < f PROB)\n      )\""], ["proof (state)\nthis:\n  P PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "have \"(exec_plan s as \\<in> valid_states PROB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_plan s as \\<in> valid_states PROB", "using assms P1 valid_as_valid_exec"], ["proof (prove)\nusing this:\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n  P PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n  \\<lbrakk>?as \\<in> valid_plans ?PROB; ?s \\<in> valid_states ?PROB\\<rbrakk>\n  \\<Longrightarrow> exec_plan ?s ?as \\<in> valid_states ?PROB\n\ngoal (1 subgoal):\n 1. exec_plan s as \\<in> valid_states PROB", "by blast"], ["proof (state)\nthis:\n  exec_plan s as \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "then"], ["proof (chain)\npicking this:\n  exec_plan s as \\<in> valid_states PROB", "have \"(P PROB)\n      \\<and> (as \\<in> valid_plans PROB)\n      \\<and> (s \\<in> (valid_states PROB))\n      \\<longrightarrow> (\\<exists>x. \n        (x \\<in> PLS s as) \n        \\<and> (x < f PROB)\n      )\n    \""], ["proof (prove)\nusing this:\n  exec_plan s as \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. P PROB \\<and>\n    as \\<in> valid_plans PROB \\<and>\n    s \\<in> valid_states PROB \\<longrightarrow>\n    (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "unfolding PLS_def"], ["proof (prove)\nusing this:\n  exec_plan s as \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. P PROB \\<and>\n    as \\<in> valid_plans PROB \\<and>\n    s \\<in> valid_states PROB \\<longrightarrow>\n    (\\<exists>x.\n        x \\<in> length `\n                {as'.\n                 exec_plan s as' = exec_plan s as \\<and>\n                 subseq as' as} \\<and>\n        x < f PROB)", "using P1"], ["proof (prove)\nusing this:\n  exec_plan s as \\<in> valid_states PROB\n  P PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. P PROB \\<and>\n    as \\<in> valid_plans PROB \\<and>\n    s \\<in> valid_states PROB \\<longrightarrow>\n    (\\<exists>x.\n        x \\<in> length `\n                {as'.\n                 exec_plan s as' = exec_plan s as \\<and>\n                 subseq as' as} \\<and>\n        x < f PROB)", "by force"], ["proof (state)\nthis:\n  P PROB \\<and>\n  as \\<in> valid_plans PROB \\<and>\n  s \\<in> valid_states PROB \\<longrightarrow>\n  (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> P ?PROB2 \\<and>\n                    ?as2 \\<in> valid_plans ?PROB2 \\<and>\n                    ?s2 \\<in> valid_states ?PROB2 \\<longrightarrow>\n                    (\\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>P ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> P ?PROB2 \\<and>\n                    ?as2 \\<in> valid_plans ?PROB2 \\<and>\n                    ?s2 \\<in> valid_states ?PROB2 \\<longrightarrow>\n                    (\\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2)", "show \"(\\<forall>PROB s as. \n    (P PROB)\n    \\<and> (as \\<in> valid_plans PROB)\n    \\<and> (s \\<in> (valid_states PROB))\n    \\<longrightarrow> (\\<exists>x. \n      (x \\<in> PLS s as) \n      \\<and> (x < f PROB)\n    )\n  )\""], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> P ?PROB2 \\<and>\n                    ?as2 \\<in> valid_plans ?PROB2 \\<and>\n                    ?s2 \\<in> valid_states ?PROB2 \\<longrightarrow>\n                    (\\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> P ?PROB2 \\<and>\n                    ?as2 \\<in> valid_plans ?PROB2 \\<and>\n                    ?s2 \\<in> valid_states ?PROB2 \\<longrightarrow>\n                    (\\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2)\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "by simp"], ["proof (state)\nthis:\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE types of premise had to be fixed to be able to use lemma `bound\\_child\\_parent\\_card\\_state\\_set\\_cons`.\\<close>"], ["", "lemma bound_on_all_plans_bounds_MPLS: \n  fixes P f\n  assumes \"(\\<forall>(PROB :: 'a problem) as (s :: 'a state).\n    (P PROB) \n    \\<and> (s \\<in> valid_states PROB) \n    \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as) \n      \\<and> (length as' < f PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB x. P PROB\n    \\<longrightarrow> (x \\<in> MPLS(PROB)) \n    \\<longrightarrow> (x < f PROB)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "fix PROB :: \"'a problem\" and as and s :: \"'a state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "assume \"(P PROB)\"\n      \"(s \\<in> valid_states PROB)\"\n      \"(as \\<in> valid_plans PROB)\"\n      \"(\\<exists>as'. \n        (exec_plan s as = exec_plan s as') \n        \\<and> (subseq as' as) \n        \\<and> (length as' < f PROB)\n      )\""], ["proof (state)\nthis:\n  P PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "then"], ["proof (chain)\npicking this:\n  P PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB", "have \"(\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)\""], ["proof (prove)\nusing this:\n  P PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x < f PROB", "using assms(1) bound_child_parent_card_state_set_cons[where P = P and f = f]"], ["proof (prove)\nusing this:\n  P PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB) \\<Longrightarrow>\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x < f PROB", "by presburger"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> PLS s as \\<and> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P ?PROB2; ?s2 \\<in> valid_states ?PROB2;\n   ?as2 \\<in> valid_plans ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "note 1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>P ?PROB2; ?s2 \\<in> valid_states ?PROB2;\n   ?as2 \\<in> valid_plans ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "{"], ["proof (state)\nthis:\n  \\<lbrakk>P ?PROB2; ?s2 \\<in> valid_states ?PROB2;\n   ?as2 \\<in> valid_plans ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "fix PROB x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "assume P1: \"P PROB\" \"x \\<in> MPLS PROB\"\n      \\<comment> \\<open>TODO refactor 'x\\_in\\_MPLS\\_if' and use here.\\<close>"], ["proof (state)\nthis:\n  P PROB\n  x \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "then"], ["proof (chain)\npicking this:\n  P PROB\n  x \\<in> MPLS PROB", "obtain s as where a:\n      \"x = Inf (PLS s as)\" \"s \\<in> valid_states PROB\" \"as \\<in> valid_plans PROB\""], ["proof (prove)\nusing this:\n  P PROB\n  x \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. (\\<And>s as.\n        \\<lbrakk>x = Inf (PLS s as); s \\<in> valid_states PROB;\n         as \\<in> valid_plans PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding MPLS_def"], ["proof (prove)\nusing this:\n  P PROB\n  x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as).\n           s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. (\\<And>s as.\n        \\<lbrakk>x = Inf (PLS s as); s \\<in> valid_states PROB;\n         as \\<in> valid_plans PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = Inf (PLS s as)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "moreover"], ["proof (state)\nthis:\n  x = Inf (PLS s as)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "have \"(\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as) \n      \\<and> (length as' < f PROB)\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' < f PROB", "using P1(1) assms calculation(2, 3)"], ["proof (prove)\nusing this:\n  P PROB\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "ultimately"], ["proof (chain)\npicking this:\n  x = Inf (PLS s as)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB", "obtain x' where \"x' \\<in> PLS s as\" \"x' < f PROB\""], ["proof (prove)\nusing this:\n  x = Inf (PLS s as)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> PLS s as; x' < f PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P1 1"], ["proof (prove)\nusing this:\n  x = Inf (PLS s as)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n  P PROB\n  x \\<in> MPLS PROB\n  \\<lbrakk>P ?PROB2; ?s2 \\<in> valid_states ?PROB2;\n   ?as2 \\<in> valid_plans ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> PLS s as; x' < f PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x' \\<in> PLS s as\n  x' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "then"], ["proof (chain)\npicking this:\n  x' \\<in> PLS s as\n  x' < f PROB", "have \"x < f PROB\""], ["proof (prove)\nusing this:\n  x' \\<in> PLS s as\n  x' < f PROB\n\ngoal (1 subgoal):\n 1. x < f PROB", "using a(1) mem_lt_imp_MIN_lt"], ["proof (prove)\nusing this:\n  x' \\<in> PLS s as\n  x' < f PROB\n  x = Inf (PLS s as)\n  \\<exists>x. x \\<in> ?s \\<and> x < ?k \\<Longrightarrow> Inf ?s < ?k\n\ngoal (1 subgoal):\n 1. x < f PROB", "by fastforce"], ["proof (state)\nthis:\n  x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P ?PROB2; ?x2 \\<in> MPLS ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>P ?PROB2; ?x2 \\<in> MPLS ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 < f ?PROB2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?PROB2; ?x2 \\<in> MPLS ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<forall>PROB x.\n     P PROB \\<longrightarrow> x \\<in> MPLS PROB \\<longrightarrow> x < f PROB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_child_parent_card_state_set_cons_finite: \n  fixes P f\n  assumes \"(\\<forall>PROB as s.\n    P PROB \\<and> finite PROB \\<and> as \\<in> (valid_plans PROB) \\<and> s \\<in> (valid_states PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> subseq as' as \n      \\<and> length as' < f(PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB s as. \n    P PROB \\<and> finite PROB \\<and> as \\<in> (valid_plans PROB) \\<and> (s \\<in> (valid_states PROB))\n    \\<longrightarrow> (\\<exists>x. (x \\<in> PLS s as) \\<and> x < f PROB)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "fix PROB s as"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "assume \"P PROB\" \"finite PROB\" \"as \\<in> (valid_plans PROB)\" \"s \\<in> (valid_states PROB)\"\n      \" (\\<exists>as'. \n        (exec_plan s as = exec_plan s as') \n        \\<and> subseq as' as \n        \\<and> length as' < f PROB\n      )\""], ["proof (state)\nthis:\n  P PROB\n  finite PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "(* NOTE[1]\n        moreover have \"exec_plan s as \\<in> valid_states PROB\" \n          using calculation valid_as_valid_exec by blast\n    *)"], ["proof (state)\nthis:\n  P PROB\n  finite PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "then"], ["proof (chain)\npicking this:\n  P PROB\n  finite PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB", "obtain as' where \n      \"(exec_plan s as = exec_plan s as')\" \"subseq as' as\" \"length as' < f PROB\""], ["proof (prove)\nusing this:\n  P PROB\n  finite PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' < f PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "moreover"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "have \"length as' \\<in> PLS s as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as' \\<in> PLS s as", "unfolding PLS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length as'\n    \\<in> length `\n          {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}", "using calculation"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' < f PROB\n\ngoal (1 subgoal):\n 1. length as'\n    \\<in> length `\n          {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}", "by fastforce"], ["proof (state)\nthis:\n  length as' \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "ultimately"], ["proof (chain)\npicking this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' < f PROB\n  length as' \\<in> PLS s as", "have \"(\\<exists>x. (x \\<in> PLS s as) \\<and> x < f PROB)\""], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' < f PROB\n  length as' \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> PLS s as \\<and> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2", "show \"(\\<forall>PROB s as. \n    P PROB  \n    \\<and> finite PROB\n    \\<and> as \\<in> (valid_plans PROB)\n    \\<and> (s \\<in> (valid_states PROB))\n    \\<longrightarrow> (\\<exists>x. (x \\<in> PLS s as) \\<and> x < f PROB)\n  )\""], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> PLS ?s2 ?as2 \\<and> x < f ?PROB2\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)", "by auto"], ["proof (state)\nthis:\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_on_all_plans_bounds_MPLS_finite: \n  fixes P f\n  assumes \"(\\<forall>PROB as s. \n    P PROB \\<and> finite PROB \\<and> s \\<in> (valid_states PROB) \\<and> as \\<in> (valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> subseq as' as \n      \\<and> length as' < f(PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB x. \n    P PROB \\<and> finite PROB \n    \\<longrightarrow> (x \\<in> MPLS PROB)\n    \\<longrightarrow> x < f PROB\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "fix PROB x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "assume P1: \"P PROB\" \"finite PROB\" \"x \\<in> MPLS PROB\"\n      \\<comment> \\<open>TODO refactor 'x\\_in\\_MPLS\\_if' and use here.\\<close>"], ["proof (state)\nthis:\n  P PROB\n  finite PROB\n  x \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "then"], ["proof (chain)\npicking this:\n  P PROB\n  finite PROB\n  x \\<in> MPLS PROB", "obtain s as where a:\n      \"x = Inf (PLS s as)\" \"s \\<in> valid_states PROB\" \"as \\<in> valid_plans PROB\""], ["proof (prove)\nusing this:\n  P PROB\n  finite PROB\n  x \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. (\\<And>s as.\n        \\<lbrakk>x = Inf (PLS s as); s \\<in> valid_states PROB;\n         as \\<in> valid_plans PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding MPLS_def"], ["proof (prove)\nusing this:\n  P PROB\n  finite PROB\n  x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as).\n           s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. (\\<And>s as.\n        \\<lbrakk>x = Inf (PLS s as); s \\<in> valid_states PROB;\n         as \\<in> valid_plans PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = Inf (PLS s as)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "moreover"], ["proof (state)\nthis:\n  x = Inf (PLS s as)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "have \"(\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as) \n      \\<and> (length as' < f PROB)\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' < f PROB", "using P1(1, 2) assms calculation(2, 3)"], ["proof (prove)\nusing this:\n  P PROB\n  finite PROB\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     finite PROB \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "moreover"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "obtain x' where \"x' \\<in> PLS s as\" \"x' < f PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> PLS s as; x' < f PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using PLS_def calculation(4)"], ["proof (prove)\nusing this:\n  PLS ?s ?as \\<equiv>\n  length ` {as'. exec_plan ?s as' = exec_plan ?s ?as \\<and> subseq as' ?as}\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> PLS s as; x' < f PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x' \\<in> PLS s as\n  x' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "then"], ["proof (chain)\npicking this:\n  x' \\<in> PLS s as\n  x' < f PROB", "have \"x < f PROB\""], ["proof (prove)\nusing this:\n  x' \\<in> PLS s as\n  x' < f PROB\n\ngoal (1 subgoal):\n 1. x < f PROB", "using a(1) mem_lt_imp_MIN_lt"], ["proof (prove)\nusing this:\n  x' \\<in> PLS s as\n  x' < f PROB\n  x = Inf (PLS s as)\n  \\<exists>x. x \\<in> ?s \\<and> x < ?k \\<Longrightarrow> Inf ?s < ?k\n\ngoal (1 subgoal):\n 1. x < f PROB", "by fastforce"], ["proof (state)\nthis:\n  x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?x2 \\<in> MPLS ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?x2 \\<in> MPLS ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 < f ?PROB2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?x2 \\<in> MPLS ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?x2 \\<in> MPLS ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 < f ?PROB2\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     finite PROB \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS PROB \\<longrightarrow> x < f PROB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_on_all_plans_bounds_problem_plan_bound: \n  fixes P f\n  assumes \"(\\<forall>PROB as s. \n    (P PROB) \n    \\<and> finite PROB\n    \\<and> (s \\<in> valid_states PROB) \n    \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as')\n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB. \n    (P PROB) \n    \\<and> finite PROB\n    \\<longrightarrow> (problem_plan_bound PROB < f PROB)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "have 1: \"\\<forall>PROB x. \n    P PROB \n    \\<and> finite PROB \n    \\<longrightarrow> x \\<in> MPLS PROB   \n    \\<longrightarrow> x < f PROB\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "using assms bound_on_all_plans_bounds_MPLS_finite"], ["proof (prove)\nusing this:\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     finite PROB \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n  \\<forall>PROB as s.\n     ?P PROB \\<and>\n     finite PROB \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < ?f PROB) \\<Longrightarrow>\n  \\<forall>PROB x.\n     ?P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS PROB \\<longrightarrow> x < ?f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "{"], ["proof (state)\nthis:\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "fix PROB x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "assume \"P PROB \\<and> finite PROB \n      \\<longrightarrow> x \\<in> MPLS PROB   \n      \\<longrightarrow> x < f PROB\n    \""], ["proof (state)\nthis:\n  P PROB \\<and> finite PROB \\<longrightarrow>\n  x \\<in> MPLS PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "then"], ["proof (chain)\npicking this:\n  P PROB \\<and> finite PROB \\<longrightarrow>\n  x \\<in> MPLS PROB \\<longrightarrow> x < f PROB", "have \"\\<forall>PROB.\n      P PROB \\<and> finite PROB \n      \\<longrightarrow> problem_plan_bound PROB < f PROB\n    \""], ["proof (prove)\nusing this:\n  P PROB \\<and> finite PROB \\<longrightarrow>\n  x \\<in> MPLS PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "unfolding problem_plan_bound_def"], ["proof (prove)\nusing this:\n  P PROB \\<and> finite PROB \\<longrightarrow>\n  x \\<in> MPLS PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow> Sup (MPLS PROB) < f PROB", "using 1 bound_child_parent_not_eq_last_diff_paths 1 MPLS_nempty"], ["proof (prove)\nusing this:\n  P PROB \\<and> finite PROB \\<longrightarrow>\n  x \\<in> MPLS PROB \\<longrightarrow> x < f PROB\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS PROB \\<longrightarrow> x < f PROB\n  \\<lbrakk>?s \\<noteq> {};\n   \\<forall>x. x \\<in> ?s \\<longrightarrow> x < ?k\\<rbrakk>\n  \\<Longrightarrow> Sup ?s < ?k\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS PROB \\<longrightarrow> x < f PROB\n  finite ?PROB \\<Longrightarrow> MPLS ?PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow> Sup (MPLS PROB) < f PROB", "by metis"], ["proof (state)\nthis:\n  \\<forall>PROB.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound PROB < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "then"], ["proof (chain)\npicking this:\n  \\<forall>PROB.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound PROB < f PROB", "have \"\\<forall>PROB.\n      P PROB \\<and> finite PROB \n      \\<longrightarrow> problem_plan_bound PROB < f PROB\n    \""], ["proof (prove)\nusing this:\n  \\<forall>PROB.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound PROB < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "using MPLS_nempty"], ["proof (prove)\nusing this:\n  \\<forall>PROB.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound PROB < f PROB\n  finite ?PROB \\<Longrightarrow> MPLS ?PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<forall>PROB.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound PROB < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "}"], ["proof (state)\nthis:\n  P ?PROB2 \\<and> finite ?PROB2 \\<longrightarrow>\n  ?x2 \\<in> MPLS ?PROB2 \\<longrightarrow> ?x2 < f ?PROB2 \\<Longrightarrow>\n  \\<forall>PROB.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound PROB < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "then"], ["proof (chain)\npicking this:\n  P ?PROB2 \\<and> finite ?PROB2 \\<longrightarrow>\n  ?x2 \\<in> MPLS ?PROB2 \\<longrightarrow> ?x2 < f ?PROB2 \\<Longrightarrow>\n  \\<forall>PROB.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound PROB < f PROB", "show \"(\\<forall>PROB. \n    (P PROB) \n    \\<and> finite PROB\n    \\<longrightarrow> (problem_plan_bound PROB < f PROB)\n  )\""], ["proof (prove)\nusing this:\n  P ?PROB2 \\<and> finite ?PROB2 \\<longrightarrow>\n  ?x2 \\<in> MPLS ?PROB2 \\<longrightarrow> ?x2 < f ?PROB2 \\<Longrightarrow>\n  \\<forall>PROB.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound PROB < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "using 1"], ["proof (prove)\nusing this:\n  P ?PROB2 \\<and> finite ?PROB2 \\<longrightarrow>\n  ?x2 \\<in> MPLS ?PROB2 \\<longrightarrow> ?x2 < f ?PROB2 \\<Longrightarrow>\n  \\<forall>PROB.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound PROB < f PROB\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound PROB < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<forall>PROB.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound PROB < f PROB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_child_parent_card_state_set_cons_thesis: \n  assumes \"finite PROB\" \"(\\<forall>as s. \n    as \\<in> (valid_plans PROB) \n    \\<and> s \\<in> (valid_states PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as')\n      \\<and> subseq as' as \n      \\<and> length as' < k\n    ) \n  )\" \"as \\<in> (valid_plans PROB)\" \"(s \\<in> (valid_states PROB))\" \n  shows \"(\\<exists>x. (x \\<in> PLS s as) \\<and> x < k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x < k", "unfolding PLS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> length `\n               {as'.\n                exec_plan s as' = exec_plan s as \\<and>\n                subseq as' as} \\<and>\n       x < k", "using assms"], ["proof (prove)\nusing this:\n  finite PROB\n  \\<forall>as s.\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < k)\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> length `\n               {as'.\n                exec_plan s as' = exec_plan s as \\<and>\n                subseq as' as} \\<and>\n       x < k", "by fastforce\n\n\n\\<comment> \\<open>NOTE added lemma.\\<close>\n\\<comment> \\<open>TODO refactor/move up.\\<close>"], ["", "lemma x_in_MPLS_if: \n  fixes x PROB \n  assumes \"x \\<in> MPLS PROB\"  \n  shows \"\\<exists>s as. s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB \\<and> x = Inf (PLS s as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s as.\n       s \\<in> valid_states PROB \\<and>\n       as \\<in> valid_plans PROB \\<and> x = Inf (PLS s as)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. \\<exists>s as.\n       s \\<in> valid_states PROB \\<and>\n       as \\<in> valid_plans PROB \\<and> x = Inf (PLS s as)", "unfolding MPLS_def"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as).\n           s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. \\<exists>s as.\n       s \\<in> valid_states PROB \\<and>\n       as \\<in> valid_plans PROB \\<and> x = Inf (PLS s as)", "by fast"], ["", "lemma bound_on_all_plans_bounds_MPLS_thesis: \n  assumes \"finite PROB\" \"(\\<forall>as s. \n    (s \\<in> valid_states PROB) \n    \\<and> (as \\<in> valid_plans PROB)\n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' < k)\n    )\n  )\" \"(x \\<in> MPLS PROB)\" \n  shows \"(x < k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < k", "obtain s as where 1: \"s \\<in> valid_states PROB\" \"as \\<in> valid_plans PROB\" \"x = Inf (PLS s as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s as.\n        \\<lbrakk>s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n         x = Inf (PLS s as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3) x_in_MPLS_if"], ["proof (prove)\nusing this:\n  x \\<in> MPLS PROB\n  ?x \\<in> MPLS ?PROB \\<Longrightarrow>\n  \\<exists>s as.\n     s \\<in> valid_states ?PROB \\<and>\n     as \\<in> valid_plans ?PROB \\<and> ?x = Inf (PLS s as)\n\ngoal (1 subgoal):\n 1. (\\<And>s as.\n        \\<lbrakk>s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n         x = Inf (PLS s as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  x = Inf (PLS s as)\n\ngoal (1 subgoal):\n 1. x < k", "then"], ["proof (chain)\npicking this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  x = Inf (PLS s as)", "obtain x' :: nat where \"x' \\<in> PLS s as\" \"x' < k\""], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  x = Inf (PLS s as)\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> PLS s as; x' < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1, 2) bound_child_parent_card_state_set_cons_thesis"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  x = Inf (PLS s as)\n  finite PROB\n  \\<forall>as s.\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < k)\n  \\<lbrakk>finite ?PROB;\n   \\<forall>as s.\n      as \\<in> valid_plans ?PROB \\<and>\n      s \\<in> valid_states ?PROB \\<longrightarrow>\n      (\\<exists>as'.\n          exec_plan s as = exec_plan s as' \\<and>\n          subseq as' as \\<and> length as' < ?k);\n   ?as \\<in> valid_plans ?PROB; ?s \\<in> valid_states ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> PLS ?s ?as \\<and> x < ?k\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> PLS s as; x' < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x' \\<in> PLS s as\n  x' < k\n\ngoal (1 subgoal):\n 1. x < k", "then"], ["proof (chain)\npicking this:\n  x' \\<in> PLS s as\n  x' < k", "have \"Inf (PLS s as) < k\""], ["proof (prove)\nusing this:\n  x' \\<in> PLS s as\n  x' < k\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) < k", "using mem_lt_imp_MIN_lt"], ["proof (prove)\nusing this:\n  x' \\<in> PLS s as\n  x' < k\n  \\<exists>x. x \\<in> ?s \\<and> x < ?k \\<Longrightarrow> Inf ?s < ?k\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) < k", "by blast"], ["proof (state)\nthis:\n  Inf (PLS s as) < k\n\ngoal (1 subgoal):\n 1. x < k", "then"], ["proof (chain)\npicking this:\n  Inf (PLS s as) < k", "show \"x < k\""], ["proof (prove)\nusing this:\n  Inf (PLS s as) < k\n\ngoal (1 subgoal):\n 1. x < k", "using 1"], ["proof (prove)\nusing this:\n  Inf (PLS s as) < k\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  x = Inf (PLS s as)\n\ngoal (1 subgoal):\n 1. x < k", "by simp"], ["proof (state)\nthis:\n  x < k\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE added lemma.\\<close>"], ["", "lemma bounded_MPLS_contains_supremum: \n  fixes PROB\n  assumes \"finite PROB\" \"(\\<exists>k. \\<forall>x \\<in> MPLS PROB. x < k)\" \n  shows \"Sup (MPLS PROB) \\<in> MPLS PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "obtain k where \"\\<forall>x \\<in> MPLS PROB. x < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<forall>x\\<in>MPLS PROB. x < k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<exists>k. \\<forall>x\\<in>MPLS PROB. x < k\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<forall>x\\<in>MPLS PROB. x < k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>MPLS PROB. x < k\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>MPLS PROB. x < k\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "have \"finite (MPLS PROB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (MPLS PROB)", "using assms(2) finite_nat_set_iff_bounded"], ["proof (prove)\nusing this:\n  \\<exists>k. \\<forall>x\\<in>MPLS PROB. x < k\n  finite ?N = (\\<exists>m. \\<forall>n\\<in>?N. n < m)\n\ngoal (1 subgoal):\n 1. finite (MPLS PROB)", "by presburger"], ["proof (state)\nthis:\n  finite (MPLS PROB)\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "moreover"], ["proof (state)\nthis:\n  finite (MPLS PROB)\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "have \"MPLS PROB \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "using assms(1) MPLS_nempty"], ["proof (prove)\nusing this:\n  finite PROB\n  finite ?PROB \\<Longrightarrow> MPLS ?PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. MPLS PROB \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  MPLS PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>MPLS PROB. x < k\n  finite (MPLS PROB)\n  MPLS PROB \\<noteq> {}", "show \"Sup (MPLS PROB) \\<in> MPLS PROB\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS PROB. x < k\n  finite (MPLS PROB)\n  MPLS PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "unfolding Sup_nat_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS PROB. x < k\n  finite (MPLS PROB)\n  MPLS PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (if MPLS PROB = {} then 0 else Max (MPLS PROB)) \\<in> MPLS PROB", "by simp"], ["proof (state)\nthis:\n  Sup (MPLS PROB) \\<in> MPLS PROB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_on_all_plans_bounds_problem_plan_bound_thesis': \n  assumes \"finite PROB\" \"(\\<forall>as s. \n      s \\<in> (valid_states PROB) \n      \\<and> as \\<in> (valid_plans PROB)\n      \\<longrightarrow> (\\<exists>as'. \n        (exec_plan s as = exec_plan s as') \n        \\<and> subseq as' as \n        \\<and> length as' < k\n      )\n    )\"\n  shows \"problem_plan_bound PROB < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < k", "have 1: \"\\<forall>x \\<in> MPLS PROB. x < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS PROB. x < k", "using assms(1, 2) bound_on_all_plans_bounds_MPLS_thesis"], ["proof (prove)\nusing this:\n  finite PROB\n  \\<forall>as s.\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < k)\n  \\<lbrakk>finite ?PROB;\n   \\<forall>as s.\n      s \\<in> valid_states ?PROB \\<and>\n      as \\<in> valid_plans ?PROB \\<longrightarrow>\n      (\\<exists>as'.\n          exec_plan s as = exec_plan s as' \\<and>\n          subseq as' as \\<and> length as' < ?k);\n   ?x \\<in> MPLS ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?x < ?k\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS PROB. x < k", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>MPLS PROB. x < k\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < k", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>MPLS PROB. x < k", "have \"Sup (MPLS PROB) \\<in> MPLS PROB\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS PROB. x < k\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "using assms(1) bounded_MPLS_contains_supremum"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS PROB. x < k\n  finite PROB\n  \\<lbrakk>finite ?PROB;\n   \\<exists>k. \\<forall>x\\<in>MPLS ?PROB. x < k\\<rbrakk>\n  \\<Longrightarrow> Sup (MPLS ?PROB) \\<in> MPLS ?PROB\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "by auto"], ["proof (state)\nthis:\n  Sup (MPLS PROB) \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < k", "then"], ["proof (chain)\npicking this:\n  Sup (MPLS PROB) \\<in> MPLS PROB", "have \"Sup (MPLS PROB) < k\""], ["proof (prove)\nusing this:\n  Sup (MPLS PROB) \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) < k", "using 1"], ["proof (prove)\nusing this:\n  Sup (MPLS PROB) \\<in> MPLS PROB\n  \\<forall>x\\<in>MPLS PROB. x < k\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) < k", "by blast"], ["proof (state)\nthis:\n  Sup (MPLS PROB) < k\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < k", "then"], ["proof (chain)\npicking this:\n  Sup (MPLS PROB) < k", "show ?thesis"], ["proof (prove)\nusing this:\n  Sup (MPLS PROB) < k\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < k", "unfolding problem_plan_bound_def"], ["proof (prove)\nusing this:\n  Sup (MPLS PROB) < k\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) < k", "by simp"], ["proof (state)\nthis:\n  problem_plan_bound PROB < k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_on_all_plans_bounds_problem_plan_bound_thesis: \n  assumes \"finite PROB\" \"(\\<forall>as s. \n      (s \\<in> valid_states PROB) \n      \\<and> (as \\<in> valid_plans PROB) \n      \\<longrightarrow> (\\<exists>as'. \n        (exec_plan s as = exec_plan s as') \n        \\<and> (subseq as' as)\n        \\<and> (length as' \\<le> k)\n      )\n    )\"\n  shows \"(problem_plan_bound PROB \\<le> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> k", "have 1: \"\\<forall>x\\<in>MPLS PROB. x < k + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS PROB. x < k + 1", "using assms(1, 2) bound_on_all_plans_bounds_MPLS_thesis[where k = \"k + 1\"] Suc_eq_plus1 \n      less_Suc_eq_le"], ["proof (prove)\nusing this:\n  finite PROB\n  \\<forall>as s.\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' \\<le> k)\n  \\<lbrakk>finite ?PROB;\n   \\<forall>as s.\n      s \\<in> valid_states ?PROB \\<and>\n      as \\<in> valid_plans ?PROB \\<longrightarrow>\n      (\\<exists>as'.\n          exec_plan s as = exec_plan s as' \\<and>\n          subseq as' as \\<and> length as' < k + 1);\n   ?x \\<in> MPLS ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?x < k + 1\n  Suc ?n = ?n + 1\n  (?m < Suc ?n) = (?m \\<le> ?n)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS PROB. x < k + 1", "by metis"], ["proof (state)\nthis:\n  \\<forall>x\\<in>MPLS PROB. x < k + 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> k", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>MPLS PROB. x < k + 1", "have \"Sup (MPLS PROB) \\<in> MPLS PROB\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS PROB. x < k + 1\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "using assms(1) bounded_MPLS_contains_supremum"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS PROB. x < k + 1\n  finite PROB\n  \\<lbrakk>finite ?PROB;\n   \\<exists>k. \\<forall>x\\<in>MPLS ?PROB. x < k\\<rbrakk>\n  \\<Longrightarrow> Sup (MPLS ?PROB) \\<in> MPLS ?PROB\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<in> MPLS PROB", "by fast"], ["proof (state)\nthis:\n  Sup (MPLS PROB) \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> k", "then"], ["proof (chain)\npicking this:\n  Sup (MPLS PROB) \\<in> MPLS PROB", "show \"(problem_plan_bound PROB \\<le> k)\""], ["proof (prove)\nusing this:\n  Sup (MPLS PROB) \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> k", "unfolding problem_plan_bound_def"], ["proof (prove)\nusing this:\n  Sup (MPLS PROB) \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<le> k", "using 1"], ["proof (prove)\nusing this:\n  Sup (MPLS PROB) \\<in> MPLS PROB\n  \\<forall>x\\<in>MPLS PROB. x < k + 1\n\ngoal (1 subgoal):\n 1. Sup (MPLS PROB) \\<le> k", "by fastforce"], ["proof (state)\nthis:\n  problem_plan_bound PROB \\<le> k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  bound_on_all_plans_bounds_problem_plan_bound_: \n  fixes P f PROB\n  assumes \"(\\<forall>PROB' as s. \n      finite PROB \\<and> (P PROB') \\<and> (s \\<in> valid_states PROB') \\<and> (as \\<in> valid_plans PROB') \n      \\<longrightarrow> (\\<exists>as'. \n        (exec_plan s as = exec_plan s as') \n        \\<and> (subseq as' as)\n        \\<and> (length as' < f PROB')\n      )\n    )\" \"(P PROB)\" \"finite PROB\" \n  shows \"(problem_plan_bound PROB < f PROB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < f PROB", "unfolding problem_plan_bound_def MPLS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP (s,\n        as)\\<in>{(s, as).\n                 s \\<in> valid_states PROB \\<and>\n                 as \\<in> valid_plans PROB}.\n        Inf (PLS s as))\n    < f PROB", "using assms bound_on_all_plans_bounds_problem_plan_bound_thesis' expanded_problem_plan_bound_thm_1"], ["proof (prove)\nusing this:\n  \\<forall>PROB' as s.\n     finite PROB \\<and>\n     P PROB' \\<and>\n     s \\<in> valid_states PROB' \\<and>\n     as \\<in> valid_plans PROB' \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB')\n  P PROB\n  finite PROB\n  \\<lbrakk>finite ?PROB;\n   \\<forall>as s.\n      s \\<in> valid_states ?PROB \\<and>\n      as \\<in> valid_plans ?PROB \\<longrightarrow>\n      (\\<exists>as'.\n          exec_plan s as = exec_plan s as' \\<and>\n          subseq as' as \\<and> length as' < ?k)\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound ?PROB < ?k\n  problem_plan_bound ?PROB =\n  (SUP (s,\n      as)\\<in>{(s, as).\n               s \\<in> valid_states ?PROB \\<and>\n               as \\<in> valid_plans ?PROB}.\n      Inf (PLS s as))\n\ngoal (1 subgoal):\n 1. (SUP (s,\n        as)\\<in>{(s, as).\n                 s \\<in> valid_states PROB \\<and>\n                 as \\<in> valid_plans PROB}.\n        Inf (PLS s as))\n    < f PROB", "by metis"], ["", "lemma S_VALID_AS_VALID_IMP_MIN_IN_PLS: \n  fixes PROB s as\n  assumes \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\" \n  shows \"(Inf (PLS s as) \\<in> (MPLS PROB))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<in> MPLS PROB", "unfolding MPLS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf (PLS s as)\n    \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as).\n           s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. Inf (PLS s as)\n    \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as).\n           s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB}", "by fast\n\n\n\\<comment> \\<open>NOTE type of `s` had to be fixed (type mismatch in goal).\\<close>\n\\<comment> \\<open>NOTE premises rewritten to implications for proof set up.\\<close>"], ["", "lemma problem_plan_bound_ge_min_pls: \n  fixes PROB :: \"'a problem\" and s :: \"'a state\" and as k\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\" \n    \"(problem_plan_bound PROB \\<le> k)\"\n  shows \"(Inf (PLS s as) \\<le> problem_plan_bound PROB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound PROB", "have \"Inf (PLS s as) \\<in> MPLS PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<in> MPLS PROB", "using assms(2, 3) S_VALID_AS_VALID_IMP_MIN_IN_PLS"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> Inf (PLS ?s ?as) \\<in> MPLS ?PROB\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<in> MPLS PROB", "by blast"], ["proof (state)\nthis:\n  Inf (PLS s as) \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound PROB", "moreover"], ["proof (state)\nthis:\n  Inf (PLS s as) \\<in> MPLS PROB\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound PROB", "have \"finite (MPLS PROB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (MPLS PROB)", "using assms(1) FINITE_MPLS"], ["proof (prove)\nusing this:\n  finite PROB\n  finite ?Pi \\<Longrightarrow> finite (MPLS ?Pi)\n\ngoal (1 subgoal):\n 1. finite (MPLS PROB)", "by blast"], ["proof (state)\nthis:\n  finite (MPLS PROB)\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound PROB", "ultimately"], ["proof (chain)\npicking this:\n  Inf (PLS s as) \\<in> MPLS PROB\n  finite (MPLS PROB)", "have \"Inf (PLS s as) \\<le> Sup (MPLS PROB)\""], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<in> MPLS PROB\n  finite (MPLS PROB)\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> Sup (MPLS PROB)", "using le_cSup_finite"], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<in> MPLS PROB\n  finite (MPLS PROB)\n  \\<lbrakk>finite ?X; ?x \\<in> ?X\\<rbrakk> \\<Longrightarrow> ?x \\<le> Sup ?X\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> Sup (MPLS PROB)", "by blast"], ["proof (state)\nthis:\n  Inf (PLS s as) \\<le> Sup (MPLS PROB)\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound PROB", "then"], ["proof (chain)\npicking this:\n  Inf (PLS s as) \\<le> Sup (MPLS PROB)", "show ?thesis"], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<le> Sup (MPLS PROB)\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound PROB", "unfolding problem_plan_bound_def"], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<le> Sup (MPLS PROB)\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> Sup (MPLS PROB)", "by simp"], ["proof (state)\nthis:\n  Inf (PLS s as) \\<le> problem_plan_bound PROB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  PLS_NEMPTY: \n  fixes s as \n  shows \"PLS s as \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PLS s as \\<noteq> {}", "unfolding PLS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length `\n    {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as} \\<noteq>\n    {}", "by blast"], ["", "lemma  PLS_nempty_and_has_min: \n  fixes s as \n  shows \"(\\<exists>x. (x \\<in> PLS s as) \\<and> (x = Inf (PLS s as)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)", "have \"PLS s as \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PLS s as \\<noteq> {}", "using PLS_NEMPTY"], ["proof (prove)\nusing this:\n  PLS ?s ?as \\<noteq> {}\n\ngoal (1 subgoal):\n 1. PLS s as \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  PLS s as \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)", "then"], ["proof (chain)\npicking this:\n  PLS s as \\<noteq> {}", "have \"Inf (PLS s as) \\<in> PLS s as\""], ["proof (prove)\nusing this:\n  PLS s as \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<in> PLS s as", "unfolding Inf_nat_def"], ["proof (prove)\nusing this:\n  PLS s as \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (LEAST n. n \\<in> PLS s as) \\<in> PLS s as", "using LeastI_ex Max_in finite_PLS"], ["proof (prove)\nusing this:\n  PLS s as \\<noteq> {}\n  \\<exists>x. ?P x \\<Longrightarrow> ?P (Least ?P)\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Max ?A \\<in> ?A\n  finite (PLS ?s ?as)\n\ngoal (1 subgoal):\n 1. (LEAST n. n \\<in> PLS s as) \\<in> PLS s as", "by metis"], ["proof (state)\nthis:\n  Inf (PLS s as) \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)", "then"], ["proof (chain)\npicking this:\n  Inf (PLS s as) \\<in> PLS s as", "show ?thesis"], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  PLS_works: \n  fixes x s as\n  assumes \"(x \\<in> PLS s as)\" \n  shows\"(\\<exists>as'. \n      (exec_plan s as = exec_plan s as')\n      \\<and> (length as' = x) \n      \\<and> (subseq as' as)\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       length as' = x \\<and> subseq as' as", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       length as' = x \\<and> subseq as' as", "unfolding PLS_def"], ["proof (prove)\nusing this:\n  x \\<in> length `\n          {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       length as' = x \\<and> subseq as' as", "by (smt imageE mem_Collect_eq)\n\n\n\\<comment> \\<open>NOTE type of `s` had to be fixed (type mismatch in goal).\\<close>"], ["", "lemma problem_plan_bound_works: \n  fixes PROB :: \"'a problem\" and as and s :: \"'a state\"\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\" \n  shows \"(\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' \\<le> problem_plan_bound PROB)\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "have \"problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "using assms(1) bound_main_lemma"], ["proof (prove)\nusing this:\n  finite PROB\n  finite ?PROB \\<Longrightarrow>\n  problem_plan_bound ?PROB \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "then"], ["proof (chain)\npicking this:\n  problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "have 1: \"Inf (PLS s as) \\<le> problem_plan_bound PROB\""], ["proof (prove)\nusing this:\n  problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound PROB", "using \n      assms(1, 2, 3)\n      problem_plan_bound_ge_min_pls"], ["proof (prove)\nusing this:\n  problem_plan_bound PROB \\<le> 2 ^ card (prob_dom PROB) - 1\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB; problem_plan_bound ?PROB \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> Inf (PLS ?s ?as) \\<le> problem_plan_bound ?PROB\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound PROB", "by blast"], ["proof (state)\nthis:\n  Inf (PLS s as) \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "then"], ["proof (chain)\npicking this:\n  Inf (PLS s as) \\<le> problem_plan_bound PROB", "have \"\\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)\""], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)", "using PLS_nempty_and_has_min"], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<le> problem_plan_bound PROB\n  \\<exists>x. x \\<in> PLS ?s ?as \\<and> x = Inf (PLS ?s ?as)\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)", "have \"Inf (PLS s as) \\<in> (PLS s as)\""], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> PLS s as \\<and> x = Inf (PLS s as)\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<in> PLS s as", "by blast"], ["proof (state)\nthis:\n  Inf (PLS s as) \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "then"], ["proof (chain)\npicking this:\n  Inf (PLS s as) \\<in> PLS s as", "obtain as' where 2:\n    \"exec_plan s as = exec_plan s as'\" \"length as' = Inf (PLS s as)\" \"subseq as' as\""], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as';\n         length as' = Inf (PLS s as); subseq as' as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using PLS_works"], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<in> PLS s as\n  ?x \\<in> PLS ?s ?as \\<Longrightarrow>\n  \\<exists>as'.\n     exec_plan ?s ?as = exec_plan ?s as' \\<and>\n     length as' = ?x \\<and> subseq as' ?as\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as';\n         length as' = Inf (PLS s as); subseq as' as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  length as' = Inf (PLS s as)\n  subseq as' as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "then"], ["proof (chain)\npicking this:\n  exec_plan s as = exec_plan s as'\n  length as' = Inf (PLS s as)\n  subseq as' as", "have \"length as' \\<le> problem_plan_bound PROB\""], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  length as' = Inf (PLS s as)\n  subseq as' as\n\ngoal (1 subgoal):\n 1. length as' \\<le> problem_plan_bound PROB", "using 1"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  length as' = Inf (PLS s as)\n  subseq as' as\n  Inf (PLS s as) \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. length as' \\<le> problem_plan_bound PROB", "by argo"], ["proof (state)\nthis:\n  length as' \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "then"], ["proof (chain)\npicking this:\n  length as' \\<le> problem_plan_bound PROB", "show \"(\\<exists>as'. \n    (exec_plan s as = exec_plan s as') \n    \\<and> (subseq as' as)\n    \\<and> (length as' \\<le> problem_plan_bound PROB)\n  )\""], ["proof (prove)\nusing this:\n  length as' \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "using 2(1) 2(3)"], ["proof (prove)\nusing this:\n  length as' \\<le> problem_plan_bound PROB\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE name shortened.\\<close>"], ["", "definition MPLS_s where\n  \"MPLS_s PROB s \\<equiv> (\\<lambda> (s, as). Inf (PLS s as)) ` {(s, as) | as. as \\<in> valid_plans PROB}\"\n\n\n\\<comment> \\<open>NOTE type of `PROB` had to be fixed (type mismatch in goal).\\<close>"], ["", "lemma bound_main_lemma_s_3: \n  fixes PROB :: \"(('a, 'b) fmap \\<times> ('a, 'b) fmap) set\" and s\n  shows \"MPLS_s PROB s \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPLS_s PROB s \\<noteq> {}", "proof -\n  \\<comment> \\<open>TODO @{term \"(s, []) \\<in> {}\"} could be refactored (this is used in 'MPLS\\_nempty' too).\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. MPLS_s PROB s \\<noteq> {}", "have \"[] \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> valid_plans PROB", "using empty_plan_is_valid"], ["proof (prove)\nusing this:\n  [] \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. [] \\<in> valid_plans PROB", "by blast"], ["proof (state)\nthis:\n  [] \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. MPLS_s PROB s \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  [] \\<in> valid_plans PROB", "have \"(s, []) \\<in> {(s, as). as \\<in> valid_plans PROB}\""], ["proof (prove)\nusing this:\n  [] \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. (s, []) \\<in> {(s, as). as \\<in> valid_plans PROB}", "by simp"], ["proof (state)\nthis:\n  (s, []) \\<in> {(s, as). as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. MPLS_s PROB s \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  (s, []) \\<in> {(s, as). as \\<in> valid_plans PROB}", "show \"MPLS_s PROB s \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (s, []) \\<in> {(s, as). as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. MPLS_s PROB s \\<noteq> {}", "unfolding MPLS_s_def"], ["proof (prove)\nusing this:\n  (s, []) \\<in> {(s, as). as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. (\\<lambda>(s, as). Inf (PLS s as)) `\n    {(s, as) |as. as \\<in> valid_plans PROB} \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  MPLS_s PROB s \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE name shortened.\\<close>"], ["", "definition problem_plan_bound_s where\n  \"problem_plan_bound_s PROB s = Sup (MPLS_s PROB s)\"\n\n\n\\<comment> \\<open>NOTE removed typing from assumption due to matching problems in later proofs.\\<close>"], ["", "lemma  bound_on_all_plans_bounds_PLS_s: \n  fixes P f \n  assumes \"(\\<forall>PROB as s.  \n    finite PROB \\<and> (P PROB) \\<and> (as \\<in> valid_plans PROB) \\<and> (s \\<in> valid_states PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as')\n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB s)\n    )\n  )\"\n  shows \"(\\<forall>PROB s as. \n    finite PROB \\<and> (P PROB) \\<and> (as \\<in> valid_plans PROB) \\<and> (s \\<in> valid_states PROB)\n    \\<longrightarrow> (\\<exists>x. \n      (x \\<in> PLS s as) \n      \\<and> (x < f PROB s)\n    )\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB s)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB s)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB s)", "unfolding PLS_def"], ["proof (prove)\nusing this:\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB s)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x.\n           x \\<in> length `\n                   {as'.\n                    exec_plan s as' = exec_plan s as \\<and>\n                    subseq as' as} \\<and>\n           x < f PROB s)", "by fastforce\n\n\n\\<comment> \\<open>NOTE added lemma.\\<close>"], ["", "lemma bound_on_all_plans_bounds_MPLS_s_i:\n  fixes PROB s x\n  assumes \"s \\<in> valid_states PROB\" \"x \\<in> MPLS_s PROB s\" \n  shows \"\\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "let ?S=\"{(s, as) | as. as \\<in> valid_plans PROB}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "obtain x' where 1: \n    \"x' \\<in> ?S\"\n    \"x = (\\<lambda> (s, as). Inf (PLS s as)) x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> {(s, as) |as. as \\<in> valid_plans PROB};\n         x = (case x' of (s, as) \\<Rightarrow> Inf (PLS s as))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  x \\<in> MPLS_s PROB s\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> {(s, as) |as. as \\<in> valid_plans PROB};\n         x = (case x' of (s, as) \\<Rightarrow> Inf (PLS s as))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding MPLS_s_def"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as) |as. as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> {(s, as) |as. as \\<in> valid_plans PROB};\n         x = (case x' of (s, as) \\<Rightarrow> Inf (PLS s as))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x' \\<in> {(s, as) |as. as \\<in> valid_plans PROB}\n  x = (case x' of (s, as) \\<Rightarrow> Inf (PLS s as))\n\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "let ?as=\"snd x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "let ?s=\"fst x'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "have \"?as \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd x' \\<in> valid_plans PROB", "using 1(1)"], ["proof (prove)\nusing this:\n  x' \\<in> {(s, as) |as. as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. snd x' \\<in> valid_plans PROB", "by auto"], ["proof (state)\nthis:\n  snd x' \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "moreover"], ["proof (state)\nthis:\n  snd x' \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "have \"?s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x' = s", "using 1(1)"], ["proof (prove)\nusing this:\n  x' \\<in> {(s, as) |as. as \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. fst x' = s", "by fastforce"], ["proof (state)\nthis:\n  fst x' = s\n\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "moreover"], ["proof (state)\nthis:\n  fst x' = s\n\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "have \"x = Inf (PLS ?s ?as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = Inf (PLS (fst x') (snd x'))", "using 1(2)"], ["proof (prove)\nusing this:\n  x = (case x' of (s, as) \\<Rightarrow> Inf (PLS s as))\n\ngoal (1 subgoal):\n 1. x = Inf (PLS (fst x') (snd x'))", "by (simp add: case_prod_unfold)"], ["proof (state)\nthis:\n  x = Inf (PLS (fst x') (snd x'))\n\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "ultimately"], ["proof (chain)\npicking this:\n  snd x' \\<in> valid_plans PROB\n  fst x' = s\n  x = Inf (PLS (fst x') (snd x'))", "show ?thesis"], ["proof (prove)\nusing this:\n  snd x' \\<in> valid_plans PROB\n  fst x' = s\n  x = Inf (PLS (fst x') (snd x'))\n\ngoal (1 subgoal):\n 1. \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. x = Inf (PLS s as) \\<and> as \\<in> valid_plans PROB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_on_all_plans_bounds_MPLS_s: \n  fixes P f\n  assumes \"(\\<forall>PROB as s.\n    finite PROB \\<and> (P PROB) \\<and> (as \\<in> valid_plans PROB)  \\<and> (s \\<in> valid_states PROB)\n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB s)\n    )\n  )\"\n  shows \"(\\<forall>PROB x s. \n    finite PROB \\<and> (P PROB) \\<and> (s \\<in> valid_states PROB) \\<longrightarrow> (x \\<in> MPLS_s PROB s) \n     \\<longrightarrow> (x < f PROB s)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB s)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "unfolding MPLS_def"], ["proof (prove)\nusing this:\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB s)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "have 1: \"\\<forall>PROB s as.\n     finite PROB \\<and> P PROB \\<and> as \\<in> valid_plans PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB s)", "using bound_on_all_plans_bounds_PLS_s[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>PROB s as.\n     finite PROB \\<and>\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB s)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB s)", "."], ["proof (state)\nthis:\n  \\<forall>PROB s as.\n     finite PROB \\<and>\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB s)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "{"], ["proof (state)\nthis:\n  \\<forall>PROB s as.\n     finite PROB \\<and>\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB s)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "fix PROB x and s :: \"('a, 'b) fmap\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "assume P1: \"finite PROB\" \"(P PROB)\" \"(s \\<in> valid_states PROB)\""], ["proof (state)\nthis:\n  finite PROB\n  P PROB\n  s \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "{"], ["proof (state)\nthis:\n  finite PROB\n  P PROB\n  s \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "assume \"(x \\<in> MPLS_s PROB s)\""], ["proof (state)\nthis:\n  x \\<in> MPLS_s PROB s\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "then"], ["proof (chain)\npicking this:\n  x \\<in> MPLS_s PROB s", "obtain as where i: \"x = Inf (PLS s as)\" \"as \\<in> valid_plans PROB\""], ["proof (prove)\nusing this:\n  x \\<in> MPLS_s PROB s\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>x = Inf (PLS s as); as \\<in> valid_plans PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P1 bound_on_all_plans_bounds_MPLS_s_i"], ["proof (prove)\nusing this:\n  x \\<in> MPLS_s PROB s\n  finite PROB\n  P PROB\n  s \\<in> valid_states PROB\n  \\<lbrakk>?s \\<in> valid_states ?PROB; ?x \\<in> MPLS_s ?PROB ?s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as.\n                       ?x = Inf (PLS ?s as) \\<and>\n                       as \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>x = Inf (PLS s as); as \\<in> valid_plans PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = Inf (PLS s as)\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "then"], ["proof (chain)\npicking this:\n  x = Inf (PLS s as)\n  as \\<in> valid_plans PROB", "obtain x' where \"x' \\<in> PLS s as\" \"x' < f PROB s\""], ["proof (prove)\nusing this:\n  x = Inf (PLS s as)\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> PLS s as; x' < f PROB s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P1 i 1"], ["proof (prove)\nusing this:\n  x = Inf (PLS s as)\n  as \\<in> valid_plans PROB\n  finite PROB\n  P PROB\n  s \\<in> valid_states PROB\n  x = Inf (PLS s as)\n  as \\<in> valid_plans PROB\n  \\<forall>PROB s as.\n     finite PROB \\<and>\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>x. x \\<in> PLS s as \\<and> x < f PROB s)\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> PLS s as; x' < f PROB s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x' \\<in> PLS s as\n  x' < f PROB s\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "then"], ["proof (chain)\npicking this:\n  x' \\<in> PLS s as\n  x' < f PROB s", "have \"x < f PROB s\""], ["proof (prove)\nusing this:\n  x' \\<in> PLS s as\n  x' < f PROB s\n\ngoal (1 subgoal):\n 1. x < f PROB s", "using mem_lt_imp_MIN_lt i(1)"], ["proof (prove)\nusing this:\n  x' \\<in> PLS s as\n  x' < f PROB s\n  \\<exists>x. x \\<in> ?s \\<and> x < ?k \\<Longrightarrow> Inf ?s < ?k\n  x = Inf (PLS s as)\n\ngoal (1 subgoal):\n 1. x < f PROB s", "by blast"], ["proof (state)\nthis:\n  x < f PROB s\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "}"], ["proof (state)\nthis:\n  x \\<in> MPLS_s PROB s \\<Longrightarrow> x < f PROB s\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "then"], ["proof (chain)\npicking this:\n  x \\<in> MPLS_s PROB s \\<Longrightarrow> x < f PROB s", "have \"(x \\<in> MPLS_s PROB s) \\<longrightarrow> (x < f PROB s)\""], ["proof (prove)\nusing this:\n  x \\<in> MPLS_s PROB s \\<Longrightarrow> x < f PROB s\n\ngoal (1 subgoal):\n 1. x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "by blast"], ["proof (state)\nthis:\n  x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?PROB2; P ?PROB2; ?s2 \\<in> valid_states ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> MPLS_s ?PROB2 ?s2 \\<longrightarrow>\n                    ?x2 < f ?PROB2 ?s2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       P PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n    \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?PROB2; P ?PROB2; ?s2 \\<in> valid_states ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> MPLS_s ?PROB2 ?s2 \\<longrightarrow>\n                    ?x2 < f ?PROB2 ?s2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?PROB2; P ?PROB2; ?s2 \\<in> valid_states ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> MPLS_s ?PROB2 ?s2 \\<longrightarrow>\n                    ?x2 < f ?PROB2 ?s2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "by blast"], ["proof (state)\nthis:\n  \\<forall>PROB x s.\n     finite PROB \\<and>\n     P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n     x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE added lemma.\\<close>"], ["", "lemma Sup_MPLS_s_lt_if: \n  fixes PROB s k\n  assumes \"(\\<forall>x\\<in>MPLS_s PROB s. x < k)\"\n  shows \"Sup (MPLS_s PROB s) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (MPLS_s PROB s) < k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sup (MPLS_s PROB s) < k", "have \"MPLS_s PROB s \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPLS_s PROB s \\<noteq> {}", "using bound_main_lemma_s_3"], ["proof (prove)\nusing this:\n  MPLS_s ?PROB ?s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. MPLS_s PROB s \\<noteq> {}", "by fast"], ["proof (state)\nthis:\n  MPLS_s PROB s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Sup (MPLS_s PROB s) < k", "then"], ["proof (chain)\npicking this:\n  MPLS_s PROB s \\<noteq> {}", "have \"Sup (MPLS_s PROB s) \\<in> MPLS_s PROB s\""], ["proof (prove)\nusing this:\n  MPLS_s PROB s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Sup (MPLS_s PROB s) \\<in> MPLS_s PROB s", "using assms Sup_nat_def bounded_nat_set_is_finite"], ["proof (prove)\nusing this:\n  MPLS_s PROB s \\<noteq> {}\n  \\<forall>x\\<in>MPLS_s PROB s. x < k\n  Sup ?X = (if ?X = {} then 0 else Max ?X)\n  \\<forall>i\\<in>?N. i < ?n \\<Longrightarrow> finite ?N\n\ngoal (1 subgoal):\n 1. Sup (MPLS_s PROB s) \\<in> MPLS_s PROB s", "by force"], ["proof (state)\nthis:\n  Sup (MPLS_s PROB s) \\<in> MPLS_s PROB s\n\ngoal (1 subgoal):\n 1. Sup (MPLS_s PROB s) < k", "then"], ["proof (chain)\npicking this:\n  Sup (MPLS_s PROB s) \\<in> MPLS_s PROB s", "show \"Sup (MPLS_s PROB s) < k\""], ["proof (prove)\nusing this:\n  Sup (MPLS_s PROB s) \\<in> MPLS_s PROB s\n\ngoal (1 subgoal):\n 1. Sup (MPLS_s PROB s) < k", "using assms"], ["proof (prove)\nusing this:\n  Sup (MPLS_s PROB s) \\<in> MPLS_s PROB s\n  \\<forall>x\\<in>MPLS_s PROB s. x < k\n\ngoal (1 subgoal):\n 1. Sup (MPLS_s PROB s) < k", "by blast"], ["proof (state)\nthis:\n  Sup (MPLS_s PROB s) < k\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>NOTE type of `P` had to be fixed (type mismatch in goal).\\<close>"], ["", "lemma bound_child_parent_lemma_s_2: \n  fixes PROB :: \"'a problem\" and P :: \"'a problem \\<Rightarrow> bool\" and s f\n  assumes \"(\\<forall>(PROB :: 'a problem) as s. \n    finite PROB \\<and> (P PROB) \\<and> (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB s)\n    )\n  )\"\n  shows \"(\n    finite PROB \\<and> (P PROB) \\<and> (s \\<in> valid_states PROB)\n    \\<longrightarrow> problem_plan_bound_s PROB s < f PROB s\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite PROB \\<and>\n    P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n    problem_plan_bound_s PROB s < f PROB s", "proof -\n  \\<comment> \\<open>NOTE manual instantiation is required (automation fails otherwise).\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. finite PROB \\<and>\n    P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n    problem_plan_bound_s PROB s < f PROB s", "have \"\\<forall>(PROB :: 'a problem) x s. \n    finite PROB \\<and> P PROB \\<and> s \\<in> valid_states PROB \n    \\<longrightarrow> x \\<in> MPLS_s PROB s \n    \\<longrightarrow> x < f PROB s\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "using assms bound_on_all_plans_bounds_MPLS_s[of P f]"], ["proof (prove)\nusing this:\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     P PROB \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB s)\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     P PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB s) \\<Longrightarrow>\n  \\<forall>PROB x s.\n     finite PROB \\<and>\n     P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n     x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x s.\n       finite PROB \\<and>\n       P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n       x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "by simp"], ["proof (state)\nthis:\n  \\<forall>PROB x s.\n     finite PROB \\<and>\n     P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n     x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s\n\ngoal (1 subgoal):\n 1. finite PROB \\<and>\n    P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n    problem_plan_bound_s PROB s < f PROB s", "then"], ["proof (chain)\npicking this:\n  \\<forall>PROB x s.\n     finite PROB \\<and>\n     P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n     x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s", "show\n    \"finite PROB \\<and> (P PROB) \\<and> (s \\<in> valid_states PROB) \\<longrightarrow> (problem_plan_bound_s PROB s < f PROB s)\""], ["proof (prove)\nusing this:\n  \\<forall>PROB x s.\n     finite PROB \\<and>\n     P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n     x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s\n\ngoal (1 subgoal):\n 1. finite PROB \\<and>\n    P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n    problem_plan_bound_s PROB s < f PROB s", "unfolding problem_plan_bound_s_def"], ["proof (prove)\nusing this:\n  \\<forall>PROB x s.\n     finite PROB \\<and>\n     P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n     x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s\n\ngoal (1 subgoal):\n 1. finite PROB \\<and>\n    P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n    Sup (MPLS_s PROB s) < f PROB s", "using Sup_MPLS_s_lt_if problem_plan_bound_s_def"], ["proof (prove)\nusing this:\n  \\<forall>PROB x s.\n     finite PROB \\<and>\n     P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n     x \\<in> MPLS_s PROB s \\<longrightarrow> x < f PROB s\n  \\<forall>x\\<in>MPLS_s ?PROB ?s. x < ?k \\<Longrightarrow>\n  Sup (MPLS_s ?PROB ?s) < ?k\n  problem_plan_bound_s ?PROB ?s = Sup (MPLS_s ?PROB ?s)\n\ngoal (1 subgoal):\n 1. finite PROB \\<and>\n    P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n    Sup (MPLS_s PROB s) < f PROB s", "by metis"], ["proof (state)\nthis:\n  finite PROB \\<and>\n  P PROB \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n  problem_plan_bound_s PROB s < f PROB s\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem bound_main_lemma_reachability_s: \n  fixes PROB :: \"'a problem\" and s\n  assumes \"finite PROB\" \"s \\<in> valid_states PROB\" \n  shows \"(problem_plan_bound_s PROB s < card (reachable_s PROB s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "proof -\n  \\<comment> \\<open>NOTE derive premise for MP of 'bound\\_child\\_parent\\_lemma\\_s\\_2'.\\<close>\n  \\<comment> \\<open>NOTE type of `s` had to be fixed (warning in assumption declaration).\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "fix PROB :: \"'a problem\" and s :: \"'a state\" and as"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "assume P1: \"finite PROB\" \"s \\<in> valid_states PROB\" \"as \\<in> valid_plans PROB\""], ["proof (state)\nthis:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "then"], ["proof (chain)\npicking this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB", "obtain as' where a: \"exec_plan s as = exec_plan s as'\" \"subseq as' as\" \n      \"length as' \\<le> card (reachable_s PROB s) - 1\""], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' \\<le> card (reachable_s PROB s) - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P1 main_lemma_reachability_s"], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s ?as = exec_plan ?s as' \\<and>\n                       subseq as' ?as \\<and>\n                       length as' \\<le> card (reachable_s ?PROB ?s) - 1\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' \\<le> card (reachable_s PROB s) - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> card (reachable_s PROB s) - 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "then"], ["proof (chain)\npicking this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> card (reachable_s PROB s) - 1", "have \"length as' < card (reachable_s PROB s)\""], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> card (reachable_s PROB s) - 1\n\ngoal (1 subgoal):\n 1. length as' < card (reachable_s PROB s)", "using P1(1, 2) card_reachable_s_non_zero"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> card (reachable_s PROB s) - 1\n  finite PROB\n  s \\<in> valid_states PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB\\<rbrakk>\n  \\<Longrightarrow> 0 < card (reachable_s ?PROB ?s)\n\ngoal (1 subgoal):\n 1. length as' < card (reachable_s PROB s)", "by fastforce"], ["proof (state)\nthis:\n  length as' < card (reachable_s PROB s)\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "then"], ["proof (chain)\npicking this:\n  length as' < card (reachable_s PROB s)", "have \"(\\<exists>as'. \n      exec_plan s as = exec_plan s as' \\<and> subseq as' as \\<and> length as' < card (reachable_s PROB s))\n    \""], ["proof (prove)\nusing this:\n  length as' < card (reachable_s PROB s)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' < card (reachable_s PROB s)", "using a"], ["proof (prove)\nusing this:\n  length as' < card (reachable_s PROB s)\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> card (reachable_s PROB s) - 1\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' < card (reachable_s PROB s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < card (reachable_s PROB s)\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?PROBa2; ?sa2 \\<in> valid_states ?PROBa2;\n   ?as2 \\<in> valid_plans ?PROBa2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?sa2 ?as2 = exec_plan ?sa2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as' < card (reachable_s ?PROBa2 ?sa2)\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?PROBa2; ?sa2 \\<in> valid_states ?PROBa2;\n   ?as2 \\<in> valid_plans ?PROBa2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?sa2 ?as2 = exec_plan ?sa2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as' < card (reachable_s ?PROBa2 ?sa2)", "have \"\n    finite PROB \\<and> True \\<and> s \\<in> valid_states PROB \n    \\<longrightarrow> problem_plan_bound_s PROB s < card (reachable_s PROB s)\n  \""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?PROBa2; ?sa2 \\<in> valid_states ?PROBa2;\n   ?as2 \\<in> valid_plans ?PROBa2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?sa2 ?as2 = exec_plan ?sa2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as' < card (reachable_s ?PROBa2 ?sa2)\n\ngoal (1 subgoal):\n 1. finite PROB \\<and>\n    True \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n    problem_plan_bound_s PROB s < card (reachable_s PROB s)", "using bound_child_parent_lemma_s_2[where PROB = PROB and P = \"\\<lambda>_. True\" and s = s\n        and f = \"\\<lambda>PROB s. card (reachable_s PROB s)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?PROBa2; ?sa2 \\<in> valid_states ?PROBa2;\n   ?as2 \\<in> valid_plans ?PROBa2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?sa2 ?as2 = exec_plan ?sa2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as' < card (reachable_s ?PROBa2 ?sa2)\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     True \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and>\n         length as' < card (reachable_s PROB s)) \\<Longrightarrow>\n  finite PROB \\<and> True \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n  problem_plan_bound_s PROB s < card (reachable_s PROB s)\n\ngoal (1 subgoal):\n 1. finite PROB \\<and>\n    True \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n    problem_plan_bound_s PROB s < card (reachable_s PROB s)", "by blast"], ["proof (state)\nthis:\n  finite PROB \\<and> True \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n  problem_plan_bound_s PROB s < card (reachable_s PROB s)\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "then"], ["proof (chain)\npicking this:\n  finite PROB \\<and> True \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n  problem_plan_bound_s PROB s < card (reachable_s PROB s)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite PROB \\<and> True \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n  problem_plan_bound_s PROB s < card (reachable_s PROB s)\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  finite PROB \\<and> True \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n  problem_plan_bound_s PROB s < card (reachable_s PROB s)\n  finite PROB\n  s \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < card (reachable_s PROB s)", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound_s PROB s < card (reachable_s PROB s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  problem_plan_bound_s_LESS_EQ_problem_plan_bound_thm: \n  fixes PROB :: \"'a problem\" and s :: \"'a state\"\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\"\n  shows \"(problem_plan_bound_s PROB s < problem_plan_bound PROB + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "fix PROB :: \"'a problem\" and s :: \"'a state\" and as"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "assume \"finite PROB\" \"s \\<in> valid_states PROB\" \"as \\<in> valid_plans PROB\""], ["proof (state)\nthis:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "then"], ["proof (chain)\npicking this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB", "obtain as' where a: \"exec_plan s as = exec_plan s as'\" \"subseq as' as\" \n      \"length as' \\<le> problem_plan_bound PROB\""], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' \\<le> problem_plan_bound PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using problem_plan_bound_works"], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s ?as = exec_plan ?s as' \\<and>\n                       subseq as' ?as \\<and>\n                       length as' \\<le> problem_plan_bound ?PROB\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' \\<le> problem_plan_bound PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "then"], ["proof (chain)\npicking this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound PROB", "have \"length as' < problem_plan_bound PROB + 1\""], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. length as' < problem_plan_bound PROB + 1", "by linarith"], ["proof (state)\nthis:\n  length as' < problem_plan_bound PROB + 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "then"], ["proof (chain)\npicking this:\n  length as' < problem_plan_bound PROB + 1", "have \"\\<exists>as'. \n      exec_plan s as = exec_plan s as' \\<and> subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB + 1\n    \""], ["proof (prove)\nusing this:\n  length as' < problem_plan_bound PROB + 1\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB + 1", "using a"], ["proof (prove)\nusing this:\n  length as' < problem_plan_bound PROB + 1\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB + 1", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB + 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "}\n    \\<comment> \\<open>TODO unsure why a proof is needed at all here.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?PROBa2; ?sa2 \\<in> valid_states ?PROBa2;\n   ?as2 \\<in> valid_plans ?PROBa2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?sa2 ?as2 = exec_plan ?sa2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as' \\<le> problem_plan_bound ?PROBa2 + 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?PROBa2; ?sa2 \\<in> valid_states ?PROBa2;\n   ?as2 \\<in> valid_plans ?PROBa2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?sa2 ?as2 = exec_plan ?sa2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as' \\<le> problem_plan_bound ?PROBa2 + 1", "have \"\\<forall>(PROB :: 'a problem) as s.\n   finite PROB \\<and> True \\<and> s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB \n   \\<longrightarrow> (\\<exists>as'. \n    exec_plan s as = exec_plan s as' \\<and> subseq as' as \\<and> length as' < problem_plan_bound PROB + 1)\n  \""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?PROBa2; ?sa2 \\<in> valid_states ?PROBa2;\n   ?as2 \\<in> valid_plans ?PROBa2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?sa2 ?as2 = exec_plan ?sa2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as' \\<le> problem_plan_bound ?PROBa2 + 1\n\ngoal (1 subgoal):\n 1. \\<forall>PROB as s.\n       finite PROB \\<and>\n       True \\<and>\n       s \\<in> valid_states PROB \\<and>\n       as \\<in> valid_plans PROB \\<longrightarrow>\n       (\\<exists>as'.\n           exec_plan s as = exec_plan s as' \\<and>\n           subseq as' as \\<and> length as' < problem_plan_bound PROB + 1)", "by (metis Suc_eq_plus1 problem_plan_bound_works le_imp_less_Suc)"], ["proof (state)\nthis:\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     True \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < problem_plan_bound PROB + 1)\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "then"], ["proof (chain)\npicking this:\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     True \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < problem_plan_bound PROB + 1)", "show \"(problem_plan_bound_s PROB s < problem_plan_bound PROB + 1)\""], ["proof (prove)\nusing this:\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     True \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < problem_plan_bound PROB + 1)\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "using assms bound_child_parent_lemma_s_2[where PROB = PROB and s = s and P = \"\\<lambda>_. True\" \n        and f = \"\\<lambda>PROB s. problem_plan_bound PROB + 1\"]"], ["proof (prove)\nusing this:\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     True \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < problem_plan_bound PROB + 1)\n  finite PROB\n  s \\<in> valid_states PROB\n  \\<forall>PROB as s.\n     finite PROB \\<and>\n     True \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and>\n         length as' < problem_plan_bound PROB + 1) \\<Longrightarrow>\n  finite PROB \\<and> True \\<and> s \\<in> valid_states PROB \\<longrightarrow>\n  problem_plan_bound_s PROB s < problem_plan_bound PROB + 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s < problem_plan_bound PROB + 1", "by fast"], ["proof (state)\nthis:\n  problem_plan_bound_s PROB s < problem_plan_bound PROB + 1\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE lemma `bound\\_main\\_lemma\\_s\\_1` skipped (this is being equivalently redeclared later).\\<close>"], ["", "lemma AS_VALID_MPLS_VALID: \n  fixes PROB as \n  assumes \"(as \\<in> valid_plans PROB)\" \n  shows \"(Inf (PLS s as) \\<in> MPLS_s PROB s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<in> MPLS_s PROB s", "using assms"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<in> MPLS_s PROB s", "unfolding MPLS_s_def"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. Inf (PLS s as)\n    \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as) |as. as \\<in> valid_plans PROB}", "by fast\n\n\n\\<comment> \\<open>NOTE moved up because it's used in the following lemma.\\<close>\n\\<comment> \\<open>NOTE type of `s` had to be fixed for 'in\\_PLS\\_leq\\_2\\_pow\\_n'.\\<close>"], ["", "lemma bound_main_lemma_s_1: \n  fixes PROB :: \"'a problem\" and s :: \"'a state\" and x\n  assumes \"finite PROB\" \"s \\<in> (valid_states PROB)\" \"x \\<in> MPLS_s PROB s\"\n  shows \"(x \\<le> (2 ^ card (prob_dom PROB)) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "obtain as :: \"(('a, bool) fmap \\<times> ('a, bool) fmap) list\" where \"as \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        as \\<in> valid_plans PROB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using empty_plan_is_valid"], ["proof (prove)\nusing this:\n  [] \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        as \\<in> valid_plans PROB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  as \\<in> valid_plans PROB", "obtain x where 1: \"x \\<in> PLS s as\" \"x \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> PLS s as;\n         x \\<le> 2 ^ card (prob_dom PROB) - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms in_PLS_leq_2_pow_n"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n  finite PROB\n  s \\<in> valid_states PROB\n  x \\<in> MPLS_s PROB s\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       x \\<in> PLS ?s ?as \\<and>\n                       x \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> PLS s as;\n         x \\<le> 2 ^ card (prob_dom PROB) - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> PLS s as\n  x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  x \\<in> PLS s as\n  x \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"Inf (PLS s as) \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\nusing this:\n  x \\<in> PLS s as\n  x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> 2 ^ card (prob_dom PROB) - 1", "using mem_le_imp_MIN_le[where s = \"PLS s as\" and k = \"2 ^ card (prob_dom PROB) - 1\"]"], ["proof (prove)\nusing this:\n  x \\<in> PLS s as\n  x \\<le> 2 ^ card (prob_dom PROB) - 1\n  \\<exists>x.\n     x \\<in> PLS s as \\<and>\n     x \\<le> 2 ^ card (prob_dom PROB) - 1 \\<Longrightarrow>\n  Inf (PLS s as) \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast"], ["proof (state)\nthis:\n  Inf (PLS s as) \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  Inf (PLS s as) \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"x \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "using assms(3) 1"], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<le> 2 ^ card (prob_dom PROB) - 1\n  x \\<in> MPLS_s PROB s\n  x \\<in> PLS s as\n  x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast\n      \\<comment> \\<open>TODO unsure why a proof is needed here (typing problem?).\\<close>"], ["proof (state)\nthis:\n  x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  x \\<le> 2 ^ card (prob_dom PROB) - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "using assms(1, 2, 3) S_VALID_AS_VALID_IMP_MIN_IN_PLS bound_on_all_plans_bounds_MPLS_s_i \n      in_MPLS_leq_2_pow_n"], ["proof (prove)\nusing this:\n  x \\<le> 2 ^ card (prob_dom PROB) - 1\n  finite PROB\n  s \\<in> valid_states PROB\n  x \\<in> MPLS_s PROB s\n  \\<lbrakk>?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> Inf (PLS ?s ?as) \\<in> MPLS ?PROB\n  \\<lbrakk>?s \\<in> valid_states ?PROB; ?x \\<in> MPLS_s ?PROB ?s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as.\n                       ?x = Inf (PLS ?s as) \\<and>\n                       as \\<in> valid_plans ?PROB\n  \\<lbrakk>finite ?PROB; ?x \\<in> MPLS ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "by metis"], ["proof (state)\nthis:\n  x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma problem_plan_bound_s_ge_min_pls: \n  fixes PROB :: \"'a problem\" and as k s\n  assumes \"finite PROB\" \"s \\<in> (valid_states PROB)\" \"as \\<in> (valid_plans PROB)\" \n    \"problem_plan_bound_s PROB s \\<le> k\"\n  shows \"(Inf (PLS s as) \\<le> problem_plan_bound_s PROB s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound_s PROB s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound_s PROB s", "have \"\\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1", "using assms(1, 2) bound_main_lemma_s_1"], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB;\n   ?x \\<in> MPLS_s ?PROB ?s\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound_s PROB s", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1", "have 1: \"finite (MPLS_s PROB s)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. finite (MPLS_s PROB s)", "using mems_le_finite[where s = \"MPLS_s PROB s\" and k = \"2 ^ card (prob_dom PROB) - 1\"]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1\n  \\<forall>x.\n     x \\<in> MPLS_s PROB s \\<longrightarrow>\n     x \\<le> 2 ^ card (prob_dom PROB) - 1 \\<Longrightarrow>\n  finite (MPLS_s PROB s)\n\ngoal (1 subgoal):\n 1. finite (MPLS_s PROB s)", "by blast"], ["proof (state)\nthis:\n  finite (MPLS_s PROB s)\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound_s PROB s", "then"], ["proof (chain)\npicking this:\n  finite (MPLS_s PROB s)", "have \"MPLS_s PROB s \\<noteq> {}\""], ["proof (prove)\nusing this:\n  finite (MPLS_s PROB s)\n\ngoal (1 subgoal):\n 1. MPLS_s PROB s \\<noteq> {}", "using bound_main_lemma_s_3"], ["proof (prove)\nusing this:\n  finite (MPLS_s PROB s)\n  MPLS_s ?PROB ?s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. MPLS_s PROB s \\<noteq> {}", "by fast"], ["proof (state)\nthis:\n  MPLS_s PROB s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound_s PROB s", "then"], ["proof (chain)\npicking this:\n  MPLS_s PROB s \\<noteq> {}", "have \"Inf (PLS s as) \\<in> MPLS_s PROB s\""], ["proof (prove)\nusing this:\n  MPLS_s PROB s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<in> MPLS_s PROB s", "using assms AS_VALID_MPLS_VALID"], ["proof (prove)\nusing this:\n  MPLS_s PROB s \\<noteq> {}\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  problem_plan_bound_s PROB s \\<le> k\n  ?as \\<in> valid_plans ?PROB \\<Longrightarrow>\n  Inf (PLS ?s ?as) \\<in> MPLS_s ?PROB ?s\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<in> MPLS_s PROB s", "by blast"], ["proof (state)\nthis:\n  Inf (PLS s as) \\<in> MPLS_s PROB s\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound_s PROB s", "then"], ["proof (chain)\npicking this:\n  Inf (PLS s as) \\<in> MPLS_s PROB s", "show \"(Inf (PLS s as) \\<le> problem_plan_bound_s PROB s)\""], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<in> MPLS_s PROB s\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound_s PROB s", "unfolding problem_plan_bound_s_def"], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<in> MPLS_s PROB s\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> Sup (MPLS_s PROB s)", "using 1 le_cSup_finite"], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<in> MPLS_s PROB s\n  finite (MPLS_s PROB s)\n  \\<lbrakk>finite ?X; ?x \\<in> ?X\\<rbrakk> \\<Longrightarrow> ?x \\<le> Sup ?X\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> Sup (MPLS_s PROB s)", "by blast"], ["proof (state)\nthis:\n  Inf (PLS s as) \\<le> problem_plan_bound_s PROB s\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem bound_main_lemma_s:\n  fixes PROB :: \"'a problem\" and s\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\"\n  shows \"(problem_plan_bound_s PROB s \\<le> 2 ^ (card (prob_dom PROB)) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1", "have 1: \"\\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1", "using assms bound_main_lemma_s_1"], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB;\n   ?x \\<in> MPLS_s ?PROB ?s\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1", "by metis"], ["proof (state)\nthis:\n  \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"MPLS_s PROB s \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. MPLS_s PROB s \\<noteq> {}", "using bound_main_lemma_s_3"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1\n  MPLS_s ?PROB ?s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. MPLS_s PROB s \\<noteq> {}", "by fast"], ["proof (state)\nthis:\n  MPLS_s PROB s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  MPLS_s PROB s \\<noteq> {}", "have \"Sup (MPLS_s PROB s) \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\nusing this:\n  MPLS_s PROB s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Sup (MPLS_s PROB s) \\<le> 2 ^ card (prob_dom PROB) - 1", "using 1 bound_main_lemma_2[where s = \"MPLS_s PROB s\" and k = \"2 ^ card (prob_dom PROB) - 1\"]"], ["proof (prove)\nusing this:\n  MPLS_s PROB s \\<noteq> {}\n  \\<forall>x\\<in>MPLS_s PROB s. x \\<le> 2 ^ card (prob_dom PROB) - 1\n  MPLS_s PROB s \\<noteq> {} \\<and>\n  (\\<forall>x.\n      x \\<in> MPLS_s PROB s \\<longrightarrow>\n      x \\<le> 2 ^ card (prob_dom PROB) - 1) \\<Longrightarrow>\n  Sup (MPLS_s PROB s) \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. Sup (MPLS_s PROB s) \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast"], ["proof (state)\nthis:\n  Sup (MPLS_s PROB s) \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  Sup (MPLS_s PROB s) \\<le> 2 ^ card (prob_dom PROB) - 1", "show \"problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\nusing this:\n  Sup (MPLS_s PROB s) \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1", "unfolding problem_plan_bound_s_def"], ["proof (prove)\nusing this:\n  Sup (MPLS_s PROB s) \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. Sup (MPLS_s PROB s) \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma problem_plan_bound_s_works:\n  fixes PROB :: \"'a problem\" and as s\n  assumes \"finite PROB\" \"(as \\<in> valid_plans PROB)\" \"(s \\<in> valid_states PROB)\"\n  shows \"(\\<exists>as'. \n    (exec_plan s as = exec_plan s as') \n    \\<and> (subseq as' as) \n    \\<and> (length as' \\<le> problem_plan_bound_s PROB s)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound_s PROB s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound_s PROB s", "have \"problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1", "using assms(1, 3) bound_main_lemma_s"], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound_s ?PROB ?s\n                    \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound_s PROB s", "then"], ["proof (chain)\npicking this:\n  problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1", "have 1: \"Inf (PLS s as) \\<le> problem_plan_bound_s PROB s\""], ["proof (prove)\nusing this:\n  problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound_s PROB s", "using assms problem_plan_bound_s_ge_min_pls[of PROB s as \" 2 ^ card (prob_dom PROB) - 1\"]"], ["proof (prove)\nusing this:\n  problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1\n  finite PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<lbrakk>finite PROB; s \\<in> valid_states PROB;\n   as \\<in> valid_plans PROB;\n   problem_plan_bound_s PROB s \\<le> 2 ^ card (prob_dom PROB) - 1\\<rbrakk>\n  \\<Longrightarrow> Inf (PLS s as) \\<le> problem_plan_bound_s PROB s\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) \\<le> problem_plan_bound_s PROB s", "by blast"], ["proof (state)\nthis:\n  Inf (PLS s as) \\<le> problem_plan_bound_s PROB s\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound_s PROB s", "then"], ["proof (chain)\npicking this:\n  Inf (PLS s as) \\<le> problem_plan_bound_s PROB s", "obtain x where obtain_x: \"x \\<in> PLS s as \\<and> x = Inf (PLS s as)\""], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<le> problem_plan_bound_s PROB s\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> PLS s as \\<and> x = Inf (PLS s as) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using PLS_nempty_and_has_min"], ["proof (prove)\nusing this:\n  Inf (PLS s as) \\<le> problem_plan_bound_s PROB s\n  \\<exists>x. x \\<in> PLS ?s ?as \\<and> x = Inf (PLS ?s ?as)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> PLS s as \\<and> x = Inf (PLS s as) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> PLS s as \\<and> x = Inf (PLS s as)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound_s PROB s", "then"], ["proof (chain)\npicking this:\n  x \\<in> PLS s as \\<and> x = Inf (PLS s as)", "have \"\\<exists>as'. exec_plan s as = exec_plan s as' \\<and> length as' = Inf (PLS s as) \\<and> subseq as' as\""], ["proof (prove)\nusing this:\n  x \\<in> PLS s as \\<and> x = Inf (PLS s as)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       length as' = Inf (PLS s as) \\<and> subseq as' as", "using PLS_works[where s = s and as = as and x = \"Inf (PLS s as)\"]\n      obtain_x"], ["proof (prove)\nusing this:\n  x \\<in> PLS s as \\<and> x = Inf (PLS s as)\n  Inf (PLS s as) \\<in> PLS s as \\<Longrightarrow>\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     length as' = Inf (PLS s as) \\<and> subseq as' as\n  x \\<in> PLS s as \\<and> x = Inf (PLS s as)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       length as' = Inf (PLS s as) \\<and> subseq as' as", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     length as' = Inf (PLS s as) \\<and> subseq as' as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound_s PROB s", "then"], ["proof (chain)\npicking this:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     length as' = Inf (PLS s as) \\<and> subseq as' as", "show \"(\\<exists>as'. \n    (exec_plan s as = exec_plan s as') \\<and> (subseq as' as) \n    \\<and> (length as' \\<le> problem_plan_bound_s PROB s)\n  )\""], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     length as' = Inf (PLS s as) \\<and> subseq as' as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound_s PROB s", "using 1"], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     length as' = Inf (PLS s as) \\<and> subseq as' as\n  Inf (PLS s as) \\<le> problem_plan_bound_s PROB s\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound_s PROB s", "by metis"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' \\<le> problem_plan_bound_s PROB s\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE skipped second declaration (declared twice in source).\\<close>"], ["", "lemma PLS_def_ITP2015: \n  fixes s as\n  shows \"PLS s as = {length as' | as'. (exec_plan s as' = exec_plan s as) \\<and> (subseq as' as)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PLS s as =\n    {length as' |as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}", "using PLS_def"], ["proof (prove)\nusing this:\n  PLS ?s ?as \\<equiv>\n  length ` {as'. exec_plan ?s as' = exec_plan ?s ?as \\<and> subseq as' ?as}\n\ngoal (1 subgoal):\n 1. PLS s as =\n    {length as' |as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}", "by blast\n\n\n\\<comment> \\<open>NOTE Set comprehension had to be rewritten to image (there is no pattern matching in the part \nleft of the pipe symbol).\\<close>"], ["", "lemma expanded_problem_plan_bound_charles_thm: \n  fixes PROB :: \"'a problem\" \n  shows \" \n    problem_plan_bound_charles PROB \n    = Sup (\n      {\n        Inf (PLS_charles (fst p) (snd p) PROB) \n        | p. (fst p \\<in> valid_states PROB) \\<and> (snd p \\<in> valid_plans PROB)})\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB =\n    Sup {Inf (PLS_charles (fst p) (snd p) PROB) |p.\n         fst p \\<in> valid_states PROB \\<and> snd p \\<in> valid_plans PROB}", "unfolding problem_plan_bound_charles_def MPLS_charles_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {Inf (PLS_charles (fst p) (snd p) PROB) |p.\n         fst p \\<in> valid_states PROB \\<and>\n         snd p \\<in> valid_plans PROB} =\n    Sup {Inf (PLS_charles (fst p) (snd p) PROB) |p.\n         fst p \\<in> valid_states PROB \\<and> snd p \\<in> valid_plans PROB}", "by blast"], ["", "lemma bound_main_lemma_charles_3:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\"\n  shows \"MPLS_charles PROB \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "have 1: \"[] \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> valid_plans PROB", "using empty_plan_is_valid"], ["proof (prove)\nusing this:\n  [] \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. [] \\<in> valid_plans PROB", "by auto"], ["proof (state)\nthis:\n  [] \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  [] \\<in> valid_plans PROB", "obtain s :: \"'a state\" where obtain_s: \"s \\<in> valid_states PROB\""], ["proof (prove)\nusing this:\n  [] \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> valid_states PROB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms valid_states_nempty"], ["proof (prove)\nusing this:\n  [] \\<in> valid_plans PROB\n  finite PROB\n  finite ?PROB \\<Longrightarrow> \\<exists>s. s \\<in> valid_states ?PROB\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> valid_states PROB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  s \\<in> valid_states PROB", "have \"Inf (PLS_charles s [] PROB) \\<in> MPLS_charles PROB\""], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. Inf (PLS_charles s [] PROB) \\<in> MPLS_charles PROB", "unfolding MPLS_charles_def"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. Inf (PLS_charles s [] PROB)\n    \\<in> {Inf (PLS_charles (fst p) (snd p) PROB) |p.\n           fst p \\<in> valid_states PROB \\<and>\n           snd p \\<in> valid_plans PROB}", "using 1"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  [] \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. Inf (PLS_charles s [] PROB)\n    \\<in> {Inf (PLS_charles (fst p) (snd p) PROB) |p.\n           fst p \\<in> valid_states PROB \\<and>\n           snd p \\<in> valid_plans PROB}", "by auto"], ["proof (state)\nthis:\n  Inf (PLS_charles s [] PROB) \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  Inf (PLS_charles s [] PROB) \\<in> MPLS_charles PROB", "show \"MPLS_charles PROB \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Inf (PLS_charles s [] PROB) \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  MPLS_charles PROB \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_PLS_charles_leq_2_pow_n: \n  fixes PROB :: \"'a problem\" and s as\n  assumes \"finite PROB\" \"s \\<in> valid_states PROB\" \"as \\<in> valid_plans PROB\"\n  shows \"(\\<exists>x. \n    (x \\<in> PLS_charles s as PROB) \n    \\<and> (x \\<le> 2 ^ card (prob_dom PROB) - 1))\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> PLS_charles s as PROB \\<and>\n       x \\<le> 2 ^ card (prob_dom PROB) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> PLS_charles s as PROB \\<and>\n       x \\<le> 2 ^ card (prob_dom PROB) - 1", "obtain as' where 1:\n    \"exec_plan s as = exec_plan s as'\" \"subseq as' as\" \"length as' \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' \\<le> 2 ^ card (prob_dom PROB) - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms main_lemma"], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s ?as = exec_plan ?s as' \\<and>\n                       subseq as' ?as \\<and>\n                       length as' \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' \\<le> 2 ^ card (prob_dom PROB) - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> PLS_charles s as PROB \\<and>\n       x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"as' \\<in> valid_plans PROB\""], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. as' \\<in> valid_plans PROB", "using assms(3) sublist_valid_plan"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1\n  as \\<in> valid_plans PROB\n  \\<lbrakk>subseq ?as' ?as; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?as' \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. as' \\<in> valid_plans PROB", "by blast"], ["proof (state)\nthis:\n  as' \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> PLS_charles s as PROB \\<and>\n       x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  as' \\<in> valid_plans PROB", "have \"length as' \\<in> PLS_charles s as PROB\""], ["proof (prove)\nusing this:\n  as' \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. length as' \\<in> PLS_charles s as PROB", "unfolding PLS_charles_def"], ["proof (prove)\nusing this:\n  as' \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. length as'\n    \\<in> {length as' |as'.\n           as' \\<in> valid_plans PROB \\<and>\n           exec_plan s as' = exec_plan s as}", "using 1"], ["proof (prove)\nusing this:\n  as' \\<in> valid_plans PROB\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. length as'\n    \\<in> {length as' |as'.\n           as' \\<in> valid_plans PROB \\<and>\n           exec_plan s as' = exec_plan s as}", "by auto"], ["proof (state)\nthis:\n  length as' \\<in> PLS_charles s as PROB\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> PLS_charles s as PROB \\<and>\n       x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  length as' \\<in> PLS_charles s as PROB", "show ?thesis"], ["proof (prove)\nusing this:\n  length as' \\<in> PLS_charles s as PROB\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> PLS_charles s as PROB \\<and>\n       x \\<le> 2 ^ card (prob_dom PROB) - 1", "using 1(3)"], ["proof (prove)\nusing this:\n  length as' \\<in> PLS_charles s as PROB\n  length as' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> PLS_charles s as PROB \\<and>\n       x \\<le> 2 ^ card (prob_dom PROB) - 1", "by fast"], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<in> PLS_charles s as PROB \\<and>\n     x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE added lemma.\\<close>\n\\<comment> \\<open>NOTE this lemma retrieves `s`, `as` for a given @{term \"x \\<in> MPLS_charles PROB\"} and characterizes it as\nthe minimum of 'PLS\\_charles s as PROB'.\\<close>"], ["", "lemma x_in_MPLS_charles_then: \n  fixes PROB s as\n  assumes \"x \\<in> MPLS_charles PROB\"\n  shows \"\\<exists>s as. \n    s \\<in> valid_states PROB \\<and> as \\<in> valid_plans PROB \\<and> x = Inf (PLS_charles s as PROB)\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s as.\n       s \\<in> valid_states PROB \\<and>\n       as \\<in> valid_plans PROB \\<and> x = Inf (PLS_charles s as PROB)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s as.\n       s \\<in> valid_states PROB \\<and>\n       as \\<in> valid_plans PROB \\<and> x = Inf (PLS_charles s as PROB)", "have \"\\<exists>p \\<in> {p. (fst p) \\<in> valid_states PROB \\<and> (snd p) \\<in> valid_plans PROB}. x = Inf (PLS_charles (fst p) (snd p) PROB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>{p. fst p \\<in> valid_states PROB \\<and>\n                       snd p \\<in> valid_plans PROB}.\n       x = Inf (PLS_charles (fst p) (snd p) PROB)", "using MPLS_charles_def assms"], ["proof (prove)\nusing this:\n  MPLS_charles ?PROB \\<equiv>\n  {Inf (PLS_charles (fst p) (snd p) ?PROB) |p.\n   fst p \\<in> valid_states ?PROB \\<and> snd p \\<in> valid_plans ?PROB}\n  x \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>{p. fst p \\<in> valid_states PROB \\<and>\n                       snd p \\<in> valid_plans PROB}.\n       x = Inf (PLS_charles (fst p) (snd p) PROB)", "by fast"], ["proof (state)\nthis:\n  \\<exists>p\\<in>{p. fst p \\<in> valid_states PROB \\<and>\n                     snd p \\<in> valid_plans PROB}.\n     x = Inf (PLS_charles (fst p) (snd p) PROB)\n\ngoal (1 subgoal):\n 1. \\<exists>s as.\n       s \\<in> valid_states PROB \\<and>\n       as \\<in> valid_plans PROB \\<and> x = Inf (PLS_charles s as PROB)", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>{p. fst p \\<in> valid_states PROB \\<and>\n                     snd p \\<in> valid_plans PROB}.\n     x = Inf (PLS_charles (fst p) (snd p) PROB)", "obtain p where 1:\n    \"p \\<in> {p. (fst p) \\<in> valid_states PROB \\<and> (snd p) \\<in> valid_plans PROB}\" \n    \"x = Inf (PLS_charles (fst p) (snd p) PROB)\""], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>{p. fst p \\<in> valid_states PROB \\<and>\n                     snd p \\<in> valid_plans PROB}.\n     x = Inf (PLS_charles (fst p) (snd p) PROB)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> {p. fst p \\<in> valid_states PROB \\<and>\n                             snd p \\<in> valid_plans PROB};\n         x = Inf (PLS_charles (fst p) (snd p) PROB)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in> {p. fst p \\<in> valid_states PROB \\<and>\n              snd p \\<in> valid_plans PROB}\n  x = Inf (PLS_charles (fst p) (snd p) PROB)\n\ngoal (1 subgoal):\n 1. \\<exists>s as.\n       s \\<in> valid_states PROB \\<and>\n       as \\<in> valid_plans PROB \\<and> x = Inf (PLS_charles s as PROB)", "then"], ["proof (chain)\npicking this:\n  p \\<in> {p. fst p \\<in> valid_states PROB \\<and>\n              snd p \\<in> valid_plans PROB}\n  x = Inf (PLS_charles (fst p) (snd p) PROB)", "have \"fst p \\<in> valid_states PROB\" \"snd p \\<in> valid_plans PROB\""], ["proof (prove)\nusing this:\n  p \\<in> {p. fst p \\<in> valid_states PROB \\<and>\n              snd p \\<in> valid_plans PROB}\n  x = Inf (PLS_charles (fst p) (snd p) PROB)\n\ngoal (1 subgoal):\n 1. fst p \\<in> valid_states PROB &&& snd p \\<in> valid_plans PROB", "by blast+"], ["proof (state)\nthis:\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>s as.\n       s \\<in> valid_states PROB \\<and>\n       as \\<in> valid_plans PROB \\<and> x = Inf (PLS_charles s as PROB)", "then"], ["proof (chain)\npicking this:\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB", "show ?thesis"], ["proof (prove)\nusing this:\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>s as.\n       s \\<in> valid_states PROB \\<and>\n       as \\<in> valid_plans PROB \\<and> x = Inf (PLS_charles s as PROB)", "using 1"], ["proof (prove)\nusing this:\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n  p \\<in> {p. fst p \\<in> valid_states PROB \\<and>\n              snd p \\<in> valid_plans PROB}\n  x = Inf (PLS_charles (fst p) (snd p) PROB)\n\ngoal (1 subgoal):\n 1. \\<exists>s as.\n       s \\<in> valid_states PROB \\<and>\n       as \\<in> valid_plans PROB \\<and> x = Inf (PLS_charles s as PROB)", "by fast"], ["proof (state)\nthis:\n  \\<exists>s as.\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<and> x = Inf (PLS_charles s as PROB)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_MPLS_charles_leq_2_pow_n:\n  fixes PROB :: \"'a problem\" and x\n  assumes \"finite PROB\" \"x \\<in> MPLS_charles PROB\"\n  shows \"x \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "obtain s as where 1:\n    \"s \\<in> valid_states PROB\" \"as \\<in> valid_plans PROB\" \"x = Inf (PLS_charles s as PROB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s as.\n        \\<lbrakk>s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n         x = Inf (PLS_charles s as PROB)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) x_in_MPLS_charles_then"], ["proof (prove)\nusing this:\n  x \\<in> MPLS_charles PROB\n  ?x \\<in> MPLS_charles ?PROB \\<Longrightarrow>\n  \\<exists>s as.\n     s \\<in> valid_states ?PROB \\<and>\n     as \\<in> valid_plans ?PROB \\<and> ?x = Inf (PLS_charles s as ?PROB)\n\ngoal (1 subgoal):\n 1. (\\<And>s as.\n        \\<lbrakk>s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n         x = Inf (PLS_charles s as PROB)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  x = Inf (PLS_charles s as PROB)\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  x = Inf (PLS_charles s as PROB)", "obtain x' where 2: \"x' \\<in> PLS_charles s as PROB\"\"x' \\<le> 2 ^ card (prob_dom PROB) - 1\""], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  x = Inf (PLS_charles s as PROB)\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> PLS_charles s as PROB;\n         x' \\<le> 2 ^ card (prob_dom PROB) - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) in_PLS_charles_leq_2_pow_n"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  x = Inf (PLS_charles s as PROB)\n  finite PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       x \\<in> PLS_charles ?s ?as ?PROB \\<and>\n                       x \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> PLS_charles s as PROB;\n         x' \\<le> 2 ^ card (prob_dom PROB) - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x' \\<in> PLS_charles s as PROB\n  x' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  x' \\<in> PLS_charles s as PROB\n  x' \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"x \\<le> x'\""], ["proof (prove)\nusing this:\n  x' \\<in> PLS_charles s as PROB\n  x' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. x \\<le> x'", "using 1(3) mem_le_imp_MIN_le"], ["proof (prove)\nusing this:\n  x' \\<in> PLS_charles s as PROB\n  x' \\<le> 2 ^ card (prob_dom PROB) - 1\n  x = Inf (PLS_charles s as PROB)\n  \\<exists>x. x \\<in> ?s \\<and> x \\<le> ?k \\<Longrightarrow> Inf ?s \\<le> ?k\n\ngoal (1 subgoal):\n 1. x \\<le> x'", "by blast"], ["proof (state)\nthis:\n  x \\<le> x'\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  x \\<le> x'", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> x'\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "using 1 2"], ["proof (prove)\nusing this:\n  x \\<le> x'\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  x = Inf (PLS_charles s as PROB)\n  x' \\<in> PLS_charles s as PROB\n  x' \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. x \\<le> 2 ^ card (prob_dom PROB) - 1", "by linarith"], ["proof (state)\nthis:\n  x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_main_lemma_charles:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\"\n  shows \"problem_plan_bound_charles PROB \\<le> 2 ^ (card (prob_dom PROB)) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "have 1: \"\\<forall>x\\<in>MPLS_charles PROB. x \\<le> 2 ^ (card (prob_dom PROB)) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS_charles PROB. x \\<le> 2 ^ card (prob_dom PROB) - 1", "using assms in_MPLS_charles_leq_2_pow_n"], ["proof (prove)\nusing this:\n  finite PROB\n  \\<lbrakk>finite ?PROB; ?x \\<in> MPLS_charles ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> 2 ^ card (prob_dom ?PROB) - 1\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>MPLS_charles PROB. x \\<le> 2 ^ card (prob_dom PROB) - 1", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>MPLS_charles PROB. x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>MPLS_charles PROB. x \\<le> 2 ^ card (prob_dom PROB) - 1", "have \"MPLS_charles PROB \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS_charles PROB. x \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "using assms bound_main_lemma_charles_3"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>MPLS_charles PROB. x \\<le> 2 ^ card (prob_dom PROB) - 1\n  finite PROB\n  finite ?PROB \\<Longrightarrow> MPLS_charles ?PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  MPLS_charles PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  MPLS_charles PROB \\<noteq> {}", "have \"Sup (MPLS_charles PROB) \\<le> 2 ^ (card (prob_dom PROB)) - 1\""], ["proof (prove)\nusing this:\n  MPLS_charles PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) \\<le> 2 ^ card (prob_dom PROB) - 1", "using 1 bound_main_lemma_2"], ["proof (prove)\nusing this:\n  MPLS_charles PROB \\<noteq> {}\n  \\<forall>x\\<in>MPLS_charles PROB. x \\<le> 2 ^ card (prob_dom PROB) - 1\n  ?s \\<noteq> {} \\<and>\n  (\\<forall>x. x \\<in> ?s \\<longrightarrow> x \\<le> ?k) \\<Longrightarrow>\n  Sup ?s \\<le> ?k\n\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) \\<le> 2 ^ card (prob_dom PROB) - 1", "by meson"], ["proof (state)\nthis:\n  Sup (MPLS_charles PROB) \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "then"], ["proof (chain)\npicking this:\n  Sup (MPLS_charles PROB) \\<le> 2 ^ card (prob_dom PROB) - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  Sup (MPLS_charles PROB) \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "using problem_plan_bound_charles_def"], ["proof (prove)\nusing this:\n  Sup (MPLS_charles PROB) \\<le> 2 ^ card (prob_dom PROB) - 1\n  problem_plan_bound_charles ?PROB \\<equiv> Sup (MPLS_charles ?PROB)\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> 2 ^ card (prob_dom PROB) - 1", "by metis"], ["proof (state)\nthis:\n  problem_plan_bound_charles PROB \\<le> 2 ^ card (prob_dom PROB) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_on_all_plans_bounds_PLS_charles:\n  fixes P and f\n  assumes \"\\<forall>(PROB :: 'a problem) as s.\n    (P PROB) \\<and> finite PROB \\<and> (as \\<in> valid_plans PROB) \\<and> (s \\<in> valid_states PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \\<and> (subseq as' as)\\<and> (length as' < f PROB))\n  \"\n  shows \"(\\<forall>PROB s as. \n    (P PROB) \\<and> finite PROB \\<and> (as \\<in> valid_plans PROB)  \\<and> (s \\<in> valid_states PROB)\n    \\<longrightarrow> (\\<exists>x. \n      (x \\<in> PLS_charles s as PROB) \n      \\<and> (x < f PROB)))\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "{\n    \\<comment> \\<open>NOTE type for 's' had to be fixed (type mismatch in first proof step.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "fix PROB :: \"'a problem\" and as and s :: \"'a state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "assume P: \n      \"P PROB\" \"finite PROB\" \"as \\<in> valid_plans PROB\" \"s \\<in> valid_states PROB\"\n      \"(\\<exists>as'. \n        (exec_plan s as = exec_plan s as') \n        \\<and> (subseq as' as)\n        \\<and> (length as' < f PROB)\n      )\""], ["proof (state)\nthis:\n  P PROB\n  finite PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "then"], ["proof (chain)\npicking this:\n  P PROB\n  finite PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB", "obtain as' where 1:\n      \"(exec_plan s as = exec_plan s as')\" \"(subseq as' as)\" \"(length as' < f PROB)\""], ["proof (prove)\nusing this:\n  P PROB\n  finite PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' < f PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P(5)"], ["proof (prove)\nusing this:\n  P PROB\n  finite PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < f PROB\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' < f PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "then"], ["proof (chain)\npicking this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' < f PROB", "have 2: \"as' \\<in> valid_plans PROB\""], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' < f PROB\n\ngoal (1 subgoal):\n 1. as' \\<in> valid_plans PROB", "using P(3) sublist_valid_plan"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' < f PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>subseq ?as' ?as; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?as' \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. as' \\<in> valid_plans PROB", "by blast"], ["proof (state)\nthis:\n  as' \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "let ?x = \"length as'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "have \"?x \\<in> PLS_charles s as PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as' \\<in> PLS_charles s as PROB", "unfolding PLS_charles_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length as'\n    \\<in> {length as' |as'.\n           as' \\<in> valid_plans PROB \\<and>\n           exec_plan s as' = exec_plan s as}", "using 1 2"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' < f PROB\n  as' \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. length as'\n    \\<in> {length as' |as'.\n           as' \\<in> valid_plans PROB \\<and>\n           exec_plan s as' = exec_plan s as}", "by auto"], ["proof (state)\nthis:\n  length as' \\<in> PLS_charles s as PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "then"], ["proof (chain)\npicking this:\n  length as' \\<in> PLS_charles s as PROB", "have \"\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB\""], ["proof (prove)\nusing this:\n  length as' \\<in> PLS_charles s as PROB\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB", "using 1 2"], ["proof (prove)\nusing this:\n  length as' \\<in> PLS_charles s as PROB\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' < f PROB\n  as' \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       x \\<in> PLS_charles ?s2 ?as2 ?PROB2 \\<and>\n                       x < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       x \\<in> PLS_charles ?s2 ?as2 ?PROB2 \\<and>\n                       x < f ?PROB2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       x \\<in> PLS_charles ?s2 ?as2 ?PROB2 \\<and>\n                       x < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?as2 \\<in> valid_plans ?PROB2;\n   ?s2 \\<in> valid_states ?PROB2;\n   \\<exists>as'.\n      exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n      subseq as' ?as2 \\<and> length as' < f ?PROB2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       x \\<in> PLS_charles ?s2 ?as2 ?PROB2 \\<and>\n                       x < f ?PROB2\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "by auto"], ["proof (state)\nthis:\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE added lemma (refactored from `bound\\_on\\_all\\_plans\\_bounds\\_MPLS\\_charles`).\\<close>"], ["", "lemma bound_on_all_plans_bounds_MPLS_charles_i:\n  assumes \"\\<forall>(PROB :: 'a problem) s as.\n    (P PROB) \\<and> finite PROB \\<and> (as \\<in> valid_plans PROB) \\<and> (s \\<in> valid_states PROB)\n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \\<and> (subseq as' as) \\<and> (length as' < f PROB))\n  \"\n  shows \"\\<forall>(PROB :: 'a problem) s as.\n    P PROB \\<and> finite PROB \\<and> as \\<in> valid_plans PROB \\<and> s \\<in> valid_states PROB\n    \\<longrightarrow> Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "fix PROB :: \"'a problem\" and s as"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "have \"P PROB \\<and> finite PROB \\<and> as \\<in> valid_plans PROB \\<and> s \\<in> valid_states PROB\n     \\<longrightarrow> (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. P PROB \\<and>\n    finite PROB \\<and>\n    as \\<in> valid_plans PROB \\<and>\n    s \\<in> valid_states PROB \\<longrightarrow>\n    (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "using assms bound_on_all_plans_bounds_PLS_charles[of P f]"], ["proof (prove)\nusing this:\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB) \\<Longrightarrow>\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)\n\ngoal (1 subgoal):\n 1. P PROB \\<and>\n    finite PROB \\<and>\n    as \\<in> valid_plans PROB \\<and>\n    s \\<in> valid_states PROB \\<longrightarrow>\n    (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "by blast"], ["proof (state)\nthis:\n  P PROB \\<and>\n  finite PROB \\<and>\n  as \\<in> valid_plans PROB \\<and>\n  s \\<in> valid_states PROB \\<longrightarrow>\n  (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "then"], ["proof (chain)\npicking this:\n  P PROB \\<and>\n  finite PROB \\<and>\n  as \\<in> valid_plans PROB \\<and>\n  s \\<in> valid_states PROB \\<longrightarrow>\n  (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)", "have \"\n      P PROB \\<and> finite PROB \\<and> as \\<in> valid_plans PROB \\<and> s \\<in> valid_states PROB\n      \\<longrightarrow> Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n    \""], ["proof (prove)\nusing this:\n  P PROB \\<and>\n  finite PROB \\<and>\n  as \\<in> valid_plans PROB \\<and>\n  s \\<in> valid_states PROB \\<longrightarrow>\n  (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)\n\ngoal (1 subgoal):\n 1. P PROB \\<and>\n    finite PROB \\<and>\n    as \\<in> valid_plans PROB \\<and>\n    s \\<in> valid_states PROB \\<longrightarrow>\n    Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "using mem_lt_imp_MIN_lt CollectI"], ["proof (prove)\nusing this:\n  P PROB \\<and>\n  finite PROB \\<and>\n  as \\<in> valid_plans PROB \\<and>\n  s \\<in> valid_states PROB \\<longrightarrow>\n  (\\<exists>x. x \\<in> PLS_charles s as PROB \\<and> x < f PROB)\n  \\<exists>x. x \\<in> ?s \\<and> x < ?k \\<Longrightarrow> Inf ?s < ?k\n  ?P ?a \\<Longrightarrow> ?a \\<in> {x. ?P x}\n\ngoal (1 subgoal):\n 1. P PROB \\<and>\n    finite PROB \\<and>\n    as \\<in> valid_plans PROB \\<and>\n    s \\<in> valid_states PROB \\<longrightarrow>\n    Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "by metis"], ["proof (state)\nthis:\n  P PROB \\<and>\n  finite PROB \\<and>\n  as \\<in> valid_plans PROB \\<and>\n  s \\<in> valid_states PROB \\<longrightarrow>\n  Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "}"], ["proof (state)\nthis:\n  P ?PROB2 \\<and>\n  finite ?PROB2 \\<and>\n  ?as2 \\<in> valid_plans ?PROB2 \\<and>\n  ?s2 \\<in> valid_states ?PROB2 \\<longrightarrow>\n  Inf {n. n \\<in> PLS_charles ?s2 ?as2 ?PROB2} < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "then"], ["proof (chain)\npicking this:\n  P ?PROB2 \\<and>\n  finite ?PROB2 \\<and>\n  ?as2 \\<in> valid_plans ?PROB2 \\<and>\n  ?s2 \\<in> valid_states ?PROB2 \\<longrightarrow>\n  Inf {n. n \\<in> PLS_charles ?s2 ?as2 ?PROB2} < f ?PROB2", "show ?thesis"], ["proof (prove)\nusing this:\n  P ?PROB2 \\<and>\n  finite ?PROB2 \\<and>\n  ?as2 \\<in> valid_plans ?PROB2 \\<and>\n  ?s2 \\<in> valid_states ?PROB2 \\<longrightarrow>\n  Inf {n. n \\<in> PLS_charles ?s2 ?as2 ?PROB2} < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_on_all_plans_bounds_MPLS_charles:\n  fixes P f\n  assumes \"(\\<forall>(PROB :: 'a problem) as s. \n    (P PROB) \\<and> finite PROB \\<and> (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB)\n    )\n  )\"\n  shows \"(\\<forall>PROB x. \n    (P PROB) \\<and> finite PROB\n    \\<longrightarrow> (x \\<in> MPLS_charles PROB) \n    \\<longrightarrow> (x < f PROB)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "have 1: \"\\<forall>(PROB :: 'a problem) s as. \n    P PROB \\<and> finite PROB \\<and> as \\<in> valid_plans PROB \\<and> s \\<in> valid_states PROB\n    \\<longrightarrow> Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "using assms bound_on_all_plans_bounds_MPLS_charles_i"], ["proof (prove)\nusing this:\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     finite PROB \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n  \\<forall>PROB s as.\n     ?P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < ?f PROB) \\<Longrightarrow>\n  \\<forall>PROB s as.\n     ?P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     Inf {n. n \\<in> PLS_charles s as PROB} < ?f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB s as.\n       P PROB \\<and>\n       finite PROB \\<and>\n       as \\<in> valid_plans PROB \\<and>\n       s \\<in> valid_states PROB \\<longrightarrow>\n       Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "moreover"], ["proof (state)\nthis:\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "{"], ["proof (state)\nthis:\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "fix PROB :: \"'a problem\" and x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "assume P1: \"(P PROB)\" \"finite PROB\" \"x \\<in> MPLS_charles PROB\""], ["proof (state)\nthis:\n  P PROB\n  finite PROB\n  x \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "then"], ["proof (chain)\npicking this:\n  P PROB\n  finite PROB\n  x \\<in> MPLS_charles PROB", "obtain s as where a:\n      \"as \\<in> valid_plans PROB\" \"s \\<in> valid_states PROB\" \"x = Inf (PLS_charles s as PROB)\""], ["proof (prove)\nusing this:\n  P PROB\n  finite PROB\n  x \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. (\\<And>as s.\n        \\<lbrakk>as \\<in> valid_plans PROB; s \\<in> valid_states PROB;\n         x = Inf (PLS_charles s as PROB)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using x_in_MPLS_charles_then"], ["proof (prove)\nusing this:\n  P PROB\n  finite PROB\n  x \\<in> MPLS_charles PROB\n  ?x \\<in> MPLS_charles ?PROB \\<Longrightarrow>\n  \\<exists>s as.\n     s \\<in> valid_states ?PROB \\<and>\n     as \\<in> valid_plans ?PROB \\<and> ?x = Inf (PLS_charles s as ?PROB)\n\ngoal (1 subgoal):\n 1. (\\<And>as s.\n        \\<lbrakk>as \\<in> valid_plans PROB; s \\<in> valid_states PROB;\n         x = Inf (PLS_charles s as PROB)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  x = Inf (PLS_charles s as PROB)\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "then"], ["proof (chain)\npicking this:\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  x = Inf (PLS_charles s as PROB)", "have \"Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\""], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  x = Inf (PLS_charles s as PROB)\n\ngoal (1 subgoal):\n 1. Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "using 1 P1"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  x = Inf (PLS_charles s as PROB)\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n  P PROB\n  finite PROB\n  x \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "by blast"], ["proof (state)\nthis:\n  Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "then"], ["proof (chain)\npicking this:\n  Inf {n. n \\<in> PLS_charles s as PROB} < f PROB", "have \"x < f PROB\""], ["proof (prove)\nusing this:\n  Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n\ngoal (1 subgoal):\n 1. x < f PROB", "using a"], ["proof (prove)\nusing this:\n  Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n  as \\<in> valid_plans PROB\n  s \\<in> valid_states PROB\n  x = Inf (PLS_charles s as PROB)\n\ngoal (1 subgoal):\n 1. x < f PROB", "by simp"], ["proof (state)\nthis:\n  x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?x2 \\<in> MPLS_charles ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?x2 \\<in> MPLS_charles ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 < f ?PROB2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>PROB s as.\n     P PROB \\<and>\n     finite PROB \\<and>\n     as \\<in> valid_plans PROB \\<and>\n     s \\<in> valid_states PROB \\<longrightarrow>\n     Inf {n. n \\<in> PLS_charles s as PROB} < f PROB\n  \\<lbrakk>P ?PROB2; finite ?PROB2; ?x2 \\<in> MPLS_charles ?PROB2\\<rbrakk>\n  \\<Longrightarrow> ?x2 < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE added lemma (refactored from 'bound\\_on\\_all\\_plans\\_bounds\\_problem\\_plan\\_bound\\_charles').\\<close>"], ["", "lemma bound_on_all_plans_bounds_problem_plan_bound_charles_i: \n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"\\<forall>x \\<in> MPLS_charles PROB. x < k\"\n  shows \"Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB", "have 1: \"MPLS_charles PROB \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "using assms(1) bound_main_lemma_charles_3"], ["proof (prove)\nusing this:\n  finite PROB\n  finite ?PROB \\<Longrightarrow> MPLS_charles ?PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  MPLS_charles PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB", "then"], ["proof (chain)\npicking this:\n  MPLS_charles PROB \\<noteq> {}", "have \"finite (MPLS_charles PROB)\""], ["proof (prove)\nusing this:\n  MPLS_charles PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite (MPLS_charles PROB)", "using assms(2) finite_nat_set_iff_bounded"], ["proof (prove)\nusing this:\n  MPLS_charles PROB \\<noteq> {}\n  \\<forall>x\\<in>MPLS_charles PROB. x < k\n  finite ?N = (\\<exists>m. \\<forall>n\\<in>?N. n < m)\n\ngoal (1 subgoal):\n 1. finite (MPLS_charles PROB)", "by blast"], ["proof (state)\nthis:\n  finite (MPLS_charles PROB)\n\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB", "then"], ["proof (chain)\npicking this:\n  finite (MPLS_charles PROB)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (MPLS_charles PROB)\n\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB", "unfolding Sup_nat_def"], ["proof (prove)\nusing this:\n  finite (MPLS_charles PROB)\n\ngoal (1 subgoal):\n 1. (if MPLS_charles PROB = {} then 0 else Max (MPLS_charles PROB))\n    \\<in> MPLS_charles PROB", "using 1"], ["proof (prove)\nusing this:\n  finite (MPLS_charles PROB)\n  MPLS_charles PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (if MPLS_charles PROB = {} then 0 else Max (MPLS_charles PROB))\n    \\<in> MPLS_charles PROB", "by simp"], ["proof (state)\nthis:\n  Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bound_on_all_plans_bounds_problem_plan_bound_charles: \n  fixes P f\n  assumes \"(\\<forall>(PROB :: 'a problem) as s. \n    (P PROB) \\<and> finite PROB \\<and> (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (\\<exists>as'. \n      (exec_plan s as = exec_plan s as') \n      \\<and> (subseq as' as)\n      \\<and> (length as' < f PROB)))\n  \"\n  shows \"(\\<forall>PROB. \n    (P PROB) \\<and> finite PROB \\<longrightarrow> (problem_plan_bound_charles PROB < f PROB))\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "have 1: \"\\<forall>PROB x. P PROB \\<and> finite PROB \\<longrightarrow> x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "using assms bound_on_all_plans_bounds_MPLS_charles"], ["proof (prove)\nusing this:\n  \\<forall>PROB as s.\n     P PROB \\<and>\n     finite PROB \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n  \\<forall>PROB as s.\n     ?P PROB \\<and>\n     finite PROB \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < ?f PROB) \\<Longrightarrow>\n  \\<forall>PROB x.\n     ?P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS_charles PROB \\<longrightarrow> x < ?f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB x.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "moreover"], ["proof (state)\nthis:\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "{"], ["proof (state)\nthis:\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "fix PROB"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "assume P: \"P PROB\" \"finite PROB\""], ["proof (state)\nthis:\n  P PROB\n  finite PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "moreover"], ["proof (state)\nthis:\n  P PROB\n  finite PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "have 2: \"\\<forall>x. x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "using 1 P"], ["proof (prove)\nusing this:\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n  P PROB\n  finite PROB\n\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "moreover"], ["proof (state)\nthis:\n  \\<forall>x. x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "{"], ["proof (state)\nthis:\n  \\<forall>x. x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "assume P1: \"x \\<in> MPLS_charles PROB\""], ["proof (state)\nthis:\n  x \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "moreover"], ["proof (state)\nthis:\n  x \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "have \"x < f PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < f PROB", "using P(1, 2) P1 1"], ["proof (prove)\nusing this:\n  P PROB\n  finite PROB\n  x \\<in> MPLS_charles PROB\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n\ngoal (1 subgoal):\n 1. x < f PROB", "by presburger"], ["proof (state)\nthis:\n  x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "moreover"], ["proof (state)\nthis:\n  x < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "have \"MPLS_charles PROB \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "using P1"], ["proof (prove)\nusing this:\n  x \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. MPLS_charles PROB \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  MPLS_charles PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "moreover"], ["proof (state)\nthis:\n  MPLS_charles PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "have \"Sup (MPLS_charles PROB) < f PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) < f PROB", "using calculation(3) 2 bound_child_parent_not_eq_last_diff_paths[of \"MPLS_charles PROB\" \"f PROB\"]"], ["proof (prove)\nusing this:\n  MPLS_charles PROB \\<noteq> {}\n  \\<forall>x. x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n  \\<lbrakk>MPLS_charles PROB \\<noteq> {};\n   \\<forall>x.\n      x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\\<rbrakk>\n  \\<Longrightarrow> Sup (MPLS_charles PROB) < f PROB\n\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) < f PROB", "by blast"], ["proof (state)\nthis:\n  Sup (MPLS_charles PROB) < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> MPLS_charles PROB\n  x < f PROB\n  MPLS_charles PROB \\<noteq> {}\n  Sup (MPLS_charles PROB) < f PROB", "have \"(problem_plan_bound_charles PROB < f PROB)\""], ["proof (prove)\nusing this:\n  x \\<in> MPLS_charles PROB\n  x < f PROB\n  MPLS_charles PROB \\<noteq> {}\n  Sup (MPLS_charles PROB) < f PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB < f PROB", "unfolding problem_plan_bound_charles_def"], ["proof (prove)\nusing this:\n  x \\<in> MPLS_charles PROB\n  x < f PROB\n  MPLS_charles PROB \\<noteq> {}\n  Sup (MPLS_charles PROB) < f PROB\n\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) < f PROB", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound_charles PROB < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> MPLS_charles PROB \\<Longrightarrow>\n  problem_plan_bound_charles PROB < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "moreover"], ["proof (state)\nthis:\n  ?x2 \\<in> MPLS_charles PROB \\<Longrightarrow>\n  problem_plan_bound_charles PROB < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "have \"Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB", "using P(2) 2 bound_on_all_plans_bounds_problem_plan_bound_charles_i"], ["proof (prove)\nusing this:\n  finite PROB\n  \\<forall>x. x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n  \\<lbrakk>finite ?PROB; \\<forall>x\\<in>MPLS_charles ?PROB. x < ?k\\<rbrakk>\n  \\<Longrightarrow> Sup (MPLS_charles ?PROB) \\<in> MPLS_charles ?PROB\n\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB", "by blast"], ["proof (state)\nthis:\n  Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "ultimately"], ["proof (chain)\npicking this:\n  P PROB\n  finite PROB\n  \\<forall>x. x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n  ?x2 \\<in> MPLS_charles PROB \\<Longrightarrow>\n  problem_plan_bound_charles PROB < f PROB\n  Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB", "have \"problem_plan_bound_charles PROB < f PROB\""], ["proof (prove)\nusing this:\n  P PROB\n  finite PROB\n  \\<forall>x. x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n  ?x2 \\<in> MPLS_charles PROB \\<Longrightarrow>\n  problem_plan_bound_charles PROB < f PROB\n  Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB < f PROB", "unfolding problem_plan_bound_charles_def"], ["proof (prove)\nusing this:\n  P PROB\n  finite PROB\n  \\<forall>x. x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n  ?x2 \\<in> MPLS_charles PROB \\<Longrightarrow>\n  Sup (MPLS_charles PROB) < f PROB\n  Sup (MPLS_charles PROB) \\<in> MPLS_charles PROB\n\ngoal (1 subgoal):\n 1. Sup (MPLS_charles PROB) < f PROB", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound_charles PROB < f PROB\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P ?PROB2; finite ?PROB2\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound_charles ?PROB2 < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n  \\<lbrakk>P ?PROB2; finite ?PROB2\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound_charles ?PROB2 < f ?PROB2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>PROB x.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     x \\<in> MPLS_charles PROB \\<longrightarrow> x < f PROB\n  \\<lbrakk>P ?PROB2; finite ?PROB2\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound_charles ?PROB2 < f ?PROB2\n\ngoal (1 subgoal):\n 1. \\<forall>PROB.\n       P PROB \\<and> finite PROB \\<longrightarrow>\n       problem_plan_bound_charles PROB < f PROB", "by blast"], ["proof (state)\nthis:\n  \\<forall>PROB.\n     P PROB \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound_charles PROB < f PROB\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"The Relation between Diameter, Sublist Diameter and Recurrence Diameter Bounds.\""], ["", "text \\<open> The goal of this subsection is to verify the relation between diameter, sublist diameter\nand recurrence diameter bounds given by HOL4 Theorem 1, i.e.\n\n  @{term \"\\<d>(\\<delta>) \\<le> \\<l>(\\<delta>) \\<and> \\<l>(\\<delta>) \\<le> \\<r>\\<d>(\\<delta>)\"}\n\nwhere @{term \"\\<d>(\\<delta>)\"}, @{term \"\\<l>(\\<delta>)\"} and @{term \"\\<r>\\<d>(\\<delta>)\"} denote the diameter, sublist diameter and recurrence diameter bounds.\n[Abdualaziz et al., p.20]\n\nThe relevant lemmas are `sublistD\\_bounds\\_D` and `RD\\_bounds\\_sublistD` which culminate in \ntheorem `sublistD\\_bounds\\_D\\_and\\_RD\\_bounds\\_sublistD`. \\<close>"], ["", "lemma sublistD_bounds_D:  \n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\"\n  shows \"problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB", "proof -\n  \\<comment> \\<open>NOTE obtain the premise needed for MP of 'bound\\_on\\_all\\_plans\\_bounds\\_problem\\_plan\\_bound\\_charles'.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB", "fix PROB :: \"'a problem\" and s :: \"'a state\" and as"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB", "assume P: \"finite PROB\" \"s \\<in> valid_states PROB\" \"as \\<in> valid_plans PROB\""], ["proof (state)\nthis:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB", "then"], ["proof (chain)\npicking this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB", "have \"\\<exists>as'. \n      exec_plan s as = exec_plan s as' \\<and> subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB\n    \""], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "using problem_plan_bound_works"], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s ?as = exec_plan ?s as' \\<and>\n                       subseq as' ?as \\<and>\n                       length as' \\<le> problem_plan_bound ?PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB", "then"], ["proof (chain)\npicking this:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB", "have \"\\<exists>as'. \n      exec_plan s as = exec_plan s as' \\<and> subseq as' as \\<and> length as' < problem_plan_bound PROB + 1\n    \""], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' < problem_plan_bound PROB + 1", "by force"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < problem_plan_bound PROB + 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?PROBa2; ?s2 \\<in> valid_states ?PROBa2;\n   ?as2 \\<in> valid_plans ?PROBa2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as' < problem_plan_bound ?PROBa2 + 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?PROBa2; ?s2 \\<in> valid_states ?PROBa2;\n   ?as2 \\<in> valid_plans ?PROBa2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as' < problem_plan_bound ?PROBa2 + 1", "have \"problem_plan_bound_charles PROB < problem_plan_bound PROB + 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?PROBa2; ?s2 \\<in> valid_states ?PROBa2;\n   ?as2 \\<in> valid_plans ?PROBa2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as' < problem_plan_bound ?PROBa2 + 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB < problem_plan_bound PROB + 1", "using assms bound_on_all_plans_bounds_problem_plan_bound_charles[where f = \"\\<lambda>PROB. problem_plan_bound PROB + 1\"\n        and P = \"\\<lambda>_. True\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?PROBa2; ?s2 \\<in> valid_states ?PROBa2;\n   ?as2 \\<in> valid_plans ?PROBa2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as' < problem_plan_bound ?PROBa2 + 1\n  finite PROB\n  \\<forall>PROB as s.\n     True \\<and>\n     finite PROB \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and>\n         length as' < problem_plan_bound PROB + 1) \\<Longrightarrow>\n  \\<forall>PROB.\n     True \\<and> finite PROB \\<longrightarrow>\n     problem_plan_bound_charles PROB < problem_plan_bound PROB + 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB < problem_plan_bound PROB + 1", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound_charles PROB < problem_plan_bound PROB + 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB", "then"], ["proof (chain)\npicking this:\n  problem_plan_bound_charles PROB < problem_plan_bound PROB + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  problem_plan_bound_charles PROB < problem_plan_bound PROB + 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB", "by simp"], ["proof (state)\nthis:\n  problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE added lemma (this was adapted from pred\\_setScript.sml:4887 with exlusion of the premise for \nthe empty set since `Max {}` is undefined in Isabelle/HOL.)\\<close>"], ["", "lemma MAX_SET_ELIM':\n  fixes P Q\n  assumes \"finite P\" \"P \\<noteq> {}\" \"(\\<forall>x. (\\<forall>y. y \\<in> P \\<longrightarrow> y \\<le> x) \\<and> x \\<in> P \\<longrightarrow> R x)\"\n  shows \"R (Max P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (Max P)", "using assms"], ["proof (prove)\nusing this:\n  finite P\n  P \\<noteq> {}\n  \\<forall>x.\n     (\\<forall>y. y \\<in> P \\<longrightarrow> y \\<le> x) \\<and>\n     x \\<in> P \\<longrightarrow>\n     R x\n\ngoal (1 subgoal):\n 1. R (Max P)", "by force\n\n\\<comment> \\<open>NOTE added lemma.\\<close>\n\\<comment> \\<open>NOTE adapted from pred\\_setScript.sml:4895 (premise `finite P` was added).\\<close>"], ["", "lemma MIN_SET_ELIM':\n  fixes P Q\n  assumes \"finite P\" \"P \\<noteq> {}\" \"\\<forall>x. (\\<forall>y. y \\<in> P \\<longrightarrow> x \\<le> y) \\<and> x \\<in> P \\<longrightarrow> Q x\"\n  shows \"Q (Min P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (Min P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q (Min P)", "let ?x=\"Min P\""], ["proof (state)\ngoal (1 subgoal):\n 1. Q (Min P)", "have \"Min P \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min P \\<in> P", "using Min_in[OF assms(1) assms(2)]"], ["proof (prove)\nusing this:\n  Min P \\<in> P\n\ngoal (1 subgoal):\n 1. Min P \\<in> P", "by simp"], ["proof (state)\nthis:\n  Min P \\<in> P\n\ngoal (1 subgoal):\n 1. Q (Min P)", "moreover"], ["proof (state)\nthis:\n  Min P \\<in> P\n\ngoal (1 subgoal):\n 1. Q (Min P)", "{"], ["proof (state)\nthis:\n  Min P \\<in> P\n\ngoal (1 subgoal):\n 1. Q (Min P)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. Q (Min P)", "assume P: \"y \\<in> P\""], ["proof (state)\nthis:\n  y \\<in> P\n\ngoal (1 subgoal):\n 1. Q (Min P)", "then"], ["proof (chain)\npicking this:\n  y \\<in> P", "have \"?x \\<le> y\""], ["proof (prove)\nusing this:\n  y \\<in> P\n\ngoal (1 subgoal):\n 1. Min P \\<le> y", "using Min.coboundedI[OF assms(1)]"], ["proof (prove)\nusing this:\n  y \\<in> P\n  ?a \\<in> P \\<Longrightarrow> Min P \\<le> ?a\n\ngoal (1 subgoal):\n 1. Min P \\<le> y", "by blast"], ["proof (state)\nthis:\n  Min P \\<le> y\n\ngoal (1 subgoal):\n 1. Q (Min P)", "then"], ["proof (chain)\npicking this:\n  Min P \\<le> y", "have \"Q ?x\""], ["proof (prove)\nusing this:\n  Min P \\<le> y\n\ngoal (1 subgoal):\n 1. Q (Min P)", "using P assms"], ["proof (prove)\nusing this:\n  Min P \\<le> y\n  y \\<in> P\n  finite P\n  P \\<noteq> {}\n  \\<forall>x.\n     (\\<forall>y. y \\<in> P \\<longrightarrow> x \\<le> y) \\<and>\n     x \\<in> P \\<longrightarrow>\n     Q x\n\ngoal (1 subgoal):\n 1. Q (Min P)", "by auto"], ["proof (state)\nthis:\n  Q (Min P)\n\ngoal (1 subgoal):\n 1. Q (Min P)", "}"], ["proof (state)\nthis:\n  ?y2 \\<in> P \\<Longrightarrow> Q (Min P)\n\ngoal (1 subgoal):\n 1. Q (Min P)", "ultimately"], ["proof (chain)\npicking this:\n  Min P \\<in> P\n  ?y2 \\<in> P \\<Longrightarrow> Q (Min P)", "show ?thesis"], ["proof (prove)\nusing this:\n  Min P \\<in> P\n  ?y2 \\<in> P \\<Longrightarrow> Q (Min P)\n\ngoal (1 subgoal):\n 1. Q (Min P)", "by blast"], ["proof (state)\nthis:\n  Q (Min P)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>NOTE added lemma (refactored from `RD\\_bounds\\_sublistD`).\\<close>"], ["", "lemma RD_bounds_sublistD_i_a:\n  fixes Pi :: \"'a problem\" \n  assumes \"finite Pi\"\n  shows \"finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?ss=\"{length p - 1 |p. valid_path Pi p \\<and> distinct p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?ss'=\"{p. valid_path Pi p \\<and> distinct p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have 1: \"?ss = (\\<lambda>x. length x - 1) ` ?ss'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} =\n    (\\<lambda>x. length x - 1) ` {p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  {length p - 1 |p. valid_path Pi p \\<and> distinct p} =\n  (\\<lambda>x. length x - 1) ` {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{\n      \\<comment> \\<open>NOTE type of `valid\\_states Pi` had to be asserted to match `FINITE\\_valid\\_states`.\\<close>"], ["proof (state)\nthis:\n  {length p - 1 |p. valid_path Pi p \\<and> distinct p} =\n  (\\<lambda>x. length x - 1) ` {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?S=\"{p. distinct p \\<and> set p \\<subseteq> (valid_states Pi :: 'a state set)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from assms"], ["proof (chain)\npicking this:\n  finite Pi", "have \"finite (valid_states Pi :: 'a state set)\""], ["proof (prove)\nusing this:\n  finite Pi\n\ngoal (1 subgoal):\n 1. finite (valid_states Pi)", "using FINITE_valid_states[of Pi]"], ["proof (prove)\nusing this:\n  finite Pi\n  finite Pi \\<Longrightarrow> finite (valid_states Pi)\n\ngoal (1 subgoal):\n 1. finite (valid_states Pi)", "by simp"], ["proof (state)\nthis:\n  finite (valid_states Pi)\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  finite (valid_states Pi)", "have \"finite ?S\""], ["proof (prove)\nusing this:\n  finite (valid_states Pi)\n\ngoal (1 subgoal):\n 1. finite {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}", "using FINITE_ALL_DISTINCT_LISTS"], ["proof (prove)\nusing this:\n  finite (valid_states Pi)\n  finite ?P \\<Longrightarrow>\n  finite {p. distinct p \\<and> set p \\<subseteq> ?P}\n\ngoal (1 subgoal):\n 1. finite {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}", "by blast"], ["proof (state)\nthis:\n  finite {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  finite {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "moreover"], ["proof (state)\nthis:\n  finite {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  finite {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  finite {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "assume \"x \\<in> ?ss'\""], ["proof (state)\nthis:\n  x \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  x \\<in> {p. valid_path Pi p \\<and> distinct p}", "have \"x \\<in> ?S\""], ["proof (prove)\nusing this:\n  x \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. x \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}", "proof (induction x)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n    [] \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n 2. \\<And>a x.\n       \\<lbrakk>x \\<in> {p. valid_path Pi p \\<and>\n                            distinct p} \\<Longrightarrow>\n                x \\<in> {p. distinct p \\<and>\n                            set p \\<subseteq> valid_states Pi};\n        a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\\<rbrakk>\n       \\<Longrightarrow> a # x\n                         \\<in> {p. distinct p \\<and>\n                                   set p \\<subseteq> valid_states Pi}", "case (Cons a x)"], ["proof (state)\nthis:\n  x \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n  x \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n  a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (2 subgoals):\n 1. [] \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n    [] \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n 2. \\<And>a x.\n       \\<lbrakk>x \\<in> {p. valid_path Pi p \\<and>\n                            distinct p} \\<Longrightarrow>\n                x \\<in> {p. distinct p \\<and>\n                            set p \\<subseteq> valid_states Pi};\n        a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\\<rbrakk>\n       \\<Longrightarrow> a # x\n                         \\<in> {p. distinct p \\<and>\n                                   set p \\<subseteq> valid_states Pi}", "then"], ["proof (chain)\npicking this:\n  x \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n  x \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n  a # x \\<in> {p. valid_path Pi p \\<and> distinct p}", "have a: \"valid_path Pi (a # x)\" \"distinct (a # x)\""], ["proof (prove)\nusing this:\n  x \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n  x \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n  a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. valid_path Pi (a # x) &&& distinct (a # x)", "by blast+"], ["proof (state)\nthis:\n  valid_path Pi (a # x)\n  distinct (a # x)\n\ngoal (2 subgoals):\n 1. [] \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n    [] \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n 2. \\<And>a x.\n       \\<lbrakk>x \\<in> {p. valid_path Pi p \\<and>\n                            distinct p} \\<Longrightarrow>\n                x \\<in> {p. distinct p \\<and>\n                            set p \\<subseteq> valid_states Pi};\n        a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\\<rbrakk>\n       \\<Longrightarrow> a # x\n                         \\<in> {p. distinct p \\<and>\n                                   set p \\<subseteq> valid_states Pi}", "moreover"], ["proof (state)\nthis:\n  valid_path Pi (a # x)\n  distinct (a # x)\n\ngoal (2 subgoals):\n 1. [] \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n    [] \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n 2. \\<And>a x.\n       \\<lbrakk>x \\<in> {p. valid_path Pi p \\<and>\n                            distinct p} \\<Longrightarrow>\n                x \\<in> {p. distinct p \\<and>\n                            set p \\<subseteq> valid_states Pi};\n        a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\\<rbrakk>\n       \\<Longrightarrow> a # x\n                         \\<in> {p. distinct p \\<and>\n                                   set p \\<subseteq> valid_states Pi}", "{"], ["proof (state)\nthis:\n  valid_path Pi (a # x)\n  distinct (a # x)\n\ngoal (2 subgoals):\n 1. [] \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n    [] \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n 2. \\<And>a x.\n       \\<lbrakk>x \\<in> {p. valid_path Pi p \\<and>\n                            distinct p} \\<Longrightarrow>\n                x \\<in> {p. distinct p \\<and>\n                            set p \\<subseteq> valid_states Pi};\n        a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\\<rbrakk>\n       \\<Longrightarrow> a # x\n                         \\<in> {p. distinct p \\<and>\n                                   set p \\<subseteq> valid_states Pi}", "fix x'"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n    [] \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n 2. \\<And>a x.\n       \\<lbrakk>x \\<in> {p. valid_path Pi p \\<and>\n                            distinct p} \\<Longrightarrow>\n                x \\<in> {p. distinct p \\<and>\n                            set p \\<subseteq> valid_states Pi};\n        a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\\<rbrakk>\n       \\<Longrightarrow> a # x\n                         \\<in> {p. distinct p \\<and>\n                                   set p \\<subseteq> valid_states Pi}", "assume P: \"x' \\<in> set (a # x)\""], ["proof (state)\nthis:\n  x' \\<in> set (a # x)\n\ngoal (2 subgoals):\n 1. [] \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n    [] \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n 2. \\<And>a x.\n       \\<lbrakk>x \\<in> {p. valid_path Pi p \\<and>\n                            distinct p} \\<Longrightarrow>\n                x \\<in> {p. distinct p \\<and>\n                            set p \\<subseteq> valid_states Pi};\n        a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\\<rbrakk>\n       \\<Longrightarrow> a # x\n                         \\<in> {p. distinct p \\<and>\n                                   set p \\<subseteq> valid_states Pi}", "then"], ["proof (chain)\npicking this:\n  x' \\<in> set (a # x)", "have \"x' \\<in> valid_states Pi\""], ["proof (prove)\nusing this:\n  x' \\<in> set (a # x)\n\ngoal (1 subgoal):\n 1. x' \\<in> valid_states Pi", "proof (cases \"x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<in> set (a # x); x = []\\<rbrakk>\n    \\<Longrightarrow> x' \\<in> valid_states Pi\n 2. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "case Nil"], ["proof (state)\nthis:\n  x = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<in> set (a # x); x = []\\<rbrakk>\n    \\<Longrightarrow> x' \\<in> valid_states Pi\n 2. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "from a(1) Nil"], ["proof (chain)\npicking this:\n  valid_path Pi (a # x)\n  x = []", "have \"a \\<in> valid_states Pi\""], ["proof (prove)\nusing this:\n  valid_path Pi (a # x)\n  x = []\n\ngoal (1 subgoal):\n 1. a \\<in> valid_states Pi", "by simp"], ["proof (state)\nthis:\n  a \\<in> valid_states Pi\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<in> set (a # x); x = []\\<rbrakk>\n    \\<Longrightarrow> x' \\<in> valid_states Pi\n 2. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "moreover"], ["proof (state)\nthis:\n  a \\<in> valid_states Pi\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<in> set (a # x); x = []\\<rbrakk>\n    \\<Longrightarrow> x' \\<in> valid_states Pi\n 2. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "from P Nil"], ["proof (chain)\npicking this:\n  x' \\<in> set (a # x)\n  x = []", "have \"x' = a\""], ["proof (prove)\nusing this:\n  x' \\<in> set (a # x)\n  x = []\n\ngoal (1 subgoal):\n 1. x' = a", "by force"], ["proof (state)\nthis:\n  x' = a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<in> set (a # x); x = []\\<rbrakk>\n    \\<Longrightarrow> x' \\<in> valid_states Pi\n 2. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> valid_states Pi\n  x' = a", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> valid_states Pi\n  x' = a\n\ngoal (1 subgoal):\n 1. x' \\<in> valid_states Pi", "by simp"], ["proof (state)\nthis:\n  x' \\<in> valid_states Pi\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "case (Cons a' list)"], ["proof (state)\nthis:\n  x = a' # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "{"], ["proof (state)\nthis:\n  x = a' # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "{"], ["proof (state)\nthis:\n  x = a' # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "from Cons.prems"], ["proof (chain)\npicking this:\n  a # x \\<in> {p. valid_path Pi p \\<and> distinct p}", "have \"valid_path Pi (a # x)\""], ["proof (prove)\nusing this:\n  a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. valid_path Pi (a # x)", "by simp"], ["proof (state)\nthis:\n  valid_path Pi (a # x)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "then"], ["proof (chain)\npicking this:\n  valid_path Pi (a # x)", "have \"a \\<in> valid_states Pi\" \"valid_path Pi (a' # list)\""], ["proof (prove)\nusing this:\n  valid_path Pi (a # x)\n\ngoal (1 subgoal):\n 1. a \\<in> valid_states Pi &&& valid_path Pi (a' # list)", "using Cons"], ["proof (prove)\nusing this:\n  valid_path Pi (a # x)\n  x = a' # list\n\ngoal (1 subgoal):\n 1. a \\<in> valid_states Pi &&& valid_path Pi (a' # list)", "by fastforce+"], ["proof (state)\nthis:\n  a \\<in> valid_states Pi\n  valid_path Pi (a' # list)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "}"], ["proof (state)\nthis:\n  a \\<in> valid_states Pi\n  valid_path Pi (a' # list)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "note a = this"], ["proof (state)\nthis:\n  a \\<in> valid_states Pi\n  valid_path Pi (a' # list)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "moreover"], ["proof (state)\nthis:\n  a \\<in> valid_states Pi\n  valid_path Pi (a' # list)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "{"], ["proof (state)\nthis:\n  a \\<in> valid_states Pi\n  valid_path Pi (a' # list)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "from Cons.prems"], ["proof (chain)\npicking this:\n  a # x \\<in> {p. valid_path Pi p \\<and> distinct p}", "have \"distinct (a # x)\""], ["proof (prove)\nusing this:\n  a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. distinct (a # x)", "by blast"], ["proof (state)\nthis:\n  distinct (a # x)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "then"], ["proof (chain)\npicking this:\n  distinct (a # x)", "have \"distinct (a' # list)\""], ["proof (prove)\nusing this:\n  distinct (a # x)\n\ngoal (1 subgoal):\n 1. distinct (a' # list)", "using Cons"], ["proof (prove)\nusing this:\n  distinct (a # x)\n  x = a' # list\n\ngoal (1 subgoal):\n 1. distinct (a' # list)", "by simp"], ["proof (state)\nthis:\n  distinct (a' # list)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "}"], ["proof (state)\nthis:\n  distinct (a' # list)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> valid_states Pi\n  valid_path Pi (a' # list)\n  distinct (a' # list)", "have \"(a' # list) \\<in> ?ss'\""], ["proof (prove)\nusing this:\n  a \\<in> valid_states Pi\n  valid_path Pi (a' # list)\n  distinct (a' # list)\n\ngoal (1 subgoal):\n 1. a' # list \\<in> {p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  a' # list \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "then"], ["proof (chain)\npicking this:\n  a' # list \\<in> {p. valid_path Pi p \\<and> distinct p}", "have \"(a' # list) \\<in> ?S\""], ["proof (prove)\nusing this:\n  a' # list \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. a' # list \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}", "using Cons Cons.IH"], ["proof (prove)\nusing this:\n  a' # list \\<in> {p. valid_path Pi p \\<and> distinct p}\n  x = a' # list\n  x \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n  x \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. a' # list \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}", "by argo"], ["proof (state)\nthis:\n  a' # list \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "}"], ["proof (state)\nthis:\n  a' # list \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x' \\<in> set (a # x); x = aa # list\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> valid_states Pi", "then"], ["proof (chain)\npicking this:\n  a' # list \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}", "show ?thesis"], ["proof (prove)\nusing this:\n  a' # list \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. x' \\<in> valid_states Pi", "using P a(1) local.Cons set_ConsD"], ["proof (prove)\nusing this:\n  a' # list \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n  x' \\<in> set (a # x)\n  valid_path Pi (a # x)\n  x = a' # list\n  ?y \\<in> set (?x # ?xs) \\<Longrightarrow> ?y = ?x \\<or> ?y \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. x' \\<in> valid_states Pi", "by fastforce"], ["proof (state)\nthis:\n  x' \\<in> valid_states Pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x' \\<in> valid_states Pi\n\ngoal (2 subgoals):\n 1. [] \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n    [] \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n 2. \\<And>a x.\n       \\<lbrakk>x \\<in> {p. valid_path Pi p \\<and>\n                            distinct p} \\<Longrightarrow>\n                x \\<in> {p. distinct p \\<and>\n                            set p \\<subseteq> valid_states Pi};\n        a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\\<rbrakk>\n       \\<Longrightarrow> a # x\n                         \\<in> {p. distinct p \\<and>\n                                   set p \\<subseteq> valid_states Pi}", "}"], ["proof (state)\nthis:\n  ?x'2 \\<in> set (a # x) \\<Longrightarrow> ?x'2 \\<in> valid_states Pi\n\ngoal (2 subgoals):\n 1. [] \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n    [] \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n 2. \\<And>a x.\n       \\<lbrakk>x \\<in> {p. valid_path Pi p \\<and>\n                            distinct p} \\<Longrightarrow>\n                x \\<in> {p. distinct p \\<and>\n                            set p \\<subseteq> valid_states Pi};\n        a # x \\<in> {p. valid_path Pi p \\<and> distinct p}\\<rbrakk>\n       \\<Longrightarrow> a # x\n                         \\<in> {p. distinct p \\<and>\n                                   set p \\<subseteq> valid_states Pi}", "ultimately"], ["proof (chain)\npicking this:\n  valid_path Pi (a # x)\n  distinct (a # x)\n  ?x'2 \\<in> set (a # x) \\<Longrightarrow> ?x'2 \\<in> valid_states Pi", "show ?case"], ["proof (prove)\nusing this:\n  valid_path Pi (a # x)\n  distinct (a # x)\n  ?x'2 \\<in> set (a # x) \\<Longrightarrow> ?x'2 \\<in> valid_states Pi\n\ngoal (1 subgoal):\n 1. a # x \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}", "by blast"], ["proof (state)\nthis:\n  a # x \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. [] \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n    [] \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}", "qed simp"], ["proof (state)\nthis:\n  x \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n  ?x2 \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  ?x2 \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n  ?x2 \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}", "have \"?ss' \\<subseteq> ?S\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> {p. valid_path Pi p \\<and> distinct p} \\<Longrightarrow>\n  ?x2 \\<in> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. {p. valid_path Pi p \\<and> distinct p}\n    \\<subseteq> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}", "by blast"], ["proof (state)\nthis:\n  {p. valid_path Pi p \\<and> distinct p}\n  \\<subseteq> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  {p. valid_path Pi p \\<and> distinct p}\n  \\<subseteq> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "ultimately"], ["proof (chain)\npicking this:\n  finite {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n  {p. valid_path Pi p \\<and> distinct p}\n  \\<subseteq> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}", "have \"finite ?ss'\""], ["proof (prove)\nusing this:\n  finite {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n  {p. valid_path Pi p \\<and> distinct p}\n  \\<subseteq> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n\ngoal (1 subgoal):\n 1. finite {p. valid_path Pi p \\<and> distinct p}", "using rev_finite_subset"], ["proof (prove)\nusing this:\n  finite {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n  {p. valid_path Pi p \\<and> distinct p}\n  \\<subseteq> {p. distinct p \\<and> set p \\<subseteq> valid_states Pi}\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite {p. valid_path Pi p \\<and> distinct p}", "by auto"], ["proof (state)\nthis:\n  finite {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  finite {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "note 2 = this"], ["proof (state)\nthis:\n  finite {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from 1 2"], ["proof (chain)\npicking this:\n  {length p - 1 |p. valid_path Pi p \\<and> distinct p} =\n  (\\<lambda>x. length x - 1) ` {p. valid_path Pi p \\<and> distinct p}\n  finite {p. valid_path Pi p \\<and> distinct p}", "have \"finite ?ss\""], ["proof (prove)\nusing this:\n  {length p - 1 |p. valid_path Pi p \\<and> distinct p} =\n  (\\<lambda>x. length x - 1) ` {p. valid_path Pi p \\<and> distinct p}\n  finite {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "using finite_imageI"], ["proof (prove)\nusing this:\n  {length p - 1 |p. valid_path Pi p \\<and> distinct p} =\n  (\\<lambda>x. length x - 1) ` {p. valid_path Pi p \\<and> distinct p}\n  finite {p. valid_path Pi p \\<and> distinct p}\n  finite ?F \\<Longrightarrow> finite (?h ` ?F)\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by auto"], ["proof (state)\nthis:\n  finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>NOTE added lemma (refactored from `RD\\_bounds\\_sublistD`).\\<close>"], ["", "lemma RD_bounds_sublistD_i_b:\n  fixes Pi :: \"'a problem\" \n  shows \"{length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "let ?Q=\"{length p - 1 |p. valid_path Pi p \\<and> distinct p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "let ?Q'=\"{p. valid_path Pi p \\<and> distinct p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "have \"valid_path Pi []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path Pi []", "by simp"], ["proof (state)\nthis:\n  valid_path Pi []\n\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  valid_path Pi []\n\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "have \"distinct []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct []", "by simp"], ["proof (state)\nthis:\n  distinct []\n\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  valid_path Pi []\n  distinct []", "have \"[] \\<in> ?Q'\""], ["proof (prove)\nusing this:\n  valid_path Pi []\n  distinct []\n\ngoal (1 subgoal):\n 1. [] \\<in> {p. valid_path Pi p \\<and> distinct p}", "by simp"], ["proof (state)\nthis:\n  [] \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "}"], ["proof (state)\nthis:\n  [] \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "note 1 = this"], ["proof (state)\nthis:\n  [] \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "have \"?Q = (\\<lambda>p. length p - 1) ` ?Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} =\n    (\\<lambda>p. length p - 1) ` {p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  {length p - 1 |p. valid_path Pi p \\<and> distinct p} =\n  (\\<lambda>p. length p - 1) ` {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  {length p - 1 |p. valid_path Pi p \\<and> distinct p} =\n  (\\<lambda>p. length p - 1) ` {p. valid_path Pi p \\<and> distinct p}", "have \"length [] - 1 \\<in> ?Q\""], ["proof (prove)\nusing this:\n  {length p - 1 |p. valid_path Pi p \\<and> distinct p} =\n  (\\<lambda>p. length p - 1) ` {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. length [] - 1 \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "using 1"], ["proof (prove)\nusing this:\n  {length p - 1 |p. valid_path Pi p \\<and> distinct p} =\n  (\\<lambda>p. length p - 1) ` {p. valid_path Pi p \\<and> distinct p}\n  [] \\<in> {p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. length [] - 1 \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by (metis (mono_tags, lifting) image_iff list.size(3))"], ["proof (state)\nthis:\n  length [] - 1 \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  length [] - 1 \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "show ?thesis"], ["proof (prove)\nusing this:\n  length [] - 1 \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>NOTE added lemma (refactored from `RD\\_bounds\\_sublistD`).\\<close>"], ["", "lemma RD_bounds_sublistD_i_c:\n  fixes Pi :: \"'a problem\" and as :: \"(('a, bool) fmap \\<times> ('a, bool) fmap) list\" and x \n    and s :: \"('a, bool) fmap\" \n  assumes \"s \\<in> valid_states Pi\" \"as \\<in> valid_plans Pi\" \n    \"(\\<forall>y. y \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<longrightarrow> y \\<le> x)\" \n    \"x \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}\"\n  shows \"Min (PLS s as) \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?P=\"(PLS s as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?Q=\"{length p - 1 |p. valid_path Pi p \\<and> distinct p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from assms(4)"], ["proof (chain)\npicking this:\n  x \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "obtain p where 1:\n    \"x = length p - 1\" \"valid_path Pi p\" \"distinct p\""], ["proof (prove)\nusing this:\n  x \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>x = length p - 1; valid_path Pi p; distinct p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = length p - 1\n  valid_path Pi p\n  distinct p\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  x = length p - 1\n  valid_path Pi p\n  distinct p\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "fix p'"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "assume \"valid_path Pi p'\" \"distinct p'\""], ["proof (state)\nthis:\n  valid_path Pi p'\n  distinct p'\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  valid_path Pi p'\n  distinct p'", "obtain y where \"y \\<in> ?Q\" \"y = length p' - 1\""], ["proof (prove)\nusing this:\n  valid_path Pi p'\n  distinct p'\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> {length p - 1 |p.\n                          valid_path Pi p \\<and> distinct p};\n         y = length p' - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n        \\<comment> \\<open>NOTE we cannot infer @{term \"length p' - 1 \\<le> length p - 1\"} since `length p' = 0` might be true.\\<close>"], ["proof (state)\nthis:\n  y \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n  y = length p' - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  y \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n  y = length p' - 1", "have a: \"length p' - 1 \\<le> length p - 1\""], ["proof (prove)\nusing this:\n  y \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n  y = length p' - 1\n\ngoal (1 subgoal):\n 1. length p' - 1 \\<le> length p - 1", "using assms(3) 1(1)"], ["proof (prove)\nusing this:\n  y \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n  y = length p' - 1\n  \\<forall>y.\n     y \\<in> {length p - 1 |p.\n              valid_path Pi p \\<and> distinct p} \\<longrightarrow>\n     y \\<le> x\n  x = length p - 1\n\ngoal (1 subgoal):\n 1. length p' - 1 \\<le> length p - 1", "by meson"], ["proof (state)\nthis:\n  length p' - 1 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>valid_path Pi ?p'2; distinct ?p'2\\<rbrakk>\n  \\<Longrightarrow> length ?p'2 - 1 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "note 2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>valid_path Pi ?p'2; distinct ?p'2\\<rbrakk>\n  \\<Longrightarrow> length ?p'2 - 1 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>valid_path Pi ?p'2; distinct ?p'2\\<rbrakk>\n  \\<Longrightarrow> length ?p'2 - 1 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from finite_PLS PLS_NEMPTY"], ["proof (chain)\npicking this:\n  finite (PLS ?s ?as)\n  PLS ?s ?as \\<noteq> {}", "have \"finite (PLS s as)\" \"PLS s as \\<noteq> {}\""], ["proof (prove)\nusing this:\n  finite (PLS ?s ?as)\n  PLS ?s ?as \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite (PLS s as) &&& PLS s as \\<noteq> {}", "by blast+"], ["proof (state)\nthis:\n  finite (PLS s as)\n  PLS s as \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "moreover"], ["proof (state)\nthis:\n  finite (PLS s as)\n  PLS s as \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  finite (PLS s as)\n  PLS s as \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "assume P: \"(\\<forall>y. y \\<in> PLS s as \\<longrightarrow> n \\<le> y)\" \"n \\<in> PLS s as\""], ["proof (state)\nthis:\n  \\<forall>y. y \\<in> PLS s as \\<longrightarrow> n \\<le> y\n  n \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from P(2)"], ["proof (chain)\npicking this:\n  n \\<in> PLS s as", "obtain as' where i: \n        \"n = length as'\" \"exec_plan s as' = exec_plan s as\" \"subseq as' as\""], ["proof (prove)\nusing this:\n  n \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>n = length as'; exec_plan s as' = exec_plan s as;\n         subseq as' as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding PLS_def"], ["proof (prove)\nusing this:\n  n \\<in> length `\n          {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>n = length as'; exec_plan s as' = exec_plan s as;\n         subseq as' as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = length as'\n  exec_plan s as' = exec_plan s as\n  subseq as' as\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?p'=\"statelist' s as'\""], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have \"length as' = length ?p' - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as' = length (statelist' s as') - 1", "by (simp add: LENGTH_statelist')        \n            \\<comment> \\<open>MARKER (topologicalPropsScript.sml:195)\\<close>"], ["proof (state)\nthis:\n  length as' = length (statelist' s as') - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have \"1 + (length p - 1) = length p - 1 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + (length p - 1) = length p - 1 + 1", "by presburger\n            \\<comment> \\<open>MARKER (topologicalPropsScript.sml:200)\\<close>"], ["proof (state)\nthis:\n  1 + (length p - 1) = length p - 1 + 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  1 + (length p - 1) = length p - 1 + 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from assms(2) i(3) sublist_valid_plan"], ["proof (chain)\npicking this:\n  as \\<in> valid_plans Pi\n  subseq as' as\n  \\<lbrakk>subseq ?as' ?as; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?as' \\<in> valid_plans ?PROB", "have \"as' \\<in> valid_plans Pi\""], ["proof (prove)\nusing this:\n  as \\<in> valid_plans Pi\n  subseq as' as\n  \\<lbrakk>subseq ?as' ?as; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?as' \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. as' \\<in> valid_plans Pi", "by blast"], ["proof (state)\nthis:\n  as' \\<in> valid_plans Pi\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  as' \\<in> valid_plans Pi", "have \"valid_path Pi ?p'\""], ["proof (prove)\nusing this:\n  as' \\<in> valid_plans Pi\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s as')", "using assms(1) valid_path_statelist'"], ["proof (prove)\nusing this:\n  as' \\<in> valid_plans Pi\n  s \\<in> valid_states Pi\n  \\<lbrakk>?as \\<in> valid_plans ?Pi; ?s \\<in> valid_states ?Pi\\<rbrakk>\n  \\<Longrightarrow> valid_path ?Pi (statelist' ?s ?as)\n\ngoal (1 subgoal):\n 1. valid_path Pi (statelist' s as')", "by auto"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "moreover"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  valid_path Pi (statelist' s as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "assume C: \"\\<not>distinct ?p'\"\n              \\<comment> \\<open>NOTE renamed variable `drop` to `drop'` to avoid shadowing of the function by the \n            same name in Isabelle/HOL.\\<close>"], ["proof (state)\nthis:\n  \\<not> distinct (statelist' s as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct (statelist' s as')", "obtain rs pfx drop' tail where C_1: \"?p' = pfx @ [rs] @ drop' @ [rs] @ tail\""], ["proof (prove)\nusing this:\n  \\<not> distinct (statelist' s as')\n\ngoal (1 subgoal):\n 1. (\\<And>pfx rs drop' tail.\n        statelist' s as' =\n        pfx @ [rs] @ drop' @ [rs] @ tail \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using not_distinct_decomp[OF C]"], ["proof (prove)\nusing this:\n  \\<not> distinct (statelist' s as')\n  \\<exists>xs ys zs y. statelist' s as' = xs @ [y] @ ys @ [y] @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>pfx rs drop' tail.\n        statelist' s as' =\n        pfx @ [rs] @ drop' @ [rs] @ tail \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  statelist' s as' = pfx @ [rs] @ drop' @ [rs] @ tail\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?pfxn=\"length pfx\""], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have C_2: \"?p' ! ?pfxn = rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. statelist' s as' ! length pfx = rs", "by (simp add: C_1)"], ["proof (state)\nthis:\n  statelist' s as' ! length pfx = rs\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from LENGTH_statelist'"], ["proof (chain)\npicking this:\n  length (statelist' ?s ?as) = length ?as + 1", "have C_3: \"length as' + 1 = length ?p'\""], ["proof (prove)\nusing this:\n  length (statelist' ?s ?as) = length ?as + 1\n\ngoal (1 subgoal):\n 1. length as' + 1 = length (statelist' s as')", "by metis"], ["proof (state)\nthis:\n  length as' + 1 = length (statelist' s as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  length as' + 1 = length (statelist' s as')", "have \"?pfxn \\<le> length as'\""], ["proof (prove)\nusing this:\n  length as' + 1 = length (statelist' s as')\n\ngoal (1 subgoal):\n 1. length pfx \\<le> length as'", "using C_1"], ["proof (prove)\nusing this:\n  length as' + 1 = length (statelist' s as')\n  statelist' s as' = pfx @ [rs] @ drop' @ [rs] @ tail\n\ngoal (1 subgoal):\n 1. length pfx \\<le> length as'", "by fastforce"], ["proof (state)\nthis:\n  length pfx \\<le> length as'\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  length pfx \\<le> length as'", "have C_4: \"exec_plan s (take ?pfxn as') = rs\""], ["proof (prove)\nusing this:\n  length pfx \\<le> length as'\n\ngoal (1 subgoal):\n 1. exec_plan s (take (length pfx) as') = rs", "using C_2 statelist'_TAKE"], ["proof (prove)\nusing this:\n  length pfx \\<le> length as'\n  statelist' s as' ! length pfx = rs\n  statelist' ?s ?as = ?p \\<Longrightarrow>\n  \\<forall>n\\<le>length ?as. exec_plan ?s (take n ?as) = ?p ! n\n\ngoal (1 subgoal):\n 1. exec_plan s (take (length pfx) as') = rs", "by blast"], ["proof (state)\nthis:\n  exec_plan s (take (length pfx) as') = rs\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?prsd = \"length (pfx @ [rs] @ drop')\""], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?ap1 = \"take ?pfxn as'\" \n              \\<comment> \\<open>MARKER (topologicalPropsScript.sml:215)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from C_1"], ["proof (chain)\npicking this:\n  statelist' s as' = pfx @ [rs] @ drop' @ [rs] @ tail", "have C_5: \"?p' ! ?prsd = rs\""], ["proof (prove)\nusing this:\n  statelist' s as' = pfx @ [rs] @ drop' @ [rs] @ tail\n\ngoal (1 subgoal):\n 1. statelist' s as' ! length (pfx @ [rs] @ drop') = rs", "by (metis append_Cons length_append nth_append_length nth_append_length_plus)"], ["proof (state)\nthis:\n  statelist' s as' ! length (pfx @ [rs] @ drop') = rs\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from C_1 C_3"], ["proof (chain)\npicking this:\n  statelist' s as' = pfx @ [rs] @ drop' @ [rs] @ tail\n  length as' + 1 = length (statelist' s as')", "have C_6: \"?prsd \\<le> length as'\""], ["proof (prove)\nusing this:\n  statelist' s as' = pfx @ [rs] @ drop' @ [rs] @ tail\n  length as' + 1 = length (statelist' s as')\n\ngoal (1 subgoal):\n 1. length (pfx @ [rs] @ drop') \\<le> length as'", "by simp"], ["proof (state)\nthis:\n  length (pfx @ [rs] @ drop') \\<le> length as'\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  length (pfx @ [rs] @ drop') \\<le> length as'", "have C_7: \"exec_plan s (take ?prsd as') = rs\""], ["proof (prove)\nusing this:\n  length (pfx @ [rs] @ drop') \\<le> length as'\n\ngoal (1 subgoal):\n 1. exec_plan s (take (length (pfx @ [rs] @ drop')) as') = rs", "using C_5 statelist'_TAKE"], ["proof (prove)\nusing this:\n  length (pfx @ [rs] @ drop') \\<le> length as'\n  statelist' s as' ! length (pfx @ [rs] @ drop') = rs\n  statelist' ?s ?as = ?p \\<Longrightarrow>\n  \\<forall>n\\<le>length ?as. exec_plan ?s (take n ?as) = ?p ! n\n\ngoal (1 subgoal):\n 1. exec_plan s (take (length (pfx @ [rs] @ drop')) as') = rs", "by auto"], ["proof (state)\nthis:\n  exec_plan s (take (length (pfx @ [rs] @ drop')) as') = rs\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?ap2=\"take ?prsd as'\""], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?asfx=\"drop ?prsd as'\""], ["proof (state)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have C_8: \"as' = ?ap2 @ ?asfx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as' =\n    take (length (pfx @ [rs] @ drop')) as' @\n    drop (length (pfx @ [rs] @ drop')) as'", "by force"], ["proof (state)\nthis:\n  as' =\n  take (length (pfx @ [rs] @ drop')) as' @\n  drop (length (pfx @ [rs] @ drop')) as'\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  as' =\n  take (length (pfx @ [rs] @ drop')) as' @\n  drop (length (pfx @ [rs] @ drop')) as'", "have \"exec_plan s as' = exec_plan (exec_plan s ?ap2) ?asfx\""], ["proof (prove)\nusing this:\n  as' =\n  take (length (pfx @ [rs] @ drop')) as' @\n  drop (length (pfx @ [rs] @ drop')) as'\n\ngoal (1 subgoal):\n 1. exec_plan s as' =\n    exec_plan (exec_plan s (take (length (pfx @ [rs] @ drop')) as'))\n     (drop (length (pfx @ [rs] @ drop')) as')", "using exec_plan_Append"], ["proof (prove)\nusing this:\n  as' =\n  take (length (pfx @ [rs] @ drop')) as' @\n  drop (length (pfx @ [rs] @ drop')) as'\n  exec_plan ?s (?as_a @ ?as_b) = exec_plan (exec_plan ?s ?as_a) ?as_b\n\ngoal (1 subgoal):\n 1. exec_plan s as' =\n    exec_plan (exec_plan s (take (length (pfx @ [rs] @ drop')) as'))\n     (drop (length (pfx @ [rs] @ drop')) as')", "by metis"], ["proof (state)\nthis:\n  exec_plan s as' =\n  exec_plan (exec_plan s (take (length (pfx @ [rs] @ drop')) as'))\n   (drop (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  exec_plan s as' =\n  exec_plan (exec_plan s (take (length (pfx @ [rs] @ drop')) as'))\n   (drop (length (pfx @ [rs] @ drop')) as')", "have C_9: \"exec_plan s as' = exec_plan s (?ap1 @ ?asfx)\""], ["proof (prove)\nusing this:\n  exec_plan s as' =\n  exec_plan (exec_plan s (take (length (pfx @ [rs] @ drop')) as'))\n   (drop (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. exec_plan s as' =\n    exec_plan s\n     (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')", "using C_4 C_7 exec_plan_Append"], ["proof (prove)\nusing this:\n  exec_plan s as' =\n  exec_plan (exec_plan s (take (length (pfx @ [rs] @ drop')) as'))\n   (drop (length (pfx @ [rs] @ drop')) as')\n  exec_plan s (take (length pfx) as') = rs\n  exec_plan s (take (length (pfx @ [rs] @ drop')) as') = rs\n  exec_plan ?s (?as_a @ ?as_b) = exec_plan (exec_plan ?s ?as_a) ?as_b\n\ngoal (1 subgoal):\n 1. exec_plan s as' =\n    exec_plan s\n     (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')", "by metis"], ["proof (state)\nthis:\n  exec_plan s as' =\n  exec_plan s\n   (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from C_6"], ["proof (chain)\npicking this:\n  length (pfx @ [rs] @ drop') \\<le> length as'", "have C_10: \"(length ?ap1 = ?pfxn) \\<and> (length ?ap2 = ?prsd)\""], ["proof (prove)\nusing this:\n  length (pfx @ [rs] @ drop') \\<le> length as'\n\ngoal (1 subgoal):\n 1. length (take (length pfx) as') = length pfx \\<and>\n    length (take (length (pfx @ [rs] @ drop')) as') =\n    length (pfx @ [rs] @ drop')", "by fastforce"], ["proof (state)\nthis:\n  length (take (length pfx) as') = length pfx \\<and>\n  length (take (length (pfx @ [rs] @ drop')) as') =\n  length (pfx @ [rs] @ drop')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  length (take (length pfx) as') = length pfx \\<and>\n  length (take (length (pfx @ [rs] @ drop')) as') =\n  length (pfx @ [rs] @ drop')", "have C_11: \"length (?ap1 @ ?asfx) < length (?ap2 @ ?asfx)\""], ["proof (prove)\nusing this:\n  length (take (length pfx) as') = length pfx \\<and>\n  length (take (length (pfx @ [rs] @ drop')) as') =\n  length (pfx @ [rs] @ drop')\n\ngoal (1 subgoal):\n 1. length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n    < length\n       (take (length (pfx @ [rs] @ drop')) as' @\n        drop (length (pfx @ [rs] @ drop')) as')", "by auto"], ["proof (state)\nthis:\n  length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n  < length\n     (take (length (pfx @ [rs] @ drop')) as' @\n      drop (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n  < length\n     (take (length (pfx @ [rs] @ drop')) as' @\n      drop (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from C_10"], ["proof (chain)\npicking this:\n  length (take (length pfx) as') = length pfx \\<and>\n  length (take (length (pfx @ [rs] @ drop')) as') =\n  length (pfx @ [rs] @ drop')", "have \"?pfxn + length ?asfx = length (?ap1 @ ?asfx)\""], ["proof (prove)\nusing this:\n  length (take (length pfx) as') = length pfx \\<and>\n  length (take (length (pfx @ [rs] @ drop')) as') =\n  length (pfx @ [rs] @ drop')\n\ngoal (1 subgoal):\n 1. length pfx + length (drop (length (pfx @ [rs] @ drop')) as') =\n    length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')", "by simp"], ["proof (state)\nthis:\n  length pfx + length (drop (length (pfx @ [rs] @ drop')) as') =\n  length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from C_9 i(2)"], ["proof (chain)\npicking this:\n  exec_plan s as' =\n  exec_plan s\n   (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n  exec_plan s as' = exec_plan s as", "have C_12: \"exec_plan s (?ap1 @ ?asfx) = exec_plan s as\""], ["proof (prove)\nusing this:\n  exec_plan s as' =\n  exec_plan s\n   (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n  exec_plan s as' = exec_plan s as\n\ngoal (1 subgoal):\n 1. exec_plan s\n     (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') =\n    exec_plan s as", "by argo"], ["proof (state)\nthis:\n  exec_plan s\n   (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') =\n  exec_plan s as\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  exec_plan s\n   (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') =\n  exec_plan s as\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  exec_plan s\n   (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') =\n  exec_plan s as\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  exec_plan s\n   (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') =\n  exec_plan s as\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have \"prefix ?ap1 ?ap2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')", "by (metis (no_types) length_append prefix_def take_add)"], ["proof (state)\nthis:\n  prefix (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  prefix (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')", "have \"subseq ?ap1 ?ap2\""], ["proof (prove)\nusing this:\n  prefix (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. subseq (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')", "using isPREFIX_sublist"], ["proof (prove)\nusing this:\n  prefix (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')\n  prefix ?x ?y \\<Longrightarrow> subseq ?x ?y\n\ngoal (1 subgoal):\n 1. subseq (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')", "by blast"], ["proof (state)\nthis:\n  subseq (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  subseq (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "moreover"], ["proof (state)\nthis:\n  subseq (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have \"sublist ?asfx ?asfx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist (drop (length (pfx @ [rs] @ drop')) as')\n     (drop (length (pfx @ [rs] @ drop')) as')", "using sublist_refl"], ["proof (prove)\nusing this:\n  subseq ?l ?l\n\ngoal (1 subgoal):\n 1. sublist (drop (length (pfx @ [rs] @ drop')) as')\n     (drop (length (pfx @ [rs] @ drop')) as')", "by blast"], ["proof (state)\nthis:\n  sublist (drop (length (pfx @ [rs] @ drop')) as')\n   (drop (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "ultimately"], ["proof (chain)\npicking this:\n  subseq (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')\n  sublist (drop (length (pfx @ [rs] @ drop')) as')\n   (drop (length (pfx @ [rs] @ drop')) as')", "have \"subseq (?ap1 @ ?asfx) as'\""], ["proof (prove)\nusing this:\n  subseq (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')\n  sublist (drop (length (pfx @ [rs] @ drop')) as')\n   (drop (length (pfx @ [rs] @ drop')) as')\n\ngoal (1 subgoal):\n 1. subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n     as'", "using C_8 subseq_append"], ["proof (prove)\nusing this:\n  subseq (take (length pfx) as') (take (length (pfx @ [rs] @ drop')) as')\n  sublist (drop (length (pfx @ [rs] @ drop')) as')\n   (drop (length (pfx @ [rs] @ drop')) as')\n  as' =\n  take (length (pfx @ [rs] @ drop')) as' @\n  drop (length (pfx @ [rs] @ drop')) as'\n  subseq (?xs @ ?zs) (?ys @ ?zs) = subseq ?xs ?ys\n\ngoal (1 subgoal):\n 1. subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n     as'", "by metis"], ["proof (state)\nthis:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n   as'\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n   as'\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "moreover"], ["proof (state)\nthis:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n   as'\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from i(3)"], ["proof (chain)\npicking this:\n  subseq as' as", "have \"subseq as' as\""], ["proof (prove)\nusing this:\n  subseq as' as\n\ngoal (1 subgoal):\n 1. subseq as' as", "by simp"], ["proof (state)\nthis:\n  subseq as' as\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "ultimately"], ["proof (chain)\npicking this:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n   as'\n  subseq as' as", "have \"subseq (?ap1 @ ?asfx) as\""], ["proof (prove)\nusing this:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n   as'\n  subseq as' as\n\ngoal (1 subgoal):\n 1. subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n     as", "using sublist_trans"], ["proof (prove)\nusing this:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n   as'\n  subseq as' as\n  \\<lbrakk>subseq ?l1.0 ?l2.0; subseq ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> subseq ?l1.0 ?l3.0\n\ngoal (1 subgoal):\n 1. subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n     as", "by blast"], ["proof (state)\nthis:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') as\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') as\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') as", "have \"length (?ap1 @ ?asfx) \\<in> PLS s as\""], ["proof (prove)\nusing this:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') as\n\ngoal (1 subgoal):\n 1. length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n    \\<in> PLS s as", "unfolding PLS_def"], ["proof (prove)\nusing this:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') as\n\ngoal (1 subgoal):\n 1. length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n    \\<in> length `\n          {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}", "using C_12"], ["proof (prove)\nusing this:\n  subseq (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') as\n  exec_plan s\n   (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as') =\n  exec_plan s as\n\ngoal (1 subgoal):\n 1. length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n    \\<in> length `\n          {as'. exec_plan s as' = exec_plan s as \\<and> subseq as' as}", "by blast"], ["proof (state)\nthis:\n  length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n  \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n  \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n  \\<in> PLS s as", "have False"], ["proof (prove)\nusing this:\n  length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n  \\<in> PLS s as\n\ngoal (1 subgoal):\n 1. False", "using P(1) i(1) C_10"], ["proof (prove)\nusing this:\n  length (take (length pfx) as' @ drop (length (pfx @ [rs] @ drop')) as')\n  \\<in> PLS s as\n  \\<forall>y. y \\<in> PLS s as \\<longrightarrow> n \\<le> y\n  n = length as'\n  length (take (length pfx) as') = length pfx \\<and>\n  length (take (length (pfx @ [rs] @ drop')) as') =\n  length (pfx @ [rs] @ drop')\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  \\<not> distinct (statelist' s as') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "hence \"distinct ?p'\""], ["proof (prove)\nusing this:\n  \\<not> distinct (statelist' s as') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. distinct (statelist' s as')", "by auto"], ["proof (state)\nthis:\n  distinct (statelist' s as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  distinct (statelist' s as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "ultimately"], ["proof (chain)\npicking this:\n  valid_path Pi (statelist' s as')\n  distinct (statelist' s as')", "have \"length ?p' - 1 \\<le> length p - 1\""], ["proof (prove)\nusing this:\n  valid_path Pi (statelist' s as')\n  distinct (statelist' s as')\n\ngoal (1 subgoal):\n 1. length (statelist' s as') - 1 \\<le> length p - 1", "using 2"], ["proof (prove)\nusing this:\n  valid_path Pi (statelist' s as')\n  distinct (statelist' s as')\n  \\<lbrakk>valid_path Pi ?p'2; distinct ?p'2\\<rbrakk>\n  \\<Longrightarrow> length ?p'2 - 1 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. length (statelist' s as') - 1 \\<le> length p - 1", "by blast"], ["proof (state)\nthis:\n  length (statelist' s as') - 1 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  length (statelist' s as') - 1 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "note ii = this"], ["proof (state)\nthis:\n  length (statelist' s as') - 1 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  length (statelist' s as') - 1 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from i(1)"], ["proof (chain)\npicking this:\n  n = length as'", "have \"n + 1 = length ?p'\""], ["proof (prove)\nusing this:\n  n = length as'\n\ngoal (1 subgoal):\n 1. n + 1 = length (statelist' s as')", "using LENGTH_statelist'[symmetric]"], ["proof (prove)\nusing this:\n  n = length as'\n  length ?as + 1 = length (statelist' ?s ?as)\n\ngoal (1 subgoal):\n 1. n + 1 = length (statelist' s as')", "by blast"], ["proof (state)\nthis:\n  n + 1 = length (statelist' s as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "also"], ["proof (state)\nthis:\n  n + 1 = length (statelist' s as')\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have \"\\<dots> \\<le> 1 + (length p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (statelist' s as') \\<le> 1 + (length p - 1)", "using ii"], ["proof (prove)\nusing this:\n  length (statelist' s as') - 1 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. length (statelist' s as') \\<le> 1 + (length p - 1)", "by linarith"], ["proof (state)\nthis:\n  length (statelist' s as') \\<le> 1 + (length p - 1)\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "finally"], ["proof (chain)\npicking this:\n  n + 1 \\<le> 1 + (length p - 1)", "have \"n \\<le> length p - 1\""], ["proof (prove)\nusing this:\n  n + 1 \\<le> 1 + (length p - 1)\n\ngoal (1 subgoal):\n 1. n \\<le> length p - 1", "by fastforce"], ["proof (state)\nthis:\n  n \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  n \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  n \\<le> length p - 1", "have \"n \\<le> length p - 1\""], ["proof (prove)\nusing this:\n  n \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. n \\<le> length p - 1", "by blast"], ["proof (state)\nthis:\n  n \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>y. y \\<in> PLS s as \\<longrightarrow> ?n2 \\<le> y;\n   ?n2 \\<in> PLS s as\\<rbrakk>\n  \\<Longrightarrow> ?n2 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "ultimately"], ["proof (chain)\npicking this:\n  finite (PLS s as)\n  PLS s as \\<noteq> {}\n  \\<lbrakk>\\<forall>y. y \\<in> PLS s as \\<longrightarrow> ?n2 \\<le> y;\n   ?n2 \\<in> PLS s as\\<rbrakk>\n  \\<Longrightarrow> ?n2 \\<le> length p - 1", "have \"Min ?P \\<le> length p - 1\""], ["proof (prove)\nusing this:\n  finite (PLS s as)\n  PLS s as \\<noteq> {}\n  \\<lbrakk>\\<forall>y. y \\<in> PLS s as \\<longrightarrow> ?n2 \\<le> y;\n   ?n2 \\<in> PLS s as\\<rbrakk>\n  \\<Longrightarrow> ?n2 \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as) \\<le> length p - 1", "using MIN_SET_ELIM'[where P=\"?P\" and Q=\"\\<lambda>x. x \\<le> length p - 1\"]"], ["proof (prove)\nusing this:\n  finite (PLS s as)\n  PLS s as \\<noteq> {}\n  \\<lbrakk>\\<forall>y. y \\<in> PLS s as \\<longrightarrow> ?n2 \\<le> y;\n   ?n2 \\<in> PLS s as\\<rbrakk>\n  \\<Longrightarrow> ?n2 \\<le> length p - 1\n  \\<lbrakk>finite (PLS s as); PLS s as \\<noteq> {};\n   \\<forall>x.\n      (\\<forall>y. y \\<in> PLS s as \\<longrightarrow> x \\<le> y) \\<and>\n      x \\<in> PLS s as \\<longrightarrow>\n      x \\<le> length p - 1\\<rbrakk>\n  \\<Longrightarrow> Min (PLS s as) \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as) \\<le> length p - 1", "by blast"], ["proof (state)\nthis:\n  Min (PLS s as) \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  Min (PLS s as) \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "note 3 = this"], ["proof (state)\nthis:\n  Min (PLS s as) \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  Min (PLS s as) \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have \"length p - 1 \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p - 1\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "using assms(3, 4) 1(1)"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     y \\<in> {length p - 1 |p.\n              valid_path Pi p \\<and> distinct p} \\<longrightarrow>\n     y \\<le> x\n  x \\<in> {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n  x = length p - 1\n\ngoal (1 subgoal):\n 1. length p - 1\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by (smt Max.coboundedI bdd_aboveI bdd_above_nat)"], ["proof (state)\nthis:\n  length p - 1\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "moreover"], ["proof (state)\nthis:\n  length p - 1\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have \"Min (PLS s as) \\<le> length p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (PLS s as) \\<le> length p - 1", "using 3"], ["proof (prove)\nusing this:\n  Min (PLS s as) \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as) \\<le> length p - 1", "by blast"], ["proof (state)\nthis:\n  Min (PLS s as) \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "ultimately"], ["proof (chain)\npicking this:\n  length p - 1\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n  Min (PLS s as) \\<le> length p - 1", "have \"Min (PLS s as) \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\""], ["proof (prove)\nusing this:\n  length p - 1\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n  Min (PLS s as) \\<le> length p - 1\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by linarith"], ["proof (state)\nthis:\n  Min (PLS s as)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  Min (PLS s as)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  Min (PLS s as)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "show ?thesis"], ["proof (prove)\nusing this:\n  Min (PLS s as)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  Min (PLS s as)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>NOTE added lemma (refactored from `RD\\_bounds\\_sublistD`).\\<close>"], ["", "lemma RD_bounds_sublistD_i:\n  fixes Pi :: \"'a problem\" and x\n  assumes \"finite Pi\" \"(\\<forall>y. y \\<in> MPLS Pi \\<longrightarrow> y \\<le> x)\" \"x \\<in> MPLS Pi\" \n  shows \"x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?P=\"MPLS Pi\""], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?Q=\"{length p - 1 |p. valid_path Pi p \\<and> distinct p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from assms(3)"], ["proof (chain)\npicking this:\n  x \\<in> MPLS Pi", "obtain s as where 1:\n      \"s \\<in> valid_states Pi\" \"as \\<in> valid_plans Pi\" \"x = Inf (PLS s as)\""], ["proof (prove)\nusing this:\n  x \\<in> MPLS Pi\n\ngoal (1 subgoal):\n 1. (\\<And>s as.\n        \\<lbrakk>s \\<in> valid_states Pi; as \\<in> valid_plans Pi;\n         x = Inf (PLS s as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding MPLS_def"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as). s \\<in> valid_states Pi \\<and> as \\<in> valid_plans Pi}\n\ngoal (1 subgoal):\n 1. (\\<And>s as.\n        \\<lbrakk>s \\<in> valid_states Pi; as \\<in> valid_plans Pi;\n         x = Inf (PLS s as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  s \\<in> valid_states Pi\n  as \\<in> valid_plans Pi\n  x = Inf (PLS s as)\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have \"x \\<le> Max ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "text \\<open> Show that `x` is not only the infimum but also the minimum of `PLS s as`.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have \"finite (PLS s as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (PLS s as)", "using finite_PLS"], ["proof (prove)\nusing this:\n  finite (PLS ?s ?as)\n\ngoal (1 subgoal):\n 1. finite (PLS s as)", "by auto"], ["proof (state)\nthis:\n  finite (PLS s as)\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "moreover"], ["proof (state)\nthis:\n  finite (PLS s as)\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have \"PLS s as \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PLS s as \\<noteq> {}", "using PLS_NEMPTY"], ["proof (prove)\nusing this:\n  PLS ?s ?as \\<noteq> {}\n\ngoal (1 subgoal):\n 1. PLS s as \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  PLS s as \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "ultimately"], ["proof (chain)\npicking this:\n  finite (PLS s as)\n  PLS s as \\<noteq> {}", "have a: \"Inf (PLS s as) = Min (PLS s as)\""], ["proof (prove)\nusing this:\n  finite (PLS s as)\n  PLS s as \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) = Min (PLS s as)", "using cInf_eq_Min[of \"PLS s as\"]"], ["proof (prove)\nusing this:\n  finite (PLS s as)\n  PLS s as \\<noteq> {}\n  \\<lbrakk>finite (PLS s as); PLS s as \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Inf (PLS s as) = Min (PLS s as)\n\ngoal (1 subgoal):\n 1. Inf (PLS s as) = Min (PLS s as)", "by blast"], ["proof (state)\nthis:\n  Inf (PLS s as) = Min (PLS s as)\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from 1(3) a"], ["proof (chain)\npicking this:\n  x = Inf (PLS s as)\n  Inf (PLS s as) = Min (PLS s as)", "have \"x = Min (PLS s as)\""], ["proof (prove)\nusing this:\n  x = Inf (PLS s as)\n  Inf (PLS s as) = Min (PLS s as)\n\ngoal (1 subgoal):\n 1. x = Min (PLS s as)", "by blast"], ["proof (state)\nthis:\n  x = Min (PLS s as)\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  x = Min (PLS s as)\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "note a = this"], ["proof (state)\nthis:\n  x = Min (PLS s as)\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "{"], ["proof (state)\nthis:\n  x = Min (PLS s as)\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "let ?limit=\"Min (PLS s as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from assms(1)"], ["proof (chain)\npicking this:\n  finite Pi", "have a: \"finite ?Q\""], ["proof (prove)\nusing this:\n  finite Pi\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "using RD_bounds_sublistD_i_a"], ["proof (prove)\nusing this:\n  finite Pi\n  finite ?Pi \\<Longrightarrow>\n  finite {length p - 1 |p. valid_path ?Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  finite {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have b: \"?Q \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "using RD_bounds_sublistD_i_b"], ["proof (prove)\nusing this:\n  {length p - 1 |p. valid_path ?Pi p \\<and> distinct p} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}", "by fast"], ["proof (state)\nthis:\n  {length p - 1 |p. valid_path Pi p \\<and> distinct p} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from 1(1, 2)"], ["proof (chain)\npicking this:\n  s \\<in> valid_states Pi\n  as \\<in> valid_plans Pi", "have c: \"\\<forall>x. (\\<forall>y. y \\<in> ?Q \\<longrightarrow> y \\<le> x) \\<and> x \\<in> ?Q \\<longrightarrow> ?limit \\<le> Max ?Q\""], ["proof (prove)\nusing this:\n  s \\<in> valid_states Pi\n  as \\<in> valid_plans Pi\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<forall>y.\n           y \\<in> {length p - 1 |p.\n                    valid_path Pi p \\<and> distinct p} \\<longrightarrow>\n           y \\<le> x) \\<and>\n       x \\<in> {length p - 1 |p.\n                valid_path Pi p \\<and> distinct p} \\<longrightarrow>\n       Min (PLS s as)\n       \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "using RD_bounds_sublistD_i_c"], ["proof (prove)\nusing this:\n  s \\<in> valid_states Pi\n  as \\<in> valid_plans Pi\n  \\<lbrakk>?s \\<in> valid_states ?Pi; ?as \\<in> valid_plans ?Pi;\n   \\<forall>y.\n      y \\<in> {length p - 1 |p.\n               valid_path ?Pi p \\<and> distinct p} \\<longrightarrow>\n      y \\<le> ?x;\n   ?x \\<in> {length p - 1 |p. valid_path ?Pi p \\<and> distinct p}\\<rbrakk>\n  \\<Longrightarrow> Min (PLS ?s ?as)\n                    \\<le> Max {length p - 1 |p.\n                               valid_path ?Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<forall>y.\n           y \\<in> {length p - 1 |p.\n                    valid_path Pi p \\<and> distinct p} \\<longrightarrow>\n           y \\<le> x) \\<and>\n       x \\<in> {length p - 1 |p.\n                valid_path Pi p \\<and> distinct p} \\<longrightarrow>\n       Min (PLS s as)\n       \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  \\<forall>x.\n     (\\<forall>y.\n         y \\<in> {length p - 1 |p.\n                  valid_path Pi p \\<and> distinct p} \\<longrightarrow>\n         y \\<le> x) \\<and>\n     x \\<in> {length p - 1 |p.\n              valid_path Pi p \\<and> distinct p} \\<longrightarrow>\n     Min (PLS s as)\n     \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "have \"?limit \\<le> Max ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "using MAX_SET_ELIM'[where P=\"?Q\" and R=\"\\<lambda>x. ?limit \\<le> Max ?Q\", OF a b c]"], ["proof (prove)\nusing this:\n  Min (PLS s as)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. Min (PLS s as)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  Min (PLS s as)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  Min (PLS s as)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "note b = this"], ["proof (state)\nthis:\n  Min (PLS s as)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "from a b"], ["proof (chain)\npicking this:\n  x = Min (PLS s as)\n  Min (PLS s as)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "show \"x \\<le> Max ?Q\""], ["proof (prove)\nusing this:\n  x = Min (PLS s as)\n  Min (PLS s as)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "}"], ["proof (state)\nthis:\n  x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "then"], ["proof (chain)\npicking this:\n  x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "using assms"], ["proof (prove)\nusing this:\n  x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n  finite Pi\n  \\<forall>y. y \\<in> MPLS Pi \\<longrightarrow> y \\<le> x\n  x \\<in> MPLS Pi\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "unfolding MPLS_def"], ["proof (prove)\nusing this:\n  x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n  finite Pi\n  \\<forall>y.\n     y \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n             {(s, as).\n              s \\<in> valid_states Pi \\<and>\n              as \\<in> valid_plans Pi} \\<longrightarrow>\n     y \\<le> x\n  x \\<in> (\\<lambda>(s, as). Inf (PLS s as)) `\n          {(s, as). s \\<in> valid_states Pi \\<and> as \\<in> valid_plans Pi}\n\ngoal (1 subgoal):\n 1. x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>NOTE type of `Pi` had to be fixed for use of `FINITE\\_valid\\_states`.\\<close>"], ["", "lemma RD_bounds_sublistD: \n  fixes Pi :: \"'a problem\"\n  assumes \"finite Pi\"\n  shows \"problem_plan_bound Pi \\<le> RD Pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound Pi \\<le> RD Pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound Pi \\<le> RD Pi", "let ?P=\"MPLS Pi\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound Pi \\<le> RD Pi", "let ?Q=\"{length p - 1 |p. valid_path Pi p \\<and> distinct p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound Pi \\<le> RD Pi", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound Pi \\<le> RD Pi", "from assms"], ["proof (chain)\npicking this:\n  finite Pi", "have 1: \"finite ?P\""], ["proof (prove)\nusing this:\n  finite Pi\n\ngoal (1 subgoal):\n 1. finite (MPLS Pi)", "using FINITE_MPLS"], ["proof (prove)\nusing this:\n  finite Pi\n  finite ?Pi \\<Longrightarrow> finite (MPLS ?Pi)\n\ngoal (1 subgoal):\n 1. finite (MPLS Pi)", "by blast"], ["proof (state)\nthis:\n  finite (MPLS Pi)\n\ngoal (1 subgoal):\n 1. problem_plan_bound Pi \\<le> RD Pi", "from assms"], ["proof (chain)\npicking this:\n  finite Pi", "have 2: \"?P \\<noteq> {}\""], ["proof (prove)\nusing this:\n  finite Pi\n\ngoal (1 subgoal):\n 1. MPLS Pi \\<noteq> {}", "using MPLS_nempty"], ["proof (prove)\nusing this:\n  finite Pi\n  finite ?PROB \\<Longrightarrow> MPLS ?PROB \\<noteq> {}\n\ngoal (1 subgoal):\n 1. MPLS Pi \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  MPLS Pi \\<noteq> {}\n\ngoal (1 subgoal):\n 1. problem_plan_bound Pi \\<le> RD Pi", "from assms"], ["proof (chain)\npicking this:\n  finite Pi", "have 3: \"\\<forall>x. (\\<forall>y. y \\<in> ?P \\<longrightarrow> y \\<le> x) \\<and> x \\<in> ?P \\<longrightarrow> x \\<le> Max ?Q\""], ["proof (prove)\nusing this:\n  finite Pi\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<forall>y. y \\<in> MPLS Pi \\<longrightarrow> y \\<le> x) \\<and>\n       x \\<in> MPLS Pi \\<longrightarrow>\n       x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "using RD_bounds_sublistD_i"], ["proof (prove)\nusing this:\n  finite Pi\n  \\<lbrakk>finite ?Pi;\n   \\<forall>y. y \\<in> MPLS ?Pi \\<longrightarrow> y \\<le> ?x;\n   ?x \\<in> MPLS ?Pi\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> Max {length p - 1 |p.\n                                  valid_path ?Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<forall>y. y \\<in> MPLS Pi \\<longrightarrow> y \\<le> x) \\<and>\n       x \\<in> MPLS Pi \\<longrightarrow>\n       x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  \\<forall>x.\n     (\\<forall>y. y \\<in> MPLS Pi \\<longrightarrow> y \\<le> x) \\<and>\n     x \\<in> MPLS Pi \\<longrightarrow>\n     x \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. problem_plan_bound Pi \\<le> RD Pi", "have \"Max ?P \\<le> Max ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (MPLS Pi)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "using MAX_SET_ELIM'[OF 1 2 3]"], ["proof (prove)\nusing this:\n  Max (MPLS Pi)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. Max (MPLS Pi)\n    \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "by blast"], ["proof (state)\nthis:\n  Max (MPLS Pi)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. problem_plan_bound Pi \\<le> RD Pi", "}"], ["proof (state)\nthis:\n  Max (MPLS Pi)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. problem_plan_bound Pi \\<le> RD Pi", "then"], ["proof (chain)\npicking this:\n  Max (MPLS Pi)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}", "show ?thesis"], ["proof (prove)\nusing this:\n  Max (MPLS Pi)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. problem_plan_bound Pi \\<le> RD Pi", "unfolding problem_plan_bound_def RD_def Sup_nat_def"], ["proof (prove)\nusing this:\n  Max (MPLS Pi)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n\ngoal (1 subgoal):\n 1. (if MPLS Pi = {} then 0 else Max (MPLS Pi))\n    \\<le> (if {length p - 1 |p. valid_path Pi p \\<and> distinct p} = {}\n           then 0\n           else Max {length p - 1 |p. valid_path Pi p \\<and> distinct p})", "using RD_bounds_sublistD_i_b"], ["proof (prove)\nusing this:\n  Max (MPLS Pi)\n  \\<le> Max {length p - 1 |p. valid_path Pi p \\<and> distinct p}\n  {length p - 1 |p. valid_path ?Pi p \\<and> distinct p} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (if MPLS Pi = {} then 0 else Max (MPLS Pi))\n    \\<le> (if {length p - 1 |p. valid_path Pi p \\<and> distinct p} = {}\n           then 0\n           else Max {length p - 1 |p. valid_path Pi p \\<and> distinct p})", "by auto"], ["proof (state)\nthis:\n  problem_plan_bound Pi \\<le> RD Pi\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE type for `PROB` had to be fixed in order to be able to match `sublistD\\_bounds\\_D`.\\<close>"], ["", "theorem sublistD_bounds_D_and_RD_bounds_sublistD: \n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\"\n  shows \"\n    problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB \n    \\<and> problem_plan_bound PROB \\<le> RD PROB\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB \\<and>\n    problem_plan_bound PROB \\<le> RD PROB", "using assms sublistD_bounds_D RD_bounds_sublistD"], ["proof (prove)\nusing this:\n  finite PROB\n  finite ?PROB \\<Longrightarrow>\n  problem_plan_bound_charles ?PROB \\<le> problem_plan_bound ?PROB\n  finite ?Pi \\<Longrightarrow> problem_plan_bound ?Pi \\<le> RD ?Pi\n\ngoal (1 subgoal):\n 1. problem_plan_bound_charles PROB \\<le> problem_plan_bound PROB \\<and>\n    problem_plan_bound PROB \\<le> RD PROB", "by auto\n\n\n\\<comment> \\<open>NOTE type of `PROB` had to be fixed for MP of lemmas.\\<close>"], ["", "lemma empty_problem_bound: \n  fixes PROB :: \"'a problem\"\n  assumes \"(prob_dom PROB = {})\"\n  shows \"(problem_plan_bound PROB = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB = 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB = 0", "fix PROB' and as :: \"(('a, 'b) fmap \\<times> ('a, 'b) fmap) list\" and s :: \"('a, 'b) fmap\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB = 0", "assume \n      \"finite PROB\" \"prob_dom PROB' = {}\" \"s \\<in> valid_states PROB'\" \"as \\<in> valid_plans PROB'\""], ["proof (state)\nthis:\n  finite PROB\n  prob_dom PROB' = {}\n  s \\<in> valid_states PROB'\n  as \\<in> valid_plans PROB'\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB = 0", "then"], ["proof (chain)\npicking this:\n  finite PROB\n  prob_dom PROB' = {}\n  s \\<in> valid_states PROB'\n  as \\<in> valid_plans PROB'", "have \"exec_plan s [] = exec_plan s as\""], ["proof (prove)\nusing this:\n  finite PROB\n  prob_dom PROB' = {}\n  s \\<in> valid_states PROB'\n  as \\<in> valid_plans PROB'\n\ngoal (1 subgoal):\n 1. exec_plan s [] = exec_plan s as", "using empty_prob_dom_imp_empty_plan_always_good"], ["proof (prove)\nusing this:\n  finite PROB\n  prob_dom PROB' = {}\n  s \\<in> valid_states PROB'\n  as \\<in> valid_plans PROB'\n  \\<lbrakk>prob_dom ?PROB = {}; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> exec_plan ?s [] = exec_plan ?s ?as\n\ngoal (1 subgoal):\n 1. exec_plan s [] = exec_plan s as", "by blast"], ["proof (state)\nthis:\n  exec_plan s [] = exec_plan s as\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB = 0", "then"], ["proof (chain)\npicking this:\n  exec_plan s [] = exec_plan s as", "have \"(\\<exists>as'. exec_plan s as = exec_plan s as' \\<and> subseq as' as \\<and> length as' < 1)\""], ["proof (prove)\nusing this:\n  exec_plan s [] = exec_plan s as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and> length as' < 1", "by force"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and> length as' < 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB = 0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite PROB; prob_dom ?PROB'2 = {};\n   ?s2 \\<in> valid_states ?PROB'2; ?as2 \\<in> valid_plans ?PROB'2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and> length as' < 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite PROB; prob_dom ?PROB'2 = {};\n   ?s2 \\<in> valid_states ?PROB'2; ?as2 \\<in> valid_plans ?PROB'2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and> length as' < 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite PROB; prob_dom ?PROB'2 = {};\n   ?s2 \\<in> valid_states ?PROB'2; ?as2 \\<in> valid_plans ?PROB'2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and> length as' < 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB = 0", "using bound_on_all_plans_bounds_problem_plan_bound_[where P=\"\\<lambda>P. prob_dom P = {}\" and f=\"\\<lambda>P. 1\", of PROB]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite PROB; prob_dom ?PROB'2 = {};\n   ?s2 \\<in> valid_states ?PROB'2; ?as2 \\<in> valid_plans ?PROB'2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and> length as' < 1\n  \\<lbrakk>\\<forall>PROB' as s.\n              finite PROB \\<and>\n              prob_dom PROB' = {} \\<and>\n              s \\<in> valid_states PROB' \\<and>\n              as \\<in> valid_plans PROB' \\<longrightarrow>\n              (\\<exists>as'.\n                  exec_plan s as = exec_plan s as' \\<and>\n                  subseq as' as \\<and> length as' < 1);\n   prob_dom PROB = {}; finite PROB\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound PROB < 1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB = 0", "using assms empty_prob_dom_finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite PROB; prob_dom ?PROB'2 = {};\n   ?s2 \\<in> valid_states ?PROB'2; ?as2 \\<in> valid_plans ?PROB'2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and> length as' < 1\n  \\<lbrakk>\\<forall>PROB' as s.\n              finite PROB \\<and>\n              prob_dom PROB' = {} \\<and>\n              s \\<in> valid_states PROB' \\<and>\n              as \\<in> valid_plans PROB' \\<longrightarrow>\n              (\\<exists>as'.\n                  exec_plan s as = exec_plan s as' \\<and>\n                  subseq as' as \\<and> length as' < 1);\n   prob_dom PROB = {}; finite PROB\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound PROB < 1\n  prob_dom PROB = {}\n  prob_dom ?PROB = {} \\<Longrightarrow> finite ?PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB = 0", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound PROB = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma problem_plan_bound_works':\n  fixes PROB :: \"'a problem\" and as s\n  assumes \"finite PROB\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'. \n    (exec_plan s as' = exec_plan s as) \n    \\<and> (subseq as' as)\n    \\<and> (length as' \\<le> problem_plan_bound PROB) \n    \\<and> (sat_precond_as s as')\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "obtain as' where 1:\n    \"exec_plan s as = exec_plan s as'\" \"subseq as' as\" \"length as' \\<le> problem_plan_bound PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' \\<le> problem_plan_bound PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms problem_plan_bound_works"], ["proof (prove)\nusing this:\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s ?as = exec_plan ?s as' \\<and>\n                       subseq as' ?as \\<and>\n                       length as' \\<le> problem_plan_bound ?PROB\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as' \\<le> problem_plan_bound PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n      \\<comment> \\<open>NOTE this step seems to be handled implicitely in original proof.\\<close>"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "moreover"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "have \"rem_condless_act s [] as' \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rem_condless_act s [] as' \\<in> valid_plans PROB", "using assms(3) 1(2) rem_condless_valid_10 sublist_valid_plan"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n  subseq as' as\n  ?as \\<in> valid_plans ?PROB \\<Longrightarrow>\n  rem_condless_act ?s [] ?as \\<in> valid_plans ?PROB\n  \\<lbrakk>subseq ?as' ?as; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?as' \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. rem_condless_act s [] as' \\<in> valid_plans PROB", "by blast"], ["proof (state)\nthis:\n  rem_condless_act s [] as' \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "moreover"], ["proof (state)\nthis:\n  rem_condless_act s [] as' \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "have \"subseq (rem_condless_act s [] as') as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq (rem_condless_act s [] as') as'", "using rem_condless_valid_8"], ["proof (prove)\nusing this:\n  subseq (rem_condless_act ?s [] ?as) ?as\n\ngoal (1 subgoal):\n 1. subseq (rem_condless_act s [] as') as'", "by blast"], ["proof (state)\nthis:\n  subseq (rem_condless_act s [] as') as'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "moreover"], ["proof (state)\nthis:\n  subseq (rem_condless_act s [] as') as'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "have \"length (rem_condless_act s [] as') \\<le> length as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rem_condless_act s [] as') \\<le> length as'", "using rem_condless_valid_3"], ["proof (prove)\nusing this:\n  length (rem_condless_act ?s [] ?as) \\<le> length ?as\n\ngoal (1 subgoal):\n 1. length (rem_condless_act s [] as') \\<le> length as'", "by blast"], ["proof (state)\nthis:\n  length (rem_condless_act s [] as') \\<le> length as'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "moreover"], ["proof (state)\nthis:\n  length (rem_condless_act s [] as') \\<le> length as'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "have \"sat_precond_as s (rem_condless_act s [] as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_precond_as s (rem_condless_act s [] as')", "using rem_condless_valid_2"], ["proof (prove)\nusing this:\n  sat_precond_as ?s (rem_condless_act ?s [] ?as)\n\ngoal (1 subgoal):\n 1. sat_precond_as s (rem_condless_act s [] as')", "by blast"], ["proof (state)\nthis:\n  sat_precond_as s (rem_condless_act s [] as')\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "moreover"], ["proof (state)\nthis:\n  sat_precond_as s (rem_condless_act s [] as')\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "have \"exec_plan s as' = exec_plan s (rem_condless_act s [] as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_plan s as' = exec_plan s (rem_condless_act s [] as')", "using rem_condless_valid_1"], ["proof (prove)\nusing this:\n  exec_plan ?s ?as = exec_plan ?s (rem_condless_act ?s [] ?as)\n\ngoal (1 subgoal):\n 1. exec_plan s as' = exec_plan s (rem_condless_act s [] as')", "by blast"], ["proof (state)\nthis:\n  exec_plan s as' = exec_plan s (rem_condless_act s [] as')\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "ultimately"], ["proof (chain)\npicking this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound PROB\n  rem_condless_act s [] as' \\<in> valid_plans PROB\n  subseq (rem_condless_act s [] as') as'\n  length (rem_condless_act s [] as') \\<le> length as'\n  sat_precond_as s (rem_condless_act s [] as')\n  exec_plan s as' = exec_plan s (rem_condless_act s [] as')", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound PROB\n  rem_condless_act s [] as' \\<in> valid_plans PROB\n  subseq (rem_condless_act s [] as') as'\n  length (rem_condless_act s [] as') \\<le> length as'\n  sat_precond_as s (rem_condless_act s [] as')\n  exec_plan s as' = exec_plan s (rem_condless_act s [] as')\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as' = exec_plan s as \\<and>\n     subseq as' as \\<and>\n     length as' \\<le> problem_plan_bound PROB \\<and> sat_precond_as s as'\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>TODO remove? Can be solved directly with 'TopologicalProps.bound\\_on\\_all\\_plans\\_bounds\\_problem\\_plan\\_bound\\_thesis'.\\<close>"], ["", "lemma problem_plan_bound_UBound: \n  assumes \"(\\<forall>as s.\n    (s \\<in> valid_states PROB) \n    \\<and> (as \\<in> valid_plans PROB)\n    \\<longrightarrow> (\\<exists>as'.\n      (exec_plan s as = exec_plan s as') \n      \\<and> subseq as' as \n      \\<and> (length as' < f PROB)\n    )\n  )\" \"finite PROB\"\n  shows \"(problem_plan_bound PROB < f PROB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < f PROB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < f PROB", "let ?P = \"\\<lambda>Pr. PROB = Pr\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < f PROB", "have \"?P PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROB = PROB", "by simp"], ["proof (state)\nthis:\n  PROB = PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < f PROB", "then"], ["proof (chain)\npicking this:\n  PROB = PROB", "show ?thesis"], ["proof (prove)\nusing this:\n  PROB = PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < f PROB", "using assms bound_on_all_plans_bounds_problem_plan_bound_[where P = ?P]"], ["proof (prove)\nusing this:\n  PROB = PROB\n  \\<forall>as s.\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     (\\<exists>as'.\n         exec_plan s as = exec_plan s as' \\<and>\n         subseq as' as \\<and> length as' < f PROB)\n  finite PROB\n  \\<lbrakk>\\<forall>PROB' as s.\n              finite ?PROB \\<and>\n              PROB = PROB' \\<and>\n              s \\<in> valid_states PROB' \\<and>\n              as \\<in> valid_plans PROB' \\<longrightarrow>\n              (\\<exists>as'.\n                  exec_plan s as = exec_plan s as' \\<and>\n                  subseq as' as \\<and> length as' < ?f PROB');\n   PROB = ?PROB; finite ?PROB\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound ?PROB < ?f ?PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB < f PROB", "by force"], ["proof (state)\nthis:\n  problem_plan_bound PROB < f PROB\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Traversal Diameter\"\n\n\n\\<comment> \\<open>NOTE name shortened.\\<close>"], ["", "definition traversed_states where\n  \"traversed_states s as \\<equiv> set (state_list s as)\""], ["", "lemma finite_traversed_states: \"finite (traversed_states s as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (traversed_states s as)", "unfolding traversed_states_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (state_list s as))", "by simp"], ["", "lemma traversed_states_nempty: \"traversed_states s as \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traversed_states s as \\<noteq> {}", "unfolding traversed_states_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (state_list s as) \\<noteq> {}", "by (induction as) auto"], ["", "lemma traversed_states_geq_1: \n  fixes s\n  shows \"1 \\<le> card (traversed_states s as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card (traversed_states s as)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> card (traversed_states s as)", "have \"card (traversed_states s as) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (traversed_states s as) \\<noteq> 0", "using traversed_states_nempty finite_traversed_states card_0_eq"], ["proof (prove)\nusing this:\n  traversed_states ?s ?as \\<noteq> {}\n  finite (traversed_states ?s ?as)\n  finite ?A \\<Longrightarrow> (card ?A = 0) = (?A = {})\n\ngoal (1 subgoal):\n 1. card (traversed_states s as) \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  card (traversed_states s as) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> card (traversed_states s as)", "then"], ["proof (chain)\npicking this:\n  card (traversed_states s as) \\<noteq> 0", "show \"1 \\<le> card (traversed_states s as)\""], ["proof (prove)\nusing this:\n  card (traversed_states s as) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> card (traversed_states s as)", "by linarith"], ["proof (state)\nthis:\n  1 \\<le> card (traversed_states s as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma init_is_traversed: \"s \\<in> traversed_states s as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> traversed_states s as", "unfolding traversed_states_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> set (state_list s as)", "by (induction as) auto\n\n\n\\<comment> \\<open>NOTE name shortened.\\<close>"], ["", "definition td where\n  \"td PROB \\<equiv> Sup {\n    (card (traversed_states (fst p) (snd p))) - 1 \n    | p. (fst p \\<in> valid_states PROB) \\<and> (snd p \\<in> valid_plans PROB)}\n  \""], ["", "lemma traversed_states_rem_condless_act: \"\\<And>s. \n  traversed_states s (rem_condless_act s [] as) = traversed_states s as\n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       traversed_states s (rem_condless_act s [] as) = traversed_states s as", "apply(induction as)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       traversed_states s (rem_condless_act s [] []) = traversed_states s []\n 2. \\<And>a as s.\n       (\\<And>s.\n           traversed_states s (rem_condless_act s [] as) =\n           traversed_states s as) \\<Longrightarrow>\n       traversed_states s (rem_condless_act s [] (a # as)) =\n       traversed_states s (a # as)", "apply(auto simp add: traversed_states_def rem_condless_act_cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b as s x.\n       \\<lbrakk>\\<And>s.\n                   set (state_list s (rem_condless_act s [] as)) =\n                   set (state_list s as);\n        \\<not> a \\<subseteq>\\<^sub>f s; x \\<in> set (state_list s as);\n        x \\<notin> set (state_list (state_succ s (a, b)) as)\\<rbrakk>\n       \\<Longrightarrow> x = s\n 2. \\<And>a as s.\n       \\<lbrakk>\\<And>s.\n                   set (state_list s (rem_condless_act s [] as)) =\n                   set (state_list s as);\n        \\<not> a \\<subseteq>\\<^sub>f s\\<rbrakk>\n       \\<Longrightarrow> s \\<in> set (state_list s as)\n 3. \\<And>a b as s x.\n       \\<lbrakk>\\<And>s.\n                   set (state_list s (rem_condless_act s [] as)) =\n                   set (state_list s as);\n        \\<not> a \\<subseteq>\\<^sub>f s;\n        x \\<in> set (state_list (state_succ s (a, b)) as)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (state_list s as)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                set (state_list s (rem_condless_act s [] as_)) =\n                set (state_list s as_);\n     \\<not> a_ \\<subseteq>\\<^sub>f s_; x_ \\<in> set (state_list s_ as_);\n     x_ \\<notin> set (state_list (state_succ s_ (a_, b_)) as_)\\<rbrakk>\n    \\<Longrightarrow> x_ = s_", "by (simp add: state_succ_pair)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as s.\n       \\<lbrakk>\\<And>s.\n                   set (state_list s (rem_condless_act s [] as)) =\n                   set (state_list s as);\n        \\<not> a \\<subseteq>\\<^sub>f s\\<rbrakk>\n       \\<Longrightarrow> s \\<in> set (state_list s as)\n 2. \\<And>a b as s x.\n       \\<lbrakk>\\<And>s.\n                   set (state_list s (rem_condless_act s [] as)) =\n                   set (state_list s as);\n        \\<not> a \\<subseteq>\\<^sub>f s;\n        x \\<in> set (state_list (state_succ s (a, b)) as)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (state_list s as)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                set (state_list s (rem_condless_act s [] as_)) =\n                set (state_list s as_);\n     \\<not> a_ \\<subseteq>\\<^sub>f s_\\<rbrakk>\n    \\<Longrightarrow> s_ \\<in> set (state_list s_ as_)", "using init_is_traversed traversed_states_def"], ["proof (prove)\nusing this:\n  ?s \\<in> traversed_states ?s ?as\n  traversed_states ?s ?as \\<equiv> set (state_list ?s ?as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                set (state_list s (rem_condless_act s [] as_)) =\n                set (state_list s as_);\n     \\<not> a_ \\<subseteq>\\<^sub>f s_\\<rbrakk>\n    \\<Longrightarrow> s_ \\<in> set (state_list s_ as_)", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b as s x.\n       \\<lbrakk>\\<And>s.\n                   set (state_list s (rem_condless_act s [] as)) =\n                   set (state_list s as);\n        \\<not> a \\<subseteq>\\<^sub>f s;\n        x \\<in> set (state_list (state_succ s (a, b)) as)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (state_list s as)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                set (state_list s (rem_condless_act s [] as_)) =\n                set (state_list s as_);\n     \\<not> a_ \\<subseteq>\\<^sub>f s_;\n     x_ \\<in> set (state_list (state_succ s_ (a_, b_)) as_)\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> set (state_list s_ as_)", "by (simp add: state_succ_pair)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\\<comment> \\<open>NOTE added lemma.\\<close>"], ["", "lemma td_UBound_i: \n  fixes PROB :: \"(('a, 'b) fmap \\<times> ('a, 'b) fmap) set\"\n  assumes \"finite PROB\" \n  shows \"\n  {\n    (card (traversed_states (fst p) (snd p))) - 1 \n    | p. (fst p \\<in> valid_states PROB) \\<and> (snd p \\<in> valid_plans PROB)}\n  \\<noteq> {}\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. {card (traversed_states (fst p) (snd p)) - 1 |p.\n     fst p \\<in> valid_states PROB \\<and>\n     snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {card (traversed_states (fst p) (snd p)) - 1 |p.\n     fst p \\<in> valid_states PROB \\<and>\n     snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "let ?S=\"{p. (fst p \\<in> valid_states PROB) \\<and> (snd p \\<in> valid_plans PROB)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. {card (traversed_states (fst p) (snd p)) - 1 |p.\n     fst p \\<in> valid_states PROB \\<and>\n     snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "obtain s :: \"'a state\" where \"s \\<in> valid_states PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> valid_states PROB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms valid_states_nempty"], ["proof (prove)\nusing this:\n  finite PROB\n  finite ?PROB \\<Longrightarrow> \\<exists>s. s \\<in> valid_states ?PROB\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> valid_states PROB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. {card (traversed_states (fst p) (snd p)) - 1 |p.\n     fst p \\<in> valid_states PROB \\<and>\n     snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  s \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. {card (traversed_states (fst p) (snd p)) - 1 |p.\n     fst p \\<in> valid_states PROB \\<and>\n     snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "have \"[] \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> valid_plans PROB", "using empty_plan_is_valid"], ["proof (prove)\nusing this:\n  [] \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. [] \\<in> valid_plans PROB", "by auto"], ["proof (state)\nthis:\n  [] \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. {card (traversed_states (fst p) (snd p)) - 1 |p.\n     fst p \\<in> valid_states PROB \\<and>\n     snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> valid_states PROB\n  [] \\<in> valid_plans PROB", "have \"?S \\<noteq> {}\""], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  [] \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. {p. fst p \\<in> valid_states PROB \\<and>\n        snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "using assms valid_states_nempty"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  [] \\<in> valid_plans PROB\n  finite PROB\n  finite ?PROB \\<Longrightarrow> \\<exists>s. s \\<in> valid_states ?PROB\n\ngoal (1 subgoal):\n 1. {p. fst p \\<in> valid_states PROB \\<and>\n        snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  {p. fst p \\<in> valid_states PROB \\<and>\n      snd p \\<in> valid_plans PROB} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. {card (traversed_states (fst p) (snd p)) - 1 |p.\n     fst p \\<in> valid_states PROB \\<and>\n     snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  {p. fst p \\<in> valid_states PROB \\<and>\n      snd p \\<in> valid_plans PROB} \\<noteq>\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  {p. fst p \\<in> valid_states PROB \\<and>\n      snd p \\<in> valid_plans PROB} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. {card (traversed_states (fst p) (snd p)) - 1 |p.\n     fst p \\<in> valid_states PROB \\<and>\n     snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  {card (traversed_states (fst p) (snd p)) - 1 |p.\n   fst p \\<in> valid_states PROB \\<and>\n   snd p \\<in> valid_plans PROB} \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma td_UBound: \n  fixes PROB :: \"(('a, 'b) fmap \\<times> ('a, 'b) fmap) set\" \n  assumes \"finite PROB\" \"(\\<forall>s as. \n    (sat_precond_as s as) \\<and> (s \\<in> valid_states PROB) \\<and> (as \\<in> valid_plans PROB) \n    \\<longrightarrow> (card (traversed_states s as) \\<le> k)\n  )\"\n  shows \"(td PROB \\<le> k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "let ?S=\"{\n    (card (traversed_states (fst p) (snd p))) - 1 \n    | p. (fst p \\<in> valid_states PROB) \\<and> (snd p \\<in> valid_plans PROB)}\n  \""], ["proof (state)\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "assume \"x \\<in> ?S\""], ["proof (state)\nthis:\n  x \\<in> {card (traversed_states (fst p) (snd p)) - 1 |p.\n           fst p \\<in> valid_states PROB \\<and>\n           snd p \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "then"], ["proof (chain)\npicking this:\n  x \\<in> {card (traversed_states (fst p) (snd p)) - 1 |p.\n           fst p \\<in> valid_states PROB \\<and>\n           snd p \\<in> valid_plans PROB}", "obtain p where 1:\n      \"x = card (traversed_states (fst p) (snd p)) - 1\" \"fst p \\<in> valid_states PROB\" \n      \"snd p \\<in> valid_plans PROB\""], ["proof (prove)\nusing this:\n  x \\<in> {card (traversed_states (fst p) (snd p)) - 1 |p.\n           fst p \\<in> valid_states PROB \\<and>\n           snd p \\<in> valid_plans PROB}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>x = card (traversed_states (fst p) (snd p)) - 1;\n         fst p \\<in> valid_states PROB;\n         snd p \\<in> valid_plans PROB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = card (traversed_states (fst p) (snd p)) - 1\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "let ?s=\"fst p\""], ["proof (state)\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "let ?as=\"snd p\""], ["proof (state)\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "let ?as'=\"(rem_condless_act ?s [] ?as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "have 2: \"traversed_states ?s ?as = traversed_states ?s ?as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traversed_states (fst p) (snd p) =\n    traversed_states (fst p) (rem_condless_act (fst p) [] (snd p))", "using traversed_states_rem_condless_act"], ["proof (prove)\nusing this:\n  traversed_states ?s (rem_condless_act ?s [] ?as) = traversed_states ?s ?as\n\ngoal (1 subgoal):\n 1. traversed_states (fst p) (snd p) =\n    traversed_states (fst p) (rem_condless_act (fst p) [] (snd p))", "by blast"], ["proof (state)\nthis:\n  traversed_states (fst p) (snd p) =\n  traversed_states (fst p) (rem_condless_act (fst p) [] (snd p))\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "moreover"], ["proof (state)\nthis:\n  traversed_states (fst p) (snd p) =\n  traversed_states (fst p) (rem_condless_act (fst p) [] (snd p))\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "have \"sat_precond_as ?s ?as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_precond_as (fst p) (rem_condless_act (fst p) [] (snd p))", "using rem_condless_valid_2"], ["proof (prove)\nusing this:\n  sat_precond_as ?s (rem_condless_act ?s [] ?as)\n\ngoal (1 subgoal):\n 1. sat_precond_as (fst p) (rem_condless_act (fst p) [] (snd p))", "by blast"], ["proof (state)\nthis:\n  sat_precond_as (fst p) (rem_condless_act (fst p) [] (snd p))\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "moreover"], ["proof (state)\nthis:\n  sat_precond_as (fst p) (rem_condless_act (fst p) [] (snd p))\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "have \"?as' \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rem_condless_act (fst p) [] (snd p) \\<in> valid_plans PROB", "using 1(3) rem_condless_valid_10"], ["proof (prove)\nusing this:\n  snd p \\<in> valid_plans PROB\n  ?as \\<in> valid_plans ?PROB \\<Longrightarrow>\n  rem_condless_act ?s [] ?as \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. rem_condless_act (fst p) [] (snd p) \\<in> valid_plans PROB", "by blast"], ["proof (state)\nthis:\n  rem_condless_act (fst p) [] (snd p) \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "ultimately"], ["proof (chain)\npicking this:\n  traversed_states (fst p) (snd p) =\n  traversed_states (fst p) (rem_condless_act (fst p) [] (snd p))\n  sat_precond_as (fst p) (rem_condless_act (fst p) [] (snd p))\n  rem_condless_act (fst p) [] (snd p) \\<in> valid_plans PROB", "have \"card (traversed_states ?s ?as') \\<le> k\""], ["proof (prove)\nusing this:\n  traversed_states (fst p) (snd p) =\n  traversed_states (fst p) (rem_condless_act (fst p) [] (snd p))\n  sat_precond_as (fst p) (rem_condless_act (fst p) [] (snd p))\n  rem_condless_act (fst p) [] (snd p) \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. card (traversed_states (fst p) (rem_condless_act (fst p) [] (snd p)))\n    \\<le> k", "using assms(2) 1(2)"], ["proof (prove)\nusing this:\n  traversed_states (fst p) (snd p) =\n  traversed_states (fst p) (rem_condless_act (fst p) [] (snd p))\n  sat_precond_as (fst p) (rem_condless_act (fst p) [] (snd p))\n  rem_condless_act (fst p) [] (snd p) \\<in> valid_plans PROB\n  \\<forall>s as.\n     sat_precond_as s as \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     card (traversed_states s as) \\<le> k\n  fst p \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. card (traversed_states (fst p) (rem_condless_act (fst p) [] (snd p)))\n    \\<le> k", "by blast"], ["proof (state)\nthis:\n  card (traversed_states (fst p) (rem_condless_act (fst p) [] (snd p)))\n  \\<le> k\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "then"], ["proof (chain)\npicking this:\n  card (traversed_states (fst p) (rem_condless_act (fst p) [] (snd p)))\n  \\<le> k", "have \"card (traversed_states ?s ?as) \\<le> k\""], ["proof (prove)\nusing this:\n  card (traversed_states (fst p) (rem_condless_act (fst p) [] (snd p)))\n  \\<le> k\n\ngoal (1 subgoal):\n 1. card (traversed_states (fst p) (snd p)) \\<le> k", "using 2"], ["proof (prove)\nusing this:\n  card (traversed_states (fst p) (rem_condless_act (fst p) [] (snd p)))\n  \\<le> k\n  traversed_states (fst p) (snd p) =\n  traversed_states (fst p) (rem_condless_act (fst p) [] (snd p))\n\ngoal (1 subgoal):\n 1. card (traversed_states (fst p) (snd p)) \\<le> k", "by argo"], ["proof (state)\nthis:\n  card (traversed_states (fst p) (snd p)) \\<le> k\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "}"], ["proof (state)\nthis:\n  card (traversed_states (fst p) (snd p)) \\<le> k\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "then"], ["proof (chain)\npicking this:\n  card (traversed_states (fst p) (snd p)) \\<le> k", "have \"x \\<le> k - 1\""], ["proof (prove)\nusing this:\n  card (traversed_states (fst p) (snd p)) \\<le> k\n\ngoal (1 subgoal):\n 1. x \\<le> k - 1", "using 1"], ["proof (prove)\nusing this:\n  card (traversed_states (fst p) (snd p)) \\<le> k\n  x = card (traversed_states (fst p) (snd p)) - 1\n  fst p \\<in> valid_states PROB\n  snd p \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. x \\<le> k - 1", "by linarith"], ["proof (state)\nthis:\n  x \\<le> k - 1\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "}"], ["proof (state)\nthis:\n  ?x2\n  \\<in> {card (traversed_states (fst p) (snd p)) - 1 |p.\n         fst p \\<in> valid_states PROB \\<and>\n         snd p \\<in> valid_plans PROB} \\<Longrightarrow>\n  ?x2 \\<le> k - 1\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "moreover"], ["proof (state)\nthis:\n  ?x2\n  \\<in> {card (traversed_states (fst p) (snd p)) - 1 |p.\n         fst p \\<in> valid_states PROB \\<and>\n         snd p \\<in> valid_plans PROB} \\<Longrightarrow>\n  ?x2 \\<le> k - 1\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "have \"?S \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {card (traversed_states (fst p) (snd p)) - 1 |p.\n     fst p \\<in> valid_states PROB \\<and>\n     snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "using assms td_UBound_i"], ["proof (prove)\nusing this:\n  finite PROB\n  \\<forall>s as.\n     sat_precond_as s as \\<and>\n     s \\<in> valid_states PROB \\<and>\n     as \\<in> valid_plans PROB \\<longrightarrow>\n     card (traversed_states s as) \\<le> k\n  finite ?PROB \\<Longrightarrow>\n  {card (traversed_states (fst p) (snd p)) - 1 |p.\n   fst p \\<in> valid_states ?PROB \\<and>\n   snd p \\<in> valid_plans ?PROB} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. {card (traversed_states (fst p) (snd p)) - 1 |p.\n     fst p \\<in> valid_states PROB \\<and>\n     snd p \\<in> valid_plans PROB} \\<noteq>\n    {}", "by fast"], ["proof (state)\nthis:\n  {card (traversed_states (fst p) (snd p)) - 1 |p.\n   fst p \\<in> valid_states PROB \\<and>\n   snd p \\<in> valid_plans PROB} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "ultimately"], ["proof (chain)\npicking this:\n  ?x2\n  \\<in> {card (traversed_states (fst p) (snd p)) - 1 |p.\n         fst p \\<in> valid_states PROB \\<and>\n         snd p \\<in> valid_plans PROB} \\<Longrightarrow>\n  ?x2 \\<le> k - 1\n  {card (traversed_states (fst p) (snd p)) - 1 |p.\n   fst p \\<in> valid_states PROB \\<and>\n   snd p \\<in> valid_plans PROB} \\<noteq>\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x2\n  \\<in> {card (traversed_states (fst p) (snd p)) - 1 |p.\n         fst p \\<in> valid_states PROB \\<and>\n         snd p \\<in> valid_plans PROB} \\<Longrightarrow>\n  ?x2 \\<le> k - 1\n  {card (traversed_states (fst p) (snd p)) - 1 |p.\n   fst p \\<in> valid_states PROB \\<and>\n   snd p \\<in> valid_plans PROB} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. td PROB \\<le> k - 1", "unfolding td_def"], ["proof (prove)\nusing this:\n  ?x2\n  \\<in> {card (traversed_states (fst p) (snd p)) - 1 |p.\n         fst p \\<in> valid_states PROB \\<and>\n         snd p \\<in> valid_plans PROB} \\<Longrightarrow>\n  ?x2 \\<le> k - 1\n  {card (traversed_states (fst p) (snd p)) - 1 |p.\n   fst p \\<in> valid_states PROB \\<and>\n   snd p \\<in> valid_plans PROB} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Sup {card (traversed_states (fst p) (snd p)) - 1 |p.\n         fst p \\<in> valid_states PROB \\<and> snd p \\<in> valid_plans PROB}\n    \\<le> k - 1", "using td_UBound_i bound_main_lemma_2[of ?S \"k - 1\"]"], ["proof (prove)\nusing this:\n  ?x2\n  \\<in> {card (traversed_states (fst p) (snd p)) - 1 |p.\n         fst p \\<in> valid_states PROB \\<and>\n         snd p \\<in> valid_plans PROB} \\<Longrightarrow>\n  ?x2 \\<le> k - 1\n  {card (traversed_states (fst p) (snd p)) - 1 |p.\n   fst p \\<in> valid_states PROB \\<and>\n   snd p \\<in> valid_plans PROB} \\<noteq>\n  {}\n  finite ?PROB \\<Longrightarrow>\n  {card (traversed_states (fst p) (snd p)) - 1 |p.\n   fst p \\<in> valid_states ?PROB \\<and>\n   snd p \\<in> valid_plans ?PROB} \\<noteq>\n  {}\n  {card (traversed_states (fst p) (snd p)) - 1 |p.\n   fst p \\<in> valid_states PROB \\<and>\n   snd p \\<in> valid_plans PROB} \\<noteq>\n  {} \\<and>\n  (\\<forall>x.\n      x \\<in> {card (traversed_states (fst p) (snd p)) - 1 |p.\n               fst p \\<in> valid_states PROB \\<and>\n               snd p \\<in> valid_plans PROB} \\<longrightarrow>\n      x \\<le> k - 1) \\<Longrightarrow>\n  Sup {card (traversed_states (fst p) (snd p)) - 1 |p.\n       fst p \\<in> valid_states PROB \\<and> snd p \\<in> valid_plans PROB}\n  \\<le> k - 1\n\ngoal (1 subgoal):\n 1. Sup {card (traversed_states (fst p) (snd p)) - 1 |p.\n         fst p \\<in> valid_states PROB \\<and> snd p \\<in> valid_plans PROB}\n    \\<le> k - 1", "by presburger"], ["proof (state)\nthis:\n  td PROB \\<le> k - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}