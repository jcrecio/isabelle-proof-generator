{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/Power_Products.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemmas keys_eq_empty_iff = keys_eq_empty", "lemma in_Keys: \"s \\<in> Keys F \\<longleftrightarrow> (\\<exists>f\\<in>F. s \\<in> keys f)\"", "lemma in_KeysI:\n  assumes \"s \\<in> keys f\" and \"f \\<in> F\"\n  shows \"s \\<in> Keys F\"", "lemma in_KeysE:\n  assumes \"s \\<in> Keys F\"\n  obtains f where \"s \\<in> keys f\" and \"f \\<in> F\"", "lemma Keys_mono:\n  assumes \"A \\<subseteq> B\"\n  shows \"Keys A \\<subseteq> Keys B\"", "lemma Keys_insert: \"Keys (insert a A) = keys a \\<union> Keys A\"", "lemma Keys_Un: \"Keys (A \\<union> B) = Keys A \\<union> Keys B\"", "lemma finite_Keys:\n  assumes \"finite A\"\n  shows \"finite (Keys A)\"", "lemma Keys_not_empty:\n  assumes \"a \\<in> A\" and \"a \\<noteq> 0\"\n  shows \"Keys A \\<noteq> {}\"", "lemma Keys_empty [simp]: \"Keys {} = {}\"", "lemma Keys_zero [simp]: \"Keys {0} = {}\"", "lemma keys_subset_Keys:\n  assumes \"f \\<in> F\"\n  shows \"keys f \\<subseteq> Keys F\"", "lemma Keys_minus: \"Keys (A - B) \\<subseteq> Keys A\"", "lemma Keys_minus_zero: \"Keys (A - {0}) = Keys A\"", "lemma lookup_except_when: \"lookup (except p S) = (\\<lambda>t. lookup p t when t \\<notin> S)\"", "lemma lookup_except: \"lookup (except p S) = (\\<lambda>t. if t \\<in> S then 0 else lookup p t)\"", "lemma lookup_except_singleton: \"lookup (except p {t}) t = 0\"", "lemma except_zero [simp]: \"except 0 S = 0\"", "lemma lookup_except_eq_idI:\n  assumes \"t \\<notin> S\"\n  shows \"lookup (except p S) t = lookup p t\"", "lemma lookup_except_eq_zeroI:\n  assumes \"t \\<in> S\"\n  shows \"lookup (except p S) t = 0\"", "lemma except_empty [simp]: \"except p {} = p\"", "lemma except_eq_zeroI:\n  assumes \"keys p \\<subseteq> S\"\n  shows \"except p S = 0\"", "lemma except_eq_zeroE:\n  assumes \"except p S = 0\"\n  shows \"keys p \\<subseteq> S\"", "lemma except_eq_zero_iff: \"except p S = 0 \\<longleftrightarrow> keys p \\<subseteq> S\"", "lemma except_keys [simp]: \"except p (keys p) = 0\"", "lemma plus_except: \"p = Poly_Mapping.single t (lookup p t) + except p {t}\"", "lemma keys_except: \"keys (except p S) = keys p - S\"", "lemma except_single: \"except (Poly_Mapping.single u c) S = (Poly_Mapping.single u c when u \\<notin> S)\"", "lemma except_plus: \"except (p + q) S = except p S + except q S\"", "lemma except_minus: \"except (p - q) S = except p S - except q S\"", "lemma except_uminus: \"except (- p) S = - except p S\"", "lemma except_except: \"except (except p S) T = except p (S \\<union> T)\"", "lemma poly_mapping_keys_eqI:\n  assumes a1: \"keys p = keys q\" and a2: \"\\<And>t. t \\<in> keys p \\<Longrightarrow> lookup p t = lookup q t\"\n  shows \"p = q\"", "lemma except_id_iff: \"except p S = p \\<longleftrightarrow> keys p \\<inter> S = {}\"", "lemma keys_subset_wf:\n  \"wfP (\\<lambda>p q::('a, 'b::zero) poly_mapping. keys p \\<subset> keys q)\"", "lemma poly_mapping_except_induct:\n  assumes base: \"P 0\" and ind: \"\\<And>p t. p \\<noteq> 0 \\<Longrightarrow> t \\<in> keys p \\<Longrightarrow> P (except p {t}) \\<Longrightarrow> P p\"\n  shows \"P p\"", "lemma poly_mapping_except_induct':\n  assumes \"\\<And>p. (\\<And>t. t \\<in> keys p \\<Longrightarrow> P (except p {t})) \\<Longrightarrow> P p\"\n  shows \"P p\"", "lemma poly_mapping_plus_induct:\n  assumes \"P 0\" and \"\\<And>p c t. c \\<noteq> 0 \\<Longrightarrow> t \\<notin> keys p \\<Longrightarrow> P p \\<Longrightarrow> P (Poly_Mapping.single t c + p)\"\n  shows \"P p\"", "lemma except_Diff_singleton: \"except p (keys p - {t}) = Poly_Mapping.single t (lookup p t)\"", "lemma except_Un_plus_Int: \"except p (U \\<union> V) + except p (U \\<inter> V) = except p U + except p V\"", "lemma except_keys_Int [simp]: \"except p (keys p \\<inter> U) = except p U\"", "lemma except_Int_keys [simp]: \"except p (U \\<inter> keys p) = except p U\"", "lemma except_keys_Diff: \"except p (keys p - U) = except p (- U)\"", "lemma except_decomp: \"p = except p U + except p (- U)\"", "lemma addsI [intro?]: \"a = b + k \\<Longrightarrow> b adds a\"", "lemma addsE [elim?]: \"b adds a \\<Longrightarrow> (\\<And>k. a = b + k \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma adds_refl [simp]: \"a adds a\"", "lemma adds_trans [trans]:\n  assumes \"a adds b\" and \"b adds c\"\n  shows \"a adds c\"", "lemma subset_divisors_adds: \"{c. c adds a} \\<subseteq> {c. c adds b} \\<longleftrightarrow> a adds b\"", "lemma strict_subset_divisors_adds: \"{c. c adds a} \\<subset> {c. c adds b} \\<longleftrightarrow> a adds b \\<and> \\<not> b adds a\"", "lemma zero_adds [simp]: \"0 adds a\"", "lemma adds_plus_right [simp]: \"a adds c \\<Longrightarrow> a adds (b + c)\"", "lemma adds_plus_left [simp]: \"a adds b \\<Longrightarrow> a adds (b + c)\"", "lemma adds_triv_right [simp]: \"a adds b + a\"", "lemma adds_triv_left [simp]: \"a adds a + b\"", "lemma plus_adds_mono:\n  assumes \"a adds b\"\n    and \"c adds d\"\n  shows \"a + c adds b + d\"", "lemma plus_adds_left: \"a + b adds c \\<Longrightarrow> a adds c\"", "lemma plus_adds_right: \"a + b adds c \\<Longrightarrow> b adds c\"", "lemma plus_eq_zero_2: \"t = 0\" if \"s + t = 0\"", "lemma adds_zero: \"s adds 0 \\<longleftrightarrow> (s = 0)\"", "lemma adds_canc: \"s + u adds t + u \\<longleftrightarrow> s adds t\" for s t u::'a", "lemma adds_canc_2: \"u + s adds u + t \\<longleftrightarrow> s adds t\"", "lemma add_minus_2: \"(s + t) - s = t\"", "lemma adds_minus:\n  assumes \"s adds t\"\n  shows \"(t - s) + s = t\"", "lemma plus_adds_0:\n  assumes \"(s + t) adds u\"\n  shows \"s adds (u - t)\"", "lemma plus_adds_2:\n  assumes \"t adds u\" and \"s adds (u - t)\"\n  shows \"(s + t) adds u\"", "lemma plus_adds:\n  shows \"(s + t) adds u \\<longleftrightarrow> (t adds u \\<and> s adds (u - t))\"", "lemma minus_plus:\n  assumes \"s adds t\"\n  shows \"(t - s) + u = (t + u) - s\"", "lemma minus_plus_minus:\n  assumes \"s adds t\" and \"u adds v\"\n  shows \"(t - s) + (v - u) = (t + v) - (s + u)\"", "lemma minus_plus_minus_cancel:\n  assumes \"u adds t\" and \"s adds u\"\n  shows \"(t - u) + (u - s) = t - s\"", "lemma adds_lcs_2: \"t adds (lcs s t)\"", "lemma lcs_adds_plus: \"lcs s t adds s + t\"", "lemma gcs_plus_lcs: \"(gcs s t) + (lcs s t) = s + t\"", "lemma gcs_adds: \"(gcs s t) adds s\"", "lemma gcs_comm: \"gcs s t = gcs t s\"", "lemma gcs_adds_2: \"(gcs s t) adds t\"", "lemma adds_antisym:\n  assumes \"s adds t\" \"t adds s\"\n  shows \"s = t\"", "lemma lcs_unique:\n  assumes \"s adds l\" and \"t adds l\" and *: \"\\<And>u. s adds u \\<Longrightarrow> t adds u \\<Longrightarrow> l adds u\"\n  shows \"l = lcs s t\"", "lemma lcs_zero: \"lcs 0 t = t\"", "lemma lcs_plus_left: \"lcs (u + s) (u + t) = u + lcs s t\"", "lemma lcs_plus_right: \"lcs (s + u) (t + u) = (lcs s t) + u\"", "lemma adds_gcs:\n  assumes \"u adds s\" and \"u adds t\"\n  shows \"u adds (gcs s t)\"", "lemma gcs_unique:\n  assumes \"g adds s\" and \"g adds t\" and *: \"\\<And>u. u adds s \\<Longrightarrow> u adds t \\<Longrightarrow> u adds g\"\n  shows \"g = gcs s t\"", "lemma gcs_plus_left: \"gcs (u + s) (u + t) = u + gcs s t\"", "lemma gcs_plus_right: \"gcs (s + u) (t + u) = (gcs s t) + u\"", "lemma lcs_same [simp]: \"lcs s s = s\"", "lemma gcs_same [simp]: \"gcs s s = s\"", "lemma dickson_gradingI:\n  assumes \"\\<And>s t. d (s + t) = max (d s) (d t)\"\n  assumes \"\\<And>n::nat. almost_full_on (adds) {x. d x \\<le> n}\"\n  shows \"dickson_grading d\"", "lemma dickson_gradingD1: \"dickson_grading d \\<Longrightarrow> d (s + t) = max (d s) (d t)\"", "lemma dickson_gradingD2: \"dickson_grading d \\<Longrightarrow> almost_full_on (adds) {x. d x \\<le> n}\"", "lemma dickson_gradingD2':\n  assumes \"dickson_grading (d::'a::comm_monoid_add \\<Rightarrow> nat)\"\n  shows \"wqo_on (adds) {x. d x \\<le> n}\"", "lemma dickson_gradingE:\n  assumes \"dickson_grading d\" and \"\\<And>i::nat. d ((seq::nat \\<Rightarrow> 'a::plus) i) \\<le> n\"\n  obtains i j where \"i < j\" and \"seq i adds seq j\"", "lemma dickson_grading_adds_imp_le:\n  assumes \"dickson_grading d\" and \"s adds t\"\n  shows \"d s \\<le> d t\"", "lemma dickson_grading_minus:\n  assumes \"dickson_grading d\" and \"s adds (t::'a::cancel_ab_semigroup_add)\"\n  shows \"d (t - s) \\<le> d t\"", "lemma dickson_grading_lcs:\n  assumes \"dickson_grading d\"\n  shows \"d (lcs s t) \\<le> max (d s) (d t)\"", "lemma dickson_grading_lcs_minus:\n  assumes \"dickson_grading d\"\n  shows \"d (lcs s t - s) \\<le> max (d s) (d t)\"", "lemma dgrad_set_leI:\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. d s \\<le> d t\"\n  shows \"dgrad_set_le d S T\"", "lemma dgrad_set_leE:\n  assumes \"dgrad_set_le d S T\" and \"s \\<in> S\"\n  obtains t where \"t \\<in> T\" and \"d s \\<le> d t\"", "lemma dgrad_set_exhaust_expl:\n  assumes \"finite F\"\n  shows \"F \\<subseteq> dgrad_set d (Max (d ` F))\"", "lemma dgrad_set_exhaust:\n  assumes \"finite F\"\n  obtains m where \"F \\<subseteq> dgrad_set d m\"", "lemma dgrad_set_le_trans [trans]:\n  assumes \"dgrad_set_le d S T\" and \"dgrad_set_le d T U\"\n  shows \"dgrad_set_le d S U\"", "lemma dgrad_set_le_Un: \"dgrad_set_le d (S \\<union> T) U \\<longleftrightarrow> (dgrad_set_le d S U \\<and> dgrad_set_le d T U)\"", "lemma dgrad_set_le_subset:\n  assumes \"S \\<subseteq> T\"\n  shows \"dgrad_set_le d S T\"", "lemma dgrad_set_le_refl: \"dgrad_set_le d S S\"", "lemma dgrad_set_le_dgrad_set:\n  assumes \"dgrad_set_le d F G\" and \"G \\<subseteq> dgrad_set d m\"\n  shows \"F \\<subseteq> dgrad_set d m\"", "lemma dgrad_set_dgrad: \"p \\<in> dgrad_set d (d p)\"", "lemma dgrad_setI [intro]:\n  assumes \"d t \\<le> m\"\n  shows \"t \\<in> dgrad_set d m\"", "lemma dgrad_setD:\n  assumes \"t \\<in> dgrad_set d m\"\n  shows \"d t \\<le> m\"", "lemma dgrad_set_zero [simp]: \"dgrad_set (\\<lambda>_. 0) m = UNIV\"", "lemma subset_dgrad_set_zero: \"F \\<subseteq> dgrad_set (\\<lambda>_. 0) m\"", "lemma dgrad_set_subset:\n  assumes \"m \\<le> n\"\n  shows \"dgrad_set d m \\<subseteq> dgrad_set d n\"", "lemma dgrad_set_closed_plus:\n  assumes \"dickson_grading d\" and \"s \\<in> dgrad_set d m\" and \"t \\<in> dgrad_set d m\"\n  shows \"s + t \\<in> dgrad_set d m\"", "lemma dgrad_set_closed_minus:\n  assumes \"dickson_grading d\" and \"s \\<in> dgrad_set d m\" and \"t adds (s::'a::cancel_ab_semigroup_add)\"\n  shows \"s - t \\<in> dgrad_set d m\"", "lemma dgrad_set_closed_lcs:\n  assumes \"dickson_grading d\" and \"s \\<in> dgrad_set d m\" and \"t \\<in> dgrad_set d m\"\n  shows \"lcs s t \\<in> dgrad_set d m\"", "lemma dickson_gradingD_dgrad_set: \"dickson_grading d \\<Longrightarrow> almost_full_on (adds) (dgrad_set d m)\"", "lemma ex_finite_adds:\n  assumes \"dickson_grading d\" and \"S \\<subseteq> dgrad_set d m\"\n  obtains T where \"finite T\" and \"T \\<subseteq> S\" and \"\\<And>s. s \\<in> S \\<Longrightarrow> (\\<exists>t\\<in>T. t adds (s::'a::cancel_comm_monoid_add))\"", "lemma dickson_grading_dgrad_dummy: \"dickson_grading dgrad_dummy\"", "lemma dickson_grading_zero: \"dickson_grading (\\<lambda>_::'a. 0)\"", "lemma group_eq_aux: \"a + (b - a) = (b::'a::ab_group_add)\"", "lemma le_imp_inv:\n  assumes \"a \\<le> b\"\n  shows \"b = a + (b - a)\"", "lemma max_eq_sum:\n  obtains y where \"max a b = a + y\"", "lemma min_plus_max:\n  shows \"(min a b) + (max a b) = a + b\"", "lemma leq_add_right:\n  shows \"x \\<le> x + y\"", "lemma leq_add_left:\n  shows \"x \\<le> y + x\"", "lemma ord_canc:\n  assumes \"s + u \\<preceq> t + u\"\n  shows \"s \\<preceq> t\"", "lemma ord_adds:\n  assumes \"s adds t\"\n  shows \"s \\<preceq> t\"", "lemma ord_canc_left:\n  assumes \"u + s \\<preceq> u + t\"\n  shows \"s \\<preceq> t\"", "lemma ord_strict_canc:\n  assumes \"s + u \\<prec> t + u\"\n  shows \"s \\<prec> t\"", "lemma ord_strict_canc_left:\n  assumes \"u + s \\<prec> u + t\"\n  shows \"s \\<prec> t\"", "lemma plus_monotone_left:\n  assumes \"s \\<preceq> t\"\n  shows \"u + s \\<preceq> u + t\"", "lemma plus_monotone_strict:\n  assumes \"s \\<prec> t\"\n  shows \"s + u \\<prec> t + u\"", "lemma plus_monotone_strict_left:\n  assumes \"s \\<prec> t\"\n  shows \"u + s \\<prec> u + t\"", "lemma dickson_leI:\n  assumes \"d s \\<le> m\" and \"d t \\<le> m\" and \"s \\<preceq> t\"\n  shows \"dickson_le d m s t\"", "lemma dickson_leD1:\n  assumes \"dickson_le d m s t\"\n  shows \"d s \\<le> m\"", "lemma dickson_leD2:\n  assumes \"dickson_le d m s t\"\n  shows \"d t \\<le> m\"", "lemma dickson_leD3:\n  assumes \"dickson_le d m s t\"\n  shows \"s \\<preceq> t\"", "lemma dickson_le_trans:\n  assumes \"dickson_le d m s t\" and \"dickson_le d m t u\"\n  shows \"dickson_le d m s u\"", "lemma dickson_lessI:\n  assumes \"d s \\<le> m\" and \"d t \\<le> m\" and \"s \\<prec> t\"\n  shows \"dickson_less d m s t\"", "lemma dickson_lessD1:\n  assumes \"dickson_less d m s t\"\n  shows \"d s \\<le> m\"", "lemma dickson_lessD2:\n  assumes \"dickson_less d m s t\"\n  shows \"d t \\<le> m\"", "lemma dickson_lessD3:\n  assumes \"dickson_less d m s t\"\n  shows \"s \\<prec> t\"", "lemma dickson_less_irrefl: \"\\<not> dickson_less d m t t\"", "lemma dickson_less_trans:\n  assumes \"dickson_less d m s t\" and \"dickson_less d m t u\"\n  shows \"dickson_less d m s u\"", "lemma transp_dickson_less: \"transp (dickson_less d m)\"", "lemma wfp_on_ord_strict:\n  assumes \"dickson_grading d\"\n  shows \"wfp_on (\\<prec>) {x. d x \\<le> n}\"", "lemma wf_dickson_less:\n  assumes \"dickson_grading d\"\n  shows \"wfP (dickson_less d m)\"", "lemma wf_ord_strict: \"wfP (\\<prec>)\"", "lemma finite_neq_0:\n  assumes fin_A: \"finite {x. f x \\<noteq> 0}\" and fin_B: \"finite {x. g x \\<noteq> 0}\" and \"\\<And>x. h x 0 0 = 0\"\n  shows \"finite {x. h x (f x) (g x) \\<noteq> 0}\"", "lemma finite_neq_0':\n  assumes \"finite {x. f x \\<noteq> 0}\" and \"finite {x. g x \\<noteq> 0}\" and \"h 0 0 = 0\"\n  shows \"finite {x. h (f x) (g x) \\<noteq> 0}\"", "lemma finite_neq_0_inv:\n  assumes fin_A: \"finite {x. h x (f x) (g x) \\<noteq> 0}\" and fin_B: \"finite {x. f x \\<noteq> 0}\" and \"\\<And>x y. h x 0 y = y\"\n  shows \"finite {x. g x \\<noteq> 0}\"", "lemma finite_neq_0_inv':\n  assumes inf_A: \"finite {x. h (f x) (g x) \\<noteq> 0}\" and fin_B: \"finite {x. f x \\<noteq> 0}\" and \"\\<And>x. h 0 x = x\"\n  shows \"finite {x. g x \\<noteq> 0}\"", "lemma adds_funI:\n  assumes \"s \\<le> t\"\n  shows \"s adds (t::'a \\<Rightarrow> 'b)\"", "lemma adds_fun_iff: \"f adds (g::'a \\<Rightarrow> 'b) \\<longleftrightarrow> (\\<forall>x. f x adds g x)\"", "lemma adds_fun_iff': \"f adds (g::'a \\<Rightarrow> 'b) \\<longleftrightarrow> (\\<forall>x. \\<exists>y. g x = f x + y)\"", "lemma adds_lcs_fun:\n  shows \"s adds (lcs s (t::'a \\<Rightarrow> 'b))\"", "lemma lcs_comm_fun:  \"lcs s t = lcs t (s::'a \\<Rightarrow> 'b)\"", "lemma lcs_adds_fun:\n  assumes \"s adds u\" and \"t adds (u::'a \\<Rightarrow> 'b)\"\n  shows \"(lcs s t) adds u\"", "lemma leq_lcs_fun_1: \"s \\<le> (lcs s (t::'a \\<Rightarrow> 'b::add_linorder))\"", "lemma leq_lcs_fun_2: \"t \\<le> (lcs s (t::'a \\<Rightarrow> 'b::add_linorder))\"", "lemma lcs_leq_fun:\n  assumes \"s \\<le> u\" and \"t \\<le> (u::'a \\<Rightarrow> 'b::add_linorder)\"\n  shows \"(lcs s t) \\<le> u\"", "lemma adds_fun: \"s adds t \\<longleftrightarrow> s \\<le> t\"\n  for s t::\"'a \\<Rightarrow> 'b::add_linorder_min\"", "lemma gcs_fun: \"gcs s (t::'a \\<Rightarrow> ('b::add_linorder)) = (\\<lambda>x. min (s x) (t x))\"", "lemma gcs_leq_fun_1: \"(gcs s (t::'a \\<Rightarrow> 'b::add_linorder)) \\<le> s\"", "lemma gcs_leq_fun_2: \"(gcs s (t::'a \\<Rightarrow> 'b::add_linorder)) \\<le> t\"", "lemma leq_gcs_fun:\n  assumes \"u \\<le> s\" and \"u \\<le> (t::'a \\<Rightarrow> 'b::add_linorder)\"\n  shows \"u \\<le> (gcs s t)\"", "lemma keys_eq_supp: \"keys s = supp_fun (lookup s)\"", "lemma supp_fun_zero [simp]: \"supp_fun 0 = {}\"", "lemma supp_fun_eq_zero_iff: \"supp_fun f = {} \\<longleftrightarrow> f = 0\"", "lemma sub_supp_empty: \"supp_fun s \\<subseteq> {} \\<longleftrightarrow> (s = 0)\"", "lemma except_fun_idI: \"supp_fun f \\<inter> V = {} \\<Longrightarrow> except_fun f V = f\"", "lemma supp_except_fun: \"supp_fun (except_fun s V) = supp_fun s - V\"", "lemma supp_fun_plus_subset: \"supp_fun (s + t) \\<subseteq> supp_fun s \\<union> supp_fun (t::'a \\<Rightarrow> 'b::monoid_add)\"", "lemma fun_eq_zeroI:\n  assumes \"\\<And>x. x \\<in> supp_fun f \\<Longrightarrow> f x = 0\"\n  shows \"f = 0\"", "lemma except_fun_cong1:\n  \"supp_fun s \\<inter> ((V - U) \\<union> (U - V)) \\<subseteq> {} \\<Longrightarrow> except_fun s V = except_fun s U\"", "lemma adds_except_fun:\n  \"s adds t = (except_fun s V adds except_fun t V \\<and> except_fun s (- V) adds except_fun t (- V))\"\n  for s t :: \"'a \\<Rightarrow> 'b::add_linorder\"", "lemma adds_except_fun_singleton: \"s adds t = (except_fun s {v} adds except_fun t {v} \\<and> s v adds t v)\"\n  for s t :: \"'a \\<Rightarrow> 'b::add_linorder\"", "lemma Dickson_fun:\n  assumes \"finite V\"\n  shows \"almost_full_on (adds) {x::'a \\<Rightarrow> 'b::add_wellorder. supp_fun x \\<subseteq> V}\"", "lemma neq_fun_alt:\n  assumes \"s \\<noteq> (t::'a \\<Rightarrow> 'b)\"\n  obtains x where \"s x \\<noteq> t x\" and \"\\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y\"", "lemma lex_fun_alt:\n  shows \"lex_fun s t = (s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)))\" (is \"?L = ?R\")", "lemma lex_fun_refl: \"lex_fun s s\"", "lemma lex_fun_antisym:\n  assumes \"lex_fun s t\" and \"lex_fun t s\"\n  shows \"s = t\"", "lemma lex_fun_trans:\n  assumes \"lex_fun s t\" and \"lex_fun t u\"\n  shows \"lex_fun s u\"", "lemma lex_fun_lin: \"lex_fun s t \\<or> lex_fun t s\" for s t::\"'a \\<Rightarrow> 'b::{ordered_comm_monoid_add, linorder}\"", "lemma lex_fun_zero_min: \"lex_fun 0 s\" for s::\"'a \\<Rightarrow> 'b::add_linorder_min\"", "lemma lex_fun_plus_monotone:\n  \"lex_fun (s + u) (t + u)\" if \"lex_fun s t\"\n  for s t::\"'a \\<Rightarrow> 'b::ordered_cancel_comm_monoid_add\"", "lemma deg_fun_zero[simp]: \"deg_fun 0 = 0\"", "lemma deg_fun_eq_0_iff:\n  assumes \"finite (supp_fun (s::'a \\<Rightarrow> 'b::add_linorder_min))\"\n  shows \"deg_fun s = 0 \\<longleftrightarrow> s = 0\"", "lemma deg_fun_superset:\n  fixes A::\"'a set\"\n  assumes \"supp_fun s \\<subseteq> A\" and \"finite A\"\n  shows \"deg_fun s = (\\<Sum>x\\<in>A. s x)\"", "lemma deg_fun_plus:\n  assumes \"finite (supp_fun s)\" and \"finite (supp_fun t)\"\n  shows \"deg_fun (s + t) = deg_fun s + deg_fun (t::'a \\<Rightarrow> 'b::comm_monoid_add)\"", "lemma deg_fun_leq:\n  assumes \"finite (supp_fun s)\" and \"finite (supp_fun t)\" and \"s \\<le> (t::'a \\<Rightarrow> 'b::ordered_comm_monoid_add)\"\n  shows \"deg_fun s \\<le> deg_fun t\"", "lemma ex_min:\n  assumes \"finite (A::'a set)\" and \"A \\<noteq> {}\"\n  shows \"\\<exists>y\\<in>A. (\\<forall>z\\<in>A. y \\<le> z)\"", "lemma dord_fun_degD:\n  assumes \"dord_fun ord s t\"\n  shows \"deg_fun s \\<le> deg_fun t\"", "lemma dord_fun_refl:\n  assumes \"ord s s\"\n  shows \"dord_fun ord s s\"", "lemma dord_fun_antisym:\n  assumes ord_antisym: \"ord s t \\<Longrightarrow> ord t s \\<Longrightarrow> s = t\" and \"dord_fun ord s t\" and \"dord_fun ord t s\"\n  shows \"s = t\"", "lemma dord_fun_trans:\n  assumes ord_trans: \"ord s t \\<Longrightarrow> ord t u \\<Longrightarrow> ord s u\" and \"dord_fun ord s t\" and \"dord_fun ord t u\"\n  shows \"dord_fun ord s u\"", "lemma dord_fun_lin:\n  \"dord_fun ord s t \\<or> dord_fun ord t s\"\n  if \"ord s t \\<or> ord t s\"\n  for s t::\"'a \\<Rightarrow> 'b::{ordered_comm_monoid_add, linorder}\"", "lemma dord_fun_zero_min:\n  fixes s t::\"'a \\<Rightarrow> 'b::add_linorder_min\"\n  assumes ord_refl: \"\\<And>t. ord t t\" and \"finite (supp_fun s)\"\n  shows \"dord_fun ord 0 s\"", "lemma dord_fun_plus_monotone:\n  fixes s t u ::\"'a \\<Rightarrow> 'b::{ordered_comm_monoid_add, ordered_ab_semigroup_add_imp_le}\"\n  assumes ord_monotone: \"ord s t \\<Longrightarrow> ord (s + u) (t + u)\" and \"finite (supp_fun s)\"\n    and \"finite (supp_fun t)\" and \"finite (supp_fun u)\" and \"dord_fun ord s t\"\n  shows \"dord_fun ord (s + u) (t + u)\"", "lemma dlex_fun_refl:\n  shows \"dlex_fun s s\"", "lemma dlex_fun_antisym:\n  assumes \"dlex_fun s t\" and \"dlex_fun t s\"\n  shows \"s = t\"", "lemma dlex_fun_trans:\n  assumes \"dlex_fun s t\" and \"dlex_fun t u\"\n  shows \"dlex_fun s u\"", "lemma dlex_fun_lin: \"dlex_fun s t \\<or> dlex_fun t s\"\n  for s t::\"('a \\<Rightarrow> 'b::{ordered_comm_monoid_add, linorder})\"", "lemma dlex_fun_zero_min:\n  fixes s t::\"('a \\<Rightarrow> 'b::add_linorder_min)\"\n  assumes \"finite (supp_fun s)\"\n  shows \"dlex_fun 0 s\"", "lemma dlex_fun_plus_monotone:\n  fixes s t u::\"'a \\<Rightarrow> 'b::{ordered_cancel_comm_monoid_add, ordered_ab_semigroup_add_imp_le}\"\n  assumes \"finite (supp_fun s)\" and \"finite (supp_fun t)\" and \"finite (supp_fun u)\" and \"dlex_fun s t\"\n  shows \"dlex_fun (s + u) (t + u)\"", "lemma drlex_fun_refl:\n  shows \"drlex_fun s s\"", "lemma drlex_fun_antisym:\n  assumes \"drlex_fun s t\" and \"drlex_fun t s\"\n  shows \"s = t\"", "lemma drlex_fun_trans:\n  assumes \"drlex_fun s t\" and \"drlex_fun t u\"\n  shows \"drlex_fun s u\"", "lemma drlex_fun_lin: \"drlex_fun s t \\<or> drlex_fun t s\"\n  for s t::\"('a \\<Rightarrow> 'b::{ordered_comm_monoid_add, linorder})\"", "lemma drlex_fun_zero_min:\n  fixes s t::\"('a \\<Rightarrow> 'b::add_linorder_min)\"\n  assumes \"finite (supp_fun s)\"\n  shows \"drlex_fun 0 s\"", "lemma drlex_fun_plus_monotone:\n  fixes s t u::\"'a \\<Rightarrow> 'b::{ordered_cancel_comm_monoid_add, ordered_ab_semigroup_add_imp_le}\"\n  assumes \"finite (supp_fun s)\" and \"finite (supp_fun t)\" and \"finite (supp_fun u)\" and \"drlex_fun s t\"\n  shows \"drlex_fun (s + u) (t + u)\"", "lemma poly_mapping_eq_zeroI:\n  assumes \"keys s = {}\"\n  shows \"s = (0::('a, 'b::zero) poly_mapping)\"", "lemma keys_plus_ninv_comm_monoid_add: \"keys (s + t) = keys s \\<union> keys (t::'a \\<Rightarrow>\\<^sub>0 'b::ninv_comm_monoid_add)\"", "lemma lookup_zero_fun: \"lookup 0 = 0\"", "lemma lookup_plus_fun: \"lookup (s + t) = lookup s + lookup t\"", "lemma lookup_uminus_fun: \"lookup (- s) = - lookup s\"", "lemma lookup_minus_fun: \"lookup (s - t) = lookup s - lookup t\"", "lemma poly_mapping_adds_iff: \"s adds t \\<longleftrightarrow> lookup s adds lookup t\"", "lemma adds_poly_mappingI:\n  assumes \"lookup s \\<le> lookup (t::'a \\<Rightarrow>\\<^sub>0 'b)\"\n  shows \"s adds t\"", "lemma lookup_lcs_fun: \"lookup (lcs s t) = lcs (lookup s) (lookup (t:: 'a \\<Rightarrow>\\<^sub>0 'b))\"", "lemma adds_poly_mapping: \"s adds t \\<longleftrightarrow> lookup s \\<le> lookup t\"\n  for s t::\"'a \\<Rightarrow>\\<^sub>0 'b::add_linorder_min\"", "lemma lookup_gcs_fun: \"lookup (gcs s (t::'a \\<Rightarrow>\\<^sub>0 ('b::add_linorder))) = gcs (lookup s) (lookup t)\"", "lemma adds_except:\n  \"s adds t = (except s V adds except t V \\<and> except s (- V) adds except t (- V))\"\n  for s t :: \"'a \\<Rightarrow>\\<^sub>0 'b::add_linorder\"", "lemma adds_except_singleton:\n  \"s adds t \\<longleftrightarrow> (except s {v} adds except t {v} \\<and> lookup s v adds lookup t v)\"\n  for s t :: \"'a \\<Rightarrow>\\<^sub>0 'b::add_linorder\"", "lemma inj_elem_index: \"inj elem_index\"", "lemma elem_index_inj:\n  assumes \"elem_index x = elem_index y\"\n  shows \"x = y\"", "lemma finite_nat_seg: \"finite {x. elem_index x < n}\"", "lemma Dickson_poly_mapping:\n  assumes \"finite V\"\n  shows \"almost_full_on (adds) {x::'a \\<Rightarrow>\\<^sub>0 'b::add_wellorder. keys x \\<subseteq> V}\"", "lemma elem_index_less_varnum:\n  assumes \"x \\<in> keys t\"\n  obtains \"x \\<in> X\" | \"elem_index x < varnum X t\"", "lemma varnum_plus:\n  \"varnum X (s + t) = max (varnum X s) (varnum X (t::'x::countable \\<Rightarrow>\\<^sub>0 'b::ninv_comm_monoid_add))\"", "lemma dickson_grading_varnum:\n  assumes \"finite X\"\n  shows \"dickson_grading ((varnum X)::('x::countable \\<Rightarrow>\\<^sub>0 'b::add_wellorder) \\<Rightarrow> nat)\"", "lemma varnum_le_iff: \"varnum X t \\<le> n \\<longleftrightarrow> keys t \\<subseteq> X \\<union> {x. elem_index x < n}\"", "lemma varnum_zero [simp]: \"varnum X 0 = 0\"", "lemma varnum_empty_eq_zero_iff: \"varnum {} t = 0 \\<longleftrightarrow> t = 0\"", "lemma lex_pm_alt: \"lex_pm s t = (s = t \\<or> (\\<exists>x. lookup s x < lookup t x \\<and> (\\<forall>y<x. lookup s y = lookup t y)))\"", "lemma lex_pm_refl: \"lex_pm s s\"", "lemma lex_pm_antisym: \"lex_pm s t \\<Longrightarrow> lex_pm t s \\<Longrightarrow> s = t\"", "lemma lex_pm_trans: \"lex_pm s t \\<Longrightarrow> lex_pm t u \\<Longrightarrow> lex_pm s u\"", "lemma lex_pm_lin: \"lex_pm s t \\<or> lex_pm t s\"", "lemma lex_pm_zero_min: \"lex_pm 0 s\" for s::\"_ \\<Rightarrow>\\<^sub>0 _::add_linorder_min\"", "lemma lex_pm_plus_monotone: \"lex_pm s t \\<Longrightarrow> lex_pm (s + u) (t + u)\"\n  for s t::\"_ \\<Rightarrow>\\<^sub>0 _::{ordered_comm_monoid_add, ordered_ab_semigroup_add_imp_le}\"", "lemma deg_pm_zero[simp]: \"deg_pm 0 = 0\"", "lemma deg_pm_eq_0_iff[simp]: \"deg_pm s = 0 \\<longleftrightarrow> s = 0\" for s::\"'a \\<Rightarrow>\\<^sub>0 'b::add_linorder_min\"", "lemma deg_pm_superset:\n  assumes \"keys s \\<subseteq> A\" and \"finite A\"\n  shows \"deg_pm s = (\\<Sum>x\\<in>A. lookup s x)\"", "lemma deg_pm_plus: \"deg_pm (s + t) = deg_pm s + deg_pm (t::'a \\<Rightarrow>\\<^sub>0 'b::comm_monoid_add)\"", "lemma deg_pm_single: \"deg_pm (Poly_Mapping.single x k) = k\"", "lemma dord_pm_alt: \"dord_pm ord = (\\<lambda>x y. deg_pm x < deg_pm y \\<or> (deg_pm x = deg_pm y \\<and> ord x y))\"", "lemma dord_pm_degD:\n  assumes \"dord_pm ord s t\"\n  shows \"deg_pm s \\<le> deg_pm t\"", "lemma dord_pm_refl:\n  assumes \"ord s s\"\n  shows \"dord_pm ord s s\"", "lemma dord_pm_antisym:\n  assumes \"ord s t \\<Longrightarrow> ord t s \\<Longrightarrow> s = t\" and \"dord_pm ord s t\" and \"dord_pm ord t s\"\n  shows \"s = t\"", "lemma dord_pm_trans:\n  assumes \"ord s t \\<Longrightarrow> ord t u \\<Longrightarrow> ord s u\" and \"dord_pm ord s t\" and \"dord_pm ord t u\"\n  shows \"dord_pm ord s u\"", "lemma dord_pm_lin:\n  \"dord_pm ord s t \\<or> dord_pm ord t s\"\n  if \"ord s t \\<or> ord t s\"\n  for s t::\"'a \\<Rightarrow>\\<^sub>0 'b::{ordered_comm_monoid_add, linorder}\"", "lemma dord_pm_zero_min: \"dord_pm ord 0 s\"\n  if ord_refl: \"\\<And>t. ord t t\"\n  for s t::\"'a \\<Rightarrow>\\<^sub>0 'b::add_linorder_min\"", "lemma dord_pm_plus_monotone:\n  fixes s t u ::\"'a \\<Rightarrow>\\<^sub>0 'b::{ordered_comm_monoid_add, ordered_ab_semigroup_add_imp_le}\"\n  assumes \"ord s t \\<Longrightarrow> ord (s + u) (t + u)\" and \"dord_pm ord s t\"\n  shows \"dord_pm ord (s + u) (t + u)\"", "lemma dlex_pm_refl: \"dlex_pm s s\"", "lemma dlex_pm_antisym: \"dlex_pm s t \\<Longrightarrow> dlex_pm t s \\<Longrightarrow> s = t\"", "lemma dlex_pm_trans: \"dlex_pm s t \\<Longrightarrow> dlex_pm t u \\<Longrightarrow> dlex_pm s u\"", "lemma dlex_pm_lin: \"dlex_pm s t \\<or> dlex_pm t s\"", "lemma dlex_pm_zero_min: \"dlex_pm 0 s\"\n  for s t::\"(_ \\<Rightarrow>\\<^sub>0 _::add_linorder_min)\"", "lemma dlex_pm_plus_monotone: \"dlex_pm s t \\<Longrightarrow> dlex_pm (s + u) (t + u)\"\n  for s t::\"_ \\<Rightarrow>\\<^sub>0 _::{ordered_ab_semigroup_add_imp_le, ordered_cancel_comm_monoid_add}\"", "lemma drlex_pm_refl: \"drlex_pm s s\"", "lemma drlex_pm_antisym: \"drlex_pm s t \\<Longrightarrow> drlex_pm t s \\<Longrightarrow> s = t\"", "lemma drlex_pm_trans: \"drlex_pm s t \\<Longrightarrow> drlex_pm t u \\<Longrightarrow> drlex_pm s u\"", "lemma drlex_pm_lin: \"drlex_pm s t \\<or> drlex_pm t s\"", "lemma drlex_pm_zero_min: \"drlex_pm 0 s\"\n  for s t::\"(_ \\<Rightarrow>\\<^sub>0 _::add_linorder_min)\"", "lemma drlex_pm_plus_monotone: \"drlex_pm s t \\<Longrightarrow> drlex_pm (s + u) (t + u)\"\n  for s t::\"_ \\<Rightarrow>\\<^sub>0 _::{ordered_ab_semigroup_add_imp_le, ordered_cancel_comm_monoid_add}\""], "translations": [["", "lemmas keys_eq_empty_iff = keys_eq_empty"], ["", "definition Keys :: \"('a \\<Rightarrow>\\<^sub>0 'b::zero) set \\<Rightarrow> 'a set\"\n  where \"Keys F = \\<Union>(keys ` F)\""], ["", "lemma in_Keys: \"s \\<in> Keys F \\<longleftrightarrow> (\\<exists>f\\<in>F. s \\<in> keys f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<in> Keys F) = (\\<exists>f\\<in>F. s \\<in> keys f)", "unfolding Keys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<in> \\<Union> (keys ` F)) = (\\<exists>f\\<in>F. s \\<in> keys f)", "by simp"], ["", "lemma in_KeysI:\n  assumes \"s \\<in> keys f\" and \"f \\<in> F\"\n  shows \"s \\<in> Keys F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> Keys F", "unfolding in_Keys"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>F. s \\<in> keys f", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> keys f\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>F. s \\<in> keys f", ".."], ["", "lemma in_KeysE:\n  assumes \"s \\<in> Keys F\"\n  obtains f where \"s \\<in> keys f\" and \"f \\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>s \\<in> keys f; f \\<in> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> Keys F\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>s \\<in> keys f; f \\<in> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_Keys"], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>F. s \\<in> keys f\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>s \\<in> keys f; f \\<in> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["", "lemma Keys_mono:\n  assumes \"A \\<subseteq> B\"\n  shows \"Keys A \\<subseteq> Keys B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys A \\<subseteq> Keys B", "using assms"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. Keys A \\<subseteq> Keys B", "by (auto simp add: Keys_def)"], ["", "lemma Keys_insert: \"Keys (insert a A) = keys a \\<union> Keys A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (insert a A) = keys a \\<union> Keys A", "by (simp add: Keys_def)"], ["", "lemma Keys_Un: \"Keys (A \\<union> B) = Keys A \\<union> Keys B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (A \\<union> B) = Keys A \\<union> Keys B", "by (simp add: Keys_def)"], ["", "lemma finite_Keys:\n  assumes \"finite A\"\n  shows \"finite (Keys A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Keys A)", "unfolding Keys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (keys ` A))", "by (rule, fact assms, rule finite_keys)"], ["", "lemma Keys_not_empty:\n  assumes \"a \\<in> A\" and \"a \\<noteq> 0\"\n  shows \"Keys A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys A \\<noteq> {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Keys A = {} \\<Longrightarrow> False", "assume \"Keys A = {}\""], ["proof (state)\nthis:\n  Keys A = {}\n\ngoal (1 subgoal):\n 1. Keys A = {} \\<Longrightarrow> False", "from \\<open>a \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  a \\<noteq> 0", "have \"keys a \\<noteq> {}\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys a \\<noteq> {}", "using aux"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  (lookup ?f = (\\<lambda>_. 0::?'b)) = (?f = 0)\n\ngoal (1 subgoal):\n 1. keys a \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  keys a \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Keys A = {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  keys a \\<noteq> {}", "obtain s where \"s \\<in> keys a\""], ["proof (prove)\nusing this:\n  keys a \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>s. s \\<in> keys a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in> keys a\n\ngoal (1 subgoal):\n 1. Keys A = {} \\<Longrightarrow> False", "from this assms(1)"], ["proof (chain)\npicking this:\n  s \\<in> keys a\n  a \\<in> A", "have \"s \\<in> Keys A\""], ["proof (prove)\nusing this:\n  s \\<in> keys a\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. s \\<in> Keys A", "by (rule in_KeysI)"], ["proof (state)\nthis:\n  s \\<in> Keys A\n\ngoal (1 subgoal):\n 1. Keys A = {} \\<Longrightarrow> False", "with \\<open>Keys A = {}\\<close>"], ["proof (chain)\npicking this:\n  Keys A = {}\n  s \\<in> Keys A", "show False"], ["proof (prove)\nusing this:\n  Keys A = {}\n  s \\<in> Keys A\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Keys_empty [simp]: \"Keys {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys {} = {}", "by (simp add: Keys_def)"], ["", "lemma Keys_zero [simp]: \"Keys {0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys {0} = {}", "by (simp add: Keys_def)"], ["", "lemma keys_subset_Keys:\n  assumes \"f \\<in> F\"\n  shows \"keys f \\<subseteq> Keys F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys f \\<subseteq> Keys F", "using in_KeysI[OF _ assms]"], ["proof (prove)\nusing this:\n  ?s \\<in> keys f \\<Longrightarrow> ?s \\<in> Keys F\n\ngoal (1 subgoal):\n 1. keys f \\<subseteq> Keys F", "by auto"], ["", "lemma Keys_minus: \"Keys (A - B) \\<subseteq> Keys A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (A - B) \\<subseteq> Keys A", "by (auto simp add: Keys_def)"], ["", "lemma Keys_minus_zero: \"Keys (A - {0}) = Keys A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (A - {0}) = Keys A", "proof (cases \"0 \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> A \\<Longrightarrow> Keys (A - {0}) = Keys A\n 2. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "case True"], ["proof (state)\nthis:\n  0 \\<in> A\n\ngoal (2 subgoals):\n 1. 0 \\<in> A \\<Longrightarrow> Keys (A - {0}) = Keys A\n 2. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "hence \"(A - {0}) \\<union> {0} = A\""], ["proof (prove)\nusing this:\n  0 \\<in> A\n\ngoal (1 subgoal):\n 1. A - {0} \\<union> {0} = A", "by auto"], ["proof (state)\nthis:\n  A - {0} \\<union> {0} = A\n\ngoal (2 subgoals):\n 1. 0 \\<in> A \\<Longrightarrow> Keys (A - {0}) = Keys A\n 2. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "hence \"Keys A = Keys ((A - {0}) \\<union> {0})\""], ["proof (prove)\nusing this:\n  A - {0} \\<union> {0} = A\n\ngoal (1 subgoal):\n 1. Keys A = Keys (A - {0} \\<union> {0})", "by simp"], ["proof (state)\nthis:\n  Keys A = Keys (A - {0} \\<union> {0})\n\ngoal (2 subgoals):\n 1. 0 \\<in> A \\<Longrightarrow> Keys (A - {0}) = Keys A\n 2. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "also"], ["proof (state)\nthis:\n  Keys A = Keys (A - {0} \\<union> {0})\n\ngoal (2 subgoals):\n 1. 0 \\<in> A \\<Longrightarrow> Keys (A - {0}) = Keys A\n 2. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "have \"... = Keys (A - {0}) \\<union> Keys {0::('a \\<Rightarrow>\\<^sub>0 'b)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (A - {0} \\<union> {0}) = Keys (A - {0}) \\<union> Keys {0}", "by (fact Keys_Un)"], ["proof (state)\nthis:\n  Keys (A - {0} \\<union> {0}) = Keys (A - {0}) \\<union> Keys {0}\n\ngoal (2 subgoals):\n 1. 0 \\<in> A \\<Longrightarrow> Keys (A - {0}) = Keys A\n 2. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "also"], ["proof (state)\nthis:\n  Keys (A - {0} \\<union> {0}) = Keys (A - {0}) \\<union> Keys {0}\n\ngoal (2 subgoals):\n 1. 0 \\<in> A \\<Longrightarrow> Keys (A - {0}) = Keys A\n 2. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "have \"... = Keys (A - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (A - {0}) \\<union> Keys {0} = Keys (A - {0})", "by simp"], ["proof (state)\nthis:\n  Keys (A - {0}) \\<union> Keys {0} = Keys (A - {0})\n\ngoal (2 subgoals):\n 1. 0 \\<in> A \\<Longrightarrow> Keys (A - {0}) = Keys A\n 2. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "finally"], ["proof (chain)\npicking this:\n  Keys A = Keys (A - {0})", "show ?thesis"], ["proof (prove)\nusing this:\n  Keys A = Keys (A - {0})\n\ngoal (1 subgoal):\n 1. Keys (A - {0}) = Keys A", "by simp"], ["proof (state)\nthis:\n  Keys (A - {0}) = Keys A\n\ngoal (1 subgoal):\n 1. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "case False"], ["proof (state)\nthis:\n  0 \\<notin> A\n\ngoal (1 subgoal):\n 1. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "hence \"A - {0} = A\""], ["proof (prove)\nusing this:\n  0 \\<notin> A\n\ngoal (1 subgoal):\n 1. A - {0} = A", "by simp"], ["proof (state)\nthis:\n  A - {0} = A\n\ngoal (1 subgoal):\n 1. 0 \\<notin> A \\<Longrightarrow> Keys (A - {0}) = Keys A", "thus ?thesis"], ["proof (prove)\nusing this:\n  A - {0} = A\n\ngoal (1 subgoal):\n 1. Keys (A - {0}) = Keys A", "by simp"], ["proof (state)\nthis:\n  Keys (A - {0}) = Keys A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Constant @{term except}\\<close>"], ["", "definition except_fun :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a set \\<Rightarrow> ('a \\<Rightarrow> 'b::zero)\"\n  where \"except_fun f S = (\\<lambda>x. (f x when x \\<notin> S))\""], ["", "lift_definition except :: \"('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> 'a set \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b::zero)\" is except_fun"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun set.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. except_fun fun set x \\<noteq> (0::'b)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun set.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. except_fun fun set x \\<noteq> (0::'b)}", "fix p::\"'a \\<Rightarrow> 'b\" and S::\"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun set.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. except_fun fun set x \\<noteq> (0::'b)}", "assume \"finite {t. p t \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {t. p t \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>fun set.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. except_fun fun set x \\<noteq> (0::'b)}", "show \"finite {t. except_fun p S t \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. except_fun p S t \\<noteq> (0::'b)}", "proof (rule finite_subset[of _ \"{t. p t \\<noteq> 0}\"], rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {t. except_fun p S t \\<noteq> (0::'b)} \\<Longrightarrow>\n       x \\<in> {t. p t \\<noteq> (0::'b)}\n 2. finite {t. p t \\<noteq> (0::'b)}", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {t. except_fun p S t \\<noteq> (0::'b)} \\<Longrightarrow>\n       x \\<in> {t. p t \\<noteq> (0::'b)}\n 2. finite {t. p t \\<noteq> (0::'b)}", "assume \"u \\<in> {t. except_fun p S t \\<noteq> 0}\""], ["proof (state)\nthis:\n  u \\<in> {t. except_fun p S t \\<noteq> (0::'b)}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {t. except_fun p S t \\<noteq> (0::'b)} \\<Longrightarrow>\n       x \\<in> {t. p t \\<noteq> (0::'b)}\n 2. finite {t. p t \\<noteq> (0::'b)}", "hence \"p u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  u \\<in> {t. except_fun p S t \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. p u \\<noteq> (0::'b)", "by (simp add: except_fun_def)"], ["proof (state)\nthis:\n  p u \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {t. except_fun p S t \\<noteq> (0::'b)} \\<Longrightarrow>\n       x \\<in> {t. p t \\<noteq> (0::'b)}\n 2. finite {t. p t \\<noteq> (0::'b)}", "thus \"u \\<in> {t. p t \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  p u \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. u \\<in> {t. p t \\<noteq> (0::'b)}", "by simp"], ["proof (state)\nthis:\n  u \\<in> {t. p t \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. finite {t. p t \\<noteq> (0::'b)}", "qed fact"], ["proof (state)\nthis:\n  finite {t. except_fun p S t \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_except_when: \"lookup (except p S) = (\\<lambda>t. lookup p t when t \\<notin> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (except p S) = (\\<lambda>t. lookup p t when t \\<notin> S)", "by (auto simp: except.rep_eq except_fun_def)"], ["", "lemma lookup_except: \"lookup (except p S) = (\\<lambda>t. if t \\<in> S then 0 else lookup p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (except p S) =\n    (\\<lambda>t. if t \\<in> S then 0::'b else lookup p t)", "by (rule ext) (simp add: lookup_except_when)"], ["", "lemma lookup_except_singleton: \"lookup (except p {t}) t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (except p {t}) t = (0::'a)", "by (simp add: lookup_except)"], ["", "lemma except_zero [simp]: \"except 0 S = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except 0 S = 0", "by (rule poly_mapping_eqI) (simp add: lookup_except)"], ["", "lemma lookup_except_eq_idI:\n  assumes \"t \\<notin> S\"\n  shows \"lookup (except p S) t = lookup p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (except p S) t = lookup p t", "using assms"], ["proof (prove)\nusing this:\n  t \\<notin> S\n\ngoal (1 subgoal):\n 1. lookup (except p S) t = lookup p t", "by (simp add: lookup_except)"], ["", "lemma lookup_except_eq_zeroI:\n  assumes \"t \\<in> S\"\n  shows \"lookup (except p S) t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (except p S) t = (0::'b)", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. lookup (except p S) t = (0::'b)", "by (simp add: lookup_except)"], ["", "lemma except_empty [simp]: \"except p {} = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p {} = p", "by (rule poly_mapping_eqI) (simp add: lookup_except)"], ["", "lemma except_eq_zeroI:\n  assumes \"keys p \\<subseteq> S\"\n  shows \"except p S = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p S = 0", "proof (rule poly_mapping_eqI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (except p S) k = (0::'b)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (except p S) k = (0::'b)", "show \"lookup (except p S) t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (except p S) t = (0::'b)", "proof (cases \"t \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> S \\<Longrightarrow> lookup (except p S) t = (0::'b)\n 2. t \\<notin> S \\<Longrightarrow> lookup (except p S) t = (0::'b)", "case True"], ["proof (state)\nthis:\n  t \\<in> S\n\ngoal (2 subgoals):\n 1. t \\<in> S \\<Longrightarrow> lookup (except p S) t = (0::'b)\n 2. t \\<notin> S \\<Longrightarrow> lookup (except p S) t = (0::'b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. lookup (except p S) t = (0::'b)", "by (rule lookup_except_eq_zeroI)"], ["proof (state)\nthis:\n  lookup (except p S) t = (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<notin> S \\<Longrightarrow> lookup (except p S) t = (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> S \\<Longrightarrow> lookup (except p S) t = (0::'b)", "case False"], ["proof (state)\nthis:\n  t \\<notin> S\n\ngoal (1 subgoal):\n 1. t \\<notin> S \\<Longrightarrow> lookup (except p S) t = (0::'b)", "then"], ["proof (chain)\npicking this:\n  t \\<notin> S", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<notin> S\n\ngoal (1 subgoal):\n 1. lookup (except p S) t = (0::'b)", "by (metis assms in_keys_iff lookup_except_eq_idI subset_eq)"], ["proof (state)\nthis:\n  lookup (except p S) t = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (except p S) t = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma except_eq_zeroE:\n  assumes \"except p S = 0\"\n  shows \"keys p \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys p \\<subseteq> S", "by (metis assms aux in_keys_iff lookup_except_eq_idI subset_iff)"], ["", "lemma except_eq_zero_iff: \"except p S = 0 \\<longleftrightarrow> keys p \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (except p S = 0) = (keys p \\<subseteq> S)", "by (rule, elim except_eq_zeroE, elim except_eq_zeroI)"], ["", "lemma except_keys [simp]: \"except p (keys p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p (keys p) = 0", "by (rule except_eq_zeroI, rule subset_refl)"], ["", "lemma plus_except: \"p = Poly_Mapping.single t (lookup p t) + except p {t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = Poly_Mapping.single t (lookup p t) + except p {t}", "by (rule poly_mapping_eqI, simp add: lookup_add lookup_single lookup_except when_def split: if_split)"], ["", "lemma keys_except: \"keys (except p S) = keys p - S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (except p S) = keys p - S", "by (transfer, auto simp: except_fun_def)"], ["", "lemma except_single: \"except (Poly_Mapping.single u c) S = (Poly_Mapping.single u c when u \\<notin> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except (Poly_Mapping.single u c) S =\n    (Poly_Mapping.single u c when u \\<notin> S)", "by (rule poly_mapping_eqI) (simp add: lookup_except lookup_single when_def)"], ["", "lemma except_plus: \"except (p + q) S = except p S + except q S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except (p + q) S = except p S + except q S", "by (rule poly_mapping_eqI) (simp add: lookup_except lookup_add)"], ["", "lemma except_minus: \"except (p - q) S = except p S - except q S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except (p - q) S = except p S - except q S", "by (rule poly_mapping_eqI) (simp add: lookup_except lookup_minus)"], ["", "lemma except_uminus: \"except (- p) S = - except p S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except (- p) S = - except p S", "by (rule poly_mapping_eqI) (simp add: lookup_except)"], ["", "lemma except_except: \"except (except p S) T = except p (S \\<union> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except (except p S) T = except p (S \\<union> T)", "by (rule poly_mapping_eqI) (simp add: lookup_except)"], ["", "lemma poly_mapping_keys_eqI:\n  assumes a1: \"keys p = keys q\" and a2: \"\\<And>t. t \\<in> keys p \\<Longrightarrow> lookup p t = lookup q t\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup p k = lookup q k", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup p k = lookup q k", "show \"lookup p t = lookup q t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup p t = lookup q t", "proof (cases \"t \\<in> keys p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow> lookup p t = lookup q t\n 2. t \\<notin> keys p \\<Longrightarrow> lookup p t = lookup q t", "case True"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow> lookup p t = lookup q t\n 2. t \\<notin> keys p \\<Longrightarrow> lookup p t = lookup q t", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. lookup p t = lookup q t", "by (rule a2)"], ["proof (state)\nthis:\n  lookup p t = lookup q t\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow> lookup p t = lookup q t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow> lookup p t = lookup q t", "case False"], ["proof (state)\nthis:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow> lookup p t = lookup q t", "moreover"], ["proof (state)\nthis:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow> lookup p t = lookup q t", "from this"], ["proof (chain)\npicking this:\n  t \\<notin> keys p", "have \"t \\<notin> keys q\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> keys q", "unfolding a1"], ["proof (prove)\nusing this:\n  t \\<notin> keys q\n\ngoal (1 subgoal):\n 1. t \\<notin> keys q", "."], ["proof (state)\nthis:\n  t \\<notin> keys q\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow> lookup p t = lookup q t", "ultimately"], ["proof (chain)\npicking this:\n  t \\<notin> keys p\n  t \\<notin> keys q", "have \"lookup p t = 0\" and \"lookup q t = 0\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n  t \\<notin> keys q\n\ngoal (1 subgoal):\n 1. lookup p t = (0::'b) &&& lookup q t = (0::'b)", "unfolding in_keys_iff"], ["proof (prove)\nusing this:\n  \\<not> lookup p t \\<noteq> (0::'b)\n  \\<not> lookup q t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup p t = (0::'b) &&& lookup q t = (0::'b)", "by simp_all"], ["proof (state)\nthis:\n  lookup p t = (0::'b)\n  lookup q t = (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow> lookup p t = lookup q t", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup p t = (0::'b)\n  lookup q t = (0::'b)\n\ngoal (1 subgoal):\n 1. lookup p t = lookup q t", "by simp"], ["proof (state)\nthis:\n  lookup p t = lookup q t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup p t = lookup q t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma except_id_iff: \"except p S = p \\<longleftrightarrow> keys p \\<inter> S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (except p S = p) = (keys p \\<inter> S = {})", "by (metis Diff_Diff_Int Diff_eq_empty_iff Diff_triv inf_le2 keys_except lookup_except_eq_idI\n      lookup_except_eq_zeroI not_in_keys_iff_lookup_eq_zero poly_mapping_keys_eqI)"], ["", "lemma keys_subset_wf:\n  \"wfP (\\<lambda>p q::('a, 'b::zero) poly_mapping. keys p \\<subset> keys q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>p q. keys p \\<subset> keys q)", "unfolding wfP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(p, q). keys p \\<subset> keys q}", "proof (intro wfI_min)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(p, q). keys p \\<subset> keys q} \\<longrightarrow>\n             y \\<notin> Q", "fix x::\"('a, 'b) poly_mapping\" and Q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(p, q). keys p \\<subset> keys q} \\<longrightarrow>\n             y \\<notin> Q", "assume x_in: \"x \\<in> Q\""], ["proof (state)\nthis:\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(p, q). keys p \\<subset> keys q} \\<longrightarrow>\n             y \\<notin> Q", "let ?Q0 = \"card ` keys ` Q\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(p, q). keys p \\<subset> keys q} \\<longrightarrow>\n             y \\<notin> Q", "from x_in"], ["proof (chain)\npicking this:\n  x \\<in> Q", "have \"card (keys x) \\<in> ?Q0\""], ["proof (prove)\nusing this:\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. card (keys x) \\<in> card ` keys ` Q", "by simp"], ["proof (state)\nthis:\n  card (keys x) \\<in> card ` keys ` Q\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(p, q). keys p \\<subset> keys q} \\<longrightarrow>\n             y \\<notin> Q", "from wfE_min[OF wf this]"], ["proof (chain)\npicking this:\n  (\\<And>z.\n      \\<lbrakk>z \\<in> card ` keys ` Q;\n       \\<And>y.\n          (y, z) \\<in> {(x, y). x < y} \\<Longrightarrow>\n          y \\<notin> card ` keys ` Q\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain z0\n    where z0_in: \"z0 \\<in> ?Q0\" and z0_min: \"\\<And>y. (y, z0) \\<in> {(x, y). x < y} \\<Longrightarrow> y \\<notin> ?Q0\""], ["proof (prove)\nusing this:\n  (\\<And>z.\n      \\<lbrakk>z \\<in> card ` keys ` Q;\n       \\<And>y.\n          (y, z) \\<in> {(x, y). x < y} \\<Longrightarrow>\n          y \\<notin> card ` keys ` Q\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>z0.\n        \\<lbrakk>z0 \\<in> card ` keys ` Q;\n         \\<And>y.\n            (y, z0) \\<in> {(x, y). x < y} \\<Longrightarrow>\n            y \\<notin> card ` keys ` Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z0 \\<in> card ` keys ` Q\n  (?y, z0) \\<in> {(x, y). x < y} \\<Longrightarrow>\n  ?y \\<notin> card ` keys ` Q\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(p, q). keys p \\<subset> keys q} \\<longrightarrow>\n             y \\<notin> Q", "from z0_in"], ["proof (chain)\npicking this:\n  z0 \\<in> card ` keys ` Q", "obtain z where z0_def: \"z0 = card (keys z)\" and \"z \\<in> Q\""], ["proof (prove)\nusing this:\n  z0 \\<in> card ` keys ` Q\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z0 = card (keys z); z \\<in> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z0 = card (keys z)\n  z \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             (y, z)\n             \\<in> {(p, q). keys p \\<subset> keys q} \\<longrightarrow>\n             y \\<notin> Q", "show \"\\<exists>z\\<in>Q. \\<forall>y. (y, z) \\<in> {(p, q). keys p \\<subset> keys q} \\<longrightarrow> y \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y.\n          (y, z) \\<in> {(p, q). keys p \\<subset> keys q} \\<longrightarrow>\n          y \\<notin> Q", "proof (intro bexI[of _ z], rule, rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       (y, z) \\<in> {(p, q). keys p \\<subset> keys q} \\<Longrightarrow>\n       y \\<notin> Q\n 2. z \\<in> Q", "fix y::\"('a, 'b) poly_mapping\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       (y, z) \\<in> {(p, q). keys p \\<subset> keys q} \\<Longrightarrow>\n       y \\<notin> Q\n 2. z \\<in> Q", "let ?y0 = \"card (keys y)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       (y, z) \\<in> {(p, q). keys p \\<subset> keys q} \\<Longrightarrow>\n       y \\<notin> Q\n 2. z \\<in> Q", "assume \"(y, z) \\<in> {(p, q). keys p \\<subset> keys q}\""], ["proof (state)\nthis:\n  (y, z) \\<in> {(p, q). keys p \\<subset> keys q}\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       (y, z) \\<in> {(p, q). keys p \\<subset> keys q} \\<Longrightarrow>\n       y \\<notin> Q\n 2. z \\<in> Q", "hence \"keys y \\<subset> keys z\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> {(p, q). keys p \\<subset> keys q}\n\ngoal (1 subgoal):\n 1. keys y \\<subset> keys z", "by simp"], ["proof (state)\nthis:\n  keys y \\<subset> keys z\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       (y, z) \\<in> {(p, q). keys p \\<subset> keys q} \\<Longrightarrow>\n       y \\<notin> Q\n 2. z \\<in> Q", "hence \"?y0 < z0\""], ["proof (prove)\nusing this:\n  keys y \\<subset> keys z\n\ngoal (1 subgoal):\n 1. card (keys y) < z0", "unfolding z0_def"], ["proof (prove)\nusing this:\n  keys y \\<subset> keys z\n\ngoal (1 subgoal):\n 1. card (keys y) < card (keys z)", "by (simp add: psubset_card_mono)"], ["proof (state)\nthis:\n  card (keys y) < z0\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       (y, z) \\<in> {(p, q). keys p \\<subset> keys q} \\<Longrightarrow>\n       y \\<notin> Q\n 2. z \\<in> Q", "hence \"(?y0, z0) \\<in> {(x, y). x < y}\""], ["proof (prove)\nusing this:\n  card (keys y) < z0\n\ngoal (1 subgoal):\n 1. (card (keys y), z0) \\<in> {(x, y). x < y}", "by simp"], ["proof (state)\nthis:\n  (card (keys y), z0) \\<in> {(x, y). x < y}\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       (y, z) \\<in> {(p, q). keys p \\<subset> keys q} \\<Longrightarrow>\n       y \\<notin> Q\n 2. z \\<in> Q", "from z0_min[OF this]"], ["proof (chain)\npicking this:\n  card (keys y) \\<notin> card ` keys ` Q", "show \"y \\<notin> Q\""], ["proof (prove)\nusing this:\n  card (keys y) \\<notin> card ` keys ` Q\n\ngoal (1 subgoal):\n 1. y \\<notin> Q", "by auto"], ["proof (state)\nthis:\n  y \\<notin> Q\n\ngoal (1 subgoal):\n 1. z \\<in> Q", "qed (fact)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Q.\n     \\<forall>y.\n        (y, z) \\<in> {(p, q). keys p \\<subset> keys q} \\<longrightarrow>\n        y \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_mapping_except_induct:\n  assumes base: \"P 0\" and ind: \"\\<And>p t. p \\<noteq> 0 \\<Longrightarrow> t \\<in> keys p \\<Longrightarrow> P (except p {t}) \\<Longrightarrow> P p\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (induct rule: wfP_induct[OF keys_subset_wf])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          keys y \\<subset> keys x \\<longrightarrow> P y \\<Longrightarrow>\n       P x", "fix p::\"('a, 'b) poly_mapping\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          keys y \\<subset> keys x \\<longrightarrow> P y \\<Longrightarrow>\n       P x", "assume \"\\<forall>q. keys q \\<subset> keys p \\<longrightarrow> P q\""], ["proof (state)\nthis:\n  \\<forall>q. keys q \\<subset> keys p \\<longrightarrow> P q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          keys y \\<subset> keys x \\<longrightarrow> P y \\<Longrightarrow>\n       P x", "hence IH: \"\\<And>q. keys q \\<subset> keys p \\<Longrightarrow> P q\""], ["proof (prove)\nusing this:\n  \\<forall>q. keys q \\<subset> keys p \\<longrightarrow> P q\n\ngoal (1 subgoal):\n 1. \\<And>q. keys q \\<subset> keys p \\<Longrightarrow> P q", "by simp"], ["proof (state)\nthis:\n  keys ?q \\<subset> keys p \\<Longrightarrow> P ?q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          keys y \\<subset> keys x \\<longrightarrow> P y \\<Longrightarrow>\n       P x", "show \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. p \\<noteq> 0 \\<Longrightarrow> P p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. p \\<noteq> 0 \\<Longrightarrow> P p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. P p", "using base"], ["proof (prove)\nusing this:\n  p = 0\n  P 0\n\ngoal (1 subgoal):\n 1. P p", "by simp"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> P p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> P p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> P p", "hence \"keys p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys p \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  keys p \\<noteq> {}", "obtain t where \"t \\<in> keys p\""], ["proof (prove)\nusing this:\n  keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t. t \\<in> keys p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> P p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (rule ind, fact, fact, rule IH, simp only: keys_except, rule, rule Diff_subset, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. keys p - {t} = keys p \\<Longrightarrow> False", "assume \"keys p - {t} = keys p\""], ["proof (state)\nthis:\n  keys p - {t} = keys p\n\ngoal (1 subgoal):\n 1. keys p - {t} = keys p \\<Longrightarrow> False", "hence \"t \\<notin> keys p\""], ["proof (prove)\nusing this:\n  keys p - {t} = keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p", "by blast"], ["proof (state)\nthis:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. keys p - {t} = keys p \\<Longrightarrow> False", "from this \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  t \\<notin> keys p\n  t \\<in> keys p", "show False"], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_mapping_except_induct':\n  assumes \"\\<And>p. (\\<And>t. t \\<in> keys p \\<Longrightarrow> P (except p {t})) \\<Longrightarrow> P p\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (induct \"card (keys p)\" arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p. 0 = card (keys p) \\<Longrightarrow> P p\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "case 0"], ["proof (state)\nthis:\n  0 = card (keys p)\n\ngoal (2 subgoals):\n 1. \\<And>p. 0 = card (keys p) \\<Longrightarrow> P p\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "with finite_keys[of p]"], ["proof (chain)\npicking this:\n  finite (keys p)\n  0 = card (keys p)", "have \"keys p = {}\""], ["proof (prove)\nusing this:\n  finite (keys p)\n  0 = card (keys p)\n\ngoal (1 subgoal):\n 1. keys p = {}", "by simp"], ["proof (state)\nthis:\n  keys p = {}\n\ngoal (2 subgoals):\n 1. \\<And>p. 0 = card (keys p) \\<Longrightarrow> P p\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "by (rule assms, simp add: \\<open>keys p = {}\\<close>)"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "case step: (Suc n)"], ["proof (state)\nthis:\n  n = card (keys ?p) \\<Longrightarrow> P ?p\n  Suc n = card (keys p)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (rule assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> keys p \\<Longrightarrow> P (except p {t})", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> keys p \\<Longrightarrow> P (except p {t})", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> keys p \\<Longrightarrow> P (except p {t})", "show \"P (except p {t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (except p {t})", "proof (rule step(1), simp add: keys_except)"], ["proof (state)\ngoal (1 subgoal):\n 1. n = card (keys p - {t})", "from step(2) \\<open>t \\<in> keys p\\<close> finite_keys[of p]"], ["proof (chain)\npicking this:\n  Suc n = card (keys p)\n  t \\<in> keys p\n  finite (keys p)", "show \"n = card (keys p - {t})\""], ["proof (prove)\nusing this:\n  Suc n = card (keys p)\n  t \\<in> keys p\n  finite (keys p)\n\ngoal (1 subgoal):\n 1. n = card (keys p - {t})", "by simp"], ["proof (state)\nthis:\n  n = card (keys p - {t})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (except p {t})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_mapping_plus_induct:\n  assumes \"P 0\" and \"\\<And>p c t. c \\<noteq> 0 \\<Longrightarrow> t \\<notin> keys p \\<Longrightarrow> P p \\<Longrightarrow> P (Poly_Mapping.single t c + p)\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (induct \"card (keys p)\" arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p. 0 = card (keys p) \\<Longrightarrow> P p\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "case 0"], ["proof (state)\nthis:\n  0 = card (keys p)\n\ngoal (2 subgoals):\n 1. \\<And>p. 0 = card (keys p) \\<Longrightarrow> P p\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "with finite_keys[of p]"], ["proof (chain)\npicking this:\n  finite (keys p)\n  0 = card (keys p)", "have \"keys p = {}\""], ["proof (prove)\nusing this:\n  finite (keys p)\n  0 = card (keys p)\n\ngoal (1 subgoal):\n 1. keys p = {}", "by simp"], ["proof (state)\nthis:\n  keys p = {}\n\ngoal (2 subgoals):\n 1. \\<And>p. 0 = card (keys p) \\<Longrightarrow> P p\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "hence \"p = 0\""], ["proof (prove)\nusing this:\n  keys p = {}\n\ngoal (1 subgoal):\n 1. p = 0", "by simp"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p. 0 = card (keys p) \\<Longrightarrow> P p\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "with assms(1)"], ["proof (chain)\npicking this:\n  P 0\n  p = 0", "show ?case"], ["proof (prove)\nusing this:\n  P 0\n  p = 0\n\ngoal (1 subgoal):\n 1. P p", "by simp"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "case step: (Suc n)"], ["proof (state)\nthis:\n  n = card (keys ?p) \\<Longrightarrow> P ?p\n  Suc n = card (keys p)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "from step(2)"], ["proof (chain)\npicking this:\n  Suc n = card (keys p)", "obtain t where t: \"t \\<in> keys p\""], ["proof (prove)\nusing this:\n  Suc n = card (keys p)\n\ngoal (1 subgoal):\n 1. (\\<And>t. t \\<in> keys p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis card_eq_SucD insert_iff)"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "define c where \"c = lookup p t\""], ["proof (state)\nthis:\n  c = lookup p t\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "define q where \"q = except p {t}\""], ["proof (state)\nthis:\n  q = except p {t}\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "have *: \"p = Poly_Mapping.single t c + q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = Poly_Mapping.single t c + q", "by (rule poly_mapping_eqI, simp add: lookup_add lookup_single Poly_Mapping.when_def, intro conjI impI,\n        simp add: q_def lookup_except c_def, simp add: q_def lookup_except_eq_idI)"], ["proof (state)\nthis:\n  p = Poly_Mapping.single t c + q\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p. x = card (keys p) \\<Longrightarrow> P p;\n        Suc x = card (keys p)\\<rbrakk>\n       \\<Longrightarrow> P p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (simp only: *, rule assms(2))"], ["proof (state)\ngoal (3 subgoals):\n 1. c \\<noteq> (0::'b)\n 2. t \\<notin> keys q\n 3. P q", "from t"], ["proof (chain)\npicking this:\n  t \\<in> keys p", "show \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b)", "using c_def"], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  c = lookup p t\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. t \\<notin> keys q\n 2. P q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<notin> keys q\n 2. P q", "show \"t \\<notin> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> keys q", "by (simp add: q_def keys_except)"], ["proof (state)\nthis:\n  t \\<notin> keys q\n\ngoal (1 subgoal):\n 1. P q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P q", "show \"P q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P q", "proof (rule step(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. n = card (keys q)", "from step(2) \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  Suc n = card (keys p)\n  t \\<in> keys p", "show \"n = card (keys q)\""], ["proof (prove)\nusing this:\n  Suc n = card (keys p)\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. n = card (keys q)", "unfolding q_def keys_except"], ["proof (prove)\nusing this:\n  Suc n = card (keys p)\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. n = card (keys p - {t})", "by (metis Suc_inject card.remove finite_keys)"], ["proof (state)\nthis:\n  n = card (keys q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma except_Diff_singleton: \"except p (keys p - {t}) = Poly_Mapping.single t (lookup p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p (keys p - {t}) = Poly_Mapping.single t (lookup p t)", "by (rule poly_mapping_eqI) (simp add: lookup_single in_keys_iff lookup_except when_def)"], ["", "lemma except_Un_plus_Int: \"except p (U \\<union> V) + except p (U \\<inter> V) = except p U + except p V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p (U \\<union> V) + except p (U \\<inter> V) =\n    except p U + except p V", "by (rule poly_mapping_eqI) (simp add: lookup_except lookup_add)"], ["", "corollary except_Int:\n  assumes \"keys p \\<subseteq> U \\<union> V\"\n  shows \"except p (U \\<inter> V) = except p U + except p V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p (U \\<inter> V) = except p U + except p V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. except p (U \\<inter> V) = except p U + except p V", "from assms"], ["proof (chain)\npicking this:\n  keys p \\<subseteq> U \\<union> V", "have \"except p (U \\<union> V) = 0\""], ["proof (prove)\nusing this:\n  keys p \\<subseteq> U \\<union> V\n\ngoal (1 subgoal):\n 1. except p (U \\<union> V) = 0", "by (rule except_eq_zeroI)"], ["proof (state)\nthis:\n  except p (U \\<union> V) = 0\n\ngoal (1 subgoal):\n 1. except p (U \\<inter> V) = except p U + except p V", "hence \"except p (U \\<inter> V) = except p (U \\<union> V) + except p (U \\<inter> V)\""], ["proof (prove)\nusing this:\n  except p (U \\<union> V) = 0\n\ngoal (1 subgoal):\n 1. except p (U \\<inter> V) =\n    except p (U \\<union> V) + except p (U \\<inter> V)", "by simp"], ["proof (state)\nthis:\n  except p (U \\<inter> V) =\n  except p (U \\<union> V) + except p (U \\<inter> V)\n\ngoal (1 subgoal):\n 1. except p (U \\<inter> V) = except p U + except p V", "also"], ["proof (state)\nthis:\n  except p (U \\<inter> V) =\n  except p (U \\<union> V) + except p (U \\<inter> V)\n\ngoal (1 subgoal):\n 1. except p (U \\<inter> V) = except p U + except p V", "have \"\\<dots> = except p U + except p V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p (U \\<union> V) + except p (U \\<inter> V) =\n    except p U + except p V", "by (fact except_Un_plus_Int)"], ["proof (state)\nthis:\n  except p (U \\<union> V) + except p (U \\<inter> V) =\n  except p U + except p V\n\ngoal (1 subgoal):\n 1. except p (U \\<inter> V) = except p U + except p V", "finally"], ["proof (chain)\npicking this:\n  except p (U \\<inter> V) = except p U + except p V", "show ?thesis"], ["proof (prove)\nusing this:\n  except p (U \\<inter> V) = except p U + except p V\n\ngoal (1 subgoal):\n 1. except p (U \\<inter> V) = except p U + except p V", "."], ["proof (state)\nthis:\n  except p (U \\<inter> V) = except p U + except p V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma except_keys_Int [simp]: \"except p (keys p \\<inter> U) = except p U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p (keys p \\<inter> U) = except p U", "by (rule poly_mapping_eqI) (simp add: in_keys_iff lookup_except)"], ["", "lemma except_Int_keys [simp]: \"except p (U \\<inter> keys p) = except p U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p (U \\<inter> keys p) = except p U", "by (simp only: Int_commute[of U] except_keys_Int)"], ["", "lemma except_keys_Diff: \"except p (keys p - U) = except p (- U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p (keys p - U) = except p (- U)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. except p (keys p - U) = except p (- U)", "have \"except p (keys p - U) = except p (keys p \\<inter> (- U))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p (keys p - U) = except p (keys p \\<inter> - U)", "by (simp only: Diff_eq)"], ["proof (state)\nthis:\n  except p (keys p - U) = except p (keys p \\<inter> - U)\n\ngoal (1 subgoal):\n 1. except p (keys p - U) = except p (- U)", "also"], ["proof (state)\nthis:\n  except p (keys p - U) = except p (keys p \\<inter> - U)\n\ngoal (1 subgoal):\n 1. except p (keys p - U) = except p (- U)", "have \"\\<dots> = except p (- U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p (keys p \\<inter> - U) = except p (- U)", "by simp"], ["proof (state)\nthis:\n  except p (keys p \\<inter> - U) = except p (- U)\n\ngoal (1 subgoal):\n 1. except p (keys p - U) = except p (- U)", "finally"], ["proof (chain)\npicking this:\n  except p (keys p - U) = except p (- U)", "show ?thesis"], ["proof (prove)\nusing this:\n  except p (keys p - U) = except p (- U)\n\ngoal (1 subgoal):\n 1. except p (keys p - U) = except p (- U)", "."], ["proof (state)\nthis:\n  except p (keys p - U) = except p (- U)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma except_decomp: \"p = except p U + except p (- U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = except p U + except p (- U)", "by (rule poly_mapping_eqI) (simp add: lookup_except lookup_add)"], ["", "corollary except_Compl: \"except p (- U) = p - except p U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except p (- U) = p - except p U", "by (metis add_diff_cancel_left' except_decomp)"], ["", "subsection \\<open>'Divisibility' on Additive Structures\\<close>"], ["", "context plus begin"], ["", "definition adds :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"adds\" 50)\n  where \"b adds a \\<longleftrightarrow> (\\<exists>k. a = b + k)\""], ["", "lemma addsI [intro?]: \"a = b + k \\<Longrightarrow> b adds a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b + k \\<Longrightarrow> b adds a", "unfolding adds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b + k \\<Longrightarrow> \\<exists>k. a = b + k", ".."], ["", "lemma addsE [elim?]: \"b adds a \\<Longrightarrow> (\\<And>k. a = b + k \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b adds a; \\<And>k. a = b + k \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding adds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>k. a = b + k;\n     \\<And>k. a = b + k \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by blast"], ["", "end"], ["", "context comm_monoid_add\nbegin"], ["", "lemma adds_refl [simp]: \"a adds a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a adds a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a = a + ?k", "show \"a = a + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a + (0::'a)", "by simp"], ["proof (state)\nthis:\n  a = a + (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adds_trans [trans]:\n  assumes \"a adds b\" and \"b adds c\"\n  shows \"a adds c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a adds c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a adds c", "from assms"], ["proof (chain)\npicking this:\n  a adds b\n  b adds c", "obtain v where \"b = a + v\""], ["proof (prove)\nusing this:\n  a adds b\n  b adds c\n\ngoal (1 subgoal):\n 1. (\\<And>v. b = a + v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto elim!: addsE)"], ["proof (state)\nthis:\n  b = a + v\n\ngoal (1 subgoal):\n 1. a adds c", "moreover"], ["proof (state)\nthis:\n  b = a + v\n\ngoal (1 subgoal):\n 1. a adds c", "from assms"], ["proof (chain)\npicking this:\n  a adds b\n  b adds c", "obtain w where \"c = b + w\""], ["proof (prove)\nusing this:\n  a adds b\n  b adds c\n\ngoal (1 subgoal):\n 1. (\\<And>w. c = b + w \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto elim!: addsE)"], ["proof (state)\nthis:\n  c = b + w\n\ngoal (1 subgoal):\n 1. a adds c", "ultimately"], ["proof (chain)\npicking this:\n  b = a + v\n  c = b + w", "have \"c = a + (v + w)\""], ["proof (prove)\nusing this:\n  b = a + v\n  c = b + w\n\ngoal (1 subgoal):\n 1. c = a + (v + w)", "by (simp add: add.assoc)"], ["proof (state)\nthis:\n  c = a + (v + w)\n\ngoal (1 subgoal):\n 1. a adds c", "then"], ["proof (chain)\npicking this:\n  c = a + (v + w)", "show ?thesis"], ["proof (prove)\nusing this:\n  c = a + (v + w)\n\ngoal (1 subgoal):\n 1. a adds c", ".."], ["proof (state)\nthis:\n  a adds c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subset_divisors_adds: \"{c. c adds a} \\<subseteq> {c. c adds b} \\<longleftrightarrow> a adds b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({c. c adds a} \\<subseteq> {c. c adds b}) = (a adds b)", "by (auto simp add: subset_iff intro: adds_trans)"], ["", "lemma strict_subset_divisors_adds: \"{c. c adds a} \\<subset> {c. c adds b} \\<longleftrightarrow> a adds b \\<and> \\<not> b adds a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({c. c adds a} \\<subset> {c. c adds b}) = strict (adds) a b", "by (auto simp add: subset_iff intro: adds_trans)"], ["", "lemma zero_adds [simp]: \"0 adds a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) adds a", "by (auto intro!: addsI)"], ["", "lemma adds_plus_right [simp]: \"a adds c \\<Longrightarrow> a adds (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a adds c \\<Longrightarrow> a adds b + c", "by (auto intro!: add.left_commute addsI elim!: addsE)"], ["", "lemma adds_plus_left [simp]: \"a adds b \\<Longrightarrow> a adds (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a adds b \\<Longrightarrow> a adds b + c", "using adds_plus_right [of a b c]"], ["proof (prove)\nusing this:\n  a adds b \\<Longrightarrow> a adds c + b\n\ngoal (1 subgoal):\n 1. a adds b \\<Longrightarrow> a adds b + c", "by (simp add: ac_simps)"], ["", "lemma adds_triv_right [simp]: \"a adds b + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a adds b + a", "by (rule adds_plus_right) (rule adds_refl)"], ["", "lemma adds_triv_left [simp]: \"a adds a + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a adds a + b", "by (rule adds_plus_left) (rule adds_refl)"], ["", "lemma plus_adds_mono:\n  assumes \"a adds b\"\n    and \"c adds d\"\n  shows \"a + c adds b + d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + c adds b + d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a + c adds b + d", "from \\<open>a adds b\\<close>"], ["proof (chain)\npicking this:\n  a adds b", "obtain b' where \"b = a + b'\""], ["proof (prove)\nusing this:\n  a adds b\n\ngoal (1 subgoal):\n 1. (\\<And>b'. b = a + b' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  b = a + b'\n\ngoal (1 subgoal):\n 1. a + c adds b + d", "moreover"], ["proof (state)\nthis:\n  b = a + b'\n\ngoal (1 subgoal):\n 1. a + c adds b + d", "from \\<open>c adds d\\<close>"], ["proof (chain)\npicking this:\n  c adds d", "obtain d' where \"d = c + d'\""], ["proof (prove)\nusing this:\n  c adds d\n\ngoal (1 subgoal):\n 1. (\\<And>d'. d = c + d' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  d = c + d'\n\ngoal (1 subgoal):\n 1. a + c adds b + d", "ultimately"], ["proof (chain)\npicking this:\n  b = a + b'\n  d = c + d'", "have \"b + d = (a + c) + (b' + d')\""], ["proof (prove)\nusing this:\n  b = a + b'\n  d = c + d'\n\ngoal (1 subgoal):\n 1. b + d = a + c + (b' + d')", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  b + d = a + c + (b' + d')\n\ngoal (1 subgoal):\n 1. a + c adds b + d", "then"], ["proof (chain)\npicking this:\n  b + d = a + c + (b' + d')", "show ?thesis"], ["proof (prove)\nusing this:\n  b + d = a + c + (b' + d')\n\ngoal (1 subgoal):\n 1. a + c adds b + d", ".."], ["proof (state)\nthis:\n  a + c adds b + d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_adds_left: \"a + b adds c \\<Longrightarrow> a adds c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b adds c \\<Longrightarrow> a adds c", "by (simp add: adds_def add.assoc) blast"], ["", "lemma plus_adds_right: \"a + b adds c \\<Longrightarrow> b adds c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b adds c \\<Longrightarrow> b adds c", "using plus_adds_left [of b a c]"], ["proof (prove)\nusing this:\n  b + a adds c \\<Longrightarrow> b adds c\n\ngoal (1 subgoal):\n 1. a + b adds c \\<Longrightarrow> b adds c", "by (simp add: ac_simps)"], ["", "end"], ["", "class ninv_comm_monoid_add = comm_monoid_add +\n  assumes plus_eq_zero: \"s + t = 0 \\<Longrightarrow> s = 0\"\nbegin"], ["", "lemma plus_eq_zero_2: \"t = 0\" if \"s + t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = (0::'a)", "using that"], ["proof (prove)\nusing this:\n  s + t = (0::'a)\n\ngoal (1 subgoal):\n 1. t = (0::'a)", "by (simp only: add_commute[of s t] plus_eq_zero)"], ["", "lemma adds_zero: \"s adds 0 \\<longleftrightarrow> (s = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s adds (0::'a)) = (s = (0::'a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s adds (0::'a) \\<Longrightarrow> s = (0::'a)\n 2. s = (0::'a) \\<Longrightarrow> s adds (0::'a)", "assume \"s adds 0\""], ["proof (state)\nthis:\n  s adds (0::'a)\n\ngoal (2 subgoals):\n 1. s adds (0::'a) \\<Longrightarrow> s = (0::'a)\n 2. s = (0::'a) \\<Longrightarrow> s adds (0::'a)", "from this"], ["proof (chain)\npicking this:\n  s adds (0::'a)", "obtain k where \"0 = s + k\""], ["proof (prove)\nusing this:\n  s adds (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>k. (0::'a) = s + k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding adds_def"], ["proof (prove)\nusing this:\n  \\<exists>k. (0::'a) = s + k\n\ngoal (1 subgoal):\n 1. (\\<And>k. (0::'a) = s + k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (0::'a) = s + k\n\ngoal (2 subgoals):\n 1. s adds (0::'a) \\<Longrightarrow> s = (0::'a)\n 2. s = (0::'a) \\<Longrightarrow> s adds (0::'a)", "from this plus_eq_zero[of s k]"], ["proof (chain)\npicking this:\n  (0::'a) = s + k\n  s + k = (0::'a) \\<Longrightarrow> s = (0::'a)", "show \"s = 0\""], ["proof (prove)\nusing this:\n  (0::'a) = s + k\n  s + k = (0::'a) \\<Longrightarrow> s = (0::'a)\n\ngoal (1 subgoal):\n 1. s = (0::'a)", "by blast"], ["proof (state)\nthis:\n  s = (0::'a)\n\ngoal (1 subgoal):\n 1. s = (0::'a) \\<Longrightarrow> s adds (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s = (0::'a) \\<Longrightarrow> s adds (0::'a)", "assume \"s = 0\""], ["proof (state)\nthis:\n  s = (0::'a)\n\ngoal (1 subgoal):\n 1. s = (0::'a) \\<Longrightarrow> s adds (0::'a)", "thus \"s adds 0\""], ["proof (prove)\nusing this:\n  s = (0::'a)\n\ngoal (1 subgoal):\n 1. s adds (0::'a)", "by simp"], ["proof (state)\nthis:\n  s adds (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context canonically_ordered_monoid_add\nbegin"], ["", "subclass ninv_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ninv_comm_monoid_add (+) (0::'a)", "by (standard, simp)"], ["", "end"], ["", "class comm_powerprod = cancel_comm_monoid_add\nbegin"], ["", "lemma adds_canc: \"s + u adds t + u \\<longleftrightarrow> s adds t\" for s t u::'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s + u adds t + u) = (s adds t)", "unfolding adds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>k. t + u = s + u + k) = (\\<exists>k. t = s + k)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k. t + u = s + u + k \\<Longrightarrow> \\<exists>k. t = s + k\n 2. \\<And>k. t = s + k \\<Longrightarrow> \\<exists>ka. s + k + u = s + u + ka", "apply (metis local.add.left_commute local.add_diff_cancel_left' local.add_diff_cancel_right')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. t = s + k \\<Longrightarrow> \\<exists>ka. s + k + u = s + u + ka", "using add_assoc add_commute"], ["proof (prove)\nusing this:\n  ?a + ?b + ?c = ?a + (?b + ?c)\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. \\<And>k. t = s + k \\<Longrightarrow> \\<exists>ka. s + k + u = s + u + ka", "by auto"], ["", "lemma adds_canc_2: \"u + s adds u + t \\<longleftrightarrow> s adds t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u + s adds u + t) = (s adds t)", "by (simp add: adds_canc ac_simps)"], ["", "lemma add_minus_2: \"(s + t) - s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + t - s = t", "by simp"], ["", "lemma adds_minus:\n  assumes \"s adds t\"\n  shows \"(t - s) + s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t - s + s = t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t - s + s = t", "from assms adds_def[of s t]"], ["proof (chain)\npicking this:\n  s adds t\n  (s adds t) = (\\<exists>k. t = s + k)", "obtain u where u: \"t = u + s\""], ["proof (prove)\nusing this:\n  s adds t\n  (s adds t) = (\\<exists>k. t = s + k)\n\ngoal (1 subgoal):\n 1. (\\<And>u. t = u + s \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  t = u + s\n\ngoal (1 subgoal):\n 1. t - s + s = t", "then"], ["proof (chain)\npicking this:\n  t = u + s", "have \"t - s = u\""], ["proof (prove)\nusing this:\n  t = u + s\n\ngoal (1 subgoal):\n 1. t - s = u", "by simp"], ["proof (state)\nthis:\n  t - s = u\n\ngoal (1 subgoal):\n 1. t - s + s = t", "thus ?thesis"], ["proof (prove)\nusing this:\n  t - s = u\n\ngoal (1 subgoal):\n 1. t - s + s = t", "using u"], ["proof (prove)\nusing this:\n  t - s = u\n  t = u + s\n\ngoal (1 subgoal):\n 1. t - s + s = t", "by simp"], ["proof (state)\nthis:\n  t - s + s = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_adds_0:\n  assumes \"(s + t) adds u\"\n  shows \"s adds (u - t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds u - t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s adds u - t", "from assms"], ["proof (chain)\npicking this:\n  s + t adds u", "have \"(s + t) adds ((u - t) + t)\""], ["proof (prove)\nusing this:\n  s + t adds u\n\ngoal (1 subgoal):\n 1. s + t adds u - t + t", "using adds_minus local.plus_adds_right"], ["proof (prove)\nusing this:\n  s + t adds u\n  ?s adds ?t \\<Longrightarrow> ?t - ?s + ?s = ?t\n  ?a + ?b adds ?c \\<Longrightarrow> ?b adds ?c\n\ngoal (1 subgoal):\n 1. s + t adds u - t + t", "by presburger"], ["proof (state)\nthis:\n  s + t adds u - t + t\n\ngoal (1 subgoal):\n 1. s adds u - t", "thus ?thesis"], ["proof (prove)\nusing this:\n  s + t adds u - t + t\n\ngoal (1 subgoal):\n 1. s adds u - t", "using adds_canc[of s t \"u - t\"]"], ["proof (prove)\nusing this:\n  s + t adds u - t + t\n  (s + t adds u - t + t) = (s adds u - t)\n\ngoal (1 subgoal):\n 1. s adds u - t", "by simp"], ["proof (state)\nthis:\n  s adds u - t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_adds_2:\n  assumes \"t adds u\" and \"s adds (u - t)\"\n  shows \"(s + t) adds u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + t adds u", "by (metis adds_canc adds_minus assms)"], ["", "lemma plus_adds:\n  shows \"(s + t) adds u \\<longleftrightarrow> (t adds u \\<and> s adds (u - t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s + t adds u) = (t adds u \\<and> s adds u - t)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s + t adds u \\<Longrightarrow> t adds u \\<and> s adds u - t\n 2. t adds u \\<and> s adds u - t \\<Longrightarrow> s + t adds u", "assume a1: \"(s + t) adds u\""], ["proof (state)\nthis:\n  s + t adds u\n\ngoal (2 subgoals):\n 1. s + t adds u \\<Longrightarrow> t adds u \\<and> s adds u - t\n 2. t adds u \\<and> s adds u - t \\<Longrightarrow> s + t adds u", "show \"t adds u \\<and> s adds (u - t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t adds u \\<and> s adds u - t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t adds u\n 2. s adds u - t", "from plus_adds_right[OF a1]"], ["proof (chain)\npicking this:\n  t adds u", "show \"t adds u\""], ["proof (prove)\nusing this:\n  t adds u\n\ngoal (1 subgoal):\n 1. t adds u", "."], ["proof (state)\nthis:\n  t adds u\n\ngoal (1 subgoal):\n 1. s adds u - t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s adds u - t", "from plus_adds_0[OF a1]"], ["proof (chain)\npicking this:\n  s adds u - t", "show \"s adds (u - t)\""], ["proof (prove)\nusing this:\n  s adds u - t\n\ngoal (1 subgoal):\n 1. s adds u - t", "."], ["proof (state)\nthis:\n  s adds u - t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t adds u \\<and> s adds u - t\n\ngoal (1 subgoal):\n 1. t adds u \\<and> s adds u - t \\<Longrightarrow> s + t adds u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t adds u \\<and> s adds u - t \\<Longrightarrow> s + t adds u", "assume \"t adds u \\<and> s adds (u - t)\""], ["proof (state)\nthis:\n  t adds u \\<and> s adds u - t\n\ngoal (1 subgoal):\n 1. t adds u \\<and> s adds u - t \\<Longrightarrow> s + t adds u", "hence \"t adds u\" and \"s adds (u - t)\""], ["proof (prove)\nusing this:\n  t adds u \\<and> s adds u - t\n\ngoal (1 subgoal):\n 1. t adds u &&& s adds u - t", "by auto"], ["proof (state)\nthis:\n  t adds u\n  s adds u - t\n\ngoal (1 subgoal):\n 1. t adds u \\<and> s adds u - t \\<Longrightarrow> s + t adds u", "from plus_adds_2[OF \\<open>t adds u\\<close> \\<open>s adds (u - t)\\<close>]"], ["proof (chain)\npicking this:\n  s + t adds u", "show \"(s + t) adds u\""], ["proof (prove)\nusing this:\n  s + t adds u\n\ngoal (1 subgoal):\n 1. s + t adds u", "."], ["proof (state)\nthis:\n  s + t adds u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minus_plus:\n  assumes \"s adds t\"\n  shows \"(t - s) + u = (t + u) - s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t - s + u = t + u - s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t - s + u = t + u - s", "from assms"], ["proof (chain)\npicking this:\n  s adds t", "obtain k where k: \"t = s + k\""], ["proof (prove)\nusing this:\n  s adds t\n\ngoal (1 subgoal):\n 1. (\\<And>k. t = s + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding adds_def"], ["proof (prove)\nusing this:\n  \\<exists>k. t = s + k\n\ngoal (1 subgoal):\n 1. (\\<And>k. t = s + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  t = s + k\n\ngoal (1 subgoal):\n 1. t - s + u = t + u - s", "hence \"t - s = k\""], ["proof (prove)\nusing this:\n  t = s + k\n\ngoal (1 subgoal):\n 1. t - s = k", "by simp"], ["proof (state)\nthis:\n  t - s = k\n\ngoal (1 subgoal):\n 1. t - s + u = t + u - s", "also"], ["proof (state)\nthis:\n  t - s = k\n\ngoal (1 subgoal):\n 1. t - s + u = t + u - s", "from k"], ["proof (chain)\npicking this:\n  t = s + k", "have \"(t + u) - s = k + u\""], ["proof (prove)\nusing this:\n  t = s + k\n\ngoal (1 subgoal):\n 1. t + u - s = k + u", "by (simp add: add_assoc)"], ["proof (state)\nthis:\n  t + u - s = k + u\n\ngoal (1 subgoal):\n 1. t - s + u = t + u - s", "finally"], ["proof (chain)\npicking this:\n  t + u - s = t - s + u", "show ?thesis"], ["proof (prove)\nusing this:\n  t + u - s = t - s + u\n\ngoal (1 subgoal):\n 1. t - s + u = t + u - s", "by simp"], ["proof (state)\nthis:\n  t - s + u = t + u - s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minus_plus_minus:\n  assumes \"s adds t\" and \"u adds v\"\n  shows \"(t - s) + (v - u) = (t + v) - (s + u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t - s + (v - u) = t + v - (s + u)", "using add_commute assms(1) assms(2) diff_diff_add minus_plus"], ["proof (prove)\nusing this:\n  ?a + ?b = ?b + ?a\n  s adds t\n  u adds v\n  ?a - ?b - ?c = ?a - (?b + ?c)\n  ?s adds ?t \\<Longrightarrow> ?t - ?s + ?u = ?t + ?u - ?s\n\ngoal (1 subgoal):\n 1. t - s + (v - u) = t + v - (s + u)", "by auto"], ["", "lemma minus_plus_minus_cancel:\n  assumes \"u adds t\" and \"s adds u\"\n  shows \"(t - u) + (u - s) = t - s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t - u + (u - s) = t - s", "by (metis assms(1) assms(2) local.add_diff_cancel_left' local.add_diff_cancel_right local.addsE minus_plus)"], ["", "end"], ["", "text \\<open>Instances of class \\<open>lcs_powerprod\\<close> are types of commutative power-products admitting\n  (not necessarily unique) least common sums (inspired from least common multiplies).\n  Note that if the components of indeterminates are arbitrary integers (as for instance in Laurent\n  polynomials), then no unique lcss exist.\\<close>"], ["", "class lcs_powerprod = comm_powerprod +\n  fixes lcs::\"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  assumes adds_lcs: \"s adds (lcs s t)\"\n  assumes lcs_adds: \"s adds u \\<Longrightarrow> t adds u \\<Longrightarrow> (lcs s t) adds u\"\n  assumes lcs_comm: \"lcs s t = lcs t s\"\nbegin"], ["", "lemma adds_lcs_2: \"t adds (lcs s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t adds lcs s t", "by (simp only: lcs_comm[of s t], rule adds_lcs)"], ["", "lemma lcs_adds_plus: \"lcs s t adds s + t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs s t adds s + t", "by (simp add: lcs_adds)"], ["", "text \\<open>\"gcs\" stands for \"greatest common summand\".\\<close>"], ["", "definition gcs :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" where \"gcs s t = (s + t) - (lcs s t)\""], ["", "lemma gcs_plus_lcs: \"(gcs s t) + (lcs s t) = s + t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s t + lcs s t = s + t", "unfolding gcs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s + t - lcs s t + lcs s t = s + t", "by (rule adds_minus, fact lcs_adds_plus)"], ["", "lemma gcs_adds: \"(gcs s t) adds s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s t adds s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcs s t adds s", "have \"t adds (lcs s t)\" (is \"t adds ?l\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. t adds lcs s t", "unfolding lcs_comm[of s t]"], ["proof (prove)\ngoal (1 subgoal):\n 1. t adds lcs t s", "by (fact adds_lcs)"], ["proof (state)\nthis:\n  t adds lcs s t\n\ngoal (1 subgoal):\n 1. gcs s t adds s", "then"], ["proof (chain)\npicking this:\n  t adds lcs s t", "obtain u where eq1: \"?l = t + u\""], ["proof (prove)\nusing this:\n  t adds lcs s t\n\ngoal (1 subgoal):\n 1. (\\<And>u. lcs s t = t + u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding adds_def"], ["proof (prove)\nusing this:\n  \\<exists>k. lcs s t = t + k\n\ngoal (1 subgoal):\n 1. (\\<And>u. lcs s t = t + u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  lcs s t = t + u\n\ngoal (1 subgoal):\n 1. gcs s t adds s", "from lcs_adds_plus[of s t]"], ["proof (chain)\npicking this:\n  lcs s t adds s + t", "obtain v where eq2: \"s + t = ?l + v\""], ["proof (prove)\nusing this:\n  lcs s t adds s + t\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        s + t = lcs s t + v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding adds_def"], ["proof (prove)\nusing this:\n  \\<exists>k. s + t = lcs s t + k\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        s + t = lcs s t + v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s + t = lcs s t + v\n\ngoal (1 subgoal):\n 1. gcs s t adds s", "hence \"t + s = t + (u + v)\""], ["proof (prove)\nusing this:\n  s + t = lcs s t + v\n\ngoal (1 subgoal):\n 1. t + s = t + (u + v)", "unfolding eq1"], ["proof (prove)\nusing this:\n  s + t = t + u + v\n\ngoal (1 subgoal):\n 1. t + s = t + (u + v)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  t + s = t + (u + v)\n\ngoal (1 subgoal):\n 1. gcs s t adds s", "hence s: \"s = u + v\""], ["proof (prove)\nusing this:\n  t + s = t + (u + v)\n\ngoal (1 subgoal):\n 1. s = u + v", "unfolding add_left_cancel"], ["proof (prove)\nusing this:\n  s = u + v\n\ngoal (1 subgoal):\n 1. s = u + v", "."], ["proof (state)\nthis:\n  s = u + v\n\ngoal (1 subgoal):\n 1. gcs s t adds s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s t adds s", "unfolding eq2 gcs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs s t + v - lcs s t adds s", "unfolding s"], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs (u + v) t + v - lcs (u + v) t adds u + v", "by simp"], ["proof (state)\nthis:\n  gcs s t adds s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcs_comm: \"gcs s t = gcs t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s t = gcs t s", "unfolding gcs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s + t - lcs s t = t + s - lcs t s", "by (simp add: lcs_comm ac_simps)"], ["", "lemma gcs_adds_2: \"(gcs s t) adds t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s t adds t", "by (simp only: gcs_comm[of s t], rule gcs_adds)"], ["", "end"], ["", "class ulcs_powerprod = lcs_powerprod + ninv_comm_monoid_add\nbegin"], ["", "lemma adds_antisym:\n  assumes \"s adds t\" \"t adds s\"\n  shows \"s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s = t", "from \\<open>s adds t\\<close>"], ["proof (chain)\npicking this:\n  s adds t", "obtain u where u_def: \"t = s + u\""], ["proof (prove)\nusing this:\n  s adds t\n\ngoal (1 subgoal):\n 1. (\\<And>u. t = s + u \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding adds_def"], ["proof (prove)\nusing this:\n  \\<exists>k. t = s + k\n\ngoal (1 subgoal):\n 1. (\\<And>u. t = s + u \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  t = s + u\n\ngoal (1 subgoal):\n 1. s = t", "from \\<open>t adds s\\<close>"], ["proof (chain)\npicking this:\n  t adds s", "obtain v where v_def: \"s = t + v\""], ["proof (prove)\nusing this:\n  t adds s\n\ngoal (1 subgoal):\n 1. (\\<And>v. s = t + v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding adds_def"], ["proof (prove)\nusing this:\n  \\<exists>k. s = t + k\n\ngoal (1 subgoal):\n 1. (\\<And>v. s = t + v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  s = t + v\n\ngoal (1 subgoal):\n 1. s = t", "from u_def v_def"], ["proof (chain)\npicking this:\n  t = s + u\n  s = t + v", "have \"s = (s + u) + v\""], ["proof (prove)\nusing this:\n  t = s + u\n  s = t + v\n\ngoal (1 subgoal):\n 1. s = s + u + v", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  s = s + u + v\n\ngoal (1 subgoal):\n 1. s = t", "hence \"s + 0 = s + (u + v)\""], ["proof (prove)\nusing this:\n  s = s + u + v\n\ngoal (1 subgoal):\n 1. s + (0::'a) = s + (u + v)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  s + (0::'a) = s + (u + v)\n\ngoal (1 subgoal):\n 1. s = t", "hence \"u + v = 0\""], ["proof (prove)\nusing this:\n  s + (0::'a) = s + (u + v)\n\ngoal (1 subgoal):\n 1. u + v = (0::'a)", "by simp"], ["proof (state)\nthis:\n  u + v = (0::'a)\n\ngoal (1 subgoal):\n 1. s = t", "hence \"u = 0\""], ["proof (prove)\nusing this:\n  u + v = (0::'a)\n\ngoal (1 subgoal):\n 1. u = (0::'a)", "using plus_eq_zero[of u v]"], ["proof (prove)\nusing this:\n  u + v = (0::'a)\n  u + v = (0::'a) \\<Longrightarrow> u = (0::'a)\n\ngoal (1 subgoal):\n 1. u = (0::'a)", "by simp"], ["proof (state)\nthis:\n  u = (0::'a)\n\ngoal (1 subgoal):\n 1. s = t", "thus ?thesis"], ["proof (prove)\nusing this:\n  u = (0::'a)\n\ngoal (1 subgoal):\n 1. s = t", "using u_def"], ["proof (prove)\nusing this:\n  u = (0::'a)\n  t = s + u\n\ngoal (1 subgoal):\n 1. s = t", "by simp"], ["proof (state)\nthis:\n  s = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lcs_unique:\n  assumes \"s adds l\" and \"t adds l\" and *: \"\\<And>u. s adds u \\<Longrightarrow> t adds u \\<Longrightarrow> l adds u\"\n  shows \"l = lcs s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = lcs s t", "by (rule adds_antisym, rule *, fact adds_lcs, fact adds_lcs_2, rule lcs_adds, fact+)"], ["", "lemma lcs_zero: \"lcs 0 t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs (0::'a) t = t", "by (rule lcs_unique[symmetric], fact zero_adds, fact adds_refl)"], ["", "lemma lcs_plus_left: \"lcs (u + s) (u + t) = u + lcs s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs (u + s) (u + t) = u + lcs s t", "proof (rule lcs_unique[symmetric], simp_all only: adds_canc_2, fact adds_lcs, fact adds_lcs_2,\n    simp add: add.commute[of u] plus_adds)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>u adds ua \\<and> s adds ua - u; t adds ua - u\\<rbrakk>\n       \\<Longrightarrow> lcs s t adds ua - u", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>u adds ua \\<and> s adds ua - u; t adds ua - u\\<rbrakk>\n       \\<Longrightarrow> lcs s t adds ua - u", "assume \"u adds v \\<and> s adds v - u\""], ["proof (state)\nthis:\n  u adds v \\<and> s adds v - u\n\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>u adds ua \\<and> s adds ua - u; t adds ua - u\\<rbrakk>\n       \\<Longrightarrow> lcs s t adds ua - u", "hence \"s adds v - u\""], ["proof (prove)\nusing this:\n  u adds v \\<and> s adds v - u\n\ngoal (1 subgoal):\n 1. s adds v - u", ".."], ["proof (state)\nthis:\n  s adds v - u\n\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>u adds ua \\<and> s adds ua - u; t adds ua - u\\<rbrakk>\n       \\<Longrightarrow> lcs s t adds ua - u", "assume \"t adds v - u\""], ["proof (state)\nthis:\n  t adds v - u\n\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>u adds ua \\<and> s adds ua - u; t adds ua - u\\<rbrakk>\n       \\<Longrightarrow> lcs s t adds ua - u", "with \\<open>s adds v - u\\<close>"], ["proof (chain)\npicking this:\n  s adds v - u\n  t adds v - u", "show \"lcs s t adds v - u\""], ["proof (prove)\nusing this:\n  s adds v - u\n  t adds v - u\n\ngoal (1 subgoal):\n 1. lcs s t adds v - u", "by (rule lcs_adds)"], ["proof (state)\nthis:\n  lcs s t adds v - u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lcs_plus_right: \"lcs (s + u) (t + u) = (lcs s t) + u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs (s + u) (t + u) = lcs s t + u", "using lcs_plus_left[of u s t]"], ["proof (prove)\nusing this:\n  lcs (u + s) (u + t) = u + lcs s t\n\ngoal (1 subgoal):\n 1. lcs (s + u) (t + u) = lcs s t + u", "by (simp add: ac_simps)"], ["", "lemma adds_gcs:\n  assumes \"u adds s\" and \"u adds t\"\n  shows \"u adds (gcs s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u adds gcs s t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u adds gcs s t", "from assms"], ["proof (chain)\npicking this:\n  u adds s\n  u adds t", "have \"s + u adds s + t\" and \"t + u adds t + s\""], ["proof (prove)\nusing this:\n  u adds s\n  u adds t\n\ngoal (1 subgoal):\n 1. s + u adds s + t &&& t + u adds t + s", "by (simp_all add: plus_adds_mono)"], ["proof (state)\nthis:\n  s + u adds s + t\n  t + u adds t + s\n\ngoal (1 subgoal):\n 1. u adds gcs s t", "hence \"lcs (s + u) (t + u) adds s + t\""], ["proof (prove)\nusing this:\n  s + u adds s + t\n  t + u adds t + s\n\ngoal (1 subgoal):\n 1. lcs (s + u) (t + u) adds s + t", "by (auto intro: lcs_adds simp add: ac_simps)"], ["proof (state)\nthis:\n  lcs (s + u) (t + u) adds s + t\n\ngoal (1 subgoal):\n 1. u adds gcs s t", "hence \"u + (lcs s t) adds s + t\""], ["proof (prove)\nusing this:\n  lcs (s + u) (t + u) adds s + t\n\ngoal (1 subgoal):\n 1. u + lcs s t adds s + t", "unfolding lcs_plus_right"], ["proof (prove)\nusing this:\n  lcs s t + u adds s + t\n\ngoal (1 subgoal):\n 1. u + lcs s t adds s + t", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  u + lcs s t adds s + t\n\ngoal (1 subgoal):\n 1. u adds gcs s t", "hence \"u adds (s + t) - (lcs s t)\""], ["proof (prove)\nusing this:\n  u + lcs s t adds s + t\n\ngoal (1 subgoal):\n 1. u adds s + t - lcs s t", "unfolding plus_adds"], ["proof (prove)\nusing this:\n  lcs s t adds s + t \\<and> u adds s + t - lcs s t\n\ngoal (1 subgoal):\n 1. u adds s + t - lcs s t", ".."], ["proof (state)\nthis:\n  u adds s + t - lcs s t\n\ngoal (1 subgoal):\n 1. u adds gcs s t", "thus ?thesis"], ["proof (prove)\nusing this:\n  u adds s + t - lcs s t\n\ngoal (1 subgoal):\n 1. u adds gcs s t", "unfolding gcs_def"], ["proof (prove)\nusing this:\n  u adds s + t - lcs s t\n\ngoal (1 subgoal):\n 1. u adds s + t - lcs s t", "."], ["proof (state)\nthis:\n  u adds gcs s t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcs_unique:\n  assumes \"g adds s\" and \"g adds t\" and *: \"\\<And>u. u adds s \\<Longrightarrow> u adds t \\<Longrightarrow> u adds g\"\n  shows \"g = gcs s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = gcs s t", "by (rule adds_antisym, rule adds_gcs, fact, fact, rule *, fact gcs_adds, fact gcs_adds_2)"], ["", "lemma gcs_plus_left: \"gcs (u + s) (u + t) = u + gcs s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs (u + s) (u + t) = u + gcs s t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcs (u + s) (u + t) = u + gcs s t", "have \"u + s + (u + t) - (u + lcs s t) = u + s + (u + t) - u - lcs s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u + s + (u + t) - (u + lcs s t) = u + s + (u + t) - u - lcs s t", "by (simp only: diff_diff_add)"], ["proof (state)\nthis:\n  u + s + (u + t) - (u + lcs s t) = u + s + (u + t) - u - lcs s t\n\ngoal (1 subgoal):\n 1. gcs (u + s) (u + t) = u + gcs s t", "also"], ["proof (state)\nthis:\n  u + s + (u + t) - (u + lcs s t) = u + s + (u + t) - u - lcs s t\n\ngoal (1 subgoal):\n 1. gcs (u + s) (u + t) = u + gcs s t", "have \"... = u + s + t + (u - u) - lcs s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u + s + (u + t) - u - lcs s t = u + s + t + (u - u) - lcs s t", "by (simp add: add.left_commute)"], ["proof (state)\nthis:\n  u + s + (u + t) - u - lcs s t = u + s + t + (u - u) - lcs s t\n\ngoal (1 subgoal):\n 1. gcs (u + s) (u + t) = u + gcs s t", "also"], ["proof (state)\nthis:\n  u + s + (u + t) - u - lcs s t = u + s + t + (u - u) - lcs s t\n\ngoal (1 subgoal):\n 1. gcs (u + s) (u + t) = u + gcs s t", "have \"... = u + s + t - lcs s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u + s + t + (u - u) - lcs s t = u + s + t - lcs s t", "by simp"], ["proof (state)\nthis:\n  u + s + t + (u - u) - lcs s t = u + s + t - lcs s t\n\ngoal (1 subgoal):\n 1. gcs (u + s) (u + t) = u + gcs s t", "also"], ["proof (state)\nthis:\n  u + s + t + (u - u) - lcs s t = u + s + t - lcs s t\n\ngoal (1 subgoal):\n 1. gcs (u + s) (u + t) = u + gcs s t", "have \"... =  u + (s + t - lcs s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u + s + t - lcs s t = u + (s + t - lcs s t)", "using add_assoc add_commute local.lcs_adds_plus local.minus_plus"], ["proof (prove)\nusing this:\n  ?a + ?b + ?c = ?a + (?b + ?c)\n  ?a + ?b = ?b + ?a\n  lcs ?s ?t adds ?s + ?t\n  ?s adds ?t \\<Longrightarrow> ?t - ?s + ?u = ?t + ?u - ?s\n\ngoal (1 subgoal):\n 1. u + s + t - lcs s t = u + (s + t - lcs s t)", "by auto"], ["proof (state)\nthis:\n  u + s + t - lcs s t = u + (s + t - lcs s t)\n\ngoal (1 subgoal):\n 1. gcs (u + s) (u + t) = u + gcs s t", "finally"], ["proof (chain)\npicking this:\n  u + s + (u + t) - (u + lcs s t) = u + (s + t - lcs s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  u + s + (u + t) - (u + lcs s t) = u + (s + t - lcs s t)\n\ngoal (1 subgoal):\n 1. gcs (u + s) (u + t) = u + gcs s t", "unfolding gcs_def lcs_plus_left"], ["proof (prove)\nusing this:\n  u + s + (u + t) - (u + lcs s t) = u + (s + t - lcs s t)\n\ngoal (1 subgoal):\n 1. u + s + (u + t) - (u + lcs s t) = u + (s + t - lcs s t)", "."], ["proof (state)\nthis:\n  gcs (u + s) (u + t) = u + gcs s t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcs_plus_right: \"gcs (s + u) (t + u) = (gcs s t) + u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs (s + u) (t + u) = gcs s t + u", "using gcs_plus_left[of u s t]"], ["proof (prove)\nusing this:\n  gcs (u + s) (u + t) = u + gcs s t\n\ngoal (1 subgoal):\n 1. gcs (s + u) (t + u) = gcs s t + u", "by (simp add: ac_simps)"], ["", "lemma lcs_same [simp]: \"lcs s s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs s s = s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lcs s s = s", "have \"lcs s s adds s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs s s adds s", "by (rule lcs_adds, simp_all)"], ["proof (state)\nthis:\n  lcs s s adds s\n\ngoal (1 subgoal):\n 1. lcs s s = s", "moreover"], ["proof (state)\nthis:\n  lcs s s adds s\n\ngoal (1 subgoal):\n 1. lcs s s = s", "have \"s adds lcs s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds lcs s s", "by (rule adds_lcs)"], ["proof (state)\nthis:\n  s adds lcs s s\n\ngoal (1 subgoal):\n 1. lcs s s = s", "ultimately"], ["proof (chain)\npicking this:\n  lcs s s adds s\n  s adds lcs s s", "show ?thesis"], ["proof (prove)\nusing this:\n  lcs s s adds s\n  s adds lcs s s\n\ngoal (1 subgoal):\n 1. lcs s s = s", "by (rule adds_antisym)"], ["proof (state)\nthis:\n  lcs s s = s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcs_same [simp]: \"gcs s s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s s = s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcs s s = s", "have \"gcs s s adds s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s s adds s", "by (rule gcs_adds)"], ["proof (state)\nthis:\n  gcs s s adds s\n\ngoal (1 subgoal):\n 1. gcs s s = s", "moreover"], ["proof (state)\nthis:\n  gcs s s adds s\n\ngoal (1 subgoal):\n 1. gcs s s = s", "have \"s adds gcs s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds gcs s s", "by (rule adds_gcs, simp_all)"], ["proof (state)\nthis:\n  s adds gcs s s\n\ngoal (1 subgoal):\n 1. gcs s s = s", "ultimately"], ["proof (chain)\npicking this:\n  gcs s s adds s\n  s adds gcs s s", "show ?thesis"], ["proof (prove)\nusing this:\n  gcs s s adds s\n  s adds gcs s s\n\ngoal (1 subgoal):\n 1. gcs s s = s", "by (rule adds_antisym)"], ["proof (state)\nthis:\n  gcs s s = s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Dickson Classes\\<close>"], ["", "definition (in plus) dickson_grading :: \"('a \\<Rightarrow> nat) \\<Rightarrow> bool\"\n  where \"dickson_grading d \\<longleftrightarrow>\n          ((\\<forall>s t. d (s + t) = max (d s) (d t)) \\<and> (\\<forall>n::nat. almost_full_on (adds) {x. d x \\<le> n}))\""], ["", "definition dgrad_set :: \"('a \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> 'a set\"\n  where \"dgrad_set d m = {t. d t \\<le> m}\""], ["", "definition dgrad_set_le :: \"('a \\<Rightarrow> nat) \\<Rightarrow> ('a set) \\<Rightarrow> ('a set) \\<Rightarrow> bool\"\n  where \"dgrad_set_le d S T \\<longleftrightarrow> (\\<forall>s\\<in>S. \\<exists>t\\<in>T. d s \\<le> d t)\""], ["", "lemma dickson_gradingI:\n  assumes \"\\<And>s t. d (s + t) = max (d s) (d t)\"\n  assumes \"\\<And>n::nat. almost_full_on (adds) {x. d x \\<le> n}\"\n  shows \"dickson_grading d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_grading d", "unfolding dickson_grading_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s t. d (s + t) = max (d s) (d t)) \\<and>\n    (\\<forall>n. almost_full_on (adds) {x. d x \\<le> n})", "using assms"], ["proof (prove)\nusing this:\n  d (?s + ?t) = max (d ?s) (d ?t)\n  almost_full_on (adds) {x. d x \\<le> ?n}\n\ngoal (1 subgoal):\n 1. (\\<forall>s t. d (s + t) = max (d s) (d t)) \\<and>\n    (\\<forall>n. almost_full_on (adds) {x. d x \\<le> n})", "by blast"], ["", "lemma dickson_gradingD1: \"dickson_grading d \\<Longrightarrow> d (s + t) = max (d s) (d t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_grading d \\<Longrightarrow> d (s + t) = max (d s) (d t)", "by (auto simp add: dickson_grading_def)"], ["", "lemma dickson_gradingD2: \"dickson_grading d \\<Longrightarrow> almost_full_on (adds) {x. d x \\<le> n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_grading d \\<Longrightarrow>\n    almost_full_on (adds) {x. d x \\<le> n}", "by (auto simp add: dickson_grading_def)"], ["", "lemma dickson_gradingD2':\n  assumes \"dickson_grading (d::'a::comm_monoid_add \\<Rightarrow> nat)\"\n  shows \"wqo_on (adds) {x. d x \\<le> n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wqo_on (adds) {x. d x \\<le> n}", "proof (intro wqo_onI transp_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<in> {x. d x \\<le> n}; y \\<in> {x. d x \\<le> n};\n        z \\<in> {x. d x \\<le> n}; x adds y; y adds z\\<rbrakk>\n       \\<Longrightarrow> x adds z\n 2. almost_full_on (adds) {x. d x \\<le> n}", "fix x y z :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<in> {x. d x \\<le> n}; y \\<in> {x. d x \\<le> n};\n        z \\<in> {x. d x \\<le> n}; x adds y; y adds z\\<rbrakk>\n       \\<Longrightarrow> x adds z\n 2. almost_full_on (adds) {x. d x \\<le> n}", "assume \"x adds y\" and \"y adds z\""], ["proof (state)\nthis:\n  x adds y\n  y adds z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<in> {x. d x \\<le> n}; y \\<in> {x. d x \\<le> n};\n        z \\<in> {x. d x \\<le> n}; x adds y; y adds z\\<rbrakk>\n       \\<Longrightarrow> x adds z\n 2. almost_full_on (adds) {x. d x \\<le> n}", "thus \"x adds z\""], ["proof (prove)\nusing this:\n  x adds y\n  y adds z\n\ngoal (1 subgoal):\n 1. x adds z", "by (rule adds_trans)"], ["proof (state)\nthis:\n  x adds z\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. d x \\<le> n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. d x \\<le> n}", "from assms"], ["proof (chain)\npicking this:\n  dickson_grading d", "show \"almost_full_on (adds) {x. d x \\<le> n}\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. d x \\<le> n}", "by (rule dickson_gradingD2)"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. d x \\<le> n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dickson_gradingE:\n  assumes \"dickson_grading d\" and \"\\<And>i::nat. d ((seq::nat \\<Rightarrow> 'a::plus) i) \\<le> n\"\n  obtains i j where \"i < j\" and \"seq i adds seq j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(1)"], ["proof (chain)\npicking this:\n  dickson_grading d", "have \"almost_full_on (adds) {x. d x \\<le> n}\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. d x \\<le> n}", "by (rule dickson_gradingD2)"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(2)"], ["proof (chain)\npicking this:\n  d (seq ?i) \\<le> n", "have \"\\<And>i. seq i \\<in> {x. d x \\<le> n}\""], ["proof (prove)\nusing this:\n  d (seq ?i) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i. seq i \\<in> {x. d x \\<le> n}", "by simp"], ["proof (state)\nthis:\n  seq ?i \\<in> {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  almost_full_on (adds) {x. d x \\<le> n}\n  seq ?i \\<in> {x. d x \\<le> n}", "obtain i j where \"i < j\" and \"seq i adds seq j\""], ["proof (prove)\nusing this:\n  almost_full_on (adds) {x. d x \\<le> n}\n  seq ?i \\<in> {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule almost_full_onD)"], ["proof (state)\nthis:\n  i < j\n  seq i adds seq j\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < j\n  seq i adds seq j\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dickson_grading_adds_imp_le:\n  assumes \"dickson_grading d\" and \"s adds t\"\n  shows \"d s \\<le> d t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d s \\<le> d t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d s \\<le> d t", "from assms(2)"], ["proof (chain)\npicking this:\n  s adds t", "obtain u where \"t = s + u\""], ["proof (prove)\nusing this:\n  s adds t\n\ngoal (1 subgoal):\n 1. (\\<And>u. t = s + u \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  t = s + u\n\ngoal (1 subgoal):\n 1. d s \\<le> d t", "hence \"d t = max (d s) (d u)\""], ["proof (prove)\nusing this:\n  t = s + u\n\ngoal (1 subgoal):\n 1. d t = max (d s) (d u)", "by (simp only: dickson_gradingD1[OF assms(1)])"], ["proof (state)\nthis:\n  d t = max (d s) (d u)\n\ngoal (1 subgoal):\n 1. d s \\<le> d t", "thus ?thesis"], ["proof (prove)\nusing this:\n  d t = max (d s) (d u)\n\ngoal (1 subgoal):\n 1. d s \\<le> d t", "by simp"], ["proof (state)\nthis:\n  d s \\<le> d t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dickson_grading_minus:\n  assumes \"dickson_grading d\" and \"s adds (t::'a::cancel_ab_semigroup_add)\"\n  shows \"d (t - s) \\<le> d t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (t - s) \\<le> d t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d (t - s) \\<le> d t", "from assms(2)"], ["proof (chain)\npicking this:\n  s adds t", "obtain u where \"t = s + u\""], ["proof (prove)\nusing this:\n  s adds t\n\ngoal (1 subgoal):\n 1. (\\<And>u. t = s + u \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  t = s + u\n\ngoal (1 subgoal):\n 1. d (t - s) \\<le> d t", "hence \"t - s = u\""], ["proof (prove)\nusing this:\n  t = s + u\n\ngoal (1 subgoal):\n 1. t - s = u", "by simp"], ["proof (state)\nthis:\n  t - s = u\n\ngoal (1 subgoal):\n 1. d (t - s) \\<le> d t", "from assms(1)"], ["proof (chain)\npicking this:\n  dickson_grading d", "have \"d t = ord_class.max (d s) (d u)\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. d t = max (d s) (d u)", "unfolding \\<open>t = s + u\\<close>"], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. d (s + u) = max (d s) (d u)", "by (rule dickson_gradingD1)"], ["proof (state)\nthis:\n  d t = max (d s) (d u)\n\ngoal (1 subgoal):\n 1. d (t - s) \\<le> d t", "thus ?thesis"], ["proof (prove)\nusing this:\n  d t = max (d s) (d u)\n\ngoal (1 subgoal):\n 1. d (t - s) \\<le> d t", "by (simp add: \\<open>t - s = u\\<close>)"], ["proof (state)\nthis:\n  d (t - s) \\<le> d t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dickson_grading_lcs:\n  assumes \"dickson_grading d\"\n  shows \"d (lcs s t) \\<le> max (d s) (d t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (lcs s t) \\<le> max (d s) (d t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d (lcs s t) \\<le> max (d s) (d t)", "from assms"], ["proof (chain)\npicking this:\n  dickson_grading d", "have \"d (lcs s t) \\<le> d (s + t)\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. d (lcs s t) \\<le> d (s + t)", "by (rule dickson_grading_adds_imp_le, intro lcs_adds_plus)"], ["proof (state)\nthis:\n  d (lcs s t) \\<le> d (s + t)\n\ngoal (1 subgoal):\n 1. d (lcs s t) \\<le> max (d s) (d t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  d (lcs s t) \\<le> d (s + t)\n\ngoal (1 subgoal):\n 1. d (lcs s t) \\<le> max (d s) (d t)", "by (simp only: dickson_gradingD1[OF assms])"], ["proof (state)\nthis:\n  d (lcs s t) \\<le> max (d s) (d t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dickson_grading_lcs_minus:\n  assumes \"dickson_grading d\"\n  shows \"d (lcs s t - s) \\<le> max (d s) (d t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (lcs s t - s) \\<le> max (d s) (d t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d (lcs s t - s) \\<le> max (d s) (d t)", "from assms"], ["proof (chain)\npicking this:\n  dickson_grading d", "have \"d (lcs s t - s) \\<le> d (lcs s t)\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. d (lcs s t - s) \\<le> d (lcs s t)", "by (rule dickson_grading_minus, intro adds_lcs)"], ["proof (state)\nthis:\n  d (lcs s t - s) \\<le> d (lcs s t)\n\ngoal (1 subgoal):\n 1. d (lcs s t - s) \\<le> max (d s) (d t)", "also"], ["proof (state)\nthis:\n  d (lcs s t - s) \\<le> d (lcs s t)\n\ngoal (1 subgoal):\n 1. d (lcs s t - s) \\<le> max (d s) (d t)", "from assms"], ["proof (chain)\npicking this:\n  dickson_grading d", "have \"... \\<le> max (d s) (d t)\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. d (lcs s t) \\<le> max (d s) (d t)", "by (rule dickson_grading_lcs)"], ["proof (state)\nthis:\n  d (lcs s t) \\<le> max (d s) (d t)\n\ngoal (1 subgoal):\n 1. d (lcs s t - s) \\<le> max (d s) (d t)", "finally"], ["proof (chain)\npicking this:\n  d (lcs s t - s) \\<le> max (d s) (d t)", "show ?thesis"], ["proof (prove)\nusing this:\n  d (lcs s t - s) \\<le> max (d s) (d t)\n\ngoal (1 subgoal):\n 1. d (lcs s t - s) \\<le> max (d s) (d t)", "."], ["proof (state)\nthis:\n  d (lcs s t - s) \\<le> max (d s) (d t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dgrad_set_leI:\n  assumes \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. d s \\<le> d t\"\n  shows \"dgrad_set_le d S T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_set_le d S T", "using assms"], ["proof (prove)\nusing this:\n  ?s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. d ?s \\<le> d t\n\ngoal (1 subgoal):\n 1. dgrad_set_le d S T", "by (auto simp: dgrad_set_le_def)"], ["", "lemma dgrad_set_leE:\n  assumes \"dgrad_set_le d S T\" and \"s \\<in> S\"\n  obtains t where \"t \\<in> T\" and \"d s \\<le> d t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> T; d s \\<le> d t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  dgrad_set_le d S T\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> T; d s \\<le> d t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: dgrad_set_le_def)"], ["", "lemma dgrad_set_exhaust_expl:\n  assumes \"finite F\"\n  shows \"F \\<subseteq> dgrad_set d (Max (d ` F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> dgrad_set d (Max (d ` F))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d (Max (d ` F))", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d (Max (d ` F))", "assume \"f \\<in> F\""], ["proof (state)\nthis:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d (Max (d ` F))", "hence \"d f \\<in> d ` F\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. d f \\<in> d ` F", "by simp"], ["proof (state)\nthis:\n  d f \\<in> d ` F\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d (Max (d ` F))", "with _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  d f \\<in> d ` F", "have \"d f \\<le> Max (d ` F)\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  d f \\<in> d ` F\n\ngoal (1 subgoal):\n 1. d f \\<le> Max (d ` F)", "proof (rule Max_ge)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (d ` F)", "from assms"], ["proof (chain)\npicking this:\n  finite F", "show \"finite (d ` F)\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite (d ` F)", "by auto"], ["proof (state)\nthis:\n  finite (d ` F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d f \\<le> Max (d ` F)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d (Max (d ` F))", "hence \"dgrad_set d (d f) \\<subseteq> dgrad_set d (Max (d ` F))\""], ["proof (prove)\nusing this:\n  d f \\<le> Max (d ` F)\n\ngoal (1 subgoal):\n 1. dgrad_set d (d f) \\<subseteq> dgrad_set d (Max (d ` F))", "by (auto simp: dgrad_set_def)"], ["proof (state)\nthis:\n  dgrad_set d (d f) \\<subseteq> dgrad_set d (Max (d ` F))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d (Max (d ` F))", "moreover"], ["proof (state)\nthis:\n  dgrad_set d (d f) \\<subseteq> dgrad_set d (Max (d ` F))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d (Max (d ` F))", "have \"f \\<in> dgrad_set d (d f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> dgrad_set d (d f)", "by (simp add: dgrad_set_def)"], ["proof (state)\nthis:\n  f \\<in> dgrad_set d (d f)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d (Max (d ` F))", "ultimately"], ["proof (chain)\npicking this:\n  dgrad_set d (d f) \\<subseteq> dgrad_set d (Max (d ` F))\n  f \\<in> dgrad_set d (d f)", "show \"f \\<in> dgrad_set d (Max (d ` F))\""], ["proof (prove)\nusing this:\n  dgrad_set d (d f) \\<subseteq> dgrad_set d (Max (d ` F))\n  f \\<in> dgrad_set d (d f)\n\ngoal (1 subgoal):\n 1. f \\<in> dgrad_set d (Max (d ` F))", ".."], ["proof (state)\nthis:\n  f \\<in> dgrad_set d (Max (d ` F))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dgrad_set_exhaust:\n  assumes \"finite F\"\n  obtains m where \"F \\<subseteq> dgrad_set d m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        F \\<subseteq> dgrad_set d m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        F \\<subseteq> dgrad_set d m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    F \\<subseteq> dgrad_set d ?m2", "from assms"], ["proof (chain)\npicking this:\n  finite F", "show \"F \\<subseteq> dgrad_set d (Max (d ` F))\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. F \\<subseteq> dgrad_set d (Max (d ` F))", "by (rule dgrad_set_exhaust_expl)"], ["proof (state)\nthis:\n  F \\<subseteq> dgrad_set d (Max (d ` F))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dgrad_set_le_trans [trans]:\n  assumes \"dgrad_set_le d S T\" and \"dgrad_set_le d T U\"\n  shows \"dgrad_set_le d S U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_set_le d S U", "unfolding dgrad_set_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. \\<exists>t\\<in>U. d s \\<le> d t", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>U. d s \\<le> d t", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>U. d s \\<le> d t", "assume \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>U. d s \\<le> d t", "with assms(1)"], ["proof (chain)\npicking this:\n  dgrad_set_le d S T\n  s \\<in> S", "obtain t where \"t \\<in> T\" and 1: \"d s \\<le> d t\""], ["proof (prove)\nusing this:\n  dgrad_set_le d S T\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> T; d s \\<le> d t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: dgrad_set_le_def)"], ["proof (state)\nthis:\n  t \\<in> T\n  d s \\<le> d t\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>U. d s \\<le> d t", "from assms(2) this(1)"], ["proof (chain)\npicking this:\n  dgrad_set_le d T U\n  t \\<in> T", "obtain u where \"u \\<in> U\" and 2: \"d t \\<le> d u\""], ["proof (prove)\nusing this:\n  dgrad_set_le d T U\n  t \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> U; d t \\<le> d u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: dgrad_set_le_def)"], ["proof (state)\nthis:\n  u \\<in> U\n  d t \\<le> d u\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>U. d s \\<le> d t", "from this(1)"], ["proof (chain)\npicking this:\n  u \\<in> U", "show \"\\<exists>u\\<in>U. d s \\<le> d u\""], ["proof (prove)\nusing this:\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. d s \\<le> d u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. d s \\<le> d u", "from 1 2"], ["proof (chain)\npicking this:\n  d s \\<le> d t\n  d t \\<le> d u", "show \"d s \\<le> d u\""], ["proof (prove)\nusing this:\n  d s \\<le> d t\n  d t \\<le> d u\n\ngoal (1 subgoal):\n 1. d s \\<le> d u", "by (rule le_trans)"], ["proof (state)\nthis:\n  d s \\<le> d u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. d s \\<le> d u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dgrad_set_le_Un: \"dgrad_set_le d (S \\<union> T) U \\<longleftrightarrow> (dgrad_set_le d S U \\<and> dgrad_set_le d T U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_set_le d (S \\<union> T) U =\n    (dgrad_set_le d S U \\<and> dgrad_set_le d T U)", "by (auto simp add: dgrad_set_le_def)"], ["", "lemma dgrad_set_le_subset:\n  assumes \"S \\<subseteq> T\"\n  shows \"dgrad_set_le d S T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_set_le d S T", "unfolding dgrad_set_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. \\<exists>t\\<in>T. d s \\<le> d t", "using assms"], ["proof (prove)\nusing this:\n  S \\<subseteq> T\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. \\<exists>t\\<in>T. d s \\<le> d t", "by blast"], ["", "lemma dgrad_set_le_refl: \"dgrad_set_le d S S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_set_le d S S", "by (rule dgrad_set_le_subset, fact subset_refl)"], ["", "lemma dgrad_set_le_dgrad_set:\n  assumes \"dgrad_set_le d F G\" and \"G \\<subseteq> dgrad_set d m\"\n  shows \"F \\<subseteq> dgrad_set d m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> dgrad_set d m", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d m", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d m", "assume \"f \\<in> F\""], ["proof (state)\nthis:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d m", "with assms(1)"], ["proof (chain)\npicking this:\n  dgrad_set_le d F G\n  f \\<in> F", "obtain g where \"g \\<in> G\" and *: \"d f \\<le> d g\""], ["proof (prove)\nusing this:\n  dgrad_set_le d F G\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; d f \\<le> d g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: dgrad_set_le_def)"], ["proof (state)\nthis:\n  g \\<in> G\n  d f \\<le> d g\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d m", "from assms(2) this(1)"], ["proof (chain)\npicking this:\n  G \\<subseteq> dgrad_set d m\n  g \\<in> G", "have \"g \\<in> dgrad_set d m\""], ["proof (prove)\nusing this:\n  G \\<subseteq> dgrad_set d m\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. g \\<in> dgrad_set d m", ".."], ["proof (state)\nthis:\n  g \\<in> dgrad_set d m\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d m", "hence \"d g \\<le> m\""], ["proof (prove)\nusing this:\n  g \\<in> dgrad_set d m\n\ngoal (1 subgoal):\n 1. d g \\<le> m", "by (simp add: dgrad_set_def)"], ["proof (state)\nthis:\n  d g \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d m", "with *"], ["proof (chain)\npicking this:\n  d f \\<le> d g\n  d g \\<le> m", "have \"d f \\<le> m\""], ["proof (prove)\nusing this:\n  d f \\<le> d g\n  d g \\<le> m\n\ngoal (1 subgoal):\n 1. d f \\<le> m", "by (rule le_trans)"], ["proof (state)\nthis:\n  d f \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> dgrad_set d m", "thus \"f \\<in> dgrad_set d m\""], ["proof (prove)\nusing this:\n  d f \\<le> m\n\ngoal (1 subgoal):\n 1. f \\<in> dgrad_set d m", "by (simp add: dgrad_set_def)"], ["proof (state)\nthis:\n  f \\<in> dgrad_set d m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dgrad_set_dgrad: \"p \\<in> dgrad_set d (d p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> dgrad_set d (d p)", "by (simp add: dgrad_set_def)"], ["", "lemma dgrad_setI [intro]:\n  assumes \"d t \\<le> m\"\n  shows \"t \\<in> dgrad_set d m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> dgrad_set d m", "using assms"], ["proof (prove)\nusing this:\n  d t \\<le> m\n\ngoal (1 subgoal):\n 1. t \\<in> dgrad_set d m", "by (auto simp: dgrad_set_def)"], ["", "lemma dgrad_setD:\n  assumes \"t \\<in> dgrad_set d m\"\n  shows \"d t \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d t \\<le> m", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> dgrad_set d m\n\ngoal (1 subgoal):\n 1. d t \\<le> m", "by (simp add: dgrad_set_def)"], ["", "lemma dgrad_set_zero [simp]: \"dgrad_set (\\<lambda>_. 0) m = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_set (\\<lambda>_. 0) m = UNIV", "by auto"], ["", "lemma subset_dgrad_set_zero: \"F \\<subseteq> dgrad_set (\\<lambda>_. 0) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> dgrad_set (\\<lambda>_. 0) m", "by simp"], ["", "lemma dgrad_set_subset:\n  assumes \"m \\<le> n\"\n  shows \"dgrad_set d m \\<subseteq> dgrad_set d n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_set d m \\<subseteq> dgrad_set d n", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. dgrad_set d m \\<subseteq> dgrad_set d n", "by (auto simp: dgrad_set_def)"], ["", "lemma dgrad_set_closed_plus:\n  assumes \"dickson_grading d\" and \"s \\<in> dgrad_set d m\" and \"t \\<in> dgrad_set d m\"\n  shows \"s + t \\<in> dgrad_set d m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + t \\<in> dgrad_set d m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s + t \\<in> dgrad_set d m", "from assms(1)"], ["proof (chain)\npicking this:\n  dickson_grading d", "have \"d (s + t) = ord_class.max (d s) (d t)\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. d (s + t) = max (d s) (d t)", "by (rule dickson_gradingD1)"], ["proof (state)\nthis:\n  d (s + t) = max (d s) (d t)\n\ngoal (1 subgoal):\n 1. s + t \\<in> dgrad_set d m", "also"], ["proof (state)\nthis:\n  d (s + t) = max (d s) (d t)\n\ngoal (1 subgoal):\n 1. s + t \\<in> dgrad_set d m", "from assms(2, 3)"], ["proof (chain)\npicking this:\n  s \\<in> dgrad_set d m\n  t \\<in> dgrad_set d m", "have \"... \\<le> m\""], ["proof (prove)\nusing this:\n  s \\<in> dgrad_set d m\n  t \\<in> dgrad_set d m\n\ngoal (1 subgoal):\n 1. max (d s) (d t) \\<le> m", "by (simp add: dgrad_set_def)"], ["proof (state)\nthis:\n  max (d s) (d t) \\<le> m\n\ngoal (1 subgoal):\n 1. s + t \\<in> dgrad_set d m", "finally"], ["proof (chain)\npicking this:\n  d (s + t) \\<le> m", "show ?thesis"], ["proof (prove)\nusing this:\n  d (s + t) \\<le> m\n\ngoal (1 subgoal):\n 1. s + t \\<in> dgrad_set d m", "by (simp add: dgrad_set_def)"], ["proof (state)\nthis:\n  s + t \\<in> dgrad_set d m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dgrad_set_closed_minus:\n  assumes \"dickson_grading d\" and \"s \\<in> dgrad_set d m\" and \"t adds (s::'a::cancel_ab_semigroup_add)\"\n  shows \"s - t \\<in> dgrad_set d m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s - t \\<in> dgrad_set d m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s - t \\<in> dgrad_set d m", "from assms(1, 3)"], ["proof (chain)\npicking this:\n  dickson_grading d\n  t adds s", "have \"d (s - t) \\<le> d s\""], ["proof (prove)\nusing this:\n  dickson_grading d\n  t adds s\n\ngoal (1 subgoal):\n 1. d (s - t) \\<le> d s", "by (rule dickson_grading_minus)"], ["proof (state)\nthis:\n  d (s - t) \\<le> d s\n\ngoal (1 subgoal):\n 1. s - t \\<in> dgrad_set d m", "also"], ["proof (state)\nthis:\n  d (s - t) \\<le> d s\n\ngoal (1 subgoal):\n 1. s - t \\<in> dgrad_set d m", "from assms(2)"], ["proof (chain)\npicking this:\n  s \\<in> dgrad_set d m", "have \"... \\<le> m\""], ["proof (prove)\nusing this:\n  s \\<in> dgrad_set d m\n\ngoal (1 subgoal):\n 1. d s \\<le> m", "by (simp add: dgrad_set_def)"], ["proof (state)\nthis:\n  d s \\<le> m\n\ngoal (1 subgoal):\n 1. s - t \\<in> dgrad_set d m", "finally"], ["proof (chain)\npicking this:\n  d (s - t) \\<le> m", "show ?thesis"], ["proof (prove)\nusing this:\n  d (s - t) \\<le> m\n\ngoal (1 subgoal):\n 1. s - t \\<in> dgrad_set d m", "by (simp add: dgrad_set_def)"], ["proof (state)\nthis:\n  s - t \\<in> dgrad_set d m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dgrad_set_closed_lcs:\n  assumes \"dickson_grading d\" and \"s \\<in> dgrad_set d m\" and \"t \\<in> dgrad_set d m\"\n  shows \"lcs s t \\<in> dgrad_set d m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs s t \\<in> dgrad_set d m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lcs s t \\<in> dgrad_set d m", "from assms(1)"], ["proof (chain)\npicking this:\n  dickson_grading d", "have \"d (lcs s t) \\<le> ord_class.max (d s) (d t)\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. d (lcs s t) \\<le> max (d s) (d t)", "by (rule dickson_grading_lcs)"], ["proof (state)\nthis:\n  d (lcs s t) \\<le> max (d s) (d t)\n\ngoal (1 subgoal):\n 1. lcs s t \\<in> dgrad_set d m", "also"], ["proof (state)\nthis:\n  d (lcs s t) \\<le> max (d s) (d t)\n\ngoal (1 subgoal):\n 1. lcs s t \\<in> dgrad_set d m", "from assms(2, 3)"], ["proof (chain)\npicking this:\n  s \\<in> dgrad_set d m\n  t \\<in> dgrad_set d m", "have \"... \\<le> m\""], ["proof (prove)\nusing this:\n  s \\<in> dgrad_set d m\n  t \\<in> dgrad_set d m\n\ngoal (1 subgoal):\n 1. max (d s) (d t) \\<le> m", "by (simp add: dgrad_set_def)"], ["proof (state)\nthis:\n  max (d s) (d t) \\<le> m\n\ngoal (1 subgoal):\n 1. lcs s t \\<in> dgrad_set d m", "finally"], ["proof (chain)\npicking this:\n  d (lcs s t) \\<le> m", "show ?thesis"], ["proof (prove)\nusing this:\n  d (lcs s t) \\<le> m\n\ngoal (1 subgoal):\n 1. lcs s t \\<in> dgrad_set d m", "by (simp add: dgrad_set_def)"], ["proof (state)\nthis:\n  lcs s t \\<in> dgrad_set d m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dickson_gradingD_dgrad_set: \"dickson_grading d \\<Longrightarrow> almost_full_on (adds) (dgrad_set d m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_grading d \\<Longrightarrow>\n    almost_full_on (adds) (dgrad_set d m)", "by (auto dest: dickson_gradingD2 simp: dgrad_set_def)"], ["", "lemma ex_finite_adds:\n  assumes \"dickson_grading d\" and \"S \\<subseteq> dgrad_set d m\"\n  obtains T where \"finite T\" and \"T \\<subseteq> S\" and \"\\<And>s. s \\<in> S \\<Longrightarrow> (\\<exists>t\\<in>T. t adds (s::'a::cancel_comm_monoid_add))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. t adds s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. t adds s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"reflp ((adds)::'a \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp (adds)", "by (simp add: reflp_def)"], ["proof (state)\nthis:\n  reflp (adds)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. t adds s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  reflp (adds)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. t adds s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(2)"], ["proof (chain)\npicking this:\n  S \\<subseteq> dgrad_set d m", "have \"almost_full_on (adds) S\""], ["proof (prove)\nusing this:\n  S \\<subseteq> dgrad_set d m\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) S", "proof (rule almost_full_on_subset)"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_full_on (adds) (dgrad_set d m)", "from assms(1)"], ["proof (chain)\npicking this:\n  dickson_grading d", "show \"almost_full_on (adds) (dgrad_set d m)\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) (dgrad_set d m)", "by (rule dickson_gradingD_dgrad_set)"], ["proof (state)\nthis:\n  almost_full_on (adds) (dgrad_set d m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_full_on (adds) S\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. t adds s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  reflp (adds)\n  almost_full_on (adds) S", "obtain T where \"finite T\" and \"T \\<subseteq> S\" and \"\\<And>s. s \\<in> S \\<Longrightarrow> (\\<exists>t\\<in>T. t adds s)\""], ["proof (prove)\nusing this:\n  reflp (adds)\n  almost_full_on (adds) S\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. t adds s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule almost_full_on_finite_subsetE, blast)"], ["proof (state)\nthis:\n  finite T\n  T \\<subseteq> S\n  ?s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. t adds ?s\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. t adds s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite T\n  T \\<subseteq> S\n  ?s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. t adds ?s\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "class graded_dickson_powerprod = ulcs_powerprod +\n  assumes ex_dgrad: \"\\<exists>d::'a \\<Rightarrow> nat. dickson_grading d\"\nbegin"], ["", "definition dgrad_dummy where \"dgrad_dummy = (SOME d. dickson_grading d)\""], ["", "lemma dickson_grading_dgrad_dummy: \"dickson_grading dgrad_dummy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_grading dgrad_dummy", "unfolding dgrad_dummy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_grading (Eps dickson_grading)", "using ex_dgrad"], ["proof (prove)\nusing this:\n  \\<exists>d. dickson_grading d\n\ngoal (1 subgoal):\n 1. dickson_grading (Eps dickson_grading)", "by (rule someI_ex)"], ["", "end"], ["", "(* graded_dickson_powerprod *)"], ["", "class dickson_powerprod = ulcs_powerprod +\n  assumes dickson: \"almost_full_on (adds) UNIV\"\nbegin"], ["", "lemma dickson_grading_zero: \"dickson_grading (\\<lambda>_::'a. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_grading (\\<lambda>_. 0)", "by (simp add: dickson_grading_def dickson)"], ["", "subclass graded_dickson_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.graded_dickson_powerprod (+) (-) (0::'a) lcs", "by (standard, rule, fact dickson_grading_zero)"], ["", "end"], ["", "(* dickson_powerprod *)"], ["", "text \\<open>Class @{class graded_dickson_powerprod} is a slightly artificial construction. It is needed,\n  because type @{typ \"nat \\<Rightarrow>\\<^sub>0 nat\"} does not satisfy the usual conditions of a \"Dickson domain\" (as\n  formulated in class @{class dickson_powerprod}), but we still want to use that type as the type of\n  power-products in the computation of Gr\\\"obner bases. So, we exploit the fact that in a finite\n  set of polynomials (which is the input of Buchberger's algorithm) there is always some \"highest\"\n  indeterminate that occurs with non-zero exponent, and no \"higher\" indeterminates are generated\n  during the execution of the algorithm. This allows us to prove that the algorithm terminates, even\n  though there are in principle infinitely many indeterminates.\\<close>"], ["", "subsection \\<open>Additive Linear Orderings\\<close>"], ["", "lemma group_eq_aux: \"a + (b - a) = (b::'a::ab_group_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (b - a) = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a + (b - a) = b", "have \"a + (b - a) = b - a + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (b - a) = b - a + a", "by simp"], ["proof (state)\nthis:\n  a + (b - a) = b - a + a\n\ngoal (1 subgoal):\n 1. a + (b - a) = b", "also"], ["proof (state)\nthis:\n  a + (b - a) = b - a + a\n\ngoal (1 subgoal):\n 1. a + (b - a) = b", "have \"... = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b - a + a = b", "by simp"], ["proof (state)\nthis:\n  b - a + a = b\n\ngoal (1 subgoal):\n 1. a + (b - a) = b", "finally"], ["proof (chain)\npicking this:\n  a + (b - a) = b", "show ?thesis"], ["proof (prove)\nusing this:\n  a + (b - a) = b\n\ngoal (1 subgoal):\n 1. a + (b - a) = b", "."], ["proof (state)\nthis:\n  a + (b - a) = b\n\ngoal:\nNo subgoals!", "qed"], ["", "class semi_canonically_ordered_monoid_add = ordered_comm_monoid_add +\n  assumes le_imp_add: \"a \\<le> b \\<Longrightarrow> (\\<exists>c. b = a + c)\""], ["", "context canonically_ordered_monoid_add\nbegin"], ["", "subclass semi_canonically_ordered_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semi_canonically_ordered_monoid_add (+) (0::'a) (\\<le>) (<)", "by (standard, simp only: le_iff_add)"], ["", "end"], ["", "class add_linorder_group = ordered_ab_semigroup_add_imp_le + ab_group_add + linorder"], ["", "class add_linorder = ordered_ab_semigroup_add_imp_le + cancel_comm_monoid_add + semi_canonically_ordered_monoid_add + linorder\nbegin"], ["", "subclass ordered_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ordered_comm_monoid_add (+) (0::'a) (\\<le>) (<)", ".."], ["", "subclass ordered_cancel_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ordered_cancel_comm_monoid_add (+) (-) (0::'a) (\\<le>) (<)", ".."], ["", "lemma le_imp_inv:\n  assumes \"a \\<le> b\"\n  shows \"b = a + (b - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = a + (b - a)", "using le_imp_add[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>c. b = a + c\n\ngoal (1 subgoal):\n 1. b = a + (b - a)", "by auto"], ["", "lemma max_eq_sum:\n  obtains y where \"max a b = a + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. max a b = a + y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"a \\<le> b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n                thesis;\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n                thesis;\n     \\<not> a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n                thesis;\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n                thesis;\n     \\<not> a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"b = a + (b - a)\""], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. b = a + (b - a)", "by (rule le_imp_inv)"], ["proof (state)\nthis:\n  b = a + (b - a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n                thesis;\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n                thesis;\n     \\<not> a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  b = a + (b - a)", "obtain c where eq: \"b = a + c\""], ["proof (prove)\nusing this:\n  b = a + (b - a)\n\ngoal (1 subgoal):\n 1. (\\<And>c. b = a + c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  b = a + c\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n                thesis;\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n                thesis;\n     \\<not> a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. max a b = a + ?y1", "from True"], ["proof (chain)\npicking this:\n  a \\<le> b", "show \"max a b = a + c\""], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. max a b = a + c", "unfolding max_def eq"], ["proof (prove)\nusing this:\n  a \\<le> a + c\n\ngoal (1 subgoal):\n 1. (if a \\<le> a + c then a + c else a) = a + c", "by simp"], ["proof (state)\nthis:\n  max a b = a + c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n                thesis;\n     \\<not> a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n                thesis;\n     \\<not> a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                (if a \\<le> b then b else a) = a + y \\<Longrightarrow>\n                thesis;\n     \\<not> a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. max a b = a + ?y1", "from False"], ["proof (chain)\npicking this:\n  \\<not> a \\<le> b", "show \"max a b = a + 0\""], ["proof (prove)\nusing this:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. max a b = a + (0::'a)", "unfolding max_def"], ["proof (prove)\nusing this:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. (if a \\<le> b then b else a) = a + (0::'a)", "by simp"], ["proof (state)\nthis:\n  max a b = a + (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_plus_max:\n  shows \"(min a b) + (max a b) = a + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min a b + max a b = a + b", "proof (cases \"a \\<le> b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow> min a b + max a b = a + b\n 2. \\<not> a \\<le> b \\<Longrightarrow> min a b + max a b = a + b", "case True"], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow> min a b + max a b = a + b\n 2. \\<not> a \\<le> b \\<Longrightarrow> min a b + max a b = a + b", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. min a b + max a b = a + b", "unfolding min_def max_def"], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. (if a \\<le> b then a else b) + (if a \\<le> b then b else a) = a + b", "by simp"], ["proof (state)\nthis:\n  min a b + max a b = a + b\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow> min a b + max a b = a + b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow> min a b + max a b = a + b", "case False"], ["proof (state)\nthis:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow> min a b + max a b = a + b", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. min a b + max a b = a + b", "unfolding min_def max_def"], ["proof (prove)\nusing this:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. (if a \\<le> b then a else b) + (if a \\<le> b then b else a) = a + b", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  min a b + max a b = a + b\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* add_linorder *)"], ["", "class add_linorder_min = add_linorder +\n  assumes zero_min: \"0 \\<le> x\"\nbegin"], ["", "subclass ninv_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ninv_comm_monoid_add (+) (0::'a)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t. s + t = (0::'a) \\<Longrightarrow> s = (0::'a)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t. s + t = (0::'a) \\<Longrightarrow> s = (0::'a)", "assume *: \"x + y = 0\""], ["proof (state)\nthis:\n  x + y = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>s t. s + t = (0::'a) \\<Longrightarrow> s = (0::'a)", "show \"x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = (0::'a)", "from zero_min[of x]"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> x", "have \"0 = x \\<or> x > 0\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. (0::'a) = x \\<or> (0::'a) < x", "by auto"], ["proof (state)\nthis:\n  (0::'a) = x \\<or> (0::'a) < x\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) = x \\<or> (0::'a) < x\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) = x \\<Longrightarrow> x = (0::'a)\n 2. (0::'a) < x \\<Longrightarrow> x = (0::'a)", "assume \"x > 0\""], ["proof (state)\nthis:\n  (0::'a) < x\n\ngoal (2 subgoals):\n 1. (0::'a) = x \\<Longrightarrow> x = (0::'a)\n 2. (0::'a) < x \\<Longrightarrow> x = (0::'a)", "have \"0 \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> y", "by (fact zero_min)"], ["proof (state)\nthis:\n  (0::'a) \\<le> y\n\ngoal (2 subgoals):\n 1. (0::'a) = x \\<Longrightarrow> x = (0::'a)\n 2. (0::'a) < x \\<Longrightarrow> x = (0::'a)", "also"], ["proof (state)\nthis:\n  (0::'a) \\<le> y\n\ngoal (2 subgoals):\n 1. (0::'a) = x \\<Longrightarrow> x = (0::'a)\n 2. (0::'a) < x \\<Longrightarrow> x = (0::'a)", "have \"... = 0 + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = (0::'a) + y", "by simp"], ["proof (state)\nthis:\n  y = (0::'a) + y\n\ngoal (2 subgoals):\n 1. (0::'a) = x \\<Longrightarrow> x = (0::'a)\n 2. (0::'a) < x \\<Longrightarrow> x = (0::'a)", "also"], ["proof (state)\nthis:\n  y = (0::'a) + y\n\ngoal (2 subgoals):\n 1. (0::'a) = x \\<Longrightarrow> x = (0::'a)\n 2. (0::'a) < x \\<Longrightarrow> x = (0::'a)", "from \\<open>x > 0\\<close>"], ["proof (chain)\npicking this:\n  (0::'a) < x", "have \"... < x + y\""], ["proof (prove)\nusing this:\n  (0::'a) < x\n\ngoal (1 subgoal):\n 1. (0::'a) + y < x + y", "by (rule add_strict_right_mono)"], ["proof (state)\nthis:\n  (0::'a) + y < x + y\n\ngoal (2 subgoals):\n 1. (0::'a) = x \\<Longrightarrow> x = (0::'a)\n 2. (0::'a) < x \\<Longrightarrow> x = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (0::'a) < x + y", "have \"0 < x + y\""], ["proof (prove)\nusing this:\n  (0::'a) < x + y\n\ngoal (1 subgoal):\n 1. (0::'a) < x + y", "."], ["proof (state)\nthis:\n  (0::'a) < x + y\n\ngoal (2 subgoals):\n 1. (0::'a) = x \\<Longrightarrow> x = (0::'a)\n 2. (0::'a) < x \\<Longrightarrow> x = (0::'a)", "hence \"x + y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (0::'a) < x + y\n\ngoal (1 subgoal):\n 1. x + y \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  x + y \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. (0::'a) = x \\<Longrightarrow> x = (0::'a)\n 2. (0::'a) < x \\<Longrightarrow> x = (0::'a)", "from this *"], ["proof (chain)\npicking this:\n  x + y \\<noteq> (0::'a)\n  x + y = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  x + y \\<noteq> (0::'a)\n  x + y = (0::'a)\n\ngoal (1 subgoal):\n 1. x = (0::'a)", ".."], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) = x \\<Longrightarrow> x = (0::'a)", "qed simp"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leq_add_right:\n  shows \"x \\<le> x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x + y", "using add_left_mono[OF zero_min[of y], of x]"], ["proof (prove)\nusing this:\n  x + (0::'a) \\<le> x + y\n\ngoal (1 subgoal):\n 1. x \\<le> x + y", "by simp"], ["", "lemma leq_add_left:\n  shows \"x \\<le> y + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y + x", "using add_right_mono[OF zero_min[of y], of x]"], ["proof (prove)\nusing this:\n  (0::'a) + x \\<le> y + x\n\ngoal (1 subgoal):\n 1. x \\<le> y + x", "by simp"], ["", "subclass canonically_ordered_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.canonically_ordered_monoid_add (+) (0::'a) (\\<le>) (<)", "by (standard, rule, elim le_imp_add, elim exE, simp add: leq_add_right)"], ["", "end"], ["", "(* add_linorder_min *)"], ["", "class add_wellorder = add_linorder_min + wellorder"], ["", "instantiation nat :: add_linorder\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, add_linorder_class)", "by (standard, simp)"], ["", "end"], ["", "(* add_linorder *)"], ["", "instantiation nat :: add_linorder_min\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, add_linorder_min_class)", "by (standard, simp)"], ["", "end"], ["", "instantiation nat :: add_wellorder\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, add_wellorder_class)", ".."], ["", "end"], ["", "context add_linorder_group\nbegin"], ["", "subclass add_linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.add_linorder (+) (-) (0::'a) (\\<le>) (<)", "proof (standard, intro exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. a \\<le> b \\<Longrightarrow> b = a + ?c10 a b", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. a \\<le> b \\<Longrightarrow> b = a + ?c10 a b", "show \"b = a + (b - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = a + (b - a)", "using add_commute local.diff_add_cancel"], ["proof (prove)\nusing this:\n  ?a + ?b = ?b + ?a\n  ?a - ?b + ?b = ?a\n\ngoal (1 subgoal):\n 1. b = a + (b - a)", "by auto"], ["proof (state)\nthis:\n  b = a + (b - a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* add_linorder_group *)"], ["", "instantiation int :: add_linorder_group\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, add_linorder_group_class)", ".."], ["", "end"], ["", "instantiation rat :: add_linorder_group\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(rat, add_linorder_group_class)", ".."], ["", "end"], ["", "instantiation real :: add_linorder_group\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real, add_linorder_group_class)", ".."], ["", "end"], ["", "subsection \\<open>Ordered Power-Products\\<close>"], ["", "locale ordered_powerprod =\n  ordered_powerprod_lin: linorder ord ord_strict\n  for ord::\"'a \\<Rightarrow> 'a::comm_powerprod \\<Rightarrow> bool\" (infixl \"\\<preceq>\" 50)\n  and ord_strict::\"'a \\<Rightarrow> 'a::comm_powerprod \\<Rightarrow> bool\" (infixl \"\\<prec>\" 50) +\n  assumes zero_min: \"0 \\<preceq> t\"\n  assumes plus_monotone: \"s \\<preceq> t \\<Longrightarrow> s + u \\<preceq> t + u\"\nbegin"], ["", "abbreviation ord_conv (infixl \"\\<succeq>\" 50) where \"ord_conv \\<equiv> (\\<preceq>)\\<inverse>\\<inverse>\""], ["", "abbreviation ord_strict_conv (infixl \"\\<succ>\" 50) where \"ord_strict_conv \\<equiv> (\\<prec>)\\<inverse>\\<inverse>\""], ["", "lemma ord_canc:\n  assumes \"s + u \\<preceq> t + u\"\n  shows \"s \\<preceq> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<preceq> t", "proof (rule ordered_powerprod_lin.le_cases[of s t], simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<preceq> s \\<Longrightarrow> s \\<preceq> t", "assume \"t \\<preceq> s\""], ["proof (state)\nthis:\n  t \\<preceq> s\n\ngoal (1 subgoal):\n 1. t \\<preceq> s \\<Longrightarrow> s \\<preceq> t", "from assms plus_monotone[OF this, of u]"], ["proof (chain)\npicking this:\n  s + u \\<preceq> t + u\n  t + u \\<preceq> s + u", "have \"t + u = s + u\""], ["proof (prove)\nusing this:\n  s + u \\<preceq> t + u\n  t + u \\<preceq> s + u\n\ngoal (1 subgoal):\n 1. t + u = s + u", "using ordered_powerprod_lin.eq_iff"], ["proof (prove)\nusing this:\n  s + u \\<preceq> t + u\n  t + u \\<preceq> s + u\n  (?x = ?y) = (?x \\<preceq> ?y \\<and> ?y \\<preceq> ?x)\n\ngoal (1 subgoal):\n 1. t + u = s + u", "by simp"], ["proof (state)\nthis:\n  t + u = s + u\n\ngoal (1 subgoal):\n 1. t \\<preceq> s \\<Longrightarrow> s \\<preceq> t", "hence \"t = s\""], ["proof (prove)\nusing this:\n  t + u = s + u\n\ngoal (1 subgoal):\n 1. t = s", "by simp"], ["proof (state)\nthis:\n  t = s\n\ngoal (1 subgoal):\n 1. t \\<preceq> s \\<Longrightarrow> s \\<preceq> t", "thus \"s \\<preceq> t\""], ["proof (prove)\nusing this:\n  t = s\n\ngoal (1 subgoal):\n 1. s \\<preceq> t", "by simp"], ["proof (state)\nthis:\n  s \\<preceq> t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ord_adds:\n  assumes \"s adds t\"\n  shows \"s \\<preceq> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<preceq> t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<preceq> t", "from assms"], ["proof (chain)\npicking this:\n  s adds t", "have \"\\<exists>u. t = s + u\""], ["proof (prove)\nusing this:\n  s adds t\n\ngoal (1 subgoal):\n 1. \\<exists>u. t = s + u", "unfolding adds_def"], ["proof (prove)\nusing this:\n  \\<exists>k. t = s + k\n\ngoal (1 subgoal):\n 1. \\<exists>u. t = s + u", "by simp"], ["proof (state)\nthis:\n  \\<exists>u. t = s + u\n\ngoal (1 subgoal):\n 1. s \\<preceq> t", "then"], ["proof (chain)\npicking this:\n  \\<exists>u. t = s + u", "obtain k where \"t = s + k\""], ["proof (prove)\nusing this:\n  \\<exists>u. t = s + u\n\ngoal (1 subgoal):\n 1. (\\<And>k. t = s + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  t = s + k\n\ngoal (1 subgoal):\n 1. s \\<preceq> t", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = s + k\n\ngoal (1 subgoal):\n 1. s \\<preceq> t", "using plus_monotone[OF zero_min[of k], of s]"], ["proof (prove)\nusing this:\n  t = s + k\n  (0::'a) + s \\<preceq> k + s\n\ngoal (1 subgoal):\n 1. s \\<preceq> t", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  s \\<preceq> t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ord_canc_left:\n  assumes \"u + s \\<preceq> u + t\"\n  shows \"s \\<preceq> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<preceq> t", "using assms"], ["proof (prove)\nusing this:\n  u + s \\<preceq> u + t\n\ngoal (1 subgoal):\n 1. s \\<preceq> t", "unfolding add.commute[of u]"], ["proof (prove)\nusing this:\n  s + u \\<preceq> t + u\n\ngoal (1 subgoal):\n 1. s \\<preceq> t", "by (rule ord_canc)"], ["", "lemma ord_strict_canc:\n  assumes \"s + u \\<prec> t + u\"\n  shows \"s \\<prec> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<prec> t", "using assms ord_canc[of s u t] add_right_cancel[of s u t]\n    ordered_powerprod_lin.le_imp_less_or_eq ordered_powerprod_lin.order.strict_implies_order"], ["proof (prove)\nusing this:\n  s + u \\<prec> t + u\n  s + u \\<preceq> t + u \\<Longrightarrow> s \\<preceq> t\n  (s + u = t + u) = (s = t)\n  ?x \\<preceq> ?y \\<Longrightarrow> ?x \\<prec> ?y \\<or> ?x = ?y\n  ?a \\<prec> ?b \\<Longrightarrow> ?a \\<preceq> ?b\n\ngoal (1 subgoal):\n 1. s \\<prec> t", "by blast"], ["", "lemma ord_strict_canc_left:\n  assumes \"u + s \\<prec> u + t\"\n  shows \"s \\<prec> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<prec> t", "using assms"], ["proof (prove)\nusing this:\n  u + s \\<prec> u + t\n\ngoal (1 subgoal):\n 1. s \\<prec> t", "unfolding add.commute[of u]"], ["proof (prove)\nusing this:\n  s + u \\<prec> t + u\n\ngoal (1 subgoal):\n 1. s \\<prec> t", "by (rule ord_strict_canc)"], ["", "lemma plus_monotone_left:\n  assumes \"s \\<preceq> t\"\n  shows \"u + s \\<preceq> u + t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u + s \\<preceq> u + t", "using assms"], ["proof (prove)\nusing this:\n  s \\<preceq> t\n\ngoal (1 subgoal):\n 1. u + s \\<preceq> u + t", "by (simp add: add.commute, rule plus_monotone)"], ["", "lemma plus_monotone_strict:\n  assumes \"s \\<prec> t\"\n  shows \"s + u \\<prec> t + u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + u \\<prec> t + u", "using assms"], ["proof (prove)\nusing this:\n  s \\<prec> t\n\ngoal (1 subgoal):\n 1. s + u \\<prec> t + u", "by (simp add: ordered_powerprod_lin.order.strict_iff_order plus_monotone)"], ["", "lemma plus_monotone_strict_left:\n  assumes \"s \\<prec> t\"\n  shows \"u + s \\<prec> u + t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u + s \\<prec> u + t", "using assms"], ["proof (prove)\nusing this:\n  s \\<prec> t\n\ngoal (1 subgoal):\n 1. u + s \\<prec> u + t", "by (simp add: ordered_powerprod_lin.order.strict_iff_order plus_monotone_left)"], ["", "end"], ["", "locale gd_powerprod =\n  ordered_powerprod ord ord_strict\n  for ord::\"'a \\<Rightarrow> 'a::graded_dickson_powerprod \\<Rightarrow> bool\" (infixl \"\\<preceq>\" 50)\n  and ord_strict (infixl \"\\<prec>\" 50)\nbegin"], ["", "definition dickson_le :: \"('a \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  where \"dickson_le d m s t \\<longleftrightarrow> (d s \\<le> m \\<and> d t \\<le> m \\<and> s \\<preceq> t)\""], ["", "definition dickson_less :: \"('a \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  where \"dickson_less d m s t \\<longleftrightarrow> (d s \\<le> m \\<and> d t \\<le> m \\<and> s \\<prec> t)\""], ["", "lemma dickson_leI:\n  assumes \"d s \\<le> m\" and \"d t \\<le> m\" and \"s \\<preceq> t\"\n  shows \"dickson_le d m s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_le d m s t", "using assms"], ["proof (prove)\nusing this:\n  d s \\<le> m\n  d t \\<le> m\n  s \\<preceq> t\n\ngoal (1 subgoal):\n 1. dickson_le d m s t", "by (simp add: dickson_le_def)"], ["", "lemma dickson_leD1:\n  assumes \"dickson_le d m s t\"\n  shows \"d s \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d s \\<le> m", "using assms"], ["proof (prove)\nusing this:\n  dickson_le d m s t\n\ngoal (1 subgoal):\n 1. d s \\<le> m", "by (simp add: dickson_le_def)"], ["", "lemma dickson_leD2:\n  assumes \"dickson_le d m s t\"\n  shows \"d t \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d t \\<le> m", "using assms"], ["proof (prove)\nusing this:\n  dickson_le d m s t\n\ngoal (1 subgoal):\n 1. d t \\<le> m", "by (simp add: dickson_le_def)"], ["", "lemma dickson_leD3:\n  assumes \"dickson_le d m s t\"\n  shows \"s \\<preceq> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<preceq> t", "using assms"], ["proof (prove)\nusing this:\n  dickson_le d m s t\n\ngoal (1 subgoal):\n 1. s \\<preceq> t", "by (simp add: dickson_le_def)"], ["", "lemma dickson_le_trans:\n  assumes \"dickson_le d m s t\" and \"dickson_le d m t u\"\n  shows \"dickson_le d m s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_le d m s u", "using assms"], ["proof (prove)\nusing this:\n  dickson_le d m s t\n  dickson_le d m t u\n\ngoal (1 subgoal):\n 1. dickson_le d m s u", "by (auto simp add: dickson_le_def)"], ["", "lemma dickson_lessI:\n  assumes \"d s \\<le> m\" and \"d t \\<le> m\" and \"s \\<prec> t\"\n  shows \"dickson_less d m s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_less d m s t", "using assms"], ["proof (prove)\nusing this:\n  d s \\<le> m\n  d t \\<le> m\n  s \\<prec> t\n\ngoal (1 subgoal):\n 1. dickson_less d m s t", "by (simp add: dickson_less_def)"], ["", "lemma dickson_lessD1:\n  assumes \"dickson_less d m s t\"\n  shows \"d s \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d s \\<le> m", "using assms"], ["proof (prove)\nusing this:\n  dickson_less d m s t\n\ngoal (1 subgoal):\n 1. d s \\<le> m", "by (simp add: dickson_less_def)"], ["", "lemma dickson_lessD2:\n  assumes \"dickson_less d m s t\"\n  shows \"d t \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d t \\<le> m", "using assms"], ["proof (prove)\nusing this:\n  dickson_less d m s t\n\ngoal (1 subgoal):\n 1. d t \\<le> m", "by (simp add: dickson_less_def)"], ["", "lemma dickson_lessD3:\n  assumes \"dickson_less d m s t\"\n  shows \"s \\<prec> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<prec> t", "using assms"], ["proof (prove)\nusing this:\n  dickson_less d m s t\n\ngoal (1 subgoal):\n 1. s \\<prec> t", "by (simp add: dickson_less_def)"], ["", "lemma dickson_less_irrefl: \"\\<not> dickson_less d m t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> dickson_less d m t t", "by (simp add: dickson_less_def)"], ["", "lemma dickson_less_trans:\n  assumes \"dickson_less d m s t\" and \"dickson_less d m t u\"\n  shows \"dickson_less d m s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_less d m s u", "using assms"], ["proof (prove)\nusing this:\n  dickson_less d m s t\n  dickson_less d m t u\n\ngoal (1 subgoal):\n 1. dickson_less d m s u", "by (auto simp add: dickson_less_def)"], ["", "lemma transp_dickson_less: \"transp (dickson_less d m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp (dickson_less d m)", "by (rule transpI, fact dickson_less_trans)"], ["", "lemma wfp_on_ord_strict:\n  assumes \"dickson_grading d\"\n  shows \"wfp_on (\\<prec>) {x. d x \\<le> n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n}", "let ?A = \"{x. d x \\<le> n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n}", "have \"strict (\\<preceq>) = (\\<prec>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict (\\<preceq>) = (\\<prec>)", "by (intro ext, simp only: ordered_powerprod_lin.less_le_not_le)"], ["proof (state)\nthis:\n  strict (\\<preceq>) = (\\<prec>)\n\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n}", "have \"qo_on (adds) ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qo_on (adds) {x. d x \\<le> n}", "by (auto simp: qo_on_def reflp_on_def transp_on_def dest: adds_trans)"], ["proof (state)\nthis:\n  qo_on (adds) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n}", "moreover"], ["proof (state)\nthis:\n  qo_on (adds) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n}", "from assms"], ["proof (chain)\npicking this:\n  dickson_grading d", "have \"wqo_on (adds) ?A\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. wqo_on (adds) {x. d x \\<le> n}", "by (rule dickson_gradingD2')"], ["proof (state)\nthis:\n  wqo_on (adds) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n}", "ultimately"], ["proof (chain)\npicking this:\n  qo_on (adds) {x. d x \\<le> n}\n  wqo_on (adds) {x. d x \\<le> n}", "have \"(\\<forall>Q. (\\<forall>x\\<in>?A. \\<forall>y\\<in>?A. x adds y \\<longrightarrow> Q x y) \\<and> qo_on Q ?A \\<longrightarrow> wfp_on (strict Q) ?A)\""], ["proof (prove)\nusing this:\n  qo_on (adds) {x. d x \\<le> n}\n  wqo_on (adds) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. \\<forall>Q.\n       (\\<forall>x\\<in>{x. d x \\<le> n}.\n           \\<forall>y\\<in>{x. d x \\<le> n}.\n              x adds y \\<longrightarrow> Q x y) \\<and>\n       qo_on Q {x. d x \\<le> n} \\<longrightarrow>\n       wfp_on (strict Q) {x. d x \\<le> n}", "by (simp only: wqo_extensions_wf_conv)"], ["proof (state)\nthis:\n  \\<forall>Q.\n     (\\<forall>x\\<in>{x. d x \\<le> n}.\n         \\<forall>y\\<in>{x. d x \\<le> n}.\n            x adds y \\<longrightarrow> Q x y) \\<and>\n     qo_on Q {x. d x \\<le> n} \\<longrightarrow>\n     wfp_on (strict Q) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n}", "hence \"(\\<forall>x\\<in>?A. \\<forall>y\\<in>?A. x adds y \\<longrightarrow> x \\<preceq> y) \\<and> qo_on (\\<preceq>) ?A \\<longrightarrow> wfp_on (strict (\\<preceq>)) ?A\""], ["proof (prove)\nusing this:\n  \\<forall>Q.\n     (\\<forall>x\\<in>{x. d x \\<le> n}.\n         \\<forall>y\\<in>{x. d x \\<le> n}.\n            x adds y \\<longrightarrow> Q x y) \\<and>\n     qo_on Q {x. d x \\<le> n} \\<longrightarrow>\n     wfp_on (strict Q) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{x. d x \\<le> n}.\n        \\<forall>y\\<in>{x. d x \\<le> n}.\n           x adds y \\<longrightarrow> x \\<preceq> y) \\<and>\n    qo_on (\\<preceq>) {x. d x \\<le> n} \\<longrightarrow>\n    wfp_on (strict (\\<preceq>)) {x. d x \\<le> n}", ".."], ["proof (state)\nthis:\n  (\\<forall>x\\<in>{x. d x \\<le> n}.\n      \\<forall>y\\<in>{x. d x \\<le> n}.\n         x adds y \\<longrightarrow> x \\<preceq> y) \\<and>\n  qo_on (\\<preceq>) {x. d x \\<le> n} \\<longrightarrow>\n  wfp_on (strict (\\<preceq>)) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>{x. d x \\<le> n}.\n      \\<forall>y\\<in>{x. d x \\<le> n}.\n         x adds y \\<longrightarrow> x \\<preceq> y) \\<and>\n  qo_on (\\<preceq>) {x. d x \\<le> n} \\<longrightarrow>\n  wfp_on (strict (\\<preceq>)) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n}", "unfolding \\<open>strict (\\<preceq>) = (\\<prec>)\\<close>"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>{x. d x \\<le> n}.\n      \\<forall>y\\<in>{x. d x \\<le> n}.\n         x adds y \\<longrightarrow> x \\<preceq> y) \\<and>\n  qo_on (\\<preceq>) {x. d x \\<le> n} \\<longrightarrow>\n  wfp_on (\\<prec>) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n} \\<Longrightarrow>\n    wfp_on (\\<prec>) {x. d x \\<le> n}\n 2. (\\<forall>x\\<in>{x. d x \\<le> n}.\n        \\<forall>y\\<in>{x. d x \\<le> n}.\n           x adds y \\<longrightarrow> x \\<preceq> y) \\<and>\n    qo_on (\\<preceq>) {x. d x \\<le> n} \\<longrightarrow>\n    wfp_on (\\<prec>) {x. d x \\<le> n} \\<Longrightarrow>\n    (\\<forall>x\\<in>{x. d x \\<le> n}.\n        \\<forall>y\\<in>{x. d x \\<le> n}.\n           x adds y \\<longrightarrow> x \\<preceq> y) \\<and>\n    qo_on (\\<preceq>) {x. d x \\<le> n}", "show \"(\\<forall>x\\<in>?A. \\<forall>y\\<in>?A. x adds y \\<longrightarrow> x \\<preceq> y) \\<and> qo_on (\\<preceq>) ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{x. d x \\<le> n}.\n        \\<forall>y\\<in>{x. d x \\<le> n}.\n           x adds y \\<longrightarrow> x \\<preceq> y) \\<and>\n    qo_on (\\<preceq>) {x. d x \\<le> n}", "proof (intro conjI ballI impI ord_adds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x. d x \\<le> n}; y \\<in> {x. d x \\<le> n};\n        x adds y\\<rbrakk>\n       \\<Longrightarrow> x adds y\n 2. qo_on (\\<preceq>) {x. d x \\<le> n}", "show \"qo_on (\\<preceq>) ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qo_on (\\<preceq>) {x. d x \\<le> n}", "by (auto simp: qo_on_def reflp_on_def transp_on_def)"], ["proof (state)\nthis:\n  qo_on (\\<preceq>) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x. d x \\<le> n}; y \\<in> {x. d x \\<le> n};\n        x adds y\\<rbrakk>\n       \\<Longrightarrow> x adds y", "qed"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>{x. d x \\<le> n}.\n      \\<forall>y\\<in>{x. d x \\<le> n}.\n         x adds y \\<longrightarrow> x \\<preceq> y) \\<and>\n  qo_on (\\<preceq>) {x. d x \\<le> n}\n\ngoal (1 subgoal):\n 1. wfp_on (\\<prec>) {x. d x \\<le> n} \\<Longrightarrow>\n    wfp_on (\\<prec>) {x. d x \\<le> n}", "qed"], ["proof (state)\nthis:\n  wfp_on (\\<prec>) {x. d x \\<le> n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_dickson_less:\n  assumes \"dickson_grading d\"\n  shows \"wfP (dickson_less d m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (dickson_less d m)", "proof (rule wfP_chain)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>f. \\<forall>i. dickson_less d m (f (Suc i)) (f i)", "show \"\\<not> (\\<exists>seq. \\<forall>i. dickson_less d m (seq (Suc i)) (seq i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>seq. \\<forall>i. dickson_less d m (seq (Suc i)) (seq i)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>seq.\n       \\<forall>i. dickson_less d m (seq (Suc i)) (seq i) \\<Longrightarrow>\n    False", "assume \"\\<exists>seq. \\<forall>i. dickson_less d m (seq (Suc i)) (seq i)\""], ["proof (state)\nthis:\n  \\<exists>seq. \\<forall>i. dickson_less d m (seq (Suc i)) (seq i)\n\ngoal (1 subgoal):\n 1. \\<exists>seq.\n       \\<forall>i. dickson_less d m (seq (Suc i)) (seq i) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>seq. \\<forall>i. dickson_less d m (seq (Suc i)) (seq i)", "obtain seq::\"nat \\<Rightarrow> 'a\" where \"\\<forall>i. dickson_less d m (seq (Suc i)) (seq i)\""], ["proof (prove)\nusing this:\n  \\<exists>seq. \\<forall>i. dickson_less d m (seq (Suc i)) (seq i)\n\ngoal (1 subgoal):\n 1. (\\<And>seq.\n        \\<forall>i. dickson_less d m (seq (Suc i)) (seq i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>i. dickson_less d m (seq (Suc i)) (seq i)\n\ngoal (1 subgoal):\n 1. \\<exists>seq.\n       \\<forall>i. dickson_less d m (seq (Suc i)) (seq i) \\<Longrightarrow>\n    False", "hence *: \"\\<And>i. dickson_less d m (seq (Suc i)) (seq i)\""], ["proof (prove)\nusing this:\n  \\<forall>i. dickson_less d m (seq (Suc i)) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>i. dickson_less d m (seq (Suc i)) (seq i)", ".."], ["proof (state)\nthis:\n  dickson_less d m (seq (Suc ?i1)) (seq ?i1)\n\ngoal (1 subgoal):\n 1. \\<exists>seq.\n       \\<forall>i. dickson_less d m (seq (Suc i)) (seq i) \\<Longrightarrow>\n    False", "with transp_dickson_less"], ["proof (chain)\npicking this:\n  transp (dickson_less ?d ?m)\n  dickson_less d m (seq (Suc ?i1)) (seq ?i1)", "have seq_decr: \"\\<And>i j. i < j \\<Longrightarrow> dickson_less d m (seq j) (seq i)\""], ["proof (prove)\nusing this:\n  transp (dickson_less ?d ?m)\n  dickson_less d m (seq (Suc ?i1)) (seq ?i1)\n\ngoal (1 subgoal):\n 1. \\<And>i j. i < j \\<Longrightarrow> dickson_less d m (seq j) (seq i)", "by (rule transp_sequence)"], ["proof (state)\nthis:\n  ?i1 < ?j1 \\<Longrightarrow> dickson_less d m (seq ?j1) (seq ?i1)\n\ngoal (1 subgoal):\n 1. \\<exists>seq.\n       \\<forall>i. dickson_less d m (seq (Suc i)) (seq i) \\<Longrightarrow>\n    False", "from assms"], ["proof (chain)\npicking this:\n  dickson_grading d", "obtain i j where \"i < j\" and i_adds_j: \"seq i adds seq j\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule dickson_gradingE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       (\\<And>i j.\n           \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n           \\<Longrightarrow> thesis) \\<Longrightarrow>\n       d (?seq3 i) \\<le> ?n3\n 2. \\<And>i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        i < j; ?seq3 i adds ?seq3 j\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       (\\<And>i j.\n           \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n           \\<Longrightarrow> thesis) \\<Longrightarrow>\n       d (?seq3 i) \\<le> ?n3\n 2. \\<And>i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        i < j; ?seq3 i adds ?seq3 j\\<rbrakk>\n       \\<Longrightarrow> thesis", "from *"], ["proof (chain)\npicking this:\n  dickson_less d m (seq (Suc ?i1)) (seq ?i1)", "show \"d (seq i) \\<le> m\""], ["proof (prove)\nusing this:\n  dickson_less d m (seq (Suc ?i1)) (seq ?i1)\n\ngoal (1 subgoal):\n 1. d (seq i) \\<le> m", "by (rule dickson_lessD2)"], ["proof (state)\nthis:\n  d (seq i) \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        i < j; seq (?i10 i) adds seq (?i10 j)\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed"], ["proof (state)\nthis:\n  i < j\n  seq i adds seq j\n\ngoal (1 subgoal):\n 1. \\<exists>seq.\n       \\<forall>i. dickson_less d m (seq (Suc i)) (seq i) \\<Longrightarrow>\n    False", "from \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  i < j", "have \"dickson_less d m (seq j) (seq i)\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. dickson_less d m (seq j) (seq i)", "by (rule seq_decr)"], ["proof (state)\nthis:\n  dickson_less d m (seq j) (seq i)\n\ngoal (1 subgoal):\n 1. \\<exists>seq.\n       \\<forall>i. dickson_less d m (seq (Suc i)) (seq i) \\<Longrightarrow>\n    False", "hence \"seq j \\<prec> seq i\""], ["proof (prove)\nusing this:\n  dickson_less d m (seq j) (seq i)\n\ngoal (1 subgoal):\n 1. seq j \\<prec> seq i", "by (rule dickson_lessD3)"], ["proof (state)\nthis:\n  seq j \\<prec> seq i\n\ngoal (1 subgoal):\n 1. \\<exists>seq.\n       \\<forall>i. dickson_less d m (seq (Suc i)) (seq i) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  seq j \\<prec> seq i\n\ngoal (1 subgoal):\n 1. \\<exists>seq.\n       \\<forall>i. dickson_less d m (seq (Suc i)) (seq i) \\<Longrightarrow>\n    False", "from i_adds_j"], ["proof (chain)\npicking this:\n  seq i adds seq j", "have \"seq i \\<preceq> seq j\""], ["proof (prove)\nusing this:\n  seq i adds seq j\n\ngoal (1 subgoal):\n 1. seq i \\<preceq> seq j", "by (rule ord_adds)"], ["proof (state)\nthis:\n  seq i \\<preceq> seq j\n\ngoal (1 subgoal):\n 1. \\<exists>seq.\n       \\<forall>i. dickson_less d m (seq (Suc i)) (seq i) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  seq j \\<prec> seq i\n  seq i \\<preceq> seq j", "show False"], ["proof (prove)\nusing this:\n  seq j \\<prec> seq i\n  seq i \\<preceq> seq j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>seq. \\<forall>i. dickson_less d m (seq (Suc i)) (seq i)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\\<open>gd_powerprod\\<close> stands for @{emph \\<open>graded ordered Dickson power-products\\<close>}.\\<close>"], ["", "locale od_powerprod =\n  ordered_powerprod ord ord_strict\n  for ord::\"'a \\<Rightarrow> 'a::dickson_powerprod \\<Rightarrow> bool\" (infixl \"\\<preceq>\" 50)\n  and ord_strict (infixl \"\\<prec>\" 50)\nbegin"], ["", "sublocale gd_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. gd_powerprod (\\<preceq>) (\\<prec>)", "by standard"], ["", "lemma wf_ord_strict: \"wfP (\\<prec>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<prec>)", "proof (rule wfP_chain)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>f. \\<forall>i. f (Suc i) \\<prec> f i", "show \"\\<not> (\\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i \\<Longrightarrow>\n    False", "assume \"\\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i\""], ["proof (state)\nthis:\n  \\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i\n\ngoal (1 subgoal):\n 1. \\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i", "obtain seq::\"nat \\<Rightarrow> 'a\" where \"\\<forall>i. seq (Suc i) \\<prec> seq i\""], ["proof (prove)\nusing this:\n  \\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i\n\ngoal (1 subgoal):\n 1. (\\<And>seq.\n        \\<forall>i. seq (Suc i) \\<prec> seq i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>i. seq (Suc i) \\<prec> seq i\n\ngoal (1 subgoal):\n 1. \\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i \\<Longrightarrow>\n    False", "hence \"\\<And>i. seq (Suc i) \\<prec> seq i\""], ["proof (prove)\nusing this:\n  \\<forall>i. seq (Suc i) \\<prec> seq i\n\ngoal (1 subgoal):\n 1. \\<And>i. seq (Suc i) \\<prec> seq i", ".."], ["proof (state)\nthis:\n  seq (Suc ?i1) \\<prec> seq ?i1\n\ngoal (1 subgoal):\n 1. \\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i \\<Longrightarrow>\n    False", "with ordered_powerprod_lin.transp_less"], ["proof (chain)\npicking this:\n  transp (\\<prec>)\n  seq (Suc ?i1) \\<prec> seq ?i1", "have seq_decr: \"\\<And>i j. i < j \\<Longrightarrow> (seq j) \\<prec> (seq i)\""], ["proof (prove)\nusing this:\n  transp (\\<prec>)\n  seq (Suc ?i1) \\<prec> seq ?i1\n\ngoal (1 subgoal):\n 1. \\<And>i j. i < j \\<Longrightarrow> seq j \\<prec> seq i", "by (rule transp_sequence)"], ["proof (state)\nthis:\n  ?i1 < ?j1 \\<Longrightarrow> seq ?j1 \\<prec> seq ?i1\n\ngoal (1 subgoal):\n 1. \\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i \\<Longrightarrow>\n    False", "from dickson"], ["proof (chain)\npicking this:\n  almost_full_on (adds) UNIV", "obtain i j::nat where \"i < j\" and i_adds_j: \"seq i adds seq j\""], ["proof (prove)\nusing this:\n  almost_full_on (adds) UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; seq i adds seq j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: almost_full_onD)"], ["proof (state)\nthis:\n  i < j\n  seq i adds seq j\n\ngoal (1 subgoal):\n 1. \\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i \\<Longrightarrow>\n    False", "from seq_decr[OF \\<open>i < j\\<close>]"], ["proof (chain)\npicking this:\n  seq j \\<prec> seq i", "have \"seq j \\<preceq> seq i \\<and> seq j \\<noteq> seq i\""], ["proof (prove)\nusing this:\n  seq j \\<prec> seq i\n\ngoal (1 subgoal):\n 1. seq j \\<preceq> seq i \\<and> seq j \\<noteq> seq i", "by auto"], ["proof (state)\nthis:\n  seq j \\<preceq> seq i \\<and> seq j \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. \\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i \\<Longrightarrow>\n    False", "hence \"seq j \\<preceq> seq i\" and \"seq j \\<noteq> seq i\""], ["proof (prove)\nusing this:\n  seq j \\<preceq> seq i \\<and> seq j \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. seq j \\<preceq> seq i &&& seq j \\<noteq> seq i", "by simp_all"], ["proof (state)\nthis:\n  seq j \\<preceq> seq i\n  seq j \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. \\<exists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i \\<Longrightarrow>\n    False", "from \\<open>seq j \\<noteq> seq i\\<close> \\<open>seq j \\<preceq> seq i\\<close> ord_adds[OF i_adds_j]\n         ordered_powerprod_lin.eq_iff[of \"seq j\" \"seq i\"]"], ["proof (chain)\npicking this:\n  seq j \\<noteq> seq i\n  seq j \\<preceq> seq i\n  seq i \\<preceq> seq j\n  (seq j = seq i) = (seq j \\<preceq> seq i \\<and> seq i \\<preceq> seq j)", "show False"], ["proof (prove)\nusing this:\n  seq j \\<noteq> seq i\n  seq j \\<preceq> seq i\n  seq i \\<preceq> seq j\n  (seq j = seq i) = (seq j \\<preceq> seq i \\<and> seq i \\<preceq> seq j)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>seq. \\<forall>i. seq (Suc i) \\<prec> seq i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\\<open>od_powerprod\\<close> stands for @{emph \\<open>ordered Dickson power-products\\<close>}.\\<close>"], ["", "subsection \\<open>Functions as Power-Products\\<close>"], ["", "lemma finite_neq_0:\n  assumes fin_A: \"finite {x. f x \\<noteq> 0}\" and fin_B: \"finite {x. g x \\<noteq> 0}\" and \"\\<And>x. h x 0 0 = 0\"\n  shows \"finite {x. h x (f x) (g x) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. h x (f x) (g x) \\<noteq> (0::'d)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. h x (f x) (g x) \\<noteq> (0::'d)}", "from fin_A fin_B"], ["proof (chain)\npicking this:\n  finite {x. f x \\<noteq> (0::'b)}\n  finite {x. g x \\<noteq> (0::'c)}", "have  \"finite ({x. f x \\<noteq> 0} \\<union> {x. g x \\<noteq> 0})\""], ["proof (prove)\nusing this:\n  finite {x. f x \\<noteq> (0::'b)}\n  finite {x. g x \\<noteq> (0::'c)}\n\ngoal (1 subgoal):\n 1. finite ({x. f x \\<noteq> (0::'b)} \\<union> {x. g x \\<noteq> (0::'c)})", "by (intro finite_UnI)"], ["proof (state)\nthis:\n  finite ({x. f x \\<noteq> (0::'b)} \\<union> {x. g x \\<noteq> (0::'c)})\n\ngoal (1 subgoal):\n 1. finite {x. h x (f x) (g x) \\<noteq> (0::'d)}", "hence finite_union: \"finite {x. (f x \\<noteq> 0) \\<or> (g x \\<noteq> 0)}\""], ["proof (prove)\nusing this:\n  finite ({x. f x \\<noteq> (0::'b)} \\<union> {x. g x \\<noteq> (0::'c)})\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)}", "by (simp only: Collect_disj_eq)"], ["proof (state)\nthis:\n  finite {x. f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)}\n\ngoal (1 subgoal):\n 1. finite {x. h x (f x) (g x) \\<noteq> (0::'d)}", "have \"{x. h x (f x) (g x) \\<noteq> 0} \\<subseteq> {x. (f x \\<noteq> 0) \\<or> (g x \\<noteq> 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. h x (f x) (g x) \\<noteq> (0::'d)}\n    \\<subseteq> {x. f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)}", "proof (intro Collect_mono, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       h x (f x) (g x) \\<noteq> (0::'d) \\<Longrightarrow>\n       f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)", "fix x::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       h x (f x) (g x) \\<noteq> (0::'d) \\<Longrightarrow>\n       f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)", "assume h_not_zero: \"h x (f x) (g x) \\<noteq> 0\""], ["proof (state)\nthis:\n  h x (f x) (g x) \\<noteq> (0::'d)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       h x (f x) (g x) \\<noteq> (0::'d) \\<Longrightarrow>\n       f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)", "have \"f x = 0 \\<Longrightarrow> g x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = (0::'b) \\<Longrightarrow> g x \\<noteq> (0::'c)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f x = (0::'b); g x = (0::'c)\\<rbrakk> \\<Longrightarrow> False", "assume \"f x = 0\" \"g x = 0\""], ["proof (state)\nthis:\n  f x = (0::'b)\n  g x = (0::'c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f x = (0::'b); g x = (0::'c)\\<rbrakk> \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  f x = (0::'b)\n  g x = (0::'c)\n\ngoal (1 subgoal):\n 1. False", "using h_not_zero \\<open>h x 0 0 = 0\\<close>"], ["proof (prove)\nusing this:\n  f x = (0::'b)\n  g x = (0::'c)\n  h x (f x) (g x) \\<noteq> (0::'d)\n  h x (0::'b) (0::'c) = (0::'d)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f x = (0::'b) \\<Longrightarrow> g x \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       h x (f x) (g x) \\<noteq> (0::'d) \\<Longrightarrow>\n       f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)", "thus \"f x \\<noteq> 0 \\<or> g x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f x = (0::'b) \\<Longrightarrow> g x \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)", "by auto"], ["proof (state)\nthis:\n  f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {x. h x (f x) (g x) \\<noteq> (0::'d)}\n  \\<subseteq> {x. f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)}\n\ngoal (1 subgoal):\n 1. finite {x. h x (f x) (g x) \\<noteq> (0::'d)}", "from finite_subset[OF this] finite_union"], ["proof (chain)\npicking this:\n  finite\n   {x. f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)} \\<Longrightarrow>\n  finite {x. h x (f x) (g x) \\<noteq> (0::'d)}\n  finite {x. f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)}", "show \"finite {x. h x (f x) (g x) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  finite\n   {x. f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)} \\<Longrightarrow>\n  finite {x. h x (f x) (g x) \\<noteq> (0::'d)}\n  finite {x. f x \\<noteq> (0::'b) \\<or> g x \\<noteq> (0::'c)}\n\ngoal (1 subgoal):\n 1. finite {x. h x (f x) (g x) \\<noteq> (0::'d)}", "."], ["proof (state)\nthis:\n  finite {x. h x (f x) (g x) \\<noteq> (0::'d)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_neq_0':\n  assumes \"finite {x. f x \\<noteq> 0}\" and \"finite {x. g x \\<noteq> 0}\" and \"h 0 0 = 0\"\n  shows \"finite {x. h (f x) (g x) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. h (f x) (g x) \\<noteq> (0::'d)}", "using assms"], ["proof (prove)\nusing this:\n  finite {x. f x \\<noteq> (0::'b)}\n  finite {x. g x \\<noteq> (0::'c)}\n  h (0::'b) (0::'c) = (0::'d)\n\ngoal (1 subgoal):\n 1. finite {x. h (f x) (g x) \\<noteq> (0::'d)}", "by (rule finite_neq_0)"], ["", "lemma finite_neq_0_inv:\n  assumes fin_A: \"finite {x. h x (f x) (g x) \\<noteq> 0}\" and fin_B: \"finite {x. f x \\<noteq> 0}\" and \"\\<And>x y. h x 0 y = y\"\n  shows \"finite {x. g x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. g x \\<noteq> (0::'b)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. g x \\<noteq> (0::'b)}", "from fin_A and fin_B"], ["proof (chain)\npicking this:\n  finite {x. h x (f x) (g x) \\<noteq> (0::'b)}\n  finite {x. f x \\<noteq> (0::'c)}", "have \"finite ({x. h x (f x) (g x) \\<noteq> 0} \\<union> {x. f x \\<noteq> 0})\""], ["proof (prove)\nusing this:\n  finite {x. h x (f x) (g x) \\<noteq> (0::'b)}\n  finite {x. f x \\<noteq> (0::'c)}\n\ngoal (1 subgoal):\n 1. finite\n     ({x. h x (f x) (g x) \\<noteq> (0::'b)} \\<union>\n      {x. f x \\<noteq> (0::'c)})", "by (intro finite_UnI)"], ["proof (state)\nthis:\n  finite\n   ({x. h x (f x) (g x) \\<noteq> (0::'b)} \\<union>\n    {x. f x \\<noteq> (0::'c)})\n\ngoal (1 subgoal):\n 1. finite {x. g x \\<noteq> (0::'b)}", "hence finite_union: \"finite {x. (h x (f x) (g x) \\<noteq> 0) \\<or> f x \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  finite\n   ({x. h x (f x) (g x) \\<noteq> (0::'b)} \\<union>\n    {x. f x \\<noteq> (0::'c)})\n\ngoal (1 subgoal):\n 1. finite {x. h x (f x) (g x) \\<noteq> (0::'b) \\<or> f x \\<noteq> (0::'c)}", "by (simp only: Collect_disj_eq)"], ["proof (state)\nthis:\n  finite {x. h x (f x) (g x) \\<noteq> (0::'b) \\<or> f x \\<noteq> (0::'c)}\n\ngoal (1 subgoal):\n 1. finite {x. g x \\<noteq> (0::'b)}", "have \"{x. g x \\<noteq> 0} \\<subseteq> {x. (h x (f x) (g x) \\<noteq> 0) \\<or> f x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. g x \\<noteq> (0::'b)}\n    \\<subseteq> {x. h x (f x) (g x) \\<noteq> (0::'b) \\<or>\n                    f x \\<noteq> (0::'c)}", "by (intro Collect_mono, rule, rule disjCI, simp add: assms(3))"], ["proof (state)\nthis:\n  {x. g x \\<noteq> (0::'b)}\n  \\<subseteq> {x. h x (f x) (g x) \\<noteq> (0::'b) \\<or>\n                  f x \\<noteq> (0::'c)}\n\ngoal (1 subgoal):\n 1. finite {x. g x \\<noteq> (0::'b)}", "from this finite_union"], ["proof (chain)\npicking this:\n  {x. g x \\<noteq> (0::'b)}\n  \\<subseteq> {x. h x (f x) (g x) \\<noteq> (0::'b) \\<or>\n                  f x \\<noteq> (0::'c)}\n  finite {x. h x (f x) (g x) \\<noteq> (0::'b) \\<or> f x \\<noteq> (0::'c)}", "show \"finite {x. g x \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  {x. g x \\<noteq> (0::'b)}\n  \\<subseteq> {x. h x (f x) (g x) \\<noteq> (0::'b) \\<or>\n                  f x \\<noteq> (0::'c)}\n  finite {x. h x (f x) (g x) \\<noteq> (0::'b) \\<or> f x \\<noteq> (0::'c)}\n\ngoal (1 subgoal):\n 1. finite {x. g x \\<noteq> (0::'b)}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {x. g x \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_neq_0_inv':\n  assumes inf_A: \"finite {x. h (f x) (g x) \\<noteq> 0}\" and fin_B: \"finite {x. f x \\<noteq> 0}\" and \"\\<And>x. h 0 x = x\"\n  shows \"finite {x. g x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. g x \\<noteq> (0::'b)}", "using assms"], ["proof (prove)\nusing this:\n  finite {x. h (f x) (g x) \\<noteq> (0::'b)}\n  finite {x. f x \\<noteq> (0::'c)}\n  h (0::'c) ?x = ?x\n\ngoal (1 subgoal):\n 1. finite {x. g x \\<noteq> (0::'b)}", "by (rule finite_neq_0_inv)"], ["", "subsubsection \\<open>@{typ \"'a \\<Rightarrow> 'b\"} belongs to class @{class comm_powerprod}\\<close>"], ["", "instance \"fun\" :: (type, cancel_comm_monoid_add) comm_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, comm_powerprod_class)", "by standard"], ["", "subsubsection \\<open>@{typ \"'a \\<Rightarrow> 'b\"} belongs to class @{class ninv_comm_monoid_add}\\<close>"], ["", "instance \"fun\" :: (type, ninv_comm_monoid_add) ninv_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, ninv_comm_monoid_add_class)", "by (standard, simp only: plus_fun_def zero_fun_def fun_eq_iff, intro allI, rule plus_eq_zero, auto)"], ["", "subsubsection \\<open>@{typ \"'a \\<Rightarrow> 'b\"} belongs to class @{class lcs_powerprod}\\<close>"], ["", "instantiation \"fun\" :: (type, add_linorder) lcs_powerprod\nbegin"], ["", "definition lcs_fun::\"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b)\" where \"lcs f g = (\\<lambda>x. max (f x) (g x))\""], ["", "lemma adds_funI:\n  assumes \"s \\<le> t\"\n  shows \"s adds (t::'a \\<Rightarrow> 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds t", "proof (rule addsI, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. t x = (s + ?k) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. t x = (s + ?k) x", "from assms"], ["proof (chain)\npicking this:\n  s \\<le> t", "have \"s x \\<le> t x\""], ["proof (prove)\nusing this:\n  s \\<le> t\n\ngoal (1 subgoal):\n 1. s x \\<le> t x", "unfolding le_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x. s x \\<le> t x\n\ngoal (1 subgoal):\n 1. s x \\<le> t x", ".."], ["proof (state)\nthis:\n  s x \\<le> t x\n\ngoal (1 subgoal):\n 1. \\<And>x. t x = (s + ?k) x", "hence \"t x = s x + (t x - s x)\""], ["proof (prove)\nusing this:\n  s x \\<le> t x\n\ngoal (1 subgoal):\n 1. t x = s x + (t x - s x)", "by (rule le_imp_inv)"], ["proof (state)\nthis:\n  t x = s x + (t x - s x)\n\ngoal (1 subgoal):\n 1. \\<And>x. t x = (s + ?k) x", "thus \"t x = (s + (t - s)) x\""], ["proof (prove)\nusing this:\n  t x = s x + (t x - s x)\n\ngoal (1 subgoal):\n 1. t x = (s + (t - s)) x", "by simp"], ["proof (state)\nthis:\n  t x = (s + (t - s)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adds_fun_iff: \"f adds (g::'a \\<Rightarrow> 'b) \\<longleftrightarrow> (\\<forall>x. f x adds g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f adds g) = (\\<forall>x. f x adds g x)", "unfolding adds_def plus_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>k. g = (\\<lambda>x. f x + k x)) =\n    (\\<forall>x. \\<exists>k. g x = f x + k)", "by metis"], ["", "lemma adds_fun_iff': \"f adds (g::'a \\<Rightarrow> 'b) \\<longleftrightarrow> (\\<forall>x. \\<exists>y. g x = f x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f adds g) = (\\<forall>x. \\<exists>y. g x = f x + y)", "unfolding adds_fun_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. f x adds g x) = (\\<forall>x. \\<exists>y. g x = f x + y)", "unfolding adds_def plus_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. \\<exists>k. g x = f x + k) =\n    (\\<forall>x. \\<exists>y. g x = f x + y)", ".."], ["", "lemma adds_lcs_fun:\n  shows \"s adds (lcs s (t::'a \\<Rightarrow> 'b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds lcs s t", "by (rule adds_funI, simp only: le_fun_def lcs_fun_def, auto simp: max_def)"], ["", "lemma lcs_comm_fun:  \"lcs s t = lcs t (s::'a \\<Rightarrow> 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs s t = lcs t s", "unfolding lcs_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. max (s x) (t x)) = (\\<lambda>x. max (t x) (s x))", "by (auto simp: max_def intro!: ext)"], ["", "lemma lcs_adds_fun:\n  assumes \"s adds u\" and \"t adds (u::'a \\<Rightarrow> 'b)\"\n  shows \"(lcs s t) adds u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs s t adds u", "using assms"], ["proof (prove)\nusing this:\n  s adds u\n  t adds u\n\ngoal (1 subgoal):\n 1. lcs s t adds u", "unfolding lcs_fun_def adds_fun_iff'"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<exists>y. u x = s x + y\n  \\<forall>x. \\<exists>y. u x = t x + y\n\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>y. u x = max (s x) (t x) + y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. \\<exists>y. u x = s x + y;\n     \\<forall>x. \\<exists>y. u x = t x + y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x. \\<exists>y. u x = max (s x) (t x) + y", "assume a1: \"\\<forall>x. \\<exists>y. u x = s x + y\" and a2: \"\\<forall>x. \\<exists>y. u x = t x + y\""], ["proof (state)\nthis:\n  \\<forall>x. \\<exists>y. u x = s x + y\n  \\<forall>x. \\<exists>y. u x = t x + y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. \\<exists>y. u x = s x + y;\n     \\<forall>x. \\<exists>y. u x = t x + y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x. \\<exists>y. u x = max (s x) (t x) + y", "show \"\\<forall>x. \\<exists>y. u x = max (s x) (t x) + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>y. u x = max (s x) (t x) + y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. u x = max (s x) (t x) + y", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. u x = max (s x) (t x) + y", "from a1"], ["proof (chain)\npicking this:\n  \\<forall>x. \\<exists>y. u x = s x + y", "have b1: \"\\<exists>y. u x = s x + y\""], ["proof (prove)\nusing this:\n  \\<forall>x. \\<exists>y. u x = s x + y\n\ngoal (1 subgoal):\n 1. \\<exists>y. u x = s x + y", ".."], ["proof (state)\nthis:\n  \\<exists>y. u x = s x + y\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. u x = max (s x) (t x) + y", "from a2"], ["proof (chain)\npicking this:\n  \\<forall>x. \\<exists>y. u x = t x + y", "have b2: \"\\<exists>y. u x = t x + y\""], ["proof (prove)\nusing this:\n  \\<forall>x. \\<exists>y. u x = t x + y\n\ngoal (1 subgoal):\n 1. \\<exists>y. u x = t x + y", ".."], ["proof (state)\nthis:\n  \\<exists>y. u x = t x + y\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. u x = max (s x) (t x) + y", "show \"\\<exists>y. u x = max (s x) (t x) + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. u x = max (s x) (t x) + y", "unfolding max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. u x = (if s x \\<le> t x then t x else s x) + y", "by (split if_split, intro conjI impI, rule b2, rule b1)"], ["proof (state)\nthis:\n  \\<exists>y. u x = max (s x) (t x) + y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x. \\<exists>y. u x = max (s x) (t x) + y\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, lcs_powerprod_class)", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t. s adds lcs s t\n 2. \\<And>s u t.\n       \\<lbrakk>s adds u; t adds u\\<rbrakk> \\<Longrightarrow> lcs s t adds u\n 3. \\<And>s t. lcs s t = lcs t s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s_ adds lcs s_ t_", "by (rule adds_lcs_fun)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s u t.\n       \\<lbrakk>s adds u; t adds u\\<rbrakk> \\<Longrightarrow> lcs s t adds u\n 2. \\<And>s t. lcs s t = lcs t s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s_ adds u_; t_ adds u_\\<rbrakk>\n    \\<Longrightarrow> lcs s_ t_ adds u_", "by (rule lcs_adds_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t. lcs s t = lcs t s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs s_ t_ = lcs t_ s_", "by (rule lcs_comm_fun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma leq_lcs_fun_1: \"s \\<le> (lcs s (t::'a \\<Rightarrow> 'b::add_linorder))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<le> lcs s t", "by (simp add: lcs_fun_def le_fun_def)"], ["", "lemma leq_lcs_fun_2: \"t \\<le> (lcs s (t::'a \\<Rightarrow> 'b::add_linorder))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> lcs s t", "by (simp add: lcs_fun_def le_fun_def)"], ["", "lemma lcs_leq_fun:\n  assumes \"s \\<le> u\" and \"t \\<le> (u::'a \\<Rightarrow> 'b::add_linorder)\"\n  shows \"(lcs s t) \\<le> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs s t \\<le> u", "using assms"], ["proof (prove)\nusing this:\n  s \\<le> u\n  t \\<le> u\n\ngoal (1 subgoal):\n 1. lcs s t \\<le> u", "by (simp add: lcs_fun_def le_fun_def)"], ["", "lemma adds_fun: \"s adds t \\<longleftrightarrow> s \\<le> t\"\n  for s t::\"'a \\<Rightarrow> 'b::add_linorder_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s adds t) = (s \\<le> t)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s adds t \\<Longrightarrow> s \\<le> t\n 2. s \\<le> t \\<Longrightarrow> s adds t", "assume \"s adds t\""], ["proof (state)\nthis:\n  s adds t\n\ngoal (2 subgoals):\n 1. s adds t \\<Longrightarrow> s \\<le> t\n 2. s \\<le> t \\<Longrightarrow> s adds t", "from this"], ["proof (chain)\npicking this:\n  s adds t", "obtain k where \"t = s + k\""], ["proof (prove)\nusing this:\n  s adds t\n\ngoal (1 subgoal):\n 1. (\\<And>k. t = s + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  t = s + k\n\ngoal (2 subgoals):\n 1. s adds t \\<Longrightarrow> s \\<le> t\n 2. s \\<le> t \\<Longrightarrow> s adds t", "show \"s \\<le> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<le> t", "unfolding \\<open>t = s + k\\<close> le_fun_def plus_fun_def le_iff_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>c. s x + k x = s x + c", "by (simp add: leq_add_right)"], ["proof (state)\nthis:\n  s \\<le> t\n\ngoal (1 subgoal):\n 1. s \\<le> t \\<Longrightarrow> s adds t", "qed (rule adds_funI)"], ["", "lemma gcs_fun: \"gcs s (t::'a \\<Rightarrow> ('b::add_linorder)) = (\\<lambda>x. min (s x) (t x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s t = (\\<lambda>x. min (s x) (t x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcs s t = (\\<lambda>x. min (s x) (t x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s t = (\\<lambda>x. min (s x) (t x))", "unfolding gcs_def lcs_fun_def fun_diff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (s + t) x - max (s x) (t x)) =\n    (\\<lambda>x. min (s x) (t x))", "proof (simp, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. s x + t x - max (s x) (t x) = min (s x) (t x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. s x + t x - max (s x) (t x) = min (s x) (t x)", "have eq: \"s x + t x = max (s x) (t x) + min (s x) (t x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s x + t x = max (s x) (t x) + min (s x) (t x)", "by (metis add.commute min_def max_def)"], ["proof (state)\nthis:\n  s x + t x = max (s x) (t x) + min (s x) (t x)\n\ngoal (1 subgoal):\n 1. \\<And>x. s x + t x - max (s x) (t x) = min (s x) (t x)", "thus \"s x + t x - max (s x) (t x) = min (s x) (t x)\""], ["proof (prove)\nusing this:\n  s x + t x = max (s x) (t x) + min (s x) (t x)\n\ngoal (1 subgoal):\n 1. s x + t x - max (s x) (t x) = min (s x) (t x)", "by simp"], ["proof (state)\nthis:\n  s x + t x - max (s x) (t x) = min (s x) (t x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcs s t = (\\<lambda>x. min (s x) (t x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcs_leq_fun_1: \"(gcs s (t::'a \\<Rightarrow> 'b::add_linorder)) \\<le> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s t \\<le> s", "by (simp add: gcs_fun le_fun_def)"], ["", "lemma gcs_leq_fun_2: \"(gcs s (t::'a \\<Rightarrow> 'b::add_linorder)) \\<le> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s t \\<le> t", "by (simp add: gcs_fun le_fun_def)"], ["", "lemma leq_gcs_fun:\n  assumes \"u \\<le> s\" and \"u \\<le> (t::'a \\<Rightarrow> 'b::add_linorder)\"\n  shows \"u \\<le> (gcs s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<le> gcs s t", "using assms"], ["proof (prove)\nusing this:\n  u \\<le> s\n  u \\<le> t\n\ngoal (1 subgoal):\n 1. u \\<le> gcs s t", "by (simp add: gcs_fun le_fun_def)"], ["", "subsubsection \\<open>@{typ \"'a \\<Rightarrow> 'b\"} belongs to class @{class ulcs_powerprod}\\<close>"], ["", "instance \"fun\" :: (type, add_linorder_min) ulcs_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, ulcs_powerprod_class)", ".."], ["", "subsubsection \\<open>Power-products in a given set of indeterminates\\<close>"], ["", "definition supp_fun::\"('a \\<Rightarrow> 'b::zero) \\<Rightarrow> 'a set\" where \"supp_fun f = {x. f x \\<noteq> 0}\""], ["", "text \\<open>@{term supp_fun} for general functions is like @{term keys} for @{type poly_mapping},\n  but does not need to be finite.\\<close>"], ["", "lemma keys_eq_supp: \"keys s = supp_fun (lookup s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys s = supp_fun (lookup s)", "unfolding supp_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys s = {x. lookup s x \\<noteq> (0::'b)}", "by (transfer, rule)"], ["", "lemma supp_fun_zero [simp]: \"supp_fun 0 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp_fun 0 = {}", "by (auto simp: supp_fun_def)"], ["", "lemma supp_fun_eq_zero_iff: \"supp_fun f = {} \\<longleftrightarrow> f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (supp_fun f = {}) = (f = 0)", "by (auto simp: supp_fun_def)"], ["", "lemma sub_supp_empty: \"supp_fun s \\<subseteq> {} \\<longleftrightarrow> (s = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (supp_fun s \\<subseteq> {}) = (s = 0)", "by (auto simp: supp_fun_def)"], ["", "lemma except_fun_idI: \"supp_fun f \\<inter> V = {} \\<Longrightarrow> except_fun f V = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp_fun f \\<inter> V = {} \\<Longrightarrow> except_fun f V = f", "by (auto simp: except_fun_def supp_fun_def when_def intro!: ext)"], ["", "lemma supp_except_fun: \"supp_fun (except_fun s V) = supp_fun s - V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp_fun (except_fun s V) = supp_fun s - V", "by (auto simp: except_fun_def supp_fun_def)"], ["", "lemma supp_fun_plus_subset: \"supp_fun (s + t) \\<subseteq> supp_fun s \\<union> supp_fun (t::'a \\<Rightarrow> 'b::monoid_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp_fun (s + t) \\<subseteq> supp_fun s \\<union> supp_fun t", "unfolding supp_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (s + t) x \\<noteq> (0::'b)}\n    \\<subseteq> {x. s x \\<noteq> (0::'b)} \\<union> {x. t x \\<noteq> (0::'b)}", "by force"], ["", "lemma fun_eq_zeroI:\n  assumes \"\\<And>x. x \\<in> supp_fun f \\<Longrightarrow> f x = 0\"\n  shows \"f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = 0", "proof (rule, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = (0::'b)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = (0::'b)", "show \"f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = (0::'b)", "proof (cases \"x \\<in> supp_fun f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> supp_fun f \\<Longrightarrow> f x = (0::'b)\n 2. x \\<notin> supp_fun f \\<Longrightarrow> f x = (0::'b)", "case True"], ["proof (state)\nthis:\n  x \\<in> supp_fun f\n\ngoal (2 subgoals):\n 1. x \\<in> supp_fun f \\<Longrightarrow> f x = (0::'b)\n 2. x \\<notin> supp_fun f \\<Longrightarrow> f x = (0::'b)", "then"], ["proof (chain)\npicking this:\n  x \\<in> supp_fun f", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> supp_fun f\n\ngoal (1 subgoal):\n 1. f x = (0::'b)", "by (rule assms)"], ["proof (state)\nthis:\n  f x = (0::'b)\n\ngoal (1 subgoal):\n 1. x \\<notin> supp_fun f \\<Longrightarrow> f x = (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> supp_fun f \\<Longrightarrow> f x = (0::'b)", "case False"], ["proof (state)\nthis:\n  x \\<notin> supp_fun f\n\ngoal (1 subgoal):\n 1. x \\<notin> supp_fun f \\<Longrightarrow> f x = (0::'b)", "then"], ["proof (chain)\npicking this:\n  x \\<notin> supp_fun f", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> supp_fun f\n\ngoal (1 subgoal):\n 1. f x = (0::'b)", "by (simp add: supp_fun_def)"], ["proof (state)\nthis:\n  f x = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f x = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma except_fun_cong1:\n  \"supp_fun s \\<inter> ((V - U) \\<union> (U - V)) \\<subseteq> {} \\<Longrightarrow> except_fun s V = except_fun s U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp_fun s \\<inter> (V - U \\<union> (U - V))\n    \\<subseteq> {} \\<Longrightarrow>\n    except_fun s V = except_fun s U", "by (auto simp: except_fun_def when_def supp_fun_def intro!: ext)"], ["", "lemma adds_except_fun:\n  \"s adds t = (except_fun s V adds except_fun t V \\<and> except_fun s (- V) adds except_fun t (- V))\"\n  for s t :: \"'a \\<Rightarrow> 'b::add_linorder\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s adds t) =\n    (except_fun s V adds except_fun t V \\<and>\n     except_fun s (- V) adds except_fun t (- V))", "by (auto simp: supp_fun_def except_fun_def adds_fun_iff when_def)"], ["", "lemma adds_except_fun_singleton: \"s adds t = (except_fun s {v} adds except_fun t {v} \\<and> s v adds t v)\"\n  for s t :: \"'a \\<Rightarrow> 'b::add_linorder\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s adds t) =\n    (except_fun s {v} adds except_fun t {v} \\<and> s v adds t v)", "by (auto simp: supp_fun_def except_fun_def adds_fun_iff when_def)"], ["", "subsubsection \\<open>Dickson's lemma for power-products in finitely many indeterminates\\<close>"], ["", "lemma Dickson_fun:\n  assumes \"finite V\"\n  shows \"almost_full_on (adds) {x::'a \\<Rightarrow> 'b::add_wellorder. supp_fun x \\<subseteq> V}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> V}", "using assms"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> V}", "proof (induct V)"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        almost_full_on (adds) {x. supp_fun x \\<subseteq> F}\\<rbrakk>\n       \\<Longrightarrow> almost_full_on (adds)\n                          {xa. supp_fun xa \\<subseteq> insert x F}", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        almost_full_on (adds) {x. supp_fun x \\<subseteq> F}\\<rbrakk>\n       \\<Longrightarrow> almost_full_on (adds)\n                          {xa. supp_fun xa \\<subseteq> insert x F}", "have \"finite {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0::'c}", "by simp"], ["proof (state)\nthis:\n  finite {0::?'c1}\n\ngoal (2 subgoals):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        almost_full_on (adds) {x. supp_fun x \\<subseteq> F}\\<rbrakk>\n       \\<Longrightarrow> almost_full_on (adds)\n                          {xa. supp_fun xa \\<subseteq> insert x F}", "moreover"], ["proof (state)\nthis:\n  finite {0::?'c1}\n\ngoal (2 subgoals):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        almost_full_on (adds) {x. supp_fun x \\<subseteq> F}\\<rbrakk>\n       \\<Longrightarrow> almost_full_on (adds)\n                          {xa. supp_fun xa \\<subseteq> insert x F}", "have \"reflp_on (adds) {0::'a \\<Rightarrow> 'b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp_on (adds) {0}", "by (simp add: reflp_on_def)"], ["proof (state)\nthis:\n  reflp_on (adds) {0}\n\ngoal (2 subgoals):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        almost_full_on (adds) {x. supp_fun x \\<subseteq> F}\\<rbrakk>\n       \\<Longrightarrow> almost_full_on (adds)\n                          {xa. supp_fun xa \\<subseteq> insert x F}", "ultimately"], ["proof (chain)\npicking this:\n  finite {0::?'c1}\n  reflp_on (adds) {0}", "have \"almost_full_on (adds) {0::'a \\<Rightarrow> 'b}\""], ["proof (prove)\nusing this:\n  finite {0::?'c1}\n  reflp_on (adds) {0}\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) {0}", "by (rule finite_almost_full_on)"], ["proof (state)\nthis:\n  almost_full_on (adds) {0}\n\ngoal (2 subgoals):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        almost_full_on (adds) {x. supp_fun x \\<subseteq> F}\\<rbrakk>\n       \\<Longrightarrow> almost_full_on (adds)\n                          {xa. supp_fun xa \\<subseteq> insert x F}", "thus ?case"], ["proof (prove)\nusing this:\n  almost_full_on (adds) {0}\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> {}}", "by (simp add: supp_fun_eq_zero_iff)"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> {}}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        almost_full_on (adds) {x. supp_fun x \\<subseteq> F}\\<rbrakk>\n       \\<Longrightarrow> almost_full_on (adds)\n                          {xa. supp_fun xa \\<subseteq> insert x F}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        almost_full_on (adds) {x. supp_fun x \\<subseteq> F}\\<rbrakk>\n       \\<Longrightarrow> almost_full_on (adds)\n                          {xa. supp_fun xa \\<subseteq> insert x F}", "case (insert v V)"], ["proof (state)\nthis:\n  finite V\n  v \\<notin> V\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> V}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        almost_full_on (adds) {x. supp_fun x \\<subseteq> F}\\<rbrakk>\n       \\<Longrightarrow> almost_full_on (adds)\n                          {xa. supp_fun xa \\<subseteq> insert x F}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> insert v V}", "proof (rule almost_full_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> insert v V} \\<Longrightarrow>\n       good (adds) f", "fix seq::\"nat \\<Rightarrow> 'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> insert v V} \\<Longrightarrow>\n       good (adds) f", "assume \"\\<forall>i. seq i \\<in> {x. supp_fun x \\<subseteq> insert v V}\""], ["proof (state)\nthis:\n  \\<forall>i. seq i \\<in> {x. supp_fun x \\<subseteq> insert v V}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> insert v V} \\<Longrightarrow>\n       good (adds) f", "hence a: \"supp_fun (seq i) \\<subseteq> insert v V\" for i"], ["proof (prove)\nusing this:\n  \\<forall>i. seq i \\<in> {x. supp_fun x \\<subseteq> insert v V}\n\ngoal (1 subgoal):\n 1. supp_fun (seq i) \\<subseteq> insert v V", "by simp"], ["proof (state)\nthis:\n  supp_fun (seq ?i) \\<subseteq> insert v V\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> insert v V} \\<Longrightarrow>\n       good (adds) f", "define seq' where \"seq' = (\\<lambda>i. (except_fun (seq i) {v}, except_fun (seq i) V))\""], ["proof (state)\nthis:\n  seq' = (\\<lambda>i. (except_fun (seq i) {v}, except_fun (seq i) V))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> insert v V} \\<Longrightarrow>\n       good (adds) f", "have \"almost_full_on (adds) {x::'a \\<Rightarrow> 'b. supp_fun x \\<subseteq> {v}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> {v}}", "proof (rule almost_full_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "fix f::\"nat \\<Rightarrow> 'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "assume \"\\<forall>i. f i \\<in> {x. supp_fun x \\<subseteq> {v}}\""], ["proof (state)\nthis:\n  \\<forall>i. f i \\<in> {x. supp_fun x \\<subseteq> {v}}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "hence b: \"supp_fun (f i) \\<subseteq> {v}\" for i"], ["proof (prove)\nusing this:\n  \\<forall>i. f i \\<in> {x. supp_fun x \\<subseteq> {v}}\n\ngoal (1 subgoal):\n 1. supp_fun (f i) \\<subseteq> {v}", "by simp"], ["proof (state)\nthis:\n  supp_fun (f ?i) \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "let ?f = \"\\<lambda>i. f i v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "have \"wfP ((<)::'b \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (<)", "by (simp add: wf wfP_def)"], ["proof (state)\nthis:\n  wfP (<)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "hence \"\\<forall>f::nat \\<Rightarrow> 'b. \\<exists>i. f i \\<le> f (Suc i)\""], ["proof (prove)\nusing this:\n  wfP (<)\n\ngoal (1 subgoal):\n 1. \\<forall>f. \\<exists>i. f i \\<le> f (Suc i)", "by (simp add: wf_iff_no_infinite_down_chain[to_pred] not_less)"], ["proof (state)\nthis:\n  \\<forall>f. \\<exists>i. f i \\<le> f (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "hence \"\\<exists>i. ?f i \\<le> ?f (Suc i)\""], ["proof (prove)\nusing this:\n  \\<forall>f. \\<exists>i. f i \\<le> f (Suc i)\n\ngoal (1 subgoal):\n 1. \\<exists>i. f i v \\<le> f (Suc i) v", ".."], ["proof (state)\nthis:\n  \\<exists>i. f i v \\<le> f (Suc i) v\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. f i v \\<le> f (Suc i) v", "obtain i where \"?f i \\<le> ?f (Suc i)\""], ["proof (prove)\nusing this:\n  \\<exists>i. f i v \\<le> f (Suc i) v\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        f i v \\<le> f (Suc i) v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  f i v \\<le> f (Suc i) v\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "have \"i < Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < Suc i", "by simp"], ["proof (state)\nthis:\n  i < Suc i\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "moreover"], ["proof (state)\nthis:\n  i < Suc i\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "have \"f i adds f (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i adds f (Suc i)", "unfolding adds_fun_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. f i x adds f (Suc i) x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f i x adds f (Suc i) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f i x adds f (Suc i) x", "show \"f i x adds f (Suc i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i x adds f (Suc i) x", "proof (cases \"x = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = v \\<Longrightarrow> f i x adds f (Suc i) x\n 2. x \\<noteq> v \\<Longrightarrow> f i x adds f (Suc i) x", "case True"], ["proof (state)\nthis:\n  x = v\n\ngoal (2 subgoals):\n 1. x = v \\<Longrightarrow> f i x adds f (Suc i) x\n 2. x \\<noteq> v \\<Longrightarrow> f i x adds f (Suc i) x", "with \\<open>?f i \\<le> ?f (Suc i)\\<close>"], ["proof (chain)\npicking this:\n  f i v \\<le> f (Suc i) v\n  x = v", "show ?thesis"], ["proof (prove)\nusing this:\n  f i v \\<le> f (Suc i) v\n  x = v\n\ngoal (1 subgoal):\n 1. f i x adds f (Suc i) x", "by (simp add: adds_def le_iff_add)"], ["proof (state)\nthis:\n  f i x adds f (Suc i) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow> f i x adds f (Suc i) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow> f i x adds f (Suc i) x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow> f i x adds f (Suc i) x", "with b"], ["proof (chain)\npicking this:\n  supp_fun (f ?i) \\<subseteq> {v}\n  x \\<noteq> v", "have \"x \\<notin> supp_fun (f i)\" and \"x \\<notin> supp_fun (f (Suc i))\""], ["proof (prove)\nusing this:\n  supp_fun (f ?i) \\<subseteq> {v}\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. x \\<notin> supp_fun (f i) &&& x \\<notin> supp_fun (f (Suc i))", "by blast+"], ["proof (state)\nthis:\n  x \\<notin> supp_fun (f i)\n  x \\<notin> supp_fun (f (Suc i))\n\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow> f i x adds f (Suc i) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> supp_fun (f i)\n  x \\<notin> supp_fun (f (Suc i))\n\ngoal (1 subgoal):\n 1. f i x adds f (Suc i) x", "by (simp add: supp_fun_def)"], ["proof (state)\nthis:\n  f i x adds f (Suc i) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f i x adds f (Suc i) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f i adds f (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> {v}} \\<Longrightarrow>\n       good (adds) f", "ultimately"], ["proof (chain)\npicking this:\n  i < Suc i\n  f i adds f (Suc i)", "show \"good (adds) f\""], ["proof (prove)\nusing this:\n  i < Suc i\n  f i adds f (Suc i)\n\ngoal (1 subgoal):\n 1. good (adds) f", "by (meson goodI)"], ["proof (state)\nthis:\n  good (adds) f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> {v}}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> insert v V} \\<Longrightarrow>\n       good (adds) f", "with insert(3)"], ["proof (chain)\npicking this:\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> V}\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> {v}}", "have\n      \"almost_full_on (prod_le (adds) (adds)) ({x::'a \\<Rightarrow> 'b. supp_fun x \\<subseteq> V} \\<times> {x::'a \\<Rightarrow> 'b. supp_fun x \\<subseteq> {v}})\"\n      (is \"almost_full_on ?P ?A\")"], ["proof (prove)\nusing this:\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> V}\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> {v}}\n\ngoal (1 subgoal):\n 1. almost_full_on (prod_le (adds) (adds))\n     ({x. supp_fun x \\<subseteq> V} \\<times>\n      {x. supp_fun x \\<subseteq> {v}})", "by (rule almost_full_on_Sigma)"], ["proof (state)\nthis:\n  almost_full_on (prod_le (adds) (adds))\n   ({x. supp_fun x \\<subseteq> V} \\<times> {x. supp_fun x \\<subseteq> {v}})\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> insert v V} \\<Longrightarrow>\n       good (adds) f", "moreover"], ["proof (state)\nthis:\n  almost_full_on (prod_le (adds) (adds))\n   ({x. supp_fun x \\<subseteq> V} \\<times> {x. supp_fun x \\<subseteq> {v}})\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> insert v V} \\<Longrightarrow>\n       good (adds) f", "from a"], ["proof (chain)\npicking this:\n  supp_fun (seq ?i) \\<subseteq> insert v V", "have \"seq' i \\<in> ?A\" for i"], ["proof (prove)\nusing this:\n  supp_fun (seq ?i) \\<subseteq> insert v V\n\ngoal (1 subgoal):\n 1. seq' i\n    \\<in> {x. supp_fun x \\<subseteq> V} \\<times>\n          {x. supp_fun x \\<subseteq> {v}}", "by (auto simp add: seq'_def supp_except_fun)"], ["proof (state)\nthis:\n  seq' ?i\n  \\<in> {x. supp_fun x \\<subseteq> V} \\<times>\n        {x. supp_fun x \\<subseteq> {v}}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> insert v V} \\<Longrightarrow>\n       good (adds) f", "ultimately"], ["proof (chain)\npicking this:\n  almost_full_on (prod_le (adds) (adds))\n   ({x. supp_fun x \\<subseteq> V} \\<times> {x. supp_fun x \\<subseteq> {v}})\n  seq' ?i\n  \\<in> {x. supp_fun x \\<subseteq> V} \\<times>\n        {x. supp_fun x \\<subseteq> {v}}", "obtain i j where \"i < j\" and \"?P (seq' i) (seq' j)\""], ["proof (prove)\nusing this:\n  almost_full_on (prod_le (adds) (adds))\n   ({x. supp_fun x \\<subseteq> V} \\<times> {x. supp_fun x \\<subseteq> {v}})\n  seq' ?i\n  \\<in> {x. supp_fun x \\<subseteq> V} \\<times>\n        {x. supp_fun x \\<subseteq> {v}}\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; prod_le (adds) (adds) (seq' i) (seq' j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule almost_full_onD)"], ["proof (state)\nthis:\n  i < j\n  prod_le (adds) (adds) (seq' i) (seq' j)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> insert v V} \\<Longrightarrow>\n       good (adds) f", "have \"seq i adds seq j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq i adds seq j", "unfolding adds_except_fun[where s=\"seq i\" and V=V]"], ["proof (prove)\ngoal (1 subgoal):\n 1. except_fun (seq i) V adds except_fun (seq j) V \\<and>\n    except_fun (seq i) (- V) adds except_fun (seq j) (- V)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. except_fun (seq i) V adds except_fun (seq j) V\n 2. except_fun (seq i) (- V) adds except_fun (seq j) (- V)", "from \\<open>?P (seq' i) (seq' j)\\<close>"], ["proof (chain)\npicking this:\n  prod_le (adds) (adds) (seq' i) (seq' j)", "show \"except_fun (seq i) V adds except_fun (seq j) V\""], ["proof (prove)\nusing this:\n  prod_le (adds) (adds) (seq' i) (seq' j)\n\ngoal (1 subgoal):\n 1. except_fun (seq i) V adds except_fun (seq j) V", "by (simp add: prod_le_def seq'_def)"], ["proof (state)\nthis:\n  except_fun (seq i) V adds except_fun (seq j) V\n\ngoal (1 subgoal):\n 1. except_fun (seq i) (- V) adds except_fun (seq j) (- V)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. except_fun (seq i) (- V) adds except_fun (seq j) (- V)", "from \\<open>?P (seq' i) (seq' j)\\<close>"], ["proof (chain)\npicking this:\n  prod_le (adds) (adds) (seq' i) (seq' j)", "have \"except_fun (seq i) {v} adds except_fun (seq j) {v}\""], ["proof (prove)\nusing this:\n  prod_le (adds) (adds) (seq' i) (seq' j)\n\ngoal (1 subgoal):\n 1. except_fun (seq i) {v} adds except_fun (seq j) {v}", "by (simp add: prod_le_def seq'_def)"], ["proof (state)\nthis:\n  except_fun (seq i) {v} adds except_fun (seq j) {v}\n\ngoal (1 subgoal):\n 1. except_fun (seq i) (- V) adds except_fun (seq j) (- V)", "moreover"], ["proof (state)\nthis:\n  except_fun (seq i) {v} adds except_fun (seq j) {v}\n\ngoal (1 subgoal):\n 1. except_fun (seq i) (- V) adds except_fun (seq j) (- V)", "have \"except_fun (seq i) (- V) = except_fun (seq i) {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except_fun (seq i) (- V) = except_fun (seq i) {v}", "by (rule except_fun_cong1; use a[of i] insert.hyps(2) in blast)"], ["proof (state)\nthis:\n  except_fun (seq i) (- V) = except_fun (seq i) {v}\n\ngoal (1 subgoal):\n 1. except_fun (seq i) (- V) adds except_fun (seq j) (- V)", "moreover"], ["proof (state)\nthis:\n  except_fun (seq i) (- V) = except_fun (seq i) {v}\n\ngoal (1 subgoal):\n 1. except_fun (seq i) (- V) adds except_fun (seq j) (- V)", "have \"except_fun (seq j) (- V) = except_fun (seq j) {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except_fun (seq j) (- V) = except_fun (seq j) {v}", "by (rule except_fun_cong1; use a[of j] insert.hyps(2) in blast)"], ["proof (state)\nthis:\n  except_fun (seq j) (- V) = except_fun (seq j) {v}\n\ngoal (1 subgoal):\n 1. except_fun (seq i) (- V) adds except_fun (seq j) (- V)", "ultimately"], ["proof (chain)\npicking this:\n  except_fun (seq i) {v} adds except_fun (seq j) {v}\n  except_fun (seq i) (- V) = except_fun (seq i) {v}\n  except_fun (seq j) (- V) = except_fun (seq j) {v}", "show \"except_fun (seq i) (- V) adds except_fun (seq j) (- V)\""], ["proof (prove)\nusing this:\n  except_fun (seq i) {v} adds except_fun (seq j) {v}\n  except_fun (seq i) (- V) = except_fun (seq i) {v}\n  except_fun (seq j) (- V) = except_fun (seq j) {v}\n\ngoal (1 subgoal):\n 1. except_fun (seq i) (- V) adds except_fun (seq j) (- V)", "by simp"], ["proof (state)\nthis:\n  except_fun (seq i) (- V) adds except_fun (seq j) (- V)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  seq i adds seq j\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i.\n          f i \\<in> {x. supp_fun x \\<subseteq> insert v V} \\<Longrightarrow>\n       good (adds) f", "with \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  i < j\n  seq i adds seq j", "show \"good (adds) seq\""], ["proof (prove)\nusing this:\n  i < j\n  seq i adds seq j\n\ngoal (1 subgoal):\n 1. good (adds) seq", "by (meson goodI)"], ["proof (state)\nthis:\n  good (adds) seq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> insert v V}\n\ngoal:\nNo subgoals!", "qed"], ["", "instance \"fun\" :: (finite, add_wellorder) dickson_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, dickson_powerprod_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_full_on (adds) UNIV", "have \"finite (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "by simp"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) UNIV", "hence \"almost_full_on (adds) {x::'a \\<Rightarrow> 'b. supp_fun x \\<subseteq> UNIV}\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> UNIV}", "by (rule Dickson_fun)"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> UNIV}\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) UNIV", "thus \"almost_full_on (adds) (UNIV::('a \\<Rightarrow> 'b) set)\""], ["proof (prove)\nusing this:\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> UNIV}\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) UNIV", "by simp"], ["proof (state)\nthis:\n  almost_full_on (adds) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lexicographic Term Order\\<close>"], ["", "text \\<open>Term orders are certain linear orders on power-products, satisfying additional requirements.\n  Further information on term orders can be found, e.\\,g., in @{cite Robbiano1985}.\\<close>"], ["", "context wellorder\nbegin"], ["", "lemma neq_fun_alt:\n  assumes \"s \\<noteq> (t::'a \\<Rightarrow> 'b)\"\n  obtains x where \"s x \\<noteq> t x\" and \"\\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>s x \\<noteq> t x;\n         \\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>s x \\<noteq> t x;\n         \\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms ext[of s t]"], ["proof (chain)\npicking this:\n  s \\<noteq> t\n  (\\<And>x. s x = t x) \\<Longrightarrow> s = t", "have \"\\<exists>x. s x \\<noteq> t x\""], ["proof (prove)\nusing this:\n  s \\<noteq> t\n  (\\<And>x. s x = t x) \\<Longrightarrow> s = t\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x \\<noteq> t x", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. s x \\<noteq> t x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>s x \\<noteq> t x;\n         \\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with exists_least_iff[of \"\\<lambda>x. s x \\<noteq> t x\"]"], ["proof (chain)\npicking this:\n  (\\<exists>n. s n \\<noteq> t n) =\n  (\\<exists>n.\n      s n \\<noteq> t n \\<and> (\\<forall>m<n. \\<not> s m \\<noteq> t m))\n  \\<exists>x. s x \\<noteq> t x", "obtain x where x1: \"s x \\<noteq> t x\" and x2: \"\\<And>y. y < x \\<Longrightarrow> s y = t y\""], ["proof (prove)\nusing this:\n  (\\<exists>n. s n \\<noteq> t n) =\n  (\\<exists>n.\n      s n \\<noteq> t n \\<and> (\\<forall>m<n. \\<not> s m \\<noteq> t m))\n  \\<exists>x. s x \\<noteq> t x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>s x \\<noteq> t x;\n         \\<And>y. y < x \\<Longrightarrow> s y = t y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s x \\<noteq> t x\n  ?y < x \\<Longrightarrow> s ?y = t ?y\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>s x \\<noteq> t x;\n         \\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s ?x \\<noteq> t ?x\n 2. \\<And>y. s y \\<noteq> t y \\<Longrightarrow> ?x \\<le> y", "from x1"], ["proof (chain)\npicking this:\n  s x \\<noteq> t x", "show \"s x \\<noteq> t x\""], ["proof (prove)\nusing this:\n  s x \\<noteq> t x\n\ngoal (1 subgoal):\n 1. s x \\<noteq> t x", "."], ["proof (state)\nthis:\n  s x \\<noteq> t x\n\ngoal (1 subgoal):\n 1. \\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y", "assume \"s y \\<noteq> t y\""], ["proof (state)\nthis:\n  s y \\<noteq> t y\n\ngoal (1 subgoal):\n 1. \\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y", "with x2[of y]"], ["proof (chain)\npicking this:\n  y < x \\<Longrightarrow> s y = t y\n  s y \\<noteq> t y", "have \"\\<not> y < x\""], ["proof (prove)\nusing this:\n  y < x \\<Longrightarrow> s y = t y\n  s y \\<noteq> t y\n\ngoal (1 subgoal):\n 1. \\<not> y < x", "by auto"], ["proof (state)\nthis:\n  \\<not> y < x\n\ngoal (1 subgoal):\n 1. \\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y", "thus \"x \\<le> y\""], ["proof (prove)\nusing this:\n  \\<not> y < x\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by simp"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition lex_fun::\"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b::order) \\<Rightarrow> bool\" where\n  \"lex_fun s t \\<equiv> (\\<forall>x. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y))\""], ["", "definition \"lex_fun_strict s t \\<longleftrightarrow> lex_fun s t \\<and> \\<not> lex_fun t s\""], ["", "text \\<open>Attention! @{term lex_fun} reverses the order of the indeterminates: if @{term x} is smaller than\n  @{term y} w.r.t. the order on @{typ 'a}, then the @{emph \\<open>power-product\\<close>} @{term x} is\n  @{emph \\<open>greater\\<close>} than the @{emph \\<open>power-product\\<close>} @{term y}.\\<close>"], ["", "lemma lex_fun_alt:\n  shows \"lex_fun s t = (s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)))\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_fun s t =\n    (s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lex_fun s t \\<Longrightarrow>\n    s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n 2. s = t \\<or>\n    (\\<exists>x.\n        s x < t x \\<and> (\\<forall>y<x. s y = t y)) \\<Longrightarrow>\n    lex_fun s t", "assume ?L"], ["proof (state)\nthis:\n  lex_fun s t\n\ngoal (2 subgoals):\n 1. lex_fun s t \\<Longrightarrow>\n    s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n 2. s = t \\<or>\n    (\\<exists>x.\n        s x < t x \\<and> (\\<forall>y<x. s y = t y)) \\<Longrightarrow>\n    lex_fun s t", "show ?R"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "proof (cases \"s = t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = t \\<Longrightarrow>\n    s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n 2. s \\<noteq> t \\<Longrightarrow>\n    s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "assume \"s = t\""], ["proof (state)\nthis:\n  s = t\n\ngoal (2 subgoals):\n 1. s = t \\<Longrightarrow>\n    s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n 2. s \\<noteq> t \\<Longrightarrow>\n    s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "thus ?R"], ["proof (prove)\nusing this:\n  s = t\n\ngoal (1 subgoal):\n 1. s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "by simp"], ["proof (state)\nthis:\n  s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n\ngoal (1 subgoal):\n 1. s \\<noteq> t \\<Longrightarrow>\n    s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> t \\<Longrightarrow>\n    s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "assume \"s \\<noteq> t\""], ["proof (state)\nthis:\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. s \\<noteq> t \\<Longrightarrow>\n    s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "from neq_fun_alt[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      \\<lbrakk>s x \\<noteq> t x;\n       \\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain x0\n      where x0_neq: \"s x0 \\<noteq> t x0\" and x0_min: \"\\<And>z. s z \\<noteq> t z \\<Longrightarrow> x0 \\<le> z\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<lbrakk>s x \\<noteq> t x;\n       \\<And>y. s y \\<noteq> t y \\<Longrightarrow> x \\<le> y\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x0.\n        \\<lbrakk>s x0 \\<noteq> t x0;\n         \\<And>z. s z \\<noteq> t z \\<Longrightarrow> x0 \\<le> z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s x0 \\<noteq> t x0\n  s ?z \\<noteq> t ?z \\<Longrightarrow> x0 \\<le> ?z\n\ngoal (1 subgoal):\n 1. s \\<noteq> t \\<Longrightarrow>\n    s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "show ?R"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "proof (intro disjI2, rule exI[of _ x0], intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. s x0 < t x0\n 2. \\<forall>y<x0. s y = t y", "from \\<open>?L\\<close>"], ["proof (chain)\npicking this:\n  lex_fun s t", "have \"s x0 \\<le> t x0 \\<or> (\\<exists>y. y < x0 \\<and> s y \\<noteq> t y)\""], ["proof (prove)\nusing this:\n  lex_fun s t\n\ngoal (1 subgoal):\n 1. s x0 \\<le> t x0 \\<or> (\\<exists>y<x0. s y \\<noteq> t y)", "unfolding lex_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\n\ngoal (1 subgoal):\n 1. s x0 \\<le> t x0 \\<or> (\\<exists>y<x0. s y \\<noteq> t y)", ".."], ["proof (state)\nthis:\n  s x0 \\<le> t x0 \\<or> (\\<exists>y<x0. s y \\<noteq> t y)\n\ngoal (2 subgoals):\n 1. s x0 < t x0\n 2. \\<forall>y<x0. s y = t y", "thus \"s x0 < t x0\""], ["proof (prove)\nusing this:\n  s x0 \\<le> t x0 \\<or> (\\<exists>y<x0. s y \\<noteq> t y)\n\ngoal (1 subgoal):\n 1. s x0 < t x0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s x0 \\<le> t x0 \\<Longrightarrow> s x0 < t x0\n 2. \\<exists>y<x0. s y \\<noteq> t y \\<Longrightarrow> s x0 < t x0", "assume \"s x0 \\<le> t x0\""], ["proof (state)\nthis:\n  s x0 \\<le> t x0\n\ngoal (2 subgoals):\n 1. s x0 \\<le> t x0 \\<Longrightarrow> s x0 < t x0\n 2. \\<exists>y<x0. s y \\<noteq> t y \\<Longrightarrow> s x0 < t x0", "from this x0_neq"], ["proof (chain)\npicking this:\n  s x0 \\<le> t x0\n  s x0 \\<noteq> t x0", "show ?thesis"], ["proof (prove)\nusing this:\n  s x0 \\<le> t x0\n  s x0 \\<noteq> t x0\n\ngoal (1 subgoal):\n 1. s x0 < t x0", "by simp"], ["proof (state)\nthis:\n  s x0 < t x0\n\ngoal (1 subgoal):\n 1. \\<exists>y<x0. s y \\<noteq> t y \\<Longrightarrow> s x0 < t x0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y<x0. s y \\<noteq> t y \\<Longrightarrow> s x0 < t x0", "assume \"\\<exists>y. y < x0 \\<and> s y \\<noteq> t y\""], ["proof (state)\nthis:\n  \\<exists>y<x0. s y \\<noteq> t y\n\ngoal (1 subgoal):\n 1. \\<exists>y<x0. s y \\<noteq> t y \\<Longrightarrow> s x0 < t x0", "then"], ["proof (chain)\npicking this:\n  \\<exists>y<x0. s y \\<noteq> t y", "obtain y where \"y < x0\" and y_neq: \"s y \\<noteq> t y\""], ["proof (prove)\nusing this:\n  \\<exists>y<x0. s y \\<noteq> t y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y < x0; s y \\<noteq> t y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y < x0\n  s y \\<noteq> t y\n\ngoal (1 subgoal):\n 1. \\<exists>y<x0. s y \\<noteq> t y \\<Longrightarrow> s x0 < t x0", "from \\<open>y < x0\\<close> x0_min[OF y_neq]"], ["proof (chain)\npicking this:\n  y < x0\n  x0 \\<le> y", "show ?thesis"], ["proof (prove)\nusing this:\n  y < x0\n  x0 \\<le> y\n\ngoal (1 subgoal):\n 1. s x0 < t x0", "by simp"], ["proof (state)\nthis:\n  s x0 < t x0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s x0 < t x0\n\ngoal (1 subgoal):\n 1. \\<forall>y<x0. s y = t y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y<x0. s y = t y", "show \"\\<forall>y<x0. s y = t y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y<x0. s y = t y", "proof (rule, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y < x0 \\<Longrightarrow> s y = t y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y < x0 \\<Longrightarrow> s y = t y", "assume \"y < x0\""], ["proof (state)\nthis:\n  y < x0\n\ngoal (1 subgoal):\n 1. \\<And>y. y < x0 \\<Longrightarrow> s y = t y", "hence \"\\<not> x0 \\<le> y\""], ["proof (prove)\nusing this:\n  y < x0\n\ngoal (1 subgoal):\n 1. \\<not> x0 \\<le> y", "by simp"], ["proof (state)\nthis:\n  \\<not> x0 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>y. y < x0 \\<Longrightarrow> s y = t y", "from this x0_min[of y]"], ["proof (chain)\npicking this:\n  \\<not> x0 \\<le> y\n  s y \\<noteq> t y \\<Longrightarrow> x0 \\<le> y", "show \"s y = t y\""], ["proof (prove)\nusing this:\n  \\<not> x0 \\<le> y\n  s y \\<noteq> t y \\<Longrightarrow> x0 \\<le> y\n\ngoal (1 subgoal):\n 1. s y = t y", "by auto"], ["proof (state)\nthis:\n  s y = t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y<x0. s y = t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n\ngoal (1 subgoal):\n 1. s = t \\<or>\n    (\\<exists>x.\n        s x < t x \\<and> (\\<forall>y<x. s y = t y)) \\<Longrightarrow>\n    lex_fun s t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s = t \\<or>\n    (\\<exists>x.\n        s x < t x \\<and> (\\<forall>y<x. s y = t y)) \\<Longrightarrow>\n    lex_fun s t", "assume ?R"], ["proof (state)\nthis:\n  s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n\ngoal (1 subgoal):\n 1. s = t \\<or>\n    (\\<exists>x.\n        s x < t x \\<and> (\\<forall>y<x. s y = t y)) \\<Longrightarrow>\n    lex_fun s t", "thus ?L"], ["proof (prove)\nusing this:\n  s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n\ngoal (1 subgoal):\n 1. lex_fun s t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s = t \\<Longrightarrow> lex_fun s t\n 2. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s t", "assume \"s = t\""], ["proof (state)\nthis:\n  s = t\n\ngoal (2 subgoals):\n 1. s = t \\<Longrightarrow> lex_fun s t\n 2. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s t", "thus ?thesis"], ["proof (prove)\nusing this:\n  s = t\n\ngoal (1 subgoal):\n 1. lex_fun s t", "by (simp add: lex_fun_def)"], ["proof (state)\nthis:\n  lex_fun s t\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s t", "assume \"\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)\""], ["proof (state)\nthis:\n  \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s t", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)", "obtain y where y: \"s y < t y\" and y_min: \"\\<forall>z<y. s z = t z\""], ["proof (prove)\nusing this:\n  \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>s y < t y; \\<forall>z<y. s z = t z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s y < t y\n  \\<forall>z<y. s z = t z\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_fun s t", "unfolding lex_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "show \"s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "proof (cases \"s x \\<le> t x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s x \\<le> t x \\<Longrightarrow>\n    s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\n 2. \\<not> s x \\<le> t x \\<Longrightarrow>\n    s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "assume \"s x \\<le> t x\""], ["proof (state)\nthis:\n  s x \\<le> t x\n\ngoal (2 subgoals):\n 1. s x \\<le> t x \\<Longrightarrow>\n    s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\n 2. \\<not> s x \\<le> t x \\<Longrightarrow>\n    s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s x \\<le> t x\n\ngoal (1 subgoal):\n 1. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "by simp"], ["proof (state)\nthis:\n  s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\n\ngoal (1 subgoal):\n 1. \\<not> s x \\<le> t x \\<Longrightarrow>\n    s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s x \\<le> t x \\<Longrightarrow>\n    s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "assume x: \"\\<not> s x \\<le> t x\""], ["proof (state)\nthis:\n  \\<not> s x \\<le> t x\n\ngoal (1 subgoal):\n 1. \\<not> s x \\<le> t x \\<Longrightarrow>\n    s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "proof (intro disjI2, rule exI[of _ y], intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. y < x\n 2. s y \\<noteq> t y", "have \"\\<not> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> False", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> False", "hence \"x < y \\<or> y = x\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x < y \\<or> y = x", "by auto"], ["proof (state)\nthis:\n  x < y \\<or> y = x\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  x < y \\<or> y = x\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> False\n 2. y = x \\<Longrightarrow> False", "assume \"x < y\""], ["proof (state)\nthis:\n  x < y\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> False\n 2. y = x \\<Longrightarrow> False", "from x y_min[rule_format, OF this]"], ["proof (chain)\npicking this:\n  \\<not> s x \\<le> t x\n  s x = t x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> s x \\<le> t x\n  s x = t x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. y = x \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y = x \\<Longrightarrow> False", "assume \"y = x\""], ["proof (state)\nthis:\n  y = x\n\ngoal (1 subgoal):\n 1. y = x \\<Longrightarrow> False", "from this x y"], ["proof (chain)\npicking this:\n  y = x\n  \\<not> s x \\<le> t x\n  s y < t y", "show ?thesis"], ["proof (prove)\nusing this:\n  y = x\n  \\<not> s x \\<le> t x\n  s y < t y\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: preorder_class.less_le_not_le)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> x \\<le> y\n\ngoal (2 subgoals):\n 1. y < x\n 2. s y \\<noteq> t y", "thus \"y < x\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. y < x", "by simp"], ["proof (state)\nthis:\n  y < x\n\ngoal (1 subgoal):\n 1. s y \\<noteq> t y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s y \\<noteq> t y", "from y"], ["proof (chain)\npicking this:\n  s y < t y", "show \"s y \\<noteq> t y\""], ["proof (prove)\nusing this:\n  s y < t y\n\ngoal (1 subgoal):\n 1. s y \\<noteq> t y", "by simp"], ["proof (state)\nthis:\n  s y \\<noteq> t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_fun s t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_fun s t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_fun_refl: \"lex_fun s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_fun s s", "unfolding lex_fun_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = s \\<or> (\\<exists>x. s x < s x \\<and> (\\<forall>y<x. s y = s y))", "by simp"], ["", "lemma lex_fun_antisym:\n  assumes \"lex_fun s t\" and \"lex_fun t s\"\n  shows \"s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. s x = t x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. s x = t x", "from assms(1)"], ["proof (chain)\npicking this:\n  lex_fun s t", "have \"s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\""], ["proof (prove)\nusing this:\n  lex_fun s t\n\ngoal (1 subgoal):\n 1. s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "unfolding lex_fun_alt"], ["proof (prove)\nusing this:\n  s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n\ngoal (1 subgoal):\n 1. s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "."], ["proof (state)\nthis:\n  s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n\ngoal (1 subgoal):\n 1. \\<And>x. s x = t x", "thus \"s x = t x\""], ["proof (prove)\nusing this:\n  s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n\ngoal (1 subgoal):\n 1. s x = t x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s = t \\<Longrightarrow> s x = t x\n 2. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    s x = t x", "assume \"s = t\""], ["proof (state)\nthis:\n  s = t\n\ngoal (2 subgoals):\n 1. s = t \\<Longrightarrow> s x = t x\n 2. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    s x = t x", "thus ?thesis"], ["proof (prove)\nusing this:\n  s = t\n\ngoal (1 subgoal):\n 1. s x = t x", "by simp"], ["proof (state)\nthis:\n  s x = t x\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    s x = t x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    s x = t x", "assume \"\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)\""], ["proof (state)\nthis:\n  \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    s x = t x", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)", "obtain x0 where x0: \"s x0 < t x0\" and x0_min: \"\\<forall>y<x0. s y = t y\""], ["proof (prove)\nusing this:\n  \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)\n\ngoal (1 subgoal):\n 1. (\\<And>x0.\n        \\<lbrakk>s x0 < t x0; \\<forall>y<x0. s y = t y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s x0 < t x0\n  \\<forall>y<x0. s y = t y\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    s x = t x", "from assms(2)"], ["proof (chain)\npicking this:\n  lex_fun t s", "have \"t = s \\<or> (\\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y))\""], ["proof (prove)\nusing this:\n  lex_fun t s\n\ngoal (1 subgoal):\n 1. t = s \\<or> (\\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y))", "unfolding lex_fun_alt"], ["proof (prove)\nusing this:\n  t = s \\<or> (\\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y))\n\ngoal (1 subgoal):\n 1. t = s \\<or> (\\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y))", "."], ["proof (state)\nthis:\n  t = s \\<or> (\\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y))\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    s x = t x", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = s \\<or> (\\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y))\n\ngoal (1 subgoal):\n 1. s x = t x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t = s \\<Longrightarrow> s x = t x\n 2. \\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y) \\<Longrightarrow>\n    s x = t x", "assume \"t = s\""], ["proof (state)\nthis:\n  t = s\n\ngoal (2 subgoals):\n 1. t = s \\<Longrightarrow> s x = t x\n 2. \\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y) \\<Longrightarrow>\n    s x = t x", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = s\n\ngoal (1 subgoal):\n 1. s x = t x", "by simp"], ["proof (state)\nthis:\n  s x = t x\n\ngoal (1 subgoal):\n 1. \\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y) \\<Longrightarrow>\n    s x = t x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y) \\<Longrightarrow>\n    s x = t x", "assume \"\\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y)\""], ["proof (state)\nthis:\n  \\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y)\n\ngoal (1 subgoal):\n 1. \\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y) \\<Longrightarrow>\n    s x = t x", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y)", "obtain x1 where x1: \"t x1 < s x1\" and x1_min: \"\\<forall>y<x1. t y = s y\""], ["proof (prove)\nusing this:\n  \\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y)\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>t x1 < s x1; \\<forall>y<x1. t y = s y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t x1 < s x1\n  \\<forall>y<x1. t y = s y\n\ngoal (1 subgoal):\n 1. \\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y) \\<Longrightarrow>\n    s x = t x", "have \"x0 < x1 \\<or> x1 < x0 \\<or> x1 = x0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x0 < x1 \\<or> x1 < x0 \\<or> x1 = x0", "using local.antisym_conv3"], ["proof (prove)\nusing this:\n  \\<not> ?y < ?x \\<Longrightarrow> (\\<not> ?x < ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. x0 < x1 \\<or> x1 < x0 \\<or> x1 = x0", "by auto"], ["proof (state)\nthis:\n  x0 < x1 \\<or> x1 < x0 \\<or> x1 = x0\n\ngoal (1 subgoal):\n 1. \\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y) \\<Longrightarrow>\n    s x = t x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s x = t x", "proof (rule linorder_cases[of x0 x1])"], ["proof (state)\ngoal (3 subgoals):\n 1. x0 < x1 \\<Longrightarrow> s x = t x\n 2. x0 = x1 \\<Longrightarrow> s x = t x\n 3. x1 < x0 \\<Longrightarrow> s x = t x", "assume \"x1 < x0\""], ["proof (state)\nthis:\n  x1 < x0\n\ngoal (3 subgoals):\n 1. x0 < x1 \\<Longrightarrow> s x = t x\n 2. x0 = x1 \\<Longrightarrow> s x = t x\n 3. x1 < x0 \\<Longrightarrow> s x = t x", "from x0_min[rule_format, OF this] x1"], ["proof (chain)\npicking this:\n  s x1 = t x1\n  t x1 < s x1", "show ?thesis"], ["proof (prove)\nusing this:\n  s x1 = t x1\n  t x1 < s x1\n\ngoal (1 subgoal):\n 1. s x = t x", "by simp"], ["proof (state)\nthis:\n  s x = t x\n\ngoal (2 subgoals):\n 1. x0 < x1 \\<Longrightarrow> s x = t x\n 2. x0 = x1 \\<Longrightarrow> s x = t x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x0 < x1 \\<Longrightarrow> s x = t x\n 2. x0 = x1 \\<Longrightarrow> s x = t x", "assume \"x0 = x1\""], ["proof (state)\nthis:\n  x0 = x1\n\ngoal (2 subgoals):\n 1. x0 < x1 \\<Longrightarrow> s x = t x\n 2. x0 = x1 \\<Longrightarrow> s x = t x", "from this x0 x1"], ["proof (chain)\npicking this:\n  x0 = x1\n  s x0 < t x0\n  t x1 < s x1", "show ?thesis"], ["proof (prove)\nusing this:\n  x0 = x1\n  s x0 < t x0\n  t x1 < s x1\n\ngoal (1 subgoal):\n 1. s x = t x", "by simp"], ["proof (state)\nthis:\n  s x = t x\n\ngoal (1 subgoal):\n 1. x0 < x1 \\<Longrightarrow> s x = t x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x0 < x1 \\<Longrightarrow> s x = t x", "assume \"x0 < x1\""], ["proof (state)\nthis:\n  x0 < x1\n\ngoal (1 subgoal):\n 1. x0 < x1 \\<Longrightarrow> s x = t x", "from x1_min[rule_format, OF this] x0"], ["proof (chain)\npicking this:\n  t x0 = s x0\n  s x0 < t x0", "show ?thesis"], ["proof (prove)\nusing this:\n  t x0 = s x0\n  s x0 < t x0\n\ngoal (1 subgoal):\n 1. s x = t x", "by simp"], ["proof (state)\nthis:\n  s x = t x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s x = t x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s x = t x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s x = t x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_fun_trans:\n  assumes \"lex_fun s t\" and \"lex_fun t u\"\n  shows \"lex_fun s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_fun s u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lex_fun s u", "from assms(1)"], ["proof (chain)\npicking this:\n  lex_fun s t", "have \"s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\""], ["proof (prove)\nusing this:\n  lex_fun s t\n\ngoal (1 subgoal):\n 1. s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "unfolding lex_fun_alt"], ["proof (prove)\nusing this:\n  s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n\ngoal (1 subgoal):\n 1. s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))", "."], ["proof (state)\nthis:\n  s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n\ngoal (1 subgoal):\n 1. lex_fun s u", "thus ?thesis"], ["proof (prove)\nusing this:\n  s = t \\<or> (\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y))\n\ngoal (1 subgoal):\n 1. lex_fun s u", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s = t \\<Longrightarrow> lex_fun s u\n 2. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s u", "assume \"s = t\""], ["proof (state)\nthis:\n  s = t\n\ngoal (2 subgoals):\n 1. s = t \\<Longrightarrow> lex_fun s u\n 2. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s u", "from this assms(2)"], ["proof (chain)\npicking this:\n  s = t\n  lex_fun t u", "show ?thesis"], ["proof (prove)\nusing this:\n  s = t\n  lex_fun t u\n\ngoal (1 subgoal):\n 1. lex_fun s u", "by simp"], ["proof (state)\nthis:\n  lex_fun s u\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s u", "assume \"\\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)\""], ["proof (state)\nthis:\n  \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s u", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)", "obtain x0 where x0: \"s x0 < t x0\" and x0_min: \"\\<forall>y<x0. s y = t y\""], ["proof (prove)\nusing this:\n  \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y)\n\ngoal (1 subgoal):\n 1. (\\<And>x0.\n        \\<lbrakk>s x0 < t x0; \\<forall>y<x0. s y = t y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s x0 < t x0\n  \\<forall>y<x0. s y = t y\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s u", "from assms(2)"], ["proof (chain)\npicking this:\n  lex_fun t u", "have \"t = u \\<or> (\\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y))\""], ["proof (prove)\nusing this:\n  lex_fun t u\n\ngoal (1 subgoal):\n 1. t = u \\<or> (\\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y))", "unfolding lex_fun_alt"], ["proof (prove)\nusing this:\n  t = u \\<or> (\\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y))\n\ngoal (1 subgoal):\n 1. t = u \\<or> (\\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y))", "."], ["proof (state)\nthis:\n  t = u \\<or> (\\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y))\n\ngoal (1 subgoal):\n 1. \\<exists>x. s x < t x \\<and> (\\<forall>y<x. s y = t y) \\<Longrightarrow>\n    lex_fun s u", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = u \\<or> (\\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y))\n\ngoal (1 subgoal):\n 1. lex_fun s u", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t = u \\<Longrightarrow> lex_fun s u\n 2. \\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y) \\<Longrightarrow>\n    lex_fun s u", "assume \"t = u\""], ["proof (state)\nthis:\n  t = u\n\ngoal (2 subgoals):\n 1. t = u \\<Longrightarrow> lex_fun s u\n 2. \\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y) \\<Longrightarrow>\n    lex_fun s u", "from this assms(1)"], ["proof (chain)\npicking this:\n  t = u\n  lex_fun s t", "show ?thesis"], ["proof (prove)\nusing this:\n  t = u\n  lex_fun s t\n\ngoal (1 subgoal):\n 1. lex_fun s u", "by simp"], ["proof (state)\nthis:\n  lex_fun s u\n\ngoal (1 subgoal):\n 1. \\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y) \\<Longrightarrow>\n    lex_fun s u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y) \\<Longrightarrow>\n    lex_fun s u", "assume \"\\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y)\""], ["proof (state)\nthis:\n  \\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y)\n\ngoal (1 subgoal):\n 1. \\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y) \\<Longrightarrow>\n    lex_fun s u", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y)", "obtain x1 where x1: \"t x1 < u x1\" and x1_min: \"\\<forall>y<x1. t y = u y\""], ["proof (prove)\nusing this:\n  \\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y)\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>t x1 < u x1; \\<forall>y<x1. t y = u y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t x1 < u x1\n  \\<forall>y<x1. t y = u y\n\ngoal (1 subgoal):\n 1. \\<exists>x. t x < u x \\<and> (\\<forall>y<x. t y = u y) \\<Longrightarrow>\n    lex_fun s u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_fun s u", "unfolding lex_fun_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = u \\<or> (\\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y))", "proof (intro disjI2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "show \"\\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "proof (rule linorder_cases[of x0 x1])"], ["proof (state)\ngoal (3 subgoals):\n 1. x0 < x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\n 2. x0 = x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\n 3. x1 < x0 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "assume \"x1 < x0\""], ["proof (state)\nthis:\n  x1 < x0\n\ngoal (3 subgoals):\n 1. x0 < x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\n 2. x0 = x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\n 3. x1 < x0 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "proof (rule exI[of _ x1], intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. s x1 < u x1\n 2. \\<forall>y<x1. s y = u y", "from x0_min[rule_format, OF \\<open>x1 < x0\\<close>] x1"], ["proof (chain)\npicking this:\n  s x1 = t x1\n  t x1 < u x1", "show \"s x1 < u x1\""], ["proof (prove)\nusing this:\n  s x1 = t x1\n  t x1 < u x1\n\ngoal (1 subgoal):\n 1. s x1 < u x1", "by simp"], ["proof (state)\nthis:\n  s x1 < u x1\n\ngoal (1 subgoal):\n 1. \\<forall>y<x1. s y = u y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y<x1. s y = u y", "show \"\\<forall>y<x1. s y = u y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y<x1. s y = u y", "proof (intro allI, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y < x1 \\<Longrightarrow> s y = u y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y < x1 \\<Longrightarrow> s y = u y", "assume \"y < x1\""], ["proof (state)\nthis:\n  y < x1\n\ngoal (1 subgoal):\n 1. \\<And>y. y < x1 \\<Longrightarrow> s y = u y", "from this \\<open>x1 < x0\\<close>"], ["proof (chain)\npicking this:\n  y < x1\n  x1 < x0", "have \"y < x0\""], ["proof (prove)\nusing this:\n  y < x1\n  x1 < x0\n\ngoal (1 subgoal):\n 1. y < x0", "by simp"], ["proof (state)\nthis:\n  y < x0\n\ngoal (1 subgoal):\n 1. \\<And>y. y < x1 \\<Longrightarrow> s y = u y", "from x0_min[rule_format, OF this] x1_min[rule_format, OF \\<open>y < x1\\<close>]"], ["proof (chain)\npicking this:\n  s y = t y\n  t y = u y", "show \"s y = u y\""], ["proof (prove)\nusing this:\n  s y = t y\n  t y = u y\n\ngoal (1 subgoal):\n 1. s y = u y", "by simp"], ["proof (state)\nthis:\n  s y = u y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y<x1. s y = u y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\n\ngoal (2 subgoals):\n 1. x0 < x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\n 2. x0 = x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x0 < x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\n 2. x0 = x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "assume \"x0 < x1\""], ["proof (state)\nthis:\n  x0 < x1\n\ngoal (2 subgoals):\n 1. x0 < x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\n 2. x0 = x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "proof (rule exI[of _ x0], intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. s x0 < u x0\n 2. \\<forall>y<x0. s y = u y", "from x1_min[rule_format, OF \\<open>x0 < x1\\<close>] x0"], ["proof (chain)\npicking this:\n  t x0 = u x0\n  s x0 < t x0", "show \"s x0 < u x0\""], ["proof (prove)\nusing this:\n  t x0 = u x0\n  s x0 < t x0\n\ngoal (1 subgoal):\n 1. s x0 < u x0", "by simp"], ["proof (state)\nthis:\n  s x0 < u x0\n\ngoal (1 subgoal):\n 1. \\<forall>y<x0. s y = u y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y<x0. s y = u y", "show \"\\<forall>y<x0. s y = u y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y<x0. s y = u y", "proof (intro allI, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y < x0 \\<Longrightarrow> s y = u y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y < x0 \\<Longrightarrow> s y = u y", "assume \"y < x0\""], ["proof (state)\nthis:\n  y < x0\n\ngoal (1 subgoal):\n 1. \\<And>y. y < x0 \\<Longrightarrow> s y = u y", "from this \\<open>x0 < x1\\<close>"], ["proof (chain)\npicking this:\n  y < x0\n  x0 < x1", "have \"y < x1\""], ["proof (prove)\nusing this:\n  y < x0\n  x0 < x1\n\ngoal (1 subgoal):\n 1. y < x1", "by simp"], ["proof (state)\nthis:\n  y < x1\n\ngoal (1 subgoal):\n 1. \\<And>y. y < x0 \\<Longrightarrow> s y = u y", "from x0_min[rule_format, OF \\<open>y < x0\\<close>] x1_min[rule_format, OF this]"], ["proof (chain)\npicking this:\n  s y = t y\n  t y = u y", "show \"s y = u y\""], ["proof (prove)\nusing this:\n  s y = t y\n  t y = u y\n\ngoal (1 subgoal):\n 1. s y = u y", "by simp"], ["proof (state)\nthis:\n  s y = u y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y<x0. s y = u y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\n\ngoal (1 subgoal):\n 1. x0 = x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x0 = x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "assume \"x0 = x1\""], ["proof (state)\nthis:\n  x0 = x1\n\ngoal (1 subgoal):\n 1. x0 = x1 \\<Longrightarrow>\n    \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)", "proof (rule exI[of _ x1], intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. s x1 < u x1\n 2. \\<forall>y<x1. s y = u y", "from \\<open>x0 = x1\\<close> x0 x1"], ["proof (chain)\npicking this:\n  x0 = x1\n  s x0 < t x0\n  t x1 < u x1", "show \"s x1 < u x1\""], ["proof (prove)\nusing this:\n  x0 = x1\n  s x0 < t x0\n  t x1 < u x1\n\ngoal (1 subgoal):\n 1. s x1 < u x1", "by simp"], ["proof (state)\nthis:\n  s x1 < u x1\n\ngoal (1 subgoal):\n 1. \\<forall>y<x1. s y = u y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y<x1. s y = u y", "show \"\\<forall>y<x1. s y = u y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y<x1. s y = u y", "proof (intro allI, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y < x1 \\<Longrightarrow> s y = u y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y < x1 \\<Longrightarrow> s y = u y", "assume \"y < x1\""], ["proof (state)\nthis:\n  y < x1\n\ngoal (1 subgoal):\n 1. \\<And>y. y < x1 \\<Longrightarrow> s y = u y", "hence \"y < x0\""], ["proof (prove)\nusing this:\n  y < x1\n\ngoal (1 subgoal):\n 1. y < x0", "using \\<open>x0 = x1\\<close>"], ["proof (prove)\nusing this:\n  y < x1\n  x0 = x1\n\ngoal (1 subgoal):\n 1. y < x0", "by simp"], ["proof (state)\nthis:\n  y < x0\n\ngoal (1 subgoal):\n 1. \\<And>y. y < x1 \\<Longrightarrow> s y = u y", "from x0_min[rule_format, OF this] x1_min[rule_format, OF \\<open>y < x1\\<close>]"], ["proof (chain)\npicking this:\n  s y = t y\n  t y = u y", "show \"s y = u y\""], ["proof (prove)\nusing this:\n  s y = t y\n  t y = u y\n\ngoal (1 subgoal):\n 1. s y = u y", "by simp"], ["proof (state)\nthis:\n  s y = u y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y<x1. s y = u y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. s x < u x \\<and> (\\<forall>y<x. s y = u y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_fun s u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_fun s u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_fun s u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_fun_lin: \"lex_fun s t \\<or> lex_fun t s\" for s t::\"'a \\<Rightarrow> 'b::{ordered_comm_monoid_add, linorder}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_fun s t \\<or> lex_fun t s", "proof (intro disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lex_fun t s \\<Longrightarrow> lex_fun s t", "assume \"\\<not> lex_fun t s\""], ["proof (state)\nthis:\n  \\<not> lex_fun t s\n\ngoal (1 subgoal):\n 1. \\<not> lex_fun t s \\<Longrightarrow> lex_fun s t", "hence a: \"\\<forall>x. \\<not> (t x < s x) \\<or> (\\<exists>y<x. t y \\<noteq> s y)\""], ["proof (prove)\nusing this:\n  \\<not> lex_fun t s\n\ngoal (1 subgoal):\n 1. \\<forall>x. \\<not> t x < s x \\<or> (\\<exists>y<x. t y \\<noteq> s y)", "unfolding lex_fun_alt"], ["proof (prove)\nusing this:\n  \\<not> (t = s \\<or>\n          (\\<exists>x. t x < s x \\<and> (\\<forall>y<x. t y = s y)))\n\ngoal (1 subgoal):\n 1. \\<forall>x. \\<not> t x < s x \\<or> (\\<exists>y<x. t y \\<noteq> s y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. \\<not> t x < s x \\<or> (\\<exists>y<x. t y \\<noteq> s y)\n\ngoal (1 subgoal):\n 1. \\<not> lex_fun t s \\<Longrightarrow> lex_fun s t", "show \"lex_fun s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_fun s t", "unfolding lex_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "from a"], ["proof (chain)\npicking this:\n  \\<forall>x. \\<not> t x < s x \\<or> (\\<exists>y<x. t y \\<noteq> s y)", "have \"\\<not> (t x < s x) \\<or> (\\<exists>y<x. t y \\<noteq> s y)\""], ["proof (prove)\nusing this:\n  \\<forall>x. \\<not> t x < s x \\<or> (\\<exists>y<x. t y \\<noteq> s y)\n\ngoal (1 subgoal):\n 1. \\<not> t x < s x \\<or> (\\<exists>y<x. t y \\<noteq> s y)", ".."], ["proof (state)\nthis:\n  \\<not> t x < s x \\<or> (\\<exists>y<x. t y \\<noteq> s y)\n\ngoal (1 subgoal):\n 1. \\<And>x. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "thus \"s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\""], ["proof (prove)\nusing this:\n  \\<not> t x < s x \\<or> (\\<exists>y<x. t y \\<noteq> s y)\n\ngoal (1 subgoal):\n 1. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "by auto"], ["proof (state)\nthis:\n  s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_fun s t\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lex_fun_strict_alt [code]:\n  \"lex_fun_strict s t = (\\<not> lex_fun t s)\" for s t::\"'a \\<Rightarrow> 'b::{ordered_comm_monoid_add, linorder}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_fun_strict s t = (\\<not> lex_fun t s)", "unfolding lex_fun_strict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict lex_fun s t = (\\<not> lex_fun t s)", "using lex_fun_lin[of s t]"], ["proof (prove)\nusing this:\n  lex_fun s t \\<or> lex_fun t s\n\ngoal (1 subgoal):\n 1. strict lex_fun s t = (\\<not> lex_fun t s)", "by auto"], ["", "lemma lex_fun_zero_min: \"lex_fun 0 s\" for s::\"'a \\<Rightarrow> 'b::add_linorder_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_fun 0 s", "by (simp add: lex_fun_def zero_min)"], ["", "lemma lex_fun_plus_monotone:\n  \"lex_fun (s + u) (t + u)\" if \"lex_fun s t\"\n  for s t::\"'a \\<Rightarrow> 'b::ordered_cancel_comm_monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_fun (s + u) (t + u)", "unfolding lex_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (s + u) x \\<le> (t + u) x \\<or>\n       (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (s + u) x \\<le> (t + u) x \\<or>\n       (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (s + u) x \\<le> (t + u) x \\<or>\n       (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "from that"], ["proof (chain)\npicking this:\n  lex_fun s t", "have \"s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\""], ["proof (prove)\nusing this:\n  lex_fun s t\n\ngoal (1 subgoal):\n 1. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", "unfolding lex_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\n\ngoal (1 subgoal):\n 1. s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)", ".."], ["proof (state)\nthis:\n  s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (s + u) x \\<le> (t + u) x \\<or>\n       (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "thus \"(s + u) x \\<le> (t + u) x \\<or> (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)\""], ["proof (prove)\nusing this:\n  s x \\<le> t x \\<or> (\\<exists>y<x. s y \\<noteq> t y)\n\ngoal (1 subgoal):\n 1. (s + u) x \\<le> (t + u) x \\<or>\n    (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s x \\<le> t x \\<Longrightarrow>\n    (s + u) x \\<le> (t + u) x \\<or>\n    (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)\n 2. \\<exists>y<x. s y \\<noteq> t y \\<Longrightarrow>\n    (s + u) x \\<le> (t + u) x \\<or>\n    (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "assume a1: \"s x \\<le> t x\""], ["proof (state)\nthis:\n  s x \\<le> t x\n\ngoal (2 subgoals):\n 1. s x \\<le> t x \\<Longrightarrow>\n    (s + u) x \\<le> (t + u) x \\<or>\n    (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)\n 2. \\<exists>y<x. s y \\<noteq> t y \\<Longrightarrow>\n    (s + u) x \\<le> (t + u) x \\<or>\n    (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s + u) x \\<le> (t + u) x \\<or>\n    (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "proof (intro disjI1)"], ["proof (state)\ngoal (1 subgoal):\n 1. (s + u) x \\<le> (t + u) x", "from a1"], ["proof (chain)\npicking this:\n  s x \\<le> t x", "show \"(s + u) x \\<le> (t + u) x\""], ["proof (prove)\nusing this:\n  s x \\<le> t x\n\ngoal (1 subgoal):\n 1. (s + u) x \\<le> (t + u) x", "by (auto simp: add_right_mono)"], ["proof (state)\nthis:\n  (s + u) x \\<le> (t + u) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s + u) x \\<le> (t + u) x \\<or>\n  (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)\n\ngoal (1 subgoal):\n 1. \\<exists>y<x. s y \\<noteq> t y \\<Longrightarrow>\n    (s + u) x \\<le> (t + u) x \\<or>\n    (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y<x. s y \\<noteq> t y \\<Longrightarrow>\n    (s + u) x \\<le> (t + u) x \\<or>\n    (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "assume \"\\<exists>y<x. s y \\<noteq> t y\""], ["proof (state)\nthis:\n  \\<exists>y<x. s y \\<noteq> t y\n\ngoal (1 subgoal):\n 1. \\<exists>y<x. s y \\<noteq> t y \\<Longrightarrow>\n    (s + u) x \\<le> (t + u) x \\<or>\n    (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "then"], ["proof (chain)\npicking this:\n  \\<exists>y<x. s y \\<noteq> t y", "obtain y where \"y < x\" and a2: \"s y \\<noteq> t y\""], ["proof (prove)\nusing this:\n  \\<exists>y<x. s y \\<noteq> t y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y < x; s y \\<noteq> t y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y < x\n  s y \\<noteq> t y\n\ngoal (1 subgoal):\n 1. \\<exists>y<x. s y \\<noteq> t y \\<Longrightarrow>\n    (s + u) x \\<le> (t + u) x \\<or>\n    (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s + u) x \\<le> (t + u) x \\<or>\n    (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)", "proof (intro disjI2, rule exI[of _ y], intro conjI, fact)"], ["proof (state)\ngoal (1 subgoal):\n 1. (s + u) y \\<noteq> (t + u) y", "from a2"], ["proof (chain)\npicking this:\n  s y \\<noteq> t y", "show \"(s + u) y \\<noteq> (t + u) y\""], ["proof (prove)\nusing this:\n  s y \\<noteq> t y\n\ngoal (1 subgoal):\n 1. (s + u) y \\<noteq> (t + u) y", "by (auto simp: add_right_mono)"], ["proof (state)\nthis:\n  (s + u) y \\<noteq> (t + u) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s + u) x \\<le> (t + u) x \\<or>\n  (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s + u) x \\<le> (t + u) x \\<or>\n  (\\<exists>y<x. (s + u) y \\<noteq> (t + u) y)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* wellorder *)"], ["", "subsubsection \\<open>Degree\\<close>"], ["", "definition deg_fun::\"('a \\<Rightarrow> 'b::comm_monoid_add) \\<Rightarrow> 'b\" where \"deg_fun s \\<equiv> \\<Sum>x\\<in>(supp_fun s). s x\""], ["", "lemma deg_fun_zero[simp]: \"deg_fun 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_fun 0 = (0::'a)", "by (auto simp: deg_fun_def)"], ["", "lemma deg_fun_eq_0_iff:\n  assumes \"finite (supp_fun (s::'a \\<Rightarrow> 'b::add_linorder_min))\"\n  shows \"deg_fun s = 0 \\<longleftrightarrow> s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (deg_fun s = (0::'b)) = (s = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_fun s = (0::'b) \\<Longrightarrow> s = 0\n 2. s = 0 \\<Longrightarrow> deg_fun s = (0::'b)", "assume \"deg_fun s = 0\""], ["proof (state)\nthis:\n  deg_fun s = (0::'b)\n\ngoal (2 subgoals):\n 1. deg_fun s = (0::'b) \\<Longrightarrow> s = 0\n 2. s = 0 \\<Longrightarrow> deg_fun s = (0::'b)", "hence *: \"(\\<Sum>x\\<in>(supp_fun s). s x) = 0\""], ["proof (prove)\nusing this:\n  deg_fun s = (0::'b)\n\ngoal (1 subgoal):\n 1. sum s (supp_fun s) = (0::'b)", "by (simp only: deg_fun_def)"], ["proof (state)\nthis:\n  sum s (supp_fun s) = (0::'b)\n\ngoal (2 subgoals):\n 1. deg_fun s = (0::'b) \\<Longrightarrow> s = 0\n 2. s = 0 \\<Longrightarrow> deg_fun s = (0::'b)", "have **: \"\\<And>x. 0 \\<le> s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> s x", "by (rule zero_min)"], ["proof (state)\nthis:\n  (0::'b) \\<le> s ?x\n\ngoal (2 subgoals):\n 1. deg_fun s = (0::'b) \\<Longrightarrow> s = 0\n 2. s = 0 \\<Longrightarrow> deg_fun s = (0::'b)", "from *"], ["proof (chain)\npicking this:\n  sum s (supp_fun s) = (0::'b)", "have \"\\<And>x. x \\<in> supp_fun s \\<Longrightarrow> s x = 0\""], ["proof (prove)\nusing this:\n  sum s (supp_fun s) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> supp_fun s \\<Longrightarrow> s x = (0::'b)", "by (simp only: sum_nonneg_eq_0_iff[OF assms **])"], ["proof (state)\nthis:\n  ?x \\<in> supp_fun s \\<Longrightarrow> s ?x = (0::'b)\n\ngoal (2 subgoals):\n 1. deg_fun s = (0::'b) \\<Longrightarrow> s = 0\n 2. s = 0 \\<Longrightarrow> deg_fun s = (0::'b)", "thus \"s = 0\""], ["proof (prove)\nusing this:\n  ?x \\<in> supp_fun s \\<Longrightarrow> s ?x = (0::'b)\n\ngoal (1 subgoal):\n 1. s = 0", "by (rule fun_eq_zeroI)"], ["proof (state)\nthis:\n  s = 0\n\ngoal (1 subgoal):\n 1. s = 0 \\<Longrightarrow> deg_fun s = (0::'b)", "qed simp"], ["", "lemma deg_fun_superset:\n  fixes A::\"'a set\"\n  assumes \"supp_fun s \\<subseteq> A\" and \"finite A\"\n  shows \"deg_fun s = (\\<Sum>x\\<in>A. s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_fun s = sum s A", "unfolding deg_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum s (supp_fun s) = sum s A", "proof (rule sum.mono_neutral_cong_left, fact, fact, rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A - supp_fun s \\<Longrightarrow> s i = (0::'b)\n 2. \\<And>x. x \\<in> supp_fun s \\<Longrightarrow> s x = s x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A - supp_fun s \\<Longrightarrow> s i = (0::'b)\n 2. \\<And>x. x \\<in> supp_fun s \\<Longrightarrow> s x = s x", "assume \"x \\<in> A - supp_fun s\""], ["proof (state)\nthis:\n  x \\<in> A - supp_fun s\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A - supp_fun s \\<Longrightarrow> s i = (0::'b)\n 2. \\<And>x. x \\<in> supp_fun s \\<Longrightarrow> s x = s x", "hence \"x \\<notin> supp_fun s\""], ["proof (prove)\nusing this:\n  x \\<in> A - supp_fun s\n\ngoal (1 subgoal):\n 1. x \\<notin> supp_fun s", "by simp"], ["proof (state)\nthis:\n  x \\<notin> supp_fun s\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A - supp_fun s \\<Longrightarrow> s i = (0::'b)\n 2. \\<And>x. x \\<in> supp_fun s \\<Longrightarrow> s x = s x", "thus \"s x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> supp_fun s\n\ngoal (1 subgoal):\n 1. s x = (0::'b)", "by (simp add: supp_fun_def)"], ["proof (state)\nthis:\n  s x = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> supp_fun s \\<Longrightarrow> s x = s x", "qed rule"], ["", "lemma deg_fun_plus:\n  assumes \"finite (supp_fun s)\" and \"finite (supp_fun t)\"\n  shows \"deg_fun (s + t) = deg_fun s + deg_fun (t::'a \\<Rightarrow> 'b::comm_monoid_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "from assms"], ["proof (chain)\npicking this:\n  finite (supp_fun s)\n  finite (supp_fun t)", "have fin: \"finite (supp_fun s \\<union> supp_fun t)\""], ["proof (prove)\nusing this:\n  finite (supp_fun s)\n  finite (supp_fun t)\n\ngoal (1 subgoal):\n 1. finite (supp_fun s \\<union> supp_fun t)", "by simp"], ["proof (state)\nthis:\n  finite (supp_fun s \\<union> supp_fun t)\n\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "have \"deg_fun (s + t) = (\\<Sum>x\\<in>(supp_fun (s + t)). s x + t x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_fun (s + t) = (\\<Sum>x\\<in>supp_fun (s + t). s x + t x)", "by (simp add: deg_fun_def)"], ["proof (state)\nthis:\n  deg_fun (s + t) = (\\<Sum>x\\<in>supp_fun (s + t). s x + t x)\n\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "also"], ["proof (state)\nthis:\n  deg_fun (s + t) = (\\<Sum>x\\<in>supp_fun (s + t). s x + t x)\n\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "from fin"], ["proof (chain)\npicking this:\n  finite (supp_fun s \\<union> supp_fun t)", "have \"... = (\\<Sum>x\\<in>(supp_fun s \\<union> supp_fun t). s x + t x)\""], ["proof (prove)\nusing this:\n  finite (supp_fun s \\<union> supp_fun t)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>supp_fun (s + t). s x + t x) =\n    (\\<Sum>x\\<in>supp_fun s \\<union> supp_fun t. s x + t x)", "proof (rule sum.mono_neutral_cong_left)"], ["proof (state)\ngoal (3 subgoals):\n 1. supp_fun (s + t) \\<subseteq> supp_fun s \\<union> supp_fun t\n 2. \\<forall>i\\<in>supp_fun s \\<union> supp_fun t - supp_fun (s + t).\n       s i + t i = (0::'b)\n 3. \\<And>x.\n       x \\<in> supp_fun (s + t) \\<Longrightarrow> s x + t x = s x + t x", "show \"\\<forall>x\\<in>supp_fun s \\<union> supp_fun t - supp_fun (s + t). s x + t x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>supp_fun s \\<union> supp_fun t - supp_fun (s + t).\n       s x + t x = (0::'b)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t -\n               supp_fun (s + t) \\<Longrightarrow>\n       s x + t x = (0::'b)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t -\n               supp_fun (s + t) \\<Longrightarrow>\n       s x + t x = (0::'b)", "assume \"x \\<in> supp_fun s \\<union> supp_fun t - supp_fun (s + t)\""], ["proof (state)\nthis:\n  x \\<in> supp_fun s \\<union> supp_fun t - supp_fun (s + t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t -\n               supp_fun (s + t) \\<Longrightarrow>\n       s x + t x = (0::'b)", "hence \"x \\<notin> supp_fun (s + t)\""], ["proof (prove)\nusing this:\n  x \\<in> supp_fun s \\<union> supp_fun t - supp_fun (s + t)\n\ngoal (1 subgoal):\n 1. x \\<notin> supp_fun (s + t)", "by simp"], ["proof (state)\nthis:\n  x \\<notin> supp_fun (s + t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t -\n               supp_fun (s + t) \\<Longrightarrow>\n       s x + t x = (0::'b)", "thus \"s x + t x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> supp_fun (s + t)\n\ngoal (1 subgoal):\n 1. s x + t x = (0::'b)", "by (simp add: supp_fun_def)"], ["proof (state)\nthis:\n  s x + t x = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>supp_fun s \\<union> supp_fun t - supp_fun (s + t).\n     s x + t x = (0::'b)\n\ngoal (2 subgoals):\n 1. supp_fun (s + t) \\<subseteq> supp_fun s \\<union> supp_fun t\n 2. \\<And>x.\n       x \\<in> supp_fun (s + t) \\<Longrightarrow> s x + t x = s x + t x", "qed (rule supp_fun_plus_subset, rule)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>supp_fun (s + t). s x + t x) =\n  (\\<Sum>x\\<in>supp_fun s \\<union> supp_fun t. s x + t x)\n\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>supp_fun (s + t). s x + t x) =\n  (\\<Sum>x\\<in>supp_fun s \\<union> supp_fun t. s x + t x)\n\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "have \"\\<dots> = (\\<Sum>x\\<in>(supp_fun s \\<union> supp_fun t). s x) + (\\<Sum>x\\<in>(supp_fun s \\<union> supp_fun t). t x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>supp_fun s \\<union> supp_fun t. s x + t x) =\n    sum s (supp_fun s \\<union> supp_fun t) +\n    sum t (supp_fun s \\<union> supp_fun t)", "by (rule sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>supp_fun s \\<union> supp_fun t. s x + t x) =\n  sum s (supp_fun s \\<union> supp_fun t) +\n  sum t (supp_fun s \\<union> supp_fun t)\n\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>supp_fun s \\<union> supp_fun t. s x + t x) =\n  sum s (supp_fun s \\<union> supp_fun t) +\n  sum t (supp_fun s \\<union> supp_fun t)\n\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "from fin"], ["proof (chain)\npicking this:\n  finite (supp_fun s \\<union> supp_fun t)", "have \"(\\<Sum>x\\<in>(supp_fun s \\<union> supp_fun t). s x) = deg_fun s\""], ["proof (prove)\nusing this:\n  finite (supp_fun s \\<union> supp_fun t)\n\ngoal (1 subgoal):\n 1. sum s (supp_fun s \\<union> supp_fun t) = deg_fun s", "unfolding deg_fun_def"], ["proof (prove)\nusing this:\n  finite (supp_fun s \\<union> supp_fun t)\n\ngoal (1 subgoal):\n 1. sum s (supp_fun s \\<union> supp_fun t) = sum s (supp_fun s)", "proof (rule sum.mono_neutral_cong_right)"], ["proof (state)\ngoal (3 subgoals):\n 1. supp_fun s \\<subseteq> supp_fun s \\<union> supp_fun t\n 2. \\<forall>i\\<in>supp_fun s \\<union> supp_fun t - supp_fun s.\n       s i = (0::'b)\n 3. \\<And>x. x \\<in> supp_fun s \\<Longrightarrow> s x = s x", "show \"\\<forall>x\\<in>supp_fun s \\<union> supp_fun t - supp_fun s. s x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>supp_fun s \\<union> supp_fun t - supp_fun s.\n       s x = (0::'b)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t - supp_fun s \\<Longrightarrow>\n       s x = (0::'b)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t - supp_fun s \\<Longrightarrow>\n       s x = (0::'b)", "assume \"x \\<in> supp_fun s \\<union> supp_fun t - supp_fun s\""], ["proof (state)\nthis:\n  x \\<in> supp_fun s \\<union> supp_fun t - supp_fun s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t - supp_fun s \\<Longrightarrow>\n       s x = (0::'b)", "hence \"x \\<notin> supp_fun s\""], ["proof (prove)\nusing this:\n  x \\<in> supp_fun s \\<union> supp_fun t - supp_fun s\n\ngoal (1 subgoal):\n 1. x \\<notin> supp_fun s", "by simp"], ["proof (state)\nthis:\n  x \\<notin> supp_fun s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t - supp_fun s \\<Longrightarrow>\n       s x = (0::'b)", "thus \"s x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> supp_fun s\n\ngoal (1 subgoal):\n 1. s x = (0::'b)", "by (simp add: supp_fun_def)"], ["proof (state)\nthis:\n  s x = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>supp_fun s \\<union> supp_fun t - supp_fun s. s x = (0::'b)\n\ngoal (2 subgoals):\n 1. supp_fun s \\<subseteq> supp_fun s \\<union> supp_fun t\n 2. \\<And>x. x \\<in> supp_fun s \\<Longrightarrow> s x = s x", "qed simp_all"], ["proof (state)\nthis:\n  sum s (supp_fun s \\<union> supp_fun t) = deg_fun s\n\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "also"], ["proof (state)\nthis:\n  sum s (supp_fun s \\<union> supp_fun t) = deg_fun s\n\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "from fin"], ["proof (chain)\npicking this:\n  finite (supp_fun s \\<union> supp_fun t)", "have \"(\\<Sum>x\\<in>(supp_fun s \\<union> supp_fun t). t x) = deg_fun t\""], ["proof (prove)\nusing this:\n  finite (supp_fun s \\<union> supp_fun t)\n\ngoal (1 subgoal):\n 1. sum t (supp_fun s \\<union> supp_fun t) = deg_fun t", "unfolding deg_fun_def"], ["proof (prove)\nusing this:\n  finite (supp_fun s \\<union> supp_fun t)\n\ngoal (1 subgoal):\n 1. sum t (supp_fun s \\<union> supp_fun t) = sum t (supp_fun t)", "proof (rule sum.mono_neutral_cong_right)"], ["proof (state)\ngoal (3 subgoals):\n 1. supp_fun t \\<subseteq> supp_fun s \\<union> supp_fun t\n 2. \\<forall>i\\<in>supp_fun s \\<union> supp_fun t - supp_fun t.\n       t i = (0::'b)\n 3. \\<And>x. x \\<in> supp_fun t \\<Longrightarrow> t x = t x", "show \"\\<forall>x\\<in>supp_fun s \\<union> supp_fun t - supp_fun t. t x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>supp_fun s \\<union> supp_fun t - supp_fun t.\n       t x = (0::'b)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t - supp_fun t \\<Longrightarrow>\n       t x = (0::'b)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t - supp_fun t \\<Longrightarrow>\n       t x = (0::'b)", "assume \"x \\<in> supp_fun s \\<union> supp_fun t - supp_fun t\""], ["proof (state)\nthis:\n  x \\<in> supp_fun s \\<union> supp_fun t - supp_fun t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t - supp_fun t \\<Longrightarrow>\n       t x = (0::'b)", "hence \"x \\<notin> supp_fun t\""], ["proof (prove)\nusing this:\n  x \\<in> supp_fun s \\<union> supp_fun t - supp_fun t\n\ngoal (1 subgoal):\n 1. x \\<notin> supp_fun t", "by simp"], ["proof (state)\nthis:\n  x \\<notin> supp_fun t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp_fun s \\<union> supp_fun t - supp_fun t \\<Longrightarrow>\n       t x = (0::'b)", "thus \"t x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> supp_fun t\n\ngoal (1 subgoal):\n 1. t x = (0::'b)", "by (simp add: supp_fun_def)"], ["proof (state)\nthis:\n  t x = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>supp_fun s \\<union> supp_fun t - supp_fun t. t x = (0::'b)\n\ngoal (2 subgoals):\n 1. supp_fun t \\<subseteq> supp_fun s \\<union> supp_fun t\n 2. \\<And>x. x \\<in> supp_fun t \\<Longrightarrow> t x = t x", "qed simp_all"], ["proof (state)\nthis:\n  sum t (supp_fun s \\<union> supp_fun t) = deg_fun t\n\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "finally"], ["proof (chain)\npicking this:\n  deg_fun (s + t) = deg_fun s + deg_fun t", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_fun (s + t) = deg_fun s + deg_fun t\n\ngoal (1 subgoal):\n 1. deg_fun (s + t) = deg_fun s + deg_fun t", "."], ["proof (state)\nthis:\n  deg_fun (s + t) = deg_fun s + deg_fun t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deg_fun_leq:\n  assumes \"finite (supp_fun s)\" and \"finite (supp_fun t)\" and \"s \\<le> (t::'a \\<Rightarrow> 'b::ordered_comm_monoid_add)\"\n  shows \"deg_fun s \\<le> deg_fun t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t", "let ?A = \"supp_fun s \\<union> supp_fun t\""], ["proof (state)\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t", "from assms(1) assms(2)"], ["proof (chain)\npicking this:\n  finite (supp_fun s)\n  finite (supp_fun t)", "have 1: \"finite ?A\""], ["proof (prove)\nusing this:\n  finite (supp_fun s)\n  finite (supp_fun t)\n\ngoal (1 subgoal):\n 1. finite (supp_fun s \\<union> supp_fun t)", "by simp"], ["proof (state)\nthis:\n  finite (supp_fun s \\<union> supp_fun t)\n\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t", "have s: \"supp_fun s \\<subseteq> ?A\" and t: \"supp_fun t \\<subseteq> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp_fun s \\<subseteq> supp_fun s \\<union> supp_fun t &&&\n    supp_fun t \\<subseteq> supp_fun s \\<union> supp_fun t", "by simp_all"], ["proof (state)\nthis:\n  supp_fun s \\<subseteq> supp_fun s \\<union> supp_fun t\n  supp_fun t \\<subseteq> supp_fun s \\<union> supp_fun t\n\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t", "unfolding deg_fun_superset[OF s 1] deg_fun_superset[OF t 1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum s (supp_fun s \\<union> supp_fun t)\n    \\<le> sum t (supp_fun s \\<union> supp_fun t)", "proof (rule sum_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> supp_fun s \\<union> supp_fun t \\<Longrightarrow>\n       s i \\<le> t i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> supp_fun s \\<union> supp_fun t \\<Longrightarrow>\n       s i \\<le> t i", "from assms(3)"], ["proof (chain)\npicking this:\n  s \\<le> t", "show \"s i \\<le> t i\""], ["proof (prove)\nusing this:\n  s \\<le> t\n\ngoal (1 subgoal):\n 1. s i \\<le> t i", "unfolding le_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x. s x \\<le> t x\n\ngoal (1 subgoal):\n 1. s i \\<le> t i", ".."], ["proof (state)\nthis:\n  s i \\<le> t i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_fun s \\<le> deg_fun t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>General Degree-Orders\\<close>"], ["", "context linorder\nbegin"], ["", "lemma ex_min:\n  assumes \"finite (A::'a set)\" and \"A \\<noteq> {}\"\n  shows \"\\<exists>y\\<in>A. (\\<forall>z\\<in>A. y \\<le> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. \\<forall>z\\<in>A. y \\<le> z", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. \\<forall>z\\<in>A. y \\<le> z", "proof (induct rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> \\<exists>y\\<in>{}. Ball {} ((\\<le>) y)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow>\n        \\<exists>y\\<in>F. Ball F ((\\<le>) y);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>insert x F.\n                            Ball (insert x F) ((\\<le>) y)", "assume \"{} \\<noteq> {}\""], ["proof (state)\nthis:\n  {} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> \\<exists>y\\<in>{}. Ball {} ((\\<le>) y)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow>\n        \\<exists>y\\<in>F. Ball F ((\\<le>) y);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>insert x F.\n                            Ball (insert x F) ((\\<le>) y)", "thus \"\\<exists>y\\<in>{}. \\<forall>z\\<in>{}. y \\<le> z\""], ["proof (prove)\nusing this:\n  {} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>{}. \\<forall>z\\<in>{}. y \\<le> z", "by simp"], ["proof (state)\nthis:\n  \\<exists>y\\<in>{}. \\<forall>z\\<in>{}. y \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow>\n        \\<exists>y\\<in>F. Ball F ((\\<le>) y);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>insert x F.\n                            Ball (insert x F) ((\\<le>) y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow>\n        \\<exists>y\\<in>F. Ball F ((\\<le>) y);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>insert x F.\n                            Ball (insert x F) ((\\<le>) y)", "fix a::'a and A::\"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow>\n        \\<exists>y\\<in>F. Ball F ((\\<le>) y);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>insert x F.\n                            Ball (insert x F) ((\\<le>) y)", "assume \"a \\<notin> A\" and IH: \"A \\<noteq> {} \\<Longrightarrow> \\<exists>y\\<in>A. (\\<forall>z\\<in>A. y \\<le> z)\""], ["proof (state)\nthis:\n  a \\<notin> A\n  A \\<noteq> {} \\<Longrightarrow>\n  \\<exists>y\\<in>A. \\<forall>z\\<in>A. y \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow>\n        \\<exists>y\\<in>F. Ball F ((\\<le>) y);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>insert x F.\n                            Ball (insert x F) ((\\<le>) y)", "show \"\\<exists>y\\<in>insert a A. (\\<forall>z\\<in>insert a A. y \\<le> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "proof (cases \"A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z\n 2. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "case True"], ["proof (state)\nthis:\n  A = {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z\n 2. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "proof (rule bexI[of _ a], intro ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> a \\<le> z\n 2. a \\<in> insert a A", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> a \\<le> z\n 2. a \\<in> insert a A", "assume \"z \\<in> insert a A\""], ["proof (state)\nthis:\n  z \\<in> insert a A\n\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> a \\<le> z\n 2. a \\<in> insert a A", "from this True"], ["proof (chain)\npicking this:\n  z \\<in> insert a A\n  A = {}", "have \"z = a\""], ["proof (prove)\nusing this:\n  z \\<in> insert a A\n  A = {}\n\ngoal (1 subgoal):\n 1. z = a", "by simp"], ["proof (state)\nthis:\n  z = a\n\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> a \\<le> z\n 2. a \\<in> insert a A", "thus \"a \\<le> z\""], ["proof (prove)\nusing this:\n  z = a\n\ngoal (1 subgoal):\n 1. a \\<le> z", "by simp"], ["proof (state)\nthis:\n  a \\<le> z\n\ngoal (1 subgoal):\n 1. a \\<in> insert a A", "qed (simp)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "case False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "from IH[OF False]"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>A. \\<forall>z\\<in>A. y \\<le> z", "obtain y where \"y \\<in> A\" and y_min: \"\\<forall>z\\<in>A. y \\<le> z\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>A. \\<forall>z\\<in>A. y \\<le> z\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> A; \\<forall>z\\<in>A. y \\<le> z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> A\n  \\<forall>z\\<in>A. y \\<le> z\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "from linear[of a y]"], ["proof (chain)\npicking this:\n  a \\<le> y \\<or> y \\<le> a", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> y \\<or> y \\<le> a\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> y \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z\n 2. y \\<le> a \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "assume \"y \\<le> a\""], ["proof (state)\nthis:\n  y \\<le> a\n\ngoal (2 subgoals):\n 1. a \\<le> y \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z\n 2. y \\<le> a \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "proof (rule bexI[of _ y], intro ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> y \\<le> z\n 2. y \\<in> insert a A", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> y \\<le> z\n 2. y \\<in> insert a A", "assume \"z \\<in> insert a A\""], ["proof (state)\nthis:\n  z \\<in> insert a A\n\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> y \\<le> z\n 2. y \\<in> insert a A", "hence \"z = a \\<or> z \\<in> A\""], ["proof (prove)\nusing this:\n  z \\<in> insert a A\n\ngoal (1 subgoal):\n 1. z = a \\<or> z \\<in> A", "by simp"], ["proof (state)\nthis:\n  z = a \\<or> z \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> y \\<le> z\n 2. y \\<in> insert a A", "thus \"y \\<le> z\""], ["proof (prove)\nusing this:\n  z = a \\<or> z \\<in> A\n\ngoal (1 subgoal):\n 1. y \\<le> z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z = a \\<Longrightarrow> y \\<le> z\n 2. z \\<in> A \\<Longrightarrow> y \\<le> z", "assume \"z = a\""], ["proof (state)\nthis:\n  z = a\n\ngoal (2 subgoals):\n 1. z = a \\<Longrightarrow> y \\<le> z\n 2. z \\<in> A \\<Longrightarrow> y \\<le> z", "from this \\<open>y \\<le> a\\<close>"], ["proof (chain)\npicking this:\n  z = a\n  y \\<le> a", "show \"y \\<le> z\""], ["proof (prove)\nusing this:\n  z = a\n  y \\<le> a\n\ngoal (1 subgoal):\n 1. y \\<le> z", "by simp"], ["proof (state)\nthis:\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. z \\<in> A \\<Longrightarrow> y \\<le> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> A \\<Longrightarrow> y \\<le> z", "assume \"z \\<in> A\""], ["proof (state)\nthis:\n  z \\<in> A\n\ngoal (1 subgoal):\n 1. z \\<in> A \\<Longrightarrow> y \\<le> z", "from y_min[rule_format, OF this]"], ["proof (chain)\npicking this:\n  y \\<le> z", "show \"y \\<le> z\""], ["proof (prove)\nusing this:\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. y \\<le> z", "."], ["proof (state)\nthis:\n  y \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. y \\<in> insert a A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> insert a A", "from \\<open>y \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> A", "show \"y \\<in> insert a A\""], ["proof (prove)\nusing this:\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. y \\<in> insert a A", "by simp"], ["proof (state)\nthis:\n  y \\<in> insert a A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z\n\ngoal (1 subgoal):\n 1. a \\<le> y \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<le> y \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "assume \"a \\<le> y\""], ["proof (state)\nthis:\n  a \\<le> y\n\ngoal (1 subgoal):\n 1. a \\<le> y \\<Longrightarrow>\n    \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z", "proof (rule bexI[of _ a], intro ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> a \\<le> z\n 2. a \\<in> insert a A", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> a \\<le> z\n 2. a \\<in> insert a A", "assume \"z \\<in> insert a A\""], ["proof (state)\nthis:\n  z \\<in> insert a A\n\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> a \\<le> z\n 2. a \\<in> insert a A", "hence \"z = a \\<or> z \\<in> A\""], ["proof (prove)\nusing this:\n  z \\<in> insert a A\n\ngoal (1 subgoal):\n 1. z = a \\<or> z \\<in> A", "by simp"], ["proof (state)\nthis:\n  z = a \\<or> z \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> insert a A \\<Longrightarrow> a \\<le> z\n 2. a \\<in> insert a A", "thus \"a \\<le> z\""], ["proof (prove)\nusing this:\n  z = a \\<or> z \\<in> A\n\ngoal (1 subgoal):\n 1. a \\<le> z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z = a \\<Longrightarrow> a \\<le> z\n 2. z \\<in> A \\<Longrightarrow> a \\<le> z", "assume \"z = a\""], ["proof (state)\nthis:\n  z = a\n\ngoal (2 subgoals):\n 1. z = a \\<Longrightarrow> a \\<le> z\n 2. z \\<in> A \\<Longrightarrow> a \\<le> z", "from this"], ["proof (chain)\npicking this:\n  z = a", "show \"a \\<le> z\""], ["proof (prove)\nusing this:\n  z = a\n\ngoal (1 subgoal):\n 1. a \\<le> z", "by simp"], ["proof (state)\nthis:\n  a \\<le> z\n\ngoal (1 subgoal):\n 1. z \\<in> A \\<Longrightarrow> a \\<le> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> A \\<Longrightarrow> a \\<le> z", "assume \"z \\<in> A\""], ["proof (state)\nthis:\n  z \\<in> A\n\ngoal (1 subgoal):\n 1. z \\<in> A \\<Longrightarrow> a \\<le> z", "from y_min[rule_format, OF this] \\<open>a \\<le> y\\<close>"], ["proof (chain)\npicking this:\n  y \\<le> z\n  a \\<le> y", "show \"a \\<le> z\""], ["proof (prove)\nusing this:\n  y \\<le> z\n  a \\<le> y\n\ngoal (1 subgoal):\n 1. a \\<le> z", "by simp"], ["proof (state)\nthis:\n  a \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<le> z\n\ngoal (1 subgoal):\n 1. a \\<in> insert a A", "qed (simp)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y\\<in>insert a A. \\<forall>z\\<in>insert a A. y \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["", "definition dord_fun::\"(('a \\<Rightarrow> 'b::ordered_comm_monoid_add) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> bool\"\n  where \"dord_fun ord s t \\<equiv> (let d1 = deg_fun s; d2 = deg_fun t in (d1 < d2 \\<or> (d1 = d2 \\<and> ord s t)))\""], ["", "lemma dord_fun_degD:\n  assumes \"dord_fun ord s t\"\n  shows \"deg_fun s \\<le> deg_fun t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t", "using assms"], ["proof (prove)\nusing this:\n  dord_fun ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t", "unfolding dord_fun_def Let_def"], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t", "by auto"], ["", "lemma dord_fun_refl:\n  assumes \"ord s s\"\n  shows \"dord_fun ord s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun ord s s", "using assms"], ["proof (prove)\nusing this:\n  ord s s\n\ngoal (1 subgoal):\n 1. dord_fun ord s s", "unfolding dord_fun_def"], ["proof (prove)\nusing this:\n  ord s s\n\ngoal (1 subgoal):\n 1. let d1 = deg_fun s; d2 = deg_fun s\n    in d1 < d2 \\<or> d1 = d2 \\<and> ord s s", "by simp"], ["", "lemma dord_fun_antisym:\n  assumes ord_antisym: \"ord s t \\<Longrightarrow> ord t s \\<Longrightarrow> s = t\" and \"dord_fun ord s t\" and \"dord_fun ord t s\"\n  shows \"s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s = t", "from assms(3)"], ["proof (chain)\npicking this:\n  dord_fun ord t s", "have ts: \"deg_fun t < deg_fun s \\<or> (deg_fun t = deg_fun s \\<and> ord t s)\""], ["proof (prove)\nusing this:\n  dord_fun ord t s\n\ngoal (1 subgoal):\n 1. deg_fun t < deg_fun s \\<or> deg_fun t = deg_fun s \\<and> ord t s", "unfolding dord_fun_def Let_def"], ["proof (prove)\nusing this:\n  deg_fun t < deg_fun s \\<or> deg_fun t = deg_fun s \\<and> ord t s\n\ngoal (1 subgoal):\n 1. deg_fun t < deg_fun s \\<or> deg_fun t = deg_fun s \\<and> ord t s", "."], ["proof (state)\nthis:\n  deg_fun t < deg_fun s \\<or> deg_fun t = deg_fun s \\<and> ord t s\n\ngoal (1 subgoal):\n 1. s = t", "from assms(2)"], ["proof (chain)\npicking this:\n  dord_fun ord s t", "have st: \"deg_fun s < deg_fun t \\<or> (deg_fun s = deg_fun t \\<and> ord s t)\""], ["proof (prove)\nusing this:\n  dord_fun ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t", "unfolding dord_fun_def Let_def"], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t", "."], ["proof (state)\nthis:\n  deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. s = t", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. s = t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_fun s < deg_fun t \\<Longrightarrow> s = t\n 2. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> s = t", "assume \"deg_fun s < deg_fun t\""], ["proof (state)\nthis:\n  deg_fun s < deg_fun t\n\ngoal (2 subgoals):\n 1. deg_fun s < deg_fun t \\<Longrightarrow> s = t\n 2. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> s = t", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun t\n\ngoal (1 subgoal):\n 1. s = t", "using ts"], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun t\n  deg_fun t < deg_fun s \\<or> deg_fun t = deg_fun s \\<and> ord t s\n\ngoal (1 subgoal):\n 1. s = t", "by auto"], ["proof (state)\nthis:\n  s = t\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> s = t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> s = t", "assume \"deg_fun s = deg_fun t \\<and> ord s t\""], ["proof (state)\nthis:\n  deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> s = t", "hence \"deg_fun s = deg_fun t\" and \"ord s t\""], ["proof (prove)\nusing this:\n  deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t &&& ord s t", "by simp_all"], ["proof (state)\nthis:\n  deg_fun s = deg_fun t\n  ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> s = t", "from \\<open>deg_fun s = deg_fun t\\<close> ts"], ["proof (chain)\npicking this:\n  deg_fun s = deg_fun t\n  deg_fun t < deg_fun s \\<or> deg_fun t = deg_fun s \\<and> ord t s", "have \"ord t s\""], ["proof (prove)\nusing this:\n  deg_fun s = deg_fun t\n  deg_fun t < deg_fun s \\<or> deg_fun t = deg_fun s \\<and> ord t s\n\ngoal (1 subgoal):\n 1. ord t s", "by simp"], ["proof (state)\nthis:\n  ord t s\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> s = t", "with \\<open>ord s t\\<close>"], ["proof (chain)\npicking this:\n  ord s t\n  ord t s", "show ?thesis"], ["proof (prove)\nusing this:\n  ord s t\n  ord t s\n\ngoal (1 subgoal):\n 1. s = t", "by (rule ord_antisym)"], ["proof (state)\nthis:\n  s = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dord_fun_trans:\n  assumes ord_trans: \"ord s t \\<Longrightarrow> ord t u \\<Longrightarrow> ord s u\" and \"dord_fun ord s t\" and \"dord_fun ord t u\"\n  shows \"dord_fun ord s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun ord s u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dord_fun ord s u", "from assms(3)"], ["proof (chain)\npicking this:\n  dord_fun ord t u", "have ts: \"deg_fun t < deg_fun u \\<or> (deg_fun t = deg_fun u \\<and> ord t u)\""], ["proof (prove)\nusing this:\n  dord_fun ord t u\n\ngoal (1 subgoal):\n 1. deg_fun t < deg_fun u \\<or> deg_fun t = deg_fun u \\<and> ord t u", "unfolding dord_fun_def Let_def"], ["proof (prove)\nusing this:\n  deg_fun t < deg_fun u \\<or> deg_fun t = deg_fun u \\<and> ord t u\n\ngoal (1 subgoal):\n 1. deg_fun t < deg_fun u \\<or> deg_fun t = deg_fun u \\<and> ord t u", "."], ["proof (state)\nthis:\n  deg_fun t < deg_fun u \\<or> deg_fun t = deg_fun u \\<and> ord t u\n\ngoal (1 subgoal):\n 1. dord_fun ord s u", "from assms(2)"], ["proof (chain)\npicking this:\n  dord_fun ord s t", "have st: \"deg_fun s < deg_fun t \\<or> (deg_fun s = deg_fun t \\<and> ord s t)\""], ["proof (prove)\nusing this:\n  dord_fun ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t", "unfolding dord_fun_def Let_def"], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t", "."], ["proof (state)\nthis:\n  deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. dord_fun ord s u", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. dord_fun ord s u", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_fun s < deg_fun t \\<Longrightarrow> dord_fun ord s u\n 2. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> dord_fun ord s u", "assume \"deg_fun s < deg_fun t\""], ["proof (state)\nthis:\n  deg_fun s < deg_fun t\n\ngoal (2 subgoals):\n 1. deg_fun s < deg_fun t \\<Longrightarrow> dord_fun ord s u\n 2. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> dord_fun ord s u", "from this dord_fun_degD[OF assms(3)]"], ["proof (chain)\npicking this:\n  deg_fun s < deg_fun t\n  deg_fun t \\<le> deg_fun u", "have \"deg_fun s < deg_fun u\""], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun t\n  deg_fun t \\<le> deg_fun u\n\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun u", "by simp"], ["proof (state)\nthis:\n  deg_fun s < deg_fun u\n\ngoal (2 subgoals):\n 1. deg_fun s < deg_fun t \\<Longrightarrow> dord_fun ord s u\n 2. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> dord_fun ord s u", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun u\n\ngoal (1 subgoal):\n 1. dord_fun ord s u", "by (simp add: dord_fun_def Let_def)"], ["proof (state)\nthis:\n  dord_fun ord s u\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> dord_fun ord s u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> dord_fun ord s u", "assume \"deg_fun s = deg_fun t \\<and> ord s t\""], ["proof (state)\nthis:\n  deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> dord_fun ord s u", "hence \"deg_fun s = deg_fun t\" and \"ord s t\""], ["proof (prove)\nusing this:\n  deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t &&& ord s t", "by simp_all"], ["proof (state)\nthis:\n  deg_fun s = deg_fun t\n  ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow> dord_fun ord s u", "from ts"], ["proof (chain)\npicking this:\n  deg_fun t < deg_fun u \\<or> deg_fun t = deg_fun u \\<and> ord t u", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_fun t < deg_fun u \\<or> deg_fun t = deg_fun u \\<and> ord t u\n\ngoal (1 subgoal):\n 1. dord_fun ord s u", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_fun t < deg_fun u \\<Longrightarrow> dord_fun ord s u\n 2. deg_fun t = deg_fun u \\<and> ord t u \\<Longrightarrow> dord_fun ord s u", "assume \"deg_fun t < deg_fun u\""], ["proof (state)\nthis:\n  deg_fun t < deg_fun u\n\ngoal (2 subgoals):\n 1. deg_fun t < deg_fun u \\<Longrightarrow> dord_fun ord s u\n 2. deg_fun t = deg_fun u \\<and> ord t u \\<Longrightarrow> dord_fun ord s u", "hence \"deg_fun s < deg_fun u\""], ["proof (prove)\nusing this:\n  deg_fun t < deg_fun u\n\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun u", "using \\<open>deg_fun s = deg_fun t\\<close>"], ["proof (prove)\nusing this:\n  deg_fun t < deg_fun u\n  deg_fun s = deg_fun t\n\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun u", "by simp"], ["proof (state)\nthis:\n  deg_fun s < deg_fun u\n\ngoal (2 subgoals):\n 1. deg_fun t < deg_fun u \\<Longrightarrow> dord_fun ord s u\n 2. deg_fun t = deg_fun u \\<and> ord t u \\<Longrightarrow> dord_fun ord s u", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun u\n\ngoal (1 subgoal):\n 1. dord_fun ord s u", "by (simp add: dord_fun_def Let_def)"], ["proof (state)\nthis:\n  dord_fun ord s u\n\ngoal (1 subgoal):\n 1. deg_fun t = deg_fun u \\<and> ord t u \\<Longrightarrow> dord_fun ord s u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_fun t = deg_fun u \\<and> ord t u \\<Longrightarrow> dord_fun ord s u", "assume \"deg_fun t = deg_fun u \\<and> ord t u\""], ["proof (state)\nthis:\n  deg_fun t = deg_fun u \\<and> ord t u\n\ngoal (1 subgoal):\n 1. deg_fun t = deg_fun u \\<and> ord t u \\<Longrightarrow> dord_fun ord s u", "hence \"deg_fun t = deg_fun u\" and \"ord t u\""], ["proof (prove)\nusing this:\n  deg_fun t = deg_fun u \\<and> ord t u\n\ngoal (1 subgoal):\n 1. deg_fun t = deg_fun u &&& ord t u", "by simp_all"], ["proof (state)\nthis:\n  deg_fun t = deg_fun u\n  ord t u\n\ngoal (1 subgoal):\n 1. deg_fun t = deg_fun u \\<and> ord t u \\<Longrightarrow> dord_fun ord s u", "from ord_trans[OF \\<open>ord s t\\<close> \\<open>ord t u\\<close>] \\<open>deg_fun s = deg_fun t\\<close> \\<open>deg_fun t = deg_fun u\\<close>"], ["proof (chain)\npicking this:\n  ord s u\n  deg_fun s = deg_fun t\n  deg_fun t = deg_fun u", "show ?thesis"], ["proof (prove)\nusing this:\n  ord s u\n  deg_fun s = deg_fun t\n  deg_fun t = deg_fun u\n\ngoal (1 subgoal):\n 1. dord_fun ord s u", "by (simp add: dord_fun_def Let_def)"], ["proof (state)\nthis:\n  dord_fun ord s u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dord_fun ord s u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dord_fun ord s u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dord_fun_lin:\n  \"dord_fun ord s t \\<or> dord_fun ord t s\"\n  if \"ord s t \\<or> ord t s\"\n  for s t::\"'a \\<Rightarrow> 'b::{ordered_comm_monoid_add, linorder}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun ord s t \\<or> dord_fun ord t s", "proof (intro disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dord_fun ord t s \\<Longrightarrow> dord_fun ord s t", "assume \"\\<not> dord_fun ord t s\""], ["proof (state)\nthis:\n  \\<not> dord_fun ord t s\n\ngoal (1 subgoal):\n 1. \\<not> dord_fun ord t s \\<Longrightarrow> dord_fun ord s t", "hence \"deg_fun s \\<le> deg_fun t \\<and> (deg_fun t \\<noteq> deg_fun s \\<or> \\<not> ord t s)\""], ["proof (prove)\nusing this:\n  \\<not> dord_fun ord t s\n\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t \\<and>\n    (deg_fun t \\<noteq> deg_fun s \\<or> \\<not> ord t s)", "unfolding dord_fun_def Let_def"], ["proof (prove)\nusing this:\n  \\<not> (deg_fun t < deg_fun s \\<or> deg_fun t = deg_fun s \\<and> ord t s)\n\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t \\<and>\n    (deg_fun t \\<noteq> deg_fun s \\<or> \\<not> ord t s)", "by auto"], ["proof (state)\nthis:\n  deg_fun s \\<le> deg_fun t \\<and>\n  (deg_fun t \\<noteq> deg_fun s \\<or> \\<not> ord t s)\n\ngoal (1 subgoal):\n 1. \\<not> dord_fun ord t s \\<Longrightarrow> dord_fun ord s t", "hence \"deg_fun s \\<le> deg_fun t\" and dis1: \"deg_fun t \\<noteq> deg_fun s \\<or> \\<not> ord t s\""], ["proof (prove)\nusing this:\n  deg_fun s \\<le> deg_fun t \\<and>\n  (deg_fun t \\<noteq> deg_fun s \\<or> \\<not> ord t s)\n\ngoal (1 subgoal):\n 1. deg_fun s \\<le> deg_fun t &&&\n    deg_fun t \\<noteq> deg_fun s \\<or> \\<not> ord t s", "by simp_all"], ["proof (state)\nthis:\n  deg_fun s \\<le> deg_fun t\n  deg_fun t \\<noteq> deg_fun s \\<or> \\<not> ord t s\n\ngoal (1 subgoal):\n 1. \\<not> dord_fun ord t s \\<Longrightarrow> dord_fun ord s t", "show \"dord_fun ord s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun ord s t", "unfolding dord_fun_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t", "proof (intro disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (deg_fun s = deg_fun t \\<and> ord s t) \\<Longrightarrow>\n    deg_fun s < deg_fun t", "assume \"\\<not> (deg_fun s = deg_fun t \\<and> ord s t)\""], ["proof (state)\nthis:\n  \\<not> (deg_fun s = deg_fun t \\<and> ord s t)\n\ngoal (1 subgoal):\n 1. \\<not> (deg_fun s = deg_fun t \\<and> ord s t) \\<Longrightarrow>\n    deg_fun s < deg_fun t", "hence dis2: \"deg_fun s \\<noteq> deg_fun t \\<or> \\<not> ord s t\""], ["proof (prove)\nusing this:\n  \\<not> (deg_fun s = deg_fun t \\<and> ord s t)\n\ngoal (1 subgoal):\n 1. deg_fun s \\<noteq> deg_fun t \\<or> \\<not> ord s t", "by simp"], ["proof (state)\nthis:\n  deg_fun s \\<noteq> deg_fun t \\<or> \\<not> ord s t\n\ngoal (1 subgoal):\n 1. \\<not> (deg_fun s = deg_fun t \\<and> ord s t) \\<Longrightarrow>\n    deg_fun s < deg_fun t", "show \"deg_fun s < deg_fun t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun t", "proof (cases \"deg_fun s = deg_fun t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_fun s = deg_fun t \\<Longrightarrow> deg_fun s < deg_fun t\n 2. deg_fun s \\<noteq> deg_fun t \\<Longrightarrow> deg_fun s < deg_fun t", "case True"], ["proof (state)\nthis:\n  deg_fun s = deg_fun t\n\ngoal (2 subgoals):\n 1. deg_fun s = deg_fun t \\<Longrightarrow> deg_fun s < deg_fun t\n 2. deg_fun s \\<noteq> deg_fun t \\<Longrightarrow> deg_fun s < deg_fun t", "from True dis1"], ["proof (chain)\npicking this:\n  deg_fun s = deg_fun t\n  deg_fun t \\<noteq> deg_fun s \\<or> \\<not> ord t s", "have \"\\<not> ord t s\""], ["proof (prove)\nusing this:\n  deg_fun s = deg_fun t\n  deg_fun t \\<noteq> deg_fun s \\<or> \\<not> ord t s\n\ngoal (1 subgoal):\n 1. \\<not> ord t s", "by simp"], ["proof (state)\nthis:\n  \\<not> ord t s\n\ngoal (2 subgoals):\n 1. deg_fun s = deg_fun t \\<Longrightarrow> deg_fun s < deg_fun t\n 2. deg_fun s \\<noteq> deg_fun t \\<Longrightarrow> deg_fun s < deg_fun t", "from True dis2"], ["proof (chain)\npicking this:\n  deg_fun s = deg_fun t\n  deg_fun s \\<noteq> deg_fun t \\<or> \\<not> ord s t", "have \"\\<not> ord s t\""], ["proof (prove)\nusing this:\n  deg_fun s = deg_fun t\n  deg_fun s \\<noteq> deg_fun t \\<or> \\<not> ord s t\n\ngoal (1 subgoal):\n 1. \\<not> ord s t", "by simp"], ["proof (state)\nthis:\n  \\<not> ord s t\n\ngoal (2 subgoals):\n 1. deg_fun s = deg_fun t \\<Longrightarrow> deg_fun s < deg_fun t\n 2. deg_fun s \\<noteq> deg_fun t \\<Longrightarrow> deg_fun s < deg_fun t", "from \\<open>\\<not> ord s t\\<close> \\<open>\\<not> ord t s\\<close> that"], ["proof (chain)\npicking this:\n  \\<not> ord s t\n  \\<not> ord t s\n  ord s t \\<or> ord t s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> ord s t\n  \\<not> ord t s\n  ord s t \\<or> ord t s\n\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun t", "by simp"], ["proof (state)\nthis:\n  deg_fun s < deg_fun t\n\ngoal (1 subgoal):\n 1. deg_fun s \\<noteq> deg_fun t \\<Longrightarrow> deg_fun s < deg_fun t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_fun s \\<noteq> deg_fun t \\<Longrightarrow> deg_fun s < deg_fun t", "case False"], ["proof (state)\nthis:\n  deg_fun s \\<noteq> deg_fun t\n\ngoal (1 subgoal):\n 1. deg_fun s \\<noteq> deg_fun t \\<Longrightarrow> deg_fun s < deg_fun t", "from this \\<open>deg_fun s \\<le> deg_fun t\\<close>"], ["proof (chain)\npicking this:\n  deg_fun s \\<noteq> deg_fun t\n  deg_fun s \\<le> deg_fun t", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_fun s \\<noteq> deg_fun t\n  deg_fun s \\<le> deg_fun t\n\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun t", "by simp"], ["proof (state)\nthis:\n  deg_fun s < deg_fun t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_fun s < deg_fun t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dord_fun ord s t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dord_fun_zero_min:\n  fixes s t::\"'a \\<Rightarrow> 'b::add_linorder_min\"\n  assumes ord_refl: \"\\<And>t. ord t t\" and \"finite (supp_fun s)\"\n  shows \"dord_fun ord 0 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun ord 0 s", "unfolding dord_fun_def Let_def deg_fun_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) < deg_fun s \\<or> (0::'b) = deg_fun s \\<and> ord 0 s", "proof (rule disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((0::'b) = deg_fun s \\<and> ord 0 s) \\<Longrightarrow>\n    (0::'b) < deg_fun s", "assume \"\\<not> (0 = deg_fun s \\<and> ord 0 s)\""], ["proof (state)\nthis:\n  \\<not> ((0::'b) = deg_fun s \\<and> ord 0 s)\n\ngoal (1 subgoal):\n 1. \\<not> ((0::'b) = deg_fun s \\<and> ord 0 s) \\<Longrightarrow>\n    (0::'b) < deg_fun s", "hence dis: \"deg_fun s \\<noteq> 0 \\<or> \\<not> ord 0 s\""], ["proof (prove)\nusing this:\n  \\<not> ((0::'b) = deg_fun s \\<and> ord 0 s)\n\ngoal (1 subgoal):\n 1. deg_fun s \\<noteq> (0::'b) \\<or> \\<not> ord 0 s", "by simp"], ["proof (state)\nthis:\n  deg_fun s \\<noteq> (0::'b) \\<or> \\<not> ord 0 s\n\ngoal (1 subgoal):\n 1. \\<not> ((0::'b) = deg_fun s \\<and> ord 0 s) \\<Longrightarrow>\n    (0::'b) < deg_fun s", "show \"0 < deg_fun s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) < deg_fun s", "proof (cases \"deg_fun s = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_fun s = (0::'b) \\<Longrightarrow> (0::'b) < deg_fun s\n 2. deg_fun s \\<noteq> (0::'b) \\<Longrightarrow> (0::'b) < deg_fun s", "case True"], ["proof (state)\nthis:\n  deg_fun s = (0::'b)\n\ngoal (2 subgoals):\n 1. deg_fun s = (0::'b) \\<Longrightarrow> (0::'b) < deg_fun s\n 2. deg_fun s \\<noteq> (0::'b) \\<Longrightarrow> (0::'b) < deg_fun s", "hence \"s = 0\""], ["proof (prove)\nusing this:\n  deg_fun s = (0::'b)\n\ngoal (1 subgoal):\n 1. s = 0", "using deg_fun_eq_0_iff[OF assms(2)]"], ["proof (prove)\nusing this:\n  deg_fun s = (0::'b)\n  (deg_fun s = (0::'b)) = (s = 0)\n\ngoal (1 subgoal):\n 1. s = 0", "by auto"], ["proof (state)\nthis:\n  s = 0\n\ngoal (2 subgoals):\n 1. deg_fun s = (0::'b) \\<Longrightarrow> (0::'b) < deg_fun s\n 2. deg_fun s \\<noteq> (0::'b) \\<Longrightarrow> (0::'b) < deg_fun s", "hence \"ord 0 s\""], ["proof (prove)\nusing this:\n  s = 0\n\ngoal (1 subgoal):\n 1. ord 0 s", "using ord_refl"], ["proof (prove)\nusing this:\n  s = 0\n  ord ?t ?t\n\ngoal (1 subgoal):\n 1. ord 0 s", "by simp"], ["proof (state)\nthis:\n  ord 0 s\n\ngoal (2 subgoals):\n 1. deg_fun s = (0::'b) \\<Longrightarrow> (0::'b) < deg_fun s\n 2. deg_fun s \\<noteq> (0::'b) \\<Longrightarrow> (0::'b) < deg_fun s", "with True dis"], ["proof (chain)\npicking this:\n  deg_fun s = (0::'b)\n  deg_fun s \\<noteq> (0::'b) \\<or> \\<not> ord 0 s\n  ord 0 s", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_fun s = (0::'b)\n  deg_fun s \\<noteq> (0::'b) \\<or> \\<not> ord 0 s\n  ord 0 s\n\ngoal (1 subgoal):\n 1. (0::'b) < deg_fun s", "by simp"], ["proof (state)\nthis:\n  (0::'b) < deg_fun s\n\ngoal (1 subgoal):\n 1. deg_fun s \\<noteq> (0::'b) \\<Longrightarrow> (0::'b) < deg_fun s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_fun s \\<noteq> (0::'b) \\<Longrightarrow> (0::'b) < deg_fun s", "case False"], ["proof (state)\nthis:\n  deg_fun s \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. deg_fun s \\<noteq> (0::'b) \\<Longrightarrow> (0::'b) < deg_fun s", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_fun s \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (0::'b) < deg_fun s", "by (auto simp: zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  (0::'b) < deg_fun s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0::'b) < deg_fun s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dord_fun_plus_monotone:\n  fixes s t u ::\"'a \\<Rightarrow> 'b::{ordered_comm_monoid_add, ordered_ab_semigroup_add_imp_le}\"\n  assumes ord_monotone: \"ord s t \\<Longrightarrow> ord (s + u) (t + u)\" and \"finite (supp_fun s)\"\n    and \"finite (supp_fun t)\" and \"finite (supp_fun u)\" and \"dord_fun ord s t\"\n  shows \"dord_fun ord (s + u) (t + u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun ord (s + u) (t + u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dord_fun ord (s + u) (t + u)", "from assms(5)"], ["proof (chain)\npicking this:\n  dord_fun ord s t", "have \"deg_fun s < deg_fun t \\<or> (deg_fun s = deg_fun t \\<and> ord s t)\""], ["proof (prove)\nusing this:\n  dord_fun ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t", "unfolding dord_fun_def Let_def"], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t", "."], ["proof (state)\nthis:\n  deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. dord_fun ord (s + u) (t + u)", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun t \\<or> deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. dord_fun ord (s + u) (t + u)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_fun s < deg_fun t \\<Longrightarrow> dord_fun ord (s + u) (t + u)\n 2. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow>\n    dord_fun ord (s + u) (t + u)", "assume \"deg_fun s < deg_fun t\""], ["proof (state)\nthis:\n  deg_fun s < deg_fun t\n\ngoal (2 subgoals):\n 1. deg_fun s < deg_fun t \\<Longrightarrow> dord_fun ord (s + u) (t + u)\n 2. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow>\n    dord_fun ord (s + u) (t + u)", "hence \"deg_fun (s + u) < deg_fun (t + u)\""], ["proof (prove)\nusing this:\n  deg_fun s < deg_fun t\n\ngoal (1 subgoal):\n 1. deg_fun (s + u) < deg_fun (t + u)", "by (auto simp: deg_fun_plus[OF _ assms(4)] assms(2) assms(3))"], ["proof (state)\nthis:\n  deg_fun (s + u) < deg_fun (t + u)\n\ngoal (2 subgoals):\n 1. deg_fun s < deg_fun t \\<Longrightarrow> dord_fun ord (s + u) (t + u)\n 2. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow>\n    dord_fun ord (s + u) (t + u)", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_fun (s + u) < deg_fun (t + u)\n\ngoal (1 subgoal):\n 1. dord_fun ord (s + u) (t + u)", "unfolding dord_fun_def Let_def"], ["proof (prove)\nusing this:\n  deg_fun (s + u) < deg_fun (t + u)\n\ngoal (1 subgoal):\n 1. deg_fun (s + u) < deg_fun (t + u) \\<or>\n    deg_fun (s + u) = deg_fun (t + u) \\<and> ord (s + u) (t + u)", "by simp"], ["proof (state)\nthis:\n  dord_fun ord (s + u) (t + u)\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow>\n    dord_fun ord (s + u) (t + u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow>\n    dord_fun ord (s + u) (t + u)", "assume \"deg_fun s = deg_fun t \\<and> ord s t\""], ["proof (state)\nthis:\n  deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow>\n    dord_fun ord (s + u) (t + u)", "hence \"deg_fun s = deg_fun t\" and \"ord s t\""], ["proof (prove)\nusing this:\n  deg_fun s = deg_fun t \\<and> ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t &&& ord s t", "by simp_all"], ["proof (state)\nthis:\n  deg_fun s = deg_fun t\n  ord s t\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow>\n    dord_fun ord (s + u) (t + u)", "from \\<open>deg_fun s = deg_fun t\\<close>"], ["proof (chain)\npicking this:\n  deg_fun s = deg_fun t", "have \"deg_fun (s + u) = deg_fun (t + u)\""], ["proof (prove)\nusing this:\n  deg_fun s = deg_fun t\n\ngoal (1 subgoal):\n 1. deg_fun (s + u) = deg_fun (t + u)", "by (auto simp: deg_fun_plus[OF _ assms(4)] assms(2) assms(3))"], ["proof (state)\nthis:\n  deg_fun (s + u) = deg_fun (t + u)\n\ngoal (1 subgoal):\n 1. deg_fun s = deg_fun t \\<and> ord s t \\<Longrightarrow>\n    dord_fun ord (s + u) (t + u)", "from this ord_monotone[OF \\<open>ord s t\\<close>]"], ["proof (chain)\npicking this:\n  deg_fun (s + u) = deg_fun (t + u)\n  ord (s + u) (t + u)", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_fun (s + u) = deg_fun (t + u)\n  ord (s + u) (t + u)\n\ngoal (1 subgoal):\n 1. dord_fun ord (s + u) (t + u)", "unfolding dord_fun_def Let_def"], ["proof (prove)\nusing this:\n  deg_fun (s + u) = deg_fun (t + u)\n  ord (s + u) (t + u)\n\ngoal (1 subgoal):\n 1. deg_fun (s + u) < deg_fun (t + u) \\<or>\n    deg_fun (s + u) = deg_fun (t + u) \\<and> ord (s + u) (t + u)", "by simp"], ["proof (state)\nthis:\n  dord_fun ord (s + u) (t + u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dord_fun ord (s + u) (t + u)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* linorder *)"], ["", "context wellorder\nbegin"], ["", "subsubsection \\<open>Degree-Lexicographic Term Order\\<close>"], ["", "definition dlex_fun::\"('a \\<Rightarrow> 'b::ordered_comm_monoid_add) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> bool\"\n  where \"dlex_fun \\<equiv> dord_fun lex_fun\""], ["", "definition \"dlex_fun_strict s t \\<longleftrightarrow> dlex_fun s t \\<and> \\<not> dlex_fun t s\""], ["", "lemma dlex_fun_refl:\n  shows \"dlex_fun s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_fun s s", "unfolding dlex_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun lex_fun s s", "by (rule dord_fun_refl, rule lex_fun_refl)"], ["", "lemma dlex_fun_antisym:\n  assumes \"dlex_fun s t\" and \"dlex_fun t s\"\n  shows \"s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "by (rule dord_fun_antisym, erule lex_fun_antisym, assumption,\n      simp_all only: dlex_fun_def[symmetric], fact+)"], ["", "lemma dlex_fun_trans:\n  assumes \"dlex_fun s t\" and \"dlex_fun t u\"\n  shows \"dlex_fun s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_fun s u", "by (simp only: dlex_fun_def, rule dord_fun_trans, erule lex_fun_trans, assumption,\n      simp_all only: dlex_fun_def[symmetric], fact+)"], ["", "lemma dlex_fun_lin: \"dlex_fun s t \\<or> dlex_fun t s\"\n  for s t::\"('a \\<Rightarrow> 'b::{ordered_comm_monoid_add, linorder})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_fun s t \\<or> dlex_fun t s", "unfolding dlex_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun lex_fun s t \\<or> dord_fun lex_fun t s", "by (rule dord_fun_lin, rule lex_fun_lin)"], ["", "corollary dlex_fun_strict_alt [code]:\n  \"dlex_fun_strict s t = (\\<not> dlex_fun t s)\" for s t::\"'a \\<Rightarrow> 'b::{ordered_comm_monoid_add, linorder}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_fun_strict s t = (\\<not> dlex_fun t s)", "unfolding dlex_fun_strict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict dlex_fun s t = (\\<not> dlex_fun t s)", "using dlex_fun_lin"], ["proof (prove)\nusing this:\n  dlex_fun ?s ?t \\<or> dlex_fun ?t ?s\n\ngoal (1 subgoal):\n 1. strict dlex_fun s t = (\\<not> dlex_fun t s)", "by auto"], ["", "lemma dlex_fun_zero_min:\n  fixes s t::\"('a \\<Rightarrow> 'b::add_linorder_min)\"\n  assumes \"finite (supp_fun s)\"\n  shows \"dlex_fun 0 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_fun 0 s", "unfolding dlex_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun lex_fun 0 s", "by (rule dord_fun_zero_min, rule lex_fun_refl, fact)"], ["", "lemma dlex_fun_plus_monotone:\n  fixes s t u::\"'a \\<Rightarrow> 'b::{ordered_cancel_comm_monoid_add, ordered_ab_semigroup_add_imp_le}\"\n  assumes \"finite (supp_fun s)\" and \"finite (supp_fun t)\" and \"finite (supp_fun u)\" and \"dlex_fun s t\"\n  shows \"dlex_fun (s + u) (t + u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_fun (s + u) (t + u)", "using lex_fun_plus_monotone[of s t u] assms"], ["proof (prove)\nusing this:\n  lex_fun s t \\<Longrightarrow> lex_fun (s + u) (t + u)\n  finite (supp_fun s)\n  finite (supp_fun t)\n  finite (supp_fun u)\n  dlex_fun s t\n\ngoal (1 subgoal):\n 1. dlex_fun (s + u) (t + u)", "unfolding dlex_fun_def"], ["proof (prove)\nusing this:\n  lex_fun s t \\<Longrightarrow> lex_fun (s + u) (t + u)\n  finite (supp_fun s)\n  finite (supp_fun t)\n  finite (supp_fun u)\n  dord_fun lex_fun s t\n\ngoal (1 subgoal):\n 1. dord_fun lex_fun (s + u) (t + u)", "by (rule dord_fun_plus_monotone)"], ["", "subsubsection \\<open>Degree-Reverse-Lexicographic Term Order\\<close>"], ["", "abbreviation rlex_fun::\"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b::order) \\<Rightarrow> bool\" where\n  \"rlex_fun s t \\<equiv> lex_fun t s\""], ["", "text \\<open>Note that @{const rlex_fun} is not precisely the reverse-lexicographic order relation on\n  power-products. Normally, the @{emph \\<open>last\\<close>} (i.\\,e. highest) indeterminate whose exponent differs\n  in the two power-products to be compared is taken, but since we do not require the domain to be finite,\n  there might not be such a last indeterminate. Therefore, we simply take the converse of\n  @{const lex_fun}.\\<close>"], ["", "definition drlex_fun::\"('a \\<Rightarrow> 'b::ordered_comm_monoid_add) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> bool\"\n  where \"drlex_fun \\<equiv> dord_fun rlex_fun\""], ["", "definition \"drlex_fun_strict s t \\<longleftrightarrow> drlex_fun s t \\<and> \\<not> drlex_fun t s\""], ["", "lemma drlex_fun_refl:\n  shows \"drlex_fun s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_fun s s", "unfolding drlex_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun rlex_fun s s", "by (rule dord_fun_refl, fact lex_fun_refl)"], ["", "lemma drlex_fun_antisym:\n  assumes \"drlex_fun s t\" and \"drlex_fun t s\"\n  shows \"s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "by (rule dord_fun_antisym, erule lex_fun_antisym, assumption,\n      simp_all only: drlex_fun_def[symmetric], fact+)"], ["", "lemma drlex_fun_trans:\n  assumes \"drlex_fun s t\" and \"drlex_fun t u\"\n  shows \"drlex_fun s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_fun s u", "by (simp only: drlex_fun_def, rule dord_fun_trans, erule lex_fun_trans, assumption,\n      simp_all only: drlex_fun_def[symmetric], fact+)"], ["", "lemma drlex_fun_lin: \"drlex_fun s t \\<or> drlex_fun t s\"\n  for s t::\"('a \\<Rightarrow> 'b::{ordered_comm_monoid_add, linorder})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_fun s t \\<or> drlex_fun t s", "unfolding drlex_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun rlex_fun s t \\<or> dord_fun rlex_fun t s", "by (rule dord_fun_lin, rule lex_fun_lin)"], ["", "corollary drlex_fun_strict_alt [code]:\n  \"drlex_fun_strict s t = (\\<not> drlex_fun t s)\" for s t::\"'a \\<Rightarrow> 'b::{ordered_comm_monoid_add, linorder}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_fun_strict s t = (\\<not> drlex_fun t s)", "unfolding drlex_fun_strict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict drlex_fun s t = (\\<not> drlex_fun t s)", "using drlex_fun_lin"], ["proof (prove)\nusing this:\n  drlex_fun ?s ?t \\<or> drlex_fun ?t ?s\n\ngoal (1 subgoal):\n 1. strict drlex_fun s t = (\\<not> drlex_fun t s)", "by auto"], ["", "lemma drlex_fun_zero_min:\n  fixes s t::\"('a \\<Rightarrow> 'b::add_linorder_min)\"\n  assumes \"finite (supp_fun s)\"\n  shows \"drlex_fun 0 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_fun 0 s", "unfolding drlex_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_fun rlex_fun 0 s", "by (rule dord_fun_zero_min, rule lex_fun_refl, fact)"], ["", "lemma drlex_fun_plus_monotone:\n  fixes s t u::\"'a \\<Rightarrow> 'b::{ordered_cancel_comm_monoid_add, ordered_ab_semigroup_add_imp_le}\"\n  assumes \"finite (supp_fun s)\" and \"finite (supp_fun t)\" and \"finite (supp_fun u)\" and \"drlex_fun s t\"\n  shows \"drlex_fun (s + u) (t + u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_fun (s + u) (t + u)", "using lex_fun_plus_monotone[of t s u] assms"], ["proof (prove)\nusing this:\n  rlex_fun s t \\<Longrightarrow> rlex_fun (s + u) (t + u)\n  finite (supp_fun s)\n  finite (supp_fun t)\n  finite (supp_fun u)\n  drlex_fun s t\n\ngoal (1 subgoal):\n 1. drlex_fun (s + u) (t + u)", "unfolding drlex_fun_def"], ["proof (prove)\nusing this:\n  rlex_fun s t \\<Longrightarrow> rlex_fun (s + u) (t + u)\n  finite (supp_fun s)\n  finite (supp_fun t)\n  finite (supp_fun u)\n  dord_fun rlex_fun s t\n\ngoal (1 subgoal):\n 1. dord_fun rlex_fun (s + u) (t + u)", "by (rule dord_fun_plus_monotone)"], ["", "end"], ["", "(* wellorder *)"], ["", "text\\<open>Every finite linear ordering is also a well-ordering. This fact is particularly useful when\n  working with fixed finite sets of indeterminates.\\<close>"], ["", "class finite_linorder = finite + linorder\nbegin"], ["", "subclass wellorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.wellorder (\\<le>) (<)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "fix P::\"'a \\<Rightarrow> bool\" and a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "assume hyp: \"\\<And>x. (\\<And>y. (y < x) \\<Longrightarrow> P y) \\<Longrightarrow> P x\""], ["proof (state)\nthis:\n  (\\<And>y. y < ?x \\<Longrightarrow> P y) \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "show \"P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow> False", "assume \"\\<not> P a\""], ["proof (state)\nthis:\n  \\<not> P a\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow> False", "have \"finite {x. \\<not> P x}\" (is \"finite ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. \\<not> P x}", "by simp"], ["proof (state)\nthis:\n  finite {x. \\<not> P x}\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow> False", "from \\<open>\\<not> P a\\<close>"], ["proof (chain)\npicking this:\n  \\<not> P a", "have \"a \\<in> ?A\""], ["proof (prove)\nusing this:\n  \\<not> P a\n\ngoal (1 subgoal):\n 1. a \\<in> {x. \\<not> P x}", "by simp"], ["proof (state)\nthis:\n  a \\<in> {x. \\<not> P x}\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow> False", "hence \"?A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  a \\<in> {x. \\<not> P x}\n\ngoal (1 subgoal):\n 1. {x. \\<not> P x} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {x. \\<not> P x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow> False", "from ex_min[OF \\<open>finite ?A\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>{x. \\<not> P x}. \\<forall>z\\<in>{x. \\<not> P x}. y \\<le> z", "obtain b where \"b \\<in> ?A\" and b_min: \"\\<forall>y\\<in>?A. b \\<le> y\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>{x. \\<not> P x}. \\<forall>z\\<in>{x. \\<not> P x}. y \\<le> z\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> {x. \\<not> P x};\n         \\<forall>y\\<in>{x. \\<not> P x}. b \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b \\<in> {x. \\<not> P x}\n  \\<forall>y\\<in>{x. \\<not> P x}. b \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow> False", "from \\<open>b \\<in> ?A\\<close>"], ["proof (chain)\npicking this:\n  b \\<in> {x. \\<not> P x}", "have \"\\<not> P b\""], ["proof (prove)\nusing this:\n  b \\<in> {x. \\<not> P x}\n\ngoal (1 subgoal):\n 1. \\<not> P b", "by simp"], ["proof (state)\nthis:\n  \\<not> P b\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow> False", "with hyp[of b]"], ["proof (chain)\npicking this:\n  (\\<And>y. y < b \\<Longrightarrow> P y) \\<Longrightarrow> P b\n  \\<not> P b", "obtain y where \"y < b\" and \"\\<not> P y\""], ["proof (prove)\nusing this:\n  (\\<And>y. y < b \\<Longrightarrow> P y) \\<Longrightarrow> P b\n  \\<not> P b\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y < b; \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y < b\n  \\<not> P y\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow> False", "from \\<open>\\<not> P y\\<close>"], ["proof (chain)\npicking this:\n  \\<not> P y", "have \"y \\<in> ?A\""], ["proof (prove)\nusing this:\n  \\<not> P y\n\ngoal (1 subgoal):\n 1. y \\<in> {x. \\<not> P x}", "by simp"], ["proof (state)\nthis:\n  y \\<in> {x. \\<not> P x}\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow> False", "with b_min"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>{x. \\<not> P x}. b \\<le> y\n  y \\<in> {x. \\<not> P x}", "have \"b \\<le> y\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>{x. \\<not> P x}. b \\<le> y\n  y \\<in> {x. \\<not> P x}\n\ngoal (1 subgoal):\n 1. b \\<le> y", "by simp"], ["proof (state)\nthis:\n  b \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow> False", "with \\<open>y < b\\<close>"], ["proof (chain)\npicking this:\n  y < b\n  b \\<le> y", "show False"], ["proof (prove)\nusing this:\n  y < b\n  b \\<le> y\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Type @{type poly_mapping}\\<close>"], ["", "lemma poly_mapping_eq_zeroI:\n  assumes \"keys s = {}\"\n  shows \"s = (0::('a, 'b::zero) poly_mapping)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = 0", "proof (rule poly_mapping_eqI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup s k = (0::'b)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup s k = (0::'b)", "from assms"], ["proof (chain)\npicking this:\n  keys s = {}", "show \"lookup s x = 0\""], ["proof (prove)\nusing this:\n  keys s = {}\n\ngoal (1 subgoal):\n 1. lookup s x = (0::'b)", "by auto"], ["proof (state)\nthis:\n  lookup s x = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_plus_ninv_comm_monoid_add: \"keys (s + t) = keys s \\<union> keys (t::'a \\<Rightarrow>\\<^sub>0 'b::ninv_comm_monoid_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (s + t) = keys s \\<union> keys t", "proof (rule, fact Poly_Mapping.keys_add, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys s \\<union> keys t \\<Longrightarrow> x \\<in> keys (s + t)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys s \\<union> keys t \\<Longrightarrow> x \\<in> keys (s + t)", "assume \"x \\<in> keys s \\<union> keys t\""], ["proof (state)\nthis:\n  x \\<in> keys s \\<union> keys t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys s \\<union> keys t \\<Longrightarrow> x \\<in> keys (s + t)", "thus \"x \\<in> keys (s + t)\""], ["proof (prove)\nusing this:\n  x \\<in> keys s \\<union> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> keys (s + t)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> keys s \\<Longrightarrow> x \\<in> keys (s + t)\n 2. x \\<in> keys t \\<Longrightarrow> x \\<in> keys (s + t)", "assume \"x \\<in> keys s\""], ["proof (state)\nthis:\n  x \\<in> keys s\n\ngoal (2 subgoals):\n 1. x \\<in> keys s \\<Longrightarrow> x \\<in> keys (s + t)\n 2. x \\<in> keys t \\<Longrightarrow> x \\<in> keys (s + t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> keys s\n\ngoal (1 subgoal):\n 1. x \\<in> keys (s + t)", "by (metis in_keys_iff lookup_add plus_eq_zero)"], ["proof (state)\nthis:\n  x \\<in> keys (s + t)\n\ngoal (1 subgoal):\n 1. x \\<in> keys t \\<Longrightarrow> x \\<in> keys (s + t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> keys t \\<Longrightarrow> x \\<in> keys (s + t)", "assume \"x \\<in> keys t\""], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> keys t \\<Longrightarrow> x \\<in> keys (s + t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> keys (s + t)", "by (metis in_keys_iff lookup_add plus_eq_zero_2)"], ["proof (state)\nthis:\n  x \\<in> keys (s + t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> keys (s + t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_zero_fun: \"lookup 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup 0 = 0", "by (simp only: zero_poly_mapping.rep_eq zero_fun_def)"], ["", "lemma lookup_plus_fun: \"lookup (s + t) = lookup s + lookup t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (s + t) = lookup s + lookup t", "by (simp only: plus_poly_mapping.rep_eq plus_fun_def)"], ["", "lemma lookup_uminus_fun: \"lookup (- s) = - lookup s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (- s) = - lookup s", "by (fact uminus_poly_mapping.rep_eq)"], ["", "lemma lookup_minus_fun: \"lookup (s - t) = lookup s - lookup t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (s - t) = lookup s - lookup t", "by (simp only: minus_poly_mapping.rep_eq, rule, simp only: minus_apply)"], ["", "lemma poly_mapping_adds_iff: \"s adds t \\<longleftrightarrow> lookup s adds lookup t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s adds t) = (lookup s adds lookup t)", "unfolding adds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>k. t = s + k) = (\\<exists>k. lookup t = lookup s + k)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>k. t = s + k \\<Longrightarrow>\n    \\<exists>k. lookup t = lookup s + k\n 2. \\<exists>k. lookup t = lookup s + k \\<Longrightarrow>\n    \\<exists>k. t = s + k", "assume \"\\<exists>k. t = s + k\""], ["proof (state)\nthis:\n  \\<exists>k. t = s + k\n\ngoal (2 subgoals):\n 1. \\<exists>k. t = s + k \\<Longrightarrow>\n    \\<exists>k. lookup t = lookup s + k\n 2. \\<exists>k. lookup t = lookup s + k \\<Longrightarrow>\n    \\<exists>k. t = s + k", "then"], ["proof (chain)\npicking this:\n  \\<exists>k. t = s + k", "obtain k where *: \"t = s + k\""], ["proof (prove)\nusing this:\n  \\<exists>k. t = s + k\n\ngoal (1 subgoal):\n 1. (\\<And>k. t = s + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  t = s + k\n\ngoal (2 subgoals):\n 1. \\<exists>k. t = s + k \\<Longrightarrow>\n    \\<exists>k. lookup t = lookup s + k\n 2. \\<exists>k. lookup t = lookup s + k \\<Longrightarrow>\n    \\<exists>k. t = s + k", "show \"\\<exists>k. lookup t = lookup s + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. lookup t = lookup s + k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup t = lookup s + ?k", "from *"], ["proof (chain)\npicking this:\n  t = s + k", "show \"lookup t = lookup s + lookup k\""], ["proof (prove)\nusing this:\n  t = s + k\n\ngoal (1 subgoal):\n 1. lookup t = lookup s + lookup k", "by (simp only: lookup_plus_fun)"], ["proof (state)\nthis:\n  lookup t = lookup s + lookup k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k. lookup t = lookup s + k\n\ngoal (1 subgoal):\n 1. \\<exists>k. lookup t = lookup s + k \\<Longrightarrow>\n    \\<exists>k. t = s + k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. lookup t = lookup s + k \\<Longrightarrow>\n    \\<exists>k. t = s + k", "assume \"\\<exists>k. lookup t = lookup s + k\""], ["proof (state)\nthis:\n  \\<exists>k. lookup t = lookup s + k\n\ngoal (1 subgoal):\n 1. \\<exists>k. lookup t = lookup s + k \\<Longrightarrow>\n    \\<exists>k. t = s + k", "then"], ["proof (chain)\npicking this:\n  \\<exists>k. lookup t = lookup s + k", "obtain k where *: \"lookup t = lookup s + k\""], ["proof (prove)\nusing this:\n  \\<exists>k. lookup t = lookup s + k\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        lookup t = lookup s + k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  lookup t = lookup s + k\n\ngoal (1 subgoal):\n 1. \\<exists>k. lookup t = lookup s + k \\<Longrightarrow>\n    \\<exists>k. t = s + k", "have **: \"k \\<in> {f. finite {x. f x \\<noteq> 0}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. k x \\<noteq> (0::'b)}", "have \"finite {x. lookup t x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. lookup t x \\<noteq> (0::'b)}", "by transfer"], ["proof (state)\nthis:\n  finite {x. lookup t x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. finite {x. k x \\<noteq> (0::'b)}", "hence \"finite {x. lookup s x + k x \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  finite {x. lookup t x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. finite {x. lookup s x + k x \\<noteq> (0::'b)}", "by (simp only: * plus_fun_def)"], ["proof (state)\nthis:\n  finite {x. lookup s x + k x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. finite {x. k x \\<noteq> (0::'b)}", "moreover"], ["proof (state)\nthis:\n  finite {x. lookup s x + k x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. finite {x. k x \\<noteq> (0::'b)}", "have \"finite {x. lookup s x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. lookup s x \\<noteq> (0::'b)}", "by transfer"], ["proof (state)\nthis:\n  finite {x. lookup s x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. finite {x. k x \\<noteq> (0::'b)}", "ultimately"], ["proof (chain)\npicking this:\n  finite {x. lookup s x + k x \\<noteq> (0::'b)}\n  finite {x. lookup s x \\<noteq> (0::'b)}", "show \"finite {x. k x \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  finite {x. lookup s x + k x \\<noteq> (0::'b)}\n  finite {x. lookup s x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. finite {x. k x \\<noteq> (0::'b)}", "by (rule finite_neq_0_inv', simp)"], ["proof (state)\nthis:\n  finite {x. k x \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}\n\ngoal (1 subgoal):\n 1. \\<exists>k. lookup t = lookup s + k \\<Longrightarrow>\n    \\<exists>k. t = s + k", "show \"\\<exists>k. t = s + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. t = s + k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t = s + ?k", "show \"t = s + Abs_poly_mapping k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = s + Abs_poly_mapping k", "by (rule poly_mapping_eqI, simp add: * lookup_add Abs_poly_mapping_inverse[OF **])"], ["proof (state)\nthis:\n  t = s + Abs_poly_mapping k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k. t = s + k\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{typ \"('a, 'b) poly_mapping\"} belongs to class @{class comm_powerprod}\\<close>"], ["", "instance poly_mapping :: (type, cancel_comm_monoid_add) comm_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>0 'b, comm_powerprod_class)", "by standard"], ["", "subsubsection \\<open>@{typ \"('a, 'b) poly_mapping\"} belongs to class @{class ninv_comm_monoid_add}\\<close>"], ["", "instance poly_mapping :: (type, ninv_comm_monoid_add) ninv_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>0 'b, ninv_comm_monoid_add_class)", "proof (standard, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>finite {x. s x \\<noteq> (0::'b)};\n        finite {x. t x \\<noteq> (0::'b)};\n        (\\<lambda>k. s k + t k) = (\\<lambda>k. 0::'b)\\<rbrakk>\n       \\<Longrightarrow> s = (\\<lambda>k. 0::'b)", "fix s t::\"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>finite {x. s x \\<noteq> (0::'b)};\n        finite {x. t x \\<noteq> (0::'b)};\n        (\\<lambda>k. s k + t k) = (\\<lambda>k. 0::'b)\\<rbrakk>\n       \\<Longrightarrow> s = (\\<lambda>k. 0::'b)", "assume \"(\\<lambda>k. s k + t k) = (\\<lambda>_. 0)\""], ["proof (state)\nthis:\n  (\\<lambda>k. s k + t k) = (\\<lambda>_. 0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>finite {x. s x \\<noteq> (0::'b)};\n        finite {x. t x \\<noteq> (0::'b)};\n        (\\<lambda>k. s k + t k) = (\\<lambda>k. 0::'b)\\<rbrakk>\n       \\<Longrightarrow> s = (\\<lambda>k. 0::'b)", "hence \"s + t = 0\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. s k + t k) = (\\<lambda>_. 0::'b)\n\ngoal (1 subgoal):\n 1. s + t = 0", "by (simp only: plus_fun_def zero_fun_def)"], ["proof (state)\nthis:\n  s + t = 0\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>finite {x. s x \\<noteq> (0::'b)};\n        finite {x. t x \\<noteq> (0::'b)};\n        (\\<lambda>k. s k + t k) = (\\<lambda>k. 0::'b)\\<rbrakk>\n       \\<Longrightarrow> s = (\\<lambda>k. 0::'b)", "hence \"s = 0\""], ["proof (prove)\nusing this:\n  s + t = 0\n\ngoal (1 subgoal):\n 1. s = 0", "by (rule plus_eq_zero)"], ["proof (state)\nthis:\n  s = 0\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>finite {x. s x \\<noteq> (0::'b)};\n        finite {x. t x \\<noteq> (0::'b)};\n        (\\<lambda>k. s k + t k) = (\\<lambda>k. 0::'b)\\<rbrakk>\n       \\<Longrightarrow> s = (\\<lambda>k. 0::'b)", "thus \"s = (\\<lambda>_. 0)\""], ["proof (prove)\nusing this:\n  s = 0\n\ngoal (1 subgoal):\n 1. s = (\\<lambda>_. 0::'b)", "by (simp only: zero_fun_def)"], ["proof (state)\nthis:\n  s = (\\<lambda>_. 0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{typ \"('a, 'b) poly_mapping\"} belongs to class @{class lcs_powerprod}\\<close>"], ["", "instantiation poly_mapping :: (type, add_linorder) lcs_powerprod\nbegin"], ["", "lift_definition lcs_poly_mapping::\"('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b)\" is \"\\<lambda>s t. \\<lambda>x. max (s x) (t x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>finite {x. fun1 x \\<noteq> (0::'b)};\n        finite {x. fun2 x \\<noteq> (0::'b)}\\<rbrakk>\n       \\<Longrightarrow> finite {x. max (fun1 x) (fun2 x) \\<noteq> (0::'b)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>finite {x. fun1 x \\<noteq> (0::'b)};\n        finite {x. fun2 x \\<noteq> (0::'b)}\\<rbrakk>\n       \\<Longrightarrow> finite {x. max (fun1 x) (fun2 x) \\<noteq> (0::'b)}", "fix fun1 fun2::\"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>finite {x. fun1 x \\<noteq> (0::'b)};\n        finite {x. fun2 x \\<noteq> (0::'b)}\\<rbrakk>\n       \\<Longrightarrow> finite {x. max (fun1 x) (fun2 x) \\<noteq> (0::'b)}", "assume \"finite {t. fun1 t \\<noteq> 0}\" and \"finite {t. fun2 t \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {t. fun1 t \\<noteq> (0::'b)}\n  finite {t. fun2 t \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>finite {x. fun1 x \\<noteq> (0::'b)};\n        finite {x. fun2 x \\<noteq> (0::'b)}\\<rbrakk>\n       \\<Longrightarrow> finite {x. max (fun1 x) (fun2 x) \\<noteq> (0::'b)}", "from finite_neq_0'[OF this, of max]"], ["proof (chain)\npicking this:\n  max (0::'b) (0::'b) = (0::'b) \\<Longrightarrow>\n  finite {x. max (fun1 x) (fun2 x) \\<noteq> (0::'b)}", "show \"finite {t. max (fun1 t) (fun2 t) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  max (0::'b) (0::'b) = (0::'b) \\<Longrightarrow>\n  finite {x. max (fun1 x) (fun2 x) \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. finite {t. max (fun1 t) (fun2 t) \\<noteq> (0::'b)}", "by (auto simp: max_def)"], ["proof (state)\nthis:\n  finite {t. max (fun1 t) (fun2 t) \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adds_poly_mappingI:\n  assumes \"lookup s \\<le> lookup (t::'a \\<Rightarrow>\\<^sub>0 'b)\"\n  shows \"s adds t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds t", "unfolding poly_mapping_adds_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup s adds lookup t", "using assms"], ["proof (prove)\nusing this:\n  lookup s \\<le> lookup t\n\ngoal (1 subgoal):\n 1. lookup s adds lookup t", "by (rule adds_funI)"], ["", "lemma lookup_lcs_fun: \"lookup (lcs s t) = lcs (lookup s) (lookup (t:: 'a \\<Rightarrow>\\<^sub>0 'b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lcs s t) = lcs (lookup s) (lookup t)", "by (simp only: lcs_poly_mapping.rep_eq lcs_fun_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>0 'b, lcs_powerprod_class)", "by (standard, simp_all only: poly_mapping_adds_iff lookup_lcs_fun, rule adds_lcs, elim lcs_adds,\n      assumption, rule poly_mapping_eqI, simp only: lookup_lcs_fun lcs_comm)"], ["", "end"], ["", "lemma adds_poly_mapping: \"s adds t \\<longleftrightarrow> lookup s \\<le> lookup t\"\n  for s t::\"'a \\<Rightarrow>\\<^sub>0 'b::add_linorder_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s adds t) = (lookup s \\<le> lookup t)", "by (simp only: poly_mapping_adds_iff adds_fun)"], ["", "lemma lookup_gcs_fun: \"lookup (gcs s (t::'a \\<Rightarrow>\\<^sub>0 ('b::add_linorder))) = gcs (lookup s) (lookup t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (gcs s t) = gcs (lookup s) (lookup t)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup (gcs s t) x = gcs (lookup s) (lookup t) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup (gcs s t) x = gcs (lookup s) (lookup t) x", "show \"lookup (gcs s t) x = gcs (lookup s) (lookup t) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (gcs s t) x = gcs (lookup s) (lookup t) x", "by (simp add: gcs_def lookup_minus lookup_add lookup_lcs_fun)"], ["proof (state)\nthis:\n  lookup (gcs s t) x = gcs (lookup s) (lookup t) x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{typ \"('a, 'b) poly_mapping\"} belongs to class @{class ulcs_powerprod}\\<close>"], ["", "instance poly_mapping :: (type, add_linorder_min) ulcs_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>0 'b, ulcs_powerprod_class)", ".."], ["", "subsubsection \\<open>Power-products in a given set of indeterminates.\\<close>"], ["", "lemma adds_except:\n  \"s adds t = (except s V adds except t V \\<and> except s (- V) adds except t (- V))\"\n  for s t :: \"'a \\<Rightarrow>\\<^sub>0 'b::add_linorder\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s adds t) =\n    (except s V adds except t V \\<and> except s (- V) adds except t (- V))", "by (simp add: poly_mapping_adds_iff adds_except_fun[of \"lookup s\", where V=V] except.rep_eq)"], ["", "lemma adds_except_singleton:\n  \"s adds t \\<longleftrightarrow> (except s {v} adds except t {v} \\<and> lookup s v adds lookup t v)\"\n  for s t :: \"'a \\<Rightarrow>\\<^sub>0 'b::add_linorder\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s adds t) =\n    (except s {v} adds except t {v} \\<and> lookup s v adds lookup t v)", "by (simp add: poly_mapping_adds_iff adds_except_fun_singleton[of \"lookup s\", where v=v] except.rep_eq)"], ["", "subsubsection \\<open>Dickson's lemma for power-products in finitely many indeterminates\\<close>"], ["", "context countable\nbegin"], ["", "definition elem_index :: \"'a \\<Rightarrow> nat\" where \"elem_index = (SOME f. inj f)\""], ["", "lemma inj_elem_index: \"inj elem_index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj elem_index", "unfolding elem_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (SOME f. inj f)", "using ex_inj"], ["proof (prove)\nusing this:\n  \\<exists>to_nat. inj to_nat\n\ngoal (1 subgoal):\n 1. inj (SOME f. inj f)", "by (rule someI_ex)"], ["", "lemma elem_index_inj:\n  assumes \"elem_index x = elem_index y\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using inj_elem_index assms"], ["proof (prove)\nusing this:\n  inj elem_index\n  elem_index x = elem_index y\n\ngoal (1 subgoal):\n 1. x = y", "by (rule injD)"], ["", "lemma finite_nat_seg: \"finite {x. elem_index x < n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. elem_index x < n}", "proof (rule finite_imageD)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (?f ` {x. elem_index x < n})\n 2. inj_on ?f {x. elem_index x < n}", "have \"elem_index ` {x. elem_index x < n} \\<subseteq> {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem_index ` {x. elem_index x < n} \\<subseteq> {0..<n}", "by auto"], ["proof (state)\nthis:\n  elem_index ` {x. elem_index x < n} \\<subseteq> {0..<n}\n\ngoal (2 subgoals):\n 1. finite (?f ` {x. elem_index x < n})\n 2. inj_on ?f {x. elem_index x < n}", "moreover"], ["proof (state)\nthis:\n  elem_index ` {x. elem_index x < n} \\<subseteq> {0..<n}\n\ngoal (2 subgoals):\n 1. finite (?f ` {x. elem_index x < n})\n 2. inj_on ?f {x. elem_index x < n}", "have \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0..<n}", ".."], ["proof (state)\nthis:\n  finite {0..<n}\n\ngoal (2 subgoals):\n 1. finite (?f ` {x. elem_index x < n})\n 2. inj_on ?f {x. elem_index x < n}", "ultimately"], ["proof (chain)\npicking this:\n  elem_index ` {x. elem_index x < n} \\<subseteq> {0..<n}\n  finite {0..<n}", "show \"finite (elem_index ` {x. elem_index x < n})\""], ["proof (prove)\nusing this:\n  elem_index ` {x. elem_index x < n} \\<subseteq> {0..<n}\n  finite {0..<n}\n\ngoal (1 subgoal):\n 1. finite (elem_index ` {x. elem_index x < n})", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite (elem_index ` {x. elem_index x < n})\n\ngoal (1 subgoal):\n 1. inj_on elem_index {x. elem_index x < n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on elem_index {x. elem_index x < n}", "from inj_elem_index"], ["proof (chain)\npicking this:\n  inj elem_index", "show \"inj_on elem_index {x. elem_index x < n}\""], ["proof (prove)\nusing this:\n  inj elem_index\n\ngoal (1 subgoal):\n 1. inj_on elem_index {x. elem_index x < n}", "using inj_on_subset"], ["proof (prove)\nusing this:\n  inj elem_index\n  \\<lbrakk>inj_on ?f ?A; ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?B\n\ngoal (1 subgoal):\n 1. inj_on elem_index {x. elem_index x < n}", "by blast"], ["proof (state)\nthis:\n  inj_on elem_index {x. elem_index x < n}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* countable *)"], ["", "lemma Dickson_poly_mapping:\n  assumes \"finite V\"\n  shows \"almost_full_on (adds) {x::'a \\<Rightarrow>\\<^sub>0 'b::add_wellorder. keys x \\<subseteq> V}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. keys x \\<subseteq> V}", "proof (rule almost_full_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> {x. keys x \\<subseteq> V} \\<Longrightarrow>\n       good (adds) f", "fix seq::\"nat \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>0 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> {x. keys x \\<subseteq> V} \\<Longrightarrow>\n       good (adds) f", "assume a: \"\\<forall>i. seq i \\<in> {x::'a \\<Rightarrow>\\<^sub>0 'b. keys x \\<subseteq> V}\""], ["proof (state)\nthis:\n  \\<forall>i. seq i \\<in> {x. keys x \\<subseteq> V}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> {x. keys x \\<subseteq> V} \\<Longrightarrow>\n       good (adds) f", "define seq' where \"seq' = (\\<lambda>i. lookup (seq i))\""], ["proof (state)\nthis:\n  seq' = (\\<lambda>i. lookup (seq i))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> {x. keys x \\<subseteq> V} \\<Longrightarrow>\n       good (adds) f", "from assms"], ["proof (chain)\npicking this:\n  finite V", "have \"almost_full_on (adds) {x::'a \\<Rightarrow> 'b. supp_fun x \\<subseteq> V}\""], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. supp_fun x \\<subseteq> V}", "by (rule Dickson_fun)"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> V}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> {x. keys x \\<subseteq> V} \\<Longrightarrow>\n       good (adds) f", "moreover"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> V}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> {x. keys x \\<subseteq> V} \\<Longrightarrow>\n       good (adds) f", "from a"], ["proof (chain)\npicking this:\n  \\<forall>i. seq i \\<in> {x. keys x \\<subseteq> V}", "have \"\\<And>i. seq' i \\<in> {x::'a \\<Rightarrow> 'b. supp_fun x \\<subseteq> V}\""], ["proof (prove)\nusing this:\n  \\<forall>i. seq i \\<in> {x. keys x \\<subseteq> V}\n\ngoal (1 subgoal):\n 1. \\<And>i. seq' i \\<in> {x. supp_fun x \\<subseteq> V}", "by (auto simp: seq'_def keys_eq_supp)"], ["proof (state)\nthis:\n  seq' ?i \\<in> {x. supp_fun x \\<subseteq> V}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> {x. keys x \\<subseteq> V} \\<Longrightarrow>\n       good (adds) f", "ultimately"], ["proof (chain)\npicking this:\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> V}\n  seq' ?i \\<in> {x. supp_fun x \\<subseteq> V}", "obtain i j where \"i < j\" and \"seq' i adds seq' j\""], ["proof (prove)\nusing this:\n  almost_full_on (adds) {x. supp_fun x \\<subseteq> V}\n  seq' ?i \\<in> {x. supp_fun x \\<subseteq> V}\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; seq' i adds seq' j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule almost_full_onD)"], ["proof (state)\nthis:\n  i < j\n  seq' i adds seq' j\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> {x. keys x \\<subseteq> V} \\<Longrightarrow>\n       good (adds) f", "from this(2)"], ["proof (chain)\npicking this:\n  seq' i adds seq' j", "have \"seq i adds seq j\""], ["proof (prove)\nusing this:\n  seq' i adds seq' j\n\ngoal (1 subgoal):\n 1. seq i adds seq j", "by (simp add: seq'_def poly_mapping_adds_iff)"], ["proof (state)\nthis:\n  seq i adds seq j\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> {x. keys x \\<subseteq> V} \\<Longrightarrow>\n       good (adds) f", "with \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  i < j\n  seq i adds seq j", "show \"good (adds) seq\""], ["proof (prove)\nusing this:\n  i < j\n  seq i adds seq j\n\ngoal (1 subgoal):\n 1. good (adds) seq", "by (rule goodI)"], ["proof (state)\nthis:\n  good (adds) seq\n\ngoal:\nNo subgoals!", "qed"], ["", "definition varnum :: \"'x set \\<Rightarrow> ('x::countable \\<Rightarrow>\\<^sub>0 'b::zero) \\<Rightarrow> nat\"\n  where \"varnum X t = (if keys t - X = {} then 0 else Suc (Max (elem_index ` (keys t - X))))\""], ["", "lemma elem_index_less_varnum:\n  assumes \"x \\<in> keys t\"\n  obtains \"x \\<in> X\" | \"elem_index x < varnum X t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases \"x \\<in> X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis; x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis;\n     x \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis; x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis;\n     x \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis;\n     x \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis;\n     x \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis;\n     x \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms"], ["proof (chain)\npicking this:\n  x \\<in> keys t\n  x \\<notin> X", "have 1: \"x \\<in> keys t - X\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. x \\<in> keys t - X", "by simp"], ["proof (state)\nthis:\n  x \\<in> keys t - X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis;\n     x \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"keys t - X \\<noteq> {}\""], ["proof (prove)\nusing this:\n  x \\<in> keys t - X\n\ngoal (1 subgoal):\n 1. keys t - X \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  keys t - X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis;\n     x \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence eq: \"varnum X t = Suc (Max (elem_index ` (keys t - X)))\""], ["proof (prove)\nusing this:\n  keys t - X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. varnum X t = Suc (Max (elem_index ` (keys t - X)))", "by (simp add: varnum_def)"], ["proof (state)\nthis:\n  varnum X t = Suc (Max (elem_index ` (keys t - X)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis;\n     x \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"elem_index x < varnum X t\""], ["proof (prove)\nusing this:\n  varnum X t = Suc (Max (elem_index ` (keys t - X)))\n\ngoal (1 subgoal):\n 1. elem_index x < varnum X t", "using 1"], ["proof (prove)\nusing this:\n  varnum X t = Suc (Max (elem_index ` (keys t - X)))\n  x \\<in> keys t - X\n\ngoal (1 subgoal):\n 1. elem_index x < varnum X t", "by (simp add: less_Suc_eq_le)"], ["proof (state)\nthis:\n  elem_index x < varnum X t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X \\<Longrightarrow> thesis;\n     elem_index x < varnum X t \\<Longrightarrow> thesis;\n     x \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  elem_index x < varnum X t\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma varnum_plus:\n  \"varnum X (s + t) = max (varnum X s) (varnum X (t::'x::countable \\<Rightarrow>\\<^sub>0 'b::ninv_comm_monoid_add))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. varnum X (s + t) = max (varnum X s) (varnum X t)", "proof (simp add: varnum_def keys_plus_ninv_comm_monoid_add image_Un Un_Diff del: Diff_eq_empty_iff, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>keys s - X \\<noteq> {}; keys t - X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (elem_index ` (keys s - X) \\<union>\n                           elem_index ` (keys t - X)) =\n                      max (Max (elem_index ` (keys s - X)))\n                       (Max (elem_index ` (keys t - X)))", "assume 1: \"keys s - X \\<noteq> {}\" and 2: \"keys t - X \\<noteq> {}\""], ["proof (state)\nthis:\n  keys s - X \\<noteq> {}\n  keys t - X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>keys s - X \\<noteq> {}; keys t - X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (elem_index ` (keys s - X) \\<union>\n                           elem_index ` (keys t - X)) =\n                      max (Max (elem_index ` (keys s - X)))\n                       (Max (elem_index ` (keys t - X)))", "have \"finite (elem_index ` (keys s - X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (elem_index ` (keys s - X))", "by simp"], ["proof (state)\nthis:\n  finite (elem_index ` (keys s - X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>keys s - X \\<noteq> {}; keys t - X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (elem_index ` (keys s - X) \\<union>\n                           elem_index ` (keys t - X)) =\n                      max (Max (elem_index ` (keys s - X)))\n                       (Max (elem_index ` (keys t - X)))", "moreover"], ["proof (state)\nthis:\n  finite (elem_index ` (keys s - X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>keys s - X \\<noteq> {}; keys t - X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (elem_index ` (keys s - X) \\<union>\n                           elem_index ` (keys t - X)) =\n                      max (Max (elem_index ` (keys s - X)))\n                       (Max (elem_index ` (keys t - X)))", "from 1"], ["proof (chain)\npicking this:\n  keys s - X \\<noteq> {}", "have \"elem_index ` (keys s - X) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  keys s - X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. elem_index ` (keys s - X) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  elem_index ` (keys s - X) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>keys s - X \\<noteq> {}; keys t - X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (elem_index ` (keys s - X) \\<union>\n                           elem_index ` (keys t - X)) =\n                      max (Max (elem_index ` (keys s - X)))\n                       (Max (elem_index ` (keys t - X)))", "moreover"], ["proof (state)\nthis:\n  elem_index ` (keys s - X) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>keys s - X \\<noteq> {}; keys t - X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (elem_index ` (keys s - X) \\<union>\n                           elem_index ` (keys t - X)) =\n                      max (Max (elem_index ` (keys s - X)))\n                       (Max (elem_index ` (keys t - X)))", "have \"finite (elem_index ` (keys t - X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (elem_index ` (keys t - X))", "by simp"], ["proof (state)\nthis:\n  finite (elem_index ` (keys t - X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>keys s - X \\<noteq> {}; keys t - X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (elem_index ` (keys s - X) \\<union>\n                           elem_index ` (keys t - X)) =\n                      max (Max (elem_index ` (keys s - X)))\n                       (Max (elem_index ` (keys t - X)))", "moreover"], ["proof (state)\nthis:\n  finite (elem_index ` (keys t - X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>keys s - X \\<noteq> {}; keys t - X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (elem_index ` (keys s - X) \\<union>\n                           elem_index ` (keys t - X)) =\n                      max (Max (elem_index ` (keys s - X)))\n                       (Max (elem_index ` (keys t - X)))", "from 2"], ["proof (chain)\npicking this:\n  keys t - X \\<noteq> {}", "have \"elem_index ` (keys t - X) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  keys t - X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. elem_index ` (keys t - X) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  elem_index ` (keys t - X) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>keys s - X \\<noteq> {}; keys t - X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (elem_index ` (keys s - X) \\<union>\n                           elem_index ` (keys t - X)) =\n                      max (Max (elem_index ` (keys s - X)))\n                       (Max (elem_index ` (keys t - X)))", "ultimately"], ["proof (chain)\npicking this:\n  finite (elem_index ` (keys s - X))\n  elem_index ` (keys s - X) \\<noteq> {}\n  finite (elem_index ` (keys t - X))\n  elem_index ` (keys t - X) \\<noteq> {}", "show \"Max (elem_index ` (keys s - X) \\<union> elem_index ` (keys t - X)) =\n                    max (Max (elem_index ` (keys s - X))) (Max (elem_index ` (keys t - X)))\""], ["proof (prove)\nusing this:\n  finite (elem_index ` (keys s - X))\n  elem_index ` (keys s - X) \\<noteq> {}\n  finite (elem_index ` (keys t - X))\n  elem_index ` (keys t - X) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (elem_index ` (keys s - X) \\<union> elem_index ` (keys t - X)) =\n    max (Max (elem_index ` (keys s - X))) (Max (elem_index ` (keys t - X)))", "by (rule Max_Un)"], ["proof (state)\nthis:\n  Max (elem_index ` (keys s - X) \\<union> elem_index ` (keys t - X)) =\n  max (Max (elem_index ` (keys s - X))) (Max (elem_index ` (keys t - X)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dickson_grading_varnum:\n  assumes \"finite X\"\n  shows \"dickson_grading ((varnum X)::('x::countable \\<Rightarrow>\\<^sub>0 'b::add_wellorder) \\<Rightarrow> nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_grading (varnum X)", "using varnum_plus"], ["proof (prove)\nusing this:\n  varnum ?X (?s + ?t) = max (varnum ?X ?s) (varnum ?X ?t)\n\ngoal (1 subgoal):\n 1. dickson_grading (varnum X)", "proof (rule dickson_gradingI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. almost_full_on (adds) {x. varnum X x \\<le> n}", "fix m::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. almost_full_on (adds) {x. varnum X x \\<le> n}", "let ?V = \"X \\<union> {x. elem_index x < m}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. almost_full_on (adds) {x. varnum X x \\<le> n}", "have \"{t::'x \\<Rightarrow>\\<^sub>0 'b. varnum X t \\<le> m} \\<subseteq> {t. keys t \\<subseteq> ?V}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. varnum X t \\<le> m}\n    \\<subseteq> {t. keys t \\<subseteq> X \\<union> {x. elem_index x < m}}", "proof (rule, simp, intro subsetI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>varnum X x \\<le> m; xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> X \\<or> elem_index xa < m", "fix t::\"'x \\<Rightarrow>\\<^sub>0 'b\" and x::'x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>varnum X x \\<le> m; xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> X \\<or> elem_index xa < m", "assume \"varnum X t \\<le> m\""], ["proof (state)\nthis:\n  varnum X t \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>varnum X x \\<le> m; xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> X \\<or> elem_index xa < m", "assume \"x \\<in> keys t\""], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>varnum X x \\<le> m; xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> X \\<or> elem_index xa < m", "thus \"x \\<in> X \\<or> elem_index x < m\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<or> elem_index x < m", "proof (rule elem_index_less_varnum)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> ?X \\<Longrightarrow> x \\<in> X \\<or> elem_index x < m\n 2. elem_index x < varnum ?X t \\<Longrightarrow>\n    x \\<in> X \\<or> elem_index x < m", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. x \\<in> ?X \\<Longrightarrow> x \\<in> X \\<or> elem_index x < m\n 2. elem_index x < varnum ?X t \\<Longrightarrow>\n    x \\<in> X \\<or> elem_index x < m", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<or> elem_index x < m", ".."], ["proof (state)\nthis:\n  x \\<in> X \\<or> elem_index x < m\n\ngoal (1 subgoal):\n 1. elem_index x < varnum X t \\<Longrightarrow>\n    x \\<in> X \\<or> elem_index x < m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. elem_index x < varnum X t \\<Longrightarrow>\n    x \\<in> X \\<or> elem_index x < m", "assume \"elem_index x < varnum X t\""], ["proof (state)\nthis:\n  elem_index x < varnum X t\n\ngoal (1 subgoal):\n 1. elem_index x < varnum X t \\<Longrightarrow>\n    x \\<in> X \\<or> elem_index x < m", "hence \"elem_index x < m\""], ["proof (prove)\nusing this:\n  elem_index x < varnum X t\n\ngoal (1 subgoal):\n 1. elem_index x < m", "using \\<open>varnum X t \\<le> m\\<close>"], ["proof (prove)\nusing this:\n  elem_index x < varnum X t\n  varnum X t \\<le> m\n\ngoal (1 subgoal):\n 1. elem_index x < m", "by (rule less_le_trans)"], ["proof (state)\nthis:\n  elem_index x < m\n\ngoal (1 subgoal):\n 1. elem_index x < varnum X t \\<Longrightarrow>\n    x \\<in> X \\<or> elem_index x < m", "thus ?thesis"], ["proof (prove)\nusing this:\n  elem_index x < m\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<or> elem_index x < m", ".."], ["proof (state)\nthis:\n  x \\<in> X \\<or> elem_index x < m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> X \\<or> elem_index x < m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {t. varnum X t \\<le> m}\n  \\<subseteq> {t. keys t \\<subseteq> X \\<union> {x. elem_index x < m}}\n\ngoal (1 subgoal):\n 1. \\<And>n. almost_full_on (adds) {x. varnum X x \\<le> n}", "thus \"almost_full_on (adds) {t::'x \\<Rightarrow>\\<^sub>0 'b. varnum X t \\<le> m}\""], ["proof (prove)\nusing this:\n  {t. varnum X t \\<le> m}\n  \\<subseteq> {t. keys t \\<subseteq> X \\<union> {x. elem_index x < m}}\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) {t. varnum X t \\<le> m}", "proof (rule almost_full_on_subset)"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_full_on (adds)\n     {t. keys t \\<subseteq> X \\<union> {x. elem_index x < m}}", "from assms finite_nat_seg"], ["proof (chain)\npicking this:\n  finite X\n  finite {x. elem_index x < ?n}", "have \"finite ?V\""], ["proof (prove)\nusing this:\n  finite X\n  finite {x. elem_index x < ?n}\n\ngoal (1 subgoal):\n 1. finite (X \\<union> {x. elem_index x < m})", "by (rule finite_UnI)"], ["proof (state)\nthis:\n  finite (X \\<union> {x. elem_index x < m})\n\ngoal (1 subgoal):\n 1. almost_full_on (adds)\n     {t. keys t \\<subseteq> X \\<union> {x. elem_index x < m}}", "thus \"almost_full_on (adds) {t::'x \\<Rightarrow>\\<^sub>0 'b. keys t \\<subseteq> ?V}\""], ["proof (prove)\nusing this:\n  finite (X \\<union> {x. elem_index x < m})\n\ngoal (1 subgoal):\n 1. almost_full_on (adds)\n     {t. keys t \\<subseteq> X \\<union> {x. elem_index x < m}}", "by (rule Dickson_poly_mapping)"], ["proof (state)\nthis:\n  almost_full_on (adds)\n   {t. keys t \\<subseteq> X \\<union> {x. elem_index x < m}}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_full_on (adds) {t. varnum X t \\<le> m}\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary dickson_grading_varnum_empty:\n  \"dickson_grading ((varnum {})::(_ \\<Rightarrow>\\<^sub>0 _::add_wellorder) \\<Rightarrow> nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_grading (varnum {})", "using finite.emptyI"], ["proof (prove)\nusing this:\n  finite {}\n\ngoal (1 subgoal):\n 1. dickson_grading (varnum {})", "by (rule dickson_grading_varnum)"], ["", "lemma varnum_le_iff: \"varnum X t \\<le> n \\<longleftrightarrow> keys t \\<subseteq> X \\<union> {x. elem_index x < n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (varnum X t \\<le> n) =\n    (keys t \\<subseteq> X \\<union> {x. elem_index x < n})", "by (auto simp: varnum_def Suc_le_eq)"], ["", "lemma varnum_zero [simp]: \"varnum X 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. varnum X 0 = 0", "by (simp add: varnum_def)"], ["", "lemma varnum_empty_eq_zero_iff: \"varnum {} t = 0 \\<longleftrightarrow> t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (varnum {} t = 0) = (t = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. varnum {} t = 0 \\<Longrightarrow> t = 0\n 2. t = 0 \\<Longrightarrow> varnum {} t = 0", "assume \"varnum {} t = 0\""], ["proof (state)\nthis:\n  varnum {} t = 0\n\ngoal (2 subgoals):\n 1. varnum {} t = 0 \\<Longrightarrow> t = 0\n 2. t = 0 \\<Longrightarrow> varnum {} t = 0", "hence \"keys t = {}\""], ["proof (prove)\nusing this:\n  varnum {} t = 0\n\ngoal (1 subgoal):\n 1. keys t = {}", "by (simp add: varnum_def split: if_splits)"], ["proof (state)\nthis:\n  keys t = {}\n\ngoal (2 subgoals):\n 1. varnum {} t = 0 \\<Longrightarrow> t = 0\n 2. t = 0 \\<Longrightarrow> varnum {} t = 0", "thus \"t = 0\""], ["proof (prove)\nusing this:\n  keys t = {}\n\ngoal (1 subgoal):\n 1. t = 0", "by (rule poly_mapping_eq_zeroI)"], ["proof (state)\nthis:\n  t = 0\n\ngoal (1 subgoal):\n 1. t = 0 \\<Longrightarrow> varnum {} t = 0", "qed simp"], ["", "instance poly_mapping :: (countable, add_wellorder) graded_dickson_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>0 'b, graded_dickson_powerprod_class)", "by standard (rule, fact dickson_grading_varnum_empty)"], ["", "instance poly_mapping :: (finite, add_wellorder) dickson_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>0 'b, dickson_powerprod_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_full_on (adds) UNIV", "have \"finite (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "by simp"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) UNIV", "hence \"almost_full_on (adds) {x::'a \\<Rightarrow>\\<^sub>0 'b. keys x \\<subseteq> UNIV}\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. keys x \\<subseteq> UNIV}", "by (rule Dickson_poly_mapping)"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. keys x \\<subseteq> UNIV}\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) UNIV", "thus \"almost_full_on (adds) (UNIV::('a \\<Rightarrow>\\<^sub>0 'b) set)\""], ["proof (prove)\nusing this:\n  almost_full_on (adds) {x. keys x \\<subseteq> UNIV}\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) UNIV", "by simp"], ["proof (state)\nthis:\n  almost_full_on (adds) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lexicographic Term Order\\<close>"], ["", "definition lex_pm :: \"('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a::linorder \\<Rightarrow>\\<^sub>0 'b::{zero,linorder}) \\<Rightarrow> bool\"\n  where \"lex_pm = (\\<le>)\""], ["", "definition lex_pm_strict :: \"('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a::linorder \\<Rightarrow>\\<^sub>0 'b::{zero,linorder}) \\<Rightarrow> bool\"\n  where \"lex_pm_strict = (<)\""], ["", "lemma lex_pm_alt: \"lex_pm s t = (s = t \\<or> (\\<exists>x. lookup s x < lookup t x \\<and> (\\<forall>y<x. lookup s y = lookup t y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm s t =\n    (s = t \\<or>\n     (\\<exists>x.\n         lookup s x < lookup t x \\<and>\n         (\\<forall>y<x. lookup s y = lookup t y)))", "unfolding lex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<le> t) =\n    (s = t \\<or>\n     (\\<exists>x.\n         lookup s x < lookup t x \\<and>\n         (\\<forall>y<x. lookup s y = lookup t y)))", "by (metis less_eq_poly_mapping.rep_eq less_funE less_funI poly_mapping_eq_iff)"], ["", "lemma lex_pm_refl: \"lex_pm s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm s s", "by (simp add: lex_pm_def)"], ["", "lemma lex_pm_antisym: \"lex_pm s t \\<Longrightarrow> lex_pm t s \\<Longrightarrow> s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lex_pm s t; lex_pm t s\\<rbrakk> \\<Longrightarrow> s = t", "by (simp add: lex_pm_def)"], ["", "lemma lex_pm_trans: \"lex_pm s t \\<Longrightarrow> lex_pm t u \\<Longrightarrow> lex_pm s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lex_pm s t; lex_pm t u\\<rbrakk> \\<Longrightarrow> lex_pm s u", "by (simp add: lex_pm_def)"], ["", "lemma lex_pm_lin: \"lex_pm s t \\<or> lex_pm t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm s t \\<or> lex_pm t s", "by (simp add: lex_pm_def linear)"], ["", "corollary lex_pm_strict_alt [code]: \"lex_pm_strict s t = (\\<not> lex_pm t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm_strict s t = (\\<not> lex_pm t s)", "by (auto simp: lex_pm_strict_def lex_pm_def)"], ["", "lemma lex_pm_zero_min: \"lex_pm 0 s\" for s::\"_ \\<Rightarrow>\\<^sub>0 _::add_linorder_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm 0 s", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lex_pm 0 s \\<Longrightarrow> False", "assume \"\\<not> lex_pm 0 s\""], ["proof (state)\nthis:\n  \\<not> lex_pm 0 s\n\ngoal (1 subgoal):\n 1. \\<not> lex_pm 0 s \\<Longrightarrow> False", "hence \"lex_pm_strict s 0\""], ["proof (prove)\nusing this:\n  \\<not> lex_pm 0 s\n\ngoal (1 subgoal):\n 1. lex_pm_strict s 0", "by (simp add: lex_pm_strict_alt)"], ["proof (state)\nthis:\n  lex_pm_strict s 0\n\ngoal (1 subgoal):\n 1. \\<not> lex_pm 0 s \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lex_pm_strict s 0\n\ngoal (1 subgoal):\n 1. False", "by (simp add: lex_pm_strict_def less_poly_mapping.rep_eq less_fun_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_pm_plus_monotone: \"lex_pm s t \\<Longrightarrow> lex_pm (s + u) (t + u)\"\n  for s t::\"_ \\<Rightarrow>\\<^sub>0 _::{ordered_comm_monoid_add, ordered_ab_semigroup_add_imp_le}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm s t \\<Longrightarrow> lex_pm (s + u) (t + u)", "by (simp add: lex_pm_def add_right_mono)"], ["", "subsubsection \\<open>Degree\\<close>"], ["", "lift_definition deg_pm::\"('a \\<Rightarrow>\\<^sub>0 'b::comm_monoid_add) \\<Rightarrow> 'b\" is deg_fun"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma deg_pm_zero[simp]: \"deg_pm 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm 0 = (0::'a)", "by (simp add: deg_pm.rep_eq lookup_zero_fun)"], ["", "lemma deg_pm_eq_0_iff[simp]: \"deg_pm s = 0 \\<longleftrightarrow> s = 0\" for s::\"'a \\<Rightarrow>\\<^sub>0 'b::add_linorder_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (deg_pm s = (0::'b)) = (s = 0)", "by (simp only: deg_pm.rep_eq poly_mapping_eq_iff lookup_zero_fun, rule deg_fun_eq_0_iff,\n      simp add: keys_eq_supp[symmetric])"], ["", "lemma deg_pm_superset:\n  assumes \"keys s \\<subseteq> A\" and \"finite A\"\n  shows \"deg_pm s = (\\<Sum>x\\<in>A. lookup s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm s = sum (lookup s) A", "using assms"], ["proof (prove)\nusing this:\n  keys s \\<subseteq> A\n  finite A\n\ngoal (1 subgoal):\n 1. deg_pm s = sum (lookup s) A", "by (simp only: deg_pm.rep_eq keys_eq_supp, elim deg_fun_superset)"], ["", "lemma deg_pm_plus: \"deg_pm (s + t) = deg_pm s + deg_pm (t::'a \\<Rightarrow>\\<^sub>0 'b::comm_monoid_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (s + t) = deg_pm s + deg_pm t", "by (simp only: deg_pm.rep_eq lookup_plus_fun, rule deg_fun_plus, simp_all add: keys_eq_supp[symmetric])"], ["", "lemma deg_pm_single: \"deg_pm (Poly_Mapping.single x k) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (Poly_Mapping.single x k) = k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm (Poly_Mapping.single x k) = k", "have \"keys (Poly_Mapping.single x k) \\<subseteq> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (Poly_Mapping.single x k) \\<subseteq> {x}", "by simp"], ["proof (state)\nthis:\n  keys (Poly_Mapping.single x k) \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. deg_pm (Poly_Mapping.single x k) = k", "moreover"], ["proof (state)\nthis:\n  keys (Poly_Mapping.single x k) \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. deg_pm (Poly_Mapping.single x k) = k", "have \"finite {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x}", "by simp"], ["proof (state)\nthis:\n  finite {x}\n\ngoal (1 subgoal):\n 1. deg_pm (Poly_Mapping.single x k) = k", "ultimately"], ["proof (chain)\npicking this:\n  keys (Poly_Mapping.single x k) \\<subseteq> {x}\n  finite {x}", "have \"deg_pm (Poly_Mapping.single x k) = (\\<Sum>y\\<in>{x}. lookup (Poly_Mapping.single x k) y)\""], ["proof (prove)\nusing this:\n  keys (Poly_Mapping.single x k) \\<subseteq> {x}\n  finite {x}\n\ngoal (1 subgoal):\n 1. deg_pm (Poly_Mapping.single x k) =\n    sum (lookup (Poly_Mapping.single x k)) {x}", "by (rule deg_pm_superset)"], ["proof (state)\nthis:\n  deg_pm (Poly_Mapping.single x k) =\n  sum (lookup (Poly_Mapping.single x k)) {x}\n\ngoal (1 subgoal):\n 1. deg_pm (Poly_Mapping.single x k) = k", "also"], ["proof (state)\nthis:\n  deg_pm (Poly_Mapping.single x k) =\n  sum (lookup (Poly_Mapping.single x k)) {x}\n\ngoal (1 subgoal):\n 1. deg_pm (Poly_Mapping.single x k) = k", "have \"... = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup (Poly_Mapping.single x k)) {x} = k", "by simp"], ["proof (state)\nthis:\n  sum (lookup (Poly_Mapping.single x k)) {x} = k\n\ngoal (1 subgoal):\n 1. deg_pm (Poly_Mapping.single x k) = k", "finally"], ["proof (chain)\npicking this:\n  deg_pm (Poly_Mapping.single x k) = k", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pm (Poly_Mapping.single x k) = k\n\ngoal (1 subgoal):\n 1. deg_pm (Poly_Mapping.single x k) = k", "."], ["proof (state)\nthis:\n  deg_pm (Poly_Mapping.single x k) = k\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>General Degree-Orders\\<close>"], ["", "context linorder\nbegin"], ["", "lift_definition dord_pm::\"(('a \\<Rightarrow>\\<^sub>0 'b::ordered_comm_monoid_add) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> bool\"\n  is dord_fun"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>finite {xa. x xa \\<noteq> (0::'b)};\n                    finite {x. xa x \\<noteq> (0::'b)}\\<rbrakk>\n                   \\<Longrightarrow> fun1 x xa = fun2 x xa;\n        finite {x. fun3 x \\<noteq> (0::'b)};\n        finite {x. fun4 x \\<noteq> (0::'b)}\\<rbrakk>\n       \\<Longrightarrow> dord_fun fun1 fun3 fun4 = dord_fun fun2 fun3 fun4", "by (metis local.dord_fun_def)"], ["", "lemma dord_pm_alt: \"dord_pm ord = (\\<lambda>x y. deg_pm x < deg_pm y \\<or> (deg_pm x = deg_pm y \\<and> ord x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm ord =\n    (\\<lambda>x y.\n        deg_pm x < deg_pm y \\<or> deg_pm x = deg_pm y \\<and> ord x y)", "by (intro ext) (transfer, simp add: dord_fun_def Let_def)"], ["", "lemma dord_pm_degD:\n  assumes \"dord_pm ord s t\"\n  shows \"deg_pm s \\<le> deg_pm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm s \\<le> deg_pm t", "using assms"], ["proof (prove)\nusing this:\n  dord_pm ord s t\n\ngoal (1 subgoal):\n 1. deg_pm s \\<le> deg_pm t", "by (simp only: dord_pm.rep_eq deg_pm.rep_eq, elim dord_fun_degD)"], ["", "lemma dord_pm_refl:\n  assumes \"ord s s\"\n  shows \"dord_pm ord s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm ord s s", "using assms"], ["proof (prove)\nusing this:\n  ord s s\n\ngoal (1 subgoal):\n 1. dord_pm ord s s", "by (simp only: dord_pm.rep_eq, intro dord_fun_refl, simp add: lookup_inverse)"], ["", "lemma dord_pm_antisym:\n  assumes \"ord s t \\<Longrightarrow> ord t s \\<Longrightarrow> s = t\" and \"dord_pm ord s t\" and \"dord_pm ord t s\"\n  shows \"s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>ord s t; ord t s\\<rbrakk> \\<Longrightarrow> s = t\n  dord_pm ord s t\n  dord_pm ord t s\n\ngoal (1 subgoal):\n 1. s = t", "proof (simp only: dord_pm.rep_eq poly_mapping_eq_iff)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ord s t; ord t s\\<rbrakk>\n             \\<Longrightarrow> lookup s = lookup t;\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup s) (lookup t);\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup t) (lookup s)\\<rbrakk>\n    \\<Longrightarrow> lookup s = lookup t", "assume 1: \"(ord s t \\<Longrightarrow> ord t s \\<Longrightarrow> lookup s = lookup t)\""], ["proof (state)\nthis:\n  \\<lbrakk>ord s t; ord t s\\<rbrakk> \\<Longrightarrow> lookup s = lookup t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ord s t; ord t s\\<rbrakk>\n             \\<Longrightarrow> lookup s = lookup t;\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup s) (lookup t);\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup t) (lookup s)\\<rbrakk>\n    \\<Longrightarrow> lookup s = lookup t", "assume 2: \"dord_fun (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping) (lookup s) (lookup t)\""], ["proof (state)\nthis:\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup s) (lookup t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ord s t; ord t s\\<rbrakk>\n             \\<Longrightarrow> lookup s = lookup t;\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup s) (lookup t);\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup t) (lookup s)\\<rbrakk>\n    \\<Longrightarrow> lookup s = lookup t", "assume 3: \"dord_fun (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping) (lookup t) (lookup s)\""], ["proof (state)\nthis:\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup t) (lookup s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ord s t; ord t s\\<rbrakk>\n             \\<Longrightarrow> lookup s = lookup t;\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup s) (lookup t);\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup t) (lookup s)\\<rbrakk>\n    \\<Longrightarrow> lookup s = lookup t", "from _ 2 3"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup s) (lookup t)\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup t) (lookup s)", "show \"lookup s = lookup t\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup s) (lookup t)\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup t) (lookup s)\n\ngoal (1 subgoal):\n 1. lookup s = lookup t", "by (rule dord_fun_antisym, simp add: lookup_inverse 1)"], ["proof (state)\nthis:\n  lookup s = lookup t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dord_pm_trans:\n  assumes \"ord s t \\<Longrightarrow> ord t u \\<Longrightarrow> ord s u\" and \"dord_pm ord s t\" and \"dord_pm ord t u\"\n  shows \"dord_pm ord s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm ord s u", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>ord s t; ord t u\\<rbrakk> \\<Longrightarrow> ord s u\n  dord_pm ord s t\n  dord_pm ord t u\n\ngoal (1 subgoal):\n 1. dord_pm ord s u", "proof (simp only: dord_pm.rep_eq poly_mapping_eq_iff)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ord s t; ord t u\\<rbrakk> \\<Longrightarrow> ord s u;\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup s) (lookup t);\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup t) (lookup u)\\<rbrakk>\n    \\<Longrightarrow> dord_fun\n                       (map_fun Abs_poly_mapping id \\<circ> ord \\<circ>\n                        Abs_poly_mapping)\n                       (lookup s) (lookup u)", "assume 1: \"(ord s t \\<Longrightarrow> ord t u \\<Longrightarrow> ord s u)\""], ["proof (state)\nthis:\n  \\<lbrakk>ord s t; ord t u\\<rbrakk> \\<Longrightarrow> ord s u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ord s t; ord t u\\<rbrakk> \\<Longrightarrow> ord s u;\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup s) (lookup t);\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup t) (lookup u)\\<rbrakk>\n    \\<Longrightarrow> dord_fun\n                       (map_fun Abs_poly_mapping id \\<circ> ord \\<circ>\n                        Abs_poly_mapping)\n                       (lookup s) (lookup u)", "assume 2: \"dord_fun (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping) (lookup s) (lookup t)\""], ["proof (state)\nthis:\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup s) (lookup t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ord s t; ord t u\\<rbrakk> \\<Longrightarrow> ord s u;\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup s) (lookup t);\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup t) (lookup u)\\<rbrakk>\n    \\<Longrightarrow> dord_fun\n                       (map_fun Abs_poly_mapping id \\<circ> ord \\<circ>\n                        Abs_poly_mapping)\n                       (lookup s) (lookup u)", "assume 3: \"dord_fun (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping) (lookup t) (lookup u)\""], ["proof (state)\nthis:\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup t) (lookup u)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ord s t; ord t u\\<rbrakk> \\<Longrightarrow> ord s u;\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup s) (lookup t);\n     dord_fun\n      (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n      (lookup t) (lookup u)\\<rbrakk>\n    \\<Longrightarrow> dord_fun\n                       (map_fun Abs_poly_mapping id \\<circ> ord \\<circ>\n                        Abs_poly_mapping)\n                       (lookup s) (lookup u)", "from _ 2 3"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup s) (lookup t)\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup t) (lookup u)", "show \"dord_fun (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping) (lookup s) (lookup u)\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup s) (lookup t)\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup t) (lookup u)\n\ngoal (1 subgoal):\n 1. dord_fun\n     (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n     (lookup s) (lookup u)", "by (rule dord_fun_trans, simp add: lookup_inverse 1)"], ["proof (state)\nthis:\n  dord_fun\n   (map_fun Abs_poly_mapping id \\<circ> ord \\<circ> Abs_poly_mapping)\n   (lookup s) (lookup u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dord_pm_lin:\n  \"dord_pm ord s t \\<or> dord_pm ord t s\"\n  if \"ord s t \\<or> ord t s\"\n  for s t::\"'a \\<Rightarrow>\\<^sub>0 'b::{ordered_comm_monoid_add, linorder}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm ord s t \\<or> dord_pm ord t s", "using that"], ["proof (prove)\nusing this:\n  ord s t \\<or> ord t s\n\ngoal (1 subgoal):\n 1. dord_pm ord s t \\<or> dord_pm ord t s", "by (simp only: dord_pm.rep_eq, intro dord_fun_lin, simp add: lookup_inverse)"], ["", "lemma dord_pm_zero_min: \"dord_pm ord 0 s\"\n  if ord_refl: \"\\<And>t. ord t t\"\n  for s t::\"'a \\<Rightarrow>\\<^sub>0 'b::add_linorder_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm ord 0 s", "using that"], ["proof (prove)\nusing this:\n  ord ?t ?t\n\ngoal (1 subgoal):\n 1. dord_pm ord 0 s", "by (simp only: dord_pm.rep_eq lookup_zero_fun, intro dord_fun_zero_min,\n      simp add: lookup_inverse, simp add: keys_eq_supp[symmetric])"], ["", "lemma dord_pm_plus_monotone:\n  fixes s t u ::\"'a \\<Rightarrow>\\<^sub>0 'b::{ordered_comm_monoid_add, ordered_ab_semigroup_add_imp_le}\"\n  assumes \"ord s t \\<Longrightarrow> ord (s + u) (t + u)\" and \"dord_pm ord s t\"\n  shows \"dord_pm ord (s + u) (t + u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm ord (s + u) (t + u)", "using assms"], ["proof (prove)\nusing this:\n  ord s t \\<Longrightarrow> ord (s + u) (t + u)\n  dord_pm ord s t\n\ngoal (1 subgoal):\n 1. dord_pm ord (s + u) (t + u)", "by (simp only: dord_pm.rep_eq lookup_plus_fun, intro dord_fun_plus_monotone,\n      simp add: lookup_inverse lookup_plus_fun[symmetric],\n      simp add: keys_eq_supp[symmetric],\n      simp add: keys_eq_supp[symmetric],\n      simp add: keys_eq_supp[symmetric],\n      simp add: lookup_inverse)"], ["", "end"], ["", "(* linorder *)"], ["", "subsubsection \\<open>Degree-Lexicographic Term Order\\<close>"], ["", "definition dlex_pm::\"('a::linorder \\<Rightarrow>\\<^sub>0 'b::{ordered_comm_monoid_add,linorder}) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> bool\"\n  where \"dlex_pm \\<equiv> dord_pm lex_pm\""], ["", "definition \"dlex_pm_strict s t \\<longleftrightarrow> dlex_pm s t \\<and> \\<not> dlex_pm t s\""], ["", "lemma dlex_pm_refl: \"dlex_pm s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pm s s", "unfolding dlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm lex_pm s s", "using lex_pm_refl"], ["proof (prove)\nusing this:\n  lex_pm ?s ?s\n\ngoal (1 subgoal):\n 1. dord_pm lex_pm s s", "by (rule dord_pm_refl)"], ["", "lemma dlex_pm_antisym: \"dlex_pm s t \\<Longrightarrow> dlex_pm t s \\<Longrightarrow> s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dlex_pm s t; dlex_pm t s\\<rbrakk> \\<Longrightarrow> s = t", "unfolding dlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dord_pm lex_pm s t; dord_pm lex_pm t s\\<rbrakk>\n    \\<Longrightarrow> s = t", "using lex_pm_antisym"], ["proof (prove)\nusing this:\n  \\<lbrakk>lex_pm ?s ?t; lex_pm ?t ?s\\<rbrakk> \\<Longrightarrow> ?s = ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dord_pm lex_pm s t; dord_pm lex_pm t s\\<rbrakk>\n    \\<Longrightarrow> s = t", "by (rule dord_pm_antisym)"], ["", "lemma dlex_pm_trans: \"dlex_pm s t \\<Longrightarrow> dlex_pm t u \\<Longrightarrow> dlex_pm s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dlex_pm s t; dlex_pm t u\\<rbrakk> \\<Longrightarrow> dlex_pm s u", "unfolding dlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dord_pm lex_pm s t; dord_pm lex_pm t u\\<rbrakk>\n    \\<Longrightarrow> dord_pm lex_pm s u", "using lex_pm_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>lex_pm ?s ?t; lex_pm ?t ?u\\<rbrakk>\n  \\<Longrightarrow> lex_pm ?s ?u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dord_pm lex_pm s t; dord_pm lex_pm t u\\<rbrakk>\n    \\<Longrightarrow> dord_pm lex_pm s u", "by (rule dord_pm_trans)"], ["", "lemma dlex_pm_lin: \"dlex_pm s t \\<or> dlex_pm t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pm s t \\<or> dlex_pm t s", "unfolding dlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm lex_pm s t \\<or> dord_pm lex_pm t s", "using lex_pm_lin"], ["proof (prove)\nusing this:\n  lex_pm ?s ?t \\<or> lex_pm ?t ?s\n\ngoal (1 subgoal):\n 1. dord_pm lex_pm s t \\<or> dord_pm lex_pm t s", "by (rule dord_pm_lin)"], ["", "corollary dlex_pm_strict_alt [code]: \"dlex_pm_strict s t = (\\<not> dlex_pm t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pm_strict s t = (\\<not> dlex_pm t s)", "unfolding dlex_pm_strict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict dlex_pm s t = (\\<not> dlex_pm t s)", "using dlex_pm_lin"], ["proof (prove)\nusing this:\n  dlex_pm ?s ?t \\<or> dlex_pm ?t ?s\n\ngoal (1 subgoal):\n 1. strict dlex_pm s t = (\\<not> dlex_pm t s)", "by auto"], ["", "lemma dlex_pm_zero_min: \"dlex_pm 0 s\"\n  for s t::\"(_ \\<Rightarrow>\\<^sub>0 _::add_linorder_min)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pm 0 s", "unfolding dlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm lex_pm 0 s", "using lex_pm_refl"], ["proof (prove)\nusing this:\n  lex_pm ?s ?s\n\ngoal (1 subgoal):\n 1. dord_pm lex_pm 0 s", "by (rule dord_pm_zero_min)"], ["", "lemma dlex_pm_plus_monotone: \"dlex_pm s t \\<Longrightarrow> dlex_pm (s + u) (t + u)\"\n  for s t::\"_ \\<Rightarrow>\\<^sub>0 _::{ordered_ab_semigroup_add_imp_le, ordered_cancel_comm_monoid_add}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pm s t \\<Longrightarrow> dlex_pm (s + u) (t + u)", "unfolding dlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm lex_pm s t \\<Longrightarrow> dord_pm lex_pm (s + u) (t + u)", "using lex_pm_plus_monotone"], ["proof (prove)\nusing this:\n  lex_pm ?s ?t \\<Longrightarrow> lex_pm (?s + ?u) (?t + ?u)\n\ngoal (1 subgoal):\n 1. dord_pm lex_pm s t \\<Longrightarrow> dord_pm lex_pm (s + u) (t + u)", "by (rule dord_pm_plus_monotone)"], ["", "subsubsection \\<open>Degree-Reverse-Lexicographic Term Order\\<close>"], ["", "definition drlex_pm::\"('a::linorder \\<Rightarrow>\\<^sub>0 'b::{ordered_comm_monoid_add,linorder}) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> bool\"\n  where \"drlex_pm \\<equiv> dord_pm (\\<lambda>s t. lex_pm t s)\""], ["", "definition \"drlex_pm_strict s t \\<longleftrightarrow> drlex_pm s t \\<and> \\<not> drlex_pm t s\""], ["", "lemma drlex_pm_refl: \"drlex_pm s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pm s s", "unfolding drlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm (\\<lambda>s t. lex_pm t s) s s", "using lex_pm_refl"], ["proof (prove)\nusing this:\n  lex_pm ?s ?s\n\ngoal (1 subgoal):\n 1. dord_pm (\\<lambda>s t. lex_pm t s) s s", "by (rule dord_pm_refl)"], ["", "lemma drlex_pm_antisym: \"drlex_pm s t \\<Longrightarrow> drlex_pm t s \\<Longrightarrow> s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drlex_pm s t; drlex_pm t s\\<rbrakk> \\<Longrightarrow> s = t", "unfolding drlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dord_pm (\\<lambda>s t. lex_pm t s) s t;\n     dord_pm (\\<lambda>s t. lex_pm t s) t s\\<rbrakk>\n    \\<Longrightarrow> s = t", "using lex_pm_antisym"], ["proof (prove)\nusing this:\n  \\<lbrakk>lex_pm ?s ?t; lex_pm ?t ?s\\<rbrakk> \\<Longrightarrow> ?s = ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dord_pm (\\<lambda>s t. lex_pm t s) s t;\n     dord_pm (\\<lambda>s t. lex_pm t s) t s\\<rbrakk>\n    \\<Longrightarrow> s = t", "by (rule dord_pm_antisym)"], ["", "lemma drlex_pm_trans: \"drlex_pm s t \\<Longrightarrow> drlex_pm t u \\<Longrightarrow> drlex_pm s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drlex_pm s t; drlex_pm t u\\<rbrakk>\n    \\<Longrightarrow> drlex_pm s u", "unfolding drlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dord_pm (\\<lambda>s t. lex_pm t s) s t;\n     dord_pm (\\<lambda>s t. lex_pm t s) t u\\<rbrakk>\n    \\<Longrightarrow> dord_pm (\\<lambda>s t. lex_pm t s) s u", "using lex_pm_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>lex_pm ?s ?t; lex_pm ?t ?u\\<rbrakk>\n  \\<Longrightarrow> lex_pm ?s ?u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dord_pm (\\<lambda>s t. lex_pm t s) s t;\n     dord_pm (\\<lambda>s t. lex_pm t s) t u\\<rbrakk>\n    \\<Longrightarrow> dord_pm (\\<lambda>s t. lex_pm t s) s u", "by (rule dord_pm_trans)"], ["", "lemma drlex_pm_lin: \"drlex_pm s t \\<or> drlex_pm t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pm s t \\<or> drlex_pm t s", "unfolding drlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm (\\<lambda>s t. lex_pm t s) s t \\<or>\n    dord_pm (\\<lambda>s t. lex_pm t s) t s", "using lex_pm_lin"], ["proof (prove)\nusing this:\n  lex_pm ?s ?t \\<or> lex_pm ?t ?s\n\ngoal (1 subgoal):\n 1. dord_pm (\\<lambda>s t. lex_pm t s) s t \\<or>\n    dord_pm (\\<lambda>s t. lex_pm t s) t s", "by (rule dord_pm_lin)"], ["", "corollary drlex_pm_strict_alt [code]: \"drlex_pm_strict s t = (\\<not> drlex_pm t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pm_strict s t = (\\<not> drlex_pm t s)", "unfolding drlex_pm_strict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict drlex_pm s t = (\\<not> drlex_pm t s)", "using drlex_pm_lin"], ["proof (prove)\nusing this:\n  drlex_pm ?s ?t \\<or> drlex_pm ?t ?s\n\ngoal (1 subgoal):\n 1. strict drlex_pm s t = (\\<not> drlex_pm t s)", "by auto"], ["", "lemma drlex_pm_zero_min: \"drlex_pm 0 s\"\n  for s t::\"(_ \\<Rightarrow>\\<^sub>0 _::add_linorder_min)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pm 0 s", "unfolding drlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm (\\<lambda>s t. lex_pm t s) 0 s", "using lex_pm_refl"], ["proof (prove)\nusing this:\n  lex_pm ?s ?s\n\ngoal (1 subgoal):\n 1. dord_pm (\\<lambda>s t. lex_pm t s) 0 s", "by (rule dord_pm_zero_min)"], ["", "lemma drlex_pm_plus_monotone: \"drlex_pm s t \\<Longrightarrow> drlex_pm (s + u) (t + u)\"\n  for s t::\"_ \\<Rightarrow>\\<^sub>0 _::{ordered_ab_semigroup_add_imp_le, ordered_cancel_comm_monoid_add}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pm s t \\<Longrightarrow> drlex_pm (s + u) (t + u)", "unfolding drlex_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm (\\<lambda>s t. lex_pm t s) s t \\<Longrightarrow>\n    dord_pm (\\<lambda>s t. lex_pm t s) (s + u) (t + u)", "using lex_pm_plus_monotone"], ["proof (prove)\nusing this:\n  lex_pm ?s ?t \\<Longrightarrow> lex_pm (?s + ?u) (?t + ?u)\n\ngoal (1 subgoal):\n 1. dord_pm (\\<lambda>s t. lex_pm t s) s t \\<Longrightarrow>\n    dord_pm (\\<lambda>s t. lex_pm t s) (s + u) (t + u)", "by (rule dord_pm_plus_monotone)"], ["", "end"], ["", "(* theory *)"]]}