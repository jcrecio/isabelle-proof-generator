{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/Poly_Mapping_Finite_Map.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma fmdom'_fmap_of_list: \"fmdom' (fmap_of_list xs) = set (map fst xs)\"", "lemma fmlookup_default_fmmap:\n  \"fmlookup_default d (fmmap f M) x = (if x \\<in> fmdom' M then f (fmlookup_default d M x) else d)\"", "lemma fmlookup_default_fmmap_keys: \"fmlookup_default d (fmmap_keys f M) x =\n  (if x \\<in> fmdom' M then f x (fmlookup_default d M x) else d)\"", "lemma fmlookup_default_add[simp]:\n  \"fmlookup_default d (m ++\\<^sub>f n) x =\n    (if x |\\<in>| fmdom n then the (fmlookup n x)\n    else fmlookup_default d m x)\"", "lemma fmlookup_default_if[simp]:\n  \"fmlookup ys a = Some r \\<Longrightarrow> fmlookup_default d ys a = r\"\n  \"fmlookup ys a = None \\<Longrightarrow> fmlookup_default d ys a = d\"", "lemma finite_lookup_default:\n  \"finite {x. fmlookup_default d xs x \\<noteq> d}\"", "lemma lookup0_clearjunk0: \"lookup0 xs s = lookup0 (clearjunk0 xs) s\"", "lemma clearjunk0_nonzero:\n  assumes \"t \\<in> fmdom' (clearjunk0 xs)\"\n  shows \"fmlookup xs t \\<noteq> Some 0\"", "lemma clearjunk0_map_of_SomeD:\n  assumes a1: \"fmlookup xs t = Some c\" and \"c \\<noteq> 0\"\n  shows \"t \\<in> fmdom' (clearjunk0 xs)\"", "lemmas [simp] = Pm_fmap.rep_eq", "lemma PM_clearjunk0_cong:\n  \"Pm_fmap (clearjunk0 xs) = Pm_fmap xs\"", "lemma PM_all_2:\n  assumes \"P 0 0\"\n  shows \"(\\<forall>x. P (lookup (Pm_fmap xs) x) (lookup (Pm_fmap ys) x)) =\n    fmpred (\\<lambda>k v. P (lookup0 xs k) (lookup0 ys k)) (xs ++\\<^sub>f ys)\"", "lemma compute_keys_pp[code]: \"keys (Pm_fmap xs) = fmdom' (clearjunk0 xs)\"", "lemma compute_zero_pp[code]: \"0 = Pm_fmap fmempty\"", "lemma compute_plus_pp [code]:\n  \"Pm_fmap xs + Pm_fmap ys = Pm_fmap (clearjunk0 (fmmap_keys (\\<lambda>k v. lookup0 xs k + lookup0 ys k) (xs ++\\<^sub>f ys)))\"", "lemma compute_lookup_pp[code]:\n  \"lookup (Pm_fmap xs) x = lookup0 xs x\"", "lemma compute_minus_pp [code]:\n  \"Pm_fmap xs - Pm_fmap ys = Pm_fmap (clearjunk0 (fmmap_keys (\\<lambda>k v. lookup0 xs k - lookup0 ys k) (xs ++\\<^sub>f ys)))\"", "lemma compute_uminus_pp[code]:\n  \"- Pm_fmap ys = Pm_fmap (fmmap_keys (\\<lambda>k v. - lookup0 ys k) ys)\"", "lemma compute_equal_pp[code]:\n  \"equal_class.equal (Pm_fmap xs) (Pm_fmap ys) = fmpred (\\<lambda>k v. lookup0 xs k = lookup0 ys k) (xs ++\\<^sub>f ys)\"", "lemma compute_map_pp[code]:\n  \"Poly_Mapping.map f (Pm_fmap xs) = Pm_fmap (fmmap (\\<lambda>x. f x when x \\<noteq> 0) xs)\"", "lemma fmran'_fmfilter_eq: \"fmran' (fmfilter p fm) = {y | y. \\<exists>x \\<in> fmdom' fm. p x \\<and> fmlookup fm x = Some y}\"", "lemma compute_range_pp[code]:\n  \"Poly_Mapping.range (Pm_fmap xs) = fmran' (clearjunk0 xs)\"", "lemma compute_single[code]: \"Poly_Mapping.single k v = sparse\\<^sub>0 [(k, v)]\""], "translations": [["", "lemma fmdom'_fmap_of_list: \"fmdom' (fmap_of_list xs) = set (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom' (fmap_of_list xs) = set (map fst xs)", "by (auto simp: fmdom'_def fmdom'I fmap_of_list.rep_eq weak_map_of_SomeI)\n    (metis map_of_eq_None_iff option.distinct(1))"], ["", "text \\<open>In this theory, type @{typ \"('a, 'b) poly_mapping\"} is represented as association lists.\n  Code equations are proved in order actually perform computations (addition, multiplication, etc.).\\<close>"], ["", "subsection \\<open>Utilities\\<close>"], ["", "instantiation poly_mapping :: (type, \"{equal, zero}\") equal\nbegin"], ["", "definition equal_poly_mapping::\"('a, 'b) poly_mapping \\<Rightarrow> ('a, 'b) poly_mapping \\<Rightarrow> bool\" where\n  \"equal_poly_mapping p q \\<equiv> (\\<forall>t. lookup p t = lookup q t)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>0 'b, equal_class)", "by standard (auto simp add: equal_poly_mapping_def poly_mapping_eqI)"], ["", "end"], ["", "definition \"clearjunk0 m = fmfilter (\\<lambda>k. fmlookup m k \\<noteq> Some 0) m\""], ["", "definition \"fmlookup_default d m x = (case fmlookup m x of Some v \\<Rightarrow> v | None \\<Rightarrow> d)\""], ["", "abbreviation \"lookup0 \\<equiv> fmlookup_default 0\""], ["", "lemma fmlookup_default_fmmap:\n  \"fmlookup_default d (fmmap f M) x = (if x \\<in> fmdom' M then f (fmlookup_default d M x) else d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup_default d (fmmap f M) x =\n    (if x \\<in> fmdom' M then f (fmlookup_default d M x) else d)", "by (auto simp: fmlookup_default_def fmdom'_notI split: option.splits)"], ["", "lemma fmlookup_default_fmmap_keys: \"fmlookup_default d (fmmap_keys f M) x =\n  (if x \\<in> fmdom' M then f x (fmlookup_default d M x) else d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup_default d (fmmap_keys f M) x =\n    (if x \\<in> fmdom' M then f x (fmlookup_default d M x) else d)", "by (auto simp: fmlookup_default_def fmdom'_notI split: option.splits)"], ["", "lemma fmlookup_default_add[simp]:\n  \"fmlookup_default d (m ++\\<^sub>f n) x =\n    (if x |\\<in>| fmdom n then the (fmlookup n x)\n    else fmlookup_default d m x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup_default d (m ++\\<^sub>f n) x =\n    (if x |\\<in>| fmdom n then the (fmlookup n x)\n     else fmlookup_default d m x)", "by (auto simp: fmlookup_default_def)"], ["", "lemma fmlookup_default_if[simp]:\n  \"fmlookup ys a = Some r \\<Longrightarrow> fmlookup_default d ys a = r\"\n  \"fmlookup ys a = None \\<Longrightarrow> fmlookup_default d ys a = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fmlookup ys a = Some r \\<Longrightarrow>\n     fmlookup_default d ys a = r) &&&\n    (fmlookup ys a = None \\<Longrightarrow> fmlookup_default d ys a = d)", "by (auto simp: fmlookup_default_def)"], ["", "lemma finite_lookup_default:\n  \"finite {x. fmlookup_default d xs x \\<noteq> d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. fmlookup_default d xs x \\<noteq> d}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. fmlookup_default d xs x \\<noteq> d}", "have \"{x. fmlookup_default d xs x \\<noteq> d} \\<subseteq> fmdom' xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. fmlookup_default d xs x \\<noteq> d} \\<subseteq> fmdom' xs", "by (auto simp: fmlookup_default_def fmdom'I split: option.splits)"], ["proof (state)\nthis:\n  {x. fmlookup_default d xs x \\<noteq> d} \\<subseteq> fmdom' xs\n\ngoal (1 subgoal):\n 1. finite {x. fmlookup_default d xs x \\<noteq> d}", "also"], ["proof (state)\nthis:\n  {x. fmlookup_default d xs x \\<noteq> d} \\<subseteq> fmdom' xs\n\ngoal (1 subgoal):\n 1. finite {x. fmlookup_default d xs x \\<noteq> d}", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fmdom' xs)", "by simp"], ["proof (state)\nthis:\n  finite (fmdom' xs)\n\ngoal (1 subgoal):\n 1. finite {x. fmlookup_default d xs x \\<noteq> d}", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite {x. fmlookup_default d xs x \\<noteq> d}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {x. fmlookup_default d xs x \\<noteq> d}\n\ngoal (1 subgoal):\n 1. finite {x. fmlookup_default d xs x \\<noteq> d}", "."], ["proof (state)\nthis:\n  finite {x. fmlookup_default d xs x \\<noteq> d}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup0_clearjunk0: \"lookup0 xs s = lookup0 (clearjunk0 xs) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup0 xs s = lookup0 (clearjunk0 xs) s", "unfolding clearjunk0_def fmlookup_default_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case fmlookup xs s of None \\<Rightarrow> 0::'a\n     | Some v \\<Rightarrow> v) =\n    (case fmlookup\n           (fmfilter (\\<lambda>k. fmlookup xs k \\<noteq> Some (0::'a)) xs)\n           s of\n     None \\<Rightarrow> 0::'a | Some v \\<Rightarrow> v)", "by auto"], ["", "lemma clearjunk0_nonzero:\n  assumes \"t \\<in> fmdom' (clearjunk0 xs)\"\n  shows \"fmlookup xs t \\<noteq> Some 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup xs t \\<noteq> Some (0::'b)", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> fmdom' (clearjunk0 xs)\n\ngoal (1 subgoal):\n 1. fmlookup xs t \\<noteq> Some (0::'b)", "unfolding clearjunk0_def"], ["proof (prove)\nusing this:\n  t \\<in> fmdom'\n           (fmfilter (\\<lambda>k. fmlookup xs k \\<noteq> Some (0::'b)) xs)\n\ngoal (1 subgoal):\n 1. fmlookup xs t \\<noteq> Some (0::'b)", "by simp"], ["", "lemma clearjunk0_map_of_SomeD:\n  assumes a1: \"fmlookup xs t = Some c\" and \"c \\<noteq> 0\"\n  shows \"t \\<in> fmdom' (clearjunk0 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> fmdom' (clearjunk0 xs)", "using assms"], ["proof (prove)\nusing this:\n  fmlookup xs t = Some c\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. t \\<in> fmdom' (clearjunk0 xs)", "by (auto simp: clearjunk0_def fmdom'I)"], ["", "subsection \\<open>Implementation of Polynomial Mappings as Association Lists\\<close>"], ["", "lift_definition Pm_fmap::\"('a, 'b::zero) fmap \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>0 'b\" is lookup0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fmap. finite {x. lookup0 fmap x \\<noteq> (0::'b)}", "by (rule finite_lookup_default)"], ["", "lemmas [simp] = Pm_fmap.rep_eq"], ["", "code_datatype Pm_fmap"], ["", "lemma PM_clearjunk0_cong:\n  \"Pm_fmap (clearjunk0 xs) = Pm_fmap xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pm_fmap (clearjunk0 xs) = Pm_fmap xs", "by (metis Pm_fmap.rep_eq lookup0_clearjunk0 poly_mapping_eqI)"], ["", "lemma PM_all_2:\n  assumes \"P 0 0\"\n  shows \"(\\<forall>x. P (lookup (Pm_fmap xs) x) (lookup (Pm_fmap ys) x)) =\n    fmpred (\\<lambda>k v. P (lookup0 xs k) (lookup0 ys k)) (xs ++\\<^sub>f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. P (lookup (Pm_fmap xs) x) (lookup (Pm_fmap ys) x)) =\n    fmpred (\\<lambda>k v. P (lookup0 xs k) (lookup0 ys k))\n     (xs ++\\<^sub>f ys)", "using assms"], ["proof (prove)\nusing this:\n  P (0::'a) (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. P (lookup (Pm_fmap xs) x) (lookup (Pm_fmap ys) x)) =\n    fmpred (\\<lambda>k v. P (lookup0 xs k) (lookup0 ys k))\n     (xs ++\\<^sub>f ys)", "unfolding list_all_def"], ["proof (prove)\nusing this:\n  P (0::'a) (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. P (lookup (Pm_fmap xs) x) (lookup (Pm_fmap ys) x)) =\n    fmpred (\\<lambda>k v. P (lookup0 xs k) (lookup0 ys k))\n     (xs ++\\<^sub>f ys)", "by (force simp: fmlookup_default_def fmlookup_dom_iff\n      split: option.splits if_splits)"], ["", "lemma compute_keys_pp[code]: \"keys (Pm_fmap xs) = fmdom' (clearjunk0 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (Pm_fmap xs) = fmdom' (clearjunk0 xs)", "by transfer\n    (auto simp: fmlookup_dom'_iff clearjunk0_def fmlookup_default_def fmdom'I split: option.splits)"], ["", "lemma compute_zero_pp[code]: \"0 = Pm_fmap fmempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = Pm_fmap fmempty", "by (auto intro!: poly_mapping_eqI simp: fmlookup_default_def)"], ["", "lemma compute_plus_pp [code]:\n  \"Pm_fmap xs + Pm_fmap ys = Pm_fmap (clearjunk0 (fmmap_keys (\\<lambda>k v. lookup0 xs k + lookup0 ys k) (xs ++\\<^sub>f ys)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pm_fmap xs + Pm_fmap ys =\n    Pm_fmap\n     (clearjunk0\n       (fmmap_keys (\\<lambda>k v. lookup0 xs k + lookup0 ys k)\n         (xs ++\\<^sub>f ys)))", "by (auto intro!: poly_mapping_eqI\n      simp: fmlookup_default_def lookup_add fmlookup_dom_iff PM_clearjunk0_cong\n      split: option.splits)"], ["", "lemma compute_lookup_pp[code]:\n  \"lookup (Pm_fmap xs) x = lookup0 xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Pm_fmap xs) x = lookup0 xs x", "by (transfer, simp)"], ["", "lemma compute_minus_pp [code]:\n  \"Pm_fmap xs - Pm_fmap ys = Pm_fmap (clearjunk0 (fmmap_keys (\\<lambda>k v. lookup0 xs k - lookup0 ys k) (xs ++\\<^sub>f ys)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pm_fmap xs - Pm_fmap ys =\n    Pm_fmap\n     (clearjunk0\n       (fmmap_keys (\\<lambda>k v. lookup0 xs k - lookup0 ys k)\n         (xs ++\\<^sub>f ys)))", "by (auto intro!: poly_mapping_eqI\n      simp: fmlookup_default_def lookup_minus fmlookup_dom_iff PM_clearjunk0_cong\n      split: option.splits)"], ["", "lemma compute_uminus_pp[code]:\n  \"- Pm_fmap ys = Pm_fmap (fmmap_keys (\\<lambda>k v. - lookup0 ys k) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Pm_fmap ys = Pm_fmap (fmmap_keys (\\<lambda>k v. - lookup0 ys k) ys)", "by (auto intro!: poly_mapping_eqI\n      simp: fmlookup_default_def\n      split: option.splits)"], ["", "lemma compute_equal_pp[code]:\n  \"equal_class.equal (Pm_fmap xs) (Pm_fmap ys) = fmpred (\\<lambda>k v. lookup0 xs k = lookup0 ys k) (xs ++\\<^sub>f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal (Pm_fmap xs) (Pm_fmap ys) =\n    fmpred (\\<lambda>k v. lookup0 xs k = lookup0 ys k) (xs ++\\<^sub>f ys)", "unfolding equal_poly_mapping_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t. lookup (Pm_fmap xs) t = lookup (Pm_fmap ys) t) =\n    fmpred (\\<lambda>k v. lookup0 xs k = lookup0 ys k) (xs ++\\<^sub>f ys)", "by (simp only: PM_all_2)"], ["", "lemma compute_map_pp[code]:\n  \"Poly_Mapping.map f (Pm_fmap xs) = Pm_fmap (fmmap (\\<lambda>x. f x when x \\<noteq> 0) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map f (Pm_fmap xs) =\n    Pm_fmap (fmmap (\\<lambda>x. f x when x \\<noteq> (0::'c)) xs)", "by (auto intro!: poly_mapping_eqI\n      simp: fmlookup_default_def map.rep_eq\n      split: option.splits)"], ["", "lemma fmran'_fmfilter_eq: \"fmran' (fmfilter p fm) = {y | y. \\<exists>x \\<in> fmdom' fm. p x \\<and> fmlookup fm x = Some y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmran' (fmfilter p fm) =\n    {y |y. \\<exists>x\\<in>fmdom' fm. p x \\<and> fmlookup fm x = Some y}", "by (force simp: fmlookup_ran'_iff fmdom'I split: if_splits)"], ["", "lemma compute_range_pp[code]:\n  \"Poly_Mapping.range (Pm_fmap xs) = fmran' (clearjunk0 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.range (Pm_fmap xs) = fmran' (clearjunk0 xs)", "by (force simp: range.rep_eq clearjunk0_def fmran'_fmfilter_eq fmdom'I\n      fmlookup_default_def split: option.splits)"], ["", "subsubsection \\<open>Constructors\\<close>"], ["", "definition \"sparse\\<^sub>0 xs = Pm_fmap (fmap_of_list xs)\" \\<comment>\\<open>sparse representation\\<close>"], ["", "definition \"dense\\<^sub>0 xs = Pm_fmap (fmap_of_list (zip [0..<length xs] xs))\" \\<comment>\\<open>dense representation\\<close>"], ["", "lemma compute_single[code]: \"Poly_Mapping.single k v = sparse\\<^sub>0 [(k, v)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.single k v = sparse\\<^sub>0 [(k, v)]", "by (auto simp: sparse\\<^sub>0_def fmlookup_default_def lookup_single intro!: poly_mapping_eqI )"], ["", "end"]]}