{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/Utils.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma subset_imageE_inj:\n  assumes \"B \\<subseteq> f ` A\"\n  obtains C where \"C \\<subseteq> A\" and \"B = f ` C\" and \"inj_on f C\"", "lemma wfP_chain:\n  assumes \"\\<not>(\\<exists>f. \\<forall>i. r (f (Suc i)) (f i))\"\n  shows \"wfP r\"", "lemma transp_sequence:\n  assumes \"transp r\" and \"\\<And>i. r (seq (Suc i)) (seq i)\" and \"i < j\"\n  shows \"r (seq j) (seq i)\"", "lemma almost_full_on_finite_subsetE:\n  assumes \"reflp P\" and \"almost_full_on P S\"\n  obtains T where \"finite T\" and \"T \\<subseteq> S\" and \"\\<And>s. s \\<in> S \\<Longrightarrow> (\\<exists>t\\<in>T. P t s)\"", "lemma map_upt: \"map (\\<lambda>i. f (xs ! i)) [0..<length xs] = map f xs\"", "lemma map_upt_zip:\n  assumes \"length xs = length ys\"\n  shows \"map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map (\\<lambda>(x, y). f x y) (zip xs ys)\" (is \"?l = ?r\")", "lemma distinct_sorted_wrt_irrefl:\n  assumes \"irreflp rel\" and \"transp rel\" and \"sorted_wrt rel xs\"\n  shows \"distinct xs\"", "lemma distinct_sorted_wrt_imp_sorted_wrt_strict:\n  assumes \"distinct xs\" and \"sorted_wrt rel xs\"\n  shows \"sorted_wrt (\\<lambda>x y. rel x y \\<and> \\<not> x = y) xs\"", "lemma sorted_wrt_distinct_set_unique:\n  assumes \"antisymp rel\"\n  assumes \"sorted_wrt rel xs\" \"distinct xs\" \"sorted_wrt rel ys\" \"distinct ys\" \"set xs = set ys\"\n  shows \"xs = ys\"", "lemma sorted_wrt_refl_nth_mono:\n  assumes \"reflp P\" and \"sorted_wrt P xs\" and \"i \\<le> j\" and \"j < length xs\"\n  shows \"P (xs ! i) (xs ! j)\"", "lemma set_merge_wrt: \"set (merge_wrt rel xs ys) = set xs \\<union> set ys\"", "lemma sorted_merge_wrt:\n  assumes \"transp rel\" and \"\\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x\"\n    and \"sorted_wrt rel xs\" and \"sorted_wrt rel ys\"\n  shows \"sorted_wrt rel (merge_wrt rel xs ys)\"", "lemma set_fold:\n  assumes \"\\<And>x ys. set (f (g x) ys) = set (g x) \\<union> set ys\"\n  shows \"set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys\"", "lemma additive_implies_homogenous:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f (y::'a::monoid_add))::'b::cancel_comm_monoid_add)\"\n  shows \"f 0 = 0\"", "lemma fun_sum_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n  shows \"f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\"", "lemma fun_sum_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f y)::'a::cancel_comm_monoid_add)\"\n  shows \"f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\"", "lemma fun_sum_list_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n  shows \"f (sum_list xs) = sum_list (map f xs)\"", "lemma fun_sum_list_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f y)::'a::cancel_comm_monoid_add)\"\n  shows \"f (sum_list xs) = sum_list (map f xs)\"", "lemma sum_set_upt_eq_sum_list: \"(\\<Sum>i = m..<n. f i) = (\\<Sum>i\\<leftarrow>[m..<n]. f i)\"", "lemma sum_list_upt: \"(\\<Sum>i\\<leftarrow>[0..<(length xs)]. f (xs ! i)) = (\\<Sum>x\\<leftarrow>xs. f x)\"", "lemma sum_list_upt_zip:\n  assumes \"length xs = length ys\"\n  shows \"(\\<Sum>i\\<leftarrow>[0..<(length ys)]. f (xs ! i) (ys ! i)) = (\\<Sum>(x, y)\\<leftarrow>(zip xs ys). f x y)\"", "lemma sum_list_zeroI:\n  assumes \"set xs \\<subseteq> {0}\"\n  shows \"sum_list xs = 0\"", "lemma fun_prod_commute:\n  assumes \"f 1 = 1\" and \"\\<And>x y. f (x * y) = f x * f y\"\n  shows \"f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\""], "translations": [["", "lemma subset_imageE_inj:\n  assumes \"B \\<subseteq> f ` A\"\n  obtains C where \"C \\<subseteq> A\" and \"B = f ` C\" and \"inj_on f C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define g where \"g = (\\<lambda>x. SOME a. a \\<in> A \\<and> f a = x)\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. SOME a. a \\<in> A \\<and> f a = x)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"g b \\<in> A \\<and> f (g b) = b\" if \"b \\<in> B\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b", "from that assms"], ["proof (chain)\npicking this:\n  b \\<in> B\n  B \\<subseteq> f ` A", "have \"b \\<in> f ` A\""], ["proof (prove)\nusing this:\n  b \\<in> B\n  B \\<subseteq> f ` A\n\ngoal (1 subgoal):\n 1. b \\<in> f ` A", ".."], ["proof (state)\nthis:\n  b \\<in> f ` A\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b", "then"], ["proof (chain)\npicking this:\n  b \\<in> f ` A", "obtain a where \"a \\<in> A\" and \"b = f a\""], ["proof (prove)\nusing this:\n  b \\<in> f ` A\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A; b = f a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  a \\<in> A\n  b = f a\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b", "hence \"a \\<in> A \\<and> f a = b\""], ["proof (prove)\nusing this:\n  a \\<in> A\n  b = f a\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<and> f a = b", "by simp"], ["proof (state)\nthis:\n  a \\<in> A \\<and> f a = b\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> A \\<and> f a = b\n\ngoal (1 subgoal):\n 1. g b \\<in> A \\<and> f (g b) = b", "unfolding g_def"], ["proof (prove)\nusing this:\n  a \\<in> A \\<and> f a = b\n\ngoal (1 subgoal):\n 1. (SOME a. a \\<in> A \\<and> f a = b) \\<in> A \\<and>\n    f (SOME a. a \\<in> A \\<and> f a = b) = b", "by (rule someI)"], ["proof (state)\nthis:\n  g b \\<in> A \\<and> f (g b) = b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Longrightarrow> g ?b \\<in> A \\<and> f (g ?b) = ?b\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence 1: \"\\<And>b. b \\<in> B \\<Longrightarrow> g b \\<in> A\" and 2: \"\\<And>b. b \\<in> B \\<Longrightarrow> f (g b) = b\""], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Longrightarrow> g ?b \\<in> A \\<and> f (g ?b) = ?b\n\ngoal (1 subgoal):\n 1. (\\<And>b. b \\<in> B \\<Longrightarrow> g b \\<in> A) &&&\n    (\\<And>b. b \\<in> B \\<Longrightarrow> f (g b) = b)", "by simp_all"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Longrightarrow> g ?b \\<in> A\n  ?b \\<in> B \\<Longrightarrow> f (g ?b) = ?b\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?C = \"g ` B\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<subseteq> A; B = f ` C; inj_on f C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?C \\<subseteq> A\n 2. B = f ` ?C\n 3. inj_on f ?C", "show \"?C \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` B \\<subseteq> A", "by (auto intro: 1)"], ["proof (state)\nthis:\n  g ` B \\<subseteq> A\n\ngoal (2 subgoals):\n 1. B = f ` g ` B\n 2. inj_on f (g ` B)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. B = f ` g ` B\n 2. inj_on f (g ` B)", "show \"B = f ` ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = f ` g ` B", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> B) = (x \\<in> f ` g ` B)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> B) = (x \\<in> f ` g ` B)", "show \"b \\<in> B \\<longleftrightarrow> b \\<in> f ` ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<in> B) = (b \\<in> f ` g ` B)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B", "assume \"b \\<in> B\""], ["proof (state)\nthis:\n  b \\<in> B\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B", "moreover"], ["proof (state)\nthis:\n  b \\<in> B\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B", "from this"], ["proof (chain)\npicking this:\n  b \\<in> B", "have \"f (g b) = b\""], ["proof (prove)\nusing this:\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. f (g b) = b", "by (rule 2)"], ["proof (state)\nthis:\n  f (g b) = b\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow> b \\<in> f ` g ` B\n 2. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B", "ultimately"], ["proof (chain)\npicking this:\n  b \\<in> B\n  f (g b) = b", "show \"b \\<in> f ` ?C\""], ["proof (prove)\nusing this:\n  b \\<in> B\n  f (g b) = b\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B", "by force"], ["proof (state)\nthis:\n  b \\<in> f ` g ` B\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B", "assume \"b \\<in> f ` ?C\""], ["proof (state)\nthis:\n  b \\<in> f ` g ` B\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B", "then"], ["proof (chain)\npicking this:\n  b \\<in> f ` g ` B", "obtain b' where \"b' \\<in> B\" and \"b = f (g b')\""], ["proof (prove)\nusing this:\n  b \\<in> f ` g ` B\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' \\<in> B; b = f (g b')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding image_image"], ["proof (prove)\nusing this:\n  b \\<in> (\\<lambda>x. f (g x)) ` B\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' \\<in> B; b = f (g b')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  b' \\<in> B\n  b = f (g b')\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B", "moreover"], ["proof (state)\nthis:\n  b' \\<in> B\n  b = f (g b')\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B", "from this(1)"], ["proof (chain)\npicking this:\n  b' \\<in> B", "have \"f (g b') = b'\""], ["proof (prove)\nusing this:\n  b' \\<in> B\n\ngoal (1 subgoal):\n 1. f (g b') = b'", "by (rule 2)"], ["proof (state)\nthis:\n  f (g b') = b'\n\ngoal (1 subgoal):\n 1. b \\<in> f ` g ` B \\<Longrightarrow> b \\<in> B", "ultimately"], ["proof (chain)\npicking this:\n  b' \\<in> B\n  b = f (g b')\n  f (g b') = b'", "show \"b \\<in> B\""], ["proof (prove)\nusing this:\n  b' \\<in> B\n  b = f (g b')\n  f (g b') = b'\n\ngoal (1 subgoal):\n 1. b \\<in> B", "by simp"], ["proof (state)\nthis:\n  b \\<in> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (b \\<in> B) = (b \\<in> f ` g ` B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B = f ` g ` B\n\ngoal (1 subgoal):\n 1. inj_on f (g ` B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on f (g ` B)", "show \"inj_on f ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (g ` B)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> ?C\""], ["proof (state)\nthis:\n  x \\<in> g ` B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<in> g ` B", "obtain bx where \"bx \\<in> B\" and x: \"x = g bx\""], ["proof (prove)\nusing this:\n  x \\<in> g ` B\n\ngoal (1 subgoal):\n 1. (\\<And>bx.\n        \\<lbrakk>bx \\<in> B; x = g bx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  bx \\<in> B\n  x = g bx\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  bx \\<in> B\n  x = g bx\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from this(1)"], ["proof (chain)\npicking this:\n  bx \\<in> B", "have \"f (g bx) = bx\""], ["proof (prove)\nusing this:\n  bx \\<in> B\n\ngoal (1 subgoal):\n 1. f (g bx) = bx", "by (rule 2)"], ["proof (state)\nthis:\n  f (g bx) = bx\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  bx \\<in> B\n  x = g bx\n  f (g bx) = bx", "have *: \"f x = bx\""], ["proof (prove)\nusing this:\n  bx \\<in> B\n  x = g bx\n  f (g bx) = bx\n\ngoal (1 subgoal):\n 1. f x = bx", "by simp"], ["proof (state)\nthis:\n  f x = bx\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"y \\<in> ?C\""], ["proof (state)\nthis:\n  y \\<in> g ` B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  y \\<in> g ` B", "obtain \"by\" where \"by \\<in> B\" and y: \"y = g by\""], ["proof (prove)\nusing this:\n  y \\<in> g ` B\n\ngoal (1 subgoal):\n 1. (\\<And>by.\n        \\<lbrakk>by \\<in> B; y = g by\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  by \\<in> B\n  y = g by\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  by \\<in> B\n  y = g by\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from this(1)"], ["proof (chain)\npicking this:\n  by \\<in> B", "have \"f (g by) = by\""], ["proof (prove)\nusing this:\n  by \\<in> B\n\ngoal (1 subgoal):\n 1. f (g by) = by", "by (rule 2)"], ["proof (state)\nthis:\n  f (g by) = by\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  by \\<in> B\n  y = g by\n  f (g by) = by", "have \"f y = by\""], ["proof (prove)\nusing this:\n  by \\<in> B\n  y = g by\n  f (g by) = by\n\ngoal (1 subgoal):\n 1. f y = by", "by simp"], ["proof (state)\nthis:\n  f y = by\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  f y = by\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"f x = f y\""], ["proof (state)\nthis:\n  f x = f y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  f y = by\n  f x = f y", "have \"bx = by\""], ["proof (prove)\nusing this:\n  f y = by\n  f x = f y\n\ngoal (1 subgoal):\n 1. bx = by", "using *"], ["proof (prove)\nusing this:\n  f y = by\n  f x = f y\n  f x = bx\n\ngoal (1 subgoal):\n 1. bx = by", "by simp"], ["proof (state)\nthis:\n  bx = by\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> g ` B; y \\<in> g ` B; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  bx = by\n\ngoal (1 subgoal):\n 1. x = y", "by (simp only: x y)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on f (g ` B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wfP_chain:\n  assumes \"\\<not>(\\<exists>f. \\<forall>i. r (f (Suc i)) (f i))\"\n  shows \"wfP r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP r", "from assms wf_iff_no_infinite_down_chain[of \"{(x, y). r x y}\"]"], ["proof (chain)\npicking this:\n  \\<nexists>f. \\<forall>i. r (f (Suc i)) (f i)\n  wf {(x, y). r x y} =\n  (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y})", "have \"wf {(x, y). r x y}\""], ["proof (prove)\nusing this:\n  \\<nexists>f. \\<forall>i. r (f (Suc i)) (f i)\n  wf {(x, y). r x y} =\n  (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y})\n\ngoal (1 subgoal):\n 1. wf {(x, y). r x y}", "by auto"], ["proof (state)\nthis:\n  wf {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. wfP r", "thus \"wfP r\""], ["proof (prove)\nusing this:\n  wf {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. wfP r", "unfolding wfP_def"], ["proof (prove)\nusing this:\n  wf {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. wf {(x, y). r x y}", "."], ["proof (state)\nthis:\n  wfP r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transp_sequence:\n  assumes \"transp r\" and \"\\<And>i. r (seq (Suc i)) (seq i)\" and \"i < j\"\n  shows \"r (seq j) (seq i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (seq j) (seq i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r (seq j) (seq i)", "have \"\\<And>k. r (seq (i + Suc k)) (seq i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i)", "fix k::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. r (seq (i + Suc k)) (seq i)", "show \"r (seq (i + Suc k)) (seq i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (seq (i + Suc k)) (seq i)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. r (seq (i + Suc 0)) (seq i)\n 2. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. r (seq (i + Suc 0)) (seq i)\n 2. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "from assms(2)"], ["proof (chain)\npicking this:\n  r (seq (Suc ?i)) (seq ?i)", "have \"r (seq (Suc i)) (seq i)\""], ["proof (prove)\nusing this:\n  r (seq (Suc ?i)) (seq ?i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc i)) (seq i)", "."], ["proof (state)\nthis:\n  r (seq (Suc i)) (seq i)\n\ngoal (2 subgoals):\n 1. r (seq (i + Suc 0)) (seq i)\n 2. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "thus ?case"], ["proof (prove)\nusing this:\n  r (seq (Suc i)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (i + Suc 0)) (seq i)", "by simp"], ["proof (state)\nthis:\n  r (seq (i + Suc 0)) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "case (Suc k)"], ["proof (state)\nthis:\n  r (seq (i + Suc k)) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "note assms(1)"], ["proof (state)\nthis:\n  transp r\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "moreover"], ["proof (state)\nthis:\n  transp r\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "from assms(2)"], ["proof (chain)\npicking this:\n  r (seq (Suc ?i)) (seq ?i)", "have \"r (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\""], ["proof (prove)\nusing this:\n  r (seq (Suc ?i)) (seq ?i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc (Suc i + k))) (seq (Suc (i + k)))", "by simp"], ["proof (state)\nthis:\n  r (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "moreover"], ["proof (state)\nthis:\n  r (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "have \"r (seq (Suc (i + k))) (seq i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (seq (Suc (i + k))) (seq i)", "using Suc.hyps"], ["proof (prove)\nusing this:\n  r (seq (i + Suc k)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc (i + k))) (seq i)", "by simp"], ["proof (state)\nthis:\n  r (seq (Suc (i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "ultimately"], ["proof (chain)\npicking this:\n  transp r\n  r (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\n  r (seq (Suc (i + k))) (seq i)", "have \"r (seq (Suc (Suc i + k))) (seq i)\""], ["proof (prove)\nusing this:\n  transp r\n  r (seq (Suc (Suc i + k))) (seq (Suc (i + k)))\n  r (seq (Suc (i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (Suc (Suc i + k))) (seq i)", "by (rule transpD)"], ["proof (state)\nthis:\n  r (seq (Suc (Suc i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       r (seq (i + Suc k)) (seq i) \\<Longrightarrow>\n       r (seq (i + Suc (Suc k))) (seq i)", "thus ?case"], ["proof (prove)\nusing this:\n  r (seq (Suc (Suc i + k))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (i + Suc (Suc k))) (seq i)", "by simp"], ["proof (state)\nthis:\n  r (seq (i + Suc (Suc k))) (seq i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r (seq (i + Suc k)) (seq i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r (seq (i + Suc ?k)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)", "hence \"r (seq (i + Suc(j - i - 1))) (seq i)\""], ["proof (prove)\nusing this:\n  r (seq (i + Suc ?k)) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq (i + Suc (j - i - 1))) (seq i)", "."], ["proof (state)\nthis:\n  r (seq (i + Suc (j - i - 1))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)", "thus \"r (seq j) (seq i)\""], ["proof (prove)\nusing this:\n  r (seq (i + Suc (j - i - 1))) (seq i)\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)", "using \\<open>i < j\\<close>"], ["proof (prove)\nusing this:\n  r (seq (i + Suc (j - i - 1))) (seq i)\n  i < j\n\ngoal (1 subgoal):\n 1. r (seq j) (seq i)", "by simp"], ["proof (state)\nthis:\n  r (seq j) (seq i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma almost_full_on_finite_subsetE:\n  assumes \"reflp P\" and \"almost_full_on P S\"\n  obtains T where \"finite T\" and \"T \\<subseteq> S\" and \"\\<And>s. s \\<in> S \\<Longrightarrow> (\\<exists>t\\<in>T. P t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define crit where \"crit = (\\<lambda>U s. s \\<in> S \\<and> (\\<forall>u\\<in>U. \\<not> P u s))\""], ["proof (state)\nthis:\n  crit = (\\<lambda>U s. s \\<in> S \\<and> (\\<forall>u\\<in>U. \\<not> P u s))\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have critD: \"s \\<notin> U\" if \"crit U s\" for U s"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<notin> U", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False", "assume \"s \\<in> U\""], ["proof (state)\nthis:\n  s \\<in> U\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False", "from \\<open>crit U s\\<close>"], ["proof (chain)\npicking this:\n  crit U s", "have \"\\<forall>u\\<in>U. \\<not> P u s\""], ["proof (prove)\nusing this:\n  crit U s\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. \\<not> P u s", "unfolding crit_def"], ["proof (prove)\nusing this:\n  s \\<in> S \\<and> (\\<forall>u\\<in>U. \\<not> P u s)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. \\<not> P u s", ".."], ["proof (state)\nthis:\n  \\<forall>u\\<in>U. \\<not> P u s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False", "from this \\<open>s \\<in> U\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>U. \\<not> P u s\n  s \\<in> U", "have \"\\<not> P s s\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>U. \\<not> P u s\n  s \\<in> U\n\ngoal (1 subgoal):\n 1. \\<not> P s s", ".."], ["proof (state)\nthis:\n  \\<not> P s s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> P s s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False", "from assms(1)"], ["proof (chain)\npicking this:\n  reflp P", "have \"P s s\""], ["proof (prove)\nusing this:\n  reflp P\n\ngoal (1 subgoal):\n 1. P s s", "by (rule reflpD)"], ["proof (state)\nthis:\n  P s s\n\ngoal (1 subgoal):\n 1. s \\<in> U \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> P s s\n  P s s", "show False"], ["proof (prove)\nusing this:\n  \\<not> P s s\n  P s s\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  crit ?U ?s \\<Longrightarrow> ?s \\<notin> ?U\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define \"fun\"\n    where \"fun = (\\<lambda>U. (if (\\<exists>s. crit U s) then\n                        insert (SOME s. crit U s) U\n                      else\n                        U\n                      ))\""], ["proof (state)\nthis:\n  fun =\n  (\\<lambda>U.\n      if \\<exists>s. crit U s then insert (SOME s. crit U s) U else U)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define seq where \"seq = rec_nat {} (\\<lambda>_. fun)\""], ["proof (state)\nthis:\n  seq = rec_nat {} (\\<lambda>_. fun)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have seq_Suc: \"seq (Suc i) = fun (seq i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (Suc i) = fun (seq i)", "by (simp add: seq_def)"], ["proof (state)\nthis:\n  seq (Suc ?i) = fun (seq ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have seq_incr_Suc: \"seq i \\<subseteq> seq (Suc i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq (Suc i)", "by (auto simp add: seq_Suc fun_def)"], ["proof (state)\nthis:\n  seq ?i \\<subseteq> seq (Suc ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have seq_incr: \"i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j", "assume \"i \\<le> j\""], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j", "hence \"i = j \\<or> i < j\""], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i = j \\<or> i < j", "by auto"], ["proof (state)\nthis:\n  i = j \\<or> i < j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> seq i \\<subseteq> seq j", "thus \"seq i \\<subseteq> seq j\""], ["proof (prove)\nusing this:\n  i = j \\<or> i < j\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq j", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> seq i \\<subseteq> seq j\n 2. i < j \\<Longrightarrow> seq i \\<subseteq> seq j", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> seq i \\<subseteq> seq j\n 2. i < j \\<Longrightarrow> seq i \\<subseteq> seq j", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq j", "by simp"], ["proof (state)\nthis:\n  seq i \\<subseteq> seq j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> seq i \\<subseteq> seq j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> seq i \\<subseteq> seq j", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> seq i \\<subseteq> seq j", "with _ seq_incr_Suc"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  seq ?i \\<subseteq> seq (Suc ?i)\n  i < j", "show ?thesis"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  seq ?i \\<subseteq> seq (Suc ?i)\n  i < j\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> seq j", "by (rule transp_sequence, simp add: transp_def)"], ["proof (state)\nthis:\n  seq i \\<subseteq> seq j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  seq i \\<subseteq> seq j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<le> ?j \\<Longrightarrow> seq ?i \\<subseteq> seq ?j\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have sub: \"seq i \\<subseteq> S\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. seq i \\<subseteq> S", "proof (induct i, simp add: seq_def, simp add: seq_Suc fun_def, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk>\n       \\<Longrightarrow> Eps (crit (seq i)) \\<in> S", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk>\n       \\<Longrightarrow> Eps (crit (seq i)) \\<in> S", "assume \"Ex (crit (seq i))\""], ["proof (state)\nthis:\n  Ex (crit (seq i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk>\n       \\<Longrightarrow> Eps (crit (seq i)) \\<in> S", "hence \"crit (seq i) (Eps (crit (seq i)))\""], ["proof (prove)\nusing this:\n  Ex (crit (seq i))\n\ngoal (1 subgoal):\n 1. crit (seq i) (Eps (crit (seq i)))", "by (rule someI_ex)"], ["proof (state)\nthis:\n  crit (seq i) (Eps (crit (seq i)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>seq i \\<subseteq> S; Ex (crit (seq i))\\<rbrakk>\n       \\<Longrightarrow> Eps (crit (seq i)) \\<in> S", "thus \"Eps (crit (seq i)) \\<in> S\""], ["proof (prove)\nusing this:\n  crit (seq i) (Eps (crit (seq i)))\n\ngoal (1 subgoal):\n 1. Eps (crit (seq i)) \\<in> S", "by (simp add: crit_def)"], ["proof (state)\nthis:\n  Eps (crit (seq i)) \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  seq ?i \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>i. seq (Suc i) = seq i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. seq (Suc i) = seq i", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "assume \"\\<forall>i. seq (Suc i) \\<noteq> seq i\""], ["proof (state)\nthis:\n  \\<forall>i. seq (Suc i) \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "with seq_incr_Suc"], ["proof (chain)\npicking this:\n  seq ?i \\<subseteq> seq (Suc ?i)\n  \\<forall>i. seq (Suc i) \\<noteq> seq i", "have \"seq i \\<subset> seq (Suc i)\" for i"], ["proof (prove)\nusing this:\n  seq ?i \\<subseteq> seq (Suc ?i)\n  \\<forall>i. seq (Suc i) \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. seq i \\<subset> seq (Suc i)", "by blast"], ["proof (state)\nthis:\n  seq ?i \\<subset> seq (Suc ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "define seq1 where \"seq1 = (\\<lambda>n. (SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n))\""], ["proof (state)\nthis:\n  seq1 = (\\<lambda>n. SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "have seq1: \"seq1 n \\<in> seq (Suc n) \\<and> seq1 n \\<notin> seq n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. seq1 n \\<in> seq (Suc n) \\<and> seq1 n \\<notin> seq n", "unfolding seq1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n)\n    \\<in> seq (Suc n) \\<and>\n    (SOME s. s \\<in> seq (Suc n) \\<and> s \\<notin> seq n) \\<notin> seq n", "proof (rule someI_ex)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n", "from \\<open>seq n \\<subset> seq (Suc n)\\<close>"], ["proof (chain)\npicking this:\n  seq n \\<subset> seq (Suc n)", "show \"\\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n\""], ["proof (prove)\nusing this:\n  seq n \\<subset> seq (Suc n)\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> seq (Suc n) \\<and> x \\<notin> seq n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  seq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "have \"seq1 i \\<in> S\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. seq1 i \\<in> S", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. seq1 i \\<in> ?A\n 2. ?A \\<subseteq> S", "from seq1[of i]"], ["proof (chain)\npicking this:\n  seq1 i \\<in> seq (Suc i) \\<and> seq1 i \\<notin> seq i", "show \"seq1 i \\<in> seq (Suc i)\""], ["proof (prove)\nusing this:\n  seq1 i \\<in> seq (Suc i) \\<and> seq1 i \\<notin> seq i\n\ngoal (1 subgoal):\n 1. seq1 i \\<in> seq (Suc i)", ".."], ["proof (state)\nthis:\n  seq1 i \\<in> seq (Suc i)\n\ngoal (1 subgoal):\n 1. seq (Suc i) \\<subseteq> S", "qed (fact sub)"], ["proof (state)\nthis:\n  seq1 ?i \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "with assms(2)"], ["proof (chain)\npicking this:\n  almost_full_on P S\n  seq1 ?i \\<in> S", "obtain a b where \"a < b\" and \"P (seq1 a) (seq1 b)\""], ["proof (prove)\nusing this:\n  almost_full_on P S\n  seq1 ?i \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a < b; P (seq1 a) (seq1 b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule almost_full_onD)"], ["proof (state)\nthis:\n  a < b\n  P (seq1 a) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "from \\<open>a < b\\<close>"], ["proof (chain)\npicking this:\n  a < b", "have \"Suc a \\<le> b\""], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. Suc a \\<le> b", "by simp"], ["proof (state)\nthis:\n  Suc a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "from seq1"], ["proof (chain)\npicking this:\n  seq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n", "have \"seq1 a \\<in> seq (Suc a)\""], ["proof (prove)\nusing this:\n  seq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n\n\ngoal (1 subgoal):\n 1. seq1 a \\<in> seq (Suc a)", ".."], ["proof (state)\nthis:\n  seq1 a \\<in> seq (Suc a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  seq1 a \\<in> seq (Suc a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "from \\<open>Suc a \\<le> b\\<close>"], ["proof (chain)\npicking this:\n  Suc a \\<le> b", "have \"... \\<subseteq> seq b\""], ["proof (prove)\nusing this:\n  Suc a \\<le> b\n\ngoal (1 subgoal):\n 1. seq (Suc a) \\<subseteq> seq b", "by (rule seq_incr)"], ["proof (state)\nthis:\n  seq (Suc a) \\<subseteq> seq b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  seq1 a \\<in> seq b", "have \"seq1 a \\<in> seq b\""], ["proof (prove)\nusing this:\n  seq1 a \\<in> seq b\n\ngoal (1 subgoal):\n 1. seq1 a \\<in> seq b", "."], ["proof (state)\nthis:\n  seq1 a \\<in> seq b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "from seq1"], ["proof (chain)\npicking this:\n  seq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n", "have \"seq1 b \\<in> seq (Suc b)\" and \"seq1 b \\<notin> seq b\""], ["proof (prove)\nusing this:\n  seq1 ?n \\<in> seq (Suc ?n) \\<and> seq1 ?n \\<notin> seq ?n\n\ngoal (1 subgoal):\n 1. seq1 b \\<in> seq (Suc b) &&& seq1 b \\<notin> seq b", "by blast+"], ["proof (state)\nthis:\n  seq1 b \\<in> seq (Suc b)\n  seq1 b \\<notin> seq b\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "hence \"crit (seq b) (seq1 b)\""], ["proof (prove)\nusing this:\n  seq1 b \\<in> seq (Suc b)\n  seq1 b \\<notin> seq b\n\ngoal (1 subgoal):\n 1. crit (seq b) (seq1 b)", "by (simp add: seq_Suc fun_def someI split: if_splits)"], ["proof (state)\nthis:\n  crit (seq b) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "hence \"\\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\""], ["proof (prove)\nusing this:\n  crit (seq b) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>seq b. \\<not> P u (seq1 b)", "by (simp add: crit_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "from this \\<open>seq1 a \\<in> seq b\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\n  seq1 a \\<in> seq b", "have \"\\<not> P (seq1 a) (seq1 b)\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>seq b. \\<not> P u (seq1 b)\n  seq1 a \\<in> seq b\n\ngoal (1 subgoal):\n 1. \\<not> P (seq1 a) (seq1 b)", ".."], ["proof (state)\nthis:\n  \\<not> P (seq1 a) (seq1 b)\n\ngoal (1 subgoal):\n 1. \\<forall>i. seq (Suc i) \\<noteq> seq i \\<Longrightarrow> False", "from this \\<open>P (seq1 a) (seq1 b)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> P (seq1 a) (seq1 b)\n  P (seq1 a) (seq1 b)", "show False"], ["proof (prove)\nusing this:\n  \\<not> P (seq1 a) (seq1 b)\n  P (seq1 a) (seq1 b)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i. seq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. seq (Suc i) = seq i", "obtain i where \"seq (Suc i) = seq i\""], ["proof (prove)\nusing this:\n  \\<exists>i. seq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        seq (Suc i) = seq i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  seq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>finite T; T \\<subseteq> S;\n         \\<And>s.\n            s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>T. P t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. finite ?T\n 2. ?T \\<subseteq> S\n 3. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>?T. P t s", "show \"finite (seq i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (seq i)", "by (induct i, simp_all add: seq_def fun_def)"], ["proof (state)\nthis:\n  finite (seq i)\n\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s", "assume \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s", "let ?s = \"Eps (crit (seq i))\""], ["proof (state)\ngoal (2 subgoals):\n 1. seq i \\<subseteq> S\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> \\<exists>t\\<in>seq i. P t s", "show \"\\<exists>t\\<in>seq i. P t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>seq i. P t s", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False", "assume \"\\<forall>t\\<in>seq i. \\<not> P t s\""], ["proof (state)\nthis:\n  \\<forall>t\\<in>seq i. \\<not> P t s\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False", "with \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> S\n  \\<forall>t\\<in>seq i. \\<not> P t s", "have \"crit (seq i) s\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  \\<forall>t\\<in>seq i. \\<not> P t s\n\ngoal (1 subgoal):\n 1. crit (seq i) s", "by (simp only: crit_def)"], ["proof (state)\nthis:\n  crit (seq i) s\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False", "hence \"crit (seq i) ?s\" and eq: \"seq (Suc i) = insert ?s (seq i)\""], ["proof (prove)\nusing this:\n  crit (seq i) s\n\ngoal (1 subgoal):\n 1. crit (seq i) (Eps (crit (seq i))) &&&\n    seq (Suc i) = insert (Eps (crit (seq i))) (seq i)", "by (auto simp add: seq_Suc fun_def intro: someI)"], ["proof (state)\nthis:\n  crit (seq i) (Eps (crit (seq i)))\n  seq (Suc i) = insert (Eps (crit (seq i))) (seq i)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False", "from this(1)"], ["proof (chain)\npicking this:\n  crit (seq i) (Eps (crit (seq i)))", "have \"?s \\<notin> seq i\""], ["proof (prove)\nusing this:\n  crit (seq i) (Eps (crit (seq i)))\n\ngoal (1 subgoal):\n 1. Eps (crit (seq i)) \\<notin> seq i", "by (rule critD)"], ["proof (state)\nthis:\n  Eps (crit (seq i)) \\<notin> seq i\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False", "hence \"seq (Suc i) \\<noteq> seq i\""], ["proof (prove)\nusing this:\n  Eps (crit (seq i)) \\<notin> seq i\n\ngoal (1 subgoal):\n 1. seq (Suc i) \\<noteq> seq i", "unfolding eq"], ["proof (prove)\nusing this:\n  Eps (crit (seq i)) \\<notin> seq i\n\ngoal (1 subgoal):\n 1. insert (Eps (crit (seq i))) (seq i) \\<noteq> seq i", "by blast"], ["proof (state)\nthis:\n  seq (Suc i) \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>seq i. \\<not> P t s \\<Longrightarrow> False", "from this \\<open>seq (Suc i) = seq i\\<close>"], ["proof (chain)\npicking this:\n  seq (Suc i) \\<noteq> seq i\n  seq (Suc i) = seq i", "show False"], ["proof (prove)\nusing this:\n  seq (Suc i) \\<noteq> seq i\n  seq (Suc i) = seq i\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t\\<in>seq i. P t s\n\ngoal (1 subgoal):\n 1. seq i \\<subseteq> S", "qed (fact sub)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lists\\<close>"], ["", "lemma map_upt: \"map (\\<lambda>i. f (xs ! i)) [0..<length xs] = map f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i)) [0..<length xs] = map f xs", "by (auto intro: nth_equalityI)"], ["", "lemma map_upt_zip:\n  assumes \"length xs = length ys\"\n  shows \"map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map (\\<lambda>(x, y). f x y) (zip xs ys)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys", "have len_l: \"length ?l = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys]) =\n    length ys", "by simp"], ["proof (state)\nthis:\n  length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys]) = length ys\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys", "from assms"], ["proof (chain)\npicking this:\n  length xs = length ys", "have len_r: \"length ?r = length ys\""], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. length (map2 f xs ys) = length ys", "by simp"], ["proof (state)\nthis:\n  length (map2 f xs ys) = length ys\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys", "proof (simp only: list_eq_iff_nth_eq len_l len_r, rule, rule, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i =\n       map2 f xs ys ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i =\n       map2 f xs ys ! i", "assume \"i < length ys\""], ["proof (state)\nthis:\n  i < length ys\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i =\n       map2 f xs ys ! i", "hence \"i < length ?l\" and \"i < length ?r\""], ["proof (prove)\nusing this:\n  i < length ys\n\ngoal (1 subgoal):\n 1. i < length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys]) &&&\n    i < length (map2 f xs ys)", "by (simp_all only: len_l len_r)"], ["proof (state)\nthis:\n  i < length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys])\n  i < length (map2 f xs ys)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i =\n       map2 f xs ys ! i", "thus \"map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i = map (\\<lambda>(x, y). f x y) (zip xs ys) ! i\""], ["proof (prove)\nusing this:\n  i < length (map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys])\n  i < length (map2 f xs ys)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i =\n    map2 f xs ys ! i", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] ! i =\n  map2 f xs ys ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>i. f (xs ! i) (ys ! i)) [0..<length ys] = map2 f xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_sorted_wrt_irrefl:\n  assumes \"irreflp rel\" and \"transp rel\" and \"sorted_wrt rel xs\"\n  shows \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs", "using assms(3)"], ["proof (prove)\nusing this:\n  sorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. distinct xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted_wrt rel [] \\<Longrightarrow> distinct []\n 2. \\<And>a xs.\n       \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs;\n        sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "case Nil"], ["proof (state)\nthis:\n  sorted_wrt rel []\n\ngoal (2 subgoals):\n 1. sorted_wrt rel [] \\<Longrightarrow> distinct []\n 2. \\<And>a xs.\n       \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs;\n        sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct []", "by simp"], ["proof (state)\nthis:\n  distinct []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs;\n        sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs;\n        sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  sorted_wrt rel xs \\<Longrightarrow> distinct xs\n  sorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs;\n        sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "from Cons(2)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (x # xs)", "have \"sorted_wrt rel xs\" and *: \"\\<forall>y\\<in>set xs. rel x y\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs &&& \\<forall>y\\<in>set xs. rel x y", "by (simp_all)"], ["proof (state)\nthis:\n  sorted_wrt rel xs\n  \\<forall>y\\<in>set xs. rel x y\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs;\n        sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "from this(1)"], ["proof (chain)\npicking this:\n  sorted_wrt rel xs", "have \"distinct xs\""], ["proof (prove)\nusing this:\n  sorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. distinct xs", "by (rule Cons(1))"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted_wrt rel xs \\<Longrightarrow> distinct xs;\n        sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (x # xs)", "proof (simp add: \\<open>distinct xs\\<close>, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> False", "assume \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set xs. rel x y\n  x \\<in> set xs", "have \"rel x x\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set xs. rel x y\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x x", ".."], ["proof (state)\nthis:\n  rel x x\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> False", "with assms(1)"], ["proof (chain)\npicking this:\n  irreflp rel\n  rel x x", "show False"], ["proof (prove)\nusing this:\n  irreflp rel\n  rel x x\n\ngoal (1 subgoal):\n 1. False", "by (simp add: irreflp_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_sorted_wrt_imp_sorted_wrt_strict:\n  assumes \"distinct xs\" and \"sorted_wrt rel xs\"\n  shows \"sorted_wrt (\\<lambda>x y. rel x y \\<and> \\<not> x = y) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  sorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; sorted_wrt rel []\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y)\n                       []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (\\<lambda>x y.\n rel x y \\<and> x \\<noteq> y)\n                                   xs;\n        distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt\n                          (\\<lambda>x y. rel x y \\<and> x \\<noteq> y)\n                          (a # xs)", "case Nil"], ["proof (state)\nthis:\n  distinct []\n  sorted_wrt rel []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; sorted_wrt rel []\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y)\n                       []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (\\<lambda>x y.\n rel x y \\<and> x \\<noteq> y)\n                                   xs;\n        distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt\n                          (\\<lambda>x y. rel x y \\<and> x \\<noteq> y)\n                          (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) []", "by simp"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (\\<lambda>x y.\n rel x y \\<and> x \\<noteq> y)\n                                   xs;\n        distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt\n                          (\\<lambda>x y. rel x y \\<and> x \\<noteq> y)\n                          (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (\\<lambda>x y.\n rel x y \\<and> x \\<noteq> y)\n                                   xs;\n        distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt\n                          (\\<lambda>x y. rel x y \\<and> x \\<noteq> y)\n                          (a # xs)", "case step: (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y)\n                     xs\n  distinct (x # xs)\n  sorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs; sorted_wrt rel xs\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (\\<lambda>x y.\n rel x y \\<and> x \\<noteq> y)\n                                   xs;\n        distinct (a # xs); sorted_wrt rel (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt\n                          (\\<lambda>x y. rel x y \\<and> x \\<noteq> y)\n                          (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "proof (cases \"xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "case (Cons y zs)"], ["proof (state)\nthis:\n  xs = y # zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "from step(2)"], ["proof (chain)\npicking this:\n  distinct (x # xs)", "have \"x \\<noteq> y\" and 1: \"distinct (y # zs)\""], ["proof (prove)\nusing this:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y &&& distinct (y # zs)", "by (simp_all add: Cons)"], ["proof (state)\nthis:\n  x \\<noteq> y\n  distinct (y # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "from step(3)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (x # xs)", "have \"rel x y\" and 2: \"sorted_wrt rel (y # zs)\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. rel x y &&& sorted_wrt rel (y # zs)", "by (simp_all add: Cons)"], ["proof (state)\nthis:\n  rel x y\n  sorted_wrt rel (y # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "from 1 2"], ["proof (chain)\npicking this:\n  distinct (y # zs)\n  sorted_wrt rel (y # zs)", "have \"sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\""], ["proof (prove)\nusing this:\n  distinct (y # zs)\n  sorted_wrt rel (y # zs)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)", "by (rule step(1)[simplified Cons])"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "with \\<open>x \\<noteq> y\\<close> \\<open>rel x y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  rel x y\n  sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  rel x y\n  sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "using step.prems"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  rel x y\n  sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (y # zs)\n  distinct (x # xs)\n  sorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)", "by (auto simp: Cons)"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. rel x y \\<and> x \\<noteq> y) (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_wrt_distinct_set_unique:\n  assumes \"antisymp rel\"\n  assumes \"sorted_wrt rel xs\" \"distinct xs\" \"sorted_wrt rel ys\" \"distinct ys\" \"set xs = set ys\"\n  shows \"xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = ys", "from assms"], ["proof (chain)\npicking this:\n  antisymp rel\n  sorted_wrt rel xs\n  distinct xs\n  sorted_wrt rel ys\n  distinct ys\n  set xs = set ys", "have 1: \"length xs = length ys\""], ["proof (prove)\nusing this:\n  antisymp rel\n  sorted_wrt rel xs\n  distinct xs\n  sorted_wrt rel ys\n  distinct ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. length xs = length ys", "by (auto dest!: distinct_card)"], ["proof (state)\nthis:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. xs = ys", "from assms(2-6)"], ["proof (chain)\npicking this:\n  sorted_wrt rel xs\n  distinct xs\n  sorted_wrt rel ys\n  distinct ys\n  set xs = set ys", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt rel xs\n  distinct xs\n  sorted_wrt rel ys\n  distinct ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. xs = ys", "proof(induct rule:list_induct2[OF 1])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt rel []; distinct []; sorted_wrt rel []; distinct [];\n     set [] = set []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case 1"], ["proof (state)\nthis:\n  sorted_wrt rel []\n  distinct []\n  sorted_wrt rel []\n  distinct []\n  set [] = set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt rel []; distinct []; sorted_wrt rel []; distinct [];\n     set [] = set []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] = []", "by simp"], ["proof (state)\nthis:\n  [] = []\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (2 x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys; distinct ys;\n   set xs = set ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  sorted_wrt rel (x # xs)\n  distinct (x # xs)\n  sorted_wrt rel (y # ys)\n  distinct (y # ys)\n  set (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "from 2(4)"], ["proof (chain)\npicking this:\n  distinct (x # xs)", "have \"x \\<notin> set xs\" and \"distinct xs\""], ["proof (prove)\nusing this:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs &&& distinct xs", "by simp_all"], ["proof (state)\nthis:\n  x \\<notin> set xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "from 2(6)"], ["proof (chain)\npicking this:\n  distinct (y # ys)", "have \"y \\<notin> set ys\" and \"distinct ys\""], ["proof (prove)\nusing this:\n  distinct (y # ys)\n\ngoal (1 subgoal):\n 1. y \\<notin> set ys &&& distinct ys", "by simp_all"], ["proof (state)\nthis:\n  y \\<notin> set ys\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "have \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "from 2(3)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (x # xs)", "have \"\\<forall>z\\<in>set xs. rel x z\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set xs. rel x z", "by (simp)"], ["proof (state)\nthis:\n  \\<forall>z\\<in>set xs. rel x z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>z\\<in>set xs. rel x z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "from \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have \"y \\<in> set xs\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. y \\<in> set xs", "using 2(7)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. y \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>z\\<in>set xs. rel x z\n  y \\<in> set xs", "have *: \"rel x y\""], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>set xs. rel x z\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x y", ".."], ["proof (state)\nthis:\n  rel x y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "from 2(5)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (y # ys)", "have \"\\<forall>z\\<in>set ys. rel y z\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set ys. rel y z", "by (simp)"], ["proof (state)\nthis:\n  \\<forall>z\\<in>set ys. rel y z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>z\\<in>set ys. rel y z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "from \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have \"x \\<in> set ys\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<in> set ys", "using 2(7)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  set (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. x \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>z\\<in>set ys. rel y z\n  x \\<in> set ys", "have \"rel y x\""], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>set ys. rel y z\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y x", ".."], ["proof (state)\nthis:\n  rel y x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "with assms(1) *"], ["proof (chain)\npicking this:\n  antisymp rel\n  rel x y\n  rel y x", "have \"x = y\""], ["proof (prove)\nusing this:\n  antisymp rel\n  rel x y\n  rel y x\n\ngoal (1 subgoal):\n 1. x = y", "by (rule antisympD)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "with \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x = y", "show False"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x = y\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "from 2(3)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (x # xs)", "have \"sorted_wrt rel xs\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs", "by (simp)"], ["proof (state)\nthis:\n  sorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "moreover"], ["proof (state)\nthis:\n  sorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "note \\<open>distinct xs\\<close>"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "moreover"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "from 2(5)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (y # ys)", "have \"sorted_wrt rel ys\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel ys", "by (simp)"], ["proof (state)\nthis:\n  sorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "moreover"], ["proof (state)\nthis:\n  sorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "note \\<open>distinct ys\\<close>"], ["proof (state)\nthis:\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "moreover"], ["proof (state)\nthis:\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "from 2(7) \\<open>x \\<notin> set xs\\<close> \\<open>y \\<notin> set ys\\<close>"], ["proof (chain)\npicking this:\n  set (x # xs) = set (y # ys)\n  x \\<notin> set xs\n  y \\<notin> set ys", "have \"set xs = set ys\""], ["proof (prove)\nusing this:\n  set (x # xs) = set (y # ys)\n  x \\<notin> set xs\n  y \\<notin> set ys\n\ngoal (1 subgoal):\n 1. set xs = set ys", "by (auto simp add: \\<open>x = y\\<close>)"], ["proof (state)\nthis:\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "ultimately"], ["proof (chain)\npicking this:\n  sorted_wrt rel xs\n  distinct xs\n  sorted_wrt rel ys\n  distinct ys\n  set xs = set ys", "have \"xs = ys\""], ["proof (prove)\nusing this:\n  sorted_wrt rel xs\n  distinct xs\n  sorted_wrt rel ys\n  distinct ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. xs = ys", "by (rule 2(2))"], ["proof (state)\nthis:\n  xs = ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_wrt rel xs; distinct xs; sorted_wrt rel ys;\n         distinct ys; set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_wrt rel (x # xs); distinct (x # xs); sorted_wrt rel (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "with \\<open>x = y\\<close>"], ["proof (chain)\npicking this:\n  x = y\n  xs = ys", "show ?case"], ["proof (prove)\nusing this:\n  x = y\n  xs = ys\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "by simp"], ["proof (state)\nthis:\n  x # xs = y # ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_wrt_refl_nth_mono:\n  assumes \"reflp P\" and \"sorted_wrt P xs\" and \"i \\<le> j\" and \"j < length xs\"\n  shows \"P (xs ! i) (xs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (xs ! i) (xs ! j)", "proof (cases \"i < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> P (xs ! i) (xs ! j)\n 2. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)", "case True"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> P (xs ! i) (xs ! j)\n 2. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)", "from assms(2) this assms(4)"], ["proof (chain)\npicking this:\n  sorted_wrt P xs\n  i < j\n  j < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt P xs\n  i < j\n  j < length xs\n\ngoal (1 subgoal):\n 1. P (xs ! i) (xs ! j)", "by (rule sorted_wrt_nth_less)"], ["proof (state)\nthis:\n  P (xs ! i) (xs ! j)\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)", "case False"], ["proof (state)\nthis:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)", "with assms(3)"], ["proof (chain)\npicking this:\n  i \\<le> j\n  \\<not> i < j", "have \"i = j\""], ["proof (prove)\nusing this:\n  i \\<le> j\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. i = j", "by simp"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> P (xs ! i) (xs ! j)", "from assms(1)"], ["proof (chain)\npicking this:\n  reflp P", "show ?thesis"], ["proof (prove)\nusing this:\n  reflp P\n\ngoal (1 subgoal):\n 1. P (xs ! i) (xs ! j)", "unfolding \\<open>i = j\\<close>"], ["proof (prove)\nusing this:\n  reflp P\n\ngoal (1 subgoal):\n 1. P (xs ! j) (xs ! j)", "by (rule reflpD)"], ["proof (state)\nthis:\n  P (xs ! i) (xs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun merge_wrt :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"merge_wrt _ xs [] = xs\"|\n  \"merge_wrt rel [] ys = ys\"|\n  \"merge_wrt rel (x # xs) (y # ys) =\n    (if x = y then\n      y # (merge_wrt rel xs ys)\n    else if rel x y then\n      x # (merge_wrt rel xs (y # ys))\n    else\n      y # (merge_wrt rel (x # xs) ys)\n    )\""], ["", "lemma set_merge_wrt: \"set (merge_wrt rel xs ys) = set xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel xs ys) = set xs \\<union> set ys", "proof (induct rel xs ys rule: merge_wrt.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ xs. set (merge_wrt uu_ xs []) = set xs \\<union> set []\n 2. \\<And>rel v va.\n       set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 3. \\<And>rel x xs y ys.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                set (merge_wrt rel xs ys) = set xs \\<union> set ys;\n        \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) =\n                          set xs \\<union> set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) =\n                          set (x # xs) \\<union> set ys\\<rbrakk>\n       \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) =\n                         set (x # xs) \\<union> set (y # ys)", "case (1 rel xs)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>uu_ xs. set (merge_wrt uu_ xs []) = set xs \\<union> set []\n 2. \\<And>rel v va.\n       set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 3. \\<And>rel x xs y ys.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                set (merge_wrt rel xs ys) = set xs \\<union> set ys;\n        \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) =\n                          set xs \\<union> set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) =\n                          set (x # xs) \\<union> set ys\\<rbrakk>\n       \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) =\n                         set (x # xs) \\<union> set (y # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel xs []) = set xs \\<union> set []", "by simp"], ["proof (state)\nthis:\n  set (merge_wrt rel xs []) = set xs \\<union> set []\n\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                set (merge_wrt rel xs ys) = set xs \\<union> set ys;\n        \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) =\n                          set xs \\<union> set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) =\n                          set (x # xs) \\<union> set ys\\<rbrakk>\n       \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) =\n                         set (x # xs) \\<union> set (y # ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                set (merge_wrt rel xs ys) = set xs \\<union> set ys;\n        \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) =\n                          set xs \\<union> set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) =\n                          set (x # xs) \\<union> set ys\\<rbrakk>\n       \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) =\n                         set (x # xs) \\<union> set (y # ys)", "case (2 rel y ys)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       set (merge_wrt rel [] (v # va)) = set [] \\<union> set (v # va)\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                set (merge_wrt rel xs ys) = set xs \\<union> set ys;\n        \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) =\n                          set xs \\<union> set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) =\n                          set (x # xs) \\<union> set ys\\<rbrakk>\n       \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) =\n                         set (x # xs) \\<union> set (y # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel [] (y # ys)) = set [] \\<union> set (y # ys)", "by simp"], ["proof (state)\nthis:\n  set (merge_wrt rel [] (y # ys)) = set [] \\<union> set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                set (merge_wrt rel xs ys) = set xs \\<union> set ys;\n        \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) =\n                          set xs \\<union> set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) =\n                          set (x # xs) \\<union> set ys\\<rbrakk>\n       \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) =\n                         set (x # xs) \\<union> set (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                set (merge_wrt rel xs ys) = set xs \\<union> set ys;\n        \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) =\n                          set xs \\<union> set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) =\n                          set (x # xs) \\<union> set ys\\<rbrakk>\n       \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) =\n                         set (x # xs) \\<union> set (y # ys)", "case (3 rel x xs y ys)"], ["proof (state)\nthis:\n  x = y \\<Longrightarrow> set (merge_wrt rel xs ys) = set xs \\<union> set ys\n  \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk>\n  \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) =\n                    set xs \\<union> set (y # ys)\n  \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk>\n  \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) =\n                    set (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                set (merge_wrt rel xs ys) = set xs \\<union> set ys;\n        \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel xs (y # ys)) =\n                          set xs \\<union> set (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk>\n        \\<Longrightarrow> set (merge_wrt rel (x # xs) ys) =\n                          set (x # xs) \\<union> set ys\\<rbrakk>\n       \\<Longrightarrow> set (merge_wrt rel (x # xs) (y # ys)) =\n                         set (x # xs) \\<union> set (y # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)\n 2. x \\<noteq> y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)\n 2. x \\<noteq> y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "by (simp add: 3(1))"], ["proof (state)\nthis:\n  set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "proof (cases \"rel x y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)\n 2. \\<not> rel x y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "case True"], ["proof (state)\nthis:\n  rel x y\n\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)\n 2. \\<not> rel x y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "with \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  rel x y", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  rel x y\n\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "by (simp add: 3(2) insert_commute)"], ["proof (state)\nthis:\n  set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "case False"], ["proof (state)\nthis:\n  \\<not> rel x y\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow>\n    set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "with \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  \\<not> rel x y", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<not> rel x y\n\ngoal (1 subgoal):\n 1. set (merge_wrt rel (x # xs) (y # ys)) =\n    set (x # xs) \\<union> set (y # ys)", "by (simp add: 3(3))"], ["proof (state)\nthis:\n  set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (merge_wrt rel (x # xs) (y # ys)) = set (x # xs) \\<union> set (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_merge_wrt:\n  assumes \"transp rel\" and \"\\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x\"\n    and \"sorted_wrt rel xs\" and \"sorted_wrt rel ys\"\n  shows \"sorted_wrt rel (merge_wrt rel xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)", "using assms"], ["proof (prove)\nusing this:\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel xs\n  sorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)", "proof (induct rel xs ys rule: merge_wrt.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ xs.\n       \\<lbrakk>transp uu_;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> uu_ x y \\<or> uu_ y x;\n        sorted_wrt uu_ xs; sorted_wrt uu_ []\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt uu_ (merge_wrt uu_ xs [])\n 2. \\<And>rel v va.\n       \\<lbrakk>transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 3. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; transp rel;\n                 \\<And>x y.\n                    x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n                 sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys);\n        \\<lbrakk>x \\<noteq> y; rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys);\n        transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "case (1 rel xs)"], ["proof (state)\nthis:\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel xs\n  sorted_wrt rel []\n\ngoal (3 subgoals):\n 1. \\<And>uu_ xs.\n       \\<lbrakk>transp uu_;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> uu_ x y \\<or> uu_ y x;\n        sorted_wrt uu_ xs; sorted_wrt uu_ []\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt uu_ (merge_wrt uu_ xs [])\n 2. \\<And>rel v va.\n       \\<lbrakk>transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 3. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; transp rel;\n                 \\<And>x y.\n                    x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n                 sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys);\n        \\<lbrakk>x \\<noteq> y; rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys);\n        transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "from 1(3)"], ["proof (chain)\npicking this:\n  sorted_wrt rel xs", "show ?case"], ["proof (prove)\nusing this:\n  sorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs [])", "by simp"], ["proof (state)\nthis:\n  sorted_wrt rel (merge_wrt rel xs [])\n\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       \\<lbrakk>transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; transp rel;\n                 \\<And>x y.\n                    x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n                 sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys);\n        \\<lbrakk>x \\<noteq> y; rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys);\n        transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       \\<lbrakk>transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; transp rel;\n                 \\<And>x y.\n                    x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n                 sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys);\n        \\<lbrakk>x \\<noteq> y; rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys);\n        transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "case (2 rel y ys)"], ["proof (state)\nthis:\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel []\n  sorted_wrt rel (y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       \\<lbrakk>transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel []; sorted_wrt rel (v # va)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel [] (v # va))\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; transp rel;\n                 \\<And>x y.\n                    x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n                 sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys);\n        \\<lbrakk>x \\<noteq> y; rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys);\n        transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "from 2(4)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (y # ys)", "show ?case"], ["proof (prove)\nusing this:\n  sorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel [] (y # ys))", "by simp"], ["proof (state)\nthis:\n  sorted_wrt rel (merge_wrt rel [] (y # ys))\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; transp rel;\n                 \\<And>x y.\n                    x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n                 sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys);\n        \\<lbrakk>x \\<noteq> y; rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys);\n        transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; transp rel;\n                 \\<And>x y.\n                    x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n                 sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys);\n        \\<lbrakk>x \\<noteq> y; rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys);\n        transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "case (3 rel x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>x = y; transp rel;\n   \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n   sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys)\n  \\<lbrakk>x \\<noteq> y; rel x y; transp rel;\n   \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n   sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys))\n  \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel;\n   \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n   sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys)\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel (x # xs)\n  sorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; transp rel;\n                 \\<And>x y.\n                    x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n                 sorted_wrt rel xs; sorted_wrt rel ys\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs ys);\n        \\<lbrakk>x \\<noteq> y; rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel xs; sorted_wrt rel (y # ys)\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel xs (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y; transp rel;\n         \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n         sorted_wrt rel (x # xs); sorted_wrt rel ys\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) ys);\n        transp rel;\n        \\<And>x y. x \\<noteq> y \\<Longrightarrow> rel x y \\<or> rel y x;\n        sorted_wrt rel (x # xs); sorted_wrt rel (y # ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. x \\<noteq> y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. x \\<noteq> y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "proof (auto simp add: True)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)", "assume \"z \\<in> set (merge_wrt rel xs ys)\""], ["proof (state)\nthis:\n  z \\<in> set (merge_wrt rel xs ys)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)", "hence \"z \\<in> set xs \\<union> set ys\""], ["proof (prove)\nusing this:\n  z \\<in> set (merge_wrt rel xs ys)\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys", "by (simp only: set_merge_wrt)"], ["proof (state)\nthis:\n  z \\<in> set xs \\<union> set ys\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (merge_wrt rel xs ys) \\<Longrightarrow> rel y x\n 2. sorted_wrt rel (merge_wrt rel xs ys)", "thus \"rel y z\""], ["proof (prove)\nusing this:\n  z \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. rel y z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z", "assume \"z \\<in> set xs\""], ["proof (state)\nthis:\n  z \\<in> set xs\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z", "with 3(6)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (x # xs)\n  z \\<in> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt rel (x # xs)\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel y z", "by (simp add: True)"], ["proof (state)\nthis:\n  rel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z", "assume \"z \\<in> set ys\""], ["proof (state)\nthis:\n  z \\<in> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z", "with 3(7)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (y # ys)\n  z \\<in> set ys", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt rel (y # ys)\n  z \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y z", "by (simp)"], ["proof (state)\nthis:\n  rel y z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel y z\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)", "note True 3(4, 5)"], ["proof (state)\nthis:\n  x = y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)", "moreover"], ["proof (state)\nthis:\n  x = y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)", "from 3(6)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (x # xs)", "have \"sorted_wrt rel xs\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs", "by (simp)"], ["proof (state)\nthis:\n  sorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)", "moreover"], ["proof (state)\nthis:\n  sorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)", "from 3(7)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (y # ys)", "have \"sorted_wrt rel ys\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel ys", "by (simp)"], ["proof (state)\nthis:\n  sorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)", "ultimately"], ["proof (chain)\npicking this:\n  x = y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel xs\n  sorted_wrt rel ys", "show \"sorted_wrt rel (merge_wrt rel xs ys)\""], ["proof (prove)\nusing this:\n  x = y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel xs\n  sorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs ys)", "by (rule 3(1))"], ["proof (state)\nthis:\n  sorted_wrt rel (merge_wrt rel xs ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "proof (cases \"rel x y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. \\<not> rel x y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "case True"], ["proof (state)\nthis:\n  rel x y\n\ngoal (2 subgoals):\n 1. rel x y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n 2. \\<not> rel x y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "proof (auto simp add: False True)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))", "assume \"z \\<in> set (merge_wrt rel xs (y # ys))\""], ["proof (state)\nthis:\n  z \\<in> set (merge_wrt rel xs (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))", "hence \"z \\<in> insert y (set xs \\<union> set ys)\""], ["proof (prove)\nusing this:\n  z \\<in> set (merge_wrt rel xs (y # ys))\n\ngoal (1 subgoal):\n 1. z \\<in> insert y (set xs \\<union> set ys)", "by (simp add: set_merge_wrt)"], ["proof (state)\nthis:\n  z \\<in> insert y (set xs \\<union> set ys)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (merge_wrt rel xs (y # ys)) \\<Longrightarrow> rel x xa\n 2. sorted_wrt rel (merge_wrt rel xs (y # ys))", "thus \"rel x z\""], ["proof (prove)\nusing this:\n  z \\<in> insert y (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. rel x z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z = y \\<Longrightarrow> rel x z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z", "assume \"z = y\""], ["proof (state)\nthis:\n  z = y\n\ngoal (2 subgoals):\n 1. z = y \\<Longrightarrow> rel x z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z", "with True"], ["proof (chain)\npicking this:\n  rel x y\n  z = y", "show ?thesis"], ["proof (prove)\nusing this:\n  rel x y\n  z = y\n\ngoal (1 subgoal):\n 1. rel x z", "by simp"], ["proof (state)\nthis:\n  rel x z\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z", "assume \"z \\<in> set xs \\<union> set ys\""], ["proof (state)\nthis:\n  z \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel x z", "thus ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. rel x z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel x z\n 2. z \\<in> set ys \\<Longrightarrow> rel x z", "assume \"z \\<in> set xs\""], ["proof (state)\nthis:\n  z \\<in> set xs\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel x z\n 2. z \\<in> set ys \\<Longrightarrow> rel x z", "with 3(6)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (x # xs)\n  z \\<in> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt rel (x # xs)\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x z", "by (simp)"], ["proof (state)\nthis:\n  rel x z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z", "assume \"z \\<in> set ys\""], ["proof (state)\nthis:\n  z \\<in> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z", "with 3(7)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (y # ys)\n  z \\<in> set ys", "have \"rel y z\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (y # ys)\n  z \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y z", "by (simp)"], ["proof (state)\nthis:\n  rel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel x z", "with 3(4) True"], ["proof (chain)\npicking this:\n  transp rel\n  rel x y\n  rel y z", "show ?thesis"], ["proof (prove)\nusing this:\n  transp rel\n  rel x y\n  rel y z\n\ngoal (1 subgoal):\n 1. rel x z", "by (rule transpD)"], ["proof (state)\nthis:\n  rel x z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel x z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel x z\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))", "note False True 3(4, 5)"], ["proof (state)\nthis:\n  x \\<noteq> y\n  rel x y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))", "moreover"], ["proof (state)\nthis:\n  x \\<noteq> y\n  rel x y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))", "from 3(6)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (x # xs)", "have \"sorted_wrt rel xs\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel xs", "by (simp)"], ["proof (state)\nthis:\n  sorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))", "ultimately"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  rel x y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel xs", "show \"sorted_wrt rel (merge_wrt rel xs (y # ys))\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  rel x y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel xs\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))", "using 3(7)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  rel x y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel xs\n  sorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel xs (y # ys))", "by (rule 3(2))"], ["proof (state)\nthis:\n  sorted_wrt rel (merge_wrt rel xs (y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "assume \"\\<not> rel x y\""], ["proof (state)\nthis:\n  \\<not> rel x y\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "from \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have \"rel x y \\<or> rel y x\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. rel x y \\<or> rel y x", "by (rule 3(5))"], ["proof (state)\nthis:\n  rel x y \\<or> rel y x\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "with \\<open>\\<not> rel x y\\<close>"], ["proof (chain)\npicking this:\n  \\<not> rel x y\n  rel x y \\<or> rel y x", "have *: \"rel y x\""], ["proof (prove)\nusing this:\n  \\<not> rel x y\n  rel x y \\<or> rel y x\n\ngoal (1 subgoal):\n 1. rel y x", "by simp"], ["proof (state)\nthis:\n  rel y x\n\ngoal (1 subgoal):\n 1. \\<not> rel x y \\<Longrightarrow>\n    sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))", "proof (auto simp add: False \\<open>\\<not> rel x y\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)", "assume \"z \\<in> set (merge_wrt rel (x # xs) ys)\""], ["proof (state)\nthis:\n  z \\<in> set (merge_wrt rel (x # xs) ys)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)", "hence \"z \\<in> insert x (set xs \\<union> set ys)\""], ["proof (prove)\nusing this:\n  z \\<in> set (merge_wrt rel (x # xs) ys)\n\ngoal (1 subgoal):\n 1. z \\<in> insert x (set xs \\<union> set ys)", "by (simp add: set_merge_wrt)"], ["proof (state)\nthis:\n  z \\<in> insert x (set xs \\<union> set ys)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (merge_wrt rel (x # xs) ys) \\<Longrightarrow> rel y xa\n 2. sorted_wrt rel (merge_wrt rel (x # xs) ys)", "thus \"rel y z\""], ["proof (prove)\nusing this:\n  z \\<in> insert x (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. rel y z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel y z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z", "assume \"z = x\""], ["proof (state)\nthis:\n  z = x\n\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel y z\n 2. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z", "with *"], ["proof (chain)\npicking this:\n  rel y x\n  z = x", "show ?thesis"], ["proof (prove)\nusing this:\n  rel y x\n  z = x\n\ngoal (1 subgoal):\n 1. rel y z", "by simp"], ["proof (state)\nthis:\n  rel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z", "assume \"z \\<in> set xs \\<union> set ys\""], ["proof (state)\nthis:\n  z \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<union> set ys \\<Longrightarrow> rel y z", "thus ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. rel y z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z", "assume \"z \\<in> set xs\""], ["proof (state)\nthis:\n  z \\<in> set xs\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z", "with 3(6)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (x # xs)\n  z \\<in> set xs", "have \"rel x z\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (x # xs)\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x z", "by (simp)"], ["proof (state)\nthis:\n  rel x z\n\ngoal (2 subgoals):\n 1. z \\<in> set xs \\<Longrightarrow> rel y z\n 2. z \\<in> set ys \\<Longrightarrow> rel y z", "with 3(4) *"], ["proof (chain)\npicking this:\n  transp rel\n  rel y x\n  rel x z", "show ?thesis"], ["proof (prove)\nusing this:\n  transp rel\n  rel y x\n  rel x z\n\ngoal (1 subgoal):\n 1. rel y z", "by (rule transpD)"], ["proof (state)\nthis:\n  rel y z\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z", "assume \"z \\<in> set ys\""], ["proof (state)\nthis:\n  z \\<in> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> rel y z", "with 3(7)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (y # ys)\n  z \\<in> set ys", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt rel (y # ys)\n  z \\<in> set ys\n\ngoal (1 subgoal):\n 1. rel y z", "by (simp)"], ["proof (state)\nthis:\n  rel y z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel y z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel y z\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)", "note False \\<open>\\<not> rel x y\\<close> 3(4, 5, 6)"], ["proof (state)\nthis:\n  x \\<noteq> y\n  \\<not> rel x y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)", "moreover"], ["proof (state)\nthis:\n  x \\<noteq> y\n  \\<not> rel x y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)", "from 3(7)"], ["proof (chain)\npicking this:\n  sorted_wrt rel (y # ys)", "have \"sorted_wrt rel ys\""], ["proof (prove)\nusing this:\n  sorted_wrt rel (y # ys)\n\ngoal (1 subgoal):\n 1. sorted_wrt rel ys", "by (simp)"], ["proof (state)\nthis:\n  sorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  \\<not> rel x y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel (x # xs)\n  sorted_wrt rel ys", "show \"sorted_wrt rel (merge_wrt rel (x # xs) ys)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<not> rel x y\n  transp rel\n  ?x \\<noteq> ?y \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  sorted_wrt rel (x # xs)\n  sorted_wrt rel ys\n\ngoal (1 subgoal):\n 1. sorted_wrt rel (merge_wrt rel (x # xs) ys)", "by (rule 3(3))"], ["proof (state)\nthis:\n  sorted_wrt rel (merge_wrt rel (x # xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt rel (merge_wrt rel (x # xs) (y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_fold:\n  assumes \"\\<And>x ys. set (f (g x) ys) = set (g x) \\<union> set ys\"\n  shows \"set (fold (\\<lambda>x. f (g x)) xs ys) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) xs ys) =\n    (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ys", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       set (fold (\\<lambda>x. f (g x)) [] ys) =\n       (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           set (fold (\\<lambda>x. f (g x)) xs ys) =\n           (\\<Union>x\\<in>set xs. set (g x)) \\<union>\n           set ys) \\<Longrightarrow>\n       set (fold (\\<lambda>x. f (g x)) (a # xs) ys) =\n       (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       set (fold (\\<lambda>x. f (g x)) [] ys) =\n       (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           set (fold (\\<lambda>x. f (g x)) xs ys) =\n           (\\<Union>x\\<in>set xs. set (g x)) \\<union>\n           set ys) \\<Longrightarrow>\n       set (fold (\\<lambda>x. f (g x)) (a # xs) ys) =\n       (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) [] ys) =\n    (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys", "by simp"], ["proof (state)\nthis:\n  set (fold (\\<lambda>x. f (g x)) [] ys) =\n  (\\<Union>x\\<in>set []. set (g x)) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (fold (\\<lambda>x. f (g x)) xs ys) =\n           (\\<Union>x\\<in>set xs. set (g x)) \\<union>\n           set ys) \\<Longrightarrow>\n       set (fold (\\<lambda>x. f (g x)) (a # xs) ys) =\n       (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (fold (\\<lambda>x. f (g x)) xs ys) =\n           (\\<Union>x\\<in>set xs. set (g x)) \\<union>\n           set ys) \\<Longrightarrow>\n       set (fold (\\<lambda>x. f (g x)) (a # xs) ys) =\n       (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  set (fold (\\<lambda>x. f (g x)) xs ?ys) =\n  (\\<Union>x\\<in>set xs. set (g x)) \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (fold (\\<lambda>x. f (g x)) xs ys) =\n           (\\<Union>x\\<in>set xs. set (g x)) \\<union>\n           set ys) \\<Longrightarrow>\n       set (fold (\\<lambda>x. f (g x)) (a # xs) ys) =\n       (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys", "have eq: \"set (fold (\\<lambda>x. f (g x)) xs (f (g x) ys)) = (\\<Union>x\\<in>set xs. set (g x)) \\<union> set (f (g x) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) xs (f (g x) ys)) =\n    (\\<Union>x\\<in>set xs. set (g x)) \\<union> set (f (g x) ys)", "by (rule Cons)"], ["proof (state)\nthis:\n  set (fold (\\<lambda>x. f (g x)) xs (f (g x) ys)) =\n  (\\<Union>x\\<in>set xs. set (g x)) \\<union> set (f (g x) ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (fold (\\<lambda>x. f (g x)) xs ys) =\n           (\\<Union>x\\<in>set xs. set (g x)) \\<union>\n           set ys) \\<Longrightarrow>\n       set (fold (\\<lambda>x. f (g x)) (a # xs) ys) =\n       (\\<Union>x\\<in>set (a # xs). set (g x)) \\<union> set ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>x. f (g x)) (x # xs) ys) =\n    (\\<Union>x\\<in>set (x # xs). set (g x)) \\<union> set ys", "by (simp add: o_def assms set_merge_wrt eq ac_simps)"], ["proof (state)\nthis:\n  set (fold (\\<lambda>x. f (g x)) (x # xs) ys) =\n  (\\<Union>x\\<in>set (x # xs). set (g x)) \\<union> set ys\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Sums and Products\\<close>"], ["", "lemma additive_implies_homogenous:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f (y::'a::monoid_add))::'b::cancel_comm_monoid_add)\"\n  shows \"f 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)", "have \"f (0 + 0) = f 0 + f 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ((0::'a) + (0::'a)) = f (0::'a) + f (0::'a)", "by (rule assms)"], ["proof (state)\nthis:\n  f ((0::'a) + (0::'a)) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)", "hence \"f 0 = f 0 + f 0\""], ["proof (prove)\nusing this:\n  f ((0::'a) + (0::'a)) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = f (0::'a) + f (0::'a)", "by simp"], ["proof (state)\nthis:\n  f (0::'a) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)", "thus \"f 0 = 0\""], ["proof (prove)\nusing this:\n  f (0::'a) = f (0::'a) + f (0::'a)\n\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  f (0::'a) = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fun_sum_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n  shows \"f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))", "proof (cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. f (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk>\n       \\<Longrightarrow> f (sum g (insert x F)) =\n                         (\\<Sum>a\\<in>insert x F. f (g a))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. f (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk>\n       \\<Longrightarrow> f (sum g (insert x F)) =\n                         (\\<Sum>a\\<in>insert x F. f (g a))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  f (sum g {}) = (\\<Sum>a\\<in>{}. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk>\n       \\<Longrightarrow> f (sum g (insert x F)) =\n                         (\\<Sum>a\\<in>insert x F. f (g a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk>\n       \\<Longrightarrow> f (sum g (insert x F)) =\n                         (\\<Sum>a\\<in>insert x F. f (g a))", "case step: (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f (sum g F) = (\\<Sum>a\\<in>F. f (g a))\\<rbrakk>\n       \\<Longrightarrow> f (sum g (insert x F)) =\n                         (\\<Sum>a\\<in>insert x F. f (g a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (sum g (insert a A)) = (\\<Sum>a\\<in>insert a A. f (g a))", "by (simp add: sum.insert[OF step(1) step(2)] assms(2) step(3))"], ["proof (state)\nthis:\n  f (sum g (insert a A)) = (\\<Sum>a\\<in>insert a A. f (g a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))", "case False"], ["proof (state)\nthis:\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (sum g A) = (\\<Sum>a\\<in>A. f (g a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fun_sum_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f y)::'a::cancel_comm_monoid_add)\"\n  shows \"f (sum g A) = (\\<Sum>a\\<in>A. f (g a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>a\\<in>A. f (g a))", "by (rule fun_sum_commute, rule additive_implies_homogenous, fact+)"], ["", "lemma fun_sum_list_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n  shows \"f (sum_list xs) = sum_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (sum_list xs) = sum_list (map f xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. f (sum_list []) = sum_list (map f [])\n 2. \\<And>a xs.\n       f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow>\n       f (sum_list (a # xs)) = sum_list (map f (a # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. f (sum_list []) = sum_list (map f [])\n 2. \\<And>a xs.\n       f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow>\n       f (sum_list (a # xs)) = sum_list (map f (a # xs))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (sum_list []) = sum_list (map f [])", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  f (sum_list []) = sum_list (map f [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow>\n       f (sum_list (a # xs)) = sum_list (map f (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow>\n       f (sum_list (a # xs)) = sum_list (map f (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  f (sum_list xs) = sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       f (sum_list xs) = sum_list (map f xs) \\<Longrightarrow>\n       f (sum_list (a # xs)) = sum_list (map f (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  f (sum_list xs) = sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. f (sum_list (x # xs)) = sum_list (map f (x # xs))", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  f (sum_list (x # xs)) = sum_list (map f (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fun_sum_list_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + ((f y)::'a::cancel_comm_monoid_add)\"\n  shows \"f (sum_list xs) = sum_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (sum_list xs) = sum_list (map f xs)", "by (rule fun_sum_list_commute, rule additive_implies_homogenous, fact+)"], ["", "lemma sum_set_upt_eq_sum_list: \"(\\<Sum>i = m..<n. f i) = (\\<Sum>i\\<leftarrow>[m..<n]. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {m..<n} = sum_list (map f [m..<n])", "using sum_set_upt_conv_sum_list_nat"], ["proof (prove)\nusing this:\n  sum ?f (set [?m..<?n]) = sum_list (map ?f [?m..<?n])\n\ngoal (1 subgoal):\n 1. sum f {m..<n} = sum_list (map f [m..<n])", "by auto"], ["", "lemma sum_list_upt: \"(\\<Sum>i\\<leftarrow>[0..<(length xs)]. f (xs ! i)) = (\\<Sum>x\\<leftarrow>xs. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<length xs]. f (xs ! i)) = sum_list (map f xs)", "by (simp only: map_upt)"], ["", "lemma sum_list_upt_zip:\n  assumes \"length xs = length ys\"\n  shows \"(\\<Sum>i\\<leftarrow>[0..<(length ys)]. f (xs ! i) (ys ! i)) = (\\<Sum>(x, y)\\<leftarrow>(zip xs ys). f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<length ys]. f (xs ! i) (ys ! i)) =\n    sum_list (map2 f xs ys)", "by (simp only: map_upt_zip[OF assms])"], ["", "lemma sum_list_zeroI:\n  assumes \"set xs \\<subseteq> {0}\"\n  shows \"sum_list xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> {0::'a}\n\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)", "by (induct xs, auto)"], ["", "lemma fun_prod_commute:\n  assumes \"f 1 = 1\" and \"\\<And>x y. f (x * y) = f x * f y\"\n  shows \"f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (prod g A) = (\\<Prod>a\\<in>A. f (g a))", "proof (cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n 2. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. f (prod g A) = (\\<Prod>a\\<in>A. f (g a))", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. f (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk>\n       \\<Longrightarrow> f (prod g (insert x F)) =\n                         (\\<Prod>a\\<in>insert x F. f (g a))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. f (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk>\n       \\<Longrightarrow> f (prod g (insert x F)) =\n                         (\\<Prod>a\\<in>insert x F. f (g a))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  f (prod g {}) = (\\<Prod>a\\<in>{}. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk>\n       \\<Longrightarrow> f (prod g (insert x F)) =\n                         (\\<Prod>a\\<in>insert x F. f (g a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk>\n       \\<Longrightarrow> f (prod g (insert x F)) =\n                         (\\<Prod>a\\<in>insert x F. f (g a))", "case step: (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f (prod g F) = (\\<Prod>a\\<in>F. f (g a))\\<rbrakk>\n       \\<Longrightarrow> f (prod g (insert x F)) =\n                         (\\<Prod>a\\<in>insert x F. f (g a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (prod g (insert a A)) = (\\<Prod>a\\<in>insert a A. f (g a))", "by (simp add: prod.insert[OF step(1) step(2)] assms(2) step(3))"], ["proof (state)\nthis:\n  f (prod g (insert a A)) = (\\<Prod>a\\<in>insert a A. f (g a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))", "case False"], ["proof (state)\nthis:\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> f (prod g A) = (\\<Prod>a\\<in>A. f (g a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. f (prod g A) = (\\<Prod>a\\<in>A. f (g a))", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  f (prod g A) = (\\<Prod>a\\<in>A. f (g a))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* theory *)"]]}