{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/MPoly_Type_Class_FMap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma compute_lcs_pp[code]:\n  \"lcs (Pm_fmap xs) (Pm_fmap ys) =\n  Pm_fmap (fmmap_keys (\\<lambda>k v. Orderings.max (lookup0 xs k) (lookup0 ys k)) (xs ++\\<^sub>f ys))\"", "lemma compute_deg_pp[code]:\n  \"deg_pm (Pm_fmap xs) = sum (the o fmlookup xs) (fmdom' xs)\"", "lemma compute_adds_pp[code]:\n  \"adds_pp_add_linorder (Pm_fmap xs) (Pm_fmap ys) =\n    (fmpred (\\<lambda>k v. lookup0 xs k \\<le> lookup0 ys k) (xs ++\\<^sub>f ys))\"\n  for xs ys::\"('a, 'b::add_linorder_min) fmap\"", "lemma lex_pm_iff: \"lex_pm s t = (\\<forall>x. lookup s x \\<le> lookup t x \\<or> (\\<exists>y<x. lookup s y \\<noteq> lookup t y))\"", "lemma compute_lex_pp[code]:\n  \"(lex_pm (Pm_fmap xs) (Pm_fmap (ys::(_, _::ordered_comm_monoid_add) fmap))) =\n    (let zs = xs ++\\<^sub>f ys in\n      fmpred (\\<lambda>x v.\n        lookup0 xs x \\<le> lookup0 ys x \\<or>\n        \\<not> fmpred (\\<lambda>y w. y \\<ge> x \\<or> lookup0 xs y = lookup0 ys y) zs) zs\n    )\"", "lemma compute_dord_pp[code]:\n  \"(dord_pm ord (Pm_fmap xs) (Pm_fmap (ys::('a::wellorder , 'b::ordered_comm_monoid_add) fmap))) =\n    (let dx = deg_pm (Pm_fmap xs) in let dy = deg_pm (Pm_fmap ys) in\n      dx < dy \\<or> (dx = dy \\<and> ord (Pm_fmap xs) (Pm_fmap ys))\n    )\"", "lemma\n  \"sparse\\<^sub>0 [(X, 2::nat), (Z, 7)] + sparse\\<^sub>0 [(Y, 3), (Z, 2)] = sparse\\<^sub>0 [(X, 2), (Z, 9), (Y, 3)]\"\n  \"dense\\<^sub>0 [2, 0, 7::nat] + dense\\<^sub>0 [0, 3, 2] = dense\\<^sub>0 [2, 3, 9]\"", "lemma\n  \"sparse\\<^sub>0 [(X, 2::nat), (Z, 7)] - sparse\\<^sub>0 [(X, 2), (Z, 2)] = sparse\\<^sub>0 [(Z, 5)]\"", "lemma\n  \"lcs (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 7)]) (sparse\\<^sub>0 [(Y, 3), (Z, 2)]) = sparse\\<^sub>0 [(X, 2), (Y, 3), (Z, 7)]\"", "lemma\n  \"(sparse\\<^sub>0 [(X, 2::nat), (Z, 1)]) adds (sparse\\<^sub>0 [(X, 3), (Y, 2), (Z, 1)])\"", "lemma\n  \"lookup (sparse\\<^sub>0 [(X, 2::nat), (Z, 3)]) X = 2\"", "lemma\n  \"deg_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 3), (X, 1)]) = 6\"", "lemma\n  \"lex_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 3)]) (sparse\\<^sub>0 [(X, 4)])\"", "lemma\n  \"lex_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 3)]) (sparse\\<^sub>0 [(X, 4)])\"", "lemma\n  \"\\<not> (dlex_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 3)]) (sparse\\<^sub>0 [(X, 4)]))\"", "lemma\n  \"dlex_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 2)]) (sparse\\<^sub>0 [(X, 5)])\"", "lemma\n  \"\\<not> (drlex_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 2)]) (sparse\\<^sub>0 [(X, 5)]))\"", "lemma compute_monomial [code]:\n  \"monomial c t = (if c = 0 then 0 else sparse\\<^sub>0 [(t, c)])\"", "lemma compute_one_poly_mapping [code]: \"1 = sparse\\<^sub>0 [(0, 1)]\"", "lemma compute_except_poly_mapping [code]:\n  \"except (Pm_fmap xs) S = Pm_fmap (fmfilter (\\<lambda>k. k \\<notin> S) xs)\"", "lemma lookup0_fmap_of_list_simps:\n  \"lookup0 (fmap_of_list ((x, y)#xs)) i = (if x = i then y else lookup0 (fmap_of_list xs) i)\"\n  \"lookup0 (fmap_of_list []) i = 0\"", "lemma if_poly_mapping_eq_iff:\n  \"(if x = y then a else b) =\n    (if (\\<forall>i\\<in>keys x \\<union> keys y. lookup x i = lookup y i) then a else b)\"", "lemma keys_add_eq: \"keys (a + b) = keys a \\<union> keys b - {x \\<in> keys a \\<inter> keys b. lookup a x + lookup b x = 0}\"", "lemma compute_shift_map_keys[code]:\n  \"shift_map_keys t f (fmap_of_list xs) = fmap_of_list (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs)\"", "lemmas [simp] = compute_zero_pp[symmetric]", "lemma compute_monom_mult_poly_mapping [code]:\n  \"monom_mult c t (Pm_fmap xs) = Pm_fmap (if c = 0 then fmempty else shift_map_keys t ((*) c) xs)\"", "lemma compute_mult_scalar_poly_mapping [code]:\n  \"Pm_fmap (fmap_of_list xs) \\<odot> q = (case xs of ((t, c) # ys) \\<Rightarrow>\n    (monom_mult c t q + except (Pm_fmap (fmap_of_list ys)) {t} \\<odot> q) | _ \\<Rightarrow>\n    Pm_fmap fmempty)\"", "lemma monomial1_Nil[mpoly_simps]: \"monomial1 0 = 1\"", "lemma monomial_mp: \"monomial c (pp::'a\\<Rightarrow>\\<^sub>0nat) = Const\\<^sub>0 c * monomial1 pp\"\n  for c::\"'b::comm_semiring_1\"", "lemma monomial1_add: \"(monomial1 (a + b)::('a::monoid_add\\<Rightarrow>\\<^sub>0'b::comm_semiring_1)) = monomial1 a * monomial1 b\"", "lemma monomial1_monomial: \"monomial1 (monomial n v) = (Var\\<^sub>0 v::_\\<Rightarrow>\\<^sub>0('b::comm_semiring_1))^n\"", "lemma Ball_True: \"(\\<forall>x\\<in>X. True) \\<longleftrightarrow> True\"", "lemma Collect_False: \"{x. False} = {}\"", "lemma Pm_fmap_sum: \"Pm_fmap f = (\\<Sum>x \\<in> fmdom' f. monomial (lookup0 f x) x)\"", "lemma MPoly_numeral: \"MPoly (numeral x) = numeral x\"", "lemma MPoly_power: \"MPoly (x ^ n) = MPoly x ^ n\"", "lemmas [mpoly_simps] = Pm_fmap_sum\n  add.assoc[symmetric] mult.assoc[symmetric]\n  add_0 add_0_right mult_1 mult_1_right mult_zero_left mult_zero_right power_0 power_one_right\n  fmdom'_fmap_of_list\n  list.map fst_conv\n  sum.insert_remove finite_insert finite.emptyI\n  lookup0_fmap_of_list_simps\n  num.simps rel_simps\n  if_True if_False\n  insert_Diff_if insert_iff empty_Diff empty_iff\n  simp_thms\n  sum.empty\n  if_poly_mapping_eq_iff\n  keys_zero keys_one\n  keys_add_eq\n  keys_single\n  Un_insert_left Un_empty_left\n  Int_insert_left Int_empty_left\n  Collect_False\n  lookup_add lookup_single lookup_zero lookup_one\n  Set.ball_simps\n  when_simps\n  monomial_mp\n  monomial1_add\n  monomial1_monomial\n  Const\\<^sub>0_one Const\\<^sub>0_zero Const\\<^sub>0_numeral Const\\<^sub>0_minus\n  set_simps", "lemma foldl_assoc:\n  assumes \"\\<And>x y z. f (f x y) z = f x (f y z)\"\n  shows \"foldl f (f a b) xs = f a (foldl f b xs)\"", "lemma list_max_Cons: \"list_max (x # xs) = ord_term_lin.max x (list_max xs)\"", "lemma list_max_empty: \"list_max [] = min_term\"", "lemma list_max_in_list:\n  assumes \"xs \\<noteq> []\"\n  shows \"list_max xs \\<in> set xs\"", "lemma list_max_maximum:\n  assumes \"a \\<in> set xs\"\n  shows \"a \\<preceq>\\<^sub>t (list_max xs)\"", "lemma list_max_nonempty:\n  assumes \"xs \\<noteq> []\"\n  shows \"list_max xs = ord_term_lin.Max (set xs)\"", "lemma in_set_clearjunk_iff_map_of_eq_Some:\n  \"(a, b) \\<in> set (AList.clearjunk xs) \\<longleftrightarrow> map_of xs a = Some b\"", "lemma Pm_fmap_of_list_eq_zero_iff:\n  \"Pm_fmap (fmap_of_list xs) = 0 \\<longleftrightarrow> [(k, v)\\<leftarrow>AList.clearjunk xs . v \\<noteq> 0] = []\"", "lemma fmdom'_clearjunk0: \"fmdom' (clearjunk0 xs) = fmdom' xs - {x. fmlookup xs x = Some 0}\"", "lemma compute_lt_poly_mapping[code]:\n  \"lt (Pm_fmap (fmap_of_list xs)) = list_max (map fst [(k, v) \\<leftarrow> AList.clearjunk xs. v \\<noteq> 0])\"", "lemma compute_higher_poly_mapping [code]:\n  \"higher (Pm_fmap xs) t = Pm_fmap (fmfilter (\\<lambda>k. t \\<prec>\\<^sub>t k) xs)\"", "lemma compute_lower_poly_mapping [code]:\n  \"lower (Pm_fmap xs) t = Pm_fmap (fmfilter (\\<lambda>k. k \\<prec>\\<^sub>t t) xs)\"", "lemma compute_shift_map_keys_punit [code]:\n  \"shift_map_keys_punit t f (fmap_of_list xs) = fmap_of_list (map (\\<lambda>(k, v). (t + k, f v)) xs)\"", "lemma compute_monom_mult_punit [code]:\n  \"monom_mult_punit c t (Pm_fmap xs) = Pm_fmap (if c = 0 then fmempty else shift_map_keys_punit t ((*) c) xs)\"", "lemma compute_mult_scalar_punit [code]:\n  \"Pm_fmap (fmap_of_list xs) * q = (case xs of ((t, c) # ys) \\<Rightarrow>\n    (monom_mult_punit c t q + except (Pm_fmap (fmap_of_list ys)) {t} * q) | _ \\<Rightarrow>\n    Pm_fmap fmempty)\"", "lemma\n  \"keys (X\\<^sup>2 * Z ^ 3 + 2 * Y ^ 3 * Z\\<^sup>2) =\n    {monomial 2 0 + monomial 3 2, monomial 3 1 + monomial 2 2}\"", "lemma\n  \"keys (X\\<^sup>2 * Z ^ 3 + 2 * Y ^ 3 * Z\\<^sup>2) =\n    {monomial 2 0 + monomial 3 2, monomial 3 1 + monomial 2 2}\"", "lemma\n  \"- 1 * X\\<^sup>2 * Z ^ 7 + - 2 * Y ^ 3 * Z\\<^sup>2 = - X\\<^sup>2 * Z ^ 7 + - 2 * Y ^ 3 * Z\\<^sup>2\"", "lemma\n  \"X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2 + X\\<^sup>2 * Z ^ 4 + - 2 * Y ^ 3 * Z\\<^sup>2 = X\\<^sup>2 * Z ^ 7 + X\\<^sup>2 * Z ^ 4\"", "lemma\n  \"X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2 - X\\<^sup>2 * Z ^ 4 + - 2 * Y ^ 3 * Z\\<^sup>2 =\n    X\\<^sup>2 * Z ^ 7 - X\\<^sup>2 * Z ^ 4\"", "lemma\n  \"lookup (X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2 + 2) (sparse\\<^sub>0 [(0, 2), (2, 7)]) = 1\"", "lemma\n  \"X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2 \\<noteq>\n   X\\<^sup>2 * Z ^ 4 + - 2 * Y ^ 3 * Z\\<^sup>2\"", "lemma\n  \"0 * X^2 * Z^7 + 0 * Y^3*Z\\<^sup>2 = 0\"", "lemma\n  \"monom_mult_punit 3 (sparse\\<^sub>0 [(1, 2::nat)]) (X\\<^sup>2 * Z + 2 * Y ^ 3 * Z\\<^sup>2) =\n    3 * Y\\<^sup>2 * Z * X\\<^sup>2 + 6 * Y ^ 5 * Z\\<^sup>2\"", "lemma\n  \"monomial (-4) (sparse\\<^sub>0 [(0, 2::nat)]) = - 4 * X\\<^sup>2\"", "lemma \"monomial (0::rat) (sparse\\<^sub>0 [(0::nat, 2::nat)]) = 0\"", "lemma\n  \"(X\\<^sup>2 * Z + 2 * Y ^ 3 * Z\\<^sup>2) * (X\\<^sup>2 * Z ^ 3 + - 2 * Y ^ 3 * Z\\<^sup>2) =\n    X ^ 4 * Z ^ 4 + - 2 * X\\<^sup>2 * Z ^ 3 * Y ^ 3 +\n - 4 * Y ^ 6 * Z ^ 4 + 2 * Y ^ 3 * Z ^ 5 * X\\<^sup>2\"", "lemma compute_adds_term_pprod [code_unfold]:\n  \"adds_term_pprod u v = (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))\"", "lemma compute_splus_pprod [code]: \"splus_pprod t (s, i) = (t + s, i)\"", "lemma compute_shift_map_keys_pprod [code]:\n  \"shift_map_keys_pprod t f (fmap_of_list xs) = fmap_of_list (map (\\<lambda>(k, v). (splus_pprod t k, f v)) xs)\"", "lemma compute_monom_mult_pprod [code]:\n  \"monom_mult_pprod c t (Pm_fmap xs) = Pm_fmap (if c = 0 then fmempty else shift_map_keys_pprod t ((*) c) xs)\"", "lemma compute_mult_scalar_pprod [code]:\n  \"mult_scalar_pprod (Pm_fmap (fmap_of_list xs)) q = (case xs of ((t, c) # ys) \\<Rightarrow>\n    (monom_mult_pprod c t q + mult_scalar_pprod (except (Pm_fmap (fmap_of_list ys)) {t}) q) | _ \\<Rightarrow>\n    Pm_fmap fmempty)\"", "lemma\n  \"keys (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 3) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0), (sparse\\<^sub>0 [(1, 3), (2, 2)], 1)}\"", "lemma\n  \"keys (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 3) + Vec\\<^sub>0 2 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0), (sparse\\<^sub>0 [(1, 3), (2, 2)], 2)}\"", "lemma\n  \"Vec\\<^sub>0 1 (X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2) + Vec\\<^sub>0 3 (X\\<^sup>2 * Z ^ 4) + Vec\\<^sub>0 1 (- 2 * Y ^ 3 * Z\\<^sup>2) =\n    Vec\\<^sub>0 1 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 3 (X\\<^sup>2 * Z ^ 4)\"", "lemma\n  \"lookup (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2 + 2)) (sparse\\<^sub>0 [(0, 2), (2, 7)], 0) = 1\"", "lemma\n  \"lookup (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2 + 2)) (sparse\\<^sub>0 [(0, 2), (2, 7)], 1) = 0\"", "lemma\n  \"Vec\\<^sub>0 0 (0 * X^2 * Z^7) + Vec\\<^sub>0 1 (0 * Y^3*Z\\<^sup>2) = 0\"", "lemma\n  \"monom_mult_pprod 3 (sparse\\<^sub>0 [(1, 2::nat)]) (Vec\\<^sub>0 0 (X\\<^sup>2 * Z) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    Vec\\<^sub>0 0 (3 * Y\\<^sup>2 * Z * X\\<^sup>2) + Vec\\<^sub>0 1 (6 * Y ^ 5 * Z\\<^sup>2)\"", "lemmas [code_post] =\n  plus_mpoly.abs_eq[symmetric]\n  times_mpoly.abs_eq[symmetric]\n  MPoly_numeral\n  MPoly_power\n  one_mpoly_def[symmetric]\n  Var.abs_eq[symmetric]\n  Const.abs_eq[symmetric]", "lemmas [mpoly_simps] = plus_mpoly.abs_eq", "lemma \"content_primitive (4 * X * Y^2 * Z^3 + 6 * X\\<^sup>2 * Y^4 + 8 * X\\<^sup>2 * Y^5) =\n    (2::int, 2 * X * Y\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y ^ 4 + 4 * X\\<^sup>2 * Y ^ 5)\""], "translations": [["", "lemma compute_lcs_pp[code]:\n  \"lcs (Pm_fmap xs) (Pm_fmap ys) =\n  Pm_fmap (fmmap_keys (\\<lambda>k v. Orderings.max (lookup0 xs k) (lookup0 ys k)) (xs ++\\<^sub>f ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs (Pm_fmap xs) (Pm_fmap ys) =\n    Pm_fmap\n     (fmmap_keys (\\<lambda>k v. max (lookup0 xs k) (lookup0 ys k))\n       (xs ++\\<^sub>f ys))", "by (rule poly_mapping_eqI)\n    (auto simp add: fmlookup_default_fmmap_keys fmlookup_dom_iff fmdom'_notI\n      lcs_poly_mapping.rep_eq fmdom'_notD)"], ["", "lemma compute_deg_pp[code]:\n  \"deg_pm (Pm_fmap xs) = sum (the o fmlookup xs) (fmdom' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (Pm_fmap xs) = sum (the \\<circ> fmlookup xs) (fmdom' xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm (Pm_fmap xs) = sum (the \\<circ> fmlookup xs) (fmdom' xs)", "have \"deg_pm (Pm_fmap xs) = sum (lookup (Pm_fmap xs)) (keys (Pm_fmap xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (Pm_fmap xs) = sum (lookup (Pm_fmap xs)) (keys (Pm_fmap xs))", "by (rule deg_pm_superset) auto"], ["proof (state)\nthis:\n  deg_pm (Pm_fmap xs) = sum (lookup (Pm_fmap xs)) (keys (Pm_fmap xs))\n\ngoal (1 subgoal):\n 1. deg_pm (Pm_fmap xs) = sum (the \\<circ> fmlookup xs) (fmdom' xs)", "also"], ["proof (state)\nthis:\n  deg_pm (Pm_fmap xs) = sum (lookup (Pm_fmap xs)) (keys (Pm_fmap xs))\n\ngoal (1 subgoal):\n 1. deg_pm (Pm_fmap xs) = sum (the \\<circ> fmlookup xs) (fmdom' xs)", "have \"\\<dots> = sum (the o fmlookup xs) (fmdom' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup (Pm_fmap xs)) (keys (Pm_fmap xs)) =\n    sum (the \\<circ> fmlookup xs) (fmdom' xs)", "by (rule sum.mono_neutral_cong_left)\n       (auto simp: fmlookup_dom'_iff fmdom'I in_keys_iff fmlookup_default_def\n             split: option.splits)"], ["proof (state)\nthis:\n  sum (lookup (Pm_fmap xs)) (keys (Pm_fmap xs)) =\n  sum (the \\<circ> fmlookup xs) (fmdom' xs)\n\ngoal (1 subgoal):\n 1. deg_pm (Pm_fmap xs) = sum (the \\<circ> fmlookup xs) (fmdom' xs)", "finally"], ["proof (chain)\npicking this:\n  deg_pm (Pm_fmap xs) = sum (the \\<circ> fmlookup xs) (fmdom' xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pm (Pm_fmap xs) = sum (the \\<circ> fmlookup xs) (fmdom' xs)\n\ngoal (1 subgoal):\n 1. deg_pm (Pm_fmap xs) = sum (the \\<circ> fmlookup xs) (fmdom' xs)", "."], ["proof (state)\nthis:\n  deg_pm (Pm_fmap xs) = sum (the \\<circ> fmlookup xs) (fmdom' xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition adds_pp_add_linorder :: \"('b \\<Rightarrow>\\<^sub>0 'a::add_linorder) \\<Rightarrow> _ \\<Rightarrow> bool\"\n  where [code_abbrev]: \"adds_pp_add_linorder = (adds)\""], ["", "lemma compute_adds_pp[code]:\n  \"adds_pp_add_linorder (Pm_fmap xs) (Pm_fmap ys) =\n    (fmpred (\\<lambda>k v. lookup0 xs k \\<le> lookup0 ys k) (xs ++\\<^sub>f ys))\"\n  for xs ys::\"('a, 'b::add_linorder_min) fmap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adds_pp_add_linorder (Pm_fmap xs) (Pm_fmap ys) =\n    fmpred (\\<lambda>k v. lookup0 xs k \\<le> lookup0 ys k)\n     (xs ++\\<^sub>f ys)", "unfolding adds_pp_add_linorder_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pm_fmap xs adds Pm_fmap ys) =\n    fmpred (\\<lambda>k v. lookup0 xs k \\<le> lookup0 ys k)\n     (xs ++\\<^sub>f ys)", "unfolding adds_poly_mapping"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup (Pm_fmap xs) \\<le> lookup (Pm_fmap ys)) =\n    fmpred (\\<lambda>k v. lookup0 xs k \\<le> lookup0 ys k)\n     (xs ++\\<^sub>f ys)", "using fmdom_notI"], ["proof (prove)\nusing this:\n  fmlookup ?m ?x = None \\<Longrightarrow> ?x |\\<notin>| fmdom ?m\n\ngoal (1 subgoal):\n 1. (lookup (Pm_fmap xs) \\<le> lookup (Pm_fmap ys)) =\n    fmpred (\\<lambda>k v. lookup0 xs k \\<le> lookup0 ys k)\n     (xs ++\\<^sub>f ys)", "by (force simp: fmlookup_dom_iff le_fun_def\n      split: option.splits if_splits)"], ["", "text\\<open>Computing @{term lex} as below is certainly not the most efficient way, but it works.\\<close>"], ["", "lemma lex_pm_iff: \"lex_pm s t = (\\<forall>x. lookup s x \\<le> lookup t x \\<or> (\\<exists>y<x. lookup s y \\<noteq> lookup t y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm s t =\n    (\\<forall>x.\n        lookup s x \\<le> lookup t x \\<or>\n        (\\<exists>y<x. lookup s y \\<noteq> lookup t y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lex_pm s t =\n    (\\<forall>x.\n        lookup s x \\<le> lookup t x \\<or>\n        (\\<exists>y<x. lookup s y \\<noteq> lookup t y))", "have \"lex_pm s t = (\\<not> lex_pm_strict t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm s t = (\\<not> lex_pm_strict t s)", "by (simp add: lex_pm_strict_alt)"], ["proof (state)\nthis:\n  lex_pm s t = (\\<not> lex_pm_strict t s)\n\ngoal (1 subgoal):\n 1. lex_pm s t =\n    (\\<forall>x.\n        lookup s x \\<le> lookup t x \\<or>\n        (\\<exists>y<x. lookup s y \\<noteq> lookup t y))", "also"], ["proof (state)\nthis:\n  lex_pm s t = (\\<not> lex_pm_strict t s)\n\ngoal (1 subgoal):\n 1. lex_pm s t =\n    (\\<forall>x.\n        lookup s x \\<le> lookup t x \\<or>\n        (\\<exists>y<x. lookup s y \\<noteq> lookup t y))", "have \"\\<dots> = (\\<forall>x. lookup s x \\<le> lookup t x \\<or> (\\<exists>y<x. lookup s y \\<noteq> lookup t y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> lex_pm_strict t s) =\n    (\\<forall>x.\n        lookup s x \\<le> lookup t x \\<or>\n        (\\<exists>y<x. lookup s y \\<noteq> lookup t y))", "by (simp add: lex_pm_strict_def less_poly_mapping_def less_fun_def) (metis leD leI)"], ["proof (state)\nthis:\n  (\\<not> lex_pm_strict t s) =\n  (\\<forall>x.\n      lookup s x \\<le> lookup t x \\<or>\n      (\\<exists>y<x. lookup s y \\<noteq> lookup t y))\n\ngoal (1 subgoal):\n 1. lex_pm s t =\n    (\\<forall>x.\n        lookup s x \\<le> lookup t x \\<or>\n        (\\<exists>y<x. lookup s y \\<noteq> lookup t y))", "finally"], ["proof (chain)\npicking this:\n  lex_pm s t =\n  (\\<forall>x.\n      lookup s x \\<le> lookup t x \\<or>\n      (\\<exists>y<x. lookup s y \\<noteq> lookup t y))", "show ?thesis"], ["proof (prove)\nusing this:\n  lex_pm s t =\n  (\\<forall>x.\n      lookup s x \\<le> lookup t x \\<or>\n      (\\<exists>y<x. lookup s y \\<noteq> lookup t y))\n\ngoal (1 subgoal):\n 1. lex_pm s t =\n    (\\<forall>x.\n        lookup s x \\<le> lookup t x \\<or>\n        (\\<exists>y<x. lookup s y \\<noteq> lookup t y))", "."], ["proof (state)\nthis:\n  lex_pm s t =\n  (\\<forall>x.\n      lookup s x \\<le> lookup t x \\<or>\n      (\\<exists>y<x. lookup s y \\<noteq> lookup t y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compute_lex_pp[code]:\n  \"(lex_pm (Pm_fmap xs) (Pm_fmap (ys::(_, _::ordered_comm_monoid_add) fmap))) =\n    (let zs = xs ++\\<^sub>f ys in\n      fmpred (\\<lambda>x v.\n        lookup0 xs x \\<le> lookup0 ys x \\<or>\n        \\<not> fmpred (\\<lambda>y w. y \\<ge> x \\<or> lookup0 xs y = lookup0 ys y) zs) zs\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm (Pm_fmap xs) (Pm_fmap ys) =\n    (let zs = xs ++\\<^sub>f ys\n     in fmpred\n         (\\<lambda>x v.\n             lookup0 xs x \\<le> lookup0 ys x \\<or>\n             \\<not> fmpred\n                     (\\<lambda>y w.\n                         x \\<le> y \\<or> lookup0 xs y = lookup0 ys y)\n                     zs)\n         zs)", "unfolding Let_def lex_pm_iff fmpred_iff Pm_fmap.rep_eq fmlookup_add fmlookup_dom_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        lookup0 xs x \\<le> lookup0 ys x \\<or>\n        (\\<exists>y<x. lookup0 xs y \\<noteq> lookup0 ys y)) =\n    (\\<forall>x y.\n        (if \\<exists>a. fmlookup ys x = Some a then fmlookup ys x\n         else fmlookup xs x) =\n        Some y \\<longrightarrow>\n        lookup0 xs x \\<le> lookup0 ys x \\<or>\n        \\<not> (\\<forall>xa y.\n                   (if \\<exists>a. fmlookup ys xa = Some a\n                    then fmlookup ys xa else fmlookup xs xa) =\n                   Some y \\<longrightarrow>\n                   x \\<le> xa \\<or> lookup0 xs xa = lookup0 ys xa))", "apply (intro iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       lookup0 xs x \\<le> lookup0 ys x \\<or>\n       (\\<exists>y<x. lookup0 xs y \\<noteq> lookup0 ys y) \\<Longrightarrow>\n    \\<forall>x y.\n       (if \\<exists>a. fmlookup ys x = Some a then fmlookup ys x\n        else fmlookup xs x) =\n       Some y \\<longrightarrow>\n       lookup0 xs x \\<le> lookup0 ys x \\<or>\n       \\<not> (\\<forall>xa y.\n                  (if \\<exists>a. fmlookup ys xa = Some a\n                   then fmlookup ys xa else fmlookup xs xa) =\n                  Some y \\<longrightarrow>\n                  x \\<le> xa \\<or> lookup0 xs xa = lookup0 ys xa)\n 2. \\<forall>x y.\n       (if \\<exists>a. fmlookup ys x = Some a then fmlookup ys x\n        else fmlookup xs x) =\n       Some y \\<longrightarrow>\n       lookup0 xs x \\<le> lookup0 ys x \\<or>\n       \\<not> (\\<forall>xa y.\n                  (if \\<exists>a. fmlookup ys xa = Some a\n                   then fmlookup ys xa else fmlookup xs xa) =\n                  Some y \\<longrightarrow>\n                  x \\<le> xa \\<or>\n                  lookup0 xs xa = lookup0 ys xa) \\<Longrightarrow>\n    \\<forall>x.\n       lookup0 xs x \\<le> lookup0 ys x \\<or>\n       (\\<exists>y<x. lookup0 xs y \\<noteq> lookup0 ys y)", "apply (metis fmdom'_notD fmlookup_default_if(2) fmlookup_dom'_iff leD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (if \\<exists>a. fmlookup ys x = Some a then fmlookup ys x\n        else fmlookup xs x) =\n       Some y \\<longrightarrow>\n       lookup0 xs x \\<le> lookup0 ys x \\<or>\n       \\<not> (\\<forall>xa y.\n                  (if \\<exists>a. fmlookup ys xa = Some a\n                   then fmlookup ys xa else fmlookup xs xa) =\n                  Some y \\<longrightarrow>\n                  x \\<le> xa \\<or>\n                  lookup0 xs xa = lookup0 ys xa) \\<Longrightarrow>\n    \\<forall>x.\n       lookup0 xs x \\<le> lookup0 ys x \\<or>\n       (\\<exists>y<x. lookup0 xs y \\<noteq> lookup0 ys y)", "apply (metis eq_iff not_le fmdom'_notD fmlookup_default_if(2) fmlookup_dom'_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compute_dord_pp[code]:\n  \"(dord_pm ord (Pm_fmap xs) (Pm_fmap (ys::('a::wellorder , 'b::ordered_comm_monoid_add) fmap))) =\n    (let dx = deg_pm (Pm_fmap xs) in let dy = deg_pm (Pm_fmap ys) in\n      dx < dy \\<or> (dx = dy \\<and> ord (Pm_fmap xs) (Pm_fmap ys))\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dord_pm ord (Pm_fmap xs) (Pm_fmap ys) =\n    (let dx = deg_pm (Pm_fmap xs); dy = deg_pm (Pm_fmap ys)\n     in dx < dy \\<or> dx = dy \\<and> ord (Pm_fmap xs) (Pm_fmap ys))", "by (auto simp: Let_def deg_pm.rep_eq dord_fun_def dord_pm.rep_eq)\n    (simp_all add: Pm_fmap.abs_eq)"], ["", "subsubsection \\<open>Computations\\<close>"], ["", "experiment begin"], ["", "abbreviation \"X \\<equiv> 0::nat\""], ["", "abbreviation \"Y \\<equiv> 1::nat\""], ["", "abbreviation \"Z \\<equiv> 2::nat\""], ["", "lemma\n  \"sparse\\<^sub>0 [(X, 2::nat), (Z, 7)] + sparse\\<^sub>0 [(Y, 3), (Z, 2)] = sparse\\<^sub>0 [(X, 2), (Z, 9), (Y, 3)]\"\n  \"dense\\<^sub>0 [2, 0, 7::nat] + dense\\<^sub>0 [0, 3, 2] = dense\\<^sub>0 [2, 3, 9]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sparse\\<^sub>0 [(0, 2), (2, 7)] + sparse\\<^sub>0 [(1, 3), (2, 2)] =\n    sparse\\<^sub>0 [(0, 2), (2, 9), (1, 3)] &&&\n    dense\\<^sub>0 [2, 0, 7] + dense\\<^sub>0 [0, 3, 2] =\n    dense\\<^sub>0 [2, 3, 9]", "by eval+"], ["", "lemma\n  \"sparse\\<^sub>0 [(X, 2::nat), (Z, 7)] - sparse\\<^sub>0 [(X, 2), (Z, 2)] = sparse\\<^sub>0 [(Z, 5)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sparse\\<^sub>0 [(0, 2), (2, 7)] - sparse\\<^sub>0 [(0, 2), (2, 2)] =\n    sparse\\<^sub>0 [(2, 5)]", "by eval"], ["", "lemma\n  \"lcs (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 7)]) (sparse\\<^sub>0 [(Y, 3), (Z, 2)]) = sparse\\<^sub>0 [(X, 2), (Y, 3), (Z, 7)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs (sparse\\<^sub>0 [(0, 2), (1, 1), (2, 7)])\n     (sparse\\<^sub>0 [(1, 3), (2, 2)]) =\n    sparse\\<^sub>0 [(0, 2), (1, 3), (2, 7)]", "by eval"], ["", "lemma\n  \"(sparse\\<^sub>0 [(X, 2::nat), (Z, 1)]) adds (sparse\\<^sub>0 [(X, 3), (Y, 2), (Z, 1)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sparse\\<^sub>0 [(0, 2), (2, 1)] adds\n    sparse\\<^sub>0 [(0, 3), (1, 2), (2, 1)]", "by eval"], ["", "lemma\n  \"lookup (sparse\\<^sub>0 [(X, 2::nat), (Z, 3)]) X = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (sparse\\<^sub>0 [(0, 2), (2, 3)]) 0 = 2", "by eval"], ["", "lemma\n  \"deg_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 3), (X, 1)]) = 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (sparse\\<^sub>0 [(0, 2), (1, 1), (2, 3), (0, 1)]) = 6", "by eval"], ["", "lemma\n  \"lex_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 3)]) (sparse\\<^sub>0 [(X, 4)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm (sparse\\<^sub>0 [(0, 2), (1, 1), (2, 3)])\n     (sparse\\<^sub>0 [(0, 4)])", "by eval"], ["", "lemma\n  \"lex_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 3)]) (sparse\\<^sub>0 [(X, 4)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm (sparse\\<^sub>0 [(0, 2), (1, 1), (2, 3)])\n     (sparse\\<^sub>0 [(0, 4)])", "by eval"], ["", "lemma\n  \"\\<not> (dlex_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 3)]) (sparse\\<^sub>0 [(X, 4)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> dlex_pm (sparse\\<^sub>0 [(0, 2), (1, 1), (2, 3)])\n            (sparse\\<^sub>0 [(0, 4)])", "by eval"], ["", "lemma\n  \"dlex_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 2)]) (sparse\\<^sub>0 [(X, 5)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pm (sparse\\<^sub>0 [(0, 2), (1, 1), (2, 2)])\n     (sparse\\<^sub>0 [(0, 5)])", "by eval"], ["", "lemma\n  \"\\<not> (drlex_pm (sparse\\<^sub>0 [(X, 2::nat), (Y, 1), (Z, 2)]) (sparse\\<^sub>0 [(X, 5)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> drlex_pm (sparse\\<^sub>0 [(0, 2), (1, 1), (2, 2)])\n            (sparse\\<^sub>0 [(0, 5)])", "by eval"], ["", "end"], ["", "subsection \\<open>Implementation of Multivariate Polynomials as Association Lists\\<close>"], ["", "subsubsection \\<open>Unordered Power-Products\\<close>"], ["", "lemma compute_monomial [code]:\n  \"monomial c t = (if c = 0 then 0 else sparse\\<^sub>0 [(t, c)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c t = (if c = (0::'b) then 0 else sparse\\<^sub>0 [(t, c)])", "by (auto intro!: poly_mapping_eqI simp: sparse\\<^sub>0_def fmlookup_default_def lookup_single)"], ["", "lemma compute_one_poly_mapping [code]: \"1 = sparse\\<^sub>0 [(0, 1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = sparse\\<^sub>0 [(0::'a, 1::'b)]", "by (metis compute_monomial single_one zero_neq_one)"], ["", "lemma compute_except_poly_mapping [code]:\n  \"except (Pm_fmap xs) S = Pm_fmap (fmfilter (\\<lambda>k. k \\<notin> S) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except (Pm_fmap xs) S = Pm_fmap (fmfilter (\\<lambda>k. k \\<notin> S) xs)", "by (auto simp: fmlookup_default_def lookup_except split: option.splits intro!: poly_mapping_eqI)"], ["", "lemma lookup0_fmap_of_list_simps:\n  \"lookup0 (fmap_of_list ((x, y)#xs)) i = (if x = i then y else lookup0 (fmap_of_list xs) i)\"\n  \"lookup0 (fmap_of_list []) i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup0 (fmap_of_list ((x, y) # xs)) i =\n    (if x = i then y else lookup0 (fmap_of_list xs) i) &&&\n    lookup0 (fmap_of_list []) i = (0::'c)", "by (auto simp: fmlookup_default_def fmlookup_of_list split: if_splits option.splits)"], ["", "lemma if_poly_mapping_eq_iff:\n  \"(if x = y then a else b) =\n    (if (\\<forall>i\\<in>keys x \\<union> keys y. lookup x i = lookup y i) then a else b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = y then a else b) =\n    (if \\<forall>i\\<in>keys x \\<union> keys y. lookup x i = lookup y i\n     then a else b)", "by simp (metis UnI1 UnI2 in_keys_iff poly_mapping_eqI)"], ["", "lemma keys_add_eq: \"keys (a + b) = keys a \\<union> keys b - {x \\<in> keys a \\<inter> keys b. lookup a x + lookup b x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (a + b) =\n    keys a \\<union> keys b -\n    {x \\<in> keys a \\<inter> keys b. lookup a x + lookup b x = (0::'b)}", "by (auto simp: in_keys_iff lookup_add add_eq_0_iff)"], ["", "context term_powerprod\nbegin"], ["", "context includes fmap.lifting begin"], ["", "lift_definition shift_keys::\"'a \\<Rightarrow> ('t, 'b) fmap \\<Rightarrow> ('t, 'b) fmap\"\n  is \"\\<lambda>t m x. if t adds\\<^sub>p x then m (x \\<ominus> t) else None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if a adds\\<^sub>p x then fun (x \\<ominus> a) else None))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if a adds\\<^sub>p x then fun (x \\<ominus> a) else None))", "fix t and f::\"'t \\<Rightarrow> 'b option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if a adds\\<^sub>p x then fun (x \\<ominus> a) else None))", "assume \"finite (dom f)\""], ["proof (state)\nthis:\n  finite (dom f)\n\ngoal (1 subgoal):\n 1. \\<And>a fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if a adds\\<^sub>p x then fun (x \\<ominus> a) else None))", "have \"dom (\\<lambda>x. if t adds\\<^sub>p x then f (x \\<ominus> t) else None) \\<subseteq> (\\<oplus>) t ` dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x. if t adds\\<^sub>p x then f (x \\<ominus> t) else None)\n    \\<subseteq> (\\<oplus>) t ` dom f", "by (auto simp: adds_pp_alt domI term_simps split: if_splits)"], ["proof (state)\nthis:\n  dom (\\<lambda>x. if t adds\\<^sub>p x then f (x \\<ominus> t) else None)\n  \\<subseteq> (\\<oplus>) t ` dom f\n\ngoal (1 subgoal):\n 1. \\<And>a fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if a adds\\<^sub>p x then fun (x \\<ominus> a) else None))", "also"], ["proof (state)\nthis:\n  dom (\\<lambda>x. if t adds\\<^sub>p x then f (x \\<ominus> t) else None)\n  \\<subseteq> (\\<oplus>) t ` dom f\n\ngoal (1 subgoal):\n 1. \\<And>a fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if a adds\\<^sub>p x then fun (x \\<ominus> a) else None))", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<oplus>) t ` dom f)", "using \\<open>finite (dom f)\\<close>"], ["proof (prove)\nusing this:\n  finite (dom f)\n\ngoal (1 subgoal):\n 1. finite ((\\<oplus>) t ` dom f)", "by simp"], ["proof (state)\nthis:\n  finite ((\\<oplus>) t ` dom f)\n\ngoal (1 subgoal):\n 1. \\<And>a fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if a adds\\<^sub>p x then fun (x \\<ominus> a) else None))", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite\n   (dom (\\<lambda>x. if t adds\\<^sub>p x then f (x \\<ominus> t) else None))", "show \"finite (dom (\\<lambda>x. if t adds\\<^sub>p x then f (x \\<ominus> t) else None))\""], ["proof (prove)\nusing this:\n  finite\n   (dom (\\<lambda>x. if t adds\\<^sub>p x then f (x \\<ominus> t) else None))\n\ngoal (1 subgoal):\n 1. finite\n     (dom (\\<lambda>x.\n              if t adds\\<^sub>p x then f (x \\<ominus> t) else None))", "."], ["proof (state)\nthis:\n  finite\n   (dom (\\<lambda>x. if t adds\\<^sub>p x then f (x \\<ominus> t) else None))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"shift_map_keys t f m = fmmap f (shift_keys t m)\""], ["", "lemma compute_shift_map_keys[code]:\n  \"shift_map_keys t f (fmap_of_list xs) = fmap_of_list (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift_map_keys t f (fmap_of_list xs) =\n    fmap_of_list (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs)", "unfolding shift_map_keys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmmap f (shift_keys t (fmap_of_list xs)) =\n    fmap_of_list (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f t xs.\n       map_option f \\<circ>\n       (\\<lambda>x.\n           if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None) =\n       map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs)", "subgoal for f t xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option f \\<circ>\n    (\\<lambda>x.\n        if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None) =\n    map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_option f \\<circ>\n    (\\<lambda>x.\n        if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None) =\n    map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option f \\<circ>\n    (\\<lambda>x.\n        if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None) =\n    map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (map_option f \\<circ>\n        (\\<lambda>x.\n            if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None))\n        x =\n       map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs) x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_option f \\<circ>\n     (\\<lambda>x.\n         if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None))\n     x =\n    map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs) x", "apply (cases \"t adds\\<^sub>p x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t adds\\<^sub>p x \\<Longrightarrow>\n    (map_option f \\<circ>\n     (\\<lambda>x.\n         if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None))\n     x =\n    map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs) x\n 2. \\<not> t adds\\<^sub>p x \\<Longrightarrow>\n    (map_option f \\<circ>\n     (\\<lambda>x.\n         if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None))\n     x =\n    map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs) x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. t adds\\<^sub>p x \\<Longrightarrow>\n    (map_option f \\<circ>\n     (\\<lambda>x.\n         if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None))\n     x =\n    map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs) x", "by (induction xs) (auto simp: adds_pp_alt term_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t adds\\<^sub>p x \\<Longrightarrow>\n    (map_option f \\<circ>\n     (\\<lambda>x.\n         if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None))\n     x =\n    map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs) x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t adds\\<^sub>p x \\<Longrightarrow>\n    (map_option f \\<circ>\n     (\\<lambda>x.\n         if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None))\n     x =\n    map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs) x", "by (induction xs) (auto simp: adds_pp_alt term_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_option f \\<circ>\n  (\\<lambda>x.\n      if t adds\\<^sub>p x then map_of xs (x \\<ominus> t) else None) =\n  map_of (map (\\<lambda>(k, v). (t \\<oplus> k, f v)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemmas [simp] = compute_zero_pp[symmetric]"], ["", "lemma compute_monom_mult_poly_mapping [code]:\n  \"monom_mult c t (Pm_fmap xs) = Pm_fmap (if c = 0 then fmempty else shift_map_keys t ((*) c) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)", "proof (cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = (0::'b) \\<Longrightarrow>\n    monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)\n 2. c \\<noteq> (0::'b) \\<Longrightarrow>\n    monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)", "case True"], ["proof (state)\nthis:\n  c = (0::'b)\n\ngoal (2 subgoals):\n 1. c = (0::'b) \\<Longrightarrow>\n    monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)\n 2. c \\<noteq> (0::'b) \\<Longrightarrow>\n    monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)", "hence \"monom_mult c t (Pm_fmap xs) = 0\""], ["proof (prove)\nusing this:\n  c = (0::'b)\n\ngoal (1 subgoal):\n 1. monom_mult c t (Pm_fmap xs) = 0", "using monom_mult_zero_left"], ["proof (prove)\nusing this:\n  c = (0::'b)\n  monom_mult (0::?'b) ?t ?p = 0\n\ngoal (1 subgoal):\n 1. monom_mult c t (Pm_fmap xs) = 0", "by simp"], ["proof (state)\nthis:\n  monom_mult c t (Pm_fmap xs) = 0\n\ngoal (2 subgoals):\n 1. c = (0::'b) \\<Longrightarrow>\n    monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)\n 2. c \\<noteq> (0::'b) \\<Longrightarrow>\n    monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  monom_mult c t (Pm_fmap xs) = 0\n\ngoal (1 subgoal):\n 1. monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)", "using True"], ["proof (prove)\nusing this:\n  monom_mult c t (Pm_fmap xs) = 0\n  c = (0::'b)\n\ngoal (1 subgoal):\n 1. monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)", "by simp"], ["proof (state)\nthis:\n  monom_mult c t (Pm_fmap xs) =\n  Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<Longrightarrow>\n    monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<Longrightarrow>\n    monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)", "case False"], ["proof (state)\nthis:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<Longrightarrow>\n    monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. monom_mult c t (Pm_fmap xs) =\n    Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)", "by (auto simp: simp: fmlookup_default_def shift_map_keys_def lookup_monom_mult\n        adds_def group_eq_aux shift_keys.rep_eq\n        intro!: poly_mapping_eqI split: option.splits)"], ["proof (state)\nthis:\n  monom_mult c t (Pm_fmap xs) =\n  Pm_fmap (if c = (0::'b) then fmempty else shift_map_keys t ((*) c) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compute_mult_scalar_poly_mapping [code]:\n  \"Pm_fmap (fmap_of_list xs) \\<odot> q = (case xs of ((t, c) # ys) \\<Rightarrow>\n    (monom_mult c t q + except (Pm_fmap (fmap_of_list ys)) {t} \\<odot> q) | _ \\<Rightarrow>\n    Pm_fmap fmempty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pm_fmap (fmap_of_list xs) \\<odot> q =\n    (case xs of [] \\<Rightarrow> Pm_fmap fmempty\n     | (t, c) # ys \\<Rightarrow>\n         monom_mult c t q +\n         except (Pm_fmap (fmap_of_list ys)) {t} \\<odot> q)", "proof (split list.splits, simp, intro conjI impI allI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x22.\n       xs = (a, b) # x22 \\<Longrightarrow>\n       Pm_fmap (fmupd a b (fmap_of_list x22)) \\<odot> q =\n       monom_mult b a q + except (Pm_fmap (fmap_of_list x22)) {a} \\<odot> q", "case (1 t c ys)"], ["proof (state)\nthis:\n  xs = (t, c) # ys\n\ngoal (1 subgoal):\n 1. \\<And>a b x22.\n       xs = (a, b) # x22 \\<Longrightarrow>\n       Pm_fmap (fmupd a b (fmap_of_list x22)) \\<odot> q =\n       monom_mult b a q + except (Pm_fmap (fmap_of_list x22)) {a} \\<odot> q", "have \"Pm_fmap (fmupd t c (fmap_of_list ys)) = sparse\\<^sub>0 [(t, c)] + except (sparse\\<^sub>0 ys) {t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pm_fmap (fmupd t c (fmap_of_list ys)) =\n    sparse\\<^sub>0 [(t, c)] + except (sparse\\<^sub>0 ys) {t}", "by (auto simp: sparse\\<^sub>0_def fmlookup_default_def lookup_add lookup_except\n        split: option.splits intro!: poly_mapping_eqI)"], ["proof (state)\nthis:\n  Pm_fmap (fmupd t c (fmap_of_list ys)) =\n  sparse\\<^sub>0 [(t, c)] + except (sparse\\<^sub>0 ys) {t}\n\ngoal (1 subgoal):\n 1. \\<And>a b x22.\n       xs = (a, b) # x22 \\<Longrightarrow>\n       Pm_fmap (fmupd a b (fmap_of_list x22)) \\<odot> q =\n       monom_mult b a q + except (Pm_fmap (fmap_of_list x22)) {a} \\<odot> q", "also"], ["proof (state)\nthis:\n  Pm_fmap (fmupd t c (fmap_of_list ys)) =\n  sparse\\<^sub>0 [(t, c)] + except (sparse\\<^sub>0 ys) {t}\n\ngoal (1 subgoal):\n 1. \\<And>a b x22.\n       xs = (a, b) # x22 \\<Longrightarrow>\n       Pm_fmap (fmupd a b (fmap_of_list x22)) \\<odot> q =\n       monom_mult b a q + except (Pm_fmap (fmap_of_list x22)) {a} \\<odot> q", "have \"sparse\\<^sub>0 [(t, c)] = monomial c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sparse\\<^sub>0 [(t, c)] = monomial c t", "by (auto simp: sparse\\<^sub>0_def lookup_single fmlookup_default_def intro!: poly_mapping_eqI)"], ["proof (state)\nthis:\n  sparse\\<^sub>0 [(t, c)] = monomial c t\n\ngoal (1 subgoal):\n 1. \\<And>a b x22.\n       xs = (a, b) # x22 \\<Longrightarrow>\n       Pm_fmap (fmupd a b (fmap_of_list x22)) \\<odot> q =\n       monom_mult b a q + except (Pm_fmap (fmap_of_list x22)) {a} \\<odot> q", "finally"], ["proof (chain)\npicking this:\n  Pm_fmap (fmupd t c (fmap_of_list ys)) =\n  monomial c t + except (sparse\\<^sub>0 ys) {t}", "show ?case"], ["proof (prove)\nusing this:\n  Pm_fmap (fmupd t c (fmap_of_list ys)) =\n  monomial c t + except (sparse\\<^sub>0 ys) {t}\n\ngoal (1 subgoal):\n 1. Pm_fmap (fmupd t c (fmap_of_list ys)) \\<odot> q =\n    monom_mult c t q + except (Pm_fmap (fmap_of_list ys)) {t} \\<odot> q", "by (simp add: algebra_simps mult_scalar_monomial sparse\\<^sub>0_def)"], ["proof (state)\nthis:\n  Pm_fmap (fmupd t c (fmap_of_list ys)) \\<odot> q =\n  monom_mult c t q + except (Pm_fmap (fmap_of_list ys)) {t} \\<odot> q\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* term_powerprod *)"], ["", "subsubsection \\<open>restore constructor view\\<close>"], ["", "named_theorems mpoly_simps"], ["", "definition \"monomial1 pp = monomial 1 pp\""], ["", "lemma monomial1_Nil[mpoly_simps]: \"monomial1 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial1 (0::'a) = 1", "by (simp add: monomial1_def)"], ["", "lemma monomial_mp: \"monomial c (pp::'a\\<Rightarrow>\\<^sub>0nat) = Const\\<^sub>0 c * monomial1 pp\"\n  for c::\"'b::comm_semiring_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c pp = Const\\<^sub>0 c * monomial1 pp", "by (auto intro!: poly_mapping_eqI simp: monomial1_def Const\\<^sub>0_def mult_single)"], ["", "lemma monomial1_add: \"(monomial1 (a + b)::('a::monoid_add\\<Rightarrow>\\<^sub>0'b::comm_semiring_1)) = monomial1 a * monomial1 b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial1 (a + b) = monomial1 a * monomial1 b", "by (auto simp: monomial1_def mult_single)"], ["", "lemma monomial1_monomial: \"monomial1 (monomial n v) = (Var\\<^sub>0 v::_\\<Rightarrow>\\<^sub>0('b::comm_semiring_1))^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial1 (monomial n v) = Var\\<^sub>0 v ^ n", "by (auto intro!: poly_mapping_eqI simp: monomial1_def Var\\<^sub>0_power lookup_single when_def)"], ["", "lemma Ball_True: \"(\\<forall>x\\<in>X. True) \\<longleftrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. True) = True", "by auto"], ["", "lemma Collect_False: \"{x. False} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. False} = {}", "by simp"], ["", "lemma Pm_fmap_sum: \"Pm_fmap f = (\\<Sum>x \\<in> fmdom' f. monomial (lookup0 f x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pm_fmap f = (\\<Sum>x\\<in>fmdom' f. monomial (lookup0 f x) x)", "including fmap.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pm_fmap f = (\\<Sum>x\\<in>fmdom' f. monomial (lookup0 f x) x)", "by (auto intro!: poly_mapping_eqI sum.neutral\n      simp: fmlookup_default_def lookup_sum lookup_single when_def fmdom'I\n      split: option.splits)"], ["", "lemma MPoly_numeral: \"MPoly (numeral x) = numeral x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly (numeral x) = numeral x", "by (metis monom.abs_eq monom_numeral single_numeral)"], ["", "lemma MPoly_power: \"MPoly (x ^ n) = MPoly x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly (x ^ n) = MPoly x ^ n", "by (induction n) (auto simp: one_mpoly_def times_mpoly.abs_eq[symmetric])"], ["", "lemmas [mpoly_simps] = Pm_fmap_sum\n  add.assoc[symmetric] mult.assoc[symmetric]\n  add_0 add_0_right mult_1 mult_1_right mult_zero_left mult_zero_right power_0 power_one_right\n  fmdom'_fmap_of_list\n  list.map fst_conv\n  sum.insert_remove finite_insert finite.emptyI\n  lookup0_fmap_of_list_simps\n  num.simps rel_simps\n  if_True if_False\n  insert_Diff_if insert_iff empty_Diff empty_iff\n  simp_thms\n  sum.empty\n  if_poly_mapping_eq_iff\n  keys_zero keys_one\n  keys_add_eq\n  keys_single\n  Un_insert_left Un_empty_left\n  Int_insert_left Int_empty_left\n  Collect_False\n  lookup_add lookup_single lookup_zero lookup_one\n  Set.ball_simps\n  when_simps\n  monomial_mp\n  monomial1_add\n  monomial1_monomial\n  Const\\<^sub>0_one Const\\<^sub>0_zero Const\\<^sub>0_numeral Const\\<^sub>0_minus\n  set_simps"], ["", "text \\<open>A simproc for postprocessing with \\<open>mpoly_simps\\<close> and not polluting \\<open>[code_post]\\<close>:\\<close>"], ["", "ML \\<open>val mpoly_simproc = Simplifier.make_simproc @{context} \"multivariate polynomials\"\n      {lhss = [@{term \"Pm_fmap mpp::(_ \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 _\"}],\n       proc = (K (fn ctxt => fn ct =>\n          SOME (Simplifier.rewrite (put_simpset HOL_basic_ss ctxt addsimps\n            (Named_Theorems.get ctxt (\\<^named_theorems>\\<open>mpoly_simps\\<close>))) ct)))}\\<close>"], ["", "(* The simproc slows down computations *a lot*, so it is deactivated by default. *)\n\n(* setup \\<open>Code_Preproc.map_post (fn ctxt => ctxt addsimprocs [mpoly_simproc])\\<close> *)"], ["", "subsubsection \\<open>Ordered Power-Products\\<close>"], ["", "lemma foldl_assoc:\n  assumes \"\\<And>x y z. f (f x y) z = f x (f y z)\"\n  shows \"foldl f (f a b) xs = f a (foldl f b xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl f (f a b) xs = f a (foldl f b xs)", "proof (induct xs arbitrary: a b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b. foldl f (f a b) [] = f a (foldl f b [])\n 2. \\<And>a xs aa b.\n       (\\<And>a b.\n           foldl f (f a b) xs = f a (foldl f b xs)) \\<Longrightarrow>\n       foldl f (f aa b) (a # xs) = f aa (foldl f b (a # xs))", "fix a b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b. foldl f (f a b) [] = f a (foldl f b [])\n 2. \\<And>a xs aa b.\n       (\\<And>a b.\n           foldl f (f a b) xs = f a (foldl f b xs)) \\<Longrightarrow>\n       foldl f (f aa b) (a # xs) = f aa (foldl f b (a # xs))", "show \"foldl f (f a b) [] = f a (foldl f b [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl f (f a b) [] = f a (foldl f b [])", "by simp"], ["proof (state)\nthis:\n  foldl f (f a b) [] = f a (foldl f b [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs aa b.\n       (\\<And>a b.\n           foldl f (f a b) xs = f a (foldl f b xs)) \\<Longrightarrow>\n       foldl f (f aa b) (a # xs) = f aa (foldl f b (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs aa b.\n       (\\<And>a b.\n           foldl f (f a b) xs = f a (foldl f b xs)) \\<Longrightarrow>\n       foldl f (f aa b) (a # xs) = f aa (foldl f b (a # xs))", "fix a b x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs aa b.\n       (\\<And>a b.\n           foldl f (f a b) xs = f a (foldl f b xs)) \\<Longrightarrow>\n       foldl f (f aa b) (a # xs) = f aa (foldl f b (a # xs))", "assume \"\\<And>a b. foldl f (f a b) xs = f a (foldl f b xs)\""], ["proof (state)\nthis:\n  foldl f (f ?a ?b) xs = f ?a (foldl f ?b xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs aa b.\n       (\\<And>a b.\n           foldl f (f a b) xs = f a (foldl f b xs)) \\<Longrightarrow>\n       foldl f (f aa b) (a # xs) = f aa (foldl f b (a # xs))", "from assms[of a b x] this[of a \"f b x\"]"], ["proof (chain)\npicking this:\n  f (f a b) x = f a (f b x)\n  foldl f (f a (f b x)) xs = f a (foldl f (f b x) xs)", "show \"foldl f (f a b) (x # xs) = f a (foldl f b (x # xs))\""], ["proof (prove)\nusing this:\n  f (f a b) x = f a (f b x)\n  foldl f (f a (f b x)) xs = f a (foldl f (f b x) xs)\n\ngoal (1 subgoal):\n 1. foldl f (f a b) (x # xs) = f a (foldl f b (x # xs))", "unfolding foldl_Cons"], ["proof (prove)\nusing this:\n  f (f a b) x = f a (f b x)\n  foldl f (f a (f b x)) xs = f a (foldl f (f b x) xs)\n\ngoal (1 subgoal):\n 1. foldl f (f (f a b) x) xs = f a (foldl f (f b x) xs)", "by simp"], ["proof (state)\nthis:\n  foldl f (f a b) (x # xs) = f a (foldl f b (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "context ordered_term\nbegin"], ["", "definition list_max::\"'t list \\<Rightarrow> 't\" where\n  \"list_max xs \\<equiv> foldl ord_term_lin.max min_term xs\""], ["", "lemma list_max_Cons: \"list_max (x # xs) = ord_term_lin.max x (list_max xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_max (x # xs) = ord_term_lin.max x (list_max xs)", "unfolding list_max_def foldl_Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl ord_term_lin.max (ord_term_lin.max min_term x) xs =\n    ord_term_lin.max x (foldl ord_term_lin.max min_term xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldl ord_term_lin.max (ord_term_lin.max min_term x) xs =\n    ord_term_lin.max x (foldl ord_term_lin.max min_term xs)", "have \"foldl ord_term_lin.max (ord_term_lin.max x min_term) xs =\n          ord_term_lin.max x (foldl ord_term_lin.max min_term xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl ord_term_lin.max (ord_term_lin.max x min_term) xs =\n    ord_term_lin.max x (foldl ord_term_lin.max min_term xs)", "by (rule foldl_assoc, rule ord_term_lin.max.assoc)"], ["proof (state)\nthis:\n  foldl ord_term_lin.max (ord_term_lin.max x min_term) xs =\n  ord_term_lin.max x (foldl ord_term_lin.max min_term xs)\n\ngoal (1 subgoal):\n 1. foldl ord_term_lin.max (ord_term_lin.max min_term x) xs =\n    ord_term_lin.max x (foldl ord_term_lin.max min_term xs)", "from this ord_term_lin.max.commute[of min_term x]"], ["proof (chain)\npicking this:\n  foldl ord_term_lin.max (ord_term_lin.max x min_term) xs =\n  ord_term_lin.max x (foldl ord_term_lin.max min_term xs)\n  ord_term_lin.max min_term x = ord_term_lin.max x min_term", "show \"foldl ord_term_lin.max (ord_term_lin.max min_term x) xs =\n            ord_term_lin.max x (foldl ord_term_lin.max min_term xs)\""], ["proof (prove)\nusing this:\n  foldl ord_term_lin.max (ord_term_lin.max x min_term) xs =\n  ord_term_lin.max x (foldl ord_term_lin.max min_term xs)\n  ord_term_lin.max min_term x = ord_term_lin.max x min_term\n\ngoal (1 subgoal):\n 1. foldl ord_term_lin.max (ord_term_lin.max min_term x) xs =\n    ord_term_lin.max x (foldl ord_term_lin.max min_term xs)", "by simp"], ["proof (state)\nthis:\n  foldl ord_term_lin.max (ord_term_lin.max min_term x) xs =\n  ord_term_lin.max x (foldl ord_term_lin.max min_term xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_max_empty: \"list_max [] = min_term\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_max [] = min_term", "unfolding list_max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl ord_term_lin.max min_term [] = min_term", "by simp"], ["", "lemma list_max_in_list:\n  assumes \"xs \\<noteq> []\"\n  shows \"list_max xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_max xs \\<in> set xs", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. list_max xs \\<in> set xs", "proof (induct xs, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow> list_max xs \\<in> set xs;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> list_max (a # xs) \\<in> set (a # xs)", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow> list_max xs \\<in> set xs;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> list_max (a # xs) \\<in> set (a # xs)", "assume IH: \"xs \\<noteq> [] \\<Longrightarrow> list_max xs \\<in> set xs\""], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<Longrightarrow> list_max xs \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow> list_max xs \\<in> set xs;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> list_max (a # xs) \\<in> set (a # xs)", "show \"list_max (x # xs) \\<in> set (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_max (x # xs) \\<in> set (x # xs)", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)", "hence \"list_max (x # xs) = ord_term_lin.max min_term x\""], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. list_max (x # xs) = ord_term_lin.max min_term x", "unfolding list_max_def"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. foldl ord_term_lin.max min_term (x # xs) = ord_term_lin.max min_term x", "by simp"], ["proof (state)\nthis:\n  list_max (x # xs) = ord_term_lin.max min_term x\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)", "also"], ["proof (state)\nthis:\n  list_max (x # xs) = ord_term_lin.max min_term x\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_term_lin.max min_term x = x", "unfolding ord_term_lin.max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if min_term \\<preceq>\\<^sub>t x then x else min_term) = x", "by (simp add: min_term_min)"], ["proof (state)\nthis:\n  ord_term_lin.max min_term x = x\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)", "finally"], ["proof (chain)\npicking this:\n  list_max (x # xs) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  list_max (x # xs) = x\n\ngoal (1 subgoal):\n 1. list_max (x # xs) \\<in> set (x # xs)", "by simp"], ["proof (state)\nthis:\n  list_max (x # xs) \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)", "assume \"xs \\<noteq> []\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_max (x # xs) \\<in> set (x # xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_max (x # xs) \\<in> set (x # xs)", "proof (cases \"x \\<preceq>\\<^sub>t list_max xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<preceq>\\<^sub>t list_max xs \\<Longrightarrow>\n    list_max (x # xs) \\<in> set (x # xs)\n 2. \\<not> x \\<preceq>\\<^sub>t list_max xs \\<Longrightarrow>\n    list_max (x # xs) \\<in> set (x # xs)", "case True"], ["proof (state)\nthis:\n  x \\<preceq>\\<^sub>t list_max xs\n\ngoal (2 subgoals):\n 1. x \\<preceq>\\<^sub>t list_max xs \\<Longrightarrow>\n    list_max (x # xs) \\<in> set (x # xs)\n 2. \\<not> x \\<preceq>\\<^sub>t list_max xs \\<Longrightarrow>\n    list_max (x # xs) \\<in> set (x # xs)", "hence \"list_max (x # xs) = list_max xs\""], ["proof (prove)\nusing this:\n  x \\<preceq>\\<^sub>t list_max xs\n\ngoal (1 subgoal):\n 1. list_max (x # xs) = list_max xs", "unfolding list_max_Cons ord_term_lin.max_def"], ["proof (prove)\nusing this:\n  x \\<preceq>\\<^sub>t list_max xs\n\ngoal (1 subgoal):\n 1. (if x \\<preceq>\\<^sub>t list_max xs then list_max xs else x) =\n    list_max xs", "by simp"], ["proof (state)\nthis:\n  list_max (x # xs) = list_max xs\n\ngoal (2 subgoals):\n 1. x \\<preceq>\\<^sub>t list_max xs \\<Longrightarrow>\n    list_max (x # xs) \\<in> set (x # xs)\n 2. \\<not> x \\<preceq>\\<^sub>t list_max xs \\<Longrightarrow>\n    list_max (x # xs) \\<in> set (x # xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_max (x # xs) = list_max xs\n\ngoal (1 subgoal):\n 1. list_max (x # xs) \\<in> set (x # xs)", "using IH[OF \\<open>xs \\<noteq> []\\<close>]"], ["proof (prove)\nusing this:\n  list_max (x # xs) = list_max xs\n  list_max xs \\<in> set xs\n\ngoal (1 subgoal):\n 1. list_max (x # xs) \\<in> set (x # xs)", "by simp"], ["proof (state)\nthis:\n  list_max (x # xs) \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<preceq>\\<^sub>t list_max xs \\<Longrightarrow>\n    list_max (x # xs) \\<in> set (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<preceq>\\<^sub>t list_max xs \\<Longrightarrow>\n    list_max (x # xs) \\<in> set (x # xs)", "case False"], ["proof (state)\nthis:\n  \\<not> x \\<preceq>\\<^sub>t list_max xs\n\ngoal (1 subgoal):\n 1. \\<not> x \\<preceq>\\<^sub>t list_max xs \\<Longrightarrow>\n    list_max (x # xs) \\<in> set (x # xs)", "hence \"list_max (x # xs) = x\""], ["proof (prove)\nusing this:\n  \\<not> x \\<preceq>\\<^sub>t list_max xs\n\ngoal (1 subgoal):\n 1. list_max (x # xs) = x", "unfolding list_max_Cons ord_term_lin.max_def"], ["proof (prove)\nusing this:\n  \\<not> x \\<preceq>\\<^sub>t list_max xs\n\ngoal (1 subgoal):\n 1. (if x \\<preceq>\\<^sub>t list_max xs then list_max xs else x) = x", "by simp"], ["proof (state)\nthis:\n  list_max (x # xs) = x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<preceq>\\<^sub>t list_max xs \\<Longrightarrow>\n    list_max (x # xs) \\<in> set (x # xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_max (x # xs) = x\n\ngoal (1 subgoal):\n 1. list_max (x # xs) \\<in> set (x # xs)", "by simp"], ["proof (state)\nthis:\n  list_max (x # xs) \\<in> set (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_max (x # xs) \\<in> set (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_max (x # xs) \\<in> set (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_max_maximum:\n  assumes \"a \\<in> set xs\"\n  shows \"a \\<preceq>\\<^sub>t (list_max xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<preceq>\\<^sub>t list_max xs", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<preceq>\\<^sub>t list_max xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> set [] \\<Longrightarrow> a \\<preceq>\\<^sub>t list_max []\n 2. \\<And>aa xs.\n       \\<lbrakk>a \\<in> set xs \\<Longrightarrow>\n                a \\<preceq>\\<^sub>t list_max xs;\n        a \\<in> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<preceq>\\<^sub>t list_max (aa # xs)", "assume \"a \\<in> set []\""], ["proof (state)\nthis:\n  a \\<in> set []\n\ngoal (2 subgoals):\n 1. a \\<in> set [] \\<Longrightarrow> a \\<preceq>\\<^sub>t list_max []\n 2. \\<And>aa xs.\n       \\<lbrakk>a \\<in> set xs \\<Longrightarrow>\n                a \\<preceq>\\<^sub>t list_max xs;\n        a \\<in> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<preceq>\\<^sub>t list_max (aa # xs)", "thus \"a \\<preceq>\\<^sub>t list_max []\""], ["proof (prove)\nusing this:\n  a \\<in> set []\n\ngoal (1 subgoal):\n 1. a \\<preceq>\\<^sub>t list_max []", "by simp"], ["proof (state)\nthis:\n  a \\<preceq>\\<^sub>t list_max []\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>a \\<in> set xs \\<Longrightarrow>\n                a \\<preceq>\\<^sub>t list_max xs;\n        a \\<in> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<preceq>\\<^sub>t list_max (aa # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>a \\<in> set xs \\<Longrightarrow>\n                a \\<preceq>\\<^sub>t list_max xs;\n        a \\<in> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<preceq>\\<^sub>t list_max (aa # xs)", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>a \\<in> set xs \\<Longrightarrow>\n                a \\<preceq>\\<^sub>t list_max xs;\n        a \\<in> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<preceq>\\<^sub>t list_max (aa # xs)", "assume IH: \"a \\<in> set xs \\<Longrightarrow> a \\<preceq>\\<^sub>t list_max xs\" and a_in: \"a \\<in> set (x # xs)\""], ["proof (state)\nthis:\n  a \\<in> set xs \\<Longrightarrow> a \\<preceq>\\<^sub>t list_max xs\n  a \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>a \\<in> set xs \\<Longrightarrow>\n                a \\<preceq>\\<^sub>t list_max xs;\n        a \\<in> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<preceq>\\<^sub>t list_max (aa # xs)", "from a_in"], ["proof (chain)\npicking this:\n  a \\<in> set (x # xs)", "have \"a = x \\<or> a \\<in> set xs\""], ["proof (prove)\nusing this:\n  a \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. a = x \\<or> a \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  a = x \\<or> a \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>a \\<in> set xs \\<Longrightarrow>\n                a \\<preceq>\\<^sub>t list_max xs;\n        a \\<in> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<preceq>\\<^sub>t list_max (aa # xs)", "thus \"a \\<preceq>\\<^sub>t list_max (x # xs)\""], ["proof (prove)\nusing this:\n  a = x \\<or> a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<preceq>\\<^sub>t list_max (x # xs)", "unfolding list_max_Cons"], ["proof (prove)\nusing this:\n  a = x \\<or> a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)\n 2. a \\<in> set xs \\<Longrightarrow>\n    a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)", "assume \"a = x\""], ["proof (state)\nthis:\n  a = x\n\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)\n 2. a \\<in> set xs \\<Longrightarrow>\n    a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)", "thus \"a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)\""], ["proof (prove)\nusing this:\n  a = x\n\ngoal (1 subgoal):\n 1. a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)", "by simp"], ["proof (state)\nthis:\n  a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)", "assume \"a \\<in> set xs\""], ["proof (state)\nthis:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)", "from IH[OF this]"], ["proof (chain)\npicking this:\n  a \\<preceq>\\<^sub>t list_max xs", "show \"a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)\""], ["proof (prove)\nusing this:\n  a \\<preceq>\\<^sub>t list_max xs\n\ngoal (1 subgoal):\n 1. a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)", "by (simp add: ord_term_lin.le_max_iff_disj)"], ["proof (state)\nthis:\n  a \\<preceq>\\<^sub>t ord_term_lin.max x (list_max xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<preceq>\\<^sub>t list_max (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_max_nonempty:\n  assumes \"xs \\<noteq> []\"\n  shows \"list_max xs = ord_term_lin.Max (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_max xs = ord_term_lin.Max (set xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_max xs = ord_term_lin.Max (set xs)", "have fin: \"finite (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set xs)", "by simp"], ["proof (state)\nthis:\n  finite (set xs)\n\ngoal (1 subgoal):\n 1. list_max xs = ord_term_lin.Max (set xs)", "have \"ord_term_lin.Max (set xs) = list_max xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_term_lin.Max (set xs) = list_max xs", "proof (rule ord_term_lin.Max_eqI[OF fin, of \"list_max xs\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> set xs \\<Longrightarrow> y \\<preceq>\\<^sub>t list_max xs\n 2. list_max xs \\<in> set xs", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> set xs \\<Longrightarrow> y \\<preceq>\\<^sub>t list_max xs\n 2. list_max xs \\<in> set xs", "assume \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> set xs \\<Longrightarrow> y \\<preceq>\\<^sub>t list_max xs\n 2. list_max xs \\<in> set xs", "from list_max_maximum[OF this]"], ["proof (chain)\npicking this:\n  y \\<preceq>\\<^sub>t list_max xs", "show \"y \\<preceq>\\<^sub>t list_max xs\""], ["proof (prove)\nusing this:\n  y \\<preceq>\\<^sub>t list_max xs\n\ngoal (1 subgoal):\n 1. y \\<preceq>\\<^sub>t list_max xs", "."], ["proof (state)\nthis:\n  y \\<preceq>\\<^sub>t list_max xs\n\ngoal (1 subgoal):\n 1. list_max xs \\<in> set xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. list_max xs \\<in> set xs", "from list_max_in_list[OF assms]"], ["proof (chain)\npicking this:\n  list_max xs \\<in> set xs", "show \"list_max xs \\<in> set xs\""], ["proof (prove)\nusing this:\n  list_max xs \\<in> set xs\n\ngoal (1 subgoal):\n 1. list_max xs \\<in> set xs", "."], ["proof (state)\nthis:\n  list_max xs \\<in> set xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord_term_lin.Max (set xs) = list_max xs\n\ngoal (1 subgoal):\n 1. list_max xs = ord_term_lin.Max (set xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ord_term_lin.Max (set xs) = list_max xs\n\ngoal (1 subgoal):\n 1. list_max xs = ord_term_lin.Max (set xs)", "by simp"], ["proof (state)\nthis:\n  list_max xs = ord_term_lin.Max (set xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_clearjunk_iff_map_of_eq_Some:\n  \"(a, b) \\<in> set (AList.clearjunk xs) \\<longleftrightarrow> map_of xs a = Some b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, b) \\<in> set (AList.clearjunk xs)) = (map_of xs a = Some b)", "by (metis Some_eq_map_of_iff distinct_clearjunk map_of_clearjunk)"], ["", "lemma Pm_fmap_of_list_eq_zero_iff:\n  \"Pm_fmap (fmap_of_list xs) = 0 \\<longleftrightarrow> [(k, v)\\<leftarrow>AList.clearjunk xs . v \\<noteq> 0] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pm_fmap (fmap_of_list xs) = 0) =\n    (filter (\\<lambda>(k, v). v \\<noteq> (0::'c)) (AList.clearjunk xs) = [])", "by (auto simp: poly_mapping_eq_iff fmlookup_default_def fun_eq_iff\n    in_set_clearjunk_iff_map_of_eq_Some filter_empty_conv fmlookup_of_list split: option.splits)"], ["", "lemma fmdom'_clearjunk0: \"fmdom' (clearjunk0 xs) = fmdom' xs - {x. fmlookup xs x = Some 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom' (clearjunk0 xs) = fmdom' xs - {x. fmlookup xs x = Some (0::'c)}", "by (metis (no_types, lifting) clearjunk0_def fmdom'_drop_set fmfilter_alt_defs(2) fmfilter_cong' mem_Collect_eq)"], ["", "lemma compute_lt_poly_mapping[code]:\n  \"lt (Pm_fmap (fmap_of_list xs)) = list_max (map fst [(k, v) \\<leftarrow> AList.clearjunk xs. v \\<noteq> 0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (Pm_fmap (fmap_of_list xs)) =\n    list_max\n     (map fst\n       (filter (\\<lambda>(k, v). v \\<noteq> (0::'b)) (AList.clearjunk xs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lt (Pm_fmap (fmap_of_list xs)) =\n    list_max\n     (map fst\n       (filter (\\<lambda>(k, v). v \\<noteq> (0::'b)) (AList.clearjunk xs)))", "have \"keys (Pm_fmap (fmap_of_list xs)) = fst ` {x \\<in> set (AList.clearjunk xs). case x of (k, v) \\<Rightarrow> v \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (Pm_fmap (fmap_of_list xs)) =\n    fst `\n    {x \\<in> set (AList.clearjunk xs).\n     case x of (k, v) \\<Rightarrow> v \\<noteq> (0::'b)}", "by (auto simp: compute_keys_pp fmdom'_clearjunk0 fmap_of_list.rep_eq\n        in_set_clearjunk_iff_map_of_eq_Some fmdom'I image_iff fmlookup_dom'_iff)"], ["proof (state)\nthis:\n  keys (Pm_fmap (fmap_of_list xs)) =\n  fst `\n  {x \\<in> set (AList.clearjunk xs).\n   case x of (k, v) \\<Rightarrow> v \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. lt (Pm_fmap (fmap_of_list xs)) =\n    list_max\n     (map fst\n       (filter (\\<lambda>(k, v). v \\<noteq> (0::'b)) (AList.clearjunk xs)))", "then"], ["proof (chain)\npicking this:\n  keys (Pm_fmap (fmap_of_list xs)) =\n  fst `\n  {x \\<in> set (AList.clearjunk xs).\n   case x of (k, v) \\<Rightarrow> v \\<noteq> (0::'b)}", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (Pm_fmap (fmap_of_list xs)) =\n  fst `\n  {x \\<in> set (AList.clearjunk xs).\n   case x of (k, v) \\<Rightarrow> v \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. lt (Pm_fmap (fmap_of_list xs)) =\n    list_max\n     (map fst\n       (filter (\\<lambda>(k, v). v \\<noteq> (0::'b)) (AList.clearjunk xs)))", "unfolding lt_def"], ["proof (prove)\nusing this:\n  keys (Pm_fmap (fmap_of_list xs)) =\n  fst `\n  {x \\<in> set (AList.clearjunk xs).\n   case x of (k, v) \\<Rightarrow> v \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. (if Pm_fmap (fmap_of_list xs) = 0 then min_term\n     else ord_term_lin.Max (keys (Pm_fmap (fmap_of_list xs)))) =\n    list_max\n     (map fst\n       (filter (\\<lambda>(k, v). v \\<noteq> (0::'b)) (AList.clearjunk xs)))", "by (auto simp: Pm_fmap_of_list_eq_zero_iff list_max_empty list_max_nonempty)"], ["proof (state)\nthis:\n  lt (Pm_fmap (fmap_of_list xs)) =\n  list_max\n   (map fst\n     (filter (\\<lambda>(k, v). v \\<noteq> (0::'b)) (AList.clearjunk xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compute_higher_poly_mapping [code]:\n  \"higher (Pm_fmap xs) t = Pm_fmap (fmfilter (\\<lambda>k. t \\<prec>\\<^sub>t k) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higher (Pm_fmap xs) t = Pm_fmap (fmfilter ((\\<prec>\\<^sub>t) t) xs)", "unfolding higher_def compute_except_poly_mapping"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pm_fmap\n     (fmfilter (\\<lambda>k. k \\<notin> {s. s \\<preceq>\\<^sub>t t}) xs) =\n    Pm_fmap (fmfilter ((\\<prec>\\<^sub>t) t) xs)", "by (metis mem_Collect_eq ord_term_lin.leD ord_term_lin.leI)"], ["", "lemma compute_lower_poly_mapping [code]:\n  \"lower (Pm_fmap xs) t = Pm_fmap (fmfilter (\\<lambda>k. k \\<prec>\\<^sub>t t) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lower (Pm_fmap xs) t =\n    Pm_fmap (fmfilter (\\<lambda>k. k \\<prec>\\<^sub>t t) xs)", "unfolding lower_def compute_except_poly_mapping"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pm_fmap\n     (fmfilter (\\<lambda>k. k \\<notin> Collect ((\\<preceq>\\<^sub>t) t))\n       xs) =\n    Pm_fmap (fmfilter (\\<lambda>k. k \\<prec>\\<^sub>t t) xs)", "by (metis mem_Collect_eq ord_term_lin.leD ord_term_lin.leI)"], ["", "end"], ["", "(* ordered_term *)"], ["", "lifting_update poly_mapping.lifting"], ["", "lifting_forget poly_mapping.lifting"], ["", "subsection \\<open>Computations\\<close>"], ["", "subsubsection \\<open>Scalar Polynomials\\<close>"], ["", "type_synonym 'a mpoly_tc = \"(nat \\<Rightarrow>\\<^sub>0 nat)\\<Rightarrow>\\<^sub>0'a\""], ["", "definition \"shift_map_keys_punit = term_powerprod.shift_map_keys to_pair_unit fst\""], ["", "lemma compute_shift_map_keys_punit [code]:\n  \"shift_map_keys_punit t f (fmap_of_list xs) = fmap_of_list (map (\\<lambda>(k, v). (t + k, f v)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift_map_keys_punit t f (fmap_of_list xs) =\n    fmap_of_list (map (\\<lambda>(k, v). (t + k, f v)) xs)", "by (simp add: punit.compute_shift_map_keys shift_map_keys_punit_def)"], ["", "global_interpretation punit: term_powerprod to_pair_unit fst\n  rewrites \"punit.adds_term = (adds)\"\n  and \"punit.pp_of_term = (\\<lambda>x. x)\"\n  and \"punit.component_of_term = (\\<lambda>_. ())\"\n  defines monom_mult_punit = punit.monom_mult\n  and mult_scalar_punit = punit.mult_scalar"], ["proof (prove)\ngoal (1 subgoal):\n 1. (term_powerprod to_pair_unit fst &&& punit.adds_term = (adds)) &&&\n    punit.pp_of_term = (\\<lambda>x. x) &&&\n    punit.component_of_term = (\\<lambda>_. ())", "apply (fact MPoly_Type_Class.punit.term_powerprod_axioms)"], ["proof (prove)\ngoal (3 subgoals):\n 1. punit.adds_term = (adds)\n 2. punit.pp_of_term = (\\<lambda>x. x)\n 3. punit.component_of_term = (\\<lambda>_. ())", "apply (fact MPoly_Type_Class.punit_adds_term)"], ["proof (prove)\ngoal (2 subgoals):\n 1. punit.pp_of_term = (\\<lambda>x. x)\n 2. punit.component_of_term = (\\<lambda>_. ())", "apply (fact MPoly_Type_Class.punit_pp_of_term)"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.component_of_term = (\\<lambda>_. ())", "apply (fact MPoly_Type_Class.punit_component_of_term)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compute_monom_mult_punit [code]:\n  \"monom_mult_punit c t (Pm_fmap xs) = Pm_fmap (if c = 0 then fmempty else shift_map_keys_punit t ((*) c) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult_punit c t (Pm_fmap xs) =\n    Pm_fmap\n     (if c = (0::'b) then fmempty else shift_map_keys_punit t ((*) c) xs)", "by (simp add: monom_mult_punit_def punit.compute_monom_mult_poly_mapping shift_map_keys_punit_def)"], ["", "lemma compute_mult_scalar_punit [code]:\n  \"Pm_fmap (fmap_of_list xs) * q = (case xs of ((t, c) # ys) \\<Rightarrow>\n    (monom_mult_punit c t q + except (Pm_fmap (fmap_of_list ys)) {t} * q) | _ \\<Rightarrow>\n    Pm_fmap fmempty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pm_fmap (fmap_of_list xs) * q =\n    (case xs of [] \\<Rightarrow> Pm_fmap fmempty\n     | (t, c) # ys \\<Rightarrow>\n         monom_mult_punit c t q +\n         except (Pm_fmap (fmap_of_list ys)) {t} * q)", "by (simp only: punit_mult_scalar[symmetric] punit.compute_mult_scalar_poly_mapping monom_mult_punit_def)"], ["", "locale trivariate\\<^sub>0_rat\nbegin"], ["", "abbreviation X::\"rat mpoly_tc\" where \"X \\<equiv> Var\\<^sub>0 (0::nat)\""], ["", "abbreviation Y::\"rat mpoly_tc\" where \"Y \\<equiv> Var\\<^sub>0 (1::nat)\""], ["", "abbreviation Z::\"rat mpoly_tc\" where \"Z \\<equiv> Var\\<^sub>0 (2::nat)\""], ["", "end"], ["", "locale trivariate\nbegin"], ["", "abbreviation \"X \\<equiv> Var 0\""], ["", "abbreviation \"Y \\<equiv> Var 1\""], ["", "abbreviation \"Z \\<equiv> Var 2\""], ["", "end"], ["", "experiment begin"], ["", "interpretation trivariate\\<^sub>0_rat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma\n  \"keys (X\\<^sup>2 * Z ^ 3 + 2 * Y ^ 3 * Z\\<^sup>2) =\n    {monomial 2 0 + monomial 3 2, monomial 3 1 + monomial 2 2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 3 +\n      2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2) =\n    {monomial 2 0 + monomial 3 2, monomial 3 1 + monomial 2 2}", "by eval"], ["", "lemma\n  \"keys (X\\<^sup>2 * Z ^ 3 + 2 * Y ^ 3 * Z\\<^sup>2) =\n    {monomial 2 0 + monomial 3 2, monomial 3 1 + monomial 2 2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 3 +\n      2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2) =\n    {monomial 2 0 + monomial 3 2, monomial 3 1 + monomial 2 2}", "by eval"], ["", "lemma\n  \"- 1 * X\\<^sup>2 * Z ^ 7 + - 2 * Y ^ 3 * Z\\<^sup>2 = - X\\<^sup>2 * Z ^ 7 + - 2 * Y ^ 3 * Z\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 * (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7 +\n    - 2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2 =\n    - (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7 +\n    - 2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2", "by eval"], ["", "lemma\n  \"X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2 + X\\<^sup>2 * Z ^ 4 + - 2 * Y ^ 3 * Z\\<^sup>2 = X\\<^sup>2 * Z ^ 7 + X\\<^sup>2 * Z ^ 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7 +\n    2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2 +\n    (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 4 +\n    - 2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2 =\n    (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7 +\n    (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 4", "by eval"], ["", "lemma\n  \"X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2 - X\\<^sup>2 * Z ^ 4 + - 2 * Y ^ 3 * Z\\<^sup>2 =\n    X\\<^sup>2 * Z ^ 7 - X\\<^sup>2 * Z ^ 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7 +\n    2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2 -\n    (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 4 +\n    - 2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2 =\n    (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7 -\n    (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 4", "by eval"], ["", "lemma\n  \"lookup (X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2 + 2) (sparse\\<^sub>0 [(0, 2), (2, 7)]) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7 +\n      2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2 +\n      2)\n     (sparse\\<^sub>0 [(0, 2), (2, 7)]) =\n    1", "by eval"], ["", "lemma\n  \"X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2 \\<noteq>\n   X\\<^sup>2 * Z ^ 4 + - 2 * Y ^ 3 * Z\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7 +\n    2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2 \\<noteq>\n    (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 4 +\n    - 2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2", "by eval"], ["", "lemma\n  \"0 * X^2 * Z^7 + 0 * Y^3*Z\\<^sup>2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 * (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7 +\n    0 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2 =\n    0", "by eval"], ["", "lemma\n  \"monom_mult_punit 3 (sparse\\<^sub>0 [(1, 2::nat)]) (X\\<^sup>2 * Z + 2 * Y ^ 3 * Z\\<^sup>2) =\n    3 * Y\\<^sup>2 * Z * X\\<^sup>2 + 6 * Y ^ 5 * Z\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult_punit 3 (sparse\\<^sub>0 [(1, 2)])\n     ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 +\n      2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2) =\n    3 * (Var\\<^sub>0 1)\\<^sup>2 * Var\\<^sub>0 2 * (Var\\<^sub>0 0)\\<^sup>2 +\n    6 * Var\\<^sub>0 1 ^ 5 * (Var\\<^sub>0 2)\\<^sup>2", "by eval"], ["", "lemma\n  \"monomial (-4) (sparse\\<^sub>0 [(0, 2::nat)]) = - 4 * X\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (- 4) (sparse\\<^sub>0 [(0, 2)]) = - 4 * (Var\\<^sub>0 0)\\<^sup>2", "by eval"], ["", "lemma \"monomial (0::rat) (sparse\\<^sub>0 [(0::nat, 2::nat)]) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial 0 (sparse\\<^sub>0 [(0, 2)]) = 0", "by eval"], ["", "lemma\n  \"(X\\<^sup>2 * Z + 2 * Y ^ 3 * Z\\<^sup>2) * (X\\<^sup>2 * Z ^ 3 + - 2 * Y ^ 3 * Z\\<^sup>2) =\n    X ^ 4 * Z ^ 4 + - 2 * X\\<^sup>2 * Z ^ 3 * Y ^ 3 +\n - 4 * Y ^ 6 * Z ^ 4 + 2 * Y ^ 3 * Z ^ 5 * X\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 +\n     2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2) *\n    ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 3 +\n     - 2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2) =\n    Var\\<^sub>0 0 ^ 4 * Var\\<^sub>0 2 ^ 4 +\n    - 2 * (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 3 * Var\\<^sub>0 1 ^ 3 +\n    - 4 * Var\\<^sub>0 1 ^ 6 * Var\\<^sub>0 2 ^ 4 +\n    2 * Var\\<^sub>0 1 ^ 3 * Var\\<^sub>0 2 ^ 5 * (Var\\<^sub>0 0)\\<^sup>2", "by eval"], ["", "end"], ["", "subsubsection \\<open>Vector-Polynomials\\<close>"], ["", "type_synonym 'a vmpoly_tc = \"((nat \\<Rightarrow>\\<^sub>0 nat) \\<times> nat) \\<Rightarrow>\\<^sub>0 'a\""], ["", "definition \"shift_map_keys_pprod = pprod.shift_map_keys\""], ["", "global_interpretation pprod: term_powerprod \"\\<lambda>x. x\" \"\\<lambda>x. x\"\n  rewrites \"pprod.pp_of_term = fst\"\n  and \"pprod.component_of_term = snd\"\n  defines splus_pprod = pprod.splus\n  and monom_mult_pprod = pprod.monom_mult\n  and mult_scalar_pprod = pprod.mult_scalar\n  and adds_term_pprod = pprod.adds_term"], ["proof (prove)\ngoal (1 subgoal):\n 1. term_powerprod (\\<lambda>x. x) (\\<lambda>x. x) &&&\n    pprod.pp_of_term = fst &&& pprod.component_of_term = snd", "apply (fact MPoly_Type_Class.pprod.term_powerprod_axioms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pprod.pp_of_term = fst\n 2. pprod.component_of_term = snd", "apply (fact MPoly_Type_Class.pprod_pp_of_term)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.component_of_term = snd", "apply (fact MPoly_Type_Class.pprod_component_of_term)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compute_adds_term_pprod [code_unfold]:\n  \"adds_term_pprod u v = (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adds_term_pprod u v =\n    (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))", "by (simp add: adds_term_pprod_def pprod.adds_term_def adds_pp_add_linorder_def)"], ["", "lemma compute_splus_pprod [code]: \"splus_pprod t (s, i) = (t + s, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splus_pprod t (s, i) = (t + s, i)", "by (simp add: splus_pprod_def pprod.splus_def)"], ["", "lemma compute_shift_map_keys_pprod [code]:\n  \"shift_map_keys_pprod t f (fmap_of_list xs) = fmap_of_list (map (\\<lambda>(k, v). (splus_pprod t k, f v)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift_map_keys_pprod t f (fmap_of_list xs) =\n    fmap_of_list (map (\\<lambda>(k, v). (splus_pprod t k, f v)) xs)", "by (simp add: pprod.compute_shift_map_keys shift_map_keys_pprod_def splus_pprod_def)"], ["", "lemma compute_monom_mult_pprod [code]:\n  \"monom_mult_pprod c t (Pm_fmap xs) = Pm_fmap (if c = 0 then fmempty else shift_map_keys_pprod t ((*) c) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult_pprod c t (Pm_fmap xs) =\n    Pm_fmap\n     (if c = (0::'c) then fmempty else shift_map_keys_pprod t ((*) c) xs)", "by (simp add: monom_mult_pprod_def pprod.compute_monom_mult_poly_mapping shift_map_keys_pprod_def)"], ["", "lemma compute_mult_scalar_pprod [code]:\n  \"mult_scalar_pprod (Pm_fmap (fmap_of_list xs)) q = (case xs of ((t, c) # ys) \\<Rightarrow>\n    (monom_mult_pprod c t q + mult_scalar_pprod (except (Pm_fmap (fmap_of_list ys)) {t}) q) | _ \\<Rightarrow>\n    Pm_fmap fmempty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_scalar_pprod (Pm_fmap (fmap_of_list xs)) q =\n    (case xs of [] \\<Rightarrow> Pm_fmap fmempty\n     | (t, c) # ys \\<Rightarrow>\n         monom_mult_pprod c t q +\n         mult_scalar_pprod (except (Pm_fmap (fmap_of_list ys)) {t}) q)", "by (simp only: mult_scalar_pprod_def pprod.compute_mult_scalar_poly_mapping monom_mult_pprod_def)"], ["", "definition Vec\\<^sub>0 :: \"nat \\<Rightarrow> (('a \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> (('a \\<Rightarrow>\\<^sub>0 nat) \\<times> nat) \\<Rightarrow>\\<^sub>0 'b::semiring_1\" where\n  \"Vec\\<^sub>0 i p = mult_scalar_pprod p (Poly_Mapping.single (0, i) 1)\""], ["", "experiment begin"], ["", "interpretation trivariate\\<^sub>0_rat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma\n  \"keys (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 3) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0), (sparse\\<^sub>0 [(1, 3), (2, 2)], 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (Vec\\<^sub>0 0 ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 3) +\n      Vec\\<^sub>0 1 (2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0),\n     (sparse\\<^sub>0 [(1, 3), (2, 2)], 1)}", "by eval"], ["", "lemma\n  \"keys (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 3) + Vec\\<^sub>0 2 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0), (sparse\\<^sub>0 [(1, 3), (2, 2)], 2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (Vec\\<^sub>0 0 ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 3) +\n      Vec\\<^sub>0 2 (2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0),\n     (sparse\\<^sub>0 [(1, 3), (2, 2)], 2)}", "by eval"], ["", "lemma\n  \"Vec\\<^sub>0 1 (X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2) + Vec\\<^sub>0 3 (X\\<^sup>2 * Z ^ 4) + Vec\\<^sub>0 1 (- 2 * Y ^ 3 * Z\\<^sup>2) =\n    Vec\\<^sub>0 1 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 3 (X\\<^sup>2 * Z ^ 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vec\\<^sub>0 1\n     ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7 +\n      2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2) +\n    Vec\\<^sub>0 3 ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 4) +\n    Vec\\<^sub>0 1 (- 2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2) =\n    Vec\\<^sub>0 1 ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7) +\n    Vec\\<^sub>0 3 ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 4)", "by eval"], ["", "lemma\n  \"lookup (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2 + 2)) (sparse\\<^sub>0 [(0, 2), (2, 7)], 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Vec\\<^sub>0 0 ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7) +\n      Vec\\<^sub>0 1 (2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2 + 2))\n     (sparse\\<^sub>0 [(0, 2), (2, 7)], 0) =\n    1", "by eval"], ["", "lemma\n  \"lookup (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2 + 2)) (sparse\\<^sub>0 [(0, 2), (2, 7)], 1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Vec\\<^sub>0 0 ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7) +\n      Vec\\<^sub>0 1 (2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2 + 2))\n     (sparse\\<^sub>0 [(0, 2), (2, 7)], 1) =\n    0", "by eval"], ["", "lemma\n  \"Vec\\<^sub>0 0 (0 * X^2 * Z^7) + Vec\\<^sub>0 1 (0 * Y^3*Z\\<^sup>2) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vec\\<^sub>0 0 (0 * (Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2 ^ 7) +\n    Vec\\<^sub>0 1 (0 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2) =\n    0", "by eval"], ["", "lemma\n  \"monom_mult_pprod 3 (sparse\\<^sub>0 [(1, 2::nat)]) (Vec\\<^sub>0 0 (X\\<^sup>2 * Z) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    Vec\\<^sub>0 0 (3 * Y\\<^sup>2 * Z * X\\<^sup>2) + Vec\\<^sub>0 1 (6 * Y ^ 5 * Z\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult_pprod 3 (sparse\\<^sub>0 [(1, 2)])\n     (Vec\\<^sub>0 0 ((Var\\<^sub>0 0)\\<^sup>2 * Var\\<^sub>0 2) +\n      Vec\\<^sub>0 1 (2 * Var\\<^sub>0 1 ^ 3 * (Var\\<^sub>0 2)\\<^sup>2)) =\n    Vec\\<^sub>0 0\n     (3 * (Var\\<^sub>0 1)\\<^sup>2 * Var\\<^sub>0 2 *\n      (Var\\<^sub>0 0)\\<^sup>2) +\n    Vec\\<^sub>0 1 (6 * Var\\<^sub>0 1 ^ 5 * (Var\\<^sub>0 2)\\<^sup>2)", "by eval"], ["", "end"], ["", "subsection \\<open>Code setup for type MPoly\\<close>"], ["", "text \\<open>postprocessing from \\<open>Var\\<^sub>0, Const\\<^sub>0\\<close> to \\<open>Var, Const\\<close>.\\<close>"], ["", "lemmas [code_post] =\n  plus_mpoly.abs_eq[symmetric]\n  times_mpoly.abs_eq[symmetric]\n  MPoly_numeral\n  MPoly_power\n  one_mpoly_def[symmetric]\n  Var.abs_eq[symmetric]\n  Const.abs_eq[symmetric]"], ["", "instantiation mpoly::(\"{equal, zero}\")equal begin"], ["", "lift_definition equal_mpoly:: \"'a mpoly \\<Rightarrow> 'a mpoly \\<Rightarrow> bool\" is HOL.equal"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mpoly, equal_class)", "proof standard"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "qed (transfer, rule equal_eq)"], ["", "end"], ["", "experiment begin"], ["", "interpretation trivariate"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas [mpoly_simps] = plus_mpoly.abs_eq"], ["", "lemma \"content_primitive (4 * X * Y^2 * Z^3 + 6 * X\\<^sup>2 * Y^4 + 8 * X\\<^sup>2 * Y^5) =\n    (2::int, 2 * X * Y\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y ^ 4 + 4 * X\\<^sup>2 * Y ^ 5)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content_primitive\n     (4 * Var 0 * (Var 1)\\<^sup>2 * Var 2 ^ 3 +\n      6 * (Var 0)\\<^sup>2 * Var 1 ^ 4 +\n      8 * (Var 0)\\<^sup>2 * Var 1 ^ 5) =\n    (2, 2 * Var 0 * (Var 1)\\<^sup>2 * Var 2 ^ 3 +\n        3 * (Var 0)\\<^sup>2 * Var 1 ^ 4 +\n        4 * (Var 0)\\<^sup>2 * Var 1 ^ 5)", "by eval"], ["", "end"], ["", "end"], ["", "(* theory *)"]]}