{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/More_MPoly_Type.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma lookup_Abs_poly_mapping_when_finite:\nassumes \"finite S\"\nshows \"lookup (Abs_poly_mapping (\\<lambda>x. f x when x\\<in>S)) = (\\<lambda>x. f x when x\\<in>S)\"", "lemma remove_key_lookup:\n  \"lookup (remove_key k0 f) k = (lookup f k when k \\<noteq> k0)\"", "lemma remove_key_keys: \"keys f - {k} = keys (remove_key k f)\" (is \"?A = ?B\")", "lemma remove_key_sum: \"remove_key k f + Poly_Mapping.single k (lookup f k) = f\"", "lemma remove_key_single[simp]: \"remove_key v (Poly_Mapping.single v n) = 0\"", "lemma remove_key_add: \"remove_key v m + remove_key v m' = remove_key v (m + m')\"", "lemma poly_mapping_induct [case_names single sum]:\nfixes P::\"('a, 'b::monoid_add) poly_mapping \\<Rightarrow> bool\"\nassumes single:\"\\<And>k v. P (Poly_Mapping.single k v)\"\nand sum:\"(\\<And>f g k v. P f \\<Longrightarrow> P g \\<Longrightarrow> g = (Poly_Mapping.single k v) \\<Longrightarrow> k \\<notin> keys f \\<Longrightarrow> P (f+g))\"\nshows \"P f\"", "lemma map_lookup:\nassumes \"g 0 = 0\"\nshows \"lookup (Poly_Mapping.map g f) x = g ((lookup f) x)\"", "lemma keys_add:\nassumes \"keys f \\<inter> keys g = {}\"\nshows \"keys f \\<union> keys g = keys (f+g)\"", "lemma fun_when:\n\"f 0 = 0 \\<Longrightarrow> f (a when P) = (f a when P)\"", "lemma coeff_all_0:\"(\\<And>m. coeff p m = 0) \\<Longrightarrow> p=0\"", "lemma vars_finite: \"finite (vars p)\"", "lemma vars_monom_single: \"vars (monom (Poly_Mapping.single v k) a) \\<subseteq> {v}\"", "lemma vars_monom_keys:\nassumes \"a\\<noteq>0\"\nshows \"vars (monom m a) = keys m\"", "lemma vars_monom_subset:\nshows \"vars (monom m a) \\<subseteq> keys m\"", "lemma vars_monom_single_cases: \"vars (monom (Poly_Mapping.single v k) a) = (if k=0 \\<or> a=0 then {} else {v})\"", "lemma vars_monom:\nassumes \"a\\<noteq>0\"\nshows \"vars (monom m (1::'a::zero_neq_one)) = vars (monom m (a::'a))\"", "lemma vars_add: \"vars (p1 + p2) \\<subseteq> vars p1 \\<union> vars p2\"", "lemma vars_mult: \"vars (p*q) \\<subseteq> vars p \\<union> vars q\"", "lemma vars_add_monom:\nassumes \"p2 = monom m a\" \"m \\<notin> keys (mapping_of p1)\"\nshows \"vars (p1 + p2) = vars p1 \\<union> vars p2\"", "lemma vars_setsum: \"finite S \\<Longrightarrow> vars (\\<Sum>m\\<in>S. f m) \\<subseteq> (\\<Union>m\\<in>S. vars (f m))\"", "lemma coeff_monom: \"coeff (monom m a) m' = (a when m'=m)\"", "lemma coeff_add: \"coeff p m + coeff q m = coeff (p+q) m\"", "lemma coeff_eq: \"coeff p = coeff q \\<longleftrightarrow> p=q\"", "lemma coeff_monom_mult: \"coeff ((monom m' a)  * q) (m' + m)  = a * coeff q m\"", "lemma one_term_is_monomial:\nassumes \"card (keys (mapping_of p)) \\<le> 1\"\nobtains m where \"p = monom m (coeff p m)\"", "lemma remove_term_coeff: \"coeff (remove_term m0 p) m = (coeff p m when m \\<noteq> m0)\"", "lemma coeff_keys: \"m \\<in> keys (mapping_of p) \\<longleftrightarrow> coeff p m \\<noteq> 0\"", "lemma remove_term_keys:\nshows \"keys (mapping_of p) - {m} = keys (mapping_of (remove_term m p))\" (is \"?A = ?B\")", "lemma remove_term_sum: \"remove_term m p + monom m (coeff p m) = p\"", "lemma mpoly_induct [case_names monom sum]:\nassumes monom:\"\\<And>m a. P (monom m a)\"\nand sum:\"(\\<And>p1 p2 m a. P p1 \\<Longrightarrow> P p2 \\<Longrightarrow> p2 = (monom m a) \\<Longrightarrow> m \\<notin> keys (mapping_of p1) \\<Longrightarrow> P (p1+p2))\"\nshows \"P p\"", "lemma monom_pow:\"monom (Poly_Mapping.single v n0) a ^ n = monom (Poly_Mapping.single v (n0*n)) (a ^ n)\"", "lemma insertion_fun_single: \"insertion_fun f (\\<lambda>m. (a when (Poly_Mapping.single (v::nat) (n::nat)) = m)) = a * f v ^ n\" (is \"?i = _\")", "lemma insertion_single[simp]: \"insertion f (monom (Poly_Mapping.single (v::nat) (n::nat)) a) = a * f v ^ n\"", "lemma insertion_fun_irrelevant_vars:\nfixes p::\"((nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a::comm_ring_1)\"\nassumes \"\\<And>m v. p m \\<noteq> 0 \\<Longrightarrow> lookup m v \\<noteq> 0 \\<Longrightarrow> f v = g v\"\nshows \"insertion_fun f p = insertion_fun g p\"", "lemma insertion_aux_irrelevant_vars:\nfixes p::\"((nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1)\"\nassumes \"\\<And>m v. lookup p m \\<noteq> 0 \\<Longrightarrow> lookup m v \\<noteq> 0 \\<Longrightarrow> f v = g v\"\nshows \"insertion_aux f p = insertion_aux g p\"", "lemma insertion_irrelevant_vars:\nfixes p::\"'a::comm_ring_1 mpoly\"\nassumes \"\\<And>v. v\\<in>vars p \\<Longrightarrow> f v = g v\"\nshows \"insertion f p = insertion g p\"", "lemma reduce_nested_mpoly_sum:\nfixes p1::\"'a::comm_ring_1 mpoly mpoly\"\nshows \"reduce_nested_mpoly (p1 + p2) = reduce_nested_mpoly p1 + reduce_nested_mpoly p2\"", "lemma reduce_nested_mpoly_prod:\nfixes p1::\"'a::comm_ring_1 mpoly mpoly\"\nshows \"reduce_nested_mpoly (p1 * p2) = reduce_nested_mpoly p1 * reduce_nested_mpoly p2\"", "lemma reduce_nested_mpoly_0:\nshows \"reduce_nested_mpoly 0 = 0\"", "lemma insertion_nested_poly:\nfixes pp::\"'a::comm_ring_1 mpoly mpoly\"\nshows \"insertion f (insertion (\\<lambda>v. monom 0 (f v)) pp) = insertion f (reduce_nested_mpoly pp)\"", "lemma extract_var_finite_set:\nassumes \"{m'. coeff p m' \\<noteq> 0} \\<subseteq> S\"\nassumes \"finite S\"\nshows \"extract_var p v = (\\<Sum>m\\<in>S. monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\"", "lemma extract_var_non_zero_coeff: \"extract_var p v = (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> 0}. monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\"", "lemma extract_var_sum: \"extract_var (p+p') v = extract_var p v + extract_var p' v\"", "lemma extract_var_monom:\nshows \"extract_var (monom m a) v = monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)\"", "lemma extract_var_monom_mult:\nshows \"extract_var (monom (m+m') (a*b)) v = extract_var (monom m a) v * extract_var (monom m' b) v\"", "lemma extract_var_single: \"extract_var (monom (Poly_Mapping.single v n) a) v = monom 0 (monom (Poly_Mapping.single v n) a)\"", "lemma extract_var_single':\nassumes \"v \\<noteq> v'\"\nshows \"extract_var (monom (Poly_Mapping.single v n) a) v' = monom (Poly_Mapping.single v n) (monom 0 a)\"", "lemma reduce_nested_mpoly_extract_var:\nfixes p::\"'a::comm_ring_1 mpoly\"\nshows \"reduce_nested_mpoly (extract_var p v) = p\"", "lemma vars_extract_var_subset: \"vars (extract_var p v) \\<subseteq> vars p\"", "lemma v_not_in_vars_extract_var: \"v \\<notin> vars (extract_var p v)\"", "lemma vars_coeff_extract_var: \"vars (coeff (extract_var p v) j) \\<subseteq> {v}\"", "lemma coeff_replace_coeff:\nassumes \"f 0 = 0\"\nshows \"coeff (replace_coeff f p) m = f (coeff p m)\"", "lemma replace_coeff_monom:\nassumes \"f 0 = 0\"\nshows \"replace_coeff f (monom m a) = monom m (f a)\"", "lemma replace_coeff_add:\nassumes \"f 0 = 0\"\nassumes \"\\<And>a b. f (a+b) = f a + f b\"\nshows \"replace_coeff f (p1 + p2) = replace_coeff f p1 + replace_coeff f p2\"", "lemma insertion_replace_coeff:\nfixes pp::\"'a::comm_ring_1 mpoly mpoly\"\nshows \"insertion f (replace_coeff (insertion f) pp) = insertion f (reduce_nested_mpoly pp)\"", "lemma replace_coeff_extract_var_cong:\nassumes \"f v = g v\"\nshows \"replace_coeff (insertion f) (extract_var p v) = replace_coeff (insertion g) (extract_var p v)\"", "lemma vars_replace_coeff:\nassumes \"f 0 = 0\"\nshows \"vars (replace_coeff f p) \\<subseteq> vars p\"", "lemma polyfunI: \"(\\<And>P. (\\<And>p. vars p \\<subseteq> N \\<Longrightarrow> (\\<And>x. insertion x p = f x) \\<Longrightarrow> P) \\<Longrightarrow> P) \\<Longrightarrow> polyfun N f\"", "lemma polyfun_subset: \"N\\<subseteq>N' \\<Longrightarrow> polyfun N f \\<Longrightarrow> polyfun N' f\"", "lemma polyfun_const: \"polyfun N (\\<lambda>_. c)\"", "lemma polyfun_add:\nassumes \"polyfun N f\" \"polyfun N g\"\nshows \"polyfun N (\\<lambda>x. f x + g x)\"", "lemma polyfun_mult:\nassumes \"polyfun N f\" \"polyfun N g\"\nshows \"polyfun N (\\<lambda>x. f x * g x)\"", "lemma polyfun_Sum:\nassumes \"finite I\"\nassumes \"\\<And>i. i\\<in>I \\<Longrightarrow> polyfun N (f i)\"\nshows \"polyfun N (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\"", "lemma polyfun_Prod:\nassumes \"finite I\"\nassumes \"\\<And>i. i\\<in>I \\<Longrightarrow> polyfun N (f i)\"\nshows \"polyfun N (\\<lambda>x. \\<Prod>i\\<in>I. f i x)\"", "lemma polyfun_single:\nassumes \"i\\<in>N\"\nshows \"polyfun N (\\<lambda>x. x i)\""], "translations": [["", "lemma lookup_Abs_poly_mapping_when_finite:\nassumes \"finite S\"\nshows \"lookup (Abs_poly_mapping (\\<lambda>x. f x when x\\<in>S)) = (\\<lambda>x. f x when x\\<in>S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping (\\<lambda>x. f x when x \\<in> S)) =\n    (\\<lambda>x. f x when x \\<in> S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping (\\<lambda>x. f x when x \\<in> S)) =\n    (\\<lambda>x. f x when x \\<in> S)", "have \"finite {x. (f x when x\\<in>S) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. (f x when x \\<in> S) \\<noteq> (0::'b)}", "using assms"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. finite {x. (f x when x \\<in> S) \\<noteq> (0::'b)}", "by auto"], ["proof (state)\nthis:\n  finite {x. (f x when x \\<in> S) \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping (\\<lambda>x. f x when x \\<in> S)) =\n    (\\<lambda>x. f x when x \\<in> S)", "then"], ["proof (chain)\npicking this:\n  finite {x. (f x when x \\<in> S) \\<noteq> (0::'b)}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {x. (f x when x \\<in> S) \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping (\\<lambda>x. f x when x \\<in> S)) =\n    (\\<lambda>x. f x when x \\<in> S)", "using lookup_Abs_poly_mapping"], ["proof (prove)\nusing this:\n  finite {x. (f x when x \\<in> S) \\<noteq> (0::'b)}\n  finite {x. ?f x \\<noteq> (0::?'b)} \\<Longrightarrow>\n  lookup (Abs_poly_mapping ?f) = ?f\n\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping (\\<lambda>x. f x when x \\<in> S)) =\n    (\\<lambda>x. f x when x \\<in> S)", "by fast"], ["proof (state)\nthis:\n  lookup (Abs_poly_mapping (\\<lambda>x. f x when x \\<in> S)) =\n  (\\<lambda>x. f x when x \\<in> S)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition remove_key::\"'a \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b::monoid_add) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b)\" where\n  \"remove_key k0 f = Abs_poly_mapping (\\<lambda>k. lookup f k when k \\<noteq> k0)\""], ["", "lemma remove_key_lookup:\n  \"lookup (remove_key k0 f) k = (lookup f k when k \\<noteq> k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (remove_key k0 f) k = (lookup f k when k \\<noteq> k0)", "unfolding remove_key_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping (\\<lambda>k. lookup f k when k \\<noteq> k0))\n     k =\n    (lookup f k when k \\<noteq> k0)", "using finite_subset"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping (\\<lambda>k. lookup f k when k \\<noteq> k0))\n     k =\n    (lookup f k when k \\<noteq> k0)", "by (simp add: lookup_Abs_poly_mapping)"], ["", "lemma remove_key_keys: \"keys f - {k} = keys (remove_key k f)\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys f - {k} = keys (remove_key k f)", "proof (rule antisym; rule subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys f - {k} \\<Longrightarrow> x \\<in> keys (remove_key k f)\n 2. \\<And>x.\n       x \\<in> keys (remove_key k f) \\<Longrightarrow> x \\<in> keys f - {k}", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys f - {k} \\<Longrightarrow> x \\<in> keys (remove_key k f)\n 2. \\<And>x.\n       x \\<in> keys (remove_key k f) \\<Longrightarrow> x \\<in> keys f - {k}", "assume \"x \\<in> ?A\""], ["proof (state)\nthis:\n  x \\<in> keys f - {k}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys f - {k} \\<Longrightarrow> x \\<in> keys (remove_key k f)\n 2. \\<And>x.\n       x \\<in> keys (remove_key k f) \\<Longrightarrow> x \\<in> keys f - {k}", "then"], ["proof (chain)\npicking this:\n  x \\<in> keys f - {k}", "show \"x \\<in> ?B\""], ["proof (prove)\nusing this:\n  x \\<in> keys f - {k}\n\ngoal (1 subgoal):\n 1. x \\<in> keys (remove_key k f)", "using remove_key_lookup lookup_not_eq_zero_eq_in_keys DiffD1 DiffD2 insertCI"], ["proof (prove)\nusing this:\n  x \\<in> keys f - {k}\n  lookup (remove_key ?k0.0 ?f) ?k = (lookup ?f ?k when ?k \\<noteq> ?k0.0)\n  (lookup ?f ?k \\<noteq> (0::?'a)) = (?k \\<in> keys ?f)\n  ?c \\<in> ?A - ?B \\<Longrightarrow> ?c \\<in> ?A\n  \\<lbrakk>?c \\<in> ?A - ?B; ?c \\<in> ?B\\<rbrakk> \\<Longrightarrow> ?P\n  (?a \\<notin> ?B \\<Longrightarrow> ?a = ?b) \\<Longrightarrow>\n  ?a \\<in> insert ?b ?B\n\ngoal (1 subgoal):\n 1. x \\<in> keys (remove_key k f)", "by (metis (mono_tags, lifting) when_def)"], ["proof (state)\nthis:\n  x \\<in> keys (remove_key k f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (remove_key k f) \\<Longrightarrow> x \\<in> keys f - {k}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (remove_key k f) \\<Longrightarrow> x \\<in> keys f - {k}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (remove_key k f) \\<Longrightarrow> x \\<in> keys f - {k}", "assume \"x \\<in> ?B\""], ["proof (state)\nthis:\n  x \\<in> keys (remove_key k f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (remove_key k f) \\<Longrightarrow> x \\<in> keys f - {k}", "then"], ["proof (chain)\npicking this:\n  x \\<in> keys (remove_key k f)", "have \"lookup (remove_key k f) x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> keys (remove_key k f)\n\ngoal (1 subgoal):\n 1. lookup (remove_key k f) x \\<noteq> (0::'b)", "by blast"], ["proof (state)\nthis:\n  lookup (remove_key k f) x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (remove_key k f) \\<Longrightarrow> x \\<in> keys f - {k}", "then"], ["proof (chain)\npicking this:\n  lookup (remove_key k f) x \\<noteq> (0::'b)", "show \"x \\<in> ?A\""], ["proof (prove)\nusing this:\n  lookup (remove_key k f) x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. x \\<in> keys f - {k}", "by (simp add: lookup_not_eq_zero_eq_in_keys remove_key_lookup)"], ["proof (state)\nthis:\n  x \\<in> keys f - {k}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_key_sum: \"remove_key k f + Poly_Mapping.single k (lookup f k) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_key k f + Poly_Mapping.single k (lookup f k) = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. remove_key k f + Poly_Mapping.single k (lookup f k) = f", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. remove_key k f + Poly_Mapping.single k (lookup f k) = f", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. remove_key k f + Poly_Mapping.single k (lookup f k) = f", "have rem:\"(lookup f k' when k' \\<noteq> k) = lookup (remove_key k f) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup f k' when k' \\<noteq> k) = lookup (remove_key k f) k'", "using when_def"], ["proof (prove)\nusing this:\n  (?a when ?P) = (if ?P then ?a else (0::?'a))\n\ngoal (1 subgoal):\n 1. (lookup f k' when k' \\<noteq> k) = lookup (remove_key k f) k'", "by (simp add: remove_key_lookup)"], ["proof (state)\nthis:\n  (lookup f k' when k' \\<noteq> k) = lookup (remove_key k f) k'\n\ngoal (1 subgoal):\n 1. remove_key k f + Poly_Mapping.single k (lookup f k) = f", "have sin:\"(lookup f k when k'=k) =  lookup (Poly_Mapping.single k (lookup f k)) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup f k when k' = k) =\n    lookup (Poly_Mapping.single k (lookup f k)) k'", "by (simp add: lookup_single_not_eq when_def)"], ["proof (state)\nthis:\n  (lookup f k when k' = k) = lookup (Poly_Mapping.single k (lookup f k)) k'\n\ngoal (1 subgoal):\n 1. remove_key k f + Poly_Mapping.single k (lookup f k) = f", "have \"lookup f k' = (lookup f k' when k' \\<noteq> k) + ((lookup f k) when k'=k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup f k' =\n    (lookup f k' when k' \\<noteq> k) + (lookup f k when k' = k)", "unfolding when_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup f k' =\n    (if k' \\<noteq> k then lookup f k' else (0::'b)) +\n    (if k' = k then lookup f k else (0::'b))", "by fastforce"], ["proof (state)\nthis:\n  lookup f k' = (lookup f k' when k' \\<noteq> k) + (lookup f k when k' = k)\n\ngoal (1 subgoal):\n 1. remove_key k f + Poly_Mapping.single k (lookup f k) = f", "with rem sin"], ["proof (chain)\npicking this:\n  (lookup f k' when k' \\<noteq> k) = lookup (remove_key k f) k'\n  (lookup f k when k' = k) = lookup (Poly_Mapping.single k (lookup f k)) k'\n  lookup f k' = (lookup f k' when k' \\<noteq> k) + (lookup f k when k' = k)", "have \"lookup f k' = lookup ((remove_key k f) + Poly_Mapping.single k (lookup f k)) k'\""], ["proof (prove)\nusing this:\n  (lookup f k' when k' \\<noteq> k) = lookup (remove_key k f) k'\n  (lookup f k when k' = k) = lookup (Poly_Mapping.single k (lookup f k)) k'\n  lookup f k' = (lookup f k' when k' \\<noteq> k) + (lookup f k when k' = k)\n\ngoal (1 subgoal):\n 1. lookup f k' =\n    lookup (remove_key k f + Poly_Mapping.single k (lookup f k)) k'", "using lookup_add"], ["proof (prove)\nusing this:\n  (lookup f k' when k' \\<noteq> k) = lookup (remove_key k f) k'\n  (lookup f k when k' = k) = lookup (Poly_Mapping.single k (lookup f k)) k'\n  lookup f k' = (lookup f k' when k' \\<noteq> k) + (lookup f k when k' = k)\n  lookup (?f + ?g) ?k = lookup ?f ?k + lookup ?g ?k\n\ngoal (1 subgoal):\n 1. lookup f k' =\n    lookup (remove_key k f + Poly_Mapping.single k (lookup f k)) k'", "by metis"], ["proof (state)\nthis:\n  lookup f k' =\n  lookup (remove_key k f + Poly_Mapping.single k (lookup f k)) k'\n\ngoal (1 subgoal):\n 1. remove_key k f + Poly_Mapping.single k (lookup f k) = f", "}"], ["proof (state)\nthis:\n  lookup f ?k'2 =\n  lookup (remove_key k f + Poly_Mapping.single k (lookup f k)) ?k'2\n\ngoal (1 subgoal):\n 1. remove_key k f + Poly_Mapping.single k (lookup f k) = f", "then"], ["proof (chain)\npicking this:\n  lookup f ?k'2 =\n  lookup (remove_key k f + Poly_Mapping.single k (lookup f k)) ?k'2", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup f ?k'2 =\n  lookup (remove_key k f + Poly_Mapping.single k (lookup f k)) ?k'2\n\ngoal (1 subgoal):\n 1. remove_key k f + Poly_Mapping.single k (lookup f k) = f", "by (metis poly_mapping_eqI)"], ["proof (state)\nthis:\n  remove_key k f + Poly_Mapping.single k (lookup f k) = f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_key_single[simp]: \"remove_key v (Poly_Mapping.single v n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_key v (Poly_Mapping.single v n) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. remove_key v (Poly_Mapping.single v n) = 0", "have 0:\"\\<And>k. (lookup (Poly_Mapping.single v n) k when k \\<noteq> v) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       (lookup (Poly_Mapping.single v n) k when k \\<noteq> v) = (0::'b)", "by (simp add: lookup_single_not_eq when_def)"], ["proof (state)\nthis:\n  (lookup (Poly_Mapping.single v n) ?k when ?k \\<noteq> v) = (0::'b)\n\ngoal (1 subgoal):\n 1. remove_key v (Poly_Mapping.single v n) = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_key v (Poly_Mapping.single v n) = 0", "unfolding remove_key_def 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_poly_mapping (\\<lambda>k. 0::'b) = 0", "by auto"], ["proof (state)\nthis:\n  remove_key v (Poly_Mapping.single v n) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_key_add: \"remove_key v m + remove_key v m' = remove_key v (m + m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_key v m + remove_key v m' = remove_key v (m + m')", "by (rule poly_mapping_eqI; simp add: lookup_add remove_key_lookup when_add_distrib)"], ["", "lemma poly_mapping_induct [case_names single sum]:\nfixes P::\"('a, 'b::monoid_add) poly_mapping \\<Rightarrow> bool\"\nassumes single:\"\\<And>k v. P (Poly_Mapping.single k v)\"\nand sum:\"(\\<And>f g k v. P f \\<Longrightarrow> P g \\<Longrightarrow> g = (Poly_Mapping.single k v) \\<Longrightarrow> k \\<notin> keys f \\<Longrightarrow> P (f+g))\"\nshows \"P f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P f", "using finite_keys[of f]"], ["proof (prove)\nusing this:\n  finite (keys f)\n\ngoal (1 subgoal):\n 1. P f", "proof (induction \"keys f\" arbitrary: f rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f. {} = keys f \\<Longrightarrow> P f\n 2. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f. F = keys f \\<Longrightarrow> P f;\n        insert x F = keys f\\<rbrakk>\n       \\<Longrightarrow> P f", "case (empty)"], ["proof (state)\nthis:\n  {} = keys f\n\ngoal (2 subgoals):\n 1. \\<And>f. {} = keys f \\<Longrightarrow> P f\n 2. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f. F = keys f \\<Longrightarrow> P f;\n        insert x F = keys f\\<rbrakk>\n       \\<Longrightarrow> P f", "then"], ["proof (chain)\npicking this:\n  {} = keys f", "show ?case"], ["proof (prove)\nusing this:\n  {} = keys f\n\ngoal (1 subgoal):\n 1. P f", "using single[of _ 0]"], ["proof (prove)\nusing this:\n  {} = keys f\n  P (Poly_Mapping.single ?k (0::'b))\n\ngoal (1 subgoal):\n 1. P f", "by (metis (full_types) aux empty_iff not_in_keys_iff_lookup_eq_zero single_zero)"], ["proof (state)\nthis:\n  P f\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f. F = keys f \\<Longrightarrow> P f;\n        insert x F = keys f\\<rbrakk>\n       \\<Longrightarrow> P f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f. F = keys f \\<Longrightarrow> P f;\n        insert x F = keys f\\<rbrakk>\n       \\<Longrightarrow> P f", "case (insert k K f)"], ["proof (state)\nthis:\n  finite K\n  k \\<notin> K\n  K = keys ?f \\<Longrightarrow> P ?f\n  insert k K = keys f\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f. F = keys f \\<Longrightarrow> P f;\n        insert x F = keys f\\<rbrakk>\n       \\<Longrightarrow> P f", "obtain f1 f2 where f12_def: \"f1 = remove_key k f\" \"f2 = Poly_Mapping.single k (lookup f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f1 f2.\n        \\<lbrakk>f1 = remove_key k f;\n         f2 = Poly_Mapping.single k (lookup f k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f1 = remove_key k f\n  f2 = Poly_Mapping.single k (lookup f k)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f. F = keys f \\<Longrightarrow> P f;\n        insert x F = keys f\\<rbrakk>\n       \\<Longrightarrow> P f", "have \"P f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P f1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P f1", "have \"Suc (card (keys f1)) = card (keys f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card (keys f1)) = card (keys f)", "using remove_key_keys finite_keys f12_def(1)"], ["proof (prove)\nusing this:\n  keys ?f - {?k} = keys (remove_key ?k ?f)\n  finite (keys ?f)\n  f1 = remove_key k f\n\ngoal (1 subgoal):\n 1. Suc (card (keys f1)) = card (keys f)", "by (metis (no_types) Diff_insert_absorb card_insert_disjoint insert.hyps(2) insert.hyps(4))"], ["proof (state)\nthis:\n  Suc (card (keys f1)) = card (keys f)\n\ngoal (1 subgoal):\n 1. P f1", "then"], ["proof (chain)\npicking this:\n  Suc (card (keys f1)) = card (keys f)", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc (card (keys f1)) = card (keys f)\n\ngoal (1 subgoal):\n 1. P f1", "using insert lessI"], ["proof (prove)\nusing this:\n  Suc (card (keys f1)) = card (keys f)\n  finite K\n  k \\<notin> K\n  K = keys ?f \\<Longrightarrow> P ?f\n  insert k K = keys f\n  ?n < Suc ?n\n\ngoal (1 subgoal):\n 1. P f1", "by (metis Diff_insert_absorb f12_def(1) remove_key_keys)"], ["proof (state)\nthis:\n  P f1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P f1\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f. F = keys f \\<Longrightarrow> P f;\n        insert x F = keys f\\<rbrakk>\n       \\<Longrightarrow> P f", "have \"P f2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P f2", "by (simp add: single f12_def(2))"], ["proof (state)\nthis:\n  P f2\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f. F = keys f \\<Longrightarrow> P f;\n        insert x F = keys f\\<rbrakk>\n       \\<Longrightarrow> P f", "have \"f1 + f2 = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f1 + f2 = f", "using remove_key_sum f12_def"], ["proof (prove)\nusing this:\n  remove_key ?k ?f + Poly_Mapping.single ?k (lookup ?f ?k) = ?f\n  f1 = remove_key k f\n  f2 = Poly_Mapping.single k (lookup f k)\n\ngoal (1 subgoal):\n 1. f1 + f2 = f", "by auto"], ["proof (state)\nthis:\n  f1 + f2 = f\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f. F = keys f \\<Longrightarrow> P f;\n        insert x F = keys f\\<rbrakk>\n       \\<Longrightarrow> P f", "have \"k \\<notin> keys f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> keys f1", "using remove_key_keys f12_def"], ["proof (prove)\nusing this:\n  keys ?f - {?k} = keys (remove_key ?k ?f)\n  f1 = remove_key k f\n  f2 = Poly_Mapping.single k (lookup f k)\n\ngoal (1 subgoal):\n 1. k \\<notin> keys f1", "by fast"], ["proof (state)\nthis:\n  k \\<notin> keys f1\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f. F = keys f \\<Longrightarrow> P f;\n        insert x F = keys f\\<rbrakk>\n       \\<Longrightarrow> P f", "then"], ["proof (chain)\npicking this:\n  k \\<notin> keys f1", "show ?case"], ["proof (prove)\nusing this:\n  k \\<notin> keys f1\n\ngoal (1 subgoal):\n 1. P f", "using \\<open>P f1\\<close> \\<open>P f2\\<close> sum[of f1 f2 k \"lookup f k\"] \\<open>f1 + f2 = f\\<close> f12_def"], ["proof (prove)\nusing this:\n  k \\<notin> keys f1\n  P f1\n  P f2\n  \\<lbrakk>P f1; P f2; f2 = Poly_Mapping.single k (lookup f k);\n   k \\<notin> keys f1\\<rbrakk>\n  \\<Longrightarrow> P (f1 + f2)\n  f1 + f2 = f\n  f1 = remove_key k f\n  f2 = Poly_Mapping.single k (lookup f k)\n\ngoal (1 subgoal):\n 1. P f", "by auto"], ["proof (state)\nthis:\n  P f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_lookup:\nassumes \"g 0 = 0\"\nshows \"lookup (Poly_Mapping.map g f) x = g ((lookup f) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Poly_Mapping.map g f) x = g (lookup f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (Poly_Mapping.map g f) x = g (lookup f x)", "have \"(g (lookup f x) when lookup f x \\<noteq> 0) = g (lookup f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g (lookup f x) when lookup f x \\<noteq> (0::'b)) = g (lookup f x)", "by (metis (mono_tags, lifting) assms when_def)"], ["proof (state)\nthis:\n  (g (lookup f x) when lookup f x \\<noteq> (0::'b)) = g (lookup f x)\n\ngoal (1 subgoal):\n 1. lookup (Poly_Mapping.map g f) x = g (lookup f x)", "then"], ["proof (chain)\npicking this:\n  (g (lookup f x) when lookup f x \\<noteq> (0::'b)) = g (lookup f x)", "have \"(g (lookup f x) when x \\<in> keys f) = g (lookup f x)\""], ["proof (prove)\nusing this:\n  (g (lookup f x) when lookup f x \\<noteq> (0::'b)) = g (lookup f x)\n\ngoal (1 subgoal):\n 1. (g (lookup f x) when x \\<in> keys f) = g (lookup f x)", "using lookup_not_eq_zero_eq_in_keys [of f]"], ["proof (prove)\nusing this:\n  (g (lookup f x) when lookup f x \\<noteq> (0::'b)) = g (lookup f x)\n  (lookup f ?k \\<noteq> (0::'b)) = (?k \\<in> keys f)\n\ngoal (1 subgoal):\n 1. (g (lookup f x) when x \\<in> keys f) = g (lookup f x)", "by simp"], ["proof (state)\nthis:\n  (g (lookup f x) when x \\<in> keys f) = g (lookup f x)\n\ngoal (1 subgoal):\n 1. lookup (Poly_Mapping.map g f) x = g (lookup f x)", "then"], ["proof (chain)\npicking this:\n  (g (lookup f x) when x \\<in> keys f) = g (lookup f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (g (lookup f x) when x \\<in> keys f) = g (lookup f x)\n\ngoal (1 subgoal):\n 1. lookup (Poly_Mapping.map g f) x = g (lookup f x)", "by (simp add: Poly_Mapping.map_def map_fun_def in_keys_iff)"], ["proof (state)\nthis:\n  lookup (Poly_Mapping.map g f) x = g (lookup f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_add:\nassumes \"keys f \\<inter> keys g = {}\"\nshows \"keys f \\<union> keys g = keys (f+g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys f \\<union> keys g = keys (f + g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. keys f \\<union> keys g \\<subseteq> keys (f + g)\n 2. keys (f + g) \\<subseteq> keys f \\<union> keys g", "have \"keys f \\<subseteq> keys (f+g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys f \\<subseteq> keys (f + g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys f \\<Longrightarrow> x \\<in> keys (f + g)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys f \\<Longrightarrow> x \\<in> keys (f + g)", "assume \"x\\<in>keys f\""], ["proof (state)\nthis:\n  x \\<in> keys f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys f \\<Longrightarrow> x \\<in> keys (f + g)", "then"], ["proof (chain)\npicking this:\n  x \\<in> keys f", "have \"lookup (f+g) x = lookup f x \""], ["proof (prove)\nusing this:\n  x \\<in> keys f\n\ngoal (1 subgoal):\n 1. lookup (f + g) x = lookup f x", "by (metis add.right_neutral assms disjoint_iff_not_equal not_in_keys_iff_lookup_eq_zero plus_poly_mapping.rep_eq)"], ["proof (state)\nthis:\n  lookup (f + g) x = lookup f x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys f \\<Longrightarrow> x \\<in> keys (f + g)", "then"], ["proof (chain)\npicking this:\n  lookup (f + g) x = lookup f x", "show \"x\\<in>keys (f+g)\""], ["proof (prove)\nusing this:\n  lookup (f + g) x = lookup f x\n\ngoal (1 subgoal):\n 1. x \\<in> keys (f + g)", "using \\<open>x\\<in>keys f\\<close>"], ["proof (prove)\nusing this:\n  lookup (f + g) x = lookup f x\n  x \\<in> keys f\n\ngoal (1 subgoal):\n 1. x \\<in> keys (f + g)", "by (metis not_in_keys_iff_lookup_eq_zero)"], ["proof (state)\nthis:\n  x \\<in> keys (f + g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys f \\<subseteq> keys (f + g)\n\ngoal (2 subgoals):\n 1. keys f \\<union> keys g \\<subseteq> keys (f + g)\n 2. keys (f + g) \\<subseteq> keys f \\<union> keys g", "moreover"], ["proof (state)\nthis:\n  keys f \\<subseteq> keys (f + g)\n\ngoal (2 subgoals):\n 1. keys f \\<union> keys g \\<subseteq> keys (f + g)\n 2. keys (f + g) \\<subseteq> keys f \\<union> keys g", "have \"keys g \\<subseteq> keys (f+g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys g \\<subseteq> keys (f + g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys g \\<Longrightarrow> x \\<in> keys (f + g)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys g \\<Longrightarrow> x \\<in> keys (f + g)", "assume \"x\\<in>keys g\""], ["proof (state)\nthis:\n  x \\<in> keys g\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys g \\<Longrightarrow> x \\<in> keys (f + g)", "then"], ["proof (chain)\npicking this:\n  x \\<in> keys g", "have \"lookup (f+g) x = lookup g x \""], ["proof (prove)\nusing this:\n  x \\<in> keys g\n\ngoal (1 subgoal):\n 1. lookup (f + g) x = lookup g x", "by (metis IntI add.left_neutral assms empty_iff not_in_keys_iff_lookup_eq_zero plus_poly_mapping.rep_eq)"], ["proof (state)\nthis:\n  lookup (f + g) x = lookup g x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys g \\<Longrightarrow> x \\<in> keys (f + g)", "then"], ["proof (chain)\npicking this:\n  lookup (f + g) x = lookup g x", "show \"x\\<in>keys (f+g)\""], ["proof (prove)\nusing this:\n  lookup (f + g) x = lookup g x\n\ngoal (1 subgoal):\n 1. x \\<in> keys (f + g)", "using \\<open>x\\<in>keys g\\<close>"], ["proof (prove)\nusing this:\n  lookup (f + g) x = lookup g x\n  x \\<in> keys g\n\ngoal (1 subgoal):\n 1. x \\<in> keys (f + g)", "by (metis not_in_keys_iff_lookup_eq_zero)"], ["proof (state)\nthis:\n  x \\<in> keys (f + g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys g \\<subseteq> keys (f + g)\n\ngoal (2 subgoals):\n 1. keys f \\<union> keys g \\<subseteq> keys (f + g)\n 2. keys (f + g) \\<subseteq> keys f \\<union> keys g", "ultimately"], ["proof (chain)\npicking this:\n  keys f \\<subseteq> keys (f + g)\n  keys g \\<subseteq> keys (f + g)", "show \"keys f \\<union> keys g \\<subseteq> keys (f+g)\""], ["proof (prove)\nusing this:\n  keys f \\<subseteq> keys (f + g)\n  keys g \\<subseteq> keys (f + g)\n\ngoal (1 subgoal):\n 1. keys f \\<union> keys g \\<subseteq> keys (f + g)", "by simp"], ["proof (state)\nthis:\n  keys f \\<union> keys g \\<subseteq> keys (f + g)\n\ngoal (1 subgoal):\n 1. keys (f + g) \\<subseteq> keys f \\<union> keys g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. keys (f + g) \\<subseteq> keys f \\<union> keys g", "show \"keys (f + g) \\<subseteq> keys f \\<union> keys g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (f + g) \\<subseteq> keys f \\<union> keys g", "by (simp add: keys_add)"], ["proof (state)\nthis:\n  keys (f + g) \\<subseteq> keys f \\<union> keys g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fun_when:\n\"f 0 = 0 \\<Longrightarrow> f (a when P) = (f a when P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (0::'b) = (0::'a) \\<Longrightarrow> f (a when P) = (f a when P)", "by (simp add: when_def)"], ["", "section \"MPoly extension\""], ["", "lemma coeff_all_0:\"(\\<And>m. coeff p m = 0) \\<Longrightarrow> p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. coeff p m = (0::'a)) \\<Longrightarrow> p = 0", "by (metis aux coeff_def mapping_of_inject zero_mpoly.rep_eq)"], ["", "definition vars::\"'a::zero mpoly \\<Rightarrow> nat set\" where\n  \"vars p = \\<Union> (keys ` keys (mapping_of p))\""], ["", "lemma vars_finite: \"finite (vars p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (vars p)", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (keys ` keys (mapping_of p)))", "by auto"], ["", "lemma vars_monom_single: \"vars (monom (Poly_Mapping.single v k) a) \\<subseteq> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (monom (Poly_Mapping.single v k) a) \\<subseteq> {v}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (monom (Poly_Mapping.single v k) a) \\<Longrightarrow>\n       x \\<in> {v}", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (monom (Poly_Mapping.single v k) a) \\<Longrightarrow>\n       x \\<in> {v}", "assume \"w \\<in> vars (monom (Poly_Mapping.single v k) a)\""], ["proof (state)\nthis:\n  w \\<in> vars (monom (Poly_Mapping.single v k) a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (monom (Poly_Mapping.single v k) a) \\<Longrightarrow>\n       x \\<in> {v}", "then"], ["proof (chain)\npicking this:\n  w \\<in> vars (monom (Poly_Mapping.single v k) a)", "have \"w = v\""], ["proof (prove)\nusing this:\n  w \\<in> vars (monom (Poly_Mapping.single v k) a)\n\ngoal (1 subgoal):\n 1. w = v", "using vars_def"], ["proof (prove)\nusing this:\n  w \\<in> vars (monom (Poly_Mapping.single v k) a)\n  vars ?p = \\<Union> (keys ` keys (mapping_of ?p))\n\ngoal (1 subgoal):\n 1. w = v", "by (metis UN_E lookup_eq_zero_in_keys_contradict lookup_single_not_eq monom.rep_eq)"], ["proof (state)\nthis:\n  w = v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (monom (Poly_Mapping.single v k) a) \\<Longrightarrow>\n       x \\<in> {v}", "then"], ["proof (chain)\npicking this:\n  w = v", "show \"w \\<in> {v}\""], ["proof (prove)\nusing this:\n  w = v\n\ngoal (1 subgoal):\n 1. w \\<in> {v}", "by auto"], ["proof (state)\nthis:\n  w \\<in> {v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_monom_keys:\nassumes \"a\\<noteq>0\"\nshows \"vars (monom m a) = keys m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (monom m a) = keys m", "proof (rule antisym; rule subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> vars (monom m a) \\<Longrightarrow> x \\<in> keys m\n 2. \\<And>x. x \\<in> keys m \\<Longrightarrow> x \\<in> vars (monom m a)", "fix w"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> vars (monom m a) \\<Longrightarrow> x \\<in> keys m\n 2. \\<And>x. x \\<in> keys m \\<Longrightarrow> x \\<in> vars (monom m a)", "assume \"w \\<in> vars (monom m a)\""], ["proof (state)\nthis:\n  w \\<in> vars (monom m a)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> vars (monom m a) \\<Longrightarrow> x \\<in> keys m\n 2. \\<And>x. x \\<in> keys m \\<Longrightarrow> x \\<in> vars (monom m a)", "then"], ["proof (chain)\npicking this:\n  w \\<in> vars (monom m a)", "have \"lookup m w \\<noteq> 0\""], ["proof (prove)\nusing this:\n  w \\<in> vars (monom m a)\n\ngoal (1 subgoal):\n 1. lookup m w \\<noteq> 0", "using vars_def"], ["proof (prove)\nusing this:\n  w \\<in> vars (monom m a)\n  vars ?p = \\<Union> (keys ` keys (mapping_of ?p))\n\ngoal (1 subgoal):\n 1. lookup m w \\<noteq> 0", "by (metis UN_E lookup_eq_zero_in_keys_contradict lookup_single_not_eq monom.rep_eq)"], ["proof (state)\nthis:\n  lookup m w \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> vars (monom m a) \\<Longrightarrow> x \\<in> keys m\n 2. \\<And>x. x \\<in> keys m \\<Longrightarrow> x \\<in> vars (monom m a)", "then"], ["proof (chain)\npicking this:\n  lookup m w \\<noteq> 0", "show \"w \\<in> keys m\""], ["proof (prove)\nusing this:\n  lookup m w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. w \\<in> keys m", "by (meson lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  w \\<in> keys m\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys m \\<Longrightarrow> x \\<in> vars (monom m a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys m \\<Longrightarrow> x \\<in> vars (monom m a)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys m \\<Longrightarrow> x \\<in> vars (monom m a)", "assume \"w \\<in> keys m\""], ["proof (state)\nthis:\n  w \\<in> keys m\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys m \\<Longrightarrow> x \\<in> vars (monom m a)", "then"], ["proof (chain)\npicking this:\n  w \\<in> keys m", "have \"lookup m w \\<noteq> 0\""], ["proof (prove)\nusing this:\n  w \\<in> keys m\n\ngoal (1 subgoal):\n 1. lookup m w \\<noteq> 0", "by (meson lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  lookup m w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys m \\<Longrightarrow> x \\<in> vars (monom m a)", "then"], ["proof (chain)\npicking this:\n  lookup m w \\<noteq> 0", "show \"w \\<in> vars (monom m a)\""], ["proof (prove)\nusing this:\n  lookup m w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. w \\<in> vars (monom m a)", "unfolding vars_def"], ["proof (prove)\nusing this:\n  lookup m w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. w \\<in> \\<Union> (keys ` keys (mapping_of (monom m a)))", "using assms"], ["proof (prove)\nusing this:\n  lookup m w \\<noteq> 0\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. w \\<in> \\<Union> (keys ` keys (mapping_of (monom m a)))", "by (metis UN_iff lookup_not_eq_zero_eq_in_keys lookup_single_eq monom.rep_eq)"], ["proof (state)\nthis:\n  w \\<in> vars (monom m a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_monom_subset:\nshows \"vars (monom m a) \\<subseteq> keys m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (monom m a) \\<subseteq> keys m", "by (cases \"a=0\"; simp add: vars_def vars_monom_keys)"], ["", "lemma vars_monom_single_cases: \"vars (monom (Poly_Mapping.single v k) a) = (if k=0 \\<or> a=0 then {} else {v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "proof(cases \"k=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "assume \"k=0\""], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "then"], ["proof (chain)\npicking this:\n  k = 0", "have \"(Poly_Mapping.single v k) = 0\""], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. Poly_Mapping.single v k = 0", "by simp"], ["proof (state)\nthis:\n  Poly_Mapping.single v k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "then"], ["proof (chain)\npicking this:\n  Poly_Mapping.single v k = 0", "have \"vars (monom (Poly_Mapping.single v k) a) = {}\""], ["proof (prove)\nusing this:\n  Poly_Mapping.single v k = 0\n\ngoal (1 subgoal):\n 1. vars (monom (Poly_Mapping.single v k) a) = {}", "by (metis (mono_tags, lifting) single_zero singleton_inject subset_singletonD vars_monom_single zero_neq_one)"], ["proof (state)\nthis:\n  vars (monom (Poly_Mapping.single v k) a) = {}\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "then"], ["proof (chain)\npicking this:\n  vars (monom (Poly_Mapping.single v k) a) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  vars (monom (Poly_Mapping.single v k) a) = {}\n\ngoal (1 subgoal):\n 1. vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "using \\<open>k=0\\<close>"], ["proof (prove)\nusing this:\n  vars (monom (Poly_Mapping.single v k) a) = {}\n  k = 0\n\ngoal (1 subgoal):\n 1. vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "by auto"], ["proof (state)\nthis:\n  vars (monom (Poly_Mapping.single v k) a) =\n  (if k = 0 \\<or> a = (0::'a) then {} else {v})\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "assume \"k\\<noteq>0\""], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "proof (cases \"a=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<noteq> 0; a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> vars (monom (Poly_Mapping.single v k) a) =\n                      (if k = 0 \\<or> a = (0::'a) then {} else {v})\n 2. \\<lbrakk>k \\<noteq> 0; a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> vars (monom (Poly_Mapping.single v k) a) =\n                      (if k = 0 \\<or> a = (0::'a) then {} else {v})", "assume \"a=0\""], ["proof (state)\nthis:\n  a = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<noteq> 0; a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> vars (monom (Poly_Mapping.single v k) a) =\n                      (if k = 0 \\<or> a = (0::'a) then {} else {v})\n 2. \\<lbrakk>k \\<noteq> 0; a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> vars (monom (Poly_Mapping.single v k) a) =\n                      (if k = 0 \\<or> a = (0::'a) then {} else {v})", "then"], ["proof (chain)\npicking this:\n  a = (0::'a)", "have \"monom (Poly_Mapping.single v k) a = 0\""], ["proof (prove)\nusing this:\n  a = (0::'a)\n\ngoal (1 subgoal):\n 1. monom (Poly_Mapping.single v k) a = 0", "by (metis monom.abs_eq monom_zero single_zero)"], ["proof (state)\nthis:\n  monom (Poly_Mapping.single v k) a = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<noteq> 0; a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> vars (monom (Poly_Mapping.single v k) a) =\n                      (if k = 0 \\<or> a = (0::'a) then {} else {v})\n 2. \\<lbrakk>k \\<noteq> 0; a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> vars (monom (Poly_Mapping.single v k) a) =\n                      (if k = 0 \\<or> a = (0::'a) then {} else {v})", "then"], ["proof (chain)\npicking this:\n  monom (Poly_Mapping.single v k) a = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  monom (Poly_Mapping.single v k) a = 0\n\ngoal (1 subgoal):\n 1. vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "by (metis (mono_tags, hide_lams) \\<open>k \\<noteq> 0\\<close> \\<open>a=0\\<close> monom.abs_eq single_zero singleton_inject subset_singletonD vars_monom_single)"], ["proof (state)\nthis:\n  vars (monom (Poly_Mapping.single v k) a) =\n  (if k = 0 \\<or> a = (0::'a) then {} else {v})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> 0; a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> vars (monom (Poly_Mapping.single v k) a) =\n                      (if k = 0 \\<or> a = (0::'a) then {} else {v})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> 0; a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> vars (monom (Poly_Mapping.single v k) a) =\n                      (if k = 0 \\<or> a = (0::'a) then {} else {v})", "assume \"a\\<noteq>0\""], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> 0; a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> vars (monom (Poly_Mapping.single v k) a) =\n                      (if k = 0 \\<or> a = (0::'a) then {} else {v})", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)", "have \"v \\<in> vars (monom (Poly_Mapping.single v k) a)\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. v \\<in> vars (monom (Poly_Mapping.single v k) a)", "by (simp add: \\<open>k \\<noteq> 0\\<close> vars_def)"], ["proof (state)\nthis:\n  v \\<in> vars (monom (Poly_Mapping.single v k) a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> 0; a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> vars (monom (Poly_Mapping.single v k) a) =\n                      (if k = 0 \\<or> a = (0::'a) then {} else {v})", "then"], ["proof (chain)\npicking this:\n  v \\<in> vars (monom (Poly_Mapping.single v k) a)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> vars (monom (Poly_Mapping.single v k) a)\n\ngoal (1 subgoal):\n 1. vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "using \\<open>a\\<noteq>0\\<close> \\<open>k \\<noteq> 0\\<close> vars_monom_single"], ["proof (prove)\nusing this:\n  v \\<in> vars (monom (Poly_Mapping.single v k) a)\n  a \\<noteq> (0::'a)\n  k \\<noteq> 0\n  vars (monom (Poly_Mapping.single ?v ?k) ?a) \\<subseteq> {?v}\n\ngoal (1 subgoal):\n 1. vars (monom (Poly_Mapping.single v k) a) =\n    (if k = 0 \\<or> a = (0::'a) then {} else {v})", "by fastforce"], ["proof (state)\nthis:\n  vars (monom (Poly_Mapping.single v k) a) =\n  (if k = 0 \\<or> a = (0::'a) then {} else {v})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars (monom (Poly_Mapping.single v k) a) =\n  (if k = 0 \\<or> a = (0::'a) then {} else {v})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_monom:\nassumes \"a\\<noteq>0\"\nshows \"vars (monom m (1::'a::zero_neq_one)) = vars (monom m (a::'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (monom m (1::'a)) = vars (monom m a)", "unfolding vars_monom_keys[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (monom m (1::'a)) = keys m", "using vars_monom_keys[of 1] one_neq_zero"], ["proof (prove)\nusing this:\n  (1::?'b1) \\<noteq> (0::?'b1) \\<Longrightarrow>\n  vars (monom ?m (1::?'b1)) = keys ?m\n  (1::?'a) \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. vars (monom m (1::'a)) = keys m", "by blast"], ["", "lemma vars_add: \"vars (p1 + p2) \\<subseteq> vars p1 \\<union> vars p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p1 + p2) \\<subseteq> vars p1 \\<union> vars p2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p1 + p2) \\<Longrightarrow>\n       x \\<in> vars p1 \\<union> vars p2", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p1 + p2) \\<Longrightarrow>\n       x \\<in> vars p1 \\<union> vars p2", "assume \"w \\<in> vars (p1 + p2)\""], ["proof (state)\nthis:\n  w \\<in> vars (p1 + p2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p1 + p2) \\<Longrightarrow>\n       x \\<in> vars p1 \\<union> vars p2", "then"], ["proof (chain)\npicking this:\n  w \\<in> vars (p1 + p2)", "obtain m where \"w \\<in> keys m\" \"m \\<in> keys (mapping_of (p1 + p2))\""], ["proof (prove)\nusing this:\n  w \\<in> vars (p1 + p2)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>w \\<in> keys m;\n         m \\<in> keys (mapping_of (p1 + p2))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis UN_E vars_def)"], ["proof (state)\nthis:\n  w \\<in> keys m\n  m \\<in> keys (mapping_of (p1 + p2))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p1 + p2) \\<Longrightarrow>\n       x \\<in> vars p1 \\<union> vars p2", "then"], ["proof (chain)\npicking this:\n  w \\<in> keys m\n  m \\<in> keys (mapping_of (p1 + p2))", "have \"m \\<in> keys (mapping_of (p1)) \\<union> keys (mapping_of (p2))\""], ["proof (prove)\nusing this:\n  w \\<in> keys m\n  m \\<in> keys (mapping_of (p1 + p2))\n\ngoal (1 subgoal):\n 1. m \\<in> keys (mapping_of p1) \\<union> keys (mapping_of p2)", "by (metis Poly_Mapping.keys_add plus_mpoly.rep_eq subset_iff)"], ["proof (state)\nthis:\n  m \\<in> keys (mapping_of p1) \\<union> keys (mapping_of p2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p1 + p2) \\<Longrightarrow>\n       x \\<in> vars p1 \\<union> vars p2", "then"], ["proof (chain)\npicking this:\n  m \\<in> keys (mapping_of p1) \\<union> keys (mapping_of p2)", "show \"w \\<in> vars p1 \\<union> vars p2\""], ["proof (prove)\nusing this:\n  m \\<in> keys (mapping_of p1) \\<union> keys (mapping_of p2)\n\ngoal (1 subgoal):\n 1. w \\<in> vars p1 \\<union> vars p2", "using vars_def \\<open>w \\<in> keys m\\<close>"], ["proof (prove)\nusing this:\n  m \\<in> keys (mapping_of p1) \\<union> keys (mapping_of p2)\n  vars ?p = \\<Union> (keys ` keys (mapping_of ?p))\n  w \\<in> keys m\n\ngoal (1 subgoal):\n 1. w \\<in> vars p1 \\<union> vars p2", "by fastforce"], ["proof (state)\nthis:\n  w \\<in> vars p1 \\<union> vars p2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_mult: \"vars (p*q) \\<subseteq> vars p \\<union> vars q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p * q) \\<subseteq> vars p \\<union> vars q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p * q) \\<Longrightarrow> x \\<in> vars p \\<union> vars q", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p * q) \\<Longrightarrow> x \\<in> vars p \\<union> vars q", "assume \"x\\<in>vars (p*q)\""], ["proof (state)\nthis:\n  x \\<in> vars (p * q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p * q) \\<Longrightarrow> x \\<in> vars p \\<union> vars q", "then"], ["proof (chain)\npicking this:\n  x \\<in> vars (p * q)", "obtain m where \"m\\<in>keys (mapping_of (p*q))\" \"x\\<in>keys m\""], ["proof (prove)\nusing this:\n  x \\<in> vars (p * q)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<in> keys (mapping_of (p * q)); x \\<in> keys m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using vars_def"], ["proof (prove)\nusing this:\n  x \\<in> vars (p * q)\n  vars ?p = \\<Union> (keys ` keys (mapping_of ?p))\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<in> keys (mapping_of (p * q)); x \\<in> keys m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m \\<in> keys (mapping_of (p * q))\n  x \\<in> keys m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p * q) \\<Longrightarrow> x \\<in> vars p \\<union> vars q", "then"], ["proof (chain)\npicking this:\n  m \\<in> keys (mapping_of (p * q))\n  x \\<in> keys m", "have \"m\\<in>keys (mapping_of p * mapping_of q)\""], ["proof (prove)\nusing this:\n  m \\<in> keys (mapping_of (p * q))\n  x \\<in> keys m\n\ngoal (1 subgoal):\n 1. m \\<in> keys (mapping_of p * mapping_of q)", "by (simp add: times_mpoly.rep_eq)"], ["proof (state)\nthis:\n  m \\<in> keys (mapping_of p * mapping_of q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p * q) \\<Longrightarrow> x \\<in> vars p \\<union> vars q", "then"], ["proof (chain)\npicking this:\n  m \\<in> keys (mapping_of p * mapping_of q)", "obtain a b where \"m=a + b\" \"a \\<in> keys (mapping_of p)\" \"b \\<in> keys (mapping_of q)\""], ["proof (prove)\nusing this:\n  m \\<in> keys (mapping_of p * mapping_of q)\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>m = a + b; a \\<in> keys (mapping_of p);\n         b \\<in> keys (mapping_of q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using keys_mult"], ["proof (prove)\nusing this:\n  m \\<in> keys (mapping_of p * mapping_of q)\n  keys (?f * ?g)\n  \\<subseteq> {a + b |a b. a \\<in> keys ?f \\<and> b \\<in> keys ?g}\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>m = a + b; a \\<in> keys (mapping_of p);\n         b \\<in> keys (mapping_of q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m = a + b\n  a \\<in> keys (mapping_of p)\n  b \\<in> keys (mapping_of q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p * q) \\<Longrightarrow> x \\<in> vars p \\<union> vars q", "then"], ["proof (chain)\npicking this:\n  m = a + b\n  a \\<in> keys (mapping_of p)\n  b \\<in> keys (mapping_of q)", "have \"x \\<in> keys a \\<union> keys b\""], ["proof (prove)\nusing this:\n  m = a + b\n  a \\<in> keys (mapping_of p)\n  b \\<in> keys (mapping_of q)\n\ngoal (1 subgoal):\n 1. x \\<in> keys a \\<union> keys b", "using Poly_Mapping.keys_add \\<open>x \\<in> keys m\\<close>"], ["proof (prove)\nusing this:\n  m = a + b\n  a \\<in> keys (mapping_of p)\n  b \\<in> keys (mapping_of q)\n  keys (?f + ?g) \\<subseteq> keys ?f \\<union> keys ?g\n  x \\<in> keys m\n\ngoal (1 subgoal):\n 1. x \\<in> keys a \\<union> keys b", "by force"], ["proof (state)\nthis:\n  x \\<in> keys a \\<union> keys b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (p * q) \\<Longrightarrow> x \\<in> vars p \\<union> vars q", "then"], ["proof (chain)\npicking this:\n  x \\<in> keys a \\<union> keys b", "show \"x \\<in> vars p \\<union> vars q\""], ["proof (prove)\nusing this:\n  x \\<in> keys a \\<union> keys b\n\ngoal (1 subgoal):\n 1. x \\<in> vars p \\<union> vars q", "unfolding vars_def"], ["proof (prove)\nusing this:\n  x \\<in> keys a \\<union> keys b\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (keys ` keys (mapping_of p)) \\<union>\n            \\<Union> (keys ` keys (mapping_of q))", "using \\<open>a \\<in> keys (mapping_of p)\\<close> \\<open>b \\<in> keys (mapping_of q)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> keys a \\<union> keys b\n  a \\<in> keys (mapping_of p)\n  b \\<in> keys (mapping_of q)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (keys ` keys (mapping_of p)) \\<union>\n            \\<Union> (keys ` keys (mapping_of q))", "by blast"], ["proof (state)\nthis:\n  x \\<in> vars p \\<union> vars q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_add_monom:\nassumes \"p2 = monom m a\" \"m \\<notin> keys (mapping_of p1)\"\nshows \"vars (p1 + p2) = vars p1 \\<union> vars p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p1 + p2) = vars p1 \\<union> vars p2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vars (p1 + p2) = vars p1 \\<union> vars p2", "have \"keys (mapping_of p2) \\<subseteq> {m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapping_of p2) \\<subseteq> {m}", "using monom_def keys_single assms"], ["proof (prove)\nusing this:\n  monom \\<equiv> map_fun id (map_fun id MPoly) Poly_Mapping.single\n  keys (Poly_Mapping.single ?k ?v) = (if ?v = (0::?'b) then {} else {?k})\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n\ngoal (1 subgoal):\n 1. keys (mapping_of p2) \\<subseteq> {m}", "by auto"], ["proof (state)\nthis:\n  keys (mapping_of p2) \\<subseteq> {m}\n\ngoal (1 subgoal):\n 1. vars (p1 + p2) = vars p1 \\<union> vars p2", "have \"keys (mapping_of (p1+p2)) = keys (mapping_of p1) \\<union> keys (mapping_of p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapping_of (p1 + p2)) =\n    keys (mapping_of p1) \\<union> keys (mapping_of p2)", "using keys_add"], ["proof (prove)\nusing this:\n  keys ?f \\<inter> keys ?g = {} \\<Longrightarrow>\n  keys ?f \\<union> keys ?g = keys (?f + ?g)\n\ngoal (1 subgoal):\n 1. keys (mapping_of (p1 + p2)) =\n    keys (mapping_of p1) \\<union> keys (mapping_of p2)", "by (metis Int_insert_right_if0 \\<open>keys (mapping_of p2) \\<subseteq> {m}\\<close> assms(2) inf_bot_right plus_mpoly.rep_eq subset_singletonD)"], ["proof (state)\nthis:\n  keys (mapping_of (p1 + p2)) =\n  keys (mapping_of p1) \\<union> keys (mapping_of p2)\n\ngoal (1 subgoal):\n 1. vars (p1 + p2) = vars p1 \\<union> vars p2", "then"], ["proof (chain)\npicking this:\n  keys (mapping_of (p1 + p2)) =\n  keys (mapping_of p1) \\<union> keys (mapping_of p2)", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (mapping_of (p1 + p2)) =\n  keys (mapping_of p1) \\<union> keys (mapping_of p2)\n\ngoal (1 subgoal):\n 1. vars (p1 + p2) = vars p1 \\<union> vars p2", "unfolding vars_def"], ["proof (prove)\nusing this:\n  keys (mapping_of (p1 + p2)) =\n  keys (mapping_of p1) \\<union> keys (mapping_of p2)\n\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of (p1 + p2))) =\n    \\<Union> (keys ` keys (mapping_of p1)) \\<union>\n    \\<Union> (keys ` keys (mapping_of p2))", "by simp"], ["proof (state)\nthis:\n  vars (p1 + p2) = vars p1 \\<union> vars p2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_setsum: \"finite S \\<Longrightarrow> vars (\\<Sum>m\\<in>S. f m) \\<subseteq> (\\<Union>m\\<in>S. vars (f m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    vars (sum f S) \\<subseteq> (\\<Union>m\\<in>S. vars (f m))", "proof (induction S rule:finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. vars (sum f {}) \\<subseteq> (\\<Union>m\\<in>{}. vars (f m))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        vars (sum f F) \\<subseteq> (\\<Union>m\\<in>F. vars (f m))\\<rbrakk>\n       \\<Longrightarrow> vars (sum f (insert x F))\n                         \\<subseteq> (\\<Union>m\\<in>insert x F. vars (f m))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. vars (sum f {}) \\<subseteq> (\\<Union>m\\<in>{}. vars (f m))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        vars (sum f F) \\<subseteq> (\\<Union>m\\<in>F. vars (f m))\\<rbrakk>\n       \\<Longrightarrow> vars (sum f (insert x F))\n                         \\<subseteq> (\\<Union>m\\<in>insert x F. vars (f m))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (sum f {}) \\<subseteq> (\\<Union>m\\<in>{}. vars (f m))", "by (metis UN_empty eq_iff monom_zero sum.empty single_zero vars_monom_single_cases)"], ["proof (state)\nthis:\n  vars (sum f {}) \\<subseteq> (\\<Union>m\\<in>{}. vars (f m))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        vars (sum f F) \\<subseteq> (\\<Union>m\\<in>F. vars (f m))\\<rbrakk>\n       \\<Longrightarrow> vars (sum f (insert x F))\n                         \\<subseteq> (\\<Union>m\\<in>insert x F. vars (f m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        vars (sum f F) \\<subseteq> (\\<Union>m\\<in>F. vars (f m))\\<rbrakk>\n       \\<Longrightarrow> vars (sum f (insert x F))\n                         \\<subseteq> (\\<Union>m\\<in>insert x F. vars (f m))", "case (insert s S)"], ["proof (state)\nthis:\n  finite S\n  s \\<notin> S\n  vars (sum f S) \\<subseteq> (\\<Union>m\\<in>S. vars (f m))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        vars (sum f F) \\<subseteq> (\\<Union>m\\<in>F. vars (f m))\\<rbrakk>\n       \\<Longrightarrow> vars (sum f (insert x F))\n                         \\<subseteq> (\\<Union>m\\<in>insert x F. vars (f m))", "then"], ["proof (chain)\npicking this:\n  finite S\n  s \\<notin> S\n  vars (sum f S) \\<subseteq> (\\<Union>m\\<in>S. vars (f m))", "have \"vars (sum f (insert s S)) = vars (f s + sum f S)\""], ["proof (prove)\nusing this:\n  finite S\n  s \\<notin> S\n  vars (sum f S) \\<subseteq> (\\<Union>m\\<in>S. vars (f m))\n\ngoal (1 subgoal):\n 1. vars (sum f (insert s S)) = vars (f s + sum f S)", "by (metis sum.insert)"], ["proof (state)\nthis:\n  vars (sum f (insert s S)) = vars (f s + sum f S)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        vars (sum f F) \\<subseteq> (\\<Union>m\\<in>F. vars (f m))\\<rbrakk>\n       \\<Longrightarrow> vars (sum f (insert x F))\n                         \\<subseteq> (\\<Union>m\\<in>insert x F. vars (f m))", "also"], ["proof (state)\nthis:\n  vars (sum f (insert s S)) = vars (f s + sum f S)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        vars (sum f F) \\<subseteq> (\\<Union>m\\<in>F. vars (f m))\\<rbrakk>\n       \\<Longrightarrow> vars (sum f (insert x F))\n                         \\<subseteq> (\\<Union>m\\<in>insert x F. vars (f m))", "have \"... \\<subseteq> vars (f s) \\<union> vars (sum f S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (f s + sum f S) \\<subseteq> vars (f s) \\<union> vars (sum f S)", "by (simp add: vars_add)"], ["proof (state)\nthis:\n  vars (f s + sum f S) \\<subseteq> vars (f s) \\<union> vars (sum f S)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        vars (sum f F) \\<subseteq> (\\<Union>m\\<in>F. vars (f m))\\<rbrakk>\n       \\<Longrightarrow> vars (sum f (insert x F))\n                         \\<subseteq> (\\<Union>m\\<in>insert x F. vars (f m))", "also"], ["proof (state)\nthis:\n  vars (f s + sum f S) \\<subseteq> vars (f s) \\<union> vars (sum f S)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        vars (sum f F) \\<subseteq> (\\<Union>m\\<in>F. vars (f m))\\<rbrakk>\n       \\<Longrightarrow> vars (sum f (insert x F))\n                         \\<subseteq> (\\<Union>m\\<in>insert x F. vars (f m))", "have \"... \\<subseteq> (\\<Union>m\\<in>insert s S. vars (f m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (f s) \\<union> vars (sum f S)\n    \\<subseteq> (\\<Union>m\\<in>insert s S. vars (f m))", "using insert.IH"], ["proof (prove)\nusing this:\n  vars (sum f S) \\<subseteq> (\\<Union>m\\<in>S. vars (f m))\n\ngoal (1 subgoal):\n 1. vars (f s) \\<union> vars (sum f S)\n    \\<subseteq> (\\<Union>m\\<in>insert s S. vars (f m))", "by auto"], ["proof (state)\nthis:\n  vars (f s) \\<union> vars (sum f S)\n  \\<subseteq> (\\<Union>m\\<in>insert s S. vars (f m))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        vars (sum f F) \\<subseteq> (\\<Union>m\\<in>F. vars (f m))\\<rbrakk>\n       \\<Longrightarrow> vars (sum f (insert x F))\n                         \\<subseteq> (\\<Union>m\\<in>insert x F. vars (f m))", "finally"], ["proof (chain)\npicking this:\n  vars (sum f (insert s S))\n  \\<subseteq> (\\<Union>m\\<in>insert s S. vars (f m))", "show ?case"], ["proof (prove)\nusing this:\n  vars (sum f (insert s S))\n  \\<subseteq> (\\<Union>m\\<in>insert s S. vars (f m))\n\ngoal (1 subgoal):\n 1. vars (sum f (insert s S))\n    \\<subseteq> (\\<Union>m\\<in>insert s S. vars (f m))", "by metis"], ["proof (state)\nthis:\n  vars (sum f (insert s S))\n  \\<subseteq> (\\<Union>m\\<in>insert s S. vars (f m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_monom: \"coeff (monom m a) m' = (a when m'=m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (monom m a) m' = (a when m' = m)", "by (simp add: coeff_def lookup_single_not_eq when_def)"], ["", "lemma coeff_add: \"coeff p m + coeff q m = coeff (p+q) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p m + coeff q m = coeff (p + q) m", "by (simp add: coeff_def lookup_add plus_mpoly.rep_eq)"], ["", "lemma coeff_eq: \"coeff p = coeff q \\<longleftrightarrow> p=q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (coeff p = coeff q) = (p = q)", "by (simp add: coeff_def lookup_inject mapping_of_inject)"], ["", "lemma coeff_monom_mult: \"coeff ((monom m' a)  * q) (m' + m)  = a * coeff q m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (monom m' a * q) (m' + m) = a * coeff q m", "unfolding coeff_def times_mpoly.rep_eq lookup_mult mapping_of_monom lookup_single when_mult\n  Sum_any_when_equal' Groups.cancel_semigroup_add_class.add_left_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. a * lookup (mapping_of q) m = a * lookup (mapping_of q) m", "by metis"], ["", "lemma one_term_is_monomial:\nassumes \"card (keys (mapping_of p)) \\<le> 1\"\nobtains m where \"p = monom m (coeff p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        p = monom m (coeff p m) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"keys (mapping_of p) = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m. p = monom m (coeff p m) \\<Longrightarrow> thesis;\n     keys (mapping_of p) = {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>m. p = monom m (coeff p m) \\<Longrightarrow> thesis;\n     keys (mapping_of p) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  keys (mapping_of p) = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m. p = monom m (coeff p m) \\<Longrightarrow> thesis;\n     keys (mapping_of p) = {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>m. p = monom m (coeff p m) \\<Longrightarrow> thesis;\n     keys (mapping_of p) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  keys (mapping_of p) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (mapping_of p) = {}\n\ngoal (1 subgoal):\n 1. thesis", "using aux coeff_def empty_iff mapping_of_inject mapping_of_monom not_in_keys_iff_lookup_eq_zero single_zero"], ["proof (prove)\nusing this:\n  keys (mapping_of p) = {}\n  (lookup ?f = (\\<lambda>_. 0::?'b)) = (?f = 0)\n  coeff ?p = lookup (mapping_of ?p)\n  (?c \\<in> {}) = False\n  (mapping_of ?x = mapping_of ?y) = (?x = ?y)\n  mapping_of (monom ?m ?a) = Poly_Mapping.single ?m ?a\n  (?k \\<notin> keys ?f) = (lookup ?f ?k = (0::?'b))\n  Poly_Mapping.single ?k (0::?'b) = 0\n\ngoal (1 subgoal):\n 1. thesis", "by (metis (no_types) that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m. p = monom m (coeff p m) \\<Longrightarrow> thesis;\n     keys (mapping_of p) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m. p = monom m (coeff p m) \\<Longrightarrow> thesis;\n     keys (mapping_of p) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  keys (mapping_of p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m. p = monom m (coeff p m) \\<Longrightarrow> thesis;\n     keys (mapping_of p) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  keys (mapping_of p) \\<noteq> {}", "obtain m where \"keys (mapping_of p) = {m}\""], ["proof (prove)\nusing this:\n  keys (mapping_of p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        keys (mapping_of p) = {m} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  keys (mapping_of p) \\<noteq> {}\n  card (keys (mapping_of p)) \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        keys (mapping_of p) = {m} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis One_nat_def Suc_leI antisym card_0_eq card_eq_SucD finite_keys neq0_conv)"], ["proof (state)\nthis:\n  keys (mapping_of p) = {m}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m. p = monom m (coeff p m) \\<Longrightarrow> thesis;\n     keys (mapping_of p) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"p = monom m (coeff p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = monom m (coeff p m)", "unfolding mapping_of_inject[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping_of p = mapping_of (monom m (coeff p m))", "by (rule poly_mapping_eqI, metis (no_types, lifting) \\<open>keys (mapping_of p) = {m}\\<close>\n    coeff_def keys_single lookup_single_eq  mapping_of_monom not_in_keys_iff_lookup_eq_zero\n    singletonD)"], ["proof (state)\nthis:\n  p = monom m (coeff p m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m. p = monom m (coeff p m) \\<Longrightarrow> thesis;\n     keys (mapping_of p) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  p = monom m (coeff p m)", "show ?thesis"], ["proof (prove)\nusing this:\n  p = monom m (coeff p m)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "(* remove_term is eventually unnessecary *)"], ["", "definition remove_term::\"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a::zero mpoly \\<Rightarrow> 'a mpoly\" where\n  \"remove_term m0 p = MPoly (Abs_poly_mapping (\\<lambda>m. coeff p m when m \\<noteq> m0))\""], ["", "lemma remove_term_coeff: \"coeff (remove_term m0 p) m = (coeff p m when m \\<noteq> m0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (remove_term m0 p) m = (coeff p m when m \\<noteq> m0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (remove_term m0 p) m = (coeff p m when m \\<noteq> m0)", "have \"{m. (coeff p m when m \\<noteq> m0) \\<noteq> 0} \\<subseteq> {m. coeff p m \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m. (coeff p m when m \\<noteq> m0) \\<noteq> (0::'a)}\n    \\<subseteq> {m. coeff p m \\<noteq> (0::'a)}", "by auto"], ["proof (state)\nthis:\n  {m. (coeff p m when m \\<noteq> m0) \\<noteq> (0::'a)}\n  \\<subseteq> {m. coeff p m \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. coeff (remove_term m0 p) m = (coeff p m when m \\<noteq> m0)", "then"], ["proof (chain)\npicking this:\n  {m. (coeff p m when m \\<noteq> m0) \\<noteq> (0::'a)}\n  \\<subseteq> {m. coeff p m \\<noteq> (0::'a)}", "have \"finite {m. (coeff p m when m \\<noteq> m0) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  {m. (coeff p m when m \\<noteq> m0) \\<noteq> (0::'a)}\n  \\<subseteq> {m. coeff p m \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. finite {m. (coeff p m when m \\<noteq> m0) \\<noteq> (0::'a)}", "unfolding coeff_def"], ["proof (prove)\nusing this:\n  {m. (lookup (mapping_of p) m when m \\<noteq> m0) \\<noteq> (0::'a)}\n  \\<subseteq> {m. lookup (mapping_of p) m \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. finite\n     {m. (lookup (mapping_of p) m when m \\<noteq> m0) \\<noteq> (0::'a)}", "using finite_subset"], ["proof (prove)\nusing this:\n  {m. (lookup (mapping_of p) m when m \\<noteq> m0) \\<noteq> (0::'a)}\n  \\<subseteq> {m. lookup (mapping_of p) m \\<noteq> (0::'a)}\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite\n     {m. (lookup (mapping_of p) m when m \\<noteq> m0) \\<noteq> (0::'a)}", "by auto"], ["proof (state)\nthis:\n  finite {m. (coeff p m when m \\<noteq> m0) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. coeff (remove_term m0 p) m = (coeff p m when m \\<noteq> m0)", "then"], ["proof (chain)\npicking this:\n  finite {m. (coeff p m when m \\<noteq> m0) \\<noteq> (0::'a)}", "have \"lookup (Abs_poly_mapping (\\<lambda>m. coeff p m when m \\<noteq> m0)) m = (coeff p m when m \\<noteq> m0)\""], ["proof (prove)\nusing this:\n  finite {m. (coeff p m when m \\<noteq> m0) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping (\\<lambda>m. coeff p m when m \\<noteq> m0)) m =\n    (coeff p m when m \\<noteq> m0)", "using lookup_Abs_poly_mapping"], ["proof (prove)\nusing this:\n  finite {m. (coeff p m when m \\<noteq> m0) \\<noteq> (0::'a)}\n  finite {x. ?f x \\<noteq> (0::?'b)} \\<Longrightarrow>\n  lookup (Abs_poly_mapping ?f) = ?f\n\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping (\\<lambda>m. coeff p m when m \\<noteq> m0)) m =\n    (coeff p m when m \\<noteq> m0)", "by fastforce"], ["proof (state)\nthis:\n  lookup (Abs_poly_mapping (\\<lambda>m. coeff p m when m \\<noteq> m0)) m =\n  (coeff p m when m \\<noteq> m0)\n\ngoal (1 subgoal):\n 1. coeff (remove_term m0 p) m = (coeff p m when m \\<noteq> m0)", "then"], ["proof (chain)\npicking this:\n  lookup (Abs_poly_mapping (\\<lambda>m. coeff p m when m \\<noteq> m0)) m =\n  (coeff p m when m \\<noteq> m0)", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (Abs_poly_mapping (\\<lambda>m. coeff p m when m \\<noteq> m0)) m =\n  (coeff p m when m \\<noteq> m0)\n\ngoal (1 subgoal):\n 1. coeff (remove_term m0 p) m = (coeff p m when m \\<noteq> m0)", "unfolding remove_term_def"], ["proof (prove)\nusing this:\n  lookup (Abs_poly_mapping (\\<lambda>m. coeff p m when m \\<noteq> m0)) m =\n  (coeff p m when m \\<noteq> m0)\n\ngoal (1 subgoal):\n 1. coeff\n     (MPoly (Abs_poly_mapping (\\<lambda>m. coeff p m when m \\<noteq> m0)))\n     m =\n    (coeff p m when m \\<noteq> m0)", "using coeff_def"], ["proof (prove)\nusing this:\n  lookup (Abs_poly_mapping (\\<lambda>m. coeff p m when m \\<noteq> m0)) m =\n  (coeff p m when m \\<noteq> m0)\n  coeff ?p = lookup (mapping_of ?p)\n\ngoal (1 subgoal):\n 1. coeff\n     (MPoly (Abs_poly_mapping (\\<lambda>m. coeff p m when m \\<noteq> m0)))\n     m =\n    (coeff p m when m \\<noteq> m0)", "by (metis (mono_tags, lifting) Quotient_mpoly Quotient_rep_abs_fold_unmap)"], ["proof (state)\nthis:\n  coeff (remove_term m0 p) m = (coeff p m when m \\<noteq> m0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_keys: \"m \\<in> keys (mapping_of p) \\<longleftrightarrow> coeff p m \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<in> keys (mapping_of p)) = (coeff p m \\<noteq> (0::'a))", "by (simp add: coeff_def in_keys_iff)"], ["", "lemma remove_term_keys:\nshows \"keys (mapping_of p) - {m} = keys (mapping_of (remove_term m p))\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapping_of p) - {m} = keys (mapping_of (remove_term m p))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (mapping_of p) - {m}\n    \\<subseteq> keys (mapping_of (remove_term m p))\n 2. keys (mapping_of (remove_term m p))\n    \\<subseteq> keys (mapping_of p) - {m}", "show \"?A \\<subseteq> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapping_of p) - {m}\n    \\<subseteq> keys (mapping_of (remove_term m p))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (mapping_of p) - {m} \\<Longrightarrow>\n       x \\<in> keys (mapping_of (remove_term m p))", "fix m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (mapping_of p) - {m} \\<Longrightarrow>\n       x \\<in> keys (mapping_of (remove_term m p))", "assume \"m'\\<in>?A\""], ["proof (state)\nthis:\n  m' \\<in> keys (mapping_of p) - {m}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (mapping_of p) - {m} \\<Longrightarrow>\n       x \\<in> keys (mapping_of (remove_term m p))", "then"], ["proof (chain)\npicking this:\n  m' \\<in> keys (mapping_of p) - {m}", "show \"m' \\<in> ?B\""], ["proof (prove)\nusing this:\n  m' \\<in> keys (mapping_of p) - {m}\n\ngoal (1 subgoal):\n 1. m' \\<in> keys (mapping_of (remove_term m p))", "by (simp add: coeff_keys remove_term_coeff)"], ["proof (state)\nthis:\n  m' \\<in> keys (mapping_of (remove_term m p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (mapping_of p) - {m} \\<subseteq> keys (mapping_of (remove_term m p))\n\ngoal (1 subgoal):\n 1. keys (mapping_of (remove_term m p))\n    \\<subseteq> keys (mapping_of p) - {m}", "show \"?B \\<subseteq> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapping_of (remove_term m p))\n    \\<subseteq> keys (mapping_of p) - {m}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (mapping_of (remove_term m p)) \\<Longrightarrow>\n       x \\<in> keys (mapping_of p) - {m}", "fix m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (mapping_of (remove_term m p)) \\<Longrightarrow>\n       x \\<in> keys (mapping_of p) - {m}", "assume \"m'\\<in> ?B\""], ["proof (state)\nthis:\n  m' \\<in> keys (mapping_of (remove_term m p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (mapping_of (remove_term m p)) \\<Longrightarrow>\n       x \\<in> keys (mapping_of p) - {m}", "then"], ["proof (chain)\npicking this:\n  m' \\<in> keys (mapping_of (remove_term m p))", "show \"m' \\<in> ?A\""], ["proof (prove)\nusing this:\n  m' \\<in> keys (mapping_of (remove_term m p))\n\ngoal (1 subgoal):\n 1. m' \\<in> keys (mapping_of p) - {m}", "by (simp add: coeff_keys remove_term_coeff)"], ["proof (state)\nthis:\n  m' \\<in> keys (mapping_of p) - {m}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (mapping_of (remove_term m p)) \\<subseteq> keys (mapping_of p) - {m}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_term_sum: \"remove_term m p + monom m (coeff p m) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_term m p + monom m (coeff p m) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. remove_term m p + monom m (coeff p m) = p", "have \"coeff p = (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + ((coeff p m) when m'=m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p =\n    (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))", "unfolding when_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p =\n    (\\<lambda>m'.\n        (if m' \\<noteq> m then coeff p m' else (0::'a)) +\n        (if m' = m then coeff p m else (0::'a)))", "by fastforce"], ["proof (state)\nthis:\n  coeff p =\n  (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))\n\ngoal (1 subgoal):\n 1. remove_term m p + monom m (coeff p m) = p", "moreover"], ["proof (state)\nthis:\n  coeff p =\n  (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))\n\ngoal (1 subgoal):\n 1. remove_term m p + monom m (coeff p m) = p", "have \"coeff (remove_term m p + monom m (coeff p m)) = ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (remove_term m p + monom m (coeff p m)) =\n    (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))", "using remove_term_coeff coeff_monom coeff_add"], ["proof (prove)\nusing this:\n  coeff (remove_term ?m0.0 ?p) ?m = (coeff ?p ?m when ?m \\<noteq> ?m0.0)\n  coeff (monom ?m ?a) ?m' = (?a when ?m' = ?m)\n  coeff ?p ?m + coeff ?q ?m = coeff (?p + ?q) ?m\n\ngoal (1 subgoal):\n 1. coeff (remove_term m p + monom m (coeff p m)) =\n    (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))", "by (metis (no_types))"], ["proof (state)\nthis:\n  coeff (remove_term m p + monom m (coeff p m)) =\n  (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))\n\ngoal (1 subgoal):\n 1. remove_term m p + monom m (coeff p m) = p", "ultimately"], ["proof (chain)\npicking this:\n  coeff p =\n  (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))\n  coeff (remove_term m p + monom m (coeff p m)) =\n  (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff p =\n  (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))\n  coeff (remove_term m p + monom m (coeff p m)) =\n  (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))\n\ngoal (1 subgoal):\n 1. remove_term m p + monom m (coeff p m) = p", "using coeff_eq"], ["proof (prove)\nusing this:\n  coeff p =\n  (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))\n  coeff (remove_term m p + monom m (coeff p m)) =\n  (\\<lambda>m'. (coeff p m' when m' \\<noteq> m) + (coeff p m when m' = m))\n  (coeff ?p = coeff ?q) = (?p = ?q)\n\ngoal (1 subgoal):\n 1. remove_term m p + monom m (coeff p m) = p", "by auto"], ["proof (state)\nthis:\n  remove_term m p + monom m (coeff p m) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mpoly_induct [case_names monom sum]:\nassumes monom:\"\\<And>m a. P (monom m a)\"\nand sum:\"(\\<And>p1 p2 m a. P p1 \\<Longrightarrow> P p2 \\<Longrightarrow> p2 = (monom m a) \\<Longrightarrow> m \\<notin> keys (mapping_of p1) \\<Longrightarrow> P (p1+p2))\"\nshows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "using assms"], ["proof (prove)\nusing this:\n  P (monom ?m ?a)\n  \\<lbrakk>P ?p1.0; P ?p2.0; ?p2.0 = monom ?m ?a;\n   ?m \\<notin> keys (mapping_of ?p1.0)\\<rbrakk>\n  \\<Longrightarrow> P (?p1.0 + ?p2.0)\n\ngoal (1 subgoal):\n 1. P p", "using poly_mapping_induct[of \"\\<lambda>p :: (nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a. P (MPoly p)\"] MPoly_induct monom.abs_eq plus_mpoly.abs_eq"], ["proof (prove)\nusing this:\n  P (monom ?m ?a)\n  \\<lbrakk>P ?p1.0; P ?p2.0; ?p2.0 = monom ?m ?a;\n   ?m \\<notin> keys (mapping_of ?p1.0)\\<rbrakk>\n  \\<Longrightarrow> P (?p1.0 + ?p2.0)\n  \\<lbrakk>\\<And>k v. P (MPoly (Poly_Mapping.single k v));\n   \\<And>f g k v.\n      \\<lbrakk>P (MPoly f); P (MPoly g); g = Poly_Mapping.single k v;\n       k \\<notin> keys f\\<rbrakk>\n      \\<Longrightarrow> P (MPoly (f + g))\\<rbrakk>\n  \\<Longrightarrow> P (MPoly ?f)\n  (\\<And>y. y \\<in> UNIV \\<Longrightarrow> ?P (MPoly y)) \\<Longrightarrow>\n  ?P ?x\n  monom ?xa ?x = MPoly (Poly_Mapping.single ?xa ?x)\n  MPoly ?xa + MPoly ?x = MPoly (?xa + ?x)\n\ngoal (1 subgoal):\n 1. P p", "by (metis (no_types) MPoly_inverse UNIV_I)"], ["", "lemma monom_pow:\"monom (Poly_Mapping.single v n0) a ^ n = monom (Poly_Mapping.single v (n0*n)) (a ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (Poly_Mapping.single v n0) a ^ n =\n    monom (Poly_Mapping.single v (n0 * n)) (a ^ n)", "apply (induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. monom (Poly_Mapping.single v n0) a ^ 0 =\n    monom (Poly_Mapping.single v (n0 * 0)) (a ^ 0)\n 2. \\<And>n.\n       monom (Poly_Mapping.single v n0) a ^ n =\n       monom (Poly_Mapping.single v (n0 * n)) (a ^ n) \\<Longrightarrow>\n       monom (Poly_Mapping.single v n0) a ^ Suc n =\n       monom (Poly_Mapping.single v (n0 * Suc n)) (a ^ Suc n)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       monom (Poly_Mapping.single v n0) a ^ n =\n       monom (Poly_Mapping.single v (n0 * n)) (a ^ n) \\<Longrightarrow>\n       monom (Poly_Mapping.single v n0) a *\n       monom (Poly_Mapping.single v (n0 * n)) (a ^ n) =\n       monom (Poly_Mapping.single v (n0 + n0 * n)) (a * a ^ n)", "by (metis (no_types, lifting) mult_monom single_add)"], ["", "lemma insertion_fun_single: \"insertion_fun f (\\<lambda>m. (a when (Poly_Mapping.single (v::nat) (n::nat)) = m)) = a * f v ^ n\" (is \"?i = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * f v ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * f v ^ n", "have setsum_single:\"\\<And> a f. (\\<Sum>m\\<in>{a}. f m) = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a f. sum f {a} = f a", "by (metis add.right_neutral empty_Diff finite.emptyI sum.empty sum.insert_remove)"], ["proof (state)\nthis:\n  sum ?f {?a} = ?f ?a\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * f v ^ n", "have 1:\"?i = (\\<Sum>m. (a when Poly_Mapping.single v n = m) * (\\<Prod>v. f v ^ lookup m v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    (\\<Sum>m. (a when Poly_Mapping.single v n = m) *\n              (\\<Prod>v. f v ^ lookup m v))", "unfolding insertion_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. (a when Poly_Mapping.single v n = m) *\n              (\\<Prod>v. f v ^ lookup m v)) =\n    (\\<Sum>m. (a when Poly_Mapping.single v n = m) *\n              (\\<Prod>v. f v ^ lookup m v))", "by metis"], ["proof (state)\nthis:\n  insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n  (\\<Sum>m. (a when Poly_Mapping.single v n = m) *\n            (\\<Prod>v. f v ^ lookup m v))\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * f v ^ n", "have \"\\<forall>m. m \\<noteq> Poly_Mapping.single v n \\<longrightarrow> (a when Poly_Mapping.single v n = m) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m.\n       m \\<noteq> Poly_Mapping.single v n \\<longrightarrow>\n       (a when Poly_Mapping.single v n = m) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  \\<forall>m.\n     m \\<noteq> Poly_Mapping.single v n \\<longrightarrow>\n     (a when Poly_Mapping.single v n = m) = (0::'a)\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * f v ^ n", "have \"(\\<Sum>m\\<in>{Poly_Mapping.single v n}. (a when Poly_Mapping.single v n = m) * (\\<Prod>v. f v ^ lookup m v)) = ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>{Poly_Mapping.single v n}.\n       (a when Poly_Mapping.single v n = m) *\n       (\\<Prod>v. f v ^ lookup m v)) =\n    insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m)", "unfolding 1 when_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>{Poly_Mapping.single v n}.\n       a * (\\<Prod>v. f v ^ lookup m v) when Poly_Mapping.single v n = m) =\n    (\\<Sum>m. a * (\\<Prod>v. f v ^ lookup m v) when\n              Poly_Mapping.single v n = m)", "unfolding when_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>{Poly_Mapping.single v n}.\n       if Poly_Mapping.single v n = m then a * (\\<Prod>v. f v ^ lookup m v)\n       else (0::'a)) =\n    (\\<Sum>m. if Poly_Mapping.single v n = m\n              then a * (\\<Prod>v. f v ^ lookup m v) else (0::'a))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>{Poly_Mapping.single v n}.\n     (a when Poly_Mapping.single v n = m) * (\\<Prod>v. f v ^ lookup m v)) =\n  insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m)\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * f v ^ n", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>m\\<in>{Poly_Mapping.single v n}.\n     (a when Poly_Mapping.single v n = m) * (\\<Prod>v. f v ^ lookup m v)) =\n  insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m)", "have 2:\"?i = a * (\\<Prod>va. f va ^ lookup (Poly_Mapping.single v n) va)\""], ["proof (prove)\nusing this:\n  (\\<Sum>m\\<in>{Poly_Mapping.single v n}.\n     (a when Poly_Mapping.single v n = m) * (\\<Prod>v. f v ^ lookup m v)) =\n  insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m)\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * (\\<Prod>va. f va ^ lookup (Poly_Mapping.single v n) va)", "unfolding setsum_single[of \"\\<lambda>m. (a when Poly_Mapping.single v n = m) * (\\<Prod>v. f v ^ lookup m v)\" \"Poly_Mapping.single k v\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>m\\<in>{Poly_Mapping.single v n}.\n     (a when Poly_Mapping.single v n = m) * (\\<Prod>v. f v ^ lookup m v)) =\n  insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m)\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * (\\<Prod>va. f va ^ lookup (Poly_Mapping.single v n) va)", "by auto"], ["proof (state)\nthis:\n  insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n  a * (\\<Prod>va. f va ^ lookup (Poly_Mapping.single v n) va)\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * f v ^ n", "have \"\\<forall>v0. v0\\<noteq>v \\<longrightarrow> lookup (Poly_Mapping.single v n) v0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v0.\n       v0 \\<noteq> v \\<longrightarrow>\n       lookup (Poly_Mapping.single v n) v0 = 0", "by (simp add: lookup_single_not_eq)"], ["proof (state)\nthis:\n  \\<forall>v0.\n     v0 \\<noteq> v \\<longrightarrow> lookup (Poly_Mapping.single v n) v0 = 0\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * f v ^ n", "then"], ["proof (chain)\npicking this:\n  \\<forall>v0.\n     v0 \\<noteq> v \\<longrightarrow> lookup (Poly_Mapping.single v n) v0 = 0", "have \"\\<forall>va. va\\<noteq>v \\<longrightarrow> f va ^ lookup (Poly_Mapping.single v n) va = 1\""], ["proof (prove)\nusing this:\n  \\<forall>v0.\n     v0 \\<noteq> v \\<longrightarrow> lookup (Poly_Mapping.single v n) v0 = 0\n\ngoal (1 subgoal):\n 1. \\<forall>va.\n       va \\<noteq> v \\<longrightarrow>\n       f va ^ lookup (Poly_Mapping.single v n) va = (1::'a)", "by simp"], ["proof (state)\nthis:\n  \\<forall>va.\n     va \\<noteq> v \\<longrightarrow>\n     f va ^ lookup (Poly_Mapping.single v n) va = (1::'a)\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * f v ^ n", "then"], ["proof (chain)\npicking this:\n  \\<forall>va.\n     va \\<noteq> v \\<longrightarrow>\n     f va ^ lookup (Poly_Mapping.single v n) va = (1::'a)", "have \"a * (\\<Prod>va\\<in>{v}. f va ^ lookup (Poly_Mapping.single v n) va) = ?i\""], ["proof (prove)\nusing this:\n  \\<forall>va.\n     va \\<noteq> v \\<longrightarrow>\n     f va ^ lookup (Poly_Mapping.single v n) va = (1::'a)\n\ngoal (1 subgoal):\n 1. a * (\\<Prod>va\\<in>{v}. f va ^ lookup (Poly_Mapping.single v n) va) =\n    insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m)", "unfolding 2"], ["proof (prove)\nusing this:\n  \\<forall>va.\n     va \\<noteq> v \\<longrightarrow>\n     f va ^ lookup (Poly_Mapping.single v n) va = (1::'a)\n\ngoal (1 subgoal):\n 1. a * (\\<Prod>va\\<in>{v}. f va ^ lookup (Poly_Mapping.single v n) va) =\n    a * (\\<Prod>va. f va ^ lookup (Poly_Mapping.single v n) va)", "using Prod_any.expand_superset[of \"{v}\" \"\\<lambda>va. f va ^ lookup (Poly_Mapping.single v n) va\", simplified]"], ["proof (prove)\nusing this:\n  \\<forall>va.\n     va \\<noteq> v \\<longrightarrow>\n     f va ^ lookup (Poly_Mapping.single v n) va = (1::'a)\n  {a. f a ^ lookup (Poly_Mapping.single v n) a \\<noteq> (1::'a)}\n  \\<subseteq> {v} \\<Longrightarrow>\n  (\\<Prod>va. f va ^ lookup (Poly_Mapping.single v n) va) = f v ^ n\n\ngoal (1 subgoal):\n 1. a * (\\<Prod>va\\<in>{v}. f va ^ lookup (Poly_Mapping.single v n) va) =\n    a * (\\<Prod>va. f va ^ lookup (Poly_Mapping.single v n) va)", "by fastforce"], ["proof (state)\nthis:\n  a * (\\<Prod>va\\<in>{v}. f va ^ lookup (Poly_Mapping.single v n) va) =\n  insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m)\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * f v ^ n", "then"], ["proof (chain)\npicking this:\n  a * (\\<Prod>va\\<in>{v}. f va ^ lookup (Poly_Mapping.single v n) va) =\n  insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m)", "show ?thesis"], ["proof (prove)\nusing this:\n  a * (\\<Prod>va\\<in>{v}. f va ^ lookup (Poly_Mapping.single v n) va) =\n  insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m)\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n    a * f v ^ n", "by simp"], ["proof (state)\nthis:\n  insertion_fun f (\\<lambda>m. a when Poly_Mapping.single v n = m) =\n  a * f v ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_single[simp]: \"insertion f (monom (Poly_Mapping.single (v::nat) (n::nat)) a) = a * f v ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (monom (Poly_Mapping.single v n) a) = a * f v ^ n", "using insertion_fun_single  Sum_any.cong insertion.rep_eq insertion_aux.rep_eq insertion_fun_def\n  mapping_of_monom single.rep_eq"], ["proof (prove)\nusing this:\n  insertion_fun ?f (\\<lambda>m. ?a when Poly_Mapping.single ?v ?n = m) =\n  ?a * ?f ?v ^ ?n\n  (\\<And>a. ?g a = ?h a) \\<Longrightarrow> Sum_any ?g = Sum_any ?h\n  insertion ?x ?xa = insertion_aux ?x (mapping_of ?xa)\n  insertion_aux ?x ?xa = insertion_fun ?x (lookup ?xa)\n  insertion_fun ?f ?p = (\\<Sum>m. ?p m * (\\<Prod>v. ?f v ^ lookup m v))\n  mapping_of (monom ?m ?a) = Poly_Mapping.single ?m ?a\n  lookup (Poly_Mapping.single ?x ?xa) = (\\<lambda>k'. ?xa when ?x = k')\n\ngoal (1 subgoal):\n 1. insertion f (monom (Poly_Mapping.single v n) a) = a * f v ^ n", "by (metis (no_types, lifting))"], ["", "lemma insertion_fun_irrelevant_vars:\nfixes p::\"((nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a::comm_ring_1)\"\nassumes \"\\<And>m v. p m \\<noteq> 0 \\<Longrightarrow> lookup m v \\<noteq> 0 \\<Longrightarrow> f v = g v\"\nshows \"insertion_fun f p = insertion_fun g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_fun f p = insertion_fun g p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion_fun f p = insertion_fun g p", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion_fun f p = insertion_fun g p", "fix m::\"nat\\<Rightarrow>\\<^sub>0nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. insertion_fun f p = insertion_fun g p", "assume \"p m \\<noteq> 0\""], ["proof (state)\nthis:\n  p m \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. insertion_fun f p = insertion_fun g p", "then"], ["proof (chain)\npicking this:\n  p m \\<noteq> (0::'a)", "have \"(\\<Prod>v. f v ^ lookup m v) = (\\<Prod>v. g v ^ lookup m v)\""], ["proof (prove)\nusing this:\n  p m \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Prod>v. f v ^ lookup m v) = (\\<Prod>v. g v ^ lookup m v)", "using assms"], ["proof (prove)\nusing this:\n  p m \\<noteq> (0::'a)\n  \\<lbrakk>p ?m \\<noteq> (0::'a); lookup ?m ?v \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> f ?v = g ?v\n\ngoal (1 subgoal):\n 1. (\\<Prod>v. f v ^ lookup m v) = (\\<Prod>v. g v ^ lookup m v)", "by (metis power_0)"], ["proof (state)\nthis:\n  (\\<Prod>v. f v ^ lookup m v) = (\\<Prod>v. g v ^ lookup m v)\n\ngoal (1 subgoal):\n 1. insertion_fun f p = insertion_fun g p", "}"], ["proof (state)\nthis:\n  p ?m2 \\<noteq> (0::'a) \\<Longrightarrow>\n  (\\<Prod>v. f v ^ lookup ?m2 v) = (\\<Prod>v. g v ^ lookup ?m2 v)\n\ngoal (1 subgoal):\n 1. insertion_fun f p = insertion_fun g p", "then"], ["proof (chain)\npicking this:\n  p ?m2 \\<noteq> (0::'a) \\<Longrightarrow>\n  (\\<Prod>v. f v ^ lookup ?m2 v) = (\\<Prod>v. g v ^ lookup ?m2 v)", "show ?thesis"], ["proof (prove)\nusing this:\n  p ?m2 \\<noteq> (0::'a) \\<Longrightarrow>\n  (\\<Prod>v. f v ^ lookup ?m2 v) = (\\<Prod>v. g v ^ lookup ?m2 v)\n\ngoal (1 subgoal):\n 1. insertion_fun f p = insertion_fun g p", "unfolding insertion_fun_def"], ["proof (prove)\nusing this:\n  p ?m2 \\<noteq> (0::'a) \\<Longrightarrow>\n  (\\<Prod>v. f v ^ lookup ?m2 v) = (\\<Prod>v. g v ^ lookup ?m2 v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v)) =\n    (\\<Sum>m. p m * (\\<Prod>v. g v ^ lookup m v))", "by (metis (no_types, lifting) mult_not_zero)"], ["proof (state)\nthis:\n  insertion_fun f p = insertion_fun g p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_aux_irrelevant_vars:\nfixes p::\"((nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1)\"\nassumes \"\\<And>m v. lookup p m \\<noteq> 0 \\<Longrightarrow> lookup m v \\<noteq> 0 \\<Longrightarrow> f v = g v\"\nshows \"insertion_aux f p = insertion_aux g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_aux f p = insertion_aux g p", "using insertion_fun_irrelevant_vars[of \"lookup p\" f g] assms"], ["proof (prove)\nusing this:\n  (\\<And>m v.\n      \\<lbrakk>lookup p m \\<noteq> (0::'a); lookup m v \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> f v = g v) \\<Longrightarrow>\n  insertion_fun f (lookup p) = insertion_fun g (lookup p)\n  \\<lbrakk>lookup p ?m \\<noteq> (0::'a); lookup ?m ?v \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> f ?v = g ?v\n\ngoal (1 subgoal):\n 1. insertion_aux f p = insertion_aux g p", "by (metis insertion_aux.rep_eq)"], ["", "lemma insertion_irrelevant_vars:\nfixes p::\"'a::comm_ring_1 mpoly\"\nassumes \"\\<And>v. v\\<in>vars p \\<Longrightarrow> f v = g v\"\nshows \"insertion f p = insertion g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p = insertion g p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion f p = insertion g p", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion f p = insertion g p", "fix m v"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion f p = insertion g p", "assume \"lookup (mapping_of p) m \\<noteq> 0\" \"lookup m v \\<noteq> 0\""], ["proof (state)\nthis:\n  lookup (mapping_of p) m \\<noteq> (0::'a)\n  lookup m v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. insertion f p = insertion g p", "then"], ["proof (chain)\npicking this:\n  lookup (mapping_of p) m \\<noteq> (0::'a)\n  lookup m v \\<noteq> 0", "have \"v \\<in> vars p\""], ["proof (prove)\nusing this:\n  lookup (mapping_of p) m \\<noteq> (0::'a)\n  lookup m v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<in> vars p", "unfolding vars_def"], ["proof (prove)\nusing this:\n  lookup (mapping_of p) m \\<noteq> (0::'a)\n  lookup m v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> (keys ` keys (mapping_of p))", "by (meson UN_I lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  v \\<in> vars p\n\ngoal (1 subgoal):\n 1. insertion f p = insertion g p", "then"], ["proof (chain)\npicking this:\n  v \\<in> vars p", "have \"f v = g v\""], ["proof (prove)\nusing this:\n  v \\<in> vars p\n\ngoal (1 subgoal):\n 1. f v = g v", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> vars p\n  ?v \\<in> vars p \\<Longrightarrow> f ?v = g ?v\n\ngoal (1 subgoal):\n 1. f v = g v", "by auto"], ["proof (state)\nthis:\n  f v = g v\n\ngoal (1 subgoal):\n 1. insertion f p = insertion g p", "}"], ["proof (state)\nthis:\n  \\<lbrakk>lookup (mapping_of p) ?m2 \\<noteq> (0::'a);\n   lookup ?m2 ?v2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> f ?v2 = g ?v2\n\ngoal (1 subgoal):\n 1. insertion f p = insertion g p", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>lookup (mapping_of p) ?m2 \\<noteq> (0::'a);\n   lookup ?m2 ?v2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> f ?v2 = g ?v2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>lookup (mapping_of p) ?m2 \\<noteq> (0::'a);\n   lookup ?m2 ?v2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> f ?v2 = g ?v2\n\ngoal (1 subgoal):\n 1. insertion f p = insertion g p", "unfolding insertion_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>lookup (mapping_of p) ?m2 \\<noteq> (0::'a);\n   lookup ?m2 ?v2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> f ?v2 = g ?v2\n\ngoal (1 subgoal):\n 1. map_fun id (map_fun mapping_of id) insertion_aux f p =\n    map_fun id (map_fun mapping_of id) insertion_aux g p", "using insertion_aux_irrelevant_vars[of \"mapping_of p\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>lookup (mapping_of p) ?m2 \\<noteq> (0::'a);\n   lookup ?m2 ?v2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> f ?v2 = g ?v2\n  (\\<And>m v.\n      \\<lbrakk>lookup (mapping_of p) m \\<noteq> (0::'a);\n       lookup m v \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?f v = ?g v) \\<Longrightarrow>\n  insertion_aux ?f (mapping_of p) = insertion_aux ?g (mapping_of p)\n\ngoal (1 subgoal):\n 1. map_fun id (map_fun mapping_of id) insertion_aux f p =\n    map_fun id (map_fun mapping_of id) insertion_aux g p", "by (metis insertion.rep_eq insertion_def)"], ["proof (state)\nthis:\n  insertion f p = insertion g p\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Nested MPoly\""], ["", "definition reduce_nested_mpoly::\"'a::comm_ring_1 mpoly mpoly \\<Rightarrow> 'a mpoly\" where\n  \"reduce_nested_mpoly pp = insertion (\\<lambda>v. monom (Poly_Mapping.single v 1) 1) pp\""], ["", "lemma reduce_nested_mpoly_sum:\nfixes p1::\"'a::comm_ring_1 mpoly mpoly\"\nshows \"reduce_nested_mpoly (p1 + p2) = reduce_nested_mpoly p1 + reduce_nested_mpoly p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_nested_mpoly (p1 + p2) =\n    reduce_nested_mpoly p1 + reduce_nested_mpoly p2", "by (simp add: insertion_add reduce_nested_mpoly_def)"], ["", "lemma reduce_nested_mpoly_prod:\nfixes p1::\"'a::comm_ring_1 mpoly mpoly\"\nshows \"reduce_nested_mpoly (p1 * p2) = reduce_nested_mpoly p1 * reduce_nested_mpoly p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_nested_mpoly (p1 * p2) =\n    reduce_nested_mpoly p1 * reduce_nested_mpoly p2", "by (simp add: insertion_mult reduce_nested_mpoly_def)"], ["", "lemma reduce_nested_mpoly_0:\nshows \"reduce_nested_mpoly 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_nested_mpoly 0 = 0", "by (simp add: reduce_nested_mpoly_def)"], ["", "lemma insertion_nested_poly:\nfixes pp::\"'a::comm_ring_1 mpoly mpoly\"\nshows \"insertion f (insertion (\\<lambda>v. monom 0 (f v)) pp) = insertion f (reduce_nested_mpoly pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (insertion (\\<lambda>v. monom 0 (f v)) pp) =\n    insertion f (reduce_nested_mpoly pp)", "proof (induction pp rule:mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m a)) =\n       insertion f (reduce_nested_mpoly (monom m a))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion f (insertion (\\<lambda>v. monom 0 (f v)) p1) =\n                insertion f (reduce_nested_mpoly p1);\n        insertion f (insertion (\\<lambda>v. monom 0 (f v)) p2) =\n        insertion f (reduce_nested_mpoly p2);\n        p2 = monom m a; m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (insertion (\\<lambda>v. monom 0 (f v))\n                            (p1 + p2)) =\n                         insertion f (reduce_nested_mpoly (p1 + p2))", "case (monom m a)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m a)) =\n       insertion f (reduce_nested_mpoly (monom m a))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion f (insertion (\\<lambda>v. monom 0 (f v)) p1) =\n                insertion f (reduce_nested_mpoly p1);\n        insertion f (insertion (\\<lambda>v. monom 0 (f v)) p2) =\n        insertion f (reduce_nested_mpoly p2);\n        p2 = monom m a; m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (insertion (\\<lambda>v. monom 0 (f v))\n                            (p1 + p2)) =\n                         insertion f (reduce_nested_mpoly (p1 + p2))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m a)) =\n    insertion f (reduce_nested_mpoly (monom m a))", "proof (induction m arbitrary:a rule:poly_mapping_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v a.\n       insertion f\n        (insertion (\\<lambda>v. monom 0 (f v))\n          (monom (Poly_Mapping.single k v) a)) =\n       insertion f (reduce_nested_mpoly (monom (Poly_Mapping.single k v) a))\n 2. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f\n                    (insertion (\\<lambda>v. monom 0 (f v)) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (insertion (\\<lambda>v. monom 0 (f v))\n                            (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "case (single v n)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>k v a.\n       insertion f\n        (insertion (\\<lambda>v. monom 0 (f v))\n          (monom (Poly_Mapping.single k v) a)) =\n       insertion f (reduce_nested_mpoly (monom (Poly_Mapping.single k v) a))\n 2. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f\n                    (insertion (\\<lambda>v. monom 0 (f v)) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (insertion (\\<lambda>v. monom 0 (f v))\n                            (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f\n     (insertion (\\<lambda>v. monom 0 (f v))\n       (monom (Poly_Mapping.single v n) a)) =\n    insertion f (reduce_nested_mpoly (monom (Poly_Mapping.single v n) a))", "unfolding reduce_nested_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f\n     (insertion (\\<lambda>v. monom 0 (f v))\n       (monom (Poly_Mapping.single v n) a)) =\n    insertion f\n     (insertion (\\<lambda>v. monom (Poly_Mapping.single v 1) (1::'a))\n       (monom (Poly_Mapping.single v n) a))", "apply (simp add: insertion_mult monom_pow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f a * insertion f (monom 0 (f v) ^ n) =\n    insertion f a * f v ^ n", "using monom_pow[of 0 0 \"f v\" n]"], ["proof (prove)\nusing this:\n  monom (Poly_Mapping.single 0 0) (f v) ^ n =\n  monom (Poly_Mapping.single 0 (0 * n)) (f v ^ n)\n\ngoal (1 subgoal):\n 1. insertion f a * insertion f (monom 0 (f v) ^ n) =\n    insertion f a * f v ^ n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 0 (f v) ^ n = monom 0 (f v ^ n) \\<Longrightarrow>\n    insertion f a * insertion f (monom 0 (f v ^ n)) =\n    insertion f a * f v ^ n", "using insertion_single[of f 0 0]"], ["proof (prove)\nusing this:\n  insertion f (monom (Poly_Mapping.single 0 0) ?a) = ?a * f 0 ^ 0\n\ngoal (1 subgoal):\n 1. monom 0 (f v) ^ n = monom 0 (f v ^ n) \\<Longrightarrow>\n    insertion f a * insertion f (monom 0 (f v ^ n)) =\n    insertion f a * f v ^ n", "by auto"], ["proof (state)\nthis:\n  insertion f\n   (insertion (\\<lambda>v. monom 0 (f v))\n     (monom (Poly_Mapping.single v n) a)) =\n  insertion f (reduce_nested_mpoly (monom (Poly_Mapping.single v n) a))\n\ngoal (1 subgoal):\n 1. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f\n                    (insertion (\\<lambda>v. monom 0 (f v)) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (insertion (\\<lambda>v. monom 0 (f v))\n                            (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f\n                    (insertion (\\<lambda>v. monom 0 (f v)) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (insertion (\\<lambda>v. monom 0 (f v))\n                            (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "case (sum m1 m2 k v)"], ["proof (state)\nthis:\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m1 ?a)) =\n  insertion f (reduce_nested_mpoly (monom m1 ?a))\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m2 ?a)) =\n  insertion f (reduce_nested_mpoly (monom m2 ?a))\n  m2 = Poly_Mapping.single k v\n  k \\<notin> keys m1\n\ngoal (1 subgoal):\n 1. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f\n                    (insertion (\\<lambda>v. monom 0 (f v)) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (insertion (\\<lambda>v. monom 0 (f v))\n                            (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "then"], ["proof (chain)\npicking this:\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m1 ?a)) =\n  insertion f (reduce_nested_mpoly (monom m1 ?a))\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m2 ?a)) =\n  insertion f (reduce_nested_mpoly (monom m2 ?a))\n  m2 = Poly_Mapping.single k v\n  k \\<notin> keys m1", "have \"insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m1 a * monom m2 1))\n             = insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))\""], ["proof (prove)\nusing this:\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m1 ?a)) =\n  insertion f (reduce_nested_mpoly (monom m1 ?a))\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m2 ?a)) =\n  insertion f (reduce_nested_mpoly (monom m2 ?a))\n  m2 = Poly_Mapping.single k v\n  k \\<notin> keys m1\n\ngoal (1 subgoal):\n 1. insertion f\n     (insertion (\\<lambda>v. monom 0 (f v)) (monom m1 a * monom m2 1)) =\n    insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))", "unfolding reduce_nested_mpoly_prod insertion_mult"], ["proof (prove)\nusing this:\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m1 ?a)) =\n  insertion f (reduce_nested_mpoly (monom m1 ?a))\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m2 ?a)) =\n  insertion f (reduce_nested_mpoly (monom m2 ?a))\n  m2 = Poly_Mapping.single k v\n  k \\<notin> keys m1\n\ngoal (1 subgoal):\n 1. insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m1 a)) *\n    insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m2 1)) =\n    insertion f (reduce_nested_mpoly (monom m1 a)) *\n    insertion f (reduce_nested_mpoly (monom m2 1))", "by metis"], ["proof (state)\nthis:\n  insertion f\n   (insertion (\\<lambda>v. monom 0 (f v)) (monom m1 a * monom m2 1)) =\n  insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))\n\ngoal (1 subgoal):\n 1. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f\n                    (insertion (\\<lambda>v. monom 0 (f v)) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (insertion (\\<lambda>v. monom 0 (f v))\n                            (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "then"], ["proof (chain)\npicking this:\n  insertion f\n   (insertion (\\<lambda>v. monom 0 (f v)) (monom m1 a * monom m2 1)) =\n  insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))", "show ?case"], ["proof (prove)\nusing this:\n  insertion f\n   (insertion (\\<lambda>v. monom 0 (f v)) (monom m1 a * monom m2 1)) =\n  insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))\n\ngoal (1 subgoal):\n 1. insertion f\n     (insertion (\\<lambda>v. monom 0 (f v)) (monom (m1 + m2) a)) =\n    insertion f (reduce_nested_mpoly (monom (m1 + m2) a))", "using mult_monom[of m1 a m2 1]"], ["proof (prove)\nusing this:\n  insertion f\n   (insertion (\\<lambda>v. monom 0 (f v)) (monom m1 a * monom m2 1)) =\n  insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))\n  monom m1 a * monom m2 1 = monom (m1 + m2) (a * 1)\n\ngoal (1 subgoal):\n 1. insertion f\n     (insertion (\\<lambda>v. monom 0 (f v)) (monom (m1 + m2) a)) =\n    insertion f (reduce_nested_mpoly (monom (m1 + m2) a))", "by auto"], ["proof (state)\nthis:\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom (m1 + m2) a)) =\n  insertion f (reduce_nested_mpoly (monom (m1 + m2) a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) (monom m a)) =\n  insertion f (reduce_nested_mpoly (monom m a))\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion f (insertion (\\<lambda>v. monom 0 (f v)) p1) =\n                insertion f (reduce_nested_mpoly p1);\n        insertion f (insertion (\\<lambda>v. monom 0 (f v)) p2) =\n        insertion f (reduce_nested_mpoly p2);\n        p2 = monom m a; m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (insertion (\\<lambda>v. monom 0 (f v))\n                            (p1 + p2)) =\n                         insertion f (reduce_nested_mpoly (p1 + p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion f (insertion (\\<lambda>v. monom 0 (f v)) p1) =\n                insertion f (reduce_nested_mpoly p1);\n        insertion f (insertion (\\<lambda>v. monom 0 (f v)) p2) =\n        insertion f (reduce_nested_mpoly p2);\n        p2 = monom m a; m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (insertion (\\<lambda>v. monom 0 (f v))\n                            (p1 + p2)) =\n                         insertion f (reduce_nested_mpoly (p1 + p2))", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) p1) =\n  insertion f (reduce_nested_mpoly p1)\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) p2) =\n  insertion f (reduce_nested_mpoly p2)\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion f (insertion (\\<lambda>v. monom 0 (f v)) p1) =\n                insertion f (reduce_nested_mpoly p1);\n        insertion f (insertion (\\<lambda>v. monom 0 (f v)) p2) =\n        insertion f (reduce_nested_mpoly p2);\n        p2 = monom m a; m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (insertion (\\<lambda>v. monom 0 (f v))\n                            (p1 + p2)) =\n                         insertion f (reduce_nested_mpoly (p1 + p2))", "then"], ["proof (chain)\npicking this:\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) p1) =\n  insertion f (reduce_nested_mpoly p1)\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) p2) =\n  insertion f (reduce_nested_mpoly p2)\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)", "show ?case"], ["proof (prove)\nusing this:\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) p1) =\n  insertion f (reduce_nested_mpoly p1)\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) p2) =\n  insertion f (reduce_nested_mpoly p2)\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n\ngoal (1 subgoal):\n 1. insertion f (insertion (\\<lambda>v. monom 0 (f v)) (p1 + p2)) =\n    insertion f (reduce_nested_mpoly (p1 + p2))", "by (simp add: reduce_nested_mpoly_sum insertion_add)"], ["proof (state)\nthis:\n  insertion f (insertion (\\<lambda>v. monom 0 (f v)) (p1 + p2)) =\n  insertion f (reduce_nested_mpoly (p1 + p2))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition extract_var::\"'a::comm_ring_1 mpoly \\<Rightarrow> nat \\<Rightarrow> 'a::comm_ring_1 mpoly mpoly\" where\n\"extract_var p v = (\\<Sum>m. monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\""], ["", "lemma extract_var_finite_set:\nassumes \"{m'. coeff p m' \\<noteq> 0} \\<subseteq> S\"\nassumes \"finite S\"\nshows \"extract_var p v = (\\<Sum>m\\<in>S. monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "fix m'"], ["proof (state)\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "assume \"coeff p m' = 0\""], ["proof (state)\nthis:\n  coeff p m' = (0::'a)\n\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "then"], ["proof (chain)\npicking this:\n  coeff p m' = (0::'a)", "have \"monom (remove_key v m') (monom (Poly_Mapping.single v (lookup m' v)) (coeff p m')) = 0\""], ["proof (prove)\nusing this:\n  coeff p m' = (0::'a)\n\ngoal (1 subgoal):\n 1. monom (remove_key v m')\n     (monom (Poly_Mapping.single v (lookup m' v)) (coeff p m')) =\n    0", "using monom.abs_eq monom_zero single_zero"], ["proof (prove)\nusing this:\n  coeff p m' = (0::'a)\n  monom ?xa ?x = MPoly (Poly_Mapping.single ?xa ?x)\n  monom 0 (0::?'a) = 0\n  Poly_Mapping.single ?k (0::?'b) = 0\n\ngoal (1 subgoal):\n 1. monom (remove_key v m')\n     (monom (Poly_Mapping.single v (lookup m' v)) (coeff p m')) =\n    0", "by metis"], ["proof (state)\nthis:\n  monom (remove_key v m')\n   (monom (Poly_Mapping.single v (lookup m' v)) (coeff p m')) =\n  0\n\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "}"], ["proof (state)\nthis:\n  coeff p ?m'2 = (0::'a) \\<Longrightarrow>\n  monom (remove_key v ?m'2)\n   (monom (Poly_Mapping.single v (lookup ?m'2 v)) (coeff p ?m'2)) =\n  0\n\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "then"], ["proof (chain)\npicking this:\n  coeff p ?m'2 = (0::'a) \\<Longrightarrow>\n  monom (remove_key v ?m'2)\n   (monom (Poly_Mapping.single v (lookup ?m'2 v)) (coeff p ?m'2)) =\n  0", "have 0:\"{a. monom (remove_key v a) (monom (Poly_Mapping.single v (lookup a v)) (coeff p a)) \\<noteq> 0} \\<subseteq> S\""], ["proof (prove)\nusing this:\n  coeff p ?m'2 = (0::'a) \\<Longrightarrow>\n  monom (remove_key v ?m'2)\n   (monom (Poly_Mapping.single v (lookup ?m'2 v)) (coeff p ?m'2)) =\n  0\n\ngoal (1 subgoal):\n 1. {a. monom (remove_key v a)\n         (monom (Poly_Mapping.single v (lookup a v)) (coeff p a)) \\<noteq>\n        0}\n    \\<subseteq> S", "using \\<open>{m'. coeff p m' \\<noteq> 0} \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  coeff p ?m'2 = (0::'a) \\<Longrightarrow>\n  monom (remove_key v ?m'2)\n   (monom (Poly_Mapping.single v (lookup ?m'2 v)) (coeff p ?m'2)) =\n  0\n  {m'. coeff p m' \\<noteq> (0::'a)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. {a. monom (remove_key v a)\n         (monom (Poly_Mapping.single v (lookup a v)) (coeff p a)) \\<noteq>\n        0}\n    \\<subseteq> S", "by fastforce"], ["proof (state)\nthis:\n  {a. monom (remove_key v a)\n       (monom (Poly_Mapping.single v (lookup a v)) (coeff p a)) \\<noteq>\n      0}\n  \\<subseteq> S\n\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "then"], ["proof (chain)\npicking this:\n  {a. monom (remove_key v a)\n       (monom (Poly_Mapping.single v (lookup a v)) (coeff p a)) \\<noteq>\n      0}\n  \\<subseteq> S", "show ?thesis"], ["proof (prove)\nusing this:\n  {a. monom (remove_key v a)\n       (monom (Poly_Mapping.single v (lookup a v)) (coeff p a)) \\<noteq>\n      0}\n  \\<subseteq> S\n\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "unfolding extract_var_def"], ["proof (prove)\nusing this:\n  {a. monom (remove_key v a)\n       (monom (Poly_Mapping.single v (lookup a v)) (coeff p a)) \\<noteq>\n      0}\n  \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<Sum>m. monom (remove_key v m)\n               (monom (Poly_Mapping.single v (lookup m v)) (coeff p m))) =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "using Sum_any.expand_superset [OF \\<open>finite S\\<close> 0]"], ["proof (prove)\nusing this:\n  {a. monom (remove_key v a)\n       (monom (Poly_Mapping.single v (lookup a v)) (coeff p a)) \\<noteq>\n      0}\n  \\<subseteq> S\n  (\\<Sum>a. monom (remove_key v a)\n             (monom (Poly_Mapping.single v (lookup a v)) (coeff p a))) =\n  (\\<Sum>a\\<in>S.\n     monom (remove_key v a)\n      (monom (Poly_Mapping.single v (lookup a v)) (coeff p a)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m. monom (remove_key v m)\n               (monom (Poly_Mapping.single v (lookup m v)) (coeff p m))) =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "by metis"], ["proof (state)\nthis:\n  extract_var p v =\n  (\\<Sum>m\\<in>S.\n     monom (remove_key v m)\n      (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extract_var_non_zero_coeff: \"extract_var p v = (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> 0}. monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "using extract_var_finite_set  coeff_def finite_lookup order_refl"], ["proof (prove)\nusing this:\n  \\<lbrakk>{m'. coeff ?p m' \\<noteq> (0::?'a)} \\<subseteq> ?S;\n   finite ?S\\<rbrakk>\n  \\<Longrightarrow> extract_var ?p ?v =\n                    (\\<Sum>m\\<in>?S.\n                       monom (remove_key ?v m)\n                        (monom (Poly_Mapping.single ?v (lookup m ?v))\n                          (coeff ?p m)))\n  coeff ?p = lookup (mapping_of ?p)\n  finite {k. lookup ?f k \\<noteq> (0::?'b)}\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "by (metis (no_types, lifting) Collect_cong sum.cong)"], ["", "lemma extract_var_sum: \"extract_var (p+p') v = extract_var p v + extract_var p' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_var (p + p') v = extract_var p v + extract_var p' v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extract_var (p + p') v = extract_var p v + extract_var p' v", "define S where \"S = {m. coeff p m \\<noteq> 0} \\<union> {m. coeff p' m \\<noteq> 0} \\<union> {m. coeff (p+p') m \\<noteq> 0}\""], ["proof (state)\nthis:\n  S =\n  {m. coeff p m \\<noteq> (0::'a)} \\<union>\n  {m. coeff p' m \\<noteq> (0::'a)} \\<union>\n  {m. coeff (p + p') m \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. extract_var (p + p') v = extract_var p v + extract_var p' v", "have subsets:\"{m. coeff p m \\<noteq> 0} \\<subseteq> S\" \"{m. coeff p' m \\<noteq> 0} \\<subseteq> S\" \"{m. coeff (p+p') m \\<noteq> 0} \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m. coeff p m \\<noteq> (0::'a)} \\<subseteq> S &&&\n    {m. coeff p' m \\<noteq> (0::'a)} \\<subseteq> S &&&\n    {m. coeff (p + p') m \\<noteq> (0::'a)} \\<subseteq> S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {m. coeff p m \\<noteq> (0::'a)}\n    \\<subseteq> {m. coeff p m \\<noteq> (0::'a)} \\<union>\n                {m. coeff p' m \\<noteq> (0::'a)} \\<union>\n                {m. coeff (p + p') m \\<noteq> (0::'a)} &&&\n    {m. coeff p' m \\<noteq> (0::'a)}\n    \\<subseteq> {m. coeff p m \\<noteq> (0::'a)} \\<union>\n                {m. coeff p' m \\<noteq> (0::'a)} \\<union>\n                {m. coeff (p + p') m \\<noteq> (0::'a)} &&&\n    {m. coeff (p + p') m \\<noteq> (0::'a)}\n    \\<subseteq> {m. coeff p m \\<noteq> (0::'a)} \\<union>\n                {m. coeff p' m \\<noteq> (0::'a)} \\<union>\n                {m. coeff (p + p') m \\<noteq> (0::'a)}", "by auto"], ["proof (state)\nthis:\n  {m. coeff p m \\<noteq> (0::'a)} \\<subseteq> S\n  {m. coeff p' m \\<noteq> (0::'a)} \\<subseteq> S\n  {m. coeff (p + p') m \\<noteq> (0::'a)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. extract_var (p + p') v = extract_var p v + extract_var p' v", "have \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({m. coeff p m \\<noteq> (0::'a)} \\<union>\n      {m. coeff p' m \\<noteq> (0::'a)} \\<union>\n      {m. coeff (p + p') m \\<noteq> (0::'a)})", "using coeff_def finite_lookup"], ["proof (prove)\nusing this:\n  coeff ?p = lookup (mapping_of ?p)\n  finite {k. lookup ?f k \\<noteq> (0::?'b)}\n\ngoal (1 subgoal):\n 1. finite\n     ({m. coeff p m \\<noteq> (0::'a)} \\<union>\n      {m. coeff p' m \\<noteq> (0::'a)} \\<union>\n      {m. coeff (p + p') m \\<noteq> (0::'a)})", "by (metis (mono_tags) Collect_disj_eq finite_Collect_disjI)"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. extract_var (p + p') v = extract_var p v + extract_var p' v", "then"], ["proof (chain)\npicking this:\n  finite S", "show ?thesis"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. extract_var (p + p') v = extract_var p v + extract_var p' v", "unfolding\n    extract_var_finite_set[OF subsets(1) \\<open>finite S\\<close>]\n    extract_var_finite_set[OF subsets(2) \\<open>finite S\\<close>]\n    extract_var_finite_set[OF subsets(3) \\<open>finite S\\<close>]\n    coeff_add[symmetric] monom_add sum.distrib"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m))) +\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p' m))) =\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p m))) +\n    (\\<Sum>m\\<in>S.\n       monom (remove_key v m)\n        (monom (Poly_Mapping.single v (lookup m v)) (coeff p' m)))", "by metis"], ["proof (state)\nthis:\n  extract_var (p + p') v = extract_var p v + extract_var p' v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extract_var_monom:\nshows \"extract_var (monom m a) v = monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "proof (cases \"a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "assume \"a \\<noteq> 0\""], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "have 0:\"{m'. coeff (monom m a) m' \\<noteq> 0} = {m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m'. coeff (monom m a) m' \\<noteq> (0::'a)} = {m}", "unfolding coeff_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. {m'. (a when m' = m) \\<noteq> (0::'a)} = {m}", "using \\<open>a \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. {m'. (a when m' = m) \\<noteq> (0::'a)} = {m}", "by auto"], ["proof (state)\nthis:\n  {m'. coeff (monom m a) m' \\<noteq> (0::'a)} = {m}\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "unfolding extract_var_non_zero_coeff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ma\\<in>{m'. coeff (monom m a) m' \\<noteq> (0::'a)}.\n       monom (remove_key v ma)\n        (monom (Poly_Mapping.single v (lookup ma v))\n          (coeff (monom m a) ma))) =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ma\\<in>{m}.\n       monom (remove_key v ma)\n        (monom (Poly_Mapping.single v (lookup ma v))\n          (coeff (monom m a) ma))) =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "unfolding coeff_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ma\\<in>{m}.\n       monom (remove_key v ma)\n        (monom (Poly_Mapping.single v (lookup ma v)) (a when ma = m))) =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "using sum.insert[OF finite.emptyI, unfolded sum.empty add.right_neutral] when_def"], ["proof (prove)\nusing this:\n  ?x \\<notin> {} \\<Longrightarrow> sum ?g {?x} = ?g ?x\n  (?a when ?P) = (if ?P then ?a else (0::?'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>ma\\<in>{m}.\n       monom (remove_key v ma)\n        (monom (Poly_Mapping.single v (lookup ma v)) (a when ma = m))) =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "by auto"], ["proof (state)\nthis:\n  extract_var (monom m a) v =\n  monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)\n\ngoal (1 subgoal):\n 1. a = (0::'a) \\<Longrightarrow>\n    extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = (0::'a) \\<Longrightarrow>\n    extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "assume \"a = 0\""], ["proof (state)\nthis:\n  a = (0::'a)\n\ngoal (1 subgoal):\n 1. a = (0::'a) \\<Longrightarrow>\n    extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "have 0:\"{m'. coeff (monom m a) m' \\<noteq> 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m'. coeff (monom m a) m' \\<noteq> (0::'a)} = {}", "unfolding coeff_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. {m'. (a when m' = m) \\<noteq> (0::'a)} = {}", "using \\<open>a = 0\\<close>"], ["proof (prove)\nusing this:\n  a = (0::'a)\n\ngoal (1 subgoal):\n 1. {m'. (a when m' = m) \\<noteq> (0::'a)} = {}", "by auto"], ["proof (state)\nthis:\n  {m'. coeff (monom m a) m' \\<noteq> (0::'a)} = {}\n\ngoal (1 subgoal):\n 1. a = (0::'a) \\<Longrightarrow>\n    extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_var (monom m a) v =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "unfolding extract_var_non_zero_coeff 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ma\\<in>{}.\n       monom (remove_key v ma)\n        (monom (Poly_Mapping.single v (lookup ma v))\n          (coeff (monom m a) ma))) =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "using \\<open>a = 0\\<close> monom.abs_eq monom_zero sum.empty single_zero"], ["proof (prove)\nusing this:\n  a = (0::'a)\n  monom ?xa ?x = MPoly (Poly_Mapping.single ?xa ?x)\n  monom 0 (0::?'a) = 0\n  sum ?g {} = (0::?'a)\n  Poly_Mapping.single ?k (0::?'b) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>ma\\<in>{}.\n       monom (remove_key v ma)\n        (monom (Poly_Mapping.single v (lookup ma v))\n          (coeff (monom m a) ma))) =\n    monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  extract_var (monom m a) v =\n  monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extract_var_monom_mult:\nshows \"extract_var (monom (m+m') (a*b)) v = extract_var (monom m a) v * extract_var (monom m' b) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_var (monom (m + m') (a * b)) v =\n    extract_var (monom m a) v * extract_var (monom m' b) v", "unfolding extract_var_monom remove_key_add lookup_add single_add mult_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (remove_key v (m + m'))\n     (monom\n       (Poly_Mapping.single v (lookup m v) +\n        Poly_Mapping.single v (lookup m' v))\n       (a * b)) =\n    monom (remove_key v (m + m'))\n     (monom\n       (Poly_Mapping.single v (lookup m v) +\n        Poly_Mapping.single v (lookup m' v))\n       (a * b))", "by auto"], ["", "lemma extract_var_single: \"extract_var (monom (Poly_Mapping.single v n) a) v = monom 0 (monom (Poly_Mapping.single v n) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_var (monom (Poly_Mapping.single v n) a) v =\n    monom 0 (monom (Poly_Mapping.single v n) a)", "unfolding extract_var_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (remove_key v (Poly_Mapping.single v n))\n     (monom (Poly_Mapping.single v (lookup (Poly_Mapping.single v n) v))\n       a) =\n    monom 0 (monom (Poly_Mapping.single v n) a)", "by simp"], ["", "lemma extract_var_single':\nassumes \"v \\<noteq> v'\"\nshows \"extract_var (monom (Poly_Mapping.single v n) a) v' = monom (Poly_Mapping.single v n) (monom 0 a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_var (monom (Poly_Mapping.single v n) a) v' =\n    monom (Poly_Mapping.single v n) (monom 0 a)", "unfolding extract_var_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (remove_key v' (Poly_Mapping.single v n))\n     (monom (Poly_Mapping.single v' (lookup (Poly_Mapping.single v n) v'))\n       a) =\n    monom (Poly_Mapping.single v n) (monom 0 a)", "using assms"], ["proof (prove)\nusing this:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. monom (remove_key v' (Poly_Mapping.single v n))\n     (monom (Poly_Mapping.single v' (lookup (Poly_Mapping.single v n) v'))\n       a) =\n    monom (Poly_Mapping.single v n) (monom 0 a)", "by (metis add.right_neutral lookup_single_not_eq remove_key_sum single_zero)"], ["", "lemma reduce_nested_mpoly_extract_var:\nfixes p::\"'a::comm_ring_1 mpoly\"\nshows \"reduce_nested_mpoly (extract_var p v) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_nested_mpoly (extract_var p v) = p", "proof (induction p rule:mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a. reduce_nested_mpoly (extract_var (monom m a) v) = monom m a\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>reduce_nested_mpoly (extract_var p1 v) = p1;\n        reduce_nested_mpoly (extract_var p2 v) = p2; p2 = monom m a;\n        m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> reduce_nested_mpoly (extract_var (p1 + p2) v) =\n                         p1 + p2", "case (monom m a)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>m a. reduce_nested_mpoly (extract_var (monom m a) v) = monom m a\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>reduce_nested_mpoly (extract_var p1 v) = p1;\n        reduce_nested_mpoly (extract_var p2 v) = p2; p2 = monom m a;\n        m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> reduce_nested_mpoly (extract_var (p1 + p2) v) =\n                         p1 + p2", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_nested_mpoly (extract_var (monom m a) v) = monom m a", "proof (induction m arbitrary:a rule:poly_mapping_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k va a.\n       reduce_nested_mpoly\n        (extract_var (monom (Poly_Mapping.single k va) a) v) =\n       monom (Poly_Mapping.single k va) a\n 2. \\<And>f g k va a.\n       \\<lbrakk>\\<And>a.\n                   reduce_nested_mpoly (extract_var (monom f a) v) =\n                   monom f a;\n        \\<And>a.\n           reduce_nested_mpoly (extract_var (monom g a) v) = monom g a;\n        g = Poly_Mapping.single k va; k \\<notin> keys f\\<rbrakk>\n       \\<Longrightarrow> reduce_nested_mpoly\n                          (extract_var (monom (f + g) a) v) =\n                         monom (f + g) a", "case (single v' n)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>k va a.\n       reduce_nested_mpoly\n        (extract_var (monom (Poly_Mapping.single k va) a) v) =\n       monom (Poly_Mapping.single k va) a\n 2. \\<And>f g k va a.\n       \\<lbrakk>\\<And>a.\n                   reduce_nested_mpoly (extract_var (monom f a) v) =\n                   monom f a;\n        \\<And>a.\n           reduce_nested_mpoly (extract_var (monom g a) v) = monom g a;\n        g = Poly_Mapping.single k va; k \\<notin> keys f\\<rbrakk>\n       \\<Longrightarrow> reduce_nested_mpoly\n                          (extract_var (monom (f + g) a) v) =\n                         monom (f + g) a", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_nested_mpoly\n     (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n    monom (Poly_Mapping.single v' n) a", "proof (cases \"v' = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' = v \\<Longrightarrow>\n    reduce_nested_mpoly\n     (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n    monom (Poly_Mapping.single v' n) a\n 2. v' \\<noteq> v \\<Longrightarrow>\n    reduce_nested_mpoly\n     (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n    monom (Poly_Mapping.single v' n) a", "case True"], ["proof (state)\nthis:\n  v' = v\n\ngoal (2 subgoals):\n 1. v' = v \\<Longrightarrow>\n    reduce_nested_mpoly\n     (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n    monom (Poly_Mapping.single v' n) a\n 2. v' \\<noteq> v \\<Longrightarrow>\n    reduce_nested_mpoly\n     (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n    monom (Poly_Mapping.single v' n) a", "then"], ["proof (chain)\npicking this:\n  v' = v", "show ?thesis"], ["proof (prove)\nusing this:\n  v' = v\n\ngoal (1 subgoal):\n 1. reduce_nested_mpoly\n     (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n    monom (Poly_Mapping.single v' n) a", "by (metis (no_types, lifting) insertion_single mult.right_neutral power_0\n        reduce_nested_mpoly_def single_zero extract_var_single)"], ["proof (state)\nthis:\n  reduce_nested_mpoly (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n  monom (Poly_Mapping.single v' n) a\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v \\<Longrightarrow>\n    reduce_nested_mpoly\n     (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n    monom (Poly_Mapping.single v' n) a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<noteq> v \\<Longrightarrow>\n    reduce_nested_mpoly\n     (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n    monom (Poly_Mapping.single v' n) a", "case False"], ["proof (state)\nthis:\n  v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v \\<Longrightarrow>\n    reduce_nested_mpoly\n     (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n    monom (Poly_Mapping.single v' n) a", "then"], ["proof (chain)\npicking this:\n  v' \\<noteq> v", "show ?thesis"], ["proof (prove)\nusing this:\n  v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. reduce_nested_mpoly\n     (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n    monom (Poly_Mapping.single v' n) a", "unfolding extract_var_single'[OF False] reduce_nested_mpoly_def insertion_single"], ["proof (prove)\nusing this:\n  v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. monom 0 a * monom (Poly_Mapping.single v' 1) (1::'a) ^ n =\n    monom (Poly_Mapping.single v' n) a", "by (simp add: monom_pow mult_monom)"], ["proof (state)\nthis:\n  reduce_nested_mpoly (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n  monom (Poly_Mapping.single v' n) a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reduce_nested_mpoly (extract_var (monom (Poly_Mapping.single v' n) a) v) =\n  monom (Poly_Mapping.single v' n) a\n\ngoal (1 subgoal):\n 1. \\<And>f g k va a.\n       \\<lbrakk>\\<And>a.\n                   reduce_nested_mpoly (extract_var (monom f a) v) =\n                   monom f a;\n        \\<And>a.\n           reduce_nested_mpoly (extract_var (monom g a) v) = monom g a;\n        g = Poly_Mapping.single k va; k \\<notin> keys f\\<rbrakk>\n       \\<Longrightarrow> reduce_nested_mpoly\n                          (extract_var (monom (f + g) a) v) =\n                         monom (f + g) a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g k va a.\n       \\<lbrakk>\\<And>a.\n                   reduce_nested_mpoly (extract_var (monom f a) v) =\n                   monom f a;\n        \\<And>a.\n           reduce_nested_mpoly (extract_var (monom g a) v) = monom g a;\n        g = Poly_Mapping.single k va; k \\<notin> keys f\\<rbrakk>\n       \\<Longrightarrow> reduce_nested_mpoly\n                          (extract_var (monom (f + g) a) v) =\n                         monom (f + g) a", "case (sum m m' v n a)"], ["proof (state)\nthis:\n  reduce_nested_mpoly (extract_var (monom m ?a) v) = monom m ?a\n  reduce_nested_mpoly (extract_var (monom m' ?a) v) = monom m' ?a\n  m' = Poly_Mapping.single v n\n  v \\<notin> keys m\n\ngoal (1 subgoal):\n 1. \\<And>f g k va a.\n       \\<lbrakk>\\<And>a.\n                   reduce_nested_mpoly (extract_var (monom f a) v) =\n                   monom f a;\n        \\<And>a.\n           reduce_nested_mpoly (extract_var (monom g a) v) = monom g a;\n        g = Poly_Mapping.single k va; k \\<notin> keys f\\<rbrakk>\n       \\<Longrightarrow> reduce_nested_mpoly\n                          (extract_var (monom (f + g) a) v) =\n                         monom (f + g) a", "then"], ["proof (chain)\npicking this:\n  reduce_nested_mpoly (extract_var (monom m ?a) v) = monom m ?a\n  reduce_nested_mpoly (extract_var (monom m' ?a) v) = monom m' ?a\n  m' = Poly_Mapping.single v n\n  v \\<notin> keys m", "show ?case"], ["proof (prove)\nusing this:\n  reduce_nested_mpoly (extract_var (monom m ?a) v) = monom m ?a\n  reduce_nested_mpoly (extract_var (monom m' ?a) v) = monom m' ?a\n  m' = Poly_Mapping.single v n\n  v \\<notin> keys m\n\ngoal (1 subgoal):\n 1. reduce_nested_mpoly (extract_var (monom (m + m') a) v) =\n    monom (m + m') a", "using extract_var_monom_mult[of m m' a 1] reduce_nested_mpoly_prod"], ["proof (prove)\nusing this:\n  reduce_nested_mpoly (extract_var (monom m ?a) v) = monom m ?a\n  reduce_nested_mpoly (extract_var (monom m' ?a) v) = monom m' ?a\n  m' = Poly_Mapping.single v n\n  v \\<notin> keys m\n  extract_var (monom (m + m') (a * (1::'a))) ?v =\n  extract_var (monom m a) ?v * extract_var (monom m' (1::'a)) ?v\n  reduce_nested_mpoly (?p1.0 * ?p2.0) =\n  reduce_nested_mpoly ?p1.0 * reduce_nested_mpoly ?p2.0\n\ngoal (1 subgoal):\n 1. reduce_nested_mpoly (extract_var (monom (m + m') a) v) =\n    monom (m + m') a", "by (metis mult.right_neutral mult_monom)"], ["proof (state)\nthis:\n  reduce_nested_mpoly (extract_var (monom (m + m') a) v) = monom (m + m') a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reduce_nested_mpoly (extract_var (monom m a) v) = monom m a\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>reduce_nested_mpoly (extract_var p1 v) = p1;\n        reduce_nested_mpoly (extract_var p2 v) = p2; p2 = monom m a;\n        m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> reduce_nested_mpoly (extract_var (p1 + p2) v) =\n                         p1 + p2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>reduce_nested_mpoly (extract_var p1 v) = p1;\n        reduce_nested_mpoly (extract_var p2 v) = p2; p2 = monom m a;\n        m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> reduce_nested_mpoly (extract_var (p1 + p2) v) =\n                         p1 + p2", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  reduce_nested_mpoly (extract_var p1 v) = p1\n  reduce_nested_mpoly (extract_var p2 v) = p2\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>reduce_nested_mpoly (extract_var p1 v) = p1;\n        reduce_nested_mpoly (extract_var p2 v) = p2; p2 = monom m a;\n        m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> reduce_nested_mpoly (extract_var (p1 + p2) v) =\n                         p1 + p2", "then"], ["proof (chain)\npicking this:\n  reduce_nested_mpoly (extract_var p1 v) = p1\n  reduce_nested_mpoly (extract_var p2 v) = p2\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)", "show ?case"], ["proof (prove)\nusing this:\n  reduce_nested_mpoly (extract_var p1 v) = p1\n  reduce_nested_mpoly (extract_var p2 v) = p2\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n\ngoal (1 subgoal):\n 1. reduce_nested_mpoly (extract_var (p1 + p2) v) = p1 + p2", "unfolding extract_var_sum reduce_nested_mpoly_sum"], ["proof (prove)\nusing this:\n  reduce_nested_mpoly (extract_var p1 v) = p1\n  reduce_nested_mpoly (extract_var p2 v) = p2\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n\ngoal (1 subgoal):\n 1. reduce_nested_mpoly (extract_var p1 v) +\n    reduce_nested_mpoly (extract_var p2 v) =\n    p1 + p2", "by auto"], ["proof (state)\nthis:\n  reduce_nested_mpoly (extract_var (p1 + p2) v) = p1 + p2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_extract_var_subset: \"vars (extract_var p v) \\<subseteq> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (extract_var p v) \\<subseteq> vars p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars (extract_var p v) \\<Longrightarrow> x \\<in> vars p", "have \"finite {m'. coeff p m' \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {m'. coeff p m' \\<noteq> (0::'a)}", "by (simp add: coeff_def)"], ["proof (state)\nthis:\n  finite {m'. coeff p m' \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars (extract_var p v) \\<Longrightarrow> x \\<in> vars p", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars (extract_var p v) \\<Longrightarrow> x \\<in> vars p", "assume \"x \\<in> vars (extract_var p v)\""], ["proof (state)\nthis:\n  x \\<in> vars (extract_var p v)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars (extract_var p v) \\<Longrightarrow> x \\<in> vars p", "then"], ["proof (chain)\npicking this:\n  x \\<in> vars (extract_var p v)", "have \"x \\<in> vars (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> 0}. monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\""], ["proof (prove)\nusing this:\n  x \\<in> vars (extract_var p v)\n\ngoal (1 subgoal):\n 1. x \\<in> vars\n             (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                monom (remove_key v m)\n                 (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "unfolding extract_var_non_zero_coeff"], ["proof (prove)\nusing this:\n  x \\<in> vars\n           (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n              monom (remove_key v m)\n               (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\n\ngoal (1 subgoal):\n 1. x \\<in> vars\n             (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                monom (remove_key v m)\n                 (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "by metis"], ["proof (state)\nthis:\n  x \\<in> vars\n           (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n              monom (remove_key v m)\n               (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars (extract_var p v) \\<Longrightarrow> x \\<in> vars p", "then"], ["proof (chain)\npicking this:\n  x \\<in> vars\n           (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n              monom (remove_key v m)\n               (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))", "have \"x \\<in> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> 0}. vars (monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) (coeff p m))))\""], ["proof (prove)\nusing this:\n  x \\<in> vars\n           (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n              monom (remove_key v m)\n               (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                vars\n                 (monom (remove_key v m)\n                   (monom (Poly_Mapping.single v (lookup m v))\n                     (coeff p m))))", "using vars_setsum[OF \\<open>finite {m'. coeff p m' \\<noteq> 0}\\<close>]"], ["proof (prove)\nusing this:\n  x \\<in> vars\n           (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n              monom (remove_key v m)\n               (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\n  vars (sum ?f {m'. coeff p m' \\<noteq> (0::'a)})\n  \\<subseteq> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}. vars (?f m))\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                vars\n                 (monom (remove_key v m)\n                   (monom (Poly_Mapping.single v (lookup m v))\n                     (coeff p m))))", "by auto"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n              vars\n               (monom (remove_key v m)\n                 (monom (Poly_Mapping.single v (lookup m v)) (coeff p m))))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars (extract_var p v) \\<Longrightarrow> x \\<in> vars p", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n              vars\n               (monom (remove_key v m)\n                 (monom (Poly_Mapping.single v (lookup m v)) (coeff p m))))", "obtain m where \"m\\<in>{m'. coeff p m' \\<noteq> 0}\" \"x \\<in> vars (monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n              vars\n               (monom (remove_key v m)\n                 (monom (Poly_Mapping.single v (lookup m v)) (coeff p m))))\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<in> {m'. coeff p m' \\<noteq> (0::'a)};\n         x \\<in> vars\n                  (monom (remove_key v m)\n                    (monom (Poly_Mapping.single v (lookup m v))\n                      (coeff p m)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m \\<in> {m'. coeff p m' \\<noteq> (0::'a)}\n  x \\<in> vars\n           (monom (remove_key v m)\n             (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> vars (extract_var p v) \\<Longrightarrow> x \\<in> vars p", "show \"x \\<in> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> vars p", "by (metis (mono_tags, lifting) DiffD1 UN_I \\<open>m \\<in> {m'. coeff p m' \\<noteq> 0}\\<close>\n    \\<open>x \\<in> vars (monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\\<close>\n    coeff_keys mem_Collect_eq remove_key_keys subsetCE vars_def vars_monom_subset)"], ["proof (state)\nthis:\n  x \\<in> vars p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma v_not_in_vars_extract_var: \"v \\<notin> vars (extract_var p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> vars (extract_var p v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> vars (extract_var p v)", "have \"finite {m'. coeff p m' \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {m'. coeff p m' \\<noteq> (0::'a)}", "by (simp add: coeff_def)"], ["proof (state)\nthis:\n  finite {m'. coeff p m' \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (extract_var p v)", "have \"\\<And>m. m\\<in>{m'. coeff p m' \\<noteq> 0} \\<Longrightarrow> v \\<notin> vars (monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) (coeff p m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> {m'. coeff p m' \\<noteq> (0::'a)} \\<Longrightarrow>\n       v \\<notin> vars\n                   (monom (remove_key v m)\n                     (monom (Poly_Mapping.single v (lookup m v))\n                       (coeff p m)))", "by (metis Diff_iff remove_key_keys singletonI subsetCE vars_monom_subset)"], ["proof (state)\nthis:\n  ?m \\<in> {m'. coeff p m' \\<noteq> (0::'a)} \\<Longrightarrow>\n  v \\<notin> vars\n              (monom (remove_key v ?m)\n                (monom (Poly_Mapping.single v (lookup ?m v)) (coeff p ?m)))\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (extract_var p v)", "then"], ["proof (chain)\npicking this:\n  ?m \\<in> {m'. coeff p m' \\<noteq> (0::'a)} \\<Longrightarrow>\n  v \\<notin> vars\n              (monom (remove_key v ?m)\n                (monom (Poly_Mapping.single v (lookup ?m v)) (coeff p ?m)))", "have \"v \\<notin> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> 0}. vars (monom (remove_key v m) (monom (Poly_Mapping.single v (lookup m v)) (coeff p m))))\""], ["proof (prove)\nusing this:\n  ?m \\<in> {m'. coeff p m' \\<noteq> (0::'a)} \\<Longrightarrow>\n  v \\<notin> vars\n              (monom (remove_key v ?m)\n                (monom (Poly_Mapping.single v (lookup ?m v)) (coeff p ?m)))\n\ngoal (1 subgoal):\n 1. v \\<notin> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                   vars\n                    (monom (remove_key v m)\n                      (monom (Poly_Mapping.single v (lookup m v))\n                        (coeff p m))))", "by simp"], ["proof (state)\nthis:\n  v \\<notin> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                 vars\n                  (monom (remove_key v m)\n                    (monom (Poly_Mapping.single v (lookup m v))\n                      (coeff p m))))\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (extract_var p v)", "then"], ["proof (chain)\npicking this:\n  v \\<notin> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                 vars\n                  (monom (remove_key v m)\n                    (monom (Poly_Mapping.single v (lookup m v))\n                      (coeff p m))))", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                 vars\n                  (monom (remove_key v m)\n                    (monom (Poly_Mapping.single v (lookup m v))\n                      (coeff p m))))\n\ngoal (1 subgoal):\n 1. v \\<notin> vars (extract_var p v)", "unfolding extract_var_non_zero_coeff"], ["proof (prove)\nusing this:\n  v \\<notin> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                 vars\n                  (monom (remove_key v m)\n                    (monom (Poly_Mapping.single v (lookup m v))\n                      (coeff p m))))\n\ngoal (1 subgoal):\n 1. v \\<notin> vars\n                (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                   monom (remove_key v m)\n                    (monom (Poly_Mapping.single v (lookup m v))\n                      (coeff p m)))", "using vars_setsum[OF \\<open>finite {m'. coeff p m' \\<noteq> 0}\\<close>]"], ["proof (prove)\nusing this:\n  v \\<notin> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                 vars\n                  (monom (remove_key v m)\n                    (monom (Poly_Mapping.single v (lookup m v))\n                      (coeff p m))))\n  vars (sum ?f {m'. coeff p m' \\<noteq> (0::'a)})\n  \\<subseteq> (\\<Union>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}. vars (?f m))\n\ngoal (1 subgoal):\n 1. v \\<notin> vars\n                (\\<Sum>m\\<in>{m'. coeff p m' \\<noteq> (0::'a)}.\n                   monom (remove_key v m)\n                    (monom (Poly_Mapping.single v (lookup m v))\n                      (coeff p m)))", "by blast"], ["proof (state)\nthis:\n  v \\<notin> vars (extract_var p v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_coeff_extract_var: \"vars (coeff (extract_var p v) j) \\<subseteq> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (coeff (extract_var p v) j) \\<subseteq> {v}", "proof (induction p rule:mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a. vars (coeff (extract_var (monom m a) v) j) \\<subseteq> {v}\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>vars (coeff (extract_var p1 v) j) \\<subseteq> {v};\n        vars (coeff (extract_var p2 v) j) \\<subseteq> {v}; p2 = monom m a;\n        m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> vars (coeff (extract_var (p1 + p2) v) j)\n                         \\<subseteq> {v}", "case (monom m a)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>m a. vars (coeff (extract_var (monom m a) v) j) \\<subseteq> {v}\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>vars (coeff (extract_var p1 v) j) \\<subseteq> {v};\n        vars (coeff (extract_var p2 v) j) \\<subseteq> {v}; p2 = monom m a;\n        m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> vars (coeff (extract_var (p1 + p2) v) j)\n                         \\<subseteq> {v}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (coeff (extract_var (monom m a) v) j) \\<subseteq> {v}", "unfolding extract_var_monom coeff_monom vars_monom_single_cases"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars\n     (monom (Poly_Mapping.single v (lookup m v)) a when j = remove_key v m)\n    \\<subseteq> {v}", "by (metis monom_zero single_zero vars_monom_single when_def)"], ["proof (state)\nthis:\n  vars (coeff (extract_var (monom m a) v) j) \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>vars (coeff (extract_var p1 v) j) \\<subseteq> {v};\n        vars (coeff (extract_var p2 v) j) \\<subseteq> {v}; p2 = monom m a;\n        m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> vars (coeff (extract_var (p1 + p2) v) j)\n                         \\<subseteq> {v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>vars (coeff (extract_var p1 v) j) \\<subseteq> {v};\n        vars (coeff (extract_var p2 v) j) \\<subseteq> {v}; p2 = monom m a;\n        m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> vars (coeff (extract_var (p1 + p2) v) j)\n                         \\<subseteq> {v}", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  vars (coeff (extract_var p1 v) j) \\<subseteq> {v}\n  vars (coeff (extract_var p2 v) j) \\<subseteq> {v}\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>vars (coeff (extract_var p1 v) j) \\<subseteq> {v};\n        vars (coeff (extract_var p2 v) j) \\<subseteq> {v}; p2 = monom m a;\n        m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> vars (coeff (extract_var (p1 + p2) v) j)\n                         \\<subseteq> {v}", "then"], ["proof (chain)\npicking this:\n  vars (coeff (extract_var p1 v) j) \\<subseteq> {v}\n  vars (coeff (extract_var p2 v) j) \\<subseteq> {v}\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)", "show ?case"], ["proof (prove)\nusing this:\n  vars (coeff (extract_var p1 v) j) \\<subseteq> {v}\n  vars (coeff (extract_var p2 v) j) \\<subseteq> {v}\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n\ngoal (1 subgoal):\n 1. vars (coeff (extract_var (p1 + p2) v) j) \\<subseteq> {v}", "unfolding extract_var_sum coeff_add[symmetric]"], ["proof (prove)\nusing this:\n  vars (coeff (extract_var p1 v) j) \\<subseteq> {v}\n  vars (coeff (extract_var p2 v) j) \\<subseteq> {v}\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n\ngoal (1 subgoal):\n 1. vars (coeff (extract_var p1 v) j + coeff (extract_var p2 v) j)\n    \\<subseteq> {v}", "by (metis (no_types, lifting) Un_insert_right insert_absorb2 subset_insertI2 subset_singletonD sup_bot.right_neutral vars_add)"], ["proof (state)\nthis:\n  vars (coeff (extract_var (p1 + p2) v) j) \\<subseteq> {v}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition replace_coeff\nwhere \"replace_coeff f p = MPoly (Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p) m)))\""], ["", "lemma coeff_replace_coeff:\nassumes \"f 0 = 0\"\nshows \"coeff (replace_coeff f p) m = f (coeff p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (replace_coeff f p) m = f (coeff p m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (replace_coeff f p) m = f (coeff p m)", "have 0:\"finite {m. f (lookup (mapping_of p) m) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {m. f (lookup (mapping_of p) m) \\<noteq> (0::'a)}", "unfolding coeff_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {m. f (coeff p m) \\<noteq> (0::'a)}", "by (metis (mono_tags, lifting) Collect_mono assms(1) coeff_def finite_lookup finite_subset)+"], ["proof (state)\nthis:\n  finite {m. f (lookup (mapping_of p) m) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. coeff (replace_coeff f p) m = f (coeff p m)", "then"], ["proof (chain)\npicking this:\n  finite {m. f (lookup (mapping_of p) m) \\<noteq> (0::'a)}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {m. f (lookup (mapping_of p) m) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. coeff (replace_coeff f p) m = f (coeff p m)", "unfolding replace_coeff_def coeff_def"], ["proof (prove)\nusing this:\n  finite {m. f (lookup (mapping_of p) m) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. lookup\n     (mapping_of\n       (MPoly (Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p) m)))))\n     m =\n    f (lookup (mapping_of p) m)", "using lookup_Abs_poly_mapping[OF 0]"], ["proof (prove)\nusing this:\n  finite {m. f (lookup (mapping_of p) m) \\<noteq> (0::'a)}\n  lookup (Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p) m))) =\n  (\\<lambda>m. f (lookup (mapping_of p) m))\n\ngoal (1 subgoal):\n 1. lookup\n     (mapping_of\n       (MPoly (Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p) m)))))\n     m =\n    f (lookup (mapping_of p) m)", "by (metis (mono_tags, lifting) Quotient_mpoly Quotient_rep_abs_fold_unmap)"], ["proof (state)\nthis:\n  coeff (replace_coeff f p) m = f (coeff p m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replace_coeff_monom:\nassumes \"f 0 = 0\"\nshows \"replace_coeff f (monom m a) = monom m (f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace_coeff f (monom m a) = monom m (f a)", "unfolding replace_coeff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly\n     (Abs_poly_mapping\n       (\\<lambda>ma. f (lookup (mapping_of (monom m a)) ma))) =\n    monom m (f a)", "unfolding  mapping_of_inject[symmetric] lookup_inject[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (mapping_of\n       (MPoly\n         (Abs_poly_mapping\n           (\\<lambda>ma. f (lookup (mapping_of (monom m a)) ma))))) =\n    lookup (mapping_of (monom m (f a)))", "apply (rule HOL.ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       lookup\n        (mapping_of\n          (MPoly\n            (Abs_poly_mapping\n              (\\<lambda>ma. f (lookup (mapping_of (monom m a)) ma)))))\n        x =\n       lookup (mapping_of (monom m (f a))) x", "unfolding lookup_single  mapping_of_monom fun_when[of f, OF \\<open>f 0 = 0\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       lookup\n        (mapping_of\n          (MPoly (Abs_poly_mapping (\\<lambda>ma. f a when m = ma))))\n        x =\n       (f a when m = x)", "by (metis coeff_def coeff_monom lookup_single lookup_single_not_eq monom.abs_eq single.abs_eq)"], ["", "lemma replace_coeff_add:\nassumes \"f 0 = 0\"\nassumes \"\\<And>a b. f (a+b) = f a + f b\"\nshows \"replace_coeff f (p1 + p2) = replace_coeff f p1 + replace_coeff f p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace_coeff f (p1 + p2) = replace_coeff f p1 + replace_coeff f p2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. replace_coeff f (p1 + p2) = replace_coeff f p1 + replace_coeff f p2", "have \"finite {m. f (lookup (mapping_of p1) m) \\<noteq> 0}\"\n       \"finite {m. f (lookup (mapping_of p2) m) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {m. f (lookup (mapping_of p1) m) \\<noteq> (0::'a)} &&&\n    finite {m. f (lookup (mapping_of p2) m) \\<noteq> (0::'a)}", "unfolding coeff_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {m. f (coeff p1 m) \\<noteq> (0::'a)} &&&\n    finite {m. f (coeff p2 m) \\<noteq> (0::'a)}", "by (metis (mono_tags, lifting) Collect_mono assms(1) coeff_def finite_lookup finite_subset)+"], ["proof (state)\nthis:\n  finite {m. f (lookup (mapping_of p1) m) \\<noteq> (0::'a)}\n  finite {m. f (lookup (mapping_of p2) m) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. replace_coeff f (p1 + p2) = replace_coeff f p1 + replace_coeff f p2", "then"], ["proof (chain)\npicking this:\n  finite {m. f (lookup (mapping_of p1) m) \\<noteq> (0::'a)}\n  finite {m. f (lookup (mapping_of p2) m) \\<noteq> (0::'a)}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {m. f (lookup (mapping_of p1) m) \\<noteq> (0::'a)}\n  finite {m. f (lookup (mapping_of p2) m) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. replace_coeff f (p1 + p2) = replace_coeff f p1 + replace_coeff f p2", "unfolding replace_coeff_def plus_mpoly.rep_eq"], ["proof (prove)\nusing this:\n  finite {m. f (lookup (mapping_of p1) m) \\<noteq> (0::'a)}\n  finite {m. f (lookup (mapping_of p2) m) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. MPoly\n     (Abs_poly_mapping\n       (\\<lambda>m. f (lookup (mapping_of p1 + mapping_of p2) m))) =\n    MPoly (Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p1) m))) +\n    MPoly (Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p2) m)))", "unfolding Poly_Mapping.plus_poly_mapping.rep_eq"], ["proof (prove)\nusing this:\n  finite {m. f (lookup (mapping_of p1) m) \\<noteq> (0::'a)}\n  finite {m. f (lookup (mapping_of p2) m) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. MPoly\n     (Abs_poly_mapping\n       (\\<lambda>m.\n           f (lookup (mapping_of p1) m + lookup (mapping_of p2) m))) =\n    MPoly (Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p1) m))) +\n    MPoly (Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p2) m)))", "unfolding assms(2) plus_mpoly.abs_eq"], ["proof (prove)\nusing this:\n  finite {m. f (lookup (mapping_of p1) m) \\<noteq> (0::'a)}\n  finite {m. f (lookup (mapping_of p2) m) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. MPoly\n     (Abs_poly_mapping\n       (\\<lambda>m.\n           f (lookup (mapping_of p1) m) + f (lookup (mapping_of p2) m))) =\n    MPoly\n     (Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p1) m)) +\n      Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p2) m)))", "using Poly_Mapping.plus_poly_mapping.abs_eq[unfolded eq_onp_def]"], ["proof (prove)\nusing this:\n  finite {m. f (lookup (mapping_of p1) m) \\<noteq> (0::'a)}\n  finite {m. f (lookup (mapping_of p2) m) \\<noteq> (0::'a)}\n  \\<lbrakk>finite {x. ?xa x \\<noteq> (0::?'b)} \\<and> ?xa = ?xa;\n   finite {x. ?x x \\<noteq> (0::?'b)} \\<and> ?x = ?x\\<rbrakk>\n  \\<Longrightarrow> Abs_poly_mapping ?xa + Abs_poly_mapping ?x =\n                    Abs_poly_mapping (\\<lambda>k. ?xa k + ?x k)\n\ngoal (1 subgoal):\n 1. MPoly\n     (Abs_poly_mapping\n       (\\<lambda>m.\n           f (lookup (mapping_of p1) m) + f (lookup (mapping_of p2) m))) =\n    MPoly\n     (Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p1) m)) +\n      Abs_poly_mapping (\\<lambda>m. f (lookup (mapping_of p2) m)))", "by fastforce"], ["proof (state)\nthis:\n  replace_coeff f (p1 + p2) = replace_coeff f p1 + replace_coeff f p2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_replace_coeff:\nfixes pp::\"'a::comm_ring_1 mpoly mpoly\"\nshows \"insertion f (replace_coeff (insertion f) pp) = insertion f (reduce_nested_mpoly pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (replace_coeff (insertion f) pp) =\n    insertion f (reduce_nested_mpoly pp)", "proof (induction pp rule:mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       insertion f (replace_coeff (insertion f) (monom m a)) =\n       insertion f (reduce_nested_mpoly (monom m a))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion f (replace_coeff (insertion f) p1) =\n                insertion f (reduce_nested_mpoly p1);\n        insertion f (replace_coeff (insertion f) p2) =\n        insertion f (reduce_nested_mpoly p2);\n        p2 = monom m a; m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (p1 + p2)) =\n                         insertion f (reduce_nested_mpoly (p1 + p2))", "case (monom m a)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       insertion f (replace_coeff (insertion f) (monom m a)) =\n       insertion f (reduce_nested_mpoly (monom m a))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion f (replace_coeff (insertion f) p1) =\n                insertion f (reduce_nested_mpoly p1);\n        insertion f (replace_coeff (insertion f) p2) =\n        insertion f (reduce_nested_mpoly p2);\n        p2 = monom m a; m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (p1 + p2)) =\n                         insertion f (reduce_nested_mpoly (p1 + p2))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (replace_coeff (insertion f) (monom m a)) =\n    insertion f (reduce_nested_mpoly (monom m a))", "proof (induction m arbitrary:a rule:poly_mapping_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v a.\n       insertion f\n        (replace_coeff (insertion f) (monom (Poly_Mapping.single k v) a)) =\n       insertion f (reduce_nested_mpoly (monom (Poly_Mapping.single k v) a))\n 2. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f (replace_coeff (insertion f) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (replace_coeff (insertion f) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "case (single v n)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>k v a.\n       insertion f\n        (replace_coeff (insertion f) (monom (Poly_Mapping.single k v) a)) =\n       insertion f (reduce_nested_mpoly (monom (Poly_Mapping.single k v) a))\n 2. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f (replace_coeff (insertion f) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (replace_coeff (insertion f) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f\n     (replace_coeff (insertion f) (monom (Poly_Mapping.single v n) a)) =\n    insertion f (reduce_nested_mpoly (monom (Poly_Mapping.single v n) a))", "unfolding reduce_nested_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f\n     (replace_coeff (insertion f) (monom (Poly_Mapping.single v n) a)) =\n    insertion f\n     (insertion (\\<lambda>v. monom (Poly_Mapping.single v 1) (1::'a))\n       (monom (Poly_Mapping.single v n) a))", "unfolding replace_coeff_monom[of \"insertion f\", OF insertion_zero]\n      insertion_single insertion_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f a * f v ^ n =\n    insertion f a *\n    insertion f (monom (Poly_Mapping.single v 1) (1::'a) ^ n)", "using insertion_single"], ["proof (prove)\nusing this:\n  insertion ?f (monom (Poly_Mapping.single ?v ?n) ?a) = ?a * ?f ?v ^ ?n\n\ngoal (1 subgoal):\n 1. insertion f a * f v ^ n =\n    insertion f a *\n    insertion f (monom (Poly_Mapping.single v 1) (1::'a) ^ n)", "by (simp add: monom_pow)"], ["proof (state)\nthis:\n  insertion f\n   (replace_coeff (insertion f) (monom (Poly_Mapping.single v n) a)) =\n  insertion f (reduce_nested_mpoly (monom (Poly_Mapping.single v n) a))\n\ngoal (1 subgoal):\n 1. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f (replace_coeff (insertion f) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (replace_coeff (insertion f) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f (replace_coeff (insertion f) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (replace_coeff (insertion f) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "case (sum m1 m2 k v)"], ["proof (state)\nthis:\n  insertion f (replace_coeff (insertion f) (monom m1 ?a)) =\n  insertion f (reduce_nested_mpoly (monom m1 ?a))\n  insertion f (replace_coeff (insertion f) (monom m2 ?a)) =\n  insertion f (reduce_nested_mpoly (monom m2 ?a))\n  m2 = Poly_Mapping.single k v\n  k \\<notin> keys m1\n\ngoal (1 subgoal):\n 1. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f (replace_coeff (insertion f) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (replace_coeff (insertion f) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "have \"replace_coeff (insertion f) (monom m1 a * monom m2 1) = replace_coeff (insertion f) (monom m1 a) * replace_coeff (insertion f) (monom m2 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace_coeff (insertion f) (monom m1 a * monom m2 1) =\n    replace_coeff (insertion f) (monom m1 a) *\n    replace_coeff (insertion f) (monom m2 1)", "by (simp add: mult_monom replace_coeff_monom)"], ["proof (state)\nthis:\n  replace_coeff (insertion f) (monom m1 a * monom m2 1) =\n  replace_coeff (insertion f) (monom m1 a) *\n  replace_coeff (insertion f) (monom m2 1)\n\ngoal (1 subgoal):\n 1. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f (replace_coeff (insertion f) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (replace_coeff (insertion f) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "then"], ["proof (chain)\npicking this:\n  replace_coeff (insertion f) (monom m1 a * monom m2 1) =\n  replace_coeff (insertion f) (monom m1 a) *\n  replace_coeff (insertion f) (monom m2 1)", "have \"insertion f (replace_coeff (insertion f) (monom m1 a * monom m2 1)) = insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))\""], ["proof (prove)\nusing this:\n  replace_coeff (insertion f) (monom m1 a * monom m2 1) =\n  replace_coeff (insertion f) (monom m1 a) *\n  replace_coeff (insertion f) (monom m2 1)\n\ngoal (1 subgoal):\n 1. insertion f (replace_coeff (insertion f) (monom m1 a * monom m2 1)) =\n    insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))", "unfolding reduce_nested_mpoly_prod insertion_mult"], ["proof (prove)\nusing this:\n  replace_coeff (insertion f) (monom m1 a * monom m2 1) =\n  replace_coeff (insertion f) (monom m1 a) *\n  replace_coeff (insertion f) (monom m2 1)\n\ngoal (1 subgoal):\n 1. insertion f (replace_coeff (insertion f) (monom m1 a * monom m2 1)) =\n    insertion f (reduce_nested_mpoly (monom m1 a)) *\n    insertion f (reduce_nested_mpoly (monom m2 1))", "by (simp add: insertion_mult sum.IH(1) sum.IH(2))"], ["proof (state)\nthis:\n  insertion f (replace_coeff (insertion f) (monom m1 a * monom m2 1)) =\n  insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))\n\ngoal (1 subgoal):\n 1. \\<And>fa g k v a.\n       \\<lbrakk>\\<And>a.\n                   insertion f (replace_coeff (insertion f) (monom fa a)) =\n                   insertion f (reduce_nested_mpoly (monom fa a));\n        \\<And>a.\n           insertion f (replace_coeff (insertion f) (monom g a)) =\n           insertion f (reduce_nested_mpoly (monom g a));\n        g = Poly_Mapping.single k v; k \\<notin> keys fa\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (monom (fa + g) a)) =\n                         insertion f\n                          (reduce_nested_mpoly (monom (fa + g) a))", "then"], ["proof (chain)\npicking this:\n  insertion f (replace_coeff (insertion f) (monom m1 a * monom m2 1)) =\n  insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))", "show ?case"], ["proof (prove)\nusing this:\n  insertion f (replace_coeff (insertion f) (monom m1 a * monom m2 1)) =\n  insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))\n\ngoal (1 subgoal):\n 1. insertion f (replace_coeff (insertion f) (monom (m1 + m2) a)) =\n    insertion f (reduce_nested_mpoly (monom (m1 + m2) a))", "using mult_monom[of m1 a m2 1]"], ["proof (prove)\nusing this:\n  insertion f (replace_coeff (insertion f) (monom m1 a * monom m2 1)) =\n  insertion f (reduce_nested_mpoly (monom m1 a * monom m2 1))\n  monom m1 a * monom m2 1 = monom (m1 + m2) (a * 1)\n\ngoal (1 subgoal):\n 1. insertion f (replace_coeff (insertion f) (monom (m1 + m2) a)) =\n    insertion f (reduce_nested_mpoly (monom (m1 + m2) a))", "by auto"], ["proof (state)\nthis:\n  insertion f (replace_coeff (insertion f) (monom (m1 + m2) a)) =\n  insertion f (reduce_nested_mpoly (monom (m1 + m2) a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insertion f (replace_coeff (insertion f) (monom m a)) =\n  insertion f (reduce_nested_mpoly (monom m a))\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion f (replace_coeff (insertion f) p1) =\n                insertion f (reduce_nested_mpoly p1);\n        insertion f (replace_coeff (insertion f) p2) =\n        insertion f (reduce_nested_mpoly p2);\n        p2 = monom m a; m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (p1 + p2)) =\n                         insertion f (reduce_nested_mpoly (p1 + p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion f (replace_coeff (insertion f) p1) =\n                insertion f (reduce_nested_mpoly p1);\n        insertion f (replace_coeff (insertion f) p2) =\n        insertion f (reduce_nested_mpoly p2);\n        p2 = monom m a; m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (p1 + p2)) =\n                         insertion f (reduce_nested_mpoly (p1 + p2))", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  insertion f (replace_coeff (insertion f) p1) =\n  insertion f (reduce_nested_mpoly p1)\n  insertion f (replace_coeff (insertion f) p2) =\n  insertion f (reduce_nested_mpoly p2)\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion f (replace_coeff (insertion f) p1) =\n                insertion f (reduce_nested_mpoly p1);\n        insertion f (replace_coeff (insertion f) p2) =\n        insertion f (reduce_nested_mpoly p2);\n        p2 = monom m a; m \\<notin> keys (mapping_of p1)\\<rbrakk>\n       \\<Longrightarrow> insertion f\n                          (replace_coeff (insertion f) (p1 + p2)) =\n                         insertion f (reduce_nested_mpoly (p1 + p2))", "then"], ["proof (chain)\npicking this:\n  insertion f (replace_coeff (insertion f) p1) =\n  insertion f (reduce_nested_mpoly p1)\n  insertion f (replace_coeff (insertion f) p2) =\n  insertion f (reduce_nested_mpoly p2)\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)", "show ?case"], ["proof (prove)\nusing this:\n  insertion f (replace_coeff (insertion f) p1) =\n  insertion f (reduce_nested_mpoly p1)\n  insertion f (replace_coeff (insertion f) p2) =\n  insertion f (reduce_nested_mpoly p2)\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n\ngoal (1 subgoal):\n 1. insertion f (replace_coeff (insertion f) (p1 + p2)) =\n    insertion f (reduce_nested_mpoly (p1 + p2))", "using reduce_nested_mpoly_sum insertion_add\n    replace_coeff_add[of \"insertion f\", OF insertion_zero insertion_add]"], ["proof (prove)\nusing this:\n  insertion f (replace_coeff (insertion f) p1) =\n  insertion f (reduce_nested_mpoly p1)\n  insertion f (replace_coeff (insertion f) p2) =\n  insertion f (reduce_nested_mpoly p2)\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n  reduce_nested_mpoly (?p1.0 + ?p2.0) =\n  reduce_nested_mpoly ?p1.0 + reduce_nested_mpoly ?p2.0\n  insertion ?f (?p + ?q) = insertion ?f ?p + insertion ?f ?q\n  replace_coeff (insertion f) (?p1.0 + ?p2.0) =\n  replace_coeff (insertion f) ?p1.0 + replace_coeff (insertion f) ?p2.0\n\ngoal (1 subgoal):\n 1. insertion f (replace_coeff (insertion f) (p1 + p2)) =\n    insertion f (reduce_nested_mpoly (p1 + p2))", "by metis"], ["proof (state)\nthis:\n  insertion f (replace_coeff (insertion f) (p1 + p2)) =\n  insertion f (reduce_nested_mpoly (p1 + p2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replace_coeff_extract_var_cong:\nassumes \"f v = g v\"\nshows \"replace_coeff (insertion f) (extract_var p v) = replace_coeff (insertion g) (extract_var p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace_coeff (insertion f) (extract_var p v) =\n    replace_coeff (insertion g) (extract_var p v)", "by (induction p rule:mpoly_induct;simp add: assms extract_var_monom replace_coeff_monom\n  extract_var_sum insertion_add replace_coeff_add)"], ["", "lemma vars_replace_coeff:\nassumes \"f 0 = 0\"\nshows \"vars (replace_coeff f p) \\<subseteq> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (replace_coeff f p) \\<subseteq> vars p", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of (replace_coeff f p)))\n    \\<subseteq> \\<Union> (keys ` keys (mapping_of p))", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (keys `\n                 keys (mapping_of (replace_coeff f p))) \\<Longrightarrow>\n       x \\<in> \\<Union> (keys ` keys (mapping_of p))", "unfolding mem_simps(8) coeff_keys"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa\\<in>keys (mapping_of (replace_coeff f p)).\n          x \\<in> keys xa \\<Longrightarrow>\n       \\<exists>xa\\<in>keys (mapping_of p). x \\<in> keys xa", "using assms coeff_replace_coeff"], ["proof (prove)\nusing this:\n  f (0::'b) = (0::'a)\n  ?f (0::?'b) = (0::?'a) \\<Longrightarrow>\n  coeff (replace_coeff ?f ?p) ?m = ?f (coeff ?p ?m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa\\<in>keys (mapping_of (replace_coeff f p)).\n          x \\<in> keys xa \\<Longrightarrow>\n       \\<exists>xa\\<in>keys (mapping_of p). x \\<in> keys xa", "by (metis coeff_keys)"], ["", "(* Polynomial functions *)"], ["", "definition polyfun :: \"nat set \\<Rightarrow> ((nat \\<Rightarrow> 'a::comm_semiring_1) \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"polyfun N f = (\\<exists>p. vars p \\<subseteq> N \\<and> (\\<forall>x. insertion x p = f x))\""], ["", "lemma polyfunI: \"(\\<And>P. (\\<And>p. vars p \\<subseteq> N \\<Longrightarrow> (\\<And>x. insertion x p = f x) \\<Longrightarrow> P) \\<Longrightarrow> P) \\<Longrightarrow> polyfun N f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        (\\<And>p.\n            \\<lbrakk>vars p \\<subseteq> N;\n             \\<And>x. insertion x p = f x\\<rbrakk>\n            \\<Longrightarrow> P) \\<Longrightarrow>\n        P) \\<Longrightarrow>\n    polyfun N f", "unfolding polyfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        (\\<And>p.\n            \\<lbrakk>vars p \\<subseteq> N;\n             \\<And>x. insertion x p = f x\\<rbrakk>\n            \\<Longrightarrow> P) \\<Longrightarrow>\n        P) \\<Longrightarrow>\n    \\<exists>p.\n       vars p \\<subseteq> N \\<and> (\\<forall>x. insertion x p = f x)", "by metis"], ["", "lemma polyfun_subset: \"N\\<subseteq>N' \\<Longrightarrow> polyfun N f \\<Longrightarrow> polyfun N' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>N \\<subseteq> N'; polyfun N f\\<rbrakk>\n    \\<Longrightarrow> polyfun N' f", "unfolding polyfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>N \\<subseteq> N';\n     \\<exists>p.\n        vars p \\<subseteq> N \\<and>\n        (\\<forall>x. insertion x p = f x)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         vars p \\<subseteq> N' \\<and>\n                         (\\<forall>x. insertion x p = f x)", "by blast"], ["", "lemma polyfun_const: \"polyfun N (\\<lambda>_. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>_. c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>_. c)", "have \"\\<And>x. insertion x (monom 0 c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. insertion x (monom 0 c) = c", "using insertion_single"], ["proof (prove)\nusing this:\n  insertion ?f (monom (Poly_Mapping.single ?v ?n) ?a) = ?a * ?f ?v ^ ?n\n\ngoal (1 subgoal):\n 1. \\<And>x. insertion x (monom 0 c) = c", "by (metis insertion_one monom_one mult.commute mult.right_neutral single_zero)"], ["proof (state)\nthis:\n  insertion ?x (monom 0 c) = c\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>_. c)", "then"], ["proof (chain)\npicking this:\n  insertion ?x (monom 0 c) = c", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion ?x (monom 0 c) = c\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>_. c)", "unfolding polyfun_def"], ["proof (prove)\nusing this:\n  insertion ?x (monom 0 c) = c\n\ngoal (1 subgoal):\n 1. \\<exists>p. vars p \\<subseteq> N \\<and> (\\<forall>x. insertion x p = c)", "by (metis (full_types) empty_iff keys_single single_zero subsetI subset_antisym vars_monom_subset)"], ["proof (state)\nthis:\n  polyfun N (\\<lambda>_. c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polyfun_add:\nassumes \"polyfun N f\" \"polyfun N g\"\nshows \"polyfun N (\\<lambda>x. f x + g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x + g x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x + g x)", "obtain p1 p2 where \"vars p1 \\<subseteq> N\" \"\\<forall>x. insertion x p1 = f x\"\n                     \"vars p2 \\<subseteq> N\" \"\\<forall>x. insertion x p2 = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>vars p1 \\<subseteq> N; \\<forall>x. insertion x p1 = f x;\n         vars p2 \\<subseteq> N; \\<forall>x. insertion x p2 = g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using polyfun_def assms"], ["proof (prove)\nusing this:\n  polyfun ?N ?f =\n  (\\<exists>p.\n      vars p \\<subseteq> ?N \\<and> (\\<forall>x. insertion x p = ?f x))\n  polyfun N f\n  polyfun N g\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>vars p1 \\<subseteq> N; \\<forall>x. insertion x p1 = f x;\n         vars p2 \\<subseteq> N; \\<forall>x. insertion x p2 = g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  vars p1 \\<subseteq> N\n  \\<forall>x. insertion x p1 = f x\n  vars p2 \\<subseteq> N\n  \\<forall>x. insertion x p2 = g x\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x + g x)", "then"], ["proof (chain)\npicking this:\n  vars p1 \\<subseteq> N\n  \\<forall>x. insertion x p1 = f x\n  vars p2 \\<subseteq> N\n  \\<forall>x. insertion x p2 = g x", "have \"vars (p1 + p2) \\<subseteq> N\" \"\\<forall>x. insertion x (p1 + p2) = f x + g x\""], ["proof (prove)\nusing this:\n  vars p1 \\<subseteq> N\n  \\<forall>x. insertion x p1 = f x\n  vars p2 \\<subseteq> N\n  \\<forall>x. insertion x p2 = g x\n\ngoal (1 subgoal):\n 1. vars (p1 + p2) \\<subseteq> N &&&\n    \\<forall>x. insertion x (p1 + p2) = f x + g x", "using vars_add"], ["proof (prove)\nusing this:\n  vars p1 \\<subseteq> N\n  \\<forall>x. insertion x p1 = f x\n  vars p2 \\<subseteq> N\n  \\<forall>x. insertion x p2 = g x\n  vars (?p1.0 + ?p2.0) \\<subseteq> vars ?p1.0 \\<union> vars ?p2.0\n\ngoal (1 subgoal):\n 1. vars (p1 + p2) \\<subseteq> N &&&\n    \\<forall>x. insertion x (p1 + p2) = f x + g x", "using Un_iff subsetCE subsetI"], ["proof (prove)\nusing this:\n  vars p1 \\<subseteq> N\n  \\<forall>x. insertion x p1 = f x\n  vars p2 \\<subseteq> N\n  \\<forall>x. insertion x p2 = g x\n  vars (?p1.0 + ?p2.0) \\<subseteq> vars ?p1.0 \\<union> vars ?p2.0\n  (?c \\<in> ?A \\<union> ?B) = (?c \\<in> ?A \\<or> ?c \\<in> ?B)\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<notin> ?A \\<Longrightarrow> ?P;\n   ?c \\<in> ?B \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<in> ?B) \\<Longrightarrow>\n  ?A \\<subseteq> ?B\n\ngoal (1 subgoal):\n 1. vars (p1 + p2) \\<subseteq> N &&&\n    \\<forall>x. insertion x (p1 + p2) = f x + g x", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. insertion x (p1 + p2) = f x + g x", "by (simp add: \\<open>\\<forall>x. insertion x p1 = f x\\<close> \\<open>\\<forall>x. insertion x p2 = g x\\<close> insertion_add)"], ["proof (state)\nthis:\n  vars (p1 + p2) \\<subseteq> N\n  \\<forall>x. insertion x (p1 + p2) = f x + g x\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x + g x)", "then"], ["proof (chain)\npicking this:\n  vars (p1 + p2) \\<subseteq> N\n  \\<forall>x. insertion x (p1 + p2) = f x + g x", "show ?thesis"], ["proof (prove)\nusing this:\n  vars (p1 + p2) \\<subseteq> N\n  \\<forall>x. insertion x (p1 + p2) = f x + g x\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x + g x)", "using polyfun_def"], ["proof (prove)\nusing this:\n  vars (p1 + p2) \\<subseteq> N\n  \\<forall>x. insertion x (p1 + p2) = f x + g x\n  polyfun ?N ?f =\n  (\\<exists>p.\n      vars p \\<subseteq> ?N \\<and> (\\<forall>x. insertion x p = ?f x))\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x + g x)", "by blast"], ["proof (state)\nthis:\n  polyfun N (\\<lambda>x. f x + g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polyfun_mult:\nassumes \"polyfun N f\" \"polyfun N g\"\nshows \"polyfun N (\\<lambda>x. f x * g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x * g x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x * g x)", "obtain p1 p2 where \"vars p1 \\<subseteq> N\" \"\\<forall>x. insertion x p1 = f x\"\n                     \"vars p2 \\<subseteq> N\" \"\\<forall>x. insertion x p2 = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>vars p1 \\<subseteq> N; \\<forall>x. insertion x p1 = f x;\n         vars p2 \\<subseteq> N; \\<forall>x. insertion x p2 = g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using polyfun_def assms"], ["proof (prove)\nusing this:\n  polyfun ?N ?f =\n  (\\<exists>p.\n      vars p \\<subseteq> ?N \\<and> (\\<forall>x. insertion x p = ?f x))\n  polyfun N f\n  polyfun N g\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>vars p1 \\<subseteq> N; \\<forall>x. insertion x p1 = f x;\n         vars p2 \\<subseteq> N; \\<forall>x. insertion x p2 = g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  vars p1 \\<subseteq> N\n  \\<forall>x. insertion x p1 = f x\n  vars p2 \\<subseteq> N\n  \\<forall>x. insertion x p2 = g x\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x * g x)", "then"], ["proof (chain)\npicking this:\n  vars p1 \\<subseteq> N\n  \\<forall>x. insertion x p1 = f x\n  vars p2 \\<subseteq> N\n  \\<forall>x. insertion x p2 = g x", "have \"vars (p1 * p2) \\<subseteq> N\" \"\\<forall>x. insertion x (p1 * p2) = f x * g x\""], ["proof (prove)\nusing this:\n  vars p1 \\<subseteq> N\n  \\<forall>x. insertion x p1 = f x\n  vars p2 \\<subseteq> N\n  \\<forall>x. insertion x p2 = g x\n\ngoal (1 subgoal):\n 1. vars (p1 * p2) \\<subseteq> N &&&\n    \\<forall>x. insertion x (p1 * p2) = f x * g x", "using vars_mult"], ["proof (prove)\nusing this:\n  vars p1 \\<subseteq> N\n  \\<forall>x. insertion x p1 = f x\n  vars p2 \\<subseteq> N\n  \\<forall>x. insertion x p2 = g x\n  vars (?p * ?q) \\<subseteq> vars ?p \\<union> vars ?q\n\ngoal (1 subgoal):\n 1. vars (p1 * p2) \\<subseteq> N &&&\n    \\<forall>x. insertion x (p1 * p2) = f x * g x", "using Un_iff subsetCE subsetI"], ["proof (prove)\nusing this:\n  vars p1 \\<subseteq> N\n  \\<forall>x. insertion x p1 = f x\n  vars p2 \\<subseteq> N\n  \\<forall>x. insertion x p2 = g x\n  vars (?p * ?q) \\<subseteq> vars ?p \\<union> vars ?q\n  (?c \\<in> ?A \\<union> ?B) = (?c \\<in> ?A \\<or> ?c \\<in> ?B)\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<notin> ?A \\<Longrightarrow> ?P;\n   ?c \\<in> ?B \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<in> ?B) \\<Longrightarrow>\n  ?A \\<subseteq> ?B\n\ngoal (1 subgoal):\n 1. vars (p1 * p2) \\<subseteq> N &&&\n    \\<forall>x. insertion x (p1 * p2) = f x * g x", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. insertion x (p1 * p2) = f x * g x", "by (simp add: \\<open>\\<forall>x. insertion x p1 = f x\\<close> \\<open>\\<forall>x. insertion x p2 = g x\\<close> insertion_mult)"], ["proof (state)\nthis:\n  vars (p1 * p2) \\<subseteq> N\n  \\<forall>x. insertion x (p1 * p2) = f x * g x\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x * g x)", "then"], ["proof (chain)\npicking this:\n  vars (p1 * p2) \\<subseteq> N\n  \\<forall>x. insertion x (p1 * p2) = f x * g x", "show ?thesis"], ["proof (prove)\nusing this:\n  vars (p1 * p2) \\<subseteq> N\n  \\<forall>x. insertion x (p1 * p2) = f x * g x\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x * g x)", "using polyfun_def"], ["proof (prove)\nusing this:\n  vars (p1 * p2) \\<subseteq> N\n  \\<forall>x. insertion x (p1 * p2) = f x * g x\n  polyfun ?N ?f =\n  (\\<exists>p.\n      vars p \\<subseteq> ?N \\<and> (\\<forall>x. insertion x p = ?f x))\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. f x * g x)", "by blast"], ["proof (state)\nthis:\n  polyfun N (\\<lambda>x. f x * g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polyfun_Sum:\nassumes \"finite I\"\nassumes \"\\<And>i. i\\<in>I \\<Longrightarrow> polyfun N (f i)\"\nshows \"polyfun N (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. \\<Sum>i\\<in>I. f i x)", "using assms"], ["proof (prove)\nusing this:\n  finite I\n  ?i \\<in> I \\<Longrightarrow> polyfun N (f ?i)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. \\<Sum>i\\<in>I. f i x)", "apply (induction I rule:finite_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i \\<in> {} \\<Longrightarrow> polyfun N (f i)) \\<Longrightarrow>\n    polyfun N (\\<lambda>x. \\<Sum>i\\<in>{}. f i x)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> polyfun N (f i)) \\<Longrightarrow>\n        polyfun N (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> polyfun N (f i)\\<rbrakk>\n       \\<Longrightarrow> polyfun N\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "apply (simp add: polyfun_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> polyfun N (f i)) \\<Longrightarrow>\n        polyfun N (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> polyfun N (f i)\\<rbrakk>\n       \\<Longrightarrow> polyfun N\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "using comm_monoid_add_class.sum.insert polyfun_add"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> sum ?g (insert ?x ?A) = ?g ?x + sum ?g ?A\n  \\<lbrakk>polyfun ?N ?f; polyfun ?N ?g\\<rbrakk>\n  \\<Longrightarrow> polyfun ?N (\\<lambda>x. ?f x + ?g x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> polyfun N (f i)) \\<Longrightarrow>\n        polyfun N (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> polyfun N (f i)\\<rbrakk>\n       \\<Longrightarrow> polyfun N\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "by fastforce"], ["", "lemma polyfun_Prod:\nassumes \"finite I\"\nassumes \"\\<And>i. i\\<in>I \\<Longrightarrow> polyfun N (f i)\"\nshows \"polyfun N (\\<lambda>x. \\<Prod>i\\<in>I. f i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. \\<Prod>i\\<in>I. f i x)", "using assms"], ["proof (prove)\nusing this:\n  finite I\n  ?i \\<in> I \\<Longrightarrow> polyfun N (f ?i)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. \\<Prod>i\\<in>I. f i x)", "apply (induction I rule:finite_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i \\<in> {} \\<Longrightarrow> polyfun N (f i)) \\<Longrightarrow>\n    polyfun N (\\<lambda>x. \\<Prod>i\\<in>{}. f i x)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> polyfun N (f i)) \\<Longrightarrow>\n        polyfun N (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> polyfun N (f i)\\<rbrakk>\n       \\<Longrightarrow> polyfun N\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "apply (simp add: polyfun_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> polyfun N (f i)) \\<Longrightarrow>\n        polyfun N (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> polyfun N (f i)\\<rbrakk>\n       \\<Longrightarrow> polyfun N\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "using comm_monoid_add_class.sum.insert polyfun_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> sum ?g (insert ?x ?A) = ?g ?x + sum ?g ?A\n  \\<lbrakk>polyfun ?N ?f; polyfun ?N ?g\\<rbrakk>\n  \\<Longrightarrow> polyfun ?N (\\<lambda>x. ?f x * ?g x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> polyfun N (f i)) \\<Longrightarrow>\n        polyfun N (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> polyfun N (f i)\\<rbrakk>\n       \\<Longrightarrow> polyfun N\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "by fastforce"], ["", "lemma polyfun_single:\nassumes \"i\\<in>N\"\nshows \"polyfun N (\\<lambda>x. x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. x i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. x i)", "have \"\\<forall>f. insertion f (monom (Poly_Mapping.single i 1) 1) = f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f. insertion f (monom (Poly_Mapping.single i 1) (1::'b)) = f i", "using insertion_single"], ["proof (prove)\nusing this:\n  insertion ?f (monom (Poly_Mapping.single ?v ?n) ?a) = ?a * ?f ?v ^ ?n\n\ngoal (1 subgoal):\n 1. \\<forall>f. insertion f (monom (Poly_Mapping.single i 1) (1::'b)) = f i", "by simp"], ["proof (state)\nthis:\n  \\<forall>f. insertion f (monom (Poly_Mapping.single i 1) (1::?'b1)) = f i\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. x i)", "then"], ["proof (chain)\npicking this:\n  \\<forall>f. insertion f (monom (Poly_Mapping.single i 1) (1::?'b1)) = f i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f. insertion f (monom (Poly_Mapping.single i 1) (1::?'b1)) = f i\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. x i)", "unfolding polyfun_def"], ["proof (prove)\nusing this:\n  \\<forall>f. insertion f (monom (Poly_Mapping.single i 1) (1::?'b1)) = f i\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       vars p \\<subseteq> N \\<and> (\\<forall>x. insertion x p = x i)", "using vars_monom_single[of i 1 1] One_nat_def assms singletonD subset_eq"], ["proof (prove)\nusing this:\n  \\<forall>f. insertion f (monom (Poly_Mapping.single i 1) (1::?'b1)) = f i\n  vars (monom (Poly_Mapping.single i 1) (1::?'b1)) \\<subseteq> {i}\n  1 = Suc 0\n  i \\<in> N\n  ?b \\<in> {?a} \\<Longrightarrow> ?b = ?a\n  (?A \\<subseteq> ?B) = (\\<forall>x\\<in>?A. x \\<in> ?B)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       vars p \\<subseteq> N \\<and> (\\<forall>x. insertion x p = x i)", "by blast"], ["proof (state)\nthis:\n  polyfun N (\\<lambda>x. x i)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}