{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/Polynomials.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma eval_monom_list[simp]: \"eval_monom_list \\<alpha> (m @ n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n\"", "lemma sum_var_list_not: \"x \\<notin> fst ` set m \\<Longrightarrow> sum_var_list m x = 0\"", "lemma monom_inv_Cons: assumes \"monom_inv ((x,p) # m)\" \n  and \"y \\<le> x\" shows \"y \\<notin> fst ` set m\"", "lemma eq_monom_sum_var_list: assumes \"monom_inv m\" and \"monom_inv n\"\n  shows \"(m = n) = (\\<forall> x. sum_var_list m x = sum_var_list n x)\" (is \"?l = ?r\")", "lemma monom_list_mult_list_vars: \"monom_list_vars (monom_mult_list m1 m2) = monom_list_vars m1 \\<union> monom_list_vars m2\"", "lemma monom_mult_list_inv: \"monom_inv m1 \\<Longrightarrow> monom_inv m2 \\<Longrightarrow> monom_inv (monom_mult_list m1 m2)\"", "lemma monom_inv_ConsD: \"monom_inv (x # xs) \\<Longrightarrow> monom_inv xs\"", "lemma sum_var_list_monom_mult_list:  \"sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x\"", "lemma monom_mult_list_inj: assumes m: \"monom_inv m\" and m1: \"monom_inv m1\" and m2: \"monom_inv m2\"\n  and eq: \"monom_mult_list m m1 = monom_mult_list m m2\"\n  shows \"m1 = m2\"", "lemma monom_mult_list[simp]: \"eval_monom_list \\<alpha> (monom_mult_list m n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n\"", "lemma eq_monom_sum_var: \"m = n \\<longleftrightarrow> (\\<forall> x. sum_var m x = sum_var n x)\"", "lemma eval_monom_mult[simp]: \"eval_monom \\<alpha> (m * n) = eval_monom \\<alpha> m * eval_monom \\<alpha> n\"", "lemma sum_var_monom_mult:  \"sum_var (m * n) x = sum_var m x + sum_var n x\"", "lemma monom_mult_inj: fixes m1 :: \"_ monom\"\n  shows \"m * m1 = m * m2 \\<Longrightarrow> m1 = m2\"", "lemma one_monom_inv_sum_var_inv[simp]: \"sum_var 1 x = 0\"", "lemma eval_monom_1[simp]: \"eval_monom  \\<alpha> 1 = 1\"", "lemma var_monom_1[simp]: \"var_monom x \\<noteq> 1\"", "lemma eval_var_monom[simp]: \"eval_monom \\<alpha> (var_monom x) = \\<alpha> x\"", "lemma sum_var_monom_var: \"sum_var (var_monom x) y = (if x = y then 1 else 0)\"", "lemma poly_const[simp]: \"eval_poly \\<alpha> (poly_const a) = a\"", "lemma poly_const_inv: \"poly_inv (poly_const a)\"", "lemma eval_poly_append[simp]: \"eval_poly \\<alpha> (mc1 @ mc2) = eval_poly \\<alpha> mc1 + eval_poly \\<alpha> mc2\"", "lemma poly_add_monoms: \"poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2\"", "lemma poly_add_inv: \"poly_inv p \\<Longrightarrow> poly_inv q \\<Longrightarrow> poly_inv (poly_add p q)\"", "lemma poly_add[simp]: \"eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q\"", "lemma monom_mult_poly_inv: \"poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m,c) p)\"", "lemma monom_mult_poly[simp]: \"eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p\"", "lemma poly_minus[simp]: \"eval_poly \\<alpha> (poly_minus f g) = eval_poly \\<alpha> f - eval_poly \\<alpha> g\"", "lemma poly_minus_inv: \"poly_inv f \\<Longrightarrow> poly_inv g \\<Longrightarrow> poly_inv (poly_minus f g)\"", "lemma poly_mult_inv: assumes p: \"poly_inv p\" and q: \"poly_inv q\"\n  shows \"poly_inv (poly_mult p q)\"", "lemma poly_mult[simp]: \"eval_poly \\<alpha> (poly_mult p q) = eval_poly \\<alpha> p * eval_poly \\<alpha> q\"", "lemma zero_poly_inv: \"poly_inv zero_poly\"", "lemma one_poly_inv: \"poly_inv one_poly\"", "lemma poly_one[simp]: \"eval_poly \\<alpha> one_poly = 1\"", "lemma poly_zero_add: \"poly_add zero_poly p = p\"", "lemma poly_zero_mult: \"poly_mult zero_poly p = zero_poly\"", "lemma poly_one_mult: \"poly_mult one_poly p =p p\"", "lemma eq_poly_refl[simp]: \"p =p p\"", "lemma eq_poly_trans[trans]: \"\\<lbrakk>p1 =p p2; p2 =p p3\\<rbrakk> \\<Longrightarrow> p1 =p p3\"", "lemma poly_add_comm: \"poly_add p q =p poly_add q p\"", "lemma poly_add_assoc: \"poly_add p1 (poly_add p2 p3) =p poly_add (poly_add p1 p2) p3\"", "lemma poly_mult_comm: \"poly_mult p q =p poly_mult q p\"", "lemma poly_mult_assoc: \"poly_mult p1 (poly_mult p2 p3) =p poly_mult (poly_mult p1 p2) p3\"", "lemma poly_distrib: \"poly_mult p (poly_add q1 q2) =p poly_add (poly_mult p q1) (poly_mult p q2)\"", "lemma poly_of: \"eval_poly \\<alpha> (poly_of p) = eval_tpoly \\<alpha> p\"", "lemma poly_of_inv: \"poly_inv (poly_of p)\"", "lemma poly_power[simp]: \"eval_poly \\<alpha> (poly_power p n) = (eval_poly \\<alpha> p) ^ n\"", "lemma poly_power_inv: assumes p: \"poly_inv p\" \n  shows \"poly_inv (poly_power p n)\"", "lemma monom_list_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" \n  shows \"poly_inv (monom_list_subst \\<sigma> m)\"", "lemma monom_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" \n  shows \"poly_inv (monom_subst \\<sigma> m)\"", "lemma monom_subst[simp]: \"eval_poly \\<alpha> (monom_subst \\<sigma> m) = eval_monom (\\<lambda> v. eval_poly \\<alpha> (\\<sigma> v)) m\"", "lemma poly_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" and p: \"poly_inv p\"\n  shows \"poly_inv (poly_subst \\<sigma> p)\"", "lemma poly_subst: \"eval_poly \\<alpha> (poly_subst \\<sigma> p) = eval_poly (\\<lambda> v. eval_poly \\<alpha> (\\<sigma> v)) p\"", "lemma eval_poly_subst: \n  assumes eq: \"\\<And> w. f w = eval_poly g (q w)\"\n  shows \"eval_poly f p = eval_poly g (poly_subst q p)\"", "lemma monom_vars_list_subst: assumes \"\\<And> w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w\" \n  shows \"monom_subst f m = monom_subst g m\"", "lemma eval_monom_vars_list: assumes \"\\<And> x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\"\n  shows \"eval_monom \\<alpha> xs = eval_monom \\<beta> xs\"", "lemma monom_vars_list_1[simp]: \"monom_vars_list 1 = []\"", "lemma monom_vars_list_var_monom[simp]: \"monom_vars_list (var_monom x) = [x]\"", "lemma monom_vars_eval_monom: \n  \"(\\<And> x. x \\<in> monom_vars m \\<Longrightarrow> f x = g x) \\<Longrightarrow> eval_monom f m = eval_monom g m\"", "lemma poly_vars_list[simp]: \"set (poly_vars_list p) = poly_vars p\"", "lemma poly_vars: assumes eq: \"\\<And> w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w\"\n  shows \"poly_subst f p = poly_subst g p\"", "lemma poly_var: assumes pv: \"v \\<notin> poly_vars p\" and diff: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  shows \"poly_subst f p = poly_subst g p\"", "lemma eval_poly_vars: assumes \"\\<And> x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x\"\n  shows \"eval_poly \\<alpha> p = eval_poly \\<beta> p\"", "lemma poly_ge_refl[simp]: \"p \\<ge>p p\"", "lemma poly_ge_trans[trans]: \"\\<lbrakk>p1 \\<ge>p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 \\<ge>p p3\"", "lemma pos_assign_monom_list: fixes \\<alpha> :: \"('v :: linorder, 'a :: poly_carrier)assign\"\n  assumes pos: \"pos_assign \\<alpha>\"\n  shows \"eval_monom_list \\<alpha> m \\<ge> 0\"", "lemma pos_assign_monom: fixes \\<alpha> :: \"('v :: linorder, 'a :: poly_carrier)assign\"\n  assumes pos: \"pos_assign \\<alpha>\"\n  shows \"eval_monom \\<alpha> m \\<ge> 0\"", "lemma pos_assign_poly:   assumes pos: \"pos_assign \\<alpha>\"\n  and p: \"p \\<ge>p zero_poly\"\n  shows \"eval_poly \\<alpha> p \\<ge> 0\"", "lemma poly_add_ge_mono: assumes \"p1 \\<ge>p p2\" shows \"poly_add p1 q \\<ge>p poly_add p2 q\"", "lemma poly_mult_ge_mono: assumes \"p1 \\<ge>p p2\" and \"q \\<ge>p zero_poly\"\n  shows \"poly_mult p1 q \\<ge>p poly_mult p2 q\"", "lemma poly_gt_imp_poly_ge: \"p >p q \\<Longrightarrow> p \\<ge>p q\"", "lemma poly_compat: \"\\<lbrakk>p1 \\<ge>p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"", "lemma poly_compat2: \"\\<lbrakk>p1 >p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"", "lemma poly_gt_trans[trans]: \"\\<lbrakk>p1 >p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\"", "lemma poly_GT_SN: \"SN poly_GT\"", "lemma eval_monom_list_mono: assumes fg: \"\\<And> x. (f :: ('v :: linorder,'a :: poly_carrier)assign) x \\<ge> g x\" \n  and g: \"\\<And> x. g x \\<ge> 0\"\n  shows \"eval_monom_list f m \\<ge> eval_monom_list g m\" \"eval_monom_list g m \\<ge> 0\"", "lemma eval_monom_mono: assumes fg: \"\\<And> x. (f :: ('v :: linorder,'a :: poly_carrier)assign) x \\<ge> g x\" \n  and g: \"\\<And> x. g x \\<ge> 0\"\nshows \"eval_monom f m \\<ge> eval_monom g m\" \"eval_monom g m \\<ge> 0\"", "lemma poly_weak_mono_all_E: assumes p: \"poly_weak_mono_all p\" and \n  ge: \"\\<And> x. f x \\<ge>p g x \\<and> g x \\<ge>p zero_poly\"\n  shows \"poly_subst f p \\<ge>p poly_subst g p\"", "lemma poly_weak_mono_E: assumes p: \"poly_weak_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v \\<ge>p g v\"\n  shows \"poly_subst f p \\<ge>p poly_subst g p\"", "lemma poly_weak_anti_mono_E: assumes p: \"poly_weak_anti_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v \\<ge>p g v\"\n  shows \"poly_subst g p \\<ge>p poly_subst f p\"", "lemma poly_weak_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes mono: \"\\<And> v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v\"\n  shows \"poly_weak_mono_all p\"", "lemma poly_weak_mono_all: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\" \n  assumes p: \"poly_weak_mono_all p\"\n  shows \"poly_weak_mono p v\"", "lemma poly_weak_mono_all_pos: \n  fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes pos_at_zero: \"eval_poly (\\<lambda> w. 0) p \\<ge> 0\"\n  and mono: \"poly_weak_mono_all p\"\n  shows \"p \\<ge>p zero_poly\"", "lemma poly_strict_mono_E: assumes p: \"poly_strict_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v >p g v\"\n  shows \"poly_subst f p >p poly_subst g p\"", "lemma poly_add_gt_mono: assumes \"p1 >p p2\" shows \"poly_add p1 q >p poly_add p2 q\"", "lemma poly_mult_gt_mono: \n  fixes q :: \"('v :: linorder,'a)poly\"\n  assumes gt: \"p1 >p p2\" and mono: \"q \\<ge>p one_poly\"\n  shows \"poly_mult p1 q >p poly_mult p2 q\"", "lemma monom_list_degree: \"eval_monom_list (\\<lambda> _. x) m = x ^ monom_list_degree m\"", "lemma monom_list_var_monom[simp]: \"monom_list (var_monom x) = [(x,1)]\"", "lemma monom_list_1[simp]: \"monom_list 1 = []\"", "lemma monom_degree: \"eval_monom (\\<lambda> _. x) m = x ^ monom_degree m\"", "lemma poly_coeff_sum: \"poly_coeff_sum p \\<ge> 0\"", "lemma poly_degree: assumes x: \"x \\<ge> (1 :: 'a :: poly_carrier)\" \n  shows \"poly_coeff_sum p * (x ^ poly_degree p) \\<ge> eval_poly (\\<lambda> _. x) p\"", "lemma poly_degree_bound: assumes x: \"x \\<ge> (1 :: 'a :: poly_carrier)\" \n  and c: \"c \\<ge> poly_coeff_sum p\"\n  and d: \"d \\<ge> poly_degree p\"\n  shows \"c * (x ^ d) \\<ge> eval_poly (\\<lambda> _. x) p\"", "lemma poly_split: assumes \"poly_split m p = (c,q)\"\n  shows \"p =p (m,c) # q\"", "lemma poly_split_eval: assumes \"poly_split m p = (c,q)\" \n  shows \"eval_poly \\<alpha> p = (eval_monom \\<alpha> m * c) + eval_poly \\<alpha> q\"", "lemma check_poly_eq: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes chk: \"check_poly_eq p q\"\n  shows \"p =p q\"", "lemma check_poly_ge: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_ge p q \\<Longrightarrow> p \\<ge>p q\"", "lemma check_poly_weak_mono_all: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_mono_all p\" shows  \"poly_weak_mono_all p\"", "lemma check_poly_weak_mono_all_pos: \n  assumes \"check_poly_weak_mono_all p\" shows  \"p \\<ge>p zero_poly\"", "lemma check_poly_weak_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_weak_mono_discrete p v\"\n  shows \"poly_weak_mono p v\"", "lemma check_poly_weak_anti_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_weak_anti_mono_discrete p v\"\n  shows \"poly_weak_anti_mono p v\"", "lemma check_poly_weak_mono_and_pos: \n  fixes p :: \"('v :: linorder,'a)poly\"\n  assumes \"check_poly_weak_mono_and_pos discrete p\"\n  shows \"poly_weak_mono_all p \\<and> (p \\<ge>p zero_poly)\"", "lemma check_poly_weak_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_mono p v\" shows  \"poly_weak_mono p v\"", "lemma (in poly_order_carrier) check_poly_weak_mono_smart: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_weak_mono_smart discrete p v \\<Longrightarrow> poly_weak_mono p v\"", "lemma check_poly_weak_anti_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_anti_mono p v\" shows  \"poly_weak_anti_mono p v\"", "lemma (in poly_order_carrier) check_poly_weak_anti_mono_smart: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_weak_anti_mono_smart discrete p v \\<Longrightarrow> poly_weak_anti_mono p v\"", "lemma univariate_power_list: assumes \"monom_inv m\" \"univariate_power_list x m = Some n\" \n  shows \"sum_var_list m = (\\<lambda> y. if x = y then n else 0)\" \n   \"eval_monom_list \\<alpha> m = ((\\<alpha> x)^n)\" \n   \"n \\<ge> 1\"", "lemma univariate_power: assumes \"univariate_power x m = Some n\" \n  shows \"sum_var m = (\\<lambda> y. if x = y then n else 0)\" \n   \"eval_monom \\<alpha> m = ((\\<alpha> x)^n)\"\n   \"n \\<ge> 1\"", "lemma univariate_power_var_monom: \"univariate_power y (var_monom x) = (if x = y then Some 1 else None)\"", "lemma check_monom_strict_mono: fixes \\<alpha> \\<beta> :: \"('v :: linorder,'a)assign\" and v :: 'v and m :: \"'v monom\"\n  assumes check: \"check_monom_strict_mono power_mono m v\"\n  and gt: \"\\<alpha> v \\<succ> \\<beta> v\"\n  and ge: \"\\<beta> v \\<ge> 0\"\nshows \"eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\"", "lemma check_poly_strict_mono: \n  assumes check1: \"check_poly_strict_mono power_mono p v\"\n  and check2: \"check_poly_weak_mono_all p\"\n  shows \"poly_strict_mono p v\"", "lemma check_poly_gt: \n  fixes p :: \"('v :: linorder,'a)poly\"\n  assumes \"check_poly_gt gt p q\" shows \"p >p q\"", "lemma check_poly_strict_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_strict_mono_discrete gt p v\"\n  shows \"poly_strict_mono p v\"", "lemma check_poly_strict_mono_smart: \n  assumes check1: \"check_poly_strict_mono_smart discrete power_mono gt p v\"\n  and check2: \"check_poly_weak_mono_and_pos discrete p\"\n  shows \"poly_strict_mono p v\""], "translations": [["", "lemma eval_monom_list[simp]: \"eval_monom_list \\<alpha> (m @ n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> (m @ n) =\n    eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n", "by (induct m, auto simp: field_simps)"], ["", "definition sum_var_list :: \"'a monom_list \\<Rightarrow> 'a \\<Rightarrow> nat\" where\n  \"sum_var_list m x \\<equiv> sum_list (map (\\<lambda> (y,c). if x = y then c else 0) m)\""], ["", "lemma sum_var_list_not: \"x \\<notin> fst ` set m \\<Longrightarrow> sum_var_list m x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set m \\<Longrightarrow> sum_var_list m x = 0", "unfolding sum_var_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set m \\<Longrightarrow>\n    (\\<Sum>(y, c)\\<leftarrow>m. if x = y then c else 0) = 0", "by (induct m, auto)"], ["", "text \\<open>\nshow that equality of monomials is equivalent to statement that \nall variables occur with the same (accumulated) power;\nafterwards properties like transitivity, etc. are easy to prove\\<close>"], ["", "lemma monom_inv_Cons: assumes \"monom_inv ((x,p) # m)\" \n  and \"y \\<le> x\" shows \"y \\<notin> fst ` set m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m", "define M where \"M = map fst m\""], ["proof (state)\nthis:\n  M = map fst m\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m", "from assms[unfolded monom_inv_def]"], ["proof (chain)\npicking this:\n  (\\<forall>(x, n)\\<in>set ((x, p) # m). 1 \\<le> n) \\<and>\n  distinct (map fst ((x, p) # m)) \\<and> sorted (map fst ((x, p) # m))\n  y \\<le> x", "have \"distinct (x # map fst m)\" \"sorted (x # map fst m)\""], ["proof (prove)\nusing this:\n  (\\<forall>(x, n)\\<in>set ((x, p) # m). 1 \\<le> n) \\<and>\n  distinct (map fst ((x, p) # m)) \\<and> sorted (map fst ((x, p) # m))\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. distinct (x # map fst m) &&& sorted (x # map fst m)", "by auto"], ["proof (state)\nthis:\n  distinct (x # map fst m)\n  sorted (x # map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m", "with assms(2)"], ["proof (chain)\npicking this:\n  y \\<le> x\n  distinct (x # map fst m)\n  sorted (x # map fst m)", "have \"y \\<notin> set (map fst m)\""], ["proof (prove)\nusing this:\n  y \\<le> x\n  distinct (x # map fst m)\n  sorted (x # map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> set (map fst m)", "unfolding M_def[symmetric]"], ["proof (prove)\nusing this:\n  y \\<le> x\n  distinct (x # M)\n  sorted (x # M)\n\ngoal (1 subgoal):\n 1. y \\<notin> set M", "by (induct M, auto)"], ["proof (state)\nthis:\n  y \\<notin> set (map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<notin> set (map fst m)\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set m", "by auto"], ["proof (state)\nthis:\n  y \\<notin> fst ` set m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_monom_sum_var_list: assumes \"monom_inv m\" and \"monom_inv n\"\n  shows \"(m = n) = (\\<forall> x. sum_var_list m x = sum_var_list n x)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x)", "using assms"], ["proof (prove)\nusing this:\n  monom_inv m\n  monom_inv n\n\ngoal (1 subgoal):\n 1. (m = n) = (\\<forall>x. sum_var_list m x = sum_var_list n x)", "proof (induct m arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk>\n       \\<Longrightarrow> ([] = n) =\n                         (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk>\n                   \\<Longrightarrow> (m = n) =\n                                     (\\<forall>x.\n   sum_var_list m x = sum_var_list n x);\n        monom_inv (a # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> (a # m = n) =\n                         (\\<forall>x.\n                             sum_var_list (a # m) x = sum_var_list n x)", "case Nil"], ["proof (state)\nthis:\n  monom_inv []\n  monom_inv n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk>\n       \\<Longrightarrow> ([] = n) =\n                         (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk>\n                   \\<Longrightarrow> (m = n) =\n                                     (\\<forall>x.\n   sum_var_list m x = sum_var_list n x);\n        monom_inv (a # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> (a # m = n) =\n                         (\\<forall>x.\n                             sum_var_list (a # m) x = sum_var_list n x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow>\n    ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list.\n       n = a # list \\<Longrightarrow>\n       ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)", "case (Cons yp nn)"], ["proof (state)\nthis:\n  n = yp # nn\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow>\n    ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list.\n       n = a # list \\<Longrightarrow>\n       ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)", "obtain y p where yp: \"yp = (y,p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y p. yp = (y, p) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases yp, auto)"], ["proof (state)\nthis:\n  yp = (y, p)\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow>\n    ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list.\n       n = a # list \\<Longrightarrow>\n       ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)", "with Cons Nil(2)[unfolded monom_inv_def]"], ["proof (chain)\npicking this:\n  n = yp # nn\n  (\\<forall>(x, n)\\<in>set n. 1 \\<le> n) \\<and>\n  distinct (map fst n) \\<and> sorted (map fst n)\n  yp = (y, p)", "have p: \"0 < p\""], ["proof (prove)\nusing this:\n  n = yp # nn\n  (\\<forall>(x, n)\\<in>set n. 1 \\<le> n) \\<and>\n  distinct (map fst n) \\<and> sorted (map fst n)\n  yp = (y, p)\n\ngoal (1 subgoal):\n 1. 0 < p", "by auto"], ["proof (state)\nthis:\n  0 < p\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow>\n    ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n 2. \\<And>a list.\n       n = a # list \\<Longrightarrow>\n       ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)", "by (simp add: Cons, rule exI[of _ y], simp add: sum_var_list_def yp p)"], ["proof (state)\nthis:\n  ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. n = [] \\<Longrightarrow>\n    ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)", "qed simp"], ["proof (state)\nthis:\n  ([] = n) = (\\<forall>x. sum_var_list [] x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. \\<And>a m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk>\n                   \\<Longrightarrow> (m = n) =\n                                     (\\<forall>x.\n   sum_var_list m x = sum_var_list n x);\n        monom_inv (a # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> (a # m = n) =\n                         (\\<forall>x.\n                             sum_var_list (a # m) x = sum_var_list n x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk>\n                   \\<Longrightarrow> (m = n) =\n                                     (\\<forall>x.\n   sum_var_list m x = sum_var_list n x);\n        monom_inv (a # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> (a # m = n) =\n                         (\\<forall>x.\n                             sum_var_list (a # m) x = sum_var_list n x)", "case (Cons xp m)"], ["proof (state)\nthis:\n  \\<lbrakk>monom_inv m; monom_inv ?n\\<rbrakk>\n  \\<Longrightarrow> (m = ?n) =\n                    (\\<forall>x. sum_var_list m x = sum_var_list ?n x)\n  monom_inv (xp # m)\n  monom_inv n\n\ngoal (1 subgoal):\n 1. \\<And>a m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk>\n                   \\<Longrightarrow> (m = n) =\n                                     (\\<forall>x.\n   sum_var_list m x = sum_var_list n x);\n        monom_inv (a # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> (a # m = n) =\n                         (\\<forall>x.\n                             sum_var_list (a # m) x = sum_var_list n x)", "obtain x p where xp: \"xp = (x,p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x p. xp = (x, p) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xp, auto)"], ["proof (state)\nthis:\n  xp = (x, p)\n\ngoal (1 subgoal):\n 1. \\<And>a m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk>\n                   \\<Longrightarrow> (m = n) =\n                                     (\\<forall>x.\n   sum_var_list m x = sum_var_list n x);\n        monom_inv (a # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> (a # m = n) =\n                         (\\<forall>x.\n                             sum_var_list (a # m) x = sum_var_list n x)", "with Cons(2)"], ["proof (chain)\npicking this:\n  monom_inv (xp # m)\n  xp = (x, p)", "have p: \"0 < p\" and x: \"x \\<notin> fst ` set m\" and m: \"monom_inv m\""], ["proof (prove)\nusing this:\n  monom_inv (xp # m)\n  xp = (x, p)\n\ngoal (1 subgoal):\n 1. 0 < p &&& x \\<notin> fst ` set m &&& monom_inv m", "unfolding monom_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>(x, n)\\<in>set (xp # m). 1 \\<le> n) \\<and>\n  distinct (map fst (xp # m)) \\<and> sorted (map fst (xp # m))\n  xp = (x, p)\n\ngoal (1 subgoal):\n 1. 0 < p &&&\n    x \\<notin> fst ` set m &&&\n    (\\<forall>(x, n)\\<in>set m. 1 \\<le> n) \\<and>\n    distinct (map fst m) \\<and> sorted (map fst m)", "by (auto)"], ["proof (state)\nthis:\n  0 < p\n  x \\<notin> fst ` set m\n  monom_inv m\n\ngoal (1 subgoal):\n 1. \\<And>a m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>monom_inv m; monom_inv n\\<rbrakk>\n                   \\<Longrightarrow> (m = n) =\n                                     (\\<forall>x.\n   sum_var_list m x = sum_var_list n x);\n        monom_inv (a # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> (a # m = n) =\n                         (\\<forall>x.\n                             sum_var_list (a # m) x = sum_var_list n x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. \\<And>a list.\n       n = a # list \\<Longrightarrow>\n       (xp # m = n) =\n       (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "case Nil"], ["proof (state)\nthis:\n  n = []\n\ngoal (2 subgoals):\n 1. n = [] \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. \\<And>a list.\n       n = a # list \\<Longrightarrow>\n       (xp # m = n) =\n       (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = []\n\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "by (auto simp: xp sum_var_list_def p intro!: exI[of _ x])"], ["proof (state)\nthis:\n  (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       n = a # list \\<Longrightarrow>\n       (xp # m = n) =\n       (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       n = a # list \\<Longrightarrow>\n       (xp # m = n) =\n       (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "case n: (Cons yq n')"], ["proof (state)\nthis:\n  n = yq # n'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       n = a # list \\<Longrightarrow>\n       (xp # m = n) =\n       (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "from Cons(3)[unfolded n]"], ["proof (chain)\npicking this:\n  monom_inv (yq # n')", "have n': \"monom_inv n'\""], ["proof (prove)\nusing this:\n  monom_inv (yq # n')\n\ngoal (1 subgoal):\n 1. monom_inv n'", "by (auto simp: monom_inv_def)"], ["proof (state)\nthis:\n  monom_inv n'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       n = a # list \\<Longrightarrow>\n       (xp # m = n) =\n       (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "proof (cases \"yq = xp\")"], ["proof (state)\ngoal (2 subgoals):\n 1. yq = xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "case True"], ["proof (state)\nthis:\n  yq = xp\n\ngoal (2 subgoals):\n 1. yq = xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n 2. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "unfolding n True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xp # m = xp # n') =\n    (\\<forall>x. sum_var_list (xp # m) x = sum_var_list (xp # n') x)", "using Cons(1)[OF m n']"], ["proof (prove)\nusing this:\n  (m = n') = (\\<forall>x. sum_var_list m x = sum_var_list n' x)\n\ngoal (1 subgoal):\n 1. (xp # m = xp # n') =\n    (\\<forall>x. sum_var_list (xp # m) x = sum_var_list (xp # n') x)", "by (auto simp: xp sum_var_list_def)"], ["proof (state)\nthis:\n  (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "case False"], ["proof (state)\nthis:\n  yq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "obtain y q where yq: \"yq = (y,q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y q. yq = (y, q) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  yq = (y, q)\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "from Cons(3)[unfolded n yq monom_inv_def]"], ["proof (chain)\npicking this:\n  (\\<forall>(x, n)\\<in>set ((y, q) # n'). 1 \\<le> n) \\<and>\n  distinct (map fst ((y, q) # n')) \\<and> sorted (map fst ((y, q) # n'))", "have q: \"q > 0\""], ["proof (prove)\nusing this:\n  (\\<forall>(x, n)\\<in>set ((y, q) # n'). 1 \\<le> n) \\<and>\n  distinct (map fst ((y, q) # n')) \\<and> sorted (map fst ((y, q) # n'))\n\ngoal (1 subgoal):\n 1. 0 < q", "by auto"], ["proof (state)\nthis:\n  0 < q\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "define z where \"z = min x y\""], ["proof (state)\nthis:\n  z = min x y\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "have zm: \"z \\<notin> fst ` set m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set m", "using Cons(2)"], ["proof (prove)\nusing this:\n  monom_inv (xp # m)\n\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set m", "unfolding xp z_def"], ["proof (prove)\nusing this:\n  monom_inv ((x, p) # m)\n\ngoal (1 subgoal):\n 1. min x y \\<notin> fst ` set m", "by (rule monom_inv_Cons, simp)"], ["proof (state)\nthis:\n  z \\<notin> fst ` set m\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "have zn': \"z \\<notin> fst ` set n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set n'", "using Cons(3)"], ["proof (prove)\nusing this:\n  monom_inv n\n\ngoal (1 subgoal):\n 1. z \\<notin> fst ` set n'", "unfolding n yq z_def"], ["proof (prove)\nusing this:\n  monom_inv ((y, q) # n')\n\ngoal (1 subgoal):\n 1. min x y \\<notin> fst ` set n'", "by (rule monom_inv_Cons, simp)"], ["proof (state)\nthis:\n  z \\<notin> fst ` set n'\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "have smz: \"sum_var_list (xp # m) z = sum_var_list [(x,p)] z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list (xp # m) z = sum_var_list [(x, p)] z", "using sum_var_list_not[OF zm]"], ["proof (prove)\nusing this:\n  sum_var_list m z = 0\n\ngoal (1 subgoal):\n 1. sum_var_list (xp # m) z = sum_var_list [(x, p)] z", "by (simp add: sum_var_list_def xp)"], ["proof (state)\nthis:\n  sum_var_list (xp # m) z = sum_var_list [(x, p)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "also"], ["proof (state)\nthis:\n  sum_var_list (xp # m) z = sum_var_list [(x, p)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "have \"\\<dots> \\<noteq> sum_var_list [(y,q)] z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z", "using False"], ["proof (prove)\nusing this:\n  yq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. sum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z", "unfolding xp yq"], ["proof (prove)\nusing this:\n  (y, q) \\<noteq> (x, p)\n\ngoal (1 subgoal):\n 1. sum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z", "by (auto simp: sum_var_list_def z_def p q min_def)"], ["proof (state)\nthis:\n  sum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "also"], ["proof (state)\nthis:\n  sum_var_list [(x, p)] z \\<noteq> sum_var_list [(y, q)] z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "have \"sum_var_list [(y,q)] z = sum_var_list n z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list [(y, q)] z = sum_var_list n z", "using sum_var_list_not[OF zn']"], ["proof (prove)\nusing this:\n  sum_var_list n' z = 0\n\ngoal (1 subgoal):\n 1. sum_var_list [(y, q)] z = sum_var_list n z", "by (simp add: sum_var_list_def n yq)"], ["proof (state)\nthis:\n  sum_var_list [(y, q)] z = sum_var_list n z\n\ngoal (1 subgoal):\n 1. yq \\<noteq> xp \\<Longrightarrow>\n    (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "finally"], ["proof (chain)\npicking this:\n  sum_var_list (xp # m) z \\<noteq> sum_var_list n z", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_var_list (xp # m) z \\<noteq> sum_var_list n z\n\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "using False"], ["proof (prove)\nusing this:\n  sum_var_list (xp # m) z \\<noteq> sum_var_list n z\n  yq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)", "unfolding n"], ["proof (prove)\nusing this:\n  sum_var_list (xp # m) z \\<noteq> sum_var_list (yq # n') z\n  yq \\<noteq> xp\n\ngoal (1 subgoal):\n 1. (xp # m = yq # n') =\n    (\\<forall>x. sum_var_list (xp # m) x = sum_var_list (yq # n') x)", "by auto"], ["proof (state)\nthis:\n  (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xp # m = n) = (\\<forall>x. sum_var_list (xp # m) x = sum_var_list n x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  equality of monomials is also a complete for several carriers, e.g. the naturals, integers, where $x^p = x^q$ implies $p = q$.\n  note that it is not complete for carriers like the Booleans where e.g. $x^{Suc(m)} = x^{Suc(n)}$ for all $n,m$.\n\\<close>"], ["", "(*\nlemma eq_monom_inv: \n  fixes m :: \"'v :: linorder monom_list\"\n  assumes exp_inject: \"\\<And> p q :: nat. \\<exists> base :: 'a :: poly_carrier. base^p = base^q \\<Longrightarrow> p = q\" \n  and m: \"monom_inv m\" and n: \"monom_inv n\" \n  shows \"(m = n) = (\\<forall> \\<alpha> :: ('v,'a :: poly_carrier)assign. eval_monom_list \\<alpha> m = eval_monom_list \\<alpha> n)\"\nproof(intro iffI allI, rule eq_monom_list)\n  assume \"\\<forall> \\<alpha> :: ('v,'a :: poly_carrier)assign. eval_monom_list \\<alpha> m = eval_monom_list \\<alpha> n\"\n  with m n show \"m = n\"\n  proof (induct m arbitrary: n)\n    case Nil\n    show ?case \n    proof (cases n)\n      case (Cons yq nn)\n      with Nil obtain y q where yq: \"yq = (y,q)\" and \"1 \\<le> q\" by (cases yq, auto simp: monom_inv_def)\n      then obtain qq where q: \"q = Suc (qq)\" by (cases q, auto)\n      from Nil(3) have \"1 = eval_monom_list (\\<lambda> x. 0 :: 'a) n\" (is \"?one = _\") by simp\n      also have \"\\<dots> = 0\" by (simp add: Cons yq q)\n      finally show ?thesis by simp\n    qed simp\n  next\n    case (Cons xp m) note mCons = this\n    show ?case\n    proof (cases xp)\n      case (Pair x p)\n      let ?ass = \"(\\<lambda> v y. if x = y then v else 1 :: 'a)\"\n      {\n        fix v :: 'a and m :: \"'v monom_list\"\n        assume \"x \\<notin> fst ` (set m)\"\n        hence \"eval_monom_list (?ass v) m = 1\"\n        proof (induct m)\n          case (Cons yp m)\n          thus ?case \n            by (cases yp, cases \"fst yp = x\", auto)\n        qed simp\n      } note ass = this\n      from Cons(2)[unfolded Pair] obtain pp where p: \"p = Suc pp\" and xm: \"x \\<notin> fst ` (set m)\" unfolding monom_inv_def by (cases p, auto)\n      from ass[OF xm] have \"\\<And> v. eval_monom_list (?ass v) (xp # m) = v * v^pp\" by (simp add: Pair p)\n      with Cons(4) have eval: \"\\<And> v. eval_monom_list (?ass v) n = v * v^pp\" by auto\n      show ?thesis \n      proof (cases \"List.extract (\\<lambda> yq. fst yq = x) n\")\n        case None\n        with ass[of n] have \"\\<And> v. eval_monom_list (?ass v) n = 1\" by (auto simp: extract_None_iff)\n        from this[of 0] eval[of 0] show ?thesis by simp\n      next\n        case (Some res)\n        obtain n1 yq n2 where \"res = (n1,yq,n2)\" by (cases res, auto)\n        then obtain y q where \"res = (n1,(y,q),n2)\" by (cases yq, auto)        \n        from extract_SomeE[OF Some[simplified this]] mCons(2)  Some Pair this have n: \"n = n1 @ (x,q) # n2\" and res: \"res = (n1,(x,q),n2)\" by auto\n        from mCons(3)[unfolded n] have xn: \"x \\<notin> fst ` (set (n1 @ n2))\" unfolding monom_inv_def by auto\n        have \"\\<And> v. eval_monom_list (?ass v) n = v^q * eval_monom_list  (?ass v) (n1 @ n2)\" unfolding n by (auto simp: field_simps)\n        from eval[unfolded this ass[OF xn]] have id: \"\\<And> v :: 'a. v^p = v^q\" using p by auto\n        from exp_inject[of p q] id have pq: \"p = q\" by auto\n        have rec: \"((xp # m) =m n) = (m =m (n1 @ n2))\" by (simp add: Pair Some res pq)\n        have ass: \"\\<forall>\\<alpha> :: ('v,'a)assign. eval_monom_list  \\<alpha> m = eval_monom_list \\<alpha> (n1 @ n2)\"\n        proof\n          fix \\<alpha> :: \"('v,'a)assign\"\n          show \"eval_monom_list \\<alpha> m = eval_monom_list \\<alpha> (n1 @ n2)\"\n          proof (rule ccontr)\n            assume neq: \"\\<not> ?thesis\"\n            let ?ass =  \"\\<lambda> y :: 'v. if x = y then 1 :: 'a else \\<alpha> y\"\n            {\n              fix m :: \"'v monom_list\"\n              assume \"x \\<notin> fst ` set m\"\n              hence \"eval_monom_list \\<alpha> m = eval_monom_list ?ass m\"\n                by (induct m, auto)\n            } note ass = this\n            have \"eval_monom_list \\<alpha> (n1 @ n2) = eval_monom_list ?ass (n1 @ n2)\" using ass[OF xn] .\n            also have \"\\<dots> = eval_monom_list ?ass n\" unfolding n by auto\n            also have \"\\<dots> = eval_monom_list ?ass ((xp # m))\" using mCons(4) by auto\n            also have \"\\<dots> = eval_monom_list ?ass m\" unfolding Pair by simp\n            also have \"\\<dots> = eval_monom_list \\<alpha> m\" using ass[OF xm] by simp \n            also have \"\\<dots> \\<noteq> eval_monom_list \\<alpha> (n1 @ n2)\" by (rule neq)\n            finally show False by simp\n          qed\n        qed\n        from mCons(2) mCons(3) have \"monom_inv m\" and \"monom_inv (n1 @ n2)\" unfolding monom_inv_def n by auto\n        from mCons(1)[OF this ass] rec show ?thesis by simp\n      qed\n    qed    \n  qed\nqed simp  *)"], ["", "abbreviation (input) monom_list_vars :: \"'a monom_list \\<Rightarrow> 'a set\"\n  where \"monom_list_vars m \\<equiv> fst ` set m\""], ["", "fun monom_mult_list :: \"'a monom_list \\<Rightarrow> 'a monom_list \\<Rightarrow> 'a monom_list\" where \n  \"monom_mult_list [] n = n\"\n| \"monom_mult_list ((x,p) # m) n = (case n of\n     Nil \\<Rightarrow> (x,p) # m \n   | (y,q) # n' \\<Rightarrow> if x = y then (x,p + q) # monom_mult_list m n' else\n       if x < y then (x,p) # monom_mult_list m n else (y,q) # monom_mult_list ((x,p) # m) n')\""], ["", "lemma monom_list_mult_list_vars: \"monom_list_vars (monom_mult_list m1 m2) = monom_list_vars m1 \\<union> monom_list_vars m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (monom_mult_list m1 m2) = fst ` set m1 \\<union> fst ` set m2", "by (induct m1 m2 rule: monom_mult_list.induct, auto split: list.splits)"], ["", "lemma monom_mult_list_inv: \"monom_inv m1 \\<Longrightarrow> monom_inv m2 \\<Longrightarrow> monom_inv (monom_mult_list m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monom_inv m1; monom_inv m2\\<rbrakk>\n    \\<Longrightarrow> monom_inv (monom_mult_list m1 m2)", "proof (induct m1 m2 rule: monom_mult_list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk>\n       \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n.\n       \\<lbrakk>\\<And>x21 x22 xa y.\n                   \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa;\n                    monom_inv m; monom_inv x22\\<rbrakk>\n                   \\<Longrightarrow> monom_inv (monom_mult_list m x22);\n        \\<And>x21 x22 xa y.\n           \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa;\n            monom_inv m; monom_inv n\\<rbrakk>\n           \\<Longrightarrow> monom_inv (monom_mult_list m n);\n        \\<And>x21 x22 xa y.\n           \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa;\n            \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk>\n           \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22);\n        monom_inv ((x, p) # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)", "case (2 x p m n')"], ["proof (state)\nthis:\n  \\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa; monom_inv m;\n   monom_inv ?x22.0\\<rbrakk>\n  \\<Longrightarrow> monom_inv (monom_mult_list m ?x22.0)\n  \\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa;\n   x < ?xa; monom_inv m; monom_inv n'\\<rbrakk>\n  \\<Longrightarrow> monom_inv (monom_mult_list m n')\n  \\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa;\n   \\<not> x < ?xa; monom_inv ((x, p) # m); monom_inv ?x22.0\\<rbrakk>\n  \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) ?x22.0)\n  monom_inv ((x, p) # m)\n  monom_inv n'\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk>\n       \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n.\n       \\<lbrakk>\\<And>x21 x22 xa y.\n                   \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa;\n                    monom_inv m; monom_inv x22\\<rbrakk>\n                   \\<Longrightarrow> monom_inv (monom_mult_list m x22);\n        \\<And>x21 x22 xa y.\n           \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa;\n            monom_inv m; monom_inv n\\<rbrakk>\n           \\<Longrightarrow> monom_inv (monom_mult_list m n);\n        \\<And>x21 x22 xa y.\n           \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa;\n            \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk>\n           \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22);\n        monom_inv ((x, p) # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)", "note IH = 2(1-3)"], ["proof (state)\nthis:\n  \\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa; monom_inv m;\n   monom_inv ?x22.0\\<rbrakk>\n  \\<Longrightarrow> monom_inv (monom_mult_list m ?x22.0)\n  \\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa;\n   x < ?xa; monom_inv m; monom_inv n'\\<rbrakk>\n  \\<Longrightarrow> monom_inv (monom_mult_list m n')\n  \\<lbrakk>n' = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa;\n   \\<not> x < ?xa; monom_inv ((x, p) # m); monom_inv ?x22.0\\<rbrakk>\n  \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) ?x22.0)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk>\n       \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n.\n       \\<lbrakk>\\<And>x21 x22 xa y.\n                   \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa;\n                    monom_inv m; monom_inv x22\\<rbrakk>\n                   \\<Longrightarrow> monom_inv (monom_mult_list m x22);\n        \\<And>x21 x22 xa y.\n           \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa;\n            monom_inv m; monom_inv n\\<rbrakk>\n           \\<Longrightarrow> monom_inv (monom_mult_list m n);\n        \\<And>x21 x22 xa y.\n           \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa;\n            \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk>\n           \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22);\n        monom_inv ((x, p) # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)", "note xpm = 2(4)"], ["proof (state)\nthis:\n  monom_inv ((x, p) # m)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk>\n       \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n.\n       \\<lbrakk>\\<And>x21 x22 xa y.\n                   \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa;\n                    monom_inv m; monom_inv x22\\<rbrakk>\n                   \\<Longrightarrow> monom_inv (monom_mult_list m x22);\n        \\<And>x21 x22 xa y.\n           \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa;\n            monom_inv m; monom_inv n\\<rbrakk>\n           \\<Longrightarrow> monom_inv (monom_mult_list m n);\n        \\<And>x21 x22 xa y.\n           \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa;\n            \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk>\n           \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22);\n        monom_inv ((x, p) # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)", "note n' = 2(5)"], ["proof (state)\nthis:\n  monom_inv n'\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk>\n       \\<Longrightarrow> monom_inv (monom_mult_list [] n)\n 2. \\<And>x p m n.\n       \\<lbrakk>\\<And>x21 x22 xa y.\n                   \\<lbrakk>n = x21 # x22; (xa, y) = x21; x = xa;\n                    monom_inv m; monom_inv x22\\<rbrakk>\n                   \\<Longrightarrow> monom_inv (monom_mult_list m x22);\n        \\<And>x21 x22 xa y.\n           \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa; x < xa;\n            monom_inv m; monom_inv n\\<rbrakk>\n           \\<Longrightarrow> monom_inv (monom_mult_list m n);\n        \\<And>x21 x22 xa y.\n           \\<lbrakk>n = x21 # x22; (xa, y) = x21; x \\<noteq> xa;\n            \\<not> x < xa; monom_inv ((x, p) # m); monom_inv x22\\<rbrakk>\n           \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) x22);\n        monom_inv ((x, p) # m); monom_inv n\\<rbrakk>\n       \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')", "proof (cases n')"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = [] \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<And>a list.\n       n' = a # list \\<Longrightarrow>\n       monom_inv (monom_mult_list ((x, p) # m) n')", "case Nil"], ["proof (state)\nthis:\n  n' = []\n\ngoal (2 subgoals):\n 1. n' = [] \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<And>a list.\n       n' = a # list \\<Longrightarrow>\n       monom_inv (monom_mult_list ((x, p) # m) n')", "with xpm"], ["proof (chain)\npicking this:\n  monom_inv ((x, p) # m)\n  n' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  monom_inv ((x, p) # m)\n  n' = []\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')", "by auto"], ["proof (state)\nthis:\n  monom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       n' = a # list \\<Longrightarrow>\n       monom_inv (monom_mult_list ((x, p) # m) n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       n' = a # list \\<Longrightarrow>\n       monom_inv (monom_mult_list ((x, p) # m) n')", "case (Cons yq n)"], ["proof (state)\nthis:\n  n' = yq # n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       n' = a # list \\<Longrightarrow>\n       monom_inv (monom_mult_list ((x, p) # m) n')", "then"], ["proof (chain)\npicking this:\n  n' = yq # n", "obtain y q where id: \"n' = ((y,q) # n)\""], ["proof (prove)\nusing this:\n  n' = yq # n\n\ngoal (1 subgoal):\n 1. (\\<And>y q. n' = (y, q) # n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases yq, auto)"], ["proof (state)\nthis:\n  n' = (y, q) # n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       n' = a # list \\<Longrightarrow>\n       monom_inv (monom_mult_list ((x, p) # m) n')", "from xpm"], ["proof (chain)\npicking this:\n  monom_inv ((x, p) # m)", "have m: \"monom_inv m\" and p: \"p > 0\" and x: \"x \\<notin> fst ` set m\" \n      and xm: \"\\<And> z. z \\<in> fst ` set m \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\nusing this:\n  monom_inv ((x, p) # m)\n\ngoal (1 subgoal):\n 1. (monom_inv m &&& 0 < p) &&&\n    x \\<notin> fst ` set m &&&\n    (\\<And>z. z \\<in> fst ` set m \\<Longrightarrow> x \\<le> z)", "unfolding monom_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>(x, n)\\<in>set ((x, p) # m). 1 \\<le> n) \\<and>\n  distinct (map fst ((x, p) # m)) \\<and> sorted (map fst ((x, p) # m))\n\ngoal (1 subgoal):\n 1. ((\\<forall>(x, n)\\<in>set m. 1 \\<le> n) \\<and>\n     distinct (map fst m) \\<and> sorted (map fst m) &&&\n     0 < p) &&&\n    x \\<notin> fst ` set m &&&\n    (\\<And>z. z \\<in> fst ` set m \\<Longrightarrow> x \\<le> z)", "by (auto)"], ["proof (state)\nthis:\n  monom_inv m\n  0 < p\n  x \\<notin> fst ` set m\n  ?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       n' = a # list \\<Longrightarrow>\n       monom_inv (monom_mult_list ((x, p) # m) n')", "from n'[unfolded id]"], ["proof (chain)\npicking this:\n  monom_inv ((y, q) # n)", "have n: \"monom_inv n\" and q: \"q > 0\" and y: \"y \\<notin> fst ` set n\" \n      and yn: \"\\<And> z. z \\<in> fst ` set n \\<Longrightarrow> y \\<le> z\""], ["proof (prove)\nusing this:\n  monom_inv ((y, q) # n)\n\ngoal (1 subgoal):\n 1. (monom_inv n &&& 0 < q) &&&\n    y \\<notin> fst ` set n &&&\n    (\\<And>z. z \\<in> fst ` set n \\<Longrightarrow> y \\<le> z)", "unfolding monom_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>(x, n)\\<in>set ((y, q) # n). 1 \\<le> n) \\<and>\n  distinct (map fst ((y, q) # n)) \\<and> sorted (map fst ((y, q) # n))\n\ngoal (1 subgoal):\n 1. ((\\<forall>(x, n)\\<in>set n. 1 \\<le> n) \\<and>\n     distinct (map fst n) \\<and> sorted (map fst n) &&&\n     0 < q) &&&\n    y \\<notin> fst ` set n &&&\n    (\\<And>z. z \\<in> fst ` set n \\<Longrightarrow> y \\<le> z)", "by (auto)"], ["proof (state)\nthis:\n  monom_inv n\n  0 < q\n  y \\<notin> fst ` set n\n  ?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       n' = a # list \\<Longrightarrow>\n       monom_inv (monom_mult_list ((x, p) # m) n')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "hence res: \"monom_mult_list ((x, p) # m) n' = (x, p + q) # monom_mult_list m n\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' = (x, p + q) # monom_mult_list m n", "by (simp add: id)"], ["proof (state)\nthis:\n  monom_mult_list ((x, p) # m) n' = (x, p + q) # monom_mult_list m n\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "from IH(1)[OF id refl True m n]"], ["proof (chain)\npicking this:\n  monom_inv (monom_mult_list m n)", "have inv: \"monom_inv (monom_mult_list m n)\""], ["proof (prove)\nusing this:\n  monom_inv (monom_mult_list m n)\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list m n)", "by simp"], ["proof (state)\nthis:\n  monom_inv (monom_mult_list m n)\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. x \\<noteq> y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')", "unfolding res"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_inv ((x, p + q) # monom_mult_list m n)", "using inv p x y True xm yn"], ["proof (prove)\nusing this:\n  monom_inv (monom_mult_list m n)\n  0 < p\n  x \\<notin> fst ` set m\n  y \\<notin> fst ` set n\n  x = y\n  ?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n  ?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. monom_inv ((x, p + q) # monom_mult_list m n)", "by (fastforce simp add: monom_inv_def monom_list_mult_list_vars)"], ["proof (state)\nthis:\n  monom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')", "proof (cases \"x < y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "case True"], ["proof (state)\nthis:\n  x < y\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "hence res: \"monom_mult_list ((x, p) # m) n' = (x,p) # monom_mult_list m n'\""], ["proof (prove)\nusing this:\n  x < y\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' = (x, p) # monom_mult_list m n'", "by (auto simp add: id)"], ["proof (state)\nthis:\n  monom_mult_list ((x, p) # m) n' = (x, p) # monom_mult_list m n'\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "from IH(2)[OF id refl False True m n']"], ["proof (chain)\npicking this:\n  monom_inv (monom_mult_list m n')", "have inv: \"monom_inv (monom_mult_list m n')\""], ["proof (prove)\nusing this:\n  monom_inv (monom_mult_list m n')\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list m n')", "."], ["proof (state)\nthis:\n  monom_inv (monom_mult_list m n')\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> monom_inv (monom_mult_list ((x, p) # m) n')\n 2. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')", "unfolding res"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_inv ((x, p) # monom_mult_list m n')", "using inv p x y True xm yn"], ["proof (prove)\nusing this:\n  monom_inv (monom_mult_list m n')\n  0 < p\n  x \\<notin> fst ` set m\n  y \\<notin> fst ` set n\n  x < y\n  ?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n  ?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. monom_inv ((x, p) # monom_mult_list m n')", "unfolding id"], ["proof (prove)\nusing this:\n  monom_inv (monom_mult_list m ((y, q) # n))\n  0 < p\n  x \\<notin> fst ` set m\n  y \\<notin> fst ` set n\n  x < y\n  ?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n  ?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. monom_inv ((x, p) # monom_mult_list m ((y, q) # n))", "by (fastforce simp add: monom_inv_def monom_list_mult_list_vars)"], ["proof (state)\nthis:\n  monom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "case gt: False"], ["proof (state)\nthis:\n  \\<not> x < y\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "with False"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  \\<not> x < y", "have lt: \"y < x\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<not> x < y\n\ngoal (1 subgoal):\n 1. y < x", "by auto"], ["proof (state)\nthis:\n  y < x\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "hence res: \"monom_mult_list ((x, p) # m) n' = (y,q) # monom_mult_list ((x, p) # m) n\""], ["proof (prove)\nusing this:\n  y < x\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' =\n    (y, q) # monom_mult_list ((x, p) # m) n", "using False"], ["proof (prove)\nusing this:\n  y < x\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. monom_mult_list ((x, p) # m) n' =\n    (y, q) # monom_mult_list ((x, p) # m) n", "by (auto simp add: id)"], ["proof (state)\nthis:\n  monom_mult_list ((x, p) # m) n' = (y, q) # monom_mult_list ((x, p) # m) n\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "from lt"], ["proof (chain)\npicking this:\n  y < x", "have zm: \"z \\<le> x \\<Longrightarrow> (z,b) \\<notin> set m\" for z b"], ["proof (prove)\nusing this:\n  y < x\n\ngoal (1 subgoal):\n 1. z \\<le> x \\<Longrightarrow> (z, b) \\<notin> set m", "using xm[of z] x"], ["proof (prove)\nusing this:\n  y < x\n  z \\<in> fst ` set m \\<Longrightarrow> x \\<le> z\n  x \\<notin> fst ` set m\n\ngoal (1 subgoal):\n 1. z \\<le> x \\<Longrightarrow> (z, b) \\<notin> set m", "by force"], ["proof (state)\nthis:\n  ?z \\<le> x \\<Longrightarrow> (?z, ?b) \\<notin> set m\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "from zm[of y] lt"], ["proof (chain)\npicking this:\n  y \\<le> x \\<Longrightarrow> (y, ?b) \\<notin> set m\n  y < x", "have ym: \"(y,b) \\<notin> set m\" for b"], ["proof (prove)\nusing this:\n  y \\<le> x \\<Longrightarrow> (y, ?b) \\<notin> set m\n  y < x\n\ngoal (1 subgoal):\n 1. (y, b) \\<notin> set m", "by auto"], ["proof (state)\nthis:\n  (y, ?b) \\<notin> set m\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "from yn"], ["proof (chain)\npicking this:\n  ?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z", "have yn': \"(a, b) \\<in> set n \\<Longrightarrow> y \\<le> a\" for a b"], ["proof (prove)\nusing this:\n  ?z \\<in> fst ` set n \\<Longrightarrow> y \\<le> ?z\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> set n \\<Longrightarrow> y \\<le> a", "by force"], ["proof (state)\nthis:\n  (?a, ?b) \\<in> set n \\<Longrightarrow> y \\<le> ?a\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "from IH(3)[OF id refl False gt xpm n]"], ["proof (chain)\npicking this:\n  monom_inv (monom_mult_list ((x, p) # m) n)", "have inv: \"monom_inv (monom_mult_list ((x, p) # m) n)\""], ["proof (prove)\nusing this:\n  monom_inv (monom_mult_list ((x, p) # m) n)\n\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n)", "."], ["proof (state)\nthis:\n  monom_inv (monom_mult_list ((x, p) # m) n)\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "define xpm where \"xpm = ((x,p) # m)\""], ["proof (state)\nthis:\n  xpm = (x, p) # m\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "have xpm': \"fst ` set xpm = insert x (fst ` set m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set xpm = insert x (fst ` set m)", "unfolding xpm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set ((x, p) # m) = insert x (fst ` set m)", "by auto"], ["proof (state)\nthis:\n  fst ` set xpm = insert x (fst ` set m)\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow>\n    monom_inv (monom_mult_list ((x, p) # m) n')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (monom_mult_list ((x, p) # m) n')", "unfolding res"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_inv ((y, q) # monom_mult_list ((x, p) # m) n)", "using inv p q x y False gt ym lt xm yn' zm xpm'"], ["proof (prove)\nusing this:\n  monom_inv (monom_mult_list ((x, p) # m) n)\n  0 < p\n  0 < q\n  x \\<notin> fst ` set m\n  y \\<notin> fst ` set n\n  x \\<noteq> y\n  \\<not> x < y\n  (y, ?b) \\<notin> set m\n  y < x\n  ?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n  (?a, ?b) \\<in> set n \\<Longrightarrow> y \\<le> ?a\n  ?z \\<le> x \\<Longrightarrow> (?z, ?b) \\<notin> set m\n  fst ` set xpm = insert x (fst ` set m)\n\ngoal (1 subgoal):\n 1. monom_inv ((y, q) # monom_mult_list ((x, p) # m) n)", "unfolding id xpm_def[symmetric]"], ["proof (prove)\nusing this:\n  monom_inv (monom_mult_list xpm n)\n  0 < p\n  0 < q\n  x \\<notin> fst ` set m\n  y \\<notin> fst ` set n\n  x \\<noteq> y\n  \\<not> x < y\n  (y, ?b) \\<notin> set m\n  y < x\n  ?z \\<in> fst ` set m \\<Longrightarrow> x \\<le> ?z\n  (?a, ?b) \\<in> set n \\<Longrightarrow> y \\<le> ?a\n  ?z \\<le> x \\<Longrightarrow> (?z, ?b) \\<notin> set m\n  fst ` set xpm = insert x (fst ` set m)\n\ngoal (1 subgoal):\n 1. monom_inv ((y, q) # monom_mult_list xpm n)", "by (auto simp add: monom_inv_def monom_list_mult_list_vars)"], ["proof (state)\nthis:\n  monom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom_inv (monom_mult_list ((x, p) # m) n')\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>monom_inv []; monom_inv n\\<rbrakk>\n       \\<Longrightarrow> monom_inv (monom_mult_list [] n)", "qed auto"], ["", "lemma monom_inv_ConsD: \"monom_inv (x # xs) \\<Longrightarrow> monom_inv xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_inv (x # xs) \\<Longrightarrow> monom_inv xs", "by (auto simp: monom_inv_def)"], ["", "lemma sum_var_list_monom_mult_list:  \"sum_var_list (monom_mult_list m n) x = sum_var_list m x + sum_var_list n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list (monom_mult_list m n) x =\n    sum_var_list m x + sum_var_list n x", "proof (induct m n rule: monom_mult_list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       sum_var_list (monom_mult_list [] n) x =\n       sum_var_list [] x + sum_var_list n x\n 2. \\<And>xa p m n.\n       \\<lbrakk>\\<And>x21 x22 xaa y.\n                   \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa = xaa\\<rbrakk>\n                   \\<Longrightarrow> sum_var_list (monom_mult_list m x22)\nx =\n                                     sum_var_list m x + sum_var_list x22 x;\n        \\<And>x21 x22 xaa y.\n           \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa;\n            xa < xaa\\<rbrakk>\n           \\<Longrightarrow> sum_var_list (monom_mult_list m n) x =\n                             sum_var_list m x + sum_var_list n x;\n        \\<And>x21 x22 xaa y.\n           \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa;\n            \\<not> xa < xaa\\<rbrakk>\n           \\<Longrightarrow> sum_var_list\n                              (monom_mult_list ((xa, p) # m) x22) x =\n                             sum_var_list ((xa, p) # m) x +\n                             sum_var_list x22 x\\<rbrakk>\n       \\<Longrightarrow> sum_var_list (monom_mult_list ((xa, p) # m) n) x =\n                         sum_var_list ((xa, p) # m) x + sum_var_list n x", "case (2 x p m n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa\\<rbrakk>\n  \\<Longrightarrow> sum_var_list (monom_mult_list m ?x22.0) x =\n                    sum_var_list m x + sum_var_list ?x22.0 x\n  \\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa;\n   x < ?xa\\<rbrakk>\n  \\<Longrightarrow> sum_var_list (monom_mult_list m n) x =\n                    sum_var_list m x + sum_var_list n x\n  \\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa;\n   \\<not> x < ?xa\\<rbrakk>\n  \\<Longrightarrow> sum_var_list (monom_mult_list ((x, p) # m) ?x22.0) x =\n                    sum_var_list ((x, p) # m) x + sum_var_list ?x22.0 x\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       sum_var_list (monom_mult_list [] n) x =\n       sum_var_list [] x + sum_var_list n x\n 2. \\<And>xa p m n.\n       \\<lbrakk>\\<And>x21 x22 xaa y.\n                   \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa = xaa\\<rbrakk>\n                   \\<Longrightarrow> sum_var_list (monom_mult_list m x22)\nx =\n                                     sum_var_list m x + sum_var_list x22 x;\n        \\<And>x21 x22 xaa y.\n           \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa;\n            xa < xaa\\<rbrakk>\n           \\<Longrightarrow> sum_var_list (monom_mult_list m n) x =\n                             sum_var_list m x + sum_var_list n x;\n        \\<And>x21 x22 xaa y.\n           \\<lbrakk>n = x21 # x22; (xaa, y) = x21; xa \\<noteq> xaa;\n            \\<not> xa < xaa\\<rbrakk>\n           \\<Longrightarrow> sum_var_list\n                              (monom_mult_list ((xa, p) # m) x22) x =\n                             sum_var_list ((xa, p) # m) x +\n                             sum_var_list x22 x\\<rbrakk>\n       \\<Longrightarrow> sum_var_list (monom_mult_list ((xa, p) # m) n) x =\n                         sum_var_list ((xa, p) # m) x + sum_var_list n x", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x = ?xa\\<rbrakk>\n  \\<Longrightarrow> sum_var_list (monom_mult_list m ?x22.0) x =\n                    sum_var_list m x + sum_var_list ?x22.0 x\n  \\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa;\n   x < ?xa\\<rbrakk>\n  \\<Longrightarrow> sum_var_list (monom_mult_list m n) x =\n                    sum_var_list m x + sum_var_list n x\n  \\<lbrakk>n = ?x21.0 # ?x22.0; (?xa, ?y) = ?x21.0; x \\<noteq> ?xa;\n   \\<not> x < ?xa\\<rbrakk>\n  \\<Longrightarrow> sum_var_list (monom_mult_list ((x, p) # m) ?x22.0) x =\n                    sum_var_list ((x, p) # m) x + sum_var_list ?x22.0 x\n\ngoal (1 subgoal):\n 1. sum_var_list (monom_mult_list ((x, p) # m) n) x =\n    sum_var_list ((x, p) # m) x + sum_var_list n x", "by (cases n; cases \"hd n\", auto split: if_splits simp: sum_var_list_def)"], ["proof (state)\nthis:\n  sum_var_list (monom_mult_list ((x, p) # m) n) x =\n  sum_var_list ((x, p) # m) x + sum_var_list n x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum_var_list (monom_mult_list [] n) x =\n       sum_var_list [] x + sum_var_list n x", "qed (auto simp: sum_var_list_def)"], ["", "lemma monom_mult_list_inj: assumes m: \"monom_inv m\" and m1: \"monom_inv m1\" and m2: \"monom_inv m2\"\n  and eq: \"monom_mult_list m m1 = monom_mult_list m m2\"\n  shows \"m1 = m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 = m2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m1 = m2", "from eq sum_var_list_monom_mult_list[of m]"], ["proof (chain)\npicking this:\n  monom_mult_list m m1 = monom_mult_list m m2\n  sum_var_list (monom_mult_list m ?n) ?x =\n  sum_var_list m ?x + sum_var_list ?n ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  monom_mult_list m m1 = monom_mult_list m m2\n  sum_var_list (monom_mult_list m ?n) ?x =\n  sum_var_list m ?x + sum_var_list ?n ?x\n\ngoal (1 subgoal):\n 1. m1 = m2", "by (auto simp: eq_monom_sum_var_list[OF m1 m2] eq_monom_sum_var_list[OF monom_mult_list_inv[OF m m1] monom_mult_list_inv[OF m m2]])"], ["proof (state)\nthis:\n  m1 = m2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monom_mult_list[simp]: \"eval_monom_list \\<alpha> (monom_mult_list m n) = eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> (monom_mult_list m n) =\n    eval_monom_list \\<alpha> m * eval_monom_list \\<alpha> n", "by (induct m n rule: monom_mult_list.induct, auto split: list.splits prod.splits simp: field_simps power_add)"], ["", "end"], ["", "declare monom_mult_list.simps[simp del]"], ["", "typedef (overloaded) 'v monom = \"Collect (monom_inv :: 'v :: linorder monom_list \\<Rightarrow> bool)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Collect monom_inv", "by (rule exI[of _ Nil], auto simp: monom_inv_def)"], ["", "setup_lifting type_definition_monom"], ["", "lift_definition eval_monom :: \"('v :: linorder,'a :: comm_semiring_1)assign \\<Rightarrow> 'v monom \\<Rightarrow> 'a\"\n  is eval_monom_list"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition sum_var :: \"'v :: linorder monom \\<Rightarrow> 'v \\<Rightarrow> nat\" is sum_var_list"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instantiation monom :: (linorder) comm_monoid_mult\nbegin"], ["", "lift_definition times_monom :: \"'a monom \\<Rightarrow> 'a monom \\<Rightarrow> 'a monom\" is monom_mult_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>list1 \\<in> Collect monom_inv;\n        list2 \\<in> Collect monom_inv\\<rbrakk>\n       \\<Longrightarrow> monom_mult_list list1 list2 \\<in> Collect monom_inv", "using monom_mult_list_inv"], ["proof (prove)\nusing this:\n  \\<lbrakk>monom_inv ?m1.0; monom_inv ?m2.0\\<rbrakk>\n  \\<Longrightarrow> monom_inv (monom_mult_list ?m1.0 ?m2.0)\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>list1 \\<in> Collect monom_inv;\n        list2 \\<in> Collect monom_inv\\<rbrakk>\n       \\<Longrightarrow> monom_mult_list list1 list2 \\<in> Collect monom_inv", "by auto"], ["", "lift_definition one_monom :: \"'a monom\" is Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> Collect monom_inv", "by (auto simp: monom_inv_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a monom, comm_monoid_mult_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. 1 * a = a", "fix a b c :: \"'a monom\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. 1 * a = a", "show \"a * b * c = a * (b * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b * c = a * (b * c)", "by (transfer, auto simp: eq_monom_sum_var_list monom_mult_list_inv sum_var_list_monom_mult_list)"], ["proof (state)\nthis:\n  a * b * c = a * (b * c)\n\ngoal (2 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a. 1 * a = a", "show \"a * b = b * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b = b * a", "by (transfer, auto simp: eq_monom_sum_var_list monom_mult_list_inv sum_var_list_monom_mult_list)"], ["proof (state)\nthis:\n  a * b = b * a\n\ngoal (1 subgoal):\n 1. \\<And>a. 1 * a = a", "show \"1 * a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * a = a", "by (transfer, auto simp: eq_monom_sum_var_list monom_mult_list_inv sum_var_list_monom_mult_list monom_mult_list.simps)"], ["proof (state)\nthis:\n  1 * a = a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma eq_monom_sum_var: \"m = n \\<longleftrightarrow> (\\<forall> x. sum_var m x = sum_var n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m = n) = (\\<forall>x. sum_var m x = sum_var n x)", "by (transfer, auto simp: eq_monom_sum_var_list)"], ["", "lemma eval_monom_mult[simp]: \"eval_monom \\<alpha> (m * n) = eval_monom \\<alpha> m * eval_monom \\<alpha> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> (m * n) =\n    eval_monom \\<alpha> m * eval_monom \\<alpha> n", "by (transfer, rule monom_mult_list)"], ["", "lemma sum_var_monom_mult:  \"sum_var (m * n) x = sum_var m x + sum_var n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_var (m * n) x = sum_var m x + sum_var n x", "by (transfer, rule sum_var_list_monom_mult_list)"], ["", "lemma monom_mult_inj: fixes m1 :: \"_ monom\"\n  shows \"m * m1 = m * m2 \\<Longrightarrow> m1 = m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m * m1 = m * m2 \\<Longrightarrow> m1 = m2", "by (transfer, rule monom_mult_list_inj, auto)"], ["", "lemma one_monom_inv_sum_var_inv[simp]: \"sum_var 1 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_var 1 x = 0", "by (transfer, auto simp: sum_var_list_def)"], ["", "lemma eval_monom_1[simp]: \"eval_monom  \\<alpha> 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> 1 = (1::'a)", "by (transfer, auto)"], ["", "lift_definition var_monom :: \"'v :: linorder \\<Rightarrow> 'v monom\" is \"\\<lambda> x. [(x,1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. [(v, 1)] \\<in> Collect monom_inv", "by (auto simp: monom_inv_def)"], ["", "lemma var_monom_1[simp]: \"var_monom x \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var_monom x \\<noteq> 1", "by (transfer, auto)"], ["", "lemma eval_var_monom[simp]: \"eval_monom \\<alpha> (var_monom x) = \\<alpha> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> (var_monom x) = \\<alpha> x", "by (transfer, auto)"], ["", "lemma sum_var_monom_var: \"sum_var (var_monom x) y = (if x = y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_var (var_monom x) y = (if x = y then 1 else 0)", "by (transfer, auto simp: sum_var_list_def)"], ["", "instantiation monom :: (\"{equal,linorder}\")equal\nbegin"], ["", "lift_definition equal_monom :: \"'a monom \\<Rightarrow> 'a monom \\<Rightarrow> bool\" is \"(=)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a monom, equal_class)", "by (standard, transfer, auto)"], ["", "end"], ["", "text \\<open>\nPolynomials are represented with as sum of monomials multiplied by some coefficient \n\\<close>"], ["", "type_synonym ('v,'a)poly = \"('v monom \\<times> 'a)list\""], ["", "text \\<open>\nThe polynomials we construct satisfy the following invariants:\n\\begin{itemize}\n\\item all coefficients are non-zero\n\\item the monomial list is distinct \n\\end{itemize}\n\\<close>"], ["", "definition poly_inv :: \"('v,'a :: zero)poly \\<Rightarrow> bool\"\n  where \"poly_inv p \\<equiv> (\\<forall> c \\<in> snd ` set p. c \\<noteq> 0) \\<and> distinct (map fst p)\""], ["", "abbreviation eval_monomc where \"eval_monomc \\<alpha> mc \\<equiv> eval_monom \\<alpha> (fst mc) * (snd mc)\""], ["", "primrec eval_poly :: \"('v :: linorder, 'a :: comm_semiring_1)assign \\<Rightarrow> ('v,'a)poly \\<Rightarrow> 'a\" where \n  \"eval_poly \\<alpha> [] = 0\"\n| \"eval_poly \\<alpha> (mc # p) = eval_monomc \\<alpha> mc + eval_poly \\<alpha> p\""], ["", "definition poly_const :: \"'a :: zero \\<Rightarrow> ('v :: linorder,'a)poly\" where\n  \"poly_const a = (if a = 0 then [] else [(1,a)])\""], ["", "lemma poly_const[simp]: \"eval_poly \\<alpha> (poly_const a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_const a) = a", "unfolding poly_const_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (if a = (0::'a) then [] else [(1, a)]) = a", "by auto"], ["", "lemma poly_const_inv: \"poly_inv (poly_const a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_const a)", "unfolding poly_const_def poly_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (if a = (0::'b) then [] else [(1, a)]).\n        c \\<noteq> (0::'b)) \\<and>\n    distinct (map fst (if a = (0::'b) then [] else [(1, a)]))", "by auto"], ["", "fun poly_add :: \"('v,'a)poly \\<Rightarrow> ('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly\" where\n  \"poly_add [] q = q\"\n| \"poly_add ((m,c) # p) q = (case List.extract (\\<lambda> mc. fst mc = m) q of\n    None \\<Rightarrow> (m,c) # poly_add p q\n  | Some (q1,(_,d),q2) \\<Rightarrow> if (c+d = 0) then poly_add p (q1 @ q2) else (m,c+d) # poly_add p (q1 @ q2))\""], ["", "lemma eval_poly_append[simp]: \"eval_poly \\<alpha> (mc1 @ mc2) = eval_poly \\<alpha> mc1 + eval_poly \\<alpha> mc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc1 @ mc2) =\n    eval_poly \\<alpha> mc1 + eval_poly \\<alpha> mc2", "by (induct mc1, auto simp: field_simps)"], ["", "abbreviation poly_monoms :: \"('v,'a)poly \\<Rightarrow> 'v monom set\"\n  where \"poly_monoms p \\<equiv> fst ` set p\""], ["", "lemma poly_add_monoms: \"poly_monoms (poly_add p1 p2) \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (poly_add p1 p2)\n    \\<subseteq> poly_monoms p1 \\<union> poly_monoms p2", "proof (induct p1 arbitrary: p2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p2.\n       poly_monoms (poly_add [] p2)\n       \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2.\n       (\\<And>p2.\n           poly_monoms (poly_add p1 p2)\n           \\<subseteq> poly_monoms p1 \\<union>\n                       poly_monoms p2) \\<Longrightarrow>\n       poly_monoms (poly_add (a # p1) p2)\n       \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2", "case (Cons mc p)"], ["proof (state)\nthis:\n  poly_monoms (poly_add p ?p2.0)\n  \\<subseteq> poly_monoms p \\<union> poly_monoms ?p2.0\n\ngoal (2 subgoals):\n 1. \\<And>p2.\n       poly_monoms (poly_add [] p2)\n       \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2.\n       (\\<And>p2.\n           poly_monoms (poly_add p1 p2)\n           \\<subseteq> poly_monoms p1 \\<union>\n                       poly_monoms p2) \\<Longrightarrow>\n       poly_monoms (poly_add (a # p1) p2)\n       \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mc, auto)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (2 subgoals):\n 1. \\<And>p2.\n       poly_monoms (poly_add [] p2)\n       \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2.\n       (\\<And>p2.\n           poly_monoms (poly_add p1 p2)\n           \\<subseteq> poly_monoms p1 \\<union>\n                       poly_monoms p2) \\<Longrightarrow>\n       poly_monoms (poly_add (a # p1) p2)\n       \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2", "hence m: \"m \\<in> poly_monoms (mc # p1)\""], ["proof (prove)\nusing this:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. m \\<in> poly_monoms (mc # p1)", "by auto"], ["proof (state)\nthis:\n  m \\<in> poly_monoms (mc # p1)\n\ngoal (2 subgoals):\n 1. \\<And>p2.\n       poly_monoms (poly_add [] p2)\n       \\<subseteq> poly_monoms [] \\<union> poly_monoms p2\n 2. \\<And>a p1 p2.\n       (\\<And>p2.\n           poly_monoms (poly_add p1 p2)\n           \\<subseteq> poly_monoms p1 \\<union>\n                       poly_monoms p2) \\<Longrightarrow>\n       poly_monoms (poly_add (a # p1) p2)\n       \\<subseteq> poly_monoms (a # p1) \\<union> poly_monoms p2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (poly_add (mc # p) p2)\n    \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2", "proof (cases \"List.extract (\\<lambda> nd. fst nd = m) p2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>nd. fst nd = m) p2 = None \\<Longrightarrow>\n    poly_monoms (poly_add (mc # p) p2)\n    \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n 2. \\<And>a.\n       List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow>\n       poly_monoms (poly_add (mc # p) p2)\n       \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2", "case None"], ["proof (state)\nthis:\n  List.extract (\\<lambda>nd. fst nd = m) p2 = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>nd. fst nd = m) p2 = None \\<Longrightarrow>\n    poly_monoms (poly_add (mc # p) p2)\n    \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n 2. \\<And>a.\n       List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow>\n       poly_monoms (poly_add (mc # p) p2)\n       \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2", "with Cons m"], ["proof (chain)\npicking this:\n  poly_monoms (poly_add p ?p2.0)\n  \\<subseteq> poly_monoms p \\<union> poly_monoms ?p2.0\n  m \\<in> poly_monoms (mc # p1)\n  List.extract (\\<lambda>nd. fst nd = m) p2 = None", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_monoms (poly_add p ?p2.0)\n  \\<subseteq> poly_monoms p \\<union> poly_monoms ?p2.0\n  m \\<in> poly_monoms (mc # p1)\n  List.extract (\\<lambda>nd. fst nd = m) p2 = None\n\ngoal (1 subgoal):\n 1. poly_monoms (poly_add (mc # p) p2)\n    \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2", "by (auto simp: mc)"], ["proof (state)\nthis:\n  poly_monoms (poly_add (mc # p) p2)\n  \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow>\n       poly_monoms (poly_add (mc # p) p2)\n       \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow>\n       poly_monoms (poly_add (mc # p) p2)\n       \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2", "case (Some res)"], ["proof (state)\nthis:\n  List.extract (\\<lambda>nd. fst nd = m) p2 = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow>\n       poly_monoms (poly_add (mc # p) p2)\n       \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2", "obtain q1 md q2 where res: \"res = (q1,md,q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2.\n        res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases res, auto)"], ["proof (state)\nthis:\n  res = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow>\n       poly_monoms (poly_add (mc # p) p2)\n       \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2", "from extract_SomeE[OF Some[simplified res]] res"], ["proof (chain)\npicking this:\n  p2 = q1 @ md # q2 \\<and>\n  fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\n  res = (q1, md, q2)", "obtain d where q: \"p2 = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\""], ["proof (prove)\nusing this:\n  p2 = q1 @ md # q2 \\<and>\n  fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\n  res = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>p2 = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases md, auto)"], ["proof (state)\nthis:\n  p2 = q1 @ (m, d) # q2\n  res = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>nd. fst nd = m) p2 = Some a \\<Longrightarrow>\n       poly_monoms (poly_add (mc # p) p2)\n       \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (poly_add (mc # p) p2)\n    \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2", "by (simp add: mc Some res, rule subset_trans[OF Cons[of \"q1 @ q2\"]], auto simp: q)"], ["proof (state)\nthis:\n  poly_monoms (poly_add (mc # p) p2)\n  \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_monoms (poly_add (mc # p) p2)\n  \\<subseteq> poly_monoms (mc # p) \\<union> poly_monoms p2\n\ngoal (1 subgoal):\n 1. \\<And>p2.\n       poly_monoms (poly_add [] p2)\n       \\<subseteq> poly_monoms [] \\<union> poly_monoms p2", "qed simp"], ["", "lemma poly_add_inv: \"poly_inv p \\<Longrightarrow> poly_inv q \\<Longrightarrow> poly_inv (poly_add p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk>\n    \\<Longrightarrow> poly_inv (poly_add p q)", "proof (induct p arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk>\n                   \\<Longrightarrow> poly_inv (poly_add p q);\n        poly_inv (a # p); poly_inv q\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_add (a # p) q)", "case (Cons mc p)"], ["proof (state)\nthis:\n  \\<lbrakk>poly_inv p; poly_inv ?q\\<rbrakk>\n  \\<Longrightarrow> poly_inv (poly_add p ?q)\n  poly_inv (mc # p)\n  poly_inv q\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk>\n                   \\<Longrightarrow> poly_inv (poly_add p q);\n        poly_inv (a # p); poly_inv q\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_add (a # p) q)", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mc, auto)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk>\n                   \\<Longrightarrow> poly_inv (poly_add p q);\n        poly_inv (a # p); poly_inv q\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_add (a # p) q)", "with Cons(2)"], ["proof (chain)\npicking this:\n  poly_inv (mc # p)\n  mc = (m, c)", "have p: \"poly_inv p\" and c: \"c \\<noteq> 0\" and mp: \"\\<forall> mm \\<in> fst ` set p. (\\<not> mm = m)\""], ["proof (prove)\nusing this:\n  poly_inv (mc # p)\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. poly_inv p &&&\n    c \\<noteq> (0::'b) &&& \\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m", "unfolding poly_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>c\\<in>snd ` set (mc # p). c \\<noteq> (0::'b)) \\<and>\n  distinct (map fst (mc # p))\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'b)) \\<and>\n    distinct (map fst p) &&&\n    c \\<noteq> (0::'b) &&& \\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m", "by auto"], ["proof (state)\nthis:\n  poly_inv p\n  c \\<noteq> (0::'b)\n  \\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_add [] q)\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>poly_inv p; poly_inv q\\<rbrakk>\n                   \\<Longrightarrow> poly_inv (poly_add p q);\n        poly_inv (a # p); poly_inv q\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_add (a # p) q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)", "proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    poly_inv (poly_add (mc # p) q)\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "case None"], ["proof (state)\nthis:\n  List.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    poly_inv (poly_add (mc # p) q)\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "hence mq: \"\\<forall> mm \\<in> fst ` set q. \\<not> mm = m\""], ["proof (prove)\nusing this:\n  List.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. \\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m", "by (auto simp: extract_None_iff)"], ["proof (state)\nthis:\n  \\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    poly_inv (poly_add (mc # p) q)\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "{"], ["proof (state)\nthis:\n  \\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    poly_inv (poly_add (mc # p) q)\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "fix mm"], ["proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    poly_inv (poly_add (mc # p) q)\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "assume \"mm \\<in> fst ` set (poly_add p q)\""], ["proof (state)\nthis:\n  mm \\<in> poly_monoms (poly_add p q)\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    poly_inv (poly_add (mc # p) q)\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "then"], ["proof (chain)\npicking this:\n  mm \\<in> poly_monoms (poly_add p q)", "obtain dd where \"(mm,dd) \\<in> set (poly_add p q)\""], ["proof (prove)\nusing this:\n  mm \\<in> poly_monoms (poly_add p q)\n\ngoal (1 subgoal):\n 1. (\\<And>dd.\n        (mm, dd) \\<in> set (poly_add p q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (mm, dd) \\<in> set (poly_add p q)\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    poly_inv (poly_add (mc # p) q)\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "with poly_add_monoms"], ["proof (chain)\npicking this:\n  poly_monoms (poly_add ?p1.0 ?p2.0)\n  \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n  (mm, dd) \\<in> set (poly_add p q)", "have \"mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\""], ["proof (prove)\nusing this:\n  poly_monoms (poly_add ?p1.0 ?p2.0)\n  \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n  (mm, dd) \\<in> set (poly_add p q)\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q", "by force"], ["proof (state)\nthis:\n  mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    poly_inv (poly_add (mc # p) q)\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "hence \"\\<not> mm = m\""], ["proof (prove)\nusing this:\n  mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m", "using mp mq"], ["proof (prove)\nusing this:\n  mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms q\n  \\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m\n  \\<forall>mm\\<in>poly_monoms q. mm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m", "by auto"], ["proof (state)\nthis:\n  mm \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    poly_inv (poly_add (mc # p) q)\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "}"], ["proof (state)\nthis:\n  ?mm2 \\<in> poly_monoms (poly_add p q) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    poly_inv (poly_add (mc # p) q)\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "note main = this"], ["proof (state)\nthis:\n  ?mm2 \\<in> poly_monoms (poly_add p q) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    poly_inv (poly_add (mc # p) q)\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)", "using Cons(1)[OF p Cons(3)]"], ["proof (prove)\nusing this:\n  poly_inv (poly_add p q)\n\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)", "unfolding poly_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>c\\<in>snd ` set (poly_add p q). c \\<noteq> (0::'b)) \\<and>\n  distinct (map fst (poly_add p q))\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (poly_add (mc # p) q).\n        c \\<noteq> (0::'b)) \\<and>\n    distinct (map fst (poly_add (mc # p) q))", "using main"], ["proof (prove)\nusing this:\n  (\\<forall>c\\<in>snd ` set (poly_add p q). c \\<noteq> (0::'b)) \\<and>\n  distinct (map fst (poly_add p q))\n  ?mm2 \\<in> poly_monoms (poly_add p q) \\<Longrightarrow> ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (poly_add (mc # p) q).\n        c \\<noteq> (0::'b)) \\<and>\n    distinct (map fst (poly_add (mc # p) q))", "by (auto simp add: None mc c)"], ["proof (state)\nthis:\n  poly_inv (poly_add (mc # p) q)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "case (Some res)"], ["proof (state)\nthis:\n  List.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "obtain q1 md q2 where res: \"res = (q1,md,q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2.\n        res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases res, auto)"], ["proof (state)\nthis:\n  res = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "from extract_SomeE[OF Some[simplified res]] res"], ["proof (chain)\npicking this:\n  q = q1 @ md # q2 \\<and>\n  fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\n  res = (q1, md, q2)", "obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\""], ["proof (prove)\nusing this:\n  q = q1 @ md # q2 \\<and>\n  fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\n  res = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases md, auto)"], ["proof (state)\nthis:\n  q = q1 @ (m, d) # q2\n  res = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "from q Cons(3)"], ["proof (chain)\npicking this:\n  q = q1 @ (m, d) # q2\n  poly_inv q", "have q1q2: \"poly_inv (q1 @ q2)\""], ["proof (prove)\nusing this:\n  q = q1 @ (m, d) # q2\n  poly_inv q\n\ngoal (1 subgoal):\n 1. poly_inv (q1 @ q2)", "unfolding poly_inv_def"], ["proof (prove)\nusing this:\n  q = q1 @ (m, d) # q2\n  (\\<forall>c\\<in>snd ` set q. c \\<noteq> (0::'b)) \\<and>\n  distinct (map fst q)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set (q1 @ q2). c \\<noteq> (0::'b)) \\<and>\n    distinct (map fst (q1 @ q2))", "by auto"], ["proof (state)\nthis:\n  poly_inv (q1 @ q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "from Cons(1)[OF p q1q2]"], ["proof (chain)\npicking this:\n  poly_inv (poly_add p (q1 @ q2))", "have main1: \"poly_inv (poly_add p (q1 @ q2))\""], ["proof (prove)\nusing this:\n  poly_inv (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. poly_inv (poly_add p (q1 @ q2))", "."], ["proof (state)\nthis:\n  poly_inv (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "{"], ["proof (state)\nthis:\n  poly_inv (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "fix mm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "assume \"mm \\<in> fst ` set (poly_add p (q1 @ q2))\""], ["proof (state)\nthis:\n  mm \\<in> poly_monoms (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "then"], ["proof (chain)\npicking this:\n  mm \\<in> poly_monoms (poly_add p (q1 @ q2))", "obtain dd where \"(mm,dd) \\<in> set (poly_add p (q1 @ q2))\""], ["proof (prove)\nusing this:\n  mm \\<in> poly_monoms (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. (\\<And>dd.\n        (mm, dd) \\<in> set (poly_add p (q1 @ q2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (mm, dd) \\<in> set (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "with poly_add_monoms"], ["proof (chain)\npicking this:\n  poly_monoms (poly_add ?p1.0 ?p2.0)\n  \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n  (mm, dd) \\<in> set (poly_add p (q1 @ q2))", "have \"mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)\""], ["proof (prove)\nusing this:\n  poly_monoms (poly_add ?p1.0 ?p2.0)\n  \\<subseteq> poly_monoms ?p1.0 \\<union> poly_monoms ?p2.0\n  (mm, dd) \\<in> set (poly_add p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)", "by force"], ["proof (state)\nthis:\n  mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "hence \"mm \\<noteq> m\""], ["proof (prove)\nusing this:\n  mm \\<in> poly_monoms p \\<or> mm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms p \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m", "assume \"mm \\<in> poly_monoms p\""], ["proof (state)\nthis:\n  mm \\<in> poly_monoms p\n\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms p \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m", "thus ?thesis"], ["proof (prove)\nusing this:\n  mm \\<in> poly_monoms p\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m", "using mp"], ["proof (prove)\nusing this:\n  mm \\<in> poly_monoms p\n  \\<forall>mm\\<in>poly_monoms p. mm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m", "by auto"], ["proof (state)\nthis:\n  mm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m", "assume member: \"mm \\<in> poly_monoms (q1 @ q2)\""], ["proof (state)\nthis:\n  mm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m", "from member"], ["proof (chain)\npicking this:\n  mm \\<in> poly_monoms (q1 @ q2)", "have \"mm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2\""], ["proof (prove)\nusing this:\n  mm \\<in> poly_monoms (q1 @ q2)\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2", "by auto"], ["proof (state)\nthis:\n  mm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms (q1 @ q2) \\<Longrightarrow> mm \\<noteq> m", "thus \"mm \\<noteq> m\""], ["proof (prove)\nusing this:\n  mm \\<in> poly_monoms q1 \\<or> mm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms q2 \\<Longrightarrow> mm \\<noteq> m", "assume \"mm \\<in> poly_monoms q2\""], ["proof (state)\nthis:\n  mm \\<in> poly_monoms q2\n\ngoal (2 subgoals):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m\n 2. mm \\<in> poly_monoms q2 \\<Longrightarrow> mm \\<noteq> m", "with Cons(3)[simplified q]"], ["proof (chain)\npicking this:\n  poly_inv (q1 @ (m, d) # q2)\n  mm \\<in> poly_monoms q2", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_inv (q1 @ (m, d) # q2)\n  mm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m", "unfolding poly_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>c\\<in>snd ` set (q1 @ (m, d) # q2). c \\<noteq> (0::'b)) \\<and>\n  distinct (map fst (q1 @ (m, d) # q2))\n  mm \\<in> poly_monoms q2\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m", "by auto"], ["proof (state)\nthis:\n  mm \\<noteq> m\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m", "assume \"mm \\<in> poly_monoms q1\""], ["proof (state)\nthis:\n  mm \\<in> poly_monoms q1\n\ngoal (1 subgoal):\n 1. mm \\<in> poly_monoms q1 \\<Longrightarrow> mm \\<noteq> m", "with Cons(3)[simplified q]"], ["proof (chain)\npicking this:\n  poly_inv (q1 @ (m, d) # q2)\n  mm \\<in> poly_monoms q1", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_inv (q1 @ (m, d) # q2)\n  mm \\<in> poly_monoms q1\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m", "unfolding poly_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>c\\<in>snd ` set (q1 @ (m, d) # q2). c \\<noteq> (0::'b)) \\<and>\n  distinct (map fst (q1 @ (m, d) # q2))\n  mm \\<in> poly_monoms q1\n\ngoal (1 subgoal):\n 1. mm \\<noteq> m", "by auto"], ["proof (state)\nthis:\n  mm \\<noteq> m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mm \\<noteq> m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mm \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "}"], ["proof (state)\nthis:\n  ?mm2 \\<in> poly_monoms (poly_add p (q1 @ q2)) \\<Longrightarrow>\n  ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "note main2 = this"], ["proof (state)\nthis:\n  ?mm2 \\<in> poly_monoms (poly_add p (q1 @ q2)) \\<Longrightarrow>\n  ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       poly_inv (poly_add (mc # p) q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)", "using  main1[unfolded poly_inv_def] main2"], ["proof (prove)\nusing this:\n  (\\<forall>c\\<in>snd ` set (poly_add p (q1 @ q2)).\n      c \\<noteq> (0::'b)) \\<and>\n  distinct (map fst (poly_add p (q1 @ q2)))\n  ?mm2 \\<in> poly_monoms (poly_add p (q1 @ q2)) \\<Longrightarrow>\n  ?mm2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. poly_inv (poly_add (mc # p) q)", "by (auto simp: poly_inv_def mc Some res)"], ["proof (state)\nthis:\n  poly_inv (poly_add (mc # p) q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_inv (poly_add (mc # p) q)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>poly_inv []; poly_inv q\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_add [] q)", "qed simp"], ["", "lemma poly_add[simp]: \"eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> p + eval_poly \\<alpha> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add p q) =\n    eval_poly \\<alpha> p + eval_poly \\<alpha> q", "proof (induct p arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       eval_poly \\<alpha> (poly_add [] q) =\n       eval_poly \\<alpha> [] + eval_poly \\<alpha> q\n 2. \\<And>a p q.\n       (\\<And>q.\n           eval_poly \\<alpha> (poly_add p q) =\n           eval_poly \\<alpha> p + eval_poly \\<alpha> q) \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (a # p) q) =\n       eval_poly \\<alpha> (a # p) + eval_poly \\<alpha> q", "case (Cons mc p)"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (poly_add p ?q) =\n  eval_poly \\<alpha> p + eval_poly \\<alpha> ?q\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       eval_poly \\<alpha> (poly_add [] q) =\n       eval_poly \\<alpha> [] + eval_poly \\<alpha> q\n 2. \\<And>a p q.\n       (\\<And>q.\n           eval_poly \\<alpha> (poly_add p q) =\n           eval_poly \\<alpha> p + eval_poly \\<alpha> q) \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (a # p) q) =\n       eval_poly \\<alpha> (a # p) + eval_poly \\<alpha> q", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mc, auto)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       eval_poly \\<alpha> (poly_add [] q) =\n       eval_poly \\<alpha> [] + eval_poly \\<alpha> q\n 2. \\<And>a p q.\n       (\\<And>q.\n           eval_poly \\<alpha> (poly_add p q) =\n           eval_poly \\<alpha> p + eval_poly \\<alpha> q) \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (a # p) q) =\n       eval_poly \\<alpha> (a # p) + eval_poly \\<alpha> q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add (mc # p) q) =\n    eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    eval_poly \\<alpha> (poly_add (mc # p) q) =\n    eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "case None"], ["proof (state)\nthis:\n  List.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    eval_poly \\<alpha> (poly_add (mc # p) q) =\n    eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add (mc # p) q) =\n    eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "by (simp add: Cons[of q] mc None field_simps)"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (poly_add (mc # p) q) =\n  eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "case (Some res)"], ["proof (state)\nthis:\n  List.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "obtain q1 md q2 where res: \"res = (q1,md,q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2.\n        res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases res, auto)"], ["proof (state)\nthis:\n  res = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "from extract_SomeE[OF Some[simplified res]] res"], ["proof (chain)\npicking this:\n  q = q1 @ md # q2 \\<and>\n  fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\n  res = (q1, md, q2)", "obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\""], ["proof (prove)\nusing this:\n  q = q1 @ md # q2 \\<and>\n  fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\n  res = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases md, auto)"], ["proof (state)\nthis:\n  q = q1 @ (m, d) # q2\n  res = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "{"], ["proof (state)\nthis:\n  q = q1 @ (m, d) # q2\n  res = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "assume c: \"c + d = 0\""], ["proof (state)\nthis:\n  c + d = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "have \"c * x + d * x = (c + d) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * x + d * x = (c + d) * x", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  c * x + d * x = (c + d) * x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "also"], ["proof (state)\nthis:\n  c * x + d * x = (c + d) * x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "have \"\\<dots> = 0 * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c + d) * x = (0::'a) * x", "by (simp only: c)"], ["proof (state)\nthis:\n  (c + d) * x = (0::'a) * x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "finally"], ["proof (chain)\npicking this:\n  c * x + d * x = (0::'a) * x", "have \"c * x + d * x = 0\""], ["proof (prove)\nusing this:\n  c * x + d * x = (0::'a) * x\n\ngoal (1 subgoal):\n 1. c * x + d * x = (0::'a)", "by simp"], ["proof (state)\nthis:\n  c * x + d * x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "}"], ["proof (state)\nthis:\n  c + d = (0::'a) \\<Longrightarrow> c * ?x2 + d * ?x2 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "note id = this"], ["proof (state)\nthis:\n  c + d = (0::'a) \\<Longrightarrow> c * ?x2 + d * ?x2 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_add (mc # p) q) =\n       eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add (mc # p) q) =\n    eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q", "by (simp add: Cons[of \"q1 @ q2\"] mc Some res, simp only: q, simp add: field_simps, auto simp: field_simps id)"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (poly_add (mc # p) q) =\n  eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (poly_add (mc # p) q) =\n  eval_poly \\<alpha> (mc # p) + eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       eval_poly \\<alpha> (poly_add [] q) =\n       eval_poly \\<alpha> [] + eval_poly \\<alpha> q", "qed simp"], ["", "declare poly_add.simps[simp del]"], ["", "fun monom_mult_poly :: \"('v :: linorder monom \\<times> 'a) \\<Rightarrow> ('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly\" where \n  \"monom_mult_poly _ [] = []\"\n| \"monom_mult_poly (m,c) ((m',d) # p) = (if c * d = 0 then monom_mult_poly (m,c) p else (m * m', c * d) # monom_mult_poly (m,c) p)\""], ["", "lemma monom_mult_poly_inv: \"poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m,c) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p)", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) [])\n 2. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "case Nil"], ["proof (state)\nthis:\n  poly_inv []\n\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) [])\n 2. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "thus ?case"], ["proof (prove)\nusing this:\n  poly_inv []\n\ngoal (1 subgoal):\n 1. poly_inv (monom_mult_poly (m, c) [])", "by (simp add: poly_inv_def)"], ["proof (state)\nthis:\n  poly_inv (monom_mult_poly (m, c) [])\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "case (Cons md p)"], ["proof (state)\nthis:\n  poly_inv p \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) p)\n  poly_inv (md # p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "obtain m' d where md: \"md = (m',d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m' d. md = (m', d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases md, auto)"], ["proof (state)\nthis:\n  md = (m', d)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "with Cons(2)"], ["proof (chain)\npicking this:\n  poly_inv (md # p)\n  md = (m', d)", "have p: \"poly_inv p\""], ["proof (prove)\nusing this:\n  poly_inv (md # p)\n  md = (m', d)\n\ngoal (1 subgoal):\n 1. poly_inv p", "unfolding poly_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>c\\<in>snd ` set (md # p). c \\<noteq> (0::'b)) \\<and>\n  distinct (map fst (md # p))\n  md = (m', d)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'b)) \\<and>\n    distinct (map fst p)", "by auto"], ["proof (state)\nthis:\n  poly_inv p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "from Cons(1)[OF p]"], ["proof (chain)\npicking this:\n  poly_inv (monom_mult_poly (m, c) p)", "have prod: \"poly_inv (monom_mult_poly (m,c) p)\""], ["proof (prove)\nusing this:\n  poly_inv (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. poly_inv (monom_mult_poly (m, c) p)", "."], ["proof (state)\nthis:\n  poly_inv (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "{"], ["proof (state)\nthis:\n  poly_inv (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "fix mm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "assume \"mm \\<in> fst ` set (monom_mult_poly (m,c) p)\" \n       and two: \"mm = m * m'\""], ["proof (state)\nthis:\n  mm \\<in> poly_monoms (monom_mult_poly (m, c) p)\n  mm = m * m'\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "then"], ["proof (chain)\npicking this:\n  mm \\<in> poly_monoms (monom_mult_poly (m, c) p)\n  mm = m * m'", "obtain dd where one: \"(mm,dd) \\<in> set (monom_mult_poly (m,c) p)\""], ["proof (prove)\nusing this:\n  mm \\<in> poly_monoms (monom_mult_poly (m, c) p)\n  mm = m * m'\n\ngoal (1 subgoal):\n 1. (\\<And>dd.\n        (mm, dd) \\<in> set (monom_mult_poly (m, c) p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (mm, dd) \\<in> set (monom_mult_poly (m, c) p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "have \"poly_monoms (monom_mult_poly (m,c) p) \\<subseteq> (*) m ` poly_monoms p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p", "proof (induct p, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       poly_monoms (monom_mult_poly (m, c) p)\n       \\<subseteq> (*) m ` poly_monoms p \\<Longrightarrow>\n       poly_monoms (monom_mult_poly (m, c) (a # p))\n       \\<subseteq> (*) m ` poly_monoms (a # p)", "case (Cons md p)"], ["proof (state)\nthis:\n  poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       poly_monoms (monom_mult_poly (m, c) p)\n       \\<subseteq> (*) m ` poly_monoms p \\<Longrightarrow>\n       poly_monoms (monom_mult_poly (m, c) (a # p))\n       \\<subseteq> (*) m ` poly_monoms (a # p)", "thus ?case"], ["proof (prove)\nusing this:\n  poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. poly_monoms (monom_mult_poly (m, c) (md # p))\n    \\<subseteq> (*) m ` poly_monoms (md # p)", "by (cases md, auto)"], ["proof (state)\nthis:\n  poly_monoms (monom_mult_poly (m, c) (md # p))\n  \\<subseteq> (*) m ` poly_monoms (md # p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "with one"], ["proof (chain)\npicking this:\n  (mm, dd) \\<in> set (monom_mult_poly (m, c) p)\n  poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p", "have \"mm \\<in> (*) m ` poly_monoms p\""], ["proof (prove)\nusing this:\n  (mm, dd) \\<in> set (monom_mult_poly (m, c) p)\n  poly_monoms (monom_mult_poly (m, c) p) \\<subseteq> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. mm \\<in> (*) m ` poly_monoms p", "by force"], ["proof (state)\nthis:\n  mm \\<in> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "then"], ["proof (chain)\npicking this:\n  mm \\<in> (*) m ` poly_monoms p", "obtain mmm where mmm: \"mmm \\<in> poly_monoms p\" and mm: \"mm = m * mmm\""], ["proof (prove)\nusing this:\n  mm \\<in> (*) m ` poly_monoms p\n\ngoal (1 subgoal):\n 1. (\\<And>mmm.\n        \\<lbrakk>mmm \\<in> poly_monoms p; mm = m * mmm\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  mmm \\<in> poly_monoms p\n  mm = m * mmm\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "from Cons(2)[simplified md] mmm"], ["proof (chain)\npicking this:\n  poly_inv ((m', d) # p)\n  mmm \\<in> poly_monoms p", "have not1: \"\\<not> mmm = m'\""], ["proof (prove)\nusing this:\n  poly_inv ((m', d) # p)\n  mmm \\<in> poly_monoms p\n\ngoal (1 subgoal):\n 1. mmm \\<noteq> m'", "unfolding poly_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>c\\<in>snd ` set ((m', d) # p). c \\<noteq> (0::'b)) \\<and>\n  distinct (map fst ((m', d) # p))\n  mmm \\<in> poly_monoms p\n\ngoal (1 subgoal):\n 1. mmm \\<noteq> m'", "by auto"], ["proof (state)\nthis:\n  mmm \\<noteq> m'\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "from mm two"], ["proof (chain)\npicking this:\n  mm = m * mmm\n  mm = m * m'", "have \"m * mmm = m * m'\""], ["proof (prove)\nusing this:\n  mm = m * mmm\n  mm = m * m'\n\ngoal (1 subgoal):\n 1. m * mmm = m * m'", "by simp"], ["proof (state)\nthis:\n  m * mmm = m * m'\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "from monom_mult_inj[OF this] not1"], ["proof (chain)\npicking this:\n  mmm = m'\n  mmm \\<noteq> m'", "have False"], ["proof (prove)\nusing this:\n  mmm = m'\n  mmm \\<noteq> m'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?mm2 \\<in> poly_monoms (monom_mult_poly (m, c) p);\n   ?mm2 = m * m'\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (monom_mult_poly (m, c) p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (monom_mult_poly (m, c) (a # p))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?mm2 \\<in> poly_monoms (monom_mult_poly (m, c) p);\n   ?mm2 = m * m'\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. poly_inv (monom_mult_poly (m, c) (md # p))", "by (simp add: md prod, intro impI, auto simp: poly_inv_def prod[simplified poly_inv_def])"], ["proof (state)\nthis:\n  poly_inv (monom_mult_poly (m, c) (md # p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monom_mult_poly[simp]: \"eval_poly \\<alpha> (monom_mult_poly mc p) = eval_monomc \\<alpha> mc * eval_poly \\<alpha> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly mc p) =\n    eval_monomc \\<alpha> mc * eval_poly \\<alpha> p", "proof (cases mc)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mc = (a, b) \\<Longrightarrow>\n       eval_poly \\<alpha> (monom_mult_poly mc p) =\n       eval_monomc \\<alpha> mc * eval_poly \\<alpha> p", "case (Pair m c)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mc = (a, b) \\<Longrightarrow>\n       eval_poly \\<alpha> (monom_mult_poly mc p) =\n       eval_monomc \\<alpha> mc * eval_poly \\<alpha> p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly mc p) =\n    eval_monomc \\<alpha> mc * eval_poly \\<alpha> p", "proof (simp add: Pair, induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> []\n 2. \\<And>a p.\n       eval_poly \\<alpha> (monom_mult_poly (m, c) p) =\n       eval_monom \\<alpha> m * c * eval_poly \\<alpha> p \\<Longrightarrow>\n       eval_poly \\<alpha> (monom_mult_poly (m, c) (a # p)) =\n       eval_monom \\<alpha> m * c * eval_poly \\<alpha> (a # p)", "case (Cons nd q)"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (monom_mult_poly (m, c) q) =\n  eval_monom \\<alpha> m * c * eval_poly \\<alpha> q\n\ngoal (2 subgoals):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> []\n 2. \\<And>a p.\n       eval_poly \\<alpha> (monom_mult_poly (m, c) p) =\n       eval_monom \\<alpha> m * c * eval_poly \\<alpha> p \\<Longrightarrow>\n       eval_poly \\<alpha> (monom_mult_poly (m, c) (a # p)) =\n       eval_monom \\<alpha> m * c * eval_poly \\<alpha> (a # p)", "obtain n d where nd: \"nd = (n,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d. nd = (n, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases nd, auto)"], ["proof (state)\nthis:\n  nd = (n, d)\n\ngoal (2 subgoals):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> []\n 2. \\<And>a p.\n       eval_poly \\<alpha> (monom_mult_poly (m, c) p) =\n       eval_monom \\<alpha> m * c * eval_poly \\<alpha> p \\<Longrightarrow>\n       eval_poly \\<alpha> (monom_mult_poly (m, c) (a # p)) =\n       eval_monom \\<alpha> m * c * eval_poly \\<alpha> (a # p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "proof (cases \"c * d = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c * d = (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n 2. c * d \\<noteq> (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "case False"], ["proof (state)\nthis:\n  c * d \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. c * d = (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n 2. c * d \\<noteq> (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  c * d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "by (simp add: nd Cons field_simps)"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n  eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "case True"], ["proof (state)\nthis:\n  c * d = (0::'a)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "let ?l = \"c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "have \"?l = (c * d) * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) =\n    c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)", "by (simp only: field_simps)"], ["proof (state)\nthis:\n  c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) =\n  c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "also"], ["proof (state)\nthis:\n  c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) =\n  c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n) = (0::'a)", "by (simp only: True, simp add: field_simps)"], ["proof (state)\nthis:\n  c * d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n) = (0::'a)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "finally"], ["proof (chain)\npicking this:\n  c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)", "have l: \"?l = 0\""], ["proof (prove)\nusing this:\n  c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)\n\ngoal (1 subgoal):\n 1. c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)", "."], ["proof (state)\nthis:\n  c * (d * (eval_monom \\<alpha> m * eval_monom \\<alpha> n)) = (0::'a)\n\ngoal (1 subgoal):\n 1. c * d = (0::'a) \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)", "by (simp add: nd Cons True, simp add: field_simps l)"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n  eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (monom_mult_poly (m, c) (nd # q)) =\n  eval_monom \\<alpha> m * c * eval_poly \\<alpha> (nd # q)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_mult_poly (m, c) []) =\n    eval_monom \\<alpha> m * c * eval_poly \\<alpha> []", "qed simp"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (monom_mult_poly mc p) =\n  eval_monomc \\<alpha> mc * eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!", "qed"], ["", "declare monom_mult_poly.simps[simp del]"], ["", "definition poly_minus :: \"('v :: linorder,'a :: ring_1)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('v,'a)poly\" where\n  \"poly_minus f g = poly_add f (monom_mult_poly (1,-1) g)\""], ["", "lemma poly_minus[simp]: \"eval_poly \\<alpha> (poly_minus f g) = eval_poly \\<alpha> f - eval_poly \\<alpha> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_minus f g) =\n    eval_poly \\<alpha> f - eval_poly \\<alpha> g", "unfolding poly_minus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_add f (monom_mult_poly (1, - (1::'a)) g)) =\n    eval_poly \\<alpha> f - eval_poly \\<alpha> g", "by simp"], ["", "lemma poly_minus_inv: \"poly_inv f \\<Longrightarrow> poly_inv g \\<Longrightarrow> poly_inv (poly_minus f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_inv f; poly_inv g\\<rbrakk>\n    \\<Longrightarrow> poly_inv (poly_minus f g)", "unfolding poly_minus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_inv f; poly_inv g\\<rbrakk>\n    \\<Longrightarrow> poly_inv\n                       (poly_add f (monom_mult_poly (1, - (1::'b)) g))", "by (intro poly_add_inv monom_mult_poly_inv)"], ["", "fun poly_mult :: \"('v :: linorder, 'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('v,'a)poly\" where \n  \"poly_mult [] q = []\"\n| \"poly_mult (mc # p) q = poly_add (monom_mult_poly mc q) (poly_mult p q)\""], ["", "lemma poly_mult_inv: assumes p: \"poly_inv p\" and q: \"poly_inv q\"\n  shows \"poly_inv (poly_mult p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_mult p q)", "using p"], ["proof (prove)\nusing this:\n  poly_inv p\n\ngoal (1 subgoal):\n 1. poly_inv (poly_mult p q)", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_mult [] q)\n 2. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_mult (a # p) q)", "case Nil"], ["proof (state)\nthis:\n  poly_inv []\n\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_mult [] q)\n 2. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_mult (a # p) q)", "thus ?case"], ["proof (prove)\nusing this:\n  poly_inv []\n\ngoal (1 subgoal):\n 1. poly_inv (poly_mult [] q)", "by (simp add: poly_inv_def)"], ["proof (state)\nthis:\n  poly_inv (poly_mult [] q)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_mult (a # p) q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_mult (a # p) q)", "case (Cons mc p)"], ["proof (state)\nthis:\n  poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q)\n  poly_inv (mc # p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_mult (a # p) q)", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mc, auto)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_mult (a # p) q)", "with Cons(2)"], ["proof (chain)\npicking this:\n  poly_inv (mc # p)\n  mc = (m, c)", "have p: \"poly_inv p\""], ["proof (prove)\nusing this:\n  poly_inv (mc # p)\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. poly_inv p", "unfolding poly_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>c\\<in>snd ` set (mc # p). c \\<noteq> (0::'b)) \\<and>\n  distinct (map fst (mc # p))\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'b)) \\<and>\n    distinct (map fst p)", "by auto"], ["proof (state)\nthis:\n  poly_inv p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow> poly_inv (poly_mult p q);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_mult (a # p) q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_mult (mc # p) q)", "by (simp add: mc, rule poly_add_inv[OF monom_mult_poly_inv[OF q] Cons(1)[OF p]])"], ["proof (state)\nthis:\n  poly_inv (poly_mult (mc # p) q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_mult[simp]: \"eval_poly \\<alpha> (poly_mult p q) = eval_poly \\<alpha> p * eval_poly \\<alpha> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_mult p q) =\n    eval_poly \\<alpha> p * eval_poly \\<alpha> q", "by (induct p, auto simp: field_simps)"], ["", "declare poly_mult.simps[simp del]"], ["", "definition zero_poly :: \"('v,'a)poly\"\nwhere \"zero_poly \\<equiv> []\""], ["", "lemma zero_poly_inv: \"poly_inv zero_poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv zero_poly", "unfolding zero_poly_def poly_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set []. c \\<noteq> (0::'b)) \\<and>\n    distinct (map fst [])", "by auto"], ["", "definition one_poly :: \"('v :: linorder,'a :: semiring_1)poly\" where \n  \"one_poly \\<equiv> [(1,1)]\""], ["", "lemma one_poly_inv: \"poly_inv one_poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv one_poly", "unfolding one_poly_def poly_inv_def monom_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set [(1, 1::'b)]. c \\<noteq> (0::'b)) \\<and>\n    distinct (map fst [(1, 1::'b)])", "by auto"], ["", "lemma poly_one[simp]: \"eval_poly \\<alpha> one_poly = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> one_poly = (1::'a)", "unfolding one_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> [(1, 1::'a)] = (1::'a)", "by simp"], ["", "lemma poly_zero_add: \"poly_add zero_poly p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_add zero_poly p = p", "unfolding zero_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_add [] p = p", "using poly_add.simps"], ["proof (prove)\nusing this:\n  poly_add [] ?q = ?q\n  poly_add ((?m, ?c) # ?p) ?q =\n  (case List.extract (\\<lambda>mc. fst mc = ?m) ?q of\n   None \\<Rightarrow> (?m, ?c) # poly_add ?p ?q\n   | Some (q1, (x, d), q2) \\<Rightarrow>\n       if ?c + d = (0::?'a) then poly_add ?p (q1 @ q2)\n       else (?m, ?c + d) # poly_add ?p (q1 @ q2))\n\ngoal (1 subgoal):\n 1. poly_add [] p = p", "by auto"], ["", "lemma poly_zero_mult: \"poly_mult zero_poly p = zero_poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mult zero_poly p = zero_poly", "unfolding zero_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mult [] p = []", "using poly_mult.simps"], ["proof (prove)\nusing this:\n  poly_mult [] ?q = []\n  poly_mult (?mc # ?p) ?q =\n  poly_add (monom_mult_poly ?mc ?q) (poly_mult ?p ?q)\n\ngoal (1 subgoal):\n 1. poly_mult [] p = []", "by auto"], ["", "text \\<open>equality of polynomials\\<close>"], ["", "definition eq_poly :: \"('v :: linorder, 'a :: comm_semiring_1)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \"=p\" 51)\nwhere \"p =p q \\<equiv> \\<forall> \\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q\""], ["", "lemma poly_one_mult: \"poly_mult one_poly p =p p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mult one_poly p =p p", "unfolding eq_poly_def one_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       eval_poly \\<alpha> (poly_mult [(1, 1::'b)] p) = eval_poly \\<alpha> p", "by simp"], ["", "lemma eq_poly_refl[simp]: \"p =p p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =p p", "unfolding eq_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> p", "by auto"], ["", "lemma eq_poly_trans[trans]: \"\\<lbrakk>p1 =p p2; p2 =p p3\\<rbrakk> \\<Longrightarrow> p1 =p p3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 =p p2; p2 =p p3\\<rbrakk> \\<Longrightarrow> p1 =p p3", "unfolding eq_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>.\n                eval_poly \\<alpha> p1 = eval_poly \\<alpha> p2;\n     \\<forall>\\<alpha>.\n        eval_poly \\<alpha> p2 = eval_poly \\<alpha> p3\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<alpha>.\n                         eval_poly \\<alpha> p1 = eval_poly \\<alpha> p3", "by auto"], ["", "lemma poly_add_comm: \"poly_add p q =p poly_add q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_add p q =p poly_add q p", "unfolding eq_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       eval_poly \\<alpha> (poly_add p q) = eval_poly \\<alpha> (poly_add q p)", "by (auto simp: field_simps)"], ["", "lemma poly_add_assoc: \"poly_add p1 (poly_add p2 p3) =p poly_add (poly_add p1 p2) p3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_add p1 (poly_add p2 p3) =p poly_add (poly_add p1 p2) p3", "unfolding eq_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       eval_poly \\<alpha> (poly_add p1 (poly_add p2 p3)) =\n       eval_poly \\<alpha> (poly_add (poly_add p1 p2) p3)", "by (auto simp: field_simps)"], ["", "lemma poly_mult_comm: \"poly_mult p q =p poly_mult q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p q =p poly_mult q p", "unfolding eq_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       eval_poly \\<alpha> (poly_mult p q) =\n       eval_poly \\<alpha> (poly_mult q p)", "by (auto simp: field_simps)"], ["", "lemma poly_mult_assoc: \"poly_mult p1 (poly_mult p2 p3) =p poly_mult (poly_mult p1 p2) p3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p1 (poly_mult p2 p3) =p poly_mult (poly_mult p1 p2) p3", "unfolding eq_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       eval_poly \\<alpha> (poly_mult p1 (poly_mult p2 p3)) =\n       eval_poly \\<alpha> (poly_mult (poly_mult p1 p2) p3)", "by (auto simp: field_simps)"], ["", "lemma poly_distrib: \"poly_mult p (poly_add q1 q2) =p poly_add (poly_mult p q1) (poly_mult p q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p (poly_add q1 q2) =p\n    poly_add (poly_mult p q1) (poly_mult p q2)", "unfolding eq_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       eval_poly \\<alpha> (poly_mult p (poly_add q1 q2)) =\n       eval_poly \\<alpha> (poly_add (poly_mult p q1) (poly_mult p q2))", "by (auto simp: field_simps)"], ["", "subsection \\<open>Computing normal forms of polynomials\\<close>"], ["", "fun\n  poly_of :: \"('v :: linorder,'a :: comm_semiring_1)tpoly \\<Rightarrow> ('v,'a)poly\"\nwhere \"poly_of (PNum i) = (if i = 0 then [] else [(1,i)])\"\n    | \"poly_of (PVar x) = [(var_monom x,1)]\"\n    | \"poly_of (PSum []) = zero_poly\" \n    | \"poly_of (PSum (p # ps)) = (poly_add (poly_of p) (poly_of (PSum ps)))\"\n    | \"poly_of (PMult []) = one_poly\" \n    | \"poly_of (PMult (p # ps)) = (poly_mult (poly_of p) (poly_of (PMult ps)))\""], ["", "text \\<open>\n  evaluation is preserved by poly\\_of\n\\<close>"], ["", "lemma poly_of: \"eval_poly \\<alpha> (poly_of p) = eval_tpoly \\<alpha> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_of p) = eval_tpoly \\<alpha> p", "by (induct p rule: poly_of.induct, (simp add: zero_poly_def one_poly_def)+)"], ["", "text \\<open>\n  poly\\_of only generates polynomials that satisfy the invariant\n\\<close>"], ["", "lemma poly_of_inv: \"poly_inv (poly_of p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_of p)", "by (induct p rule: poly_of.induct, \n    simp add: poly_inv_def monom_inv_def,\n    simp add: poly_inv_def monom_inv_def,\n    simp add: zero_poly_inv,\n    simp add: poly_add_inv,\n    simp add: one_poly_inv,\n    simp add: poly_mult_inv)"], ["", "subsection \\<open>Powers and substitutions of polynomials\\<close>"], ["", "fun poly_power :: \"('v :: linorder, 'a :: comm_semiring_1)poly \\<Rightarrow> nat \\<Rightarrow> ('v,'a)poly\" where \n  \"poly_power _ 0 = one_poly\"\n| \"poly_power p (Suc n) = poly_mult p (poly_power p n)\""], ["", "lemma poly_power[simp]: \"eval_poly \\<alpha> (poly_power p n) = (eval_poly \\<alpha> p) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_power p n) = eval_poly \\<alpha> p ^ n", "by (induct n, auto simp: one_poly_def)"], ["", "lemma poly_power_inv: assumes p: \"poly_inv p\" \n  shows \"poly_inv (poly_power p n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_power p n)", "by (induct n, simp add: one_poly_inv, simp add: poly_mult_inv[OF p])"], ["", "declare poly_power.simps[simp del]"], ["", "fun monom_list_subst :: \"('v \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> 'v monom_list \\<Rightarrow> ('w,'a)poly\" where \n  \"monom_list_subst \\<sigma> [] = one_poly\"\n| \"monom_list_subst \\<sigma> ((x,p) # m) = poly_mult (poly_power (\\<sigma> x) p) (monom_list_subst \\<sigma> m)\""], ["", "lift_definition monom_list :: \"'v :: linorder monom \\<Rightarrow> 'v monom_list\" is \"\\<lambda> x. x\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition monom_subst :: \"('v :: linorder \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> 'v monom \\<Rightarrow> ('w,'a)poly\" where \n  \"monom_subst \\<sigma> m = monom_list_subst \\<sigma> (monom_list m)\""], ["", "lemma monom_list_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" \n  shows \"poly_inv (monom_list_subst \\<sigma> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> m)", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_inv (monom_list_subst \\<sigma> [])\n 2. \\<And>a m.\n       poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow>\n       poly_inv (monom_list_subst \\<sigma> (a # m))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. poly_inv (monom_list_subst \\<sigma> [])\n 2. \\<And>a m.\n       poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow>\n       poly_inv (monom_list_subst \\<sigma> (a # m))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> [])", "by (simp add: one_poly_inv)"], ["proof (state)\nthis:\n  poly_inv (monom_list_subst \\<sigma> [])\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow>\n       poly_inv (monom_list_subst \\<sigma> (a # m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m.\n       poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow>\n       poly_inv (monom_list_subst \\<sigma> (a # m))", "case (Cons xp m)"], ["proof (state)\nthis:\n  poly_inv (monom_list_subst \\<sigma> m)\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow>\n       poly_inv (monom_list_subst \\<sigma> (a # m))", "obtain x p where xp: \"xp = (x,p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x p. xp = (x, p) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xp, auto)"], ["proof (state)\nthis:\n  xp = (x, p)\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       poly_inv (monom_list_subst \\<sigma> m) \\<Longrightarrow>\n       poly_inv (monom_list_subst \\<sigma> (a # m))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> (xp # m))", "by (simp add: xp, rule poly_mult_inv[OF poly_power_inv[OF sub] Cons])"], ["proof (state)\nthis:\n  poly_inv (monom_list_subst \\<sigma> (xp # m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monom_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" \n  shows \"poly_inv (monom_subst \\<sigma> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_subst \\<sigma> m)", "unfolding monom_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (monom_list_subst \\<sigma> (monom_list m))", "by (rule monom_list_subst_inv[OF sub])"], ["", "lemma monom_subst[simp]: \"eval_poly \\<alpha> (monom_subst \\<sigma> m) = eval_monom (\\<lambda> v. eval_poly \\<alpha> (\\<sigma> v)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_subst \\<sigma> m) =\n    eval_monom (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m", "unfolding monom_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (monom_list_subst \\<sigma> (monom_list m)) =\n    eval_monom (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m", "proof (transfer fixing: \\<alpha> \\<sigma>, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       monom_inv m \\<Longrightarrow>\n       eval_poly \\<alpha> (monom_list_subst \\<sigma> m) =\n       eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       monom_inv m \\<Longrightarrow>\n       eval_poly \\<alpha> (monom_list_subst \\<sigma> m) =\n       eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m", "show \"monom_inv m \\<Longrightarrow> eval_poly \\<alpha> (monom_list_subst \\<sigma> m) = eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_inv m \\<Longrightarrow>\n    eval_poly \\<alpha> (monom_list_subst \\<sigma> m) =\n    eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m", "by (induct m, simp add: one_poly_def, auto simp: field_simps monom_inv_ConsD)"], ["proof (state)\nthis:\n  monom_inv m \\<Longrightarrow>\n  eval_poly \\<alpha> (monom_list_subst \\<sigma> m) =\n  eval_monom_list (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) m\n\ngoal:\nNo subgoals!", "qed"], ["", "fun poly_subst :: \"('v :: linorder \\<Rightarrow> ('w :: linorder,'a :: comm_semiring_1)poly) \\<Rightarrow> ('v,'a)poly \\<Rightarrow> ('w,'a)poly\" where \n  \"poly_subst \\<sigma> [] = zero_poly\"\n| \"poly_subst \\<sigma> ((m,c) # p) = poly_add (poly_mult [(1,c)] (monom_subst \\<sigma> m)) (poly_subst \\<sigma> p)\""], ["", "lemma poly_subst_inv: assumes sub: \"\\<And> x. poly_inv (\\<sigma> x)\" and p: \"poly_inv p\"\n  shows \"poly_inv (poly_subst \\<sigma> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> p)", "using p"], ["proof (prove)\nusing this:\n  poly_inv p\n\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> p)", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_subst \\<sigma> [])\n 2. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (poly_subst \\<sigma> p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))", "case Nil"], ["proof (state)\nthis:\n  poly_inv []\n\ngoal (2 subgoals):\n 1. poly_inv [] \\<Longrightarrow> poly_inv (poly_subst \\<sigma> [])\n 2. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (poly_subst \\<sigma> p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))", "thus ?case"], ["proof (prove)\nusing this:\n  poly_inv []\n\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> [])", "by (simp add: zero_poly_inv)"], ["proof (state)\nthis:\n  poly_inv (poly_subst \\<sigma> [])\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (poly_subst \\<sigma> p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (poly_subst \\<sigma> p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))", "case (Cons mc p)"], ["proof (state)\nthis:\n  poly_inv p \\<Longrightarrow> poly_inv (poly_subst \\<sigma> p)\n  poly_inv (mc # p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (poly_subst \\<sigma> p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mc, auto)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (poly_subst \\<sigma> p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))", "with Cons(2)"], ["proof (chain)\npicking this:\n  poly_inv (mc # p)\n  mc = (m, c)", "have c: \"c \\<noteq> 0\" and p: \"poly_inv p\""], ["proof (prove)\nusing this:\n  poly_inv (mc # p)\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'c) &&& poly_inv p", "unfolding poly_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>c\\<in>snd ` set (mc # p). c \\<noteq> (0::'c)) \\<and>\n  distinct (map fst (mc # p))\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'c) &&&\n    (\\<forall>c\\<in>snd ` set p. c \\<noteq> (0::'c)) \\<and>\n    distinct (map fst p)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'c)\n  poly_inv p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (poly_subst \\<sigma> p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))", "from c"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'c)", "have c: \"poly_inv [(1,c)]\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. poly_inv [(1, c)]", "unfolding poly_inv_def monom_inv_def"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>snd ` set [(1, c)]. c \\<noteq> (0::'c)) \\<and>\n    distinct (map fst [(1, c)])", "by auto"], ["proof (state)\nthis:\n  poly_inv [(1, c)]\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>poly_inv p \\<Longrightarrow>\n                poly_inv (poly_subst \\<sigma> p);\n        poly_inv (a # p)\\<rbrakk>\n       \\<Longrightarrow> poly_inv (poly_subst \\<sigma> (a # p))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inv (poly_subst \\<sigma> (mc # p))", "by (simp add: mc, rule poly_add_inv[OF poly_mult_inv[OF c monom_subst_inv[OF sub]] Cons(1)[OF p]])"], ["proof (state)\nthis:\n  poly_inv (poly_subst \\<sigma> (mc # p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_subst: \"eval_poly \\<alpha> (poly_subst \\<sigma> p) = eval_poly (\\<lambda> v. eval_poly \\<alpha> (\\<sigma> v)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst \\<sigma> p) =\n    eval_poly (\\<lambda>v. eval_poly \\<alpha> (\\<sigma> v)) p", "by (induct p, simp add: zero_poly_def, auto simp: field_simps)"], ["", "lemma eval_poly_subst: \n  assumes eq: \"\\<And> w. f w = eval_poly g (q w)\"\n  shows \"eval_poly f p = eval_poly g (poly_subst q p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p = eval_poly g (poly_subst q p)", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval_poly f [] = eval_poly g (poly_subst q [])\n 2. \\<And>a p.\n       eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow>\n       eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. eval_poly f [] = eval_poly g (poly_subst q [])\n 2. \\<And>a p.\n       eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow>\n       eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f [] = eval_poly g (poly_subst q [])", "by (simp add: zero_poly_def)"], ["proof (state)\nthis:\n  eval_poly f [] = eval_poly g (poly_subst q [])\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow>\n       eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow>\n       eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))", "case (Cons mc p)"], ["proof (state)\nthis:\n  eval_poly f p = eval_poly g (poly_subst q p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow>\n       eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mc, auto)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow>\n       eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))", "have id: \"eval_monom f m =  eval_monom (\\<lambda>v. eval_poly g (q v)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m = eval_monom (\\<lambda>v. eval_poly g (q v)) m", "proof (transfer fixing: f g q, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       monom_inv m \\<Longrightarrow>\n       eval_monom_list f m =\n       eval_monom_list (\\<lambda>v. eval_poly g (q v)) m", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       monom_inv m \\<Longrightarrow>\n       eval_monom_list f m =\n       eval_monom_list (\\<lambda>v. eval_poly g (q v)) m", "show \"eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval_monom_list f [] =\n    eval_monom_list (\\<lambda>v. eval_poly g (q v)) []\n 2. \\<And>a m.\n       eval_monom_list f m =\n       eval_monom_list (\\<lambda>v. eval_poly g (q v)) m \\<Longrightarrow>\n       eval_monom_list f (a # m) =\n       eval_monom_list (\\<lambda>v. eval_poly g (q v)) (a # m)", "case (Cons wp m)"], ["proof (state)\nthis:\n  eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m\n\ngoal (2 subgoals):\n 1. eval_monom_list f [] =\n    eval_monom_list (\\<lambda>v. eval_poly g (q v)) []\n 2. \\<And>a m.\n       eval_monom_list f m =\n       eval_monom_list (\\<lambda>v. eval_poly g (q v)) m \\<Longrightarrow>\n       eval_monom_list f (a # m) =\n       eval_monom_list (\\<lambda>v. eval_poly g (q v)) (a # m)", "obtain w p where wp: \"wp = (w,p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w p. wp = (w, p) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases wp, auto)"], ["proof (state)\nthis:\n  wp = (w, p)\n\ngoal (2 subgoals):\n 1. eval_monom_list f [] =\n    eval_monom_list (\\<lambda>v. eval_poly g (q v)) []\n 2. \\<And>a m.\n       eval_monom_list f m =\n       eval_monom_list (\\<lambda>v. eval_poly g (q v)) m \\<Longrightarrow>\n       eval_monom_list f (a # m) =\n       eval_monom_list (\\<lambda>v. eval_poly g (q v)) (a # m)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list f (wp # m) =\n    eval_monom_list (\\<lambda>v. eval_poly g (q v)) (wp # m)", "by (simp add: wp Cons eq)"], ["proof (state)\nthis:\n  eval_monom_list f (wp # m) =\n  eval_monom_list (\\<lambda>v. eval_poly g (q v)) (wp # m)\n\ngoal (1 subgoal):\n 1. eval_monom_list f [] =\n    eval_monom_list (\\<lambda>v. eval_poly g (q v)) []", "qed simp"], ["proof (state)\nthis:\n  eval_monom_list f m = eval_monom_list (\\<lambda>v. eval_poly g (q v)) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_monom f m = eval_monom (\\<lambda>v. eval_poly g (q v)) m\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly f p = eval_poly g (poly_subst q p) \\<Longrightarrow>\n       eval_poly f (a # p) = eval_poly g (poly_subst q (a # p))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) = eval_poly g (poly_subst q (mc # p))", "by (simp add: mc Cons id, simp add: field_simps)"], ["proof (state)\nthis:\n  eval_poly f (mc # p) = eval_poly g (poly_subst q (mc # p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition monom_vars_list :: \"'v :: linorder monom \\<Rightarrow> 'v list\" is \"map fst\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma monom_vars_list_subst: assumes \"\\<And> w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w\" \n  shows \"monom_subst f m = monom_subst g m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_subst f m = monom_subst g m", "unfolding monom_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_list_subst f (monom_list m) = monom_list_subst g (monom_list m)", "using assms"], ["proof (prove)\nusing this:\n  ?w \\<in> set (monom_vars_list m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_list_subst f (monom_list m) = monom_list_subst g (monom_list m)", "proof (transfer fixing: f g)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> Collect monom_inv;\n        \\<And>w.\n           w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\\<rbrakk>\n       \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m", "fix m :: \"'a monom_list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> Collect monom_inv;\n        \\<And>w.\n           w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\\<rbrakk>\n       \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m", "assume eq: \"\\<And>w. w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\""], ["proof (state)\nthis:\n  ?w \\<in> set (map fst m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> Collect monom_inv;\n        \\<And>w.\n           w \\<in> set (map fst m) \\<Longrightarrow> f w = g w\\<rbrakk>\n       \\<Longrightarrow> monom_list_subst f m = monom_list_subst g m", "thus \"monom_list_subst f m = monom_list_subst g m\""], ["proof (prove)\nusing this:\n  ?w \\<in> set (map fst m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_list_subst f m = monom_list_subst g m", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>w.\n        w \\<in> set (map fst []) \\<Longrightarrow>\n        f w = g w) \\<Longrightarrow>\n    monom_list_subst f [] = monom_list_subst g []\n 2. \\<And>a m.\n       \\<lbrakk>(\\<And>w.\n                    w \\<in> set (map fst m) \\<Longrightarrow>\n                    f w = g w) \\<Longrightarrow>\n                monom_list_subst f m = monom_list_subst g m;\n        \\<And>w.\n           w \\<in> set (map fst (a # m)) \\<Longrightarrow>\n           f w = g w\\<rbrakk>\n       \\<Longrightarrow> monom_list_subst f (a # m) =\n                         monom_list_subst g (a # m)", "case (Cons wn m)"], ["proof (state)\nthis:\n  (\\<And>w.\n      w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow>\n  monom_list_subst f m = monom_list_subst g m\n  ?w \\<in> set (map fst (wn # m)) \\<Longrightarrow> f ?w = g ?w\n\ngoal (2 subgoals):\n 1. (\\<And>w.\n        w \\<in> set (map fst []) \\<Longrightarrow>\n        f w = g w) \\<Longrightarrow>\n    monom_list_subst f [] = monom_list_subst g []\n 2. \\<And>a m.\n       \\<lbrakk>(\\<And>w.\n                    w \\<in> set (map fst m) \\<Longrightarrow>\n                    f w = g w) \\<Longrightarrow>\n                monom_list_subst f m = monom_list_subst g m;\n        \\<And>w.\n           w \\<in> set (map fst (a # m)) \\<Longrightarrow>\n           f w = g w\\<rbrakk>\n       \\<Longrightarrow> monom_list_subst f (a # m) =\n                         monom_list_subst g (a # m)", "hence rec: \"monom_list_subst f m = monom_list_subst g m\" and eq: \"f (fst wn) = g (fst wn)\""], ["proof (prove)\nusing this:\n  (\\<And>w.\n      w \\<in> set (map fst m) \\<Longrightarrow> f w = g w) \\<Longrightarrow>\n  monom_list_subst f m = monom_list_subst g m\n  ?w \\<in> set (map fst (wn # m)) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_list_subst f m = monom_list_subst g m &&& f (fst wn) = g (fst wn)", "by auto"], ["proof (state)\nthis:\n  monom_list_subst f m = monom_list_subst g m\n  f (fst wn) = g (fst wn)\n\ngoal (2 subgoals):\n 1. (\\<And>w.\n        w \\<in> set (map fst []) \\<Longrightarrow>\n        f w = g w) \\<Longrightarrow>\n    monom_list_subst f [] = monom_list_subst g []\n 2. \\<And>a m.\n       \\<lbrakk>(\\<And>w.\n                    w \\<in> set (map fst m) \\<Longrightarrow>\n                    f w = g w) \\<Longrightarrow>\n                monom_list_subst f m = monom_list_subst g m;\n        \\<And>w.\n           w \\<in> set (map fst (a # m)) \\<Longrightarrow>\n           f w = g w\\<rbrakk>\n       \\<Longrightarrow> monom_list_subst f (a # m) =\n                         monom_list_subst g (a # m)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_list_subst f (wn # m) = monom_list_subst g (wn # m)", "proof (cases wn)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       wn = (a, b) \\<Longrightarrow>\n       monom_list_subst f (wn # m) = monom_list_subst g (wn # m)", "case (Pair w n)"], ["proof (state)\nthis:\n  wn = (w, n)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       wn = (a, b) \\<Longrightarrow>\n       monom_list_subst f (wn # m) = monom_list_subst g (wn # m)", "with eq rec"], ["proof (chain)\npicking this:\n  f (fst wn) = g (fst wn)\n  monom_list_subst f m = monom_list_subst g m\n  wn = (w, n)", "show ?thesis"], ["proof (prove)\nusing this:\n  f (fst wn) = g (fst wn)\n  monom_list_subst f m = monom_list_subst g m\n  wn = (w, n)\n\ngoal (1 subgoal):\n 1. monom_list_subst f (wn # m) = monom_list_subst g (wn # m)", "by auto"], ["proof (state)\nthis:\n  monom_list_subst f (wn # m) = monom_list_subst g (wn # m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom_list_subst f (wn # m) = monom_list_subst g (wn # m)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<in> set (map fst []) \\<Longrightarrow>\n        f w = g w) \\<Longrightarrow>\n    monom_list_subst f [] = monom_list_subst g []", "qed simp"], ["proof (state)\nthis:\n  monom_list_subst f m = monom_list_subst g m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_monom_vars_list: assumes \"\\<And> x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\"\n  shows \"eval_monom \\<alpha> xs = eval_monom \\<beta> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> xs = eval_monom \\<beta> xs", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set (monom_vars_list xs) \\<Longrightarrow>\n  \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> xs = eval_monom \\<beta> xs", "proof (transfer fixing: \\<alpha> \\<beta>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> Collect monom_inv;\n        \\<And>x.\n           x \\<in> set (map fst xs) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_monom_list \\<alpha> xs =\n                         eval_monom_list \\<beta> xs", "fix xs :: \"'a monom_list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> Collect monom_inv;\n        \\<And>x.\n           x \\<in> set (map fst xs) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_monom_list \\<alpha> xs =\n                         eval_monom_list \\<beta> xs", "assume eq: \"\\<And>w. w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> w = \\<beta> w\""], ["proof (state)\nthis:\n  ?w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> Collect monom_inv;\n        \\<And>x.\n           x \\<in> set (map fst xs) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_monom_list \\<alpha> xs =\n                         eval_monom_list \\<beta> xs", "thus \"eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\""], ["proof (prove)\nusing this:\n  ?w \\<in> set (map fst xs) \\<Longrightarrow> \\<alpha> ?w = \\<beta> ?w\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>w.\n        w \\<in> set (map fst []) \\<Longrightarrow>\n        \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n    eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>w.\n                    w \\<in> set (map fst xs) \\<Longrightarrow>\n                    \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n                eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs;\n        \\<And>w.\n           w \\<in> set (map fst (a # xs)) \\<Longrightarrow>\n           \\<alpha> w = \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) =\n                         eval_monom_list \\<beta> (a # xs)", "case (Cons xi xs)"], ["proof (state)\nthis:\n  (\\<And>w.\n      w \\<in> set (map fst xs) \\<Longrightarrow>\n      \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n  eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n  ?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow>\n  \\<alpha> ?w = \\<beta> ?w\n\ngoal (2 subgoals):\n 1. (\\<And>w.\n        w \\<in> set (map fst []) \\<Longrightarrow>\n        \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n    eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>w.\n                    w \\<in> set (map fst xs) \\<Longrightarrow>\n                    \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n                eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs;\n        \\<And>w.\n           w \\<in> set (map fst (a # xs)) \\<Longrightarrow>\n           \\<alpha> w = \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) =\n                         eval_monom_list \\<beta> (a # xs)", "hence IH: \"eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\""], ["proof (prove)\nusing this:\n  (\\<And>w.\n      w \\<in> set (map fst xs) \\<Longrightarrow>\n      \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n  eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n  ?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow>\n  \\<alpha> ?w = \\<beta> ?w\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs", "by auto"], ["proof (state)\nthis:\n  eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\ngoal (2 subgoals):\n 1. (\\<And>w.\n        w \\<in> set (map fst []) \\<Longrightarrow>\n        \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n    eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>w.\n                    w \\<in> set (map fst xs) \\<Longrightarrow>\n                    \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n                eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs;\n        \\<And>w.\n           w \\<in> set (map fst (a # xs)) \\<Longrightarrow>\n           \\<alpha> w = \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) =\n                         eval_monom_list \\<beta> (a # xs)", "obtain x i where xi: \"xi = (x,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x i. xi = (x, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  xi = (x, i)\n\ngoal (2 subgoals):\n 1. (\\<And>w.\n        w \\<in> set (map fst []) \\<Longrightarrow>\n        \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n    eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>w.\n                    w \\<in> set (map fst xs) \\<Longrightarrow>\n                    \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n                eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs;\n        \\<And>w.\n           w \\<in> set (map fst (a # xs)) \\<Longrightarrow>\n           \\<alpha> w = \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) =\n                         eval_monom_list \\<beta> (a # xs)", "from Cons(2) xi"], ["proof (chain)\npicking this:\n  ?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow>\n  \\<alpha> ?w = \\<beta> ?w\n  xi = (x, i)", "have \"\\<alpha> x = \\<beta> x\""], ["proof (prove)\nusing this:\n  ?w \\<in> set (map fst (xi # xs)) \\<Longrightarrow>\n  \\<alpha> ?w = \\<beta> ?w\n  xi = (x, i)\n\ngoal (1 subgoal):\n 1. \\<alpha> x = \\<beta> x", "by auto"], ["proof (state)\nthis:\n  \\<alpha> x = \\<beta> x\n\ngoal (2 subgoals):\n 1. (\\<And>w.\n        w \\<in> set (map fst []) \\<Longrightarrow>\n        \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n    eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>w.\n                    w \\<in> set (map fst xs) \\<Longrightarrow>\n                    \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n                eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs;\n        \\<And>w.\n           w \\<in> set (map fst (a # xs)) \\<Longrightarrow>\n           \\<alpha> w = \\<beta> w\\<rbrakk>\n       \\<Longrightarrow> eval_monom_list \\<alpha> (a # xs) =\n                         eval_monom_list \\<beta> (a # xs)", "with IH"], ["proof (chain)\npicking this:\n  eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n  \\<alpha> x = \\<beta> x", "show ?case"], ["proof (prove)\nusing this:\n  eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n  \\<alpha> x = \\<beta> x\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> (xi # xs) = eval_monom_list \\<beta> (xi # xs)", "unfolding xi"], ["proof (prove)\nusing this:\n  eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n  \\<alpha> x = \\<beta> x\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> ((x, i) # xs) =\n    eval_monom_list \\<beta> ((x, i) # xs)", "by auto"], ["proof (state)\nthis:\n  eval_monom_list \\<alpha> (xi # xs) = eval_monom_list \\<beta> (xi # xs)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<in> set (map fst []) \\<Longrightarrow>\n        \\<alpha> w = \\<beta> w) \\<Longrightarrow>\n    eval_monom_list \\<alpha> [] = eval_monom_list \\<beta> []", "qed simp"], ["proof (state)\nthis:\n  eval_monom_list \\<alpha> xs = eval_monom_list \\<beta> xs\n\ngoal:\nNo subgoals!", "qed"], ["", "definition monom_vars where \"monom_vars m = set (monom_vars_list m)\""], ["", "lemma monom_vars_list_1[simp]: \"monom_vars_list 1 = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_vars_list 1 = []", "by transfer auto"], ["", "lemma monom_vars_list_var_monom[simp]: \"monom_vars_list (var_monom x) = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_vars_list (var_monom x) = [x]", "by transfer auto"], ["", "lemma monom_vars_eval_monom: \n  \"(\\<And> x. x \\<in> monom_vars m \\<Longrightarrow> f x = g x) \\<Longrightarrow> eval_monom f m = eval_monom g m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> monom_vars m \\<Longrightarrow> f x = g x) \\<Longrightarrow>\n    eval_monom f m = eval_monom g m", "by (rule eval_monom_vars_list, auto simp: monom_vars_def)"], ["", "(* the list of variables occurring in p *)"], ["", "definition poly_vars_list :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v list\" where \n  \"poly_vars_list p = remdups (concat (map (monom_vars_list o fst) p))\""], ["", "definition poly_vars :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v set\" where \n  \"poly_vars p = set (concat (map (monom_vars_list o fst) p))\""], ["", "lemma poly_vars_list[simp]: \"set (poly_vars_list p) = poly_vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (poly_vars_list p) = poly_vars p", "unfolding poly_vars_list_def poly_vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups (concat (map (monom_vars_list \\<circ> fst) p))) =\n    set (concat (map (monom_vars_list \\<circ> fst) p))", "by auto"], ["", "lemma poly_vars: assumes eq: \"\\<And> w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w\"\n  shows \"poly_subst f p = poly_subst g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p", "using eq"], ["proof (prove)\nusing this:\n  ?w \\<in> poly_vars p \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>w.\n        w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow>\n    poly_subst f [] = poly_subst g []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>w.\n                    w \\<in> poly_vars p \\<Longrightarrow>\n                    f w = g w) \\<Longrightarrow>\n                poly_subst f p = poly_subst g p;\n        \\<And>w.\n           w \\<in> poly_vars (a # p) \\<Longrightarrow> f w = g w\\<rbrakk>\n       \\<Longrightarrow> poly_subst f (a # p) = poly_subst g (a # p)", "case (Cons mc p)"], ["proof (state)\nthis:\n  (\\<And>w.\n      w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow>\n  poly_subst f p = poly_subst g p\n  ?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\n\ngoal (2 subgoals):\n 1. (\\<And>w.\n        w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow>\n    poly_subst f [] = poly_subst g []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>w.\n                    w \\<in> poly_vars p \\<Longrightarrow>\n                    f w = g w) \\<Longrightarrow>\n                poly_subst f p = poly_subst g p;\n        \\<And>w.\n           w \\<in> poly_vars (a # p) \\<Longrightarrow> f w = g w\\<rbrakk>\n       \\<Longrightarrow> poly_subst f (a # p) = poly_subst g (a # p)", "hence rec: \"poly_subst f p = poly_subst g p\""], ["proof (prove)\nusing this:\n  (\\<And>w.\n      w \\<in> poly_vars p \\<Longrightarrow> f w = g w) \\<Longrightarrow>\n  poly_subst f p = poly_subst g p\n  ?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p", "unfolding poly_vars_def"], ["proof (prove)\nusing this:\n  (\\<And>w.\n      w \\<in> set (concat\n                    (map (monom_vars_list \\<circ> fst) p)) \\<Longrightarrow>\n      f w = g w) \\<Longrightarrow>\n  poly_subst f p = poly_subst g p\n  ?w \\<in> set (concat\n                 (map (monom_vars_list \\<circ> fst)\n                   (mc # p))) \\<Longrightarrow>\n  f ?w = g ?w\n\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p", "by auto"], ["proof (state)\nthis:\n  poly_subst f p = poly_subst g p\n\ngoal (2 subgoals):\n 1. (\\<And>w.\n        w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow>\n    poly_subst f [] = poly_subst g []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>w.\n                    w \\<in> poly_vars p \\<Longrightarrow>\n                    f w = g w) \\<Longrightarrow>\n                poly_subst f p = poly_subst g p;\n        \\<And>w.\n           w \\<in> poly_vars (a # p) \\<Longrightarrow> f w = g w\\<rbrakk>\n       \\<Longrightarrow> poly_subst f (a # p) = poly_subst g (a # p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (mc # p) = poly_subst g (mc # p)", "proof (cases mc)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mc = (a, b) \\<Longrightarrow>\n       poly_subst f (mc # p) = poly_subst g (mc # p)", "case (Pair m c)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mc = (a, b) \\<Longrightarrow>\n       poly_subst f (mc # p) = poly_subst g (mc # p)", "with Cons(2)"], ["proof (chain)\npicking this:\n  ?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\n  mc = (m, c)", "have \"\\<And> w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w\""], ["proof (prove)\nusing this:\n  ?w \\<in> poly_vars (mc # p) \\<Longrightarrow> f ?w = g ?w\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w", "unfolding poly_vars_def"], ["proof (prove)\nusing this:\n  ?w \\<in> set (concat\n                 (map (monom_vars_list \\<circ> fst)\n                   (mc # p))) \\<Longrightarrow>\n  f ?w = g ?w\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> set (monom_vars_list m) \\<Longrightarrow> f w = g w", "by auto"], ["proof (state)\nthis:\n  ?w \\<in> set (monom_vars_list m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mc = (a, b) \\<Longrightarrow>\n       poly_subst f (mc # p) = poly_subst g (mc # p)", "hence \"monom_subst f m = monom_subst g m\""], ["proof (prove)\nusing this:\n  ?w \\<in> set (monom_vars_list m) \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. monom_subst f m = monom_subst g m", "by (rule monom_vars_list_subst)"], ["proof (state)\nthis:\n  monom_subst f m = monom_subst g m\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mc = (a, b) \\<Longrightarrow>\n       poly_subst f (mc # p) = poly_subst g (mc # p)", "with rec Pair"], ["proof (chain)\npicking this:\n  poly_subst f p = poly_subst g p\n  mc = (m, c)\n  monom_subst f m = monom_subst g m", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_subst f p = poly_subst g p\n  mc = (m, c)\n  monom_subst f m = monom_subst g m\n\ngoal (1 subgoal):\n 1. poly_subst f (mc # p) = poly_subst g (mc # p)", "by auto"], ["proof (state)\nthis:\n  poly_subst f (mc # p) = poly_subst g (mc # p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_subst f (mc # p) = poly_subst g (mc # p)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<in> poly_vars [] \\<Longrightarrow> f w = g w) \\<Longrightarrow>\n    poly_subst f [] = poly_subst g []", "qed simp"], ["", "lemma poly_var: assumes pv: \"v \\<notin> poly_vars p\" and diff: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  shows \"poly_subst f p = poly_subst g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g p", "proof (rule poly_vars)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w", "assume \"w \\<in> poly_vars p\""], ["proof (state)\nthis:\n  w \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> poly_vars p \\<Longrightarrow> f w = g w", "thus \"f w = g w\""], ["proof (prove)\nusing this:\n  w \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. f w = g w", "using pv diff"], ["proof (prove)\nusing this:\n  w \\<in> poly_vars p\n  v \\<notin> poly_vars p\n  v \\<noteq> ?w \\<Longrightarrow> f ?w = g ?w\n\ngoal (1 subgoal):\n 1. f w = g w", "by (cases \"v = w\", auto)"], ["proof (state)\nthis:\n  f w = g w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_poly_vars: assumes \"\\<And> x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x\"\n  shows \"eval_poly \\<alpha> p = eval_poly \\<beta> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<beta> p", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<beta> p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> poly_vars [] \\<Longrightarrow>\n        \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n    eval_poly \\<alpha> [] = eval_poly \\<beta> []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> poly_vars p \\<Longrightarrow>\n                    \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n                eval_poly \\<alpha> p = eval_poly \\<beta> p;\n        \\<And>x.\n           x \\<in> poly_vars (a # p) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) =\n                         eval_poly \\<beta> (a # p)", "case Nil"], ["proof (state)\nthis:\n  ?x \\<in> poly_vars [] \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> poly_vars [] \\<Longrightarrow>\n        \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n    eval_poly \\<alpha> [] = eval_poly \\<beta> []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> poly_vars p \\<Longrightarrow>\n                    \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n                eval_poly \\<alpha> p = eval_poly \\<beta> p;\n        \\<And>x.\n           x \\<in> poly_vars (a # p) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) =\n                         eval_poly \\<beta> (a # p)", "thus ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> poly_vars [] \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> [] = eval_poly \\<beta> []", "by simp"], ["proof (state)\nthis:\n  eval_poly \\<alpha> [] = eval_poly \\<beta> []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> poly_vars p \\<Longrightarrow>\n                    \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n                eval_poly \\<alpha> p = eval_poly \\<beta> p;\n        \\<And>x.\n           x \\<in> poly_vars (a # p) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) =\n                         eval_poly \\<beta> (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> poly_vars p \\<Longrightarrow>\n                    \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n                eval_poly \\<alpha> p = eval_poly \\<beta> p;\n        \\<And>x.\n           x \\<in> poly_vars (a # p) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) =\n                         eval_poly \\<beta> (a # p)", "case (Cons m p)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> poly_vars p \\<Longrightarrow>\n      \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n  eval_poly \\<alpha> p = eval_poly \\<beta> p\n  ?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> poly_vars p \\<Longrightarrow>\n                    \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n                eval_poly \\<alpha> p = eval_poly \\<beta> p;\n        \\<And>x.\n           x \\<in> poly_vars (a # p) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) =\n                         eval_poly \\<beta> (a # p)", "from Cons(2)"], ["proof (chain)\npicking this:\n  ?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x", "have \"\\<And> x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x\""], ["proof (prove)\nusing this:\n  ?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> x = \\<beta> x", "unfolding poly_vars_def"], ["proof (prove)\nusing this:\n  ?x \\<in> set (concat\n                 (map (monom_vars_list \\<circ> fst)\n                   (m # p))) \\<Longrightarrow>\n  \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (concat\n                     (map (monom_vars_list \\<circ> fst)\n                       p)) \\<Longrightarrow>\n       \\<alpha> x = \\<beta> x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> poly_vars p \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> poly_vars p \\<Longrightarrow>\n                    \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n                eval_poly \\<alpha> p = eval_poly \\<beta> p;\n        \\<And>x.\n           x \\<in> poly_vars (a # p) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) =\n                         eval_poly \\<beta> (a # p)", "from Cons(1)[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> poly_vars p \\<Longrightarrow>\n      x \\<in> poly_vars p) \\<Longrightarrow>\n  eval_poly \\<alpha> p = eval_poly \\<beta> p", "have IH: \"eval_poly \\<alpha> p = eval_poly \\<beta> p\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> poly_vars p \\<Longrightarrow>\n      x \\<in> poly_vars p) \\<Longrightarrow>\n  eval_poly \\<alpha> p = eval_poly \\<beta> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<beta> p", "."], ["proof (state)\nthis:\n  eval_poly \\<alpha> p = eval_poly \\<beta> p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> poly_vars p \\<Longrightarrow>\n                    \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n                eval_poly \\<alpha> p = eval_poly \\<beta> p;\n        \\<And>x.\n           x \\<in> poly_vars (a # p) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) =\n                         eval_poly \\<beta> (a # p)", "obtain xs c where m: \"m = (xs,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs c. m = (xs, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  m = (xs, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> poly_vars p \\<Longrightarrow>\n                    \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n                eval_poly \\<alpha> p = eval_poly \\<beta> p;\n        \\<And>x.\n           x \\<in> poly_vars (a # p) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) =\n                         eval_poly \\<beta> (a # p)", "from Cons(2)"], ["proof (chain)\npicking this:\n  ?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x", "have \"\\<And> x. x \\<in> set (monom_vars_list xs) \\<Longrightarrow> \\<alpha> x = \\<beta> x\""], ["proof (prove)\nusing this:\n  ?x \\<in> poly_vars (m # p) \\<Longrightarrow> \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (monom_vars_list xs) \\<Longrightarrow>\n       \\<alpha> x = \\<beta> x", "unfolding poly_vars_def m"], ["proof (prove)\nusing this:\n  ?x \\<in> set (concat\n                 (map (monom_vars_list \\<circ> fst)\n                   ((xs, c) # p))) \\<Longrightarrow>\n  \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (monom_vars_list xs) \\<Longrightarrow>\n       \\<alpha> x = \\<beta> x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> set (monom_vars_list xs) \\<Longrightarrow>\n  \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> poly_vars p \\<Longrightarrow>\n                    \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n                eval_poly \\<alpha> p = eval_poly \\<beta> p;\n        \\<And>x.\n           x \\<in> poly_vars (a # p) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) =\n                         eval_poly \\<beta> (a # p)", "hence \"eval_monom \\<alpha> xs = eval_monom \\<beta> xs\""], ["proof (prove)\nusing this:\n  ?x \\<in> set (monom_vars_list xs) \\<Longrightarrow>\n  \\<alpha> ?x = \\<beta> ?x\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> xs = eval_monom \\<beta> xs", "by (rule eval_monom_vars_list)"], ["proof (state)\nthis:\n  eval_monom \\<alpha> xs = eval_monom \\<beta> xs\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> poly_vars p \\<Longrightarrow>\n                    \\<alpha> x = \\<beta> x) \\<Longrightarrow>\n                eval_poly \\<alpha> p = eval_poly \\<beta> p;\n        \\<And>x.\n           x \\<in> poly_vars (a # p) \\<Longrightarrow>\n           \\<alpha> x = \\<beta> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) =\n                         eval_poly \\<beta> (a # p)", "thus ?case"], ["proof (prove)\nusing this:\n  eval_monom \\<alpha> xs = eval_monom \\<beta> xs\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (m # p) = eval_poly \\<beta> (m # p)", "unfolding eval_poly.simps IH m"], ["proof (prove)\nusing this:\n  eval_monom \\<alpha> xs = eval_monom \\<beta> xs\n\ngoal (1 subgoal):\n 1. eval_monomc \\<alpha> (xs, c) + eval_poly \\<beta> p =\n    eval_monomc \\<beta> (xs, c) + eval_poly \\<beta> p", "by auto"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (m # p) = eval_poly \\<beta> (m # p)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare poly_subst.simps[simp del]"], ["", "subsection \\<open>\n  Polynomial orders\n\\<close>"], ["", "definition pos_assign :: \"('v,'a :: ordered_semiring_0)assign \\<Rightarrow> bool\"\nwhere \"pos_assign \\<alpha> = (\\<forall> x. \\<alpha> x \\<ge> 0)\""], ["", "definition poly_ge :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \"\\<ge>p\" 51)\nwhere \"p \\<ge>p q = (\\<forall> \\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<alpha> q)\""], ["", "lemma poly_ge_refl[simp]: \"p \\<ge>p p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p p", "unfolding poly_ge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly \\<alpha> p \\<le> eval_poly \\<alpha> p", "using ge_refl"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly \\<alpha> p \\<le> eval_poly \\<alpha> p", "by auto"], ["", "lemma poly_ge_trans[trans]: \"\\<lbrakk>p1 \\<ge>p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 \\<ge>p p3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 \\<ge>p p2; p2 \\<ge>p p3\\<rbrakk>\n    \\<Longrightarrow> p1 \\<ge>p p3", "unfolding poly_ge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>.\n                pos_assign \\<alpha> \\<longrightarrow>\n                eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1;\n     \\<forall>\\<alpha>.\n        pos_assign \\<alpha> \\<longrightarrow>\n        eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<alpha>.\n                         pos_assign \\<alpha> \\<longrightarrow>\n                         eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p1", "using ge_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<le> ?x; ?z \\<le> ?y\\<rbrakk> \\<Longrightarrow> ?z \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>.\n                pos_assign \\<alpha> \\<longrightarrow>\n                eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1;\n     \\<forall>\\<alpha>.\n        pos_assign \\<alpha> \\<longrightarrow>\n        eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<alpha>.\n                         pos_assign \\<alpha> \\<longrightarrow>\n                         eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p1", "by blast"], ["", "lemma pos_assign_monom_list: fixes \\<alpha> :: \"('v :: linorder, 'a :: poly_carrier)assign\"\n  assumes pos: \"pos_assign \\<alpha>\"\n  shows \"eval_monom_list \\<alpha> m \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> m", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> []\n 2. \\<And>a m.\n       (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow>\n       (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> []\n 2. \\<And>a m.\n       (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow>\n       (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> []", "by (simp add: one_ge_zero)"], ["proof (state)\nthis:\n  (0::'a) \\<le> eval_monom_list \\<alpha> []\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow>\n       (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m.\n       (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow>\n       (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)", "case (Cons xp m)"], ["proof (state)\nthis:\n  (0::'a) \\<le> eval_monom_list \\<alpha> m\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       (0::'a) \\<le> eval_monom_list \\<alpha> m \\<Longrightarrow>\n       (0::'a) \\<le> eval_monom_list \\<alpha> (a # m)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)", "proof (cases xp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       xp = (a, b) \\<Longrightarrow>\n       (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)", "case (Pair x p)"], ["proof (state)\nthis:\n  xp = (x, p)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       xp = (a, b) \\<Longrightarrow>\n       (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)", "from pos[unfolded pos_assign_def]"], ["proof (chain)\npicking this:\n  \\<forall>x. (0::'a) \\<le> \\<alpha> x", "have ge: \"\\<alpha> x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<forall>x. (0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x", "by simp"], ["proof (state)\nthis:\n  (0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       xp = (a, b) \\<Longrightarrow>\n       (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)", "have ge: \"\\<alpha> x ^ p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x ^ p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> \\<alpha> x ^ 0\n 2. \\<And>p.\n       (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow>\n       (0::'a) \\<le> \\<alpha> x ^ Suc p", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> \\<alpha> x ^ 0\n 2. \\<And>p.\n       (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow>\n       (0::'a) \\<le> \\<alpha> x ^ Suc p", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x ^ 0", "by (simp add: one_ge_zero)"], ["proof (state)\nthis:\n  (0::'a) \\<le> \\<alpha> x ^ 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow>\n       (0::'a) \\<le> \\<alpha> x ^ Suc p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow>\n       (0::'a) \\<le> \\<alpha> x ^ Suc p", "case (Suc p)"], ["proof (state)\nthis:\n  (0::'a) \\<le> \\<alpha> x ^ p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (0::'a) \\<le> \\<alpha> x ^ p \\<Longrightarrow>\n       (0::'a) \\<le> \\<alpha> x ^ Suc p", "from ge_trans[OF times_left_mono[OF ge Suc] times_right_mono[OF ge_refl ge]]"], ["proof (chain)\npicking this:\n  (0::'a) * (0::'a) \\<le> \\<alpha> x ^ p * \\<alpha> x", "show ?case"], ["proof (prove)\nusing this:\n  (0::'a) * (0::'a) \\<le> \\<alpha> x ^ p * \\<alpha> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x ^ Suc p", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (0::'a) \\<le> \\<alpha> x ^ Suc p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0::'a) \\<le> \\<alpha> x ^ p\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       xp = (a, b) \\<Longrightarrow>\n       (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)", "from ge_trans[OF times_right_mono[OF Cons ge] times_left_mono[OF ge_refl Cons]]"], ["proof (chain)\npicking this:\n  (0::'a) * (0::'a) \\<le> eval_monom_list \\<alpha> m * \\<alpha> x ^ p", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) * (0::'a) \\<le> eval_monom_list \\<alpha> m * \\<alpha> x ^ p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)", "by (simp add: Pair)"], ["proof (state)\nthis:\n  (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0::'a) \\<le> eval_monom_list \\<alpha> (xp # m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pos_assign_monom: fixes \\<alpha> :: \"('v :: linorder, 'a :: poly_carrier)assign\"\n  assumes pos: \"pos_assign \\<alpha>\"\n  shows \"eval_monom \\<alpha> m \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom \\<alpha> m", "by (transfer fixing: \\<alpha>, rule pos_assign_monom_list[OF pos])"], ["", "lemma pos_assign_poly:   assumes pos: \"pos_assign \\<alpha>\"\n  and p: \"p \\<ge>p zero_poly\"\n  shows \"eval_poly \\<alpha> p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> p", "from p[unfolded poly_ge_def zero_poly_def] pos"], ["proof (chain)\npicking this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> p\n  pos_assign \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> p\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> p", "by auto"], ["proof (state)\nthis:\n  (0::'b) \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_add_ge_mono: assumes \"p1 \\<ge>p p2\" shows \"poly_add p1 q \\<ge>p poly_add p2 q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_add p1 q \\<ge>p poly_add p2 q", "using assms"], ["proof (prove)\nusing this:\n  p1 \\<ge>p p2\n\ngoal (1 subgoal):\n 1. poly_add p1 q \\<ge>p poly_add p2 q", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly \\<alpha> (poly_add p2 q)\n       \\<le> eval_poly \\<alpha> (poly_add p1 q)", "by (auto simp: field_simps plus_left_mono)"], ["", "lemma poly_mult_ge_mono: assumes \"p1 \\<ge>p p2\" and \"q \\<ge>p zero_poly\"\n  shows \"poly_mult p1 q \\<ge>p poly_mult p2 q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p1 q \\<ge>p poly_mult p2 q", "using assms"], ["proof (prove)\nusing this:\n  p1 \\<ge>p p2\n  q \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. poly_mult p1 q \\<ge>p poly_mult p2 q", "unfolding poly_ge_def zero_poly_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly \\<alpha> (poly_mult p2 q)\n       \\<le> eval_poly \\<alpha> (poly_mult p1 q)", "by (auto simp: times_left_mono)"], ["", "context poly_order_carrier\nbegin"], ["", "definition poly_gt :: \"('v :: linorder,'a)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" (infix \">p\" 51)\nwhere \"p >p q = (\\<forall> \\<alpha>. pos_assign \\<alpha> \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q)\""], ["", "lemma poly_gt_imp_poly_ge: \"p >p q \\<Longrightarrow> p \\<ge>p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p >p q \\<Longrightarrow> p \\<ge>p q", "unfolding poly_ge_def poly_gt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q \\<Longrightarrow>\n    \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p", "using gt_imp_ge"], ["proof (prove)\nusing this:\n  ?x \\<succ> ?y \\<Longrightarrow> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q \\<Longrightarrow>\n    \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p", "by blast"], ["", "abbreviation poly_GT :: \"('v :: linorder,'a)poly rel\"\nwhere \"poly_GT \\<equiv> {(p,q) | p q. p >p q \\<and> q \\<ge>p zero_poly}\""], ["", "lemma poly_compat: \"\\<lbrakk>p1 \\<ge>p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 \\<ge>p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3", "unfolding poly_ge_def poly_gt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>.\n                pos_assign \\<alpha> \\<longrightarrow>\n                eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1;\n     \\<forall>\\<alpha>.\n        pos_assign \\<alpha> \\<longrightarrow>\n        eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<alpha>.\n                         pos_assign \\<alpha> \\<longrightarrow>\n                         eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3", "using compat"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<le> ?x; ?y \\<succ> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<succ> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>.\n                pos_assign \\<alpha> \\<longrightarrow>\n                eval_poly \\<alpha> p2 \\<le> eval_poly \\<alpha> p1;\n     \\<forall>\\<alpha>.\n        pos_assign \\<alpha> \\<longrightarrow>\n        eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<alpha>.\n                         pos_assign \\<alpha> \\<longrightarrow>\n                         eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3", "by blast"], ["", "lemma poly_compat2: \"\\<lbrakk>p1 >p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 >p p2; p2 \\<ge>p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3", "unfolding poly_ge_def poly_gt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>.\n                pos_assign \\<alpha> \\<longrightarrow>\n                eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2;\n     \\<forall>\\<alpha>.\n        pos_assign \\<alpha> \\<longrightarrow>\n        eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<alpha>.\n                         pos_assign \\<alpha> \\<longrightarrow>\n                         eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3", "using compat2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<succ> ?y; ?z \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<succ> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>.\n                pos_assign \\<alpha> \\<longrightarrow>\n                eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2;\n     \\<forall>\\<alpha>.\n        pos_assign \\<alpha> \\<longrightarrow>\n        eval_poly \\<alpha> p3 \\<le> eval_poly \\<alpha> p2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<alpha>.\n                         pos_assign \\<alpha> \\<longrightarrow>\n                         eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3", "by blast"], ["", "lemma poly_gt_trans[trans]: \"\\<lbrakk>p1 >p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p1 >p p2; p2 >p p3\\<rbrakk> \\<Longrightarrow> p1 >p p3", "unfolding poly_gt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>.\n                pos_assign \\<alpha> \\<longrightarrow>\n                eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2;\n     \\<forall>\\<alpha>.\n        pos_assign \\<alpha> \\<longrightarrow>\n        eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<alpha>.\n                         pos_assign \\<alpha> \\<longrightarrow>\n                         eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3", "using gt_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<succ> ?y; ?y \\<succ> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<succ> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<alpha>.\n                pos_assign \\<alpha> \\<longrightarrow>\n                eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2;\n     \\<forall>\\<alpha>.\n        pos_assign \\<alpha> \\<longrightarrow>\n        eval_poly \\<alpha> p2 \\<succ> eval_poly \\<alpha> p3\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<alpha>.\n                         pos_assign \\<alpha> \\<longrightarrow>\n                         eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p3", "by blast"], ["", "lemma poly_GT_SN: \"SN poly_GT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN poly_GT", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f 0 \\<in> UNIV;\n        \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk>\n       \\<Longrightarrow> False", "fix f :: \"nat \\<Rightarrow> ('c :: linorder,'a)poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f 0 \\<in> UNIV;\n        \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk>\n       \\<Longrightarrow> False", "assume f: \"\\<forall> i. (f i, f (Suc i)) \\<in> poly_GT\""], ["proof (state)\nthis:\n  \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f 0 \\<in> UNIV;\n        \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk>\n       \\<Longrightarrow> False", "have pos: \"pos_assign ((\\<lambda> x. 0) :: ('v,'a)assign)\" (is \"pos_assign ?ass\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>x. 0::'a)", "unfolding pos_assign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> (0::'a)", "using ge_refl"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> (0::'a)", "by auto"], ["proof (state)\nthis:\n  pos_assign (\\<lambda>x. 0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f 0 \\<in> UNIV;\n        \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk>\n       \\<Longrightarrow> False", "obtain g where g: \"\\<And> i. g i = eval_poly ?ass (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        (\\<And>i.\n            g i = eval_poly (\\<lambda>x. 0::'a) (f i)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g ?i3 = eval_poly (\\<lambda>x. 0::'a) (f ?i3)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f 0 \\<in> UNIV;\n        \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk>\n       \\<Longrightarrow> False", "from f pos"], ["proof (chain)\npicking this:\n  \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\n  pos_assign (\\<lambda>x. 0::'a)", "have \"\\<forall> i. g (Suc i) \\<ge> 0 \\<and> g i \\<succ> g (Suc i)\""], ["proof (prove)\nusing this:\n  \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\n  pos_assign (\\<lambda>x. 0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)", "unfolding poly_gt_def g"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (f i, f (Suc i))\n     \\<in> {(p, q) |p q.\n            (\\<forall>\\<alpha>.\n                pos_assign \\<alpha> \\<longrightarrow>\n                eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q) \\<and>\n            q \\<ge>p zero_poly}\n  pos_assign (\\<lambda>x. 0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (0::'a) \\<le> eval_poly (\\<lambda>x. 0::'a) (f (Suc i)) \\<and>\n       eval_poly (\\<lambda>x. 0::'a) (f i) \\<succ>\n       eval_poly (\\<lambda>x. 0::'a) (f (Suc i))", "using pos_assign_poly"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (f i, f (Suc i))\n     \\<in> {(p, q) |p q.\n            (\\<forall>\\<alpha>.\n                pos_assign \\<alpha> \\<longrightarrow>\n                eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q) \\<and>\n            q \\<ge>p zero_poly}\n  pos_assign (\\<lambda>x. 0::'a)\n  \\<lbrakk>pos_assign ?\\<alpha>; ?p \\<ge>p zero_poly\\<rbrakk>\n  \\<Longrightarrow> (0::?'b) \\<le> eval_poly ?\\<alpha> ?p\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (0::'a) \\<le> eval_poly (\\<lambda>x. 0::'a) (f (Suc i)) \\<and>\n       eval_poly (\\<lambda>x. 0::'a) (f i) \\<succ>\n       eval_poly (\\<lambda>x. 0::'a) (f (Suc i))", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f 0 \\<in> UNIV;\n        \\<forall>i. (f i, f (Suc i)) \\<in> poly_GT\\<rbrakk>\n       \\<Longrightarrow> False", "with SN"], ["proof (chain)\npicking this:\n  SN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}\n  \\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)", "show False"], ["proof (prove)\nusing this:\n  SN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}\n  \\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)\n\ngoal (1 subgoal):\n 1. False", "unfolding SN_defs"], ["proof (prove)\nusing this:\n  \\<nexists>f.\n     f 0 \\<in> UNIV \\<and>\n     (\\<forall>i.\n         (f i, f (Suc i))\n         \\<in> {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y})\n  \\<forall>i. (0::'a) \\<le> g (Suc i) \\<and> g i \\<succ> g (Suc i)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>monotonicity of polynomials\\<close>"], ["", "lemma eval_monom_list_mono: assumes fg: \"\\<And> x. (f :: ('v :: linorder,'a :: poly_carrier)assign) x \\<ge> g x\" \n  and g: \"\\<And> x. g x \\<ge> 0\"\n  shows \"eval_monom_list f m \\<ge> eval_monom_list g m\" \"eval_monom_list g m \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g m \\<le> eval_monom_list f m &&&\n    (0::'a) \\<le> eval_monom_list g m", "proof (atomize(full), induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and>\n    (0::'a) \\<le> eval_monom_list g []\n 2. \\<And>a m.\n       eval_monom_list g m \\<le> eval_monom_list f m \\<and>\n       (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow>\n       eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and>\n       (0::'a) \\<le> eval_monom_list g (a # m)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and>\n    (0::'a) \\<le> eval_monom_list g []\n 2. \\<And>a m.\n       eval_monom_list g m \\<le> eval_monom_list f m \\<and>\n       (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow>\n       eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and>\n       (0::'a) \\<le> eval_monom_list g (a # m)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and>\n    (0::'a) \\<le> eval_monom_list g []", "using one_ge_zero"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> (1::?'a)\n\ngoal (1 subgoal):\n 1. eval_monom_list g [] \\<le> eval_monom_list f [] \\<and>\n    (0::'a) \\<le> eval_monom_list g []", "by (auto simp: ge_refl)"], ["proof (state)\nthis:\n  eval_monom_list g [] \\<le> eval_monom_list f [] \\<and>\n  (0::'a) \\<le> eval_monom_list g []\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       eval_monom_list g m \\<le> eval_monom_list f m \\<and>\n       (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow>\n       eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and>\n       (0::'a) \\<le> eval_monom_list g (a # m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m.\n       eval_monom_list g m \\<le> eval_monom_list f m \\<and>\n       (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow>\n       eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and>\n       (0::'a) \\<le> eval_monom_list g (a # m)", "case (Cons xd m)"], ["proof (state)\nthis:\n  eval_monom_list g m \\<le> eval_monom_list f m \\<and>\n  (0::'a) \\<le> eval_monom_list g m\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       eval_monom_list g m \\<le> eval_monom_list f m \\<and>\n       (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow>\n       eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and>\n       (0::'a) \\<le> eval_monom_list g (a # m)", "hence IH1: \" eval_monom_list f m \\<ge> eval_monom_list g m\" and IH2: \"eval_monom_list g m \\<ge> 0\""], ["proof (prove)\nusing this:\n  eval_monom_list g m \\<le> eval_monom_list f m \\<and>\n  (0::'a) \\<le> eval_monom_list g m\n\ngoal (1 subgoal):\n 1. eval_monom_list g m \\<le> eval_monom_list f m &&&\n    (0::'a) \\<le> eval_monom_list g m", "by auto"], ["proof (state)\nthis:\n  eval_monom_list g m \\<le> eval_monom_list f m\n  (0::'a) \\<le> eval_monom_list g m\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       eval_monom_list g m \\<le> eval_monom_list f m \\<and>\n       (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow>\n       eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and>\n       (0::'a) \\<le> eval_monom_list g (a # m)", "obtain x d where xd: \"xd = (x,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x d. xd = (x, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  xd = (x, d)\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       eval_monom_list g m \\<le> eval_monom_list f m \\<and>\n       (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow>\n       eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and>\n       (0::'a) \\<le> eval_monom_list g (a # m)", "from pow_mono[OF fg g, of x d]"], ["proof (chain)\npicking this:\n  g x ^ d \\<le> f x ^ d \\<and> (0::'a) \\<le> g x ^ d", "have fgd: \"f x ^ d \\<ge> g x ^ d\" and gd: \"g x ^ d \\<ge> 0\""], ["proof (prove)\nusing this:\n  g x ^ d \\<le> f x ^ d \\<and> (0::'a) \\<le> g x ^ d\n\ngoal (1 subgoal):\n 1. g x ^ d \\<le> f x ^ d &&& (0::'a) \\<le> g x ^ d", "by auto"], ["proof (state)\nthis:\n  g x ^ d \\<le> f x ^ d\n  (0::'a) \\<le> g x ^ d\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       eval_monom_list g m \\<le> eval_monom_list f m \\<and>\n       (0::'a) \\<le> eval_monom_list g m \\<Longrightarrow>\n       eval_monom_list g (a # m) \\<le> eval_monom_list f (a # m) \\<and>\n       (0::'a) \\<le> eval_monom_list g (a # m)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g (xd # m) \\<le> eval_monom_list f (xd # m) \\<and>\n    (0::'a) \\<le> eval_monom_list g (xd # m)", "unfolding xd eval_monom_list.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list g m * g x ^ d \\<le> eval_monom_list f m * f x ^ d \\<and>\n    (0::'a) \\<le> eval_monom_list g m * g x ^ d", "proof (rule conjI, rule ge_trans[OF times_left_mono[OF pow_ge_zero IH1] times_right_mono[OF IH2 fgd]])"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> f x\n 2. (0::'a) \\<le> eval_monom_list g m * g x ^ d", "show \"f x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> f x", "by (rule ge_trans[OF fg g])"], ["proof (state)\nthis:\n  (0::'a) \\<le> f x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list g m * g x ^ d", "show \"eval_monom_list g m * g x ^ d \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom_list g m * g x ^ d", "by (rule mult_ge_zero[OF IH2 gd])"], ["proof (state)\nthis:\n  (0::'a) \\<le> eval_monom_list g m * g x ^ d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_monom_list g (xd # m) \\<le> eval_monom_list f (xd # m) \\<and>\n  (0::'a) \\<le> eval_monom_list g (xd # m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_monom_mono: assumes fg: \"\\<And> x. (f :: ('v :: linorder,'a :: poly_carrier)assign) x \\<ge> g x\" \n  and g: \"\\<And> x. g x \\<ge> 0\"\nshows \"eval_monom f m \\<ge> eval_monom g m\" \"eval_monom g m \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m \\<le> eval_monom f m &&& (0::'a) \\<le> eval_monom g m", "by (atomize(full), transfer fixing: f g, insert eval_monom_list_mono[of g f, OF fg g], auto)"], ["", "definition poly_weak_mono_all :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> bool\" where \n  \"poly_weak_mono_all p \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. \\<alpha> x \\<ge> \\<beta> x) \n    \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\""], ["", "lemma poly_weak_mono_all_E: assumes p: \"poly_weak_mono_all p\" and \n  ge: \"\\<And> x. f x \\<ge>p g x \\<and> g x \\<ge>p zero_poly\"\n  shows \"poly_subst f p \\<ge>p poly_subst g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p \\<ge>p poly_subst g p", "unfolding poly_ge_def poly_subst"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p\n       \\<le> eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p", "proof (intro allI impI, rule p[unfolded poly_weak_mono_all_def, rule_format])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "fix \\<alpha> :: \"('c,'b)assign\" and x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) \\<ge> eval_poly \\<alpha> (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)", "using ge[of x]"], ["proof (prove)\nusing this:\n  f x \\<ge>p g x \\<and> g x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  (\\<forall>\\<alpha>.\n      pos_assign \\<alpha> \\<longrightarrow>\n      eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)) \\<and>\n  (\\<forall>\\<alpha>.\n      pos_assign \\<alpha> \\<longrightarrow>\n      eval_poly \\<alpha> zero_poly \\<le> eval_poly \\<alpha> (g x))\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)", "by auto"], ["proof (state)\nthis:\n  pos_assign \\<alpha> \\<Longrightarrow>\n  eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "fix \\<alpha> :: \"('c,'b)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "assume alpha: \"pos_assign \\<alpha>\""], ["proof (state)\nthis:\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "unfolding pos_assign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "show \"eval_poly \\<alpha> (g x) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "using ge[of x]"], ["proof (prove)\nusing this:\n  f x \\<ge>p g x \\<and> g x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "unfolding poly_ge_def zero_poly_def"], ["proof (prove)\nusing this:\n  (\\<forall>\\<alpha>.\n      pos_assign \\<alpha> \\<longrightarrow>\n      eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)) \\<and>\n  (\\<forall>\\<alpha>.\n      pos_assign \\<alpha> \\<longrightarrow>\n      eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x))\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "using alpha"], ["proof (prove)\nusing this:\n  (\\<forall>\\<alpha>.\n      pos_assign \\<alpha> \\<longrightarrow>\n      eval_poly \\<alpha> (g x) \\<le> eval_poly \\<alpha> (f x)) \\<and>\n  (\\<forall>\\<alpha>.\n      pos_assign \\<alpha> \\<longrightarrow>\n      eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x))\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "by auto"], ["proof (state)\nthis:\n  (0::'b) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition poly_weak_mono :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_weak_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<ge> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\""], ["", "lemma poly_weak_mono_E: assumes p: \"poly_weak_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v \\<ge>p g v\"\n  shows \"poly_subst f p \\<ge>p poly_subst g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p \\<ge>p poly_subst g p", "unfolding poly_ge_def poly_subst"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p\n       \\<le> eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p", "proof (intro allI impI, rule p[unfolded poly_weak_mono_def, rule_format])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)", "fix \\<alpha> :: \"('c,'b)assign\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)", "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<ge> eval_poly \\<alpha> (g v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)", "using fgv"], ["proof (prove)\nusing this:\n  f v \\<ge>p g v\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)", "by auto"], ["proof (state)\nthis:\n  pos_assign \\<alpha> \\<Longrightarrow>\n  eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "fix \\<alpha> :: \"('c,'b)assign\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "assume alpha: \"pos_assign \\<alpha>\""], ["proof (state)\nthis:\n  pos_assign \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "unfolding pos_assign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "show \"eval_poly \\<alpha> (g x) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "using g[of x]"], ["proof (prove)\nusing this:\n  g x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "unfolding poly_ge_def zero_poly_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "using alpha"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "by auto"], ["proof (state)\nthis:\n  (0::'b) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "fix \\<alpha> :: \"('c,'b)assign\" and x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "assume v: \"v \\<noteq> x\""], ["proof (state)\nthis:\n  v \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "using fgw[OF v]"], ["proof (prove)\nusing this:\n  f x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  f x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "by auto"], ["proof (state)\nthis:\n  pos_assign \\<alpha> \\<Longrightarrow>\n  eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition poly_weak_anti_mono :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_weak_anti_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<ge> \\<beta> v \\<longrightarrow> eval_poly \\<beta> p \\<ge> eval_poly \\<alpha> p\""], ["", "lemma poly_weak_anti_mono_E: assumes p: \"poly_weak_anti_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v \\<ge>p g v\"\n  shows \"poly_subst g p \\<ge>p poly_subst f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst g p \\<ge>p poly_subst f p", "unfolding poly_ge_def poly_subst"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p\n       \\<le> eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p", "proof (intro allI impI, rule p[unfolded poly_weak_anti_mono_def, rule_format])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)", "fix \\<alpha> :: \"('c,'b)assign\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)", "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<ge> eval_poly \\<alpha> (g v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)", "using fgv"], ["proof (prove)\nusing this:\n  f v \\<ge>p g v\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)", "by auto"], ["proof (state)\nthis:\n  pos_assign \\<alpha> \\<Longrightarrow>\n  eval_poly \\<alpha> (g v) \\<le> eval_poly \\<alpha> (f v)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "fix \\<alpha> :: \"('c,'b)assign\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "assume alpha: \"pos_assign \\<alpha>\""], ["proof (state)\nthis:\n  pos_assign \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "unfolding pos_assign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "show \"eval_poly \\<alpha> (g x) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "using g[of x]"], ["proof (prove)\nusing this:\n  g x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "unfolding poly_ge_def zero_poly_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "using alpha"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'b) \\<le> eval_poly \\<alpha> (g x)", "by auto"], ["proof (state)\nthis:\n  (0::'b) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "fix \\<alpha> :: \"('c,'b)assign\" and x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "assume v: \"v \\<noteq> x\""], ["proof (state)\nthis:\n  v \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "using fgw[OF v]"], ["proof (prove)\nusing this:\n  f x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  f x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "by auto"], ["proof (state)\nthis:\n  pos_assign \\<alpha> \\<Longrightarrow>\n  eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_weak_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes mono: \"\\<And> v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v\"\n  shows \"poly_weak_mono_all p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p", "unfolding poly_weak_mono_all_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>.\n       (\\<forall>x. \\<beta> x \\<le> \\<alpha> x) \\<longrightarrow>\n       pos_assign \\<beta> \\<longrightarrow>\n       eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "fix \\<alpha> \\<beta> :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "assume all: \"\\<forall> x. \\<alpha> x \\<ge> \\<beta> x\""], ["proof (state)\nthis:\n  \\<forall>x. \\<beta> x \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "assume pos: \"pos_assign \\<beta>\""], ["proof (state)\nthis:\n  pos_assign \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "let ?ab = \"\\<lambda> vs v. if (v \\<in> set vs) then \\<alpha> v else \\<beta> v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "fix vs :: \"'v list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "assume \"set vs \\<subseteq> poly_vars p\""], ["proof (state)\nthis:\n  set vs \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "hence \"eval_poly (?ab vs) p \\<ge> eval_poly \\<beta> p\""], ["proof (prove)\nusing this:\n  set vs \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p\n    \\<le> eval_poly\n           (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p", "proof (induct vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> poly_vars p \\<Longrightarrow>\n    eval_poly \\<beta> p\n    \\<le> eval_poly\n           (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p\n 2. \\<And>a vs.\n       \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow>\n                eval_poly \\<beta> p\n                \\<le> eval_poly\n                       (\\<lambda>v.\n                           if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n                       p;\n        set (a # vs) \\<subseteq> poly_vars p\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p\n                         \\<le> eval_poly\n                                (\\<lambda>v.\n                                    if v \\<in> set (a # vs) then \\<alpha> v\n                                    else \\<beta> v)\n                                p", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> poly_vars p\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> poly_vars p \\<Longrightarrow>\n    eval_poly \\<beta> p\n    \\<le> eval_poly\n           (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p\n 2. \\<And>a vs.\n       \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow>\n                eval_poly \\<beta> p\n                \\<le> eval_poly\n                       (\\<lambda>v.\n                           if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n                       p;\n        set (a # vs) \\<subseteq> poly_vars p\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p\n                         \\<le> eval_poly\n                                (\\<lambda>v.\n                                    if v \\<in> set (a # vs) then \\<alpha> v\n                                    else \\<beta> v)\n                                p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p\n    \\<le> eval_poly\n           (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p", "by (simp add: ge_refl)"], ["proof (state)\nthis:\n  eval_poly \\<beta> p\n  \\<le> eval_poly\n         (\\<lambda>v. if v \\<in> set [] then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow>\n                eval_poly \\<beta> p\n                \\<le> eval_poly\n                       (\\<lambda>v.\n                           if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n                       p;\n        set (a # vs) \\<subseteq> poly_vars p\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p\n                         \\<le> eval_poly\n                                (\\<lambda>v.\n                                    if v \\<in> set (a # vs) then \\<alpha> v\n                                    else \\<beta> v)\n                                p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow>\n                eval_poly \\<beta> p\n                \\<le> eval_poly\n                       (\\<lambda>v.\n                           if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n                       p;\n        set (a # vs) \\<subseteq> poly_vars p\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p\n                         \\<le> eval_poly\n                                (\\<lambda>v.\n                                    if v \\<in> set (a # vs) then \\<alpha> v\n                                    else \\<beta> v)\n                                p", "case (Cons v vs)"], ["proof (state)\nthis:\n  set vs \\<subseteq> poly_vars p \\<Longrightarrow>\n  eval_poly \\<beta> p\n  \\<le> eval_poly\n         (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p\n  set (v # vs) \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow>\n                eval_poly \\<beta> p\n                \\<le> eval_poly\n                       (\\<lambda>v.\n                           if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n                       p;\n        set (a # vs) \\<subseteq> poly_vars p\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p\n                         \\<le> eval_poly\n                                (\\<lambda>v.\n                                    if v \\<in> set (a # vs) then \\<alpha> v\n                                    else \\<beta> v)\n                                p", "hence subset: \"set vs \\<subseteq> poly_vars p\"  and v: \"v \\<in> poly_vars p\""], ["proof (prove)\nusing this:\n  set vs \\<subseteq> poly_vars p \\<Longrightarrow>\n  eval_poly \\<beta> p\n  \\<le> eval_poly\n         (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p\n  set (v # vs) \\<subseteq> poly_vars p\n\ngoal (1 subgoal):\n 1. set vs \\<subseteq> poly_vars p &&& v \\<in> poly_vars p", "by auto"], ["proof (state)\nthis:\n  set vs \\<subseteq> poly_vars p\n  v \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>set vs \\<subseteq> poly_vars p \\<Longrightarrow>\n                eval_poly \\<beta> p\n                \\<le> eval_poly\n                       (\\<lambda>v.\n                           if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n                       p;\n        set (a # vs) \\<subseteq> poly_vars p\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p\n                         \\<le> eval_poly\n                                (\\<lambda>v.\n                                    if v \\<in> set (a # vs) then \\<alpha> v\n                                    else \\<beta> v)\n                                p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p\n    \\<le> eval_poly\n           (\\<lambda>va.\n               if va \\<in> set (v # vs) then \\<alpha> va else \\<beta> va)\n           p", "proof (rule ge_trans[OF mono[OF v, unfolded poly_weak_mono_def, rule_format] Cons(1)[OF subset]])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       v \\<noteq> x \\<Longrightarrow>\n       (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) =\n       (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n 2. pos_assign\n     (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n 3. (if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n    \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)", "show \"pos_assign (?ab vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign\n     (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v)", "unfolding pos_assign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)", "from pos[unfolded pos_assign_def]"], ["proof (chain)\npicking this:\n  \\<forall>x. (0::'a) \\<le> \\<beta> x", "have beta: \"\\<beta> x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<forall>x. (0::'a) \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<beta> x", "by simp"], ["proof (state)\nthis:\n  (0::'a) \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)", "from ge_trans[OF all[rule_format] this]"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> \\<alpha> x", "have alpha: \"\\<alpha> x \\<ge> 0\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<alpha> x", "."], ["proof (state)\nthis:\n  (0::'a) \\<le> \\<alpha> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)", "from alpha beta"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> \\<alpha> x\n  (0::'a) \\<le> \\<beta> x", "show \"?ab vs x \\<ge> 0\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> \\<alpha> x\n  (0::'a) \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pos_assign (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       v \\<noteq> x \\<Longrightarrow>\n       (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) =\n       (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n 2. (if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n    \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)", "show \"(?ab (v # vs) v) \\<ge> (?ab vs v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n    \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)", "using all ge_refl"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<beta> x \\<le> \\<alpha> x\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. (if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n    \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)", "by auto"], ["proof (state)\nthis:\n  (if v \\<in> set vs then \\<alpha> v else \\<beta> v)\n  \\<le> (if v \\<in> set (v # vs) then \\<alpha> v else \\<beta> v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       v \\<noteq> x \\<Longrightarrow>\n       (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) =\n       (if x \\<in> set vs then \\<alpha> x else \\<beta> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       v \\<noteq> x \\<Longrightarrow>\n       (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) =\n       (if x \\<in> set vs then \\<alpha> x else \\<beta> x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       v \\<noteq> x \\<Longrightarrow>\n       (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) =\n       (if x \\<in> set vs then \\<alpha> x else \\<beta> x)", "assume \"v \\<noteq> x\""], ["proof (state)\nthis:\n  v \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       v \\<noteq> x \\<Longrightarrow>\n       (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) =\n       (if x \\<in> set vs then \\<alpha> x else \\<beta> x)", "thus \"(?ab (v # vs) x) = (?ab vs x)\""], ["proof (prove)\nusing this:\n  v \\<noteq> x\n\ngoal (1 subgoal):\n 1. (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) =\n    (if x \\<in> set vs then \\<alpha> x else \\<beta> x)", "by simp"], ["proof (state)\nthis:\n  (if x \\<in> set (v # vs) then \\<alpha> x else \\<beta> x) =\n  (if x \\<in> set vs then \\<alpha> x else \\<beta> x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly \\<beta> p\n  \\<le> eval_poly\n         (\\<lambda>va.\n             if va \\<in> set (v # vs) then \\<alpha> va else \\<beta> va)\n         p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly \\<beta> p\n  \\<le> eval_poly\n         (\\<lambda>v. if v \\<in> set vs then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "}"], ["proof (state)\nthis:\n  set ?vs2 \\<subseteq> poly_vars p \\<Longrightarrow>\n  eval_poly \\<beta> p\n  \\<le> eval_poly\n         (\\<lambda>v. if v \\<in> set ?vs2 then \\<alpha> v else \\<beta> v) p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "from this[of \"poly_vars_list p\", unfolded poly_vars_list]"], ["proof (chain)\npicking this:\n  poly_vars p \\<subseteq> poly_vars p \\<Longrightarrow>\n  eval_poly \\<beta> p\n  \\<le> eval_poly\n         (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v)\n         p", "have \"eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p \\<ge> eval_poly \\<beta> p\""], ["proof (prove)\nusing this:\n  poly_vars p \\<subseteq> poly_vars p \\<Longrightarrow>\n  eval_poly \\<beta> p\n  \\<le> eval_poly\n         (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v)\n         p\n\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p\n    \\<le> eval_poly\n           (\\<lambda>v.\n               if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v)\n           p", "by auto"], ["proof (state)\nthis:\n  eval_poly \\<beta> p\n  \\<le> eval_poly\n         (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v)\n         p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "also"], ["proof (state)\nthis:\n  eval_poly \\<beta> p\n  \\<le> eval_poly\n         (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v)\n         p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "have \"eval_poly (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p = eval_poly \\<alpha> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly\n     (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p =\n    eval_poly \\<alpha> p", "by (rule eval_poly_vars, auto)"], ["proof (state)\nthis:\n  eval_poly\n   (\\<lambda>v. if v \\<in> poly_vars p then \\<alpha> v else \\<beta> v) p =\n  eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "finally"], ["proof (chain)\npicking this:\n  eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "show \"eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\""], ["proof (prove)\nusing this:\n  eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "."], ["proof (state)\nthis:\n  eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_weak_mono_all: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\" \n  assumes p: \"poly_weak_mono_all p\"\n  shows \"poly_weak_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v", "unfolding poly_weak_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>.\n       (\\<forall>x.\n           v \\<noteq> x \\<longrightarrow>\n           \\<alpha> x = \\<beta> x) \\<longrightarrow>\n       pos_assign \\<beta> \\<longrightarrow>\n       \\<beta> v \\<le> \\<alpha> v \\<longrightarrow>\n       eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "fix \\<alpha> \\<beta> :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "assume all: \"\\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x\""], ["proof (state)\nthis:\n  \\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "assume pos: \"pos_assign \\<beta>\""], ["proof (state)\nthis:\n  pos_assign \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "assume v: \"\\<alpha> v \\<ge> \\<beta> v\""], ["proof (state)\nthis:\n  \\<beta> v \\<le> \\<alpha> v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "show \"eval_poly \\<alpha> p \\<ge> eval_poly \\<beta> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "proof (rule p[unfolded poly_weak_mono_all_def, rule_format, OF _ pos])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<beta> x \\<le> \\<alpha> x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<beta> x \\<le> \\<alpha> x", "show \"\\<alpha> x \\<ge> \\<beta> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> x \\<le> \\<alpha> x", "using v all ge_refl[of \"\\<beta> x\"]"], ["proof (prove)\nusing this:\n  \\<beta> v \\<le> \\<alpha> v\n  \\<forall>x. v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x\n  \\<beta> x \\<le> \\<beta> x\n\ngoal (1 subgoal):\n 1. \\<beta> x \\<le> \\<alpha> x", "by auto"], ["proof (state)\nthis:\n  \\<beta> x \\<le> \\<alpha> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_weak_mono_all_pos: \n  fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes pos_at_zero: \"eval_poly (\\<lambda> w. 0) p \\<ge> 0\"\n  and mono: \"poly_weak_mono_all p\"\n  shows \"p \\<ge>p zero_poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p zero_poly", "unfolding poly_ge_def zero_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> p", "proof (intro allI impI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       (0::'a) \\<le> eval_poly \\<alpha> p", "fix  \\<alpha> :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       (0::'a) \\<le> eval_poly \\<alpha> p", "assume pos: \"pos_assign \\<alpha>\""], ["proof (state)\nthis:\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       (0::'a) \\<le> eval_poly \\<alpha> p", "show \"eval_poly \\<alpha> p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p", "let ?id = \"\\<lambda> w. poly_of (PVar w)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p", "let ?z = \"\\<lambda> w. zero_poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p", "have \"poly_subst ?id p \\<ge>p poly_subst ?z p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>w. poly_of (PVar w)) p \\<ge>p\n    poly_subst (\\<lambda>w. zero_poly) p", "by (rule poly_weak_mono_all_E[OF mono],  \n        simp, simp add: poly_ge_def zero_poly_def pos_assign_def)"], ["proof (state)\nthis:\n  poly_subst (\\<lambda>w. poly_of (PVar w)) p \\<ge>p\n  poly_subst (\\<lambda>w. zero_poly) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p", "hence \"eval_poly \\<alpha> (poly_subst ?id p) \\<ge> eval_poly \\<alpha> (poly_subst ?z p)\" (is \"_ \\<ge> ?res\")"], ["proof (prove)\nusing this:\n  poly_subst (\\<lambda>w. poly_of (PVar w)) p \\<ge>p\n  poly_subst (\\<lambda>w. zero_poly) p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p)\n    \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p)\n     \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p)\n    \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)", "using pos"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p)\n     \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p)\n    \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)", "by simp"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p)\n  \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p", "also"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p)\n  \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p", "have \"?res = eval_poly (\\<lambda> w. 0) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) =\n    eval_poly (\\<lambda>w. 0::'a) p", "by (simp add: poly_subst zero_poly_def)"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) =\n  eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p", "also"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (poly_subst (\\<lambda>w. zero_poly) p) =\n  eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p", "have \"\\<dots> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p", "by (rule pos_at_zero)"], ["proof (state)\nthis:\n  (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p", "finally"], ["proof (chain)\npicking this:\n  (0::'a)\n  \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a)\n  \\<le> eval_poly \\<alpha> (poly_subst (\\<lambda>w. poly_of (PVar w)) p)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> p", "by  (simp add: poly_subst)"], ["proof (state)\nthis:\n  (0::'a) \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0::'a) \\<le> eval_poly \\<alpha> p\n\ngoal:\nNo subgoals!", "qed"], ["", "context poly_order_carrier\nbegin"], ["", "definition poly_strict_mono :: \"('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\" where \n  \"poly_strict_mono p v \\<equiv> \\<forall> (\\<alpha> :: ('v,'a)assign) \\<beta>. (\\<forall> x. (v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x)) \\<longrightarrow> pos_assign \\<beta> \\<longrightarrow> \\<alpha> v \\<succ> \\<beta> v \\<longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p\""], ["", "lemma poly_strict_mono_E: assumes p: \"poly_strict_mono p v\"\n  and fgw: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\"\n  and g: \"\\<And> w. g w \\<ge>p zero_poly\" \n  and fgv: \"f v >p g v\"\n  shows \"poly_subst f p >p poly_subst g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p >p poly_subst g p", "unfolding poly_gt_def poly_subst"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly (\\<lambda>v. eval_poly \\<alpha> (f v)) p \\<succ>\n       eval_poly (\\<lambda>v. eval_poly \\<alpha> (g v)) p", "proof (intro allI impI, rule p[unfolded poly_strict_mono_def, rule_format])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)", "fix \\<alpha> :: \"('c,'a)assign\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n 3. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)", "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)", "using fgv"], ["proof (prove)\nusing this:\n  f v >p g v\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)", "unfolding poly_gt_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)", "by auto"], ["proof (state)\nthis:\n  pos_assign \\<alpha> \\<Longrightarrow>\n  eval_poly \\<alpha> (f v) \\<succ> eval_poly \\<alpha> (g v)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "fix \\<alpha> :: \"('c,'a)assign\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "assume alpha: \"pos_assign \\<alpha>\""], ["proof (state)\nthis:\n  pos_assign \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n 2. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "show \"pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))", "unfolding pos_assign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> eval_poly \\<alpha> (g x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> eval_poly \\<alpha> (g x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> eval_poly \\<alpha> (g x)", "show \"eval_poly \\<alpha> (g x) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)", "using g[of x]"], ["proof (prove)\nusing this:\n  g x \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)", "unfolding poly_ge_def zero_poly_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)", "using alpha"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> [] \\<le> eval_poly \\<alpha> (g x)\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_poly \\<alpha> (g x)", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pos_assign (\\<lambda>v. eval_poly \\<alpha> (g v))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "fix \\<alpha> :: \"('c,'a)assign\" and x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "assume v: \"v \\<noteq> x\""], ["proof (state)\nthis:\n  v \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>pos_assign \\<alpha>; v \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "show \"pos_assign \\<alpha> \\<Longrightarrow> eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "using fgw[OF v]"], ["proof (prove)\nusing this:\n  f x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  f x = g x\n\ngoal (1 subgoal):\n 1. pos_assign \\<alpha> \\<Longrightarrow>\n    eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)", "by auto"], ["proof (state)\nthis:\n  pos_assign \\<alpha> \\<Longrightarrow>\n  eval_poly \\<alpha> (f x) = eval_poly \\<alpha> (g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_add_gt_mono: assumes \"p1 >p p2\" shows \"poly_add p1 q >p poly_add p2 q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_add p1 q >p poly_add p2 q", "using assms"], ["proof (prove)\nusing this:\n  p1 >p p2\n\ngoal (1 subgoal):\n 1. poly_add p1 q >p poly_add p2 q", "unfolding poly_gt_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       pos_assign \\<alpha> \\<longrightarrow>\n       eval_poly \\<alpha> (poly_add p1 q) \\<succ>\n       eval_poly \\<alpha> (poly_add p2 q)", "by (auto simp: field_simps plus_gt_left_mono)"], ["", "lemma poly_mult_gt_mono: \n  fixes q :: \"('v :: linorder,'a)poly\"\n  assumes gt: \"p1 >p p2\" and mono: \"q \\<ge>p one_poly\"\n  shows \"poly_mult p1 q >p poly_mult p2 q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p1 q >p poly_mult p2 q", "proof (unfold poly_gt_def, intro impI allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_mult p1 q) \\<succ>\n       eval_poly \\<alpha> (poly_mult p2 q)", "fix \\<alpha> :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_mult p1 q) \\<succ>\n       eval_poly \\<alpha> (poly_mult p2 q)", "assume p: \"pos_assign \\<alpha>\""], ["proof (state)\nthis:\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_mult p1 q) \\<succ>\n       eval_poly \\<alpha> (poly_mult p2 q)", "with gt"], ["proof (chain)\npicking this:\n  p1 >p p2\n  pos_assign \\<alpha>", "have gt: \"eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\""], ["proof (prove)\nusing this:\n  p1 >p p2\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2", "unfolding poly_gt_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2", "by simp"], ["proof (state)\nthis:\n  eval_poly \\<alpha> p1 \\<succ> eval_poly \\<alpha> p2\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_mult p1 q) \\<succ>\n       eval_poly \\<alpha> (poly_mult p2 q)", "from mono p"], ["proof (chain)\npicking this:\n  q \\<ge>p one_poly\n  pos_assign \\<alpha>", "have one: \"eval_poly \\<alpha> q \\<ge> 1\""], ["proof (prove)\nusing this:\n  q \\<ge>p one_poly\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> eval_poly \\<alpha> q", "unfolding poly_ge_def one_poly_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> [(1, 1::'a)] \\<le> eval_poly \\<alpha> q\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> eval_poly \\<alpha> q", "by auto"], ["proof (state)\nthis:\n  (1::'a) \\<le> eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> (poly_mult p1 q) \\<succ>\n       eval_poly \\<alpha> (poly_mult p2 q)", "show \"eval_poly \\<alpha> (poly_mult p1 q) \\<succ> eval_poly \\<alpha> (poly_mult p2 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_mult p1 q) \\<succ>\n    eval_poly \\<alpha> (poly_mult p2 q)", "using times_gt_mono[OF gt one]"], ["proof (prove)\nusing this:\n  eval_poly \\<alpha> p1 * eval_poly \\<alpha> q \\<succ>\n  eval_poly \\<alpha> p2 * eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (poly_mult p1 q) \\<succ>\n    eval_poly \\<alpha> (poly_mult p2 q)", "by simp"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (poly_mult p1 q) \\<succ>\n  eval_poly \\<alpha> (poly_mult p2 q)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Degree of polynomials\\<close>"], ["", "definition monom_list_degree :: \"'v monom_list \\<Rightarrow> nat\" where \n  \"monom_list_degree xps \\<equiv> sum_list (map snd xps)\""], ["", "lift_definition monom_degree :: \"'v :: linorder monom \\<Rightarrow> nat\" is monom_list_degree"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition poly_degree :: \"(_,'a) poly \\<Rightarrow> nat\" where\n  \"poly_degree p \\<equiv> max_list (map (\\<lambda> (m,c). monom_degree m) p)\""], ["", "definition poly_coeff_sum :: \"('v,'a :: ordered_ab_semigroup) poly \\<Rightarrow> 'a\" where\n  \"poly_coeff_sum p \\<equiv> sum_list (map (\\<lambda> mc. max 0 (snd mc)) p)\""], ["", "lemma monom_list_degree: \"eval_monom_list (\\<lambda> _. x) m = x ^ monom_list_degree m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) m = x ^ monom_list_degree m", "unfolding monom_list_degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m)", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])\n 2. \\<And>a m.\n       eval_monom_list (\\<lambda>_. x) m =\n       x ^ sum_list (map snd m) \\<Longrightarrow>\n       eval_monom_list (\\<lambda>_. x) (a # m) =\n       x ^ sum_list (map snd (a # m))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. eval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])\n 2. \\<And>a m.\n       eval_monom_list (\\<lambda>_. x) m =\n       x ^ sum_list (map snd m) \\<Longrightarrow>\n       eval_monom_list (\\<lambda>_. x) (a # m) =\n       x ^ sum_list (map snd (a # m))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])", "by simp"], ["proof (state)\nthis:\n  eval_monom_list (\\<lambda>_. x) [] = x ^ sum_list (map snd [])\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       eval_monom_list (\\<lambda>_. x) m =\n       x ^ sum_list (map snd m) \\<Longrightarrow>\n       eval_monom_list (\\<lambda>_. x) (a # m) =\n       x ^ sum_list (map snd (a # m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m.\n       eval_monom_list (\\<lambda>_. x) m =\n       x ^ sum_list (map snd m) \\<Longrightarrow>\n       eval_monom_list (\\<lambda>_. x) (a # m) =\n       x ^ sum_list (map snd (a # m))", "case (Cons mc m)"], ["proof (state)\nthis:\n  eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m)\n\ngoal (1 subgoal):\n 1. \\<And>a m.\n       eval_monom_list (\\<lambda>_. x) m =\n       x ^ sum_list (map snd m) \\<Longrightarrow>\n       eval_monom_list (\\<lambda>_. x) (a # m) =\n       x ^ sum_list (map snd (a # m))", "thus ?case"], ["proof (prove)\nusing this:\n  eval_monom_list (\\<lambda>_. x) m = x ^ sum_list (map snd m)\n\ngoal (1 subgoal):\n 1. eval_monom_list (\\<lambda>_. x) (mc # m) =\n    x ^ sum_list (map snd (mc # m))", "by (cases mc, auto simp: power_add field_simps)"], ["proof (state)\nthis:\n  eval_monom_list (\\<lambda>_. x) (mc # m) = x ^ sum_list (map snd (mc # m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monom_list_var_monom[simp]: \"monom_list (var_monom x) = [(x,1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_list (var_monom x) = [(x, 1)]", "by (transfer, simp)"], ["", "lemma monom_list_1[simp]: \"monom_list 1 = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_list 1 = []", "by (transfer, simp)"], ["", "lemma monom_degree: \"eval_monom (\\<lambda> _. x) m = x ^ monom_degree m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom (\\<lambda>_. x) m = x ^ monom_degree m", "by (transfer, rule monom_list_degree)"], ["", "lemma poly_coeff_sum: \"poly_coeff_sum p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> poly_coeff_sum p", "unfolding poly_coeff_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))\n 2. \\<And>a p.\n       (0::'a)\n       \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow>\n       (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))\n 2. \\<And>a p.\n       (0::'a)\n       \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow>\n       (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))", "by (simp add: ge_refl)"], ["proof (state)\nthis:\n  (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>[]. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       (0::'a)\n       \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow>\n       (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       (0::'a)\n       \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow>\n       (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))", "case (Cons mc p)"], ["proof (state)\nthis:\n  (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       (0::'a)\n       \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow>\n       (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))", "have \"(\\<Sum>mc\\<leftarrow>mc # p. max 0 (snd mc)) = max 0 (snd mc) + (\\<Sum>mc\\<leftarrow>p. max 0 (snd mc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) =\n    max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) =\n  max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       (0::'a)\n       \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow>\n       (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))", "also"], ["proof (state)\nthis:\n  (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) =\n  max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       (0::'a)\n       \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow>\n       (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))", "have \"\\<dots> \\<ge> 0 + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) + (0::'a)\n    \\<le> max (0::'a) (snd mc) +\n          (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))", "by (rule ge_trans[OF plus_left_mono plus_right_mono[OF Cons]], auto)"], ["proof (state)\nthis:\n  (0::'a) + (0::'a)\n  \\<le> max (0::'a) (snd mc) + (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       (0::'a)\n       \\<le> (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) \\<Longrightarrow>\n       (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>a # p. max (0::'a) (snd mc))", "finally"], ["proof (chain)\npicking this:\n  (0::'a) + (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))", "show ?case"], ["proof (prove)\nusing this:\n  (0::'a) + (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))", "by simp"], ["proof (state)\nthis:\n  (0::'a) \\<le> (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_degree: assumes x: \"x \\<ge> (1 :: 'a :: poly_carrier)\" \n  shows \"poly_coeff_sum p * (x ^ poly_degree p) \\<ge> eval_poly (\\<lambda> _. x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval_poly (\\<lambda>_. x) []\n    \\<le> poly_coeff_sum [] * x ^ poly_degree []\n 2. \\<And>a p.\n       eval_poly (\\<lambda>_. x) p\n       \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow>\n       eval_poly (\\<lambda>_. x) (a # p)\n       \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. eval_poly (\\<lambda>_. x) []\n    \\<le> poly_coeff_sum [] * x ^ poly_degree []\n 2. \\<And>a p.\n       eval_poly (\\<lambda>_. x) p\n       \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow>\n       eval_poly (\\<lambda>_. x) (a # p)\n       \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) []\n    \\<le> poly_coeff_sum [] * x ^ poly_degree []", "by (simp add: ge_refl poly_degree_def poly_coeff_sum_def)"], ["proof (state)\nthis:\n  eval_poly (\\<lambda>_. x) [] \\<le> poly_coeff_sum [] * x ^ poly_degree []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly (\\<lambda>_. x) p\n       \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow>\n       eval_poly (\\<lambda>_. x) (a # p)\n       \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly (\\<lambda>_. x) p\n       \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow>\n       eval_poly (\\<lambda>_. x) (a # p)\n       \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)", "case (Cons mc p)"], ["proof (state)\nthis:\n  eval_poly (\\<lambda>_. x) p \\<le> poly_coeff_sum p * x ^ poly_degree p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly (\\<lambda>_. x) p\n       \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow>\n       eval_poly (\\<lambda>_. x) (a # p)\n       \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly (\\<lambda>_. x) p\n       \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow>\n       eval_poly (\\<lambda>_. x) (a # p)\n       \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)", "from ge_trans[OF x one_ge_zero]"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> x", "have x0: \"x \\<ge> 0\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x", "."], ["proof (state)\nthis:\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly (\\<lambda>_. x) p\n       \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow>\n       eval_poly (\\<lambda>_. x) (a # p)\n       \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)", "have id1: \"eval_poly (\\<lambda>_. x) (mc # p) = x ^ monom_degree m  * c + eval_poly (\\<lambda>_. x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) (mc # p) =\n    x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p", "unfolding mc"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) ((m, c) # p) =\n    x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p", "by (simp add: monom_degree)"], ["proof (state)\nthis:\n  eval_poly (\\<lambda>_. x) (mc # p) =\n  x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly (\\<lambda>_. x) p\n       \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow>\n       eval_poly (\\<lambda>_. x) (a # p)\n       \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)", "have id2: \"poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) = \n    x ^ max (monom_degree m) (poly_degree p) * (max 0 c) + poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) =\n    x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c +\n    poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)", "unfolding poly_coeff_sum_def poly_degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>mc\\<leftarrow>mc # p. max (0::'a) (snd mc)) *\n    x ^ max_list (map (\\<lambda>(m, c). monom_degree m) (mc # p)) =\n    x ^\n    max (monom_degree m)\n     (max_list (map (\\<lambda>(m, c). monom_degree m) p)) *\n    max (0::'a) c +\n    (\\<Sum>mc\\<leftarrow>p. max (0::'a) (snd mc)) *\n    x ^\n    max (monom_degree m)\n     (max_list (map (\\<lambda>(m, c). monom_degree m) p))", "by (simp add: mc field_simps)"], ["proof (state)\nthis:\n  poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) =\n  x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c +\n  poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       eval_poly (\\<lambda>_. x) p\n       \\<le> poly_coeff_sum p * x ^ poly_degree p \\<Longrightarrow>\n       eval_poly (\\<lambda>_. x) (a # p)\n       \\<le> poly_coeff_sum (a # p) * x ^ poly_degree (a # p)", "show \"poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p) \\<ge> eval_poly (\\<lambda>_. x) (mc # p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) (mc # p)\n    \\<le> poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p)", "unfolding id1 id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ monom_degree m * c + eval_poly (\\<lambda>_. x) p\n    \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c +\n          poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)", "proof (rule ge_trans[OF plus_left_mono plus_right_mono])"], ["proof (state)\ngoal (2 subgoals):\n 1. x ^ monom_degree m * c\n    \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c\n 2. eval_poly (\\<lambda>_. x) p\n    \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)", "show \"x ^ max (monom_degree m) (poly_degree p) * max 0 c \\<ge> x ^ monom_degree m * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ monom_degree m * c\n    \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c", "by (rule ge_trans[OF times_left_mono[OF _ pow_mono_exp] times_right_mono[OF pow_ge_zero]], insert x x0, auto)"], ["proof (state)\nthis:\n  x ^ monom_degree m * c\n  \\<le> x ^ max (monom_degree m) (poly_degree p) * max (0::'a) c\n\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p\n    \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)", "show \"poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p) \\<ge> eval_poly (\\<lambda>_. x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p\n    \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)", "by (rule ge_trans[OF times_right_mono[OF poly_coeff_sum pow_mono_exp[OF x]] Cons], auto)"], ["proof (state)\nthis:\n  eval_poly (\\<lambda>_. x) p\n  \\<le> poly_coeff_sum p * x ^ max (monom_degree m) (poly_degree p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly (\\<lambda>_. x) (mc # p)\n  \\<le> poly_coeff_sum (mc # p) * x ^ poly_degree (mc # p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_degree_bound: assumes x: \"x \\<ge> (1 :: 'a :: poly_carrier)\" \n  and c: \"c \\<ge> poly_coeff_sum p\"\n  and d: \"d \\<ge> poly_degree p\"\n  shows \"c * (x ^ d) \\<ge> eval_poly (\\<lambda> _. x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly (\\<lambda>_. x) p \\<le> c * x ^ d", "by (rule ge_trans[OF ge_trans[OF \n    times_left_mono[OF pow_ge_zero[OF ge_trans[OF x one_ge_zero]] c]   \n    times_right_mono[OF poly_coeff_sum pow_mono_exp[OF x d]]] poly_degree[OF x]])"], ["", "subsection \\<open>Executable and sufficient criteria to compare polynomials and ensure monotonicity\\<close>"], ["", "text \\<open>poly\\_split extracts the coefficient for a given monomial and returns additionally the remaining polynomial\\<close>"], ["", "definition poly_split :: \"('v monom) \\<Rightarrow> ('v,'a :: zero)poly \\<Rightarrow> 'a \\<times> ('v,'a)poly\" \n  where \"poly_split m p \\<equiv> case List.extract (\\<lambda> (n,_). m = n) p of None \\<Rightarrow> (0,p) | Some (p1,(_,c),p2) \\<Rightarrow> (c, p1 @ p2)\""], ["", "lemma poly_split: assumes \"poly_split m p = (c,q)\"\n  shows \"p =p (m,c) # q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =p (m, c) # q", "proof (cases \"List.extract (\\<lambda> (n,_). m = n) p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>(n, uu_). m = n) p = None \\<Longrightarrow>\n    p =p (m, c) # q\n 2. \\<And>a.\n       List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow>\n       p =p (m, c) # q", "case None"], ["proof (state)\nthis:\n  List.extract (\\<lambda>(n, uu_). m = n) p = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>(n, uu_). m = n) p = None \\<Longrightarrow>\n    p =p (m, c) # q\n 2. \\<And>a.\n       List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow>\n       p =p (m, c) # q", "with assms"], ["proof (chain)\npicking this:\n  poly_split m p = (c, q)\n  List.extract (\\<lambda>(n, uu_). m = n) p = None", "have \"(c,q) = (0,p)\""], ["proof (prove)\nusing this:\n  poly_split m p = (c, q)\n  List.extract (\\<lambda>(n, uu_). m = n) p = None\n\ngoal (1 subgoal):\n 1. (c, q) = (0::'a, p)", "unfolding poly_split_def"], ["proof (prove)\nusing this:\n  (case List.extract (\\<lambda>(n, uu_). m = n) p of\n   None \\<Rightarrow> (0::'a, p)\n   | Some (p1, (x, c), p2) \\<Rightarrow> (c, p1 @ p2)) =\n  (c, q)\n  List.extract (\\<lambda>(n, uu_). m = n) p = None\n\ngoal (1 subgoal):\n 1. (c, q) = (0::'a, p)", "by auto"], ["proof (state)\nthis:\n  (c, q) = (0::'a, p)\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>(n, uu_). m = n) p = None \\<Longrightarrow>\n    p =p (m, c) # q\n 2. \\<And>a.\n       List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow>\n       p =p (m, c) # q", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c, q) = (0::'a, p)\n\ngoal (1 subgoal):\n 1. p =p (m, c) # q", "unfolding eq_poly_def"], ["proof (prove)\nusing this:\n  (c, q) = (0::'a, p)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       eval_poly \\<alpha> p = eval_poly \\<alpha> ((m, c) # q)", "by auto"], ["proof (state)\nthis:\n  p =p (m, c) # q\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow>\n       p =p (m, c) # q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow>\n       p =p (m, c) # q", "case (Some res)"], ["proof (state)\nthis:\n  List.extract (\\<lambda>(n, uu_). m = n) p = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow>\n       p =p (m, c) # q", "obtain p1 mc p2 where \"res = (p1,mc,p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 mc p2.\n        res = (p1, mc, p2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases res, auto)"], ["proof (state)\nthis:\n  res = (p1, mc, p2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow>\n       p =p (m, c) # q", "with extract_SomeE[OF Some[simplified this]]"], ["proof (chain)\npicking this:\n  p = p1 @ mc # p2 \\<and>\n  (case mc of (n, uu_) \\<Rightarrow> m = n) \\<and>\n  \\<not> (\\<exists>y\\<in>set p1. case y of (n, uu_) \\<Rightarrow> m = n)\n  res = (p1, mc, p2)", "obtain a where p: \"p = p1 @ (m,a) # p2\" and res: \"res = (p1,(m,a),p2)\""], ["proof (prove)\nusing this:\n  p = p1 @ mc # p2 \\<and>\n  (case mc of (n, uu_) \\<Rightarrow> m = n) \\<and>\n  \\<not> (\\<exists>y\\<in>set p1. case y of (n, uu_) \\<Rightarrow> m = n)\n  res = (p1, mc, p2)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>p = p1 @ (m, a) # p2; res = (p1, (m, a), p2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mc, auto)"], ["proof (state)\nthis:\n  p = p1 @ (m, a) # p2\n  res = (p1, (m, a), p2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow>\n       p =p (m, c) # q", "from Some res assms"], ["proof (chain)\npicking this:\n  List.extract (\\<lambda>(n, uu_). m = n) p = Some res\n  res = (p1, (m, a), p2)\n  poly_split m p = (c, q)", "have c: \"c = a\" and q: \"q = p1 @ p2\""], ["proof (prove)\nusing this:\n  List.extract (\\<lambda>(n, uu_). m = n) p = Some res\n  res = (p1, (m, a), p2)\n  poly_split m p = (c, q)\n\ngoal (1 subgoal):\n 1. c = a &&& q = p1 @ p2", "unfolding poly_split_def"], ["proof (prove)\nusing this:\n  List.extract (\\<lambda>(n, uu_). m = n) p = Some res\n  res = (p1, (m, a), p2)\n  (case List.extract (\\<lambda>(n, uu_). m = n) p of\n   None \\<Rightarrow> (0::'a, p)\n   | Some (p1, (x, c), p2) \\<Rightarrow> (c, p1 @ p2)) =\n  (c, q)\n\ngoal (1 subgoal):\n 1. c = a &&& q = p1 @ p2", "by auto"], ["proof (state)\nthis:\n  c = a\n  q = p1 @ p2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>(n, uu_). m = n) p = Some a \\<Longrightarrow>\n       p =p (m, c) # q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =p (m, c) # q", "unfolding eq_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>.\n       eval_poly \\<alpha> p = eval_poly \\<alpha> ((m, c) # q)", "by (simp add: p c q field_simps)"], ["proof (state)\nthis:\n  p =p (m, c) # q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_split_eval: assumes \"poly_split m p = (c,q)\" \n  shows \"eval_poly \\<alpha> p = (eval_monom \\<alpha> m * c) + eval_poly \\<alpha> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_monom \\<alpha> m * c + eval_poly \\<alpha> q", "using poly_split[OF assms]"], ["proof (prove)\nusing this:\n  p =p (m, c) # q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_monom \\<alpha> m * c + eval_poly \\<alpha> q", "unfolding eq_poly_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> ((m, c) # q)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_monom \\<alpha> m * c + eval_poly \\<alpha> q", "by auto"], ["", "(* we assume that the polynomial invariant is present, otherwise this check might fail, e.g., on 0 =p 0 + 0 *)"], ["", "fun check_poly_eq :: \"('v,'a :: semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" where \n  \"check_poly_eq [] q = (q = [])\"\n| \"check_poly_eq ((m,c) # p) q = (case List.extract (\\<lambda> nd. fst nd = m) q of\n       None \\<Rightarrow> False\n     | Some (q1,(_,d),q2) \\<Rightarrow> c = d \\<and> check_poly_eq p (q1 @ q2))\""], ["", "lemma check_poly_eq: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes chk: \"check_poly_eq p q\"\n  shows \"p =p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =p q", "unfolding eq_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q", "fix \\<alpha>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. eval_poly \\<alpha> p = eval_poly \\<alpha> q", "from chk"], ["proof (chain)\npicking this:\n  check_poly_eq p q", "show \"eval_poly \\<alpha> p = eval_poly \\<alpha> q\""], ["proof (prove)\nusing this:\n  check_poly_eq p q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<alpha> q", "proof (induct p arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       check_poly_eq [] q \\<Longrightarrow>\n       eval_poly \\<alpha> [] = eval_poly \\<alpha> q\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   check_poly_eq p q \\<Longrightarrow>\n                   eval_poly \\<alpha> p = eval_poly \\<alpha> q;\n        check_poly_eq (a # p) q\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q", "case Nil"], ["proof (state)\nthis:\n  check_poly_eq [] q\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       check_poly_eq [] q \\<Longrightarrow>\n       eval_poly \\<alpha> [] = eval_poly \\<alpha> q\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   check_poly_eq p q \\<Longrightarrow>\n                   eval_poly \\<alpha> p = eval_poly \\<alpha> q;\n        check_poly_eq (a # p) q\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q", "thus ?case"], ["proof (prove)\nusing this:\n  check_poly_eq [] q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> [] = eval_poly \\<alpha> q", "by auto"], ["proof (state)\nthis:\n  eval_poly \\<alpha> [] = eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   check_poly_eq p q \\<Longrightarrow>\n                   eval_poly \\<alpha> p = eval_poly \\<alpha> q;\n        check_poly_eq (a # p) q\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   check_poly_eq p q \\<Longrightarrow>\n                   eval_poly \\<alpha> p = eval_poly \\<alpha> q;\n        check_poly_eq (a # p) q\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q", "case (Cons mc p)"], ["proof (state)\nthis:\n  check_poly_eq p ?q \\<Longrightarrow>\n  eval_poly \\<alpha> p = eval_poly \\<alpha> ?q\n  check_poly_eq (mc # p) q\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   check_poly_eq p q \\<Longrightarrow>\n                   eval_poly \\<alpha> p = eval_poly \\<alpha> q;\n        check_poly_eq (a # p) q\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mc, auto)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   check_poly_eq p q \\<Longrightarrow>\n                   eval_poly \\<alpha> p = eval_poly \\<alpha> q;\n        check_poly_eq (a # p) q\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> (a # p) = eval_poly \\<alpha> q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "case None"], ["proof (state)\nthis:\n  List.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "with Cons(2)"], ["proof (chain)\npicking this:\n  check_poly_eq (mc # p) q\n  List.extract (\\<lambda>mc. fst mc = m) q = None", "show ?thesis"], ["proof (prove)\nusing this:\n  check_poly_eq (mc # p) q\n  List.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "unfolding mc"], ["proof (prove)\nusing this:\n  check_poly_eq ((m, c) # p) q\n  List.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> ((m, c) # p) = eval_poly \\<alpha> q", "by simp"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "case (Some res)"], ["proof (state)\nthis:\n  List.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "obtain q1 md q2 where \"res = (q1,md,q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2.\n        res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases res, auto)"], ["proof (state)\nthis:\n  res = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "with extract_SomeE[OF Some[simplified this]]"], ["proof (chain)\npicking this:\n  q = q1 @ md # q2 \\<and>\n  fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\n  res = (q1, md, q2)", "obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\""], ["proof (prove)\nusing this:\n  q = q1 @ md # q2 \\<and>\n  fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\n  res = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases md, auto)"], ["proof (state)\nthis:\n  q = q1 @ (m, d) # q2\n  res = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "from Cons(2) Some mc res"], ["proof (chain)\npicking this:\n  check_poly_eq (mc # p) q\n  List.extract (\\<lambda>mc. fst mc = m) q = Some res\n  mc = (m, c)\n  res = (q1, (m, d), q2)", "have rec: \"check_poly_eq p (q1 @ q2)\" and c: \"c = d\""], ["proof (prove)\nusing this:\n  check_poly_eq (mc # p) q\n  List.extract (\\<lambda>mc. fst mc = m) q = Some res\n  mc = (m, c)\n  res = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. check_poly_eq p (q1 @ q2) &&& c = d", "by auto"], ["proof (state)\nthis:\n  check_poly_eq p (q1 @ q2)\n  c = d\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "from Cons(1)[OF rec]"], ["proof (chain)\npicking this:\n  eval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)", "have p: \"eval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)\""], ["proof (prove)\nusing this:\n  eval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)", "."], ["proof (state)\nthis:\n  eval_poly \\<alpha> p = eval_poly \\<alpha> (q1 @ q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q", "unfolding mc eval_poly.simps c p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monomc \\<alpha> (m, d) + eval_poly \\<alpha> (q1 @ q2) =\n    eval_poly \\<alpha> (q1 @ (m, d) # q2)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (mc # p) = eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly \\<alpha> p = eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!", "qed"], ["", "declare check_poly_eq.simps[simp del]"], ["", "fun check_poly_ge :: \"('v,'a :: ordered_semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\" where \n  \"check_poly_ge [] q = list_all (\\<lambda> (_,d). 0 \\<ge> d) q\"\n| \"check_poly_ge ((m,c) # p) q = (case List.extract (\\<lambda> nd. fst nd = m) q of\n     None \\<Rightarrow> c \\<ge> 0 \\<and> check_poly_ge p q\n   | Some (q1,(_,d),q2) \\<Rightarrow> c \\<ge> d \\<and> check_poly_ge p (q1 @ q2))\""], ["", "lemma check_poly_ge: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_ge p q \\<Longrightarrow> p \\<ge>p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q", "proof (induct p arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q;\n        check_poly_ge (a # p) q\\<rbrakk>\n       \\<Longrightarrow> a # p \\<ge>p q", "case Nil"], ["proof (state)\nthis:\n  check_poly_ge [] q\n\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q;\n        check_poly_ge (a # p) q\\<rbrakk>\n       \\<Longrightarrow> a # p \\<ge>p q", "hence \"\\<forall> (n,d) \\<in> set q. 0 \\<ge> d\""], ["proof (prove)\nusing this:\n  check_poly_ge [] q\n\ngoal (1 subgoal):\n 1. \\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)", "using list_all_iff[of _ q]"], ["proof (prove)\nusing this:\n  check_poly_ge [] q\n  list_all ?P q = Ball (set q) ?P\n\ngoal (1 subgoal):\n 1. \\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q;\n        check_poly_ge (a # p) q\\<rbrakk>\n       \\<Longrightarrow> a # p \\<ge>p q", "hence \"[] \\<ge>p q\""], ["proof (prove)\nusing this:\n  \\<forall>(n, d)\\<in>set q. d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. [] \\<ge>p q", "proof (induct q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(n, d)\\<in>set []. d \\<le> (0::'a) \\<Longrightarrow>\n    [] \\<ge>p []\n 2. \\<And>a q.\n       \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow>\n                [] \\<ge>p q;\n        \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> [] \\<ge>p a # q", "case Nil"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set []. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<forall>(n, d)\\<in>set []. d \\<le> (0::'a) \\<Longrightarrow>\n    [] \\<ge>p []\n 2. \\<And>a q.\n       \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow>\n                [] \\<ge>p q;\n        \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> [] \\<ge>p a # q", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set []. case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. [] \\<ge>p []", "by (simp)"], ["proof (state)\nthis:\n  [] \\<ge>p []\n\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow>\n                [] \\<ge>p q;\n        \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> [] \\<ge>p a # q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow>\n                [] \\<ge>p q;\n        \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> [] \\<ge>p a # q", "case (Cons nd q)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set q.\n     case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow>\n  [] \\<ge>p q\n  \\<forall>a\\<in>set (nd # q).\n     case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow>\n                [] \\<ge>p q;\n        \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> [] \\<ge>p a # q", "hence rec: \"[] \\<ge>p q\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set q.\n     case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow>\n  [] \\<ge>p q\n  \\<forall>a\\<in>set (nd # q).\n     case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. [] \\<ge>p q", "by simp"], ["proof (state)\nthis:\n  [] \\<ge>p q\n\ngoal (1 subgoal):\n 1. \\<And>a q.\n       \\<lbrakk>\\<forall>(n, d)\\<in>set q. d \\<le> (0::'a) \\<Longrightarrow>\n                [] \\<ge>p q;\n        \\<forall>(n, d)\\<in>set (a # q). d \\<le> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> [] \\<ge>p a # q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<ge>p nd # q", "proof (cases nd)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. nd = (a, b) \\<Longrightarrow> [] \\<ge>p nd # q", "case (Pair n d)"], ["proof (state)\nthis:\n  nd = (n, d)\n\ngoal (1 subgoal):\n 1. \\<And>a b. nd = (a, b) \\<Longrightarrow> [] \\<ge>p nd # q", "with Cons"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set q.\n     case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow>\n  [] \\<ge>p q\n  \\<forall>a\\<in>set (nd # q).\n     case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n  nd = (n, d)", "have ge: \"0 \\<ge> d\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set q.\n     case a of (n, d) \\<Rightarrow> d \\<le> (0::'a) \\<Longrightarrow>\n  [] \\<ge>p q\n  \\<forall>a\\<in>set (nd # q).\n     case a of (n, d) \\<Rightarrow> d \\<le> (0::'a)\n  nd = (n, d)\n\ngoal (1 subgoal):\n 1. d \\<le> (0::'a)", "by auto"], ["proof (state)\nthis:\n  d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a b. nd = (a, b) \\<Longrightarrow> [] \\<ge>p nd # q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<ge>p nd # q", "proof (simp only: Pair, unfold poly_ge_def, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []", "fix \\<alpha> :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []", "assume pos: \"pos_assign \\<alpha>\""], ["proof (state)\nthis:\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []", "have ge: \"0 \\<ge> eval_monom \\<alpha> n * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> n * d \\<le> (0::'a)", "using times_right_mono[OF pos_assign_monom[OF pos, of n] ge]"], ["proof (prove)\nusing this:\n  eval_monom \\<alpha> n * d \\<le> eval_monom \\<alpha> n * (0::'a)\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> n * d \\<le> (0::'a)", "by simp"], ["proof (state)\nthis:\n  eval_monom \\<alpha> n * d \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []", "from rec[unfolded poly_ge_def] pos"], ["proof (chain)\npicking this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> []\n  pos_assign \\<alpha>", "have ge2: \"0 \\<ge> eval_poly \\<alpha> q\""], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> []\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> (0::'a)", "by auto"], ["proof (state)\nthis:\n  eval_poly \\<alpha> q \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []", "show \"eval_poly \\<alpha> [] \\<ge> eval_poly \\<alpha> ((n,d) # q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []", "using ge_trans[OF plus_left_mono[OF ge] plus_right_mono[OF ge2]]"], ["proof (prove)\nusing this:\n  eval_monom \\<alpha> n * d + eval_poly \\<alpha> q \\<le> (0::'a) + (0::'a)\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []", "by simp"], ["proof (state)\nthis:\n  eval_poly \\<alpha> ((n, d) # q) \\<le> eval_poly \\<alpha> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [] \\<ge>p nd # q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [] \\<ge>p nd # q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [] \\<ge>p q\n\ngoal (2 subgoals):\n 1. \\<And>q. check_poly_ge [] q \\<Longrightarrow> [] \\<ge>p q\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q;\n        check_poly_ge (a # p) q\\<rbrakk>\n       \\<Longrightarrow> a # p \\<ge>p q", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<ge>p q\n\ngoal (1 subgoal):\n 1. [] \\<ge>p q", "by simp"], ["proof (state)\nthis:\n  [] \\<ge>p q\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q;\n        check_poly_ge (a # p) q\\<rbrakk>\n       \\<Longrightarrow> a # p \\<ge>p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q;\n        check_poly_ge (a # p) q\\<rbrakk>\n       \\<Longrightarrow> a # p \\<ge>p q", "case (Cons mc p)"], ["proof (state)\nthis:\n  check_poly_ge p ?q \\<Longrightarrow> p \\<ge>p ?q\n  check_poly_ge (mc # p) q\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q;\n        check_poly_ge (a # p) q\\<rbrakk>\n       \\<Longrightarrow> a # p \\<ge>p q", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mc, auto)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q. check_poly_ge p q \\<Longrightarrow> p \\<ge>p q;\n        check_poly_ge (a # p) q\\<rbrakk>\n       \\<Longrightarrow> a # p \\<ge>p q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mc # p \\<ge>p q", "proof (cases \"List.extract (\\<lambda> mc. fst mc = m) q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    mc # p \\<ge>p q\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       mc # p \\<ge>p q", "case None"], ["proof (state)\nthis:\n  List.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    mc # p \\<ge>p q\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       mc # p \\<ge>p q", "with Cons(2)"], ["proof (chain)\npicking this:\n  check_poly_ge (mc # p) q\n  List.extract (\\<lambda>mc. fst mc = m) q = None", "have rec: \"check_poly_ge p q\" and c: \"c \\<ge> 0\""], ["proof (prove)\nusing this:\n  check_poly_ge (mc # p) q\n  List.extract (\\<lambda>mc. fst mc = m) q = None\n\ngoal (1 subgoal):\n 1. check_poly_ge p q &&& (0::'a) \\<le> c", "using mc"], ["proof (prove)\nusing this:\n  check_poly_ge (mc # p) q\n  List.extract (\\<lambda>mc. fst mc = m) q = None\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. check_poly_ge p q &&& (0::'a) \\<le> c", "by auto"], ["proof (state)\nthis:\n  check_poly_ge p q\n  (0::'a) \\<le> c\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    mc # p \\<ge>p q\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       mc # p \\<ge>p q", "from Cons(1)[OF rec]"], ["proof (chain)\npicking this:\n  p \\<ge>p q", "have rec: \"p \\<ge>p q\""], ["proof (prove)\nusing this:\n  p \\<ge>p q\n\ngoal (1 subgoal):\n 1. p \\<ge>p q", "."], ["proof (state)\nthis:\n  p \\<ge>p q\n\ngoal (2 subgoals):\n 1. List.extract (\\<lambda>mc. fst mc = m) q = None \\<Longrightarrow>\n    mc # p \\<ge>p q\n 2. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       mc # p \\<ge>p q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mc # p \\<ge>p q", "proof (simp only: mc, unfold poly_ge_def, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "fix \\<alpha> :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "assume pos: \"pos_assign \\<alpha>\""], ["proof (state)\nthis:\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "have ge: \"eval_monom \\<alpha> m * c \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom \\<alpha> m * c", "using times_right_mono[OF pos_assign_monom[OF pos, of m] c]"], ["proof (prove)\nusing this:\n  eval_monom \\<alpha> m * (0::'a) \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> eval_monom \\<alpha> m * c", "by simp"], ["proof (state)\nthis:\n  (0::'a) \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "from rec"], ["proof (chain)\npicking this:\n  p \\<ge>p q", "have pq: \"eval_poly \\<alpha> p \\<ge> eval_poly \\<alpha> q\""], ["proof (prove)\nusing this:\n  p \\<ge>p q\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p", "using pos"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p", "by auto"], ["proof (state)\nthis:\n  eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "show \"eval_poly \\<alpha> ((m,c) # p) \\<ge> eval_poly \\<alpha> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "using ge_trans[OF plus_left_mono[OF ge] plus_right_mono[OF pq]]"], ["proof (prove)\nusing this:\n  (0::'a) + eval_poly \\<alpha> q\n  \\<le> eval_monom \\<alpha> m * c + eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "by simp"], ["proof (state)\nthis:\n  eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mc # p \\<ge>p q\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       mc # p \\<ge>p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       mc # p \\<ge>p q", "case (Some res)"], ["proof (state)\nthis:\n  List.extract (\\<lambda>mc. fst mc = m) q = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       mc # p \\<ge>p q", "obtain q1 md q2 where \"res = (q1,md,q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 md q2.\n        res = (q1, md, q2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases res, auto)"], ["proof (state)\nthis:\n  res = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       mc # p \\<ge>p q", "with extract_SomeE[OF Some[simplified this]]"], ["proof (chain)\npicking this:\n  q = q1 @ md # q2 \\<and>\n  fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\n  res = (q1, md, q2)", "obtain d where q: \"q = q1 @ (m,d) # q2\" and res: \"res = (q1,(m,d),q2)\""], ["proof (prove)\nusing this:\n  q = q1 @ md # q2 \\<and>\n  fst md = m \\<and> \\<not> (\\<exists>y\\<in>set q1. fst y = m)\n  res = (q1, md, q2)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>q = q1 @ (m, d) # q2; res = (q1, (m, d), q2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases md, auto)"], ["proof (state)\nthis:\n  q = q1 @ (m, d) # q2\n  res = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       mc # p \\<ge>p q", "from Cons(2) Some mc res"], ["proof (chain)\npicking this:\n  check_poly_ge (mc # p) q\n  List.extract (\\<lambda>mc. fst mc = m) q = Some res\n  mc = (m, c)\n  res = (q1, (m, d), q2)", "have rec: \"check_poly_ge p (q1 @ q2)\" and c: \"c \\<ge> d\""], ["proof (prove)\nusing this:\n  check_poly_ge (mc # p) q\n  List.extract (\\<lambda>mc. fst mc = m) q = Some res\n  mc = (m, c)\n  res = (q1, (m, d), q2)\n\ngoal (1 subgoal):\n 1. check_poly_ge p (q1 @ q2) &&& d \\<le> c", "by auto"], ["proof (state)\nthis:\n  check_poly_ge p (q1 @ q2)\n  d \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       mc # p \\<ge>p q", "from Cons(1)[OF rec]"], ["proof (chain)\npicking this:\n  p \\<ge>p q1 @ q2", "have p: \"p \\<ge>p q1 @ q2\""], ["proof (prove)\nusing this:\n  p \\<ge>p q1 @ q2\n\ngoal (1 subgoal):\n 1. p \\<ge>p q1 @ q2", "."], ["proof (state)\nthis:\n  p \\<ge>p q1 @ q2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.extract (\\<lambda>mc. fst mc = m) q = Some a \\<Longrightarrow>\n       mc # p \\<ge>p q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mc # p \\<ge>p q", "proof (simp only: mc, unfold poly_ge_def, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "fix \\<alpha> :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "assume pos: \"pos_assign \\<alpha>\""], ["proof (state)\nthis:\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "have ge: \"eval_monom \\<alpha> m * c \\<ge> eval_monom \\<alpha> m * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c", "using times_right_mono[OF pos_assign_monom[OF pos, of m] c]"], ["proof (prove)\nusing this:\n  eval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c", "by simp"], ["proof (state)\nthis:\n  eval_monom \\<alpha> m * d \\<le> eval_monom \\<alpha> m * c\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "from p"], ["proof (chain)\npicking this:\n  p \\<ge>p q1 @ q2", "have ge2: \"eval_poly \\<alpha> p \\<ge> eval_poly \\<alpha> (q1 @ q2)\""], ["proof (prove)\nusing this:\n  p \\<ge>p q1 @ q2\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p", "using pos"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p", "by auto"], ["proof (state)\nthis:\n  eval_poly \\<alpha> (q1 @ q2) \\<le> eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "show \"eval_poly \\<alpha> ((m,c) # p) \\<ge> eval_poly \\<alpha> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "using ge_trans[OF plus_left_mono[OF ge] plus_right_mono[OF ge2]]"], ["proof (prove)\nusing this:\n  eval_monom \\<alpha> m * d + eval_poly \\<alpha> (q1 @ q2)\n  \\<le> eval_monom \\<alpha> m * c + eval_poly \\<alpha> p\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)", "by (simp add: q field_simps)"], ["proof (state)\nthis:\n  eval_poly \\<alpha> q \\<le> eval_poly \\<alpha> ((m, c) # p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mc # p \\<ge>p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mc # p \\<ge>p q\n\ngoal:\nNo subgoals!", "qed"], ["", "declare check_poly_ge.simps[simp del]"], ["", "definition check_poly_weak_mono_all :: \"('v,'a :: ordered_semiring_0)poly \\<Rightarrow> bool\"\nwhere \"check_poly_weak_mono_all p \\<equiv> list_all (\\<lambda> (m,c). c \\<ge> 0) p\""], ["", "lemma check_poly_weak_mono_all: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_mono_all p\" shows  \"poly_weak_mono_all p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p", "unfolding poly_weak_mono_all_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>.\n       (\\<forall>x. \\<beta> x \\<le> \\<alpha> x) \\<longrightarrow>\n       pos_assign \\<beta> \\<longrightarrow>\n       eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "fix f g :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "assume fg: \"\\<forall> x. f x \\<ge> g x\"\n  and pos: \"pos_assign g\""], ["proof (state)\nthis:\n  \\<forall>x. g x \\<le> f x\n  pos_assign g\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "hence fg: \"\\<And> x. f x \\<ge> g x\""], ["proof (prove)\nusing this:\n  \\<forall>x. g x \\<le> f x\n  pos_assign g\n\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x", "by auto"], ["proof (state)\nthis:\n  g ?x \\<le> f ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "from pos[unfolded pos_assign_def]"], ["proof (chain)\npicking this:\n  \\<forall>x. (0::'a) \\<le> g x", "have g: \"\\<And> x. g x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x", ".."], ["proof (state)\nthis:\n  (0::'a) \\<le> g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "from assms"], ["proof (chain)\npicking this:\n  check_poly_weak_mono_all p", "have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> c \\<ge> 0\""], ["proof (prove)\nusing this:\n  check_poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c", "unfolding check_poly_weak_mono_all_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(m, c). (0::'a) \\<le> c) p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> c", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  (?m, ?c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x. \\<beta> x \\<le> \\<alpha> x;\n        pos_assign \\<beta>\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "thus \"eval_poly f p \\<ge> eval_poly g p\""], ["proof (prove)\nusing this:\n  (?m, ?c) \\<in> set p \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>m c.\n        (m, c) \\<in> set [] \\<Longrightarrow>\n        (0::'a) \\<le> c) \\<Longrightarrow>\n    eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    (0::'a) \\<le> c) \\<Longrightarrow>\n                eval_poly g p \\<le> eval_poly f p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           (0::'a) \\<le> c\\<rbrakk>\n       \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)", "case Nil"], ["proof (state)\nthis:\n  (?m, ?c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (2 subgoals):\n 1. (\\<And>m c.\n        (m, c) \\<in> set [] \\<Longrightarrow>\n        (0::'a) \\<le> c) \\<Longrightarrow>\n    eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    (0::'a) \\<le> c) \\<Longrightarrow>\n                eval_poly g p \\<le> eval_poly f p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           (0::'a) \\<le> c\\<rbrakk>\n       \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)", "thus ?case"], ["proof (prove)\nusing this:\n  (?m, ?c) \\<in> set [] \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. eval_poly g [] \\<le> eval_poly f []", "by (simp add: ge_refl)"], ["proof (state)\nthis:\n  eval_poly g [] \\<le> eval_poly f []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    (0::'a) \\<le> c) \\<Longrightarrow>\n                eval_poly g p \\<le> eval_poly f p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           (0::'a) \\<le> c\\<rbrakk>\n       \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    (0::'a) \\<le> c) \\<Longrightarrow>\n                eval_poly g p \\<le> eval_poly f p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           (0::'a) \\<le> c\\<rbrakk>\n       \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)", "case (Cons mc p)"], ["proof (state)\nthis:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      (0::'a) \\<le> c) \\<Longrightarrow>\n  eval_poly g p \\<le> eval_poly f p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    (0::'a) \\<le> c) \\<Longrightarrow>\n                eval_poly g p \\<le> eval_poly f p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           (0::'a) \\<le> c\\<rbrakk>\n       \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)", "hence IH: \"eval_poly f p \\<ge> eval_poly g p\""], ["proof (prove)\nusing this:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      (0::'a) \\<le> c) \\<Longrightarrow>\n  eval_poly g p \\<le> eval_poly f p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "by auto"], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    (0::'a) \\<le> c) \\<Longrightarrow>\n                eval_poly g p \\<le> eval_poly f p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           (0::'a) \\<le> c\\<rbrakk>\n       \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (mc # p) \\<le> eval_poly f (mc # p)", "proof (cases mc)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mc = (a, b) \\<Longrightarrow>\n       eval_poly g (mc # p) \\<le> eval_poly f (mc # p)", "case (Pair m c)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mc = (a, b) \\<Longrightarrow>\n       eval_poly g (mc # p) \\<le> eval_poly f (mc # p)", "with Cons"], ["proof (chain)\npicking this:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      (0::'a) \\<le> c) \\<Longrightarrow>\n  eval_poly g p \\<le> eval_poly f p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\n  mc = (m, c)", "have c: \"c \\<ge> 0\""], ["proof (prove)\nusing this:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      (0::'a) \\<le> c) \\<Longrightarrow>\n  eval_poly g p \\<le> eval_poly f p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow> (0::'a) \\<le> ?c\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mc = (a, b) \\<Longrightarrow>\n       eval_poly g (mc # p) \\<le> eval_poly f (mc # p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (mc # p) \\<le> eval_poly f (mc # p)", "unfolding Pair eval_poly.simps fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m * c + eval_poly g p\n    \\<le> eval_monom f m * c + eval_poly f p", "proof (rule ge_trans[OF plus_left_mono[OF times_left_mono[OF c]] plus_right_mono[OF IH]])"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_monom g m \\<le> eval_monom f m", "show \"eval_monom f m \\<ge> eval_monom g m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m \\<le> eval_monom f m", "by (rule eval_monom_mono(1)[OF fg g])"], ["proof (state)\nthis:\n  eval_monom g m \\<le> eval_monom f m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly g (mc # p) \\<le> eval_poly f (mc # p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly g (mc # p) \\<le> eval_poly f (mc # p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_poly_weak_mono_all_pos: \n  assumes \"check_poly_weak_mono_all p\" shows  \"p \\<ge>p zero_poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p zero_poly", "unfolding zero_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>p []", "proof (rule check_poly_ge)"], ["proof (state)\ngoal (1 subgoal):\n 1. check_poly_ge p []", "from assms"], ["proof (chain)\npicking this:\n  check_poly_weak_mono_all p", "have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> c \\<ge> 0\""], ["proof (prove)\nusing this:\n  check_poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> c", "unfolding check_poly_weak_mono_all_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(m, c). (0::'b) \\<le> c) p\n\ngoal (1 subgoal):\n 1. \\<And>m c. (m, c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> c", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  (?m, ?c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> ?c\n\ngoal (1 subgoal):\n 1. check_poly_ge p []", "thus \"check_poly_ge p []\""], ["proof (prove)\nusing this:\n  (?m, ?c) \\<in> set p \\<Longrightarrow> (0::'b) \\<le> ?c\n\ngoal (1 subgoal):\n 1. check_poly_ge p []", "by (induct p, simp add: check_poly_ge.simps,  clarify, auto simp: check_poly_ge.simps extract_Nil_code)"], ["proof (state)\nthis:\n  check_poly_ge p []\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>better check for weak monotonicity for discrete carriers: \n   $p$ is monotone in $v$ if $p(\\ldots v+1 \\ldots) \\geq p(\\ldots v \\ldots)$\\<close>"], ["", "definition check_poly_weak_mono_discrete :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_discrete p v \\<equiv> check_poly_ge (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p\""], ["", "definition check_poly_weak_mono_and_pos :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_and_pos discrete p \\<equiv> \n            if discrete then list_all (\\<lambda> v. check_poly_weak_mono_discrete p v) (poly_vars_list p) \\<and> eval_poly (\\<lambda> w. 0) p \\<ge>  0\n                        else check_poly_weak_mono_all p\""], ["", "definition check_poly_weak_anti_mono_discrete :: \"('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono_discrete p v \\<equiv> check_poly_ge p (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p)\""], ["", "context poly_order_carrier\nbegin"], ["", "lemma check_poly_weak_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_weak_mono_discrete p v\"\n  shows \"poly_weak_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v", "unfolding poly_weak_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>.\n       (\\<forall>x.\n           v \\<noteq> x \\<longrightarrow>\n           \\<alpha> x = \\<beta> x) \\<longrightarrow>\n       pos_assign \\<beta> \\<longrightarrow>\n       \\<beta> v \\<le> \\<alpha> v \\<longrightarrow>\n       eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "fix f g :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and gass: \"pos_assign g\"\n  and v: \"f v \\<ge> g v\""], ["proof (state)\nthis:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n  pos_assign g\n  g v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "from fgw"], ["proof (chain)\npicking this:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w", "have w: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\""], ["proof (prove)\nusing this:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n\ngoal (1 subgoal):\n 1. \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "from assms check_poly_ge"], ["proof (chain)\npicking this:\n  discrete\n  check_poly_weak_mono_discrete p v\n  check_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q", "have ge: \"poly_ge (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p\" (is \"poly_ge ?p1 p\")"], ["proof (prove)\nusing this:\n  discrete\n  check_poly_weak_mono_discrete p v\n  check_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p \\<ge>p\n    p", "unfolding check_poly_weak_mono_discrete_def"], ["proof (prove)\nusing this:\n  discrete\n  check_poly_ge\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n   p\n  check_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p \\<ge>p\n    p", "by blast"], ["proof (state)\nthis:\n  poly_subst\n   (\\<lambda>w.\n       poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n   p \\<ge>p\n  p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "from discrete[OF \\<open>discrete\\<close> v]"], ["proof (chain)\npicking this:\n  \\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)", "obtain k' where id: \"f v = (((+) 1)^^k') (g v)\""], ["proof (prove)\nusing this:\n  \\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        f v = ((+) (1::'a) ^^ k') (g v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "show \"eval_poly f p \\<ge> eval_poly g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "proof (cases k')"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "case 0"], ["proof (state)\nthis:\n  k' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "{"], ["proof (state)\nthis:\n  k' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "have \"f x = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = g x", "using id 0 w"], ["proof (prove)\nusing this:\n  f v = ((+) (1::'a) ^^ k') (g v)\n  k' = 0\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. f x = g x", "by (cases \"x = v\", auto)"], ["proof (state)\nthis:\n  f x = g x\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "}"], ["proof (state)\nthis:\n  f ?x5 = g ?x5\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "hence \"f = g\""], ["proof (prove)\nusing this:\n  f ?x5 = g ?x5\n\ngoal (1 subgoal):\n 1. f = g", ".."], ["proof (state)\nthis:\n  f = g\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = g\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "using ge_refl"], ["proof (prove)\nusing this:\n  f = g\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "by simp"], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "case (Suc k)"], ["proof (state)\nthis:\n  k' = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "with id"], ["proof (chain)\npicking this:\n  f v = ((+) (1::'a) ^^ k') (g v)\n  k' = Suc k", "have \"f v = (((+) 1)^^(Suc k))  (g v)\""], ["proof (prove)\nusing this:\n  f v = ((+) (1::'a) ^^ k') (g v)\n  k' = Suc k\n\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc k) (g v)", "by simp"], ["proof (state)\nthis:\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "with w gass"], ["proof (chain)\npicking this:\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)", "show \"eval_poly f p \\<ge> eval_poly g p\""], ["proof (prove)\nusing this:\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "proof (induct k arbitrary: f g rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f g.\n       \\<lbrakk>\\<And>y f g.\n                   \\<lbrakk>y < x;\n                    \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w;\n                    pos_assign g;\n                    f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk>\n                   \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p;\n        \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g;\n        f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk>\n       \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "case (less k)"], ["proof (state)\nthis:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>x f g.\n       \\<lbrakk>\\<And>y f g.\n                   \\<lbrakk>y < x;\n                    \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w;\n                    pos_assign g;\n                    f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk>\n                   \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p;\n        \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g;\n        f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk>\n       \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "with less"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  k = 0", "have id0: \"f v = 1 + g v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  k = 0\n\ngoal (1 subgoal):\n 1. f v = (1::'a) + g v", "by simp"], ["proof (state)\nthis:\n  f v = (1::'a) + g v\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "have id1: \"eval_poly f p = eval_poly g ?p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p =\n    eval_poly g\n     (poly_subst\n       (\\<lambda>w.\n           poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n       p)", "proof (rule eval_poly_subst)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       f w =\n       eval_poly g\n        (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       f w =\n       eval_poly g\n        (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "show \"f w = eval_poly g (poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "proof (cases \"w = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "case True"], ["proof (state)\nthis:\n  w = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "by (simp add: True id0 zero_poly_def)"], ["proof (state)\nthis:\n  f w =\n  eval_poly g\n   (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "case False"], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "with less"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  w \\<noteq> v", "have \"f w = g w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. f w = g w", "by simp"], ["proof (state)\nthis:\n  f w = g w\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "thus ?thesis"], ["proof (prove)\nusing this:\n  f w = g w\n\ngoal (1 subgoal):\n 1. f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "by (simp add: False)"], ["proof (state)\nthis:\n  f w =\n  eval_poly g\n   (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f w =\n  eval_poly g\n   (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f p =\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "have \"eval_poly g ?p1 \\<ge> eval_poly g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p\n    \\<le> eval_poly g\n           (poly_subst\n             (\\<lambda>w.\n                 poly_of\n                  (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n             p)", "using ge less"], ["proof (prove)\nusing this:\n  poly_subst\n   (\\<lambda>w.\n       poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n   p \\<ge>p\n  p\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g p\n    \\<le> eval_poly g\n           (poly_subst\n             (\\<lambda>w.\n                 poly_of\n                  (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n             p)", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> p\n     \\<le> eval_poly \\<alpha>\n            (poly_subst\n              (\\<lambda>w.\n                  poly_of\n                   (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n              p)\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?g3 p \\<le> eval_poly ?f3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g p\n    \\<le> eval_poly g\n           (poly_subst\n             (\\<lambda>w.\n                 poly_of\n                  (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n             p)", "by simp"], ["proof (state)\nthis:\n  eval_poly g p\n  \\<le> eval_poly g\n         (poly_subst\n           (\\<lambda>w.\n               poly_of\n                (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n           p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "with id1"], ["proof (chain)\npicking this:\n  eval_poly f p =\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n  eval_poly g p\n  \\<le> eval_poly g\n         (poly_subst\n           (\\<lambda>w.\n               poly_of\n                (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n           p)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_poly f p =\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n  eval_poly g p\n  \\<le> eval_poly g\n         (poly_subst\n           (\\<lambda>w.\n               poly_of\n                (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n           p)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "by simp"], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "case (Suc kk)"], ["proof (state)\nthis:\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "obtain g' where g': \"g' = (\\<lambda> w. if (w = v) then 1 + g w else g w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        g' =\n        (\\<lambda>w. if w = v then (1::'a) + g w else g w) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "have \"(1 :: 'a) + g v \\<ge> 1 + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) \\<le> (1::'a) + g v", "by (rule plus_right_mono, simp add: less(3)[unfolded pos_assign_def])"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "also"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "have \"1 + (0 :: 'a) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) = (1::'a)", "by simp"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "also"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "have \"\\<dots> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (1::'a)", "by (rule one_ge_zero)"], ["proof (state)\nthis:\n  (0::'a) \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "finally"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> (1::'a) + g v", "have g'pos: \"pos_assign g'\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. pos_assign g'", "using less(3)"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (1::'a) + g v\n  pos_assign g\n\ngoal (1 subgoal):\n 1. pos_assign g'", "unfolding pos_assign_def"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (1::'a) + g v\n  \\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> g' x", "by (simp add: g')"], ["proof (state)\nthis:\n  pos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "{"], ["proof (state)\nthis:\n  pos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "assume \"v \\<noteq> w\""], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "hence \"f w = g' w\""], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = g' w", "unfolding g'"], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = (if w = v then (1::'a) + g w else g w)", "by (simp add: less)"], ["proof (state)\nthis:\n  f w = g' w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "}"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "note w = this"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "have eq: \"f v = ((+) (1 :: 'a) ^^ Suc kk) ((g' v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc kk) (g' v)", "by (simp add: less(4) g' Suc, rule arg_cong[where f = \"(+) 1\"], induct kk, auto)"], ["proof (state)\nthis:\n  f v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "from Suc"], ["proof (chain)\npicking this:\n  k = Suc kk", "have kk: \"kk < k\""], ["proof (prove)\nusing this:\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. kk < k", "by simp"], ["proof (state)\nthis:\n  kk < k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "from less(1)[OF kk w g'pos] eq"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly g' p \\<le> eval_poly f p\n  f v = ((+) (1::'a) ^^ Suc kk) (g' v)", "have rec1: \"eval_poly f p \\<ge> eval_poly g' p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly g' p \\<le> eval_poly f p\n  f v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. eval_poly g' p \\<le> eval_poly f p", "by simp"], ["proof (state)\nthis:\n  eval_poly g' p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "{"], ["proof (state)\nthis:\n  eval_poly g' p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "assume \"v \\<noteq> w\""], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "hence \"g' w = g w\""], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. g' w = g w", "unfolding g'"], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. (if w = v then (1::'a) + g w else g w) = g w", "by simp"], ["proof (state)\nthis:\n  g' w = g w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "}"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "note w = this"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "from Suc"], ["proof (chain)\npicking this:\n  k = Suc kk", "have z: \"0 < k\""], ["proof (prove)\nusing this:\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. 0 < k", "by simp"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "from less(1)[OF z w less(3)] g'"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly g p \\<le> eval_poly g' p\n  g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)", "have rec2: \"eval_poly g' p \\<ge> eval_poly g p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly g p \\<le> eval_poly g' p\n  g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly g' p", "by simp"], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly g p \\<le> eval_poly f p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "by (rule ge_trans[OF rec1 rec2])"], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_poly_weak_anti_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_weak_anti_mono_discrete p v\"\n  shows \"poly_weak_anti_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_anti_mono p v", "unfolding poly_weak_anti_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>.\n       (\\<forall>x.\n           v \\<noteq> x \\<longrightarrow>\n           \\<alpha> x = \\<beta> x) \\<longrightarrow>\n       pos_assign \\<beta> \\<longrightarrow>\n       \\<beta> v \\<le> \\<alpha> v \\<longrightarrow>\n       eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "fix f g :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and gass: \"pos_assign g\"\n  and v: \"f v \\<ge> g v\""], ["proof (state)\nthis:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n  pos_assign g\n  g v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "from fgw"], ["proof (chain)\npicking this:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w", "have w: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\""], ["proof (prove)\nusing this:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n\ngoal (1 subgoal):\n 1. \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "from assms check_poly_ge"], ["proof (chain)\npicking this:\n  discrete\n  check_poly_weak_anti_mono_discrete p v\n  check_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q", "have ge: \"poly_ge p (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p)\" (is \"poly_ge p ?p1\")"], ["proof (prove)\nusing this:\n  discrete\n  check_poly_weak_anti_mono_discrete p v\n  check_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. p \\<ge>p\n    poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p", "unfolding check_poly_weak_anti_mono_discrete_def"], ["proof (prove)\nusing this:\n  discrete\n  check_poly_ge p\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n  check_poly_ge ?p ?q \\<Longrightarrow> ?p \\<ge>p ?q\n\ngoal (1 subgoal):\n 1. p \\<ge>p\n    poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p", "by blast"], ["proof (state)\nthis:\n  p \\<ge>p\n  poly_subst\n   (\\<lambda>w.\n       poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n   p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "from discrete[OF \\<open>discrete\\<close> v]"], ["proof (chain)\npicking this:\n  \\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)", "obtain k' where id: \"f v = (((+) 1)^^k') (g v)\""], ["proof (prove)\nusing this:\n  \\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        f v = ((+) (1::'a) ^^ k') (g v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "show \"eval_poly g p \\<ge> eval_poly f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p", "proof (cases k')"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "case 0"], ["proof (state)\nthis:\n  k' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "{"], ["proof (state)\nthis:\n  k' = 0\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "have \"f x = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = g x", "using id 0 w"], ["proof (prove)\nusing this:\n  f v = ((+) (1::'a) ^^ k') (g v)\n  k' = 0\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. f x = g x", "by (cases \"x = v\", auto)"], ["proof (state)\nthis:\n  f x = g x\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "}"], ["proof (state)\nthis:\n  f ?x5 = g ?x5\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "hence \"f = g\""], ["proof (prove)\nusing this:\n  f ?x5 = g ?x5\n\ngoal (1 subgoal):\n 1. f = g", ".."], ["proof (state)\nthis:\n  f = g\n\ngoal (2 subgoals):\n 1. k' = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = g\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p", "using ge_refl"], ["proof (prove)\nusing this:\n  f = g\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p", "by simp"], ["proof (state)\nthis:\n  eval_poly f p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "case (Suc k)"], ["proof (state)\nthis:\n  k' = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "with id"], ["proof (chain)\npicking this:\n  f v = ((+) (1::'a) ^^ k') (g v)\n  k' = Suc k", "have \"f v = (((+) 1)^^(Suc k))  (g v)\""], ["proof (prove)\nusing this:\n  f v = ((+) (1::'a) ^^ k') (g v)\n  k' = Suc k\n\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc k) (g v)", "by simp"], ["proof (state)\nthis:\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k' = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "with w gass"], ["proof (chain)\npicking this:\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)", "show \"eval_poly g p \\<ge> eval_poly f p\""], ["proof (prove)\nusing this:\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p", "proof (induct k arbitrary: f g rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f g.\n       \\<lbrakk>\\<And>y f g.\n                   \\<lbrakk>y < x;\n                    \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w;\n                    pos_assign g;\n                    f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk>\n                   \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p;\n        \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g;\n        f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk>\n       \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "case (less k)"], ["proof (state)\nthis:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>x f g.\n       \\<lbrakk>\\<And>y f g.\n                   \\<lbrakk>y < x;\n                    \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w;\n                    pos_assign g;\n                    f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk>\n                   \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p;\n        \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g;\n        f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk>\n       \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "with less"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  k = 0", "have id0: \"f v = 1 + g v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  k = 0\n\ngoal (1 subgoal):\n 1. f v = (1::'a) + g v", "by simp"], ["proof (state)\nthis:\n  f v = (1::'a) + g v\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "have id1: \"eval_poly f p = eval_poly g ?p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p =\n    eval_poly g\n     (poly_subst\n       (\\<lambda>w.\n           poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n       p)", "proof (rule eval_poly_subst)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       f w =\n       eval_poly g\n        (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       f w =\n       eval_poly g\n        (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "show \"f w = eval_poly g (poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "proof (cases \"w = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "case True"], ["proof (state)\nthis:\n  w = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "by (simp add: True id0 zero_poly_def)"], ["proof (state)\nthis:\n  f w =\n  eval_poly g\n   (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "case False"], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "with less"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  w \\<noteq> v", "have \"f w = g w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. f w = g w", "by simp"], ["proof (state)\nthis:\n  f w = g w\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "thus ?thesis"], ["proof (prove)\nusing this:\n  f w = g w\n\ngoal (1 subgoal):\n 1. f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "by (simp add: False)"], ["proof (state)\nthis:\n  f w =\n  eval_poly g\n   (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f w =\n  eval_poly g\n   (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f p =\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "have \"eval_poly g p \\<ge> eval_poly g ?p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g\n     (poly_subst\n       (\\<lambda>w.\n           poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n       p)\n    \\<le> eval_poly g p", "using ge less"], ["proof (prove)\nusing this:\n  p \\<ge>p\n  poly_subst\n   (\\<lambda>w.\n       poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n   p\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g\n     (poly_subst\n       (\\<lambda>w.\n           poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n       p)\n    \\<le> eval_poly g p", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha>\n      (poly_subst\n        (\\<lambda>w.\n            poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n        p)\n     \\<le> eval_poly \\<alpha> p\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<le> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g\n     (poly_subst\n       (\\<lambda>w.\n           poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n       p)\n    \\<le> eval_poly g p", "by simp"], ["proof (state)\nthis:\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n  \\<le> eval_poly g p\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "with id1"], ["proof (chain)\npicking this:\n  eval_poly f p =\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n  \\<le> eval_poly g p", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_poly f p =\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n  \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p", "by simp"], ["proof (state)\nthis:\n  eval_poly f p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "case (Suc kk)"], ["proof (state)\nthis:\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "obtain g' where g': \"g' = (\\<lambda> w. if (w = v) then 1 + g w else g w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        g' =\n        (\\<lambda>w. if w = v then (1::'a) + g w else g w) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "have \"(1 :: 'a) + g v \\<ge> 1 + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) \\<le> (1::'a) + g v", "by (rule plus_right_mono, simp add: less(3)[unfolded pos_assign_def])"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "also"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "have \"(1 :: 'a) + 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) = (1::'a)", "by simp"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "also"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "have \"\\<dots> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (1::'a)", "by (rule one_ge_zero)"], ["proof (state)\nthis:\n  (0::'a) \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "finally"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> (1::'a) + g v", "have g'pos: \"pos_assign g'\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. pos_assign g'", "using less(3)"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (1::'a) + g v\n  pos_assign g\n\ngoal (1 subgoal):\n 1. pos_assign g'", "unfolding pos_assign_def"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (1::'a) + g v\n  \\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> g' x", "by (simp add: g')"], ["proof (state)\nthis:\n  pos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "{"], ["proof (state)\nthis:\n  pos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "assume \"v \\<noteq> w\""], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "hence \"f w = g' w\""], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = g' w", "unfolding g'"], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = (if w = v then (1::'a) + g w else g w)", "by (simp add: less)"], ["proof (state)\nthis:\n  f w = g' w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "}"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "note w = this"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "have eq: \"f v = ((+) (1 :: 'a) ^^ Suc kk) ((g' v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc kk) (g' v)", "by (simp add: less(4) g' Suc, rule arg_cong[where f = \"(+) 1\"], induct kk, auto)"], ["proof (state)\nthis:\n  f v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "from Suc"], ["proof (chain)\npicking this:\n  k = Suc kk", "have kk: \"kk < k\""], ["proof (prove)\nusing this:\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. kk < k", "by simp"], ["proof (state)\nthis:\n  kk < k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "from less(1)[OF kk w g'pos] eq"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly f p \\<le> eval_poly g' p\n  f v = ((+) (1::'a) ^^ Suc kk) (g' v)", "have rec1: \"eval_poly g' p \\<ge> eval_poly f p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly f p \\<le> eval_poly g' p\n  f v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g' p", "by simp"], ["proof (state)\nthis:\n  eval_poly f p \\<le> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "{"], ["proof (state)\nthis:\n  eval_poly f p \\<le> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "assume \"v \\<noteq> w\""], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "hence \"g' w = g w\""], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. g' w = g w", "unfolding g'"], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. (if w = v then (1::'a) + g w else g w) = g w", "by simp"], ["proof (state)\nthis:\n  g' w = g w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "}"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "note w = this"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "from Suc"], ["proof (chain)\npicking this:\n  k = Suc kk", "have z: \"0 < k\""], ["proof (prove)\nusing this:\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. 0 < k", "by simp"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "from less(1)[OF z w less(3)] g'"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly g' p \\<le> eval_poly g p\n  g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)", "have rec2: \"eval_poly g p \\<ge> eval_poly g' p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly g' p \\<le> eval_poly g p\n  g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. eval_poly g' p \\<le> eval_poly g p", "by simp"], ["proof (state)\nthis:\n  eval_poly g' p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<le> eval_poly g p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p", "by (rule ge_trans[OF rec2 rec1])"], ["proof (state)\nthis:\n  eval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_poly_weak_mono_and_pos: \n  fixes p :: \"('v :: linorder,'a)poly\"\n  assumes \"check_poly_weak_mono_and_pos discrete p\"\n  shows \"poly_weak_mono_all p \\<and> (p \\<ge>p zero_poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "proof (cases discrete)"], ["proof (state)\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n 2. \\<not> discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "case False"], ["proof (state)\nthis:\n  \\<not> discrete\n\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n 2. \\<not> discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "with assms"], ["proof (chain)\npicking this:\n  check_poly_weak_mono_and_pos discrete p\n  \\<not> discrete", "have c: \"check_poly_weak_mono_all p\""], ["proof (prove)\nusing this:\n  check_poly_weak_mono_and_pos discrete p\n  \\<not> discrete\n\ngoal (1 subgoal):\n 1. check_poly_weak_mono_all p", "unfolding check_poly_weak_mono_and_pos_def"], ["proof (prove)\nusing this:\n  if discrete\n  then list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) \\<and>\n       (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p\n  else check_poly_weak_mono_all p\n  \\<not> discrete\n\ngoal (1 subgoal):\n 1. check_poly_weak_mono_all p", "by auto"], ["proof (state)\nthis:\n  check_poly_weak_mono_all p\n\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n 2. \\<not> discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "from check_poly_weak_mono_all[OF c] check_poly_weak_mono_all_pos[OF c]"], ["proof (chain)\npicking this:\n  poly_weak_mono_all p\n  p \\<ge>p zero_poly", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_weak_mono_all p\n  p \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "by auto"], ["proof (state)\nthis:\n  poly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "case True"], ["proof (state)\nthis:\n  discrete\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "with assms"], ["proof (chain)\npicking this:\n  check_poly_weak_mono_and_pos discrete p\n  discrete", "have c: \"list_all (\\<lambda> v. check_poly_weak_mono_discrete p v) (poly_vars_list p)\" and g: \"eval_poly (\\<lambda> w. 0) p \\<ge> 0\""], ["proof (prove)\nusing this:\n  check_poly_weak_mono_and_pos discrete p\n  discrete\n\ngoal (1 subgoal):\n 1. list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) &&&\n    (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p", "unfolding check_poly_weak_mono_and_pos_def"], ["proof (prove)\nusing this:\n  if discrete\n  then list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) \\<and>\n       (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p\n  else check_poly_weak_mono_all p\n  discrete\n\ngoal (1 subgoal):\n 1. list_all (check_poly_weak_mono_discrete p) (poly_vars_list p) &&&\n    (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p", "by auto"], ["proof (state)\nthis:\n  list_all (check_poly_weak_mono_discrete p) (poly_vars_list p)\n  (0::'a) \\<le> eval_poly (\\<lambda>w. 0::'a) p\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "have m: \"poly_weak_mono_all p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p", "proof (rule poly_weak_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v", "fix v :: 'v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v", "assume v: \"v \\<in> poly_vars p\""], ["proof (state)\nthis:\n  v \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v", "show \"poly_weak_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v", "by (rule check_poly_weak_mono_discrete[OF True], insert c[unfolded list_all_iff] v, auto)"], ["proof (state)\nthis:\n  poly_weak_mono p v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "have m': \"poly_weak_mono_all  p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono_all p", "proof (rule poly_weak_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v", "fix v :: 'v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v", "assume v: \"v \\<in> poly_vars p\""], ["proof (state)\nthis:\n  v \\<in> poly_vars p\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> poly_vars p \\<Longrightarrow> poly_weak_mono p v", "show \"poly_weak_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v", "by (rule check_poly_weak_mono_discrete[OF True], insert c[unfolded list_all_iff] v, auto)"], ["proof (state)\nthis:\n  poly_weak_mono p v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. discrete \\<Longrightarrow>\n    poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "from poly_weak_mono_all_pos[OF g m'] m"], ["proof (chain)\npicking this:\n  p \\<ge>p zero_poly\n  poly_weak_mono_all p", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<ge>p zero_poly\n  poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. poly_weak_mono_all p \\<and> p \\<ge>p zero_poly", "by auto"], ["proof (state)\nthis:\n  poly_weak_mono_all p \\<and> p \\<ge>p zero_poly\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition check_poly_weak_mono :: \"('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono p v \\<equiv> list_all (\\<lambda> (m,c). c \\<ge> 0 \\<or> v \\<notin> monom_vars m) p\""], ["", "lemma check_poly_weak_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_mono p v\" shows  \"poly_weak_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_mono p v", "unfolding poly_weak_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>.\n       (\\<forall>x.\n           v \\<noteq> x \\<longrightarrow>\n           \\<alpha> x = \\<beta> x) \\<longrightarrow>\n       pos_assign \\<beta> \\<longrightarrow>\n       \\<beta> v \\<le> \\<alpha> v \\<longrightarrow>\n       eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "fix f g :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "assume \"\\<forall> x. v \\<noteq> x \\<longrightarrow> f x = g x\"\n  and pos: \"pos_assign g\" \n  and ge: \"f v \\<ge> g v\""], ["proof (state)\nthis:\n  \\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\n  pos_assign g\n  g v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "hence fg: \"\\<And> x. v \\<noteq> x \\<Longrightarrow> f x = g x\""], ["proof (prove)\nusing this:\n  \\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\n  pos_assign g\n  g v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> f x = g x", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> ?x \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "from pos[unfolded pos_assign_def]"], ["proof (chain)\npicking this:\n  \\<forall>x. (0::'a) \\<le> g x", "have g: \"\\<And> x. g x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x", ".."], ["proof (state)\nthis:\n  (0::'a) \\<le> g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "from assms"], ["proof (chain)\npicking this:\n  check_poly_weak_mono p v", "have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> c \\<ge> 0 \\<or> v \\<notin> monom_vars m\""], ["proof (prove)\nusing this:\n  check_poly_weak_mono p v\n\ngoal (1 subgoal):\n 1. \\<And>m c.\n       (m, c) \\<in> set p \\<Longrightarrow>\n       (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m", "unfolding check_poly_weak_mono_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(m, c). (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m)\n   p\n\ngoal (1 subgoal):\n 1. \\<And>m c.\n       (m, c) \\<in> set p \\<Longrightarrow>\n       (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  (?m, ?c) \\<in> set p \\<Longrightarrow>\n  (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<beta> p \\<le> eval_poly \\<alpha> p", "thus \"eval_poly f p \\<ge> eval_poly g p\""], ["proof (prove)\nusing this:\n  (?m, ?c) \\<in> set p \\<Longrightarrow>\n  (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>m c.\n        (m, c) \\<in> set [] \\<Longrightarrow>\n        (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n    eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    (0::'a) \\<le> c \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly g p \\<le> eval_poly f p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)", "case (Cons mc p)"], ["proof (state)\nthis:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n  eval_poly g p \\<le> eval_poly f p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow>\n  (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (2 subgoals):\n 1. (\\<And>m c.\n        (m, c) \\<in> set [] \\<Longrightarrow>\n        (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n    eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    (0::'a) \\<le> c \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly g p \\<le> eval_poly f p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)", "hence IH: \"eval_poly f p \\<ge> eval_poly g p\""], ["proof (prove)\nusing this:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n  eval_poly g p \\<le> eval_poly f p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow>\n  (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "by auto"], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal (2 subgoals):\n 1. (\\<And>m c.\n        (m, c) \\<in> set [] \\<Longrightarrow>\n        (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n    eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    (0::'a) \\<le> c \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly g p \\<le> eval_poly f p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (2 subgoals):\n 1. (\\<And>m c.\n        (m, c) \\<in> set [] \\<Longrightarrow>\n        (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n    eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    (0::'a) \\<le> c \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly g p \\<le> eval_poly f p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)", "with Cons"], ["proof (chain)\npicking this:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n  eval_poly g p \\<le> eval_poly f p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow>\n  (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n  mc = (m, c)", "have c: \"c \\<ge> 0 \\<or> v \\<notin> monom_vars m\""], ["proof (prove)\nusing this:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n  eval_poly g p \\<le> eval_poly f p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow>\n  (0::'a) \\<le> ?c \\<or> v \\<notin> monom_vars ?m\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\n\ngoal (2 subgoals):\n 1. (\\<And>m c.\n        (m, c) \\<in> set [] \\<Longrightarrow>\n        (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n    eval_poly g [] \\<le> eval_poly f []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    (0::'a) \\<le> c \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly g p \\<le> eval_poly f p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly g (a # p) \\<le> eval_poly f (a # p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g (mc # p) \\<le> eval_poly f (mc # p)", "unfolding mc eval_poly.simps fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m * c + eval_poly g p\n    \\<le> eval_monom f m * c + eval_poly f p", "proof (rule ge_trans[OF plus_left_mono plus_right_mono[OF IH]])"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c", "from c"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m", "show \"eval_monom f m * c \\<ge> eval_monom g m * c\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> c \\<Longrightarrow>\n    eval_monom g m * c \\<le> eval_monom f m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom g m * c \\<le> eval_monom f m * c", "assume c: \"c \\<ge> 0\""], ["proof (state)\nthis:\n  (0::'a) \\<le> c\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> c \\<Longrightarrow>\n    eval_monom g m * c \\<le> eval_monom f m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom g m * c \\<le> eval_monom f m * c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c", "proof (rule times_left_mono[OF c], rule eval_monom_mono(1)[OF _ g])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x", "show \"f x \\<ge> g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x \\<le> f x", "using ge fg[of x]"], ["proof (prove)\nusing this:\n  g v \\<le> f v\n  v \\<noteq> x \\<Longrightarrow> f x = g x\n\ngoal (1 subgoal):\n 1. g x \\<le> f x", "by (cases \"x = v\", auto simp: ge_refl)"], ["proof (state)\nthis:\n  g x \\<le> f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_monom g m * c \\<le> eval_monom f m * c\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom g m * c \\<le> eval_monom f m * c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom g m * c \\<le> eval_monom f m * c", "assume v: \"v \\<notin> monom_vars m\""], ["proof (state)\nthis:\n  v \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom g m * c \\<le> eval_monom f m * c", "have \"eval_monom f m = eval_monom g m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m = eval_monom g m", "by (rule monom_vars_eval_monom, insert fg v, fast)"], ["proof (state)\nthis:\n  eval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom g m * c \\<le> eval_monom f m * c", "thus ?thesis"], ["proof (prove)\nusing this:\n  eval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c", "by (simp add: ge_refl)"], ["proof (state)\nthis:\n  eval_monom g m * c \\<le> eval_monom f m * c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_monom g m * c \\<le> eval_monom f m * c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly g (mc # p) \\<le> eval_poly f (mc # p)\n\ngoal (1 subgoal):\n 1. (\\<And>m c.\n        (m, c) \\<in> set [] \\<Longrightarrow>\n        (0::'a) \\<le> c \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n    eval_poly g [] \\<le> eval_poly f []", "qed (simp add: ge_refl)"], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal:\nNo subgoals!", "qed"], ["", "definition check_poly_weak_mono_smart :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_mono_smart discrete \\<equiv> if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono\""], ["", "lemma (in poly_order_carrier) check_poly_weak_mono_smart: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_weak_mono_smart discrete p v \\<Longrightarrow> poly_weak_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_poly_weak_mono_smart discrete p v \\<Longrightarrow>\n    poly_weak_mono p v", "unfolding check_poly_weak_mono_smart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_mono_discrete\n     else check_poly_weak_mono)\n     p v \\<Longrightarrow>\n    poly_weak_mono p v", "using check_poly_weak_mono check_poly_weak_mono_discrete"], ["proof (prove)\nusing this:\n  check_poly_weak_mono ?p ?v \\<Longrightarrow> poly_weak_mono ?p ?v\n  \\<lbrakk>discrete; check_poly_weak_mono_discrete ?p ?v\\<rbrakk>\n  \\<Longrightarrow> poly_weak_mono ?p ?v\n\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_mono_discrete\n     else check_poly_weak_mono)\n     p v \\<Longrightarrow>\n    poly_weak_mono p v", "by (cases discrete, auto)"], ["", "definition check_poly_weak_anti_mono :: \"('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono p v \\<equiv> list_all (\\<lambda> (m,c). 0 \\<ge> c \\<or> v \\<notin> monom_vars m) p\""], ["", "lemma check_poly_weak_anti_mono: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  assumes \"check_poly_weak_anti_mono p v\" shows  \"poly_weak_anti_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_weak_anti_mono p v", "unfolding poly_weak_anti_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>.\n       (\\<forall>x.\n           v \\<noteq> x \\<longrightarrow>\n           \\<alpha> x = \\<beta> x) \\<longrightarrow>\n       pos_assign \\<beta> \\<longrightarrow>\n       \\<beta> v \\<le> \\<alpha> v \\<longrightarrow>\n       eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "fix f g :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "assume \"\\<forall> x. v \\<noteq> x \\<longrightarrow> f x = g x\"\n  and pos: \"pos_assign g\" \n  and ge: \"f v \\<ge> g v\""], ["proof (state)\nthis:\n  \\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\n  pos_assign g\n  g v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "hence fg: \"\\<And> x. v \\<noteq> x \\<Longrightarrow> f x = g x\""], ["proof (prove)\nusing this:\n  \\<forall>x. v \\<noteq> x \\<longrightarrow> f x = g x\n  pos_assign g\n  g v \\<le> f v\n\ngoal (1 subgoal):\n 1. \\<And>x. v \\<noteq> x \\<Longrightarrow> f x = g x", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> ?x \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "from pos[unfolded pos_assign_def]"], ["proof (chain)\npicking this:\n  \\<forall>x. (0::'a) \\<le> g x", "have g: \"\\<And> x. g x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x", ".."], ["proof (state)\nthis:\n  (0::'a) \\<le> g ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "from assms"], ["proof (chain)\npicking this:\n  check_poly_weak_anti_mono p v", "have \"\\<And> m c. (m,c) \\<in> set p \\<Longrightarrow> 0 \\<ge> c \\<or> v \\<notin> monom_vars m\""], ["proof (prove)\nusing this:\n  check_poly_weak_anti_mono p v\n\ngoal (1 subgoal):\n 1. \\<And>m c.\n       (m, c) \\<in> set p \\<Longrightarrow>\n       c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m", "unfolding check_poly_weak_anti_mono_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(m, c). c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m)\n   p\n\ngoal (1 subgoal):\n 1. \\<And>m c.\n       (m, c) \\<in> set p \\<Longrightarrow>\n       c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  (?m, ?c) \\<in> set p \\<Longrightarrow>\n  ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<beta> v \\<le> \\<alpha> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<le> eval_poly \\<beta> p", "thus \"eval_poly g p \\<ge> eval_poly f p\""], ["proof (prove)\nusing this:\n  (?m, ?c) \\<in> set p \\<Longrightarrow>\n  ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>m c.\n        (m, c) \\<in> set [] \\<Longrightarrow>\n        c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n    eval_poly f [] \\<le> eval_poly g []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    c \\<le> (0::'a) \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly f p \\<le> eval_poly g p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)", "case Nil"], ["proof (state)\nthis:\n  (?m, ?c) \\<in> set [] \\<Longrightarrow>\n  ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (2 subgoals):\n 1. (\\<And>m c.\n        (m, c) \\<in> set [] \\<Longrightarrow>\n        c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n    eval_poly f [] \\<le> eval_poly g []\n 2. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    c \\<le> (0::'a) \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly f p \\<le> eval_poly g p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)", "thus ?case"], ["proof (prove)\nusing this:\n  (?m, ?c) \\<in> set [] \\<Longrightarrow>\n  ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly f [] \\<le> eval_poly g []", "by (simp add: ge_refl)"], ["proof (state)\nthis:\n  eval_poly f [] \\<le> eval_poly g []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    c \\<le> (0::'a) \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly f p \\<le> eval_poly g p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    c \\<le> (0::'a) \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly f p \\<le> eval_poly g p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)", "case (Cons mc p)"], ["proof (state)\nthis:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n  eval_poly f p \\<le> eval_poly g p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow>\n  ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    c \\<le> (0::'a) \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly f p \\<le> eval_poly g p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)", "hence IH: \"eval_poly g p \\<ge> eval_poly f p\""], ["proof (prove)\nusing this:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n  eval_poly f p \\<le> eval_poly g p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow>\n  ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<le> eval_poly g p", "by auto"], ["proof (state)\nthis:\n  eval_poly f p \\<le> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    c \\<le> (0::'a) \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly f p \\<le> eval_poly g p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    c \\<le> (0::'a) \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly f p \\<le> eval_poly g p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)", "with Cons"], ["proof (chain)\npicking this:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n  eval_poly f p \\<le> eval_poly g p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow>\n  ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n  mc = (m, c)", "have c: \"0 \\<ge> c \\<or> v \\<notin> monom_vars m\""], ["proof (prove)\nusing this:\n  (\\<And>m c.\n      (m, c) \\<in> set p \\<Longrightarrow>\n      c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m) \\<Longrightarrow>\n  eval_poly f p \\<le> eval_poly g p\n  (?m, ?c) \\<in> set (mc # p) \\<Longrightarrow>\n  ?c \\<le> (0::'a) \\<or> v \\<notin> monom_vars ?m\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m", "by auto"], ["proof (state)\nthis:\n  c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>(\\<And>m c.\n                    (m, c) \\<in> set p \\<Longrightarrow>\n                    c \\<le> (0::'a) \\<or>\n                    v \\<notin> monom_vars m) \\<Longrightarrow>\n                eval_poly f p \\<le> eval_poly g p;\n        \\<And>m c.\n           (m, c) \\<in> set (a # p) \\<Longrightarrow>\n           c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<le> eval_poly g (a # p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<le> eval_poly g (mc # p)", "unfolding mc eval_poly.simps fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m * c + eval_poly f p\n    \\<le> eval_monom g m * c + eval_poly g p", "proof (rule ge_trans[OF plus_left_mono plus_right_mono[OF IH]])"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c", "from c"], ["proof (chain)\npicking this:\n  c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m", "show \"eval_monom g m * c \\<ge> eval_monom f m * c\""], ["proof (prove)\nusing this:\n  c \\<le> (0::'a) \\<or> v \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<le> (0::'a) \\<Longrightarrow>\n    eval_monom f m * c \\<le> eval_monom g m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom f m * c \\<le> eval_monom g m * c", "assume c: \"0 \\<ge> c\""], ["proof (state)\nthis:\n  c \\<le> (0::'a)\n\ngoal (2 subgoals):\n 1. c \\<le> (0::'a) \\<Longrightarrow>\n    eval_monom f m * c \\<le> eval_monom g m * c\n 2. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom f m * c \\<le> eval_monom g m * c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c", "proof (rule times_left_anti_mono[OF eval_monom_mono(1)[OF _ g] c])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<le> f x", "show \"f x \\<ge> g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x \\<le> f x", "using ge fg[of x]"], ["proof (prove)\nusing this:\n  g v \\<le> f v\n  v \\<noteq> x \\<Longrightarrow> f x = g x\n\ngoal (1 subgoal):\n 1. g x \\<le> f x", "by (cases \"x = v\", auto simp: ge_refl)"], ["proof (state)\nthis:\n  g x \\<le> f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_monom f m * c \\<le> eval_monom g m * c\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom f m * c \\<le> eval_monom g m * c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom f m * c \\<le> eval_monom g m * c", "assume v: \"v \\<notin> monom_vars m\""], ["proof (state)\nthis:\n  v \\<notin> monom_vars m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom f m * c \\<le> eval_monom g m * c", "have \"eval_monom f m = eval_monom g m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom f m = eval_monom g m", "by (rule monom_vars_eval_monom, insert fg v, fast)"], ["proof (state)\nthis:\n  eval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. v \\<notin> monom_vars m \\<Longrightarrow>\n    eval_monom f m * c \\<le> eval_monom g m * c", "thus ?thesis"], ["proof (prove)\nusing this:\n  eval_monom f m = eval_monom g m\n\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<le> eval_monom g m * c", "by (simp add: ge_refl)"], ["proof (state)\nthis:\n  eval_monom f m * c \\<le> eval_monom g m * c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_monom f m * c \\<le> eval_monom g m * c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f (mc # p) \\<le> eval_poly g (mc # p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f p \\<le> eval_poly g p\n\ngoal:\nNo subgoals!", "qed"], ["", "definition check_poly_weak_anti_mono_smart :: \"bool \\<Rightarrow> ('v :: linorder,'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_weak_anti_mono_smart discrete \\<equiv> if discrete then check_poly_weak_anti_mono_discrete else check_poly_weak_anti_mono\""], ["", "lemma (in poly_order_carrier) check_poly_weak_anti_mono_smart: fixes p :: \"('v :: linorder,'a :: poly_carrier)poly\"\n  shows \"check_poly_weak_anti_mono_smart discrete p v \\<Longrightarrow> poly_weak_anti_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_poly_weak_anti_mono_smart discrete p v \\<Longrightarrow>\n    poly_weak_anti_mono p v", "unfolding check_poly_weak_anti_mono_smart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_anti_mono_discrete\n     else check_poly_weak_anti_mono)\n     p v \\<Longrightarrow>\n    poly_weak_anti_mono p v", "using check_poly_weak_anti_mono[of p v] check_poly_weak_anti_mono_discrete[of p v]"], ["proof (prove)\nusing this:\n  check_poly_weak_anti_mono p v \\<Longrightarrow> poly_weak_anti_mono p v\n  \\<lbrakk>discrete; check_poly_weak_anti_mono_discrete p v\\<rbrakk>\n  \\<Longrightarrow> poly_weak_anti_mono p v\n\ngoal (1 subgoal):\n 1. (if discrete then check_poly_weak_anti_mono_discrete\n     else check_poly_weak_anti_mono)\n     p v \\<Longrightarrow>\n    poly_weak_anti_mono p v", "by (cases discrete, auto)"], ["", "definition check_poly_gt :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a :: ordered_semiring_0)poly \\<Rightarrow> ('v,'a)poly \\<Rightarrow> bool\"\nwhere \"check_poly_gt gt p q \\<equiv> let (a1,p1) = poly_split 1 p; (b1,q1) = poly_split 1 q in gt a1 b1 \\<and> check_poly_ge p1 q1\""], ["", "fun univariate_power_list :: \"'v \\<Rightarrow> 'v monom_list \\<Rightarrow> nat option\" where\n  \"univariate_power_list x [(y,n)] = (if x = y then Some n else None)\" \n| \"univariate_power_list _ _ = None\""], ["", "lemma univariate_power_list: assumes \"monom_inv m\" \"univariate_power_list x m = Some n\" \n  shows \"sum_var_list m = (\\<lambda> y. if x = y then n else 0)\" \n   \"eval_monom_list \\<alpha> m = ((\\<alpha> x)^n)\" \n   \"n \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_var_list m = (\\<lambda>y. if x = y then n else 0) &&&\n    eval_monom_list \\<alpha> m = \\<alpha> x ^ n &&& 1 \\<le> n", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. sum_var_list m = (\\<lambda>y. if x = y then n else 0)\n 2. eval_monom_list \\<alpha> m = \\<alpha> x ^ n\n 3. 1 \\<le> n", "have m: \"m = [(x,n)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = [(x, n)]", "using assms"], ["proof (prove)\nusing this:\n  monom_inv m\n  univariate_power_list x m = Some n\n\ngoal (1 subgoal):\n 1. m = [(x, n)]", "by (induct x m rule: univariate_power_list.induct, auto split: if_splits)"], ["proof (state)\nthis:\n  m = [(x, n)]\n\ngoal (3 subgoals):\n 1. sum_var_list m = (\\<lambda>y. if x = y then n else 0)\n 2. eval_monom_list \\<alpha> m = \\<alpha> x ^ n\n 3. 1 \\<le> n", "show \"eval_monom_list \\<alpha> m = ((\\<alpha> x)^n)\" \"sum_var_list m = (\\<lambda> y. if x = y then n else 0)\"\n    \"n \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> m = \\<alpha> x ^ n &&&\n    sum_var_list m = (\\<lambda>y. if x = y then n else 0) &&& 1 \\<le> n", "using assms(1)"], ["proof (prove)\nusing this:\n  monom_inv m\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> m = \\<alpha> x ^ n &&&\n    sum_var_list m = (\\<lambda>y. if x = y then n else 0) &&& 1 \\<le> n", "unfolding m monom_inv_def"], ["proof (prove)\nusing this:\n  (\\<forall>(x, n)\\<in>set [(x, n)]. 1 \\<le> n) \\<and>\n  distinct (map fst [(x, n)]) \\<and> sorted (map fst [(x, n)])\n\ngoal (1 subgoal):\n 1. eval_monom_list \\<alpha> [(x, n)] = \\<alpha> x ^ n &&&\n    sum_var_list [(x, n)] = (\\<lambda>y. if x = y then n else 0) &&&\n    1 \\<le> n", "by (auto simp: sum_var_list_def)"], ["proof (state)\nthis:\n  eval_monom_list \\<alpha> m = \\<alpha> x ^ n\n  sum_var_list m = (\\<lambda>y. if x = y then n else 0)\n  1 \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition univariate_power :: \"'v :: linorder \\<Rightarrow> 'v monom \\<Rightarrow> nat option\" \n  is univariate_power_list"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma univariate_power: assumes \"univariate_power x m = Some n\" \n  shows \"sum_var m = (\\<lambda> y. if x = y then n else 0)\" \n   \"eval_monom \\<alpha> m = ((\\<alpha> x)^n)\"\n   \"n \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_var m = (\\<lambda>y. if x = y then n else 0) &&&\n    eval_monom \\<alpha> m = \\<alpha> x ^ n &&& 1 \\<le> n", "by (atomize(full), insert assms, transfer, auto dest: univariate_power_list)"], ["", "lemma univariate_power_var_monom: \"univariate_power y (var_monom x) = (if x = y then Some 1 else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. univariate_power y (var_monom x) = (if x = y then Some 1 else None)", "by (transfer, auto)"], ["", "definition check_monom_strict_mono :: \"bool \\<Rightarrow> 'v :: linorder monom \\<Rightarrow> 'v \\<Rightarrow> bool\" where\n  \"check_monom_strict_mono pm m v \\<equiv> case univariate_power v m of\n     Some p \\<Rightarrow> pm \\<or> p = 1\n   | None \\<Rightarrow> False\""], ["", "definition check_poly_strict_mono :: \"bool \\<Rightarrow> ('v :: linorder, 'a :: poly_carrier)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono pm p v \\<equiv> list_ex (\\<lambda> (m,c). (c \\<ge> 1) \\<and> check_monom_strict_mono pm m v) p\""], ["", "definition check_poly_strict_mono_discrete :: \"('a :: poly_carrier \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono_discrete gt p v \\<equiv> check_poly_gt gt (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p \""], ["", "definition check_poly_strict_mono_smart :: \"bool \\<Rightarrow> bool \\<Rightarrow> ('a :: poly_carrier \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('v :: linorder,'a)poly \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  where \"check_poly_strict_mono_smart discrete pm gt p v \\<equiv> \n            if discrete then check_poly_strict_mono_discrete gt p v else check_poly_strict_mono pm p v\""], ["", "context poly_order_carrier\nbegin"], ["", "lemma check_monom_strict_mono: fixes \\<alpha> \\<beta> :: \"('v :: linorder,'a)assign\" and v :: 'v and m :: \"'v monom\"\n  assumes check: \"check_monom_strict_mono power_mono m v\"\n  and gt: \"\\<alpha> v \\<succ> \\<beta> v\"\n  and ge: \"\\<beta> v \\<ge> 0\"\nshows \"eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "from check[unfolded check_monom_strict_mono_def]"], ["proof (chain)\npicking this:\n  case univariate_power v m of None \\<Rightarrow> False\n  | Some p \\<Rightarrow> power_mono \\<or> p = 1", "obtain n where\n    uni: \"univariate_power v m = Some n\" and 1: \"\\<not> power_mono \\<Longrightarrow> n = 1\""], ["proof (prove)\nusing this:\n  case univariate_power v m of None \\<Rightarrow> False\n  | Some p \\<Rightarrow> power_mono \\<or> p = 1\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>univariate_power v m = Some n;\n         \\<not> power_mono \\<Longrightarrow> n = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  univariate_power v m = Some n\n  \\<not> power_mono \\<Longrightarrow> n = 1\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "from univariate_power[OF uni]"], ["proof (chain)\npicking this:\n  sum_var m = (\\<lambda>y. if v = y then n else 0)\n  eval_monom ?\\<alpha> m = ?\\<alpha> v ^ n\n  1 \\<le> n", "have n1: \"n \\<ge> 1\" and eval: \"eval_monom a m = a v ^ n\" for a :: \"('v,'a)assign\""], ["proof (prove)\nusing this:\n  sum_var m = (\\<lambda>y. if v = y then n else 0)\n  eval_monom ?\\<alpha> m = ?\\<alpha> v ^ n\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. 1 \\<le> n &&& eval_monom a m = a v ^ n", "by auto"], ["proof (state)\nthis:\n  1 \\<le> n\n  eval_monom ?a3 m = ?a3 v ^ n\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "proof (cases power_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. power_mono \\<Longrightarrow>\n    eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n 2. \\<not> power_mono \\<Longrightarrow>\n    eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "case False"], ["proof (state)\nthis:\n  \\<not> power_mono\n\ngoal (2 subgoals):\n 1. power_mono \\<Longrightarrow>\n    eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n 2. \\<not> power_mono \\<Longrightarrow>\n    eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "with gt 1[OF this]"], ["proof (chain)\npicking this:\n  \\<alpha> v \\<succ> \\<beta> v\n  n = 1\n  \\<not> power_mono", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> v \\<succ> \\<beta> v\n  n = 1\n  \\<not> power_mono\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "unfolding eval"], ["proof (prove)\nusing this:\n  \\<alpha> v \\<succ> \\<beta> v\n  n = 1\n  \\<not> power_mono\n\ngoal (1 subgoal):\n 1. \\<alpha> v ^ n \\<succ> \\<beta> v ^ n", "by auto"], ["proof (state)\nthis:\n  eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n\ngoal (1 subgoal):\n 1. power_mono \\<Longrightarrow>\n    eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. power_mono \\<Longrightarrow>\n    eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "case True"], ["proof (state)\nthis:\n  power_mono\n\ngoal (1 subgoal):\n 1. power_mono \\<Longrightarrow>\n    eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "from power_mono[OF True gt ge n1]"], ["proof (chain)\npicking this:\n  \\<alpha> v ^ n \\<succ> \\<beta> v ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> v ^ n \\<succ> \\<beta> v ^ n\n\ngoal (1 subgoal):\n 1. eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m", "unfolding eval"], ["proof (prove)\nusing this:\n  \\<alpha> v ^ n \\<succ> \\<beta> v ^ n\n\ngoal (1 subgoal):\n 1. \\<alpha> v ^ n \\<succ> \\<beta> v ^ n", "."], ["proof (state)\nthis:\n  eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_monom \\<alpha> m \\<succ> eval_monom \\<beta> m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_poly_strict_mono: \n  assumes check1: \"check_poly_strict_mono power_mono p v\"\n  and check2: \"check_poly_weak_mono_all p\"\n  shows \"poly_strict_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_strict_mono p v", "unfolding poly_strict_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>.\n       (\\<forall>x.\n           v \\<noteq> x \\<longrightarrow>\n           \\<alpha> x = \\<beta> x) \\<longrightarrow>\n       pos_assign \\<beta> \\<longrightarrow>\n       \\<alpha> v \\<succ> \\<beta> v \\<longrightarrow>\n       eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "fix f g :: \"('b,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and pos: \"pos_assign g\"\n  and fgv: \"f v \\<succ> g v\""], ["proof (state)\nthis:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n  pos_assign g\n  f v \\<succ> g v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "from pos[unfolded pos_assign_def]"], ["proof (chain)\npicking this:\n  \\<forall>x. (0::'a) \\<le> g x", "have g: \"\\<And> x. g x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x", ".."], ["proof (state)\nthis:\n  (0::'a) \\<le> g ?x3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "{"], ["proof (state)\nthis:\n  (0::'a) \\<le> g ?x3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "have \"f w \\<ge> g w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g w \\<le> f w", "proof (cases \"v = w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = w \\<Longrightarrow> g w \\<le> f w\n 2. v \\<noteq> w \\<Longrightarrow> g w \\<le> f w", "case False"], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (2 subgoals):\n 1. v = w \\<Longrightarrow> g w \\<le> f w\n 2. v \\<noteq> w \\<Longrightarrow> g w \\<le> f w", "with fgw ge_refl"], ["proof (chain)\npicking this:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n  ?x \\<le> ?x\n  v \\<noteq> w", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n  ?x \\<le> ?x\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. g w \\<le> f w", "by auto"], ["proof (state)\nthis:\n  g w \\<le> f w\n\ngoal (1 subgoal):\n 1. v = w \\<Longrightarrow> g w \\<le> f w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w \\<Longrightarrow> g w \\<le> f w", "case True"], ["proof (state)\nthis:\n  v = w\n\ngoal (1 subgoal):\n 1. v = w \\<Longrightarrow> g w \\<le> f w", "from fgv[unfolded True]"], ["proof (chain)\npicking this:\n  f w \\<succ> g w", "show ?thesis"], ["proof (prove)\nusing this:\n  f w \\<succ> g w\n\ngoal (1 subgoal):\n 1. g w \\<le> f w", "by (rule gt_imp_ge)"], ["proof (state)\nthis:\n  g w \\<le> f w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g w \\<le> f w\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "}"], ["proof (state)\nthis:\n  g ?w5 \\<le> f ?w5\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "note fgw2 = this"], ["proof (state)\nthis:\n  g ?w5 \\<le> f ?w5\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "let ?e = \"eval_poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "show \"?e f p \\<succ> ?e g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p", "using check1[unfolded check_poly_strict_mono_def, simplified list_ex_iff]\n      check2[unfolded check_poly_weak_mono_all_def, simplified list_all_iff, THEN bspec]"], ["proof (prove)\nusing this:\n  \\<exists>(m, c)\\<in>set p.\n     (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n  ?x \\<in> set p \\<Longrightarrow>\n  case ?x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>(m, c)\\<in>set [].\n                (1::'a) \\<le> c \\<and>\n                check_monom_strict_mono power_mono m v;\n     \\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n    \\<Longrightarrow> eval_poly f [] \\<succ> eval_poly g []\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p.\n                            (1::'a) \\<le> c \\<and>\n                            check_monom_strict_mono power_mono m v;\n                 \\<And>x.\n                    x \\<in> set p \\<Longrightarrow>\n                    case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n                \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p;\n        \\<exists>(m, c)\\<in>set (a # p).\n           (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v;\n        \\<And>x.\n           x \\<in> set (a # p) \\<Longrightarrow>\n           case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)", "case Nil"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set [].\n     case a of\n     (m, c) \\<Rightarrow>\n       (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n  ?x4 \\<in> set [] \\<Longrightarrow>\n  case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>(m, c)\\<in>set [].\n                (1::'a) \\<le> c \\<and>\n                check_monom_strict_mono power_mono m v;\n     \\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n    \\<Longrightarrow> eval_poly f [] \\<succ> eval_poly g []\n 2. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p.\n                            (1::'a) \\<le> c \\<and>\n                            check_monom_strict_mono power_mono m v;\n                 \\<And>x.\n                    x \\<in> set p \\<Longrightarrow>\n                    case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n                \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p;\n        \\<exists>(m, c)\\<in>set (a # p).\n           (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v;\n        \\<And>x.\n           x \\<in> set (a # p) \\<Longrightarrow>\n           case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>set [].\n     case a of\n     (m, c) \\<Rightarrow>\n       (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n  ?x4 \\<in> set [] \\<Longrightarrow>\n  case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. eval_poly f [] \\<succ> eval_poly g []", "by simp"], ["proof (state)\nthis:\n  eval_poly f [] \\<succ> eval_poly g []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p.\n                            (1::'a) \\<le> c \\<and>\n                            check_monom_strict_mono power_mono m v;\n                 \\<And>x.\n                    x \\<in> set p \\<Longrightarrow>\n                    case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n                \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p;\n        \\<exists>(m, c)\\<in>set (a # p).\n           (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v;\n        \\<And>x.\n           x \\<in> set (a # p) \\<Longrightarrow>\n           case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p.\n                            (1::'a) \\<le> c \\<and>\n                            check_monom_strict_mono power_mono m v;\n                 \\<And>x.\n                    x \\<in> set p \\<Longrightarrow>\n                    case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n                \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p;\n        \\<exists>(m, c)\\<in>set (a # p).\n           (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v;\n        \\<And>x.\n           x \\<in> set (a # p) \\<Longrightarrow>\n           case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)", "case (Cons mc p)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>a\\<in>set p.\n              case a of\n              (m, c) \\<Rightarrow>\n                (1::'a) \\<le> c \\<and>\n                check_monom_strict_mono power_mono m v;\n   \\<And>x.\n      x \\<in> set p \\<Longrightarrow>\n      case x of (m, a) \\<Rightarrow> (0::'a) \\<le> a\\<rbrakk>\n  \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n  \\<exists>a\\<in>set (mc # p).\n     case a of\n     (m, c) \\<Rightarrow>\n       (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n  ?x4 \\<in> set (mc # p) \\<Longrightarrow>\n  case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p.\n                            (1::'a) \\<le> c \\<and>\n                            check_monom_strict_mono power_mono m v;\n                 \\<And>x.\n                    x \\<in> set p \\<Longrightarrow>\n                    case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n                \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p;\n        \\<exists>(m, c)\\<in>set (a # p).\n           (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v;\n        \\<And>x.\n           x \\<in> set (a # p) \\<Longrightarrow>\n           case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)", "obtain m c where mc: \"mc = (m,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m c. mc = (m, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases mc, auto)"], ["proof (state)\nthis:\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>\\<lbrakk>\\<exists>(m, c)\\<in>set p.\n                            (1::'a) \\<le> c \\<and>\n                            check_monom_strict_mono power_mono m v;\n                 \\<And>x.\n                    x \\<in> set p \\<Longrightarrow>\n                    case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n                \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p;\n        \\<exists>(m, c)\\<in>set (a # p).\n           (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v;\n        \\<And>x.\n           x \\<in> set (a # p) \\<Longrightarrow>\n           case x of (m, x) \\<Rightarrow> (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> eval_poly f (a # p) \\<succ> eval_poly g (a # p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "proof (cases \"c \\<ge> 1 \\<and> check_monom_strict_mono power_mono m v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and>\n    check_monom_strict_mono power_mono m v \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "case True"], ["proof (state)\nthis:\n  (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and>\n    check_monom_strict_mono power_mono m v \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "hence c: \"c \\<ge> 1\" and m: \"check_monom_strict_mono power_mono m v\""], ["proof (prove)\nusing this:\n  (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> c &&& check_monom_strict_mono power_mono m v", "by blast+"], ["proof (state)\nthis:\n  (1::'a) \\<le> c\n  check_monom_strict_mono power_mono m v\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and>\n    check_monom_strict_mono power_mono m v \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "from times_gt_mono[OF check_monom_strict_mono[OF m, of f g, OF fgv g] c]"], ["proof (chain)\npicking this:\n  eval_monom f m * c \\<succ> eval_monom g m * c", "have gt: \"eval_monom f m * c \\<succ> eval_monom g m * c\""], ["proof (prove)\nusing this:\n  eval_monom f m * c \\<succ> eval_monom g m * c\n\ngoal (1 subgoal):\n 1. eval_monom f m * c \\<succ> eval_monom g m * c", "."], ["proof (state)\nthis:\n  eval_monom f m * c \\<succ> eval_monom g m * c\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and>\n    check_monom_strict_mono power_mono m v \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "from Cons(3)"], ["proof (chain)\npicking this:\n  ?x4 \\<in> set (mc # p) \\<Longrightarrow>\n  case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a", "have \"check_poly_weak_mono_all p\""], ["proof (prove)\nusing this:\n  ?x4 \\<in> set (mc # p) \\<Longrightarrow>\n  case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. check_poly_weak_mono_all p", "unfolding check_poly_weak_mono_all_def list_all_iff"], ["proof (prove)\nusing this:\n  ?x4 \\<in> set (mc # p) \\<Longrightarrow>\n  case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. \\<forall>(m, y)\\<in>set p. (0::'a) \\<le> y", "by auto"], ["proof (state)\nthis:\n  check_poly_weak_mono_all p\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and>\n    check_monom_strict_mono power_mono m v \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "from check_poly_weak_mono_all[OF this, unfolded poly_weak_mono_all_def, rule_format, OF fgw2 pos]"], ["proof (chain)\npicking this:\n  eval_poly g p \\<le> eval_poly f p", "have ge: \"?e f p \\<ge> ?e g p\""], ["proof (prove)\nusing this:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal (1 subgoal):\n 1. eval_poly g p \\<le> eval_poly f p", "."], ["proof (state)\nthis:\n  eval_poly g p \\<le> eval_poly f p\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> c \\<and>\n    check_monom_strict_mono power_mono m v \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n 2. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "from compat2[OF plus_gt_left_mono[OF gt] plus_right_mono[OF ge]]"], ["proof (chain)\npicking this:\n  eval_monom f m * c + eval_poly f p \\<succ>\n  eval_monom g m * c + eval_poly g p", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_monom f m * c + eval_poly f p \\<succ>\n  eval_monom g m * c + eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "unfolding mc"], ["proof (prove)\nusing this:\n  eval_monom f m * c + eval_poly f p \\<succ>\n  eval_monom g m * c + eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f ((m, c) # p) \\<succ> eval_poly g ((m, c) # p)", "by simp"], ["proof (state)\nthis:\n  eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "case False"], ["proof (state)\nthis:\n  \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v)\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "with Cons(2) mc"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>set (mc # p).\n     case a of\n     (m, c) \\<Rightarrow>\n       (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n  mc = (m, c)\n  \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v)", "have \"\\<exists> mc \\<in> set p. (\\<lambda> (m,c). c \\<ge> 1 \\<and> check_monom_strict_mono power_mono m v) mc\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>set (mc # p).\n     case a of\n     (m, c) \\<Rightarrow>\n       (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n  mc = (m, c)\n  \\<not> ((1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v)\n\ngoal (1 subgoal):\n 1. \\<exists>mc\\<in>set p.\n       case mc of\n       (m, c) \\<Rightarrow>\n         (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v", "by auto"], ["proof (state)\nthis:\n  \\<exists>mc\\<in>set p.\n     case mc of\n     (m, c) \\<Rightarrow>\n       (1::'a) \\<le> c \\<and> check_monom_strict_mono power_mono m v\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "from Cons(1)[OF this] Cons(3)"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> set p \\<Longrightarrow>\n      case x of (m, a) \\<Rightarrow> (0::'a) \\<le> a) \\<Longrightarrow>\n  eval_poly f p \\<succ> eval_poly g p\n  ?x4 \\<in> set (mc # p) \\<Longrightarrow>\n  case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a", "have rec: \"?e f p \\<succ> ?e g p\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set p \\<Longrightarrow>\n      case x of (m, a) \\<Rightarrow> (0::'a) \\<le> a) \\<Longrightarrow>\n  eval_poly f p \\<succ> eval_poly g p\n  ?x4 \\<in> set (mc # p) \\<Longrightarrow>\n  case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p", "by simp"], ["proof (state)\nthis:\n  eval_poly f p \\<succ> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "from Cons(3) mc"], ["proof (chain)\npicking this:\n  ?x4 \\<in> set (mc # p) \\<Longrightarrow>\n  case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n  mc = (m, c)", "have c: \"c \\<ge> 0\""], ["proof (prove)\nusing this:\n  ?x4 \\<in> set (mc # p) \\<Longrightarrow>\n  case ?x4 of (m, a) \\<Rightarrow> (0::'a) \\<le> a\n  mc = (m, c)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> c\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "from times_left_mono[OF c eval_monom_mono(1)[OF fgw2 g]]"], ["proof (chain)\npicking this:\n  eval_monom (\\<lambda>x. g (?x5 x)) ?m1 * c\n  \\<le> eval_monom (\\<lambda>x. f (?x5 x)) ?m1 * c", "have ge: \"eval_monom f m * c \\<ge> eval_monom g m * c\""], ["proof (prove)\nusing this:\n  eval_monom (\\<lambda>x. g (?x5 x)) ?m1 * c\n  \\<le> eval_monom (\\<lambda>x. f (?x5 x)) ?m1 * c\n\ngoal (1 subgoal):\n 1. eval_monom g m * c \\<le> eval_monom f m * c", "."], ["proof (state)\nthis:\n  eval_monom g m * c \\<le> eval_monom f m * c\n\ngoal (1 subgoal):\n 1. \\<not> ((1::'a) \\<le> c \\<and>\n            check_monom_strict_mono power_mono m v) \\<Longrightarrow>\n    eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "from compat2[OF plus_gt_left_mono[OF rec] plus_right_mono[OF ge]]"], ["proof (chain)\npicking this:\n  eval_poly f p + eval_monom f m * c \\<succ>\n  eval_poly g p + eval_monom g m * c", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_poly f p + eval_monom f m * c \\<succ>\n  eval_poly g p + eval_monom g m * c\n\ngoal (1 subgoal):\n 1. eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)", "by (simp add: mc field_simps)"], ["proof (state)\nthis:\n  eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f (mc # p) \\<succ> eval_poly g (mc # p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_poly_gt: \n  fixes p :: \"('v :: linorder,'a)poly\"\n  assumes \"check_poly_gt gt p q\" shows \"p >p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p >p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p >p q", "obtain a1 p1 where p: \"poly_split 1 p = (a1,p1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a1 p1.\n        poly_split 1 p = (a1, p1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  poly_split 1 p = (a1, p1)\n\ngoal (1 subgoal):\n 1. p >p q", "obtain b1 q1 where q: \"poly_split 1 q = (b1,q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b1 q1.\n        poly_split 1 q = (b1, q1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  poly_split 1 q = (b1, q1)\n\ngoal (1 subgoal):\n 1. p >p q", "from p q assms"], ["proof (chain)\npicking this:\n  poly_split 1 p = (a1, p1)\n  poly_split 1 q = (b1, q1)\n  check_poly_gt (\\<succ>) p q", "have gt: \"a1 \\<succ> b1\" and ge: \"p1 \\<ge>p q1\""], ["proof (prove)\nusing this:\n  poly_split 1 p = (a1, p1)\n  poly_split 1 q = (b1, q1)\n  check_poly_gt (\\<succ>) p q\n\ngoal (1 subgoal):\n 1. a1 \\<succ> b1 &&& p1 \\<ge>p q1", "unfolding check_poly_gt_def"], ["proof (prove)\nusing this:\n  poly_split 1 p = (a1, p1)\n  poly_split 1 q = (b1, q1)\n  let (a1, p1) = poly_split 1 p; (b1, q1) = poly_split 1 q\n  in a1 \\<succ> b1 \\<and> check_poly_ge p1 q1\n\ngoal (1 subgoal):\n 1. a1 \\<succ> b1 &&& p1 \\<ge>p q1", "using check_poly_ge[of p1 q1]"], ["proof (prove)\nusing this:\n  poly_split 1 p = (a1, p1)\n  poly_split 1 q = (b1, q1)\n  let (a1, p1) = poly_split 1 p; (b1, q1) = poly_split 1 q\n  in a1 \\<succ> b1 \\<and> check_poly_ge p1 q1\n  check_poly_ge p1 q1 \\<Longrightarrow> p1 \\<ge>p q1\n\ngoal (1 subgoal):\n 1. a1 \\<succ> b1 &&& p1 \\<ge>p q1", "by auto"], ["proof (state)\nthis:\n  a1 \\<succ> b1\n  p1 \\<ge>p q1\n\ngoal (1 subgoal):\n 1. p >p q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p >p q", "proof (unfold poly_gt_def, intro impI allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q", "fix \\<alpha> :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q", "assume \"pos_assign \\<alpha>\""], ["proof (state)\nthis:\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q", "with ge"], ["proof (chain)\npicking this:\n  p1 \\<ge>p q1\n  pos_assign \\<alpha>", "have ge: \"eval_poly \\<alpha> p1 \\<ge> eval_poly \\<alpha> q1\""], ["proof (prove)\nusing this:\n  p1 \\<ge>p q1\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1", "unfolding poly_ge_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1\n  pos_assign \\<alpha>\n\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1", "by simp"], ["proof (state)\nthis:\n  eval_poly \\<alpha> q1 \\<le> eval_poly \\<alpha> p1\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q", "from plus_gt_left_mono[OF gt] compat[OF plus_left_mono[OF ge]]"], ["proof (chain)\npicking this:\n  a1 + ?z \\<succ> b1 + ?z\n  eval_poly \\<alpha> q1 + ?z1 \\<succ> ?z \\<Longrightarrow>\n  eval_poly \\<alpha> p1 + ?z1 \\<succ> ?z", "have gt: \"a1 + eval_poly \\<alpha> p1 \\<succ> b1 + eval_poly \\<alpha> q1\""], ["proof (prove)\nusing this:\n  a1 + ?z \\<succ> b1 + ?z\n  eval_poly \\<alpha> q1 + ?z1 \\<succ> ?z \\<Longrightarrow>\n  eval_poly \\<alpha> p1 + ?z1 \\<succ> ?z\n\ngoal (1 subgoal):\n 1. a1 + eval_poly \\<alpha> p1 \\<succ> b1 + eval_poly \\<alpha> q1", "by (force simp: field_simps)"], ["proof (state)\nthis:\n  a1 + eval_poly \\<alpha> p1 \\<succ> b1 + eval_poly \\<alpha> q1\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       pos_assign \\<alpha> \\<Longrightarrow>\n       eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q", "show \"eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q", "by (simp add: poly_split[OF p, unfolded eq_poly_def] poly_split[OF q, unfolded eq_poly_def] gt)"], ["proof (state)\nthis:\n  eval_poly \\<alpha> p \\<succ> eval_poly \\<alpha> q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p >p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_poly_strict_mono_discrete: \n  fixes v :: \"'v :: linorder\" and p :: \"('v,'a)poly\"\n  assumes discrete and check: \"check_poly_strict_mono_discrete gt p v\"\n  shows \"poly_strict_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_strict_mono p v", "unfolding poly_strict_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha> \\<beta>.\n       (\\<forall>x.\n           v \\<noteq> x \\<longrightarrow>\n           \\<alpha> x = \\<beta> x) \\<longrightarrow>\n       pos_assign \\<beta> \\<longrightarrow>\n       \\<alpha> v \\<succ> \\<beta> v \\<longrightarrow>\n       eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "fix f g :: \"('v,'a)assign\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "assume fgw: \"\\<forall> w. (v \\<noteq> w \\<longrightarrow> f w = g w)\"\n  and gass: \"pos_assign g\"\n  and v: \"f v \\<succ> g v\""], ["proof (state)\nthis:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n  pos_assign g\n  f v \\<succ> g v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "from gass"], ["proof (chain)\npicking this:\n  pos_assign g", "have g: \"\\<And> x. g x \\<ge> 0\""], ["proof (prove)\nusing this:\n  pos_assign g\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x", "unfolding pos_assign_def"], ["proof (prove)\nusing this:\n  \\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> g x", ".."], ["proof (state)\nthis:\n  (0::'a) \\<le> g ?x3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "from fgw"], ["proof (chain)\npicking this:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w", "have w: \"\\<And> w. v \\<noteq> w \\<Longrightarrow> f w = g w\""], ["proof (prove)\nusing this:\n  \\<forall>w. v \\<noteq> w \\<longrightarrow> f w = g w\n\ngoal (1 subgoal):\n 1. \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "from assms check_poly_gt"], ["proof (chain)\npicking this:\n  discrete\n  check_poly_strict_mono_discrete (\\<succ>) p v\n  check_poly_gt (\\<succ>) ?p ?q \\<Longrightarrow> ?p >p ?q", "have gt: \"poly_gt (poly_subst (\\<lambda> w. poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w)) p) p\" (is \"poly_gt ?p1 p\")"], ["proof (prove)\nusing this:\n  discrete\n  check_poly_strict_mono_discrete (\\<succ>) p v\n  check_poly_gt (\\<succ>) ?p ?q \\<Longrightarrow> ?p >p ?q\n\ngoal (1 subgoal):\n 1. poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p >p\n    p", "unfolding check_poly_strict_mono_discrete_def"], ["proof (prove)\nusing this:\n  discrete\n  check_poly_gt (\\<succ>)\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n   p\n  check_poly_gt (\\<succ>) ?p ?q \\<Longrightarrow> ?p >p ?q\n\ngoal (1 subgoal):\n 1. poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p >p\n    p", "by blast"], ["proof (state)\nthis:\n  poly_subst\n   (\\<lambda>w.\n       poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n   p >p\n  p\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "from discrete[OF \\<open>discrete\\<close> gt_imp_ge[OF v]]"], ["proof (chain)\npicking this:\n  \\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)", "obtain k' where id: \"f v = (((+) 1)^^k') (g v)\""], ["proof (prove)\nusing this:\n  \\<exists>k. f v = ((+) (1::'a) ^^ k) (g v)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        f v = ((+) (1::'a) ^^ k') (g v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "{"], ["proof (state)\nthis:\n  f v = ((+) (1::'a) ^^ k') (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "assume \"k' = 0\""], ["proof (state)\nthis:\n  k' = 0\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "from v[unfolded id this]"], ["proof (chain)\npicking this:\n  ((+) (1::'a) ^^ 0) (g v) \\<succ> g v", "have \"g v \\<succ> g v\""], ["proof (prove)\nusing this:\n  ((+) (1::'a) ^^ 0) (g v) \\<succ> g v\n\ngoal (1 subgoal):\n 1. g v \\<succ> g v", "by simp"], ["proof (state)\nthis:\n  g v \\<succ> g v\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "hence False"], ["proof (prove)\nusing this:\n  g v \\<succ> g v\n\ngoal (1 subgoal):\n 1. False", "using SN g[of v]"], ["proof (prove)\nusing this:\n  g v \\<succ> g v\n  SN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}\n  (0::'a) \\<le> g v\n\ngoal (1 subgoal):\n 1. False", "unfolding SN_defs"], ["proof (prove)\nusing this:\n  g v \\<succ> g v\n  \\<nexists>f.\n     f 0 \\<in> UNIV \\<and>\n     (\\<forall>i.\n         (f i, f (Suc i))\n         \\<in> {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y})\n  (0::'a) \\<le> g v\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "}"], ["proof (state)\nthis:\n  k' = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "with id"], ["proof (chain)\npicking this:\n  f v = ((+) (1::'a) ^^ k') (g v)\n  k' = 0 \\<Longrightarrow> False", "obtain k where id: \"f v = (((+) 1)^^(Suc k)) (g v)\""], ["proof (prove)\nusing this:\n  f v = ((+) (1::'a) ^^ k') (g v)\n  k' = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        f v = ((+) (1::'a) ^^ Suc k) (g v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases k', auto)"], ["proof (state)\nthis:\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> \\<beta>.\n       \\<lbrakk>\\<forall>x.\n                   v \\<noteq> x \\<longrightarrow> \\<alpha> x = \\<beta> x;\n        pos_assign \\<beta>; \\<alpha> v \\<succ> \\<beta> v\\<rbrakk>\n       \\<Longrightarrow> eval_poly \\<alpha> p \\<succ> eval_poly \\<beta> p", "with w gass"], ["proof (chain)\npicking this:\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)", "show \"eval_poly f p \\<succ> eval_poly g p\""], ["proof (prove)\nusing this:\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p", "proof (induct k arbitrary: f g rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f g.\n       \\<lbrakk>\\<And>y f g.\n                   \\<lbrakk>y < x;\n                    \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w;\n                    pos_assign g;\n                    f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk>\n                   \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p;\n        \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g;\n        f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk>\n       \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "case (less k)"], ["proof (state)\nthis:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. \\<And>x f g.\n       \\<lbrakk>\\<And>y f g.\n                   \\<lbrakk>y < x;\n                    \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w;\n                    pos_assign g;\n                    f v = ((+) (1::'a) ^^ Suc y) (g v)\\<rbrakk>\n                   \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p;\n        \\<And>w. v \\<noteq> w \\<Longrightarrow> f w = g w; pos_assign g;\n        f v = ((+) (1::'a) ^^ Suc x) (g v)\\<rbrakk>\n       \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "with less(4)"], ["proof (chain)\npicking this:\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  k = 0", "have id0: \"f v = 1 + g v\""], ["proof (prove)\nusing this:\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  k = 0\n\ngoal (1 subgoal):\n 1. f v = (1::'a) + g v", "by simp"], ["proof (state)\nthis:\n  f v = (1::'a) + g v\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "have id1: \"eval_poly f p = eval_poly g ?p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p =\n    eval_poly g\n     (poly_subst\n       (\\<lambda>w.\n           poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n       p)", "proof (rule eval_poly_subst)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       f w =\n       eval_poly g\n        (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       f w =\n       eval_poly g\n        (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "show \"f w = eval_poly g (poly_of (if w = v then PSum [PNum 1, PVar v] else PVar w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "proof (cases \"w = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "case True"], ["proof (state)\nthis:\n  w = v\n\ngoal (2 subgoals):\n 1. w = v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n 2. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "by (simp add: True id0 zero_poly_def)"], ["proof (state)\nthis:\n  f w =\n  eval_poly g\n   (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "case False"], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "with less"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  w \\<noteq> v", "have \"f w = g w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. f w = g w", "by simp"], ["proof (state)\nthis:\n  f w = g w\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow>\n    f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "thus ?thesis"], ["proof (prove)\nusing this:\n  f w = g w\n\ngoal (1 subgoal):\n 1. f w =\n    eval_poly g\n     (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))", "by (simp add: False)"], ["proof (state)\nthis:\n  f w =\n  eval_poly g\n   (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f w =\n  eval_poly g\n   (poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f p =\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "have \"eval_poly g ?p1 \\<succ> eval_poly g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly g\n     (poly_subst\n       (\\<lambda>w.\n           poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n       p) \\<succ>\n    eval_poly g p", "using gt less"], ["proof (prove)\nusing this:\n  poly_subst\n   (\\<lambda>w.\n       poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n   p >p\n  p\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g\n     (poly_subst\n       (\\<lambda>w.\n           poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n       p) \\<succ>\n    eval_poly g p", "unfolding poly_gt_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<alpha>.\n     pos_assign \\<alpha> \\<longrightarrow>\n     eval_poly \\<alpha>\n      (poly_subst\n        (\\<lambda>w.\n            poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n        p) \\<succ>\n     eval_poly \\<alpha> p\n  \\<lbrakk>?y3 < k; \\<And>w. v \\<noteq> w \\<Longrightarrow> ?f3 w = ?g3 w;\n   pos_assign ?g3; ?f3 v = ((+) (1::'a) ^^ Suc ?y3) (?g3 v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly ?f3 p \\<succ> eval_poly ?g3 p\n  v \\<noteq> ?w3 \\<Longrightarrow> f ?w3 = g ?w3\n  pos_assign g\n  f v = ((+) (1::'a) ^^ Suc k) (g v)\n\ngoal (1 subgoal):\n 1. eval_poly g\n     (poly_subst\n       (\\<lambda>w.\n           poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n       p) \\<succ>\n    eval_poly g p", "by simp"], ["proof (state)\nthis:\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p) \\<succ>\n  eval_poly g p\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "with id1"], ["proof (chain)\npicking this:\n  eval_poly f p =\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p) \\<succ>\n  eval_poly g p", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_poly f p =\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p)\n  eval_poly g\n   (poly_subst\n     (\\<lambda>w.\n         poly_of (if w = v then PSum [PNum (1::'a), PVar v] else PVar w))\n     p) \\<succ>\n  eval_poly g p\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p", "by simp"], ["proof (state)\nthis:\n  eval_poly f p \\<succ> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "case (Suc kk)"], ["proof (state)\nthis:\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "obtain g' where g': \"g' = (\\<lambda> w. if (w = v) then 1 + g w else g w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        g' =\n        (\\<lambda>w. if w = v then (1::'a) + g w else g w) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "have \"(1 :: 'a) + g v \\<ge> 1 + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) \\<le> (1::'a) + g v", "by (rule plus_right_mono, simp add: less(3)[unfolded pos_assign_def])"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "also"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "have \"(1 :: 'a) + 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) = (1::'a)", "by simp"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "also"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "have \"\\<dots> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (1::'a)", "by (rule one_ge_zero)"], ["proof (state)\nthis:\n  (0::'a) \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "finally"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> (1::'a) + g v", "have g'pos: \"pos_assign g'\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (1::'a) + g v\n\ngoal (1 subgoal):\n 1. pos_assign g'", "using less(3)"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (1::'a) + g v\n  pos_assign g\n\ngoal (1 subgoal):\n 1. pos_assign g'", "unfolding pos_assign_def"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (1::'a) + g v\n  \\<forall>x. (0::'a) \\<le> g x\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0::'a) \\<le> g' x", "by (simp add: g')"], ["proof (state)\nthis:\n  pos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "{"], ["proof (state)\nthis:\n  pos_assign g'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "assume \"v \\<noteq> w\""], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "hence \"f w = g' w\""], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = g' w", "unfolding g'"], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. f w = (if w = v then (1::'a) + g w else g w)", "by (simp add: less)"], ["proof (state)\nthis:\n  f w = g' w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "}"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "note w = this"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> f ?w5 = g' ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "have eq: \"f v = ((+) (1 :: 'a) ^^ Suc kk) ((g' v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f v = ((+) (1::'a) ^^ Suc kk) (g' v)", "by (simp add: less(4) g' Suc, rule arg_cong[where f = \"(+) 1\"], induct kk, auto)"], ["proof (state)\nthis:\n  f v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "from Suc"], ["proof (chain)\npicking this:\n  k = Suc kk", "have kk: \"kk < k\""], ["proof (prove)\nusing this:\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. kk < k", "by simp"], ["proof (state)\nthis:\n  kk < k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "from less(1)[OF kk w g'pos] eq"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g' p\n  f v = ((+) (1::'a) ^^ Suc kk) (g' v)", "have rec1: \"eval_poly f p \\<succ> eval_poly g' p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   f v = ((+) (1::'a) ^^ Suc kk) (g' v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g' p\n  f v = ((+) (1::'a) ^^ Suc kk) (g' v)\n\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g' p", "by simp"], ["proof (state)\nthis:\n  eval_poly f p \\<succ> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "{"], ["proof (state)\nthis:\n  eval_poly f p \\<succ> eval_poly g' p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "assume \"v \\<noteq> w\""], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "hence \"g' w = g w\""], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. g' w = g w", "unfolding g'"], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. (if w = v then (1::'a) + g w else g w) = g w", "by simp"], ["proof (state)\nthis:\n  g' w = g w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "}"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "note w = this"], ["proof (state)\nthis:\n  v \\<noteq> ?w5 \\<Longrightarrow> g' ?w5 = g ?w5\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "from Suc"], ["proof (chain)\npicking this:\n  k = Suc kk", "have z: \"0 < k\""], ["proof (prove)\nusing this:\n  k = Suc kk\n\ngoal (1 subgoal):\n 1. 0 < k", "by simp"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "from less(1)[OF z w less(3)] g'"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly g' p \\<succ> eval_poly g p\n  g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)", "have rec2: \"eval_poly g' p \\<succ> eval_poly g p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>w. v \\<noteq> w \\<Longrightarrow> v \\<noteq> w;\n   g' v = ((+) (1::'a) ^^ Suc 0) (g v)\\<rbrakk>\n  \\<Longrightarrow> eval_poly g' p \\<succ> eval_poly g p\n  g' = (\\<lambda>w. if w = v then (1::'a) + g w else g w)\n\ngoal (1 subgoal):\n 1. eval_poly g' p \\<succ> eval_poly g p", "by simp"], ["proof (state)\nthis:\n  eval_poly g' p \\<succ> eval_poly g p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> eval_poly f p \\<succ> eval_poly g p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_poly f p \\<succ> eval_poly g p", "by (rule gt_trans[OF rec1 rec2])"], ["proof (state)\nthis:\n  eval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_poly f p \\<succ> eval_poly g p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_poly_strict_mono_smart: \n  assumes check1: \"check_poly_strict_mono_smart discrete power_mono gt p v\"\n  and check2: \"check_poly_weak_mono_and_pos discrete p\"\n  shows \"poly_strict_mono p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_strict_mono p v", "proof (cases discrete)"], ["proof (state)\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_strict_mono p v\n 2. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v", "case True"], ["proof (state)\nthis:\n  discrete\n\ngoal (2 subgoals):\n 1. discrete \\<Longrightarrow> poly_strict_mono p v\n 2. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v", "with check1[unfolded check_poly_strict_mono_smart_def]\n    check_poly_strict_mono_discrete[OF True]"], ["proof (chain)\npicking this:\n  if discrete then check_poly_strict_mono_discrete (\\<succ>) p v\n  else check_poly_strict_mono power_mono p v\n  check_poly_strict_mono_discrete (\\<succ>) ?p ?v \\<Longrightarrow>\n  poly_strict_mono ?p ?v\n  discrete", "show ?thesis"], ["proof (prove)\nusing this:\n  if discrete then check_poly_strict_mono_discrete (\\<succ>) p v\n  else check_poly_strict_mono power_mono p v\n  check_poly_strict_mono_discrete (\\<succ>) ?p ?v \\<Longrightarrow>\n  poly_strict_mono ?p ?v\n  discrete\n\ngoal (1 subgoal):\n 1. poly_strict_mono p v", "by auto"], ["proof (state)\nthis:\n  poly_strict_mono p v\n\ngoal (1 subgoal):\n 1. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v", "case False"], ["proof (state)\nthis:\n  \\<not> discrete\n\ngoal (1 subgoal):\n 1. \\<not> discrete \\<Longrightarrow> poly_strict_mono p v", "from check_poly_strict_mono[OF check1[unfolded check_poly_strict_mono_smart_def, simplified False, simplified]]\n    check2[unfolded check_poly_weak_mono_and_pos_def, simplified False, simplified]"], ["proof (chain)\npicking this:\n  check_poly_weak_mono_all p \\<Longrightarrow> poly_strict_mono p v\n  check_poly_weak_mono_all p", "show ?thesis"], ["proof (prove)\nusing this:\n  check_poly_weak_mono_all p \\<Longrightarrow> poly_strict_mono p v\n  check_poly_weak_mono_all p\n\ngoal (1 subgoal):\n 1. poly_strict_mono p v", "by auto"], ["proof (state)\nthis:\n  poly_strict_mono p v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}