{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/Term_Order.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma rep_inj:\n  assumes \"rep_nat x = rep_nat y\"\n  shows \"x = y\"", "lemma abs_inj:\n  assumes \"abs_nat m = abs_nat n\"\n  shows \"m = n\"", "lemma rep_zero [simp]: \"rep_nat 0 = 0\"", "lemma rep_zero_iff: \"(rep_nat x = 0) \\<longleftrightarrow> (x = 0)\"", "lemma plus_eq: \"x + y = abs_nat (rep_nat x + rep_nat y)\"", "lemma rep_plus: \"rep_nat (x + y) = rep_nat x + rep_nat y\"", "lemma minus_eq: \"x - y = abs_nat (rep_nat x - rep_nat y)\"", "lemma rep_minus: \"rep_nat (x - y) = rep_nat x - rep_nat y\"", "lemma ord_iff:\n  \"x \\<le> y \\<longleftrightarrow> rep_nat x \\<le> rep_nat y\" (is ?thesis1)\n  \"x < y \\<longleftrightarrow> rep_nat x < rep_nat y\" (is ?thesis2)", "lemma ex_iff_abs: \"(\\<exists>x::'a. P x) \\<longleftrightarrow> (\\<exists>n::nat. P (abs_nat n))\"", "lemma ex_iff_abs': \"(\\<exists>x<abs_nat m. P x) \\<longleftrightarrow> (\\<exists>n::nat<m. P (abs_nat n))\"", "lemma all_iff_abs: \"(\\<forall>x::'a. P x) \\<longleftrightarrow> (\\<forall>n::nat. P (abs_nat n))\"", "lemma all_iff_abs': \"(\\<forall>x<abs_nat m. P x) \\<longleftrightarrow> (\\<forall>n::nat<m. P (abs_nat n))\"", "lemma comparator_of_rep [simp]: \"comparator_of (rep_nat x) (rep_nat y) = comparator_of x y\"", "lemma sum_rep: \"sum (rep_nat \\<circ> f) A = rep_nat (sum f A)\" for f :: \"'b \\<Rightarrow> 'a\" and A :: \"'b set\"", "lemma the_min_eq_zero: \"the_min = (0::'a::{the_min,nat})\"", "lemma less_pp:\n  assumes \"rep_nat_pp x < rep_nat_pp y\"\n  shows \"x < y\"", "lemma rep_nat_pp_inj:\n  assumes \"rep_nat_pp x = rep_nat_pp y\"\n  shows \"x = y\"", "lemma lex_comp'_EqD:\n  assumes \"lex_comp' x y = Eq\"\n  shows \"x = y\"", "lemma lex_comp'_valE:\n  assumes \"lex_comp' s t \\<noteq> Eq\"\n  obtains x where \"x \\<in> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\"\n    and \"comparator_of (lookup_pp (rep_nat_pp s) x) (lookup_pp (rep_nat_pp t) x) = lex_comp' s t\"\n    and \"\\<And>y. y < x \\<Longrightarrow> lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y\"", "lemma less_term:\n  assumes \"rep_nat_term x < rep_nat_term y\"\n  shows \"x < y\"", "lemma lex_comp_alt: \"lex_comp = (comparator_of::'a comparator)\"", "lemma full_component_zeroE: obtains x where \"rep_nat_term x = (t, 0)\"", "lemma comparator_lex_comp: \"comparator lex_comp\"", "lemma nat_term_comp_lex_comp: \"nat_term_comp lex_comp\"", "lemma comparator_deg_comp:\n  assumes \"comparator cmp\"\n  shows \"comparator (deg_comp cmp)\"", "lemma comparator_pot_comp:\n  assumes \"comparator cmp\"\n  shows \"comparator (pot_comp cmp)\"", "lemma deg_comp_zero_min:\n  assumes \"comparator cmp\" and \"snd (rep_nat_term u) = snd (rep_nat_term v)\" and \"fst (rep_nat_term u) = 0\"\n  shows \"deg_comp cmp u v \\<noteq> Gt\"", "lemma deg_comp_pos:\n  assumes \"cmp u v = Lt\" and \"fst (rep_nat_term u) = fst (rep_nat_term v)\"\n  shows \"deg_comp cmp u v = Lt\"", "lemma deg_comp_monotone:\n  assumes \"cmp u v = Lt \\<Longrightarrow> cmp (splus t u) (splus t v) = Lt\" and \"deg_comp cmp u v = Lt\"\n  shows \"deg_comp cmp (splus t u) (splus t v) = Lt\"", "lemma pot_comp_zero_min:\n  assumes \"cmp u v \\<noteq> Gt\" and \"snd (rep_nat_term u) = snd (rep_nat_term v)\"\n  shows \"pot_comp cmp u v \\<noteq> Gt\"", "lemma pot_comp_pos:\n  assumes \"snd (rep_nat_term u) < snd (rep_nat_term v)\"\n  shows \"pot_comp cmp u v = Lt\"", "lemma pot_comp_monotone:\n  assumes \"cmp u v = Lt \\<Longrightarrow> cmp (splus t u) (splus t v) = Lt\" and \"pot_comp cmp u v = Lt\"\n  shows \"pot_comp cmp (splus t u) (splus t v) = Lt\"", "lemma deg_comp_cong:\n  assumes \"deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v)) \\<Longrightarrow> to1 u v = to2 u v\"\n  shows \"deg_comp to1 u v = deg_comp to2 u v\"", "lemma pot_comp_cong:\n  assumes \"snd (rep_nat_term u) = snd (rep_nat_term v) \\<Longrightarrow> to1 u v = to2 u v\"\n  shows \"pot_comp to1 u v = pot_comp to2 u v\"", "lemma lookup_rep_nat_pp_pp:\n  \"lookup_pp (rep_nat_pp t) = (\\<lambda>n::nat. rep_nat (lookup_pp t (abs_nat n)))\"", "lemma lookup_abs_nat_pp_pp:\n  \"lookup_pp (abs_nat_pp t) = (\\<lambda>n::'a. abs_nat (lookup_pp t (rep_nat n)))\"", "lemma keys_rep_nat_pp_pp: \"keys_pp (rep_nat_pp t) = rep_nat ` keys_pp t\"", "lemma rep_nat_pp_pp_inverse: \"abs_nat_pp (rep_nat_pp x) = x\" for x::\"('a, 'b) pp\"", "lemma abs_nat_pp_pp_inverse: \"rep_nat_pp ((abs_nat_pp t)::('a, 'b) pp) = t\"", "lemma lex_rep_nat_pp: \"lex_pp (rep_nat_pp x) (rep_nat_pp y) \\<longleftrightarrow> lex_pp x y\"", "lemma deg_rep_nat_pp: \"deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)\" for t :: \"('a, 'b) pp\"", "lemma zero_pp_pp: \"rep_nat_pp (0::('a, 'b) pp) = 0\"", "lemma plus_pp_pp: \"rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y\"\n  for x y :: \"('a, 'b) pp\"", "lemmas [code del] = deg_pp.rep_eq plus_pp.abs_eq minus_pp.abs_eq", "lemma rep_nat_pp_nat [code_unfold]: \"(rep_nat_pp::(nat, nat) pp \\<Rightarrow> (nat, nat) pp) = (\\<lambda>x. x)\"", "lemma nat_term_compare_LEX [code]: \"nat_term_compare LEX = lex_comp\"", "lemma nat_term_compare_DRLEX [code]: \"nat_term_compare DRLEX = deg_comp (pot_comp (\\<lambda>x y. lex_comp y x))\"", "lemma nat_term_compare_DEG [code]: \"nat_term_compare (DEG to) = deg_comp (nat_term_compare to)\"", "lemma nat_term_compare_POT [code]: \"nat_term_compare (POT to) = pot_comp (nat_term_compare to)\"", "lemma nat_term_compare_POT_DRLEX [code]:\n  \"nat_term_compare (POT DRLEX) = pot_comp (deg_comp (\\<lambda>x y. lex_comp y x))\"", "lemma compute_lex_pp [code]: \"lex_pp p q = (lex_comp' p q \\<noteq> Gt)\"", "lemma compute_dlex_pp [code]: \"dlex_pp p q = (deg_comp lex_comp' p q \\<noteq> Gt)\"", "lemma compute_drlex_pp [code]: \"drlex_pp p q = (deg_comp (\\<lambda>x y. lex_comp' y x) p q \\<noteq> Gt)\"", "lemma nat_pp_order_of_le_nat_pp [code]: \"nat_term_order_of_le = LEX\"", "lemma nat_term_order_eqI:\n  assumes \"\\<And>u v. (dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))) \\<Longrightarrow>\n                  (ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)) \\<Longrightarrow>\n                  nat_term_compare to1 u v = nat_term_compare to2 u v\"\n  shows \"nat_term_order_eq to1 to2 dg ps\"", "lemma nat_term_order_eqD:\n  assumes \"nat_term_order_eq to1 to2 dg ps\"\n    and \"dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\"\n    and \"ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\"\n  shows \"nat_term_compare to1 u v = nat_term_compare to2 u v\"", "lemma nat_term_order_eq_sym: \"nat_term_order_eq to1 to2 dg ps \\<longleftrightarrow> nat_term_order_eq to2 to1 dg ps\"", "lemma nat_term_order_eq_DEG_dg:\n  \"nat_term_order_eq (DEG to1) to2 True ps \\<longleftrightarrow> nat_term_order_eq to1 to2 True ps\"", "lemma nat_term_order_eq_DEG_dg':\n  \"nat_term_order_eq to1 (DEG to2) True ps \\<longleftrightarrow> nat_term_order_eq to1 to2 True ps\"", "lemma nat_term_order_eq_POT_ps:\n  assumes \"ps \\<or> is_scalar TYPE('a::nat_term_compare)\"\n  shows \"nat_term_order_eq (POT (to1::'a nat_term_order)) to2 dg ps \\<longleftrightarrow> nat_term_order_eq to1 to2 dg ps\"", "lemma nat_term_order_eq_POT_ps':\n  assumes \"ps \\<or> is_scalar TYPE('a::nat_term_compare)\"\n  shows \"nat_term_order_eq to1 (POT (to2::'a nat_term_order)) dg ps \\<longleftrightarrow> nat_term_order_eq to1 to2 dg ps\"", "lemma snd_rep_nat_term_eqI:\n  assumes \"ps \\<or> is_scalar TYPE('a::nat_term_compare)\" and \"ps \\<Longrightarrow> snd (rep_nat_term (u::'a)) = snd (rep_nat_term (v::'a))\"\n  shows \"snd (rep_nat_term u) = snd (rep_nat_term v)\"", "lemma rep_nat_term_of_exps:\n  \"rep_nat_term ((of_exps a b i)::'a::nat_term_compare) =\n    (pp_of_fun (\\<lambda>x::nat. if x = 0 then a else if x = 1 then b else 0), if (\\<exists>y::'a. snd (rep_nat_term y) = i) then i else 0)\"", "lemma lookup_pp_of_exps:\n  \"lookup_pp (fst (rep_nat_term (of_exps a b i))) = (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0)\"", "lemma keys_pp_of_exps: \"keys_pp (fst (rep_nat_term (of_exps a b i))) \\<subseteq> {0, 1}\"", "lemma deg_pp_of_exps [simp]: \"deg_pp (fst (rep_nat_term ((of_exps a b i)::'a::nat_term_compare))) = a + b\"", "lemma snd_of_exps:\n  assumes \"snd (rep_nat_term (x::'a)) = i\"\n  shows \"snd (rep_nat_term ((of_exps a b i)::'a::nat_term_compare)) = i\"", "lemma snd_of_exps_zero [simp]: \"snd (rep_nat_term ((of_exps a b 0)::'a::nat_term_compare)) = 0\"", "lemma eq_of_exps:\n  \"(fst (rep_nat_term (of_exps a1 b1 i)) = fst (rep_nat_term (of_exps a2 b2 j))) \\<longleftrightarrow> (a1 = a2 \\<and> b1 = b2)\"", "lemma lex_pp_of_exps:\n  \"lex_pp (fst (rep_nat_term ((of_exps a1 b1 i)::'a))) (fst (rep_nat_term ((of_exps a2 b2 j)::'a::nat_term_compare))) \\<longleftrightarrow>\n    (a1 < a2 \\<or> (a1 = a2 \\<and> b1 \\<le> b2))\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma LEX_eq [code]:\n  \"nat_term_order_eq LEX (LEX::'a nat_term_order) dg ps = True\" (is ?thesis1)\n  \"nat_term_order_eq LEX (DRLEX::'a nat_term_order) dg ps = False\" (is ?thesis2)\n  \"nat_term_order_eq LEX (DEG (to::'a nat_term_order)) dg ps =\n    (dg \\<and> nat_term_order_eq LEX to dg ps)\" (is ?thesis3)\n  \"nat_term_order_eq LEX (POT (to::'a nat_term_order)) dg ps =\n    ((ps \\<or> is_scalar TYPE('a::nat_term_compare)) \\<and> nat_term_order_eq LEX to dg ps)\" (is ?thesis4)", "lemma DRLEX_eq [code]:\n  \"nat_term_order_eq DRLEX (LEX::'a nat_term_order) dg ps = False\" (is ?thesis1)\n  \"nat_term_order_eq DRLEX DRLEX dg ps = True\" (is ?thesis2)\n  \"nat_term_order_eq DRLEX (DEG (to::'a nat_term_order)) dg ps =\n    nat_term_order_eq DRLEX to True ps\" (is ?thesis3)\n  \"nat_term_order_eq DRLEX (POT (to::'a nat_term_order)) dg ps =\n    ((dg \\<or> ps \\<or> is_scalar TYPE('a::nat_term_compare)) \\<and> nat_term_order_eq DRLEX to dg True)\" (is ?thesis4)", "lemma DEG_eq [code]:\n  \"nat_term_order_eq (DEG to) (LEX::'a nat_term_order) dg ps = nat_term_order_eq LEX (DEG to) dg ps\"\n  \"nat_term_order_eq (DEG to) (DRLEX::'a nat_term_order) dg ps = nat_term_order_eq DRLEX (DEG to) dg ps\"\n  \"nat_term_order_eq (DEG to1) (DEG (to2::'a nat_term_order)) dg ps =\n    nat_term_order_eq to1 to2 True ps\" (is ?thesis3)\n  \"nat_term_order_eq (DEG to1) (POT (to2::'a nat_term_order)) dg ps =\n    (if dg then nat_term_order_eq to1 (POT to2) dg ps\n    else ((ps \\<or> is_scalar TYPE('a::nat_term_compare)) \\<and> nat_term_order_eq (DEG to1) to2 dg ps))\" (is ?thesis4)", "lemma POT_eq [code]:\n  \"nat_term_order_eq (POT to) LEX dg ps = nat_term_order_eq LEX (POT to) dg ps\"\n  \"nat_term_order_eq (POT to1) (DEG to2) dg ps = nat_term_order_eq (DEG to2) (POT to1) dg ps\"\n  \"nat_term_order_eq (POT to1) DRLEX dg ps = nat_term_order_eq DRLEX (POT to1) dg ps\"\n  \"nat_term_order_eq (POT to1) (POT (to2::'a::nat_term_compare nat_term_order)) dg ps =\n    nat_term_order_eq to1 to2 dg True\" (is ?thesis4)", "lemma nat_term_order_equal [code]: \"HOL.equal to1 to2 = nat_term_order_eq to1 to2 False False\""], "translations": [["", "lemma rep_inj:\n  assumes \"rep_nat x = rep_nat y\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have \"abs_nat (rep_nat x) = abs_nat (rep_nat y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_nat (rep_nat x) = abs_nat (rep_nat y)", "by (simp only: assms)"], ["proof (state)\nthis:\n  abs_nat (rep_nat x) = abs_nat (rep_nat y)\n\ngoal (1 subgoal):\n 1. x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  abs_nat (rep_nat x) = abs_nat (rep_nat y)\n\ngoal (1 subgoal):\n 1. x = y", "by (simp only: rep_inverse)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary rep_eq_iff: \"(rep_nat x = rep_nat y) \\<longleftrightarrow> (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rep_nat x = rep_nat y) = (x = y)", "by (auto elim: rep_inj)"], ["", "lemma abs_inj:\n  assumes \"abs_nat m = abs_nat n\"\n  shows \"m = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m = n", "have \"rep_nat (abs_nat m) = rep_nat (abs_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat (abs_nat m) = rep_nat (abs_nat n)", "by (simp only: assms)"], ["proof (state)\nthis:\n  rep_nat (abs_nat m) = rep_nat (abs_nat n)\n\ngoal (1 subgoal):\n 1. m = n", "thus ?thesis"], ["proof (prove)\nusing this:\n  rep_nat (abs_nat m) = rep_nat (abs_nat n)\n\ngoal (1 subgoal):\n 1. m = n", "by (simp only: abs_inverse)"], ["proof (state)\nthis:\n  m = n\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary abs_eq_iff: \"(abs_nat m = abs_nat n) \\<longleftrightarrow> (m = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (abs_nat m = abs_nat n) = (m = n)", "by (auto elim: abs_inj)"], ["", "lemma rep_zero [simp]: \"rep_nat 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat (0::'a) = 0", "using abs_inverse abs_zero"], ["proof (prove)\nusing this:\n  rep_nat (abs_nat ?n) = ?n\n  abs_nat 0 = (0::'a)\n\ngoal (1 subgoal):\n 1. rep_nat (0::'a) = 0", "by fastforce"], ["", "lemma rep_zero_iff: \"(rep_nat x = 0) \\<longleftrightarrow> (x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rep_nat x = 0) = (x = (0::'a))", "using rep_eq_iff"], ["proof (prove)\nusing this:\n  (rep_nat ?x = rep_nat ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. (rep_nat x = 0) = (x = (0::'a))", "by fastforce"], ["", "lemma plus_eq: \"x + y = abs_nat (rep_nat x + rep_nat y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = abs_nat (rep_nat x + rep_nat y)", "by (metis abs_plus rep_inverse)"], ["", "lemma rep_plus: \"rep_nat (x + y) = rep_nat x + rep_nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat (x + y) = rep_nat x + rep_nat y", "by (simp add: plus_eq)"], ["", "lemma minus_eq: \"x - y = abs_nat (rep_nat x - rep_nat y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y = abs_nat (rep_nat x - rep_nat y)", "by (metis abs_minus rep_inverse)"], ["", "lemma rep_minus: \"rep_nat (x - y) = rep_nat x - rep_nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat (x - y) = rep_nat x - rep_nat y", "by (simp add: minus_eq)"], ["", "lemma ord_iff:\n  \"x \\<le> y \\<longleftrightarrow> rep_nat x \\<le> rep_nat y\" (is ?thesis1)\n  \"x < y \\<longleftrightarrow> rep_nat x < rep_nat y\" (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (rep_nat x \\<le> rep_nat y) &&&\n    (x < y) = (rep_nat x < rep_nat y)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (x \\<le> y) = (rep_nat x \\<le> rep_nat y)\n 2. (x < y) = (rep_nat x < rep_nat y)", "show ?thesis1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (rep_nat x \\<le> rep_nat y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> rep_nat x \\<le> rep_nat y\n 2. rep_nat x \\<le> rep_nat y \\<Longrightarrow> x \\<le> y", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> rep_nat x \\<le> rep_nat y\n 2. rep_nat x \\<le> rep_nat y \\<Longrightarrow> x \\<le> y", "show \"rep_nat x \\<le> rep_nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat x \\<le> rep_nat y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> rep_nat x \\<le> rep_nat y \\<Longrightarrow> False", "assume \"\\<not> rep_nat x \\<le> rep_nat y\""], ["proof (state)\nthis:\n  \\<not> rep_nat x \\<le> rep_nat y\n\ngoal (1 subgoal):\n 1. \\<not> rep_nat x \\<le> rep_nat y \\<Longrightarrow> False", "hence \"rep_nat y \\<le> rep_nat x\" and \"rep_nat x \\<noteq> rep_nat y\""], ["proof (prove)\nusing this:\n  \\<not> rep_nat x \\<le> rep_nat y\n\ngoal (1 subgoal):\n 1. rep_nat y \\<le> rep_nat x &&& rep_nat x \\<noteq> rep_nat y", "by simp_all"], ["proof (state)\nthis:\n  rep_nat y \\<le> rep_nat x\n  rep_nat x \\<noteq> rep_nat y\n\ngoal (1 subgoal):\n 1. \\<not> rep_nat x \\<le> rep_nat y \\<Longrightarrow> False", "from this(1)"], ["proof (chain)\npicking this:\n  rep_nat y \\<le> rep_nat x", "have \"abs_nat (rep_nat y) \\<le> abs_nat (rep_nat x)\""], ["proof (prove)\nusing this:\n  rep_nat y \\<le> rep_nat x\n\ngoal (1 subgoal):\n 1. abs_nat (rep_nat y) \\<le> abs_nat (rep_nat x)", "by (rule abs_ord)"], ["proof (state)\nthis:\n  abs_nat (rep_nat y) \\<le> abs_nat (rep_nat x)\n\ngoal (1 subgoal):\n 1. \\<not> rep_nat x \\<le> rep_nat y \\<Longrightarrow> False", "hence \"y \\<le> x\""], ["proof (prove)\nusing this:\n  abs_nat (rep_nat y) \\<le> abs_nat (rep_nat x)\n\ngoal (1 subgoal):\n 1. y \\<le> x", "by (simp only: rep_inverse)"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> rep_nat x \\<le> rep_nat y \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> rep_nat x \\<le> rep_nat y \\<Longrightarrow> False", "from \\<open>rep_nat x \\<noteq> rep_nat y\\<close>"], ["proof (chain)\npicking this:\n  rep_nat x \\<noteq> rep_nat y", "have \"y \\<noteq> x\""], ["proof (prove)\nusing this:\n  rep_nat x \\<noteq> rep_nat y\n\ngoal (1 subgoal):\n 1. y \\<noteq> x", "using rep_inj"], ["proof (prove)\nusing this:\n  rep_nat x \\<noteq> rep_nat y\n  rep_nat ?x = rep_nat ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. y \\<noteq> x", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<not> rep_nat x \\<le> rep_nat y \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  y \\<le> x\n  y \\<noteq> x", "have \"y < x\""], ["proof (prove)\nusing this:\n  y \\<le> x\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. y < x", "by simp"], ["proof (state)\nthis:\n  y < x\n\ngoal (1 subgoal):\n 1. \\<not> rep_nat x \\<le> rep_nat y \\<Longrightarrow> False", "with \\<open>x \\<le> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y < x", "show False"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y < x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rep_nat x \\<le> rep_nat y\n\ngoal (1 subgoal):\n 1. rep_nat x \\<le> rep_nat y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rep_nat x \\<le> rep_nat y \\<Longrightarrow> x \\<le> y", "assume \"rep_nat x \\<le> rep_nat y\""], ["proof (state)\nthis:\n  rep_nat x \\<le> rep_nat y\n\ngoal (1 subgoal):\n 1. rep_nat x \\<le> rep_nat y \\<Longrightarrow> x \\<le> y", "hence \"abs_nat (rep_nat x) \\<le> abs_nat (rep_nat y)\""], ["proof (prove)\nusing this:\n  rep_nat x \\<le> rep_nat y\n\ngoal (1 subgoal):\n 1. abs_nat (rep_nat x) \\<le> abs_nat (rep_nat y)", "by (rule abs_ord)"], ["proof (state)\nthis:\n  abs_nat (rep_nat x) \\<le> abs_nat (rep_nat y)\n\ngoal (1 subgoal):\n 1. rep_nat x \\<le> rep_nat y \\<Longrightarrow> x \\<le> y", "thus \"x \\<le> y\""], ["proof (prove)\nusing this:\n  abs_nat (rep_nat x) \\<le> abs_nat (rep_nat y)\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (simp only: rep_inverse)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<le> y) = (rep_nat x \\<le> rep_nat y)\n\ngoal (1 subgoal):\n 1. (x < y) = (rep_nat x < rep_nat y)", "thus ?thesis2"], ["proof (prove)\nusing this:\n  (x \\<le> y) = (rep_nat x \\<le> rep_nat y)\n\ngoal (1 subgoal):\n 1. (x < y) = (rep_nat x < rep_nat y)", "using rep_inj[of x y]"], ["proof (prove)\nusing this:\n  (x \\<le> y) = (rep_nat x \\<le> rep_nat y)\n  rep_nat x = rep_nat y \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. (x < y) = (rep_nat x < rep_nat y)", "by (auto simp: less_le Nat.nat_less_le)"], ["proof (state)\nthis:\n  (x < y) = (rep_nat x < rep_nat y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_iff_abs: \"(\\<exists>x::'a. P x) \\<longleftrightarrow> (\\<exists>n::nat. P (abs_nat n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. P x) = (\\<exists>n. P (abs_nat n))", "by (metis rep_inverse)"], ["", "lemma ex_iff_abs': \"(\\<exists>x<abs_nat m. P x) \\<longleftrightarrow> (\\<exists>n::nat<m. P (abs_nat n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x<abs_nat m. P x) = (\\<exists>n<m. P (abs_nat n))", "by (metis abs_inverse rep_inverse ord_iff(2))"], ["", "lemma all_iff_abs: \"(\\<forall>x::'a. P x) \\<longleftrightarrow> (\\<forall>n::nat. P (abs_nat n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. P x) = (\\<forall>n. P (abs_nat n))", "by (metis rep_inverse)"], ["", "lemma all_iff_abs': \"(\\<forall>x<abs_nat m. P x) \\<longleftrightarrow> (\\<forall>n::nat<m. P (abs_nat n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x<abs_nat m. P x) = (\\<forall>n<m. P (abs_nat n))", "by (metis abs_inverse rep_inverse ord_iff(2))"], ["", "subclass linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (\\<le>) (<)", "by (standard, auto simp: ord_iff rep_inj)"], ["", "lemma comparator_of_rep [simp]: \"comparator_of (rep_nat x) (rep_nat y) = comparator_of x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator_of (rep_nat x) (rep_nat y) = comparator_of x y", "by (simp add: comparator_of_def linorder_class.comparator_of_def ord_iff rep_inj)"], ["", "subclass wellorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.wellorder (\\<le>) (<)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "fix P::\"'a \\<Rightarrow> bool\" and a::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "let ?P = \"\\<lambda>n::nat. P (abs_nat n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "assume a: \"\\<And>x. (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow> P x\""], ["proof (state)\nthis:\n  (\\<And>y. y < ?x \\<Longrightarrow> P y) \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "have \"P (abs_nat (rep_nat a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (abs_nat (rep_nat a))", "proof (rule less_induct[of _ \"rep_nat a\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y. y < x \\<Longrightarrow> P (abs_nat y)) \\<Longrightarrow>\n       P (abs_nat x)", "fix n::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y. y < x \\<Longrightarrow> P (abs_nat y)) \\<Longrightarrow>\n       P (abs_nat x)", "assume b: \"\\<And>m. m < n \\<Longrightarrow> ?P m\""], ["proof (state)\nthis:\n  ?m < n \\<Longrightarrow> P (abs_nat ?m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y. y < x \\<Longrightarrow> P (abs_nat y)) \\<Longrightarrow>\n       P (abs_nat x)", "show \"?P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (abs_nat n)", "proof (rule a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y < abs_nat n \\<Longrightarrow> P y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y < abs_nat n \\<Longrightarrow> P y", "assume \"y < abs_nat n\""], ["proof (state)\nthis:\n  y < abs_nat n\n\ngoal (1 subgoal):\n 1. \\<And>y. y < abs_nat n \\<Longrightarrow> P y", "hence \"rep_nat y < n\""], ["proof (prove)\nusing this:\n  y < abs_nat n\n\ngoal (1 subgoal):\n 1. rep_nat y < n", "by (simp only: ord_iff abs_inverse)"], ["proof (state)\nthis:\n  rep_nat y < n\n\ngoal (1 subgoal):\n 1. \\<And>y. y < abs_nat n \\<Longrightarrow> P y", "hence \"?P (rep_nat y)\""], ["proof (prove)\nusing this:\n  rep_nat y < n\n\ngoal (1 subgoal):\n 1. P (abs_nat (rep_nat y))", "by (rule b)"], ["proof (state)\nthis:\n  P (abs_nat (rep_nat y))\n\ngoal (1 subgoal):\n 1. \\<And>y. y < abs_nat n \\<Longrightarrow> P y", "thus \"P y\""], ["proof (prove)\nusing this:\n  P (abs_nat (rep_nat y))\n\ngoal (1 subgoal):\n 1. P y", "by (simp only: rep_inverse)"], ["proof (state)\nthis:\n  P y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (abs_nat n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (abs_nat (rep_nat a))\n\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "thus \"P a\""], ["proof (prove)\nusing this:\n  P (abs_nat (rep_nat a))\n\ngoal (1 subgoal):\n 1. P a", "by (simp only: rep_inverse)"], ["proof (state)\nthis:\n  P a\n\ngoal:\nNo subgoals!", "qed"], ["", "subclass comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_monoid_add (+) (0::'a)", "by (standard, auto simp: plus_eq intro: arg_cong)"], ["", "lemma sum_rep: \"sum (rep_nat \\<circ> f) A = rep_nat (sum f A)\" for f :: \"'b \\<Rightarrow> 'a\" and A :: \"'b set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (rep_nat \\<circ> f) A = rep_nat (sum f A)", "proof (induct A rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       sum (rep_nat \\<circ> f) A = rep_nat (sum f A)\n 2. sum (rep_nat \\<circ> f) {} = rep_nat (sum f {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum (rep_nat \\<circ> f) F = rep_nat (sum f F)\\<rbrakk>\n       \\<Longrightarrow> sum (rep_nat \\<circ> f) (insert x F) =\n                         rep_nat (sum f (insert x F))", "case (infinite A)"], ["proof (state)\nthis:\n  infinite A\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       sum (rep_nat \\<circ> f) A = rep_nat (sum f A)\n 2. sum (rep_nat \\<circ> f) {} = rep_nat (sum f {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum (rep_nat \\<circ> f) F = rep_nat (sum f F)\\<rbrakk>\n       \\<Longrightarrow> sum (rep_nat \\<circ> f) (insert x F) =\n                         rep_nat (sum f (insert x F))", "thus ?case"], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. sum (rep_nat \\<circ> f) A = rep_nat (sum f A)", "by simp"], ["proof (state)\nthis:\n  sum (rep_nat \\<circ> f) A = rep_nat (sum f A)\n\ngoal (2 subgoals):\n 1. sum (rep_nat \\<circ> f) {} = rep_nat (sum f {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum (rep_nat \\<circ> f) F = rep_nat (sum f F)\\<rbrakk>\n       \\<Longrightarrow> sum (rep_nat \\<circ> f) (insert x F) =\n                         rep_nat (sum f (insert x F))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sum (rep_nat \\<circ> f) {} = rep_nat (sum f {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum (rep_nat \\<circ> f) F = rep_nat (sum f F)\\<rbrakk>\n       \\<Longrightarrow> sum (rep_nat \\<circ> f) (insert x F) =\n                         rep_nat (sum f (insert x F))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sum (rep_nat \\<circ> f) {} = rep_nat (sum f {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum (rep_nat \\<circ> f) F = rep_nat (sum f F)\\<rbrakk>\n       \\<Longrightarrow> sum (rep_nat \\<circ> f) (insert x F) =\n                         rep_nat (sum f (insert x F))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (rep_nat \\<circ> f) {} = rep_nat (sum f {})", "by simp"], ["proof (state)\nthis:\n  sum (rep_nat \\<circ> f) {} = rep_nat (sum f {})\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum (rep_nat \\<circ> f) F = rep_nat (sum f F)\\<rbrakk>\n       \\<Longrightarrow> sum (rep_nat \\<circ> f) (insert x F) =\n                         rep_nat (sum f (insert x F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum (rep_nat \\<circ> f) F = rep_nat (sum f F)\\<rbrakk>\n       \\<Longrightarrow> sum (rep_nat \\<circ> f) (insert x F) =\n                         rep_nat (sum f (insert x F))", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  sum (rep_nat \\<circ> f) A = rep_nat (sum f A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum (rep_nat \\<circ> f) F = rep_nat (sum f F)\\<rbrakk>\n       \\<Longrightarrow> sum (rep_nat \\<circ> f) (insert x F) =\n                         rep_nat (sum f (insert x F))", "from insert(1, 2)"], ["proof (chain)\npicking this:\n  finite A\n  a \\<notin> A", "show ?case"], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. sum (rep_nat \\<circ> f) (insert a A) = rep_nat (sum f (insert a A))", "by (simp del: comp_apply add: insert(3) rep_plus, simp)"], ["proof (state)\nthis:\n  sum (rep_nat \\<circ> f) (insert a A) = rep_nat (sum f (insert a A))\n\ngoal:\nNo subgoals!", "qed"], ["", "subclass ordered_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ordered_comm_monoid_add (+) (0::'a) (\\<le>) (<)", "by (standard, simp add: ord_iff plus_eq)"], ["", "subclass countable"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.countable TYPE('a)", "by intro_classes (intro exI[of _ rep_nat] injI, elim rep_inj)"], ["", "subclass cancel_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.cancel_comm_monoid_add (+) (-) (0::'a)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b. a + b - a = b\n 2. \\<And>a b c. a - b - c = a - (b + c)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ + b_ - a_ = b_", "by (simp add: minus_eq rep_plus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. a - b - c = a - (b + c)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ - b_ - c_ = a_ - (b_ + c_)", "by (simp add: minus_eq rep_plus)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subclass add_wellorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.add_wellorder (\\<le>) (<) (+) (-) (0::'a)", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c a b. c + a \\<le> c + b \\<Longrightarrow> a \\<le> b\n 2. \\<And>a b. a \\<le> b \\<Longrightarrow> \\<exists>c. b = a + c\n 3. \\<And>x. (0::'a) \\<le> x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ + a_ \\<le> c_ + b_ \\<Longrightarrow> a_ \\<le> b_", "by (simp add: ord_iff rep_plus)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b. a \\<le> b \\<Longrightarrow> \\<exists>c. b = a + c\n 2. \\<And>x. (0::'a) \\<le> x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<le> b_ \\<Longrightarrow> \\<exists>c. b_ = a_ + c", "unfolding ord_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat a_ \\<le> rep_nat b_ \\<Longrightarrow> \\<exists>c. b_ = a_ + c", "by (drule le_imp_add, metis abs_plus rep_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (0::'a) \\<le> x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x_", "by (simp add: ord_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma the_min_eq_zero: \"the_min = (0::'a::{the_min,nat})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_min = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. the_min = (0::'a)", "have \"the_min \\<le> (0::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_min \\<le> (0::'a)", "by (fact the_min_min)"], ["proof (state)\nthis:\n  the_min \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. the_min = (0::'a)", "hence \"rep_nat (the_min::'a) \\<le> rep_nat (0::'a)\""], ["proof (prove)\nusing this:\n  the_min \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. rep_nat the_min \\<le> rep_nat (0::'a)", "by (simp only: ord_iff)"], ["proof (state)\nthis:\n  rep_nat the_min \\<le> rep_nat (0::'a)\n\ngoal (1 subgoal):\n 1. the_min = (0::'a)", "also"], ["proof (state)\nthis:\n  rep_nat the_min \\<le> rep_nat (0::'a)\n\ngoal (1 subgoal):\n 1. the_min = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat (0::'a) = 0", "by simp"], ["proof (state)\nthis:\n  rep_nat (0::'a) = 0\n\ngoal (1 subgoal):\n 1. the_min = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  rep_nat the_min \\<le> 0", "have \"rep_nat (the_min::'a) = 0\""], ["proof (prove)\nusing this:\n  rep_nat the_min \\<le> 0\n\ngoal (1 subgoal):\n 1. rep_nat the_min = 0", "by simp"], ["proof (state)\nthis:\n  rep_nat the_min = 0\n\ngoal (1 subgoal):\n 1. the_min = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  rep_nat the_min = 0\n\ngoal (1 subgoal):\n 1. the_min = (0::'a)", "by (simp only: rep_zero_iff)"], ["proof (state)\nthis:\n  the_min = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation nat :: nat\nbegin"], ["", "definition rep_nat_nat :: \"nat \\<Rightarrow> nat\" where rep_nat_nat_def [code_unfold]: \"rep_nat_nat = (\\<lambda>x. x)\""], ["", "definition abs_nat_nat :: \"nat \\<Rightarrow> nat\" where abs_nat_nat_def [code_unfold]: \"abs_nat_nat = (\\<lambda>x. x)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, nat_class)", "by (standard, simp_all add: rep_nat_nat_def abs_nat_nat_def)"], ["", "end"], ["", "instantiation natural :: nat\nbegin"], ["", "definition rep_nat_natural :: \"natural \\<Rightarrow> nat\"\n  where rep_nat_natural_def [code_unfold]: \"rep_nat_natural = nat_of_natural\""], ["", "definition abs_nat_natural :: \"nat \\<Rightarrow> natural\"\n  where abs_nat_natural_def [code_unfold]: \"abs_nat_natural = natural_of_nat\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(natural, nat_class)", "by (standard, simp_all add: rep_nat_natural_def abs_nat_natural_def, metis minus_natural.rep_eq nat_of_natural_of_nat of_nat_of_natural)"], ["", "end"], ["", "subsection \\<open>Term Orders\\<close>"], ["", "subsubsection \\<open>Type Classes\\<close>"], ["", "class nat_pp_compare = linorder + zero + plus +\n  fixes rep_nat_pp :: \"'a \\<Rightarrow> (nat, nat) pp\"\n    and abs_nat_pp :: \"(nat, nat) pp \\<Rightarrow> 'a\"\n    and lex_comp' :: \"'a comparator\"\n    and deg' :: \"'a \\<Rightarrow> nat\"\n  assumes rep_nat_pp_inverse [simp]: \"abs_nat_pp (rep_nat_pp x) = x\"\n    and abs_nat_pp_inverse [simp]: \"rep_nat_pp (abs_nat_pp t) = t\"\n    and lex_comp': \"lex_comp' x y = comp_of_ord lex_pp (rep_nat_pp x) (rep_nat_pp y)\"\n    and deg': \"deg' x = deg_pp (rep_nat_pp x)\"\n    and le_pp: \"rep_nat_pp x \\<le> rep_nat_pp y \\<Longrightarrow> x \\<le> y\"\n    and zero_pp: \"rep_nat_pp 0 = 0\"\n    and plus_pp: \"rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y\"\nbegin"], ["", "lemma less_pp:\n  assumes \"rep_nat_pp x < rep_nat_pp y\"\n  shows \"x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < y", "from assms"], ["proof (chain)\npicking this:\n  rep_nat_pp x < rep_nat_pp y", "have 1: \"rep_nat_pp x \\<le> rep_nat_pp y\" and 2: \"rep_nat_pp x \\<noteq> rep_nat_pp y\""], ["proof (prove)\nusing this:\n  rep_nat_pp x < rep_nat_pp y\n\ngoal (1 subgoal):\n 1. rep_nat_pp x \\<le> rep_nat_pp y &&& rep_nat_pp x \\<noteq> rep_nat_pp y", "by simp_all"], ["proof (state)\nthis:\n  rep_nat_pp x \\<le> rep_nat_pp y\n  rep_nat_pp x \\<noteq> rep_nat_pp y\n\ngoal (1 subgoal):\n 1. x < y", "from 1"], ["proof (chain)\npicking this:\n  rep_nat_pp x \\<le> rep_nat_pp y", "have \"x \\<le> y\""], ["proof (prove)\nusing this:\n  rep_nat_pp x \\<le> rep_nat_pp y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (rule le_pp)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x < y", "moreover"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x < y", "from 2"], ["proof (chain)\npicking this:\n  rep_nat_pp x \\<noteq> rep_nat_pp y", "have \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  rep_nat_pp x \\<noteq> rep_nat_pp y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x < y", "ultimately"], ["proof (chain)\npicking this:\n  x \\<le> y\n  x \\<noteq> y", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x < y", "by simp"], ["proof (state)\nthis:\n  x < y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rep_nat_pp_inj:\n  assumes \"rep_nat_pp x = rep_nat_pp y\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have \"abs_nat_pp (rep_nat_pp x) = abs_nat_pp (rep_nat_pp y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_nat_pp (rep_nat_pp x) = abs_nat_pp (rep_nat_pp y)", "by (simp only: assms)"], ["proof (state)\nthis:\n  abs_nat_pp (rep_nat_pp x) = abs_nat_pp (rep_nat_pp y)\n\ngoal (1 subgoal):\n 1. x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  abs_nat_pp (rep_nat_pp x) = abs_nat_pp (rep_nat_pp y)\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_comp'_EqD:\n  assumes \"lex_comp' x y = Eq\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (rule rep_nat_pp_inj)"], ["proof (state)\ngoal (1 subgoal):\n 1. rep_nat_pp x = rep_nat_pp y", "from assms"], ["proof (chain)\npicking this:\n  lex_comp' x y = Eq", "show \"rep_nat_pp x = rep_nat_pp y\""], ["proof (prove)\nusing this:\n  lex_comp' x y = Eq\n\ngoal (1 subgoal):\n 1. rep_nat_pp x = rep_nat_pp y", "by (simp add: lex_comp' comp_of_ord_def split: if_split_asm)"], ["proof (state)\nthis:\n  rep_nat_pp x = rep_nat_pp y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_comp'_valE:\n  assumes \"lex_comp' s t \\<noteq> Eq\"\n  obtains x where \"x \\<in> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\"\n    and \"comparator_of (lookup_pp (rep_nat_pp s) x) (lookup_pp (rep_nat_pp t) x) = lex_comp' s t\"\n    and \"\\<And>y. y < x \\<Longrightarrow> lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                         keys_pp (rep_nat_pp t);\n         comparator_of (lookup_pp (rep_nat_pp s) x)\n          (lookup_pp (rep_nat_pp t) x) =\n         lex_comp' s t;\n         \\<And>y.\n            y < x \\<Longrightarrow>\n            lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"lex_comp' s t\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Eq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Lt\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "case Eq"], ["proof (state)\nthis:\n  lex_comp' s t = Eq\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Eq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Lt\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms"], ["proof (chain)\npicking this:\n  lex_comp' s t \\<noteq> Eq\n  lex_comp' s t = Eq", "show ?thesis"], ["proof (prove)\nusing this:\n  lex_comp' s t \\<noteq> Eq\n  lex_comp' s t = Eq\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Lt\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Lt\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "case Lt"], ["proof (state)\nthis:\n  lex_comp' s t = Lt\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Lt\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"rep_nat_pp s \\<noteq> rep_nat_pp t\" and \"lex_pp (rep_nat_pp s) (rep_nat_pp t)\""], ["proof (prove)\nusing this:\n  lex_comp' s t = Lt\n\ngoal (1 subgoal):\n 1. rep_nat_pp s \\<noteq> rep_nat_pp t &&&\n    lex_pp (rep_nat_pp s) (rep_nat_pp t)", "by (auto simp: lex_comp' comp_of_ord_def split: if_split_asm)"], ["proof (state)\nthis:\n  rep_nat_pp s \\<noteq> rep_nat_pp t\n  lex_pp (rep_nat_pp s) (rep_nat_pp t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Lt\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<exists>x. lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x \\<and>\n             (\\<forall>y<x. lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y)\""], ["proof (prove)\nusing this:\n  rep_nat_pp s \\<noteq> rep_nat_pp t\n  lex_pp (rep_nat_pp s) (rep_nat_pp t)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y)", "by (simp add: lex_pp_alt)"], ["proof (state)\nthis:\n  \\<exists>x.\n     lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x \\<and>\n     (\\<forall>y<x. lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Lt\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x \\<and>\n     (\\<forall>y<x. lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y)", "obtain x where 1: \"lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x\"\n    and 2: \"\\<And>y. y < x \\<Longrightarrow> lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x \\<and>\n     (\\<forall>y<x. lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x;\n         \\<And>y.\n            y < x \\<Longrightarrow>\n            lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x\n  ?y < x \\<Longrightarrow>\n  lookup_pp (rep_nat_pp s) ?y = lookup_pp (rep_nat_pp t) ?y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Lt\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?x \\<in> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\n 2. comparator_of (lookup_pp (rep_nat_pp s) ?x)\n     (lookup_pp (rep_nat_pp t) ?x) =\n    lex_comp' s t\n 3. \\<And>y.\n       y < ?x \\<Longrightarrow>\n       lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y", "show \"x \\<in> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> keys_pp (rep_nat_pp s) \\<union>\n               keys_pp (rep_nat_pp t) \\<Longrightarrow>\n    False", "assume \"x \\<notin> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\""], ["proof (state)\nthis:\n  x \\<notin> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\n\ngoal (1 subgoal):\n 1. x \\<notin> keys_pp (rep_nat_pp s) \\<union>\n               keys_pp (rep_nat_pp t) \\<Longrightarrow>\n    False", "with 1"], ["proof (chain)\npicking this:\n  lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x\n  x \\<notin> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)", "show False"], ["proof (prove)\nusing this:\n  lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x\n  x \\<notin> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: keys_pp_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\n\ngoal (2 subgoals):\n 1. comparator_of (lookup_pp (rep_nat_pp s) x)\n     (lookup_pp (rep_nat_pp t) x) =\n    lex_comp' s t\n 2. \\<And>y.\n       y < x \\<Longrightarrow>\n       lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comparator_of (lookup_pp (rep_nat_pp s) x)\n     (lookup_pp (rep_nat_pp t) x) =\n    lex_comp' s t\n 2. \\<And>y.\n       y < x \\<Longrightarrow>\n       lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y", "show \"comparator_of (lookup_pp (rep_nat_pp s) x) (lookup_pp (rep_nat_pp t) x) = lex_comp' s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator_of (lookup_pp (rep_nat_pp s) x)\n     (lookup_pp (rep_nat_pp t) x) =\n    lex_comp' s t", "by (simp add: linorder_class.comparator_of_def 1 Lt)"], ["proof (state)\nthis:\n  comparator_of (lookup_pp (rep_nat_pp s) x) (lookup_pp (rep_nat_pp t) x) =\n  lex_comp' s t\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < x \\<Longrightarrow>\n       lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y", "qed (fact 2)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "case Gt"], ["proof (state)\nthis:\n  lex_comp' s t = Gt\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<not> lex_pp (rep_nat_pp s) (rep_nat_pp t)\""], ["proof (prove)\nusing this:\n  lex_comp' s t = Gt\n\ngoal (1 subgoal):\n 1. \\<not> lex_pp (rep_nat_pp s) (rep_nat_pp t)", "by (auto simp: lex_comp' comp_of_ord_def split: if_split_asm)"], ["proof (state)\nthis:\n  \\<not> lex_pp (rep_nat_pp s) (rep_nat_pp t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"lex_pp (rep_nat_pp t) (rep_nat_pp s)\""], ["proof (prove)\nusing this:\n  \\<not> lex_pp (rep_nat_pp s) (rep_nat_pp t)\n\ngoal (1 subgoal):\n 1. lex_pp (rep_nat_pp t) (rep_nat_pp s)", "by (rule lex_pp_lin')"], ["proof (state)\nthis:\n  lex_pp (rep_nat_pp t) (rep_nat_pp s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  lex_pp (rep_nat_pp t) (rep_nat_pp s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"rep_nat_pp t \\<noteq> rep_nat_pp s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_pp t \\<noteq> rep_nat_pp s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. rep_nat_pp t = rep_nat_pp s \\<Longrightarrow> False", "assume \"rep_nat_pp t = rep_nat_pp s\""], ["proof (state)\nthis:\n  rep_nat_pp t = rep_nat_pp s\n\ngoal (1 subgoal):\n 1. rep_nat_pp t = rep_nat_pp s \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  rep_nat_pp t = rep_nat_pp s\n\ngoal (1 subgoal):\n 1. rep_nat_pp t = rep_nat_pp s \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  rep_nat_pp t = rep_nat_pp s", "have \"lex_pp (rep_nat_pp s) (rep_nat_pp t)\""], ["proof (prove)\nusing this:\n  rep_nat_pp t = rep_nat_pp s\n\ngoal (1 subgoal):\n 1. lex_pp (rep_nat_pp s) (rep_nat_pp t)", "by (simp add: lex_pp_refl)"], ["proof (state)\nthis:\n  lex_pp (rep_nat_pp s) (rep_nat_pp t)\n\ngoal (1 subgoal):\n 1. rep_nat_pp t = rep_nat_pp s \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  rep_nat_pp t = rep_nat_pp s\n  lex_pp (rep_nat_pp s) (rep_nat_pp t)", "have \"lex_comp' s t = Eq\""], ["proof (prove)\nusing this:\n  rep_nat_pp t = rep_nat_pp s\n  lex_pp (rep_nat_pp s) (rep_nat_pp t)\n\ngoal (1 subgoal):\n 1. lex_comp' s t = Eq", "by (simp add: lex_comp' comp_of_ord_def)"], ["proof (state)\nthis:\n  lex_comp' s t = Eq\n\ngoal (1 subgoal):\n 1. rep_nat_pp t = rep_nat_pp s \\<Longrightarrow> False", "with Gt"], ["proof (chain)\npicking this:\n  lex_comp' s t = Gt\n  lex_comp' s t = Eq", "show False"], ["proof (prove)\nusing this:\n  lex_comp' s t = Gt\n  lex_comp' s t = Eq\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rep_nat_pp t \\<noteq> rep_nat_pp s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  lex_pp (rep_nat_pp t) (rep_nat_pp s)\n  rep_nat_pp t \\<noteq> rep_nat_pp s", "have \"\\<exists>x. lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x \\<and>\n                    (\\<forall>y<x. lookup_pp (rep_nat_pp t) y = lookup_pp (rep_nat_pp s) y)\""], ["proof (prove)\nusing this:\n  lex_pp (rep_nat_pp t) (rep_nat_pp s)\n  rep_nat_pp t \\<noteq> rep_nat_pp s\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (rep_nat_pp t) y = lookup_pp (rep_nat_pp s) y)", "by (simp add: lex_pp_alt)"], ["proof (state)\nthis:\n  \\<exists>x.\n     lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x \\<and>\n     (\\<forall>y<x. lookup_pp (rep_nat_pp t) y = lookup_pp (rep_nat_pp s) y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x \\<and>\n     (\\<forall>y<x. lookup_pp (rep_nat_pp t) y = lookup_pp (rep_nat_pp s) y)", "obtain x where 1: \"lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x\"\n    and 2: \"\\<And>y. y < x \\<Longrightarrow> lookup_pp (rep_nat_pp t) y = lookup_pp (rep_nat_pp s) y\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x \\<and>\n     (\\<forall>y<x. lookup_pp (rep_nat_pp t) y = lookup_pp (rep_nat_pp s) y)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x;\n         \\<And>y.\n            y < x \\<Longrightarrow>\n            lookup_pp (rep_nat_pp t) y = lookup_pp (rep_nat_pp s) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x\n  ?y < x \\<Longrightarrow>\n  lookup_pp (rep_nat_pp t) ?y = lookup_pp (rep_nat_pp s) ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> keys_pp (rep_nat_pp s) \\<union>\n                                 keys_pp (rep_nat_pp t);\n                 comparator_of (lookup_pp (rep_nat_pp s) x)\n                  (lookup_pp (rep_nat_pp t) x) =\n                 lex_comp' s t;\n                 \\<And>y.\n                    y < x \\<Longrightarrow>\n                    lookup_pp (rep_nat_pp s) y =\n                    lookup_pp (rep_nat_pp t) y\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lex_comp' s t = Gt\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?x \\<in> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\n 2. comparator_of (lookup_pp (rep_nat_pp s) ?x)\n     (lookup_pp (rep_nat_pp t) ?x) =\n    lex_comp' s t\n 3. \\<And>y.\n       y < ?x \\<Longrightarrow>\n       lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y", "show \"x \\<in> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> keys_pp (rep_nat_pp s) \\<union>\n               keys_pp (rep_nat_pp t) \\<Longrightarrow>\n    False", "assume \"x \\<notin> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\""], ["proof (state)\nthis:\n  x \\<notin> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\n\ngoal (1 subgoal):\n 1. x \\<notin> keys_pp (rep_nat_pp s) \\<union>\n               keys_pp (rep_nat_pp t) \\<Longrightarrow>\n    False", "with 1"], ["proof (chain)\npicking this:\n  lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x\n  x \\<notin> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)", "show False"], ["proof (prove)\nusing this:\n  lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x\n  x \\<notin> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: keys_pp_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> keys_pp (rep_nat_pp s) \\<union> keys_pp (rep_nat_pp t)\n\ngoal (2 subgoals):\n 1. comparator_of (lookup_pp (rep_nat_pp s) x)\n     (lookup_pp (rep_nat_pp t) x) =\n    lex_comp' s t\n 2. \\<And>y.\n       y < x \\<Longrightarrow>\n       lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comparator_of (lookup_pp (rep_nat_pp s) x)\n     (lookup_pp (rep_nat_pp t) x) =\n    lex_comp' s t\n 2. \\<And>y.\n       y < x \\<Longrightarrow>\n       lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y", "from 1"], ["proof (chain)\npicking this:\n  lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x", "have \"\\<not> lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x\"\n      and \"lookup_pp (rep_nat_pp s) x \\<noteq> lookup_pp (rep_nat_pp t) x\""], ["proof (prove)\nusing this:\n  lookup_pp (rep_nat_pp t) x < lookup_pp (rep_nat_pp s) x\n\ngoal (1 subgoal):\n 1. \\<not> lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x &&&\n    lookup_pp (rep_nat_pp s) x \\<noteq> lookup_pp (rep_nat_pp t) x", "by simp_all"], ["proof (state)\nthis:\n  \\<not> lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x\n  lookup_pp (rep_nat_pp s) x \\<noteq> lookup_pp (rep_nat_pp t) x\n\ngoal (2 subgoals):\n 1. comparator_of (lookup_pp (rep_nat_pp s) x)\n     (lookup_pp (rep_nat_pp t) x) =\n    lex_comp' s t\n 2. \\<And>y.\n       y < x \\<Longrightarrow>\n       lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y", "thus \"comparator_of (lookup_pp (rep_nat_pp s) x) (lookup_pp (rep_nat_pp t) x) = lex_comp' s t\""], ["proof (prove)\nusing this:\n  \\<not> lookup_pp (rep_nat_pp s) x < lookup_pp (rep_nat_pp t) x\n  lookup_pp (rep_nat_pp s) x \\<noteq> lookup_pp (rep_nat_pp t) x\n\ngoal (1 subgoal):\n 1. comparator_of (lookup_pp (rep_nat_pp s) x)\n     (lookup_pp (rep_nat_pp t) x) =\n    lex_comp' s t", "by (simp add: linorder_class.comparator_of_def Gt)"], ["proof (state)\nthis:\n  comparator_of (lookup_pp (rep_nat_pp s) x) (lookup_pp (rep_nat_pp t) x) =\n  lex_comp' s t\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < x \\<Longrightarrow>\n       lookup_pp (rep_nat_pp s) y = lookup_pp (rep_nat_pp t) y", "qed (simp add: 2)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class nat_term_compare = linorder + nat_term +\n  fixes is_scalar :: \"'a itself \\<Rightarrow> bool\"\n    and lex_comp :: \"'a comparator\"\n    and deg_comp :: \"'a comparator \\<Rightarrow> 'a comparator\"\n    and pot_comp :: \"'a comparator \\<Rightarrow> 'a comparator\"\n  assumes zero_component: \"\\<exists>x. snd (rep_nat_term x) = 0\"\n    and is_scalar: \"is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)\"\n    and lex_comp: \"lex_comp = lex_comp_aux\" \\<comment>\\<open>For being able to implement \\<open>lex_comp\\<close> efficiently.\\<close>\n    and deg_comp: \"deg_comp cmp = (\\<lambda>x y. case comparator_of (deg_pp (fst (rep_nat_term x))) (deg_pp (fst (rep_nat_term y))) of Eq \\<Rightarrow> cmp x y | val \\<Rightarrow> val)\"\n    and pot_comp: \"pot_comp cmp = (\\<lambda>x y. case comparator_of (snd (rep_nat_term x)) (snd (rep_nat_term y)) of Eq \\<Rightarrow> cmp x y | val \\<Rightarrow> val)\"\n    and le_term: \"rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y\"\nbegin"], ["", "text \\<open>There is no need to add something like \\<open>top_comp\\<close> for TOP orders to class @{class nat_term_compare},\n  because by default all comparators should @{emph \\<open>first\\<close>} compare power-products and @{emph \\<open>then\\<close>} positions.\n  \\<open>lex_comp\\<close> obviously does.\\<close>"], ["", "lemma less_term:\n  assumes \"rep_nat_term x < rep_nat_term y\"\n  shows \"x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < y", "from assms"], ["proof (chain)\npicking this:\n  rep_nat_term x < rep_nat_term y", "have 1: \"rep_nat_term x \\<le> rep_nat_term y\" and 2: \"rep_nat_term x \\<noteq> rep_nat_term y\""], ["proof (prove)\nusing this:\n  rep_nat_term x < rep_nat_term y\n\ngoal (1 subgoal):\n 1. rep_nat_term x \\<le> rep_nat_term y &&&\n    rep_nat_term x \\<noteq> rep_nat_term y", "by simp_all"], ["proof (state)\nthis:\n  rep_nat_term x \\<le> rep_nat_term y\n  rep_nat_term x \\<noteq> rep_nat_term y\n\ngoal (1 subgoal):\n 1. x < y", "from 1"], ["proof (chain)\npicking this:\n  rep_nat_term x \\<le> rep_nat_term y", "have \"x \\<le> y\""], ["proof (prove)\nusing this:\n  rep_nat_term x \\<le> rep_nat_term y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (rule le_term)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x < y", "moreover"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x < y", "from 2"], ["proof (chain)\npicking this:\n  rep_nat_term x \\<noteq> rep_nat_term y", "have \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  rep_nat_term x \\<noteq> rep_nat_term y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x < y", "ultimately"], ["proof (chain)\npicking this:\n  x \\<le> y\n  x \\<noteq> y", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x < y", "by simp"], ["proof (state)\nthis:\n  x < y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_comp_alt: \"lex_comp = (comparator_of::'a comparator)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_comp = comparator_of", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lex_comp = comparator_of", "from lex_pp_antisym"], ["proof (chain)\npicking this:\n  \\<lbrakk>lex_pp ?s ?t; lex_pp ?t ?s\\<rbrakk> \\<Longrightarrow> ?s = ?t", "have as: \"antisymp lex_pp\""], ["proof (prove)\nusing this:\n  \\<lbrakk>lex_pp ?s ?t; lex_pp ?t ?s\\<rbrakk> \\<Longrightarrow> ?s = ?t\n\ngoal (1 subgoal):\n 1. antisymp lex_pp", "by (rule antisympI)"], ["proof (state)\nthis:\n  antisymp lex_pp\n\ngoal (1 subgoal):\n 1. lex_comp = comparator_of", "interpret lex: comparator \"comp_of_ord (lex_pp::(nat, nat) pp \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (comp_of_ord lex_pp)", "unfolding comp_of_ord_eq_comp_of_ords[OF as]"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (comp_of_ords lex_pp (strict lex_pp))", "by (rule comp_of_ords, unfold_locales,\n        auto simp: lex_pp_refl intro: lex_pp_trans lex_pp_lin' elim!: lex_pp_antisym)"], ["proof (state)\ngoal (1 subgoal):\n 1. lex_comp = comparator_of", "have 1: \"x = y\" if \"fst (rep_nat_term x) = fst (rep_nat_term y)\"\n                  and \"snd (rep_nat_term x) = snd (rep_nat_term y)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "by (rule rep_nat_term_inj, rule prod_eqI, fact+)"], ["proof (state)\nthis:\n  \\<lbrakk>fst (rep_nat_term ?x1) = fst (rep_nat_term ?y1);\n   snd (rep_nat_term ?x1) = snd (rep_nat_term ?y1)\\<rbrakk>\n  \\<Longrightarrow> ?x1 = ?y1\n\ngoal (1 subgoal):\n 1. lex_comp = comparator_of", "have 2: \"x < y\" if \"fst (rep_nat_term x) = fst (rep_nat_term y)\"\n                  and \"snd (rep_nat_term x) < snd (rep_nat_term y)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y", "by (rule less_term, simp add: less_prod_def that)"], ["proof (state)\nthis:\n  \\<lbrakk>fst (rep_nat_term ?x1) = fst (rep_nat_term ?y1);\n   snd (rep_nat_term ?x1) < snd (rep_nat_term ?y1)\\<rbrakk>\n  \\<Longrightarrow> ?x1 < ?y1\n\ngoal (1 subgoal):\n 1. lex_comp = comparator_of", "have 3: False if \"fst (rep_nat_term x) = fst (rep_nat_term y)\"\n                and \"\\<not> snd (rep_nat_term x) < snd (rep_nat_term y)\" and \"x < y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from that(2)"], ["proof (chain)\npicking this:\n  \\<not> snd (rep_nat_term x) < snd (rep_nat_term y)", "have a: \"snd (rep_nat_term y) \\<le> snd (rep_nat_term x)\""], ["proof (prove)\nusing this:\n  \\<not> snd (rep_nat_term x) < snd (rep_nat_term y)\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term y) \\<le> snd (rep_nat_term x)", "by simp"], ["proof (state)\nthis:\n  snd (rep_nat_term y) \\<le> snd (rep_nat_term x)\n\ngoal (1 subgoal):\n 1. False", "have \"y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x", "by (rule le_term, simp add: less_eq_prod_def that(1) a)"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. False", "have \"... < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y", "by fact"], ["proof (state)\nthis:\n  x < y\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  y < y", "show False"], ["proof (prove)\nusing this:\n  y < y\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>fst (rep_nat_term ?x1) = fst (rep_nat_term ?y1);\n   \\<not> snd (rep_nat_term ?x1) < snd (rep_nat_term ?y1);\n   ?x1 < ?y1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. lex_comp = comparator_of", "have 4: \"x < y\" if \"fst (rep_nat_term x) \\<noteq> fst (rep_nat_term y)\"\n                  and \"lex_pp (fst (rep_nat_term x)) (fst (rep_nat_term y))\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < y", "from that(2)"], ["proof (chain)\npicking this:\n  lex_pp (fst (rep_nat_term x)) (fst (rep_nat_term y))", "have \"fst (rep_nat_term x) \\<le> fst (rep_nat_term y)\""], ["proof (prove)\nusing this:\n  lex_pp (fst (rep_nat_term x)) (fst (rep_nat_term y))\n\ngoal (1 subgoal):\n 1. fst (rep_nat_term x) \\<le> fst (rep_nat_term y)", "by (simp only: less_eq_pp_def)"], ["proof (state)\nthis:\n  fst (rep_nat_term x) \\<le> fst (rep_nat_term y)\n\ngoal (1 subgoal):\n 1. x < y", "with that(1)"], ["proof (chain)\npicking this:\n  fst (rep_nat_term x) \\<noteq> fst (rep_nat_term y)\n  fst (rep_nat_term x) \\<le> fst (rep_nat_term y)", "have \"fst (rep_nat_term x) < fst (rep_nat_term y)\""], ["proof (prove)\nusing this:\n  fst (rep_nat_term x) \\<noteq> fst (rep_nat_term y)\n  fst (rep_nat_term x) \\<le> fst (rep_nat_term y)\n\ngoal (1 subgoal):\n 1. fst (rep_nat_term x) < fst (rep_nat_term y)", "by simp"], ["proof (state)\nthis:\n  fst (rep_nat_term x) < fst (rep_nat_term y)\n\ngoal (1 subgoal):\n 1. x < y", "hence \"rep_nat_term x < rep_nat_term y\""], ["proof (prove)\nusing this:\n  fst (rep_nat_term x) < fst (rep_nat_term y)\n\ngoal (1 subgoal):\n 1. rep_nat_term x < rep_nat_term y", "by (simp add: less_prod_def)"], ["proof (state)\nthis:\n  rep_nat_term x < rep_nat_term y\n\ngoal (1 subgoal):\n 1. x < y", "thus ?thesis"], ["proof (prove)\nusing this:\n  rep_nat_term x < rep_nat_term y\n\ngoal (1 subgoal):\n 1. x < y", "by (rule less_term)"], ["proof (state)\nthis:\n  x < y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>fst (rep_nat_term ?x1) \\<noteq> fst (rep_nat_term ?y1);\n   lex_pp (fst (rep_nat_term ?x1)) (fst (rep_nat_term ?y1))\\<rbrakk>\n  \\<Longrightarrow> ?x1 < ?y1\n\ngoal (1 subgoal):\n 1. lex_comp = comparator_of", "have 5: False if \"fst (rep_nat_term x) \\<noteq> fst (rep_nat_term y)\"\n                and \"\\<not> lex_pp (fst (rep_nat_term x)) (fst (rep_nat_term y))\" and \"x < y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from that(2)"], ["proof (chain)\npicking this:\n  \\<not> lex_pp (fst (rep_nat_term x)) (fst (rep_nat_term y))", "have a: \"lex_pp (fst (rep_nat_term y)) (fst (rep_nat_term x))\""], ["proof (prove)\nusing this:\n  \\<not> lex_pp (fst (rep_nat_term x)) (fst (rep_nat_term y))\n\ngoal (1 subgoal):\n 1. lex_pp (fst (rep_nat_term y)) (fst (rep_nat_term x))", "by (rule lex_pp_lin')"], ["proof (state)\nthis:\n  lex_pp (fst (rep_nat_term y)) (fst (rep_nat_term x))\n\ngoal (1 subgoal):\n 1. False", "with that(1)[symmetric]"], ["proof (chain)\npicking this:\n  fst (rep_nat_term y) \\<noteq> fst (rep_nat_term x)\n  lex_pp (fst (rep_nat_term y)) (fst (rep_nat_term x))", "have \"y < x\""], ["proof (prove)\nusing this:\n  fst (rep_nat_term y) \\<noteq> fst (rep_nat_term x)\n  lex_pp (fst (rep_nat_term y)) (fst (rep_nat_term x))\n\ngoal (1 subgoal):\n 1. y < x", "by (rule 4)"], ["proof (state)\nthis:\n  y < x\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  y < x\n\ngoal (1 subgoal):\n 1. False", "have \"... < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y", "by fact"], ["proof (state)\nthis:\n  x < y\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  ?P", "show False"], ["proof (prove)\nusing this:\n  ?P\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>fst (rep_nat_term ?x1) \\<noteq> fst (rep_nat_term ?y1);\n   \\<not> lex_pp (fst (rep_nat_term ?x1)) (fst (rep_nat_term ?y1));\n   ?x1 < ?y1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. lex_comp = comparator_of", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_comp = comparator_of", "by (intro ext, simp add: lex_comp lex_comp_aux_def comparator_of_def linorder_class.comparator_of_def lex.eq split: order.splits,\n        auto simp: lex_pp_refl comp_of_ord_def elim: 1 2 3 4 5)"], ["proof (state)\nthis:\n  lex_comp = comparator_of\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma full_component_zeroE: obtains x where \"rep_nat_term x = (t, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        rep_nat_term x = (t, 0) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        rep_nat_term x = (t, 0) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from zero_component"], ["proof (chain)\npicking this:\n  \\<exists>x. snd (rep_nat_term x) = 0", "obtain x' where \"snd (rep_nat_term x') = 0\""], ["proof (prove)\nusing this:\n  \\<exists>x. snd (rep_nat_term x) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        snd (rep_nat_term x') = 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  snd (rep_nat_term x') = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        rep_nat_term x = (t, 0) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  snd (rep_nat_term x') = 0", "obtain x where \"rep_nat_term x = (t, 0)\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term x') = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        rep_nat_term x = (t, 0) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule full_componentE)"], ["proof (state)\nthis:\n  rep_nat_term x = (t, 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        rep_nat_term x = (t, 0) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  rep_nat_term x = (t, 0)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* For some reason, the following lemmas cannot be stated in context \"nat_term_compare\". *)"], ["", "lemma comparator_lex_comp: \"comparator lex_comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator lex_comp", "unfolding lex_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator lex_comp_aux", "by (fact comparator_lex_comp_aux)"], ["", "lemma nat_term_comp_lex_comp: \"nat_term_comp lex_comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_comp lex_comp", "unfolding lex_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_comp lex_comp_aux", "by (fact nat_term_comp_lex_comp_aux)"], ["", "lemma comparator_deg_comp:\n  assumes \"comparator cmp\"\n  shows \"comparator (deg_comp cmp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (deg_comp cmp)", "unfolding deg_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator\n     (\\<lambda>x y.\n         case comparator_of (deg_pp (fst (rep_nat_term x)))\n               (deg_pp (fst (rep_nat_term y))) of\n         Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n         | Gt \\<Rightarrow> Gt)", "using comparator_of assms"], ["proof (prove)\nusing this:\n  comparator comparator_of\n  comparator cmp\n\ngoal (1 subgoal):\n 1. comparator\n     (\\<lambda>x y.\n         case comparator_of (deg_pp (fst (rep_nat_term x)))\n               (deg_pp (fst (rep_nat_term y))) of\n         Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n         | Gt \\<Rightarrow> Gt)", "by (rule comparator_lexicographic)"], ["", "lemma comparator_pot_comp:\n  assumes \"comparator cmp\"\n  shows \"comparator (pot_comp cmp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (pot_comp cmp)", "unfolding pot_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator\n     (\\<lambda>x y.\n         case comparator_of (snd (rep_nat_term x)) (snd (rep_nat_term y)) of\n         Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n         | Gt \\<Rightarrow> Gt)", "using comparator_of assms"], ["proof (prove)\nusing this:\n  comparator comparator_of\n  comparator cmp\n\ngoal (1 subgoal):\n 1. comparator\n     (\\<lambda>x y.\n         case comparator_of (snd (rep_nat_term x)) (snd (rep_nat_term y)) of\n         Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n         | Gt \\<Rightarrow> Gt)", "by (rule comparator_lexicographic)"], ["", "lemma deg_comp_zero_min:\n  assumes \"comparator cmp\" and \"snd (rep_nat_term u) = snd (rep_nat_term v)\" and \"fst (rep_nat_term u) = 0\"\n  shows \"deg_comp cmp u v \\<noteq> Gt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_comp cmp u v \\<noteq> Gt", "proof (simp add: deg_comp assms(3) comparator_of_def split: order.split, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (rep_nat_term v) = 0 \\<Longrightarrow> cmp u v \\<noteq> Gt", "assume \"fst (rep_nat_term v) = 0\""], ["proof (state)\nthis:\n  fst (rep_nat_term v) = 0\n\ngoal (1 subgoal):\n 1. fst (rep_nat_term v) = 0 \\<Longrightarrow> cmp u v \\<noteq> Gt", "with assms(3)"], ["proof (chain)\npicking this:\n  fst (rep_nat_term u) = 0\n  fst (rep_nat_term v) = 0", "have \"fst (rep_nat_term u) = fst (rep_nat_term v)\""], ["proof (prove)\nusing this:\n  fst (rep_nat_term u) = 0\n  fst (rep_nat_term v) = 0\n\ngoal (1 subgoal):\n 1. fst (rep_nat_term u) = fst (rep_nat_term v)", "by simp"], ["proof (state)\nthis:\n  fst (rep_nat_term u) = fst (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. fst (rep_nat_term v) = 0 \\<Longrightarrow> cmp u v \\<noteq> Gt", "hence \"rep_nat_term u = rep_nat_term v\""], ["proof (prove)\nusing this:\n  fst (rep_nat_term u) = fst (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. rep_nat_term u = rep_nat_term v", "using assms(2)"], ["proof (prove)\nusing this:\n  fst (rep_nat_term u) = fst (rep_nat_term v)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. rep_nat_term u = rep_nat_term v", "by (rule prod_eqI)"], ["proof (state)\nthis:\n  rep_nat_term u = rep_nat_term v\n\ngoal (1 subgoal):\n 1. fst (rep_nat_term v) = 0 \\<Longrightarrow> cmp u v \\<noteq> Gt", "hence \"u = v\""], ["proof (prove)\nusing this:\n  rep_nat_term u = rep_nat_term v\n\ngoal (1 subgoal):\n 1. u = v", "by (rule rep_nat_term_inj)"], ["proof (state)\nthis:\n  u = v\n\ngoal (1 subgoal):\n 1. fst (rep_nat_term v) = 0 \\<Longrightarrow> cmp u v \\<noteq> Gt", "from assms(1)"], ["proof (chain)\npicking this:\n  comparator cmp", "interpret c: comparator cmp"], ["proof (prove)\nusing this:\n  comparator cmp\n\ngoal (1 subgoal):\n 1. comparator cmp", "."], ["proof (state)\ngoal (1 subgoal):\n 1. fst (rep_nat_term v) = 0 \\<Longrightarrow> cmp u v \\<noteq> Gt", "show \"cmp u v \\<noteq> Gt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmp u v \\<noteq> Gt", "by (simp add: \\<open>u = v\\<close>)"], ["proof (state)\nthis:\n  cmp u v \\<noteq> Gt\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deg_comp_pos:\n  assumes \"cmp u v = Lt\" and \"fst (rep_nat_term u) = fst (rep_nat_term v)\"\n  shows \"deg_comp cmp u v = Lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_comp cmp u v = Lt", "by (simp add: deg_comp assms split: order.split)"], ["", "lemma deg_comp_monotone:\n  assumes \"cmp u v = Lt \\<Longrightarrow> cmp (splus t u) (splus t v) = Lt\" and \"deg_comp cmp u v = Lt\"\n  shows \"deg_comp cmp (splus t u) (splus t v) = Lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_comp cmp (splus t u) (splus t v) = Lt", "using assms(2)"], ["proof (prove)\nusing this:\n  deg_comp cmp u v = Lt\n\ngoal (1 subgoal):\n 1. deg_comp cmp (splus t u) (splus t v) = Lt", "by (auto simp: deg_comp splus_term pprod.splus_def comparator_of_def deg_pp_plus\n                          split: order.splits if_splits intro: assms(1))"], ["", "lemma pot_comp_zero_min:\n  assumes \"cmp u v \\<noteq> Gt\" and \"snd (rep_nat_term u) = snd (rep_nat_term v)\"\n  shows \"pot_comp cmp u v \\<noteq> Gt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pot_comp cmp u v \\<noteq> Gt", "by (simp add: pot_comp comparator_of_def assms split: order.split)"], ["", "lemma pot_comp_pos:\n  assumes \"snd (rep_nat_term u) < snd (rep_nat_term v)\"\n  shows \"pot_comp cmp u v = Lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pot_comp cmp u v = Lt", "by (simp add: pot_comp comparator_of_def assms split: order.split)"], ["", "lemma pot_comp_monotone:\n  assumes \"cmp u v = Lt \\<Longrightarrow> cmp (splus t u) (splus t v) = Lt\" and \"pot_comp cmp u v = Lt\"\n  shows \"pot_comp cmp (splus t u) (splus t v) = Lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pot_comp cmp (splus t u) (splus t v) = Lt", "using assms(2)"], ["proof (prove)\nusing this:\n  pot_comp cmp u v = Lt\n\ngoal (1 subgoal):\n 1. pot_comp cmp (splus t u) (splus t v) = Lt", "by (auto simp: pot_comp splus_term pprod.splus_def comparator_of_def deg_pp_plus\n                          split: order.splits if_splits intro: assms(1))"], ["", "lemma deg_comp_cong:\n  assumes \"deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v)) \\<Longrightarrow> to1 u v = to2 u v\"\n  shows \"deg_comp to1 u v = deg_comp to2 u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_comp to1 u v = deg_comp to2 u v", "using assms"], ["proof (prove)\nusing this:\n  deg_pp (fst (rep_nat_term u)) =\n  deg_pp (fst (rep_nat_term v)) \\<Longrightarrow>\n  to1 u v = to2 u v\n\ngoal (1 subgoal):\n 1. deg_comp to1 u v = deg_comp to2 u v", "by (simp add: deg_comp comparator_of_def split: order.split)"], ["", "lemma pot_comp_cong:\n  assumes \"snd (rep_nat_term u) = snd (rep_nat_term v) \\<Longrightarrow> to1 u v = to2 u v\"\n  shows \"pot_comp to1 u v = pot_comp to2 u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pot_comp to1 u v = pot_comp to2 u v", "using assms"], ["proof (prove)\nusing this:\n  snd (rep_nat_term u) = snd (rep_nat_term v) \\<Longrightarrow>\n  to1 u v = to2 u v\n\ngoal (1 subgoal):\n 1. pot_comp to1 u v = pot_comp to2 u v", "by (simp add: pot_comp comparator_of_def split: order.split)"], ["", "instantiation pp :: (nat, nat) nat_pp_compare\nbegin"], ["", "definition rep_nat_pp_pp :: \"('a, 'b) pp \\<Rightarrow> (nat, nat) pp\"\n  where rep_nat_pp_pp_def [code del]: \"rep_nat_pp_pp x = pp_of_fun (\\<lambda>n::nat. rep_nat (lookup_pp x (abs_nat n)))\""], ["", "definition abs_nat_pp_pp :: \"(nat, nat) pp \\<Rightarrow> ('a, 'b) pp\"\n  where abs_nat_pp_pp_def [code del]: \"abs_nat_pp_pp t = pp_of_fun (\\<lambda>n::'a. abs_nat (lookup_pp t (rep_nat n)))\""], ["", "definition lex_comp'_pp :: \"('a, 'b) pp comparator\"\n  where lex_comp'_pp_def [code del]: \"lex_comp'_pp = comp_of_ord lex_pp\""], ["", "definition deg'_pp :: \"('a, 'b) pp \\<Rightarrow> nat\"\n  where \"deg'_pp x = rep_nat (deg_pp x)\""], ["", "lemma lookup_rep_nat_pp_pp:\n  \"lookup_pp (rep_nat_pp t) = (\\<lambda>n::nat. rep_nat (lookup_pp t (abs_nat n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp (rep_nat_pp t) =\n    (\\<lambda>n. rep_nat (lookup_pp t (abs_nat n)))", "unfolding rep_nat_pp_pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp (pp_of_fun (\\<lambda>n. rep_nat (lookup_pp t (abs_nat n)))) =\n    (\\<lambda>n. rep_nat (lookup_pp t (abs_nat n)))", "proof (rule lookup_pp_of_fun)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. rep_nat (lookup_pp t (abs_nat x)) \\<noteq> 0}", "have \"{n. lookup_pp t (abs_nat n) \\<noteq> 0} \\<subseteq> rep_nat ` {x. lookup_pp t x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. lookup_pp t (abs_nat n) \\<noteq> (0::'b)}\n    \\<subseteq> rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. lookup_pp t (abs_nat n) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. lookup_pp t (abs_nat n) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)}", "have \"n = rep_nat (abs_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = rep_nat (abs_nat n)", "by (simp only: nat_class.abs_inverse)"], ["proof (state)\nthis:\n  n = rep_nat (abs_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. lookup_pp t (abs_nat n) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)}", "assume \"n \\<in> {n. lookup_pp t (abs_nat n) \\<noteq> 0}\""], ["proof (state)\nthis:\n  n \\<in> {n. lookup_pp t (abs_nat n) \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. lookup_pp t (abs_nat n) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)}", "hence \"abs_nat n \\<in> {x. lookup_pp t x \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  n \\<in> {n. lookup_pp t (abs_nat n) \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. abs_nat n \\<in> {x. lookup_pp t x \\<noteq> (0::'b)}", "by simp"], ["proof (state)\nthis:\n  abs_nat n \\<in> {x. lookup_pp t x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. lookup_pp t (abs_nat n) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)}", "with \\<open>n = rep_nat (abs_nat n)\\<close>"], ["proof (chain)\npicking this:\n  n = rep_nat (abs_nat n)\n  abs_nat n \\<in> {x. lookup_pp t x \\<noteq> (0::'b)}", "show \"n \\<in> rep_nat ` {x. lookup_pp t x \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  n = rep_nat (abs_nat n)\n  abs_nat n \\<in> {x. lookup_pp t x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. n \\<in> rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)}", ".."], ["proof (state)\nthis:\n  n \\<in> rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {n. lookup_pp t (abs_nat n) \\<noteq> (0::'b)}\n  \\<subseteq> rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. finite {x. rep_nat (lookup_pp t (abs_nat x)) \\<noteq> 0}", "also"], ["proof (state)\nthis:\n  {n. lookup_pp t (abs_nat n) \\<noteq> (0::'b)}\n  \\<subseteq> rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. finite {x. rep_nat (lookup_pp t (abs_nat x)) \\<noteq> 0}", "have \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)})", "by (rule finite_imageI, transfer, simp)"], ["proof (state)\nthis:\n  finite (rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)})\n\ngoal (1 subgoal):\n 1. finite {x. rep_nat (lookup_pp t (abs_nat x)) \\<noteq> 0}", "also (finite_subset)"], ["proof (state)\nthis:\n  finite (rep_nat ` {x. lookup_pp t x \\<noteq> (0::'b)})\n\ngoal (1 subgoal):\n 1. finite {x. rep_nat (lookup_pp t (abs_nat x)) \\<noteq> 0}", "have \"{n. lookup_pp t (abs_nat n) \\<noteq> 0} = {n. rep_nat (lookup_pp t (abs_nat n)) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. lookup_pp t (abs_nat n) \\<noteq> (0::'b)} =\n    {n. rep_nat (lookup_pp t (abs_nat n)) \\<noteq> 0}", "by (metis rep_inj rep_zero)"], ["proof (state)\nthis:\n  {n. lookup_pp t (abs_nat n) \\<noteq> (0::'b)} =\n  {n. rep_nat (lookup_pp t (abs_nat n)) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. finite {x. rep_nat (lookup_pp t (abs_nat x)) \\<noteq> 0}", "finally"], ["proof (chain)\npicking this:\n  finite {n. rep_nat (lookup_pp t (abs_nat n)) \\<noteq> 0}", "show \"finite {x. rep_nat (lookup_pp t (abs_nat x)) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  finite {n. rep_nat (lookup_pp t (abs_nat n)) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. finite {x. rep_nat (lookup_pp t (abs_nat x)) \\<noteq> 0}", "."], ["proof (state)\nthis:\n  finite {x. rep_nat (lookup_pp t (abs_nat x)) \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_abs_nat_pp_pp:\n  \"lookup_pp (abs_nat_pp t) = (\\<lambda>n::'a. abs_nat (lookup_pp t (rep_nat n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp (abs_nat_pp t) =\n    (\\<lambda>n. abs_nat (lookup_pp t (rep_nat n)))", "unfolding abs_nat_pp_pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp (pp_of_fun (\\<lambda>n. abs_nat (lookup_pp t (rep_nat n)))) =\n    (\\<lambda>n. abs_nat (lookup_pp t (rep_nat n)))", "proof (rule lookup_pp_of_fun)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. abs_nat (lookup_pp t (rep_nat x)) \\<noteq> (0::'b)}", "have \"{n::'a. lookup_pp t (rep_nat n) \\<noteq> 0} \\<subseteq> abs_nat ` {x. lookup_pp t x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. lookup_pp t (rep_nat n) \\<noteq> 0}\n    \\<subseteq> abs_nat ` {x. lookup_pp t x \\<noteq> 0}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. lookup_pp t (rep_nat n) \\<noteq> 0} \\<Longrightarrow>\n       x \\<in> abs_nat ` {x. lookup_pp t x \\<noteq> 0}", "fix n :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. lookup_pp t (rep_nat n) \\<noteq> 0} \\<Longrightarrow>\n       x \\<in> abs_nat ` {x. lookup_pp t x \\<noteq> 0}", "have \"n = abs_nat (rep_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = abs_nat (rep_nat n)", "by (simp only: nat_class.rep_inverse)"], ["proof (state)\nthis:\n  n = abs_nat (rep_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. lookup_pp t (rep_nat n) \\<noteq> 0} \\<Longrightarrow>\n       x \\<in> abs_nat ` {x. lookup_pp t x \\<noteq> 0}", "assume \"n \\<in> {n. lookup_pp t (rep_nat n) \\<noteq> 0}\""], ["proof (state)\nthis:\n  n \\<in> {n. lookup_pp t (rep_nat n) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. lookup_pp t (rep_nat n) \\<noteq> 0} \\<Longrightarrow>\n       x \\<in> abs_nat ` {x. lookup_pp t x \\<noteq> 0}", "hence \"rep_nat n \\<in> {x. lookup_pp t x \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  n \\<in> {n. lookup_pp t (rep_nat n) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. rep_nat n \\<in> {x. lookup_pp t x \\<noteq> 0}", "by simp"], ["proof (state)\nthis:\n  rep_nat n \\<in> {x. lookup_pp t x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. lookup_pp t (rep_nat n) \\<noteq> 0} \\<Longrightarrow>\n       x \\<in> abs_nat ` {x. lookup_pp t x \\<noteq> 0}", "with \\<open>n = abs_nat (rep_nat n)\\<close>"], ["proof (chain)\npicking this:\n  n = abs_nat (rep_nat n)\n  rep_nat n \\<in> {x. lookup_pp t x \\<noteq> 0}", "show \"n \\<in> abs_nat ` {x. lookup_pp t x \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  n = abs_nat (rep_nat n)\n  rep_nat n \\<in> {x. lookup_pp t x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. n \\<in> abs_nat ` {x. lookup_pp t x \\<noteq> 0}", ".."], ["proof (state)\nthis:\n  n \\<in> abs_nat ` {x. lookup_pp t x \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {n. lookup_pp t (rep_nat n) \\<noteq> 0}\n  \\<subseteq> abs_nat ` {x. lookup_pp t x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. finite {x. abs_nat (lookup_pp t (rep_nat x)) \\<noteq> (0::'b)}", "also"], ["proof (state)\nthis:\n  {n. lookup_pp t (rep_nat n) \\<noteq> 0}\n  \\<subseteq> abs_nat ` {x. lookup_pp t x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. finite {x. abs_nat (lookup_pp t (rep_nat x)) \\<noteq> (0::'b)}", "have \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (abs_nat ` {x. lookup_pp t x \\<noteq> 0})", "by (rule finite_imageI, transfer, simp)"], ["proof (state)\nthis:\n  finite (abs_nat ` {x. lookup_pp t x \\<noteq> 0})\n\ngoal (1 subgoal):\n 1. finite {x. abs_nat (lookup_pp t (rep_nat x)) \\<noteq> (0::'b)}", "also (finite_subset)"], ["proof (state)\nthis:\n  finite (abs_nat ` {x. lookup_pp t x \\<noteq> 0})\n\ngoal (1 subgoal):\n 1. finite {x. abs_nat (lookup_pp t (rep_nat x)) \\<noteq> (0::'b)}", "have \"{n::'a. lookup_pp t (rep_nat n) \\<noteq> 0} = {n. abs_nat (lookup_pp t (rep_nat n)) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. lookup_pp t (rep_nat n) \\<noteq> 0} =\n    {n. abs_nat (lookup_pp t (rep_nat n)) \\<noteq> (0::'c)}", "by (metis abs_inverse abs_zero)"], ["proof (state)\nthis:\n  {n. lookup_pp t (rep_nat n) \\<noteq> 0} =\n  {n. abs_nat (lookup_pp t (rep_nat n)) \\<noteq> (0::?'c1)}\n\ngoal (1 subgoal):\n 1. finite {x. abs_nat (lookup_pp t (rep_nat x)) \\<noteq> (0::'b)}", "finally"], ["proof (chain)\npicking this:\n  finite {n. abs_nat (lookup_pp t (rep_nat n)) \\<noteq> (0::?'c2)}", "show \"finite {n::'a. abs_nat (lookup_pp t (rep_nat n)) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  finite {n. abs_nat (lookup_pp t (rep_nat n)) \\<noteq> (0::?'c2)}\n\ngoal (1 subgoal):\n 1. finite {n. abs_nat (lookup_pp t (rep_nat n)) \\<noteq> (0::'c)}", "."], ["proof (state)\nthis:\n  finite {n. abs_nat (lookup_pp t (rep_nat n)) \\<noteq> (0::?'c2)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_rep_nat_pp_pp: \"keys_pp (rep_nat_pp t) = rep_nat ` keys_pp t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys_pp (rep_nat_pp t) = rep_nat ` keys_pp t", "by (rule set_eqI,\n      simp add: keys_pp_iff lookup_rep_nat_pp_pp image_iff Bex_def ex_iff_abs[where 'a='a] rep_zero_iff del: neq0_conv)"], ["", "lemma rep_nat_pp_pp_inverse: \"abs_nat_pp (rep_nat_pp x) = x\" for x::\"('a, 'b) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_nat_pp (rep_nat_pp x) = x", "by (rule pp_eqI, simp add: lookup_abs_nat_pp_pp lookup_rep_nat_pp_pp)"], ["", "lemma abs_nat_pp_pp_inverse: \"rep_nat_pp ((abs_nat_pp t)::('a, 'b) pp) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_pp (abs_nat_pp t) = t", "by (rule pp_eqI, simp add: lookup_abs_nat_pp_pp lookup_rep_nat_pp_pp)"], ["", "corollary rep_nat_pp_pp_inj:\n  fixes x y :: \"('a, 'b) pp\"\n  assumes \"rep_nat_pp x = rep_nat_pp y\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "by (metis (no_types) rep_nat_pp_pp_inverse assms)"], ["", "corollary rep_nat_pp_pp_eq_iff: \"(rep_nat_pp x = rep_nat_pp y) \\<longleftrightarrow> (x = y)\" for x y :: \"('a, 'b) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rep_nat_pp x = rep_nat_pp y) = (x = y)", "by (auto elim: rep_nat_pp_pp_inj)"], ["", "lemma lex_rep_nat_pp: \"lex_pp (rep_nat_pp x) (rep_nat_pp y) \\<longleftrightarrow> lex_pp x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp (rep_nat_pp x) (rep_nat_pp y) = lex_pp x y", "by (simp add: lex_pp_alt rep_nat_pp_pp_eq_iff lookup_rep_nat_pp_pp rep_eq_iff\n      ord_iff[symmetric] ex_iff_abs[where 'a='a] all_iff_abs')"], ["", "corollary lex_comp'_pp: \"lex_comp' x y = comp_of_ord lex_pp (rep_nat_pp x) (rep_nat_pp y)\" for x y :: \"('a, 'b) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_comp' x y = comp_of_ord lex_pp (rep_nat_pp x) (rep_nat_pp y)", "by (simp add: lex_comp'_pp_def comp_of_ord_def rep_nat_pp_pp_eq_iff lex_rep_nat_pp)"], ["", "corollary le_pp_pp: \"rep_nat_pp x \\<le> rep_nat_pp y \\<Longrightarrow> x \\<le> y\" for x y :: \"('a, 'b) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_pp x \\<le> rep_nat_pp y \\<Longrightarrow> x \\<le> y", "by (simp only: less_eq_pp_def lex_rep_nat_pp)"], ["", "lemma deg_rep_nat_pp: \"deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)\" for t :: \"('a, 'b) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "have \"keys_pp (rep_nat_pp t) = rep_nat ` keys_pp t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys_pp (rep_nat_pp t) = rep_nat ` keys_pp t", "by (rule set_eqI, simp add: keys_pp_iff image_iff lookup_rep_nat_pp_pp Bex_def ex_iff_abs[where 'a='a] rep_zero_iff del: neq0_conv)"], ["proof (state)\nthis:\n  keys_pp (rep_nat_pp t) = rep_nat ` keys_pp t\n\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "hence \"deg_pp (rep_nat_pp t) = sum (lookup_pp (rep_nat_pp t)) (rep_nat ` keys_pp t)\""], ["proof (prove)\nusing this:\n  keys_pp (rep_nat_pp t) = rep_nat ` keys_pp t\n\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) =\n    sum (lookup_pp (rep_nat_pp t)) (rep_nat ` keys_pp t)", "by (simp add: deg_pp_alt)"], ["proof (state)\nthis:\n  deg_pp (rep_nat_pp t) =\n  sum (lookup_pp (rep_nat_pp t)) (rep_nat ` keys_pp t)\n\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "also"], ["proof (state)\nthis:\n  deg_pp (rep_nat_pp t) =\n  sum (lookup_pp (rep_nat_pp t)) (rep_nat ` keys_pp t)\n\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "have \"... = sum (lookup_pp (rep_nat_pp t) \\<circ> rep_nat) (keys_pp t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup_pp (rep_nat_pp t)) (rep_nat ` keys_pp t) =\n    sum (lookup_pp (rep_nat_pp t) \\<circ> rep_nat) (keys_pp t)", "by (rule sum.reindex, rule inj_onI, elim rep_inj)"], ["proof (state)\nthis:\n  sum (lookup_pp (rep_nat_pp t)) (rep_nat ` keys_pp t) =\n  sum (lookup_pp (rep_nat_pp t) \\<circ> rep_nat) (keys_pp t)\n\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "also"], ["proof (state)\nthis:\n  sum (lookup_pp (rep_nat_pp t)) (rep_nat ` keys_pp t) =\n  sum (lookup_pp (rep_nat_pp t) \\<circ> rep_nat) (keys_pp t)\n\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "have \"... = sum (rep_nat \\<circ> (lookup_pp t)) (keys_pp t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup_pp (rep_nat_pp t) \\<circ> rep_nat) (keys_pp t) =\n    sum (rep_nat \\<circ> lookup_pp t) (keys_pp t)", "by (simp add: lookup_rep_nat_pp_pp)"], ["proof (state)\nthis:\n  sum (lookup_pp (rep_nat_pp t) \\<circ> rep_nat) (keys_pp t) =\n  sum (rep_nat \\<circ> lookup_pp t) (keys_pp t)\n\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "also"], ["proof (state)\nthis:\n  sum (lookup_pp (rep_nat_pp t) \\<circ> rep_nat) (keys_pp t) =\n  sum (rep_nat \\<circ> lookup_pp t) (keys_pp t)\n\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "have \"... = rep_nat (deg_pp t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (rep_nat \\<circ> lookup_pp t) (keys_pp t) = rep_nat (deg_pp t)", "by (simp only: deg_pp_alt sum_rep)"], ["proof (state)\nthis:\n  sum (rep_nat \\<circ> lookup_pp t) (keys_pp t) = rep_nat (deg_pp t)\n\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "finally"], ["proof (chain)\npicking this:\n  deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)\n\ngoal (1 subgoal):\n 1. deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)", "."], ["proof (state)\nthis:\n  deg_pp (rep_nat_pp t) = rep_nat (deg_pp t)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary deg'_pp: \"deg' t = deg_pp (rep_nat_pp t)\" for t :: \"('a, 'b) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg' t = deg_pp (rep_nat_pp t)", "by (simp add: deg'_pp_def deg_rep_nat_pp)"], ["", "lemma zero_pp_pp: \"rep_nat_pp (0::('a, 'b) pp) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_pp 0 = 0", "by (rule pp_eqI, simp add: lookup_rep_nat_pp_pp)"], ["", "lemma plus_pp_pp: \"rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y\"\n  for x y :: \"('a, 'b) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y", "by (rule pp_eqI, simp add: lookup_rep_nat_pp_pp lookup_plus_pp rep_plus)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, nat_pp_compare_class)", "apply intro_classes"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x. abs_nat_pp (rep_nat_pp x) = x\n 2. \\<And>t. rep_nat_pp (abs_nat_pp t) = t\n 3. \\<And>x y.\n       lex_comp' x y = comp_of_ord lex_pp (rep_nat_pp x) (rep_nat_pp y)\n 4. \\<And>x. deg' x = deg_pp (rep_nat_pp x)\n 5. \\<And>x y. rep_nat_pp x \\<le> rep_nat_pp y \\<Longrightarrow> x \\<le> y\n 6. rep_nat_pp 0 = 0\n 7. \\<And>x y. rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_nat_pp (rep_nat_pp x_) = x_", "by (fact rep_nat_pp_pp_inverse)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>t. rep_nat_pp (abs_nat_pp t) = t\n 2. \\<And>x y.\n       lex_comp' x y = comp_of_ord lex_pp (rep_nat_pp x) (rep_nat_pp y)\n 3. \\<And>x. deg' x = deg_pp (rep_nat_pp x)\n 4. \\<And>x y. rep_nat_pp x \\<le> rep_nat_pp y \\<Longrightarrow> x \\<le> y\n 5. rep_nat_pp 0 = 0\n 6. \\<And>x y. rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_pp (abs_nat_pp t_) = t_", "by (fact abs_nat_pp_pp_inverse)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       lex_comp' x y = comp_of_ord lex_pp (rep_nat_pp x) (rep_nat_pp y)\n 2. \\<And>x. deg' x = deg_pp (rep_nat_pp x)\n 3. \\<And>x y. rep_nat_pp x \\<le> rep_nat_pp y \\<Longrightarrow> x \\<le> y\n 4. rep_nat_pp 0 = 0\n 5. \\<And>x y. rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_comp' x_ y_ = comp_of_ord lex_pp (rep_nat_pp x_) (rep_nat_pp y_)", "by (fact lex_comp'_pp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. deg' x = deg_pp (rep_nat_pp x)\n 2. \\<And>x y. rep_nat_pp x \\<le> rep_nat_pp y \\<Longrightarrow> x \\<le> y\n 3. rep_nat_pp 0 = 0\n 4. \\<And>x y. rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. deg' x_ = deg_pp (rep_nat_pp x_)", "by (fact deg'_pp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_pp x \\<le> rep_nat_pp y \\<Longrightarrow> x \\<le> y\n 2. rep_nat_pp 0 = 0\n 3. \\<And>x y. rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_pp x_ \\<le> rep_nat_pp y_ \\<Longrightarrow> x_ \\<le> y_", "by (rule le_pp_pp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rep_nat_pp 0 = 0\n 2. \\<And>x y. rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_pp 0 = 0", "by (fact zero_pp_pp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_pp (x_ + y_) = rep_nat_pp x_ + rep_nat_pp y_", "by (fact plus_pp_pp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation pp :: (nat, nat) nat_term\nbegin"], ["", "definition rep_nat_term_pp :: \"('a, 'b) pp \\<Rightarrow> (nat, nat) pp \\<times> nat\"\n  where rep_nat_term_pp_def [code del]: \"rep_nat_term_pp t = (rep_nat_pp t, 0)\""], ["", "definition splus_pp :: \"('a, 'b) pp \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> ('a, 'b) pp\"\n  where splus_pp_def [code del]: \"splus_pp = (+)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, nat_term_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_term x = rep_nat_term y \\<Longrightarrow> x = y\n 2. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 3. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "fix x y :: \"('a, 'b) pp\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_term x = rep_nat_term y \\<Longrightarrow> x = y\n 2. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 3. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "assume \"rep_nat_term x = rep_nat_term y\""], ["proof (state)\nthis:\n  rep_nat_term x = rep_nat_term y\n\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_term x = rep_nat_term y \\<Longrightarrow> x = y\n 2. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 3. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "hence \"rep_nat_pp x = rep_nat_pp y\""], ["proof (prove)\nusing this:\n  rep_nat_term x = rep_nat_term y\n\ngoal (1 subgoal):\n 1. rep_nat_pp x = rep_nat_pp y", "by (simp add: rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  rep_nat_pp x = rep_nat_pp y\n\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_term x = rep_nat_term y \\<Longrightarrow> x = y\n 2. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 3. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "thus \"x = y\""], ["proof (prove)\nusing this:\n  rep_nat_pp x = rep_nat_pp y\n\ngoal (1 subgoal):\n 1. x = y", "by (rule rep_nat_pp_pp_inj)"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 2. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 2. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "fix x::\"('a, 'b) pp\" and i t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 2. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "assume \"snd (rep_nat_term x) = i\""], ["proof (state)\nthis:\n  snd (rep_nat_term x) = i\n\ngoal (2 subgoals):\n 1. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 2. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "hence \"i = 0\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term x) = i\n\ngoal (1 subgoal):\n 1. i = 0", "by (simp add: rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 2. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "show \"\\<exists>y::('a, 'b) pp. rep_nat_term y = (t, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. rep_nat_term y = (t, i)", "unfolding \\<open>i = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. rep_nat_term y = (t, 0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. rep_nat_term ?y = (t, 0)", "show \"rep_nat_term ((abs_nat_pp t)::('a, 'b) pp) = (t, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_term (abs_nat_pp t) = (t, 0)", "by (simp add: rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  rep_nat_term (abs_nat_pp t) = (t, 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y. rep_nat_term y = (t, i)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "fix x y :: \"('a, 'b) pp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "show \"rep_nat_term (splus x y) = pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_term (splus x y) =\n    pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "by (simp add: splus_pp_def rep_nat_term_pp_def pprod.splus_def plus_pp_pp)"], ["proof (state)\nthis:\n  rep_nat_term (splus x y) =\n  pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation pp :: (nat, nat) nat_term_compare\nbegin"], ["", "definition is_scalar_pp :: \"('a, 'b) pp itself \\<Rightarrow> bool\"\n  where is_scalar_pp_def [code_unfold]: \"is_scalar_pp = (\\<lambda>_. True)\""], ["", "definition lex_comp_pp :: \"('a, 'b) pp comparator\"\n  where lex_comp_pp_def [code_unfold]: \"lex_comp_pp = lex_comp'\""], ["", "definition deg_comp_pp :: \"('a, 'b) pp comparator \\<Rightarrow> ('a, 'b) pp comparator\"\n  where deg_comp_pp_def: \"deg_comp_pp cmp = (\\<lambda>x y. case comparator_of (deg_pp x) (deg_pp y) of Eq \\<Rightarrow> cmp x y | val \\<Rightarrow> val)\""], ["", "definition pot_comp_pp :: \"('a, 'b) pp comparator \\<Rightarrow> ('a, 'b) pp comparator\"\n  where pot_comp_pp_def [code_unfold]: \"pot_comp_pp = (\\<lambda>cmp. cmp)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, nat_term_compare_class)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<exists>x. snd (rep_nat_term x) = 0\n 2. is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)\n 3. lex_comp = lex_comp_aux\n 4. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 5. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 6. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "show \"\\<exists>x::('a, 'b) pp. snd (rep_nat_term x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. snd (rep_nat_term x) = 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (rep_nat_term ?x) = 0", "show \"snd (rep_nat_term (0::('a, 'b) pp)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rep_nat_term 0) = 0", "by (simp add: rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  snd (rep_nat_term 0) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. snd (rep_nat_term x) = 0\n\ngoal (5 subgoals):\n 1. is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)\n 2. lex_comp = lex_comp_aux\n 3. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 4. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 5. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)\n 2. lex_comp = lex_comp_aux\n 3. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 4. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 5. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "show \"is_scalar = (\\<lambda>_::('a, 'b) pp itself. \\<forall>x::('a, 'b) pp. snd (rep_nat_term x) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)", "by (simp add: is_scalar_pp_def rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)\n\ngoal (4 subgoals):\n 1. lex_comp = lex_comp_aux\n 2. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 3. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 4. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. lex_comp = lex_comp_aux\n 2. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 3. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 4. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "show \"lex_comp = (lex_comp_aux::('a, 'b) pp comparator)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_comp = lex_comp_aux", "by (auto simp: lex_comp_pp_def lex_comp_aux_def rep_nat_term_pp_def lex_comp'_pp split: order.split intro!: ext)"], ["proof (state)\nthis:\n  lex_comp = lex_comp_aux\n\ngoal (3 subgoals):\n 1. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 3. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 3. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "fix cmp :: \"('a, 'b) pp comparator\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 3. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "show \"deg_comp cmp =\n         (\\<lambda>x y. case comparator_of (deg_pp (fst (rep_nat_term x))) (deg_pp (fst (rep_nat_term y))) of Eq \\<Rightarrow> cmp x y\n                      | Lt \\<Rightarrow> Lt | Gt \\<Rightarrow> Gt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_comp cmp =\n    (\\<lambda>x y.\n        case comparator_of (deg_pp (fst (rep_nat_term x)))\n              (deg_pp (fst (rep_nat_term y))) of\n        Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n        | Gt \\<Rightarrow> Gt)", "by (simp add: rep_nat_term_pp_def deg_comp_pp_def deg_rep_nat_pp comparator_of_rep)"], ["proof (state)\nthis:\n  deg_comp cmp =\n  (\\<lambda>x y.\n      case comparator_of (deg_pp (fst (rep_nat_term x)))\n            (deg_pp (fst (rep_nat_term y))) of\n      Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt | Gt \\<Rightarrow> Gt)\n\ngoal (2 subgoals):\n 1. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "fix cmp :: \"('a, 'b) pp comparator\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "show \"pot_comp cmp =\n         (\\<lambda>x y. case comparator_of (snd (rep_nat_term x)) (snd (rep_nat_term y)) of Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt | Gt \\<Rightarrow> Gt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pot_comp cmp =\n    (\\<lambda>x y.\n        case comparator_of (snd (rep_nat_term x)) (snd (rep_nat_term y)) of\n        Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n        | Gt \\<Rightarrow> Gt)", "by (simp add: rep_nat_term_pp_def pot_comp_pp_def)"], ["proof (state)\nthis:\n  pot_comp cmp =\n  (\\<lambda>x y.\n      case comparator_of (snd (rep_nat_term x)) (snd (rep_nat_term y)) of\n      Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt | Gt \\<Rightarrow> Gt)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "fix x y :: \"('a, 'b) pp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "assume \"rep_nat_term x \\<le> rep_nat_term y\""], ["proof (state)\nthis:\n  rep_nat_term x \\<le> rep_nat_term y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "hence \"rep_nat_pp x \\<le> rep_nat_pp y\""], ["proof (prove)\nusing this:\n  rep_nat_term x \\<le> rep_nat_term y\n\ngoal (1 subgoal):\n 1. rep_nat_pp x \\<le> rep_nat_pp y", "by (auto simp: rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  rep_nat_pp x \\<le> rep_nat_pp y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "thus \"x \\<le> y\""], ["proof (prove)\nusing this:\n  rep_nat_pp x \\<le> rep_nat_pp y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (rule le_pp_pp)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instance pp :: (nat, nat) nat_pp_term"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, nat_pp_term_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rep_nat_term 0 = (0, 0)\n 2. splus = (+)", "show \"rep_nat_term (0::('a, 'b) pp) = (0, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_term 0 = (0, 0)", "by (simp add: rep_nat_term_pp_def) (metis deg_pp_eq_0_iff deg_rep_nat_pp rep_zero)"], ["proof (state)\nthis:\n  rep_nat_term 0 = (0, 0)\n\ngoal (1 subgoal):\n 1. splus = (+)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. splus = (+)", "show \"splus = ((+)::('a, 'b) pp \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splus = (+)", "by (simp add: splus_pp_def)"], ["proof (state)\nthis:\n  splus = (+)\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation prod :: (\"{nat_pp_compare, comm_powerprod}\", nat) nat_term\nbegin"], ["", "definition rep_nat_term_prod :: \"('a \\<times> 'b) \\<Rightarrow> ((nat, nat) pp \\<times> nat)\"\n  where rep_nat_term_prod_def [code del]: \"rep_nat_term_prod u = (rep_nat_pp (fst u), rep_nat (snd u))\""], ["", "definition splus_prod :: \"('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'b)\"\n  where splus_prod_def [code del]: \"splus_prod t u = pprod.splus (fst t) u\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, nat_term_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_term x = rep_nat_term y \\<Longrightarrow> x = y\n 2. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 3. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "fix x y :: \"'a \\<times> 'b\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_term x = rep_nat_term y \\<Longrightarrow> x = y\n 2. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 3. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "assume \"rep_nat_term x = rep_nat_term y\""], ["proof (state)\nthis:\n  rep_nat_term x = rep_nat_term y\n\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_term x = rep_nat_term y \\<Longrightarrow> x = y\n 2. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 3. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "hence 1: \"rep_nat_pp (fst x) = rep_nat_pp (fst y)\" and 2: \"rep_nat (snd x) = rep_nat (snd y)\""], ["proof (prove)\nusing this:\n  rep_nat_term x = rep_nat_term y\n\ngoal (1 subgoal):\n 1. rep_nat_pp (fst x) = rep_nat_pp (fst y) &&&\n    rep_nat (snd x) = rep_nat (snd y)", "by (simp_all add: rep_nat_term_prod_def)"], ["proof (state)\nthis:\n  rep_nat_pp (fst x) = rep_nat_pp (fst y)\n  rep_nat (snd x) = rep_nat (snd y)\n\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_term x = rep_nat_term y \\<Longrightarrow> x = y\n 2. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 3. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "from 1"], ["proof (chain)\npicking this:\n  rep_nat_pp (fst x) = rep_nat_pp (fst y)", "have \"fst x = fst y\""], ["proof (prove)\nusing this:\n  rep_nat_pp (fst x) = rep_nat_pp (fst y)\n\ngoal (1 subgoal):\n 1. fst x = fst y", "by (rule rep_nat_pp_inj)"], ["proof (state)\nthis:\n  fst x = fst y\n\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_term x = rep_nat_term y \\<Longrightarrow> x = y\n 2. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 3. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "moreover"], ["proof (state)\nthis:\n  fst x = fst y\n\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_term x = rep_nat_term y \\<Longrightarrow> x = y\n 2. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 3. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "from 2"], ["proof (chain)\npicking this:\n  rep_nat (snd x) = rep_nat (snd y)", "have \"snd x = snd y\""], ["proof (prove)\nusing this:\n  rep_nat (snd x) = rep_nat (snd y)\n\ngoal (1 subgoal):\n 1. snd x = snd y", "by (rule rep_inj)"], ["proof (state)\nthis:\n  snd x = snd y\n\ngoal (3 subgoals):\n 1. \\<And>x y. rep_nat_term x = rep_nat_term y \\<Longrightarrow> x = y\n 2. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 3. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "ultimately"], ["proof (chain)\npicking this:\n  fst x = fst y\n  snd x = snd y", "show \"x = y\""], ["proof (prove)\nusing this:\n  fst x = fst y\n  snd x = snd y\n\ngoal (1 subgoal):\n 1. x = y", "by (rule prod_eqI)"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 2. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 2. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "fix i t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x i t.\n       snd (rep_nat_term x) = i \\<Longrightarrow>\n       \\<exists>y. rep_nat_term y = (t, i)\n 2. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "show \"\\<exists>y::'a \\<times> 'b. rep_nat_term y = (t, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. rep_nat_term y = (t, i)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. rep_nat_term ?y = (t, i)", "show \"rep_nat_term (abs_nat_pp t, abs_nat i) = (t, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_term (abs_nat_pp t, abs_nat i) = (t, i)", "by (simp add: rep_nat_term_prod_def)"], ["proof (state)\nthis:\n  rep_nat_term (abs_nat_pp t, abs_nat i) = (t, i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y. rep_nat_term y = (t, i)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "fix x y :: \"'a \\<times> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term (splus x y) =\n       pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "show \"rep_nat_term (splus x y) = pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_term (splus x y) =\n    pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)", "by (simp add: splus_prod_def rep_nat_term_prod_def pprod.splus_def plus_pp)"], ["proof (state)\nthis:\n  rep_nat_term (splus x y) =\n  pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation prod :: (\"{nat_pp_compare, comm_powerprod}\", nat) nat_term_compare\nbegin"], ["", "definition is_scalar_prod :: \"('a \\<times> 'b) itself \\<Rightarrow> bool\"\n  where is_scalar_prod_def [code_unfold]: \"is_scalar_prod = (\\<lambda>_. False)\""], ["", "definition lex_comp_prod :: \"('a \\<times> 'b) comparator\"\n  where \"lex_comp_prod = (\\<lambda>u v. case lex_comp' (fst u) (fst v) of Eq \\<Rightarrow> comparator_of (snd u) (snd v) | val \\<Rightarrow> val)\""], ["", "definition deg_comp_prod :: \"('a \\<times> 'b) comparator \\<Rightarrow> ('a \\<times> 'b) comparator\"\n  where deg_comp_prod_def: \"deg_comp_prod cmp = (\\<lambda>x y. case comparator_of (deg' (fst x)) (deg' (fst y)) of Eq \\<Rightarrow> cmp x y | val \\<Rightarrow> val)\""], ["", "definition pot_comp_prod :: \"('a \\<times> 'b) comparator \\<Rightarrow> ('a \\<times> 'b) comparator\"\n  where \"pot_comp_prod cmp = (\\<lambda>u v. case comparator_of (snd u) (snd v) of Eq \\<Rightarrow> cmp u v | val \\<Rightarrow> val)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, nat_term_compare_class)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<exists>x. snd (rep_nat_term x) = 0\n 2. is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)\n 3. lex_comp = lex_comp_aux\n 4. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 5. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 6. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "show \"\\<exists>x::'a \\<times> 'b. snd (rep_nat_term x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. snd (rep_nat_term x) = 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (rep_nat_term ?x) = 0", "show \"snd (rep_nat_term (abs_nat_pp 0, 0)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rep_nat_term (abs_nat_pp 0, 0::'d)) = 0", "by (simp add: rep_nat_term_prod_def)"], ["proof (state)\nthis:\n  snd (rep_nat_term (abs_nat_pp 0, 0::?'d1)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. snd (rep_nat_term x) = 0\n\ngoal (5 subgoals):\n 1. is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)\n 2. lex_comp = lex_comp_aux\n 3. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 4. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 5. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)\n 2. lex_comp = lex_comp_aux\n 3. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 4. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 5. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "have \"\\<not> (\\<forall>a. rep_nat (a::'b) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a. rep_nat a = 0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a. rep_nat a = 0 \\<Longrightarrow> False", "assume \"\\<forall>a. rep_nat (a::'b) = 0\""], ["proof (state)\nthis:\n  \\<forall>a. rep_nat a = 0\n\ngoal (1 subgoal):\n 1. \\<forall>a. rep_nat a = 0 \\<Longrightarrow> False", "hence \"rep_nat ((abs_nat 1)::'b) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>a. rep_nat a = 0\n\ngoal (1 subgoal):\n 1. rep_nat (abs_nat 1) = 0", "by blast"], ["proof (state)\nthis:\n  rep_nat (abs_nat 1) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>a. rep_nat a = 0 \\<Longrightarrow> False", "hence \"((abs_nat 1)::'b) = 0\""], ["proof (prove)\nusing this:\n  rep_nat (abs_nat 1) = 0\n\ngoal (1 subgoal):\n 1. abs_nat 1 = (0::'b)", "by (simp only: rep_zero_iff)"], ["proof (state)\nthis:\n  abs_nat 1 = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<forall>a. rep_nat a = 0 \\<Longrightarrow> False", "hence \"(1::nat) = 0\""], ["proof (prove)\nusing this:\n  abs_nat 1 = (0::'b)\n\ngoal (1 subgoal):\n 1. 1 = 0", "by (metis abs_inj abs_zero)"], ["proof (state)\nthis:\n  1 = 0\n\ngoal (1 subgoal):\n 1. \\<forall>a. rep_nat a = 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  1 = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<forall>a. rep_nat a = 0)\n\ngoal (5 subgoals):\n 1. is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)\n 2. lex_comp = lex_comp_aux\n 3. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 4. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 5. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "thus \"is_scalar = (\\<lambda>_::('a \\<times> 'b) itself. \\<forall>x. snd (rep_nat_term (x::'a \\<times> 'b)) = 0)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>a. rep_nat a = 0)\n\ngoal (1 subgoal):\n 1. is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)", "by (auto simp add: is_scalar_prod_def rep_nat_term_prod_def intro!: ext)"], ["proof (state)\nthis:\n  is_scalar = (\\<lambda>_. \\<forall>x. snd (rep_nat_term x) = 0)\n\ngoal (4 subgoals):\n 1. lex_comp = lex_comp_aux\n 2. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 3. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 4. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. lex_comp = lex_comp_aux\n 2. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 3. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 4. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "show \"lex_comp = (lex_comp_aux::('a \\<times> 'b) comparator)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_comp = lex_comp_aux", "by (auto simp: lex_comp_prod_def lex_comp_aux_def rep_nat_term_prod_def lex_comp' comparator_of_rep split: order.split intro!: ext)"], ["proof (state)\nthis:\n  lex_comp = lex_comp_aux\n\ngoal (3 subgoals):\n 1. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 3. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 3. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "fix cmp :: \"('a \\<times> 'b) comparator\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cmp.\n       deg_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (deg_pp (fst (rep_nat_term x)))\n                 (deg_pp (fst (rep_nat_term y))) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 3. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "show \"deg_comp cmp =\n         (\\<lambda>x y. case comparator_of (deg_pp (fst (rep_nat_term x))) (deg_pp (fst (rep_nat_term y))) of Eq \\<Rightarrow> cmp x y\n                   | Lt \\<Rightarrow> Lt | Gt \\<Rightarrow> Gt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_comp cmp =\n    (\\<lambda>x y.\n        case comparator_of (deg_pp (fst (rep_nat_term x)))\n              (deg_pp (fst (rep_nat_term y))) of\n        Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n        | Gt \\<Rightarrow> Gt)", "by (simp add: rep_nat_term_prod_def deg_comp_prod_def deg')"], ["proof (state)\nthis:\n  deg_comp cmp =\n  (\\<lambda>x y.\n      case comparator_of (deg_pp (fst (rep_nat_term x)))\n            (deg_pp (fst (rep_nat_term y))) of\n      Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt | Gt \\<Rightarrow> Gt)\n\ngoal (2 subgoals):\n 1. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "fix cmp :: \"('a \\<times> 'b) comparator\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cmp.\n       pot_comp cmp =\n       (\\<lambda>x y.\n           case comparator_of (snd (rep_nat_term x))\n                 (snd (rep_nat_term y)) of\n           Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n           | Gt \\<Rightarrow> Gt)\n 2. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "show \"pot_comp cmp =\n         (\\<lambda>x y. case comparator_of (snd (rep_nat_term x)) (snd (rep_nat_term y)) of Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt | Gt \\<Rightarrow> Gt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pot_comp cmp =\n    (\\<lambda>x y.\n        case comparator_of (snd (rep_nat_term x)) (snd (rep_nat_term y)) of\n        Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt\n        | Gt \\<Rightarrow> Gt)", "by (simp add: rep_nat_term_prod_def pot_comp_prod_def comparator_of_rep)"], ["proof (state)\nthis:\n  pot_comp cmp =\n  (\\<lambda>x y.\n      case comparator_of (snd (rep_nat_term x)) (snd (rep_nat_term y)) of\n      Eq \\<Rightarrow> cmp x y | Lt \\<Rightarrow> Lt | Gt \\<Rightarrow> Gt)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "fix x y :: \"'a \\<times> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "assume \"rep_nat_term x \\<le> rep_nat_term y\""], ["proof (state)\nthis:\n  rep_nat_term x \\<le> rep_nat_term y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "hence \"rep_nat_pp (fst x) < rep_nat_pp (fst y) \\<or> (rep_nat_pp (fst x) \\<le> rep_nat_pp (fst y) \\<and> rep_nat (snd x) \\<le> rep_nat (snd y))\""], ["proof (prove)\nusing this:\n  rep_nat_term x \\<le> rep_nat_term y\n\ngoal (1 subgoal):\n 1. rep_nat_pp (fst x) < rep_nat_pp (fst y) \\<or>\n    rep_nat_pp (fst x) \\<le> rep_nat_pp (fst y) \\<and>\n    rep_nat (snd x) \\<le> rep_nat (snd y)", "by (simp add: rep_nat_term_prod_def)"], ["proof (state)\nthis:\n  rep_nat_pp (fst x) < rep_nat_pp (fst y) \\<or>\n  rep_nat_pp (fst x) \\<le> rep_nat_pp (fst y) \\<and>\n  rep_nat (snd x) \\<le> rep_nat (snd y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rep_nat_term x \\<le> rep_nat_term y \\<Longrightarrow> x \\<le> y", "thus \"x \\<le> y\""], ["proof (prove)\nusing this:\n  rep_nat_pp (fst x) < rep_nat_pp (fst y) \\<or>\n  rep_nat_pp (fst x) \\<le> rep_nat_pp (fst y) \\<and>\n  rep_nat (snd x) \\<le> rep_nat (snd y)\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (auto simp: less_eq_prod_def ord_iff[symmetric] intro: le_pp less_pp)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemmas [code del] = deg_pp.rep_eq plus_pp.abs_eq minus_pp.abs_eq"], ["", "lemma rep_nat_pp_nat [code_unfold]: \"(rep_nat_pp::(nat, nat) pp \\<Rightarrow> (nat, nat) pp) = (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_pp = (\\<lambda>x. x)", "by (intro ext pp_eqI, simp add: lookup_rep_nat_pp_pp abs_nat_nat_def rep_nat_nat_def)"], ["", "subsubsection \\<open>\\<open>LEX\\<close>, \\<open>DRLEX\\<close>, \\<open>DEG\\<close> and \\<open>POT\\<close>\\<close>"], ["", "definition LEX :: \"'a::nat_term_compare nat_term_order\" where \"LEX = Abs_nat_term_order lex_comp\""], ["", "definition DRLEX :: \"'a::nat_term_compare nat_term_order\"\n  where \"DRLEX = Abs_nat_term_order (deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)))\""], ["", "definition DEG :: \"'a::nat_term_compare nat_term_order \\<Rightarrow> 'a nat_term_order\"\n  where \"DEG to = Abs_nat_term_order (deg_comp (nat_term_compare to))\""], ["", "definition POT :: \"'a::nat_term_compare nat_term_order \\<Rightarrow> 'a nat_term_order\"\n  where \"POT to = Abs_nat_term_order (pot_comp (nat_term_compare to))\""], ["", "text \\<open>@{const DRLEX} must apply @{const pot_comp}, for otherwise it does not satisfy\n  the second condition of @{const nat_term_comp}.\\<close>"], ["", "text \\<open>Instead of @{const DRLEX} one could also introduce another unary constructor \\<open>DEGREV\\<close>, analogous\n  to @{const DEG} and @{const POT}. Then, however, proving (in)equalities of the term orders gets\n  really messy (think of @{prop \"DEG (POT to) = DEGREV (DEGREV to)\"}, for instance).\n  So, we restrict the formalization to @{const DRLEX} only.\\<close>"], ["", "abbreviation \"DLEX \\<equiv> DEG LEX\""], ["", "code_datatype LEX DRLEX DEG POT"], ["", "lemma nat_term_compare_LEX [code]: \"nat_term_compare LEX = lex_comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX = lex_comp", "unfolding LEX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (Abs_nat_term_order lex_comp) = lex_comp", "using comparator_lex_comp nat_term_comp_lex_comp"], ["proof (prove)\nusing this:\n  comparator lex_comp\n  nat_term_comp lex_comp\n\ngoal (1 subgoal):\n 1. nat_term_compare (Abs_nat_term_order lex_comp) = lex_comp", "by (rule nat_term_compare_Abs_nat_term_order_id)"], ["", "lemma nat_term_compare_DRLEX [code]: \"nat_term_compare DRLEX = deg_comp (pot_comp (\\<lambda>x y. lex_comp y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX =\n    deg_comp (pot_comp (\\<lambda>x y. lex_comp y x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX =\n    deg_comp (pot_comp (\\<lambda>x y. lex_comp y x))", "have cmp: \"comparator (pot_comp (\\<lambda>x y. lex_comp y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (pot_comp (\\<lambda>x y. lex_comp y x))", "by (rule comparator_pot_comp, rule comparator_converse, fact comparator_lex_comp)"], ["proof (state)\nthis:\n  comparator (pot_comp (\\<lambda>x y. lex_comp y x))\n\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX =\n    deg_comp (pot_comp (\\<lambda>x y. lex_comp y x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX =\n    deg_comp (pot_comp (\\<lambda>x y. lex_comp y x))", "unfolding DRLEX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare\n     (Abs_nat_term_order\n       (deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)))) =\n    deg_comp (pot_comp (\\<lambda>x y. lex_comp y x))", "proof (rule nat_term_compare_Abs_nat_term_order_id)"], ["proof (state)\ngoal (2 subgoals):\n 1. comparator (deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)))\n 2. nat_term_comp (deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)))", "from cmp"], ["proof (chain)\npicking this:\n  comparator (pot_comp (\\<lambda>x y. lex_comp y x))", "show \"comparator (deg_comp (pot_comp (\\<lambda>x y::'a. lex_comp y x)))\""], ["proof (prove)\nusing this:\n  comparator (pot_comp (\\<lambda>x y. lex_comp y x))\n\ngoal (1 subgoal):\n 1. comparator (deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)))", "by (rule comparator_deg_comp)"], ["proof (state)\nthis:\n  comparator (deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)))\n\ngoal (1 subgoal):\n 1. nat_term_comp (deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_term_comp (deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)))", "show \"nat_term_comp (deg_comp (pot_comp (\\<lambda>x y::'a. lex_comp y x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_comp (deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)))", "proof (rule nat_term_compI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v \\<noteq>\n                         Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt\n 3. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "fix u v :: 'a"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v \\<noteq>\n                         Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt\n 3. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "assume \"snd (rep_nat_term u) = snd (rep_nat_term v)\" and \"fst (rep_nat_term u) = 0\""], ["proof (state)\nthis:\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  fst (rep_nat_term u) = 0\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v \\<noteq>\n                         Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt\n 3. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "with cmp"], ["proof (chain)\npicking this:\n  comparator (pot_comp (\\<lambda>x y. lex_comp y x))\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  fst (rep_nat_term u) = 0", "show \"deg_comp (pot_comp (\\<lambda>x y::'a. lex_comp y x)) u v \\<noteq> Gt\""], ["proof (prove)\nusing this:\n  comparator (pot_comp (\\<lambda>x y. lex_comp y x))\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  fst (rep_nat_term u) = 0\n\ngoal (1 subgoal):\n 1. deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v \\<noteq> Gt", "by (rule deg_comp_zero_min)"], ["proof (state)\nthis:\n  deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v \\<noteq> Gt\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt\n 2. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt\n 2. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "fix u v :: 'a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt\n 2. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "assume \"snd (rep_nat_term u) < snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  snd (rep_nat_term u) < snd (rep_nat_term v)\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt\n 2. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "hence \"pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term u) < snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt", "by (rule pot_comp_pos)"], ["proof (state)\nthis:\n  pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt\n 2. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "moreover"], ["proof (state)\nthis:\n  pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt\n 2. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "assume \"fst (rep_nat_term u) = fst (rep_nat_term v)\""], ["proof (state)\nthis:\n  fst (rep_nat_term u) = fst (rep_nat_term v)\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt\n 2. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "ultimately"], ["proof (chain)\npicking this:\n  pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt\n  fst (rep_nat_term u) = fst (rep_nat_term v)", "show \"deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v = Lt\""], ["proof (prove)\nusing this:\n  pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt\n  fst (rep_nat_term u) = fst (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v = Lt", "by (rule deg_comp_pos)"], ["proof (state)\nthis:\n  deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "fix t u v :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "have \"pot_comp (\\<lambda>x y. lex_comp y x) (splus t u) (splus t v) = Lt\"\n        if \"pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pot_comp (\\<lambda>x y. lex_comp y x) (splus t u) (splus t v) = Lt", "using _ that"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt\n\ngoal (1 subgoal):\n 1. pot_comp (\\<lambda>x y. lex_comp y x) (splus t u) (splus t v) = Lt", "proof (rule pot_comp_monotone)"], ["proof (state)\ngoal (1 subgoal):\n 1. lex_comp v u = Lt \\<Longrightarrow>\n    lex_comp (splus t v) (splus t u) = Lt", "assume \"lex_comp v u = Lt\""], ["proof (state)\nthis:\n  lex_comp v u = Lt\n\ngoal (1 subgoal):\n 1. lex_comp v u = Lt \\<Longrightarrow>\n    lex_comp (splus t v) (splus t u) = Lt", "with nat_term_comp_lex_comp"], ["proof (chain)\npicking this:\n  nat_term_comp lex_comp\n  lex_comp v u = Lt", "show \"lex_comp (splus t v) (splus t u) = Lt\""], ["proof (prove)\nusing this:\n  nat_term_comp lex_comp\n  lex_comp v u = Lt\n\ngoal (1 subgoal):\n 1. lex_comp (splus t v) (splus t u) = Lt", "by (rule nat_term_compD3)"], ["proof (state)\nthis:\n  lex_comp (splus t v) (splus t u) = Lt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt \\<Longrightarrow>\n  pot_comp (\\<lambda>x y. lex_comp y x) (splus t u) (splus t v) = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "moreover"], ["proof (state)\nthis:\n  pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt \\<Longrightarrow>\n  pot_comp (\\<lambda>x y. lex_comp y x) (splus t u) (splus t v) = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "assume \"deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v = Lt\""], ["proof (state)\nthis:\n  deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v =\n       Lt \\<Longrightarrow>\n       deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n        (splus t v) =\n       Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "ultimately"], ["proof (chain)\npicking this:\n  pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt \\<Longrightarrow>\n  pot_comp (\\<lambda>x y. lex_comp y x) (splus t u) (splus t v) = Lt\n  deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v = Lt", "show \"deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u) (splus t v) = Lt\""], ["proof (prove)\nusing this:\n  pot_comp (\\<lambda>x y. lex_comp y x) u v = Lt \\<Longrightarrow>\n  pot_comp (\\<lambda>x y. lex_comp y x) (splus t u) (splus t v) = Lt\n  deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v = Lt\n\ngoal (1 subgoal):\n 1. deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u)\n     (splus t v) =\n    Lt", "by (rule deg_comp_monotone)"], ["proof (state)\nthis:\n  deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) (splus t u) (splus t v) =\n  Lt\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "fix u v a b :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "assume \"fst (rep_nat_term v) = fst (rep_nat_term b)\" and \"fst (rep_nat_term u) = fst (rep_nat_term a)\"\n        and \"snd (rep_nat_term u) = snd (rep_nat_term v)\" and \"snd (rep_nat_term a) = snd (rep_nat_term b)\""], ["proof (state)\nthis:\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "moreover"], ["proof (state)\nthis:\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "from comparator_lex_comp nat_term_comp_lex_comp this(1, 2) this(3, 4)[symmetric]"], ["proof (chain)\npicking this:\n  comparator lex_comp\n  nat_term_comp lex_comp\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  snd (rep_nat_term v) = snd (rep_nat_term u)\n  snd (rep_nat_term b) = snd (rep_nat_term a)", "have \"lex_comp v u = lex_comp b a\""], ["proof (prove)\nusing this:\n  comparator lex_comp\n  nat_term_comp lex_comp\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  snd (rep_nat_term v) = snd (rep_nat_term u)\n  snd (rep_nat_term b) = snd (rep_nat_term a)\n\ngoal (1 subgoal):\n 1. lex_comp v u = lex_comp b a", "by (rule nat_term_compD4')"], ["proof (state)\nthis:\n  lex_comp v u = lex_comp b a\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "moreover"], ["proof (state)\nthis:\n  lex_comp v u = lex_comp b a\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "assume \"deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\""], ["proof (state)\nthis:\n  deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u\n                          v =\n                         Lt", "ultimately"], ["proof (chain)\npicking this:\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n  lex_comp v u = lex_comp b a\n  deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt", "show \"deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v = Lt\""], ["proof (prove)\nusing this:\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n  lex_comp v u = lex_comp b a\n  deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) a b = Lt\n\ngoal (1 subgoal):\n 1. deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v = Lt", "by (simp add: deg_comp pot_comp split: order.splits)"], ["proof (state)\nthis:\n  deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)) u v = Lt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_comp (deg_comp (pot_comp (\\<lambda>x y. lex_comp y x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_compare DRLEX = deg_comp (pot_comp (\\<lambda>x y. lex_comp y x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_term_compare_DEG [code]: \"nat_term_compare (DEG to) = deg_comp (nat_term_compare to)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (DEG to) = deg_comp (nat_term_compare to)", "unfolding DEG_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (Abs_nat_term_order (deg_comp (nat_term_compare to))) =\n    deg_comp (nat_term_compare to)", "proof (rule nat_term_compare_Abs_nat_term_order_id)"], ["proof (state)\ngoal (2 subgoals):\n 1. comparator (deg_comp (nat_term_compare to))\n 2. nat_term_comp (deg_comp (nat_term_compare to))", "from comparator_nat_term_compare"], ["proof (chain)\npicking this:\n  comparator (nat_term_compare ?to)", "show \"comparator (deg_comp (nat_term_compare to))\""], ["proof (prove)\nusing this:\n  comparator (nat_term_compare ?to)\n\ngoal (1 subgoal):\n 1. comparator (deg_comp (nat_term_compare to))", "by (rule comparator_deg_comp)"], ["proof (state)\nthis:\n  comparator (deg_comp (nat_term_compare to))\n\ngoal (1 subgoal):\n 1. nat_term_comp (deg_comp (nat_term_compare to))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_term_comp (deg_comp (nat_term_compare to))", "show \"nat_term_comp (deg_comp (nat_term_compare to))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_comp (deg_comp (nat_term_compare to))", "proof (rule nat_term_compI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt\n 3. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "fix u v :: 'a"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt\n 3. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "assume \"snd (rep_nat_term u) = snd (rep_nat_term v)\" and \"fst (rep_nat_term u) = 0\""], ["proof (state)\nthis:\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  fst (rep_nat_term u) = 0\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt\n 3. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "with comparator_nat_term_compare"], ["proof (chain)\npicking this:\n  comparator (nat_term_compare ?to)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  fst (rep_nat_term u) = 0", "show \"deg_comp (nat_term_compare to) u v \\<noteq> Gt\""], ["proof (prove)\nusing this:\n  comparator (nat_term_compare ?to)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  fst (rep_nat_term u) = 0\n\ngoal (1 subgoal):\n 1. deg_comp (nat_term_compare to) u v \\<noteq> Gt", "by (rule deg_comp_zero_min)"], ["proof (state)\nthis:\n  deg_comp (nat_term_compare to) u v \\<noteq> Gt\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt\n 2. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt\n 2. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "fix u v :: 'a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt\n 2. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "assume a: \"fst (rep_nat_term u) = fst (rep_nat_term v)\" and \"snd (rep_nat_term u) < snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  fst (rep_nat_term u) = fst (rep_nat_term v)\n  snd (rep_nat_term u) < snd (rep_nat_term v)\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt\n 2. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "with nat_term_comp_nat_term_compare"], ["proof (chain)\npicking this:\n  nat_term_comp (nat_term_compare ?to)\n  fst (rep_nat_term u) = fst (rep_nat_term v)\n  snd (rep_nat_term u) < snd (rep_nat_term v)", "have \"nat_term_compare to u v = Lt\""], ["proof (prove)\nusing this:\n  nat_term_comp (nat_term_compare ?to)\n  fst (rep_nat_term u) = fst (rep_nat_term v)\n  snd (rep_nat_term u) < snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare to u v = Lt", "by (rule nat_term_compD2)"], ["proof (state)\nthis:\n  nat_term_compare to u v = Lt\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt\n 2. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "thus \"deg_comp (nat_term_compare to) u v = Lt\""], ["proof (prove)\nusing this:\n  nat_term_compare to u v = Lt\n\ngoal (1 subgoal):\n 1. deg_comp (nat_term_compare to) u v = Lt", "using a"], ["proof (prove)\nusing this:\n  nat_term_compare to u v = Lt\n  fst (rep_nat_term u) = fst (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. deg_comp (nat_term_compare to) u v = Lt", "by (rule deg_comp_pos)"], ["proof (state)\nthis:\n  deg_comp (nat_term_compare to) u v = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "fix t u v :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "from nat_term_comp_nat_term_compare"], ["proof (chain)\npicking this:\n  nat_term_comp (nat_term_compare ?to)", "have \"nat_term_compare to u v = Lt \\<Longrightarrow> nat_term_compare to (splus t u) (splus t v) = Lt\""], ["proof (prove)\nusing this:\n  nat_term_comp (nat_term_compare ?to)\n\ngoal (1 subgoal):\n 1. nat_term_compare to u v = Lt \\<Longrightarrow>\n    nat_term_compare to (splus t u) (splus t v) = Lt", "by (rule nat_term_compD3)"], ["proof (state)\nthis:\n  nat_term_compare to u v = Lt \\<Longrightarrow>\n  nat_term_compare to (splus t u) (splus t v) = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "moreover"], ["proof (state)\nthis:\n  nat_term_compare to u v = Lt \\<Longrightarrow>\n  nat_term_compare to (splus t u) (splus t v) = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "assume \"deg_comp (nat_term_compare to) u v = Lt\""], ["proof (state)\nthis:\n  deg_comp (nat_term_compare to) u v = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       deg_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "ultimately"], ["proof (chain)\npicking this:\n  nat_term_compare to u v = Lt \\<Longrightarrow>\n  nat_term_compare to (splus t u) (splus t v) = Lt\n  deg_comp (nat_term_compare to) u v = Lt", "show \"deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\""], ["proof (prove)\nusing this:\n  nat_term_compare to u v = Lt \\<Longrightarrow>\n  nat_term_compare to (splus t u) (splus t v) = Lt\n  deg_comp (nat_term_compare to) u v = Lt\n\ngoal (1 subgoal):\n 1. deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt", "by (rule deg_comp_monotone)"], ["proof (state)\nthis:\n  deg_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "fix u v a b :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "assume \"fst (rep_nat_term u) = fst (rep_nat_term a)\" and \"fst (rep_nat_term v) = fst (rep_nat_term b)\"\n      and \"snd (rep_nat_term u) = snd (rep_nat_term v)\" and \"snd (rep_nat_term a) = snd (rep_nat_term b)\""], ["proof (state)\nthis:\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "moreover"], ["proof (state)\nthis:\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "from comparator_nat_term_compare nat_term_comp_nat_term_compare this"], ["proof (chain)\npicking this:\n  comparator (nat_term_compare ?to)\n  nat_term_comp (nat_term_compare ?to)\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)", "have \"nat_term_compare to u v = nat_term_compare to a b\""], ["proof (prove)\nusing this:\n  comparator (nat_term_compare ?to)\n  nat_term_comp (nat_term_compare ?to)\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n\ngoal (1 subgoal):\n 1. nat_term_compare to u v = nat_term_compare to a b", "by (rule nat_term_compD4')"], ["proof (state)\nthis:\n  nat_term_compare to u v = nat_term_compare to a b\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "moreover"], ["proof (state)\nthis:\n  nat_term_compare to u v = nat_term_compare to a b\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "assume \"deg_comp (nat_term_compare to) a b = Lt\""], ["proof (state)\nthis:\n  deg_comp (nat_term_compare to) a b = Lt\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        deg_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> deg_comp (nat_term_compare to) u v = Lt", "ultimately"], ["proof (chain)\npicking this:\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n  nat_term_compare to u v = nat_term_compare to a b\n  deg_comp (nat_term_compare to) a b = Lt", "show \"deg_comp (nat_term_compare to) u v = Lt\""], ["proof (prove)\nusing this:\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n  nat_term_compare to u v = nat_term_compare to a b\n  deg_comp (nat_term_compare to) a b = Lt\n\ngoal (1 subgoal):\n 1. deg_comp (nat_term_compare to) u v = Lt", "by (simp add: deg_comp split: order.splits)"], ["proof (state)\nthis:\n  deg_comp (nat_term_compare to) u v = Lt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_comp (deg_comp (nat_term_compare to))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_term_compare_POT [code]: \"nat_term_compare (POT to) = pot_comp (nat_term_compare to)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (POT to) = pot_comp (nat_term_compare to)", "unfolding POT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (Abs_nat_term_order (pot_comp (nat_term_compare to))) =\n    pot_comp (nat_term_compare to)", "proof (rule nat_term_compare_Abs_nat_term_order_id)"], ["proof (state)\ngoal (2 subgoals):\n 1. comparator (pot_comp (nat_term_compare to))\n 2. nat_term_comp (pot_comp (nat_term_compare to))", "from comparator_nat_term_compare"], ["proof (chain)\npicking this:\n  comparator (nat_term_compare ?to)", "show \"comparator (pot_comp (nat_term_compare to))\""], ["proof (prove)\nusing this:\n  comparator (nat_term_compare ?to)\n\ngoal (1 subgoal):\n 1. comparator (pot_comp (nat_term_compare to))", "by (rule comparator_pot_comp)"], ["proof (state)\nthis:\n  comparator (pot_comp (nat_term_compare to))\n\ngoal (1 subgoal):\n 1. nat_term_comp (pot_comp (nat_term_compare to))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_term_comp (pot_comp (nat_term_compare to))", "show \"nat_term_comp (pot_comp (nat_term_compare to))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_comp (pot_comp (nat_term_compare to))", "proof (rule nat_term_compI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt\n 3. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "fix u v :: 'a"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt\n 3. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "assume a: \"snd (rep_nat_term u) = snd (rep_nat_term v)\" and \"fst (rep_nat_term u) = 0\""], ["proof (state)\nthis:\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  fst (rep_nat_term u) = 0\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt\n 3. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "with nat_term_comp_nat_term_compare"], ["proof (chain)\npicking this:\n  nat_term_comp (nat_term_compare ?to)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  fst (rep_nat_term u) = 0", "have \"nat_term_compare to u v \\<noteq> Gt\""], ["proof (prove)\nusing this:\n  nat_term_comp (nat_term_compare ?to)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  fst (rep_nat_term u) = 0\n\ngoal (1 subgoal):\n 1. nat_term_compare to u v \\<noteq> Gt", "by (rule nat_term_compD1)"], ["proof (state)\nthis:\n  nat_term_compare to u v \\<noteq> Gt\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt\n 3. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "thus \"pot_comp (nat_term_compare to) u v \\<noteq> Gt\""], ["proof (prove)\nusing this:\n  nat_term_compare to u v \\<noteq> Gt\n\ngoal (1 subgoal):\n 1. pot_comp (nat_term_compare to) u v \\<noteq> Gt", "using a"], ["proof (prove)\nusing this:\n  nat_term_compare to u v \\<noteq> Gt\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. pot_comp (nat_term_compare to) u v \\<noteq> Gt", "by (rule pot_comp_zero_min)"], ["proof (state)\nthis:\n  pot_comp (nat_term_compare to) u v \\<noteq> Gt\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt\n 2. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt\n 2. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "fix u v :: 'a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt\n 2. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "assume \"snd (rep_nat_term u) < snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  snd (rep_nat_term u) < snd (rep_nat_term v)\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt\n 2. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "thus \"pot_comp (nat_term_compare to) u v = Lt\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term u) < snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. pot_comp (nat_term_compare to) u v = Lt", "by (rule pot_comp_pos)"], ["proof (state)\nthis:\n  pot_comp (nat_term_compare to) u v = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "fix t u v :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "from nat_term_comp_nat_term_compare"], ["proof (chain)\npicking this:\n  nat_term_comp (nat_term_compare ?to)", "have \"nat_term_compare to u v = Lt \\<Longrightarrow> nat_term_compare to (splus t u) (splus t v) = Lt\""], ["proof (prove)\nusing this:\n  nat_term_comp (nat_term_compare ?to)\n\ngoal (1 subgoal):\n 1. nat_term_compare to u v = Lt \\<Longrightarrow>\n    nat_term_compare to (splus t u) (splus t v) = Lt", "by (rule nat_term_compD3)"], ["proof (state)\nthis:\n  nat_term_compare to u v = Lt \\<Longrightarrow>\n  nat_term_compare to (splus t u) (splus t v) = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "moreover"], ["proof (state)\nthis:\n  nat_term_compare to u v = Lt \\<Longrightarrow>\n  nat_term_compare to (splus t u) (splus t v) = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "assume \"pot_comp (nat_term_compare to) u v = Lt\""], ["proof (state)\nthis:\n  pot_comp (nat_term_compare to) u v = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       pot_comp (nat_term_compare to) u v = Lt \\<Longrightarrow>\n       pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "ultimately"], ["proof (chain)\npicking this:\n  nat_term_compare to u v = Lt \\<Longrightarrow>\n  nat_term_compare to (splus t u) (splus t v) = Lt\n  pot_comp (nat_term_compare to) u v = Lt", "show \"pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\""], ["proof (prove)\nusing this:\n  nat_term_compare to u v = Lt \\<Longrightarrow>\n  nat_term_compare to (splus t u) (splus t v) = Lt\n  pot_comp (nat_term_compare to) u v = Lt\n\ngoal (1 subgoal):\n 1. pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt", "by (rule pot_comp_monotone)"], ["proof (state)\nthis:\n  pot_comp (nat_term_compare to) (splus t u) (splus t v) = Lt\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "fix u v a b :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "assume \"fst (rep_nat_term u) = fst (rep_nat_term a)\" and \"fst (rep_nat_term v) = fst (rep_nat_term b)\"\n      and \"snd (rep_nat_term u) = snd (rep_nat_term v)\" and \"snd (rep_nat_term a) = snd (rep_nat_term b)\""], ["proof (state)\nthis:\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "moreover"], ["proof (state)\nthis:\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "from comparator_nat_term_compare nat_term_comp_nat_term_compare this"], ["proof (chain)\npicking this:\n  comparator (nat_term_compare ?to)\n  nat_term_comp (nat_term_compare ?to)\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)", "have \"nat_term_compare to u v = nat_term_compare to a b\""], ["proof (prove)\nusing this:\n  comparator (nat_term_compare ?to)\n  nat_term_comp (nat_term_compare ?to)\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n\ngoal (1 subgoal):\n 1. nat_term_compare to u v = nat_term_compare to a b", "by (rule nat_term_compD4')"], ["proof (state)\nthis:\n  nat_term_compare to u v = nat_term_compare to a b\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "moreover"], ["proof (state)\nthis:\n  nat_term_compare to u v = nat_term_compare to a b\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "assume \"pot_comp (nat_term_compare to) a b = Lt\""], ["proof (state)\nthis:\n  pot_comp (nat_term_compare to) a b = Lt\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        pot_comp (nat_term_compare to) a b = Lt\\<rbrakk>\n       \\<Longrightarrow> pot_comp (nat_term_compare to) u v = Lt", "ultimately"], ["proof (chain)\npicking this:\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n  nat_term_compare to u v = nat_term_compare to a b\n  pot_comp (nat_term_compare to) a b = Lt", "show \"pot_comp (nat_term_compare to) u v = Lt\""], ["proof (prove)\nusing this:\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n  snd (rep_nat_term a) = snd (rep_nat_term b)\n  nat_term_compare to u v = nat_term_compare to a b\n  pot_comp (nat_term_compare to) a b = Lt\n\ngoal (1 subgoal):\n 1. pot_comp (nat_term_compare to) u v = Lt", "by (simp add: pot_comp split: order.splits)"], ["proof (state)\nthis:\n  pot_comp (nat_term_compare to) u v = Lt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_comp (pot_comp (nat_term_compare to))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_term_compare_POT_DRLEX [code]:\n  \"nat_term_compare (POT DRLEX) = pot_comp (deg_comp (\\<lambda>x y. lex_comp y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (POT DRLEX) =\n    pot_comp (deg_comp (\\<lambda>x y. lex_comp y x))", "unfolding nat_term_compare_POT nat_term_compare_DRLEX"], ["proof (prove)\ngoal (1 subgoal):\n 1. pot_comp (deg_comp (pot_comp (\\<lambda>x y. lex_comp y x))) =\n    pot_comp (deg_comp (\\<lambda>x y. lex_comp y x))", "by (intro ext pot_comp_cong deg_comp_cong, simp add: pot_comp)"], ["", "lemma compute_lex_pp [code]: \"lex_pp p q = (lex_comp' p q \\<noteq> Gt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp p q = (lex_comp' p q \\<noteq> Gt)", "by (simp add: lex_comp'_pp_def comp_of_ord_def)"], ["", "lemma compute_dlex_pp [code]: \"dlex_pp p q = (deg_comp lex_comp' p q \\<noteq> Gt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pp p q = (deg_comp lex_comp' p q \\<noteq> Gt)", "by (simp add: deg_comp_pp_def dlex_pp_alt compute_lex_pp comparator_of_def)"], ["", "lemma compute_drlex_pp [code]: \"drlex_pp p q = (deg_comp (\\<lambda>x y. lex_comp' y x) p q \\<noteq> Gt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pp p q = (deg_comp (\\<lambda>x y. lex_comp' y x) p q \\<noteq> Gt)", "by (simp add: deg_comp_pp_def drlex_pp_alt compute_lex_pp comparator_of_def)"], ["", "lemma nat_pp_order_of_le_nat_pp [code]: \"nat_term_order_of_le = LEX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_of_le = Term_Order.LEX", "by (simp add: nat_term_order_of_le_def LEX_def lex_comp_alt)"], ["", "subsubsection \\<open>Equality of Term Orders\\<close>"], ["", "definition nat_term_order_eq :: \"'a nat_term_order \\<Rightarrow> 'a::nat_term_compare nat_term_order \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> bool\"\n  where nat_term_order_eq_def [code del]:\n      \"nat_term_order_eq to1 to2 dg ps =\n                (\\<forall>u v. (dg \\<longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))) \\<longrightarrow>\n                       (ps \\<longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)) \\<longrightarrow>\n                       nat_term_compare to1 u v = nat_term_compare to2 u v)\""], ["", "lemma nat_term_order_eqI:\n  assumes \"\\<And>u v. (dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))) \\<Longrightarrow>\n                  (ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)) \\<Longrightarrow>\n                  nat_term_compare to1 u v = nat_term_compare to2 u v\"\n  shows \"nat_term_order_eq to1 to2 dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 to2 dg ps", "unfolding nat_term_order_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u v.\n       (dg \\<longrightarrow>\n        deg_pp (fst (rep_nat_term u)) =\n        deg_pp (fst (rep_nat_term v))) \\<longrightarrow>\n       (ps \\<longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)) \\<longrightarrow>\n       nat_term_compare to1 u v = nat_term_compare to2 u v", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>dg \\<Longrightarrow>\n           deg_pp (fst (rep_nat_term ?u)) = deg_pp (fst (rep_nat_term ?v));\n   ps \\<Longrightarrow>\n   snd (rep_nat_term ?u) = snd (rep_nat_term ?v)\\<rbrakk>\n  \\<Longrightarrow> nat_term_compare to1 ?u ?v = nat_term_compare to2 ?u ?v\n\ngoal (1 subgoal):\n 1. \\<forall>u v.\n       (dg \\<longrightarrow>\n        deg_pp (fst (rep_nat_term u)) =\n        deg_pp (fst (rep_nat_term v))) \\<longrightarrow>\n       (ps \\<longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)) \\<longrightarrow>\n       nat_term_compare to1 u v = nat_term_compare to2 u v", "by blast"], ["", "lemma nat_term_order_eqD:\n  assumes \"nat_term_order_eq to1 to2 dg ps\"\n    and \"dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\"\n    and \"ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\"\n  shows \"nat_term_compare to1 u v = nat_term_compare to2 u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare to1 u v = nat_term_compare to2 u v", "using assms"], ["proof (prove)\nusing this:\n  nat_term_order_eq to1 to2 dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare to1 u v = nat_term_compare to2 u v", "unfolding nat_term_order_eq_def"], ["proof (prove)\nusing this:\n  \\<forall>u v.\n     (dg \\<longrightarrow>\n      deg_pp (fst (rep_nat_term u)) =\n      deg_pp (fst (rep_nat_term v))) \\<longrightarrow>\n     (ps \\<longrightarrow>\n      snd (rep_nat_term u) = snd (rep_nat_term v)) \\<longrightarrow>\n     nat_term_compare to1 u v = nat_term_compare to2 u v\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare to1 u v = nat_term_compare to2 u v", "by blast"], ["", "lemma nat_term_order_eq_sym: \"nat_term_order_eq to1 to2 dg ps \\<longleftrightarrow> nat_term_order_eq to2 to1 dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 to2 dg ps = nat_term_order_eq to2 to1 dg ps", "by (auto simp: nat_term_order_eq_def)"], ["", "lemma nat_term_order_eq_DEG_dg:\n  \"nat_term_order_eq (DEG to1) to2 True ps \\<longleftrightarrow> nat_term_order_eq to1 to2 True ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq (DEG to1) to2 True ps =\n    nat_term_order_eq to1 to2 True ps", "by (auto simp: nat_term_order_eq_def nat_term_compare_DEG deg_comp)"], ["", "lemma nat_term_order_eq_DEG_dg':\n  \"nat_term_order_eq to1 (DEG to2) True ps \\<longleftrightarrow> nat_term_order_eq to1 to2 True ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 (DEG to2) True ps =\n    nat_term_order_eq to1 to2 True ps", "by (simp add: nat_term_order_eq_sym[of to1] nat_term_order_eq_DEG_dg)"], ["", "lemma nat_term_order_eq_POT_ps:\n  assumes \"ps \\<or> is_scalar TYPE('a::nat_term_compare)\"\n  shows \"nat_term_order_eq (POT (to1::'a nat_term_order)) to2 dg ps \\<longleftrightarrow> nat_term_order_eq to1 to2 dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps", "using assms"], ["proof (prove)\nusing this:\n  ps \\<or> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ps \\<Longrightarrow>\n    nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps\n 2. is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps", "assume \"ps\""], ["proof (state)\nthis:\n  ps\n\ngoal (2 subgoals):\n 1. ps \\<Longrightarrow>\n    nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps\n 2. is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps\n\ngoal (1 subgoal):\n 1. nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps", "by (auto simp: nat_term_order_eq_def nat_term_compare_POT pot_comp)"], ["proof (state)\nthis:\n  nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps\n\ngoal (1 subgoal):\n 1. is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps", "assume \"is_scalar TYPE('a)\""], ["proof (state)\nthis:\n  is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps", "hence \"snd (rep_nat_term x) = 0\" for x::'a"], ["proof (prove)\nusing this:\n  is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term x) = 0", "by (simp add: is_scalar)"], ["proof (state)\nthis:\n  snd (rep_nat_term ?x) = 0\n\ngoal (1 subgoal):\n 1. is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps", "thus ?thesis"], ["proof (prove)\nusing this:\n  snd (rep_nat_term ?x) = 0\n\ngoal (1 subgoal):\n 1. nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps", "by (auto simp: nat_term_order_eq_def nat_term_compare_POT pot_comp)"], ["proof (state)\nthis:\n  nat_term_order_eq (POT to1) to2 dg ps = nat_term_order_eq to1 to2 dg ps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_term_order_eq_POT_ps':\n  assumes \"ps \\<or> is_scalar TYPE('a::nat_term_compare)\"\n  shows \"nat_term_order_eq to1 (POT (to2::'a nat_term_order)) dg ps \\<longleftrightarrow> nat_term_order_eq to1 to2 dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 (POT to2) dg ps = nat_term_order_eq to1 to2 dg ps", "using assms"], ["proof (prove)\nusing this:\n  ps \\<or> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 (POT to2) dg ps = nat_term_order_eq to1 to2 dg ps", "by (simp add: nat_term_order_eq_sym[of to1] nat_term_order_eq_POT_ps)"], ["", "lemma snd_rep_nat_term_eqI:\n  assumes \"ps \\<or> is_scalar TYPE('a::nat_term_compare)\" and \"ps \\<Longrightarrow> snd (rep_nat_term (u::'a)) = snd (rep_nat_term (v::'a))\"\n  shows \"snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v)", "using assms(1)"], ["proof (prove)\nusing this:\n  ps \\<or> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n 2. is_scalar TYPE('a) \\<Longrightarrow>\n    snd (rep_nat_term u) = snd (rep_nat_term v)", "assume \"is_scalar TYPE('a)\""], ["proof (state)\nthis:\n  is_scalar TYPE('a)\n\ngoal (2 subgoals):\n 1. ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n 2. is_scalar TYPE('a) \\<Longrightarrow>\n    snd (rep_nat_term u) = snd (rep_nat_term v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v)", "by (simp add: is_scalar)"], ["proof (state)\nthis:\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)", "qed (fact assms(2))"], ["", "definition of_exps :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a::nat_term_compare\"\n  where \"of_exps a b i =\n        (THE u. rep_nat_term u = (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n                                  if (\\<exists>v::'a. snd (rep_nat_term v) = i) then i else 0))\""], ["", "text \\<open>@{const of_exps} is an auxiliary function needed for proving the equalities of the various\n  term orders.\\<close>"], ["", "lemma rep_nat_term_of_exps:\n  \"rep_nat_term ((of_exps a b i)::'a::nat_term_compare) =\n    (pp_of_fun (\\<lambda>x::nat. if x = 0 then a else if x = 1 then b else 0), if (\\<exists>y::'a. snd (rep_nat_term y) = i) then i else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "proof (cases \"\\<exists>y::'a. snd (rep_nat_term y) = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)\n 2. \\<nexists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "case True"], ["proof (state)\nthis:\n  \\<exists>y. snd (rep_nat_term y) = i\n\ngoal (2 subgoals):\n 1. \\<exists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)\n 2. \\<nexists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. snd (rep_nat_term y) = i", "obtain y::'a where \"snd (rep_nat_term y) = i\""], ["proof (prove)\nusing this:\n  \\<exists>y. snd (rep_nat_term y) = i\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        snd (rep_nat_term y) = i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  snd (rep_nat_term y) = i\n\ngoal (2 subgoals):\n 1. \\<exists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)\n 2. \\<nexists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "then"], ["proof (chain)\npicking this:\n  snd (rep_nat_term y) = i", "obtain u::'a where u: \"rep_nat_term u = (pp_of_fun (\\<lambda>x::nat. if x = 0 then a else if x = 1 then b else 0), i)\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term y) = i\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        rep_nat_term u =\n        (pp_of_fun\n          (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n         i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule full_componentE)"], ["proof (state)\nthis:\n  rep_nat_term u =\n  (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), i)\n\ngoal (2 subgoals):\n 1. \\<exists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)\n 2. \\<nexists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "from True"], ["proof (chain)\npicking this:\n  \\<exists>y. snd (rep_nat_term y) = i", "have eq: \"(if \\<exists>y::'a. snd (rep_nat_term y) = i then i else 0) = i\""], ["proof (prove)\nusing this:\n  \\<exists>y. snd (rep_nat_term y) = i\n\ngoal (1 subgoal):\n 1. (if \\<exists>y. snd (rep_nat_term y) = i then i else 0) = i", "by simp"], ["proof (state)\nthis:\n  (if \\<exists>y. snd (rep_nat_term y) = i then i else 0) = i\n\ngoal (2 subgoals):\n 1. \\<exists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)\n 2. \\<nexists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "unfolding of_exps_def eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_term\n     (THE u.\n         rep_nat_term u =\n         (pp_of_fun\n           (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n          i)) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), i)", "proof (rule theI)"], ["proof (state)\ngoal (2 subgoals):\n 1. rep_nat_term ?a =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), i)\n 2. \\<And>x.\n       rep_nat_term x =\n       (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n        i) \\<Longrightarrow>\n       x = ?a", "fix v :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. rep_nat_term ?a =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), i)\n 2. \\<And>x.\n       rep_nat_term x =\n       (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n        i) \\<Longrightarrow>\n       x = ?a", "assume \"rep_nat_term v = (pp_of_fun (\\<lambda>x::nat. if x = 0 then a else if x = 1 then b else 0), i)\""], ["proof (state)\nthis:\n  rep_nat_term v =\n  (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), i)\n\ngoal (2 subgoals):\n 1. rep_nat_term ?a =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), i)\n 2. \\<And>x.\n       rep_nat_term x =\n       (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n        i) \\<Longrightarrow>\n       x = ?a", "thus \"v = u\""], ["proof (prove)\nusing this:\n  rep_nat_term v =\n  (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), i)\n\ngoal (1 subgoal):\n 1. v = u", "unfolding u[symmetric]"], ["proof (prove)\nusing this:\n  rep_nat_term v = rep_nat_term u\n\ngoal (1 subgoal):\n 1. v = u", "by (rule rep_nat_term_inj)"], ["proof (state)\nthis:\n  v = u\n\ngoal (1 subgoal):\n 1. rep_nat_term u =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), i)", "qed (fact u)"], ["proof (state)\nthis:\n  rep_nat_term (of_exps a b i) =\n  (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n   if \\<exists>y. snd (rep_nat_term y) = i then i else 0)\n\ngoal (1 subgoal):\n 1. \\<nexists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "case False"], ["proof (state)\nthis:\n  \\<nexists>y. snd (rep_nat_term y) = i\n\ngoal (1 subgoal):\n 1. \\<nexists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "hence eq: \"(if \\<exists>y::'a. snd (rep_nat_term y) = i then i else 0) = 0\""], ["proof (prove)\nusing this:\n  \\<nexists>y. snd (rep_nat_term y) = i\n\ngoal (1 subgoal):\n 1. (if \\<exists>y. snd (rep_nat_term y) = i then i else 0) = 0", "by simp"], ["proof (state)\nthis:\n  (if \\<exists>y. snd (rep_nat_term y) = i then i else 0) = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "obtain u::'a where u: \"rep_nat_term u = (pp_of_fun (\\<lambda>x::nat. if x = 0 then a else if x = 1 then b else 0), 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        rep_nat_term u =\n        (pp_of_fun\n          (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n         0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule full_component_zeroE)"], ["proof (state)\nthis:\n  rep_nat_term u =\n  (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), 0)\n\ngoal (1 subgoal):\n 1. \\<nexists>y. snd (rep_nat_term y) = i \\<Longrightarrow>\n    rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_term (of_exps a b i) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n     if \\<exists>y. snd (rep_nat_term y) = i then i else 0)", "unfolding of_exps_def eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_nat_term\n     (THE u.\n         rep_nat_term u =\n         (pp_of_fun\n           (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n          0)) =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), 0)", "proof (rule theI)"], ["proof (state)\ngoal (2 subgoals):\n 1. rep_nat_term ?a =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), 0)\n 2. \\<And>x.\n       rep_nat_term x =\n       (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n        0) \\<Longrightarrow>\n       x = ?a", "fix v :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. rep_nat_term ?a =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), 0)\n 2. \\<And>x.\n       rep_nat_term x =\n       (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n        0) \\<Longrightarrow>\n       x = ?a", "assume \"rep_nat_term v = (pp_of_fun (\\<lambda>x::nat. if x = 0 then a else if x = 1 then b else 0), 0)\""], ["proof (state)\nthis:\n  rep_nat_term v =\n  (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), 0)\n\ngoal (2 subgoals):\n 1. rep_nat_term ?a =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), 0)\n 2. \\<And>x.\n       rep_nat_term x =\n       (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n        0) \\<Longrightarrow>\n       x = ?a", "thus \"v = u\""], ["proof (prove)\nusing this:\n  rep_nat_term v =\n  (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), 0)\n\ngoal (1 subgoal):\n 1. v = u", "unfolding u[symmetric]"], ["proof (prove)\nusing this:\n  rep_nat_term v = rep_nat_term u\n\ngoal (1 subgoal):\n 1. v = u", "by (rule rep_nat_term_inj)"], ["proof (state)\nthis:\n  v = u\n\ngoal (1 subgoal):\n 1. rep_nat_term u =\n    (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0), 0)", "qed (fact u)"], ["proof (state)\nthis:\n  rep_nat_term (of_exps a b i) =\n  (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0),\n   if \\<exists>y. snd (rep_nat_term y) = i then i else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pp_of_exps:\n  \"lookup_pp (fst (rep_nat_term (of_exps a b i))) = (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp (fst (rep_nat_term (of_exps a b i))) =\n    (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0)", "unfolding rep_nat_term_of_exps fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp\n     (pp_of_fun (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0)) =\n    (\\<lambda>x. if x = 0 then a else if x = 1 then b else 0)", "proof (rule lookup_pp_of_fun)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. (if x = 0 then a else if x = 1 then b else 0) \\<noteq> 0}", "have \"{x. (if x = 0 then a else if x = 1 then b else 0) \\<noteq> 0} \\<subseteq> {0, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (if x = (0::'b) then a else if x = (1::'b) then b else 0) \\<noteq>\n        0}\n    \\<subseteq> {0::'b, 1::'b}", "by (rule, simp split: if_split_asm)"], ["proof (state)\nthis:\n  {x. (if x = (0::?'b1) then a else if x = (1::?'b1) then b else 0) \\<noteq>\n      0}\n  \\<subseteq> {0::?'b1, 1::?'b1}\n\ngoal (1 subgoal):\n 1. finite {x. (if x = 0 then a else if x = 1 then b else 0) \\<noteq> 0}", "also"], ["proof (state)\nthis:\n  {x. (if x = (0::?'b1) then a else if x = (1::?'b1) then b else 0) \\<noteq>\n      0}\n  \\<subseteq> {0::?'b1, 1::?'b1}\n\ngoal (1 subgoal):\n 1. finite {x. (if x = 0 then a else if x = 1 then b else 0) \\<noteq> 0}", "have \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0::'b, 1::'b}", "by simp"], ["proof (state)\nthis:\n  finite {0::?'b2, 1::?'b2}\n\ngoal (1 subgoal):\n 1. finite {x. (if x = 0 then a else if x = 1 then b else 0) \\<noteq> 0}", "finally(finite_subset)"], ["proof (chain)\npicking this:\n  finite\n   {x. (if x = (0::?'b3) then a\n        else if x = (1::?'b3) then b else 0) \\<noteq>\n       0}", "show \"finite {x. (if x = 0 then a else if x = 1 then b else 0) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  finite\n   {x. (if x = (0::?'b3) then a\n        else if x = (1::?'b3) then b else 0) \\<noteq>\n       0}\n\ngoal (1 subgoal):\n 1. finite\n     {x. (if x = (0::'b) then a else if x = (1::'b) then b else 0) \\<noteq>\n         0}", "."], ["proof (state)\nthis:\n  finite\n   {x. (if x = (0::?'b3) then a\n        else if x = (1::?'b3) then b else 0) \\<noteq>\n       0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_pp_of_exps: \"keys_pp (fst (rep_nat_term (of_exps a b i))) \\<subseteq> {0, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys_pp (fst (rep_nat_term (of_exps a b i))) \\<subseteq> {0, 1}", "by (rule, simp add: keys_pp_iff lookup_pp_of_exps split: if_split_asm)"], ["", "lemma deg_pp_of_exps [simp]: \"deg_pp (fst (rep_nat_term ((of_exps a b i)::'a::nat_term_compare))) = a + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term (of_exps a b i))) = a + b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term (of_exps a b i))) = a + b", "let ?u = \"(of_exps a b i)::'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term (of_exps a b i))) = a + b", "have \"sum (lookup_pp (fst (rep_nat_term ?u))) (keys_pp (fst (rep_nat_term ?u))) =\n        sum (lookup_pp (fst (rep_nat_term ?u))) {0, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup_pp (fst (rep_nat_term (of_exps a b i))))\n     (keys_pp (fst (rep_nat_term (of_exps a b i)))) =\n    sum (lookup_pp (fst (rep_nat_term (of_exps a b i)))) {0, 1}", "proof (rule sum.mono_neutral_left, simp, fact keys_pp_of_exps, intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> {0, 1} -\n                keys_pp\n                 (fst (rep_nat_term (of_exps a b i))) \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a b i))) ia = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> {0, 1} -\n                keys_pp\n                 (fst (rep_nat_term (of_exps a b i))) \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a b i))) ia = 0", "assume \"x \\<in> {0, 1} - keys_pp (fst (rep_nat_term ?u))\""], ["proof (state)\nthis:\n  x \\<in> {0, 1} - keys_pp (fst (rep_nat_term (of_exps a b i)))\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> {0, 1} -\n                keys_pp\n                 (fst (rep_nat_term (of_exps a b i))) \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a b i))) ia = 0", "thus \"lookup_pp (fst (rep_nat_term ?u)) x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> {0, 1} - keys_pp (fst (rep_nat_term (of_exps a b i)))\n\ngoal (1 subgoal):\n 1. lookup_pp (fst (rep_nat_term (of_exps a b i))) x = 0", "by (simp add: keys_pp_iff)"], ["proof (state)\nthis:\n  lookup_pp (fst (rep_nat_term (of_exps a b i))) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (lookup_pp (fst (rep_nat_term (of_exps a b i))))\n   (keys_pp (fst (rep_nat_term (of_exps a b i)))) =\n  sum (lookup_pp (fst (rep_nat_term (of_exps a b i)))) {0, 1}\n\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term (of_exps a b i))) = a + b", "also"], ["proof (state)\nthis:\n  sum (lookup_pp (fst (rep_nat_term (of_exps a b i))))\n   (keys_pp (fst (rep_nat_term (of_exps a b i)))) =\n  sum (lookup_pp (fst (rep_nat_term (of_exps a b i)))) {0, 1}\n\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term (of_exps a b i))) = a + b", "have \"... = a + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup_pp (fst (rep_nat_term (of_exps a b i)))) {0, 1} = a + b", "by (simp add: lookup_pp_of_exps)"], ["proof (state)\nthis:\n  sum (lookup_pp (fst (rep_nat_term (of_exps a b i)))) {0, 1} = a + b\n\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term (of_exps a b i))) = a + b", "finally"], ["proof (chain)\npicking this:\n  sum (lookup_pp (fst (rep_nat_term (of_exps a b i))))\n   (keys_pp (fst (rep_nat_term (of_exps a b i)))) =\n  a + b", "show ?thesis"], ["proof (prove)\nusing this:\n  sum (lookup_pp (fst (rep_nat_term (of_exps a b i))))\n   (keys_pp (fst (rep_nat_term (of_exps a b i)))) =\n  a + b\n\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term (of_exps a b i))) = a + b", "by (simp only: deg_pp_alt)"], ["proof (state)\nthis:\n  deg_pp (fst (rep_nat_term (of_exps a b i))) = a + b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snd_of_exps:\n  assumes \"snd (rep_nat_term (x::'a)) = i\"\n  shows \"snd (rep_nat_term ((of_exps a b i)::'a::nat_term_compare)) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rep_nat_term (of_exps a b i)) = i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (rep_nat_term (of_exps a b i)) = i", "from assms"], ["proof (chain)\npicking this:\n  snd (rep_nat_term x) = i", "have \"\\<exists>x::'a. snd (rep_nat_term (x::'a)) = i\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term x) = i\n\ngoal (1 subgoal):\n 1. \\<exists>x. snd (rep_nat_term x) = i", ".."], ["proof (state)\nthis:\n  \\<exists>x. snd (rep_nat_term x) = i\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term (of_exps a b i)) = i", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x. snd (rep_nat_term x) = i\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term (of_exps a b i)) = i", "by (simp add: rep_nat_term_of_exps)"], ["proof (state)\nthis:\n  snd (rep_nat_term (of_exps a b i)) = i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snd_of_exps_zero [simp]: \"snd (rep_nat_term ((of_exps a b 0)::'a::nat_term_compare)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rep_nat_term (of_exps a b 0)) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (rep_nat_term (of_exps a b 0)) = 0", "from zero_component"], ["proof (chain)\npicking this:\n  \\<exists>x. snd (rep_nat_term x) = 0", "obtain x::'a where \"snd (rep_nat_term (x::'a)) = 0\""], ["proof (prove)\nusing this:\n  \\<exists>x. snd (rep_nat_term x) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        snd (rep_nat_term x) = 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  snd (rep_nat_term x) = 0\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term (of_exps a b 0)) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  snd (rep_nat_term x) = 0\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term (of_exps a b 0)) = 0", "by (rule snd_of_exps)"], ["proof (state)\nthis:\n  snd (rep_nat_term (of_exps a b 0)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_of_exps:\n  \"(fst (rep_nat_term (of_exps a1 b1 i)) = fst (rep_nat_term (of_exps a2 b2 j))) \\<longleftrightarrow> (a1 = a2 \\<and> b1 = b2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (rep_nat_term (of_exps a1 b1 i)) =\n     fst (rep_nat_term (of_exps a2 b2 j))) =\n    (a1 = a2 \\<and> b1 = b2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fst (rep_nat_term (of_exps a1 b1 i)) =\n     fst (rep_nat_term (of_exps a2 b2 j))) =\n    (a1 = a2 \\<and> b1 = b2)", "have \"a1 = a2 \\<and> b1 = b2\"\n    if \"(\\<lambda>x::nat. if x = 0 then a1 else if x = 1 then b1 else 0) = (\\<lambda>x. if x = 0 then a2 else if x = 1 then b2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a1 = a2 \\<and> b1 = b2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a1 = a2\n 2. b1 = b2", "from fun_cong[OF that, of 0]"], ["proof (chain)\npicking this:\n  (if 0 = 0 then a1 else if 0 = 1 then b1 else 0) =\n  (if 0 = 0 then a2 else if 0 = 1 then b2 else 0)", "show \"a1 = a2\""], ["proof (prove)\nusing this:\n  (if 0 = 0 then a1 else if 0 = 1 then b1 else 0) =\n  (if 0 = 0 then a2 else if 0 = 1 then b2 else 0)\n\ngoal (1 subgoal):\n 1. a1 = a2", "by simp"], ["proof (state)\nthis:\n  a1 = a2\n\ngoal (1 subgoal):\n 1. b1 = b2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b1 = b2", "from fun_cong[OF that, of 1]"], ["proof (chain)\npicking this:\n  (if 1 = 0 then a1 else if 1 = 1 then b1 else 0) =\n  (if 1 = 0 then a2 else if 1 = 1 then b2 else 0)", "show \"b1 = b2\""], ["proof (prove)\nusing this:\n  (if 1 = 0 then a1 else if 1 = 1 then b1 else 0) =\n  (if 1 = 0 then a2 else if 1 = 1 then b2 else 0)\n\ngoal (1 subgoal):\n 1. b1 = b2", "by simp"], ["proof (state)\nthis:\n  b1 = b2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. if x = 0 then a1 else if x = 1 then b1 else 0) =\n  (\\<lambda>x.\n      if x = 0 then a2 else if x = 1 then b2 else 0) \\<Longrightarrow>\n  a1 = a2 \\<and> b1 = b2\n\ngoal (1 subgoal):\n 1. (fst (rep_nat_term (of_exps a1 b1 i)) =\n     fst (rep_nat_term (of_exps a2 b2 j))) =\n    (a1 = a2 \\<and> b1 = b2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. if x = 0 then a1 else if x = 1 then b1 else 0) =\n  (\\<lambda>x.\n      if x = 0 then a2 else if x = 1 then b2 else 0) \\<Longrightarrow>\n  a1 = a2 \\<and> b1 = b2\n\ngoal (1 subgoal):\n 1. (fst (rep_nat_term (of_exps a1 b1 i)) =\n     fst (rep_nat_term (of_exps a2 b2 j))) =\n    (a1 = a2 \\<and> b1 = b2)", "by (auto simp: pp_eq_iff lookup_pp_of_exps)"], ["proof (state)\nthis:\n  (fst (rep_nat_term (of_exps a1 b1 i)) =\n   fst (rep_nat_term (of_exps a2 b2 j))) =\n  (a1 = a2 \\<and> b1 = b2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_pp_of_exps:\n  \"lex_pp (fst (rep_nat_term ((of_exps a1 b1 i)::'a))) (fst (rep_nat_term ((of_exps a2 b2 j)::'a::nat_term_compare))) \\<longleftrightarrow>\n    (a1 < a2 \\<or> (a1 = a2 \\<and> b1 \\<le> b2))\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j))) =\n    (a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j))) =\n    (a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2)", "let ?u = \"fst (rep_nat_term ((of_exps a1 b1 i)::'a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j))) =\n    (a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2)", "let ?v = \"fst (rep_nat_term ((of_exps a2 b2 j)::'a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j))) =\n    (a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j))) =\n    (a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j))) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n 2. a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "assume ?L"], ["proof (state)\nthis:\n  lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n   (fst (rep_nat_term (of_exps a2 b2 j)))\n\ngoal (2 subgoals):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j))) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n 2. a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "hence \"?u = ?v \\<or> (\\<exists>x. lookup_pp ?u x < lookup_pp ?v x \\<and> (\\<forall>y<x. lookup_pp ?u y = lookup_pp ?v y))\""], ["proof (prove)\nusing this:\n  lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n   (fst (rep_nat_term (of_exps a2 b2 j)))\n\ngoal (1 subgoal):\n 1. fst (rep_nat_term (of_exps a1 b1 i)) =\n    fst (rep_nat_term (of_exps a2 b2 j)) \\<or>\n    (\\<exists>x.\n        lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n        < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n        (\\<forall>y<x.\n            lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n            lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y))", "by (simp only: lex_pp_alt)"], ["proof (state)\nthis:\n  fst (rep_nat_term (of_exps a1 b1 i)) =\n  fst (rep_nat_term (of_exps a2 b2 j)) \\<or>\n  (\\<exists>x.\n      lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n      < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n      (\\<forall>y<x.\n          lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n          lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y))\n\ngoal (2 subgoals):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j))) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n 2. a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "thus ?R"], ["proof (prove)\nusing this:\n  fst (rep_nat_term (of_exps a1 b1 i)) =\n  fst (rep_nat_term (of_exps a2 b2 j)) \\<or>\n  (\\<exists>x.\n      lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n      < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n      (\\<forall>y<x.\n          lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n          lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y))\n\ngoal (1 subgoal):\n 1. a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (rep_nat_term (of_exps a1 b1 i)) =\n    fst (rep_nat_term (of_exps a2 b2 j)) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n 2. \\<exists>x.\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n       < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n           lookup_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n            y) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "assume \"?u = ?v\""], ["proof (state)\nthis:\n  fst (rep_nat_term (of_exps a1 b1 i)) =\n  fst (rep_nat_term (of_exps a2 b2 j))\n\ngoal (2 subgoals):\n 1. fst (rep_nat_term (of_exps a1 b1 i)) =\n    fst (rep_nat_term (of_exps a2 b2 j)) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n 2. \\<exists>x.\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n       < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n           lookup_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n            y) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst (rep_nat_term (of_exps a1 b1 i)) =\n  fst (rep_nat_term (of_exps a2 b2 j))\n\ngoal (1 subgoal):\n 1. a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "by (simp add: eq_of_exps)"], ["proof (state)\nthis:\n  a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n       < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n           lookup_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n            y) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n       < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n           lookup_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n            y) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "assume \"\\<exists>x. lookup_pp ?u x < lookup_pp ?v x \\<and> (\\<forall>y<x. lookup_pp ?u y = lookup_pp ?v y)\""], ["proof (state)\nthis:\n  \\<exists>x.\n     lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n     < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n     (\\<forall>y<x.\n         lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n         lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n       < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n           lookup_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n            y) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n     < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n     (\\<forall>y<x.\n         lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n         lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y)", "obtain x where 1: \"lookup_pp ?u x < lookup_pp ?v x\" and 2: \"\\<And>y. y < x \\<Longrightarrow> lookup_pp ?u y = lookup_pp ?v y\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n     < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n     (\\<forall>y<x.\n         lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n         lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n                 < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x;\n         \\<And>y.\n            y < x \\<Longrightarrow>\n            lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n            lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n  < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x\n  ?y < x \\<Longrightarrow>\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) ?y =\n  lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) ?y\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n       < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n           lookup_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n            y) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "from 1"], ["proof (chain)\npicking this:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n  < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x", "have \"lookup_pp ?v x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n  < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x\n\ngoal (1 subgoal):\n 1. lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n       < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n           lookup_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n            y) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "hence \"x \\<in> keys_pp ?v\""], ["proof (prove)\nusing this:\n  lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> keys_pp (fst (rep_nat_term (of_exps a2 b2 j)))", "by (simp add: keys_pp_iff)"], ["proof (state)\nthis:\n  x \\<in> keys_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n       < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n           lookup_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n            y) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "also"], ["proof (state)\nthis:\n  x \\<in> keys_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n       < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n           lookup_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n            y) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "have \"... \\<subseteq> {0, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys_pp (fst (rep_nat_term (of_exps a2 b2 j))) \\<subseteq> {0, 1}", "by (fact keys_pp_of_exps)"], ["proof (state)\nthis:\n  keys_pp (fst (rep_nat_term (of_exps a2 b2 j))) \\<subseteq> {0, 1}\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n       < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n           lookup_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n            y) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "finally"], ["proof (chain)\npicking this:\n  x \\<in> {0, 1}", "have \"x = 0 \\<or> x = 1\""], ["proof (prove)\nusing this:\n  x \\<in> {0, 1}\n\ngoal (1 subgoal):\n 1. x = 0 \\<or> x = 1", "by simp"], ["proof (state)\nthis:\n  x = 0 \\<or> x = 1\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n       < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n       (\\<forall>y<x.\n           lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n           lookup_pp (fst (rep_nat_term (of_exps a2 b2 j)))\n            y) \\<Longrightarrow>\n    a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0 \\<or> x = 1\n\ngoal (1 subgoal):\n 1. a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n 2. x = 1 \\<Longrightarrow> a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n 2. x = 1 \\<Longrightarrow> a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "from 1"], ["proof (chain)\npicking this:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n  < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n  < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x\n\ngoal (1 subgoal):\n 1. a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "by (simp add: lookup_pp_of_exps \\<open>x = 0\\<close>)"], ["proof (state)\nthis:\n  a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n\ngoal (1 subgoal):\n 1. x = 1 \\<Longrightarrow> a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = 1 \\<Longrightarrow> a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "assume \"x = 1\""], ["proof (state)\nthis:\n  x = 1\n\ngoal (1 subgoal):\n 1. x = 1 \\<Longrightarrow> a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "hence \"0 < x\""], ["proof (prove)\nusing this:\n  x = 1\n\ngoal (1 subgoal):\n 1. 0 < x", "by simp"], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. x = 1 \\<Longrightarrow> a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "hence \"lookup_pp ?u 0 = lookup_pp ?v 0\""], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) 0 =\n    lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) 0", "by (rule 2)"], ["proof (state)\nthis:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) 0 =\n  lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) 0\n\ngoal (1 subgoal):\n 1. x = 1 \\<Longrightarrow> a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "hence \"a1 = a2\""], ["proof (prove)\nusing this:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) 0 =\n  lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) 0\n\ngoal (1 subgoal):\n 1. a1 = a2", "by (simp add: lookup_pp_of_exps)"], ["proof (state)\nthis:\n  a1 = a2\n\ngoal (1 subgoal):\n 1. x = 1 \\<Longrightarrow> a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "from 1"], ["proof (chain)\npicking this:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n  < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n  < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x\n\ngoal (1 subgoal):\n 1. a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2", "by (simp add: lookup_pp_of_exps \\<open>x = 1\\<close> \\<open>a1 = a2\\<close>)"], ["proof (state)\nthis:\n  a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n\ngoal (1 subgoal):\n 1. a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "assume ?R"], ["proof (state)\nthis:\n  a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n\ngoal (1 subgoal):\n 1. a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "thus ?L"], ["proof (prove)\nusing this:\n  a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2\n\ngoal (1 subgoal):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a1 < a2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))\n 2. a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "assume \"a1 < a2\""], ["proof (state)\nthis:\n  a1 < a2\n\ngoal (2 subgoals):\n 1. a1 < a2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))\n 2. a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "unfolding lex_pp_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (rep_nat_term (of_exps a1 b1 i)) =\n    fst (rep_nat_term (of_exps a2 b2 j)) \\<or>\n    (\\<exists>x.\n        lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n        < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n        (\\<forall>y<x.\n            lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n            lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y))", "proof (intro disjI2 exI conjI allI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) ?x1\n    < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) ?x1\n 2. \\<And>y.\n       y < ?x1 \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n       lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "from \\<open>a1 < a2\\<close>"], ["proof (chain)\npicking this:\n  a1 < a2", "show \"lookup_pp ?u 0 < lookup_pp ?v 0\""], ["proof (prove)\nusing this:\n  a1 < a2\n\ngoal (1 subgoal):\n 1. lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) 0\n    < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) 0", "by (simp add: lookup_pp_of_exps)"], ["proof (state)\nthis:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) 0\n  < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) 0\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < 0 \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n       lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < 0 \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n       lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "fix y::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < 0 \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n       lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "assume \"y < 0\""], ["proof (state)\nthis:\n  y < 0\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < 0 \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n       lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "thus \"lookup_pp ?u y = lookup_pp ?v y\""], ["proof (prove)\nusing this:\n  y < 0\n\ngoal (1 subgoal):\n 1. lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n    lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "by simp"], ["proof (state)\nthis:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n  lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n   (fst (rep_nat_term (of_exps a2 b2 j)))\n\ngoal (1 subgoal):\n 1. a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "assume \"a1 = a2 \\<and> b1 \\<le> b2\""], ["proof (state)\nthis:\n  a1 = a2 \\<and> b1 \\<le> b2\n\ngoal (1 subgoal):\n 1. a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "hence \"a1 = a2\" and \"b1 \\<le> b2\""], ["proof (prove)\nusing this:\n  a1 = a2 \\<and> b1 \\<le> b2\n\ngoal (1 subgoal):\n 1. a1 = a2 &&& b1 \\<le> b2", "by simp_all"], ["proof (state)\nthis:\n  a1 = a2\n  b1 \\<le> b2\n\ngoal (1 subgoal):\n 1. a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "from this(2)"], ["proof (chain)\npicking this:\n  b1 \\<le> b2", "have \"b1 < b2 \\<or> b1 = b2\""], ["proof (prove)\nusing this:\n  b1 \\<le> b2\n\ngoal (1 subgoal):\n 1. b1 < b2 \\<or> b1 = b2", "by auto"], ["proof (state)\nthis:\n  b1 < b2 \\<or> b1 = b2\n\ngoal (1 subgoal):\n 1. a1 = a2 \\<and> b1 \\<le> b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  b1 < b2 \\<or> b1 = b2\n\ngoal (1 subgoal):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b1 < b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))\n 2. b1 = b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "assume \"b1 < b2\""], ["proof (state)\nthis:\n  b1 < b2\n\ngoal (2 subgoals):\n 1. b1 < b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))\n 2. b1 = b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "unfolding lex_pp_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (rep_nat_term (of_exps a1 b1 i)) =\n    fst (rep_nat_term (of_exps a2 b2 j)) \\<or>\n    (\\<exists>x.\n        lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) x\n        < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) x \\<and>\n        (\\<forall>y<x.\n            lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n            lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y))", "proof (intro disjI2 exI conjI allI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) ?x1\n    < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) ?x1\n 2. \\<And>y.\n       y < ?x1 \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n       lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "from \\<open>b1 < b2\\<close>"], ["proof (chain)\npicking this:\n  b1 < b2", "show \"lookup_pp ?u 1 < lookup_pp ?v 1\""], ["proof (prove)\nusing this:\n  b1 < b2\n\ngoal (1 subgoal):\n 1. lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) 1\n    < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) 1", "by (simp add: lookup_pp_of_exps)"], ["proof (state)\nthis:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) 1\n  < lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) 1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < 1 \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n       lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < 1 \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n       lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "fix y::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < 1 \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n       lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "assume \"y < 1\""], ["proof (state)\nthis:\n  y < 1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < 1 \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n       lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "hence \"y = 0\""], ["proof (prove)\nusing this:\n  y < 1\n\ngoal (1 subgoal):\n 1. y = 0", "by simp"], ["proof (state)\nthis:\n  y = 0\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < 1 \\<Longrightarrow>\n       lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n       lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "show \"lookup_pp ?u y = lookup_pp ?v y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n    lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y", "by (simp add: lookup_pp_of_exps \\<open>y = 0\\<close> \\<open>a1 = a2\\<close>)"], ["proof (state)\nthis:\n  lookup_pp (fst (rep_nat_term (of_exps a1 b1 i))) y =\n  lookup_pp (fst (rep_nat_term (of_exps a2 b2 j))) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n   (fst (rep_nat_term (of_exps a2 b2 j)))\n\ngoal (1 subgoal):\n 1. b1 = b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b1 = b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "assume \"b1 = b2\""], ["proof (state)\nthis:\n  b1 = b2\n\ngoal (1 subgoal):\n 1. b1 = b2 \\<Longrightarrow>\n    lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n     (fst (rep_nat_term (of_exps a2 b2 j)))", "by (simp add: lex_pp_alt eq_of_exps \\<open>a1 = a2\\<close> \\<open>b1 = b2\\<close>)"], ["proof (state)\nthis:\n  lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n   (fst (rep_nat_term (of_exps a2 b2 j)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n   (fst (rep_nat_term (of_exps a2 b2 j)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n   (fst (rep_nat_term (of_exps a2 b2 j)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_pp (fst (rep_nat_term (of_exps a1 b1 i)))\n   (fst (rep_nat_term (of_exps a2 b2 j))) =\n  (a1 < a2 \\<or> a1 = a2 \\<and> b1 \\<le> b2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LEX_eq [code]:\n  \"nat_term_order_eq LEX (LEX::'a nat_term_order) dg ps = True\" (is ?thesis1)\n  \"nat_term_order_eq LEX (DRLEX::'a nat_term_order) dg ps = False\" (is ?thesis2)\n  \"nat_term_order_eq LEX (DEG (to::'a nat_term_order)) dg ps =\n    (dg \\<and> nat_term_order_eq LEX to dg ps)\" (is ?thesis3)\n  \"nat_term_order_eq LEX (POT (to::'a nat_term_order)) dg ps =\n    ((ps \\<or> is_scalar TYPE('a::nat_term_compare)) \\<and> nat_term_order_eq LEX to dg ps)\" (is ?thesis4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat_term_order_eq Term_Order.LEX Term_Order.LEX dg ps = True &&&\n     nat_term_order_eq Term_Order.LEX DRLEX dg ps = False) &&&\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps =\n    (dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps) &&&\n    nat_term_order_eq Term_Order.LEX (POT to) dg ps =\n    ((ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq Term_Order.LEX to dg ps)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. nat_term_order_eq Term_Order.LEX Term_Order.LEX dg ps = True\n 2. nat_term_order_eq Term_Order.LEX DRLEX dg ps = False\n 3. nat_term_order_eq Term_Order.LEX (DEG to) dg ps =\n    (dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps)\n 4. nat_term_order_eq Term_Order.LEX (POT to) dg ps =\n    ((ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq Term_Order.LEX to dg ps)", "show ?thesis1"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq Term_Order.LEX Term_Order.LEX dg ps = True", "by (simp add: nat_term_order_eq_def)"], ["proof (state)\nthis:\n  nat_term_order_eq Term_Order.LEX Term_Order.LEX dg ps = True\n\ngoal (3 subgoals):\n 1. nat_term_order_eq Term_Order.LEX DRLEX dg ps = False\n 2. nat_term_order_eq Term_Order.LEX (DEG to) dg ps =\n    (dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps)\n 3. nat_term_order_eq Term_Order.LEX (POT to) dg ps =\n    ((ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq Term_Order.LEX to dg ps)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. nat_term_order_eq Term_Order.LEX DRLEX dg ps = False\n 2. nat_term_order_eq Term_Order.LEX (DEG to) dg ps =\n    (dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps)\n 3. nat_term_order_eq Term_Order.LEX (POT to) dg ps =\n    ((ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq Term_Order.LEX to dg ps)", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq Term_Order.LEX DRLEX dg ps = False", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX DRLEX dg ps \\<Longrightarrow> False\n 2. False \\<Longrightarrow> nat_term_order_eq Term_Order.LEX DRLEX dg ps", "assume a: \"nat_term_order_eq LEX (DRLEX::'a nat_term_order) dg ps\""], ["proof (state)\nthis:\n  nat_term_order_eq Term_Order.LEX DRLEX dg ps\n\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX DRLEX dg ps \\<Longrightarrow> False\n 2. False \\<Longrightarrow> nat_term_order_eq Term_Order.LEX DRLEX dg ps", "let ?u = \"(of_exps 0 1 0)::'a\""], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX DRLEX dg ps \\<Longrightarrow> False\n 2. False \\<Longrightarrow> nat_term_order_eq Term_Order.LEX DRLEX dg ps", "let ?v = \"(of_exps 1 0 0)::'a\""], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX DRLEX dg ps \\<Longrightarrow> False\n 2. False \\<Longrightarrow> nat_term_order_eq Term_Order.LEX DRLEX dg ps", "have \"nat_term_compare LEX ?u ?v = nat_term_compare DRLEX ?u ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX (of_exps 0 1 0) (of_exps 1 0 0) =\n    nat_term_compare DRLEX (of_exps 0 1 0) (of_exps 1 0 0)", "by (rule nat_term_order_eqD, fact a, simp_all)"], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX (of_exps 0 1 0) (of_exps 1 0 0) =\n  nat_term_compare DRLEX (of_exps 0 1 0) (of_exps 1 0 0)\n\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX DRLEX dg ps \\<Longrightarrow> False\n 2. False \\<Longrightarrow> nat_term_order_eq Term_Order.LEX DRLEX dg ps", "thus False"], ["proof (prove)\nusing this:\n  nat_term_compare Term_Order.LEX (of_exps 0 1 0) (of_exps 1 0 0) =\n  nat_term_compare DRLEX (of_exps 0 1 0) (of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: nat_term_compare_LEX lex_comp lex_comp_aux_def nat_term_compare_DRLEX deg_comp\n          pot_comp comparator_of_def comp_of_ord_def lex_pp_of_exps eq_of_exps)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. False \\<Longrightarrow> nat_term_order_eq Term_Order.LEX DRLEX dg ps", "qed (rule FalseE)"], ["proof (state)\nthis:\n  nat_term_order_eq Term_Order.LEX DRLEX dg ps = False\n\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX (DEG to) dg ps =\n    (dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps)\n 2. nat_term_order_eq Term_Order.LEX (POT to) dg ps =\n    ((ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq Term_Order.LEX to dg ps)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX (DEG to) dg ps =\n    (dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps)\n 2. nat_term_order_eq Term_Order.LEX (POT to) dg ps =\n    ((ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq Term_Order.LEX to dg ps)", "show ?thesis3"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq Term_Order.LEX (DEG to) dg ps =\n    (dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps)", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX (DEG to) dg ps \\<Longrightarrow>\n    dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps\n 2. dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps", "assume a: \"nat_term_order_eq LEX (DEG to) dg ps\""], ["proof (state)\nthis:\n  nat_term_order_eq Term_Order.LEX (DEG to) dg ps\n\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX (DEG to) dg ps \\<Longrightarrow>\n    dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps\n 2. dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps", "have dg"], ["proof (prove)\ngoal (1 subgoal):\n 1. dg", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dg \\<Longrightarrow> False", "assume \"\\<not> dg\""], ["proof (state)\nthis:\n  \\<not> dg\n\ngoal (1 subgoal):\n 1. \\<not> dg \\<Longrightarrow> False", "let ?u = \"(of_exps 0 2 0)::'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dg \\<Longrightarrow> False", "let ?v = \"(of_exps 1 0 0)::'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dg \\<Longrightarrow> False", "have \"nat_term_compare LEX ?u ?v = nat_term_compare (DEG to) ?u ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX (of_exps 0 2 0) (of_exps 1 0 0) =\n    nat_term_compare (DEG to) (of_exps 0 2 0) (of_exps 1 0 0)", "by (rule nat_term_order_eqD, fact a, simp_all add: \\<open>\\<not> dg\\<close>)"], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX (of_exps 0 2 0) (of_exps 1 0 0) =\n  nat_term_compare (DEG to) (of_exps 0 2 0) (of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. \\<not> dg \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  nat_term_compare Term_Order.LEX (of_exps 0 2 0) (of_exps 1 0 0) =\n  nat_term_compare (DEG to) (of_exps 0 2 0) (of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: nat_term_compare_LEX lex_comp lex_comp_aux_def nat_term_compare_DEG deg_comp\n            comparator_of_def comp_of_ord_def lex_pp_of_exps eq_of_exps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dg\n\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX (DEG to) dg ps \\<Longrightarrow>\n    dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps\n 2. dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps", "show \"dg \\<and> nat_term_order_eq LEX to dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps", "proof (intro conjI \\<open>dg\\<close> nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "assume 1: \"dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (state)\nthis:\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "from \\<open>dg\\<close>"], ["proof (chain)\npicking this:\n  dg", "have eq: \"deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (prove)\nusing this:\n  dg\n\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))", "by (rule 1)"], ["proof (state)\nthis:\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "assume \"ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "with a 1"], ["proof (chain)\npicking this:\n  nat_term_order_eq Term_Order.LEX (DEG to) dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)", "have \"nat_term_compare LEX u v = nat_term_compare (DEG to) u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq Term_Order.LEX (DEG to) dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX u v = nat_term_compare (DEG to) u v", "by (rule nat_term_order_eqD)"], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare (DEG to) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "also"], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare (DEG to) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "have \"... = nat_term_compare to u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (DEG to) u v = nat_term_compare to u v", "by (simp add: nat_term_compare_DEG deg_comp eq)"], ["proof (state)\nthis:\n  nat_term_compare (DEG to) u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "finally"], ["proof (chain)\npicking this:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare to u v", "show \"nat_term_compare LEX u v = nat_term_compare to u v\""], ["proof (prove)\nusing this:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX u v = nat_term_compare to u v", "."], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare to u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps\n\ngoal (1 subgoal):\n 1. dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps", "assume \"dg \\<and> nat_term_order_eq LEX to dg ps\""], ["proof (state)\nthis:\n  dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps\n\ngoal (1 subgoal):\n 1. dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps", "hence dg and a: \"nat_term_order_eq LEX to dg ps\""], ["proof (prove)\nusing this:\n  dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps\n\ngoal (1 subgoal):\n 1. dg &&& nat_term_order_eq Term_Order.LEX to dg ps", "by auto"], ["proof (state)\nthis:\n  dg\n  nat_term_order_eq Term_Order.LEX to dg ps\n\ngoal (1 subgoal):\n 1. dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps", "show \"nat_term_order_eq LEX (DEG to) dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq Term_Order.LEX (DEG to) dg ps", "proof (rule nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (DEG to) u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (DEG to) u v", "assume 1: \"dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (state)\nthis:\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (DEG to) u v", "from \\<open>dg\\<close>"], ["proof (chain)\npicking this:\n  dg", "have eq: \"deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (prove)\nusing this:\n  dg\n\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))", "by (rule 1)"], ["proof (state)\nthis:\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (DEG to) u v", "assume \"ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (DEG to) u v", "with a 1"], ["proof (chain)\npicking this:\n  nat_term_order_eq Term_Order.LEX to dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)", "have \"nat_term_compare LEX u v = nat_term_compare to u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq Term_Order.LEX to dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX u v = nat_term_compare to u v", "by (rule nat_term_order_eqD)"], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (DEG to) u v", "also"], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (DEG to) u v", "have \"... = nat_term_compare (DEG to) u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare to u v = nat_term_compare (DEG to) u v", "by (simp add: nat_term_compare_DEG deg_comp eq)"], ["proof (state)\nthis:\n  nat_term_compare to u v = nat_term_compare (DEG to) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (DEG to) u v", "finally"], ["proof (chain)\npicking this:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare (DEG to) u v", "show \"nat_term_compare LEX u v = nat_term_compare (DEG to) u v\""], ["proof (prove)\nusing this:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare (DEG to) u v\n\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX u v = nat_term_compare (DEG to) u v", "."], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare (DEG to) u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq Term_Order.LEX (DEG to) dg ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq Term_Order.LEX (DEG to) dg ps =\n  (dg \\<and> nat_term_order_eq Term_Order.LEX to dg ps)\n\ngoal (1 subgoal):\n 1. nat_term_order_eq Term_Order.LEX (POT to) dg ps =\n    ((ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq Term_Order.LEX to dg ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_term_order_eq Term_Order.LEX (POT to) dg ps =\n    ((ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq Term_Order.LEX to dg ps)", "show ?thesis4"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq Term_Order.LEX (POT to) dg ps =\n    ((ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq Term_Order.LEX to dg ps)", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX (POT to) dg ps \\<Longrightarrow>\n    (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq Term_Order.LEX to dg ps\n 2. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (POT to) dg ps", "assume a: \"nat_term_order_eq LEX (POT to) dg ps\""], ["proof (state)\nthis:\n  nat_term_order_eq Term_Order.LEX (POT to) dg ps\n\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX (POT to) dg ps \\<Longrightarrow>\n    (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq Term_Order.LEX to dg ps\n 2. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (POT to) dg ps", "have *: \"ps \\<or> is_scalar TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<or> is_scalar TYPE('a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "assume \"\\<not> (ps \\<or> is_scalar TYPE('a))\""], ["proof (state)\nthis:\n  \\<not> (ps \\<or> is_scalar TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "hence \"\\<not> ps\" and \"\\<not> is_scalar TYPE('a)\""], ["proof (prove)\nusing this:\n  \\<not> (ps \\<or> is_scalar TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<not> ps &&& \\<not> is_scalar TYPE('a)", "by simp_all"], ["proof (state)\nthis:\n  \\<not> ps\n  \\<not> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "from this(2)"], ["proof (chain)\npicking this:\n  \\<not> is_scalar TYPE('a)", "obtain x::'a where \"snd (rep_nat_term x) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        snd (rep_nat_term x) \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding is_scalar"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x. snd (rep_nat_term x) = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        snd (rep_nat_term x) \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd (rep_nat_term x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  snd (rep_nat_term x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "define i::nat where \"i = snd (rep_nat_term x)\""], ["proof (state)\nthis:\n  i = snd (rep_nat_term x)\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  snd (rep_nat_term x) \\<noteq> 0\n  i = snd (rep_nat_term x)", "have \"i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term x) \\<noteq> 0\n  i = snd (rep_nat_term x)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "let ?u = \"(of_exps 0 1 i)::'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "let ?v = \"(of_exps 1 0 0)::'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "from i_def[symmetric]"], ["proof (chain)\npicking this:\n  snd (rep_nat_term x) = i", "have eq: \"snd (rep_nat_term ?u) = i\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term x) = i\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term (of_exps 0 1 i)) = i", "by (rule snd_of_exps)"], ["proof (state)\nthis:\n  snd (rep_nat_term (of_exps 0 1 i)) = i\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "have \"nat_term_compare LEX ?u ?v = nat_term_compare (POT to) ?u ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX (of_exps 0 1 i) (of_exps 1 0 0) =\n    nat_term_compare (POT to) (of_exps 0 1 i) (of_exps 1 0 0)", "by (rule nat_term_order_eqD, fact a, simp_all add: \\<open>\\<not> ps\\<close>)"], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX (of_exps 0 1 i) (of_exps 1 0 0) =\n  nat_term_compare (POT to) (of_exps 0 1 i) (of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  nat_term_compare Term_Order.LEX (of_exps 0 1 i) (of_exps 1 0 0) =\n  nat_term_compare (POT to) (of_exps 0 1 i) (of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: nat_term_compare_LEX lex_comp lex_comp_aux_def pot_comp nat_term_compare_POT\n            comparator_of_def comp_of_ord_def lex_pp_of_exps eq_of_exps eq \\<open>i \\<noteq> 0\\<close> del: One_nat_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ps \\<or> is_scalar TYPE('a)\n\ngoal (2 subgoals):\n 1. nat_term_order_eq Term_Order.LEX (POT to) dg ps \\<Longrightarrow>\n    (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq Term_Order.LEX to dg ps\n 2. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (POT to) dg ps", "show \"(ps \\<or> is_scalar TYPE('a)) \\<and> nat_term_order_eq LEX to dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq Term_Order.LEX to dg ps", "proof (intro conjI * nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "assume 1: \"dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (state)\nthis:\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "assume 2: \"ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "with *"], ["proof (chain)\npicking this:\n  ps \\<or> is_scalar TYPE('a)\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)", "have eq: \"snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (prove)\nusing this:\n  ps \\<or> is_scalar TYPE('a)\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v)", "by (rule snd_rep_nat_term_eqI)"], ["proof (state)\nthis:\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "from a 1 2"], ["proof (chain)\npicking this:\n  nat_term_order_eq Term_Order.LEX (POT to) dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)", "have \"nat_term_compare LEX u v = nat_term_compare (POT to) u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq Term_Order.LEX (POT to) dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX u v = nat_term_compare (POT to) u v", "by (rule nat_term_order_eqD)"], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare (POT to) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "also"], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare (POT to) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "have \"... = nat_term_compare to u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (POT to) u v = nat_term_compare to u v", "by (simp add: nat_term_compare_POT eq pot_comp)"], ["proof (state)\nthis:\n  nat_term_compare (POT to) u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare to u v", "finally"], ["proof (chain)\npicking this:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare to u v", "show \"nat_term_compare LEX u v = nat_term_compare to u v\""], ["proof (prove)\nusing this:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX u v = nat_term_compare to u v", "."], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare to u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ps \\<or> is_scalar TYPE('a)) \\<and>\n  nat_term_order_eq Term_Order.LEX to dg ps\n\ngoal (1 subgoal):\n 1. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (POT to) dg ps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (POT to) dg ps", "assume \"(ps \\<or> is_scalar TYPE('a)) \\<and> nat_term_order_eq LEX to dg ps\""], ["proof (state)\nthis:\n  (ps \\<or> is_scalar TYPE('a)) \\<and>\n  nat_term_order_eq Term_Order.LEX to dg ps\n\ngoal (1 subgoal):\n 1. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (POT to) dg ps", "hence *: \"ps \\<or> is_scalar TYPE('a)\" and a: \"nat_term_order_eq LEX to dg ps\""], ["proof (prove)\nusing this:\n  (ps \\<or> is_scalar TYPE('a)) \\<and>\n  nat_term_order_eq Term_Order.LEX to dg ps\n\ngoal (1 subgoal):\n 1. ps \\<or> is_scalar TYPE('a) &&&\n    nat_term_order_eq Term_Order.LEX to dg ps", "by auto"], ["proof (state)\nthis:\n  ps \\<or> is_scalar TYPE('a)\n  nat_term_order_eq Term_Order.LEX to dg ps\n\ngoal (1 subgoal):\n 1. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq Term_Order.LEX to dg ps \\<Longrightarrow>\n    nat_term_order_eq Term_Order.LEX (POT to) dg ps", "show \"nat_term_order_eq LEX (POT to) dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq Term_Order.LEX (POT to) dg ps", "proof (rule nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (POT to) u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (POT to) u v", "assume 1: \"dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (state)\nthis:\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (POT to) u v", "assume 2: \"ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (POT to) u v", "with *"], ["proof (chain)\npicking this:\n  ps \\<or> is_scalar TYPE('a)\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)", "have eq: \"snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (prove)\nusing this:\n  ps \\<or> is_scalar TYPE('a)\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v)", "by (rule snd_rep_nat_term_eqI)"], ["proof (state)\nthis:\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (POT to) u v", "from a 1 2"], ["proof (chain)\npicking this:\n  nat_term_order_eq Term_Order.LEX to dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)", "have \"nat_term_compare LEX u v = nat_term_compare to u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq Term_Order.LEX to dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX u v = nat_term_compare to u v", "by (rule nat_term_order_eqD)"], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (POT to) u v", "also"], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (POT to) u v", "have \"... = nat_term_compare (POT to) u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare to u v = nat_term_compare (POT to) u v", "by (simp add: nat_term_compare_POT eq pot_comp)"], ["proof (state)\nthis:\n  nat_term_compare to u v = nat_term_compare (POT to) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare Term_Order.LEX u v =\n                         nat_term_compare (POT to) u v", "finally"], ["proof (chain)\npicking this:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare (POT to) u v", "show \"nat_term_compare LEX u v = nat_term_compare (POT to) u v\""], ["proof (prove)\nusing this:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare (POT to) u v\n\ngoal (1 subgoal):\n 1. nat_term_compare Term_Order.LEX u v = nat_term_compare (POT to) u v", "."], ["proof (state)\nthis:\n  nat_term_compare Term_Order.LEX u v = nat_term_compare (POT to) u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq Term_Order.LEX (POT to) dg ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq Term_Order.LEX (POT to) dg ps =\n  ((ps \\<or> is_scalar TYPE('a)) \\<and>\n   nat_term_order_eq Term_Order.LEX to dg ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DRLEX_eq [code]:\n  \"nat_term_order_eq DRLEX (LEX::'a nat_term_order) dg ps = False\" (is ?thesis1)\n  \"nat_term_order_eq DRLEX DRLEX dg ps = True\" (is ?thesis2)\n  \"nat_term_order_eq DRLEX (DEG (to::'a nat_term_order)) dg ps =\n    nat_term_order_eq DRLEX to True ps\" (is ?thesis3)\n  \"nat_term_order_eq DRLEX (POT (to::'a nat_term_order)) dg ps =\n    ((dg \\<or> ps \\<or> is_scalar TYPE('a::nat_term_compare)) \\<and> nat_term_order_eq DRLEX to dg True)\" (is ?thesis4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat_term_order_eq DRLEX Term_Order.LEX dg ps = False &&&\n     nat_term_order_eq DRLEX DRLEX dg ps = True) &&&\n    nat_term_order_eq DRLEX (DEG to) dg ps =\n    nat_term_order_eq DRLEX to True ps &&&\n    nat_term_order_eq DRLEX (POT to) dg ps =\n    ((dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq DRLEX to dg True)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. nat_term_order_eq DRLEX Term_Order.LEX dg ps = False\n 2. nat_term_order_eq DRLEX DRLEX dg ps = True\n 3. nat_term_order_eq DRLEX (DEG to) dg ps =\n    nat_term_order_eq DRLEX to True ps\n 4. nat_term_order_eq DRLEX (POT to) dg ps =\n    ((dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq DRLEX to dg True)", "from nat_term_order_eq_sym[of \"DRLEX::'a nat_term_order\"]"], ["proof (chain)\npicking this:\n  nat_term_order_eq DRLEX ?to2.0 ?dg ?ps =\n  nat_term_order_eq ?to2.0 DRLEX ?dg ?ps", "show ?thesis1"], ["proof (prove)\nusing this:\n  nat_term_order_eq DRLEX ?to2.0 ?dg ?ps =\n  nat_term_order_eq ?to2.0 DRLEX ?dg ?ps\n\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX Term_Order.LEX dg ps = False", "by (simp only: LEX_eq)"], ["proof (state)\nthis:\n  nat_term_order_eq DRLEX Term_Order.LEX dg ps = False\n\ngoal (3 subgoals):\n 1. nat_term_order_eq DRLEX DRLEX dg ps = True\n 2. nat_term_order_eq DRLEX (DEG to) dg ps =\n    nat_term_order_eq DRLEX to True ps\n 3. nat_term_order_eq DRLEX (POT to) dg ps =\n    ((dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq DRLEX to dg True)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. nat_term_order_eq DRLEX DRLEX dg ps = True\n 2. nat_term_order_eq DRLEX (DEG to) dg ps =\n    nat_term_order_eq DRLEX to True ps\n 3. nat_term_order_eq DRLEX (POT to) dg ps =\n    ((dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq DRLEX to dg True)", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX DRLEX dg ps = True", "by (simp add: nat_term_order_eq_def)"], ["proof (state)\nthis:\n  nat_term_order_eq DRLEX DRLEX dg ps = True\n\ngoal (2 subgoals):\n 1. nat_term_order_eq DRLEX (DEG to) dg ps =\n    nat_term_order_eq DRLEX to True ps\n 2. nat_term_order_eq DRLEX (POT to) dg ps =\n    ((dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq DRLEX to dg True)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq DRLEX (DEG to) dg ps =\n    nat_term_order_eq DRLEX to True ps\n 2. nat_term_order_eq DRLEX (POT to) dg ps =\n    ((dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq DRLEX to dg True)", "show ?thesis3"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX (DEG to) dg ps =\n    nat_term_order_eq DRLEX to True ps", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq DRLEX (DEG to) dg ps \\<Longrightarrow>\n    nat_term_order_eq DRLEX to True ps\n 2. nat_term_order_eq DRLEX to True ps \\<Longrightarrow>\n    nat_term_order_eq DRLEX (DEG to) dg ps", "assume a: \"nat_term_order_eq DRLEX (DEG to) dg ps\""], ["proof (state)\nthis:\n  nat_term_order_eq DRLEX (DEG to) dg ps\n\ngoal (2 subgoals):\n 1. nat_term_order_eq DRLEX (DEG to) dg ps \\<Longrightarrow>\n    nat_term_order_eq DRLEX to True ps\n 2. nat_term_order_eq DRLEX to True ps \\<Longrightarrow>\n    nat_term_order_eq DRLEX (DEG to) dg ps", "show \"nat_term_order_eq DRLEX to True ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX to True ps", "proof (rule nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>True \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>True \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "assume 1: \"True \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\"\n        and \"ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  True \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>True \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "with a"], ["proof (chain)\npicking this:\n  nat_term_order_eq DRLEX (DEG to) dg ps\n  True \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)", "have \"nat_term_compare DRLEX u v = nat_term_compare (DEG to) u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq DRLEX (DEG to) dg ps\n  True \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare (DEG to) u v", "by (rule nat_term_order_eqD, blast+)"], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare (DEG to) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>True \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "also"], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare (DEG to) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>True \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "have \"... = nat_term_compare to u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (DEG to) u v = nat_term_compare to u v", "by (simp add: nat_term_compare_DEG deg_comp 1)"], ["proof (state)\nthis:\n  nat_term_compare (DEG to) u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>True \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "finally"], ["proof (chain)\npicking this:\n  nat_term_compare DRLEX u v = nat_term_compare to u v", "show \"nat_term_compare DRLEX u v = nat_term_compare to u v\""], ["proof (prove)\nusing this:\n  nat_term_compare DRLEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare to u v", "."], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare to u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq DRLEX to True ps\n\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX to True ps \\<Longrightarrow>\n    nat_term_order_eq DRLEX (DEG to) dg ps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX to True ps \\<Longrightarrow>\n    nat_term_order_eq DRLEX (DEG to) dg ps", "assume a: \"nat_term_order_eq DRLEX to True ps\""], ["proof (state)\nthis:\n  nat_term_order_eq DRLEX to True ps\n\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX to True ps \\<Longrightarrow>\n    nat_term_order_eq DRLEX (DEG to) dg ps", "show \"nat_term_order_eq DRLEX (DEG to) dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX (DEG to) dg ps", "proof (rule nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare (DEG to) u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare (DEG to) u v", "assume 1: \"ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare (DEG to) u v", "show \"nat_term_compare DRLEX u v = nat_term_compare (DEG to) u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare (DEG to) u v", "proof (simp add: nat_term_compare_DRLEX nat_term_compare_DEG deg_comp comparator_of_def split: order.split, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term u)) =\n    deg_pp (fst (rep_nat_term v)) \\<Longrightarrow>\n    pot_comp (\\<lambda>x y. lex_comp y x) u v = nat_term_compare to u v", "assume 2: \"deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (state)\nthis:\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term u)) =\n    deg_pp (fst (rep_nat_term v)) \\<Longrightarrow>\n    pot_comp (\\<lambda>x y. lex_comp y x) u v = nat_term_compare to u v", "with a"], ["proof (chain)\npicking this:\n  nat_term_order_eq DRLEX to True ps\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))", "have \"nat_term_compare DRLEX u v = nat_term_compare to u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq DRLEX to True ps\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare to u v", "using 1"], ["proof (prove)\nusing this:\n  nat_term_order_eq DRLEX to True ps\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare to u v", "by (rule nat_term_order_eqD)"], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term u)) =\n    deg_pp (fst (rep_nat_term v)) \\<Longrightarrow>\n    pot_comp (\\<lambda>x y. lex_comp y x) u v = nat_term_compare to u v", "thus \"pot_comp (\\<lambda>x y. lex_comp y x) u v = nat_term_compare to u v\""], ["proof (prove)\nusing this:\n  nat_term_compare DRLEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. pot_comp (\\<lambda>x y. lex_comp y x) u v = nat_term_compare to u v", "by (simp add: nat_term_compare_DRLEX deg_comp 2)"], ["proof (state)\nthis:\n  pot_comp (\\<lambda>x y. lex_comp y x) u v = nat_term_compare to u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare (DEG to) u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq DRLEX (DEG to) dg ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq DRLEX (DEG to) dg ps =\n  nat_term_order_eq DRLEX to True ps\n\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX (POT to) dg ps =\n    ((dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq DRLEX to dg True)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX (POT to) dg ps =\n    ((dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq DRLEX to dg True)", "show ?thesis4"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX (POT to) dg ps =\n    ((dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq DRLEX to dg True)", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq DRLEX (POT to) dg ps \\<Longrightarrow>\n    (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq DRLEX to dg True\n 2. (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq DRLEX to dg True \\<Longrightarrow>\n    nat_term_order_eq DRLEX (POT to) dg ps", "assume a: \"nat_term_order_eq DRLEX (POT to) dg ps\""], ["proof (state)\nthis:\n  nat_term_order_eq DRLEX (POT to) dg ps\n\ngoal (2 subgoals):\n 1. nat_term_order_eq DRLEX (POT to) dg ps \\<Longrightarrow>\n    (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq DRLEX to dg True\n 2. (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq DRLEX to dg True \\<Longrightarrow>\n    nat_term_order_eq DRLEX (POT to) dg ps", "have *: \"dg \\<or> ps \\<or> is_scalar TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dg \\<or> ps \\<or> is_scalar TYPE('a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "assume \"\\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a))\""], ["proof (state)\nthis:\n  \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "hence \"\\<not> dg\" and \"\\<not> ps\" and \"\\<not> is_scalar TYPE('a)\""], ["proof (prove)\nusing this:\n  \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<not> dg &&& \\<not> ps &&& \\<not> is_scalar TYPE('a)", "by simp_all"], ["proof (state)\nthis:\n  \\<not> dg\n  \\<not> ps\n  \\<not> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "from this(3)"], ["proof (chain)\npicking this:\n  \\<not> is_scalar TYPE('a)", "obtain x::'a where \"snd (rep_nat_term x) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        snd (rep_nat_term x) \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding is_scalar"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x. snd (rep_nat_term x) = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        snd (rep_nat_term x) \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd (rep_nat_term x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  snd (rep_nat_term x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "define i::nat where \"i = snd (rep_nat_term x)\""], ["proof (state)\nthis:\n  i = snd (rep_nat_term x)\n\ngoal (1 subgoal):\n 1. \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  snd (rep_nat_term x) \\<noteq> 0\n  i = snd (rep_nat_term x)", "have \"i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term x) \\<noteq> 0\n  i = snd (rep_nat_term x)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "let ?u = \"(of_exps 1 0 i)::'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "let ?v = \"(of_exps 2 0 0)::'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "from i_def[symmetric]"], ["proof (chain)\npicking this:\n  snd (rep_nat_term x) = i", "have eq: \"snd (rep_nat_term ?u) = i\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term x) = i\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term (of_exps 1 0 i)) = i", "by (rule snd_of_exps)"], ["proof (state)\nthis:\n  snd (rep_nat_term (of_exps 1 0 i)) = i\n\ngoal (1 subgoal):\n 1. \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "have \"nat_term_compare DRLEX ?u ?v = nat_term_compare (POT to) ?u ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX (of_exps 1 0 i) (of_exps 2 0 0) =\n    nat_term_compare (POT to) (of_exps 1 0 i) (of_exps 2 0 0)", "by (rule nat_term_order_eqD, fact a, simp_all add: \\<open>\\<not> ps\\<close> \\<open>\\<not> dg\\<close>)"], ["proof (state)\nthis:\n  nat_term_compare DRLEX (of_exps 1 0 i) (of_exps 2 0 0) =\n  nat_term_compare (POT to) (of_exps 1 0 i) (of_exps 2 0 0)\n\ngoal (1 subgoal):\n 1. \\<not> (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  nat_term_compare DRLEX (of_exps 1 0 i) (of_exps 2 0 0) =\n  nat_term_compare (POT to) (of_exps 1 0 i) (of_exps 2 0 0)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: nat_term_compare_DRLEX deg_comp pot_comp nat_term_compare_POT\n            comparator_of_def eq \\<open>i \\<noteq> 0\\<close> del: One_nat_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dg \\<or> ps \\<or> is_scalar TYPE('a)\n\ngoal (2 subgoals):\n 1. nat_term_order_eq DRLEX (POT to) dg ps \\<Longrightarrow>\n    (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq DRLEX to dg True\n 2. (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq DRLEX to dg True \\<Longrightarrow>\n    nat_term_order_eq DRLEX (POT to) dg ps", "show \"(dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and> nat_term_order_eq DRLEX to dg True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq DRLEX to dg True", "proof (intro conjI * nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        True \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        True \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "assume 1: \"dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (state)\nthis:\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        True \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "assume 2: \"True \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  True \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        True \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "from a 1 2"], ["proof (chain)\npicking this:\n  nat_term_order_eq DRLEX (POT to) dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  True \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)", "have \"nat_term_compare DRLEX u v = nat_term_compare (POT to) u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq DRLEX (POT to) dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  True \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "by (rule nat_term_order_eqD, blast+)"], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare (POT to) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        True \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "also"], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare (POT to) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        True \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "have \"... = nat_term_compare to u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (POT to) u v = nat_term_compare to u v", "by (simp add: nat_term_compare_POT 2 pot_comp)"], ["proof (state)\nthis:\n  nat_term_compare (POT to) u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        True \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare to u v", "finally"], ["proof (chain)\npicking this:\n  nat_term_compare DRLEX u v = nat_term_compare to u v", "show \"nat_term_compare DRLEX u v = nat_term_compare to u v\""], ["proof (prove)\nusing this:\n  nat_term_compare DRLEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare to u v", "."], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare to u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n  nat_term_order_eq DRLEX to dg True\n\ngoal (1 subgoal):\n 1. (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq DRLEX to dg True \\<Longrightarrow>\n    nat_term_order_eq DRLEX (POT to) dg ps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq DRLEX to dg True \\<Longrightarrow>\n    nat_term_order_eq DRLEX (POT to) dg ps", "assume \"(dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and> nat_term_order_eq DRLEX to dg True\""], ["proof (state)\nthis:\n  (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n  nat_term_order_eq DRLEX to dg True\n\ngoal (1 subgoal):\n 1. (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq DRLEX to dg True \\<Longrightarrow>\n    nat_term_order_eq DRLEX (POT to) dg ps", "hence disj: \"dg \\<or> ps \\<or> is_scalar TYPE('a)\" and a: \"nat_term_order_eq DRLEX to dg True\""], ["proof (prove)\nusing this:\n  (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n  nat_term_order_eq DRLEX to dg True\n\ngoal (1 subgoal):\n 1. dg \\<or> ps \\<or> is_scalar TYPE('a) &&&\n    nat_term_order_eq DRLEX to dg True", "by auto"], ["proof (state)\nthis:\n  dg \\<or> ps \\<or> is_scalar TYPE('a)\n  nat_term_order_eq DRLEX to dg True\n\ngoal (1 subgoal):\n 1. (dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq DRLEX to dg True \\<Longrightarrow>\n    nat_term_order_eq DRLEX (POT to) dg ps", "show \"nat_term_order_eq DRLEX (POT to) dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq DRLEX (POT to) dg ps", "proof (rule nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare (POT to) u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare (POT to) u v", "assume 1: \"dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (state)\nthis:\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare (POT to) u v", "assume 2: \"ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare DRLEX u v =\n                         nat_term_compare (POT to) u v", "from disj"], ["proof (chain)\npicking this:\n  dg \\<or> ps \\<or> is_scalar TYPE('a)", "show \"nat_term_compare DRLEX u v = nat_term_compare (POT to) u v\""], ["proof (prove)\nusing this:\n  dg \\<or> ps \\<or> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. dg \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v\n 2. ps \\<or> is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "assume dg"], ["proof (state)\nthis:\n  dg\n\ngoal (2 subgoals):\n 1. dg \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v\n 2. ps \\<or> is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "hence eq1: \"deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (prove)\nusing this:\n  dg\n\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))", "by (rule 1)"], ["proof (state)\nthis:\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (2 subgoals):\n 1. dg \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v\n 2. ps \\<or> is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "proof (simp add: nat_term_compare_DRLEX deg_comp eq1 nat_term_compare_POT pot_comp comparator_of_def split: order.split, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v) \\<Longrightarrow>\n    lex_comp v u = nat_term_compare to u v", "assume eq2: \"snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v) \\<Longrightarrow>\n    lex_comp v u = nat_term_compare to u v", "with a 1"], ["proof (chain)\npicking this:\n  nat_term_order_eq DRLEX to dg True\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  snd (rep_nat_term u) = snd (rep_nat_term v)", "have \"nat_term_compare DRLEX u v = nat_term_compare to u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq DRLEX to dg True\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare to u v", "by (rule nat_term_order_eqD)"], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v) \\<Longrightarrow>\n    lex_comp v u = nat_term_compare to u v", "thus \"lex_comp v u = nat_term_compare to u v\""], ["proof (prove)\nusing this:\n  nat_term_compare DRLEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. lex_comp v u = nat_term_compare to u v", "by (simp add: nat_term_compare_DRLEX deg_comp eq1 pot_comp eq2)"], ["proof (state)\nthis:\n  lex_comp v u = nat_term_compare to u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare (POT to) u v\n\ngoal (1 subgoal):\n 1. ps \\<or> is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ps \\<or> is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "assume \"ps \\<or> is_scalar TYPE('a)\""], ["proof (state)\nthis:\n  ps \\<or> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. ps \\<or> is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "hence eq: \"snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (prove)\nusing this:\n  ps \\<or> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v)", "using 2"], ["proof (prove)\nusing this:\n  ps \\<or> is_scalar TYPE('a)\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v)", "by (rule snd_rep_nat_term_eqI)"], ["proof (state)\nthis:\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. ps \\<or> is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "with a 1"], ["proof (chain)\npicking this:\n  nat_term_order_eq DRLEX to dg True\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  snd (rep_nat_term u) = snd (rep_nat_term v)", "have \"nat_term_compare DRLEX u v = nat_term_compare to u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq DRLEX to dg True\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare to u v", "by (rule nat_term_order_eqD)"], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. ps \\<or> is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "also"], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare to u v\n\ngoal (1 subgoal):\n 1. ps \\<or> is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "have \"... = nat_term_compare (POT to) u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare to u v = nat_term_compare (POT to) u v", "by (simp add: nat_term_compare_POT pot_comp eq)"], ["proof (state)\nthis:\n  nat_term_compare to u v = nat_term_compare (POT to) u v\n\ngoal (1 subgoal):\n 1. ps \\<or> is_scalar TYPE('a) \\<Longrightarrow>\n    nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "finally"], ["proof (chain)\npicking this:\n  nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "show ?thesis"], ["proof (prove)\nusing this:\n  nat_term_compare DRLEX u v = nat_term_compare (POT to) u v\n\ngoal (1 subgoal):\n 1. nat_term_compare DRLEX u v = nat_term_compare (POT to) u v", "."], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare (POT to) u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_compare DRLEX u v = nat_term_compare (POT to) u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq DRLEX (POT to) dg ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq DRLEX (POT to) dg ps =\n  ((dg \\<or> ps \\<or> is_scalar TYPE('a)) \\<and>\n   nat_term_order_eq DRLEX to dg True)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DEG_eq [code]:\n  \"nat_term_order_eq (DEG to) (LEX::'a nat_term_order) dg ps = nat_term_order_eq LEX (DEG to) dg ps\"\n  \"nat_term_order_eq (DEG to) (DRLEX::'a nat_term_order) dg ps = nat_term_order_eq DRLEX (DEG to) dg ps\"\n  \"nat_term_order_eq (DEG to1) (DEG (to2::'a nat_term_order)) dg ps =\n    nat_term_order_eq to1 to2 True ps\" (is ?thesis3)\n  \"nat_term_order_eq (DEG to1) (POT (to2::'a nat_term_order)) dg ps =\n    (if dg then nat_term_order_eq to1 (POT to2) dg ps\n    else ((ps \\<or> is_scalar TYPE('a::nat_term_compare)) \\<and> nat_term_order_eq (DEG to1) to2 dg ps))\" (is ?thesis4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat_term_order_eq (DEG to) Term_Order.LEX dg ps =\n     nat_term_order_eq Term_Order.LEX (DEG to) dg ps &&&\n     nat_term_order_eq (DEG to) DRLEX dg ps =\n     nat_term_order_eq DRLEX (DEG to) dg ps) &&&\n    nat_term_order_eq (DEG to1) (DEG to2) dg ps =\n    nat_term_order_eq to1 to2 True ps &&&\n    nat_term_order_eq (DEG to1) (POT to2) dg ps =\n    (if dg then nat_term_order_eq to1 (POT to2) dg ps\n     else (ps \\<or> is_scalar TYPE('a)) \\<and>\n          nat_term_order_eq (DEG to1) to2 dg ps)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. nat_term_order_eq (DEG to) Term_Order.LEX dg ps =\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps\n 2. nat_term_order_eq (DEG to) DRLEX dg ps =\n    nat_term_order_eq DRLEX (DEG to) dg ps\n 3. nat_term_order_eq (DEG to1) (DEG to2) dg ps =\n    nat_term_order_eq to1 to2 True ps\n 4. nat_term_order_eq (DEG to1) (POT to2) dg ps =\n    (if dg then nat_term_order_eq to1 (POT to2) dg ps\n     else (ps \\<or> is_scalar TYPE('a)) \\<and>\n          nat_term_order_eq (DEG to1) to2 dg ps)", "show ?thesis3"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq (DEG to1) (DEG to2) dg ps =\n    nat_term_order_eq to1 to2 True ps", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq (DEG to1) (DEG to2) dg ps \\<Longrightarrow>\n    nat_term_order_eq to1 to2 True ps\n 2. nat_term_order_eq to1 to2 True ps \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (DEG to2) dg ps", "assume a: \"nat_term_order_eq (DEG to1) (DEG to2) dg ps\""], ["proof (state)\nthis:\n  nat_term_order_eq (DEG to1) (DEG to2) dg ps\n\ngoal (2 subgoals):\n 1. nat_term_order_eq (DEG to1) (DEG to2) dg ps \\<Longrightarrow>\n    nat_term_order_eq to1 to2 True ps\n 2. nat_term_order_eq to1 to2 True ps \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (DEG to2) dg ps", "show \"nat_term_order_eq to1 to2 True ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 to2 True ps", "proof (rule nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>True \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare to1 u v = nat_term_compare to2 u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>True \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare to1 u v = nat_term_compare to2 u v", "assume b: \"True \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\"\n        and \"ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  True \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>True \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare to1 u v = nat_term_compare to2 u v", "with a"], ["proof (chain)\npicking this:\n  nat_term_order_eq (DEG to1) (DEG to2) dg ps\n  True \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)", "have \"nat_term_compare (DEG to1) u v = nat_term_compare (DEG to2) u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq (DEG to1) (DEG to2) dg ps\n  True \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare (DEG to1) u v = nat_term_compare (DEG to2) u v", "by (rule nat_term_order_eqD, blast+)"], ["proof (state)\nthis:\n  nat_term_compare (DEG to1) u v = nat_term_compare (DEG to2) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>True \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare to1 u v = nat_term_compare to2 u v", "thus \"nat_term_compare to1 u v = nat_term_compare to2 u v\""], ["proof (prove)\nusing this:\n  nat_term_compare (DEG to1) u v = nat_term_compare (DEG to2) u v\n\ngoal (1 subgoal):\n 1. nat_term_compare to1 u v = nat_term_compare to2 u v", "by (simp add: nat_term_compare_DEG deg_comp comparator_of_def b)"], ["proof (state)\nthis:\n  nat_term_compare to1 u v = nat_term_compare to2 u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq to1 to2 True ps\n\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 to2 True ps \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (DEG to2) dg ps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 to2 True ps \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (DEG to2) dg ps", "assume a: \"nat_term_order_eq to1 to2 True ps\""], ["proof (state)\nthis:\n  nat_term_order_eq to1 to2 True ps\n\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 to2 True ps \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (DEG to2) dg ps", "show \"nat_term_order_eq (DEG to1) (DEG to2) dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq (DEG to1) (DEG to2) dg ps", "proof (rule nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare (DEG to1) u v =\n                         nat_term_compare (DEG to2) u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare (DEG to1) u v =\n                         nat_term_compare (DEG to2) u v", "assume b: \"ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare (DEG to1) u v =\n                         nat_term_compare (DEG to2) u v", "show \"nat_term_compare (DEG to1) u v = nat_term_compare (DEG to2) u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (DEG to1) u v = nat_term_compare (DEG to2) u v", "proof (simp add: nat_term_compare_DEG deg_comp comparator_of_def split: order.split, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term u)) =\n    deg_pp (fst (rep_nat_term v)) \\<Longrightarrow>\n    nat_term_compare to1 u v = nat_term_compare to2 u v", "assume \"deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (state)\nthis:\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. deg_pp (fst (rep_nat_term u)) =\n    deg_pp (fst (rep_nat_term v)) \\<Longrightarrow>\n    nat_term_compare to1 u v = nat_term_compare to2 u v", "with a"], ["proof (chain)\npicking this:\n  nat_term_order_eq to1 to2 True ps\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))", "show \"nat_term_compare to1 u v = nat_term_compare to2 u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq to1 to2 True ps\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. nat_term_compare to1 u v = nat_term_compare to2 u v", "using b"], ["proof (prove)\nusing this:\n  nat_term_order_eq to1 to2 True ps\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  ps \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare to1 u v = nat_term_compare to2 u v", "by (rule nat_term_order_eqD)"], ["proof (state)\nthis:\n  nat_term_compare to1 u v = nat_term_compare to2 u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_compare (DEG to1) u v = nat_term_compare (DEG to2) u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq (DEG to1) (DEG to2) dg ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq (DEG to1) (DEG to2) dg ps =\n  nat_term_order_eq to1 to2 True ps\n\ngoal (3 subgoals):\n 1. nat_term_order_eq (DEG to) Term_Order.LEX dg ps =\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps\n 2. nat_term_order_eq (DEG to) DRLEX dg ps =\n    nat_term_order_eq DRLEX (DEG to) dg ps\n 3. nat_term_order_eq (DEG to1) (POT to2) dg ps =\n    (if dg then nat_term_order_eq to1 (POT to2) dg ps\n     else (ps \\<or> is_scalar TYPE('a)) \\<and>\n          nat_term_order_eq (DEG to1) to2 dg ps)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. nat_term_order_eq (DEG to) Term_Order.LEX dg ps =\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps\n 2. nat_term_order_eq (DEG to) DRLEX dg ps =\n    nat_term_order_eq DRLEX (DEG to) dg ps\n 3. nat_term_order_eq (DEG to1) (POT to2) dg ps =\n    (if dg then nat_term_order_eq to1 (POT to2) dg ps\n     else (ps \\<or> is_scalar TYPE('a)) \\<and>\n          nat_term_order_eq (DEG to1) to2 dg ps)", "show ?thesis4"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq (DEG to1) (POT to2) dg ps =\n    (if dg then nat_term_order_eq to1 (POT to2) dg ps\n     else (ps \\<or> is_scalar TYPE('a)) \\<and>\n          nat_term_order_eq (DEG to1) to2 dg ps)", "proof (simp add: nat_term_order_eq_DEG_dg split: if_split, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dg \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (POT to2) False ps =\n    ((ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq (DEG to1) to2 False ps)", "show \"nat_term_order_eq (DEG to1) (POT to2) False ps =\n            ((ps \\<or> is_scalar TYPE('a)) \\<and> nat_term_order_eq (DEG to1) to2 False ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq (DEG to1) (POT to2) False ps =\n    ((ps \\<or> is_scalar TYPE('a)) \\<and>\n     nat_term_order_eq (DEG to1) to2 False ps)", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq (DEG to1) (POT to2) False ps \\<Longrightarrow>\n    (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps\n 2. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (POT to2) False ps", "assume a: \"nat_term_order_eq (DEG to1) (POT to2) False ps\""], ["proof (state)\nthis:\n  nat_term_order_eq (DEG to1) (POT to2) False ps\n\ngoal (2 subgoals):\n 1. nat_term_order_eq (DEG to1) (POT to2) False ps \\<Longrightarrow>\n    (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps\n 2. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (POT to2) False ps", "have *: \"ps \\<or> is_scalar TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<or> is_scalar TYPE('a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "assume \"\\<not> (ps \\<or> is_scalar TYPE('a))\""], ["proof (state)\nthis:\n  \\<not> (ps \\<or> is_scalar TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "hence \"\\<not> ps\" and \"\\<not> is_scalar TYPE('a)\""], ["proof (prove)\nusing this:\n  \\<not> (ps \\<or> is_scalar TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<not> ps &&& \\<not> is_scalar TYPE('a)", "by simp_all"], ["proof (state)\nthis:\n  \\<not> ps\n  \\<not> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "from this(2)"], ["proof (chain)\npicking this:\n  \\<not> is_scalar TYPE('a)", "obtain x::'a where \"snd (rep_nat_term x) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> is_scalar TYPE('a)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        snd (rep_nat_term x) \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding is_scalar"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x. snd (rep_nat_term x) = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        snd (rep_nat_term x) \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd (rep_nat_term x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  snd (rep_nat_term x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "define i::nat where \"i = snd (rep_nat_term x)\""], ["proof (state)\nthis:\n  i = snd (rep_nat_term x)\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  snd (rep_nat_term x) \\<noteq> 0\n  i = snd (rep_nat_term x)", "have \"i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term x) \\<noteq> 0\n  i = snd (rep_nat_term x)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "let ?u = \"(of_exps 1 0 i)::'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "let ?v = \"(of_exps 2 0 0)::'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "from i_def[symmetric]"], ["proof (chain)\npicking this:\n  snd (rep_nat_term x) = i", "have eq: \"snd (rep_nat_term ?u) = i\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term x) = i\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term (of_exps 1 0 i)) = i", "by (rule snd_of_exps)"], ["proof (state)\nthis:\n  snd (rep_nat_term (of_exps 1 0 i)) = i\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "have \"nat_term_compare (DEG to1) ?u ?v = nat_term_compare (POT to2) ?u ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (DEG to1) (of_exps 1 0 i) (of_exps 2 0 0) =\n    nat_term_compare (POT to2) (of_exps 1 0 i) (of_exps 2 0 0)", "by (rule nat_term_order_eqD, fact a, simp_all add: \\<open>\\<not> ps\\<close>)"], ["proof (state)\nthis:\n  nat_term_compare (DEG to1) (of_exps 1 0 i) (of_exps 2 0 0) =\n  nat_term_compare (POT to2) (of_exps 1 0 i) (of_exps 2 0 0)\n\ngoal (1 subgoal):\n 1. \\<not> (ps \\<or> is_scalar TYPE('a)) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  nat_term_compare (DEG to1) (of_exps 1 0 i) (of_exps 2 0 0) =\n  nat_term_compare (POT to2) (of_exps 1 0 i) (of_exps 2 0 0)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: nat_term_compare_DEG deg_comp pot_comp nat_term_compare_POT\n              comparator_of_def comp_of_ord_def lex_pp_of_exps eq_of_exps eq \\<open>i \\<noteq> 0\\<close> del: One_nat_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ps \\<or> is_scalar TYPE('a)\n\ngoal (2 subgoals):\n 1. nat_term_order_eq (DEG to1) (POT to2) False ps \\<Longrightarrow>\n    (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps\n 2. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (POT to2) False ps", "moreover"], ["proof (state)\nthis:\n  ps \\<or> is_scalar TYPE('a)\n\ngoal (2 subgoals):\n 1. nat_term_order_eq (DEG to1) (POT to2) False ps \\<Longrightarrow>\n    (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps\n 2. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (POT to2) False ps", "from this a"], ["proof (chain)\npicking this:\n  ps \\<or> is_scalar TYPE('a)\n  nat_term_order_eq (DEG to1) (POT to2) False ps", "have \"nat_term_order_eq (DEG to1) to2 False ps\""], ["proof (prove)\nusing this:\n  ps \\<or> is_scalar TYPE('a)\n  nat_term_order_eq (DEG to1) (POT to2) False ps\n\ngoal (1 subgoal):\n 1. nat_term_order_eq (DEG to1) to2 False ps", "by (simp add: nat_term_order_eq_POT_ps')"], ["proof (state)\nthis:\n  nat_term_order_eq (DEG to1) to2 False ps\n\ngoal (2 subgoals):\n 1. nat_term_order_eq (DEG to1) (POT to2) False ps \\<Longrightarrow>\n    (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps\n 2. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (POT to2) False ps", "ultimately"], ["proof (chain)\npicking this:\n  ps \\<or> is_scalar TYPE('a)\n  nat_term_order_eq (DEG to1) to2 False ps", "show \"(ps \\<or> is_scalar TYPE('a)) \\<and> nat_term_order_eq (DEG to1) to2 False ps\""], ["proof (prove)\nusing this:\n  ps \\<or> is_scalar TYPE('a)\n  nat_term_order_eq (DEG to1) to2 False ps\n\ngoal (1 subgoal):\n 1. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps", ".."], ["proof (state)\nthis:\n  (ps \\<or> is_scalar TYPE('a)) \\<and>\n  nat_term_order_eq (DEG to1) to2 False ps\n\ngoal (1 subgoal):\n 1. (ps \\<or> is_scalar TYPE('a)) \\<and>\n    nat_term_order_eq (DEG to1) to2 False ps \\<Longrightarrow>\n    nat_term_order_eq (DEG to1) (POT to2) False ps", "qed (simp add: nat_term_order_eq_POT_ps')"], ["proof (state)\nthis:\n  nat_term_order_eq (DEG to1) (POT to2) False ps =\n  ((ps \\<or> is_scalar TYPE('a)) \\<and>\n   nat_term_order_eq (DEG to1) to2 False ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq (DEG to1) (POT to2) dg ps =\n  (if dg then nat_term_order_eq to1 (POT to2) dg ps\n   else (ps \\<or> is_scalar TYPE('a)) \\<and>\n        nat_term_order_eq (DEG to1) to2 dg ps)\n\ngoal (2 subgoals):\n 1. nat_term_order_eq (DEG to) Term_Order.LEX dg ps =\n    nat_term_order_eq Term_Order.LEX (DEG to) dg ps\n 2. nat_term_order_eq (DEG to) DRLEX dg ps =\n    nat_term_order_eq DRLEX (DEG to) dg ps", "qed (fact nat_term_order_eq_sym)+"], ["", "lemma POT_eq [code]:\n  \"nat_term_order_eq (POT to) LEX dg ps = nat_term_order_eq LEX (POT to) dg ps\"\n  \"nat_term_order_eq (POT to1) (DEG to2) dg ps = nat_term_order_eq (DEG to2) (POT to1) dg ps\"\n  \"nat_term_order_eq (POT to1) DRLEX dg ps = nat_term_order_eq DRLEX (POT to1) dg ps\"\n  \"nat_term_order_eq (POT to1) (POT (to2::'a::nat_term_compare nat_term_order)) dg ps =\n    nat_term_order_eq to1 to2 dg True\" (is ?thesis4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat_term_order_eq (POT to) Term_Order.LEX dg ps =\n     nat_term_order_eq Term_Order.LEX (POT to) dg ps &&&\n     nat_term_order_eq (POT to1) (DEG to2) dg ps =\n     nat_term_order_eq (DEG to2) (POT to1) dg ps) &&&\n    nat_term_order_eq (POT to1) DRLEX dg ps =\n    nat_term_order_eq DRLEX (POT to1) dg ps &&&\n    nat_term_order_eq (POT to1) (POT to2) dg ps =\n    nat_term_order_eq to1 to2 dg True", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. nat_term_order_eq (POT to) Term_Order.LEX dg ps =\n    nat_term_order_eq Term_Order.LEX (POT to) dg ps\n 2. nat_term_order_eq (POT to1) (DEG to2) dg ps =\n    nat_term_order_eq (DEG to2) (POT to1) dg ps\n 3. nat_term_order_eq (POT to1) DRLEX dg ps =\n    nat_term_order_eq DRLEX (POT to1) dg ps\n 4. nat_term_order_eq (POT to1) (POT to2) dg ps =\n    nat_term_order_eq to1 to2 dg True", "show ?thesis4"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq (POT to1) (POT to2) dg ps =\n    nat_term_order_eq to1 to2 dg True", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_term_order_eq (POT to1) (POT to2) dg ps \\<Longrightarrow>\n    nat_term_order_eq to1 to2 dg True\n 2. nat_term_order_eq to1 to2 dg True \\<Longrightarrow>\n    nat_term_order_eq (POT to1) (POT to2) dg ps", "assume a: \"nat_term_order_eq (POT to1) (POT to2) dg ps\""], ["proof (state)\nthis:\n  nat_term_order_eq (POT to1) (POT to2) dg ps\n\ngoal (2 subgoals):\n 1. nat_term_order_eq (POT to1) (POT to2) dg ps \\<Longrightarrow>\n    nat_term_order_eq to1 to2 dg True\n 2. nat_term_order_eq to1 to2 dg True \\<Longrightarrow>\n    nat_term_order_eq (POT to1) (POT to2) dg ps", "show \"nat_term_order_eq to1 to2 dg True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 to2 dg True", "proof (rule nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        True \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare to1 u v = nat_term_compare to2 u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        True \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare to1 u v = nat_term_compare to2 u v", "assume \"dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\"\n        and b: \"True \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  True \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        True \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare to1 u v = nat_term_compare to2 u v", "with a"], ["proof (chain)\npicking this:\n  nat_term_order_eq (POT to1) (POT to2) dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  True \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)", "have \"nat_term_compare (POT to1) u v = nat_term_compare (POT to2) u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq (POT to1) (POT to2) dg ps\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  True \\<Longrightarrow> snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare (POT to1) u v = nat_term_compare (POT to2) u v", "by (rule nat_term_order_eqD, blast+)"], ["proof (state)\nthis:\n  nat_term_compare (POT to1) u v = nat_term_compare (POT to2) u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        True \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare to1 u v = nat_term_compare to2 u v", "thus \"nat_term_compare to1 u v = nat_term_compare to2 u v\""], ["proof (prove)\nusing this:\n  nat_term_compare (POT to1) u v = nat_term_compare (POT to2) u v\n\ngoal (1 subgoal):\n 1. nat_term_compare to1 u v = nat_term_compare to2 u v", "by (simp add: nat_term_compare_POT pot_comp comparator_of_def b)"], ["proof (state)\nthis:\n  nat_term_compare to1 u v = nat_term_compare to2 u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq to1 to2 dg True\n\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 to2 dg True \\<Longrightarrow>\n    nat_term_order_eq (POT to1) (POT to2) dg ps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 to2 dg True \\<Longrightarrow>\n    nat_term_order_eq (POT to1) (POT to2) dg ps", "assume a: \"nat_term_order_eq to1 to2 dg True\""], ["proof (state)\nthis:\n  nat_term_order_eq to1 to2 dg True\n\ngoal (1 subgoal):\n 1. nat_term_order_eq to1 to2 dg True \\<Longrightarrow>\n    nat_term_order_eq (POT to1) (POT to2) dg ps", "show \"nat_term_order_eq (POT to1) (POT to2) dg ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_order_eq (POT to1) (POT to2) dg ps", "proof (rule nat_term_order_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare (POT to1) u v =\n                         nat_term_compare (POT to2) u v", "fix u v :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare (POT to1) u v =\n                         nat_term_compare (POT to2) u v", "assume b: \"dg \\<Longrightarrow> deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\""], ["proof (state)\nthis:\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>dg \\<Longrightarrow>\n                deg_pp (fst (rep_nat_term u)) =\n                deg_pp (fst (rep_nat_term v));\n        ps \\<Longrightarrow>\n        snd (rep_nat_term u) = snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare (POT to1) u v =\n                         nat_term_compare (POT to2) u v", "show \"nat_term_compare (POT to1) u v = nat_term_compare (POT to2) u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (POT to1) u v = nat_term_compare (POT to2) u v", "proof (simp add: nat_term_compare_POT pot_comp comparator_of_def split: order.split, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v) \\<Longrightarrow>\n    nat_term_compare to1 u v = nat_term_compare to2 u v", "assume \"snd (rep_nat_term u) = snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. snd (rep_nat_term u) = snd (rep_nat_term v) \\<Longrightarrow>\n    nat_term_compare to1 u v = nat_term_compare to2 u v", "with a b"], ["proof (chain)\npicking this:\n  nat_term_order_eq to1 to2 dg True\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  snd (rep_nat_term u) = snd (rep_nat_term v)", "show \"nat_term_compare to1 u v = nat_term_compare to2 u v\""], ["proof (prove)\nusing this:\n  nat_term_order_eq to1 to2 dg True\n  dg \\<Longrightarrow>\n  deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v))\n  snd (rep_nat_term u) = snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. nat_term_compare to1 u v = nat_term_compare to2 u v", "by (rule nat_term_order_eqD)"], ["proof (state)\nthis:\n  nat_term_compare to1 u v = nat_term_compare to2 u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_compare (POT to1) u v = nat_term_compare (POT to2) u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq (POT to1) (POT to2) dg ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_order_eq (POT to1) (POT to2) dg ps =\n  nat_term_order_eq to1 to2 dg True\n\ngoal (3 subgoals):\n 1. nat_term_order_eq (POT to) Term_Order.LEX dg ps =\n    nat_term_order_eq Term_Order.LEX (POT to) dg ps\n 2. nat_term_order_eq (POT to1) (DEG to2) dg ps =\n    nat_term_order_eq (DEG to2) (POT to1) dg ps\n 3. nat_term_order_eq (POT to1) DRLEX dg ps =\n    nat_term_order_eq DRLEX (POT to1) dg ps", "qed (fact nat_term_order_eq_sym)+"], ["", "lemma nat_term_order_equal [code]: \"HOL.equal to1 to2 = nat_term_order_eq to1 to2 False False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal to1 to2 = nat_term_order_eq to1 to2 False False", "by (auto simp: nat_term_order_eq_def equal_eq nat_term_compare_inject[symmetric])"], ["", "hide_const (open) of_exps"], ["", "value [code] \"DEG (POT DRLEX) = (DRLEX::((nat, nat) pp \\<times> nat) nat_term_order)\""], ["", "value [code] \"POT LEX = (LEX::((nat, nat) pp \\<times> nat) nat_term_order)\""], ["", "value [code] \"POT LEX = (LEX::(nat, nat) pp nat_term_order)\""], ["", "end"], ["", "(*theory*)"]]}