{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/MPoly_PM.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma monomial_single_power:\n  \"(monomial c (Poly_Mapping.single x k)) ^ n = monomial (c ^ n) (Poly_Mapping.single x (k * n))\"", "lemma monomial_power_map_scale: \"(monomial c t) ^ n = monomial (c ^ n) (n \\<cdot> t)\"", "lemma times_canc_left:\n  assumes \"h * p = h * q\" and \"h \\<noteq> (0::('x::linorder \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::ring_no_zero_divisors)\"\n  shows \"p = q\"", "lemma times_canc_right:\n  assumes \"p * h = q * h\" and \"h \\<noteq> (0::('x::linorder \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::ring_no_zero_divisors)\"\n  shows \"p = q\"", "lemma plus_minus_assoc_pm_nat_1: \"s + t - u = (s - (u - t)) + (t - (u::_ \\<Rightarrow>\\<^sub>0 nat))\"", "lemma plus_minus_assoc_pm_nat_2:\n  \"s + (t - u) = (s + (except (u - t) (- keys s))) + t - (u::_ \\<Rightarrow>\\<^sub>0 nat)\"", "lemma deg_pm_sum: \"deg_pm (sum t A) = (\\<Sum>a\\<in>A. deg_pm (t a))\"", "lemma deg_pm_mono: \"s adds t \\<Longrightarrow> deg_pm s \\<le> deg_pm (t::_ \\<Rightarrow>\\<^sub>0 _::add_linorder_min)\"", "lemma adds_deg_pm_antisym: \"s adds t \\<Longrightarrow> deg_pm t \\<le> deg_pm (s::_ \\<Rightarrow>\\<^sub>0 _::add_linorder_min) \\<Longrightarrow> s = t\"", "lemma deg_pm_minus:\n  assumes \"s adds (t::_ \\<Rightarrow>\\<^sub>0 _::comm_monoid_add)\"\n  shows \"deg_pm (t - s) = deg_pm t - deg_pm s\"", "lemma adds_group [simp]: \"s adds (t::'a \\<Rightarrow>\\<^sub>0 'b::ab_group_add)\"", "lemmas deg_pm_minus_group = deg_pm_minus[OF adds_group]", "lemma deg_pm_minus_le: \"deg_pm (t - s) \\<le> deg_pm (t::_ \\<Rightarrow>\\<^sub>0 nat)\"", "lemma minus_id_iff: \"t - s = t \\<longleftrightarrow> keys t \\<inter> keys (s::_ \\<Rightarrow>\\<^sub>0 nat) = {}\"", "lemma deg_pm_minus_id_iff: \"deg_pm (t - s) = deg_pm t \\<longleftrightarrow> keys t \\<inter> keys (s::_ \\<Rightarrow>\\<^sub>0 nat) = {}\"", "lemma poly_deg_monomial: \"poly_deg (monomial c t) = (if c = 0 then 0 else deg_pm t)\"", "lemma poly_deg_monomial_zero [simp]: \"poly_deg (monomial c 0) = 0\"", "lemma poly_deg_zero [simp]: \"poly_deg 0 = 0\"", "lemma poly_deg_one [simp]: \"poly_deg 1 = 0\"", "lemma poly_degE:\n  assumes \"p \\<noteq> 0\"\n  obtains t where \"t \\<in> keys p\" and \"poly_deg p = deg_pm t\"", "lemma poly_deg_max_keys: \"t \\<in> keys p \\<Longrightarrow> deg_pm t \\<le> poly_deg p\"", "lemma poly_deg_leI: \"(\\<And>t. t \\<in> keys p \\<Longrightarrow> deg_pm t \\<le> (d::'a::add_linorder_min)) \\<Longrightarrow> poly_deg p \\<le> d\"", "lemma poly_deg_lessI:\n  \"p \\<noteq> 0 \\<Longrightarrow> (\\<And>t. t \\<in> keys p \\<Longrightarrow> deg_pm t < (d::'a::add_linorder_min)) \\<Longrightarrow> poly_deg p < d\"", "lemma poly_deg_zero_imp_monomial:\n  assumes \"poly_deg p = (0::'a::add_linorder_min)\"\n  shows \"monomial (lookup p 0) 0 = p\"", "lemma poly_deg_plus_le:\n  \"poly_deg (p + q) \\<le> max (poly_deg p) (poly_deg (q::(_ \\<Rightarrow>\\<^sub>0 'a::add_linorder_min) \\<Rightarrow>\\<^sub>0 _))\"", "lemma poly_deg_uminus [simp]: \"poly_deg (-p) = poly_deg p\"", "lemma poly_deg_minus_le:\n  \"poly_deg (p - q) \\<le> max (poly_deg p) (poly_deg (q::(_ \\<Rightarrow>\\<^sub>0 'a::add_linorder_min) \\<Rightarrow>\\<^sub>0 _))\"", "lemma poly_deg_times_le:\n  \"poly_deg (p * q) \\<le> poly_deg p + poly_deg (q::(_ \\<Rightarrow>\\<^sub>0 'a::add_linorder_min) \\<Rightarrow>\\<^sub>0 _)\"", "lemma poly_deg_times:\n  assumes \"p \\<noteq> 0\" and \"q \\<noteq> (0::('x::linorder \\<Rightarrow>\\<^sub>0 'a::add_linorder_min) \\<Rightarrow>\\<^sub>0 'b::semiring_no_zero_divisors)\"\n  shows \"poly_deg (p * q) = poly_deg p + poly_deg q\"", "lemma poly_deg_monom_mult:\n  assumes \"c \\<noteq> 0\" and \"p \\<noteq> (0::(_ \\<Rightarrow>\\<^sub>0 'a::add_linorder_min) \\<Rightarrow>\\<^sub>0 'b::semiring_no_zero_divisors)\"\n  shows \"poly_deg (punit.monom_mult c t p) = deg_pm t + poly_deg p\"", "lemma poly_deg_map_scale:\n  \"poly_deg (c \\<cdot> p) = (if c = (0::_::semiring_no_zero_divisors) then 0 else poly_deg p)\"", "lemma poly_deg_sum_le: \"((poly_deg (sum f A))::'a::add_linorder_min) \\<le> Max (poly_deg ` f ` A)\"", "lemma poly_deg_prod_le: \"((poly_deg (prod f A))::'a::add_linorder_min) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))\"", "lemma maxdeg_max:\n  assumes \"finite A\" and \"p \\<in> A\"\n  shows \"poly_deg p \\<le> maxdeg A\"", "lemma mindeg_min:\n  assumes \"finite A\" and \"p \\<in> A\"\n  shows \"mindeg A \\<le> poly_deg p\"", "lemma in_indetsI:\n  assumes \"x \\<in> keys t\" and \"t \\<in> keys p\"\n  shows \"x \\<in> indets p\"", "lemma in_indetsE:\n  assumes \"x \\<in> indets p\"\n  obtains t where \"t \\<in> keys p\" and \"x \\<in> keys t\"", "lemma keys_subset_indets: \"t \\<in> keys p \\<Longrightarrow> keys t \\<subseteq> indets p\"", "lemma indets_empty_imp_monomial:\n  assumes \"indets p = {}\"\n  shows \"monomial (lookup p 0) 0 = p\"", "lemma finite_indets: \"finite (indets p)\"", "lemma indets_zero [simp]: \"indets 0 = {}\"", "lemma indets_one [simp]: \"indets 1 = {}\"", "lemma indets_monomial_single_subset: \"indets (monomial c (Poly_Mapping.single v k)) \\<subseteq> {v}\"", "lemma indets_monomial_single:\n  assumes \"c \\<noteq> 0\" and \"k \\<noteq> 0\"\n  shows \"indets (monomial c (Poly_Mapping.single v k)) = {v}\"", "lemma indets_monomial:\n  assumes \"c \\<noteq> 0\"\n  shows \"indets (monomial c t) = keys t\"", "lemma indets_monomial_subset: \"indets (monomial c t) \\<subseteq> keys t\"", "lemma indets_monomial_zero [simp]: \"indets (monomial c 0) = {}\"", "lemma indets_plus_subset: \"indets (p + q) \\<subseteq> indets p \\<union> indets q\"", "lemma indets_uminus [simp]: \"indets (-p) = indets p\"", "lemma indets_minus_subset: \"indets (p - q) \\<subseteq> indets p \\<union> indets q\"", "lemma indets_times_subset: \"indets (p * q) \\<subseteq> indets p \\<union> indets (q::(_ \\<Rightarrow>\\<^sub>0 _::cancel_comm_monoid_add) \\<Rightarrow>\\<^sub>0 _)\"", "lemma indets_monom_mult:\n  assumes \"c \\<noteq> 0\" and \"p \\<noteq> (0::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::semiring_no_zero_divisors)\"\n  shows \"indets (punit.monom_mult c t p) = keys t \\<union> indets p\"", "lemma indets_sum_subset: \"indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\"", "lemma indets_prod_subset:\n  \"indets (prod (f::_ \\<Rightarrow> ((_ \\<Rightarrow>\\<^sub>0 _::cancel_comm_monoid_add) \\<Rightarrow>\\<^sub>0 _)) A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\"", "lemma indets_power_subset: \"indets (p ^ n) \\<subseteq> indets (p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1)\"", "lemma indets_empty_iff_poly_deg_zero: \"indets p = {} \\<longleftrightarrow> poly_deg p = 0\"", "lemma PPsI: \"keys t \\<subseteq> X \\<Longrightarrow> t \\<in> .[X]\"", "lemma PPsD: \"t \\<in> .[X] \\<Longrightarrow> keys t \\<subseteq> X\"", "lemma PPs_empty [simp]: \".[{}] = {0}\"", "lemma PPs_UNIV [simp]: \".[UNIV] = UNIV\"", "lemma PPs_singleton: \".[{x}] = range (Poly_Mapping.single x)\"", "lemma zero_in_PPs: \"0 \\<in> .[X]\"", "lemma PPs_mono: \"X \\<subseteq> Y \\<Longrightarrow> .[X] \\<subseteq> .[Y]\"", "lemma PPs_closed_single:\n  assumes \"x \\<in> X\"\n  shows \"Poly_Mapping.single x e \\<in> .[X]\"", "lemma PPs_closed_plus:\n  assumes \"s \\<in> .[X]\" and \"t \\<in> .[X]\"\n  shows \"s + t \\<in> .[X]\"", "lemma PPs_closed_minus:\n  assumes \"s \\<in> .[X]\"\n  shows \"s - t \\<in> .[X]\"", "lemma PPs_closed_adds:\n  assumes \"s \\<in> .[X]\" and \"t adds s\"\n  shows \"t \\<in> .[X]\"", "lemma PPs_closed_gcs:\n  assumes \"s \\<in> .[X]\"\n  shows \"gcs s t \\<in> .[X]\"", "lemma PPs_closed_lcs:\n  assumes \"s \\<in> .[X]\" and \"t \\<in> .[X]\"\n  shows \"lcs s t \\<in> .[X]\"", "lemma PPs_closed_except': \"t \\<in> .[X] \\<Longrightarrow> except t Y \\<in> .[X - Y]\"", "lemma PPs_closed_except: \"t \\<in> .[X] \\<Longrightarrow> except t Y \\<in> .[X]\"", "lemma PPs_UnI:\n  assumes \"tx \\<in> .[X]\" and \"ty \\<in> .[Y]\" and \"t = tx + ty\"\n  shows \"t \\<in> .[X \\<union> Y]\"", "lemma PPs_UnE:\n  assumes \"t \\<in> .[X \\<union> Y]\"\n  obtains tx ty where \"tx \\<in> .[X]\" and \"ty \\<in> .[Y]\" and \"t = tx + ty\"", "lemma PPs_Un: \".[X \\<union> Y] = (\\<Union>t\\<in>.[X]. (+) t ` .[Y])\"  (is \"?A = ?B\")", "lemma PPs_Int: \".[X \\<inter> Y] = .[X] \\<inter> .[Y]\"", "lemma PPs_INT: \".[\\<Inter> X] = \\<Inter> (PPs ` X)\"", "lemma Polys_alt: \"P[X] = {p. indets p \\<subseteq> X}\"", "lemma PolysI: \"keys p \\<subseteq> .[X] \\<Longrightarrow> p \\<in> P[X]\"", "lemma PolysI_alt: \"indets p \\<subseteq> X \\<Longrightarrow> p \\<in> P[X]\"", "lemma PolysD:\n  assumes \"p \\<in> P[X]\"\n  shows \"keys p \\<subseteq> .[X]\" and \"indets p \\<subseteq> X\"", "lemma Polys_empty: \"P[{}] = ((range (Poly_Mapping.single 0))::(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::zero) set)\"", "lemma Polys_UNIV [simp]: \"P[UNIV] = UNIV\"", "lemma zero_in_Polys: \"0 \\<in> P[X]\"", "lemma one_in_Polys: \"1 \\<in> P[X]\"", "lemma Polys_mono: \"X \\<subseteq> Y \\<Longrightarrow> P[X] \\<subseteq> P[Y]\"", "lemma Polys_closed_monomial: \"t \\<in> .[X] \\<Longrightarrow> monomial c t \\<in> P[X]\"", "lemma Polys_closed_plus: \"p \\<in> P[X] \\<Longrightarrow> q \\<in> P[X] \\<Longrightarrow> p + q \\<in> P[X]\"", "lemma Polys_closed_uminus: \"p \\<in> P[X] \\<Longrightarrow> -p \\<in> P[X]\"", "lemma Polys_closed_minus: \"p \\<in> P[X] \\<Longrightarrow> q \\<in> P[X] \\<Longrightarrow> p - q \\<in> P[X]\"", "lemma Polys_closed_monom_mult: \"t \\<in> .[X] \\<Longrightarrow> p \\<in> P[X] \\<Longrightarrow> punit.monom_mult c t p \\<in> P[X]\"", "lemma Polys_closed_times: \"p \\<in> P[X] \\<Longrightarrow> q \\<in> P[X] \\<Longrightarrow> p * q \\<in> P[X]\"", "lemma Polys_closed_power: \"p \\<in> P[X] \\<Longrightarrow> p ^ m \\<in> P[X]\"", "lemma Polys_closed_sum: \"(\\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> P[X]) \\<Longrightarrow> sum f A \\<in> P[X]\"", "lemma Polys_closed_prod: \"(\\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> P[X]) \\<Longrightarrow> prod f A \\<in> P[X]\"", "lemma Polys_closed_sum_list: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]) \\<Longrightarrow> sum_list xs \\<in> P[X]\"", "lemma Polys_closed_except: \"p \\<in> P[X] \\<Longrightarrow> except p T \\<in> P[X]\"", "lemma times_in_PolysD:\n  assumes \"p * q \\<in> P[X]\" and \"p \\<in> P[X]\" and \"p \\<noteq> (0::('x::linorder \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::semiring_no_zero_divisors)\"\n  shows \"q \\<in> P[X]\"", "lemma poly_mapping_plus_induct_Polys [consumes 1, case_names 0 plus]:\n  assumes \"p \\<in> P[X]\" and \"P 0\"\n    and \"\\<And>p c t. t \\<in> .[X] \\<Longrightarrow> p \\<in> P[X] \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> t \\<notin> keys p \\<Longrightarrow> P p \\<Longrightarrow> P (monomial c t + p)\"\n  shows \"P p\"", "lemma Polys_Int: \"P[X \\<inter> Y] = P[X] \\<inter> P[Y]\"", "lemma Polys_INT: \"P[\\<Inter> X] = \\<Inter> (Polys ` X)\"", "lemma subst_pp_alt: \"subst_pp f t = (\\<Prod>x. (f x) ^ (lookup t x))\"", "lemma subst_pp_zero [simp]: \"subst_pp f 0 = 1\"", "lemma subst_pp_trivial_not_zero:\n  assumes \"t \\<noteq> 0\"\n  shows \"subst_pp (\\<lambda>_. 0) t = (0::(_ \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1))\"", "lemma subst_pp_single: \"subst_pp f (Poly_Mapping.single x e) = (f x) ^ e\"", "lemma power_lookup_not_one_subset_keys: \"{x. f x ^ (lookup t x) \\<noteq> 1} \\<subseteq> keys t\"", "lemma subst_pp_plus: \"subst_pp f (s + t) = subst_pp f s * subst_pp f t\"", "lemma subst_pp_id:\n  assumes \"\\<And>x. x \\<in> keys t \\<Longrightarrow> f x = monomial 1 (Poly_Mapping.single x 1)\"\n  shows \"subst_pp f t = monomial 1 t\"", "lemma in_indets_subst_ppE:\n  assumes \"x \\<in> indets (subst_pp f t)\"\n  obtains y where \"y \\<in> keys t\" and \"x \\<in> indets (f y)\"", "lemma subst_pp_by_monomials:\n  assumes \"\\<And>y. y \\<in> keys t \\<Longrightarrow> f y = monomial (c y) (s y)\"\n  shows \"subst_pp f t = monomial (\\<Prod>y\\<in>keys t. (c y) ^ lookup t y) (\\<Sum>y\\<in>keys t. lookup t y \\<cdot> s y)\"", "lemma poly_deg_subst_pp_eq_zeroI:\n  assumes \"\\<And>x. x \\<in> keys t \\<Longrightarrow> poly_deg (f x) = 0\"\n  shows \"poly_deg (subst_pp f t) = 0\"", "lemma poly_deg_subst_pp_le:\n  assumes \"\\<And>x. x \\<in> keys t \\<Longrightarrow> poly_deg (f x) \\<le> 1\"\n  shows \"poly_deg (subst_pp f t) \\<le> deg_pm t\"", "lemma poly_subst_alt: \"poly_subst f p = (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))\"", "lemma poly_subst_trivial [simp]: \"poly_subst (\\<lambda>_. 0) p = monomial (lookup p 0) 0\"", "lemma poly_subst_zero [simp]: \"poly_subst f 0 = 0\"", "lemma monom_mult_lookup_not_zero_subset_keys:\n  \"{t. punit.monom_mult (lookup p t) 0 (subst_pp f t) \\<noteq> 0} \\<subseteq> keys p\"", "lemma poly_subst_plus: \"poly_subst f (p + q) = poly_subst f p + poly_subst f q\"", "lemma poly_subst_uminus: \"poly_subst f (-p) = - poly_subst f (p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::comm_ring_1)\"", "lemma poly_subst_minus:\n  \"poly_subst f (p - q) = poly_subst f p - poly_subst f (q::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::comm_ring_1)\"", "lemma poly_subst_monomial: \"poly_subst f (monomial c t) = punit.monom_mult c 0 (subst_pp f t)\"", "lemma poly_subst_times: \"poly_subst f (p * q) = poly_subst f p * poly_subst f q\"", "lemma poly_subst_sum: \"poly_subst f (sum p A) = (\\<Sum>a\\<in>A. poly_subst f (p a))\"", "lemma poly_subst_prod: \"poly_subst f (prod p A) = (\\<Prod>a\\<in>A. poly_subst f (p a))\"", "lemma poly_subst_power: \"poly_subst f (p ^ n) = (poly_subst f p) ^ n\"", "lemma poly_subst_subst_pp: \"poly_subst f (subst_pp g t) = subst_pp (\\<lambda>x. poly_subst f (g x)) t\"", "lemma poly_subst_poly_subst: \"poly_subst f (poly_subst g p) = poly_subst (\\<lambda>x. poly_subst f (g x)) p\"", "lemma poly_subst_id:\n  assumes \"\\<And>x. x \\<in> indets p \\<Longrightarrow> f x = monomial 1 (Poly_Mapping.single x 1)\"\n  shows \"poly_subst f p = p\"", "lemma in_keys_poly_substE:\n  assumes \"t \\<in> keys (poly_subst f p)\"\n  obtains s where \"s \\<in> keys p\" and \"t \\<in> keys (subst_pp f s)\"", "lemma in_indets_poly_substE:\n  assumes \"x \\<in> indets (poly_subst f p)\"\n  obtains y where \"y \\<in> indets p\" and \"x \\<in> indets (f y)\"", "lemma poly_deg_poly_subst_eq_zeroI:\n  assumes \"\\<And>x. x \\<in> indets p \\<Longrightarrow> poly_deg (f x) = 0\"\n  shows \"poly_deg (poly_subst (f::_ \\<Rightarrow> (('y \\<Rightarrow>\\<^sub>0 _) \\<Rightarrow>\\<^sub>0 _)) (p::('x \\<Rightarrow>\\<^sub>0 _) \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1)) = 0\"", "lemma poly_deg_poly_subst_le:\n  assumes \"\\<And>x. x \\<in> indets p \\<Longrightarrow> poly_deg (f x) \\<le> 1\"\n  shows \"poly_deg (poly_subst (f::_ \\<Rightarrow> (('y \\<Rightarrow>\\<^sub>0 _) \\<Rightarrow>\\<^sub>0 _)) (p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1)) \\<le> poly_deg p\"", "lemma subst_pp_cong: \"s = t \\<Longrightarrow> (\\<And>x. x \\<in> keys t \\<Longrightarrow> f x = g x) \\<Longrightarrow> subst_pp f s = subst_pp g t\"", "lemma poly_subst_cong:\n  assumes \"p = q\" and \"\\<And>x. x \\<in> indets q \\<Longrightarrow> f x = g x\"\n  shows \"poly_subst f p = poly_subst g q\"", "lemma Polys_homomorphismE:\n  obtains h where \"\\<And>p q. h (p + q) = h p + h q\" and \"\\<And>p q. h (p * q) = h p * h q\"\n    and \"\\<And>p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1. h (h p) = h p\" and \"range h = P[X]\"", "lemma in_idealE_Polys_finite:\n  assumes \"finite B\" and \"B \\<subseteq> P[X]\" and \"p \\<in> P[X]\" and \"(p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1) \\<in> ideal B\"\n  obtains q where \"\\<And>b. q b \\<in> P[X]\" and \"p = (\\<Sum>b\\<in>B. q b * b)\"", "lemma ideal_induct_Polys [consumes 3, case_names 0 plus]:\n  assumes \"F \\<subseteq> P[X]\" and \"p \\<in> P[X]\" and \"p \\<in> ideal F\"\n  assumes \"P 0\" and \"\\<And>c q h. c \\<in> P[X] \\<Longrightarrow> q \\<in> F \\<Longrightarrow> P h \\<Longrightarrow> h \\<in> P[X] \\<Longrightarrow> P (c * q + h)\"\n  shows \"P (p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1)\"", "lemma image_poly_subst_ideal_subset: \"poly_subst g ` ideal F \\<subseteq> ideal (poly_subst g ` F)\"", "lemma lookup_times_zero:\n  \"lookup (p * q) 0 = lookup p 0 * lookup q (0::'a::{comm_powerprod,ninv_comm_monoid_add})\"", "lemma poly_eval_alt: \"poly_eval a p = (\\<Sum>t\\<in>keys p. lookup p t * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\"", "lemma poly_eval_monomial: \"poly_eval a (monomial c t) = c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)\"", "lemma poly_eval_zero [simp]: \"poly_eval a 0 = 0\"", "lemma poly_eval_zero_left [simp]: \"poly_eval 0 p = lookup p 0\"", "lemma poly_eval_plus: \"poly_eval a (p + q) = poly_eval a p + poly_eval a q\"", "lemma poly_eval_uminus [simp]: \"poly_eval a (- p) = - poly_eval (a::_::comm_ring_1) p\"", "lemma poly_eval_minus: \"poly_eval a (p - q) = poly_eval a p - poly_eval (a::_::comm_ring_1) q\"", "lemma poly_eval_one [simp]: \"poly_eval a 1 = 1\"", "lemma poly_eval_times: \"poly_eval a (p * q) = poly_eval a p * poly_eval a q\"", "lemma poly_eval_power: \"poly_eval a (p ^ m) = poly_eval a p ^ m\"", "lemma poly_eval_sum: \"poly_eval a (sum f I) = (\\<Sum>i\\<in>I. poly_eval a (f i))\"", "lemma poly_eval_prod: \"poly_eval a (prod f I) = (\\<Prod>i\\<in>I. poly_eval a (f i))\"", "lemma poly_eval_cong: \"p = q \\<Longrightarrow> (\\<And>x. x \\<in> indets q \\<Longrightarrow> a x = b x) \\<Longrightarrow> poly_eval a p = poly_eval b q\"", "lemma indets_poly_eval_subset:\n  \"indets (poly_eval a p) \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union> \\<Union> (indets ` lookup p ` keys p)\"", "lemma image_poly_eval_ideal: \"poly_eval a ` ideal F = ideal (poly_eval a ` F)\"", "lemma\n  shows map_indets_zero [simp]: \"map_indets f 0 = 0\"\n    and map_indets_one [simp]: \"map_indets f 1 = 1\"\n    and map_indets_uminus [simp]: \"map_indets f (- r) = - map_indets f (r::_ \\<Rightarrow>\\<^sub>0 _::comm_ring_1)\"\n    and map_indets_plus: \"map_indets f (p + q) = map_indets f p + map_indets f q\"\n    and map_indets_minus: \"map_indets f (r - s) = map_indets f r - map_indets f s\"\n    and map_indets_times: \"map_indets f (p * q) = map_indets f p * map_indets f q\"\n    and map_indets_power [simp]: \"map_indets f (p ^ m) = map_indets f p ^ m\"\n    and map_indets_sum: \"map_indets f (sum g A) = (\\<Sum>a\\<in>A. map_indets f (g a))\"\n    and map_indets_prod: \"map_indets f (prod g A) = (\\<Prod>a\\<in>A. map_indets f (g a))\"", "lemma map_indets_monomial:\n  \"map_indets f (monomial c t) = monomial c (\\<Sum>x\\<in>keys t. Poly_Mapping.single (f x) (lookup t x))\"", "lemma map_indets_id: \"(\\<And>x. x \\<in> indets p \\<Longrightarrow> f x = x) \\<Longrightarrow> map_indets f p = p\"", "lemma map_indets_map_indets: \"map_indets f (map_indets g p) = map_indets (f \\<circ> g) p\"", "lemma map_indets_cong: \"p = q \\<Longrightarrow> (\\<And>x. x \\<in> indets q \\<Longrightarrow> f x = g x) \\<Longrightarrow> map_indets f p = map_indets g q\"", "lemma poly_subst_map_indets: \"poly_subst f (map_indets g p) = poly_subst (f \\<circ> g) p\"", "lemma poly_eval_map_indets: \"poly_eval a (map_indets g p) = poly_eval (a \\<circ> g) p\"", "lemma map_indets_inverseE_Polys:\n  assumes \"inj_on f X\" and \"p \\<in> P[X]\"\n  shows \"map_indets (the_inv_into X f) (map_indets f p) = p\"", "lemma map_indets_inverseE:\n  assumes \"inj f\"\n  obtains g where \"g = the_inv f\" and \"g \\<circ> f = id\" and \"map_indets g \\<circ> map_indets f = id\"", "lemma indets_map_indets_subset: \"indets (map_indets f (p::_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1)) \\<subseteq> f ` indets p\"", "lemma indets_map_indets:\n  assumes \"inj_on f (indets p)\"\n  shows \"indets (map_indets f p) = f ` indets p\"", "lemma image_map_indets_Polys: \"map_indets f ` P[X] = (P[f ` X]::(_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1) set)\"", "lemma in_keys_map_indetsE:\n  assumes \"t \\<in> keys (map_indets f (p::_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1))\"\n  obtains s where \"s \\<in> keys p\" and \"t = (\\<Sum>x\\<in>keys s. Poly_Mapping.single (f x) (lookup s x))\"", "lemma keys_map_indets_subset:\n  \"keys (map_indets f p) \\<subseteq> (\\<lambda>t. \\<Sum>x\\<in>keys t. Poly_Mapping.single (f x) (lookup t x)) ` keys p\"", "lemma keys_map_indets:\n  assumes \"inj_on f (indets p)\"\n  shows \"keys (map_indets f p) = (\\<lambda>t. \\<Sum>x\\<in>keys t. Poly_Mapping.single (f x) (lookup t x)) ` keys p\"", "lemma poly_deg_map_indets_le: \"poly_deg (map_indets f p) \\<le> poly_deg p\"", "lemma poly_deg_map_indets:\n  assumes \"inj_on f (indets p)\"\n  shows \"poly_deg (map_indets f p) = poly_deg p\"", "lemma map_indets_inj_on_PolysI:\n  assumes \"inj_on (f::'x \\<Rightarrow> 'y) X\"\n  shows \"inj_on ((map_indets f)::_ \\<Rightarrow> _ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1) P[X]\"", "lemma map_indets_injI:\n  assumes \"inj f\"\n  shows \"inj (map_indets f)\"", "lemma image_map_indets_ideal:\n  assumes \"inj f\"\n  shows \"map_indets f ` ideal F = ideal (map_indets f ` (F::(_ \\<Rightarrow>\\<^sub>0 'a::comm_ring_1) set)) \\<inter> P[range f]\"", "lemma homogeneousI: \"(\\<And>s t. s \\<in> keys p \\<Longrightarrow> t \\<in> keys p \\<Longrightarrow> deg_pm s = deg_pm t) \\<Longrightarrow> homogeneous p\"", "lemma homogeneousD: \"homogeneous p \\<Longrightarrow> s \\<in> keys p \\<Longrightarrow> t \\<in> keys p \\<Longrightarrow> deg_pm s = deg_pm t\"", "lemma homogeneousD_poly_deg:\n  assumes \"homogeneous p\" and \"t \\<in> keys p\"\n  shows \"deg_pm t = poly_deg p\"", "lemma homogeneous_monomial [simp]: \"homogeneous (monomial c t)\"", "lemma homogeneous_uminus_iff [simp]: \"homogeneous (- p) \\<longleftrightarrow> homogeneous p\"", "lemma homogeneous_monom_mult: \"homogeneous p \\<Longrightarrow> homogeneous (punit.monom_mult c t p)\"", "lemma homogeneous_monom_mult_rev:\n  assumes \"c \\<noteq> (0::'a::semiring_no_zero_divisors)\" and \"homogeneous (punit.monom_mult c t p)\"\n  shows \"homogeneous p\"", "lemma homogeneous_times:\n  assumes \"homogeneous p\" and \"homogeneous q\"\n  shows \"homogeneous (p * q)\"", "lemma lookup_hom_component: \"lookup (hom_component p n) = (\\<lambda>t. lookup p t when deg_pm t = n)\"", "lemma keys_hom_component: \"keys (hom_component p n) = {t. t \\<in> keys p \\<and> deg_pm t = n}\"", "lemma keys_hom_componentD:\n  assumes \"t \\<in> keys (hom_component p n)\"\n  shows \"t \\<in> keys p\" and \"deg_pm t = n\"", "lemma homogeneous_hom_component: \"homogeneous (hom_component p n)\"", "lemma hom_component_zero [simp]: \"hom_component 0 = 0\"", "lemma hom_component_zero_iff: \"hom_component p n = 0 \\<longleftrightarrow> (\\<forall>t\\<in>keys p. deg_pm t \\<noteq> n)\"", "lemma hom_component_uminus [simp]: \"hom_component (- p) = - hom_component p\"", "lemma hom_component_plus: \"hom_component (p + q) n = hom_component p n + hom_component q n\"", "lemma hom_component_minus: \"hom_component (p - q) n = hom_component p n - hom_component q n\"", "lemma hom_component_monom_mult:\n  \"punit.monom_mult c t (hom_component p n) = hom_component (punit.monom_mult c t p) (deg_pm t + n)\"", "lemma hom_component_inject:\n  assumes \"t \\<in> keys p\" and \"hom_component p (deg_pm t) = hom_component p n\"\n  shows \"deg_pm t = n\"", "lemma hom_component_of_homogeneous:\n  assumes \"homogeneous p\"\n  shows \"hom_component p n = (p when n = poly_deg p)\"", "lemma hom_components_zero [simp]: \"hom_components 0 = {}\"", "lemma hom_components_zero_iff [simp]: \"hom_components p = {} \\<longleftrightarrow> p = 0\"", "lemma hom_components_uminus: \"hom_components (- p) = uminus ` hom_components p\"", "lemma hom_components_monom_mult:\n  \"hom_components (punit.monom_mult c t p) = (if c = 0 then {} else punit.monom_mult c t ` hom_components p)\"\n  for c::\"'a::semiring_no_zero_divisors\"", "lemma hom_componentsI: \"q = hom_component p (deg_pm t) \\<Longrightarrow> t \\<in> keys p \\<Longrightarrow> q \\<in> hom_components p\"", "lemma hom_componentsE:\n  assumes \"q \\<in> hom_components p\"\n  obtains t where \"t \\<in> keys p\" and \"q = hom_component p (deg_pm t)\"", "lemma hom_components_of_homogeneous:\n  assumes \"homogeneous p\"\n  shows \"hom_components p = (if p = 0 then {} else {p})\"", "lemma finite_hom_components: \"finite (hom_components p)\"", "lemma hom_components_homogeneous: \"q \\<in> hom_components p \\<Longrightarrow> homogeneous q\"", "lemma hom_components_nonzero: \"q \\<in> hom_components p \\<Longrightarrow> q \\<noteq> 0\"", "lemma deg_pm_hom_components:\n  assumes \"q1 \\<in> hom_components p\" and \"q2 \\<in> hom_components p\" and \"t1 \\<in> keys q1\" and \"t2 \\<in> keys q2\"\n  shows \"deg_pm t1 = deg_pm t2 \\<longleftrightarrow> q1 = q2\"", "lemma poly_deg_hom_components:\n  assumes \"q1 \\<in> hom_components p\" and \"q2 \\<in> hom_components p\"\n  shows \"poly_deg q1 = poly_deg q2 \\<longleftrightarrow> q1 = q2\"", "lemma hom_components_keys_disjoint:\n  assumes \"q1 \\<in> hom_components p\" and \"q2 \\<in> hom_components p\" and \"q1 \\<noteq> q2\"\n  shows \"keys q1 \\<inter> keys q2 = {}\"", "lemma Keys_hom_components: \"Keys (hom_components p) = keys p\"", "lemma lookup_hom_components: \"q \\<in> hom_components p \\<Longrightarrow> t \\<in> keys q \\<Longrightarrow> lookup q t = lookup p t\"", "lemma poly_deg_hom_components_le:\n  assumes \"q \\<in> hom_components p\"\n  shows \"poly_deg q \\<le> poly_deg p\"", "lemma sum_hom_components: \"\\<Sum>(hom_components p) = p\"", "lemma homogeneous_setI: \"(\\<And>a n. a \\<in> A \\<Longrightarrow> hom_component a n \\<in> A) \\<Longrightarrow> homogeneous_set A\"", "lemma homogeneous_setD: \"homogeneous_set A \\<Longrightarrow> a \\<in> A \\<Longrightarrow> hom_component a n \\<in> A\"", "lemma homogeneous_set_Polys: \"homogeneous_set (P[X]::(_ \\<Rightarrow>\\<^sub>0 'a::zero) set)\"", "lemma homogeneous_set_IntI: \"homogeneous_set A \\<Longrightarrow> homogeneous_set B \\<Longrightarrow> homogeneous_set (A \\<inter> B)\"", "lemma homogeneous_setD_hom_components:\n  assumes \"homogeneous_set A\" and \"a \\<in> A\" and \"b \\<in> hom_components a\"\n  shows \"b \\<in> A\"", "lemma zero_in_homogeneous_set:\n  assumes \"homogeneous_set A\" and \"A \\<noteq> {}\"\n  shows \"0 \\<in> A\"", "lemma homogeneous_ideal:\n  assumes \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"p \\<in> ideal F\"\n  shows \"hom_component p n \\<in> ideal F\"", "lemma homogeneous_idealE_homogeneous:\n  assumes \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"p \\<in> ideal F\" and \"homogeneous p\"\n  obtains F' q where \"finite F'\" and \"F' \\<subseteq> F\" and \"p = (\\<Sum>f\\<in>F'. q f * f)\" and \"\\<And>f. homogeneous (q f)\"\n    and \"\\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p\" and \"\\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\"", "lemma homogenize_zero [simp]: \"homogenize x 0 = 0\"", "lemma homogenize_uminus [simp]: \"homogenize x (- p) = - homogenize x (p::_ \\<Rightarrow>\\<^sub>0 'a::ring_1)\"", "lemma homogenize_monom_mult [simp]:\n  \"homogenize x (punit.monom_mult c t p) = punit.monom_mult c t (homogenize x p)\"\n  for c::\"'a::{semiring_1,semiring_no_zero_divisors_cancel}\"", "lemma homogenize_alt:\n  \"homogenize x p = (\\<Sum>q\\<in>hom_components p. punit.monom_mult 1 (Poly_Mapping.single x (poly_deg p - poly_deg q)) q)\"", "lemma keys_homogenizeE:\n  assumes \"t \\<in> keys (homogenize x p)\"\n  obtains t' where \"t' \\<in> keys p\" and \"t = Poly_Mapping.single x (poly_deg p - deg_pm t') + t'\"", "lemma keys_homogenizeE_alt:\n  assumes \"t \\<in> keys (homogenize x p)\"\n  obtains q t' where \"q \\<in> hom_components p\" and \"t' \\<in> keys q\"\n    and \"t = Poly_Mapping.single x (poly_deg p - poly_deg q) + t'\"", "lemma deg_pm_homogenize:\n  assumes \"t \\<in> keys (homogenize x p)\"\n  shows \"deg_pm t = poly_deg p\"", "lemma homogenize_id_iff [simp]: \"homogenize x p = p \\<longleftrightarrow> homogeneous p\"", "lemma homogenize_homogenize [simp]: \"homogenize x (homogenize x p) = homogenize x p\"", "lemma homogenize_monomial: \"homogenize x (monomial c t) = monomial c t\"", "lemma indets_homogenize_subset: \"indets (homogenize x p) \\<subseteq> insert x (indets p)\"", "lemma homogenize_in_Polys: \"p \\<in> P[X] \\<Longrightarrow> homogenize x p \\<in> P[insert x X]\"", "lemma lookup_homogenize:\n  assumes \"x \\<notin> indets p\" and \"x \\<notin> keys t\"\n  shows \"lookup (homogenize x p) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t) = lookup p t\"", "lemma keys_homogenizeI:\n  assumes \"x \\<notin> indets p\" and \"t \\<in> keys p\"\n  shows \"Poly_Mapping.single x (poly_deg p - deg_pm t) + t \\<in> keys (homogenize x p)\" (is \"?t \\<in> keys ?p\")", "lemma keys_homogenize:\n  \"x \\<notin> indets p \\<Longrightarrow> keys (homogenize x p) = (\\<lambda>t. Poly_Mapping.single x (poly_deg p - deg_pm t) + t) ` keys p\"", "lemma card_keys_homogenize:\n  assumes \"x \\<notin> indets p\"\n  shows \"card (keys (homogenize x p)) = card (keys p)\"", "lemma poly_deg_homogenize:\n  assumes \"x \\<notin> indets p\"\n  shows \"poly_deg (homogenize x p) = poly_deg p\"", "lemma maxdeg_homogenize:\n  assumes \"x \\<notin> \\<Union> (indets ` F)\"\n  shows \"maxdeg (homogenize x ` F) = maxdeg F\"", "lemma homogeneous_ideal_homogenize:\n  assumes \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"p \\<in> ideal F\"\n  shows \"homogenize x p \\<in> ideal F\"", "lemma subst_pp_dehomo_subst [simp]:\n  \"subst_pp (dehomo_subst x) t = monomial (1::'b::comm_semiring_1) (except t {x})\"", "lemma\n  shows dehomogenize_zero [simp]: \"dehomogenize x 0 = 0\"\n    and dehomogenize_one [simp]: \"dehomogenize x 1 = 1\"\n    and dehomogenize_monomial: \"dehomogenize x (monomial c t) = monomial c (except t {x})\"\n    and dehomogenize_plus: \"dehomogenize x (p + q) = dehomogenize x p + dehomogenize x q\"\n    and dehomogenize_uminus: \"dehomogenize x (- r) = - dehomogenize x (r::_ \\<Rightarrow>\\<^sub>0 _::comm_ring_1)\"\n    and dehomogenize_minus: \"dehomogenize x (r - r') = dehomogenize x r - dehomogenize x r'\"\n    and dehomogenize_times: \"dehomogenize x (p * q) = dehomogenize x p * dehomogenize x q\"\n    and dehomogenize_power: \"dehomogenize x (p ^ n) = dehomogenize x p ^ n\"\n    and dehomogenize_sum: \"dehomogenize x (sum f A) = (\\<Sum>a\\<in>A. dehomogenize x (f a))\"\n    and dehomogenize_prod: \"dehomogenize x (prod f A) = (\\<Prod>a\\<in>A. dehomogenize x (f a))\"", "lemma poly_deg_dehomogenize_le: \"poly_deg (dehomogenize x p) \\<le> poly_deg p\"", "lemma indets_dehomogenize: \"indets (dehomogenize x p) \\<subseteq> indets p - {x}\"\n  for p::\"('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1\"", "lemma dehomogenize_id_iff [simp]: \"dehomogenize x p = p \\<longleftrightarrow> x \\<notin> indets p\"", "lemma dehomogenize_dehomogenize [simp]: \"dehomogenize x (dehomogenize x p) = dehomogenize x p\"", "lemma dehomogenize_homogenize [simp]: \"dehomogenize x (homogenize x p) = dehomogenize x p\"", "lemma range_dehomogenize: \"range (dehomogenize x) = (P[- {x}] :: (_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1) set)\"", "lemma dehomogenize_alt: \"dehomogenize x p = (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))\"", "lemma keys_dehomogenizeE:\n  assumes \"t \\<in> keys (dehomogenize x p)\"\n  obtains s where \"s \\<in> keys p\" and \"t = except s {x}\"", "lemma except_inj_on_keys_homogeneous:\n  assumes \"homogeneous p\"\n  shows \"inj_on (\\<lambda>t. except t {x}) (keys p)\"", "lemma lookup_dehomogenize:\n  assumes \"homogeneous p\" and \"t \\<in> keys p\"\n  shows \"lookup (dehomogenize x p) (except t {x}) = lookup p t\"", "lemma keys_dehomogenizeI:\n  assumes \"homogeneous p\" and \"t \\<in> keys p\"\n  shows \"except t {x} \\<in> keys (dehomogenize x p)\"", "lemma homogeneous_homogenize_dehomogenize:\n  assumes \"homogeneous p\"\n  obtains d where \"d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\"\n    and \"punit.monom_mult 1 (Poly_Mapping.single x d) (homogenize x (dehomogenize x p)) = p\"", "lemma dehomogenize_zeroD:\n  assumes \"dehomogenize x p = 0\" and \"homogeneous p\"\n  shows \"p = 0\"", "lemma dehomogenize_ideal: \"dehomogenize x ` ideal F = ideal (dehomogenize x ` F) \\<inter> P[- {x}]\"", "lemma ideal_dehomogenize:\n  assumes \"ideal G = ideal (homogenize x ` F)\" and \"F \\<subseteq> P[UNIV - {x}]\"\n  shows \"ideal (dehomogenize x ` G) = ideal F\"", "lemma lookup_extend_indets_subst_aux:\n  \"lookup (\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y)) = (\\<lambda>x. case x of Some y \\<Rightarrow> lookup t y | _ \\<Rightarrow> 0)\"", "lemma keys_extend_indets_subst_aux:\n  \"keys (\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y)) = Some ` keys t\"", "lemma subst_pp_extend_indets_subst:\n  \"subst_pp extend_indets_subst t = monomial 1 (\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y))\"", "lemma keys_extend_indets:\n  \"keys (extend_indets p) = (\\<lambda>t. \\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y)) ` keys p\"", "lemma indets_extend_indets: \"indets (extend_indets p) = Some ` indets (p::_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1)\"", "lemma poly_deg_extend_indets [simp]: \"poly_deg (extend_indets p) = poly_deg p\"", "lemma\n  shows extend_indets_zero [simp]: \"extend_indets 0 = 0\"\n    and extend_indets_one [simp]: \"extend_indets 1 = 1\"\n    and extend_indets_monomial: \"extend_indets (monomial c t) = punit.monom_mult c 0 (subst_pp extend_indets_subst t)\"\n    and extend_indets_plus: \"extend_indets (p + q) = extend_indets p + extend_indets q\"\n    and extend_indets_uminus: \"extend_indets (- r) = - extend_indets (r::_ \\<Rightarrow>\\<^sub>0 _::comm_ring_1)\"\n    and extend_indets_minus: \"extend_indets (r - r') = extend_indets r - extend_indets r'\"\n    and extend_indets_times: \"extend_indets (p * q) = extend_indets p * extend_indets q\"\n    and extend_indets_power: \"extend_indets (p ^ n) = extend_indets p ^ n\"\n    and extend_indets_sum: \"extend_indets (sum f A) = (\\<Sum>a\\<in>A. extend_indets (f a))\"\n    and extend_indets_prod: \"extend_indets (prod f A) = (\\<Prod>a\\<in>A. extend_indets (f a))\"", "lemma extend_indets_zero_iff [simp]: \"extend_indets p = 0 \\<longleftrightarrow> p = 0\"", "lemma extend_indets_inject:\n  assumes \"extend_indets p = extend_indets (q::_ \\<Rightarrow>\\<^sub>0 _::comm_ring_1)\"\n  shows \"p = q\"", "lemma poly_subst_extend_indets: \"poly_subst f (extend_indets p) = poly_subst (f \\<circ> Some) p\"", "lemma poly_eval_extend_indets: \"poly_eval a (extend_indets p) = poly_eval (a \\<circ> Some) p\"", "lemma lookup_restrict_indets_pp: \"lookup (restrict_indets_pp t) = (\\<lambda>x. lookup t (Some x))\"", "lemma keys_restrict_indets_pp: \"keys (restrict_indets_pp t) = the ` (keys t - {None})\"", "lemma subst_pp_restrict_indets_subst:\n  \"subst_pp (\\<lambda>x. monomial 1 (restrict_indets_subst x)) t = monomial 1 (restrict_indets_pp t)\"", "lemma restrict_indets_pp_zero [simp]: \"restrict_indets_pp 0 = 0\"", "lemma restrict_indets_pp_plus: \"restrict_indets_pp (s + t) = restrict_indets_pp s + restrict_indets_pp t\"", "lemma restrict_indets_pp_except_None [simp]:\n  \"restrict_indets_pp (except t {None}) = restrict_indets_pp t\"", "lemma deg_pm_restrict_indets_pp: \"deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t\"", "lemma keys_restrict_indets_subset: \"keys (restrict_indets p) \\<subseteq> restrict_indets_pp ` keys p\"", "lemma keys_restrict_indets:\n  assumes \"None \\<notin> indets p\"\n  shows \"keys (restrict_indets p) = restrict_indets_pp ` keys p\"", "lemma indets_restrict_indets_subset: \"indets (restrict_indets p) \\<subseteq> the ` (indets p - {None})\"", "lemma poly_deg_restrict_indets_le: \"poly_deg (restrict_indets p) \\<le> poly_deg p\"", "lemma\n  shows restrict_indets_zero [simp]: \"restrict_indets 0 = 0\"\n    and restrict_indets_one [simp]: \"restrict_indets 1 = 1\"\n    and restrict_indets_monomial: \"restrict_indets (monomial c t) = monomial c (restrict_indets_pp t)\"\n    and restrict_indets_plus: \"restrict_indets (p + q) = restrict_indets p + restrict_indets q\"\n    and restrict_indets_uminus: \"restrict_indets (- r) = - restrict_indets (r::_ \\<Rightarrow>\\<^sub>0 _::comm_ring_1)\"\n    and restrict_indets_minus: \"restrict_indets (r - r') = restrict_indets r - restrict_indets r'\"\n    and restrict_indets_times: \"restrict_indets (p * q) = restrict_indets p * restrict_indets q\"\n    and restrict_indets_power: \"restrict_indets (p ^ n) = restrict_indets p ^ n\"\n    and restrict_indets_sum: \"restrict_indets (sum f A) = (\\<Sum>a\\<in>A. restrict_indets (f a))\"\n    and restrict_indets_prod: \"restrict_indets (prod f A) = (\\<Prod>a\\<in>A. restrict_indets (f a))\"", "lemma restrict_extend_indets [simp]: \"restrict_indets (extend_indets p) = p\"", "lemma extend_restrict_indets:\n  assumes \"None \\<notin> indets p\"\n  shows \"extend_indets (restrict_indets p) = p\"", "lemma restrict_indets_dehomogenize [simp]: \"restrict_indets (dehomogenize None p) = restrict_indets p\"", "lemma restrict_homogenize_extend_indets [simp]:\n  \"restrict_indets (homogenize None (extend_indets p)) = p\"", "lemma dehomogenize_extend_indets [simp]: \"dehomogenize None (extend_indets p) = extend_indets p\"", "lemma restrict_indets_ideal: \"restrict_indets ` ideal F = ideal (restrict_indets ` F)\"", "lemma ideal_restrict_indets:\n  \"ideal G = ideal (homogenize None ` extend_indets ` F) \\<Longrightarrow> ideal (restrict_indets ` G) = ideal F\"", "lemma extend_indets_ideal: \"extend_indets ` ideal F = ideal (extend_indets ` F) \\<inter> P[- {None}]\"", "lemma focus_superset:\n  assumes \"finite A\" and \"keys p \\<subseteq> A\"\n  shows \"focus X p = (\\<Sum>t\\<in>A. monomial (monomial (lookup p t) (except t X)) (except t (- X)))\"", "lemma keys_focus: \"keys (focus X p) = (\\<lambda>t. except t (- X)) ` keys p\"", "lemma keys_coeffs_focus_subset:\n  assumes \"c \\<in> range (lookup (focus X p))\"\n  shows \"keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p\"", "lemma focus_in_Polys':\n  assumes \"p \\<in> P[Y]\"\n  shows \"focus X p \\<in> P[Y \\<inter> X]\"", "lemma focus_coeffs_subset_Polys':\n  assumes \"p \\<in> P[Y]\"\n  shows \"range (lookup (focus X p)) \\<subseteq> P[Y - X]\"", "lemma focus_zero [simp]: \"focus X 0 = 0\"", "lemma focus_eq_zero_iff [iff]: \"focus X p = 0 \\<longleftrightarrow> p = 0\"", "lemma focus_one [simp]: \"focus X 1 = 1\"", "lemma focus_monomial: \"focus X (monomial c t) = monomial (monomial c (except t X)) (except t (- X))\"", "lemma focus_uminus [simp]: \"focus X (- p) = - focus X p\"", "lemma focus_plus: \"focus X (p + q) = focus X p + focus X q\"", "lemma focus_minus: \"focus X (p - q) = focus X p - focus X (q::_ \\<Rightarrow>\\<^sub>0 _::ab_group_add)\"", "lemma focus_times: \"focus X (p * q) = focus X p * focus X q\"", "lemma focus_sum: \"focus X (sum f I) = (\\<Sum>i\\<in>I. focus X (f i))\"", "lemma focus_prod: \"focus X (prod f I) = (\\<Prod>i\\<in>I. focus X (f i))\"", "lemma focus_power [simp]: \"focus X (f ^ m) = focus X f ^ m\"", "lemma focus_Polys:\n  assumes \"p \\<in> P[X]\"\n  shows \"focus X p = (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) 0) t)\"", "lemma focus_Polys_Compl:\n  assumes \"p \\<in> P[- X]\"\n  shows \"focus X p = monomial p 0\"", "lemma focus_Int:\n  assumes \"p \\<in> P[Y]\"\n  shows \"focus (X \\<inter> Y) p = focus X p\"", "lemma range_focusD:\n  assumes \"p \\<in> range (focus X)\"\n  shows \"p \\<in> P[X]\" and \"range (lookup p) \\<subseteq> P[- X]\" and \"lookup p t \\<in> P[- X]\"", "lemma range_focusI:\n  assumes \"p \\<in> P[X]\" and \"lookup p ` keys (p::_ \\<Rightarrow>\\<^sub>0 _ \\<Rightarrow>\\<^sub>0 _::semiring_1) \\<subseteq> P[- X]\"\n  shows \"p \\<in> range (focus X)\"", "lemma inj_focus: \"inj ((focus X) :: (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::ab_group_add) \\<Rightarrow> _)\"", "lemma flatten_superset:\n  assumes \"finite A\" and \"keys p \\<subseteq> A\"\n  shows \"flatten p = (\\<Sum>t\\<in>A. punit.monom_mult 1 t (lookup p t))\"", "lemma keys_flatten_subset: \"keys (flatten p) \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))\"", "lemma flatten_in_Polys:\n  assumes \"p \\<in> P[X]\" and \"lookup p ` keys p \\<subseteq> P[Y]\"\n  shows \"flatten p \\<in> P[X \\<union> Y]\"", "lemma flatten_zero [simp]: \"flatten 0 = 0\"", "lemma flatten_one [simp]: \"flatten 1 = 1\"", "lemma flatten_monomial: \"flatten (monomial c t) = punit.monom_mult 1 t c\"", "lemma flatten_uminus [simp]: \"flatten (- p) = - flatten (p::_ \\<Rightarrow>\\<^sub>0 _ \\<Rightarrow>\\<^sub>0 _::ring)\"", "lemma flatten_plus: \"flatten (p + q) = flatten p + flatten q\"", "lemma flatten_minus: \"flatten (p - q) = flatten p - flatten (q::_ \\<Rightarrow>\\<^sub>0 _ \\<Rightarrow>\\<^sub>0 _::ring)\"", "lemma flatten_times: \"flatten (p * q) = flatten p * flatten (q::_ \\<Rightarrow>\\<^sub>0 _ \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1)\"", "lemma flatten_monom_mult:\n  \"flatten (punit.monom_mult c t p) = punit.monom_mult 1 t (c * flatten (p::_ \\<Rightarrow>\\<^sub>0 _ \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1))\"", "lemma flatten_sum: \"flatten (sum f I) = (\\<Sum>i\\<in>I. flatten (f i))\"", "lemma flatten_prod: \"flatten (prod f I) = (\\<Prod>i\\<in>I. flatten (f i :: _ \\<Rightarrow>\\<^sub>0 _::comm_semiring_1))\"", "lemma flatten_power [simp]: \"flatten (f ^ m) = flatten (f:: _ \\<Rightarrow>\\<^sub>0 _::comm_semiring_1) ^ m\"", "lemma surj_flatten: \"surj flatten\"", "lemma flatten_focus [simp]: \"flatten (focus X p) = p\"", "lemma focus_flatten:\n  assumes \"p \\<in> P[X]\" and \"lookup p ` keys p \\<subseteq> P[- X]\"\n  shows \"focus X (flatten p) = p\"", "lemma image_focus_ideal: \"focus X ` ideal F = ideal (focus X ` F) \\<inter> range (focus X)\"", "lemma image_flatten_ideal: \"flatten ` ideal F = ideal (flatten ` F)\"", "lemma poly_eval_focus:\n  \"poly_eval a (focus X p) = poly_subst (\\<lambda>x. if x \\<in> X then a x else monomial 1 (Poly_Mapping.single x 1)) p\"", "lemma indets_poly_eval_focus_subset:\n  \"indets (poly_eval a (focus X p)) \\<subseteq> \\<Union> (indets ` a ` X) \\<union> (indets p - X)\"", "lemma lookup_poly_eval_focus:\n  \"lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t = poly_eval a (lookup (focus (- X) p) t)\"", "lemma keys_poly_eval_focus_subset:\n  \"keys (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) \\<subseteq> (\\<lambda>t. except t X) ` keys p\"", "lemma poly_eval_focus_in_Polys:\n  assumes \"p \\<in> P[X]\"\n  shows \"poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p) \\<in> P[X - Y]\"", "lemma image_poly_eval_focus_ideal:\n  \"poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n      (P[- X]::(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1) set)\"", "lemma varnum_eq_zero_iff: \"varnum X t = 0 \\<longleftrightarrow> t \\<in> .[X]\"", "lemma dgrad_set_varnum: \"dgrad_set (varnum X) 0 = .[X]\"", "lemma PPs_closed_lpp:\n  assumes \"p \\<in> P[X]\"\n  shows \"lpp p \\<in> .[X]\"", "lemma PPs_closed_tpp:\n  assumes \"p \\<in> P[X]\"\n  shows \"tpp p \\<in> .[X]\"", "lemma hom_component_lpp:\n  assumes \"p \\<noteq> 0\"\n  shows \"hom_component p (deg_pm (lpp p)) \\<noteq> 0\" (is \"?p \\<noteq> 0\")\n    and \"lpp (hom_component p (deg_pm (lpp p))) = lpp p\"", "lemma is_hom_ordD: \"is_hom_ord x \\<Longrightarrow> deg_pm s = deg_pm t \\<Longrightarrow> s \\<preceq> t \\<longleftrightarrow> except s {x} \\<preceq> except t {x}\"", "lemma dgrad_p_set_varnum: \"punit.dgrad_p_set (varnum X) 0 = P[X]\"", "lemma extended_ord_is_hom_ord: \"extended_ord.is_hom_ord None\""], "translations": [["", "lemma monomial_single_power:\n  \"(monomial c (Poly_Mapping.single x k)) ^ n = monomial (c ^ n) (Poly_Mapping.single x (k * n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c (monomial k x) ^ n = monomial (c ^ n) (monomial (k * n) x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial c (monomial k x) ^ n = monomial (c ^ n) (monomial (k * n) x)", "have eq: \"(\\<Sum>i = 0..<n. Poly_Mapping.single x k) = Poly_Mapping.single x (k * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. monomial k x) = monomial (k * n) x", "by (induct n, simp_all add: add.commute single_add)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. monomial k x) = monomial (k * n) x\n\ngoal (1 subgoal):\n 1. monomial c (monomial k x) ^ n = monomial (c ^ n) (monomial (k * n) x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c (monomial k x) ^ n = monomial (c ^ n) (monomial (k * n) x)", "by (simp add: punit.monomial_power eq)"], ["proof (state)\nthis:\n  monomial c (monomial k x) ^ n = monomial (c ^ n) (monomial (k * n) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_power_map_scale: \"(monomial c t) ^ n = monomial (c ^ n) (n \\<cdot> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c t ^ n = monomial (c ^ n) (n \\<cdot> t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial c t ^ n = monomial (c ^ n) (n \\<cdot> t)", "have \"(\\<Sum>i = 0..<n. t) = (\\<Sum>i = 0..<n. 1) \\<cdot> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. t) = (\\<Sum>i = 0..<n. 1) \\<cdot> t", "by (simp only: map_scale_sum_distrib_right map_scale_one_left)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. t) = (\\<Sum>i = 0..<n. 1) \\<cdot> t\n\ngoal (1 subgoal):\n 1. monomial c t ^ n = monomial (c ^ n) (n \\<cdot> t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n. t) = (\\<Sum>i = 0..<n. 1) \\<cdot> t\n\ngoal (1 subgoal):\n 1. monomial c t ^ n = monomial (c ^ n) (n \\<cdot> t)", "by (simp add: punit.monomial_power)"], ["proof (state)\nthis:\n  monomial c t ^ n = monomial (c ^ n) (n \\<cdot> t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma times_canc_left:\n  assumes \"h * p = h * q\" and \"h \\<noteq> (0::('x::linorder \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::ring_no_zero_divisors)\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "assume \"p \\<noteq> q\""], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "hence \"p - q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. p - q \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  p - q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "with assms(2)"], ["proof (chain)\npicking this:\n  h \\<noteq> 0\n  p - q \\<noteq> 0", "have \"h * (p - q) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n  p - q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h * (p - q) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  h * (p - q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "hence \"h * p \\<noteq> h * q\""], ["proof (prove)\nusing this:\n  h * (p - q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h * p \\<noteq> h * q", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  h * p \\<noteq> h * q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  h * p \\<noteq> h * q\n\ngoal (1 subgoal):\n 1. False", "using assms(1)"], ["proof (prove)\nusing this:\n  h * p \\<noteq> h * q\n  h * p = h * q\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma times_canc_right:\n  assumes \"p * h = q * h\" and \"h \\<noteq> (0::('x::linorder \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::ring_no_zero_divisors)\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "assume \"p \\<noteq> q\""], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "hence \"p - q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. p - q \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  p - q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "hence \"(p - q) * h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p - q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (p - q) * h \\<noteq> 0", "using assms(2)"], ["proof (prove)\nusing this:\n  p - q \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (p - q) * h \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  (p - q) * h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "hence \"p * h \\<noteq> q * h\""], ["proof (prove)\nusing this:\n  (p - q) * h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p * h \\<noteq> q * h", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  p * h \\<noteq> q * h\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  p * h \\<noteq> q * h\n\ngoal (1 subgoal):\n 1. False", "using assms(1)"], ["proof (prove)\nusing this:\n  p * h \\<noteq> q * h\n  p * h = q * h\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Degree\\<close>"], ["", "lemma plus_minus_assoc_pm_nat_1: \"s + t - u = (s - (u - t)) + (t - (u::_ \\<Rightarrow>\\<^sub>0 nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + t - u = s - (u - t) + (t - u)", "by (rule poly_mapping_eqI, simp add: lookup_add lookup_minus)"], ["", "lemma plus_minus_assoc_pm_nat_2:\n  \"s + (t - u) = (s + (except (u - t) (- keys s))) + t - (u::_ \\<Rightarrow>\\<^sub>0 nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + (t - u) = s + except (u - t) (- keys s) + t - u", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (s + (t - u)) k =\n       lookup (s + except (u - t) (- keys s) + t - u) k", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (s + (t - u)) k =\n       lookup (s + except (u - t) (- keys s) + t - u) k", "show \"lookup (s + (t - u)) x = lookup (s + except (u - t) (- keys s) + t - u) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (s + (t - u)) x =\n    lookup (s + except (u - t) (- keys s) + t - u) x", "proof (cases \"x \\<in> keys s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> keys s \\<Longrightarrow>\n    lookup (s + (t - u)) x =\n    lookup (s + except (u - t) (- keys s) + t - u) x\n 2. x \\<notin> keys s \\<Longrightarrow>\n    lookup (s + (t - u)) x =\n    lookup (s + except (u - t) (- keys s) + t - u) x", "case True"], ["proof (state)\nthis:\n  x \\<in> keys s\n\ngoal (2 subgoals):\n 1. x \\<in> keys s \\<Longrightarrow>\n    lookup (s + (t - u)) x =\n    lookup (s + except (u - t) (- keys s) + t - u) x\n 2. x \\<notin> keys s \\<Longrightarrow>\n    lookup (s + (t - u)) x =\n    lookup (s + except (u - t) (- keys s) + t - u) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> keys s\n\ngoal (1 subgoal):\n 1. lookup (s + (t - u)) x =\n    lookup (s + except (u - t) (- keys s) + t - u) x", "by (simp add: plus_minus_assoc_pm_nat_1 lookup_add lookup_minus lookup_except)"], ["proof (state)\nthis:\n  lookup (s + (t - u)) x = lookup (s + except (u - t) (- keys s) + t - u) x\n\ngoal (1 subgoal):\n 1. x \\<notin> keys s \\<Longrightarrow>\n    lookup (s + (t - u)) x =\n    lookup (s + except (u - t) (- keys s) + t - u) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> keys s \\<Longrightarrow>\n    lookup (s + (t - u)) x =\n    lookup (s + except (u - t) (- keys s) + t - u) x", "case False"], ["proof (state)\nthis:\n  x \\<notin> keys s\n\ngoal (1 subgoal):\n 1. x \\<notin> keys s \\<Longrightarrow>\n    lookup (s + (t - u)) x =\n    lookup (s + except (u - t) (- keys s) + t - u) x", "hence \"lookup s x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> keys s\n\ngoal (1 subgoal):\n 1. lookup s x = 0", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup s x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> keys s \\<Longrightarrow>\n    lookup (s + (t - u)) x =\n    lookup (s + except (u - t) (- keys s) + t - u) x", "with False"], ["proof (chain)\npicking this:\n  x \\<notin> keys s\n  lookup s x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> keys s\n  lookup s x = 0\n\ngoal (1 subgoal):\n 1. lookup (s + (t - u)) x =\n    lookup (s + except (u - t) (- keys s) + t - u) x", "by (simp add: lookup_add lookup_minus lookup_except)"], ["proof (state)\nthis:\n  lookup (s + (t - u)) x = lookup (s + except (u - t) (- keys s) + t - u) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (s + (t - u)) x = lookup (s + except (u - t) (- keys s) + t - u) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deg_pm_sum: \"deg_pm (sum t A) = (\\<Sum>a\\<in>A. deg_pm (t a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (sum t A) = (\\<Sum>a\\<in>A. deg_pm (t a))", "by (induct A rule: infinite_finite_induct) (auto simp: deg_pm_plus)"], ["", "lemma deg_pm_mono: \"s adds t \\<Longrightarrow> deg_pm s \\<le> deg_pm (t::_ \\<Rightarrow>\\<^sub>0 _::add_linorder_min)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds t \\<Longrightarrow> deg_pm s \\<le> deg_pm t", "by (metis addsE deg_pm_plus le_iff_add)"], ["", "lemma adds_deg_pm_antisym: \"s adds t \\<Longrightarrow> deg_pm t \\<le> deg_pm (s::_ \\<Rightarrow>\\<^sub>0 _::add_linorder_min) \\<Longrightarrow> s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s adds t; deg_pm t \\<le> deg_pm s\\<rbrakk>\n    \\<Longrightarrow> s = t", "by (metis (no_types, lifting) add.right_neutral add.right_neutral add_left_cancel addsE\n      deg_pm_eq_0_iff deg_pm_mono deg_pm_plus dual_order.antisym)"], ["", "lemma deg_pm_minus:\n  assumes \"s adds (t::_ \\<Rightarrow>\\<^sub>0 _::comm_monoid_add)\"\n  shows \"deg_pm (t - s) = deg_pm t - deg_pm s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (t - s) = deg_pm t - deg_pm s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm (t - s) = deg_pm t - deg_pm s", "from assms"], ["proof (chain)\npicking this:\n  s adds t", "have \"(t - s) + s = t\""], ["proof (prove)\nusing this:\n  s adds t\n\ngoal (1 subgoal):\n 1. t - s + s = t", "by (rule adds_minus)"], ["proof (state)\nthis:\n  t - s + s = t\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) = deg_pm t - deg_pm s", "hence \"deg_pm t = deg_pm ((t - s) + s)\""], ["proof (prove)\nusing this:\n  t - s + s = t\n\ngoal (1 subgoal):\n 1. deg_pm t = deg_pm (t - s + s)", "by simp"], ["proof (state)\nthis:\n  deg_pm t = deg_pm (t - s + s)\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) = deg_pm t - deg_pm s", "also"], ["proof (state)\nthis:\n  deg_pm t = deg_pm (t - s + s)\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) = deg_pm t - deg_pm s", "have \"\\<dots> = deg_pm (t - s) + deg_pm s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (t - s + s) = deg_pm (t - s) + deg_pm s", "by (simp only: deg_pm_plus)"], ["proof (state)\nthis:\n  deg_pm (t - s + s) = deg_pm (t - s) + deg_pm s\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) = deg_pm t - deg_pm s", "finally"], ["proof (chain)\npicking this:\n  deg_pm t = deg_pm (t - s) + deg_pm s", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t = deg_pm (t - s) + deg_pm s\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) = deg_pm t - deg_pm s", "by simp"], ["proof (state)\nthis:\n  deg_pm (t - s) = deg_pm t - deg_pm s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adds_group [simp]: \"s adds (t::'a \\<Rightarrow>\\<^sub>0 'b::ab_group_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds t", "proof (rule addsI)"], ["proof (state)\ngoal (1 subgoal):\n 1. t = s + ?k", "show \"t = s + (t - s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = s + (t - s)", "by simp"], ["proof (state)\nthis:\n  t = s + (t - s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas deg_pm_minus_group = deg_pm_minus[OF adds_group]"], ["", "lemma deg_pm_minus_le: \"deg_pm (t - s) \\<le> deg_pm (t::_ \\<Rightarrow>\\<^sub>0 nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (t - s) \\<le> deg_pm t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm (t - s) \\<le> deg_pm t", "have \"keys (t - s) \\<subseteq> keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (t - s) \\<subseteq> keys t", "by (rule, simp add: lookup_minus in_keys_iff)"], ["proof (state)\nthis:\n  keys (t - s) \\<subseteq> keys t\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) \\<le> deg_pm t", "hence \"deg_pm (t - s) = (\\<Sum>x\\<in>keys t. lookup (t - s) x)\""], ["proof (prove)\nusing this:\n  keys (t - s) \\<subseteq> keys t\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) = sum (lookup (t - s)) (keys t)", "using finite_keys"], ["proof (prove)\nusing this:\n  keys (t - s) \\<subseteq> keys t\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) = sum (lookup (t - s)) (keys t)", "by (rule deg_pm_superset)"], ["proof (state)\nthis:\n  deg_pm (t - s) = sum (lookup (t - s)) (keys t)\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) \\<le> deg_pm t", "also"], ["proof (state)\nthis:\n  deg_pm (t - s) = sum (lookup (t - s)) (keys t)\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) \\<le> deg_pm t", "have \"\\<dots> \\<le> (\\<Sum>x\\<in>keys t. lookup t x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup (t - s)) (keys t) \\<le> sum (lookup t) (keys t)", "by (rule sum_mono) (simp add: lookup_minus)"], ["proof (state)\nthis:\n  sum (lookup (t - s)) (keys t) \\<le> sum (lookup t) (keys t)\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) \\<le> deg_pm t", "also"], ["proof (state)\nthis:\n  sum (lookup (t - s)) (keys t) \\<le> sum (lookup t) (keys t)\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) \\<le> deg_pm t", "have \"\\<dots> = deg_pm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup t) (keys t) = deg_pm t", "by (rule sym, rule deg_pm_superset, fact subset_refl, fact finite_keys)"], ["proof (state)\nthis:\n  sum (lookup t) (keys t) = deg_pm t\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) \\<le> deg_pm t", "finally"], ["proof (chain)\npicking this:\n  deg_pm (t - s) \\<le> deg_pm t", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pm (t - s) \\<le> deg_pm t\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) \\<le> deg_pm t", "."], ["proof (state)\nthis:\n  deg_pm (t - s) \\<le> deg_pm t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minus_id_iff: \"t - s = t \\<longleftrightarrow> keys t \\<inter> keys (s::_ \\<Rightarrow>\\<^sub>0 nat) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t - s = t) = (keys t \\<inter> keys s = {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t - s = t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "assume \"t - s = t\""], ["proof (state)\nthis:\n  t - s = t\n\ngoal (2 subgoals):\n 1. t - s = t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "{"], ["proof (state)\nthis:\n  t - s = t\n\ngoal (2 subgoals):\n 1. t - s = t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. t - s = t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "assume \"x \\<in> keys t\" and \"x \\<in> keys s\""], ["proof (state)\nthis:\n  x \\<in> keys t\n  x \\<in> keys s\n\ngoal (2 subgoals):\n 1. t - s = t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "hence \"0 < lookup t x\" and \"0 < lookup s x\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n  x \\<in> keys s\n\ngoal (1 subgoal):\n 1. 0 < lookup t x &&& 0 < lookup s x", "by (simp_all add: in_keys_iff)"], ["proof (state)\nthis:\n  0 < lookup t x\n  0 < lookup s x\n\ngoal (2 subgoals):\n 1. t - s = t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "hence \"lookup (t - s) x \\<noteq> lookup t x\""], ["proof (prove)\nusing this:\n  0 < lookup t x\n  0 < lookup s x\n\ngoal (1 subgoal):\n 1. lookup (t - s) x \\<noteq> lookup t x", "by (simp add: lookup_minus)"], ["proof (state)\nthis:\n  lookup (t - s) x \\<noteq> lookup t x\n\ngoal (2 subgoals):\n 1. t - s = t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "with \\<open>t - s = t\\<close>"], ["proof (chain)\npicking this:\n  t - s = t\n  lookup (t - s) x \\<noteq> lookup t x", "have False"], ["proof (prove)\nusing this:\n  t - s = t\n  lookup (t - s) x \\<noteq> lookup t x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. t - s = t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> keys t; ?x2 \\<in> keys s\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. t - s = t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "thus \"keys t \\<inter> keys s = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2 \\<in> keys t; ?x2 \\<in> keys s\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. keys t \\<inter> keys s = {}", "by blast"], ["proof (state)\nthis:\n  keys t \\<inter> keys s = {}\n\ngoal (1 subgoal):\n 1. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "assume *: \"keys t \\<inter> keys s = {}\""], ["proof (state)\nthis:\n  keys t \\<inter> keys s = {}\n\ngoal (1 subgoal):\n 1. keys t \\<inter> keys s = {} \\<Longrightarrow> t - s = t", "show \"t - s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t - s = t", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (t - s) k = lookup t k", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (t - s) k = lookup t k", "have \"lookup t x - lookup s x = lookup t x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup t x - lookup s x = lookup t x", "proof (cases \"x \\<in> keys t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> keys t \\<Longrightarrow> lookup t x - lookup s x = lookup t x\n 2. x \\<notin> keys t \\<Longrightarrow> lookup t x - lookup s x = lookup t x", "case True"], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (2 subgoals):\n 1. x \\<in> keys t \\<Longrightarrow> lookup t x - lookup s x = lookup t x\n 2. x \\<notin> keys t \\<Longrightarrow> lookup t x - lookup s x = lookup t x", "with *"], ["proof (chain)\npicking this:\n  keys t \\<inter> keys s = {}\n  x \\<in> keys t", "have \"x \\<notin> keys s\""], ["proof (prove)\nusing this:\n  keys t \\<inter> keys s = {}\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<notin> keys s", "by blast"], ["proof (state)\nthis:\n  x \\<notin> keys s\n\ngoal (2 subgoals):\n 1. x \\<in> keys t \\<Longrightarrow> lookup t x - lookup s x = lookup t x\n 2. x \\<notin> keys t \\<Longrightarrow> lookup t x - lookup s x = lookup t x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> keys s\n\ngoal (1 subgoal):\n 1. lookup t x - lookup s x = lookup t x", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup t x - lookup s x = lookup t x\n\ngoal (1 subgoal):\n 1. x \\<notin> keys t \\<Longrightarrow> lookup t x - lookup s x = lookup t x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> keys t \\<Longrightarrow> lookup t x - lookup s x = lookup t x", "case False"], ["proof (state)\nthis:\n  x \\<notin> keys t\n\ngoal (1 subgoal):\n 1. x \\<notin> keys t \\<Longrightarrow> lookup t x - lookup s x = lookup t x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> keys t\n\ngoal (1 subgoal):\n 1. lookup t x - lookup s x = lookup t x", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup t x - lookup s x = lookup t x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup t x - lookup s x = lookup t x\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup (t - s) k = lookup t k", "thus \"lookup (t - s) x = lookup t x\""], ["proof (prove)\nusing this:\n  lookup t x - lookup s x = lookup t x\n\ngoal (1 subgoal):\n 1. lookup (t - s) x = lookup t x", "by (simp only: lookup_minus)"], ["proof (state)\nthis:\n  lookup (t - s) x = lookup t x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t - s = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deg_pm_minus_id_iff: \"deg_pm (t - s) = deg_pm t \\<longleftrightarrow> keys t \\<inter> keys (s::_ \\<Rightarrow>\\<^sub>0 nat) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (deg_pm (t - s) = deg_pm t) = (keys t \\<inter> keys s = {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "assume eq: \"deg_pm (t - s) = deg_pm t\""], ["proof (state)\nthis:\n  deg_pm (t - s) = deg_pm t\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "{"], ["proof (state)\nthis:\n  deg_pm (t - s) = deg_pm t\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "assume \"x \\<in> keys t\" and \"x \\<in> keys s\""], ["proof (state)\nthis:\n  x \\<in> keys t\n  x \\<in> keys s\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "hence \"0 < lookup t x\" and \"0 < lookup s x\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n  x \\<in> keys s\n\ngoal (1 subgoal):\n 1. 0 < lookup t x &&& 0 < lookup s x", "by (simp_all add: in_keys_iff)"], ["proof (state)\nthis:\n  0 < lookup t x\n  0 < lookup s x\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "hence *: \"lookup (t - s) x < lookup t x\""], ["proof (prove)\nusing this:\n  0 < lookup t x\n  0 < lookup s x\n\ngoal (1 subgoal):\n 1. lookup (t - s) x < lookup t x", "by (simp add: lookup_minus)"], ["proof (state)\nthis:\n  lookup (t - s) x < lookup t x\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "have \"keys (t - s) \\<subseteq> keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (t - s) \\<subseteq> keys t", "by (rule, simp add: lookup_minus in_keys_iff)"], ["proof (state)\nthis:\n  keys (t - s) \\<subseteq> keys t\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "hence \"deg_pm (t - s) = (\\<Sum>x\\<in>keys t. lookup (t - s) x)\""], ["proof (prove)\nusing this:\n  keys (t - s) \\<subseteq> keys t\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) = sum (lookup (t - s)) (keys t)", "using finite_keys"], ["proof (prove)\nusing this:\n  keys (t - s) \\<subseteq> keys t\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) = sum (lookup (t - s)) (keys t)", "by (rule deg_pm_superset)"], ["proof (state)\nthis:\n  deg_pm (t - s) = sum (lookup (t - s)) (keys t)\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "also"], ["proof (state)\nthis:\n  deg_pm (t - s) = sum (lookup (t - s)) (keys t)\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"\\<dots> < (\\<Sum>x\\<in>keys t. lookup t x)\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. sum (lookup (t - s)) (keys t) < sum (lookup t) (keys t)", "proof (rule sum_strict_mono_ex1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>keys t. lookup (t - s) x \\<le> lookup t x\n 2. \\<exists>a\\<in>keys t. lookup (t - s) a < lookup t a", "show \"\\<forall>x\\<in>keys t. lookup (t - s) x \\<le> lookup t x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>keys t. lookup (t - s) x \\<le> lookup t x", "by (simp add: lookup_minus)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>keys t. lookup (t - s) x \\<le> lookup t x\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>keys t. lookup (t - s) a < lookup t a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>keys t. lookup (t - s) a < lookup t a", "from \\<open>x \\<in> keys t\\<close> *"], ["proof (chain)\npicking this:\n  x \\<in> keys t\n  lookup (t - s) x < lookup t x", "show \"\\<exists>x\\<in>keys t. lookup (t - s) x < lookup t x\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n  lookup (t - s) x < lookup t x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>keys t. lookup (t - s) x < lookup t x", ".."], ["proof (state)\nthis:\n  \\<exists>x\\<in>keys t. lookup (t - s) x < lookup t x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (lookup (t - s)) (keys t) < sum (lookup t) (keys t)\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "also"], ["proof (state)\nthis:\n  sum (lookup (t - s)) (keys t) < sum (lookup t) (keys t)\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "have \"\\<dots> = deg_pm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup t) (keys t) = deg_pm t", "by (rule sym, rule deg_pm_superset, fact subset_refl, fact finite_keys)"], ["proof (state)\nthis:\n  sum (lookup t) (keys t) = deg_pm t\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "finally"], ["proof (chain)\npicking this:\n  deg_pm (t - s) < deg_pm t", "have False"], ["proof (prove)\nusing this:\n  deg_pm (t - s) < deg_pm t\n\ngoal (1 subgoal):\n 1. False", "by (simp add: eq)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> keys t; ?x2 \\<in> keys s\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. deg_pm (t - s) = deg_pm t \\<Longrightarrow> keys t \\<inter> keys s = {}\n 2. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "thus \"keys t \\<inter> keys s = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2 \\<in> keys t; ?x2 \\<in> keys s\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. keys t \\<inter> keys s = {}", "by blast"], ["proof (state)\nthis:\n  keys t \\<inter> keys s = {}\n\ngoal (1 subgoal):\n 1. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "assume \"keys t \\<inter> keys s = {}\""], ["proof (state)\nthis:\n  keys t \\<inter> keys s = {}\n\ngoal (1 subgoal):\n 1. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "hence \"t - s = t\""], ["proof (prove)\nusing this:\n  keys t \\<inter> keys s = {}\n\ngoal (1 subgoal):\n 1. t - s = t", "by (simp only: minus_id_iff)"], ["proof (state)\nthis:\n  t - s = t\n\ngoal (1 subgoal):\n 1. keys t \\<inter> keys s = {} \\<Longrightarrow> deg_pm (t - s) = deg_pm t", "thus \"deg_pm (t - s) = deg_pm t\""], ["proof (prove)\nusing this:\n  t - s = t\n\ngoal (1 subgoal):\n 1. deg_pm (t - s) = deg_pm t", "by (simp only:)"], ["proof (state)\nthis:\n  deg_pm (t - s) = deg_pm t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition poly_deg :: \"(('x \\<Rightarrow>\\<^sub>0 'a::add_linorder) \\<Rightarrow>\\<^sub>0 'b::zero) \\<Rightarrow> 'a\" where\n  \"poly_deg p = (if keys p = {} then 0 else Max (deg_pm ` keys p))\""], ["", "definition maxdeg :: \"(('x \\<Rightarrow>\\<^sub>0 'a::add_linorder) \\<Rightarrow>\\<^sub>0 'b::zero) set \\<Rightarrow> 'a\" where\n  \"maxdeg A = Max (poly_deg ` A)\""], ["", "definition mindeg :: \"(('x \\<Rightarrow>\\<^sub>0 'a::add_linorder) \\<Rightarrow>\\<^sub>0 'b::zero) set \\<Rightarrow> 'a\" where\n  \"mindeg A = Min (poly_deg ` A)\""], ["", "lemma poly_deg_monomial: \"poly_deg (monomial c t) = (if c = 0 then 0 else deg_pm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (monomial c t) = (if c = (0::'c) then 0::'a else deg_pm t)", "by (simp add: poly_deg_def)"], ["", "lemma poly_deg_monomial_zero [simp]: \"poly_deg (monomial c 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (monomial c 0) = (0::'a)", "by (simp add: poly_deg_monomial)"], ["", "lemma poly_deg_zero [simp]: \"poly_deg 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg 0 = (0::'a)", "by (simp only: single_zero[of 0, symmetric] poly_deg_monomial_zero)"], ["", "lemma poly_deg_one [simp]: \"poly_deg 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg 1 = (0::'a)", "by (simp only: single_one[symmetric] poly_deg_monomial_zero)"], ["", "lemma poly_degE:\n  assumes \"p \\<noteq> 0\"\n  obtains t where \"t \\<in> keys p\" and \"poly_deg p = deg_pm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; poly_deg p = deg_pm t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; poly_deg p = deg_pm t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"poly_deg p = Max (deg_pm ` keys p)\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg p = Max (deg_pm ` keys p)", "by (simp add: poly_deg_def)"], ["proof (state)\nthis:\n  poly_deg p = Max (deg_pm ` keys p)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; poly_deg p = deg_pm t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  poly_deg p = Max (deg_pm ` keys p)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; poly_deg p = deg_pm t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> \\<in> deg_pm ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (deg_pm ` keys p) \\<in> deg_pm ` keys p", "proof (rule Max_in)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (deg_pm ` keys p)\n 2. deg_pm ` keys p \\<noteq> {}", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "show \"deg_pm ` keys p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. deg_pm ` keys p \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  deg_pm ` keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite (deg_pm ` keys p)", "qed simp"], ["proof (state)\nthis:\n  Max (deg_pm ` keys p) \\<in> deg_pm ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; poly_deg p = deg_pm t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  poly_deg p \\<in> deg_pm ` keys p", "obtain t where \"t \\<in> keys p\" and \"poly_deg p = deg_pm t\""], ["proof (prove)\nusing this:\n  poly_deg p \\<in> deg_pm ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; poly_deg p = deg_pm t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t \\<in> keys p\n  poly_deg p = deg_pm t\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; poly_deg p = deg_pm t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  poly_deg p = deg_pm t\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_max_keys: \"t \\<in> keys p \\<Longrightarrow> deg_pm t \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> keys p \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "using finite_keys"], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. t \\<in> keys p \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "by (auto simp: poly_deg_def)"], ["", "lemma poly_deg_leI: \"(\\<And>t. t \\<in> keys p \\<Longrightarrow> deg_pm t \\<le> (d::'a::add_linorder_min)) \\<Longrightarrow> poly_deg p \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> keys p \\<Longrightarrow> deg_pm t \\<le> d) \\<Longrightarrow>\n    poly_deg p \\<le> d", "using finite_keys"], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> keys p \\<Longrightarrow> deg_pm t \\<le> d) \\<Longrightarrow>\n    poly_deg p \\<le> d", "by (auto simp: poly_deg_def)"], ["", "lemma poly_deg_lessI:\n  \"p \\<noteq> 0 \\<Longrightarrow> (\\<And>t. t \\<in> keys p \\<Longrightarrow> deg_pm t < (d::'a::add_linorder_min)) \\<Longrightarrow> poly_deg p < d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     \\<And>t. t \\<in> keys p \\<Longrightarrow> deg_pm t < d\\<rbrakk>\n    \\<Longrightarrow> poly_deg p < d", "using finite_keys"], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     \\<And>t. t \\<in> keys p \\<Longrightarrow> deg_pm t < d\\<rbrakk>\n    \\<Longrightarrow> poly_deg p < d", "by (auto simp: poly_deg_def)"], ["", "lemma poly_deg_zero_imp_monomial:\n  assumes \"poly_deg p = (0::'a::add_linorder_min)\"\n  shows \"monomial (lookup p 0) 0 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (lookup p 0) 0 = p", "proof (rule keys_subset_singleton_imp_monomial, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> {0}", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> {0}", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> {0}", "have \"t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "assume \"t \\<noteq> 0\""], ["proof (state)\nthis:\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "hence \"deg_pm t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. deg_pm t \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  deg_pm t \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "hence \"0 < deg_pm t\""], ["proof (prove)\nusing this:\n  deg_pm t \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) < deg_pm t", "using not_gr_zero"], ["proof (prove)\nusing this:\n  deg_pm t \\<noteq> (0::'a)\n  (\\<not> (0::?'a) < ?n) = (?n = (0::?'a))\n\ngoal (1 subgoal):\n 1. (0::'a) < deg_pm t", "by blast"], ["proof (state)\nthis:\n  (0::'a) < deg_pm t\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (0::'a) < deg_pm t\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "from \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys p", "have \"... \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (0::'a) < poly_deg p", "have \"poly_deg p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (0::'a) < poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg p \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  poly_deg p \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "from this assms"], ["proof (chain)\npicking this:\n  poly_deg p \\<noteq> (0::'a)\n  poly_deg p = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  poly_deg p \\<noteq> (0::'a)\n  poly_deg p = (0::'a)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> {0}", "thus \"t \\<in> {0}\""], ["proof (prove)\nusing this:\n  t = 0\n\ngoal (1 subgoal):\n 1. t \\<in> {0}", "by simp"], ["proof (state)\nthis:\n  t \\<in> {0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_plus_le:\n  \"poly_deg (p + q) \\<le> max (poly_deg p) (poly_deg (q::(_ \\<Rightarrow>\\<^sub>0 'a::add_linorder_min) \\<Rightarrow>\\<^sub>0 _))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (p + q) \\<le> max (poly_deg p) (poly_deg q)", "proof (rule poly_deg_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p + q) \\<Longrightarrow>\n       deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p + q) \\<Longrightarrow>\n       deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "assume \"t \\<in> keys (p + q)\""], ["proof (state)\nthis:\n  t \\<in> keys (p + q)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p + q) \\<Longrightarrow>\n       deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "also"], ["proof (state)\nthis:\n  t \\<in> keys (p + q)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p + q) \\<Longrightarrow>\n       deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "have \"... \\<subseteq> keys p \\<union> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p + q) \\<subseteq> keys p \\<union> keys q", "by (fact Poly_Mapping.keys_add)"], ["proof (state)\nthis:\n  keys (p + q) \\<subseteq> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p + q) \\<Longrightarrow>\n       deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "finally"], ["proof (chain)\npicking this:\n  t \\<in> keys p \\<union> keys q", "show \"deg_pm t \\<le> max (poly_deg p) (poly_deg q)\""], ["proof (prove)\nusing this:\n  t \\<in> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n 2. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n 2. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "hence \"deg_pm t \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n 2. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "by (simp add: le_max_iff_disj)"], ["proof (state)\nthis:\n  deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "assume \"t \\<in> keys q\""], ["proof (state)\nthis:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "hence \"deg_pm t \\<le> poly_deg q\""], ["proof (prove)\nusing this:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg q", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg q\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t \\<le> poly_deg q\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "by (simp add: le_max_iff_disj)"], ["proof (state)\nthis:\n  deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_uminus [simp]: \"poly_deg (-p) = poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (- p) = poly_deg p", "by (simp add: poly_deg_def keys_uminus)"], ["", "lemma poly_deg_minus_le:\n  \"poly_deg (p - q) \\<le> max (poly_deg p) (poly_deg (q::(_ \\<Rightarrow>\\<^sub>0 'a::add_linorder_min) \\<Rightarrow>\\<^sub>0 _))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (p - q) \\<le> max (poly_deg p) (poly_deg q)", "proof (rule poly_deg_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p - q) \\<Longrightarrow>\n       deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p - q) \\<Longrightarrow>\n       deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "assume \"t \\<in> keys (p - q)\""], ["proof (state)\nthis:\n  t \\<in> keys (p - q)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p - q) \\<Longrightarrow>\n       deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "also"], ["proof (state)\nthis:\n  t \\<in> keys (p - q)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p - q) \\<Longrightarrow>\n       deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "have \"... \\<subseteq> keys p \\<union> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p - q) \\<subseteq> keys p \\<union> keys q", "by (fact keys_minus)"], ["proof (state)\nthis:\n  keys (p - q) \\<subseteq> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p - q) \\<Longrightarrow>\n       deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "finally"], ["proof (chain)\npicking this:\n  t \\<in> keys p \\<union> keys q", "show \"deg_pm t \\<le> max (poly_deg p) (poly_deg q)\""], ["proof (prove)\nusing this:\n  t \\<in> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n 2. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n 2. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "hence \"deg_pm t \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n 2. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "by (simp add: le_max_iff_disj)"], ["proof (state)\nthis:\n  deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "assume \"t \\<in> keys q\""], ["proof (state)\nthis:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "hence \"deg_pm t \\<le> poly_deg q\""], ["proof (prove)\nusing this:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg q", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg q\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow>\n    deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t \\<le> poly_deg q\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> max (poly_deg p) (poly_deg q)", "by (simp add: le_max_iff_disj)"], ["proof (state)\nthis:\n  deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pm t \\<le> max (poly_deg p) (poly_deg q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_times_le:\n  \"poly_deg (p * q) \\<le> poly_deg p + poly_deg (q::(_ \\<Rightarrow>\\<^sub>0 'a::add_linorder_min) \\<Rightarrow>\\<^sub>0 _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (p * q) \\<le> poly_deg p + poly_deg q", "proof (rule poly_deg_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p * q) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p + poly_deg q", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p * q) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p + poly_deg q", "assume \"t \\<in> keys (p * q)\""], ["proof (state)\nthis:\n  t \\<in> keys (p * q)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p * q) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p + poly_deg q", "then"], ["proof (chain)\npicking this:\n  t \\<in> keys (p * q)", "obtain u v where \"u \\<in> keys p\" and \"v \\<in> keys q\" and \"t = u + v\""], ["proof (prove)\nusing this:\n  t \\<in> keys (p * q)\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q; t = u + v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_timesE)"], ["proof (state)\nthis:\n  u \\<in> keys p\n  v \\<in> keys q\n  t = u + v\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p * q) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p + poly_deg q", "from \\<open>u \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> keys p", "have \"deg_pm u \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  u \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm u \\<le> poly_deg p", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm u \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p * q) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p + poly_deg q", "moreover"], ["proof (state)\nthis:\n  deg_pm u \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p * q) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p + poly_deg q", "from \\<open>v \\<in> keys q\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> keys q", "have \"deg_pm v \\<le> poly_deg q\""], ["proof (prove)\nusing this:\n  v \\<in> keys q\n\ngoal (1 subgoal):\n 1. deg_pm v \\<le> poly_deg q", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm v \\<le> poly_deg q\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (p * q) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p + poly_deg q", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm u \\<le> poly_deg p\n  deg_pm v \\<le> poly_deg q", "show \"deg_pm t \\<le> poly_deg p + poly_deg q\""], ["proof (prove)\nusing this:\n  deg_pm u \\<le> poly_deg p\n  deg_pm v \\<le> poly_deg q\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p + poly_deg q", "by (simp add: \\<open>t = u + v\\<close> deg_pm_plus add_mono)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p + poly_deg q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_times:\n  assumes \"p \\<noteq> 0\" and \"q \\<noteq> (0::('x::linorder \\<Rightarrow>\\<^sub>0 'a::add_linorder_min) \\<Rightarrow>\\<^sub>0 'b::semiring_no_zero_divisors)\"\n  shows \"poly_deg (p * q) = poly_deg p + poly_deg q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (p * q) = poly_deg p + poly_deg q", "using poly_deg_times_le"], ["proof (prove)\nusing this:\n  poly_deg (?p * ?q) \\<le> poly_deg ?p + poly_deg ?q\n\ngoal (1 subgoal):\n 1. poly_deg (p * q) = poly_deg p + poly_deg q", "proof (rule antisym)"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "let ?A = \"\\<lambda>f. {u. deg_pm u < poly_deg f}\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "define p1 where \"p1 = except p (?A p)\""], ["proof (state)\nthis:\n  p1 = except p {u. deg_pm u < poly_deg p}\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "define p2 where \"p2 = except p (- ?A p)\""], ["proof (state)\nthis:\n  p2 = except p (- {u. deg_pm u < poly_deg p})\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "define q1 where \"q1 = except q (?A q)\""], ["proof (state)\nthis:\n  q1 = except q {u. deg_pm u < poly_deg q}\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "define q2 where \"q2 = except q (- ?A q)\""], ["proof (state)\nthis:\n  q2 = except q (- {u. deg_pm u < poly_deg q})\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "have deg_p1: \"deg_pm t = poly_deg p\" if \"t \\<in> keys p1\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "from that"], ["proof (chain)\npicking this:\n  t \\<in> keys p1", "have \"t \\<in> keys p\" and \"poly_deg p \\<le> deg_pm t\""], ["proof (prove)\nusing this:\n  t \\<in> keys p1\n\ngoal (1 subgoal):\n 1. t \\<in> keys p &&& poly_deg p \\<le> deg_pm t", "by (simp_all add: p1_def keys_except not_less)"], ["proof (state)\nthis:\n  t \\<in> keys p\n  poly_deg p \\<le> deg_pm t\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "from this(1)"], ["proof (chain)\npicking this:\n  t \\<in> keys p", "have \"deg_pm t \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "using \\<open>poly_deg p \\<le> deg_pm t\\<close>"], ["proof (prove)\nusing this:\n  deg_pm t \\<le> poly_deg p\n  poly_deg p \\<le> deg_pm t\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule antisym)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t1 \\<in> keys p1 \\<Longrightarrow> deg_pm ?t1 = poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "have deg_p2: \"t \\<in> keys p2 \\<Longrightarrow> deg_pm t < poly_deg p\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> keys p2 \\<Longrightarrow> deg_pm t < poly_deg p", "by (simp add: p2_def keys_except)"], ["proof (state)\nthis:\n  ?t1 \\<in> keys p2 \\<Longrightarrow> deg_pm ?t1 < poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "have deg_q1: \"deg_pm t = poly_deg q\" if \"t \\<in> keys q1\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg q", "from that"], ["proof (chain)\npicking this:\n  t \\<in> keys q1", "have \"t \\<in> keys q\" and \"poly_deg q \\<le> deg_pm t\""], ["proof (prove)\nusing this:\n  t \\<in> keys q1\n\ngoal (1 subgoal):\n 1. t \\<in> keys q &&& poly_deg q \\<le> deg_pm t", "by (simp_all add: q1_def keys_except not_less)"], ["proof (state)\nthis:\n  t \\<in> keys q\n  poly_deg q \\<le> deg_pm t\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg q", "from this(1)"], ["proof (chain)\npicking this:\n  t \\<in> keys q", "have \"deg_pm t \\<le> poly_deg q\""], ["proof (prove)\nusing this:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg q", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg q\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg q", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t \\<le> poly_deg q\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg q", "using \\<open>poly_deg q \\<le> deg_pm t\\<close>"], ["proof (prove)\nusing this:\n  deg_pm t \\<le> poly_deg q\n  poly_deg q \\<le> deg_pm t\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg q", "by (rule antisym)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t1 \\<in> keys q1 \\<Longrightarrow> deg_pm ?t1 = poly_deg q\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "have deg_q2: \"t \\<in> keys q2 \\<Longrightarrow> deg_pm t < poly_deg q\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> keys q2 \\<Longrightarrow> deg_pm t < poly_deg q", "by (simp add: q2_def keys_except)"], ["proof (state)\nthis:\n  ?t1 \\<in> keys q2 \\<Longrightarrow> deg_pm ?t1 < poly_deg q\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "have p: \"p = p1 + p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p1 + p2", "unfolding p1_def p2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    except p {u. deg_pm u < poly_deg p} +\n    except p (- {u. deg_pm u < poly_deg p})", "by (fact except_decomp)"], ["proof (state)\nthis:\n  p = p1 + p2\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "have \"p1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p1 \\<noteq> 0", "from assms(1)"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "obtain t where \"t \\<in> keys p\" and \"poly_deg p = deg_pm t\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; poly_deg p = deg_pm t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_degE)"], ["proof (state)\nthis:\n  t \\<in> keys p\n  poly_deg p = deg_pm t\n\ngoal (1 subgoal):\n 1. p1 \\<noteq> 0", "hence \"t \\<in> keys p1\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  poly_deg p = deg_pm t\n\ngoal (1 subgoal):\n 1. t \\<in> keys p1", "by (simp add: p1_def keys_except)"], ["proof (state)\nthis:\n  t \\<in> keys p1\n\ngoal (1 subgoal):\n 1. p1 \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> keys p1\n\ngoal (1 subgoal):\n 1. p1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p1 \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "have q: \"q = q1 + q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = q1 + q2", "unfolding q1_def q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. q =\n    except q {u. deg_pm u < poly_deg q} +\n    except q (- {u. deg_pm u < poly_deg q})", "by (fact except_decomp)"], ["proof (state)\nthis:\n  q = q1 + q2\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "have \"q1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q1 \\<noteq> 0", "from assms(2)"], ["proof (chain)\npicking this:\n  q \\<noteq> 0", "obtain t where \"t \\<in> keys q\" and \"poly_deg q = deg_pm t\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys q; poly_deg q = deg_pm t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_degE)"], ["proof (state)\nthis:\n  t \\<in> keys q\n  poly_deg q = deg_pm t\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> 0", "hence \"t \\<in> keys q1\""], ["proof (prove)\nusing this:\n  t \\<in> keys q\n  poly_deg q = deg_pm t\n\ngoal (1 subgoal):\n 1. t \\<in> keys q1", "by (simp add: q1_def keys_except)"], ["proof (state)\nthis:\n  t \\<in> keys q1\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> keys q1\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q1 \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "with \\<open>p1 \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p1 \\<noteq> 0\n  q1 \\<noteq> 0", "have \"p1 * q1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p1 \\<noteq> 0\n  q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p1 * q1 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  p1 * q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "hence \"keys (p1 * q1) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p1 * q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys (p1 * q1) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys (p1 * q1) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "then"], ["proof (chain)\npicking this:\n  keys (p1 * q1) \\<noteq> {}", "obtain u where \"u \\<in> keys (p1 * q1)\""], ["proof (prove)\nusing this:\n  keys (p1 * q1) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<in> keys (p1 * q1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u \\<in> keys (p1 * q1)\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "then"], ["proof (chain)\npicking this:\n  u \\<in> keys (p1 * q1)", "obtain s t where \"s \\<in> keys p1\" and \"t \\<in> keys q1\" and u: \"u = s + t\""], ["proof (prove)\nusing this:\n  u \\<in> keys (p1 * q1)\n\ngoal (1 subgoal):\n 1. (\\<And>s t.\n        \\<lbrakk>s \\<in> keys p1; t \\<in> keys q1; u = s + t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_timesE)"], ["proof (state)\nthis:\n  s \\<in> keys p1\n  t \\<in> keys q1\n  u = s + t\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "from \\<open>s \\<in> keys p1\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p1", "have \"deg_pm s = poly_deg p\""], ["proof (prove)\nusing this:\n  s \\<in> keys p1\n\ngoal (1 subgoal):\n 1. deg_pm s = poly_deg p", "by (rule deg_p1)"], ["proof (state)\nthis:\n  deg_pm s = poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "moreover"], ["proof (state)\nthis:\n  deg_pm s = poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "from \\<open>t \\<in> keys q1\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys q1", "have \"deg_pm t = poly_deg q\""], ["proof (prove)\nusing this:\n  t \\<in> keys q1\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg q", "by (rule deg_q1)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg q\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm s = poly_deg p\n  deg_pm t = poly_deg q", "have eq: \"poly_deg p + poly_deg q = deg_pm u\""], ["proof (prove)\nusing this:\n  deg_pm s = poly_deg p\n  deg_pm t = poly_deg q\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q = deg_pm u", "by (simp only: u deg_pm_plus)"], ["proof (state)\nthis:\n  poly_deg p + poly_deg q = deg_pm u\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "also"], ["proof (state)\nthis:\n  poly_deg p + poly_deg q = deg_pm u\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "have \"\\<dots> \\<le> poly_deg (p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm u \\<le> poly_deg (p * q)", "proof (rule poly_deg_max_keys)"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> keys (p * q)", "have \"u \\<notin> keys (p1 * q2 + p2 * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> keys (p1 * q2 + p2 * q)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> keys (p1 * q2 + p2 * q) \\<Longrightarrow> False", "assume \"u \\<in> keys (p1 * q2 + p2 * q)\""], ["proof (state)\nthis:\n  u \\<in> keys (p1 * q2 + p2 * q)\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p1 * q2 + p2 * q) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  u \\<in> keys (p1 * q2 + p2 * q)\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p1 * q2 + p2 * q) \\<Longrightarrow> False", "have \"\\<dots> \\<subseteq> keys (p1 * q2) \\<union> keys (p2 * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p1 * q2 + p2 * q)\n    \\<subseteq> keys (p1 * q2) \\<union> keys (p2 * q)", "by (rule Poly_Mapping.keys_add)"], ["proof (state)\nthis:\n  keys (p1 * q2 + p2 * q) \\<subseteq> keys (p1 * q2) \\<union> keys (p2 * q)\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p1 * q2 + p2 * q) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  u \\<in> keys (p1 * q2) \\<union> keys (p2 * q)", "have \"deg_pm u < poly_deg p + poly_deg q\""], ["proof (prove)\nusing this:\n  u \\<in> keys (p1 * q2) \\<union> keys (p2 * q)\n\ngoal (1 subgoal):\n 1. deg_pm u < poly_deg p + poly_deg q", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> keys (p1 * q2) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q\n 2. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "assume \"u \\<in> keys (p1 * q2)\""], ["proof (state)\nthis:\n  u \\<in> keys (p1 * q2)\n\ngoal (2 subgoals):\n 1. u \\<in> keys (p1 * q2) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q\n 2. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "then"], ["proof (chain)\npicking this:\n  u \\<in> keys (p1 * q2)", "obtain s' t' where \"s' \\<in> keys p1\" and \"t' \\<in> keys q2\" and u: \"u = s' + t'\""], ["proof (prove)\nusing this:\n  u \\<in> keys (p1 * q2)\n\ngoal (1 subgoal):\n 1. (\\<And>s' t'.\n        \\<lbrakk>s' \\<in> keys p1; t' \\<in> keys q2; u = s' + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_timesE)"], ["proof (state)\nthis:\n  s' \\<in> keys p1\n  t' \\<in> keys q2\n  u = s' + t'\n\ngoal (2 subgoals):\n 1. u \\<in> keys (p1 * q2) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q\n 2. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "from \\<open>s' \\<in> keys p1\\<close>"], ["proof (chain)\npicking this:\n  s' \\<in> keys p1", "have \"deg_pm s' = poly_deg p\""], ["proof (prove)\nusing this:\n  s' \\<in> keys p1\n\ngoal (1 subgoal):\n 1. deg_pm s' = poly_deg p", "by (rule deg_p1)"], ["proof (state)\nthis:\n  deg_pm s' = poly_deg p\n\ngoal (2 subgoals):\n 1. u \\<in> keys (p1 * q2) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q\n 2. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "moreover"], ["proof (state)\nthis:\n  deg_pm s' = poly_deg p\n\ngoal (2 subgoals):\n 1. u \\<in> keys (p1 * q2) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q\n 2. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "from \\<open>t' \\<in> keys q2\\<close>"], ["proof (chain)\npicking this:\n  t' \\<in> keys q2", "have \"deg_pm t' < poly_deg q\""], ["proof (prove)\nusing this:\n  t' \\<in> keys q2\n\ngoal (1 subgoal):\n 1. deg_pm t' < poly_deg q", "by (rule deg_q2)"], ["proof (state)\nthis:\n  deg_pm t' < poly_deg q\n\ngoal (2 subgoals):\n 1. u \\<in> keys (p1 * q2) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q\n 2. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm s' = poly_deg p\n  deg_pm t' < poly_deg q", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pm s' = poly_deg p\n  deg_pm t' < poly_deg q\n\ngoal (1 subgoal):\n 1. deg_pm u < poly_deg p + poly_deg q", "by (simp add: u deg_pm_plus)"], ["proof (state)\nthis:\n  deg_pm u < poly_deg p + poly_deg q\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "assume \"u \\<in> keys (p2 * q)\""], ["proof (state)\nthis:\n  u \\<in> keys (p2 * q)\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "then"], ["proof (chain)\npicking this:\n  u \\<in> keys (p2 * q)", "obtain s' t' where \"s' \\<in> keys p2\" and \"t' \\<in> keys q\" and u: \"u = s' + t'\""], ["proof (prove)\nusing this:\n  u \\<in> keys (p2 * q)\n\ngoal (1 subgoal):\n 1. (\\<And>s' t'.\n        \\<lbrakk>s' \\<in> keys p2; t' \\<in> keys q; u = s' + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_timesE)"], ["proof (state)\nthis:\n  s' \\<in> keys p2\n  t' \\<in> keys q\n  u = s' + t'\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "from \\<open>s' \\<in> keys p2\\<close>"], ["proof (chain)\npicking this:\n  s' \\<in> keys p2", "have \"deg_pm s' < poly_deg p\""], ["proof (prove)\nusing this:\n  s' \\<in> keys p2\n\ngoal (1 subgoal):\n 1. deg_pm s' < poly_deg p", "by (rule deg_p2)"], ["proof (state)\nthis:\n  deg_pm s' < poly_deg p\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "moreover"], ["proof (state)\nthis:\n  deg_pm s' < poly_deg p\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "from \\<open>t' \\<in> keys q\\<close>"], ["proof (chain)\npicking this:\n  t' \\<in> keys q", "have \"deg_pm t' \\<le> poly_deg q\""], ["proof (prove)\nusing this:\n  t' \\<in> keys q\n\ngoal (1 subgoal):\n 1. deg_pm t' \\<le> poly_deg q", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t' \\<le> poly_deg q\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p2 * q) \\<Longrightarrow>\n    deg_pm u < poly_deg p + poly_deg q", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm s' < poly_deg p\n  deg_pm t' \\<le> poly_deg q", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pm s' < poly_deg p\n  deg_pm t' \\<le> poly_deg q\n\ngoal (1 subgoal):\n 1. deg_pm u < poly_deg p + poly_deg q", "by (simp add: u deg_pm_plus add_less_le_mono)"], ["proof (state)\nthis:\n  deg_pm u < poly_deg p + poly_deg q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pm u < poly_deg p + poly_deg q\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p1 * q2 + p2 * q) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  deg_pm u < poly_deg p + poly_deg q\n\ngoal (1 subgoal):\n 1. False", "by (simp only: eq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<notin> keys (p1 * q2 + p2 * q)\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p * q)", "with \\<open>u \\<in> keys (p1 * q1)\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> keys (p1 * q1)\n  u \\<notin> keys (p1 * q2 + p2 * q)", "have \"u \\<in> keys (p1 * q1 + (p1 * q2 + p2 * q))\""], ["proof (prove)\nusing this:\n  u \\<in> keys (p1 * q1)\n  u \\<notin> keys (p1 * q2 + p2 * q)\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p1 * q1 + (p1 * q2 + p2 * q))", "by (rule in_keys_plusI1)"], ["proof (state)\nthis:\n  u \\<in> keys (p1 * q1 + (p1 * q2 + p2 * q))\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p * q)", "thus \"u \\<in> keys (p * q)\""], ["proof (prove)\nusing this:\n  u \\<in> keys (p1 * q1 + (p1 * q2 + p2 * q))\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p * q)", "by (simp only: p q algebra_simps)"], ["proof (state)\nthis:\n  u \\<in> keys (p * q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pm u \\<le> poly_deg (p * q)\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "finally"], ["proof (chain)\npicking this:\n  poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "show \"poly_deg p + poly_deg q \\<le> poly_deg (p * q)\""], ["proof (prove)\nusing this:\n  poly_deg p + poly_deg q \\<le> poly_deg (p * q)\n\ngoal (1 subgoal):\n 1. poly_deg p + poly_deg q \\<le> poly_deg (p * q)", "."], ["proof (state)\nthis:\n  poly_deg p + poly_deg q \\<le> poly_deg (p * q)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary poly_deg_monom_mult_le:\n  \"poly_deg (punit.monom_mult c (t::_ \\<Rightarrow>\\<^sub>0 'a::add_linorder_min) p) \\<le> deg_pm t + poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (punit.monom_mult c t p) \\<le> deg_pm t + poly_deg p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg (punit.monom_mult c t p) \\<le> deg_pm t + poly_deg p", "have \"poly_deg (punit.monom_mult c t p) \\<le> poly_deg (monomial c t) + poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (punit.monom_mult c t p)\n    \\<le> poly_deg (monomial c t) + poly_deg p", "by (simp only: times_monomial_left[symmetric] poly_deg_times_le)"], ["proof (state)\nthis:\n  poly_deg (punit.monom_mult c t p)\n  \\<le> poly_deg (monomial c t) + poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg (punit.monom_mult c t p) \\<le> deg_pm t + poly_deg p", "also"], ["proof (state)\nthis:\n  poly_deg (punit.monom_mult c t p)\n  \\<le> poly_deg (monomial c t) + poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg (punit.monom_mult c t p) \\<le> deg_pm t + poly_deg p", "have \"... \\<le> deg_pm t + poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (monomial c t) + poly_deg p \\<le> deg_pm t + poly_deg p", "by (simp add: poly_deg_monomial)"], ["proof (state)\nthis:\n  poly_deg (monomial c t) + poly_deg p \\<le> deg_pm t + poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg (punit.monom_mult c t p) \\<le> deg_pm t + poly_deg p", "finally"], ["proof (chain)\npicking this:\n  poly_deg (punit.monom_mult c t p) \\<le> deg_pm t + poly_deg p", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg (punit.monom_mult c t p) \\<le> deg_pm t + poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg (punit.monom_mult c t p) \\<le> deg_pm t + poly_deg p", "."], ["proof (state)\nthis:\n  poly_deg (punit.monom_mult c t p) \\<le> deg_pm t + poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_monom_mult:\n  assumes \"c \\<noteq> 0\" and \"p \\<noteq> (0::(_ \\<Rightarrow>\\<^sub>0 'a::add_linorder_min) \\<Rightarrow>\\<^sub>0 'b::semiring_no_zero_divisors)\"\n  shows \"poly_deg (punit.monom_mult c t p) = deg_pm t + poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (punit.monom_mult c t p) = deg_pm t + poly_deg p", "proof (rule order.antisym, fact poly_deg_monom_mult_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg p \\<le> poly_deg (punit.monom_mult c t p)", "from assms(2)"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "obtain s where \"s \\<in> keys p\" and \"poly_deg p = deg_pm s\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; poly_deg p = deg_pm s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_degE)"], ["proof (state)\nthis:\n  s \\<in> keys p\n  poly_deg p = deg_pm s\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg p \\<le> poly_deg (punit.monom_mult c t p)", "have \"deg_pm t + poly_deg p = deg_pm (t + s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg p = deg_pm (t + s)", "by (simp add: \\<open>poly_deg p = deg_pm s\\<close> deg_pm_plus)"], ["proof (state)\nthis:\n  deg_pm t + poly_deg p = deg_pm (t + s)\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg p \\<le> poly_deg (punit.monom_mult c t p)", "also"], ["proof (state)\nthis:\n  deg_pm t + poly_deg p = deg_pm (t + s)\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg p \\<le> poly_deg (punit.monom_mult c t p)", "have \"... \\<le> poly_deg (punit.monom_mult c t p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (t + s) \\<le> poly_deg (punit.monom_mult c t p)", "proof (rule poly_deg_max_keys)"], ["proof (state)\ngoal (1 subgoal):\n 1. t + s \\<in> keys (punit.monom_mult c t p)", "from \\<open>s \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p", "show \"t + s \\<in> keys (punit.monom_mult c t p)\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. t + s \\<in> keys (punit.monom_mult c t p)", "unfolding punit.keys_monom_mult[OF assms(1)]"], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. t + s \\<in> punit.splus t ` keys p", "by fastforce"], ["proof (state)\nthis:\n  t + s \\<in> keys (punit.monom_mult c t p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pm (t + s) \\<le> poly_deg (punit.monom_mult c t p)\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg p \\<le> poly_deg (punit.monom_mult c t p)", "finally"], ["proof (chain)\npicking this:\n  deg_pm t + poly_deg p \\<le> poly_deg (punit.monom_mult c t p)", "show \"deg_pm t + poly_deg p \\<le> poly_deg (punit.monom_mult c t p)\""], ["proof (prove)\nusing this:\n  deg_pm t + poly_deg p \\<le> poly_deg (punit.monom_mult c t p)\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg p \\<le> poly_deg (punit.monom_mult c t p)", "."], ["proof (state)\nthis:\n  deg_pm t + poly_deg p \\<le> poly_deg (punit.monom_mult c t p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_map_scale:\n  \"poly_deg (c \\<cdot> p) = (if c = (0::_::semiring_no_zero_divisors) then 0 else poly_deg p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (c \\<cdot> p) = (if c = (0::'c) then 0::'a else poly_deg p)", "by (simp add: poly_deg_def keys_map_scale)"], ["", "lemma poly_deg_sum_le: \"((poly_deg (sum f A))::'a::add_linorder_min) \\<le> Max (poly_deg ` f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)", "proof (cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)\n 2. infinite A \\<Longrightarrow>\n    poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)\n 2. infinite A \\<Longrightarrow>\n    poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_deg (sum f {}) \\<le> Max (poly_deg ` f ` {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (sum f F) \\<le> Max (poly_deg ` f ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_deg (sum f (insert x F))\n                         \\<le> Max (poly_deg ` f ` insert x F)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. poly_deg (sum f {}) \\<le> Max (poly_deg ` f ` {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (sum f F) \\<le> Max (poly_deg ` f ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_deg (sum f (insert x F))\n                         \\<le> Max (poly_deg ` f ` insert x F)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (sum f {}) \\<le> Max (poly_deg ` f ` {})", "by simp"], ["proof (state)\nthis:\n  poly_deg (sum f {}) \\<le> Max (poly_deg ` f ` {})\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (sum f F) \\<le> Max (poly_deg ` f ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_deg (sum f (insert x F))\n                         \\<le> Max (poly_deg ` f ` insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (sum f F) \\<le> Max (poly_deg ` f ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_deg (sum f (insert x F))\n                         \\<le> Max (poly_deg ` f ` insert x F)", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (sum f F) \\<le> Max (poly_deg ` f ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_deg (sum f (insert x F))\n                         \\<le> Max (poly_deg ` f ` insert x F)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "proof (cases \"A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "case True"], ["proof (state)\nthis:\n  A = {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  A = {}\n\ngoal (1 subgoal):\n 1. poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "by simp"], ["proof (state)\nthis:\n  poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "case False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "have \"poly_deg (sum f (insert a A)) \\<le> max (poly_deg (f a)) (poly_deg (sum f A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (sum f (insert a A))\n    \\<le> max (poly_deg (f a)) (poly_deg (sum f A))", "by (simp only: comm_monoid_add_class.sum.insert[OF insert(1) insert(2)] poly_deg_plus_le)"], ["proof (state)\nthis:\n  poly_deg (sum f (insert a A))\n  \\<le> max (poly_deg (f a)) (poly_deg (sum f A))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "also"], ["proof (state)\nthis:\n  poly_deg (sum f (insert a A))\n  \\<le> max (poly_deg (f a)) (poly_deg (sum f A))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "have \"... \\<le> max (poly_deg (f a)) (Max (poly_deg ` f ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (poly_deg (f a)) (poly_deg (sum f A))\n    \\<le> max (poly_deg (f a)) (Max (poly_deg ` f ` A))", "using insert(3) max.mono"], ["proof (prove)\nusing this:\n  poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)\n  \\<lbrakk>?c \\<le> ?a; ?d \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> max ?c ?d \\<le> max ?a ?b\n\ngoal (1 subgoal):\n 1. max (poly_deg (f a)) (poly_deg (sum f A))\n    \\<le> max (poly_deg (f a)) (Max (poly_deg ` f ` A))", "by blast"], ["proof (state)\nthis:\n  max (poly_deg (f a)) (poly_deg (sum f A))\n  \\<le> max (poly_deg (f a)) (Max (poly_deg ` f ` A))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "also"], ["proof (state)\nthis:\n  max (poly_deg (f a)) (poly_deg (sum f A))\n  \\<le> max (poly_deg (f a)) (Max (poly_deg ` f ` A))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "have \"... = (Max (poly_deg ` f ` (insert a A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (poly_deg (f a)) (Max (poly_deg ` f ` A)) =\n    Max (poly_deg ` f ` insert a A)", "using False"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. max (poly_deg (f a)) (Max (poly_deg ` f ` A)) =\n    Max (poly_deg ` f ` insert a A)", "by (simp add: insert(1))"], ["proof (state)\nthis:\n  max (poly_deg (f a)) (Max (poly_deg ` f ` A)) =\n  Max (poly_deg ` f ` insert a A)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "finally"], ["proof (chain)\npicking this:\n  poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)\n\ngoal (1 subgoal):\n 1. poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)", "."], ["proof (state)\nthis:\n  poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg (sum f (insert a A)) \\<le> Max (poly_deg ` f ` insert a A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)", "case False"], ["proof (state)\nthis:\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)", "by simp"], ["proof (state)\nthis:\n  poly_deg (sum f A) \\<le> Max (poly_deg ` f ` A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_prod_le: \"((poly_deg (prod f A))::'a::add_linorder_min) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))", "proof (cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))\n 2. infinite A \\<Longrightarrow>\n    poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))\n 2. infinite A \\<Longrightarrow>\n    poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_deg (prod f {}) \\<le> (\\<Sum>a\\<in>{}. poly_deg (f a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (prod f F) \\<le> (\\<Sum>a\\<in>F. poly_deg (f a))\\<rbrakk>\n       \\<Longrightarrow> poly_deg (prod f (insert x F))\n                         \\<le> (\\<Sum>a\\<in>insert x F. poly_deg (f a))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. poly_deg (prod f {}) \\<le> (\\<Sum>a\\<in>{}. poly_deg (f a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (prod f F) \\<le> (\\<Sum>a\\<in>F. poly_deg (f a))\\<rbrakk>\n       \\<Longrightarrow> poly_deg (prod f (insert x F))\n                         \\<le> (\\<Sum>a\\<in>insert x F. poly_deg (f a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (prod f {}) \\<le> (\\<Sum>a\\<in>{}. poly_deg (f a))", "by simp"], ["proof (state)\nthis:\n  poly_deg (prod f {}) \\<le> (\\<Sum>a\\<in>{}. poly_deg (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (prod f F) \\<le> (\\<Sum>a\\<in>F. poly_deg (f a))\\<rbrakk>\n       \\<Longrightarrow> poly_deg (prod f (insert x F))\n                         \\<le> (\\<Sum>a\\<in>insert x F. poly_deg (f a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (prod f F) \\<le> (\\<Sum>a\\<in>F. poly_deg (f a))\\<rbrakk>\n       \\<Longrightarrow> poly_deg (prod f (insert x F))\n                         \\<le> (\\<Sum>a\\<in>insert x F. poly_deg (f a))", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (prod f F) \\<le> (\\<Sum>a\\<in>F. poly_deg (f a))\\<rbrakk>\n       \\<Longrightarrow> poly_deg (prod f (insert x F))\n                         \\<le> (\\<Sum>a\\<in>insert x F. poly_deg (f a))", "have \"poly_deg (prod f (insert a A)) \\<le> (poly_deg (f a)) + (poly_deg (prod f A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (prod f (insert a A))\n    \\<le> poly_deg (f a) + poly_deg (prod f A)", "by (simp only: comm_monoid_mult_class.prod.insert[OF insert(1) insert(2)] poly_deg_times_le)"], ["proof (state)\nthis:\n  poly_deg (prod f (insert a A)) \\<le> poly_deg (f a) + poly_deg (prod f A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (prod f F) \\<le> (\\<Sum>a\\<in>F. poly_deg (f a))\\<rbrakk>\n       \\<Longrightarrow> poly_deg (prod f (insert x F))\n                         \\<le> (\\<Sum>a\\<in>insert x F. poly_deg (f a))", "also"], ["proof (state)\nthis:\n  poly_deg (prod f (insert a A)) \\<le> poly_deg (f a) + poly_deg (prod f A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (prod f F) \\<le> (\\<Sum>a\\<in>F. poly_deg (f a))\\<rbrakk>\n       \\<Longrightarrow> poly_deg (prod f (insert x F))\n                         \\<le> (\\<Sum>a\\<in>insert x F. poly_deg (f a))", "have \"... \\<le> (poly_deg (f a)) + (\\<Sum>a\\<in>A. poly_deg (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (f a) + poly_deg (prod f A)\n    \\<le> poly_deg (f a) + (\\<Sum>a\\<in>A. poly_deg (f a))", "using insert(3) add_le_cancel_left"], ["proof (prove)\nusing this:\n  poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))\n  (?c + ?a \\<le> ?c + ?b) = (?a \\<le> ?b)\n\ngoal (1 subgoal):\n 1. poly_deg (f a) + poly_deg (prod f A)\n    \\<le> poly_deg (f a) + (\\<Sum>a\\<in>A. poly_deg (f a))", "by blast"], ["proof (state)\nthis:\n  poly_deg (f a) + poly_deg (prod f A)\n  \\<le> poly_deg (f a) + (\\<Sum>a\\<in>A. poly_deg (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (prod f F) \\<le> (\\<Sum>a\\<in>F. poly_deg (f a))\\<rbrakk>\n       \\<Longrightarrow> poly_deg (prod f (insert x F))\n                         \\<le> (\\<Sum>a\\<in>insert x F. poly_deg (f a))", "also"], ["proof (state)\nthis:\n  poly_deg (f a) + poly_deg (prod f A)\n  \\<le> poly_deg (f a) + (\\<Sum>a\\<in>A. poly_deg (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (prod f F) \\<le> (\\<Sum>a\\<in>F. poly_deg (f a))\\<rbrakk>\n       \\<Longrightarrow> poly_deg (prod f (insert x F))\n                         \\<le> (\\<Sum>a\\<in>insert x F. poly_deg (f a))", "have \"... = (\\<Sum>a\\<in>insert a A. poly_deg (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (f a) + (\\<Sum>a\\<in>A. poly_deg (f a)) =\n    (\\<Sum>a\\<in>insert a A. poly_deg (f a))", "by (simp add: insert(1) insert(2))"], ["proof (state)\nthis:\n  poly_deg (f a) + (\\<Sum>a\\<in>A. poly_deg (f a)) =\n  (\\<Sum>a\\<in>insert a A. poly_deg (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        poly_deg (prod f F) \\<le> (\\<Sum>a\\<in>F. poly_deg (f a))\\<rbrakk>\n       \\<Longrightarrow> poly_deg (prod f (insert x F))\n                         \\<le> (\\<Sum>a\\<in>insert x F. poly_deg (f a))", "finally"], ["proof (chain)\npicking this:\n  poly_deg (prod f (insert a A))\n  \\<le> (\\<Sum>a\\<in>insert a A. poly_deg (f a))", "show ?case"], ["proof (prove)\nusing this:\n  poly_deg (prod f (insert a A))\n  \\<le> (\\<Sum>a\\<in>insert a A. poly_deg (f a))\n\ngoal (1 subgoal):\n 1. poly_deg (prod f (insert a A))\n    \\<le> (\\<Sum>a\\<in>insert a A. poly_deg (f a))", "."], ["proof (state)\nthis:\n  poly_deg (prod f (insert a A))\n  \\<le> (\\<Sum>a\\<in>insert a A. poly_deg (f a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))", "case False"], ["proof (state)\nthis:\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))", "by simp"], ["proof (state)\nthis:\n  poly_deg (prod f A) \\<le> (\\<Sum>a\\<in>A. poly_deg (f a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maxdeg_max:\n  assumes \"finite A\" and \"p \\<in> A\"\n  shows \"poly_deg p \\<le> maxdeg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg p \\<le> maxdeg A", "unfolding maxdeg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg p \\<le> Max (poly_deg ` A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  p \\<in> A\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> Max (poly_deg ` A)", "by auto"], ["", "lemma mindeg_min:\n  assumes \"finite A\" and \"p \\<in> A\"\n  shows \"mindeg A \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mindeg A \\<le> poly_deg p", "unfolding mindeg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (poly_deg ` A) \\<le> poly_deg p", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  p \\<in> A\n\ngoal (1 subgoal):\n 1. Min (poly_deg ` A) \\<le> poly_deg p", "by auto"], ["", "subsection \\<open>Indeterminates\\<close>"], ["", "definition indets :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::zero) \\<Rightarrow> 'x set\"\n  where \"indets p = \\<Union> (keys ` keys p)\""], ["", "definition PPs :: \"'x set \\<Rightarrow> ('x \\<Rightarrow>\\<^sub>0 nat) set\"  (\".[(_)]\")\n  where \"PPs X = {t. keys t \\<subseteq> X}\""], ["", "definition Polys :: \"'x set \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::zero) set\"  (\"P[(_)]\")\n  where \"Polys X = {p. keys p \\<subseteq> .[X]}\""], ["", "subsubsection \\<open>@{const indets}\\<close>"], ["", "lemma in_indetsI:\n  assumes \"x \\<in> keys t\" and \"t \\<in> keys p\"\n  shows \"x \\<in> indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> indets p", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> keys t\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. x \\<in> indets p", "by (auto simp add: indets_def)"], ["", "lemma in_indetsE:\n  assumes \"x \\<in> indets p\"\n  obtains t where \"t \\<in> keys p\" and \"x \\<in> keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; x \\<in> keys t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; x \\<in> keys t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: indets_def)"], ["", "lemma keys_subset_indets: \"t \\<in> keys p \\<Longrightarrow> keys t \\<subseteq> indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> keys p \\<Longrightarrow> keys t \\<subseteq> indets p", "by (auto dest: in_indetsI)"], ["", "lemma indets_empty_imp_monomial:\n  assumes \"indets p = {}\"\n  shows \"monomial (lookup p 0) 0 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (lookup p 0) 0 = p", "proof (rule keys_subset_singleton_imp_monomial, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> {0}", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> {0}", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> {0}", "have \"t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "assume \"t \\<noteq> 0\""], ["proof (state)\nthis:\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "hence \"keys t \\<noteq> {}\""], ["proof (prove)\nusing this:\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys t \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  keys t \\<noteq> {}", "obtain x where \"x \\<in> keys t\""], ["proof (prove)\nusing this:\n  keys t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> keys t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "from this \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> keys t\n  t \\<in> keys p", "have \"x \\<in> indets p\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. x \\<in> indets p", "by (rule in_indetsI)"], ["proof (state)\nthis:\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  indets p = {}\n  x \\<in> indets p", "show False"], ["proof (prove)\nusing this:\n  indets p = {}\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> {0}", "thus \"t \\<in> {0}\""], ["proof (prove)\nusing this:\n  t = 0\n\ngoal (1 subgoal):\n 1. t \\<in> {0}", "by simp"], ["proof (state)\nthis:\n  t \\<in> {0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_indets: \"finite (indets p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (indets p)", "by (simp only: indets_def, rule finite_UN_I, (rule finite_keys)+)"], ["", "lemma indets_zero [simp]: \"indets 0 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets 0 = {}", "by (simp add: indets_def)"], ["", "lemma indets_one [simp]: \"indets 1 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets 1 = {}", "by (simp add: indets_def)"], ["", "lemma indets_monomial_single_subset: \"indets (monomial c (Poly_Mapping.single v k)) \\<subseteq> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (monomial c (monomial k v)) \\<subseteq> {v}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (monomial c (monomial k v)) \\<Longrightarrow>\n       x \\<in> {v}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (monomial c (monomial k v)) \\<Longrightarrow>\n       x \\<in> {v}", "assume \"x \\<in> indets (monomial c (Poly_Mapping.single v k))\""], ["proof (state)\nthis:\n  x \\<in> indets (monomial c (monomial k v))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (monomial c (monomial k v)) \\<Longrightarrow>\n       x \\<in> {v}", "then"], ["proof (chain)\npicking this:\n  x \\<in> indets (monomial c (monomial k v))", "have \"x = v\""], ["proof (prove)\nusing this:\n  x \\<in> indets (monomial c (monomial k v))\n\ngoal (1 subgoal):\n 1. x = v", "unfolding indets_def"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (keys ` keys (monomial c (monomial k v)))\n\ngoal (1 subgoal):\n 1. x = v", "by (metis UN_E lookup_eq_zero_in_keys_contradict lookup_single_not_eq)"], ["proof (state)\nthis:\n  x = v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (monomial c (monomial k v)) \\<Longrightarrow>\n       x \\<in> {v}", "thus \"x \\<in> {v}\""], ["proof (prove)\nusing this:\n  x = v\n\ngoal (1 subgoal):\n 1. x \\<in> {v}", "by simp"], ["proof (state)\nthis:\n  x \\<in> {v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_monomial_single:\n  assumes \"c \\<noteq> 0\" and \"k \\<noteq> 0\"\n  shows \"indets (monomial c (Poly_Mapping.single v k)) = {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (monomial c (monomial k v)) = {v}", "proof (rule, fact indets_monomial_single_subset, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> indets (monomial c (monomial k v))", "from assms"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)\n  k \\<noteq> 0", "show \"v \\<in> indets (monomial c (monomial k v))\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<in> indets (monomial c (monomial k v))", "by (simp add: indets_def)"], ["proof (state)\nthis:\n  v \\<in> indets (monomial c (monomial k v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_monomial:\n  assumes \"c \\<noteq> 0\"\n  shows \"indets (monomial c t) = keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (monomial c t) = keys t", "proof (rule antisym; rule subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> indets (monomial c t) \\<Longrightarrow> x \\<in> keys t\n 2. \\<And>x. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (monomial c t)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> indets (monomial c t) \\<Longrightarrow> x \\<in> keys t\n 2. \\<And>x. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (monomial c t)", "assume \"x \\<in> indets (monomial c t)\""], ["proof (state)\nthis:\n  x \\<in> indets (monomial c t)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> indets (monomial c t) \\<Longrightarrow> x \\<in> keys t\n 2. \\<And>x. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (monomial c t)", "then"], ["proof (chain)\npicking this:\n  x \\<in> indets (monomial c t)", "have \"lookup t x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> indets (monomial c t)\n\ngoal (1 subgoal):\n 1. lookup t x \\<noteq> 0", "unfolding indets_def"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (keys ` keys (monomial c t))\n\ngoal (1 subgoal):\n 1. lookup t x \\<noteq> 0", "by (metis UN_E lookup_eq_zero_in_keys_contradict lookup_single_not_eq)"], ["proof (state)\nthis:\n  lookup t x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> indets (monomial c t) \\<Longrightarrow> x \\<in> keys t\n 2. \\<And>x. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (monomial c t)", "thus \"x \\<in> keys t\""], ["proof (prove)\nusing this:\n  lookup t x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> keys t", "by (meson lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (monomial c t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (monomial c t)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (monomial c t)", "assume \"x \\<in> keys t\""], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (monomial c t)", "then"], ["proof (chain)\npicking this:\n  x \\<in> keys t", "have \"lookup t x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. lookup t x \\<noteq> 0", "by (meson lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  lookup t x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (monomial c t)", "thus \"x \\<in> indets (monomial c t)\""], ["proof (prove)\nusing this:\n  lookup t x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> indets (monomial c t)", "unfolding indets_def"], ["proof (prove)\nusing this:\n  lookup t x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (keys ` keys (monomial c t))", "using assms"], ["proof (prove)\nusing this:\n  lookup t x \\<noteq> 0\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (keys ` keys (monomial c t))", "by (metis UN_iff lookup_not_eq_zero_eq_in_keys lookup_single_eq)"], ["proof (state)\nthis:\n  x \\<in> indets (monomial c t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_monomial_subset: \"indets (monomial c t) \\<subseteq> keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (monomial c t) \\<subseteq> keys t", "by (cases \"c = 0\", simp_all add: indets_def)"], ["", "lemma indets_monomial_zero [simp]: \"indets (monomial c 0) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (monomial c 0) = {}", "by (simp add: indets_def)"], ["", "lemma indets_plus_subset: \"indets (p + q) \\<subseteq> indets p \\<union> indets q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (p + q) \\<subseteq> indets p \\<union> indets q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p + q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p + q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "assume \"x \\<in> indets (p + q)\""], ["proof (state)\nthis:\n  x \\<in> indets (p + q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p + q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "then"], ["proof (chain)\npicking this:\n  x \\<in> indets (p + q)", "obtain t where \"x \\<in> keys t\" and \"t \\<in> keys (p + q)\""], ["proof (prove)\nusing this:\n  x \\<in> indets (p + q)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>x \\<in> keys t; t \\<in> keys (p + q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis UN_E indets_def)"], ["proof (state)\nthis:\n  x \\<in> keys t\n  t \\<in> keys (p + q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p + q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "hence \"t \\<in> keys p \\<union> keys q\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n  t \\<in> keys (p + q)\n\ngoal (1 subgoal):\n 1. t \\<in> keys p \\<union> keys q", "by (metis Poly_Mapping.keys_add subsetCE)"], ["proof (state)\nthis:\n  t \\<in> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p + q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "thus \"x \\<in> indets p \\<union> indets q\""], ["proof (prove)\nusing this:\n  t \\<in> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<union> indets q", "using indets_def \\<open>x \\<in> keys t\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> keys p \\<union> keys q\n  indets ?p = \\<Union> (keys ` keys ?p)\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<union> indets q", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> indets p \\<union> indets q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_uminus [simp]: \"indets (-p) = indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (- p) = indets p", "by (simp add: indets_def keys_uminus)"], ["", "lemma indets_minus_subset: \"indets (p - q) \\<subseteq> indets p \\<union> indets q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (p - q) \\<subseteq> indets p \\<union> indets q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p - q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p - q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "assume \"x \\<in> indets (p - q)\""], ["proof (state)\nthis:\n  x \\<in> indets (p - q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p - q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "then"], ["proof (chain)\npicking this:\n  x \\<in> indets (p - q)", "obtain t where \"x \\<in> keys t\" and \"t \\<in> keys (p - q)\""], ["proof (prove)\nusing this:\n  x \\<in> indets (p - q)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>x \\<in> keys t; t \\<in> keys (p - q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis UN_E indets_def)"], ["proof (state)\nthis:\n  x \\<in> keys t\n  t \\<in> keys (p - q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p - q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "hence \"t \\<in> keys p \\<union> keys q\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n  t \\<in> keys (p - q)\n\ngoal (1 subgoal):\n 1. t \\<in> keys p \\<union> keys q", "by (metis keys_minus subsetCE)"], ["proof (state)\nthis:\n  t \\<in> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p - q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "thus \"x \\<in> indets p \\<union> indets q\""], ["proof (prove)\nusing this:\n  t \\<in> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<union> indets q", "using indets_def \\<open>x \\<in> keys t\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> keys p \\<union> keys q\n  indets ?p = \\<Union> (keys ` keys ?p)\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<union> indets q", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> indets p \\<union> indets q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_times_subset: \"indets (p * q) \\<subseteq> indets p \\<union> indets (q::(_ \\<Rightarrow>\\<^sub>0 _::cancel_comm_monoid_add) \\<Rightarrow>\\<^sub>0 _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (p * q) \\<subseteq> indets p \\<union> indets q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p * q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p * q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "assume \"x \\<in> indets (p * q)\""], ["proof (state)\nthis:\n  x \\<in> indets (p * q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p * q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "then"], ["proof (chain)\npicking this:\n  x \\<in> indets (p * q)", "obtain t where \"t \\<in> keys (p * q)\" and \"x \\<in> keys t\""], ["proof (prove)\nusing this:\n  x \\<in> indets (p * q)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys (p * q); x \\<in> keys t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding indets_def"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (keys ` keys (p * q))\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys (p * q); x \\<in> keys t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> keys (p * q)\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p * q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "from this(1)"], ["proof (chain)\npicking this:\n  t \\<in> keys (p * q)", "obtain u v where \"u \\<in> keys p\" \"v \\<in> keys q\" and \"t = u + v\""], ["proof (prove)\nusing this:\n  t \\<in> keys (p * q)\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q; t = u + v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_timesE)"], ["proof (state)\nthis:\n  u \\<in> keys p\n  v \\<in> keys q\n  t = u + v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p * q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "hence \"x \\<in> keys u \\<union> keys v\""], ["proof (prove)\nusing this:\n  u \\<in> keys p\n  v \\<in> keys q\n  t = u + v\n\ngoal (1 subgoal):\n 1. x \\<in> keys u \\<union> keys v", "by (metis \\<open>x \\<in> keys t\\<close> Poly_Mapping.keys_add subsetCE)"], ["proof (state)\nthis:\n  x \\<in> keys u \\<union> keys v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (p * q) \\<Longrightarrow>\n       x \\<in> indets p \\<union> indets q", "thus \"x \\<in> indets p \\<union> indets q\""], ["proof (prove)\nusing this:\n  x \\<in> keys u \\<union> keys v\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<union> indets q", "unfolding indets_def"], ["proof (prove)\nusing this:\n  x \\<in> keys u \\<union> keys v\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (keys ` keys p) \\<union> \\<Union> (keys ` keys q)", "using \\<open>u \\<in> keys p\\<close> \\<open>v \\<in> keys q\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> keys u \\<union> keys v\n  u \\<in> keys p\n  v \\<in> keys q\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (keys ` keys p) \\<union> \\<Union> (keys ` keys q)", "by blast"], ["proof (state)\nthis:\n  x \\<in> indets p \\<union> indets q\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary indets_monom_mult_subset: \"indets (punit.monom_mult c t p) \\<subseteq> keys t \\<union> indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (punit.monom_mult c t p) \\<subseteq> keys t \\<union> indets p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. indets (punit.monom_mult c t p) \\<subseteq> keys t \\<union> indets p", "have \"indets (punit.monom_mult c t p) \\<subseteq> indets (monomial c t) \\<union> indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (punit.monom_mult c t p)\n    \\<subseteq> indets (monomial c t) \\<union> indets p", "by (simp only: times_monomial_left[symmetric] indets_times_subset)"], ["proof (state)\nthis:\n  indets (punit.monom_mult c t p)\n  \\<subseteq> indets (monomial c t) \\<union> indets p\n\ngoal (1 subgoal):\n 1. indets (punit.monom_mult c t p) \\<subseteq> keys t \\<union> indets p", "also"], ["proof (state)\nthis:\n  indets (punit.monom_mult c t p)\n  \\<subseteq> indets (monomial c t) \\<union> indets p\n\ngoal (1 subgoal):\n 1. indets (punit.monom_mult c t p) \\<subseteq> keys t \\<union> indets p", "have \"... \\<subseteq> keys t \\<union> indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (monomial c t) \\<union> indets p\n    \\<subseteq> keys t \\<union> indets p", "using indets_monomial_subset[of t c]"], ["proof (prove)\nusing this:\n  indets (monomial c t) \\<subseteq> keys t\n\ngoal (1 subgoal):\n 1. indets (monomial c t) \\<union> indets p\n    \\<subseteq> keys t \\<union> indets p", "by blast"], ["proof (state)\nthis:\n  indets (monomial c t) \\<union> indets p\n  \\<subseteq> keys t \\<union> indets p\n\ngoal (1 subgoal):\n 1. indets (punit.monom_mult c t p) \\<subseteq> keys t \\<union> indets p", "finally"], ["proof (chain)\npicking this:\n  indets (punit.monom_mult c t p) \\<subseteq> keys t \\<union> indets p", "show ?thesis"], ["proof (prove)\nusing this:\n  indets (punit.monom_mult c t p) \\<subseteq> keys t \\<union> indets p\n\ngoal (1 subgoal):\n 1. indets (punit.monom_mult c t p) \\<subseteq> keys t \\<union> indets p", "."], ["proof (state)\nthis:\n  indets (punit.monom_mult c t p) \\<subseteq> keys t \\<union> indets p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_monom_mult:\n  assumes \"c \\<noteq> 0\" and \"p \\<noteq> (0::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::semiring_no_zero_divisors)\"\n  shows \"indets (punit.monom_mult c t p) = keys t \\<union> indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (punit.monom_mult c t p) = keys t \\<union> indets p", "proof (rule, fact indets_monom_mult_subset, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<union> indets p \\<Longrightarrow>\n       x \\<in> indets (punit.monom_mult c t p)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<union> indets p \\<Longrightarrow>\n       x \\<in> indets (punit.monom_mult c t p)", "assume \"x \\<in> keys t \\<union> indets p\""], ["proof (state)\nthis:\n  x \\<in> keys t \\<union> indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<union> indets p \\<Longrightarrow>\n       x \\<in> indets (punit.monom_mult c t p)", "thus \"x \\<in> indets (punit.monom_mult c t p)\""], ["proof (prove)\nusing this:\n  x \\<in> keys t \\<union> indets p\n\ngoal (1 subgoal):\n 1. x \\<in> indets (punit.monom_mult c t p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (punit.monom_mult c t p)\n 2. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "assume \"x \\<in> keys t\""], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (2 subgoals):\n 1. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (punit.monom_mult c t p)\n 2. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "from assms(2)"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"keys p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys p \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys p \\<noteq> {}\n\ngoal (2 subgoals):\n 1. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (punit.monom_mult c t p)\n 2. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "then"], ["proof (chain)\npicking this:\n  keys p \\<noteq> {}", "obtain s where \"s \\<in> keys p\""], ["proof (prove)\nusing this:\n  keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>s. s \\<in> keys p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (2 subgoals):\n 1. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (punit.monom_mult c t p)\n 2. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "hence \"t + s \\<in> (+) t ` keys p\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. t + s \\<in> (+) t ` keys p", "by fastforce"], ["proof (state)\nthis:\n  t + s \\<in> (+) t ` keys p\n\ngoal (2 subgoals):\n 1. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (punit.monom_mult c t p)\n 2. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "also"], ["proof (state)\nthis:\n  t + s \\<in> (+) t ` keys p\n\ngoal (2 subgoals):\n 1. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (punit.monom_mult c t p)\n 2. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "from assms(1)"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'b)", "have \"... = keys (punit.monom_mult c t p)\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (+) t ` keys p = keys (punit.monom_mult c t p)", "by (simp add: punit.keys_monom_mult)"], ["proof (state)\nthis:\n  (+) t ` keys p = keys (punit.monom_mult c t p)\n\ngoal (2 subgoals):\n 1. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (punit.monom_mult c t p)\n 2. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "finally"], ["proof (chain)\npicking this:\n  t + s \\<in> keys (punit.monom_mult c t p)", "have \"t + s \\<in> keys (punit.monom_mult c t p)\""], ["proof (prove)\nusing this:\n  t + s \\<in> keys (punit.monom_mult c t p)\n\ngoal (1 subgoal):\n 1. t + s \\<in> keys (punit.monom_mult c t p)", "."], ["proof (state)\nthis:\n  t + s \\<in> keys (punit.monom_mult c t p)\n\ngoal (2 subgoals):\n 1. x \\<in> keys t \\<Longrightarrow> x \\<in> indets (punit.monom_mult c t p)\n 2. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> indets (punit.monom_mult c t p)", "proof (rule in_indetsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> keys ?t\n 2. ?t \\<in> keys (punit.monom_mult c t p)", "from \\<open>x \\<in> keys t\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> keys t", "show \"x \\<in> keys (t + s)\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> keys (t + s)", "by (simp add: keys_plus_ninv_comm_monoid_add)"], ["proof (state)\nthis:\n  x \\<in> keys (t + s)\n\ngoal (1 subgoal):\n 1. t + s \\<in> keys (punit.monom_mult c t p)", "qed fact"], ["proof (state)\nthis:\n  x \\<in> indets (punit.monom_mult c t p)\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "assume \"x \\<in> indets p\""], ["proof (state)\nthis:\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "then"], ["proof (chain)\npicking this:\n  x \\<in> indets p", "obtain s where \"s \\<in> keys p\" and \"x \\<in> keys s\""], ["proof (prove)\nusing this:\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; x \\<in> keys s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_indetsE)"], ["proof (state)\nthis:\n  s \\<in> keys p\n  x \\<in> keys s\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "from this(1)"], ["proof (chain)\npicking this:\n  s \\<in> keys p", "have \"t + s \\<in> (+) t ` keys p\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. t + s \\<in> (+) t ` keys p", "by fastforce"], ["proof (state)\nthis:\n  t + s \\<in> (+) t ` keys p\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "also"], ["proof (state)\nthis:\n  t + s \\<in> (+) t ` keys p\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "from assms(1)"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'b)", "have \"... = keys (punit.monom_mult c t p)\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (+) t ` keys p = keys (punit.monom_mult c t p)", "by (simp add: punit.keys_monom_mult)"], ["proof (state)\nthis:\n  (+) t ` keys p = keys (punit.monom_mult c t p)\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "finally"], ["proof (chain)\npicking this:\n  t + s \\<in> keys (punit.monom_mult c t p)", "have \"t + s \\<in> keys (punit.monom_mult c t p)\""], ["proof (prove)\nusing this:\n  t + s \\<in> keys (punit.monom_mult c t p)\n\ngoal (1 subgoal):\n 1. t + s \\<in> keys (punit.monom_mult c t p)", "."], ["proof (state)\nthis:\n  t + s \\<in> keys (punit.monom_mult c t p)\n\ngoal (1 subgoal):\n 1. x \\<in> indets p \\<Longrightarrow>\n    x \\<in> indets (punit.monom_mult c t p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> indets (punit.monom_mult c t p)", "proof (rule in_indetsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> keys ?t\n 2. ?t \\<in> keys (punit.monom_mult c t p)", "from \\<open>x \\<in> keys s\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> keys s", "show \"x \\<in> keys (t + s)\""], ["proof (prove)\nusing this:\n  x \\<in> keys s\n\ngoal (1 subgoal):\n 1. x \\<in> keys (t + s)", "by (simp add: keys_plus_ninv_comm_monoid_add)"], ["proof (state)\nthis:\n  x \\<in> keys (t + s)\n\ngoal (1 subgoal):\n 1. t + s \\<in> keys (punit.monom_mult c t p)", "qed fact"], ["proof (state)\nthis:\n  x \\<in> indets (punit.monom_mult c t p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> indets (punit.monom_mult c t p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_sum_subset: \"indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "proof (cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n 2. infinite A \\<Longrightarrow>\n    indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n 2. infinite A \\<Longrightarrow>\n    indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. indets (sum f {}) \\<subseteq> (\\<Union>a\\<in>{}. indets (f a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (sum f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (sum f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. indets (sum f {}) \\<subseteq> (\\<Union>a\\<in>{}. indets (f a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (sum f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (sum f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (sum f {}) \\<subseteq> (\\<Union>a\\<in>{}. indets (f a))", "by simp"], ["proof (state)\nthis:\n  indets (sum f {}) \\<subseteq> (\\<Union>a\\<in>{}. indets (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (sum f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (sum f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (sum f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (sum f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (sum f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (sum f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "have \"indets (sum f (insert a A)) \\<subseteq> indets (f a) \\<union> indets (sum f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (sum f (insert a A))\n    \\<subseteq> indets (f a) \\<union> indets (sum f A)", "by (simp only: comm_monoid_add_class.sum.insert[OF insert(1) insert(2)] indets_plus_subset)"], ["proof (state)\nthis:\n  indets (sum f (insert a A))\n  \\<subseteq> indets (f a) \\<union> indets (sum f A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (sum f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (sum f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "also"], ["proof (state)\nthis:\n  indets (sum f (insert a A))\n  \\<subseteq> indets (f a) \\<union> indets (sum f A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (sum f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (sum f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "have \"... \\<subseteq> indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (f a) \\<union> indets (sum f A)\n    \\<subseteq> indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a))", "using insert(3)"], ["proof (prove)\nusing this:\n  indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n\ngoal (1 subgoal):\n 1. indets (f a) \\<union> indets (sum f A)\n    \\<subseteq> indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a))", "by blast"], ["proof (state)\nthis:\n  indets (f a) \\<union> indets (sum f A)\n  \\<subseteq> indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (sum f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (sum f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "also"], ["proof (state)\nthis:\n  indets (f a) \\<union> indets (sum f A)\n  \\<subseteq> indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (sum f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (sum f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "have \"... = (\\<Union>a\\<in>insert a A. indets (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a)) =\n    (\\<Union>a\\<in>insert a A. indets (f a))", "by simp"], ["proof (state)\nthis:\n  indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a)) =\n  (\\<Union>a\\<in>insert a A. indets (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (sum f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (sum f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "finally"], ["proof (chain)\npicking this:\n  indets (sum f (insert a A))\n  \\<subseteq> (\\<Union>a\\<in>insert a A. indets (f a))", "show ?case"], ["proof (prove)\nusing this:\n  indets (sum f (insert a A))\n  \\<subseteq> (\\<Union>a\\<in>insert a A. indets (f a))\n\ngoal (1 subgoal):\n 1. indets (sum f (insert a A))\n    \\<subseteq> (\\<Union>a\\<in>insert a A. indets (f a))", "."], ["proof (state)\nthis:\n  indets (sum f (insert a A))\n  \\<subseteq> (\\<Union>a\\<in>insert a A. indets (f a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "case False"], ["proof (state)\nthis:\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "by simp"], ["proof (state)\nthis:\n  indets (sum f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_prod_subset:\n  \"indets (prod (f::_ \\<Rightarrow> ((_ \\<Rightarrow>\\<^sub>0 _::cancel_comm_monoid_add) \\<Rightarrow>\\<^sub>0 _)) A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "proof (cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n 2. infinite A \\<Longrightarrow>\n    indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n 2. infinite A \\<Longrightarrow>\n    indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. indets (prod f {}) \\<subseteq> (\\<Union>a\\<in>{}. indets (f a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (prod f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (prod f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. indets (prod f {}) \\<subseteq> (\\<Union>a\\<in>{}. indets (f a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (prod f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (prod f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (prod f {}) \\<subseteq> (\\<Union>a\\<in>{}. indets (f a))", "by simp"], ["proof (state)\nthis:\n  indets (prod f {}) \\<subseteq> (\\<Union>a\\<in>{}. indets (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (prod f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (prod f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (prod f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (prod f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (prod f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (prod f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "have \"indets (prod f (insert a A)) \\<subseteq> indets (f a) \\<union> indets (prod f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (prod f (insert a A))\n    \\<subseteq> indets (f a) \\<union> indets (prod f A)", "by (simp only: comm_monoid_mult_class.prod.insert[OF insert(1) insert(2)] indets_times_subset)"], ["proof (state)\nthis:\n  indets (prod f (insert a A))\n  \\<subseteq> indets (f a) \\<union> indets (prod f A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (prod f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (prod f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "also"], ["proof (state)\nthis:\n  indets (prod f (insert a A))\n  \\<subseteq> indets (f a) \\<union> indets (prod f A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (prod f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (prod f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "have \"... \\<subseteq> indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (f a) \\<union> indets (prod f A)\n    \\<subseteq> indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a))", "using insert(3)"], ["proof (prove)\nusing this:\n  indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n\ngoal (1 subgoal):\n 1. indets (f a) \\<union> indets (prod f A)\n    \\<subseteq> indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a))", "by blast"], ["proof (state)\nthis:\n  indets (f a) \\<union> indets (prod f A)\n  \\<subseteq> indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (prod f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (prod f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "also"], ["proof (state)\nthis:\n  indets (f a) \\<union> indets (prod f A)\n  \\<subseteq> indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (prod f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (prod f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "have \"... = (\\<Union>a\\<in>insert a A. indets (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a)) =\n    (\\<Union>a\\<in>insert a A. indets (f a))", "by simp"], ["proof (state)\nthis:\n  indets (f a) \\<union> (\\<Union>a\\<in>A. indets (f a)) =\n  (\\<Union>a\\<in>insert a A. indets (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        indets (prod f F)\n        \\<subseteq> (\\<Union>a\\<in>F. indets (f a))\\<rbrakk>\n       \\<Longrightarrow> indets (prod f (insert x F))\n                         \\<subseteq> (\\<Union>a\\<in>insert x F.\n   indets (f a))", "finally"], ["proof (chain)\npicking this:\n  indets (prod f (insert a A))\n  \\<subseteq> (\\<Union>a\\<in>insert a A. indets (f a))", "show ?case"], ["proof (prove)\nusing this:\n  indets (prod f (insert a A))\n  \\<subseteq> (\\<Union>a\\<in>insert a A. indets (f a))\n\ngoal (1 subgoal):\n 1. indets (prod f (insert a A))\n    \\<subseteq> (\\<Union>a\\<in>insert a A. indets (f a))", "."], ["proof (state)\nthis:\n  indets (prod f (insert a A))\n  \\<subseteq> (\\<Union>a\\<in>insert a A. indets (f a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "case False"], ["proof (state)\nthis:\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))", "by simp"], ["proof (state)\nthis:\n  indets (prod f A) \\<subseteq> (\\<Union>a\\<in>A. indets (f a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_power_subset: \"indets (p ^ n) \\<subseteq> indets (p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (p ^ n) \\<subseteq> indets p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. indets (p ^ n) \\<subseteq> indets p", "have \"p ^ n = (\\<Prod>i=0..<n. p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ n = (\\<Prod>i = 0..<n. p)", "by simp"], ["proof (state)\nthis:\n  p ^ n = (\\<Prod>i = 0..<n. p)\n\ngoal (1 subgoal):\n 1. indets (p ^ n) \\<subseteq> indets p", "also"], ["proof (state)\nthis:\n  p ^ n = (\\<Prod>i = 0..<n. p)\n\ngoal (1 subgoal):\n 1. indets (p ^ n) \\<subseteq> indets p", "have \"indets ... \\<subseteq> (\\<Union>i\\<in>{0..<n}. indets p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (\\<Prod>i = 0..<n. p)\n    \\<subseteq> (\\<Union>i\\<in>{0..<n}. indets p)", "by (fact indets_prod_subset)"], ["proof (state)\nthis:\n  indets (\\<Prod>i = 0..<n. p) \\<subseteq> (\\<Union>i\\<in>{0..<n}. indets p)\n\ngoal (1 subgoal):\n 1. indets (p ^ n) \\<subseteq> indets p", "also"], ["proof (state)\nthis:\n  indets (\\<Prod>i = 0..<n. p) \\<subseteq> (\\<Union>i\\<in>{0..<n}. indets p)\n\ngoal (1 subgoal):\n 1. indets (p ^ n) \\<subseteq> indets p", "have \"... \\<subseteq> indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>{0..<n}. indets p) \\<subseteq> indets p", "by simp"], ["proof (state)\nthis:\n  (\\<Union>i\\<in>{0..<n}. indets p) \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. indets (p ^ n) \\<subseteq> indets p", "finally"], ["proof (chain)\npicking this:\n  indets (p ^ n) \\<subseteq> indets p", "show ?thesis"], ["proof (prove)\nusing this:\n  indets (p ^ n) \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. indets (p ^ n) \\<subseteq> indets p", "."], ["proof (state)\nthis:\n  indets (p ^ n) \\<subseteq> indets p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_empty_iff_poly_deg_zero: \"indets p = {} \\<longleftrightarrow> poly_deg p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (indets p = {}) = (poly_deg p = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. indets p = {} \\<Longrightarrow> poly_deg p = 0\n 2. poly_deg p = 0 \\<Longrightarrow> indets p = {}", "assume \"indets p = {}\""], ["proof (state)\nthis:\n  indets p = {}\n\ngoal (2 subgoals):\n 1. indets p = {} \\<Longrightarrow> poly_deg p = 0\n 2. poly_deg p = 0 \\<Longrightarrow> indets p = {}", "hence \"monomial (lookup p 0) 0 = p\""], ["proof (prove)\nusing this:\n  indets p = {}\n\ngoal (1 subgoal):\n 1. monomial (lookup p 0) 0 = p", "by (rule indets_empty_imp_monomial)"], ["proof (state)\nthis:\n  monomial (lookup p 0) 0 = p\n\ngoal (2 subgoals):\n 1. indets p = {} \\<Longrightarrow> poly_deg p = 0\n 2. poly_deg p = 0 \\<Longrightarrow> indets p = {}", "moreover"], ["proof (state)\nthis:\n  monomial (lookup p 0) 0 = p\n\ngoal (2 subgoals):\n 1. indets p = {} \\<Longrightarrow> poly_deg p = 0\n 2. poly_deg p = 0 \\<Longrightarrow> indets p = {}", "have \"poly_deg (monomial (lookup p 0) 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (monomial (lookup p 0) 0) = (0::'c)", "by simp"], ["proof (state)\nthis:\n  poly_deg (monomial (lookup p 0) 0) = (0::?'c1)\n\ngoal (2 subgoals):\n 1. indets p = {} \\<Longrightarrow> poly_deg p = 0\n 2. poly_deg p = 0 \\<Longrightarrow> indets p = {}", "ultimately"], ["proof (chain)\npicking this:\n  monomial (lookup p 0) 0 = p\n  poly_deg (monomial (lookup p 0) 0) = (0::?'c1)", "show \"poly_deg p = 0\""], ["proof (prove)\nusing this:\n  monomial (lookup p 0) 0 = p\n  poly_deg (monomial (lookup p 0) 0) = (0::?'c1)\n\ngoal (1 subgoal):\n 1. poly_deg p = 0", "by metis"], ["proof (state)\nthis:\n  poly_deg p = 0\n\ngoal (1 subgoal):\n 1. poly_deg p = 0 \\<Longrightarrow> indets p = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg p = 0 \\<Longrightarrow> indets p = {}", "assume \"poly_deg p = 0\""], ["proof (state)\nthis:\n  poly_deg p = 0\n\ngoal (1 subgoal):\n 1. poly_deg p = 0 \\<Longrightarrow> indets p = {}", "hence \"monomial (lookup p 0) 0 = p\""], ["proof (prove)\nusing this:\n  poly_deg p = 0\n\ngoal (1 subgoal):\n 1. monomial (lookup p 0) 0 = p", "by (rule poly_deg_zero_imp_monomial)"], ["proof (state)\nthis:\n  monomial (lookup p 0) 0 = p\n\ngoal (1 subgoal):\n 1. poly_deg p = 0 \\<Longrightarrow> indets p = {}", "moreover"], ["proof (state)\nthis:\n  monomial (lookup p 0) 0 = p\n\ngoal (1 subgoal):\n 1. poly_deg p = 0 \\<Longrightarrow> indets p = {}", "have \"indets (monomial (lookup p 0) 0) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (monomial (lookup p 0) 0) = {}", "by simp"], ["proof (state)\nthis:\n  indets (monomial (lookup p 0) 0) = {}\n\ngoal (1 subgoal):\n 1. poly_deg p = 0 \\<Longrightarrow> indets p = {}", "ultimately"], ["proof (chain)\npicking this:\n  monomial (lookup p 0) 0 = p\n  indets (monomial (lookup p 0) 0) = {}", "show \"indets p = {}\""], ["proof (prove)\nusing this:\n  monomial (lookup p 0) 0 = p\n  indets (monomial (lookup p 0) 0) = {}\n\ngoal (1 subgoal):\n 1. indets p = {}", "by metis"], ["proof (state)\nthis:\n  indets p = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const PPs}\\<close>"], ["", "lemma PPsI: \"keys t \\<subseteq> X \\<Longrightarrow> t \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys t \\<subseteq> X \\<Longrightarrow> t \\<in> .[X]", "by (simp add: PPs_def)"], ["", "lemma PPsD: \"t \\<in> .[X] \\<Longrightarrow> keys t \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> .[X] \\<Longrightarrow> keys t \\<subseteq> X", "by (simp add: PPs_def)"], ["", "lemma PPs_empty [simp]: \".[{}] = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. .[{}] = {0}", "by (simp add: PPs_def)"], ["", "lemma PPs_UNIV [simp]: \".[UNIV] = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. .[UNIV] = UNIV", "by (simp add: PPs_def)"], ["", "lemma PPs_singleton: \".[{x}] = range (Poly_Mapping.single x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. .[{x}] = range (Poly_Mapping.single x)", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. (xa \\<in> .[{x}]) = (xa \\<in> range (Poly_Mapping.single x))", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. (xa \\<in> .[{x}]) = (xa \\<in> range (Poly_Mapping.single x))", "show \"t \\<in> .[{x}] \\<longleftrightarrow> t \\<in> range (Poly_Mapping.single x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<in> .[{x}]) = (t \\<in> range (Poly_Mapping.single x))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow> t \\<in> range (Poly_Mapping.single x)\n 2. t \\<in> range (Poly_Mapping.single x) \\<Longrightarrow> t \\<in> .[{x}]", "assume \"t \\<in> .[{x}]\""], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow> t \\<in> range (Poly_Mapping.single x)\n 2. t \\<in> range (Poly_Mapping.single x) \\<Longrightarrow> t \\<in> .[{x}]", "hence \"keys t \\<subseteq> {x}\""], ["proof (prove)\nusing this:\n  t \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> {x}", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys t \\<subseteq> {x}\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow> t \\<in> range (Poly_Mapping.single x)\n 2. t \\<in> range (Poly_Mapping.single x) \\<Longrightarrow> t \\<in> .[{x}]", "hence \"Poly_Mapping.single x (lookup t x) = t\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. monomial (lookup t x) x = t", "by (rule keys_subset_singleton_imp_monomial)"], ["proof (state)\nthis:\n  monomial (lookup t x) x = t\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow> t \\<in> range (Poly_Mapping.single x)\n 2. t \\<in> range (Poly_Mapping.single x) \\<Longrightarrow> t \\<in> .[{x}]", "from this[symmetric] UNIV_I"], ["proof (chain)\npicking this:\n  t = monomial (lookup t x) x\n  ?x \\<in> UNIV", "show \"t \\<in> range (Poly_Mapping.single x)\""], ["proof (prove)\nusing this:\n  t = monomial (lookup t x) x\n  ?x \\<in> UNIV\n\ngoal (1 subgoal):\n 1. t \\<in> range (Poly_Mapping.single x)", ".."], ["proof (state)\nthis:\n  t \\<in> range (Poly_Mapping.single x)\n\ngoal (1 subgoal):\n 1. t \\<in> range (Poly_Mapping.single x) \\<Longrightarrow> t \\<in> .[{x}]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> range (Poly_Mapping.single x) \\<Longrightarrow> t \\<in> .[{x}]", "assume \"t \\<in> range (Poly_Mapping.single x)\""], ["proof (state)\nthis:\n  t \\<in> range (Poly_Mapping.single x)\n\ngoal (1 subgoal):\n 1. t \\<in> range (Poly_Mapping.single x) \\<Longrightarrow> t \\<in> .[{x}]", "then"], ["proof (chain)\npicking this:\n  t \\<in> range (Poly_Mapping.single x)", "obtain e where \"t = Poly_Mapping.single x e\""], ["proof (prove)\nusing this:\n  t \\<in> range (Poly_Mapping.single x)\n\ngoal (1 subgoal):\n 1. (\\<And>e. t = monomial e x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t = monomial e x\n\ngoal (1 subgoal):\n 1. t \\<in> range (Poly_Mapping.single x) \\<Longrightarrow> t \\<in> .[{x}]", "thus \"t \\<in> .[{x}]\""], ["proof (prove)\nusing this:\n  t = monomial e x\n\ngoal (1 subgoal):\n 1. t \\<in> .[{x}]", "by (simp add: PPs_def)"], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t \\<in> .[{x}]) = (t \\<in> range (Poly_Mapping.single x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_in_PPs: \"0 \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> .[X]", "by (simp add: PPs_def)"], ["", "lemma PPs_mono: \"X \\<subseteq> Y \\<Longrightarrow> .[X] \\<subseteq> .[Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> Y \\<Longrightarrow> .[X] \\<subseteq> .[Y]", "by (auto simp: PPs_def)"], ["", "lemma PPs_closed_single:\n  assumes \"x \\<in> X\"\n  shows \"Poly_Mapping.single x e \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial e x \\<in> .[X]", "proof (rule PPsI)"], ["proof (state)\ngoal (1 subgoal):\n 1. keys (monomial e x) \\<subseteq> X", "have \"keys (Poly_Mapping.single x e) \\<subseteq> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial e x) \\<subseteq> {x}", "by simp"], ["proof (state)\nthis:\n  keys (monomial e x) \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. keys (monomial e x) \\<subseteq> X", "also"], ["proof (state)\nthis:\n  keys (monomial e x) \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. keys (monomial e x) \\<subseteq> X", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> X", "have \"... \\<subseteq> X\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. {x} \\<subseteq> X", "by simp"], ["proof (state)\nthis:\n  {x} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. keys (monomial e x) \\<subseteq> X", "finally"], ["proof (chain)\npicking this:\n  keys (monomial e x) \\<subseteq> X", "show \"keys (Poly_Mapping.single x e) \\<subseteq> X\""], ["proof (prove)\nusing this:\n  keys (monomial e x) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. keys (monomial e x) \\<subseteq> X", "."], ["proof (state)\nthis:\n  keys (monomial e x) \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PPs_closed_plus:\n  assumes \"s \\<in> .[X]\" and \"t \\<in> .[X]\"\n  shows \"s + t \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + t \\<in> .[X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s + t \\<in> .[X]", "have \"keys (s + t) \\<subseteq> keys s \\<union> keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (s + t) \\<subseteq> keys s \\<union> keys t", "by (fact Poly_Mapping.keys_add)"], ["proof (state)\nthis:\n  keys (s + t) \\<subseteq> keys s \\<union> keys t\n\ngoal (1 subgoal):\n 1. s + t \\<in> .[X]", "also"], ["proof (state)\nthis:\n  keys (s + t) \\<subseteq> keys s \\<union> keys t\n\ngoal (1 subgoal):\n 1. s + t \\<in> .[X]", "from assms"], ["proof (chain)\npicking this:\n  s \\<in> .[X]\n  t \\<in> .[X]", "have \"... \\<subseteq> X\""], ["proof (prove)\nusing this:\n  s \\<in> .[X]\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. keys s \\<union> keys t \\<subseteq> X", "by (simp add: PPs_def)"], ["proof (state)\nthis:\n  keys s \\<union> keys t \\<subseteq> X\n\ngoal (1 subgoal):\n 1. s + t \\<in> .[X]", "finally"], ["proof (chain)\npicking this:\n  keys (s + t) \\<subseteq> X", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (s + t) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. s + t \\<in> .[X]", "by (rule PPsI)"], ["proof (state)\nthis:\n  s + t \\<in> .[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PPs_closed_minus:\n  assumes \"s \\<in> .[X]\"\n  shows \"s - t \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s - t \\<in> .[X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s - t \\<in> .[X]", "have \"keys (s - t) \\<subseteq> keys s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (s - t) \\<subseteq> keys s", "by (metis lookup_minus lookup_not_eq_zero_eq_in_keys subsetI zero_diff)"], ["proof (state)\nthis:\n  keys (s - t) \\<subseteq> keys s\n\ngoal (1 subgoal):\n 1. s - t \\<in> .[X]", "also"], ["proof (state)\nthis:\n  keys (s - t) \\<subseteq> keys s\n\ngoal (1 subgoal):\n 1. s - t \\<in> .[X]", "from assms"], ["proof (chain)\npicking this:\n  s \\<in> .[X]", "have \"... \\<subseteq> X\""], ["proof (prove)\nusing this:\n  s \\<in> .[X]\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> X", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys s \\<subseteq> X\n\ngoal (1 subgoal):\n 1. s - t \\<in> .[X]", "finally"], ["proof (chain)\npicking this:\n  keys (s - t) \\<subseteq> X", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (s - t) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. s - t \\<in> .[X]", "by (rule PPsI)"], ["proof (state)\nthis:\n  s - t \\<in> .[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PPs_closed_adds:\n  assumes \"s \\<in> .[X]\" and \"t adds s\"\n  shows \"t \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> .[X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> .[X]", "from assms(2)"], ["proof (chain)\npicking this:\n  t adds s", "have \"s - (s - t) = t\""], ["proof (prove)\nusing this:\n  t adds s\n\ngoal (1 subgoal):\n 1. s - (s - t) = t", "by (metis add_minus_2 adds_minus)"], ["proof (state)\nthis:\n  s - (s - t) = t\n\ngoal (1 subgoal):\n 1. t \\<in> .[X]", "moreover"], ["proof (state)\nthis:\n  s - (s - t) = t\n\ngoal (1 subgoal):\n 1. t \\<in> .[X]", "from assms(1)"], ["proof (chain)\npicking this:\n  s \\<in> .[X]", "have \"s - (s - t) \\<in> .[X]\""], ["proof (prove)\nusing this:\n  s \\<in> .[X]\n\ngoal (1 subgoal):\n 1. s - (s - t) \\<in> .[X]", "by (rule PPs_closed_minus)"], ["proof (state)\nthis:\n  s - (s - t) \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t \\<in> .[X]", "ultimately"], ["proof (chain)\npicking this:\n  s - (s - t) = t\n  s - (s - t) \\<in> .[X]", "show ?thesis"], ["proof (prove)\nusing this:\n  s - (s - t) = t\n  s - (s - t) \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t \\<in> .[X]", "by simp"], ["proof (state)\nthis:\n  t \\<in> .[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PPs_closed_gcs:\n  assumes \"s \\<in> .[X]\"\n  shows \"gcs s t \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs s t \\<in> .[X]", "using assms gcs_adds"], ["proof (prove)\nusing this:\n  s \\<in> .[X]\n  gcs ?s ?t adds ?s\n\ngoal (1 subgoal):\n 1. gcs s t \\<in> .[X]", "by (rule PPs_closed_adds)"], ["", "lemma PPs_closed_lcs:\n  assumes \"s \\<in> .[X]\" and \"t \\<in> .[X]\"\n  shows \"lcs s t \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs s t \\<in> .[X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lcs s t \\<in> .[X]", "from assms"], ["proof (chain)\npicking this:\n  s \\<in> .[X]\n  t \\<in> .[X]", "have \"s + t \\<in> .[X]\""], ["proof (prove)\nusing this:\n  s \\<in> .[X]\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. s + t \\<in> .[X]", "by (rule PPs_closed_plus)"], ["proof (state)\nthis:\n  s + t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. lcs s t \\<in> .[X]", "hence \"(s + t) - gcs s t \\<in> .[X]\""], ["proof (prove)\nusing this:\n  s + t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. s + t - gcs s t \\<in> .[X]", "by (rule PPs_closed_minus)"], ["proof (state)\nthis:\n  s + t - gcs s t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. lcs s t \\<in> .[X]", "thus ?thesis"], ["proof (prove)\nusing this:\n  s + t - gcs s t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. lcs s t \\<in> .[X]", "by (simp add: gcs_plus_lcs[of s t, symmetric])"], ["proof (state)\nthis:\n  lcs s t \\<in> .[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PPs_closed_except': \"t \\<in> .[X] \\<Longrightarrow> except t Y \\<in> .[X - Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> .[X] \\<Longrightarrow> except t Y \\<in> .[X - Y]", "by (auto simp: keys_except PPs_def)"], ["", "lemma PPs_closed_except: \"t \\<in> .[X] \\<Longrightarrow> except t Y \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> .[X] \\<Longrightarrow> except t Y \\<in> .[X]", "by (auto simp: keys_except PPs_def)"], ["", "lemma PPs_UnI:\n  assumes \"tx \\<in> .[X]\" and \"ty \\<in> .[Y]\" and \"t = tx + ty\"\n  shows \"t \\<in> .[X \\<union> Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> .[X \\<union> Y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> .[X \\<union> Y]", "from assms(1)"], ["proof (chain)\npicking this:\n  tx \\<in> .[X]", "have \"tx \\<in> .[X \\<union> Y]\""], ["proof (prove)\nusing this:\n  tx \\<in> .[X]\n\ngoal (1 subgoal):\n 1. tx \\<in> .[X \\<union> Y]", "by rule (simp add: PPs_mono)"], ["proof (state)\nthis:\n  tx \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. t \\<in> .[X \\<union> Y]", "moreover"], ["proof (state)\nthis:\n  tx \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. t \\<in> .[X \\<union> Y]", "from assms(2)"], ["proof (chain)\npicking this:\n  ty \\<in> .[Y]", "have \"ty \\<in> .[X \\<union> Y]\""], ["proof (prove)\nusing this:\n  ty \\<in> .[Y]\n\ngoal (1 subgoal):\n 1. ty \\<in> .[X \\<union> Y]", "by rule (simp add: PPs_mono)"], ["proof (state)\nthis:\n  ty \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. t \\<in> .[X \\<union> Y]", "ultimately"], ["proof (chain)\npicking this:\n  tx \\<in> .[X \\<union> Y]\n  ty \\<in> .[X \\<union> Y]", "show ?thesis"], ["proof (prove)\nusing this:\n  tx \\<in> .[X \\<union> Y]\n  ty \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. t \\<in> .[X \\<union> Y]", "unfolding assms(3)"], ["proof (prove)\nusing this:\n  tx \\<in> .[X \\<union> Y]\n  ty \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. tx + ty \\<in> .[X \\<union> Y]", "by (rule PPs_closed_plus)"], ["proof (state)\nthis:\n  t \\<in> .[X \\<union> Y]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PPs_UnE:\n  assumes \"t \\<in> .[X \\<union> Y]\"\n  obtains tx ty where \"tx \\<in> .[X]\" and \"ty \\<in> .[Y]\" and \"t = tx + ty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tx ty.\n        \\<lbrakk>tx \\<in> .[X]; ty \\<in> .[Y]; t = tx + ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>tx ty.\n        \\<lbrakk>tx \\<in> .[X]; ty \\<in> .[Y]; t = tx + ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  t \\<in> .[X \\<union> Y]", "have \"keys t \\<subseteq> X \\<union> Y\""], ["proof (prove)\nusing this:\n  t \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> X \\<union> Y", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys t \\<subseteq> X \\<union> Y\n\ngoal (1 subgoal):\n 1. (\\<And>tx ty.\n        \\<lbrakk>tx \\<in> .[X]; ty \\<in> .[Y]; t = tx + ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define tx where \"tx = except t (- X)\""], ["proof (state)\nthis:\n  tx = except t (- X)\n\ngoal (1 subgoal):\n 1. (\\<And>tx ty.\n        \\<lbrakk>tx \\<in> .[X]; ty \\<in> .[Y]; t = tx + ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"keys tx \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys tx \\<subseteq> X", "by (simp add: tx_def keys_except)"], ["proof (state)\nthis:\n  keys tx \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (\\<And>tx ty.\n        \\<lbrakk>tx \\<in> .[X]; ty \\<in> .[Y]; t = tx + ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"tx \\<in> .[X]\""], ["proof (prove)\nusing this:\n  keys tx \\<subseteq> X\n\ngoal (1 subgoal):\n 1. tx \\<in> .[X]", "by (simp add: PPs_def)"], ["proof (state)\nthis:\n  tx \\<in> .[X]\n\ngoal (1 subgoal):\n 1. (\\<And>tx ty.\n        \\<lbrakk>tx \\<in> .[X]; ty \\<in> .[Y]; t = tx + ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"tx adds t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tx adds t", "by (simp add: tx_def adds_poly_mappingI le_fun_def lookup_except)"], ["proof (state)\nthis:\n  tx adds t\n\ngoal (1 subgoal):\n 1. (\\<And>tx ty.\n        \\<lbrakk>tx \\<in> .[X]; ty \\<in> .[Y]; t = tx + ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from adds_minus[OF this]"], ["proof (chain)\npicking this:\n  t - tx + tx = t", "have \"t = tx + (t - tx)\""], ["proof (prove)\nusing this:\n  t - tx + tx = t\n\ngoal (1 subgoal):\n 1. t = tx + (t - tx)", "by (simp only: ac_simps)"], ["proof (state)\nthis:\n  t = tx + (t - tx)\n\ngoal (1 subgoal):\n 1. (\\<And>tx ty.\n        \\<lbrakk>tx \\<in> .[X]; ty \\<in> .[Y]; t = tx + ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"t - tx \\<in> .[Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t - tx \\<in> .[Y]", "proof (rule PPsI, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys (t - tx) \\<Longrightarrow> x \\<in> Y", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys (t - tx) \\<Longrightarrow> x \\<in> Y", "assume \"x \\<in> keys (t - tx)\""], ["proof (state)\nthis:\n  x \\<in> keys (t - tx)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys (t - tx) \\<Longrightarrow> x \\<in> Y", "also"], ["proof (state)\nthis:\n  x \\<in> keys (t - tx)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys (t - tx) \\<Longrightarrow> x \\<in> Y", "have \"... \\<subseteq> keys t \\<union> keys tx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (t - tx) \\<subseteq> keys t \\<union> keys tx", "by (rule keys_minus)"], ["proof (state)\nthis:\n  keys (t - tx) \\<subseteq> keys t \\<union> keys tx\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys (t - tx) \\<Longrightarrow> x \\<in> Y", "also"], ["proof (state)\nthis:\n  keys (t - tx) \\<subseteq> keys t \\<union> keys tx\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys (t - tx) \\<Longrightarrow> x \\<in> Y", "from \\<open>keys t \\<subseteq> X \\<union> Y\\<close> \\<open>keys tx \\<subseteq> X\\<close>"], ["proof (chain)\npicking this:\n  keys t \\<subseteq> X \\<union> Y\n  keys tx \\<subseteq> X", "have \"... \\<subseteq> X \\<union> Y\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> X \\<union> Y\n  keys tx \\<subseteq> X\n\ngoal (1 subgoal):\n 1. keys t \\<union> keys tx \\<subseteq> X \\<union> Y", "by blast"], ["proof (state)\nthis:\n  keys t \\<union> keys tx \\<subseteq> X \\<union> Y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys (t - tx) \\<Longrightarrow> x \\<in> Y", "finally"], ["proof (chain)\npicking this:\n  x \\<in> X \\<union> Y", "show \"x \\<in> Y\""], ["proof (prove)\nusing this:\n  x \\<in> X \\<union> Y\n\ngoal (1 subgoal):\n 1. x \\<in> Y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> X \\<Longrightarrow> x \\<in> Y\n 2. x \\<in> Y \\<Longrightarrow> x \\<in> Y", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. x \\<in> X \\<Longrightarrow> x \\<in> Y\n 2. x \\<in> Y \\<Longrightarrow> x \\<in> Y", "hence \"x \\<notin> keys (t - tx)\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<notin> keys (t - tx)", "by (simp add: tx_def lookup_except lookup_minus in_keys_iff)"], ["proof (state)\nthis:\n  x \\<notin> keys (t - tx)\n\ngoal (2 subgoals):\n 1. x \\<in> X \\<Longrightarrow> x \\<in> Y\n 2. x \\<in> Y \\<Longrightarrow> x \\<in> Y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> keys (t - tx)\n\ngoal (1 subgoal):\n 1. x \\<in> Y", "using \\<open>x \\<in> keys (t - tx)\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> keys (t - tx)\n  x \\<in> keys (t - tx)\n\ngoal (1 subgoal):\n 1. x \\<in> Y", ".."], ["proof (state)\nthis:\n  x \\<in> Y\n\ngoal (1 subgoal):\n 1. x \\<in> Y \\<Longrightarrow> x \\<in> Y", "qed"], ["proof (state)\nthis:\n  x \\<in> Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t - tx \\<in> .[Y]\n\ngoal (1 subgoal):\n 1. (\\<And>tx ty.\n        \\<lbrakk>tx \\<in> .[X]; ty \\<in> .[Y]; t = tx + ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>tx \\<in> .[X]\\<close>"], ["proof (chain)\npicking this:\n  tx \\<in> .[X]\n  t - tx \\<in> .[Y]", "show ?thesis"], ["proof (prove)\nusing this:\n  tx \\<in> .[X]\n  t - tx \\<in> .[Y]\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>t = tx + (t - tx)\\<close>"], ["proof (prove)\nusing this:\n  tx \\<in> .[X]\n  t - tx \\<in> .[Y]\n  t = tx + (t - tx)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PPs_Un: \".[X \\<union> Y] = (\\<Union>t\\<in>.[X]. (+) t ` .[Y])\"  (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. .[X \\<union> Y] = (\\<Union>t\\<in>.[X]. (+) t ` .[Y])", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> .[X \\<union> Y]) =\n       (x \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]))", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> .[X \\<union> Y]) =\n       (x \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]))", "show \"t \\<in> ?A \\<longleftrightarrow> t \\<in> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<in> .[X \\<union> Y]) = (t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> .[X \\<union> Y] \\<Longrightarrow>\n    t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y])\n 2. t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]) \\<Longrightarrow>\n    t \\<in> .[X \\<union> Y]", "assume \"t \\<in> ?A\""], ["proof (state)\nthis:\n  t \\<in> .[X \\<union> Y]\n\ngoal (2 subgoals):\n 1. t \\<in> .[X \\<union> Y] \\<Longrightarrow>\n    t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y])\n 2. t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]) \\<Longrightarrow>\n    t \\<in> .[X \\<union> Y]", "then"], ["proof (chain)\npicking this:\n  t \\<in> .[X \\<union> Y]", "obtain tx ty where \"tx \\<in> .[X]\" and \"ty \\<in> .[Y]\" and \"t = tx + ty\""], ["proof (prove)\nusing this:\n  t \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. (\\<And>tx ty.\n        \\<lbrakk>tx \\<in> .[X]; ty \\<in> .[Y]; t = tx + ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule PPs_UnE)"], ["proof (state)\nthis:\n  tx \\<in> .[X]\n  ty \\<in> .[Y]\n  t = tx + ty\n\ngoal (2 subgoals):\n 1. t \\<in> .[X \\<union> Y] \\<Longrightarrow>\n    t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y])\n 2. t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]) \\<Longrightarrow>\n    t \\<in> .[X \\<union> Y]", "from this(2)"], ["proof (chain)\npicking this:\n  ty \\<in> .[Y]", "have \"t \\<in> (+) tx ` .[Y]\""], ["proof (prove)\nusing this:\n  ty \\<in> .[Y]\n\ngoal (1 subgoal):\n 1. t \\<in> (+) tx ` .[Y]", "unfolding \\<open>t = tx + ty\\<close>"], ["proof (prove)\nusing this:\n  ty \\<in> .[Y]\n\ngoal (1 subgoal):\n 1. tx + ty \\<in> (+) tx ` .[Y]", "by (rule imageI)"], ["proof (state)\nthis:\n  t \\<in> (+) tx ` .[Y]\n\ngoal (2 subgoals):\n 1. t \\<in> .[X \\<union> Y] \\<Longrightarrow>\n    t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y])\n 2. t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]) \\<Longrightarrow>\n    t \\<in> .[X \\<union> Y]", "with \\<open>tx \\<in> .[X]\\<close>"], ["proof (chain)\npicking this:\n  tx \\<in> .[X]\n  t \\<in> (+) tx ` .[Y]", "show \"t \\<in> ?B\""], ["proof (prove)\nusing this:\n  tx \\<in> .[X]\n  t \\<in> (+) tx ` .[Y]\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y])", ".."], ["proof (state)\nthis:\n  t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y])\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]) \\<Longrightarrow>\n    t \\<in> .[X \\<union> Y]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]) \\<Longrightarrow>\n    t \\<in> .[X \\<union> Y]", "assume \"t \\<in> ?B\""], ["proof (state)\nthis:\n  t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y])\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]) \\<Longrightarrow>\n    t \\<in> .[X \\<union> Y]", "then"], ["proof (chain)\npicking this:\n  t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y])", "obtain tx where \"tx \\<in> .[X]\" and \"t \\<in> (+) tx ` .[Y]\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y])\n\ngoal (1 subgoal):\n 1. (\\<And>tx.\n        \\<lbrakk>tx \\<in> .[X]; t \\<in> (+) tx ` .[Y]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  tx \\<in> .[X]\n  t \\<in> (+) tx ` .[Y]\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]) \\<Longrightarrow>\n    t \\<in> .[X \\<union> Y]", "from this(2)"], ["proof (chain)\npicking this:\n  t \\<in> (+) tx ` .[Y]", "obtain ty where \"ty \\<in> .[Y]\" and \"t = tx + ty\""], ["proof (prove)\nusing this:\n  t \\<in> (+) tx ` .[Y]\n\ngoal (1 subgoal):\n 1. (\\<And>ty.\n        \\<lbrakk>ty \\<in> .[Y]; t = tx + ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  ty \\<in> .[Y]\n  t = tx + ty\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]) \\<Longrightarrow>\n    t \\<in> .[X \\<union> Y]", "with \\<open>tx \\<in> .[X]\\<close>"], ["proof (chain)\npicking this:\n  tx \\<in> .[X]\n  ty \\<in> .[Y]\n  t = tx + ty", "show \"t \\<in> ?A\""], ["proof (prove)\nusing this:\n  tx \\<in> .[X]\n  ty \\<in> .[Y]\n  t = tx + ty\n\ngoal (1 subgoal):\n 1. t \\<in> .[X \\<union> Y]", "by (rule PPs_UnI)"], ["proof (state)\nthis:\n  t \\<in> .[X \\<union> Y]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t \\<in> .[X \\<union> Y]) = (t \\<in> (\\<Union>t\\<in>.[X]. (+) t ` .[Y]))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary PPs_insert: \".[insert x X] = (\\<Union>e. (+) (Poly_Mapping.single x e) ` .[X])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. .[insert x X] = (\\<Union>e. (+) (monomial e x) ` .[X])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. .[insert x X] = (\\<Union>e. (+) (monomial e x) ` .[X])", "have \".[insert x X] = .[{x} \\<union> X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. .[insert x X] = .[{x} \\<union> X]", "by simp"], ["proof (state)\nthis:\n  .[insert x X] = .[{x} \\<union> X]\n\ngoal (1 subgoal):\n 1. .[insert x X] = (\\<Union>e. (+) (monomial e x) ` .[X])", "also"], ["proof (state)\nthis:\n  .[insert x X] = .[{x} \\<union> X]\n\ngoal (1 subgoal):\n 1. .[insert x X] = (\\<Union>e. (+) (monomial e x) ` .[X])", "have \"... = (\\<Union>t\\<in>.[{x}]. (+) t ` .[X])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. .[{x} \\<union> X] = (\\<Union>t\\<in>.[{x}]. (+) t ` .[X])", "by (fact PPs_Un)"], ["proof (state)\nthis:\n  .[{x} \\<union> X] = (\\<Union>t\\<in>.[{x}]. (+) t ` .[X])\n\ngoal (1 subgoal):\n 1. .[insert x X] = (\\<Union>e. (+) (monomial e x) ` .[X])", "also"], ["proof (state)\nthis:\n  .[{x} \\<union> X] = (\\<Union>t\\<in>.[{x}]. (+) t ` .[X])\n\ngoal (1 subgoal):\n 1. .[insert x X] = (\\<Union>e. (+) (monomial e x) ` .[X])", "have \"... = (\\<Union>e. (+) (Poly_Mapping.single x e) ` .[X])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>t\\<in>.[{x}]. (+) t ` .[X]) =\n    (\\<Union>e. (+) (monomial e x) ` .[X])", "by (simp add: PPs_singleton)"], ["proof (state)\nthis:\n  (\\<Union>t\\<in>.[{x}]. (+) t ` .[X]) =\n  (\\<Union>e. (+) (monomial e x) ` .[X])\n\ngoal (1 subgoal):\n 1. .[insert x X] = (\\<Union>e. (+) (monomial e x) ` .[X])", "finally"], ["proof (chain)\npicking this:\n  .[insert x X] = (\\<Union>e. (+) (monomial e x) ` .[X])", "show ?thesis"], ["proof (prove)\nusing this:\n  .[insert x X] = (\\<Union>e. (+) (monomial e x) ` .[X])\n\ngoal (1 subgoal):\n 1. .[insert x X] = (\\<Union>e. (+) (monomial e x) ` .[X])", "."], ["proof (state)\nthis:\n  .[insert x X] = (\\<Union>e. (+) (monomial e x) ` .[X])\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary PPs_insertI:\n  assumes \"tx \\<in> .[X]\" and \"t = Poly_Mapping.single x e + tx\"\n  shows \"t \\<in> .[insert x X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> .[insert x X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> .[insert x X]", "from assms(1)"], ["proof (chain)\npicking this:\n  tx \\<in> .[X]", "have \"t \\<in> (+) (Poly_Mapping.single x e) ` .[X]\""], ["proof (prove)\nusing this:\n  tx \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t \\<in> (+) (monomial e x) ` .[X]", "unfolding assms(2)"], ["proof (prove)\nusing this:\n  tx \\<in> .[X]\n\ngoal (1 subgoal):\n 1. monomial e x + tx \\<in> (+) (monomial e x) ` .[X]", "by (rule imageI)"], ["proof (state)\nthis:\n  t \\<in> (+) (monomial e x) ` .[X]\n\ngoal (1 subgoal):\n 1. t \\<in> .[insert x X]", "with UNIV_I"], ["proof (chain)\npicking this:\n  ?x \\<in> UNIV\n  t \\<in> (+) (monomial e x) ` .[X]", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> UNIV\n  t \\<in> (+) (monomial e x) ` .[X]\n\ngoal (1 subgoal):\n 1. t \\<in> .[insert x X]", "unfolding PPs_insert"], ["proof (prove)\nusing this:\n  ?x \\<in> UNIV\n  t \\<in> (+) (monomial e x) ` .[X]\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<Union>e. (+) (monomial e x) ` .[X])", "by (rule UN_I)"], ["proof (state)\nthis:\n  t \\<in> .[insert x X]\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary PPs_insertE:\n  assumes \"t \\<in> .[insert x X]\"\n  obtains e tx where \"tx \\<in> .[X]\" and \"t = Poly_Mapping.single x e + tx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tx e.\n        \\<lbrakk>tx \\<in> .[X]; t = monomial e x + tx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>tx e.\n        \\<lbrakk>tx \\<in> .[X]; t = monomial e x + tx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  t \\<in> .[insert x X]", "obtain e where \"t \\<in> (+) (Poly_Mapping.single x e) ` .[X]\""], ["proof (prove)\nusing this:\n  t \\<in> .[insert x X]\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        t \\<in> (+) (monomial e x) ` .[X] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding PPs_insert"], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>e. (+) (monomial e x) ` .[X])\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        t \\<in> (+) (monomial e x) ` .[X] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t \\<in> (+) (monomial e x) ` .[X]\n\ngoal (1 subgoal):\n 1. (\\<And>tx e.\n        \\<lbrakk>tx \\<in> .[X]; t = monomial e x + tx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  t \\<in> (+) (monomial e x) ` .[X]", "obtain tx where \"tx \\<in> .[X]\" and \"t = Poly_Mapping.single x e + tx\""], ["proof (prove)\nusing this:\n  t \\<in> (+) (monomial e x) ` .[X]\n\ngoal (1 subgoal):\n 1. (\\<And>tx.\n        \\<lbrakk>tx \\<in> .[X]; t = monomial e x + tx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  tx \\<in> .[X]\n  t = monomial e x + tx\n\ngoal (1 subgoal):\n 1. (\\<And>tx e.\n        \\<lbrakk>tx \\<in> .[X]; t = monomial e x + tx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  tx \\<in> .[X]\n  t = monomial e x + tx\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PPs_Int: \".[X \\<inter> Y] = .[X] \\<inter> .[Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. .[X \\<inter> Y] = .[X] \\<inter> .[Y]", "by (auto simp: PPs_def)"], ["", "lemma PPs_INT: \".[\\<Inter> X] = \\<Inter> (PPs ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. .[\\<Inter> X] = \\<Inter> (PPs ` X)", "by (auto simp: PPs_def)"], ["", "subsubsection \\<open>@{const Polys}\\<close>"], ["", "lemma Polys_alt: \"P[X] = {p. indets p \\<subseteq> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[X] = {p. indets p \\<subseteq> X}", "by (auto simp: Polys_def PPs_def indets_def)"], ["", "lemma PolysI: \"keys p \\<subseteq> .[X] \\<Longrightarrow> p \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[X] \\<Longrightarrow> p \\<in> P[X]", "by (simp add: Polys_def)"], ["", "lemma PolysI_alt: \"indets p \\<subseteq> X \\<Longrightarrow> p \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets p \\<subseteq> X \\<Longrightarrow> p \\<in> P[X]", "by (simp add: Polys_alt)"], ["", "lemma PolysD:\n  assumes \"p \\<in> P[X]\"\n  shows \"keys p \\<subseteq> .[X]\" and \"indets p \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[X] &&& indets p \\<subseteq> X", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[X] &&& indets p \\<subseteq> X", "by (simp add: Polys_def, simp add: Polys_alt)"], ["", "lemma Polys_empty: \"P[{}] = ((range (Poly_Mapping.single 0))::(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::zero) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[{}] = range (Poly_Mapping.single 0)", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> P[{}]) = (x \\<in> range (Poly_Mapping.single 0))", "fix p :: \"('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::zero\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> P[{}]) = (x \\<in> range (Poly_Mapping.single 0))", "show \"p \\<in> P[{}] \\<longleftrightarrow> p \\<in> range (Poly_Mapping.single 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<in> P[{}]) = (p \\<in> range (Poly_Mapping.single 0))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<in> P[{}] \\<Longrightarrow> p \\<in> range (Poly_Mapping.single 0)\n 2. p \\<in> range (Poly_Mapping.single 0) \\<Longrightarrow> p \\<in> P[{}]", "assume \"p \\<in> P[{}]\""], ["proof (state)\nthis:\n  p \\<in> P[{}]\n\ngoal (2 subgoals):\n 1. p \\<in> P[{}] \\<Longrightarrow> p \\<in> range (Poly_Mapping.single 0)\n 2. p \\<in> range (Poly_Mapping.single 0) \\<Longrightarrow> p \\<in> P[{}]", "hence \"keys p \\<subseteq> .[{}]\""], ["proof (prove)\nusing this:\n  p \\<in> P[{}]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[{}]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[{}]\n\ngoal (2 subgoals):\n 1. p \\<in> P[{}] \\<Longrightarrow> p \\<in> range (Poly_Mapping.single 0)\n 2. p \\<in> range (Poly_Mapping.single 0) \\<Longrightarrow> p \\<in> P[{}]", "also"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[{}]\n\ngoal (2 subgoals):\n 1. p \\<in> P[{}] \\<Longrightarrow> p \\<in> range (Poly_Mapping.single 0)\n 2. p \\<in> range (Poly_Mapping.single 0) \\<Longrightarrow> p \\<in> P[{}]", "have \"... = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. .[{}] = {0}", "by simp"], ["proof (state)\nthis:\n  .[{}] = {0}\n\ngoal (2 subgoals):\n 1. p \\<in> P[{}] \\<Longrightarrow> p \\<in> range (Poly_Mapping.single 0)\n 2. p \\<in> range (Poly_Mapping.single 0) \\<Longrightarrow> p \\<in> P[{}]", "finally"], ["proof (chain)\npicking this:\n  keys p \\<subseteq> {0}", "have \"keys p \\<subseteq> {0}\""], ["proof (prove)\nusing this:\n  keys p \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> {0}", "."], ["proof (state)\nthis:\n  keys p \\<subseteq> {0}\n\ngoal (2 subgoals):\n 1. p \\<in> P[{}] \\<Longrightarrow> p \\<in> range (Poly_Mapping.single 0)\n 2. p \\<in> range (Poly_Mapping.single 0) \\<Longrightarrow> p \\<in> P[{}]", "hence \"Poly_Mapping.single 0 (lookup p 0) = p\""], ["proof (prove)\nusing this:\n  keys p \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. monomial (lookup p 0) 0 = p", "by (rule keys_subset_singleton_imp_monomial)"], ["proof (state)\nthis:\n  monomial (lookup p 0) 0 = p\n\ngoal (2 subgoals):\n 1. p \\<in> P[{}] \\<Longrightarrow> p \\<in> range (Poly_Mapping.single 0)\n 2. p \\<in> range (Poly_Mapping.single 0) \\<Longrightarrow> p \\<in> P[{}]", "from this[symmetric] UNIV_I"], ["proof (chain)\npicking this:\n  p = monomial (lookup p 0) 0\n  ?x \\<in> UNIV", "show \"p \\<in> range (Poly_Mapping.single 0)\""], ["proof (prove)\nusing this:\n  p = monomial (lookup p 0) 0\n  ?x \\<in> UNIV\n\ngoal (1 subgoal):\n 1. p \\<in> range (Poly_Mapping.single 0)", ".."], ["proof (state)\nthis:\n  p \\<in> range (Poly_Mapping.single 0)\n\ngoal (1 subgoal):\n 1. p \\<in> range (Poly_Mapping.single 0) \\<Longrightarrow> p \\<in> P[{}]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> range (Poly_Mapping.single 0) \\<Longrightarrow> p \\<in> P[{}]", "assume \"p \\<in> range (Poly_Mapping.single 0)\""], ["proof (state)\nthis:\n  p \\<in> range (Poly_Mapping.single 0)\n\ngoal (1 subgoal):\n 1. p \\<in> range (Poly_Mapping.single 0) \\<Longrightarrow> p \\<in> P[{}]", "then"], ["proof (chain)\npicking this:\n  p \\<in> range (Poly_Mapping.single 0)", "obtain c where \"p = monomial c 0\""], ["proof (prove)\nusing this:\n  p \\<in> range (Poly_Mapping.single 0)\n\ngoal (1 subgoal):\n 1. (\\<And>c. p = monomial c 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p = monomial c 0\n\ngoal (1 subgoal):\n 1. p \\<in> range (Poly_Mapping.single 0) \\<Longrightarrow> p \\<in> P[{}]", "thus \"p \\<in> P[{}]\""], ["proof (prove)\nusing this:\n  p = monomial c 0\n\ngoal (1 subgoal):\n 1. p \\<in> P[{}]", "by (simp add: Polys_def)"], ["proof (state)\nthis:\n  p \\<in> P[{}]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (p \\<in> P[{}]) = (p \\<in> range (Poly_Mapping.single 0))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Polys_UNIV [simp]: \"P[UNIV] = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[UNIV] = UNIV", "by (simp add: Polys_def)"], ["", "lemma zero_in_Polys: \"0 \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> P[X]", "by (simp add: Polys_def)"], ["", "lemma one_in_Polys: \"1 \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> P[X]", "by (simp add: Polys_def zero_in_PPs)"], ["", "lemma Polys_mono: \"X \\<subseteq> Y \\<Longrightarrow> P[X] \\<subseteq> P[Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> Y \\<Longrightarrow> P[X] \\<subseteq> P[Y]", "by (auto simp: Polys_alt)"], ["", "lemma Polys_closed_monomial: \"t \\<in> .[X] \\<Longrightarrow> monomial c t \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> .[X] \\<Longrightarrow> monomial c t \\<in> P[X]", "using indets_monomial_subset[where c=c and t=t]"], ["proof (prove)\nusing this:\n  indets (monomial c t) \\<subseteq> keys t\n\ngoal (1 subgoal):\n 1. t \\<in> .[X] \\<Longrightarrow> monomial c t \\<in> P[X]", "by (auto simp: Polys_alt PPs_def)"], ["", "lemma Polys_closed_plus: \"p \\<in> P[X] \\<Longrightarrow> q \\<in> P[X] \\<Longrightarrow> p + q \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> P[X]; q \\<in> P[X]\\<rbrakk>\n    \\<Longrightarrow> p + q \\<in> P[X]", "using indets_plus_subset[of p q]"], ["proof (prove)\nusing this:\n  indets (p + q) \\<subseteq> indets p \\<union> indets q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> P[X]; q \\<in> P[X]\\<rbrakk>\n    \\<Longrightarrow> p + q \\<in> P[X]", "by (auto simp: Polys_alt PPs_def)"], ["", "lemma Polys_closed_uminus: \"p \\<in> P[X] \\<Longrightarrow> -p \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<Longrightarrow> - p \\<in> P[X]", "by (simp add: Polys_def keys_uminus)"], ["", "lemma Polys_closed_minus: \"p \\<in> P[X] \\<Longrightarrow> q \\<in> P[X] \\<Longrightarrow> p - q \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> P[X]; q \\<in> P[X]\\<rbrakk>\n    \\<Longrightarrow> p - q \\<in> P[X]", "using indets_minus_subset[of p q]"], ["proof (prove)\nusing this:\n  indets (p - q) \\<subseteq> indets p \\<union> indets q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> P[X]; q \\<in> P[X]\\<rbrakk>\n    \\<Longrightarrow> p - q \\<in> P[X]", "by (auto simp: Polys_alt PPs_def)"], ["", "lemma Polys_closed_monom_mult: \"t \\<in> .[X] \\<Longrightarrow> p \\<in> P[X] \\<Longrightarrow> punit.monom_mult c t p \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]\\<rbrakk>\n    \\<Longrightarrow> punit.monom_mult c t p \\<in> P[X]", "using indets_monom_mult_subset[of c t p]"], ["proof (prove)\nusing this:\n  indets (punit.monom_mult c t p) \\<subseteq> keys t \\<union> indets p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]\\<rbrakk>\n    \\<Longrightarrow> punit.monom_mult c t p \\<in> P[X]", "by (auto simp: Polys_alt PPs_def)"], ["", "corollary Polys_closed_map_scale: \"p \\<in> P[X] \\<Longrightarrow> (c::_::semiring_0) \\<cdot> p \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<Longrightarrow> c \\<cdot> p \\<in> P[X]", "unfolding punit.map_scale_eq_monom_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<Longrightarrow> punit.monom_mult c 0 p \\<in> P[X]", "using zero_in_PPs"], ["proof (prove)\nusing this:\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<Longrightarrow> punit.monom_mult c 0 p \\<in> P[X]", "by (rule Polys_closed_monom_mult)"], ["", "lemma Polys_closed_times: \"p \\<in> P[X] \\<Longrightarrow> q \\<in> P[X] \\<Longrightarrow> p * q \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> P[X]; q \\<in> P[X]\\<rbrakk>\n    \\<Longrightarrow> p * q \\<in> P[X]", "using indets_times_subset[of p q]"], ["proof (prove)\nusing this:\n  indets (p * q) \\<subseteq> indets p \\<union> indets q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> P[X]; q \\<in> P[X]\\<rbrakk>\n    \\<Longrightarrow> p * q \\<in> P[X]", "by (auto simp: Polys_alt PPs_def)"], ["", "lemma Polys_closed_power: \"p \\<in> P[X] \\<Longrightarrow> p ^ m \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<Longrightarrow> p ^ m \\<in> P[X]", "by (induct m) (auto intro: one_in_Polys Polys_closed_times)"], ["", "lemma Polys_closed_sum: \"(\\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> P[X]) \\<Longrightarrow> sum f A \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> P[X]) \\<Longrightarrow>\n    sum f A \\<in> P[X]", "by (induct A rule: infinite_finite_induct) (auto intro: zero_in_Polys Polys_closed_plus)"], ["", "lemma Polys_closed_prod: \"(\\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> P[X]) \\<Longrightarrow> prod f A \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> P[X]) \\<Longrightarrow>\n    prod f A \\<in> P[X]", "by (induct A rule: infinite_finite_induct) (auto intro: one_in_Polys Polys_closed_times)"], ["", "lemma Polys_closed_sum_list: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]) \\<Longrightarrow> sum_list xs \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]) \\<Longrightarrow>\n    sum_list xs \\<in> P[X]", "by (induct xs) (auto intro: zero_in_Polys Polys_closed_plus)"], ["", "lemma Polys_closed_except: \"p \\<in> P[X] \\<Longrightarrow> except p T \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<Longrightarrow> except p T \\<in> P[X]", "by (auto intro!: PolysI simp: keys_except dest!: PolysD(1))"], ["", "lemma times_in_PolysD:\n  assumes \"p * q \\<in> P[X]\" and \"p \\<in> P[X]\" and \"p \\<noteq> (0::('x::linorder \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::semiring_no_zero_divisors)\"\n  shows \"q \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> P[X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> P[X]", "define qX where \"qX = except q (- .[X])\""], ["proof (state)\nthis:\n  qX = except q (- .[X])\n\ngoal (1 subgoal):\n 1. q \\<in> P[X]", "define qY where \"qY = except q .[X]\""], ["proof (state)\nthis:\n  qY = except q .[X]\n\ngoal (1 subgoal):\n 1. q \\<in> P[X]", "have q: \"q = qX + qY\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = qX + qY", "by (simp only: qX_def qY_def add.commute flip: except_decomp)"], ["proof (state)\nthis:\n  q = qX + qY\n\ngoal (1 subgoal):\n 1. q \\<in> P[X]", "have \"qX \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qX \\<in> P[X]", "by (rule PolysI) (simp add: qX_def keys_except)"], ["proof (state)\nthis:\n  qX \\<in> P[X]\n\ngoal (1 subgoal):\n 1. q \\<in> P[X]", "with assms(2)"], ["proof (chain)\npicking this:\n  p \\<in> P[X]\n  qX \\<in> P[X]", "have \"p * qX \\<in> P[X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n  qX \\<in> P[X]\n\ngoal (1 subgoal):\n 1. p * qX \\<in> P[X]", "by (rule Polys_closed_times)"], ["proof (state)\nthis:\n  p * qX \\<in> P[X]\n\ngoal (1 subgoal):\n 1. q \\<in> P[X]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> P[X]", "proof (cases \"qY = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. qY = 0 \\<Longrightarrow> q \\<in> P[X]\n 2. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "case True"], ["proof (state)\nthis:\n  qY = 0\n\ngoal (2 subgoals):\n 1. qY = 0 \\<Longrightarrow> q \\<in> P[X]\n 2. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "with \\<open>qX \\<in> P[X]\\<close>"], ["proof (chain)\npicking this:\n  qX \\<in> P[X]\n  qY = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  qX \\<in> P[X]\n  qY = 0\n\ngoal (1 subgoal):\n 1. q \\<in> P[X]", "by (simp add: q)"], ["proof (state)\nthis:\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "case False"], ["proof (state)\nthis:\n  qY \\<noteq> 0\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "with assms(3)"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  qY \\<noteq> 0", "have \"p * qY \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  qY \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p * qY \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  p * qY \\<noteq> 0\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "hence \"keys (p * qY) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p * qY \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys (p * qY) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys (p * qY) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "then"], ["proof (chain)\npicking this:\n  keys (p * qY) \\<noteq> {}", "obtain t where \"t \\<in> keys (p * qY)\""], ["proof (prove)\nusing this:\n  keys (p * qY) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> keys (p * qY) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> keys (p * qY)\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "then"], ["proof (chain)\npicking this:\n  t \\<in> keys (p * qY)", "obtain t1 t2 where \"t2 \\<in> keys qY\" and t: \"t = t1 + t2\""], ["proof (prove)\nusing this:\n  t \\<in> keys (p * qY)\n\ngoal (1 subgoal):\n 1. (\\<And>t2 t1.\n        \\<lbrakk>t2 \\<in> keys qY; t = t1 + t2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_timesE)"], ["proof (state)\nthis:\n  t2 \\<in> keys qY\n  t = t1 + t2\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "have \"t \\<notin> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> .[X]", "unfolding t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t1 + t2 \\<notin> .[X]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t1 + t2 \\<in> .[X] \\<Longrightarrow> False", "assume \"t1 + t2 \\<in> .[X]\""], ["proof (state)\nthis:\n  t1 + t2 \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t1 + t2 \\<in> .[X] \\<Longrightarrow> False", "hence \"t1 + t2 - t1 \\<in> .[X]\""], ["proof (prove)\nusing this:\n  t1 + t2 \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t1 + t2 - t1 \\<in> .[X]", "by (rule PPs_closed_minus)"], ["proof (state)\nthis:\n  t1 + t2 - t1 \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t1 + t2 \\<in> .[X] \\<Longrightarrow> False", "hence \"t2 \\<in> .[X]\""], ["proof (prove)\nusing this:\n  t1 + t2 - t1 \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t2 \\<in> .[X]", "by simp"], ["proof (state)\nthis:\n  t2 \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t1 + t2 \\<in> .[X] \\<Longrightarrow> False", "with \\<open>t2 \\<in> keys qY\\<close>"], ["proof (chain)\npicking this:\n  t2 \\<in> keys qY\n  t2 \\<in> .[X]", "show False"], ["proof (prove)\nusing this:\n  t2 \\<in> keys qY\n  t2 \\<in> .[X]\n\ngoal (1 subgoal):\n 1. False", "by (simp add: qY_def keys_except)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<notin> .[X]\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "have \"t \\<notin> keys (p * qX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> keys (p * qX)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> keys (p * qX) \\<Longrightarrow> False", "assume \"t \\<in> keys (p * qX)\""], ["proof (state)\nthis:\n  t \\<in> keys (p * qX)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (p * qX) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  t \\<in> keys (p * qX)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (p * qX) \\<Longrightarrow> False", "from \\<open>p * qX \\<in> P[X]\\<close>"], ["proof (chain)\npicking this:\n  p * qX \\<in> P[X]", "have \"\\<dots> \\<subseteq> .[X]\""], ["proof (prove)\nusing this:\n  p * qX \\<in> P[X]\n\ngoal (1 subgoal):\n 1. keys (p * qX) \\<subseteq> .[X]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys (p * qX) \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. t \\<in> keys (p * qX) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  t \\<in> .[X]", "have \"t \\<in> .[X]\""], ["proof (prove)\nusing this:\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t \\<in> .[X]", "."], ["proof (state)\nthis:\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t \\<in> keys (p * qX) \\<Longrightarrow> False", "with \\<open>t \\<notin> .[X]\\<close>"], ["proof (chain)\npicking this:\n  t \\<notin> .[X]\n  t \\<in> .[X]", "show False"], ["proof (prove)\nusing this:\n  t \\<notin> .[X]\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<notin> keys (p * qX)\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "with \\<open>t \\<in> keys (p * qY)\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys (p * qY)\n  t \\<notin> keys (p * qX)", "have \"t \\<in> keys (p * qX + p * qY)\""], ["proof (prove)\nusing this:\n  t \\<in> keys (p * qY)\n  t \\<notin> keys (p * qX)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (p * qX + p * qY)", "by (rule in_keys_plusI2)"], ["proof (state)\nthis:\n  t \\<in> keys (p * qX + p * qY)\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "also"], ["proof (state)\nthis:\n  t \\<in> keys (p * qX + p * qY)\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "have \"\\<dots> = keys (p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p * qX + p * qY) = keys (p * q)", "by (simp only: q algebra_simps)"], ["proof (state)\nthis:\n  keys (p * qX + p * qY) = keys (p * q)\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "finally"], ["proof (chain)\npicking this:\n  t \\<in> keys (p * q)", "have \"p * q \\<notin> P[X]\""], ["proof (prove)\nusing this:\n  t \\<in> keys (p * q)\n\ngoal (1 subgoal):\n 1. p * q \\<notin> P[X]", "using \\<open>t \\<notin> .[X]\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> keys (p * q)\n  t \\<notin> .[X]\n\ngoal (1 subgoal):\n 1. p * q \\<notin> P[X]", "by (auto simp: Polys_def)"], ["proof (state)\nthis:\n  p * q \\<notin> P[X]\n\ngoal (1 subgoal):\n 1. qY \\<noteq> 0 \\<Longrightarrow> q \\<in> P[X]", "thus ?thesis"], ["proof (prove)\nusing this:\n  p * q \\<notin> P[X]\n\ngoal (1 subgoal):\n 1. q \\<in> P[X]", "using assms(1)"], ["proof (prove)\nusing this:\n  p * q \\<notin> P[X]\n  p * q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. q \\<in> P[X]", ".."], ["proof (state)\nthis:\n  q \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_mapping_plus_induct_Polys [consumes 1, case_names 0 plus]:\n  assumes \"p \\<in> P[X]\" and \"P 0\"\n    and \"\\<And>p c t. t \\<in> .[X] \\<Longrightarrow> p \\<in> P[X] \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> t \\<notin> keys p \\<Longrightarrow> P p \\<Longrightarrow> P (monomial c t + p)\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "using assms(1)"], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. P p", "proof (induct p rule: poly_mapping_plus_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> P[X] \\<Longrightarrow> P 0\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "case 1"], ["proof (state)\nthis:\n  0 \\<in> P[X]\n\ngoal (2 subgoals):\n 1. 0 \\<in> P[X] \\<Longrightarrow> P 0\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P 0", "by (fact assms(2))"], ["proof (state)\nthis:\n  P 0\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "case step: (2 p c t)"], ["proof (state)\nthis:\n  c \\<noteq> (0::'b)\n  t \\<notin> keys p\n  p \\<in> P[X] \\<Longrightarrow> P p\n  monomial c t + p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "from step.hyps(1)"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'b)", "have 1: \"keys (monomial c t) = {t}\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. keys (monomial c t) = {t}", "by simp"], ["proof (state)\nthis:\n  keys (monomial c t) = {t}\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "also"], ["proof (state)\nthis:\n  keys (monomial c t) = {t}\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "from step.hyps(2)"], ["proof (chain)\npicking this:\n  t \\<notin> keys p", "have \"\\<dots> \\<inter> keys p = {}\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. {t} \\<inter> keys p = {}", "by simp"], ["proof (state)\nthis:\n  {t} \\<inter> keys p = {}\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "finally"], ["proof (chain)\npicking this:\n  keys (monomial c t) \\<inter> keys p = {}", "have \"keys (monomial c t + p) = keys (monomial c t) \\<union> keys p\""], ["proof (prove)\nusing this:\n  keys (monomial c t) \\<inter> keys p = {}\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = keys (monomial c t) \\<union> keys p", "by (rule keys_add[symmetric])"], ["proof (state)\nthis:\n  keys (monomial c t + p) = keys (monomial c t) \\<union> keys p\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "hence \"keys (monomial c t + p) = insert t (keys p)\""], ["proof (prove)\nusing this:\n  keys (monomial c t + p) = keys (monomial c t) \\<union> keys p\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = insert t (keys p)", "by (simp only: 1 flip: insert_is_Un)"], ["proof (state)\nthis:\n  keys (monomial c t + p) = insert t (keys p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "moreover"], ["proof (state)\nthis:\n  keys (monomial c t + p) = insert t (keys p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "from step.prems(1)"], ["proof (chain)\npicking this:\n  monomial c t + p \\<in> P[X]", "have \"keys (monomial c t + p) \\<subseteq> .[X]\""], ["proof (prove)\nusing this:\n  monomial c t + p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) \\<subseteq> .[X]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys (monomial c t + p) \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "ultimately"], ["proof (chain)\npicking this:\n  keys (monomial c t + p) = insert t (keys p)\n  keys (monomial c t + p) \\<subseteq> .[X]", "have \"t \\<in> .[X]\" and \"keys p \\<subseteq> .[X]\""], ["proof (prove)\nusing this:\n  keys (monomial c t + p) = insert t (keys p)\n  keys (monomial c t + p) \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. t \\<in> .[X] &&& keys p \\<subseteq> .[X]", "by blast+"], ["proof (state)\nthis:\n  t \\<in> .[X]\n  keys p \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "from this(2)"], ["proof (chain)\npicking this:\n  keys p \\<subseteq> .[X]", "have \"p \\<in> P[X]\""], ["proof (prove)\nusing this:\n  keys p \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. p \\<in> P[X]", "by (rule PolysI)"], ["proof (state)\nthis:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "hence \"P p\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. P p", "by (rule step.hyps)"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        p \\<in> P[X] \\<Longrightarrow> P p;\n        monomial c t + p \\<in> P[X]\\<rbrakk>\n       \\<Longrightarrow> P (monomial c t + p)", "with \\<open>t \\<in> .[X]\\<close> \\<open>p \\<in> P[X]\\<close> step.hyps(1, 2)"], ["proof (chain)\npicking this:\n  t \\<in> .[X]\n  p \\<in> P[X]\n  c \\<noteq> (0::'b)\n  t \\<notin> keys p\n  P p", "show ?case"], ["proof (prove)\nusing this:\n  t \\<in> .[X]\n  p \\<in> P[X]\n  c \\<noteq> (0::'b)\n  t \\<notin> keys p\n  P p\n\ngoal (1 subgoal):\n 1. P (monomial c t + p)", "by (rule assms(3))"], ["proof (state)\nthis:\n  P (monomial c t + p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Polys_Int: \"P[X \\<inter> Y] = P[X] \\<inter> P[Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[X \\<inter> Y] = P[X] \\<inter> P[Y]", "by (auto simp: Polys_def PPs_Int)"], ["", "lemma Polys_INT: \"P[\\<Inter> X] = \\<Inter> (Polys ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[\\<Inter> X] = \\<Inter> (Polys ` X)", "by (auto simp: Polys_def PPs_INT)"], ["", "subsection \\<open>Substitution Homomorphism\\<close>"], ["", "text \\<open>The substitution homomorphism defined here is more general than @{const insertion}, since\n  it replaces indeterminates by @{emph \\<open>polynomials\\<close>} rather than coefficients, and therefore\n  constructs new polynomials.\\<close>"], ["", "definition subst_pp :: \"('x \\<Rightarrow> (('y \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a)) \\<Rightarrow> ('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> (('y \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1)\"\n  where \"subst_pp f t = (\\<Prod>x\\<in>keys t. (f x) ^ (lookup t x))\""], ["", "definition poly_subst :: \"('x \\<Rightarrow> (('y \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a)) \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> (('y \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1)\"\n  where \"poly_subst f p = (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp f t))\""], ["", "lemma subst_pp_alt: \"subst_pp f t = (\\<Prod>x. (f x) ^ (lookup t x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp f t = (\\<Prod>x. f x ^ lookup t x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_pp f t = (\\<Prod>x. f x ^ lookup t x)", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"subst_pp f t = (\\<Prod>x. if x \\<in> keys t then (f x) ^ (lookup t x) else 1)\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. subst_pp f t =\n    (\\<Prod>x. if x \\<in> keys t then f x ^ lookup t x else 1)", "unfolding subst_pp_def"], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>keys t. f x ^ lookup t x) =\n    (\\<Prod>x. if x \\<in> keys t then f x ^ lookup t x else 1)", "by (rule Prod_any.conditionalize)"], ["proof (state)\nthis:\n  subst_pp f t = (\\<Prod>x. if x \\<in> keys t then f x ^ lookup t x else 1)\n\ngoal (1 subgoal):\n 1. subst_pp f t = (\\<Prod>x. f x ^ lookup t x)", "also"], ["proof (state)\nthis:\n  subst_pp f t = (\\<Prod>x. if x \\<in> keys t then f x ^ lookup t x else 1)\n\ngoal (1 subgoal):\n 1. subst_pp f t = (\\<Prod>x. f x ^ lookup t x)", "have \"... = (\\<Prod>x. (f x) ^ (lookup t x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x. if x \\<in> keys t then f x ^ lookup t x else 1) =\n    (\\<Prod>x. f x ^ lookup t x)", "by (rule Prod_any.cong) (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Prod>x. if x \\<in> keys t then f x ^ lookup t x else 1) =\n  (\\<Prod>x. f x ^ lookup t x)\n\ngoal (1 subgoal):\n 1. subst_pp f t = (\\<Prod>x. f x ^ lookup t x)", "finally"], ["proof (chain)\npicking this:\n  subst_pp f t = (\\<Prod>x. f x ^ lookup t x)", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_pp f t = (\\<Prod>x. f x ^ lookup t x)\n\ngoal (1 subgoal):\n 1. subst_pp f t = (\\<Prod>x. f x ^ lookup t x)", "."], ["proof (state)\nthis:\n  subst_pp f t = (\\<Prod>x. f x ^ lookup t x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_pp_zero [simp]: \"subst_pp f 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp f 0 = 1", "by (simp add: subst_pp_def)"], ["", "lemma subst_pp_trivial_not_zero:\n  assumes \"t \\<noteq> 0\"\n  shows \"subst_pp (\\<lambda>_. 0) t = (0::(_ \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp (\\<lambda>_. 0) t = 0", "unfolding subst_pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>keys t. 0 ^ lookup t x) = 0", "using finite_keys"], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>keys t. 0 ^ lookup t x) = 0", "proof (rule prod_zero)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>keys t. 0 ^ lookup t a = 0", "from assms"], ["proof (chain)\npicking this:\n  t \\<noteq> 0", "have \"keys t \\<noteq> {}\""], ["proof (prove)\nusing this:\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys t \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>keys t. 0 ^ lookup t a = 0", "then"], ["proof (chain)\npicking this:\n  keys t \\<noteq> {}", "obtain x where \"x \\<in> keys t\""], ["proof (prove)\nusing this:\n  keys t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> keys t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>keys t. 0 ^ lookup t a = 0", "thus \"\\<exists>x\\<in>keys t. 0 ^ lookup t x = (0::(_ \\<Rightarrow>\\<^sub>0 'b))\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>keys t. 0 ^ lookup t x = 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 ^ lookup t x = 0", "from \\<open>x \\<in> keys t\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> keys t", "have \"0 < lookup t x\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. 0 < lookup t x", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  0 < lookup t x\n\ngoal (1 subgoal):\n 1. 0 ^ lookup t x = 0", "thus \"0 ^ lookup t x = (0::(_ \\<Rightarrow>\\<^sub>0 'b))\""], ["proof (prove)\nusing this:\n  0 < lookup t x\n\ngoal (1 subgoal):\n 1. 0 ^ lookup t x = 0", "by (rule Power.semiring_1_class.zero_power)"], ["proof (state)\nthis:\n  0 ^ lookup t x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x\\<in>keys t. 0 ^ lookup t x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_pp_single: \"subst_pp f (Poly_Mapping.single x e) = (f x) ^ e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp f (monomial e x) = f x ^ e", "by (simp add: subst_pp_def)"], ["", "corollary subst_pp_trivial: \"subst_pp (\\<lambda>_. 0) t = (if t = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp (\\<lambda>_. 0) t = (if t = 0 then 1 else 0)", "by (simp split: if_split add: subst_pp_trivial_not_zero)"], ["", "lemma power_lookup_not_one_subset_keys: \"{x. f x ^ (lookup t x) \\<noteq> 1} \\<subseteq> keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. f x ^ lookup t x \\<noteq> (1::'b)} \\<subseteq> keys t", "proof (rule, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       f x ^ lookup t x \\<noteq> (1::'b) \\<Longrightarrow> x \\<in> keys t", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       f x ^ lookup t x \\<noteq> (1::'b) \\<Longrightarrow> x \\<in> keys t", "assume \"f x ^ (lookup t x) \\<noteq> 1\""], ["proof (state)\nthis:\n  f x ^ lookup t x \\<noteq> (1::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       f x ^ lookup t x \\<noteq> (1::'b) \\<Longrightarrow> x \\<in> keys t", "thus \"x \\<in> keys t\""], ["proof (prove)\nusing this:\n  f x ^ lookup t x \\<noteq> (1::'b)\n\ngoal (1 subgoal):\n 1. x \\<in> keys t", "unfolding in_keys_iff"], ["proof (prove)\nusing this:\n  f x ^ lookup t x \\<noteq> (1::'b)\n\ngoal (1 subgoal):\n 1. lookup t x \\<noteq> 0", "by (metis power_0)"], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary finite_power_lookup_not_one: \"finite {x. f x ^ (lookup t x) \\<noteq> 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. f x ^ lookup t x \\<noteq> (1::'b)}", "by (rule finite_subset, fact power_lookup_not_one_subset_keys, fact finite_keys)"], ["", "lemma subst_pp_plus: \"subst_pp f (s + t) = subst_pp f s * subst_pp f t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp f (s + t) = subst_pp f s * subst_pp f t", "by (simp add: subst_pp_alt lookup_add power_add, rule Prod_any.distrib, (fact finite_power_lookup_not_one)+)"], ["", "lemma subst_pp_id:\n  assumes \"\\<And>x. x \\<in> keys t \\<Longrightarrow> f x = monomial 1 (Poly_Mapping.single x 1)\"\n  shows \"subst_pp f t = monomial 1 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp f t = monomial (1::'b) t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_pp f t = monomial (1::'b) t", "have \"subst_pp f t = (\\<Prod>x\\<in>keys t. monomial 1 (Poly_Mapping.single x (lookup t x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp f t =\n    (\\<Prod>x\\<in>keys t. monomial (1::'b) (monomial (lookup t x) x))", "proof (simp only: subst_pp_def, rule prod.cong, fact refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       f x ^ lookup t x = monomial (1::'b) (monomial (lookup t x) x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       f x ^ lookup t x = monomial (1::'b) (monomial (lookup t x) x)", "assume \"x \\<in> keys t\""], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       f x ^ lookup t x = monomial (1::'b) (monomial (lookup t x) x)", "thus \"f x ^ lookup t x = monomial 1 (Poly_Mapping.single x (lookup t x))\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. f x ^ lookup t x = monomial (1::'b) (monomial (lookup t x) x)", "by (simp add: assms monomial_single_power)"], ["proof (state)\nthis:\n  f x ^ lookup t x = monomial (1::'b) (monomial (lookup t x) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_pp f t =\n  (\\<Prod>x\\<in>keys t. monomial (1::'b) (monomial (lookup t x) x))\n\ngoal (1 subgoal):\n 1. subst_pp f t = monomial (1::'b) t", "also"], ["proof (state)\nthis:\n  subst_pp f t =\n  (\\<Prod>x\\<in>keys t. monomial (1::'b) (monomial (lookup t x) x))\n\ngoal (1 subgoal):\n 1. subst_pp f t = monomial (1::'b) t", "have \"... = monomial 1 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>keys t. monomial (1::'b) (monomial (lookup t x) x)) =\n    monomial (1::'b) t", "by (simp add: punit.monomial_prod_sum[symmetric] poly_mapping_sum_monomials)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>keys t. monomial (1::'b) (monomial (lookup t x) x)) =\n  monomial (1::'b) t\n\ngoal (1 subgoal):\n 1. subst_pp f t = monomial (1::'b) t", "finally"], ["proof (chain)\npicking this:\n  subst_pp f t = monomial (1::'b) t", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_pp f t = monomial (1::'b) t\n\ngoal (1 subgoal):\n 1. subst_pp f t = monomial (1::'b) t", "."], ["proof (state)\nthis:\n  subst_pp f t = monomial (1::'b) t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_indets_subst_ppE:\n  assumes \"x \\<in> indets (subst_pp f t)\"\n  obtains y where \"y \\<in> keys t\" and \"x \\<in> indets (f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms"], ["proof (state)\nthis:\n  x \\<in> indets (subst_pp f t)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  x \\<in> indets (subst_pp f t)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"indets (subst_pp f t) \\<subseteq> (\\<Union>y\\<in>keys t. indets ((f y) ^ (lookup t y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (subst_pp f t)\n    \\<subseteq> (\\<Union>y\\<in>keys t. indets (f y ^ lookup t y))", "unfolding subst_pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (\\<Prod>x\\<in>keys t. f x ^ lookup t x)\n    \\<subseteq> (\\<Union>y\\<in>keys t. indets (f y ^ lookup t y))", "by (rule indets_prod_subset)"], ["proof (state)\nthis:\n  indets (subst_pp f t)\n  \\<subseteq> (\\<Union>y\\<in>keys t. indets (f y ^ lookup t y))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>y\\<in>keys t. indets (f y ^ lookup t y))", "obtain y where \"y \\<in> keys t\" and \"x \\<in> indets ((f y) ^ (lookup t y))\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>y\\<in>keys t. indets (f y ^ lookup t y))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y ^ lookup t y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  y \\<in> keys t\n  x \\<in> indets (f y ^ lookup t y)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  x \\<in> indets (f y ^ lookup t y)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  x \\<in> indets (f y ^ lookup t y)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"indets ((f y) ^ (lookup t y)) \\<subseteq> indets (f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (f y ^ lookup t y) \\<subseteq> indets (f y)", "by (rule indets_power_subset)"], ["proof (state)\nthis:\n  indets (f y ^ lookup t y) \\<subseteq> indets (f y)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  x \\<in> indets (f y)", "have \"x \\<in> indets (f y)\""], ["proof (prove)\nusing this:\n  x \\<in> indets (f y)\n\ngoal (1 subgoal):\n 1. x \\<in> indets (f y)", "."], ["proof (state)\nthis:\n  x \\<in> indets (f y)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>y \\<in> keys t\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> keys t\n  x \\<in> indets (f y)", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> keys t\n  x \\<in> indets (f y)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_pp_by_monomials:\n  assumes \"\\<And>y. y \\<in> keys t \\<Longrightarrow> f y = monomial (c y) (s y)\"\n  shows \"subst_pp f t = monomial (\\<Prod>y\\<in>keys t. (c y) ^ lookup t y) (\\<Sum>y\\<in>keys t. lookup t y \\<cdot> s y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp f t =\n    monomial (\\<Prod>y\\<in>keys t. c y ^ lookup t y)\n     (\\<Sum>y\\<in>keys t. lookup t y \\<cdot> s y)", "by (simp add: subst_pp_def assms monomial_power_map_scale punit.monomial_prod_sum)"], ["", "lemma poly_deg_subst_pp_eq_zeroI:\n  assumes \"\\<And>x. x \\<in> keys t \\<Longrightarrow> poly_deg (f x) = 0\"\n  shows \"poly_deg (subst_pp f t) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) = 0", "have \"poly_deg (subst_pp f t) \\<le> (\\<Sum>x\\<in>keys t. poly_deg ((f x) ^ (lookup t x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t)\n    \\<le> (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x))", "unfolding subst_pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (\\<Prod>x\\<in>keys t. f x ^ lookup t x)\n    \\<le> (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x))", "by (fact poly_deg_prod_le)"], ["proof (state)\nthis:\n  poly_deg (subst_pp f t)\n  \\<le> (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x))\n\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) = 0", "also"], ["proof (state)\nthis:\n  poly_deg (subst_pp f t)\n  \\<le> (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x))\n\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x)) = 0", "proof (rule sum.neutral, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow> poly_deg (f x ^ lookup t x) = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow> poly_deg (f x ^ lookup t x) = 0", "assume \"x \\<in> keys t\""], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow> poly_deg (f x ^ lookup t x) = 0", "hence \"poly_deg (f x) = 0\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. poly_deg (f x) = 0", "by (rule assms)"], ["proof (state)\nthis:\n  poly_deg (f x) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow> poly_deg (f x ^ lookup t x) = 0", "have \"f x ^ lookup t x = (\\<Prod>i=0..<lookup t x. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x ^ lookup t x = (\\<Prod>i = 0..<lookup t x. f x)", "by simp"], ["proof (state)\nthis:\n  f x ^ lookup t x = (\\<Prod>i = 0..<lookup t x. f x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow> poly_deg (f x ^ lookup t x) = 0", "also"], ["proof (state)\nthis:\n  f x ^ lookup t x = (\\<Prod>i = 0..<lookup t x. f x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow> poly_deg (f x ^ lookup t x) = 0", "have \"poly_deg ... \\<le> (\\<Sum>i=0..<lookup t x. poly_deg (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (\\<Prod>i = 0..<lookup t x. f x)\n    \\<le> (\\<Sum>i = 0..<lookup t x. poly_deg (f x))", "by (rule poly_deg_prod_le)"], ["proof (state)\nthis:\n  poly_deg (\\<Prod>i = 0..<lookup t x. f x)\n  \\<le> (\\<Sum>i = 0..<lookup t x. poly_deg (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow> poly_deg (f x ^ lookup t x) = 0", "also"], ["proof (state)\nthis:\n  poly_deg (\\<Prod>i = 0..<lookup t x. f x)\n  \\<le> (\\<Sum>i = 0..<lookup t x. poly_deg (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow> poly_deg (f x ^ lookup t x) = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<lookup t x. poly_deg (f x)) = 0", "by (simp add: \\<open>poly_deg (f x) = 0\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<lookup t x. poly_deg (f x)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow> poly_deg (f x ^ lookup t x) = 0", "finally"], ["proof (chain)\npicking this:\n  poly_deg (f x ^ lookup t x) \\<le> 0", "show \"poly_deg (f x ^ lookup t x) = 0\""], ["proof (prove)\nusing this:\n  poly_deg (f x ^ lookup t x) \\<le> 0\n\ngoal (1 subgoal):\n 1. poly_deg (f x ^ lookup t x) = 0", "by simp"], ["proof (state)\nthis:\n  poly_deg (f x ^ lookup t x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x)) = 0\n\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) = 0", "finally"], ["proof (chain)\npicking this:\n  poly_deg (subst_pp f t) \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg (subst_pp f t) \\<le> 0\n\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) = 0", "by simp"], ["proof (state)\nthis:\n  poly_deg (subst_pp f t) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_subst_pp_le:\n  assumes \"\\<And>x. x \\<in> keys t \\<Longrightarrow> poly_deg (f x) \\<le> 1\"\n  shows \"poly_deg (subst_pp f t) \\<le> deg_pm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) \\<le> deg_pm t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) \\<le> deg_pm t", "have \"poly_deg (subst_pp f t) \\<le> (\\<Sum>x\\<in>keys t. poly_deg ((f x) ^ (lookup t x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t)\n    \\<le> (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x))", "unfolding subst_pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (\\<Prod>x\\<in>keys t. f x ^ lookup t x)\n    \\<le> (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x))", "by (fact poly_deg_prod_le)"], ["proof (state)\nthis:\n  poly_deg (subst_pp f t)\n  \\<le> (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x))\n\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) \\<le> deg_pm t", "also"], ["proof (state)\nthis:\n  poly_deg (subst_pp f t)\n  \\<le> (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x))\n\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) \\<le> deg_pm t", "have \"... \\<le> (\\<Sum>x\\<in>keys t. lookup t x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x))\n    \\<le> sum (lookup t) (keys t)", "proof (rule sum_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       poly_deg (f x ^ lookup t x) \\<le> lookup t x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       poly_deg (f x ^ lookup t x) \\<le> lookup t x", "assume \"x \\<in> keys t\""], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       poly_deg (f x ^ lookup t x) \\<le> lookup t x", "hence \"poly_deg (f x) \\<le> 1\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. poly_deg (f x) \\<le> 1", "by (rule assms)"], ["proof (state)\nthis:\n  poly_deg (f x) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       poly_deg (f x ^ lookup t x) \\<le> lookup t x", "have \"f x ^ lookup t x = (\\<Prod>i=0..<lookup t x. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x ^ lookup t x = (\\<Prod>i = 0..<lookup t x. f x)", "by simp"], ["proof (state)\nthis:\n  f x ^ lookup t x = (\\<Prod>i = 0..<lookup t x. f x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       poly_deg (f x ^ lookup t x) \\<le> lookup t x", "also"], ["proof (state)\nthis:\n  f x ^ lookup t x = (\\<Prod>i = 0..<lookup t x. f x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       poly_deg (f x ^ lookup t x) \\<le> lookup t x", "have \"poly_deg ... \\<le> (\\<Sum>i=0..<lookup t x. poly_deg (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (\\<Prod>i = 0..<lookup t x. f x)\n    \\<le> (\\<Sum>i = 0..<lookup t x. poly_deg (f x))", "by (rule poly_deg_prod_le)"], ["proof (state)\nthis:\n  poly_deg (\\<Prod>i = 0..<lookup t x. f x)\n  \\<le> (\\<Sum>i = 0..<lookup t x. poly_deg (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       poly_deg (f x ^ lookup t x) \\<le> lookup t x", "also"], ["proof (state)\nthis:\n  poly_deg (\\<Prod>i = 0..<lookup t x. f x)\n  \\<le> (\\<Sum>i = 0..<lookup t x. poly_deg (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       poly_deg (f x ^ lookup t x) \\<le> lookup t x", "from \\<open>poly_deg (f x) \\<le> 1\\<close>"], ["proof (chain)\npicking this:\n  poly_deg (f x) \\<le> 1", "have \"... \\<le> (\\<Sum>i=0..<lookup t x. 1)\""], ["proof (prove)\nusing this:\n  poly_deg (f x) \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<lookup t x. poly_deg (f x))\n    \\<le> (\\<Sum>i = 0..<lookup t x. 1)", "by (rule sum_mono)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<lookup t x. poly_deg (f x))\n  \\<le> (\\<Sum>i = 0..<lookup t x. 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       poly_deg (f x ^ lookup t x) \\<le> lookup t x", "finally"], ["proof (chain)\npicking this:\n  poly_deg (f x ^ lookup t x) \\<le> (\\<Sum>i = 0..<lookup t x. 1)", "show \"poly_deg (f x ^ lookup t x) \\<le> lookup t x\""], ["proof (prove)\nusing this:\n  poly_deg (f x ^ lookup t x) \\<le> (\\<Sum>i = 0..<lookup t x. 1)\n\ngoal (1 subgoal):\n 1. poly_deg (f x ^ lookup t x) \\<le> lookup t x", "by simp"], ["proof (state)\nthis:\n  poly_deg (f x ^ lookup t x) \\<le> lookup t x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x))\n  \\<le> sum (lookup t) (keys t)\n\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) \\<le> deg_pm t", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t. poly_deg (f x ^ lookup t x))\n  \\<le> sum (lookup t) (keys t)\n\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) \\<le> deg_pm t", "have \"... = deg_pm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup t) (keys t) = deg_pm t", "by (rule deg_pm_superset[symmetric], fact subset_refl, fact finite_keys)"], ["proof (state)\nthis:\n  sum (lookup t) (keys t) = deg_pm t\n\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) \\<le> deg_pm t", "finally"], ["proof (chain)\npicking this:\n  poly_deg (subst_pp f t) \\<le> deg_pm t", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg (subst_pp f t) \\<le> deg_pm t\n\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) \\<le> deg_pm t", "by simp"], ["proof (state)\nthis:\n  poly_deg (subst_pp f t) \\<le> deg_pm t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_subst_alt: \"poly_subst f p = (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p =\n    (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_subst f p =\n    (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"poly_subst f p = (\\<Sum>t. if t \\<in> keys p then punit.monom_mult (lookup p t) 0 (subst_pp f t) else 0)\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. poly_subst f p =\n    (\\<Sum>t. if t \\<in> keys p\n              then punit.monom_mult (lookup p t) 0 (subst_pp f t) else 0)", "unfolding poly_subst_def"], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp f t)) =\n    (\\<Sum>t. if t \\<in> keys p\n              then punit.monom_mult (lookup p t) 0 (subst_pp f t) else 0)", "by (rule Sum_any.conditionalize)"], ["proof (state)\nthis:\n  poly_subst f p =\n  (\\<Sum>t. if t \\<in> keys p\n            then punit.monom_mult (lookup p t) 0 (subst_pp f t) else 0)\n\ngoal (1 subgoal):\n 1. poly_subst f p =\n    (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))", "also"], ["proof (state)\nthis:\n  poly_subst f p =\n  (\\<Sum>t. if t \\<in> keys p\n            then punit.monom_mult (lookup p t) 0 (subst_pp f t) else 0)\n\ngoal (1 subgoal):\n 1. poly_subst f p =\n    (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))", "have \"\\<dots> = (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t. if t \\<in> keys p\n              then punit.monom_mult (lookup p t) 0 (subst_pp f t) else 0) =\n    (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))", "by (rule Sum_any.cong) (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Sum>t. if t \\<in> keys p\n            then punit.monom_mult (lookup p t) 0 (subst_pp f t) else 0) =\n  (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))\n\ngoal (1 subgoal):\n 1. poly_subst f p =\n    (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))", "finally"], ["proof (chain)\npicking this:\n  poly_subst f p = (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_subst f p = (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))\n\ngoal (1 subgoal):\n 1. poly_subst f p =\n    (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))", "."], ["proof (state)\nthis:\n  poly_subst f p = (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_subst_trivial [simp]: \"poly_subst (\\<lambda>_. 0) p = monomial (lookup p 0) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>_. 0) p = monomial (lookup p 0) 0", "by (simp add: poly_subst_def subst_pp_trivial if_distrib in_keys_iff cong: if_cong)\n      (metis mult.right_neutral times_monomial_left)"], ["", "lemma poly_subst_zero [simp]: \"poly_subst f 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f 0 = 0", "by (simp add: poly_subst_def)"], ["", "lemma monom_mult_lookup_not_zero_subset_keys:\n  \"{t. punit.monom_mult (lookup p t) 0 (subst_pp f t) \\<noteq> 0} \\<subseteq> keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. punit.monom_mult (lookup p t) 0 (subst_pp f t) \\<noteq> 0}\n    \\<subseteq> keys p", "proof (rule, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       punit.monom_mult (lookup p x) 0 (subst_pp f x) \\<noteq>\n       0 \\<Longrightarrow>\n       x \\<in> keys p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       punit.monom_mult (lookup p x) 0 (subst_pp f x) \\<noteq>\n       0 \\<Longrightarrow>\n       x \\<in> keys p", "assume \"punit.monom_mult (lookup p t) 0 (subst_pp f t) \\<noteq> 0\""], ["proof (state)\nthis:\n  punit.monom_mult (lookup p t) 0 (subst_pp f t) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       punit.monom_mult (lookup p x) 0 (subst_pp f x) \\<noteq>\n       0 \\<Longrightarrow>\n       x \\<in> keys p", "thus \"t \\<in> keys p\""], ["proof (prove)\nusing this:\n  punit.monom_mult (lookup p t) 0 (subst_pp f t) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t \\<in> keys p", "unfolding in_keys_iff"], ["proof (prove)\nusing this:\n  punit.monom_mult (lookup p t) 0 (subst_pp f t) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lookup p t \\<noteq> (0::'c)", "by (metis punit.monom_mult_zero_left)"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary finite_monom_mult_lookup_not_zero:\n  \"finite {t. punit.monom_mult (lookup p t) 0 (subst_pp f t) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. punit.monom_mult (lookup p t) 0 (subst_pp f t) \\<noteq> 0}", "by (rule finite_subset, fact monom_mult_lookup_not_zero_subset_keys, fact finite_keys)"], ["", "lemma poly_subst_plus: \"poly_subst f (p + q) = poly_subst f p + poly_subst f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (p + q) = poly_subst f p + poly_subst f q", "by (simp add: poly_subst_alt lookup_add punit.monom_mult_dist_left, rule Sum_any.distrib,\n      (fact finite_monom_mult_lookup_not_zero)+)"], ["", "lemma poly_subst_uminus: \"poly_subst f (-p) = - poly_subst f (p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::comm_ring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (- p) = - poly_subst f p", "by (simp add: poly_subst_def keys_uminus punit.monom_mult_uminus_left sum_negf)"], ["", "lemma poly_subst_minus:\n  \"poly_subst f (p - q) = poly_subst f p - poly_subst f (q::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::comm_ring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (p - q) = poly_subst f p - poly_subst f q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_subst f (p - q) = poly_subst f p - poly_subst f q", "have \"poly_subst f (p + (-q)) = poly_subst f p + poly_subst f (-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (p + - q) = poly_subst f p + poly_subst f (- q)", "by (fact poly_subst_plus)"], ["proof (state)\nthis:\n  poly_subst f (p + - q) = poly_subst f p + poly_subst f (- q)\n\ngoal (1 subgoal):\n 1. poly_subst f (p - q) = poly_subst f p - poly_subst f q", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly_subst f (p + - q) = poly_subst f p + poly_subst f (- q)\n\ngoal (1 subgoal):\n 1. poly_subst f (p - q) = poly_subst f p - poly_subst f q", "by (simp add: poly_subst_uminus)"], ["proof (state)\nthis:\n  poly_subst f (p - q) = poly_subst f p - poly_subst f q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_subst_monomial: \"poly_subst f (monomial c t) = punit.monom_mult c 0 (subst_pp f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (monomial c t) = punit.monom_mult c 0 (subst_pp f t)", "by (simp add: poly_subst_def lookup_single)"], ["", "corollary poly_subst_one [simp]: \"poly_subst f 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f 1 = 1", "by (simp add: single_one[symmetric] poly_subst_monomial punit.monom_mult_monomial del: single_one)"], ["", "lemma poly_subst_times: \"poly_subst f (p * q) = poly_subst f p * poly_subst f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have bij: \"bij (\\<lambda>(l, n, m). (m, l, n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (\\<lambda>(l, n, m). (m, l, n))", "by (auto intro!: bijI injI simp add: image_def)"], ["proof (state)\nthis:\n  bij (\\<lambda>(l, n, m). (m, l, n))\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "let ?P = \"keys p\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "let ?Q = \"keys q\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "let ?PQ = \"{s + t | s t. lookup p s \\<noteq> 0 \\<and> lookup q t \\<noteq> 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have fin_PQ: \"finite ?PQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {s + t |s t.\n      lookup p s \\<noteq> (0::'b) \\<and> lookup q t \\<noteq> (0::'b)}", "by (rule finite_not_eq_zero_sumI, simp_all)"], ["proof (state)\nthis:\n  finite\n   {s + t |s t.\n    lookup p s \\<noteq> (0::'b) \\<and> lookup q t \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have fin_1: \"finite {l. lookup p l * (\\<Sum>qa. lookup q qa when t = l + qa) \\<noteq> 0}\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {l. lookup p l * (\\<Sum>qa. lookup q qa when t = l + qa) \\<noteq>\n         (0::'b)}", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. {l. lookup p l * (\\<Sum>qa. lookup q qa when t = l + qa) \\<noteq>\n        (0::'b)}\n    \\<subseteq> ?B\n 2. finite ?B", "show \"{l. lookup p l * (\\<Sum>qa. lookup q qa when t = l + qa) \\<noteq> 0} \\<subseteq> keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. lookup p l * (\\<Sum>qa. lookup q qa when t = l + qa) \\<noteq>\n        (0::'b)}\n    \\<subseteq> keys p", "by (rule, auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  {l. lookup p l * (\\<Sum>qa. lookup q qa when t = l + qa) \\<noteq> (0::'b)}\n  \\<subseteq> keys p\n\ngoal (1 subgoal):\n 1. finite (keys p)", "qed (fact finite_keys)"], ["proof (state)\nthis:\n  finite\n   {l. lookup p l * (\\<Sum>qa. lookup q qa when ?t1 = l + qa) \\<noteq>\n       (0::'b)}\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have fin_2: \"finite {v. (lookup q v when t = u + v) \\<noteq> 0}\" for t u"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v. (lookup q v when t = u + v) \\<noteq> (0::'b)}", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. {v. (lookup q v when t = u + v) \\<noteq> (0::'b)} \\<subseteq> ?B\n 2. finite ?B", "show \"{v. (lookup q v when t = u + v) \\<noteq> 0} \\<subseteq> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. (lookup q v when t = u + v) \\<noteq> (0::'b)} \\<subseteq> keys q", "by (rule, auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  {v. (lookup q v when t = u + v) \\<noteq> (0::'b)} \\<subseteq> keys q\n\ngoal (1 subgoal):\n 1. finite (keys q)", "qed (fact finite_keys)"], ["proof (state)\nthis:\n  finite {v. (lookup q v when ?t1 = ?u1 + v) \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have fin_3: \"finite {v. (lookup p u * lookup q v when t = u + v) \\<noteq> 0}\" for t u"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v. (lookup p u * lookup q v when t = u + v) \\<noteq> (0::'b)}", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. {v. (lookup p u * lookup q v when t = u + v) \\<noteq> (0::'b)}\n    \\<subseteq> ?B\n 2. finite ?B", "show \"{v. (lookup p u * lookup q v when t = u + v) \\<noteq> 0} \\<subseteq> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. (lookup p u * lookup q v when t = u + v) \\<noteq> (0::'b)}\n    \\<subseteq> keys q", "by (rule, auto simp add: in_keys_iff simp del: lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  {v. (lookup p u * lookup q v when t = u + v) \\<noteq> (0::'b)}\n  \\<subseteq> keys q\n\ngoal (1 subgoal):\n 1. finite (keys q)", "qed (fact finite_keys)"], ["proof (state)\nthis:\n  finite\n   {v. (lookup p ?u1 * lookup q v when ?t1 = ?u1 + v) \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have \"(\\<Sum>t. punit.monom_mult (lookup (p * q) t) 0 (subst_pp f t)) =\n        (\\<Sum>t. \\<Sum>u. punit.monom_mult (lookup p u * (\\<Sum>v. lookup q v when t = u + v)) 0 (subst_pp f t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t. punit.monom_mult (lookup (p * q) t) 0 (subst_pp f t)) =\n    (\\<Sum>t. \\<Sum>u. punit.monom_mult\n                        (lookup p u * (\\<Sum>v. lookup q v when t = u + v))\n                        0 (subst_pp f t))", "by (simp add: times_poly_mapping.rep_eq prod_fun_def punit.monom_mult_Sum_any_left[OF fin_1])"], ["proof (state)\nthis:\n  (\\<Sum>t. punit.monom_mult (lookup (p * q) t) 0 (subst_pp f t)) =\n  (\\<Sum>t. \\<Sum>u. punit.monom_mult\n                      (lookup p u * (\\<Sum>v. lookup q v when t = u + v)) 0\n                      (subst_pp f t))\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "also"], ["proof (state)\nthis:\n  (\\<Sum>t. punit.monom_mult (lookup (p * q) t) 0 (subst_pp f t)) =\n  (\\<Sum>t. \\<Sum>u. punit.monom_mult\n                      (lookup p u * (\\<Sum>v. lookup q v when t = u + v)) 0\n                      (subst_pp f t))\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have \"\\<dots> = (\\<Sum>t. \\<Sum>u. \\<Sum>v. (punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t)) when t = u + v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t. \\<Sum>u. punit.monom_mult\n                        (lookup p u * (\\<Sum>v. lookup q v when t = u + v))\n                        0 (subst_pp f t)) =\n    (\\<Sum>t. \\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                                 (subst_pp f t) when\n                                t = u + v)", "by (simp add: Sum_any_right_distrib[OF fin_2] punit.monom_mult_Sum_any_left[OF fin_3] mult_when punit.when_monom_mult)"], ["proof (state)\nthis:\n  (\\<Sum>t. \\<Sum>u. punit.monom_mult\n                      (lookup p u * (\\<Sum>v. lookup q v when t = u + v)) 0\n                      (subst_pp f t)) =\n  (\\<Sum>t. \\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                               (subst_pp f t) when\n                              t = u + v)\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "also"], ["proof (state)\nthis:\n  (\\<Sum>t. \\<Sum>u. punit.monom_mult\n                      (lookup p u * (\\<Sum>v. lookup q v when t = u + v)) 0\n                      (subst_pp f t)) =\n  (\\<Sum>t. \\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                               (subst_pp f t) when\n                              t = u + v)\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have \"\\<dots> = (\\<Sum>t. (\\<Sum>(u, v). (punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t)) when t = u + v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t. \\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                                 (subst_pp f t) when\n                                t = u + v) =\n    (\\<Sum>t. \\<Sum>(u,\n                 v). punit.monom_mult (lookup p u * lookup q v) 0\n                      (subst_pp f t) when\n                     t = u + v)", "by (subst (2) Sum_any.cartesian_product [of \"?P \\<times> ?Q\"]) (auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Sum>t. \\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                               (subst_pp f t) when\n                              t = u + v) =\n  (\\<Sum>t. \\<Sum>(u,\n               v). punit.monom_mult (lookup p u * lookup q v) 0\n                    (subst_pp f t) when\n                   t = u + v)\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "also"], ["proof (state)\nthis:\n  (\\<Sum>t. \\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                               (subst_pp f t) when\n                              t = u + v) =\n  (\\<Sum>t. \\<Sum>(u,\n               v). punit.monom_mult (lookup p u * lookup q v) 0\n                    (subst_pp f t) when\n                   t = u + v)\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have \"\\<dots> = (\\<Sum>(t, u, v). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when t = u + v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t. \\<Sum>(u,\n                 v). punit.monom_mult (lookup p u * lookup q v) 0\n                      (subst_pp f t) when\n                     t = u + v) =\n    (\\<Sum>(t, u,\n        v). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n            t = u + v)", "apply (subst Sum_any.cartesian_product [of \"?PQ \\<times> (?P \\<times> ?Q)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     ({s + t |s t.\n       lookup p s \\<noteq> (0::'b) \\<and>\n       lookup q t \\<noteq> (0::'b)} \\<times>\n      keys p \\<times> keys q)\n 2. {a. \\<exists>b.\n           (case b of\n            (u, v) \\<Rightarrow>\n              punit.monom_mult (lookup p u * lookup q v) 0\n               (subst_pp f a) when\n              a = u + v) \\<noteq>\n           0} \\<times>\n    {b. \\<exists>a.\n           (case b of\n            (u, v) \\<Rightarrow>\n              punit.monom_mult (lookup p u * lookup q v) 0\n               (subst_pp f a) when\n              a = u + v) \\<noteq>\n           0}\n    \\<subseteq> {s + t |s t.\n                 lookup p s \\<noteq> (0::'b) \\<and>\n                 lookup q t \\<noteq> (0::'b)} \\<times>\n                keys p \\<times> keys q\n 3. (\\<Sum>(a, u,\n        v). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f a) when\n            a = u + v) =\n    (\\<Sum>(t, u,\n        v). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n            t = u + v)", "apply (auto simp: fin_PQ in_keys_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ab ba.\n       \\<lbrakk>punit.monom_mult (lookup p aa * lookup q b) 0\n                 (subst_pp f (aa + b)) \\<noteq>\n                0;\n        punit.monom_mult (lookup p ab * lookup q ba) 0\n         (subst_pp f (ab + ba)) \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s t.\n                            ab + ba = s + t \\<and>\n                            lookup p s \\<noteq> (0::'b) \\<and>\n                            lookup q t \\<noteq> (0::'b)", "apply (metis monomial_0I mult_not_zero times_monomial_left)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>t. \\<Sum>(u,\n               v). punit.monom_mult (lookup p u * lookup q v) 0\n                    (subst_pp f t) when\n                   t = u + v) =\n  (\\<Sum>(t, u,\n      v). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n          t = u + v)\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "also"], ["proof (state)\nthis:\n  (\\<Sum>t. \\<Sum>(u,\n               v). punit.monom_mult (lookup p u * lookup q v) 0\n                    (subst_pp f t) when\n                   t = u + v) =\n  (\\<Sum>(t, u,\n      v). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n          t = u + v)\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have \"\\<dots> = (\\<Sum>(u, v, t). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when t = u + v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(t, u,\n        v). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n            t = u + v) =\n    (\\<Sum>(u, v,\n        t). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n            t = u + v)", "using bij"], ["proof (prove)\nusing this:\n  bij (\\<lambda>(l, n, m). (m, l, n))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(t, u,\n        v). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n            t = u + v) =\n    (\\<Sum>(u, v,\n        t). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n            t = u + v)", "by (rule Sum_any.reindex_cong [of \"\\<lambda>(u, v, t). (t, u, v)\"]) (simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  (\\<Sum>(t, u,\n      v). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n          t = u + v) =\n  (\\<Sum>(u, v,\n      t). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n          t = u + v)\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "also"], ["proof (state)\nthis:\n  (\\<Sum>(t, u,\n      v). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n          t = u + v) =\n  (\\<Sum>(u, v,\n      t). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n          t = u + v)\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have \"\\<dots> = (\\<Sum>(u, v). \\<Sum>t. punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when t = u + v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(u, v,\n        t). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n            t = u + v) =\n    (\\<Sum>(u,\n        v). \\<Sum>t. punit.monom_mult (lookup p u * lookup q v) 0\n                      (subst_pp f t) when\n                     t = u + v)", "apply (subst Sum_any.cartesian_product2 [of \"(?P \\<times> ?Q) \\<times> ?PQ\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     ((keys p \\<times> keys q) \\<times>\n      {s + t |s t.\n       lookup p s \\<noteq> (0::'b) \\<and> lookup q t \\<noteq> (0::'b)})\n 2. {(a, b).\n     \\<exists>c.\n        (punit.monom_mult (lookup p a * lookup q b) 0 (subst_pp f c) when\n         c = a + b) \\<noteq>\n        0} \\<times>\n    {c. \\<exists>a b.\n           (punit.monom_mult (lookup p a * lookup q b) 0 (subst_pp f c) when\n            c = a + b) \\<noteq>\n           0}\n    \\<subseteq> (keys p \\<times> keys q) \\<times>\n                {s + t |s t.\n                 lookup p s \\<noteq> (0::'b) \\<and>\n                 lookup q t \\<noteq> (0::'b)}\n 3. (\\<Sum>(u, v,\n        t). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n            t = u + v) =\n    (\\<Sum>(a, b,\n        c). punit.monom_mult (lookup p a * lookup q b) 0 (subst_pp f c) when\n            c = a + b)", "apply (auto simp: fin_PQ in_keys_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa bb.\n       \\<lbrakk>punit.monom_mult (lookup p a * lookup q b) 0\n                 (subst_pp f (a + b)) \\<noteq>\n                0;\n        punit.monom_mult (lookup p aa * lookup q bb) 0\n         (subst_pp f (aa + bb)) \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s t.\n                            aa + bb = s + t \\<and>\n                            lookup p s \\<noteq> (0::'b) \\<and>\n                            lookup q t \\<noteq> (0::'b)", "apply (metis monomial_0I mult_not_zero times_monomial_left)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>(u, v,\n      t). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n          t = u + v) =\n  (\\<Sum>(u,\n      v). \\<Sum>t. punit.monom_mult (lookup p u * lookup q v) 0\n                    (subst_pp f t) when\n                   t = u + v)\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "also"], ["proof (state)\nthis:\n  (\\<Sum>(u, v,\n      t). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f t) when\n          t = u + v) =\n  (\\<Sum>(u,\n      v). \\<Sum>t. punit.monom_mult (lookup p u * lookup q v) 0\n                    (subst_pp f t) when\n                   t = u + v)\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have \"\\<dots> = (\\<Sum>(u, v). punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f u * subst_pp f v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(u,\n        v). \\<Sum>t. punit.monom_mult (lookup p u * lookup q v) 0\n                      (subst_pp f t) when\n                     t = u + v) =\n    (\\<Sum>(u,\n        v). punit.monom_mult (lookup p u * lookup q v) 0\n             (subst_pp f u * subst_pp f v))", "by (simp add: subst_pp_plus)"], ["proof (state)\nthis:\n  (\\<Sum>(u,\n      v). \\<Sum>t. punit.monom_mult (lookup p u * lookup q v) 0\n                    (subst_pp f t) when\n                   t = u + v) =\n  (\\<Sum>(u,\n      v). punit.monom_mult (lookup p u * lookup q v) 0\n           (subst_pp f u * subst_pp f v))\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "also"], ["proof (state)\nthis:\n  (\\<Sum>(u,\n      v). \\<Sum>t. punit.monom_mult (lookup p u * lookup q v) 0\n                    (subst_pp f t) when\n                   t = u + v) =\n  (\\<Sum>(u,\n      v). punit.monom_mult (lookup p u * lookup q v) 0\n           (subst_pp f u * subst_pp f v))\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have \"\\<dots> = (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0 (subst_pp f u * subst_pp f v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(u,\n        v). punit.monom_mult (lookup p u * lookup q v) 0\n             (subst_pp f u * subst_pp f v)) =\n    (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                        (subst_pp f u * subst_pp f v))", "by (subst Sum_any.cartesian_product [of \"?P \\<times> ?Q\"]) (auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Sum>(u,\n      v). punit.monom_mult (lookup p u * lookup q v) 0\n           (subst_pp f u * subst_pp f v)) =\n  (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                      (subst_pp f u * subst_pp f v))\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "also"], ["proof (state)\nthis:\n  (\\<Sum>(u,\n      v). punit.monom_mult (lookup p u * lookup q v) 0\n           (subst_pp f u * subst_pp f v)) =\n  (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                      (subst_pp f u * subst_pp f v))\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have \"\\<dots> = (\\<Sum>u. \\<Sum>v. (punit.monom_mult (lookup p u) 0 (subst_pp f u)) * (punit.monom_mult (lookup q v) 0 (subst_pp f v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                        (subst_pp f u * subst_pp f v)) =\n    (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u) 0 (subst_pp f u) *\n                       punit.monom_mult (lookup q v) 0 (subst_pp f v))", "by (simp add: times_monomial_left[symmetric] ac_simps mult_single)"], ["proof (state)\nthis:\n  (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                      (subst_pp f u * subst_pp f v)) =\n  (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u) 0 (subst_pp f u) *\n                     punit.monom_mult (lookup q v) 0 (subst_pp f v))\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "also"], ["proof (state)\nthis:\n  (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u * lookup q v) 0\n                      (subst_pp f u * subst_pp f v)) =\n  (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u) 0 (subst_pp f u) *\n                     punit.monom_mult (lookup q v) 0 (subst_pp f v))\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "have \"\\<dots> = (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) *\n                  (\\<Sum>t. punit.monom_mult (lookup q t) 0 (subst_pp f t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u) 0 (subst_pp f u) *\n                       punit.monom_mult (lookup q v) 0 (subst_pp f v)) =\n    (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) *\n    (\\<Sum>t. punit.monom_mult (lookup q t) 0 (subst_pp f t))", "by (rule Sum_any_product [symmetric], (fact finite_monom_mult_lookup_not_zero)+)"], ["proof (state)\nthis:\n  (\\<Sum>u. \\<Sum>v. punit.monom_mult (lookup p u) 0 (subst_pp f u) *\n                     punit.monom_mult (lookup q v) 0 (subst_pp f v)) =\n  (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) *\n  (\\<Sum>t. punit.monom_mult (lookup q t) 0 (subst_pp f t))\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>t. punit.monom_mult (lookup (p * q) t) 0 (subst_pp f t)) =\n  (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) *\n  (\\<Sum>t. punit.monom_mult (lookup q t) 0 (subst_pp f t))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>t. punit.monom_mult (lookup (p * q) t) 0 (subst_pp f t)) =\n  (\\<Sum>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) *\n  (\\<Sum>t. punit.monom_mult (lookup q t) 0 (subst_pp f t))\n\ngoal (1 subgoal):\n 1. poly_subst f (p * q) = poly_subst f p * poly_subst f q", "by (simp add: poly_subst_alt)"], ["proof (state)\nthis:\n  poly_subst f (p * q) = poly_subst f p * poly_subst f q\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary poly_subst_monom_mult:\n  \"poly_subst f (punit.monom_mult c t p) = punit.monom_mult c 0 (subst_pp f t * poly_subst f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (punit.monom_mult c t p) =\n    punit.monom_mult c 0 (subst_pp f t * poly_subst f p)", "by (simp only: times_monomial_left[symmetric] poly_subst_times poly_subst_monomial mult.assoc)"], ["", "corollary poly_subst_monom_mult':\n  \"poly_subst f (punit.monom_mult c t p) = (punit.monom_mult c 0 (subst_pp f t)) * poly_subst f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (punit.monom_mult c t p) =\n    punit.monom_mult c 0 (subst_pp f t) * poly_subst f p", "by (simp only: times_monomial_left[symmetric] poly_subst_times poly_subst_monomial)"], ["", "lemma poly_subst_sum: \"poly_subst f (sum p A) = (\\<Sum>a\\<in>A. poly_subst f (p a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (sum p A) = (\\<Sum>a\\<in>A. poly_subst f (p a))", "by (rule fun_sum_commute, simp_all add: poly_subst_plus)"], ["", "lemma poly_subst_prod: \"poly_subst f (prod p A) = (\\<Prod>a\\<in>A. poly_subst f (p a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (prod p A) = (\\<Prod>a\\<in>A. poly_subst f (p a))", "by (rule fun_prod_commute, simp_all add: poly_subst_times)"], ["", "lemma poly_subst_power: \"poly_subst f (p ^ n) = (poly_subst f p) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (p ^ n) = poly_subst f p ^ n", "by (induct n, simp_all add: poly_subst_times)"], ["", "lemma poly_subst_subst_pp: \"poly_subst f (subst_pp g t) = subst_pp (\\<lambda>x. poly_subst f (g x)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (subst_pp g t) =\n    subst_pp (\\<lambda>x. poly_subst f (g x)) t", "by (simp only: subst_pp_def poly_subst_prod poly_subst_power)"], ["", "lemma poly_subst_poly_subst: \"poly_subst f (poly_subst g p) = poly_subst (\\<lambda>x. poly_subst f (g x)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (poly_subst g p) =\n    poly_subst (\\<lambda>x. poly_subst f (g x)) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_subst f (poly_subst g p) =\n    poly_subst (\\<lambda>x. poly_subst f (g x)) p", "have \"poly_subst f (poly_subst g p) =\n          poly_subst f (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp g t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (poly_subst g p) =\n    poly_subst f\n     (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp g t))", "by (simp only: poly_subst_def)"], ["proof (state)\nthis:\n  poly_subst f (poly_subst g p) =\n  poly_subst f\n   (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp g t))\n\ngoal (1 subgoal):\n 1. poly_subst f (poly_subst g p) =\n    poly_subst (\\<lambda>x. poly_subst f (g x)) p", "also"], ["proof (state)\nthis:\n  poly_subst f (poly_subst g p) =\n  poly_subst f\n   (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp g t))\n\ngoal (1 subgoal):\n 1. poly_subst f (poly_subst g p) =\n    poly_subst (\\<lambda>x. poly_subst f (g x)) p", "have \"\\<dots> = (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp (\\<lambda>x. poly_subst f (g x)) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f\n     (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp g t)) =\n    (\\<Sum>t\\<in>keys p.\n       punit.monom_mult (lookup p t) 0\n        (subst_pp (\\<lambda>x. poly_subst f (g x)) t))", "by (simp add: poly_subst_sum poly_subst_monom_mult poly_subst_subst_pp)"], ["proof (state)\nthis:\n  poly_subst f\n   (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp g t)) =\n  (\\<Sum>t\\<in>keys p.\n     punit.monom_mult (lookup p t) 0\n      (subst_pp (\\<lambda>x. poly_subst f (g x)) t))\n\ngoal (1 subgoal):\n 1. poly_subst f (poly_subst g p) =\n    poly_subst (\\<lambda>x. poly_subst f (g x)) p", "also"], ["proof (state)\nthis:\n  poly_subst f\n   (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp g t)) =\n  (\\<Sum>t\\<in>keys p.\n     punit.monom_mult (lookup p t) 0\n      (subst_pp (\\<lambda>x. poly_subst f (g x)) t))\n\ngoal (1 subgoal):\n 1. poly_subst f (poly_subst g p) =\n    poly_subst (\\<lambda>x. poly_subst f (g x)) p", "have \"\\<dots> = poly_subst (\\<lambda>x. poly_subst f (g x)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       punit.monom_mult (lookup p t) 0\n        (subst_pp (\\<lambda>x. poly_subst f (g x)) t)) =\n    poly_subst (\\<lambda>x. poly_subst f (g x)) p", "by (simp only: poly_subst_def)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p.\n     punit.monom_mult (lookup p t) 0\n      (subst_pp (\\<lambda>x. poly_subst f (g x)) t)) =\n  poly_subst (\\<lambda>x. poly_subst f (g x)) p\n\ngoal (1 subgoal):\n 1. poly_subst f (poly_subst g p) =\n    poly_subst (\\<lambda>x. poly_subst f (g x)) p", "finally"], ["proof (chain)\npicking this:\n  poly_subst f (poly_subst g p) =\n  poly_subst (\\<lambda>x. poly_subst f (g x)) p", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_subst f (poly_subst g p) =\n  poly_subst (\\<lambda>x. poly_subst f (g x)) p\n\ngoal (1 subgoal):\n 1. poly_subst f (poly_subst g p) =\n    poly_subst (\\<lambda>x. poly_subst f (g x)) p", "."], ["proof (state)\nthis:\n  poly_subst f (poly_subst g p) =\n  poly_subst (\\<lambda>x. poly_subst f (g x)) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_subst_id:\n  assumes \"\\<And>x. x \\<in> indets p \\<Longrightarrow> f x = monomial 1 (Poly_Mapping.single x 1)\"\n  shows \"poly_subst f p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_subst f p = p", "have \"poly_subst f p = (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p = (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)", "proof (simp only: poly_subst_def, rule sum.cong, fact refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       punit.monom_mult (lookup p x) 0 (subst_pp f x) =\n       monomial (lookup p x) x", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       punit.monom_mult (lookup p x) 0 (subst_pp f x) =\n       monomial (lookup p x) x", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       punit.monom_mult (lookup p x) 0 (subst_pp f x) =\n       monomial (lookup p x) x", "have eq: \"subst_pp f t = monomial 1 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp f t = monomial (1::'b) t", "by (rule subst_pp_id, rule assms, erule in_indetsI, fact \\<open>t \\<in> keys p\\<close>)"], ["proof (state)\nthis:\n  subst_pp f t = monomial (1::'b) t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       punit.monom_mult (lookup p x) 0 (subst_pp f x) =\n       monomial (lookup p x) x", "show \"punit.monom_mult (lookup p t) 0 (subst_pp f t) = monomial (lookup p t) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult (lookup p t) 0 (subst_pp f t) = monomial (lookup p t) t", "by (simp add: eq punit.monom_mult_monomial)"], ["proof (state)\nthis:\n  punit.monom_mult (lookup p t) 0 (subst_pp f t) = monomial (lookup p t) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_subst f p = (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)\n\ngoal (1 subgoal):\n 1. poly_subst f p = p", "also"], ["proof (state)\nthis:\n  poly_subst f p = (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)\n\ngoal (1 subgoal):\n 1. poly_subst f p = p", "have \"... = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) = p", "by (simp only: poly_mapping_sum_monomials)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) = p\n\ngoal (1 subgoal):\n 1. poly_subst f p = p", "finally"], ["proof (chain)\npicking this:\n  poly_subst f p = p", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_subst f p = p\n\ngoal (1 subgoal):\n 1. poly_subst f p = p", "."], ["proof (state)\nthis:\n  poly_subst f p = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_keys_poly_substE:\n  assumes \"t \\<in> keys (poly_subst f p)\"\n  obtains s where \"s \\<in> keys p\" and \"t \\<in> keys (subst_pp f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms"], ["proof (state)\nthis:\n  t \\<in> keys (poly_subst f p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  t \\<in> keys (poly_subst f p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"keys (poly_subst f p) \\<subseteq> (\\<Union>t\\<in>keys p. keys (punit.monom_mult (lookup p t) 0 (subst_pp f t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (poly_subst f p)\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    keys (punit.monom_mult (lookup p t) 0 (subst_pp f t)))", "unfolding poly_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp f t))\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    keys (punit.monom_mult (lookup p t) 0 (subst_pp f t)))", "by (rule keys_sum_subset)"], ["proof (state)\nthis:\n  keys (poly_subst f p)\n  \\<subseteq> (\\<Union>t\\<in>keys p.\n                  keys (punit.monom_mult (lookup p t) 0 (subst_pp f t)))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  t \\<in> (\\<Union>t\\<in>keys p.\n              keys (punit.monom_mult (lookup p t) 0 (subst_pp f t)))", "obtain s where \"s \\<in> keys p\" and \"t \\<in> keys (punit.monom_mult (lookup p s) 0 (subst_pp f s))\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>t\\<in>keys p.\n              keys (punit.monom_mult (lookup p t) 0 (subst_pp f t)))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t \\<in> keys\n                  (punit.monom_mult (lookup p s) 0 (subst_pp f s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> keys p\n  t \\<in> keys (punit.monom_mult (lookup p s) 0 (subst_pp f s))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  t \\<in> keys (punit.monom_mult (lookup p s) 0 (subst_pp f s))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  t \\<in> keys (punit.monom_mult (lookup p s) 0 (subst_pp f s))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> \\<subseteq> (+) 0 ` keys (subst_pp f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (punit.monom_mult (lookup p s) 0 (subst_pp f s))\n    \\<subseteq> (+) 0 ` keys (subst_pp f s)", "by (rule punit.keys_monom_mult_subset[simplified])"], ["proof (state)\nthis:\n  keys (punit.monom_mult (lookup p s) 0 (subst_pp f s))\n  \\<subseteq> (+) 0 ` keys (subst_pp f s)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  keys (punit.monom_mult (lookup p s) 0 (subst_pp f s))\n  \\<subseteq> (+) 0 ` keys (subst_pp f s)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = keys (subst_pp f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) 0 ` keys (subst_pp f s) = keys (subst_pp f s)", "by simp"], ["proof (state)\nthis:\n  (+) 0 ` keys (subst_pp f s) = keys (subst_pp f s)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  t \\<in> keys (subst_pp f s)", "have \"t \\<in> keys (subst_pp f s)\""], ["proof (prove)\nusing this:\n  t \\<in> keys (subst_pp f s)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (subst_pp f s)", "."], ["proof (state)\nthis:\n  t \\<in> keys (subst_pp f s)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys (subst_pp f s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>s \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p\n  t \\<in> keys (subst_pp f s)", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> keys p\n  t \\<in> keys (subst_pp f s)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_indets_poly_substE:\n  assumes \"x \\<in> indets (poly_subst f p)\"\n  obtains y where \"y \\<in> indets p\" and \"x \\<in> indets (f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms"], ["proof (state)\nthis:\n  x \\<in> indets (poly_subst f p)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  x \\<in> indets (poly_subst f p)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"indets (poly_subst f p) \\<subseteq> (\\<Union>t\\<in>keys p. indets (punit.monom_mult (lookup p t) 0 (subst_pp f t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (poly_subst f p)\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    indets (punit.monom_mult (lookup p t) 0 (subst_pp f t)))", "unfolding poly_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. indets\n     (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp f t))\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    indets (punit.monom_mult (lookup p t) 0 (subst_pp f t)))", "by (rule indets_sum_subset)"], ["proof (state)\nthis:\n  indets (poly_subst f p)\n  \\<subseteq> (\\<Union>t\\<in>keys p.\n                  indets (punit.monom_mult (lookup p t) 0 (subst_pp f t)))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>t\\<in>keys p.\n              indets (punit.monom_mult (lookup p t) 0 (subst_pp f t)))", "obtain t where \"t \\<in> keys p\" and \"x \\<in> indets (punit.monom_mult (lookup p t) 0 (subst_pp f t))\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>t\\<in>keys p.\n              indets (punit.monom_mult (lookup p t) 0 (subst_pp f t)))\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p;\n         x \\<in> indets\n                  (punit.monom_mult (lookup p t) 0 (subst_pp f t))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t \\<in> keys p\n  x \\<in> indets (punit.monom_mult (lookup p t) 0 (subst_pp f t))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  x \\<in> indets (punit.monom_mult (lookup p t) 0 (subst_pp f t))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  x \\<in> indets (punit.monom_mult (lookup p t) 0 (subst_pp f t))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"indets (punit.monom_mult (lookup p t) 0 (subst_pp f t)) \\<subseteq> keys (0::('a \\<Rightarrow>\\<^sub>0 nat)) \\<union> indets (subst_pp f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (punit.monom_mult (lookup p t) 0 (subst_pp f t))\n    \\<subseteq> keys 0 \\<union> indets (subst_pp f t)", "by (rule indets_monom_mult_subset)"], ["proof (state)\nthis:\n  indets (punit.monom_mult (lookup p t) 0 (subst_pp f t))\n  \\<subseteq> keys 0 \\<union> indets (subst_pp f t)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  indets (punit.monom_mult (lookup p t) 0 (subst_pp f t))\n  \\<subseteq> keys 0 \\<union> indets (subst_pp f t)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"... = indets (subst_pp f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys 0 \\<union> indets (subst_pp f t) = indets (subst_pp f t)", "by simp"], ["proof (state)\nthis:\n  keys 0 \\<union> indets (subst_pp f t) = indets (subst_pp f t)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  x \\<in> indets (subst_pp f t)", "obtain y where \"y \\<in> keys t\" and \"x \\<in> indets (f y)\""], ["proof (prove)\nusing this:\n  x \\<in> indets (subst_pp f t)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_indets_subst_ppE)"], ["proof (state)\nthis:\n  y \\<in> keys t\n  x \\<in> indets (f y)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(1) \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> keys t\n  t \\<in> keys p", "have \"y \\<in> indets p\""], ["proof (prove)\nusing this:\n  y \\<in> keys t\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. y \\<in> indets p", "by (rule in_indetsI)"], ["proof (state)\nthis:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x \\<in> indets (f y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this \\<open>x \\<in> indets (f y)\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> indets p\n  x \\<in> indets (f y)", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> indets p\n  x \\<in> indets (f y)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_poly_subst_eq_zeroI:\n  assumes \"\\<And>x. x \\<in> indets p \\<Longrightarrow> poly_deg (f x) = 0\"\n  shows \"poly_deg (poly_subst (f::_ \\<Rightarrow> (('y \\<Rightarrow>\\<^sub>0 _) \\<Rightarrow>\\<^sub>0 _)) (p::('x \\<Rightarrow>\\<^sub>0 _) \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (poly_subst f p) = 0", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly_deg (poly_subst f p) = 0\n 2. p \\<noteq> 0 \\<Longrightarrow> poly_deg (poly_subst f p) = 0", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly_deg (poly_subst f p) = 0\n 2. p \\<noteq> 0 \\<Longrightarrow> poly_deg (poly_subst f p) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. poly_deg (poly_subst f p) = 0", "by simp"], ["proof (state)\nthis:\n  poly_deg (poly_subst f p) = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (poly_subst f p) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (poly_subst f p) = 0", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (poly_subst f p) = 0", "have \"poly_deg (poly_subst f p) \\<le> Max (poly_deg ` (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (poly_subst f p)\n    \\<le> Max (poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p)", "unfolding poly_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg\n     (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp f t))\n    \\<le> Max (poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p)", "by (fact poly_deg_sum_le)"], ["proof (state)\nthis:\n  poly_deg (poly_subst f p)\n  \\<le> Max (poly_deg `\n             (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n             keys p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (poly_subst f p) = 0", "also"], ["proof (state)\nthis:\n  poly_deg (poly_subst f p)\n  \\<le> Max (poly_deg `\n             (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n             keys p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (poly_subst f p) = 0", "have \"... \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg `\n         (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n         keys p)\n    \\<le> 0", "proof (rule Max.boundedI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite\n     (poly_deg `\n      (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p)\n 2. poly_deg `\n    (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n    keys p \\<noteq>\n    {}\n 3. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "show \"finite (poly_deg ` (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (poly_deg `\n      (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p)", "by (simp add: finite_image_iff)"], ["proof (state)\nthis:\n  finite\n   (poly_deg `\n    (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p)\n\ngoal (2 subgoals):\n 1. poly_deg `\n    (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n    keys p \\<noteq>\n    {}\n 2. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_deg `\n    (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n    keys p \\<noteq>\n    {}\n 2. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "from False"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "show \"poly_deg ` (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg `\n    (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n    keys p \\<noteq>\n    {}", "by simp"], ["proof (state)\nthis:\n  poly_deg `\n  (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n  keys p \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "assume \"d \\<in> poly_deg ` (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p\""], ["proof (state)\nthis:\n  d \\<in> poly_deg `\n          (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n          keys p\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "then"], ["proof (chain)\npicking this:\n  d \\<in> poly_deg `\n          (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n          keys p", "obtain t where \"t \\<in> keys p\" and d: \"d = poly_deg (punit.monom_mult (lookup p t) 0 (subst_pp f t))\""], ["proof (prove)\nusing this:\n  d \\<in> poly_deg `\n          (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n          keys p\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p;\n         d =\n         poly_deg (punit.monom_mult (lookup p t) 0 (subst_pp f t))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  t \\<in> keys p\n  d = poly_deg (punit.monom_mult (lookup p t) 0 (subst_pp f t))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "have \"d \\<le> deg_pm (0::'y \\<Rightarrow>\\<^sub>0 nat) + poly_deg (subst_pp f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> deg_pm 0 + poly_deg (subst_pp f t)", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (punit.monom_mult (lookup p t) 0 (subst_pp f t))\n    \\<le> deg_pm 0 + poly_deg (subst_pp f t)", "by (fact poly_deg_monom_mult_le)"], ["proof (state)\nthis:\n  d \\<le> deg_pm 0 + poly_deg (subst_pp f t)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "also"], ["proof (state)\nthis:\n  d \\<le> deg_pm 0 + poly_deg (subst_pp f t)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "have \"... = poly_deg (subst_pp f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm 0 + poly_deg (subst_pp f t) = poly_deg (subst_pp f t)", "by simp"], ["proof (state)\nthis:\n  deg_pm 0 + poly_deg (subst_pp f t) = poly_deg (subst_pp f t)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "also"], ["proof (state)\nthis:\n  deg_pm 0 + poly_deg (subst_pp f t) = poly_deg (subst_pp f t)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) = 0", "by (rule poly_deg_subst_pp_eq_zeroI, rule assms, erule in_indetsI, fact)"], ["proof (state)\nthis:\n  poly_deg (subst_pp f t) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> 0", "finally"], ["proof (chain)\npicking this:\n  d \\<le> 0", "show \"d \\<le> 0\""], ["proof (prove)\nusing this:\n  d \\<le> 0\n\ngoal (1 subgoal):\n 1. d \\<le> 0", "."], ["proof (state)\nthis:\n  d \\<le> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (poly_deg `\n       (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n       keys p)\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (poly_subst f p) = 0", "finally"], ["proof (chain)\npicking this:\n  poly_deg (poly_subst f p) \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg (poly_subst f p) \\<le> 0\n\ngoal (1 subgoal):\n 1. poly_deg (poly_subst f p) = 0", "by simp"], ["proof (state)\nthis:\n  poly_deg (poly_subst f p) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_poly_subst_le:\n  assumes \"\\<And>x. x \\<in> indets p \\<Longrightarrow> poly_deg (f x) \\<le> 1\"\n  shows \"poly_deg (poly_subst (f::_ \\<Rightarrow> (('y \\<Rightarrow>\\<^sub>0 _) \\<Rightarrow>\\<^sub>0 _)) (p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1)) \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (poly_subst f p) \\<le> poly_deg p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly_deg (poly_subst f p) \\<le> poly_deg p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_deg (poly_subst f p) \\<le> poly_deg p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly_deg (poly_subst f p) \\<le> poly_deg p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_deg (poly_subst f p) \\<le> poly_deg p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. poly_deg (poly_subst f p) \\<le> poly_deg p", "by simp"], ["proof (state)\nthis:\n  poly_deg (poly_subst f p) \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    poly_deg (poly_subst f p) \\<le> poly_deg p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    poly_deg (poly_subst f p) \\<le> poly_deg p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    poly_deg (poly_subst f p) \\<le> poly_deg p", "have \"poly_deg (poly_subst f p) \\<le> Max (poly_deg ` (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (poly_subst f p)\n    \\<le> Max (poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p)", "unfolding poly_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg\n     (\\<Sum>t\\<in>keys p. punit.monom_mult (lookup p t) 0 (subst_pp f t))\n    \\<le> Max (poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p)", "by (fact poly_deg_sum_le)"], ["proof (state)\nthis:\n  poly_deg (poly_subst f p)\n  \\<le> Max (poly_deg `\n             (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n             keys p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    poly_deg (poly_subst f p) \\<le> poly_deg p", "also"], ["proof (state)\nthis:\n  poly_deg (poly_subst f p)\n  \\<le> Max (poly_deg `\n             (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n             keys p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    poly_deg (poly_subst f p) \\<le> poly_deg p", "have \"... \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg `\n         (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n         keys p)\n    \\<le> poly_deg p", "proof (rule Max.boundedI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite\n     (poly_deg `\n      (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p)\n 2. poly_deg `\n    (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n    keys p \\<noteq>\n    {}\n 3. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "show \"finite (poly_deg ` (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (poly_deg `\n      (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p)", "by (simp add: finite_image_iff)"], ["proof (state)\nthis:\n  finite\n   (poly_deg `\n    (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p)\n\ngoal (2 subgoals):\n 1. poly_deg `\n    (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n    keys p \\<noteq>\n    {}\n 2. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_deg `\n    (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n    keys p \\<noteq>\n    {}\n 2. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "from False"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "show \"poly_deg ` (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg `\n    (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n    keys p \\<noteq>\n    {}", "by simp"], ["proof (state)\nthis:\n  poly_deg `\n  (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n  keys p \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "assume \"d \\<in> poly_deg ` (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) ` keys p\""], ["proof (state)\nthis:\n  d \\<in> poly_deg `\n          (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n          keys p\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "then"], ["proof (chain)\npicking this:\n  d \\<in> poly_deg `\n          (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n          keys p", "obtain t where \"t \\<in> keys p\" and d: \"d = poly_deg (punit.monom_mult (lookup p t) 0 (subst_pp f t))\""], ["proof (prove)\nusing this:\n  d \\<in> poly_deg `\n          (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n          keys p\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p;\n         d =\n         poly_deg (punit.monom_mult (lookup p t) 0 (subst_pp f t))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  t \\<in> keys p\n  d = poly_deg (punit.monom_mult (lookup p t) 0 (subst_pp f t))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "have \"d \\<le> deg_pm (0::'y \\<Rightarrow>\\<^sub>0 nat) + poly_deg (subst_pp f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> deg_pm 0 + poly_deg (subst_pp f t)", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (punit.monom_mult (lookup p t) 0 (subst_pp f t))\n    \\<le> deg_pm 0 + poly_deg (subst_pp f t)", "by (fact poly_deg_monom_mult_le)"], ["proof (state)\nthis:\n  d \\<le> deg_pm 0 + poly_deg (subst_pp f t)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "also"], ["proof (state)\nthis:\n  d \\<le> deg_pm 0 + poly_deg (subst_pp f t)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "have \"... = poly_deg (subst_pp f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm 0 + poly_deg (subst_pp f t) = poly_deg (subst_pp f t)", "by simp"], ["proof (state)\nthis:\n  deg_pm 0 + poly_deg (subst_pp f t) = poly_deg (subst_pp f t)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "also"], ["proof (state)\nthis:\n  deg_pm 0 + poly_deg (subst_pp f t) = poly_deg (subst_pp f t)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "have \"... \\<le> deg_pm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (subst_pp f t) \\<le> deg_pm t", "by (rule poly_deg_subst_pp_le, rule assms, erule in_indetsI, fact)"], ["proof (state)\nthis:\n  poly_deg (subst_pp f t) \\<le> deg_pm t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "also"], ["proof (state)\nthis:\n  poly_deg (subst_pp f t) \\<le> deg_pm t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "from \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys p", "have \"... \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg `\n               (\\<lambda>t.\n                   punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n               keys p \\<Longrightarrow>\n       a \\<le> poly_deg p", "finally"], ["proof (chain)\npicking this:\n  d \\<le> poly_deg p", "show \"d \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  d \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. d \\<le> poly_deg p", "."], ["proof (state)\nthis:\n  d \\<le> poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (poly_deg `\n       (\\<lambda>t. punit.monom_mult (lookup p t) 0 (subst_pp f t)) `\n       keys p)\n  \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    poly_deg (poly_subst f p) \\<le> poly_deg p", "finally"], ["proof (chain)\npicking this:\n  poly_deg (poly_subst f p) \\<le> poly_deg p", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg (poly_subst f p) \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg (poly_subst f p) \\<le> poly_deg p", "by simp"], ["proof (state)\nthis:\n  poly_deg (poly_subst f p) \\<le> poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_pp_cong: \"s = t \\<Longrightarrow> (\\<And>x. x \\<in> keys t \\<Longrightarrow> f x = g x) \\<Longrightarrow> subst_pp f s = subst_pp g t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = t;\n     \\<And>x. x \\<in> keys t \\<Longrightarrow> f x = g x\\<rbrakk>\n    \\<Longrightarrow> subst_pp f s = subst_pp g t", "by (simp add: subst_pp_def)"], ["", "lemma poly_subst_cong:\n  assumes \"p = q\" and \"\\<And>x. x \\<in> indets q \\<Longrightarrow> f x = g x\"\n  shows \"poly_subst f p = poly_subst g q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f p = poly_subst g q", "proof (simp add: poly_subst_def assms(1), rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys q = keys q\n 2. \\<And>x.\n       x \\<in> keys q \\<Longrightarrow>\n       punit.monom_mult (lookup q x) 0 (subst_pp f x) =\n       punit.monom_mult (lookup q x) 0 (subst_pp g x)", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. keys q = keys q\n 2. \\<And>x.\n       x \\<in> keys q \\<Longrightarrow>\n       punit.monom_mult (lookup q x) 0 (subst_pp f x) =\n       punit.monom_mult (lookup q x) 0 (subst_pp g x)", "assume \"t \\<in> keys q\""], ["proof (state)\nthis:\n  t \\<in> keys q\n\ngoal (2 subgoals):\n 1. keys q = keys q\n 2. \\<And>x.\n       x \\<in> keys q \\<Longrightarrow>\n       punit.monom_mult (lookup q x) 0 (subst_pp f x) =\n       punit.monom_mult (lookup q x) 0 (subst_pp g x)", "{"], ["proof (state)\nthis:\n  t \\<in> keys q\n\ngoal (2 subgoals):\n 1. keys q = keys q\n 2. \\<And>x.\n       x \\<in> keys q \\<Longrightarrow>\n       punit.monom_mult (lookup q x) 0 (subst_pp f x) =\n       punit.monom_mult (lookup q x) 0 (subst_pp g x)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. keys q = keys q\n 2. \\<And>x.\n       x \\<in> keys q \\<Longrightarrow>\n       punit.monom_mult (lookup q x) 0 (subst_pp f x) =\n       punit.monom_mult (lookup q x) 0 (subst_pp g x)", "assume \"x \\<in> keys t\""], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (2 subgoals):\n 1. keys q = keys q\n 2. \\<And>x.\n       x \\<in> keys q \\<Longrightarrow>\n       punit.monom_mult (lookup q x) 0 (subst_pp f x) =\n       punit.monom_mult (lookup q x) 0 (subst_pp g x)", "with \\<open>t \\<in> keys q\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys q\n  x \\<in> keys t", "have \"x \\<in> indets q\""], ["proof (prove)\nusing this:\n  t \\<in> keys q\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> indets q", "by (auto simp: indets_def)"], ["proof (state)\nthis:\n  x \\<in> indets q\n\ngoal (2 subgoals):\n 1. keys q = keys q\n 2. \\<And>x.\n       x \\<in> keys q \\<Longrightarrow>\n       punit.monom_mult (lookup q x) 0 (subst_pp f x) =\n       punit.monom_mult (lookup q x) 0 (subst_pp g x)", "hence \"f x = g x\""], ["proof (prove)\nusing this:\n  x \\<in> indets q\n\ngoal (1 subgoal):\n 1. f x = g x", "by (rule assms(2))"], ["proof (state)\nthis:\n  f x = g x\n\ngoal (2 subgoals):\n 1. keys q = keys q\n 2. \\<And>x.\n       x \\<in> keys q \\<Longrightarrow>\n       punit.monom_mult (lookup q x) 0 (subst_pp f x) =\n       punit.monom_mult (lookup q x) 0 (subst_pp g x)", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> keys t \\<Longrightarrow> f ?x2 = g ?x2\n\ngoal (2 subgoals):\n 1. keys q = keys q\n 2. \\<And>x.\n       x \\<in> keys q \\<Longrightarrow>\n       punit.monom_mult (lookup q x) 0 (subst_pp f x) =\n       punit.monom_mult (lookup q x) 0 (subst_pp g x)", "thus \"punit.monom_mult (lookup q t) 0 (subst_pp f t) = punit.monom_mult (lookup q t) 0 (subst_pp g t)\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> keys t \\<Longrightarrow> f ?x2 = g ?x2\n\ngoal (1 subgoal):\n 1. punit.monom_mult (lookup q t) 0 (subst_pp f t) =\n    punit.monom_mult (lookup q t) 0 (subst_pp g t)", "by (simp cong: subst_pp_cong)"], ["proof (state)\nthis:\n  punit.monom_mult (lookup q t) 0 (subst_pp f t) =\n  punit.monom_mult (lookup q t) 0 (subst_pp g t)\n\ngoal (1 subgoal):\n 1. keys q = keys q", "qed (fact refl)"], ["", "lemma Polys_homomorphismE:\n  obtains h where \"\\<And>p q. h (p + q) = h p + h q\" and \"\\<And>p q. h (p * q) = h p * h q\"\n    and \"\\<And>p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1. h (h p) = h p\" and \"range h = P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>\\<And>p q. h (p + q) = h p + h q;\n         \\<And>p q. h (p * q) = h p * h q; \\<And>p. h (h p) = h p;\n         range h = P[X]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>\\<And>p q. h (p + q) = h p + h q;\n         \\<And>p q. h (p * q) = h p * h q; \\<And>p. h (h p) = h p;\n         range h = P[X]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?f = \"\\<lambda>x. if x \\<in> X then monomial (1::'a) (Poly_Mapping.single x 1) else 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>\\<And>p q. h (p + q) = h p + h q;\n         \\<And>p q. h (p * q) = h p * h q; \\<And>p. h (h p) = h p;\n         range h = P[X]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \"poly_subst ?f p = p\" if \"p \\<in> P[X]\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst\n     (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n     p =\n    p", "proof (rule poly_subst_id)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow>\n       (if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1) =\n       monomial (1::'a) (monomial 1 x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow>\n       (if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1) =\n       monomial (1::'a) (monomial 1 x)", "assume \"x \\<in> indets p\""], ["proof (state)\nthis:\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow>\n       (if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1) =\n       monomial (1::'a) (monomial 1 x)", "also"], ["proof (state)\nthis:\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow>\n       (if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1) =\n       monomial (1::'a) (monomial 1 x)", "from that"], ["proof (chain)\npicking this:\n  p \\<in> P[X]", "have \"\\<dots> \\<subseteq> X\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. indets p \\<subseteq> X", "by (rule PolysD)"], ["proof (state)\nthis:\n  indets p \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow>\n       (if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1) =\n       monomial (1::'a) (monomial 1 x)", "finally"], ["proof (chain)\npicking this:\n  x \\<in> X", "show \"?f x = monomial 1 (Poly_Mapping.single x 1)\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. (if x \\<in> X then monomial (1::'a) (monomial (1::'b) x) else 1) =\n    monomial (1::'a) (monomial (1::'b) x)", "by simp"], ["proof (state)\nthis:\n  (if x \\<in> X then monomial (1::'a) (monomial (1::?'b2) x) else 1) =\n  monomial (1::'a) (monomial (1::?'b2) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?p1 \\<in> P[X] \\<Longrightarrow>\n  poly_subst\n   (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n   ?p1 =\n  ?p1\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>\\<And>p q. h (p + q) = h p + h q;\n         \\<And>p q. h (p * q) = h p * h q; \\<And>p. h (h p) = h p;\n         range h = P[X]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 2: \"poly_subst ?f p \\<in> P[X]\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst\n     (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n     p\n    \\<in> P[X]", "proof (intro PolysI_alt subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1)\n                  p) \\<Longrightarrow>\n       x \\<in> X", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1)\n                  p) \\<Longrightarrow>\n       x \\<in> X", "assume \"x \\<in> indets (poly_subst ?f p)\""], ["proof (state)\nthis:\n  x \\<in> indets\n           (poly_subst\n             (\\<lambda>x.\n                 if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n             p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1)\n                  p) \\<Longrightarrow>\n       x \\<in> X", "then"], ["proof (chain)\npicking this:\n  x \\<in> indets\n           (poly_subst\n             (\\<lambda>x.\n                 if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n             p)", "obtain y where \"x \\<in> indets (?f y)\""], ["proof (prove)\nusing this:\n  x \\<in> indets\n           (poly_subst\n             (\\<lambda>x.\n                 if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n             p)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        x \\<in> indets\n                 (if y \\<in> X then monomial (1::'a) (monomial 1 y)\n                  else 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule in_indets_poly_substE)"], ["proof (state)\nthis:\n  x \\<in> indets (if y \\<in> X then monomial (1::'a) (monomial 1 y) else 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1)\n                  p) \\<Longrightarrow>\n       x \\<in> X", "thus \"x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> indets (if y \\<in> X then monomial (1::'a) (monomial 1 y) else 1)\n\ngoal (1 subgoal):\n 1. x \\<in> X", "by (simp add: indets_monomial split: if_split_asm)"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_subst\n   (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n   ?p1\n  \\<in> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>\\<And>p q. h (p + q) = h p + h q;\n         \\<And>p q. h (p * q) = h p * h q; \\<And>p. h (h p) = h p;\n         range h = P[X]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from poly_subst_plus poly_subst_times"], ["proof (chain)\npicking this:\n  poly_subst ?f (?p + ?q) = poly_subst ?f ?p + poly_subst ?f ?q\n  poly_subst ?f (?p * ?q) = poly_subst ?f ?p * poly_subst ?f ?q", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_subst ?f (?p + ?q) = poly_subst ?f ?p + poly_subst ?f ?q\n  poly_subst ?f (?p * ?q) = poly_subst ?f ?p * poly_subst ?f ?q\n\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       poly_subst (?f3 (poly_subst (?f3 p) p)) (poly_subst (?f3 p) p) =\n       poly_subst (?f3 p) p\n 2. range (\\<lambda>a. poly_subst (?f3 a) a) = P[X]\nflex-flex pairs:\n  \\<lambda>p q. ?f3 (p + q) \\<equiv>\\<^sup>? \\<lambda>p. ?f3\n  \\<lambda>p q. ?f3 (p + q) \\<equiv>\\<^sup>? \\<lambda>p q. ?f3 p\n  \\<lambda>p. ?f3 \\<equiv>\\<^sup>? \\<lambda>p q. ?f3 (p * q)\n  \\<lambda>p q. ?f3 p \\<equiv>\\<^sup>? \\<lambda>p q. ?f3 (p * q)", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       poly_subst (?f3 (poly_subst (?f3 p) p)) (poly_subst (?f3 p) p) =\n       poly_subst (?f3 p) p\n 2. range (\\<lambda>a. poly_subst (?f3 a) a) = P[X]\nflex-flex pairs:\n  \\<lambda>p q. ?f3 (p + q) \\<equiv>\\<^sup>? \\<lambda>p. ?f3\n  \\<lambda>p q. ?f3 (p + q) \\<equiv>\\<^sup>? \\<lambda>p q. ?f3 p\n  \\<lambda>p. ?f3 \\<equiv>\\<^sup>? \\<lambda>p q. ?f3 (p * q)\n  \\<lambda>p q. ?f3 p \\<equiv>\\<^sup>? \\<lambda>p q. ?f3 (p * q)", "from 2"], ["proof (chain)\npicking this:\n  poly_subst\n   (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n   ?p1\n  \\<in> P[X]", "show \"poly_subst ?f (poly_subst ?f p) = poly_subst ?f p\""], ["proof (prove)\nusing this:\n  poly_subst\n   (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n   ?p1\n  \\<in> P[X]\n\ngoal (1 subgoal):\n 1. poly_subst\n     (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n     (poly_subst\n       (\\<lambda>x.\n           if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n       p) =\n    poly_subst\n     (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n     p", "by (rule 1)"], ["proof (state)\nthis:\n  poly_subst\n   (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n   (poly_subst\n     (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n     p) =\n  poly_subst\n   (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1) p\n\ngoal (1 subgoal):\n 1. range\n     (poly_subst\n       (\\<lambda>a.\n           if a \\<in> X then monomial (1::'a) (monomial 1 a) else 1)) =\n    P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. range\n     (poly_subst\n       (\\<lambda>a.\n           if a \\<in> X then monomial (1::'a) (monomial 1 a) else 1)) =\n    P[X]", "show \"range (poly_subst ?f) = P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range\n     (poly_subst\n       (\\<lambda>x.\n           if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)) =\n    P[X]", "proof (intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> range\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1)) \\<Longrightarrow>\n       x \\<in> P[X]\n 2. \\<And>x.\n       x \\<in> P[X] \\<Longrightarrow>\n       x \\<in> range\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1))", "fix p :: \"_ \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> range\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1)) \\<Longrightarrow>\n       x \\<in> P[X]\n 2. \\<And>x.\n       x \\<in> P[X] \\<Longrightarrow>\n       x \\<in> range\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1))", "assume \"p \\<in> P[X]\""], ["proof (state)\nthis:\n  p \\<in> P[X]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> range\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1)) \\<Longrightarrow>\n       x \\<in> P[X]\n 2. \\<And>x.\n       x \\<in> P[X] \\<Longrightarrow>\n       x \\<in> range\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1))", "hence \"p = poly_subst ?f p\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. p =\n    poly_subst\n     (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)\n     p", "by (simp only: 1)"], ["proof (state)\nthis:\n  p =\n  poly_subst\n   (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1) p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> range\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1)) \\<Longrightarrow>\n       x \\<in> P[X]\n 2. \\<And>x.\n       x \\<in> P[X] \\<Longrightarrow>\n       x \\<in> range\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1))", "thus \"p \\<in> range (poly_subst ?f)\""], ["proof (prove)\nusing this:\n  p =\n  poly_subst\n   (\\<lambda>x. if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1) p\n\ngoal (1 subgoal):\n 1. p \\<in> range\n             (poly_subst\n               (\\<lambda>x.\n                   if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                   else 1))", "by (rule image_eqI) simp"], ["proof (state)\nthis:\n  p \\<in> range\n           (poly_subst\n             (\\<lambda>x.\n                 if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range\n                (poly_subst\n                  (\\<lambda>x.\n                      if x \\<in> X then monomial (1::'a) (monomial 1 x)\n                      else 1)) \\<Longrightarrow>\n       x \\<in> P[X]", "qed (auto intro: 2)"], ["proof (state)\nthis:\n  range\n   (poly_subst\n     (\\<lambda>x.\n         if x \\<in> X then monomial (1::'a) (monomial 1 x) else 1)) =\n  P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_idealE_Polys_finite:\n  assumes \"finite B\" and \"B \\<subseteq> P[X]\" and \"p \\<in> P[X]\" and \"(p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1) \\<in> ideal B\"\n  obtains q where \"\\<And>b. q b \\<in> P[X]\" and \"p = (\\<Sum>b\\<in>B. q b * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>B. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>B. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain h where \"\\<And>p q. h (p + q) = h p + h q\" and \"\\<And>p q. h (p * q) = h p * h q\"\n    and \"\\<And>p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a. h (h p) = h p\" and rng[symmetric]: \"range h = P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>\\<And>p q. h (p + q) = h p + h q;\n         \\<And>p q. h (p * q) = h p * h q; \\<And>p. h (h p) = h p;\n         range h = P[X]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule Polys_homomorphismE) blast"], ["proof (state)\nthis:\n  h (?p + ?q) = h ?p + h ?q\n  h (?p * ?q) = h ?p * h ?q\n  h (h ?p) = h ?p\n  P[X] = range h\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>B. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(1-3) assms"], ["proof (chain)\npicking this:\n  h (?p + ?q) = h ?p + h ?q\n  h (?p * ?q) = h ?p * h ?q\n  h (h ?p) = h ?p\n  finite B\n  B \\<subseteq> P[X]\n  p \\<in> P[X]\n  p \\<in> ideal B", "obtain q where \"\\<And>b. q b \\<in> P[X]\" and \"p = (\\<Sum>b\\<in>B. q b * b)\""], ["proof (prove)\nusing this:\n  h (?p + ?q) = h ?p + h ?q\n  h (?p * ?q) = h ?p * h ?q\n  h (h ?p) = h ?p\n  finite B\n  B \\<subseteq> P[X]\n  p \\<in> P[X]\n  p \\<in> ideal B\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>B. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding rng"], ["proof (prove)\nusing this:\n  h (?p + ?q) = h ?p + h ?q\n  h (?p * ?q) = h ?p * h ?q\n  h (h ?p) = h ?p\n  finite B\n  B \\<subseteq> range h\n  p \\<in> range h\n  p \\<in> ideal B\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<And>b. q b \\<in> range h;\n         p = (\\<Sum>b\\<in>B. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_idealE_homomorphism_finite) blast"], ["proof (state)\nthis:\n  q ?b \\<in> P[X]\n  p = (\\<Sum>b\\<in>B. q b * b)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>B. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  q ?b \\<in> P[X]\n  p = (\\<Sum>b\\<in>B. q b * b)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary in_idealE_Polys:\n  assumes \"B \\<subseteq> P[X]\" and \"p \\<in> P[X]\" and \"p \\<in> ideal B\"\n  obtains A q where \"finite A\" and \"A \\<subseteq> B\" and \"\\<And>b. q b \\<in> P[X]\" and \"p = (\\<Sum>b\\<in>A. q b * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A q.\n        \\<lbrakk>finite A; A \\<subseteq> B; \\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>A. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A q.\n        \\<lbrakk>finite A; A \\<subseteq> B; \\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>A. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(3)"], ["proof (chain)\npicking this:\n  p \\<in> ideal B", "obtain A where \"finite A\" and \"A \\<subseteq> B\" and \"p \\<in> ideal A\""], ["proof (prove)\nusing this:\n  p \\<in> ideal B\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>finite A; A \\<subseteq> B; p \\<in> ideal A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule ideal.span_finite_subset)"], ["proof (state)\nthis:\n  finite A\n  A \\<subseteq> B\n  p \\<in> ideal A\n\ngoal (1 subgoal):\n 1. (\\<And>A q.\n        \\<lbrakk>finite A; A \\<subseteq> B; \\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>A. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(2) assms(1)"], ["proof (chain)\npicking this:\n  A \\<subseteq> B\n  B \\<subseteq> P[X]", "have \"A \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n  B \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. A \\<subseteq> P[X]", "by (rule subset_trans)"], ["proof (state)\nthis:\n  A \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>A q.\n        \\<lbrakk>finite A; A \\<subseteq> B; \\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>A. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  finite A\n  A \\<subseteq> P[X]", "obtain q where \"\\<And>b. q b \\<in> P[X]\" and \"p = (\\<Sum>b\\<in>A. q b * b)\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>A. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) \\<open>p \\<in> ideal A\\<close>"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> P[X]\n  p \\<in> P[X]\n  p \\<in> ideal A\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>\\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>A. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_idealE_Polys_finite) blast"], ["proof (state)\nthis:\n  q ?b \\<in> P[X]\n  p = (\\<Sum>b\\<in>A. q b * b)\n\ngoal (1 subgoal):\n 1. (\\<And>A q.\n        \\<lbrakk>finite A; A \\<subseteq> B; \\<And>b. q b \\<in> P[X];\n         p = (\\<Sum>b\\<in>A. q b * b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>finite A\\<close> \\<open>A \\<subseteq> B\\<close>"], ["proof (chain)\npicking this:\n  finite A\n  A \\<subseteq> B\n  q ?b \\<in> P[X]\n  p = (\\<Sum>b\\<in>A. q b * b)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> B\n  q ?b \\<in> P[X]\n  p = (\\<Sum>b\\<in>A. q b * b)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ideal_induct_Polys [consumes 3, case_names 0 plus]:\n  assumes \"F \\<subseteq> P[X]\" and \"p \\<in> P[X]\" and \"p \\<in> ideal F\"\n  assumes \"P 0\" and \"\\<And>c q h. c \\<in> P[X] \\<Longrightarrow> q \\<in> F \\<Longrightarrow> P h \\<Longrightarrow> h \\<in> P[X] \\<Longrightarrow> P (c * q + h)\"\n  shows \"P (p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P p", "obtain h where \"\\<And>p q. h (p + q) = h p + h q\" and \"\\<And>p q. h (p * q) = h p * h q\"\n    and \"\\<And>p::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a. h (h p) = h p\" and rng[symmetric]: \"range h = P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>\\<And>p q. h (p + q) = h p + h q;\n         \\<And>p q. h (p * q) = h p * h q; \\<And>p. h (h p) = h p;\n         range h = P[X]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule Polys_homomorphismE) blast"], ["proof (state)\nthis:\n  h (?p + ?q) = h ?p + h ?q\n  h (?p * ?q) = h ?p * h ?q\n  h (h ?p) = h ?p\n  P[X] = range h\n\ngoal (1 subgoal):\n 1. P p", "from this(1-3) assms"], ["proof (chain)\npicking this:\n  h (?p + ?q) = h ?p + h ?q\n  h (?p * ?q) = h ?p * h ?q\n  h (h ?p) = h ?p\n  F \\<subseteq> P[X]\n  p \\<in> P[X]\n  p \\<in> ideal F\n  P 0\n  \\<lbrakk>?c \\<in> P[X]; ?q \\<in> F; P ?h; ?h \\<in> P[X]\\<rbrakk>\n  \\<Longrightarrow> P (?c * ?q + ?h)", "show ?thesis"], ["proof (prove)\nusing this:\n  h (?p + ?q) = h ?p + h ?q\n  h (?p * ?q) = h ?p * h ?q\n  h (h ?p) = h ?p\n  F \\<subseteq> P[X]\n  p \\<in> P[X]\n  p \\<in> ideal F\n  P 0\n  \\<lbrakk>?c \\<in> P[X]; ?q \\<in> F; P ?h; ?h \\<in> P[X]\\<rbrakk>\n  \\<Longrightarrow> P (?c * ?q + ?h)\n\ngoal (1 subgoal):\n 1. P p", "unfolding rng"], ["proof (prove)\nusing this:\n  h (?p + ?q) = h ?p + h ?q\n  h (?p * ?q) = h ?p * h ?q\n  h (h ?p) = h ?p\n  F \\<subseteq> range h\n  p \\<in> range h\n  p \\<in> ideal F\n  P 0\n  \\<lbrakk>?c \\<in> range h; ?q \\<in> F; P ?h; ?h \\<in> range h\\<rbrakk>\n  \\<Longrightarrow> P (?c * ?q + ?h)\n\ngoal (1 subgoal):\n 1. P p", "by (rule ideal_induct_homomorphism) blast"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_poly_subst_ideal_subset: \"poly_subst g ` ideal F \\<subseteq> ideal (poly_subst g ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst g ` ideal F \\<subseteq> ideal (poly_subst g ` F)", "proof (intro subsetI, elim imageE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x = poly_subst g xa; xa \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ideal (poly_subst g ` F)", "fix h f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x = poly_subst g xa; xa \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ideal (poly_subst g ` F)", "assume h: \"h = poly_subst g f\""], ["proof (state)\nthis:\n  h = poly_subst g f\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x = poly_subst g xa; xa \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ideal (poly_subst g ` F)", "assume \"f \\<in> ideal F\""], ["proof (state)\nthis:\n  f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x = poly_subst g xa; xa \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ideal (poly_subst g ` F)", "thus \"h \\<in> ideal (poly_subst g ` F)\""], ["proof (prove)\nusing this:\n  f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. h \\<in> ideal (poly_subst g ` F)", "unfolding h"], ["proof (prove)\nusing this:\n  f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. poly_subst g f \\<in> ideal (poly_subst g ` F)", "proof (induct f rule: ideal.span_induct_alt)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_subst g 0 \\<in> ideal (poly_subst g ` F)\n 2. \\<And>c x y.\n       \\<lbrakk>x \\<in> F;\n        poly_subst g y \\<in> ideal (poly_subst g ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_subst g (c * x + y)\n                         \\<in> ideal (poly_subst g ` F)", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. poly_subst g 0 \\<in> ideal (poly_subst g ` F)\n 2. \\<And>c x y.\n       \\<lbrakk>x \\<in> F;\n        poly_subst g y \\<in> ideal (poly_subst g ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_subst g (c * x + y)\n                         \\<in> ideal (poly_subst g ` F)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst g 0 \\<in> ideal (poly_subst g ` F)", "by (simp add: ideal.span_zero)"], ["proof (state)\nthis:\n  poly_subst g 0 \\<in> ideal (poly_subst g ` F)\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>x \\<in> F;\n        poly_subst g y \\<in> ideal (poly_subst g ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_subst g (c * x + y)\n                         \\<in> ideal (poly_subst g ` F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>x \\<in> F;\n        poly_subst g y \\<in> ideal (poly_subst g ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_subst g (c * x + y)\n                         \\<in> ideal (poly_subst g ` F)", "case (step c f h)"], ["proof (state)\nthis:\n  f \\<in> F\n  poly_subst g h \\<in> ideal (poly_subst g ` F)\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>x \\<in> F;\n        poly_subst g y \\<in> ideal (poly_subst g ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_subst g (c * x + y)\n                         \\<in> ideal (poly_subst g ` F)", "from step.hyps(1)"], ["proof (chain)\npicking this:\n  f \\<in> F", "have \"poly_subst g f \\<in> ideal (poly_subst g ` F)\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. poly_subst g f \\<in> ideal (poly_subst g ` F)", "by (intro ideal.span_base imageI)"], ["proof (state)\nthis:\n  poly_subst g f \\<in> ideal (poly_subst g ` F)\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>x \\<in> F;\n        poly_subst g y \\<in> ideal (poly_subst g ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_subst g (c * x + y)\n                         \\<in> ideal (poly_subst g ` F)", "hence \"poly_subst g c * poly_subst g f \\<in> ideal (poly_subst g ` F)\""], ["proof (prove)\nusing this:\n  poly_subst g f \\<in> ideal (poly_subst g ` F)\n\ngoal (1 subgoal):\n 1. poly_subst g c * poly_subst g f \\<in> ideal (poly_subst g ` F)", "by (rule ideal.span_scale)"], ["proof (state)\nthis:\n  poly_subst g c * poly_subst g f \\<in> ideal (poly_subst g ` F)\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>x \\<in> F;\n        poly_subst g y \\<in> ideal (poly_subst g ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_subst g (c * x + y)\n                         \\<in> ideal (poly_subst g ` F)", "hence \"poly_subst g c * poly_subst g f + poly_subst g h \\<in> ideal (poly_subst g ` F)\""], ["proof (prove)\nusing this:\n  poly_subst g c * poly_subst g f \\<in> ideal (poly_subst g ` F)\n\ngoal (1 subgoal):\n 1. poly_subst g c * poly_subst g f + poly_subst g h\n    \\<in> ideal (poly_subst g ` F)", "using step.hyps(2)"], ["proof (prove)\nusing this:\n  poly_subst g c * poly_subst g f \\<in> ideal (poly_subst g ` F)\n  poly_subst g h \\<in> ideal (poly_subst g ` F)\n\ngoal (1 subgoal):\n 1. poly_subst g c * poly_subst g f + poly_subst g h\n    \\<in> ideal (poly_subst g ` F)", "by (rule ideal.span_add)"], ["proof (state)\nthis:\n  poly_subst g c * poly_subst g f + poly_subst g h\n  \\<in> ideal (poly_subst g ` F)\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>x \\<in> F;\n        poly_subst g y \\<in> ideal (poly_subst g ` F)\\<rbrakk>\n       \\<Longrightarrow> poly_subst g (c * x + y)\n                         \\<in> ideal (poly_subst g ` F)", "thus ?case"], ["proof (prove)\nusing this:\n  poly_subst g c * poly_subst g f + poly_subst g h\n  \\<in> ideal (poly_subst g ` F)\n\ngoal (1 subgoal):\n 1. poly_subst g (c * f + h) \\<in> ideal (poly_subst g ` F)", "by (simp only: poly_subst_plus poly_subst_times)"], ["proof (state)\nthis:\n  poly_subst g (c * f + h) \\<in> ideal (poly_subst g ` F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h \\<in> ideal (poly_subst g ` F)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Evaluating Polynomials\\<close>"], ["", "lemma lookup_times_zero:\n  \"lookup (p * q) 0 = lookup p 0 * lookup q (0::'a::{comm_powerprod,ninv_comm_monoid_add})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p * q) (0::'a) = lookup p (0::'a) * lookup q (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (p * q) (0::'a) = lookup p (0::'a) * lookup q (0::'a)", "have eq: \"(\\<Sum>v\\<in>keys q. lookup q v when t + v = 0) = (lookup q 0 when t = 0)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n    (lookup q (0::'a) when t = (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n    (lookup q (0::'a) when t = (0::'a))", "have \"(\\<Sum>v\\<in>keys q. lookup q v when t + v = 0) = (\\<Sum>v\\<in>keys q \\<inter> {0}. lookup q v when t + v = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n    (\\<Sum>v\\<in>keys q \\<inter> {0::'a}. lookup q v when t + v = (0::'a))", "proof (intro sum.mono_neutral_right ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (keys q)\n 2. keys q \\<inter> {0::'a} \\<subseteq> keys q\n 3. \\<And>i.\n       i \\<in> keys q - keys q \\<inter> {0::'a} \\<Longrightarrow>\n       (lookup q i when t + i = (0::'a)) = (0::'b)", "fix v"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (keys q)\n 2. keys q \\<inter> {0::'a} \\<subseteq> keys q\n 3. \\<And>i.\n       i \\<in> keys q - keys q \\<inter> {0::'a} \\<Longrightarrow>\n       (lookup q i when t + i = (0::'a)) = (0::'b)", "assume \"v \\<in> keys q - keys q \\<inter> {0}\""], ["proof (state)\nthis:\n  v \\<in> keys q - keys q \\<inter> {0::'a}\n\ngoal (3 subgoals):\n 1. finite (keys q)\n 2. keys q \\<inter> {0::'a} \\<subseteq> keys q\n 3. \\<And>i.\n       i \\<in> keys q - keys q \\<inter> {0::'a} \\<Longrightarrow>\n       (lookup q i when t + i = (0::'a)) = (0::'b)", "hence \"v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<in> keys q - keys q \\<inter> {0::'a}\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'a)", "by blast"], ["proof (state)\nthis:\n  v \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. finite (keys q)\n 2. keys q \\<inter> {0::'a} \\<subseteq> keys q\n 3. \\<And>i.\n       i \\<in> keys q - keys q \\<inter> {0::'a} \\<Longrightarrow>\n       (lookup q i when t + i = (0::'a)) = (0::'b)", "hence \"t + v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. t + v \\<noteq> (0::'a)", "using plus_eq_zero_2"], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'a)\n  ?s + ?t = (0::?'a) \\<Longrightarrow> ?t = (0::?'a)\n\ngoal (1 subgoal):\n 1. t + v \\<noteq> (0::'a)", "by blast"], ["proof (state)\nthis:\n  t + v \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. finite (keys q)\n 2. keys q \\<inter> {0::'a} \\<subseteq> keys q\n 3. \\<And>i.\n       i \\<in> keys q - keys q \\<inter> {0::'a} \\<Longrightarrow>\n       (lookup q i when t + i = (0::'a)) = (0::'b)", "thus \"(lookup q v when t + v = 0) = 0\""], ["proof (prove)\nusing this:\n  t + v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (lookup q v when t + v = (0::'a)) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  (lookup q v when t + v = (0::'a)) = (0::'b)\n\ngoal (2 subgoals):\n 1. finite (keys q)\n 2. keys q \\<inter> {0::'a} \\<subseteq> keys q", "qed simp_all"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n  (\\<Sum>v\\<in>keys q \\<inter> {0::'a}. lookup q v when t + v = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n    (lookup q (0::'a) when t = (0::'a))", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n  (\\<Sum>v\\<in>keys q \\<inter> {0::'a}. lookup q v when t + v = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n    (lookup q (0::'a) when t = (0::'a))", "have \"\\<dots> = (lookup q 0 when t = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys q \\<inter> {0::'a}. lookup q v when t + v = (0::'a)) =\n    (lookup q (0::'a) when t = (0::'a))", "by (cases \"0 \\<in> keys q\") (simp_all add: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys q \\<inter> {0::'a}. lookup q v when t + v = (0::'a)) =\n  (lookup q (0::'a) when t = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n    (lookup q (0::'a) when t = (0::'a))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n  (lookup q (0::'a) when t = (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n  (lookup q (0::'a) when t = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n    (lookup q (0::'a) when t = (0::'a))", "."], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys q. lookup q v when t + v = (0::'a)) =\n  (lookup q (0::'a) when t = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys q. lookup q v when ?t + v = (0::'a)) =\n  (lookup q (0::'a) when ?t = (0::'a))\n\ngoal (1 subgoal):\n 1. lookup (p * q) (0::'a) = lookup p (0::'a) * lookup q (0::'a)", "have \"(\\<Sum>t\\<in>keys p. lookup p t * lookup q 0 when t = 0) =\n          (\\<Sum>t\\<in>keys p \\<inter> {0}. lookup p t * lookup q 0 when t = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p. lookup p t * lookup q (0::'a) when t = (0::'a)) =\n    (\\<Sum>t\\<in>keys p \\<inter> {0::'a}.\n       lookup p t * lookup q (0::'a) when t = (0::'a))", "proof (intro sum.mono_neutral_right ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (keys p)\n 2. keys p \\<inter> {0::'a} \\<subseteq> keys p\n 3. \\<And>i.\n       i \\<in> keys p - keys p \\<inter> {0::'a} \\<Longrightarrow>\n       (lookup p i * lookup q (0::'a) when i = (0::'a)) = (0::'b)", "fix t"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (keys p)\n 2. keys p \\<inter> {0::'a} \\<subseteq> keys p\n 3. \\<And>i.\n       i \\<in> keys p - keys p \\<inter> {0::'a} \\<Longrightarrow>\n       (lookup p i * lookup q (0::'a) when i = (0::'a)) = (0::'b)", "assume \"t \\<in> keys p - keys p \\<inter> {0}\""], ["proof (state)\nthis:\n  t \\<in> keys p - keys p \\<inter> {0::'a}\n\ngoal (3 subgoals):\n 1. finite (keys p)\n 2. keys p \\<inter> {0::'a} \\<subseteq> keys p\n 3. \\<And>i.\n       i \\<in> keys p - keys p \\<inter> {0::'a} \\<Longrightarrow>\n       (lookup p i * lookup q (0::'a) when i = (0::'a)) = (0::'b)", "hence \"t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys p - keys p \\<inter> {0::'a}\n\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a)", "by blast"], ["proof (state)\nthis:\n  t \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. finite (keys p)\n 2. keys p \\<inter> {0::'a} \\<subseteq> keys p\n 3. \\<And>i.\n       i \\<in> keys p - keys p \\<inter> {0::'a} \\<Longrightarrow>\n       (lookup p i * lookup q (0::'a) when i = (0::'a)) = (0::'b)", "thus \"(lookup p t * lookup q 0 when t = 0) = 0\""], ["proof (prove)\nusing this:\n  t \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (lookup p t * lookup q (0::'a) when t = (0::'a)) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  (lookup p t * lookup q (0::'a) when t = (0::'a)) = (0::'b)\n\ngoal (2 subgoals):\n 1. finite (keys p)\n 2. keys p \\<inter> {0::'a} \\<subseteq> keys p", "qed simp_all"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p. lookup p t * lookup q (0::'a) when t = (0::'a)) =\n  (\\<Sum>t\\<in>keys p \\<inter> {0::'a}.\n     lookup p t * lookup q (0::'a) when t = (0::'a))\n\ngoal (1 subgoal):\n 1. lookup (p * q) (0::'a) = lookup p (0::'a) * lookup q (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p. lookup p t * lookup q (0::'a) when t = (0::'a)) =\n  (\\<Sum>t\\<in>keys p \\<inter> {0::'a}.\n     lookup p t * lookup q (0::'a) when t = (0::'a))\n\ngoal (1 subgoal):\n 1. lookup (p * q) (0::'a) = lookup p (0::'a) * lookup q (0::'a)", "have \"\\<dots> = lookup p 0 * lookup q 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p \\<inter> {0::'a}.\n       lookup p t * lookup q (0::'a) when t = (0::'a)) =\n    lookup p (0::'a) * lookup q (0::'a)", "by (cases \"0 \\<in> keys p\") (simp_all add: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p \\<inter> {0::'a}.\n     lookup p t * lookup q (0::'a) when t = (0::'a)) =\n  lookup p (0::'a) * lookup q (0::'a)\n\ngoal (1 subgoal):\n 1. lookup (p * q) (0::'a) = lookup p (0::'a) * lookup q (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>t\\<in>keys p. lookup p t * lookup q (0::'a) when t = (0::'a)) =\n  lookup p (0::'a) * lookup q (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>t\\<in>keys p. lookup p t * lookup q (0::'a) when t = (0::'a)) =\n  lookup p (0::'a) * lookup q (0::'a)\n\ngoal (1 subgoal):\n 1. lookup (p * q) (0::'a) = lookup p (0::'a) * lookup q (0::'a)", "by (simp add: lookup_times eq when_distrib)"], ["proof (state)\nthis:\n  lookup (p * q) (0::'a) = lookup p (0::'a) * lookup q (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lookup_prod_zero:\n  \"lookup (prod f I) 0 = (\\<Prod>i\\<in>I. lookup (f i) (0::_::{comm_powerprod,ninv_comm_monoid_add}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (prod f I) (0::'b) = (\\<Prod>i\\<in>I. lookup (f i) (0::'b))", "by (induct I rule: infinite_finite_induct) (simp_all add: lookup_times_zero)"], ["", "corollary lookup_power_zero:\n  \"lookup (p ^ k) 0 = lookup p (0::_::{comm_powerprod,ninv_comm_monoid_add}) ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p ^ k) (0::'b) = lookup p (0::'b) ^ k", "by (induct k) (simp_all add: lookup_times_zero)"], ["", "definition poly_eval :: \"('x \\<Rightarrow> 'a) \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> 'a::comm_semiring_1\"\n  where \"poly_eval a p = lookup (poly_subst (\\<lambda>y. monomial (a y) (0::'x \\<Rightarrow>\\<^sub>0 nat)) p) 0\""], ["", "lemma poly_eval_alt: \"poly_eval a p = (\\<Sum>t\\<in>keys p. lookup p t * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a p =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))", "by (simp add: poly_eval_def poly_subst_def lookup_sum lookup_times_zero subst_pp_def\n          lookup_prod_zero lookup_power_zero flip: times_monomial_left)"], ["", "lemma poly_eval_monomial: \"poly_eval a (monomial c t) = c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (monomial c t) = c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)", "by (simp add: poly_eval_def poly_subst_monomial subst_pp_def punit.lookup_monom_mult\n      lookup_prod_zero lookup_power_zero)"], ["", "lemma poly_eval_zero [simp]: \"poly_eval a 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a 0 = (0::'a)", "by (simp only: poly_eval_def poly_subst_zero lookup_zero)"], ["", "lemma poly_eval_zero_left [simp]: \"poly_eval 0 p = lookup p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval 0 p = lookup p 0", "by (simp add: poly_eval_def)"], ["", "lemma poly_eval_plus: \"poly_eval a (p + q) = poly_eval a p + poly_eval a q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (p + q) = poly_eval a p + poly_eval a q", "by (simp only: poly_eval_def poly_subst_plus lookup_add)"], ["", "lemma poly_eval_uminus [simp]: \"poly_eval a (- p) = - poly_eval (a::_::comm_ring_1) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (- p) = - poly_eval a p", "by (simp only: poly_eval_def poly_subst_uminus lookup_uminus)"], ["", "lemma poly_eval_minus: \"poly_eval a (p - q) = poly_eval a p - poly_eval (a::_::comm_ring_1) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (p - q) = poly_eval a p - poly_eval a q", "by (simp only: poly_eval_def poly_subst_minus lookup_minus)"], ["", "lemma poly_eval_one [simp]: \"poly_eval a 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a 1 = (1::'a)", "by (simp add: poly_eval_def lookup_one)"], ["", "lemma poly_eval_times: \"poly_eval a (p * q) = poly_eval a p * poly_eval a q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (p * q) = poly_eval a p * poly_eval a q", "by (simp only: poly_eval_def poly_subst_times lookup_times_zero)"], ["", "lemma poly_eval_power: \"poly_eval a (p ^ m) = poly_eval a p ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (p ^ m) = poly_eval a p ^ m", "by (induct m) (simp_all add: poly_eval_times)"], ["", "lemma poly_eval_sum: \"poly_eval a (sum f I) = (\\<Sum>i\\<in>I. poly_eval a (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (sum f I) = (\\<Sum>i\\<in>I. poly_eval a (f i))", "by (induct I rule: infinite_finite_induct) (simp_all add: poly_eval_plus)"], ["", "lemma poly_eval_prod: \"poly_eval a (prod f I) = (\\<Prod>i\\<in>I. poly_eval a (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (prod f I) = (\\<Prod>i\\<in>I. poly_eval a (f i))", "by (induct I rule: infinite_finite_induct) (simp_all add: poly_eval_times)"], ["", "lemma poly_eval_cong: \"p = q \\<Longrightarrow> (\\<And>x. x \\<in> indets q \\<Longrightarrow> a x = b x) \\<Longrightarrow> poly_eval a p = poly_eval b q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = q;\n     \\<And>x. x \\<in> indets q \\<Longrightarrow> a x = b x\\<rbrakk>\n    \\<Longrightarrow> poly_eval a p = poly_eval b q", "by (simp add: poly_eval_def cong: poly_subst_cong)"], ["", "lemma indets_poly_eval_subset:\n  \"indets (poly_eval a p) \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union> \\<Union> (indets ` lookup p ` keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (poly_eval a p)\n    \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                \\<Union> (indets ` lookup p ` keys p)", "proof (induct p rule: poly_mapping_plus_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. indets (poly_eval a 0)\n    \\<subseteq> \\<Union> (indets ` a ` indets 0) \\<union>\n                \\<Union> (indets ` lookup 0 ` keys 0)\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. indets (poly_eval a 0)\n    \\<subseteq> \\<Union> (indets ` a ` indets 0) \\<union>\n                \\<Union> (indets ` lookup 0 ` keys 0)\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (poly_eval a 0)\n    \\<subseteq> \\<Union> (indets ` a ` indets 0) \\<union>\n                \\<Union> (indets ` lookup 0 ` keys 0)", "by simp"], ["proof (state)\nthis:\n  indets (poly_eval a 0)\n  \\<subseteq> \\<Union> (indets ` a ` indets 0) \\<union>\n              \\<Union> (indets ` lookup 0 ` keys 0)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "case (2 p c t)"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  t \\<notin> keys p\n  indets (poly_eval a p)\n  \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n              \\<Union> (indets ` lookup p ` keys p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "have \"keys (monomial c t + p) = keys (monomial c t) \\<union> keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = keys (monomial c t) \\<union> keys p", "by (rule keys_plus_eqI) (simp add: 2(2))"], ["proof (state)\nthis:\n  keys (monomial c t + p) = keys (monomial c t) \\<union> keys p\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "with 2(1)"], ["proof (chain)\npicking this:\n  c \\<noteq> 0\n  keys (monomial c t + p) = keys (monomial c t) \\<union> keys p", "have eq1: \"keys (monomial c t + p) = insert t (keys p)\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  keys (monomial c t + p) = keys (monomial c t) \\<union> keys p\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = insert t (keys p)", "by simp"], ["proof (state)\nthis:\n  keys (monomial c t + p) = insert t (keys p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "hence eq2: \"indets (monomial c t + p) = keys t \\<union> indets p\""], ["proof (prove)\nusing this:\n  keys (monomial c t + p) = insert t (keys p)\n\ngoal (1 subgoal):\n 1. indets (monomial c t + p) = keys t \\<union> indets p", "by (simp add: indets_def)"], ["proof (state)\nthis:\n  indets (monomial c t + p) = keys t \\<union> indets p\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "from 2(2)"], ["proof (chain)\npicking this:\n  t \\<notin> keys p", "have eq3: \"lookup (monomial c t + p) t = c\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. lookup (monomial c t + p) t = c", "by (simp add: lookup_add in_keys_iff)"], ["proof (state)\nthis:\n  lookup (monomial c t + p) t = c\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "have eq4: \"lookup (monomial c t + p) s = lookup p s\" if \"s \\<in> keys p\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial c t + p) s = lookup p s", "using that 2(2)"], ["proof (prove)\nusing this:\n  s \\<in> keys p\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. lookup (monomial c t + p) s = lookup p s", "by (auto simp: lookup_add lookup_single when_def)"], ["proof (state)\nthis:\n  ?s \\<in> keys p \\<Longrightarrow>\n  lookup (monomial c t + p) ?s = lookup p ?s\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "have \"indets (poly_eval a (monomial c t + p)) =\n          indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x) + poly_eval a p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (poly_eval a (monomial c t + p)) =\n    indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x) + poly_eval a p)", "by (simp only: poly_eval_plus poly_eval_monomial)"], ["proof (state)\nthis:\n  indets (poly_eval a (monomial c t + p)) =\n  indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x) + poly_eval a p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "also"], ["proof (state)\nthis:\n  indets (poly_eval a (monomial c t + p)) =\n  indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x) + poly_eval a p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "have \"\\<dots> \\<subseteq> indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)) \\<union> indets (poly_eval a p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x) + poly_eval a p)\n    \\<subseteq> indets\n                 (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)) \\<union>\n                indets (poly_eval a p)", "by (fact indets_plus_subset)"], ["proof (state)\nthis:\n  indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x) + poly_eval a p)\n  \\<subseteq> indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)) \\<union>\n              indets (poly_eval a p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "also"], ["proof (state)\nthis:\n  indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x) + poly_eval a p)\n  \\<subseteq> indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)) \\<union>\n              indets (poly_eval a p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "have \"\\<dots> \\<subseteq> indets c \\<union> (\\<Union> (indets ` a ` keys t)) \\<union>\n                    (\\<Union> (indets ` a ` indets p) \\<union> \\<Union> (indets ` lookup p ` keys p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)) \\<union>\n    indets (poly_eval a p)\n    \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t) \\<union>\n                (\\<Union> (indets ` a ` indets p) \\<union>\n                 \\<Union> (indets ` lookup p ` keys p))", "proof (intro Un_mono 2(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n    \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t)", "have \"indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)) \\<subseteq> indets c \\<union> indets (\\<Prod>x\\<in>keys t. a x ^ lookup t x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n    \\<subseteq> indets c \\<union>\n                indets (\\<Prod>x\\<in>keys t. a x ^ lookup t x)", "by (fact indets_times_subset)"], ["proof (state)\nthis:\n  indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n  \\<subseteq> indets c \\<union>\n              indets (\\<Prod>x\\<in>keys t. a x ^ lookup t x)\n\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n    \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t)", "also"], ["proof (state)\nthis:\n  indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n  \\<subseteq> indets c \\<union>\n              indets (\\<Prod>x\\<in>keys t. a x ^ lookup t x)\n\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n    \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t)", "have \"indets (\\<Prod>x\\<in>keys t. a x ^ lookup t x) \\<subseteq> (\\<Union>x\\<in>keys t. indets (a x ^ lookup t x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (\\<Prod>x\\<in>keys t. a x ^ lookup t x)\n    \\<subseteq> (\\<Union>x\\<in>keys t. indets (a x ^ lookup t x))", "by (fact indets_prod_subset)"], ["proof (state)\nthis:\n  indets (\\<Prod>x\\<in>keys t. a x ^ lookup t x)\n  \\<subseteq> (\\<Union>x\\<in>keys t. indets (a x ^ lookup t x))\n\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n    \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t)", "also"], ["proof (state)\nthis:\n  indets (\\<Prod>x\\<in>keys t. a x ^ lookup t x)\n  \\<subseteq> (\\<Union>x\\<in>keys t. indets (a x ^ lookup t x))\n\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n    \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t)", "have \"\\<dots> \\<subseteq> (\\<Union>x\\<in>keys t. indets (a x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>keys t. indets (a x ^ lookup t x))\n    \\<subseteq> (\\<Union>x\\<in>keys t. indets (a x))", "by (intro UN_mono subset_refl indets_power_subset)"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>keys t. indets (a x ^ lookup t x))\n  \\<subseteq> (\\<Union>x\\<in>keys t. indets (a x))\n\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n    \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t)", "also"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>keys t. indets (a x ^ lookup t x))\n  \\<subseteq> (\\<Union>x\\<in>keys t. indets (a x))\n\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n    \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t)", "have \"\\<dots> = \\<Union> (indets ` a ` keys t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>keys t. indets (a x)) = \\<Union> (indets ` a ` keys t)", "by simp"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>keys t. indets (a x)) = \\<Union> (indets ` a ` keys t)\n\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n    \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<subseteq> y \\<Longrightarrow>\n              indets c \\<union> x \\<subseteq> indets c \\<union> y;\n   \\<And>x y.\n      x \\<subseteq> y \\<Longrightarrow>\n      indets c \\<union> x \\<subseteq> indets c \\<union> y\\<rbrakk>\n  \\<Longrightarrow> indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n                    \\<subseteq> indets c \\<union>\n                                \\<Union> (indets ` a ` keys t)", "show \"indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)) \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<subseteq> y \\<Longrightarrow>\n              indets c \\<union> x \\<subseteq> indets c \\<union> y;\n   \\<And>x y.\n      x \\<subseteq> y \\<Longrightarrow>\n      indets c \\<union> x \\<subseteq> indets c \\<union> y\\<rbrakk>\n  \\<Longrightarrow> indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n                    \\<subseteq> indets c \\<union>\n                                \\<Union> (indets ` a ` keys t)\n\ngoal (1 subgoal):\n 1. indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n    \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t)", "by blast"], ["proof (state)\nthis:\n  indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x))\n  \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)) \\<union>\n  indets (poly_eval a p)\n  \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t) \\<union>\n              (\\<Union> (indets ` a ` indets p) \\<union>\n               \\<Union> (indets ` lookup p ` keys p))\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "also"], ["proof (state)\nthis:\n  indets (c * (\\<Prod>x\\<in>keys t. a x ^ lookup t x)) \\<union>\n  indets (poly_eval a p)\n  \\<subseteq> indets c \\<union> \\<Union> (indets ` a ` keys t) \\<union>\n              (\\<Union> (indets ` a ` indets p) \\<union>\n               \\<Union> (indets ` lookup p ` keys p))\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "have \"\\<dots> = \\<Union> (indets ` a ` indets (monomial c t + p)) \\<union>\n                    \\<Union> (indets ` lookup (monomial c t + p) ` keys (monomial c t + p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets c \\<union> \\<Union> (indets ` a ` keys t) \\<union>\n    (\\<Union> (indets ` a ` indets p) \\<union>\n     \\<Union> (indets ` lookup p ` keys p)) =\n    \\<Union> (indets ` a ` indets (monomial c t + p)) \\<union>\n    \\<Union> (indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "by (simp add: eq1 eq2 eq3 eq4 Un_commute Un_assoc Un_left_commute)"], ["proof (state)\nthis:\n  indets c \\<union> \\<Union> (indets ` a ` keys t) \\<union>\n  (\\<Union> (indets ` a ` indets p) \\<union>\n   \\<Union> (indets ` lookup p ` keys p)) =\n  \\<Union> (indets ` a ` indets (monomial c t + p)) \\<union>\n  \\<Union> (indets ` lookup (monomial c t + p) ` keys (monomial c t + p))\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> 0; t \\<notin> keys p;\n        indets (poly_eval a p)\n        \\<subseteq> \\<Union> (indets ` a ` indets p) \\<union>\n                    \\<Union> (indets ` lookup p ` keys p)\\<rbrakk>\n       \\<Longrightarrow> indets (poly_eval a (monomial c t + p))\n                         \\<subseteq> \\<Union>\n(indets ` a ` indets (monomial c t + p)) \\<union>\n                                     \\<Union>\n(indets ` lookup (monomial c t + p) ` keys (monomial c t + p))", "finally"], ["proof (chain)\npicking this:\n  indets (poly_eval a (monomial c t + p))\n  \\<subseteq> \\<Union> (indets ` a ` indets (monomial c t + p)) \\<union>\n              \\<Union>\n               (indets `\n                lookup (monomial c t + p) ` keys (monomial c t + p))", "show ?case"], ["proof (prove)\nusing this:\n  indets (poly_eval a (monomial c t + p))\n  \\<subseteq> \\<Union> (indets ` a ` indets (monomial c t + p)) \\<union>\n              \\<Union>\n               (indets `\n                lookup (monomial c t + p) ` keys (monomial c t + p))\n\ngoal (1 subgoal):\n 1. indets (poly_eval a (monomial c t + p))\n    \\<subseteq> \\<Union> (indets ` a ` indets (monomial c t + p)) \\<union>\n                \\<Union>\n                 (indets `\n                  lookup (monomial c t + p) ` keys (monomial c t + p))", "."], ["proof (state)\nthis:\n  indets (poly_eval a (monomial c t + p))\n  \\<subseteq> \\<Union> (indets ` a ` indets (monomial c t + p)) \\<union>\n              \\<Union>\n               (indets `\n                lookup (monomial c t + p) ` keys (monomial c t + p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_poly_eval_ideal: \"poly_eval a ` ideal F = ideal (poly_eval a ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a ` ideal F = ideal (poly_eval a ` F)", "proof (intro image_ideal_eq_surj poly_eval_plus poly_eval_times surjI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. poly_eval a (?f1 x) = x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. poly_eval a (?f1 x) = x", "show \"poly_eval a (monomial x 0) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (monomial x 0) = x", "by (simp add: poly_eval_monomial)"], ["proof (state)\nthis:\n  poly_eval a (monomial x 0) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Replacing Indeterminates\\<close>"], ["", "definition map_indets where \"map_indets f = poly_subst (\\<lambda>x. monomial 1 (Poly_Mapping.single (f x) 1))\""], ["", "lemma\n  shows map_indets_zero [simp]: \"map_indets f 0 = 0\"\n    and map_indets_one [simp]: \"map_indets f 1 = 1\"\n    and map_indets_uminus [simp]: \"map_indets f (- r) = - map_indets f (r::_ \\<Rightarrow>\\<^sub>0 _::comm_ring_1)\"\n    and map_indets_plus: \"map_indets f (p + q) = map_indets f p + map_indets f q\"\n    and map_indets_minus: \"map_indets f (r - s) = map_indets f r - map_indets f s\"\n    and map_indets_times: \"map_indets f (p * q) = map_indets f p * map_indets f q\"\n    and map_indets_power [simp]: \"map_indets f (p ^ m) = map_indets f p ^ m\"\n    and map_indets_sum: \"map_indets f (sum g A) = (\\<Sum>a\\<in>A. map_indets f (g a))\"\n    and map_indets_prod: \"map_indets f (prod g A) = (\\<Prod>a\\<in>A. map_indets f (g a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((map_indets f 0 = 0 &&& map_indets f 1 = 1) &&&\n     map_indets f (- r) = - map_indets f r &&&\n     map_indets f (p + q) = map_indets f p + map_indets f q) &&&\n    (map_indets f (r - s) = map_indets f r - map_indets f s &&&\n     map_indets f (p * q) = map_indets f p * map_indets f q) &&&\n    map_indets f (p ^ m) = map_indets f p ^ m &&&\n    map_indets f (sum g A) = (\\<Sum>a\\<in>A. map_indets f (g a)) &&&\n    map_indets f (prod g A) = (\\<Prod>a\\<in>A. map_indets f (g a))", "by (simp_all add: map_indets_def poly_subst_uminus poly_subst_plus poly_subst_minus poly_subst_times\n      poly_subst_power poly_subst_sum poly_subst_prod)"], ["", "lemma map_indets_monomial:\n  \"map_indets f (monomial c t) = monomial c (\\<Sum>x\\<in>keys t. Poly_Mapping.single (f x) (lookup t x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets f (monomial c t) =\n    monomial c (\\<Sum>x\\<in>keys t. monomial (lookup t x) (f x))", "by (simp add: map_indets_def poly_subst_monomial subst_pp_def monomial_power_map_scale\n      punit.monom_mult_monomial flip: punit.monomial_prod_sum)"], ["", "lemma map_indets_id: \"(\\<And>x. x \\<in> indets p \\<Longrightarrow> f x = x) \\<Longrightarrow> map_indets f p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> indets p \\<Longrightarrow> f x = x) \\<Longrightarrow>\n    map_indets f p = p", "by (simp add: map_indets_def poly_subst_id)"], ["", "lemma map_indets_map_indets: \"map_indets f (map_indets g p) = map_indets (f \\<circ> g) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets f (map_indets g p) = map_indets (f \\<circ> g) p", "by (simp add: map_indets_def poly_subst_poly_subst poly_subst_monomial subst_pp_single)"], ["", "lemma map_indets_cong: \"p = q \\<Longrightarrow> (\\<And>x. x \\<in> indets q \\<Longrightarrow> f x = g x) \\<Longrightarrow> map_indets f p = map_indets g q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = q;\n     \\<And>x. x \\<in> indets q \\<Longrightarrow> f x = g x\\<rbrakk>\n    \\<Longrightarrow> map_indets f p = map_indets g q", "unfolding map_indets_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = q;\n     \\<And>x. x \\<in> indets q \\<Longrightarrow> f x = g x\\<rbrakk>\n    \\<Longrightarrow> poly_subst\n                       (\\<lambda>x. monomial (1::'b) (monomial 1 (f x))) p =\n                      poly_subst\n                       (\\<lambda>x. monomial (1::'b) (monomial 1 (g x))) q", "by (simp cong: poly_subst_cong)"], ["", "lemma poly_subst_map_indets: \"poly_subst f (map_indets g p) = poly_subst (f \\<circ> g) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (map_indets g p) = poly_subst (f \\<circ> g) p", "by (simp add: map_indets_def poly_subst_poly_subst poly_subst_monomial subst_pp_single comp_def)"], ["", "lemma poly_eval_map_indets: \"poly_eval a (map_indets g p) = poly_eval (a \\<circ> g) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (map_indets g p) = poly_eval (a \\<circ> g) p", "by (simp add: poly_eval_def poly_subst_map_indets comp_def)\n      (simp add: poly_subst_def lookup_sum lookup_times_zero subst_pp_def lookup_prod_zero\n          lookup_power_zero flip: times_monomial_left)"], ["", "lemma map_indets_inverseE_Polys:\n  assumes \"inj_on f X\" and \"p \\<in> P[X]\"\n  shows \"map_indets (the_inv_into X f) (map_indets f p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets (the_inv_into X f) (map_indets f p) = p", "unfolding map_indets_map_indets"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets (the_inv_into X f \\<circ> f) p = p", "proof (rule map_indets_id)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow> (the_inv_into X f \\<circ> f) x = x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow> (the_inv_into X f \\<circ> f) x = x", "assume \"x \\<in> indets p\""], ["proof (state)\nthis:\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow> (the_inv_into X f \\<circ> f) x = x", "also"], ["proof (state)\nthis:\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow> (the_inv_into X f \\<circ> f) x = x", "from assms(2)"], ["proof (chain)\npicking this:\n  p \\<in> P[X]", "have \"\\<dots> \\<subseteq> X\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. indets p \\<subseteq> X", "by (rule PolysD)"], ["proof (state)\nthis:\n  indets p \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow> (the_inv_into X f \\<circ> f) x = x", "finally"], ["proof (chain)\npicking this:\n  x \\<in> X", "show \"(the_inv_into X f \\<circ> f) x = x\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. (the_inv_into X f \\<circ> f) x = x", "using assms(1)"], ["proof (prove)\nusing this:\n  x \\<in> X\n  inj_on f X\n\ngoal (1 subgoal):\n 1. (the_inv_into X f \\<circ> f) x = x", "by (auto intro: the_inv_into_f_f)"], ["proof (state)\nthis:\n  (the_inv_into X f \\<circ> f) x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_indets_inverseE:\n  assumes \"inj f\"\n  obtains g where \"g = the_inv f\" and \"g \\<circ> f = id\" and \"map_indets g \\<circ> map_indets f = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g = the_inv f; g \\<circ> f = id;\n         map_indets g \\<circ> map_indets f = id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g = the_inv f; g \\<circ> f = id;\n         map_indets g \\<circ> map_indets f = id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define g where \"g = the_inv f\""], ["proof (state)\nthis:\n  g = the_inv f\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g = the_inv f; g \\<circ> f = id;\n         map_indets g \\<circ> map_indets f = id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  g = the_inv f\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g = the_inv f; g \\<circ> f = id;\n         map_indets g \\<circ> map_indets f = id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  inj f", "have eq: \"g \\<circ> f = id\""], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. g \\<circ> f = id", "by (auto intro!: ext the_inv_f_f simp: g_def)"], ["proof (state)\nthis:\n  g \\<circ> f = id\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g = the_inv f; g \\<circ> f = id;\n         map_indets g \\<circ> map_indets f = id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  g \\<circ> f = id\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g = the_inv f; g \\<circ> f = id;\n         map_indets g \\<circ> map_indets f = id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"map_indets g \\<circ> map_indets f = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets g \\<circ> map_indets f = id", "by (rule ext) (simp add: map_indets_map_indets eq map_indets_id)"], ["proof (state)\nthis:\n  map_indets g \\<circ> map_indets f = id\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g = the_inv f; g \\<circ> f = id;\n         map_indets g \\<circ> map_indets f = id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  g = the_inv f\n  g \\<circ> f = id\n  map_indets g \\<circ> map_indets f = id", "show ?thesis"], ["proof (prove)\nusing this:\n  g = the_inv f\n  g \\<circ> f = id\n  map_indets g \\<circ> map_indets f = id\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_map_indets_subset: \"indets (map_indets f (p::_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1)) \\<subseteq> f ` indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (map_indets f p) \\<subseteq> f ` indets p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (map_indets f p) \\<Longrightarrow>\n       x \\<in> f ` indets p", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (map_indets f p) \\<Longrightarrow>\n       x \\<in> f ` indets p", "assume \"x \\<in> indets (map_indets f p)\""], ["proof (state)\nthis:\n  x \\<in> indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (map_indets f p) \\<Longrightarrow>\n       x \\<in> f ` indets p", "then"], ["proof (chain)\npicking this:\n  x \\<in> indets (map_indets f p)", "obtain y where \"y \\<in> indets p\" and \"x \\<in> indets (monomial (1::'a) (Poly_Mapping.single (f y) 1))\""], ["proof (prove)\nusing this:\n  x \\<in> indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p;\n         x \\<in> indets (monomial (1::'a) (monomial 1 (f y)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding map_indets_def"], ["proof (prove)\nusing this:\n  x \\<in> indets\n           (poly_subst (\\<lambda>x. monomial (1::'a) (monomial 1 (f x))) p)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p;\n         x \\<in> indets (monomial (1::'a) (monomial 1 (f y)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_indets_poly_substE)"], ["proof (state)\nthis:\n  y \\<in> indets p\n  x \\<in> indets (monomial (1::'a) (monomial 1 (f y)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (map_indets f p) \\<Longrightarrow>\n       x \\<in> f ` indets p", "from this(2)"], ["proof (chain)\npicking this:\n  x \\<in> indets (monomial (1::'a) (monomial 1 (f y)))", "have x: \"x = f y\""], ["proof (prove)\nusing this:\n  x \\<in> indets (monomial (1::'a) (monomial 1 (f y)))\n\ngoal (1 subgoal):\n 1. x = f y", "by (simp add: indets_monomial)"], ["proof (state)\nthis:\n  x = f y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (map_indets f p) \\<Longrightarrow>\n       x \\<in> f ` indets p", "from \\<open>y \\<in> indets p\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> indets p", "show \"x \\<in> f ` indets p\""], ["proof (prove)\nusing this:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. x \\<in> f ` indets p", "unfolding x"], ["proof (prove)\nusing this:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. f y \\<in> f ` indets p", "by (rule imageI)"], ["proof (state)\nthis:\n  x \\<in> f ` indets p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary map_indets_in_Polys: \"map_indets f p \\<in> P[f ` indets p]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets f p \\<in> P[f ` indets p]", "using indets_map_indets_subset"], ["proof (prove)\nusing this:\n  indets (map_indets ?f ?p) \\<subseteq> ?f ` indets ?p\n\ngoal (1 subgoal):\n 1. map_indets f p \\<in> P[f ` indets p]", "by (rule PolysI_alt)"], ["", "lemma indets_map_indets:\n  assumes \"inj_on f (indets p)\"\n  shows \"indets (map_indets f p) = f ` indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (map_indets f p) = f ` indets p", "using indets_map_indets_subset"], ["proof (prove)\nusing this:\n  indets (map_indets ?f ?p) \\<subseteq> ?f ` indets ?p\n\ngoal (1 subgoal):\n 1. indets (map_indets f p) = f ` indets p", "proof (rule subset_antisym)"], ["proof (state)\ngoal (1 subgoal):\n 1. f ` indets p \\<subseteq> indets (map_indets f p)", "let ?g = \"the_inv_into (indets p) f\""], ["proof (state)\ngoal (1 subgoal):\n 1. f ` indets p \\<subseteq> indets (map_indets f p)", "have \"p = map_indets ?g (map_indets f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = map_indets (the_inv_into (indets p) f) (map_indets f p)", "unfolding map_indets_map_indets"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = map_indets (the_inv_into (indets p) f \\<circ> f) p", "by (rule sym, rule map_indets_id) (simp add: assms the_inv_into_f_f)"], ["proof (state)\nthis:\n  p = map_indets (the_inv_into (indets p) f) (map_indets f p)\n\ngoal (1 subgoal):\n 1. f ` indets p \\<subseteq> indets (map_indets f p)", "also"], ["proof (state)\nthis:\n  p = map_indets (the_inv_into (indets p) f) (map_indets f p)\n\ngoal (1 subgoal):\n 1. f ` indets p \\<subseteq> indets (map_indets f p)", "have \"indets \\<dots> \\<subseteq> ?g ` indets (map_indets f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (map_indets (the_inv_into (indets p) f) (map_indets f p))\n    \\<subseteq> the_inv_into (indets p) f ` indets (map_indets f p)", "by (fact indets_map_indets_subset)"], ["proof (state)\nthis:\n  indets (map_indets (the_inv_into (indets p) f) (map_indets f p))\n  \\<subseteq> the_inv_into (indets p) f ` indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. f ` indets p \\<subseteq> indets (map_indets f p)", "finally"], ["proof (chain)\npicking this:\n  indets p \\<subseteq> the_inv_into (indets p) f ` indets (map_indets f p)", "have \"f ` indets p \\<subseteq> f ` ?g ` indets (map_indets f p)\""], ["proof (prove)\nusing this:\n  indets p \\<subseteq> the_inv_into (indets p) f ` indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. f ` indets p\n    \\<subseteq> f ` the_inv_into (indets p) f ` indets (map_indets f p)", "by (rule image_mono)"], ["proof (state)\nthis:\n  f ` indets p\n  \\<subseteq> f ` the_inv_into (indets p) f ` indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. f ` indets p \\<subseteq> indets (map_indets f p)", "also"], ["proof (state)\nthis:\n  f ` indets p\n  \\<subseteq> f ` the_inv_into (indets p) f ` indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. f ` indets p \\<subseteq> indets (map_indets f p)", "have \"\\<dots> = (\\<lambda>x. x) ` indets (map_indets f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` the_inv_into (indets p) f ` indets (map_indets f p) =\n    (\\<lambda>x. x) ` indets (map_indets f p)", "unfolding image_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (the_inv_into (indets p) f x)) `\n    indets (map_indets f p) =\n    (\\<lambda>x. x) ` indets (map_indets f p)", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (the_inv_into (indets p) f x)) `\n    indets (map_indets f p) =\n    (\\<lambda>x. x) ` indets (map_indets f p)", "proof (rule image_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (map_indets f p) \\<Longrightarrow>\n       f (the_inv_into (indets p) f x) = x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (map_indets f p) \\<Longrightarrow>\n       f (the_inv_into (indets p) f x) = x", "assume \"x \\<in> indets (map_indets f p)\""], ["proof (state)\nthis:\n  x \\<in> indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (map_indets f p) \\<Longrightarrow>\n       f (the_inv_into (indets p) f x) = x", "with indets_map_indets_subset"], ["proof (chain)\npicking this:\n  indets (map_indets ?f ?p) \\<subseteq> ?f ` indets ?p\n  x \\<in> indets (map_indets f p)", "have \"x \\<in> f ` indets p\""], ["proof (prove)\nusing this:\n  indets (map_indets ?f ?p) \\<subseteq> ?f ` indets ?p\n  x \\<in> indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. x \\<in> f ` indets p", ".."], ["proof (state)\nthis:\n  x \\<in> f ` indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (map_indets f p) \\<Longrightarrow>\n       f (the_inv_into (indets p) f x) = x", "with assms"], ["proof (chain)\npicking this:\n  inj_on f (indets p)\n  x \\<in> f ` indets p", "show \"f (?g x) = x\""], ["proof (prove)\nusing this:\n  inj_on f (indets p)\n  x \\<in> f ` indets p\n\ngoal (1 subgoal):\n 1. f (the_inv_into (indets p) f x) = x", "by (rule f_the_inv_into_f)"], ["proof (state)\nthis:\n  f (the_inv_into (indets p) f x) = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ` the_inv_into (indets p) f ` indets (map_indets f p) =\n  (\\<lambda>x. x) ` indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. f ` indets p \\<subseteq> indets (map_indets f p)", "finally"], ["proof (chain)\npicking this:\n  f ` indets p \\<subseteq> (\\<lambda>x. x) ` indets (map_indets f p)", "show \"f ` indets p \\<subseteq> indets (map_indets f p)\""], ["proof (prove)\nusing this:\n  f ` indets p \\<subseteq> (\\<lambda>x. x) ` indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. f ` indets p \\<subseteq> indets (map_indets f p)", "by simp"], ["proof (state)\nthis:\n  f ` indets p \\<subseteq> indets (map_indets f p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_map_indets_Polys: \"map_indets f ` P[X] = (P[f ` X]::(_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets f ` P[X] = P[f ` X]", "proof (intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> map_indets f ` P[X] \\<Longrightarrow> x \\<in> P[f ` X]\n 2. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "fix p :: \"_ \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> map_indets f ` P[X] \\<Longrightarrow> x \\<in> P[f ` X]\n 2. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "assume \"p \\<in> map_indets f ` P[X]\""], ["proof (state)\nthis:\n  p \\<in> map_indets f ` P[X]\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> map_indets f ` P[X] \\<Longrightarrow> x \\<in> P[f ` X]\n 2. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "then"], ["proof (chain)\npicking this:\n  p \\<in> map_indets f ` P[X]", "obtain q where \"q \\<in> P[X]\" and \"p = map_indets f q\""], ["proof (prove)\nusing this:\n  p \\<in> map_indets f ` P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[X]; p = map_indets f q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  q \\<in> P[X]\n  p = map_indets f q\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> map_indets f ` P[X] \\<Longrightarrow> x \\<in> P[f ` X]\n 2. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "note this(2)"], ["proof (state)\nthis:\n  p = map_indets f q\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> map_indets f ` P[X] \\<Longrightarrow> x \\<in> P[f ` X]\n 2. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "also"], ["proof (state)\nthis:\n  p = map_indets f q\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> map_indets f ` P[X] \\<Longrightarrow> x \\<in> P[f ` X]\n 2. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "have \"map_indets f q \\<in> P[f ` indets q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets f q \\<in> P[f ` indets q]", "by (fact map_indets_in_Polys)"], ["proof (state)\nthis:\n  map_indets f q \\<in> P[f ` indets q]\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> map_indets f ` P[X] \\<Longrightarrow> x \\<in> P[f ` X]\n 2. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "also"], ["proof (state)\nthis:\n  map_indets f q \\<in> P[f ` indets q]\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> map_indets f ` P[X] \\<Longrightarrow> x \\<in> P[f ` X]\n 2. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "from \\<open>q \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> P[X]", "have \"\\<dots> \\<subseteq> P[f ` X]\""], ["proof (prove)\nusing this:\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. P[f ` indets q] \\<subseteq> P[f ` X]", "by (auto intro!: Polys_mono imageI dest: PolysD)"], ["proof (state)\nthis:\n  P[f ` indets q] \\<subseteq> P[f ` X]\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> map_indets f ` P[X] \\<Longrightarrow> x \\<in> P[f ` X]\n 2. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "finally"], ["proof (chain)\npicking this:\n  p \\<in> P[f ` X]", "show \"p \\<in> P[f ` X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[f ` X]\n\ngoal (1 subgoal):\n 1. p \\<in> P[f ` X]", "."], ["proof (state)\nthis:\n  p \\<in> P[f ` X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "fix p :: \"_ \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "assume \"p \\<in> P[f ` X]\""], ["proof (state)\nthis:\n  p \\<in> P[f ` X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "define g where \"g = (\\<lambda>y. SOME x. x \\<in> X \\<and> f x = y)\""], ["proof (state)\nthis:\n  g = (\\<lambda>y. SOME x. x \\<in> X \\<and> f x = y)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "have \"g y \\<in> X \\<and> f (g y) = y\" if \"y \\<in> indets p\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. g y \\<in> X \\<and> f (g y) = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g y \\<in> X \\<and> f (g y) = y", "note that"], ["proof (state)\nthis:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. g y \\<in> X \\<and> f (g y) = y", "also"], ["proof (state)\nthis:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. g y \\<in> X \\<and> f (g y) = y", "from \\<open>p \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> P[f ` X]", "have \"indets p \\<subseteq> f ` X\""], ["proof (prove)\nusing this:\n  p \\<in> P[f ` X]\n\ngoal (1 subgoal):\n 1. indets p \\<subseteq> f ` X", "by (rule PolysD)"], ["proof (state)\nthis:\n  indets p \\<subseteq> f ` X\n\ngoal (1 subgoal):\n 1. g y \\<in> X \\<and> f (g y) = y", "finally"], ["proof (chain)\npicking this:\n  y \\<in> f ` X", "obtain x where \"x \\<in> X\" and \"y = f x\""], ["proof (prove)\nusing this:\n  y \\<in> f ` X\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> X; y = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> X\n  y = f x\n\ngoal (1 subgoal):\n 1. g y \\<in> X \\<and> f (g y) = y", "hence \"x \\<in> X \\<and> f x = y\""], ["proof (prove)\nusing this:\n  x \\<in> X\n  y = f x\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<and> f x = y", "by simp"], ["proof (state)\nthis:\n  x \\<in> X \\<and> f x = y\n\ngoal (1 subgoal):\n 1. g y \\<in> X \\<and> f (g y) = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> X \\<and> f x = y\n\ngoal (1 subgoal):\n 1. g y \\<in> X \\<and> f (g y) = y", "unfolding g_def"], ["proof (prove)\nusing this:\n  x \\<in> X \\<and> f x = y\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> X \\<and> f x = y) \\<in> X \\<and>\n    f (SOME x. x \\<in> X \\<and> f x = y) = y", "by (rule someI)"], ["proof (state)\nthis:\n  g y \\<in> X \\<and> f (g y) = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y \\<in> indets p \\<Longrightarrow> g ?y \\<in> X \\<and> f (g ?y) = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "hence 1: \"g y \\<in> X\" and 2: \"f (g y) = y\" if \"y \\<in> indets p\" for y"], ["proof (prove)\nusing this:\n  ?y \\<in> indets p \\<Longrightarrow> g ?y \\<in> X \\<and> f (g ?y) = ?y\n\ngoal (1 subgoal):\n 1. g y \\<in> X &&& f (g y) = y", "using that"], ["proof (prove)\nusing this:\n  ?y \\<in> indets p \\<Longrightarrow> g ?y \\<in> X \\<and> f (g ?y) = ?y\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. g y \\<in> X &&& f (g y) = y", "by simp_all"], ["proof (state)\nthis:\n  ?y \\<in> indets p \\<Longrightarrow> g ?y \\<in> X\n  ?y \\<in> indets p \\<Longrightarrow> f (g ?y) = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P[f ` X] \\<Longrightarrow> x \\<in> map_indets f ` P[X]", "show \"p \\<in> map_indets f ` P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> map_indets f ` P[X]", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p = map_indets f ?x\n 2. ?x \\<in> P[X]", "show \"p = map_indets f (map_indets g p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = map_indets f (map_indets g p)", "by (rule sym) (simp add: map_indets_map_indets map_indets_id 2)"], ["proof (state)\nthis:\n  p = map_indets f (map_indets g p)\n\ngoal (1 subgoal):\n 1. map_indets g p \\<in> P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. map_indets g p \\<in> P[X]", "have \"map_indets g p \\<in> P[g ` indets p]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets g p \\<in> P[g ` indets p]", "by (fact map_indets_in_Polys)"], ["proof (state)\nthis:\n  map_indets g p \\<in> P[g ` indets p]\n\ngoal (1 subgoal):\n 1. map_indets g p \\<in> P[X]", "also"], ["proof (state)\nthis:\n  map_indets g p \\<in> P[g ` indets p]\n\ngoal (1 subgoal):\n 1. map_indets g p \\<in> P[X]", "have \"\\<dots> \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[g ` indets p] \\<subseteq> P[X]", "by (auto intro!: Polys_mono 1)"], ["proof (state)\nthis:\n  P[g ` indets p] \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. map_indets g p \\<in> P[X]", "finally"], ["proof (chain)\npicking this:\n  map_indets g p \\<in> P[X]", "show \"map_indets g p \\<in> P[X]\""], ["proof (prove)\nusing this:\n  map_indets g p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. map_indets g p \\<in> P[X]", "."], ["proof (state)\nthis:\n  map_indets g p \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> map_indets f ` P[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary range_map_indets: \"range (map_indets f) = P[range f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (map_indets f) = P[range f]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. range (map_indets f) = P[range f]", "have \"range (map_indets f) = map_indets f ` P[UNIV]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (map_indets f) = map_indets f ` P[UNIV]", "by simp"], ["proof (state)\nthis:\n  range (map_indets f) = map_indets f ` P[UNIV]\n\ngoal (1 subgoal):\n 1. range (map_indets f) = P[range f]", "also"], ["proof (state)\nthis:\n  range (map_indets f) = map_indets f ` P[UNIV]\n\ngoal (1 subgoal):\n 1. range (map_indets f) = P[range f]", "have \"\\<dots> = P[range f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets f ` P[UNIV] = P[range f]", "by (simp only: image_map_indets_Polys)"], ["proof (state)\nthis:\n  map_indets f ` P[UNIV] = P[range f]\n\ngoal (1 subgoal):\n 1. range (map_indets f) = P[range f]", "finally"], ["proof (chain)\npicking this:\n  range (map_indets f) = P[range f]", "show ?thesis"], ["proof (prove)\nusing this:\n  range (map_indets f) = P[range f]\n\ngoal (1 subgoal):\n 1. range (map_indets f) = P[range f]", "."], ["proof (state)\nthis:\n  range (map_indets f) = P[range f]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_keys_map_indetsE:\n  assumes \"t \\<in> keys (map_indets f (p::_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1))\"\n  obtains s where \"s \\<in> keys p\" and \"t = (\\<Sum>x\\<in>keys s. Poly_Mapping.single (f x) (lookup s x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?f = \"(\\<lambda>x. monomial (1::'a) (Poly_Mapping.single (f x) 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  t \\<in> keys (map_indets f p)", "obtain s where \"s \\<in> keys p\" and \"t \\<in> keys (subst_pp ?f s)\""], ["proof (prove)\nusing this:\n  t \\<in> keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t \\<in> keys\n                  (subst_pp\n                    (\\<lambda>x. monomial (1::'a) (monomial 1 (f x)))\n                    s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding map_indets_def"], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (poly_subst (\\<lambda>x. monomial (1::'a) (monomial 1 (f x))) p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t \\<in> keys\n                  (subst_pp\n                    (\\<lambda>x. monomial (1::'a) (monomial 1 (f x)))\n                    s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_poly_substE)"], ["proof (state)\nthis:\n  s \\<in> keys p\n  t \\<in> keys\n           (subst_pp (\\<lambda>x. monomial (1::'a) (monomial 1 (f x))) s)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  t \\<in> keys\n           (subst_pp (\\<lambda>x. monomial (1::'a) (monomial 1 (f x))) s)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  t \\<in> keys\n           (subst_pp (\\<lambda>x. monomial (1::'a) (monomial 1 (f x))) s)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> \\<subseteq> {\\<Sum>x\\<in>keys s. Poly_Mapping.single (f x) (lookup s x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (subst_pp (\\<lambda>x. monomial (1::'a) (monomial 1 (f x))) s)\n    \\<subseteq> {\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x)}", "by (simp add: subst_pp_def monomial_power_map_scale flip: punit.monomial_prod_sum)"], ["proof (state)\nthis:\n  keys (subst_pp (\\<lambda>x. monomial (1::'a) (monomial 1 (f x))) s)\n  \\<subseteq> {\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x)}\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  t \\<in> {\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x)}", "have \"t = (\\<Sum>x\\<in>keys s. Poly_Mapping.single (f x) (lookup s x))\""], ["proof (prove)\nusing this:\n  t \\<in> {\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x)}\n\ngoal (1 subgoal):\n 1. t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))", "by simp"], ["proof (state)\nthis:\n  t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>s \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p\n  t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> keys p\n  t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_map_indets_subset:\n  \"keys (map_indets f p) \\<subseteq> (\\<lambda>t. \\<Sum>x\\<in>keys t. Poly_Mapping.single (f x) (lookup t x)) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (map_indets f p)\n    \\<subseteq> (\\<lambda>t.\n                    \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) `\n                keys p", "by (auto elim: in_keys_map_indetsE)"], ["", "lemma keys_map_indets:\n  assumes \"inj_on f (indets p)\"\n  shows \"keys (map_indets f p) = (\\<lambda>t. \\<Sum>x\\<in>keys t. Poly_Mapping.single (f x) (lookup t x)) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (map_indets f p) =\n    (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p", "using keys_map_indets_subset"], ["proof (prove)\nusing this:\n  keys (map_indets ?f ?p)\n  \\<subseteq> (\\<lambda>t.\n                  \\<Sum>x\\<in>keys t. monomial (lookup t x) (?f x)) `\n              keys ?p\n\ngoal (1 subgoal):\n 1. keys (map_indets f p) =\n    (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p", "proof (rule subset_antisym)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "let ?g = \"the_inv_into (indets p) f\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "have \"p = map_indets ?g (map_indets f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = map_indets (the_inv_into (indets p) f) (map_indets f p)", "unfolding map_indets_map_indets"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = map_indets (the_inv_into (indets p) f \\<circ> f) p", "by (rule sym, rule map_indets_id) (simp add: assms the_inv_into_f_f)"], ["proof (state)\nthis:\n  p = map_indets (the_inv_into (indets p) f) (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "also"], ["proof (state)\nthis:\n  p = map_indets (the_inv_into (indets p) f) (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "have \"keys \\<dots> \\<subseteq> (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (?g x)) ` keys (map_indets f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (map_indets (the_inv_into (indets p) f) (map_indets f p))\n    \\<subseteq> (\\<lambda>t.\n                    \\<Sum>x\\<in>keys t.\n                      monomial (lookup t x) (the_inv_into (indets p) f x)) `\n                keys (map_indets f p)", "by (rule keys_map_indets_subset)"], ["proof (state)\nthis:\n  keys (map_indets (the_inv_into (indets p) f) (map_indets f p))\n  \\<subseteq> (\\<lambda>t.\n                  \\<Sum>x\\<in>keys t.\n                    monomial (lookup t x) (the_inv_into (indets p) f x)) `\n              keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "finally"], ["proof (chain)\npicking this:\n  keys p\n  \\<subseteq> (\\<lambda>t.\n                  \\<Sum>x\\<in>keys t.\n                    monomial (lookup t x) (the_inv_into (indets p) f x)) `\n              keys (map_indets f p)", "have \"(\\<lambda>t. \\<Sum>x\\<in>keys t. Poly_Mapping.single (f x) (lookup t x)) ` keys p \\<subseteq>\n                (\\<lambda>t. \\<Sum>x\\<in>keys t. Poly_Mapping.single (f x) (lookup t x)) `\n                (\\<lambda>t. \\<Sum>x\\<in>keys t. Poly_Mapping.single (?g x) (lookup t x)) ` keys (map_indets f p)\""], ["proof (prove)\nusing this:\n  keys p\n  \\<subseteq> (\\<lambda>t.\n                  \\<Sum>x\\<in>keys t.\n                    monomial (lookup t x) (the_inv_into (indets p) f x)) `\n              keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> (\\<lambda>t.\n                    \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) `\n                (\\<lambda>t.\n                    \\<Sum>x\\<in>keys t.\n                      monomial (lookup t x) (the_inv_into (indets p) f x)) `\n                keys (map_indets f p)", "by (rule image_mono)"], ["proof (state)\nthis:\n  (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n  \\<subseteq> (\\<lambda>t.\n                  \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) `\n              (\\<lambda>t.\n                  \\<Sum>x\\<in>keys t.\n                    monomial (lookup t x) (the_inv_into (indets p) f x)) `\n              keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "also"], ["proof (state)\nthis:\n  (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n  \\<subseteq> (\\<lambda>t.\n                  \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) `\n              (\\<lambda>t.\n                  \\<Sum>x\\<in>keys t.\n                    monomial (lookup t x) (the_inv_into (indets p) f x)) `\n              keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"\\<dots> = (\\<lambda>t. \\<Sum>x. Poly_Mapping.single (f x) (lookup t x)) `\n                       (\\<lambda>t. \\<Sum>x\\<in>keys t. Poly_Mapping.single (?g x) (lookup t x)) ` keys (map_indets f p)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) `\n    (\\<lambda>t.\n        \\<Sum>x\\<in>keys t.\n          monomial (lookup t x) (the_inv_into (indets p) f x)) `\n    keys (map_indets f p) =\n    (\\<lambda>t. \\<Sum>x. monomial (lookup t x) (f x)) `\n    (\\<lambda>t.\n        \\<Sum>x\\<in>keys t.\n          monomial (lookup t x) (the_inv_into (indets p) f x)) `\n    keys (map_indets f p)", "by (rule image_cong)\n        (smt Sum_any.conditionalize Sum_any.cong finite_keys not_in_keys_iff_lookup_eq_zero single_zero)"], ["proof (state)\nthis:\n  (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) `\n  (\\<lambda>t.\n      \\<Sum>x\\<in>keys t.\n        monomial (lookup t x) (the_inv_into (indets p) f x)) `\n  keys (map_indets f p) =\n  (\\<lambda>t. \\<Sum>x. monomial (lookup t x) (f x)) `\n  (\\<lambda>t.\n      \\<Sum>x\\<in>keys t.\n        monomial (lookup t x) (the_inv_into (indets p) f x)) `\n  keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "also"], ["proof (state)\nthis:\n  (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) `\n  (\\<lambda>t.\n      \\<Sum>x\\<in>keys t.\n        monomial (lookup t x) (the_inv_into (indets p) f x)) `\n  keys (map_indets f p) =\n  (\\<lambda>t. \\<Sum>x. monomial (lookup t x) (f x)) `\n  (\\<lambda>t.\n      \\<Sum>x\\<in>keys t.\n        monomial (lookup t x) (the_inv_into (indets p) f x)) `\n  keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "have \"\\<dots> = (\\<lambda>t. t) ` keys (map_indets f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x. monomial (lookup t x) (f x)) `\n    (\\<lambda>t.\n        \\<Sum>x\\<in>keys t.\n          monomial (lookup t x) (the_inv_into (indets p) f x)) `\n    keys (map_indets f p) =\n    (\\<lambda>t. t) ` keys (map_indets f p)", "unfolding image_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) `\n    keys (map_indets f p) =\n    (\\<lambda>t. t) ` keys (map_indets f p)", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) `\n    keys (map_indets f p) =\n    (\\<lambda>t. t) ` keys (map_indets f p)", "proof (rule image_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "assume \"t \\<in> keys (map_indets f p)\""], ["proof (state)\nthis:\n  t \\<in> keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "have \"(\\<Sum>x. monomial (lookup (\\<Sum>y\\<in>keys t. Poly_Mapping.single (?g y) (lookup t y)) x) (f x)) =\n          (\\<Sum>x. \\<Sum>y\\<in>keys t. monomial (lookup t y when ?g y = x) (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x. monomial\n               (lookup\n                 (\\<Sum>y\\<in>keys t.\n                    monomial (lookup t y) (the_inv_into (indets p) f y))\n                 x)\n               (f x)) =\n    (\\<Sum>x. \\<Sum>y\\<in>keys t.\n                monomial (lookup t y when the_inv_into (indets p) f y = x)\n                 (f x))", "by (simp add: lookup_sum lookup_single monomial_sum)"], ["proof (state)\nthis:\n  (\\<Sum>x. monomial\n             (lookup\n               (\\<Sum>y\\<in>keys t.\n                  monomial (lookup t y) (the_inv_into (indets p) f y))\n               x)\n             (f x)) =\n  (\\<Sum>x. \\<Sum>y\\<in>keys t.\n              monomial (lookup t y when the_inv_into (indets p) f y = x)\n               (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "also"], ["proof (state)\nthis:\n  (\\<Sum>x. monomial\n             (lookup\n               (\\<Sum>y\\<in>keys t.\n                  monomial (lookup t y) (the_inv_into (indets p) f y))\n               x)\n             (f x)) =\n  (\\<Sum>x. \\<Sum>y\\<in>keys t.\n              monomial (lookup t y when the_inv_into (indets p) f y = x)\n               (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "have \"\\<dots> = (\\<Sum>x\\<in>indets p. \\<Sum>y\\<in>keys t. Poly_Mapping.single (f x) (lookup t y when ?g y = x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x. \\<Sum>y\\<in>keys t.\n                monomial (lookup t y when the_inv_into (indets p) f y = x)\n                 (f x)) =\n    (\\<Sum>x\\<in>indets p.\n       \\<Sum>y\\<in>keys t.\n         monomial (lookup t y when the_inv_into (indets p) f y = x) (f x))", "proof (intro Sum_any.expand_superset finite_indets subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                      monomial\n                       (lookup t y when the_inv_into (indets p) f y = a)\n                       (f a)) \\<noteq>\n                   0} \\<Longrightarrow>\n       x \\<in> indets p", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                      monomial\n                       (lookup t y when the_inv_into (indets p) f y = a)\n                       (f a)) \\<noteq>\n                   0} \\<Longrightarrow>\n       x \\<in> indets p", "assume \"x \\<in> {a. (\\<Sum>y\\<in>keys t. Poly_Mapping.single (f a) (lookup t y when ?g y = a)) \\<noteq> 0}\""], ["proof (state)\nthis:\n  x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                 monomial (lookup t y when the_inv_into (indets p) f y = a)\n                  (f a)) \\<noteq>\n              0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                      monomial\n                       (lookup t y when the_inv_into (indets p) f y = a)\n                       (f a)) \\<noteq>\n                   0} \\<Longrightarrow>\n       x \\<in> indets p", "hence \"(\\<Sum>y\\<in>keys t. Poly_Mapping.single (f x) (lookup t y when ?g y = x)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                 monomial (lookup t y when the_inv_into (indets p) f y = a)\n                  (f a)) \\<noteq>\n              0}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t.\n       monomial (lookup t y when the_inv_into (indets p) f y = x)\n        (f x)) \\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>keys t.\n     monomial (lookup t y when the_inv_into (indets p) f y = x)\n      (f x)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                      monomial\n                       (lookup t y when the_inv_into (indets p) f y = a)\n                       (f a)) \\<noteq>\n                   0} \\<Longrightarrow>\n       x \\<in> indets p", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>keys t.\n     monomial (lookup t y when the_inv_into (indets p) f y = x)\n      (f x)) \\<noteq>\n  0", "obtain y where \"y \\<in> keys t\" and *: \"Poly_Mapping.single (f x) (lookup t y when ?g y = x) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>keys t.\n     monomial (lookup t y when the_inv_into (indets p) f y = x)\n      (f x)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t;\n         monomial (lookup t y when the_inv_into (indets p) f y = x)\n          (f x) \\<noteq>\n         0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule sum.not_neutral_contains_not_neutral)"], ["proof (state)\nthis:\n  y \\<in> keys t\n  monomial (lookup t y when the_inv_into (indets p) f y = x) (f x) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                      monomial\n                       (lookup t y when the_inv_into (indets p) f y = a)\n                       (f a)) \\<noteq>\n                   0} \\<Longrightarrow>\n       x \\<in> indets p", "from this(1)"], ["proof (chain)\npicking this:\n  y \\<in> keys t", "have \"y \\<in> indets (map_indets f p)\""], ["proof (prove)\nusing this:\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. y \\<in> indets (map_indets f p)", "using \\<open>t \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> keys t\n  t \\<in> keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. y \\<in> indets (map_indets f p)", "by (rule in_indetsI)"], ["proof (state)\nthis:\n  y \\<in> indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                      monomial\n                       (lookup t y when the_inv_into (indets p) f y = a)\n                       (f a)) \\<noteq>\n                   0} \\<Longrightarrow>\n       x \\<in> indets p", "with indets_map_indets_subset"], ["proof (chain)\npicking this:\n  indets (map_indets ?f ?p) \\<subseteq> ?f ` indets ?p\n  y \\<in> indets (map_indets f p)", "have \"y \\<in> f ` indets p\""], ["proof (prove)\nusing this:\n  indets (map_indets ?f ?p) \\<subseteq> ?f ` indets ?p\n  y \\<in> indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. y \\<in> f ` indets p", ".."], ["proof (state)\nthis:\n  y \\<in> f ` indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                      monomial\n                       (lookup t y when the_inv_into (indets p) f y = a)\n                       (f a)) \\<noteq>\n                   0} \\<Longrightarrow>\n       x \\<in> indets p", "from *"], ["proof (chain)\npicking this:\n  monomial (lookup t y when the_inv_into (indets p) f y = x) (f x) \\<noteq>\n  0", "have \"x = ?g y\""], ["proof (prove)\nusing this:\n  monomial (lookup t y when the_inv_into (indets p) f y = x) (f x) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. x = the_inv_into (indets p) f y", "by (simp add: when_def split: if_split_asm)"], ["proof (state)\nthis:\n  x = the_inv_into (indets p) f y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                      monomial\n                       (lookup t y when the_inv_into (indets p) f y = a)\n                       (f a)) \\<noteq>\n                   0} \\<Longrightarrow>\n       x \\<in> indets p", "also"], ["proof (state)\nthis:\n  x = the_inv_into (indets p) f y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                      monomial\n                       (lookup t y when the_inv_into (indets p) f y = a)\n                       (f a)) \\<noteq>\n                   0} \\<Longrightarrow>\n       x \\<in> indets p", "from assms \\<open>y \\<in> f ` indets p\\<close> subset_refl"], ["proof (chain)\npicking this:\n  inj_on f (indets p)\n  y \\<in> f ` indets p\n  ?A \\<subseteq> ?A", "have \"\\<dots> \\<in> indets p\""], ["proof (prove)\nusing this:\n  inj_on f (indets p)\n  y \\<in> f ` indets p\n  ?A \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. the_inv_into (indets p) f y \\<in> indets p", "by (rule the_inv_into_into)"], ["proof (state)\nthis:\n  the_inv_into (indets p) f y \\<in> indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {a. (\\<Sum>y\\<in>keys t.\n                      monomial\n                       (lookup t y when the_inv_into (indets p) f y = a)\n                       (f a)) \\<noteq>\n                   0} \\<Longrightarrow>\n       x \\<in> indets p", "finally"], ["proof (chain)\npicking this:\n  x \\<in> indets p", "show \"x \\<in> indets p\""], ["proof (prove)\nusing this:\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. x \\<in> indets p", "."], ["proof (state)\nthis:\n  x \\<in> indets p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x. \\<Sum>y\\<in>keys t.\n              monomial (lookup t y when the_inv_into (indets p) f y = x)\n               (f x)) =\n  (\\<Sum>x\\<in>indets p.\n     \\<Sum>y\\<in>keys t.\n       monomial (lookup t y when the_inv_into (indets p) f y = x) (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "also"], ["proof (state)\nthis:\n  (\\<Sum>x. \\<Sum>y\\<in>keys t.\n              monomial (lookup t y when the_inv_into (indets p) f y = x)\n               (f x)) =\n  (\\<Sum>x\\<in>indets p.\n     \\<Sum>y\\<in>keys t.\n       monomial (lookup t y when the_inv_into (indets p) f y = x) (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "have \"\\<dots> = (\\<Sum>y\\<in>keys t. \\<Sum>x\\<in>indets p. Poly_Mapping.single (f x) (lookup t y when ?g y = x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>indets p.\n       \\<Sum>y\\<in>keys t.\n         monomial (lookup t y when the_inv_into (indets p) f y = x) (f x)) =\n    (\\<Sum>y\\<in>keys t.\n       \\<Sum>x\\<in>indets p.\n         monomial (lookup t y when the_inv_into (indets p) f y = x) (f x))", "by (fact sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>indets p.\n     \\<Sum>y\\<in>keys t.\n       monomial (lookup t y when the_inv_into (indets p) f y = x) (f x)) =\n  (\\<Sum>y\\<in>keys t.\n     \\<Sum>x\\<in>indets p.\n       monomial (lookup t y when the_inv_into (indets p) f y = x) (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>indets p.\n     \\<Sum>y\\<in>keys t.\n       monomial (lookup t y when the_inv_into (indets p) f y = x) (f x)) =\n  (\\<Sum>y\\<in>keys t.\n     \\<Sum>x\\<in>indets p.\n       monomial (lookup t y when the_inv_into (indets p) f y = x) (f x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"\\<dots> = (\\<Sum>y\\<in>keys t. Poly_Mapping.single y (lookup t y))\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t.\n       \\<Sum>x\\<in>indets p.\n         monomial (lookup t y when the_inv_into (indets p) f y = x) (f x)) =\n    (\\<Sum>y\\<in>keys t. monomial (lookup t y) y)", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       (\\<Sum>xa\\<in>indets p.\n          monomial (lookup t x when the_inv_into (indets p) f x = xa)\n           (f xa)) =\n       monomial (lookup t x) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       (\\<Sum>xa\\<in>indets p.\n          monomial (lookup t x when the_inv_into (indets p) f x = xa)\n           (f xa)) =\n       monomial (lookup t x) x", "assume \"x \\<in> keys t\""], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       (\\<Sum>xa\\<in>indets p.\n          monomial (lookup t x when the_inv_into (indets p) f x = xa)\n           (f xa)) =\n       monomial (lookup t x) x", "hence \"x \\<in> indets (map_indets f p)\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> indets (map_indets f p)", "using \\<open>t \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> keys t\n  t \\<in> keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. x \\<in> indets (map_indets f p)", "by (rule in_indetsI)"], ["proof (state)\nthis:\n  x \\<in> indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       (\\<Sum>xa\\<in>indets p.\n          monomial (lookup t x when the_inv_into (indets p) f x = xa)\n           (f xa)) =\n       monomial (lookup t x) x", "with indets_map_indets_subset"], ["proof (chain)\npicking this:\n  indets (map_indets ?f ?p) \\<subseteq> ?f ` indets ?p\n  x \\<in> indets (map_indets f p)", "have \"x \\<in> f ` indets p\""], ["proof (prove)\nusing this:\n  indets (map_indets ?f ?p) \\<subseteq> ?f ` indets ?p\n  x \\<in> indets (map_indets f p)\n\ngoal (1 subgoal):\n 1. x \\<in> f ` indets p", ".."], ["proof (state)\nthis:\n  x \\<in> f ` indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       (\\<Sum>xa\\<in>indets p.\n          monomial (lookup t x when the_inv_into (indets p) f x = xa)\n           (f xa)) =\n       monomial (lookup t x) x", "with assms"], ["proof (chain)\npicking this:\n  inj_on f (indets p)\n  x \\<in> f ` indets p", "have \"?g x \\<in> indets p\""], ["proof (prove)\nusing this:\n  inj_on f (indets p)\n  x \\<in> f ` indets p\n\ngoal (1 subgoal):\n 1. the_inv_into (indets p) f x \\<in> indets p", "using subset_refl"], ["proof (prove)\nusing this:\n  inj_on f (indets p)\n  x \\<in> f ` indets p\n  ?A \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. the_inv_into (indets p) f x \\<in> indets p", "by (rule the_inv_into_into)"], ["proof (state)\nthis:\n  the_inv_into (indets p) f x \\<in> indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       (\\<Sum>xa\\<in>indets p.\n          monomial (lookup t x when the_inv_into (indets p) f x = xa)\n           (f xa)) =\n       monomial (lookup t x) x", "hence \"{?g x} \\<subseteq> indets p\""], ["proof (prove)\nusing this:\n  the_inv_into (indets p) f x \\<in> indets p\n\ngoal (1 subgoal):\n 1. {the_inv_into (indets p) f x} \\<subseteq> indets p", "by simp"], ["proof (state)\nthis:\n  {the_inv_into (indets p) f x} \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       (\\<Sum>xa\\<in>indets p.\n          monomial (lookup t x when the_inv_into (indets p) f x = xa)\n           (f xa)) =\n       monomial (lookup t x) x", "with finite_indets"], ["proof (chain)\npicking this:\n  finite (indets ?p)\n  {the_inv_into (indets p) f x} \\<subseteq> indets p", "have \"(\\<Sum>y\\<in>indets p. Poly_Mapping.single (f y) (lookup t x when ?g x = y)) =\n                                (\\<Sum>y\\<in>{?g x}. Poly_Mapping.single (f y) (lookup t x when ?g x = y))\""], ["proof (prove)\nusing this:\n  finite (indets ?p)\n  {the_inv_into (indets p) f x} \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>indets p.\n       monomial (lookup t x when the_inv_into (indets p) f x = y) (f y)) =\n    (\\<Sum>y\\<in>{the_inv_into (indets p) f x}.\n       monomial (lookup t x when the_inv_into (indets p) f x = y) (f y))", "by (rule sum.mono_neutral_right) (simp add: monomial_0_iff when_def)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>indets p.\n     monomial (lookup t x when the_inv_into (indets p) f x = y) (f y)) =\n  (\\<Sum>y\\<in>{the_inv_into (indets p) f x}.\n     monomial (lookup t x when the_inv_into (indets p) f x = y) (f y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       (\\<Sum>xa\\<in>indets p.\n          monomial (lookup t x when the_inv_into (indets p) f x = xa)\n           (f xa)) =\n       monomial (lookup t x) x", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>indets p.\n     monomial (lookup t x when the_inv_into (indets p) f x = y) (f y)) =\n  (\\<Sum>y\\<in>{the_inv_into (indets p) f x}.\n     monomial (lookup t x when the_inv_into (indets p) f x = y) (f y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       (\\<Sum>xa\\<in>indets p.\n          monomial (lookup t x when the_inv_into (indets p) f x = xa)\n           (f xa)) =\n       monomial (lookup t x) x", "from assms \\<open>x \\<in> f ` indets p\\<close>"], ["proof (chain)\npicking this:\n  inj_on f (indets p)\n  x \\<in> f ` indets p", "have \"\\<dots> = Poly_Mapping.single x (lookup t x)\""], ["proof (prove)\nusing this:\n  inj_on f (indets p)\n  x \\<in> f ` indets p\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{the_inv_into (indets p) f x}.\n       monomial (lookup t x when the_inv_into (indets p) f x = y) (f y)) =\n    monomial (lookup t x) x", "by (simp add: f_the_inv_into_f)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{the_inv_into (indets p) f x}.\n     monomial (lookup t x when the_inv_into (indets p) f x = y) (f y)) =\n  monomial (lookup t x) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys t \\<Longrightarrow>\n       (\\<Sum>xa\\<in>indets p.\n          monomial (lookup t x when the_inv_into (indets p) f x = xa)\n           (f xa)) =\n       monomial (lookup t x) x", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>indets p.\n     monomial (lookup t x when the_inv_into (indets p) f x = y) (f y)) =\n  monomial (lookup t x) x", "show \"(\\<Sum>y\\<in>indets p. Poly_Mapping.single (f y) (lookup t x when ?g x = y)) =\n                      Poly_Mapping.single x (lookup t x)\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>indets p.\n     monomial (lookup t x when the_inv_into (indets p) f x = y) (f y)) =\n  monomial (lookup t x) x\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>indets p.\n       monomial (lookup t x when the_inv_into (indets p) f x = y) (f y)) =\n    monomial (lookup t x) x", "."], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>indets p.\n     monomial (lookup t x when the_inv_into (indets p) f x = y) (f y)) =\n  monomial (lookup t x) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>keys t.\n     \\<Sum>x\\<in>indets p.\n       monomial (lookup t y when the_inv_into (indets p) f y = x) (f x)) =\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>keys t.\n     \\<Sum>x\\<in>indets p.\n       monomial (lookup t y when the_inv_into (indets p) f y = x) (f x)) =\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "have \"\\<dots> = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t. monomial (lookup t y) y) = t", "by (fact poly_mapping_sum_monomials)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) y) = t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (map_indets f p) \\<Longrightarrow>\n       (\\<Sum>xa. monomial\n                   (lookup\n                     (\\<Sum>xa\\<in>keys x.\n                        monomial (lookup x xa)\n                         (the_inv_into (indets p) f xa))\n                     xa)\n                   (f xa)) =\n       x", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x. monomial\n             (lookup\n               (\\<Sum>y\\<in>keys t.\n                  monomial (lookup t y) (the_inv_into (indets p) f y))\n               x)\n             (f x)) =\n  t", "show \"(\\<Sum>x. monomial (lookup (\\<Sum>y\\<in>keys t. Poly_Mapping.single (?g y) (lookup t y)) x) (f x)) = t\""], ["proof (prove)\nusing this:\n  (\\<Sum>x. monomial\n             (lookup\n               (\\<Sum>y\\<in>keys t.\n                  monomial (lookup t y) (the_inv_into (indets p) f y))\n               x)\n             (f x)) =\n  t\n\ngoal (1 subgoal):\n 1. (\\<Sum>x. monomial\n               (lookup\n                 (\\<Sum>y\\<in>keys t.\n                    monomial (lookup t y) (the_inv_into (indets p) f y))\n                 x)\n               (f x)) =\n    t", "."], ["proof (state)\nthis:\n  (\\<Sum>x. monomial\n             (lookup\n               (\\<Sum>y\\<in>keys t.\n                  monomial (lookup t y) (the_inv_into (indets p) f y))\n               x)\n             (f x)) =\n  t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>t. \\<Sum>x. monomial (lookup t x) (f x)) `\n  (\\<lambda>t.\n      \\<Sum>x\\<in>keys t.\n        monomial (lookup t x) (the_inv_into (indets p) f x)) `\n  keys (map_indets f p) =\n  (\\<lambda>t. t) ` keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "also"], ["proof (state)\nthis:\n  (\\<lambda>t. \\<Sum>x. monomial (lookup t x) (f x)) `\n  (\\<lambda>t.\n      \\<Sum>x\\<in>keys t.\n        monomial (lookup t x) (the_inv_into (indets p) f x)) `\n  keys (map_indets f p) =\n  (\\<lambda>t. t) ` keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "have \"\\<dots> = keys (map_indets f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. t) ` keys (map_indets f p) = keys (map_indets f p)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>t. t) ` keys (map_indets f p) = keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n  \\<subseteq> keys (map_indets f p)", "show \"(\\<lambda>t. \\<Sum>x\\<in>keys t. Poly_Mapping.single (f x) (lookup t x)) ` keys p \\<subseteq> keys (map_indets f p)\""], ["proof (prove)\nusing this:\n  (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n  \\<subseteq> keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n    \\<subseteq> keys (map_indets f p)", "."], ["proof (state)\nthis:\n  (\\<lambda>t. \\<Sum>x\\<in>keys t. monomial (lookup t x) (f x)) ` keys p\n  \\<subseteq> keys (map_indets f p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_map_indets_le: \"poly_deg (map_indets f p) \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (map_indets f p) \\<le> poly_deg p", "proof (rule poly_deg_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (map_indets f p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (map_indets f p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "assume \"t \\<in> keys (map_indets f p)\""], ["proof (state)\nthis:\n  t \\<in> keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (map_indets f p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "then"], ["proof (chain)\npicking this:\n  t \\<in> keys (map_indets f p)", "obtain s where \"s \\<in> keys p\" and t: \"t = (\\<Sum>x\\<in>keys s. Poly_Mapping.single (f x) (lookup s x))\""], ["proof (prove)\nusing this:\n  t \\<in> keys (map_indets f p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_map_indetsE)"], ["proof (state)\nthis:\n  s \\<in> keys p\n  t = (\\<Sum>x\\<in>keys s. monomial (lookup s x) (f x))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (map_indets f p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "from this(1)"], ["proof (chain)\npicking this:\n  s \\<in> keys p", "have \"deg_pm s \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm s \\<le> poly_deg p", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm s \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (map_indets f p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "thus \"deg_pm t \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  deg_pm s \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "by (simp add: t deg_pm_sum deg_pm_single deg_pm_superset[OF subset_refl])"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_map_indets:\n  assumes \"inj_on f (indets p)\"\n  shows \"poly_deg (map_indets f p) = poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (map_indets f p) = poly_deg p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg (map_indets f p) = poly_deg p", "from assms"], ["proof (chain)\npicking this:\n  inj_on f (indets p)", "have \"deg_pm ` keys (map_indets f p) = deg_pm ` keys p\""], ["proof (prove)\nusing this:\n  inj_on f (indets p)\n\ngoal (1 subgoal):\n 1. deg_pm ` keys (map_indets f p) = deg_pm ` keys p", "by (simp add: keys_map_indets image_image deg_pm_sum deg_pm_single\n          flip: deg_pm_superset[OF subset_refl])"], ["proof (state)\nthis:\n  deg_pm ` keys (map_indets f p) = deg_pm ` keys p\n\ngoal (1 subgoal):\n 1. poly_deg (map_indets f p) = poly_deg p", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pm ` keys (map_indets f p) = deg_pm ` keys p\n\ngoal (1 subgoal):\n 1. poly_deg (map_indets f p) = poly_deg p", "by (auto simp: poly_deg_def)"], ["proof (state)\nthis:\n  poly_deg (map_indets f p) = poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_indets_inj_on_PolysI:\n  assumes \"inj_on (f::'x \\<Rightarrow> 'y) X\"\n  shows \"inj_on ((map_indets f)::_ \\<Rightarrow> _ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1) P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (map_indets f) P[X]", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> P[X]; y \\<in> P[X];\n        map_indets f x = map_indets f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix p q :: \"_ \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> P[X]; y \\<in> P[X];\n        map_indets f x = map_indets f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"p \\<in> P[X]\""], ["proof (state)\nthis:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> P[X]; y \\<in> P[X];\n        map_indets f x = map_indets f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with assms"], ["proof (chain)\npicking this:\n  inj_on f X\n  p \\<in> P[X]", "have 1: \"map_indets (the_inv_into X f) (map_indets f p) = p\" (is \"map_indets ?g _ = _\")"], ["proof (prove)\nusing this:\n  inj_on f X\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. map_indets (the_inv_into X f) (map_indets f p) = p", "by (rule map_indets_inverseE_Polys)"], ["proof (state)\nthis:\n  map_indets (the_inv_into X f) (map_indets f p) = p\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> P[X]; y \\<in> P[X];\n        map_indets f x = map_indets f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"q \\<in> P[X]\""], ["proof (state)\nthis:\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> P[X]; y \\<in> P[X];\n        map_indets f x = map_indets f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with assms"], ["proof (chain)\npicking this:\n  inj_on f X\n  q \\<in> P[X]", "have \"map_indets ?g (map_indets f q) = q\""], ["proof (prove)\nusing this:\n  inj_on f X\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. map_indets (the_inv_into X f) (map_indets f q) = q", "by (rule map_indets_inverseE_Polys)"], ["proof (state)\nthis:\n  map_indets (the_inv_into X f) (map_indets f q) = q\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> P[X]; y \\<in> P[X];\n        map_indets f x = map_indets f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  map_indets (the_inv_into X f) (map_indets f q) = q\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> P[X]; y \\<in> P[X];\n        map_indets f x = map_indets f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"map_indets f p = map_indets f q\""], ["proof (state)\nthis:\n  map_indets f p = map_indets f q\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> P[X]; y \\<in> P[X];\n        map_indets f x = map_indets f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  map_indets (the_inv_into X f) (map_indets f q) = q\n  map_indets f p = map_indets f q", "show \"p = q\""], ["proof (prove)\nusing this:\n  map_indets (the_inv_into X f) (map_indets f q) = q\n  map_indets f p = map_indets f q\n\ngoal (1 subgoal):\n 1. p = q", "using 1"], ["proof (prove)\nusing this:\n  map_indets (the_inv_into X f) (map_indets f q) = q\n  map_indets f p = map_indets f q\n  map_indets (the_inv_into X f) (map_indets f p) = p\n\ngoal (1 subgoal):\n 1. p = q", "by (simp add: map_indets_map_indets)"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_indets_injI:\n  assumes \"inj f\"\n  shows \"inj (map_indets f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (map_indets f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj (map_indets f)", "from assms"], ["proof (chain)\npicking this:\n  inj f", "have \"inj_on (map_indets f) P[UNIV]\""], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. inj_on (map_indets f) P[UNIV]", "by (rule map_indets_inj_on_PolysI)"], ["proof (state)\nthis:\n  inj_on (map_indets f) P[UNIV]\n\ngoal (1 subgoal):\n 1. inj (map_indets f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj_on (map_indets f) P[UNIV]\n\ngoal (1 subgoal):\n 1. inj (map_indets f)", "by simp"], ["proof (state)\nthis:\n  inj (map_indets f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_map_indets_ideal:\n  assumes \"inj f\"\n  shows \"map_indets f ` ideal F = ideal (map_indets f ` (F::(_ \\<Rightarrow>\\<^sub>0 'a::comm_ring_1) set)) \\<inter> P[range f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets f ` ideal F = ideal (map_indets f ` F) \\<inter> P[range f]", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. map_indets f ` ideal F\n    \\<subseteq> ideal (map_indets f ` F) \\<inter> P[range f]\n 2. ideal (map_indets f ` F) \\<inter> P[range f]\n    \\<subseteq> map_indets f ` ideal F", "from map_indets_plus map_indets_times"], ["proof (chain)\npicking this:\n  map_indets ?f (?p + ?q) = map_indets ?f ?p + map_indets ?f ?q\n  map_indets ?f (?p * ?q) = map_indets ?f ?p * map_indets ?f ?q", "have \"map_indets f ` ideal F \\<subseteq> ideal (map_indets f ` F)\""], ["proof (prove)\nusing this:\n  map_indets ?f (?p + ?q) = map_indets ?f ?p + map_indets ?f ?q\n  map_indets ?f (?p * ?q) = map_indets ?f ?p * map_indets ?f ?q\n\ngoal (1 subgoal):\n 1. map_indets f ` ideal F \\<subseteq> ideal (map_indets f ` F)", "by (rule image_ideal_subset)"], ["proof (state)\nthis:\n  map_indets f ` ideal F \\<subseteq> ideal (map_indets f ` F)\n\ngoal (2 subgoals):\n 1. map_indets f ` ideal F\n    \\<subseteq> ideal (map_indets f ` F) \\<inter> P[range f]\n 2. ideal (map_indets f ` F) \\<inter> P[range f]\n    \\<subseteq> map_indets f ` ideal F", "moreover"], ["proof (state)\nthis:\n  map_indets f ` ideal F \\<subseteq> ideal (map_indets f ` F)\n\ngoal (2 subgoals):\n 1. map_indets f ` ideal F\n    \\<subseteq> ideal (map_indets f ` F) \\<inter> P[range f]\n 2. ideal (map_indets f ` F) \\<inter> P[range f]\n    \\<subseteq> map_indets f ` ideal F", "from subset_UNIV"], ["proof (chain)\npicking this:\n  ?A \\<subseteq> UNIV", "have \"map_indets f ` ideal F \\<subseteq> range (map_indets f)\""], ["proof (prove)\nusing this:\n  ?A \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. map_indets f ` ideal F \\<subseteq> range (map_indets f)", "by (rule image_mono)"], ["proof (state)\nthis:\n  map_indets f ` ideal F \\<subseteq> range (map_indets f)\n\ngoal (2 subgoals):\n 1. map_indets f ` ideal F\n    \\<subseteq> ideal (map_indets f ` F) \\<inter> P[range f]\n 2. ideal (map_indets f ` F) \\<inter> P[range f]\n    \\<subseteq> map_indets f ` ideal F", "ultimately"], ["proof (chain)\npicking this:\n  map_indets f ` ideal F \\<subseteq> ideal (map_indets f ` F)\n  map_indets f ` ideal F \\<subseteq> range (map_indets f)", "show \"map_indets f ` ideal F \\<subseteq> ideal (map_indets f ` F) \\<inter> P[range f]\""], ["proof (prove)\nusing this:\n  map_indets f ` ideal F \\<subseteq> ideal (map_indets f ` F)\n  map_indets f ` ideal F \\<subseteq> range (map_indets f)\n\ngoal (1 subgoal):\n 1. map_indets f ` ideal F\n    \\<subseteq> ideal (map_indets f ` F) \\<inter> P[range f]", "unfolding range_map_indets"], ["proof (prove)\nusing this:\n  map_indets f ` ideal F \\<subseteq> ideal (map_indets f ` F)\n  map_indets f ` ideal F \\<subseteq> P[range f]\n\ngoal (1 subgoal):\n 1. map_indets f ` ideal F\n    \\<subseteq> ideal (map_indets f ` F) \\<inter> P[range f]", "by blast"], ["proof (state)\nthis:\n  map_indets f ` ideal F\n  \\<subseteq> ideal (map_indets f ` F) \\<inter> P[range f]\n\ngoal (1 subgoal):\n 1. ideal (map_indets f ` F) \\<inter> P[range f]\n    \\<subseteq> map_indets f ` ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ideal (map_indets f ` F) \\<inter> P[range f]\n    \\<subseteq> map_indets f ` ideal F", "show \"ideal (map_indets f ` F) \\<inter> P[range f] \\<subseteq> map_indets f ` ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (map_indets f ` F) \\<inter> P[range f]\n    \\<subseteq> map_indets f ` ideal F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "assume \"p \\<in> ideal (map_indets f ` F) \\<inter> P[range f]\""], ["proof (state)\nthis:\n  p \\<in> ideal (map_indets f ` F) \\<inter> P[range f]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "hence \"p \\<in> ideal (map_indets f ` F)\" and \"p \\<in> range (map_indets f)\""], ["proof (prove)\nusing this:\n  p \\<in> ideal (map_indets f ` F) \\<inter> P[range f]\n\ngoal (1 subgoal):\n 1. p \\<in> ideal (map_indets f ` F) &&& p \\<in> range (map_indets f)", "by (simp_all add: range_map_indets)"], ["proof (state)\nthis:\n  p \\<in> ideal (map_indets f ` F)\n  p \\<in> range (map_indets f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "from this(1)"], ["proof (chain)\npicking this:\n  p \\<in> ideal (map_indets f ` F)", "obtain F0 q where \"F0 \\<subseteq> map_indets f ` F\" and p: \"p = (\\<Sum>f'\\<in>F0. q f' * f')\""], ["proof (prove)\nusing this:\n  p \\<in> ideal (map_indets f ` F)\n\ngoal (1 subgoal):\n 1. (\\<And>F0 q.\n        \\<lbrakk>F0 \\<subseteq> map_indets f ` F;\n         p = (\\<Sum>f'\\<in>F0. q f' * f')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule ideal.spanE)"], ["proof (state)\nthis:\n  F0 \\<subseteq> map_indets f ` F\n  p = (\\<Sum>f'\\<in>F0. q f' * f')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "from this(1)"], ["proof (chain)\npicking this:\n  F0 \\<subseteq> map_indets f ` F", "obtain F' where \"F' \\<subseteq> F\" and F0: \"F0 = map_indets f ` F'\""], ["proof (prove)\nusing this:\n  F0 \\<subseteq> map_indets f ` F\n\ngoal (1 subgoal):\n 1. (\\<And>F'.\n        \\<lbrakk>F' \\<subseteq> F; F0 = map_indets f ` F'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule subset_imageE)"], ["proof (state)\nthis:\n  F' \\<subseteq> F\n  F0 = map_indets f ` F'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "from assms"], ["proof (chain)\npicking this:\n  inj f", "obtain g where \"map_indets g \\<circ> map_indets f = (id::_ \\<Rightarrow> _ \\<Rightarrow>\\<^sub>0 'a)\""], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        map_indets g \\<circ> map_indets f = id \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule map_indets_inverseE)"], ["proof (state)\nthis:\n  map_indets g \\<circ> map_indets f = id\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "hence eq: \"map_indets g (map_indets f p') = p'\" for p'::\"_ \\<Rightarrow>\\<^sub>0 'a\""], ["proof (prove)\nusing this:\n  map_indets g \\<circ> map_indets f = id\n\ngoal (1 subgoal):\n 1. map_indets g (map_indets f p') = p'", "by (simp add: pointfree_idE)"], ["proof (state)\nthis:\n  map_indets g (map_indets f ?p') = ?p'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "from assms"], ["proof (chain)\npicking this:\n  inj f", "have \"inj (map_indets f)\""], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. inj (map_indets f)", "by (rule map_indets_injI)"], ["proof (state)\nthis:\n  inj (map_indets f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "from this subset_UNIV"], ["proof (chain)\npicking this:\n  inj (map_indets f)\n  ?A \\<subseteq> UNIV", "have \"inj_on (map_indets f) F'\""], ["proof (prove)\nusing this:\n  inj (map_indets f)\n  ?A \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. inj_on (map_indets f) F'", "by (rule inj_on_subset)"], ["proof (state)\nthis:\n  inj_on (map_indets f) F'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "from \\<open>p \\<in> range _\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> range (map_indets f)", "obtain p' where \"p = map_indets f p'\""], ["proof (prove)\nusing this:\n  p \\<in> range (map_indets f)\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = map_indets f p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p = map_indets f p'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "hence \"p = map_indets f (map_indets g p)\""], ["proof (prove)\nusing this:\n  p = map_indets f p'\n\ngoal (1 subgoal):\n 1. p = map_indets f (map_indets g p)", "by (simp add: eq)"], ["proof (state)\nthis:\n  p = map_indets f (map_indets g p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "also"], ["proof (state)\nthis:\n  p = map_indets f (map_indets g p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "from \\<open>inj_on _ F'\\<close>"], ["proof (chain)\npicking this:\n  inj_on (map_indets f) F'", "have \"\\<dots> = map_indets f (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')\""], ["proof (prove)\nusing this:\n  inj_on (map_indets f) F'\n\ngoal (1 subgoal):\n 1. map_indets f (map_indets g p) =\n    map_indets f (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')", "by (simp add: p F0 sum.reindex map_indets_sum map_indets_times eq)"], ["proof (state)\nthis:\n  map_indets f (map_indets g p) =\n  map_indets f (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "finally"], ["proof (chain)\npicking this:\n  p =\n  map_indets f (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')", "have \"p = map_indets f (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')\""], ["proof (prove)\nusing this:\n  p =\n  map_indets f (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')\n\ngoal (1 subgoal):\n 1. p =\n    map_indets f (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')", "."], ["proof (state)\nthis:\n  p =\n  map_indets f (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "moreover"], ["proof (state)\nthis:\n  p =\n  map_indets f (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "have \"(\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f') \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f') \\<in> ideal F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f') \\<in> ?A\n 2. ?A \\<subseteq> ideal F", "show \"(\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f') \\<in> ideal F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')\n    \\<in> ideal F'", "by (rule ideal.sum_in_spanI)"], ["proof (state)\nthis:\n  (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f') \\<in> ideal F'\n\ngoal (1 subgoal):\n 1. ideal F' \\<subseteq> ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ideal F' \\<subseteq> ideal F", "from \\<open>F' \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  F' \\<subseteq> F", "show \"ideal F' \\<subseteq> ideal F\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. ideal F' \\<subseteq> ideal F", "by (rule ideal.span_mono)"], ["proof (state)\nthis:\n  ideal F' \\<subseteq> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f') \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` ideal F", "ultimately"], ["proof (chain)\npicking this:\n  p =\n  map_indets f (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')\n  (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f') \\<in> ideal F", "show \"p \\<in> map_indets f ` ideal F\""], ["proof (prove)\nusing this:\n  p =\n  map_indets f (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f')\n  (\\<Sum>f'\\<in>F'. map_indets g (q (map_indets f f')) * f') \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p \\<in> map_indets f ` ideal F", "by (rule image_eqI)"], ["proof (state)\nthis:\n  p \\<in> map_indets f ` ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal (map_indets f ` F) \\<inter> P[range f]\n  \\<subseteq> map_indets f ` ideal F\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Homogeneity\\<close>"], ["", "definition homogeneous :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero) \\<Rightarrow> bool\"\n  where \"homogeneous p \\<longleftrightarrow> (\\<forall>s\\<in>keys p. \\<forall>t\\<in>keys p. deg_pm s = deg_pm t)\""], ["", "definition hom_component :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> nat \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero)\"\n  where \"hom_component p n = except p {t. deg_pm t \\<noteq> n}\""], ["", "definition hom_components :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero) set\"\n  where \"hom_components p = hom_component p ` deg_pm ` keys p\""], ["", "definition homogeneous_set :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero) set \\<Rightarrow> bool\"\n  where \"homogeneous_set A \\<longleftrightarrow> (\\<forall>a\\<in>A. \\<forall>n. hom_component a n \\<in> A)\""], ["", "lemma homogeneousI: \"(\\<And>s t. s \\<in> keys p \\<Longrightarrow> t \\<in> keys p \\<Longrightarrow> deg_pm s = deg_pm t) \\<Longrightarrow> homogeneous p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys p\\<rbrakk>\n        \\<Longrightarrow> deg_pm s = deg_pm t) \\<Longrightarrow>\n    homogeneous p", "unfolding homogeneous_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t.\n        \\<lbrakk>s \\<in> keys p; t \\<in> keys p\\<rbrakk>\n        \\<Longrightarrow> deg_pm s = deg_pm t) \\<Longrightarrow>\n    \\<forall>s\\<in>keys p. \\<forall>t\\<in>keys p. deg_pm s = deg_pm t", "by blast"], ["", "lemma homogeneousD: \"homogeneous p \\<Longrightarrow> s \\<in> keys p \\<Longrightarrow> t \\<in> keys p \\<Longrightarrow> deg_pm s = deg_pm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>homogeneous p; s \\<in> keys p; t \\<in> keys p\\<rbrakk>\n    \\<Longrightarrow> deg_pm s = deg_pm t", "unfolding homogeneous_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s\\<in>keys p.\n                \\<forall>t\\<in>keys p. deg_pm s = deg_pm t;\n     s \\<in> keys p; t \\<in> keys p\\<rbrakk>\n    \\<Longrightarrow> deg_pm s = deg_pm t", "by blast"], ["", "lemma homogeneousD_poly_deg:\n  assumes \"homogeneous p\" and \"t \\<in> keys p\"\n  shows \"deg_pm t = poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_pm t \\<le> poly_deg p\n 2. poly_deg p \\<le> deg_pm t", "from assms(2)"], ["proof (chain)\npicking this:\n  t \\<in> keys p", "show \"deg_pm t \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> deg_pm t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg p \\<le> deg_pm t", "show \"poly_deg p \\<le> deg_pm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg p \\<le> deg_pm t", "proof (rule poly_deg_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ta. ta \\<in> keys p \\<Longrightarrow> deg_pm ta \\<le> deg_pm t", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ta. ta \\<in> keys p \\<Longrightarrow> deg_pm ta \\<le> deg_pm t", "assume \"s \\<in> keys p\""], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>ta. ta \\<in> keys p \\<Longrightarrow> deg_pm ta \\<le> deg_pm t", "with assms(1)"], ["proof (chain)\npicking this:\n  homogeneous p\n  s \\<in> keys p", "have \"deg_pm s = deg_pm t\""], ["proof (prove)\nusing this:\n  homogeneous p\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm s = deg_pm t", "using assms(2)"], ["proof (prove)\nusing this:\n  homogeneous p\n  s \\<in> keys p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm s = deg_pm t", "by (rule homogeneousD)"], ["proof (state)\nthis:\n  deg_pm s = deg_pm t\n\ngoal (1 subgoal):\n 1. \\<And>ta. ta \\<in> keys p \\<Longrightarrow> deg_pm ta \\<le> deg_pm t", "thus \"deg_pm s \\<le> deg_pm t\""], ["proof (prove)\nusing this:\n  deg_pm s = deg_pm t\n\ngoal (1 subgoal):\n 1. deg_pm s \\<le> deg_pm t", "by simp"], ["proof (state)\nthis:\n  deg_pm s \\<le> deg_pm t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg p \\<le> deg_pm t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogeneous_monomial [simp]: \"homogeneous (monomial c t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous (monomial c t)", "by (auto split: if_split_asm intro: homogeneousI)"], ["", "corollary homogeneous_zero [simp]: \"homogeneous 0\" and homogeneous_one [simp]: \"homogeneous 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous 0 &&& homogeneous 1", "by (simp_all only: homogeneous_monomial flip: single_zero[of 0] single_one)"], ["", "lemma homogeneous_uminus_iff [simp]: \"homogeneous (- p) \\<longleftrightarrow> homogeneous p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous (- p) = homogeneous p", "by (auto intro!: homogeneousI dest: homogeneousD simp: keys_uminus)"], ["", "lemma homogeneous_monom_mult: \"homogeneous p \\<Longrightarrow> homogeneous (punit.monom_mult c t p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous p \\<Longrightarrow> homogeneous (punit.monom_mult c t p)", "by (auto intro!: homogeneousI elim!: punit.keys_monom_multE simp: deg_pm_plus dest: homogeneousD)"], ["", "lemma homogeneous_monom_mult_rev:\n  assumes \"c \\<noteq> (0::'a::semiring_no_zero_divisors)\" and \"homogeneous (punit.monom_mult c t p)\"\n  shows \"homogeneous p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous p", "proof (rule homogeneousI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys p; t \\<in> keys p\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys p; t \\<in> keys p\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "assume \"s \\<in> keys p\""], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys p; t \\<in> keys p\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "hence 1: \"t + s \\<in> keys (punit.monom_mult c t p)\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. t + s \\<in> keys (punit.monom_mult c t p)", "using assms(1)"], ["proof (prove)\nusing this:\n  s \\<in> keys p\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. t + s \\<in> keys (punit.monom_mult c t p)", "by (rule punit.keys_monom_multI[simplified])"], ["proof (state)\nthis:\n  t + s \\<in> keys (punit.monom_mult c t p)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys p; t \\<in> keys p\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "assume \"s' \\<in> keys p\""], ["proof (state)\nthis:\n  s' \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys p; t \\<in> keys p\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "hence \"t + s' \\<in> keys (punit.monom_mult c t p)\""], ["proof (prove)\nusing this:\n  s' \\<in> keys p\n\ngoal (1 subgoal):\n 1. t + s' \\<in> keys (punit.monom_mult c t p)", "using assms(1)"], ["proof (prove)\nusing this:\n  s' \\<in> keys p\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. t + s' \\<in> keys (punit.monom_mult c t p)", "by (rule punit.keys_monom_multI[simplified])"], ["proof (state)\nthis:\n  t + s' \\<in> keys (punit.monom_mult c t p)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys p; t \\<in> keys p\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "with assms(2) 1"], ["proof (chain)\npicking this:\n  homogeneous (punit.monom_mult c t p)\n  t + s \\<in> keys (punit.monom_mult c t p)\n  t + s' \\<in> keys (punit.monom_mult c t p)", "have \"deg_pm (t + s) = deg_pm (t + s')\""], ["proof (prove)\nusing this:\n  homogeneous (punit.monom_mult c t p)\n  t + s \\<in> keys (punit.monom_mult c t p)\n  t + s' \\<in> keys (punit.monom_mult c t p)\n\ngoal (1 subgoal):\n 1. deg_pm (t + s) = deg_pm (t + s')", "by (rule homogeneousD)"], ["proof (state)\nthis:\n  deg_pm (t + s) = deg_pm (t + s')\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys p; t \\<in> keys p\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "thus \"deg_pm s = deg_pm s'\""], ["proof (prove)\nusing this:\n  deg_pm (t + s) = deg_pm (t + s')\n\ngoal (1 subgoal):\n 1. deg_pm s = deg_pm s'", "by (simp add: deg_pm_plus)"], ["proof (state)\nthis:\n  deg_pm s = deg_pm s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogeneous_times:\n  assumes \"homogeneous p\" and \"homogeneous q\"\n  shows \"homogeneous (p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous (p * q)", "proof (rule homogeneousI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (p * q); t \\<in> keys (p * q)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (p * q); t \\<in> keys (p * q)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "assume \"s \\<in> keys (p * q)\""], ["proof (state)\nthis:\n  s \\<in> keys (p * q)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (p * q); t \\<in> keys (p * q)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "then"], ["proof (chain)\npicking this:\n  s \\<in> keys (p * q)", "obtain sp sq where sp: \"sp \\<in> keys p\" and sq: \"sq \\<in> keys q\" and s: \"s = sp + sq\""], ["proof (prove)\nusing this:\n  s \\<in> keys (p * q)\n\ngoal (1 subgoal):\n 1. (\\<And>sp sq.\n        \\<lbrakk>sp \\<in> keys p; sq \\<in> keys q; s = sp + sq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_timesE)"], ["proof (state)\nthis:\n  sp \\<in> keys p\n  sq \\<in> keys q\n  s = sp + sq\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (p * q); t \\<in> keys (p * q)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "assume \"t \\<in> keys (p * q)\""], ["proof (state)\nthis:\n  t \\<in> keys (p * q)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (p * q); t \\<in> keys (p * q)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "then"], ["proof (chain)\npicking this:\n  t \\<in> keys (p * q)", "obtain tp tq where tp: \"tp \\<in> keys p\" and tq: \"tq \\<in> keys q\" and t: \"t = tp + tq\""], ["proof (prove)\nusing this:\n  t \\<in> keys (p * q)\n\ngoal (1 subgoal):\n 1. (\\<And>tp tq.\n        \\<lbrakk>tp \\<in> keys p; tq \\<in> keys q; t = tp + tq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_timesE)"], ["proof (state)\nthis:\n  tp \\<in> keys p\n  tq \\<in> keys q\n  t = tp + tq\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (p * q); t \\<in> keys (p * q)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "from assms(1) sp tp"], ["proof (chain)\npicking this:\n  homogeneous p\n  sp \\<in> keys p\n  tp \\<in> keys p", "have \"deg_pm sp = deg_pm tp\""], ["proof (prove)\nusing this:\n  homogeneous p\n  sp \\<in> keys p\n  tp \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm sp = deg_pm tp", "by (rule homogeneousD)"], ["proof (state)\nthis:\n  deg_pm sp = deg_pm tp\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (p * q); t \\<in> keys (p * q)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "moreover"], ["proof (state)\nthis:\n  deg_pm sp = deg_pm tp\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (p * q); t \\<in> keys (p * q)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "from assms(2) sq tq"], ["proof (chain)\npicking this:\n  homogeneous q\n  sq \\<in> keys q\n  tq \\<in> keys q", "have \"deg_pm sq = deg_pm tq\""], ["proof (prove)\nusing this:\n  homogeneous q\n  sq \\<in> keys q\n  tq \\<in> keys q\n\ngoal (1 subgoal):\n 1. deg_pm sq = deg_pm tq", "by (rule homogeneousD)"], ["proof (state)\nthis:\n  deg_pm sq = deg_pm tq\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (p * q); t \\<in> keys (p * q)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm sp = deg_pm tp\n  deg_pm sq = deg_pm tq", "show \"deg_pm s = deg_pm t\""], ["proof (prove)\nusing this:\n  deg_pm sp = deg_pm tp\n  deg_pm sq = deg_pm tq\n\ngoal (1 subgoal):\n 1. deg_pm s = deg_pm t", "by (simp only: s t deg_pm_plus)"], ["proof (state)\nthis:\n  deg_pm s = deg_pm t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_hom_component: \"lookup (hom_component p n) = (\\<lambda>t. lookup p t when deg_pm t = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (hom_component p n) = (\\<lambda>t. lookup p t when deg_pm t = n)", "by (rule ext) (simp add: hom_component_def lookup_except)"], ["", "lemma keys_hom_component: \"keys (hom_component p n) = {t. t \\<in> keys p \\<and> deg_pm t = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (hom_component p n) = {t \\<in> keys p. deg_pm t = n}", "by (auto simp: hom_component_def keys_except)"], ["", "lemma keys_hom_componentD:\n  assumes \"t \\<in> keys (hom_component p n)\"\n  shows \"t \\<in> keys p\" and \"deg_pm t = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> keys p &&& deg_pm t = n", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> keys (hom_component p n)\n\ngoal (1 subgoal):\n 1. t \\<in> keys p &&& deg_pm t = n", "by (simp_all add: keys_hom_component)"], ["", "lemma homogeneous_hom_component: \"homogeneous (hom_component p n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous (hom_component p n)", "by (auto dest: keys_hom_componentD intro: homogeneousI)"], ["", "lemma hom_component_zero [simp]: \"hom_component 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component 0 = 0", "by (rule ext) (simp add: hom_component_def)"], ["", "lemma hom_component_zero_iff: \"hom_component p n = 0 \\<longleftrightarrow> (\\<forall>t\\<in>keys p. deg_pm t \\<noteq> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hom_component p n = 0) = (\\<forall>t\\<in>keys p. deg_pm t \\<noteq> n)", "by (metis (mono_tags, lifting) empty_iff keys_eq_empty_iff keys_hom_component mem_Collect_eq subsetI subset_antisym)"], ["", "lemma hom_component_uminus [simp]: \"hom_component (- p) = - hom_component p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component (- p) = - hom_component p", "by (intro ext poly_mapping_eqI) (simp add: hom_component_def lookup_except)"], ["", "lemma hom_component_plus: \"hom_component (p + q) n = hom_component p n + hom_component q n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component (p + q) n = hom_component p n + hom_component q n", "by (rule poly_mapping_eqI) (simp add: hom_component_def lookup_except lookup_add)"], ["", "lemma hom_component_minus: \"hom_component (p - q) n = hom_component p n - hom_component q n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component (p - q) n = hom_component p n - hom_component q n", "by (rule poly_mapping_eqI) (simp add: hom_component_def lookup_except lookup_minus)"], ["", "lemma hom_component_monom_mult:\n  \"punit.monom_mult c t (hom_component p n) = hom_component (punit.monom_mult c t p) (deg_pm t + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult c t (hom_component p n) =\n    hom_component (punit.monom_mult c t p) (deg_pm t + n)", "by (auto simp: hom_component_def lookup_except punit.lookup_monom_mult deg_pm_minus deg_pm_mono intro!: poly_mapping_eqI)"], ["", "lemma hom_component_inject:\n  assumes \"t \\<in> keys p\" and \"hom_component p (deg_pm t) = hom_component p n\"\n  shows \"deg_pm t = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm t = n", "from assms(1)"], ["proof (chain)\npicking this:\n  t \\<in> keys p", "have \"t \\<in> keys (hom_component p (deg_pm t))\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. t \\<in> keys (hom_component p (deg_pm t))", "by (simp add: keys_hom_component)"], ["proof (state)\nthis:\n  t \\<in> keys (hom_component p (deg_pm t))\n\ngoal (1 subgoal):\n 1. deg_pm t = n", "hence \"0 \\<noteq> lookup (hom_component p (deg_pm t)) t\""], ["proof (prove)\nusing this:\n  t \\<in> keys (hom_component p (deg_pm t))\n\ngoal (1 subgoal):\n 1. (0::'b) \\<noteq> lookup (hom_component p (deg_pm t)) t", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (0::'b) \\<noteq> lookup (hom_component p (deg_pm t)) t\n\ngoal (1 subgoal):\n 1. deg_pm t = n", "also"], ["proof (state)\nthis:\n  (0::'b) \\<noteq> lookup (hom_component p (deg_pm t)) t\n\ngoal (1 subgoal):\n 1. deg_pm t = n", "have \"lookup (hom_component p (deg_pm t)) t = lookup (hom_component p n) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (hom_component p (deg_pm t)) t = lookup (hom_component p n) t", "by (simp only: assms(2))"], ["proof (state)\nthis:\n  lookup (hom_component p (deg_pm t)) t = lookup (hom_component p n) t\n\ngoal (1 subgoal):\n 1. deg_pm t = n", "also"], ["proof (state)\nthis:\n  lookup (hom_component p (deg_pm t)) t = lookup (hom_component p n) t\n\ngoal (1 subgoal):\n 1. deg_pm t = n", "have \"\\<dots> = (lookup p t when deg_pm t = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (hom_component p n) t = (lookup p t when deg_pm t = n)", "by (simp only: lookup_hom_component)"], ["proof (state)\nthis:\n  lookup (hom_component p n) t = (lookup p t when deg_pm t = n)\n\ngoal (1 subgoal):\n 1. deg_pm t = n", "finally"], ["proof (chain)\npicking this:\n  (0::'b) \\<noteq> (lookup p t when deg_pm t = n)", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'b) \\<noteq> (lookup p t when deg_pm t = n)\n\ngoal (1 subgoal):\n 1. deg_pm t = n", "by simp"], ["proof (state)\nthis:\n  deg_pm t = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_component_of_homogeneous:\n  assumes \"homogeneous p\"\n  shows \"hom_component p n = (p when n = poly_deg p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component p n = (p when n = poly_deg p)", "proof (cases \"n = poly_deg p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = poly_deg p \\<Longrightarrow>\n    hom_component p n = (p when n = poly_deg p)\n 2. n \\<noteq> poly_deg p \\<Longrightarrow>\n    hom_component p n = (p when n = poly_deg p)", "case True"], ["proof (state)\nthis:\n  n = poly_deg p\n\ngoal (2 subgoals):\n 1. n = poly_deg p \\<Longrightarrow>\n    hom_component p n = (p when n = poly_deg p)\n 2. n \\<noteq> poly_deg p \\<Longrightarrow>\n    hom_component p n = (p when n = poly_deg p)", "have \"hom_component p n = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component p n = p", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (hom_component p n) k = lookup p k", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (hom_component p n) k = lookup p k", "show \"lookup (hom_component p n) t = lookup p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (hom_component p n) t = lookup p t", "proof (cases \"t \\<in> keys p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    lookup (hom_component p n) t = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    lookup (hom_component p n) t = lookup p t", "case True"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    lookup (hom_component p n) t = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    lookup (hom_component p n) t = lookup p t", "with assms"], ["proof (chain)\npicking this:\n  homogeneous p\n  t \\<in> keys p", "have \"deg_pm t = n\""], ["proof (prove)\nusing this:\n  homogeneous p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t = n", "unfolding \\<open>n = poly_deg p\\<close>"], ["proof (prove)\nusing this:\n  homogeneous p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t = n\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    lookup (hom_component p n) t = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    lookup (hom_component p n) t = lookup p t", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t = n\n\ngoal (1 subgoal):\n 1. lookup (hom_component p n) t = lookup p t", "by (simp add: lookup_hom_component)"], ["proof (state)\nthis:\n  lookup (hom_component p n) t = lookup p t\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (hom_component p n) t = lookup p t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (hom_component p n) t = lookup p t", "case False"], ["proof (state)\nthis:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (hom_component p n) t = lookup p t", "moreover"], ["proof (state)\nthis:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (hom_component p n) t = lookup p t", "from this"], ["proof (chain)\npicking this:\n  t \\<notin> keys p", "have \"t \\<notin> keys (hom_component p n)\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> keys (hom_component p n)", "by (simp add: keys_hom_component)"], ["proof (state)\nthis:\n  t \\<notin> keys (hom_component p n)\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (hom_component p n) t = lookup p t", "ultimately"], ["proof (chain)\npicking this:\n  t \\<notin> keys p\n  t \\<notin> keys (hom_component p n)", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n  t \\<notin> keys (hom_component p n)\n\ngoal (1 subgoal):\n 1. lookup (hom_component p n) t = lookup p t", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup (hom_component p n) t = lookup p t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (hom_component p n) t = lookup p t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hom_component p n = p\n\ngoal (2 subgoals):\n 1. n = poly_deg p \\<Longrightarrow>\n    hom_component p n = (p when n = poly_deg p)\n 2. n \\<noteq> poly_deg p \\<Longrightarrow>\n    hom_component p n = (p when n = poly_deg p)", "with True"], ["proof (chain)\npicking this:\n  n = poly_deg p\n  hom_component p n = p", "show ?thesis"], ["proof (prove)\nusing this:\n  n = poly_deg p\n  hom_component p n = p\n\ngoal (1 subgoal):\n 1. hom_component p n = (p when n = poly_deg p)", "by simp"], ["proof (state)\nthis:\n  hom_component p n = (p when n = poly_deg p)\n\ngoal (1 subgoal):\n 1. n \\<noteq> poly_deg p \\<Longrightarrow>\n    hom_component p n = (p when n = poly_deg p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> poly_deg p \\<Longrightarrow>\n    hom_component p n = (p when n = poly_deg p)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> poly_deg p\n\ngoal (1 subgoal):\n 1. n \\<noteq> poly_deg p \\<Longrightarrow>\n    hom_component p n = (p when n = poly_deg p)", "have \"hom_component p n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component p n = 0", "unfolding hom_component_zero_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>keys p. deg_pm t \\<noteq> n", "proof (intro ballI notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> keys p; deg_pm t = n\\<rbrakk>\n       \\<Longrightarrow> False", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> keys p; deg_pm t = n\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> keys p; deg_pm t = n\\<rbrakk>\n       \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  homogeneous p\n  t \\<in> keys p", "have \"deg_pm t = poly_deg p\""], ["proof (prove)\nusing this:\n  homogeneous p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> keys p; deg_pm t = n\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> keys p; deg_pm t = n\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"deg_pm t = n\""], ["proof (state)\nthis:\n  deg_pm t = n\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> keys p; deg_pm t = n\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm t = poly_deg p\n  deg_pm t = n", "show False"], ["proof (prove)\nusing this:\n  deg_pm t = poly_deg p\n  deg_pm t = n\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  deg_pm t = poly_deg p\n  deg_pm t = n\n  n \\<noteq> poly_deg p\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hom_component p n = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> poly_deg p \\<Longrightarrow>\n    hom_component p n = (p when n = poly_deg p)", "with False"], ["proof (chain)\npicking this:\n  n \\<noteq> poly_deg p\n  hom_component p n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<noteq> poly_deg p\n  hom_component p n = 0\n\ngoal (1 subgoal):\n 1. hom_component p n = (p when n = poly_deg p)", "by simp"], ["proof (state)\nthis:\n  hom_component p n = (p when n = poly_deg p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_components_zero [simp]: \"hom_components 0 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_components 0 = {}", "by (simp add: hom_components_def)"], ["", "lemma hom_components_zero_iff [simp]: \"hom_components p = {} \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hom_components p = {}) = (p = 0)", "by (simp add: hom_components_def)"], ["", "lemma hom_components_uminus: \"hom_components (- p) = uminus ` hom_components p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_components (- p) = uminus ` hom_components p", "by (simp add: hom_components_def keys_uminus image_image)"], ["", "lemma hom_components_monom_mult:\n  \"hom_components (punit.monom_mult c t p) = (if c = 0 then {} else punit.monom_mult c t ` hom_components p)\"\n  for c::\"'a::semiring_no_zero_divisors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_components (punit.monom_mult c t p) =\n    (if c = (0::'a) then {} else punit.monom_mult c t ` hom_components p)", "by (simp add: hom_components_def punit.keys_monom_mult image_image deg_pm_plus hom_component_monom_mult)"], ["", "lemma hom_componentsI: \"q = hom_component p (deg_pm t) \\<Longrightarrow> t \\<in> keys p \\<Longrightarrow> q \\<in> hom_components p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q = hom_component p (deg_pm t); t \\<in> keys p\\<rbrakk>\n    \\<Longrightarrow> q \\<in> hom_components p", "unfolding hom_components_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q = hom_component p (deg_pm t); t \\<in> keys p\\<rbrakk>\n    \\<Longrightarrow> q \\<in> hom_component p ` deg_pm ` keys p", "by blast"], ["", "lemma hom_componentsE:\n  assumes \"q \\<in> hom_components p\"\n  obtains t where \"t \\<in> keys p\" and \"q = hom_component p (deg_pm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; q = hom_component p (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; q = hom_component p (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding hom_components_def"], ["proof (prove)\nusing this:\n  q \\<in> hom_component p ` deg_pm ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; q = hom_component p (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma hom_components_of_homogeneous:\n  assumes \"homogeneous p\"\n  shows \"hom_components p = (if p = 0 then {} else {p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_components p = (if p = 0 then {} else {p})", "proof (split if_split, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> hom_components p = {}\n 2. p \\<noteq> 0 \\<Longrightarrow> hom_components p = {p}", "assume \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> hom_components p = {}\n 2. p \\<noteq> 0 \\<Longrightarrow> hom_components p = {p}", "have \"deg_pm ` keys p = {poly_deg p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm ` keys p = {poly_deg p}", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> deg_pm ` keys p) = (x \\<in> {poly_deg p})", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> deg_pm ` keys p) = (x \\<in> {poly_deg p})", "have \"n \\<in> deg_pm ` keys p \\<longleftrightarrow> n = poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n \\<in> deg_pm ` keys p) = (n = poly_deg p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<in> deg_pm ` keys p \\<Longrightarrow> n = poly_deg p\n 2. n = poly_deg p \\<Longrightarrow> n \\<in> deg_pm ` keys p", "assume \"n \\<in> deg_pm ` keys p\""], ["proof (state)\nthis:\n  n \\<in> deg_pm ` keys p\n\ngoal (2 subgoals):\n 1. n \\<in> deg_pm ` keys p \\<Longrightarrow> n = poly_deg p\n 2. n = poly_deg p \\<Longrightarrow> n \\<in> deg_pm ` keys p", "then"], ["proof (chain)\npicking this:\n  n \\<in> deg_pm ` keys p", "obtain t where \"t \\<in> keys p\" and \"n = deg_pm t\""], ["proof (prove)\nusing this:\n  n \\<in> deg_pm ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; n = deg_pm t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t \\<in> keys p\n  n = deg_pm t\n\ngoal (2 subgoals):\n 1. n \\<in> deg_pm ` keys p \\<Longrightarrow> n = poly_deg p\n 2. n = poly_deg p \\<Longrightarrow> n \\<in> deg_pm ` keys p", "from assms this(1)"], ["proof (chain)\npicking this:\n  homogeneous p\n  t \\<in> keys p", "have \"deg_pm t = poly_deg p\""], ["proof (prove)\nusing this:\n  homogeneous p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (2 subgoals):\n 1. n \\<in> deg_pm ` keys p \\<Longrightarrow> n = poly_deg p\n 2. n = poly_deg p \\<Longrightarrow> n \\<in> deg_pm ` keys p", "thus \"n = poly_deg p\""], ["proof (prove)\nusing this:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. n = poly_deg p", "by (simp only: \\<open>n = deg_pm t\\<close>)"], ["proof (state)\nthis:\n  n = poly_deg p\n\ngoal (1 subgoal):\n 1. n = poly_deg p \\<Longrightarrow> n \\<in> deg_pm ` keys p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = poly_deg p \\<Longrightarrow> n \\<in> deg_pm ` keys p", "assume \"n = poly_deg p\""], ["proof (state)\nthis:\n  n = poly_deg p\n\ngoal (1 subgoal):\n 1. n = poly_deg p \\<Longrightarrow> n \\<in> deg_pm ` keys p", "from \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"keys p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys p \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. n = poly_deg p \\<Longrightarrow> n \\<in> deg_pm ` keys p", "then"], ["proof (chain)\npicking this:\n  keys p \\<noteq> {}", "obtain t where \"t \\<in> keys p\""], ["proof (prove)\nusing this:\n  keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t. t \\<in> keys p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. n = poly_deg p \\<Longrightarrow> n \\<in> deg_pm ` keys p", "with assms"], ["proof (chain)\npicking this:\n  homogeneous p\n  t \\<in> keys p", "have \"deg_pm t = poly_deg p\""], ["proof (prove)\nusing this:\n  homogeneous p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. n = poly_deg p \\<Longrightarrow> n \\<in> deg_pm ` keys p", "hence \"n = deg_pm t\""], ["proof (prove)\nusing this:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. n = deg_pm t", "by (simp only: \\<open>n = poly_deg p\\<close>)"], ["proof (state)\nthis:\n  n = deg_pm t\n\ngoal (1 subgoal):\n 1. n = poly_deg p \\<Longrightarrow> n \\<in> deg_pm ` keys p", "with \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys p\n  n = deg_pm t", "show \"n \\<in> deg_pm ` keys p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  n = deg_pm t\n\ngoal (1 subgoal):\n 1. n \\<in> deg_pm ` keys p", "by (rule rev_image_eqI)"], ["proof (state)\nthis:\n  n \\<in> deg_pm ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (n \\<in> deg_pm ` keys p) = (n = poly_deg p)\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> deg_pm ` keys p) = (x \\<in> {poly_deg p})", "thus \"n \\<in> deg_pm ` keys p \\<longleftrightarrow> n \\<in> {poly_deg p}\""], ["proof (prove)\nusing this:\n  (n \\<in> deg_pm ` keys p) = (n = poly_deg p)\n\ngoal (1 subgoal):\n 1. (n \\<in> deg_pm ` keys p) = (n \\<in> {poly_deg p})", "by simp"], ["proof (state)\nthis:\n  (n \\<in> deg_pm ` keys p) = (n \\<in> {poly_deg p})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pm ` keys p = {poly_deg p}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> hom_components p = {}\n 2. p \\<noteq> 0 \\<Longrightarrow> hom_components p = {p}", "with assms"], ["proof (chain)\npicking this:\n  homogeneous p\n  deg_pm ` keys p = {poly_deg p}", "show \"hom_components p = {p}\""], ["proof (prove)\nusing this:\n  homogeneous p\n  deg_pm ` keys p = {poly_deg p}\n\ngoal (1 subgoal):\n 1. hom_components p = {p}", "by (simp add: hom_components_def hom_component_of_homogeneous)"], ["proof (state)\nthis:\n  hom_components p = {p}\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> hom_components p = {}", "qed simp"], ["", "lemma finite_hom_components: \"finite (hom_components p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (hom_components p)", "unfolding hom_components_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (hom_component p ` deg_pm ` keys p)", "using finite_keys"], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. finite (hom_component p ` deg_pm ` keys p)", "by (intro finite_imageI)"], ["", "lemma hom_components_homogeneous: \"q \\<in> hom_components p \\<Longrightarrow> homogeneous q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> hom_components p \\<Longrightarrow> homogeneous q", "by (elim hom_componentsE) (simp only: homogeneous_hom_component)"], ["", "lemma hom_components_nonzero: \"q \\<in> hom_components p \\<Longrightarrow> q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> hom_components p \\<Longrightarrow> q \\<noteq> 0", "by (auto elim!: hom_componentsE simp: hom_component_zero_iff)"], ["", "lemma deg_pm_hom_components:\n  assumes \"q1 \\<in> hom_components p\" and \"q2 \\<in> hom_components p\" and \"t1 \\<in> keys q1\" and \"t2 \\<in> keys q2\"\n  shows \"deg_pm t1 = deg_pm t2 \\<longleftrightarrow> q1 = q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (deg_pm t1 = deg_pm t2) = (q1 = q2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (deg_pm t1 = deg_pm t2) = (q1 = q2)", "from assms(1)"], ["proof (chain)\npicking this:\n  q1 \\<in> hom_components p", "obtain s1 where \"s1 \\<in> keys p\" and q1: \"q1 = hom_component p (deg_pm s1)\""], ["proof (prove)\nusing this:\n  q1 \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        \\<lbrakk>s1 \\<in> keys p; q1 = hom_component p (deg_pm s1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule hom_componentsE)"], ["proof (state)\nthis:\n  s1 \\<in> keys p\n  q1 = hom_component p (deg_pm s1)\n\ngoal (1 subgoal):\n 1. (deg_pm t1 = deg_pm t2) = (q1 = q2)", "from assms(3)"], ["proof (chain)\npicking this:\n  t1 \\<in> keys q1", "have t1: \"deg_pm t1 = deg_pm s1\""], ["proof (prove)\nusing this:\n  t1 \\<in> keys q1\n\ngoal (1 subgoal):\n 1. deg_pm t1 = deg_pm s1", "unfolding q1"], ["proof (prove)\nusing this:\n  t1 \\<in> keys (hom_component p (deg_pm s1))\n\ngoal (1 subgoal):\n 1. deg_pm t1 = deg_pm s1", "by (rule keys_hom_componentD)"], ["proof (state)\nthis:\n  deg_pm t1 = deg_pm s1\n\ngoal (1 subgoal):\n 1. (deg_pm t1 = deg_pm t2) = (q1 = q2)", "from assms(2)"], ["proof (chain)\npicking this:\n  q2 \\<in> hom_components p", "obtain s2 where \"s2 \\<in> keys p\" and q2: \"q2 = hom_component p (deg_pm s2)\""], ["proof (prove)\nusing this:\n  q2 \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>s2 \\<in> keys p; q2 = hom_component p (deg_pm s2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule hom_componentsE)"], ["proof (state)\nthis:\n  s2 \\<in> keys p\n  q2 = hom_component p (deg_pm s2)\n\ngoal (1 subgoal):\n 1. (deg_pm t1 = deg_pm t2) = (q1 = q2)", "from assms(4)"], ["proof (chain)\npicking this:\n  t2 \\<in> keys q2", "have t2: \"deg_pm t2 = deg_pm s2\""], ["proof (prove)\nusing this:\n  t2 \\<in> keys q2\n\ngoal (1 subgoal):\n 1. deg_pm t2 = deg_pm s2", "unfolding q2"], ["proof (prove)\nusing this:\n  t2 \\<in> keys (hom_component p (deg_pm s2))\n\ngoal (1 subgoal):\n 1. deg_pm t2 = deg_pm s2", "by (rule keys_hom_componentD)"], ["proof (state)\nthis:\n  deg_pm t2 = deg_pm s2\n\ngoal (1 subgoal):\n 1. (deg_pm t1 = deg_pm t2) = (q1 = q2)", "from \\<open>s1 \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s1 \\<in> keys p", "show ?thesis"], ["proof (prove)\nusing this:\n  s1 \\<in> keys p\n\ngoal (1 subgoal):\n 1. (deg_pm t1 = deg_pm t2) = (q1 = q2)", "by (auto simp: q1 q2 t1 t2 dest: hom_component_inject)"], ["proof (state)\nthis:\n  (deg_pm t1 = deg_pm t2) = (q1 = q2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_hom_components:\n  assumes \"q1 \\<in> hom_components p\" and \"q2 \\<in> hom_components p\"\n  shows \"poly_deg q1 = poly_deg q2 \\<longleftrightarrow> q1 = q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "from assms(1)"], ["proof (chain)\npicking this:\n  q1 \\<in> hom_components p", "have \"homogeneous q1\" and \"q1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q1 \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. homogeneous q1 &&& q1 \\<noteq> 0", "by (rule hom_components_homogeneous, rule hom_components_nonzero)"], ["proof (state)\nthis:\n  homogeneous q1\n  q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "from this(2)"], ["proof (chain)\npicking this:\n  q1 \\<noteq> 0", "have \"keys q1 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys q1 \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys q1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "then"], ["proof (chain)\npicking this:\n  keys q1 \\<noteq> {}", "obtain t1 where \"t1 \\<in> keys q1\""], ["proof (prove)\nusing this:\n  keys q1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t1. t1 \\<in> keys q1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t1 \\<in> keys q1\n\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "with \\<open>homogeneous q1\\<close>"], ["proof (chain)\npicking this:\n  homogeneous q1\n  t1 \\<in> keys q1", "have t1: \"deg_pm t1 = poly_deg q1\""], ["proof (prove)\nusing this:\n  homogeneous q1\n  t1 \\<in> keys q1\n\ngoal (1 subgoal):\n 1. deg_pm t1 = poly_deg q1", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t1 = poly_deg q1\n\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "from assms(2)"], ["proof (chain)\npicking this:\n  q2 \\<in> hom_components p", "have \"homogeneous q2\" and \"q2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q2 \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. homogeneous q2 &&& q2 \\<noteq> 0", "by (rule hom_components_homogeneous, rule hom_components_nonzero)"], ["proof (state)\nthis:\n  homogeneous q2\n  q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "from this(2)"], ["proof (chain)\npicking this:\n  q2 \\<noteq> 0", "have \"keys q2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys q2 \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys q2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "then"], ["proof (chain)\npicking this:\n  keys q2 \\<noteq> {}", "obtain t2 where \"t2 \\<in> keys q2\""], ["proof (prove)\nusing this:\n  keys q2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t2. t2 \\<in> keys q2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t2 \\<in> keys q2\n\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "with \\<open>homogeneous q2\\<close>"], ["proof (chain)\npicking this:\n  homogeneous q2\n  t2 \\<in> keys q2", "have t2: \"deg_pm t2 = poly_deg q2\""], ["proof (prove)\nusing this:\n  homogeneous q2\n  t2 \\<in> keys q2\n\ngoal (1 subgoal):\n 1. deg_pm t2 = poly_deg q2", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t2 = poly_deg q2\n\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "from assms \\<open>t1 \\<in> keys q1\\<close> \\<open>t2 \\<in> keys q2\\<close>"], ["proof (chain)\npicking this:\n  q1 \\<in> hom_components p\n  q2 \\<in> hom_components p\n  t1 \\<in> keys q1\n  t2 \\<in> keys q2", "have \"deg_pm t1 = deg_pm t2 \\<longleftrightarrow> q1 = q2\""], ["proof (prove)\nusing this:\n  q1 \\<in> hom_components p\n  q2 \\<in> hom_components p\n  t1 \\<in> keys q1\n  t2 \\<in> keys q2\n\ngoal (1 subgoal):\n 1. (deg_pm t1 = deg_pm t2) = (q1 = q2)", "by (rule deg_pm_hom_components)"], ["proof (state)\nthis:\n  (deg_pm t1 = deg_pm t2) = (q1 = q2)\n\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (deg_pm t1 = deg_pm t2) = (q1 = q2)\n\ngoal (1 subgoal):\n 1. (poly_deg q1 = poly_deg q2) = (q1 = q2)", "by (simp only: t1 t2)"], ["proof (state)\nthis:\n  (poly_deg q1 = poly_deg q2) = (q1 = q2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_components_keys_disjoint:\n  assumes \"q1 \\<in> hom_components p\" and \"q2 \\<in> hom_components p\" and \"q1 \\<noteq> q2\"\n  shows \"keys q1 \\<inter> keys q2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys q1 \\<inter> keys q2 = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. keys q1 \\<inter> keys q2 \\<noteq> {} \\<Longrightarrow> False", "assume \"keys q1 \\<inter> keys q2 \\<noteq> {}\""], ["proof (state)\nthis:\n  keys q1 \\<inter> keys q2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. keys q1 \\<inter> keys q2 \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  keys q1 \\<inter> keys q2 \\<noteq> {}", "obtain t where \"t \\<in> keys q1\" and \"t \\<in> keys q2\""], ["proof (prove)\nusing this:\n  keys q1 \\<inter> keys q2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys q1; t \\<in> keys q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> keys q1\n  t \\<in> keys q2\n\ngoal (1 subgoal):\n 1. keys q1 \\<inter> keys q2 \\<noteq> {} \\<Longrightarrow> False", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  q1 \\<in> hom_components p\n  q2 \\<in> hom_components p\n  t \\<in> keys q1\n  t \\<in> keys q2", "have \"deg_pm t = deg_pm t \\<longleftrightarrow> q1 = q2\""], ["proof (prove)\nusing this:\n  q1 \\<in> hom_components p\n  q2 \\<in> hom_components p\n  t \\<in> keys q1\n  t \\<in> keys q2\n\ngoal (1 subgoal):\n 1. (deg_pm t = deg_pm t) = (q1 = q2)", "by (rule deg_pm_hom_components)"], ["proof (state)\nthis:\n  (deg_pm t = deg_pm t) = (q1 = q2)\n\ngoal (1 subgoal):\n 1. keys q1 \\<inter> keys q2 \\<noteq> {} \\<Longrightarrow> False", "with assms(3)"], ["proof (chain)\npicking this:\n  q1 \\<noteq> q2\n  (deg_pm t = deg_pm t) = (q1 = q2)", "show False"], ["proof (prove)\nusing this:\n  q1 \\<noteq> q2\n  (deg_pm t = deg_pm t) = (q1 = q2)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Keys_hom_components: \"Keys (hom_components p) = keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (hom_components p) = keys p", "by (auto simp: Keys_def hom_components_def keys_hom_component)"], ["", "lemma lookup_hom_components: \"q \\<in> hom_components p \\<Longrightarrow> t \\<in> keys q \\<Longrightarrow> lookup q t = lookup p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> hom_components p; t \\<in> keys q\\<rbrakk>\n    \\<Longrightarrow> lookup q t = lookup p t", "by (auto elim!: hom_componentsE simp: keys_hom_component lookup_hom_component)"], ["", "lemma poly_deg_hom_components_le:\n  assumes \"q \\<in> hom_components p\"\n  shows \"poly_deg q \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg q \\<le> poly_deg p", "proof (rule poly_deg_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> keys q \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> keys q \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "assume \"t \\<in> keys q\""], ["proof (state)\nthis:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> keys q \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "also"], ["proof (state)\nthis:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> keys q \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "from assms"], ["proof (chain)\npicking this:\n  q \\<in> hom_components p", "have \"\\<dots> \\<subseteq> Keys (hom_components p)\""], ["proof (prove)\nusing this:\n  q \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. keys q \\<subseteq> Keys (hom_components p)", "by (rule keys_subset_Keys)"], ["proof (state)\nthis:\n  keys q \\<subseteq> Keys (hom_components p)\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> keys q \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "also"], ["proof (state)\nthis:\n  keys q \\<subseteq> Keys (hom_components p)\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> keys q \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "have \"\\<dots> = keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (hom_components p) = keys p", "by (fact Keys_hom_components)"], ["proof (state)\nthis:\n  Keys (hom_components p) = keys p\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> keys q \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "finally"], ["proof (chain)\npicking this:\n  t \\<in> keys p", "show \"deg_pm t \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_hom_components: \"\\<Sum>(hom_components p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum> (hom_components p) = p", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (\\<Sum> (hom_components p)) k = lookup p k", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (\\<Sum> (hom_components p)) k = lookup p k", "show \"lookup (\\<Sum>(hom_components p)) t = lookup p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<Sum> (hom_components p)) t = lookup p t", "unfolding lookup_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "proof (cases \"t \\<in> keys p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "case True"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "also"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "have \"keys p = Keys (hom_components p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys p = Keys (hom_components p)", "by (simp only: Keys_hom_components)"], ["proof (state)\nthis:\n  keys p = Keys (hom_components p)\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "finally"], ["proof (chain)\npicking this:\n  t \\<in> Keys (hom_components p)", "obtain q where q: \"q \\<in> hom_components p\" and t: \"t \\<in> keys q\""], ["proof (prove)\nusing this:\n  t \\<in> Keys (hom_components p)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> hom_components p; t \\<in> keys q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_KeysE)"], ["proof (state)\nthis:\n  q \\<in> hom_components p\n  t \\<in> keys q\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "from this(1)"], ["proof (chain)\npicking this:\n  q \\<in> hom_components p", "have \"(\\<Sum>q0\\<in>hom_components p. lookup q0 t) =\n                        (\\<Sum>q0\\<in>insert q (hom_components p). lookup q0 t)\""], ["proof (prove)\nusing this:\n  q \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. (\\<Sum>q0\\<in>hom_components p. lookup q0 t) =\n    (\\<Sum>q0\\<in>insert q (hom_components p). lookup q0 t)", "by (simp only: insert_absorb)"], ["proof (state)\nthis:\n  (\\<Sum>q0\\<in>hom_components p. lookup q0 t) =\n  (\\<Sum>q0\\<in>insert q (hom_components p). lookup q0 t)\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "also"], ["proof (state)\nthis:\n  (\\<Sum>q0\\<in>hom_components p. lookup q0 t) =\n  (\\<Sum>q0\\<in>insert q (hom_components p). lookup q0 t)\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "from finite_hom_components"], ["proof (chain)\npicking this:\n  finite (hom_components ?p)", "have \"\\<dots> = lookup q t + (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t)\""], ["proof (prove)\nusing this:\n  finite (hom_components ?p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>q0\\<in>insert q (hom_components p). lookup q0 t) =\n    lookup q t + (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t)", "by (rule sum.insert_remove)"], ["proof (state)\nthis:\n  (\\<Sum>q0\\<in>insert q (hom_components p). lookup q0 t) =\n  lookup q t + (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t)\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "also"], ["proof (state)\nthis:\n  (\\<Sum>q0\\<in>insert q (hom_components p). lookup q0 t) =\n  lookup q t + (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t)\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "from q t"], ["proof (chain)\npicking this:\n  q \\<in> hom_components p\n  t \\<in> keys q", "have \"\\<dots> = lookup p t + (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t)\""], ["proof (prove)\nusing this:\n  q \\<in> hom_components p\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. lookup q t + (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t) =\n    lookup p t + (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t)", "by (simp only: lookup_hom_components)"], ["proof (state)\nthis:\n  lookup q t + (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t) =\n  lookup p t + (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t)\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "also"], ["proof (state)\nthis:\n  lookup q t + (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t) =\n  lookup p t + (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t)\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "have \"(\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t) = (0::'b)", "proof (intro sum.neutral ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p - {q} \\<Longrightarrow> lookup x t = (0::'b)", "fix q0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p - {q} \\<Longrightarrow> lookup x t = (0::'b)", "assume \"q0 \\<in> hom_components p - {q}\""], ["proof (state)\nthis:\n  q0 \\<in> hom_components p - {q}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p - {q} \\<Longrightarrow> lookup x t = (0::'b)", "hence \"q0 \\<in> hom_components p\" and \"q \\<noteq> q0\""], ["proof (prove)\nusing this:\n  q0 \\<in> hom_components p - {q}\n\ngoal (1 subgoal):\n 1. q0 \\<in> hom_components p &&& q \\<noteq> q0", "by blast+"], ["proof (state)\nthis:\n  q0 \\<in> hom_components p\n  q \\<noteq> q0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p - {q} \\<Longrightarrow> lookup x t = (0::'b)", "with q"], ["proof (chain)\npicking this:\n  q \\<in> hom_components p\n  q0 \\<in> hom_components p\n  q \\<noteq> q0", "have \"keys q \\<inter> keys q0 = {}\""], ["proof (prove)\nusing this:\n  q \\<in> hom_components p\n  q0 \\<in> hom_components p\n  q \\<noteq> q0\n\ngoal (1 subgoal):\n 1. keys q \\<inter> keys q0 = {}", "by (rule hom_components_keys_disjoint)"], ["proof (state)\nthis:\n  keys q \\<inter> keys q0 = {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p - {q} \\<Longrightarrow> lookup x t = (0::'b)", "with t"], ["proof (chain)\npicking this:\n  t \\<in> keys q\n  keys q \\<inter> keys q0 = {}", "have \"t \\<notin> keys q0\""], ["proof (prove)\nusing this:\n  t \\<in> keys q\n  keys q \\<inter> keys q0 = {}\n\ngoal (1 subgoal):\n 1. t \\<notin> keys q0", "by blast"], ["proof (state)\nthis:\n  t \\<notin> keys q0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p - {q} \\<Longrightarrow> lookup x t = (0::'b)", "thus \"lookup q0 t = 0\""], ["proof (prove)\nusing this:\n  t \\<notin> keys q0\n\ngoal (1 subgoal):\n 1. lookup q0 t = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup q0 t = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>q0\\<in>hom_components p - {q}. lookup q0 t) = (0::'b)\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>q0\\<in>hom_components p. lookup q0 t) = lookup p t + (0::'b)", "show \"(\\<Sum>q\\<in>hom_components p. lookup q t) = lookup p t\""], ["proof (prove)\nusing this:\n  (\\<Sum>q0\\<in>hom_components p. lookup q0 t) = lookup p t + (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>hom_components p. lookup q t) = lookup p t", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>hom_components p. lookup q t) = lookup p t\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "case False"], ["proof (state)\nthis:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "hence \"t \\<notin> Keys (hom_components p)\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> Keys (hom_components p)", "by (simp add: Keys_hom_components)"], ["proof (state)\nthis:\n  t \\<notin> Keys (hom_components p)\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "hence \"\\<forall>q\\<in>hom_components p. lookup q t = 0\""], ["proof (prove)\nusing this:\n  t \\<notin> Keys (hom_components p)\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>hom_components p. lookup q t = (0::'b)", "by (simp add: Keys_def in_keys_iff)"], ["proof (state)\nthis:\n  \\<forall>q\\<in>hom_components p. lookup q t = (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "hence \"(\\<Sum>q\\<in>hom_components p. lookup q t) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>hom_components p. lookup q t = (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>hom_components p. lookup q t) = (0::'b)", "by (rule sum.neutral)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>hom_components p. lookup q t) = (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "also"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>hom_components p. lookup q t) = (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "from False"], ["proof (chain)\npicking this:\n  t \\<notin> keys p", "have \"\\<dots> = lookup p t\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. (0::'b) = lookup p t", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (0::'b) = lookup p t\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    (\\<Sum>x\\<in>hom_components p. lookup x t) = lookup p t", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>q\\<in>hom_components p. lookup q t) = lookup p t", "show \"(\\<Sum>q\\<in>hom_components p. lookup q t) = lookup p t\""], ["proof (prove)\nusing this:\n  (\\<Sum>q\\<in>hom_components p. lookup q t) = lookup p t\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>hom_components p. lookup q t) = lookup p t", "."], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>hom_components p. lookup q t) = lookup p t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (\\<Sum> (hom_components p)) t = lookup p t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogeneous_setI: \"(\\<And>a n. a \\<in> A \\<Longrightarrow> hom_component a n \\<in> A) \\<Longrightarrow> homogeneous_set A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n.\n        a \\<in> A \\<Longrightarrow>\n        hom_component a n \\<in> A) \\<Longrightarrow>\n    homogeneous_set A", "by (simp add: homogeneous_set_def)"], ["", "lemma homogeneous_setD: \"homogeneous_set A \\<Longrightarrow> a \\<in> A \\<Longrightarrow> hom_component a n \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>homogeneous_set A; a \\<in> A\\<rbrakk>\n    \\<Longrightarrow> hom_component a n \\<in> A", "by (simp add: homogeneous_set_def)"], ["", "lemma homogeneous_set_Polys: \"homogeneous_set (P[X]::(_ \\<Rightarrow>\\<^sub>0 'a::zero) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous_set P[X]", "proof (intro homogeneous_setI PolysI subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n x.\n       \\<lbrakk>a \\<in> P[X]; x \\<in> keys (hom_component a n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> .[X]", "fix p::\"_ \\<Rightarrow>\\<^sub>0 'a\" and n t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n x.\n       \\<lbrakk>a \\<in> P[X]; x \\<in> keys (hom_component a n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> .[X]", "assume \"p \\<in> P[X]\""], ["proof (state)\nthis:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a n x.\n       \\<lbrakk>a \\<in> P[X]; x \\<in> keys (hom_component a n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> .[X]", "assume \"t \\<in> keys (hom_component p n)\""], ["proof (state)\nthis:\n  t \\<in> keys (hom_component p n)\n\ngoal (1 subgoal):\n 1. \\<And>a n x.\n       \\<lbrakk>a \\<in> P[X]; x \\<in> keys (hom_component a n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> .[X]", "hence \"t \\<in> keys p\""], ["proof (prove)\nusing this:\n  t \\<in> keys (hom_component p n)\n\ngoal (1 subgoal):\n 1. t \\<in> keys p", "by (rule keys_hom_componentD)"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>a n x.\n       \\<lbrakk>a \\<in> P[X]; x \\<in> keys (hom_component a n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> .[X]", "also"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>a n x.\n       \\<lbrakk>a \\<in> P[X]; x \\<in> keys (hom_component a n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> .[X]", "from \\<open>p \\<in> P[X]\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> P[X]", "have \"\\<dots> \\<subseteq> .[X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[X]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>a n x.\n       \\<lbrakk>a \\<in> P[X]; x \\<in> keys (hom_component a n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> .[X]", "finally"], ["proof (chain)\npicking this:\n  t \\<in> .[X]", "show \"t \\<in> .[X]\""], ["proof (prove)\nusing this:\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t \\<in> .[X]", "."], ["proof (state)\nthis:\n  t \\<in> .[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogeneous_set_IntI: \"homogeneous_set A \\<Longrightarrow> homogeneous_set B \\<Longrightarrow> homogeneous_set (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>homogeneous_set A; homogeneous_set B\\<rbrakk>\n    \\<Longrightarrow> homogeneous_set (A \\<inter> B)", "by (simp add: homogeneous_set_def)"], ["", "lemma homogeneous_setD_hom_components:\n  assumes \"homogeneous_set A\" and \"a \\<in> A\" and \"b \\<in> hom_components a\"\n  shows \"b \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> A", "from assms(3)"], ["proof (chain)\npicking this:\n  b \\<in> hom_components a", "obtain t::\"'a \\<Rightarrow>\\<^sub>0 nat\" where \"b = hom_component a (deg_pm t)\""], ["proof (prove)\nusing this:\n  b \\<in> hom_components a\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        b = hom_component a (deg_pm t) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule hom_componentsE)"], ["proof (state)\nthis:\n  b = hom_component a (deg_pm t)\n\ngoal (1 subgoal):\n 1. b \\<in> A", "also"], ["proof (state)\nthis:\n  b = hom_component a (deg_pm t)\n\ngoal (1 subgoal):\n 1. b \\<in> A", "from assms(1, 2)"], ["proof (chain)\npicking this:\n  homogeneous_set A\n  a \\<in> A", "have \"\\<dots> \\<in> A\""], ["proof (prove)\nusing this:\n  homogeneous_set A\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. hom_component a (deg_pm t) \\<in> A", "by (rule homogeneous_setD)"], ["proof (state)\nthis:\n  hom_component a (deg_pm t) \\<in> A\n\ngoal (1 subgoal):\n 1. b \\<in> A", "finally"], ["proof (chain)\npicking this:\n  b \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> A\n\ngoal (1 subgoal):\n 1. b \\<in> A", "."], ["proof (state)\nthis:\n  b \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_in_homogeneous_set:\n  assumes \"homogeneous_set A\" and \"A \\<noteq> {}\"\n  shows \"0 \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<in> A", "from assms(2)"], ["proof (chain)\npicking this:\n  A \\<noteq> {}", "obtain a where \"a \\<in> A\""], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. 0 \\<in> A", "have \"lookup a t = 0\" if \"deg_pm t = Suc (poly_deg a)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup a t = (0::'b)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup a t \\<noteq> (0::'b) \\<Longrightarrow> False", "assume \"lookup a t \\<noteq> 0\""], ["proof (state)\nthis:\n  lookup a t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup a t \\<noteq> (0::'b) \\<Longrightarrow> False", "hence \"t \\<in> keys a\""], ["proof (prove)\nusing this:\n  lookup a t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<in> keys a", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  t \\<in> keys a\n\ngoal (1 subgoal):\n 1. lookup a t \\<noteq> (0::'b) \\<Longrightarrow> False", "hence \"deg_pm t \\<le> poly_deg a\""], ["proof (prove)\nusing this:\n  t \\<in> keys a\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg a", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg a\n\ngoal (1 subgoal):\n 1. lookup a t \\<noteq> (0::'b) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  deg_pm t \\<le> poly_deg a\n\ngoal (1 subgoal):\n 1. False", "by (simp add: that)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pm ?t = Suc (poly_deg a) \\<Longrightarrow> lookup a ?t = (0::'b)\n\ngoal (1 subgoal):\n 1. 0 \\<in> A", "hence \"0 = hom_component a (Suc (poly_deg a))\""], ["proof (prove)\nusing this:\n  deg_pm ?t = Suc (poly_deg a) \\<Longrightarrow> lookup a ?t = (0::'b)\n\ngoal (1 subgoal):\n 1. 0 = hom_component a (Suc (poly_deg a))", "by (intro poly_mapping_eqI) (simp add: lookup_hom_component when_def)"], ["proof (state)\nthis:\n  0 = hom_component a (Suc (poly_deg a))\n\ngoal (1 subgoal):\n 1. 0 \\<in> A", "also"], ["proof (state)\nthis:\n  0 = hom_component a (Suc (poly_deg a))\n\ngoal (1 subgoal):\n 1. 0 \\<in> A", "from assms(1) \\<open>a \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  homogeneous_set A\n  a \\<in> A", "have \"\\<dots> \\<in> A\""], ["proof (prove)\nusing this:\n  homogeneous_set A\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. hom_component a (Suc (poly_deg a)) \\<in> A", "by (rule homogeneous_setD)"], ["proof (state)\nthis:\n  hom_component a (Suc (poly_deg a)) \\<in> A\n\ngoal (1 subgoal):\n 1. 0 \\<in> A", "finally"], ["proof (chain)\npicking this:\n  0 \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<in> A\n\ngoal (1 subgoal):\n 1. 0 \\<in> A", "."], ["proof (state)\nthis:\n  0 \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogeneous_ideal:\n  assumes \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"p \\<in> ideal F\"\n  shows \"hom_component p n \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component p n \\<in> ideal F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom_component p n \\<in> ideal F", "from assms(2)"], ["proof (chain)\npicking this:\n  p \\<in> ideal F", "have \"p \\<in> punit.pmdl F\""], ["proof (prove)\nusing this:\n  p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p \\<in> punit.pmdl F", "by simp"], ["proof (state)\nthis:\n  p \\<in> punit.pmdl F\n\ngoal (1 subgoal):\n 1. hom_component p n \\<in> ideal F", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> punit.pmdl F\n\ngoal (1 subgoal):\n 1. hom_component p n \\<in> ideal F", "proof (induct p rule: punit.pmdl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. hom_component 0 n \\<in> ideal F\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "case module_0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. hom_component 0 n \\<in> ideal F\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component 0 n \\<in> ideal F", "by (simp add: ideal.span_zero)"], ["proof (state)\nthis:\n  hom_component 0 n \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "case (module_plus a f c t)"], ["proof (state)\nthis:\n  a \\<in> punit.pmdl F\n  hom_component a n \\<in> ideal F\n  f \\<in> F\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "let ?f = \"punit.monom_mult c t f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "from module_plus.hyps(3)"], ["proof (chain)\npicking this:\n  f \\<in> F", "have \"f \\<in> punit.pmdl F\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. f \\<in> punit.pmdl F", "by (simp add: ideal.span_base)"], ["proof (state)\nthis:\n  f \\<in> punit.pmdl F\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "hence *: \"?f \\<in> punit.pmdl F\""], ["proof (prove)\nusing this:\n  f \\<in> punit.pmdl F\n\ngoal (1 subgoal):\n 1. punit.monom_mult c t f \\<in> punit.pmdl F", "by (rule punit.pmdl_closed_monom_mult)"], ["proof (state)\nthis:\n  punit.monom_mult c t f \\<in> punit.pmdl F\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "from module_plus.hyps(3)"], ["proof (chain)\npicking this:\n  f \\<in> F", "have \"homogeneous f\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. homogeneous f", "by (rule assms(1))"], ["proof (state)\nthis:\n  homogeneous f\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "hence \"homogeneous ?f\""], ["proof (prove)\nusing this:\n  homogeneous f\n\ngoal (1 subgoal):\n 1. homogeneous (punit.monom_mult c t f)", "by (rule homogeneous_monom_mult)"], ["proof (state)\nthis:\n  homogeneous (punit.monom_mult c t f)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "hence \"hom_component ?f n = (?f when n = poly_deg ?f)\""], ["proof (prove)\nusing this:\n  homogeneous (punit.monom_mult c t f)\n\ngoal (1 subgoal):\n 1. hom_component (punit.monom_mult c t f) n =\n    (punit.monom_mult c t f when n = poly_deg (punit.monom_mult c t f))", "by (rule hom_component_of_homogeneous)"], ["proof (state)\nthis:\n  hom_component (punit.monom_mult c t f) n =\n  (punit.monom_mult c t f when n = poly_deg (punit.monom_mult c t f))\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "also"], ["proof (state)\nthis:\n  hom_component (punit.monom_mult c t f) n =\n  (punit.monom_mult c t f when n = poly_deg (punit.monom_mult c t f))\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "from *"], ["proof (chain)\npicking this:\n  punit.monom_mult c t f \\<in> punit.pmdl F", "have \"\\<dots> \\<in> ideal F\""], ["proof (prove)\nusing this:\n  punit.monom_mult c t f \\<in> punit.pmdl F\n\ngoal (1 subgoal):\n 1. (punit.monom_mult c t f when n = poly_deg (punit.monom_mult c t f))\n    \\<in> ideal F", "by (simp add: when_def ideal.span_zero)"], ["proof (state)\nthis:\n  (punit.monom_mult c t f when n = poly_deg (punit.monom_mult c t f))\n  \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "finally"], ["proof (chain)\npicking this:\n  hom_component (punit.monom_mult c t f) n \\<in> ideal F", "have \"hom_component ?f n \\<in> ideal F\""], ["proof (prove)\nusing this:\n  hom_component (punit.monom_mult c t f) n \\<in> ideal F\n\ngoal (1 subgoal):\n 1. hom_component (punit.monom_mult c t f) n \\<in> ideal F", "."], ["proof (state)\nthis:\n  hom_component (punit.monom_mult c t f) n \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> punit.pmdl F; hom_component a n \\<in> ideal F;\n        p \\<in> F; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> hom_component (a + punit.monom_mult c t p) n\n                         \\<in> ideal F", "with module_plus.hyps(2)"], ["proof (chain)\npicking this:\n  hom_component a n \\<in> ideal F\n  hom_component (punit.monom_mult c t f) n \\<in> ideal F", "show ?case"], ["proof (prove)\nusing this:\n  hom_component a n \\<in> ideal F\n  hom_component (punit.monom_mult c t f) n \\<in> ideal F\n\ngoal (1 subgoal):\n 1. hom_component (a + punit.monom_mult c t f) n \\<in> ideal F", "unfolding hom_component_plus"], ["proof (prove)\nusing this:\n  hom_component a n \\<in> ideal F\n  hom_component (punit.monom_mult c t f) n \\<in> ideal F\n\ngoal (1 subgoal):\n 1. hom_component a n + hom_component (punit.monom_mult c t f) n\n    \\<in> ideal F", "by (rule ideal.span_add)"], ["proof (state)\nthis:\n  hom_component (a + punit.monom_mult c t f) n \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hom_component p n \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary homogeneous_set_homogeneous_ideal:\n  \"(\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow> homogeneous_set (ideal F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n    homogeneous_set (ideal F)", "by (auto intro: homogeneous_setI homogeneous_ideal)"], ["", "corollary homogeneous_ideal':\n  assumes \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"p \\<in> ideal F\" and \"q \\<in> hom_components p\"\n  shows \"q \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> ideal F", "using _ assms(2, 3)"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  p \\<in> ideal F\n  q \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. q \\<in> ideal F", "proof (rule homogeneous_setD_hom_components)"], ["proof (state)\ngoal (1 subgoal):\n 1. homogeneous_set (ideal F)", "from assms(1)"], ["proof (chain)\npicking this:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f", "show \"homogeneous_set (ideal F)\""], ["proof (prove)\nusing this:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f\n\ngoal (1 subgoal):\n 1. homogeneous_set (ideal F)", "by (rule homogeneous_set_homogeneous_ideal)"], ["proof (state)\nthis:\n  homogeneous_set (ideal F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogeneous_idealE_homogeneous:\n  assumes \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"p \\<in> ideal F\" and \"homogeneous p\"\n  obtains F' q where \"finite F'\" and \"F' \\<subseteq> F\" and \"p = (\\<Sum>f\\<in>F'. q f * f)\" and \"\\<And>f. homogeneous (q f)\"\n    and \"\\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p\" and \"\\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(2)"], ["proof (chain)\npicking this:\n  p \\<in> ideal F", "obtain F'' q' where \"finite F''\" and \"F'' \\<subseteq> F\" and p: \"p = (\\<Sum>f\\<in>F''. q' f * f)\""], ["proof (prove)\nusing this:\n  p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>F'' q'.\n        \\<lbrakk>finite F''; F'' \\<subseteq> F;\n         p = (\\<Sum>f\\<in>F''. q' f * f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule ideal.spanE)"], ["proof (state)\nthis:\n  finite F''\n  F'' \\<subseteq> F\n  p = (\\<Sum>f\\<in>F''. q' f * f)\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?A = \"\\<lambda>f. {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?B = \"\\<lambda>f. {h \\<in> hom_components (q' f). poly_deg h + poly_deg f \\<noteq> poly_deg p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define F' where \"F' = {f \\<in> F''. (\\<Sum>(?A f)) * f \\<noteq> 0}\""], ["proof (state)\nthis:\n  F' =\n  {f \\<in> F''.\n   \\<Sum>\n    {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p} *\n   f \\<noteq>\n   0}\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define q where \"q = (\\<lambda>f. (\\<Sum>(?A f)) when f \\<in> F')\""], ["proof (state)\nthis:\n  q =\n  (\\<lambda>f.\n      \\<Sum>\n       {h \\<in> hom_components (q' f).\n        poly_deg h + poly_deg f = poly_deg p} when\n      f \\<in> F')\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"F' \\<subseteq> F''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F' \\<subseteq> F''", "by (simp add: F'_def)"], ["proof (state)\nthis:\n  F' \\<subseteq> F''\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"F' \\<subseteq> F\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> F''\n\ngoal (1 subgoal):\n 1. F' \\<subseteq> F", "using \\<open>F'' \\<subseteq> F\\<close>"], ["proof (prove)\nusing this:\n  F' \\<subseteq> F''\n  F'' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. F' \\<subseteq> F", "by (rule subset_trans)"], ["proof (state)\nthis:\n  F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \"deg_pm t + poly_deg f = poly_deg p\" if \"f \\<in> F'\" and \"t \\<in> keys (q f)\" for f t"], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg f = poly_deg p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg f = poly_deg p", "from that"], ["proof (chain)\npicking this:\n  f \\<in> F'\n  t \\<in> keys (q f)", "have \"t \\<in> keys (\\<Sum>(?A f))\""], ["proof (prove)\nusing this:\n  f \\<in> F'\n  t \\<in> keys (q f)\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (\\<Sum>\n               {h \\<in> hom_components (q' f).\n                poly_deg h + poly_deg f = poly_deg p})", "by (simp add: q_def)"], ["proof (state)\nthis:\n  t \\<in> keys\n           (\\<Sum>\n             {h \\<in> hom_components (q' f).\n              poly_deg h + poly_deg f = poly_deg p})\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg f = poly_deg p", "also"], ["proof (state)\nthis:\n  t \\<in> keys\n           (\\<Sum>\n             {h \\<in> hom_components (q' f).\n              poly_deg h + poly_deg f = poly_deg p})\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg f = poly_deg p", "have \"\\<dots> \\<subseteq> (\\<Union>h\\<in>?A f. keys h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>\n       {h \\<in> hom_components (q' f).\n        poly_deg h + poly_deg f = poly_deg p})\n    \\<subseteq> \\<Union>\n                 (keys `\n                  {h \\<in> hom_components (q' f).\n                   poly_deg h + poly_deg f = poly_deg p})", "by (fact keys_sum_subset)"], ["proof (state)\nthis:\n  keys\n   (\\<Sum>\n     {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p})\n  \\<subseteq> \\<Union>\n               (keys `\n                {h \\<in> hom_components (q' f).\n                 poly_deg h + poly_deg f = poly_deg p})\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg f = poly_deg p", "finally"], ["proof (chain)\npicking this:\n  t \\<in> \\<Union>\n           (keys `\n            {h \\<in> hom_components (q' f).\n             poly_deg h + poly_deg f = poly_deg p})", "obtain h where \"h \\<in> ?A f\" and \"t \\<in> keys h\""], ["proof (prove)\nusing this:\n  t \\<in> \\<Union>\n           (keys `\n            {h \\<in> hom_components (q' f).\n             poly_deg h + poly_deg f = poly_deg p})\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> {h \\<in> hom_components (q' f).\n                          poly_deg h + poly_deg f = poly_deg p};\n         t \\<in> keys h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  h \\<in> {h \\<in> hom_components (q' f).\n           poly_deg h + poly_deg f = poly_deg p}\n  t \\<in> keys h\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg f = poly_deg p", "from this(1)"], ["proof (chain)\npicking this:\n  h \\<in> {h \\<in> hom_components (q' f).\n           poly_deg h + poly_deg f = poly_deg p}", "have \"h \\<in> hom_components (q' f)\" and eq: \"poly_deg h + poly_deg f = poly_deg p\""], ["proof (prove)\nusing this:\n  h \\<in> {h \\<in> hom_components (q' f).\n           poly_deg h + poly_deg f = poly_deg p}\n\ngoal (1 subgoal):\n 1. h \\<in> hom_components (q' f) &&& poly_deg h + poly_deg f = poly_deg p", "by simp_all"], ["proof (state)\nthis:\n  h \\<in> hom_components (q' f)\n  poly_deg h + poly_deg f = poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg f = poly_deg p", "from this(1)"], ["proof (chain)\npicking this:\n  h \\<in> hom_components (q' f)", "have \"homogeneous h\""], ["proof (prove)\nusing this:\n  h \\<in> hom_components (q' f)\n\ngoal (1 subgoal):\n 1. homogeneous h", "by (rule hom_components_homogeneous)"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg f = poly_deg p", "hence \"deg_pm t = poly_deg h\""], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg h", "using \\<open>t \\<in> keys h\\<close>"], ["proof (prove)\nusing this:\n  homogeneous h\n  t \\<in> keys h\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg h", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg h\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg f = poly_deg p", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t = poly_deg h\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg f = poly_deg p", "by (simp only: eq)"], ["proof (state)\nthis:\n  deg_pm t + poly_deg f = poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> F'; ?t \\<in> keys (q ?f)\\<rbrakk>\n  \\<Longrightarrow> deg_pm ?t + poly_deg ?f = poly_deg p\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 2: \"deg_pm t = poly_deg p\" if \"f \\<in> F'\" and \"t \\<in> keys (q f * f)\" for f t"], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "from that(1) \\<open>F' \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F'\n  F' \\<subseteq> F", "have \"f \\<in> F\""], ["proof (prove)\nusing this:\n  f \\<in> F'\n  F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. f \\<in> F", ".."], ["proof (state)\nthis:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "hence \"homogeneous f\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. homogeneous f", "by (rule assms(1))"], ["proof (state)\nthis:\n  homogeneous f\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "from that(2)"], ["proof (chain)\npicking this:\n  t \\<in> keys (q f * f)", "obtain s1 s2 where \"s1 \\<in> keys (q f)\" and \"s2 \\<in> keys f\" and t: \"t = s1 + s2\""], ["proof (prove)\nusing this:\n  t \\<in> keys (q f * f)\n\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        \\<lbrakk>s1 \\<in> keys (q f); s2 \\<in> keys f; t = s1 + s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_timesE)"], ["proof (state)\nthis:\n  s1 \\<in> keys (q f)\n  s2 \\<in> keys f\n  t = s1 + s2\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "from that(1) this(1)"], ["proof (chain)\npicking this:\n  f \\<in> F'\n  s1 \\<in> keys (q f)", "have \"deg_pm s1 + poly_deg f = poly_deg p\""], ["proof (prove)\nusing this:\n  f \\<in> F'\n  s1 \\<in> keys (q f)\n\ngoal (1 subgoal):\n 1. deg_pm s1 + poly_deg f = poly_deg p", "by (rule 1)"], ["proof (state)\nthis:\n  deg_pm s1 + poly_deg f = poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "moreover"], ["proof (state)\nthis:\n  deg_pm s1 + poly_deg f = poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "from \\<open>homogeneous f\\<close> \\<open>s2 \\<in> keys f\\<close>"], ["proof (chain)\npicking this:\n  homogeneous f\n  s2 \\<in> keys f", "have \"deg_pm s2 = poly_deg f\""], ["proof (prove)\nusing this:\n  homogeneous f\n  s2 \\<in> keys f\n\ngoal (1 subgoal):\n 1. deg_pm s2 = poly_deg f", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm s2 = poly_deg f\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm s1 + poly_deg f = poly_deg p\n  deg_pm s2 = poly_deg f", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pm s1 + poly_deg f = poly_deg p\n  deg_pm s2 = poly_deg f\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (simp add: t deg_pm_plus)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> F'; ?t \\<in> keys (q ?f * ?f)\\<rbrakk>\n  \\<Longrightarrow> deg_pm ?t = poly_deg p\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>F' \\<subseteq> F''\\<close> \\<open>finite F''\\<close>"], ["proof (chain)\npicking this:\n  F' \\<subseteq> F''\n  finite F''", "have \"finite F'\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> F''\n  finite F''\n\ngoal (1 subgoal):\n 1. finite F'", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite F'\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. homogeneous (q f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite F'\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>F' \\<subseteq> F\\<close>"], ["proof (prove)\nusing this:\n  finite F'\n  F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. homogeneous (?q f)\n 3. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (?q f * f) = poly_deg p\n 4. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "note p"], ["proof (state)\nthis:\n  p = (\\<Sum>f\\<in>F''. q' f * f)\n\ngoal (4 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. homogeneous (?q f)\n 3. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (?q f * f) = poly_deg p\n 4. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "also"], ["proof (state)\nthis:\n  p = (\\<Sum>f\\<in>F''. q' f * f)\n\ngoal (4 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. homogeneous (?q f)\n 3. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (?q f * f) = poly_deg p\n 4. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"(\\<Sum>f\\<in>F''. q' f * f) = (\\<Sum>f\\<in>F''. (\\<Sum>(?A f) * f) + (\\<Sum>(?B f) * f))\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>F''. q' f * f) =\n    (\\<Sum>f\\<in>F''.\n       \\<Sum>\n        {h \\<in> hom_components (q' f).\n         poly_deg h + poly_deg f = poly_deg p} *\n       f +\n       \\<Sum>\n        {h \\<in> hom_components (q' f).\n         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n       f)", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       q' x * x =\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x = poly_deg p} *\n       x +\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x \\<noteq> poly_deg p} *\n       x", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       q' x * x =\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x = poly_deg p} *\n       x +\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x \\<noteq> poly_deg p} *\n       x", "assume \"f \\<in> F''\""], ["proof (state)\nthis:\n  f \\<in> F''\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       q' x * x =\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x = poly_deg p} *\n       x +\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x \\<noteq> poly_deg p} *\n       x", "from sum_hom_components"], ["proof (chain)\npicking this:\n  \\<Sum> (hom_components ?p) = ?p", "have \"q' f = (\\<Sum>(hom_components (q' f)))\""], ["proof (prove)\nusing this:\n  \\<Sum> (hom_components ?p) = ?p\n\ngoal (1 subgoal):\n 1. q' f = \\<Sum> (hom_components (q' f))", "by (rule sym)"], ["proof (state)\nthis:\n  q' f = \\<Sum> (hom_components (q' f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       q' x * x =\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x = poly_deg p} *\n       x +\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x \\<noteq> poly_deg p} *\n       x", "also"], ["proof (state)\nthis:\n  q' f = \\<Sum> (hom_components (q' f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       q' x * x =\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x = poly_deg p} *\n       x +\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x \\<noteq> poly_deg p} *\n       x", "have \"\\<dots> = (\\<Sum>(?A f \\<union> ?B f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum> (hom_components (q' f)) =\n    \\<Sum>\n     ({h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f = poly_deg p} \\<union>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p})", "by (rule arg_cong[where f=\"sum (\\<lambda>x. x)\"]) blast"], ["proof (state)\nthis:\n  \\<Sum> (hom_components (q' f)) =\n  \\<Sum>\n   ({h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f = poly_deg p} \\<union>\n    {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f \\<noteq> poly_deg p})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       q' x * x =\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x = poly_deg p} *\n       x +\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x \\<noteq> poly_deg p} *\n       x", "also"], ["proof (state)\nthis:\n  \\<Sum> (hom_components (q' f)) =\n  \\<Sum>\n   ({h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f = poly_deg p} \\<union>\n    {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f \\<noteq> poly_deg p})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       q' x * x =\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x = poly_deg p} *\n       x +\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x \\<noteq> poly_deg p} *\n       x", "have \"\\<dots> = \\<Sum>(?A f) + \\<Sum>(?B f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\n     ({h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f = poly_deg p} \\<union>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p}) =\n    \\<Sum>\n     {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p} +\n    \\<Sum>\n     {h \\<in> hom_components (q' f).\n      poly_deg h + poly_deg f \\<noteq> poly_deg p}", "proof (rule sum.union_disjoint)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite\n     {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p}\n 2. finite\n     {h \\<in> hom_components (q' f).\n      poly_deg h + poly_deg f \\<noteq> poly_deg p}\n 3. {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f = poly_deg p} \\<inter>\n    {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f \\<noteq> poly_deg p} =\n    {}", "have \"?A f \\<subseteq> hom_components (q' f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p}\n    \\<subseteq> hom_components (q' f)", "by blast"], ["proof (state)\nthis:\n  {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p}\n  \\<subseteq> hom_components (q' f)\n\ngoal (3 subgoals):\n 1. finite\n     {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p}\n 2. finite\n     {h \\<in> hom_components (q' f).\n      poly_deg h + poly_deg f \\<noteq> poly_deg p}\n 3. {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f = poly_deg p} \\<inter>\n    {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f \\<noteq> poly_deg p} =\n    {}", "thus \"finite (?A f)\""], ["proof (prove)\nusing this:\n  {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p}\n  \\<subseteq> hom_components (q' f)\n\ngoal (1 subgoal):\n 1. finite\n     {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p}", "using finite_hom_components"], ["proof (prove)\nusing this:\n  {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p}\n  \\<subseteq> hom_components (q' f)\n  finite (hom_components ?p)\n\ngoal (1 subgoal):\n 1. finite\n     {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite\n   {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p}\n\ngoal (2 subgoals):\n 1. finite\n     {h \\<in> hom_components (q' f).\n      poly_deg h + poly_deg f \\<noteq> poly_deg p}\n 2. {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f = poly_deg p} \\<inter>\n    {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f \\<noteq> poly_deg p} =\n    {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     {h \\<in> hom_components (q' f).\n      poly_deg h + poly_deg f \\<noteq> poly_deg p}\n 2. {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f = poly_deg p} \\<inter>\n    {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f \\<noteq> poly_deg p} =\n    {}", "have \"?B f \\<subseteq> hom_components (q' f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f \\<noteq> poly_deg p}\n    \\<subseteq> hom_components (q' f)", "by blast"], ["proof (state)\nthis:\n  {h \\<in> hom_components (q' f).\n   poly_deg h + poly_deg f \\<noteq> poly_deg p}\n  \\<subseteq> hom_components (q' f)\n\ngoal (2 subgoals):\n 1. finite\n     {h \\<in> hom_components (q' f).\n      poly_deg h + poly_deg f \\<noteq> poly_deg p}\n 2. {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f = poly_deg p} \\<inter>\n    {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f \\<noteq> poly_deg p} =\n    {}", "thus \"finite (?B f)\""], ["proof (prove)\nusing this:\n  {h \\<in> hom_components (q' f).\n   poly_deg h + poly_deg f \\<noteq> poly_deg p}\n  \\<subseteq> hom_components (q' f)\n\ngoal (1 subgoal):\n 1. finite\n     {h \\<in> hom_components (q' f).\n      poly_deg h + poly_deg f \\<noteq> poly_deg p}", "using finite_hom_components"], ["proof (prove)\nusing this:\n  {h \\<in> hom_components (q' f).\n   poly_deg h + poly_deg f \\<noteq> poly_deg p}\n  \\<subseteq> hom_components (q' f)\n  finite (hom_components ?p)\n\ngoal (1 subgoal):\n 1. finite\n     {h \\<in> hom_components (q' f).\n      poly_deg h + poly_deg f \\<noteq> poly_deg p}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite\n   {h \\<in> hom_components (q' f).\n    poly_deg h + poly_deg f \\<noteq> poly_deg p}\n\ngoal (1 subgoal):\n 1. {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f = poly_deg p} \\<inter>\n    {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f \\<noteq> poly_deg p} =\n    {}", "qed blast"], ["proof (state)\nthis:\n  \\<Sum>\n   ({h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f = poly_deg p} \\<union>\n    {h \\<in> hom_components (q' f).\n     poly_deg h + poly_deg f \\<noteq> poly_deg p}) =\n  \\<Sum>\n   {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p} +\n  \\<Sum>\n   {h \\<in> hom_components (q' f).\n    poly_deg h + poly_deg f \\<noteq> poly_deg p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       q' x * x =\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x = poly_deg p} *\n       x +\n       \\<Sum>\n        {h \\<in> hom_components (q' x).\n         poly_deg h + poly_deg x \\<noteq> poly_deg p} *\n       x", "finally"], ["proof (chain)\npicking this:\n  q' f =\n  \\<Sum>\n   {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p} +\n  \\<Sum>\n   {h \\<in> hom_components (q' f).\n    poly_deg h + poly_deg f \\<noteq> poly_deg p}", "show \"q' f * f = (\\<Sum>(?A f) * f) + (\\<Sum>(?B f) * f)\""], ["proof (prove)\nusing this:\n  q' f =\n  \\<Sum>\n   {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p} +\n  \\<Sum>\n   {h \\<in> hom_components (q' f).\n    poly_deg h + poly_deg f \\<noteq> poly_deg p}\n\ngoal (1 subgoal):\n 1. q' f * f =\n    \\<Sum>\n     {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p} *\n    f +\n    \\<Sum>\n     {h \\<in> hom_components (q' f).\n      poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n    f", "by (metis (no_types, lifting) distrib_right)"], ["proof (state)\nthis:\n  q' f * f =\n  \\<Sum>\n   {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p} *\n  f +\n  \\<Sum>\n   {h \\<in> hom_components (q' f).\n    poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n  f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>F''. q' f * f) =\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f = poly_deg p} *\n     f +\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f)\n\ngoal (4 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. homogeneous (?q f)\n 3. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (?q f * f) = poly_deg p\n 4. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>F''. q' f * f) =\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f = poly_deg p} *\n     f +\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f)\n\ngoal (4 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. homogeneous (?q f)\n 3. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (?q f * f) = poly_deg p\n 4. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "have \"\\<dots> = (\\<Sum>f\\<in>F''. \\<Sum>(?A f) * f) + (\\<Sum>f\\<in>F''. \\<Sum>(?B f) * f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>F''.\n       \\<Sum>\n        {h \\<in> hom_components (q' f).\n         poly_deg h + poly_deg f = poly_deg p} *\n       f +\n       \\<Sum>\n        {h \\<in> hom_components (q' f).\n         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n       f) =\n    (\\<Sum>f\\<in>F''.\n       \\<Sum>\n        {h \\<in> hom_components (q' f).\n         poly_deg h + poly_deg f = poly_deg p} *\n       f) +\n    (\\<Sum>f\\<in>F''.\n       \\<Sum>\n        {h \\<in> hom_components (q' f).\n         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n       f)", "by (rule sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f = poly_deg p} *\n     f +\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f) =\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f = poly_deg p} *\n     f) +\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f)\n\ngoal (4 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. homogeneous (?q f)\n 3. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (?q f * f) = poly_deg p\n 4. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f = poly_deg p} *\n     f +\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f) =\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f = poly_deg p} *\n     f) +\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f)\n\ngoal (4 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. homogeneous (?q f)\n 3. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (?q f * f) = poly_deg p\n 4. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "from \\<open>finite F''\\<close> \\<open>F' \\<subseteq> F''\\<close>"], ["proof (chain)\npicking this:\n  finite F''\n  F' \\<subseteq> F''", "have \"(\\<Sum>f\\<in>F''. \\<Sum>(?A f) * f) = (\\<Sum>f\\<in>F'. q f * f)\""], ["proof (prove)\nusing this:\n  finite F''\n  F' \\<subseteq> F''\n\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>F''.\n       \\<Sum>\n        {h \\<in> hom_components (q' f).\n         poly_deg h + poly_deg f = poly_deg p} *\n       f) =\n    (\\<Sum>f\\<in>F'. q f * f)", "proof (intro sum.mono_neutral_cong_right ballI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> finite F''\n 2. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F''\n 3. \\<And>i.\n       \\<lbrakk>finite F''; F' \\<subseteq> F''; i \\<in> F'' - F'\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\n                          {h \\<in> hom_components (q' i).\n                           poly_deg h + poly_deg i = poly_deg p} *\n                         i =\n                         0\n 4. \\<And>x.\n       \\<lbrakk>finite F''; F' \\<subseteq> F''; x \\<in> F'\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\n                          {h \\<in> hom_components (q' x).\n                           poly_deg h + poly_deg x = poly_deg p} *\n                         x =\n                         q x * x", "fix f"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> finite F''\n 2. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F''\n 3. \\<And>i.\n       \\<lbrakk>finite F''; F' \\<subseteq> F''; i \\<in> F'' - F'\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\n                          {h \\<in> hom_components (q' i).\n                           poly_deg h + poly_deg i = poly_deg p} *\n                         i =\n                         0\n 4. \\<And>x.\n       \\<lbrakk>finite F''; F' \\<subseteq> F''; x \\<in> F'\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\n                          {h \\<in> hom_components (q' x).\n                           poly_deg h + poly_deg x = poly_deg p} *\n                         x =\n                         q x * x", "assume \"f \\<in> F'' - F'\""], ["proof (state)\nthis:\n  f \\<in> F'' - F'\n\ngoal (4 subgoals):\n 1. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> finite F''\n 2. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F''\n 3. \\<And>i.\n       \\<lbrakk>finite F''; F' \\<subseteq> F''; i \\<in> F'' - F'\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\n                          {h \\<in> hom_components (q' i).\n                           poly_deg h + poly_deg i = poly_deg p} *\n                         i =\n                         0\n 4. \\<And>x.\n       \\<lbrakk>finite F''; F' \\<subseteq> F''; x \\<in> F'\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\n                          {h \\<in> hom_components (q' x).\n                           poly_deg h + poly_deg x = poly_deg p} *\n                         x =\n                         q x * x", "thus \"\\<Sum>(?A f) * f = 0\""], ["proof (prove)\nusing this:\n  f \\<in> F'' - F'\n\ngoal (1 subgoal):\n 1. \\<Sum>\n     {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p} *\n    f =\n    0", "by (simp add: F'_def)"], ["proof (state)\nthis:\n  \\<Sum>\n   {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p} *\n  f =\n  0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> finite F''\n 2. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F''\n 3. \\<And>x.\n       \\<lbrakk>finite F''; F' \\<subseteq> F''; x \\<in> F'\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\n                          {h \\<in> hom_components (q' x).\n                           poly_deg h + poly_deg x = poly_deg p} *\n                         x =\n                         q x * x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> finite F''\n 2. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F''\n 3. \\<And>x.\n       \\<lbrakk>finite F''; F' \\<subseteq> F''; x \\<in> F'\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\n                          {h \\<in> hom_components (q' x).\n                           poly_deg h + poly_deg x = poly_deg p} *\n                         x =\n                         q x * x", "fix f"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> finite F''\n 2. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F''\n 3. \\<And>x.\n       \\<lbrakk>finite F''; F' \\<subseteq> F''; x \\<in> F'\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\n                          {h \\<in> hom_components (q' x).\n                           poly_deg h + poly_deg x = poly_deg p} *\n                         x =\n                         q x * x", "assume \"f \\<in> F'\""], ["proof (state)\nthis:\n  f \\<in> F'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> finite F''\n 2. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F''\n 3. \\<And>x.\n       \\<lbrakk>finite F''; F' \\<subseteq> F''; x \\<in> F'\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\n                          {h \\<in> hom_components (q' x).\n                           poly_deg h + poly_deg x = poly_deg p} *\n                         x =\n                         q x * x", "thus \"\\<Sum>(?A f) * f = q f * f\""], ["proof (prove)\nusing this:\n  f \\<in> F'\n\ngoal (1 subgoal):\n 1. \\<Sum>\n     {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p} *\n    f =\n    q f * f", "by (simp add: q_def)"], ["proof (state)\nthis:\n  \\<Sum>\n   {h \\<in> hom_components (q' f). poly_deg h + poly_deg f = poly_deg p} *\n  f =\n  q f * f\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> finite F''\n 2. \\<lbrakk>finite F''; F' \\<subseteq> F''\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F''", "qed"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f = poly_deg p} *\n     f) =\n  (\\<Sum>f\\<in>F'. q f * f)\n\ngoal (4 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. homogeneous (?q f)\n 3. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (?q f * f) = poly_deg p\n 4. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "finally"], ["proof (chain)\npicking this:\n  p =\n  (\\<Sum>f\\<in>F'. q f * f) +\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f)", "have p[symmetric]: \"p = (\\<Sum>f\\<in>F'. q f * f) + (\\<Sum>f\\<in>F''. \\<Sum>(?B f) * f)\""], ["proof (prove)\nusing this:\n  p =\n  (\\<Sum>f\\<in>F'. q f * f) +\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f)\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>f\\<in>F'. q f * f) +\n    (\\<Sum>f\\<in>F''.\n       \\<Sum>\n        {h \\<in> hom_components (q' f).\n         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n       f)", "."], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>F'. q f * f) +\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f) =\n  p\n\ngoal (4 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. homogeneous (?q f)\n 3. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (?q f * f) = poly_deg p\n 4. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>F'. q f * f) +\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f) =\n  p\n\ngoal (4 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. homogeneous (?q f)\n 3. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (?q f * f) = poly_deg p\n 4. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "have \"keys (\\<Sum>f\\<in>F''. \\<Sum>(?B f) * f) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>f\\<in>F''.\n        \\<Sum>\n         {h \\<in> hom_components (q' f).\n          poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n        f) =\n    {}", "proof (rule, rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "assume t_in: \"t \\<in> keys (\\<Sum>f\\<in>F''. \\<Sum>(?B f) * f)\""], ["proof (state)\nthis:\n  t \\<in> keys\n           (\\<Sum>f\\<in>F''.\n              \\<Sum>\n               {h \\<in> hom_components (q' f).\n                poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n              f)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "also"], ["proof (state)\nthis:\n  t \\<in> keys\n           (\\<Sum>f\\<in>F''.\n              \\<Sum>\n               {h \\<in> hom_components (q' f).\n                poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n              f)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "have \"\\<dots> \\<subseteq> (\\<Union>f\\<in>F''. keys (\\<Sum>(?B f) * f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>f\\<in>F''.\n        \\<Sum>\n         {h \\<in> hom_components (q' f).\n          poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n        f)\n    \\<subseteq> (\\<Union>f\\<in>F''.\n                    keys\n                     (\\<Sum>\n                       {h \\<in> hom_components (q' f).\n                        poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                      f))", "by (fact keys_sum_subset)"], ["proof (state)\nthis:\n  keys\n   (\\<Sum>f\\<in>F''.\n      \\<Sum>\n       {h \\<in> hom_components (q' f).\n        poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n      f)\n  \\<subseteq> (\\<Union>f\\<in>F''.\n                  keys\n                   (\\<Sum>\n                     {h \\<in> hom_components (q' f).\n                      poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                    f))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "finally"], ["proof (chain)\npicking this:\n  t \\<in> (\\<Union>f\\<in>F''.\n              keys\n               (\\<Sum>\n                 {h \\<in> hom_components (q' f).\n                  poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                f))", "obtain f where \"f \\<in> F''\" and \"t \\<in> keys (\\<Sum>(?B f) * f)\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>f\\<in>F''.\n              keys\n               (\\<Sum>\n                 {h \\<in> hom_components (q' f).\n                  poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                f))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F'';\n         t \\<in> keys\n                  (\\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  f \\<in> F''\n  t \\<in> keys\n           (\\<Sum>\n             {h \\<in> hom_components (q' f).\n              poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n            f)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "from this(2)"], ["proof (chain)\npicking this:\n  t \\<in> keys\n           (\\<Sum>\n             {h \\<in> hom_components (q' f).\n              poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n            f)", "obtain s1 s2 where \"s1 \\<in> keys (\\<Sum>(?B f))\" and \"s2 \\<in> keys f\" and t: \"t = s1 + s2\""], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (\\<Sum>\n             {h \\<in> hom_components (q' f).\n              poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n            f)\n\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        \\<lbrakk>s1 \\<in> keys\n                           (\\<Sum>\n                             {h \\<in> hom_components (q' f).\n                              poly_deg h + poly_deg f \\<noteq> poly_deg p});\n         s2 \\<in> keys f; t = s1 + s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_timesE)"], ["proof (state)\nthis:\n  s1 \\<in> keys\n            (\\<Sum>\n              {h \\<in> hom_components (q' f).\n               poly_deg h + poly_deg f \\<noteq> poly_deg p})\n  s2 \\<in> keys f\n  t = s1 + s2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "from \\<open>f \\<in> F''\\<close> \\<open>F'' \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F''\n  F'' \\<subseteq> F", "have \"f \\<in> F\""], ["proof (prove)\nusing this:\n  f \\<in> F''\n  F'' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. f \\<in> F", ".."], ["proof (state)\nthis:\n  f \\<in> F\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "hence \"homogeneous f\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. homogeneous f", "by (rule assms(1))"], ["proof (state)\nthis:\n  homogeneous f\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "note \\<open>s1 \\<in> keys (\\<Sum>(?B f))\\<close>"], ["proof (state)\nthis:\n  s1 \\<in> keys\n            (\\<Sum>\n              {h \\<in> hom_components (q' f).\n               poly_deg h + poly_deg f \\<noteq> poly_deg p})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "also"], ["proof (state)\nthis:\n  s1 \\<in> keys\n            (\\<Sum>\n              {h \\<in> hom_components (q' f).\n               poly_deg h + poly_deg f \\<noteq> poly_deg p})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "have \"keys (\\<Sum>(?B f)) \\<subseteq> (\\<Union>h\\<in>?B f. keys h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>\n       {h \\<in> hom_components (q' f).\n        poly_deg h + poly_deg f \\<noteq> poly_deg p})\n    \\<subseteq> \\<Union>\n                 (keys `\n                  {h \\<in> hom_components (q' f).\n                   poly_deg h + poly_deg f \\<noteq> poly_deg p})", "by (fact keys_sum_subset)"], ["proof (state)\nthis:\n  keys\n   (\\<Sum>\n     {h \\<in> hom_components (q' f).\n      poly_deg h + poly_deg f \\<noteq> poly_deg p})\n  \\<subseteq> \\<Union>\n               (keys `\n                {h \\<in> hom_components (q' f).\n                 poly_deg h + poly_deg f \\<noteq> poly_deg p})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "finally"], ["proof (chain)\npicking this:\n  s1 \\<in> \\<Union>\n            (keys `\n             {h \\<in> hom_components (q' f).\n              poly_deg h + poly_deg f \\<noteq> poly_deg p})", "obtain h where \"h \\<in> ?B f\" and \"s1 \\<in> keys h\""], ["proof (prove)\nusing this:\n  s1 \\<in> \\<Union>\n            (keys `\n             {h \\<in> hom_components (q' f).\n              poly_deg h + poly_deg f \\<noteq> poly_deg p})\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> {h \\<in> hom_components (q' f).\n                          poly_deg h + poly_deg f \\<noteq> poly_deg p};\n         s1 \\<in> keys h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  h \\<in> {h \\<in> hom_components (q' f).\n           poly_deg h + poly_deg f \\<noteq> poly_deg p}\n  s1 \\<in> keys h\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "from this(1)"], ["proof (chain)\npicking this:\n  h \\<in> {h \\<in> hom_components (q' f).\n           poly_deg h + poly_deg f \\<noteq> poly_deg p}", "have \"h \\<in> hom_components (q' f)\" and neq: \"poly_deg h + poly_deg f \\<noteq> poly_deg p\""], ["proof (prove)\nusing this:\n  h \\<in> {h \\<in> hom_components (q' f).\n           poly_deg h + poly_deg f \\<noteq> poly_deg p}\n\ngoal (1 subgoal):\n 1. h \\<in> hom_components (q' f) &&&\n    poly_deg h + poly_deg f \\<noteq> poly_deg p", "by simp_all"], ["proof (state)\nthis:\n  h \\<in> hom_components (q' f)\n  poly_deg h + poly_deg f \\<noteq> poly_deg p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "from this(1)"], ["proof (chain)\npicking this:\n  h \\<in> hom_components (q' f)", "have \"homogeneous h\""], ["proof (prove)\nusing this:\n  h \\<in> hom_components (q' f)\n\ngoal (1 subgoal):\n 1. homogeneous h", "by (rule hom_components_homogeneous)"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "hence \"deg_pm s1 = poly_deg h\""], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. deg_pm s1 = poly_deg h", "using \\<open>s1 \\<in> keys h\\<close>"], ["proof (prove)\nusing this:\n  homogeneous h\n  s1 \\<in> keys h\n\ngoal (1 subgoal):\n 1. deg_pm s1 = poly_deg h", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm s1 = poly_deg h\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "moreover"], ["proof (state)\nthis:\n  deg_pm s1 = poly_deg h\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "from \\<open>homogeneous f\\<close> \\<open>s2 \\<in> keys f\\<close>"], ["proof (chain)\npicking this:\n  homogeneous f\n  s2 \\<in> keys f", "have \"deg_pm s2 = poly_deg f\""], ["proof (prove)\nusing this:\n  homogeneous f\n  s2 \\<in> keys f\n\ngoal (1 subgoal):\n 1. deg_pm s2 = poly_deg f", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm s2 = poly_deg f\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm s1 = poly_deg h\n  deg_pm s2 = poly_deg f", "have \"deg_pm t \\<noteq> poly_deg p\""], ["proof (prove)\nusing this:\n  deg_pm s1 = poly_deg h\n  deg_pm s2 = poly_deg f\n\ngoal (1 subgoal):\n 1. deg_pm t \\<noteq> poly_deg p", "using neq"], ["proof (prove)\nusing this:\n  deg_pm s1 = poly_deg h\n  deg_pm s2 = poly_deg f\n  poly_deg h + poly_deg f \\<noteq> poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<noteq> poly_deg p", "by (simp add: t deg_pm_plus)"], ["proof (state)\nthis:\n  deg_pm t \\<noteq> poly_deg p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "have \"t \\<notin> keys (\\<Sum>f\\<in>F'. q f * f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> keys (\\<Sum>f\\<in>F'. q f * f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> keys (\\<Sum>f\\<in>F'. q f * f) \\<Longrightarrow> False", "assume \"t \\<in> keys (\\<Sum>f\\<in>F'. q f * f)\""], ["proof (state)\nthis:\n  t \\<in> keys (\\<Sum>f\\<in>F'. q f * f)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (\\<Sum>f\\<in>F'. q f * f) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  t \\<in> keys (\\<Sum>f\\<in>F'. q f * f)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (\\<Sum>f\\<in>F'. q f * f) \\<Longrightarrow> False", "have \"\\<dots> \\<subseteq> (\\<Union>f\\<in>F'. keys (q f * f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (\\<Sum>f\\<in>F'. q f * f)\n    \\<subseteq> (\\<Union>f\\<in>F'. keys (q f * f))", "by (fact keys_sum_subset)"], ["proof (state)\nthis:\n  keys (\\<Sum>f\\<in>F'. q f * f)\n  \\<subseteq> (\\<Union>f\\<in>F'. keys (q f * f))\n\ngoal (1 subgoal):\n 1. t \\<in> keys (\\<Sum>f\\<in>F'. q f * f) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  t \\<in> (\\<Union>f\\<in>F'. keys (q f * f))", "obtain f where \"f \\<in> F'\" and \"t \\<in> keys (q f * f)\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>f\\<in>F'. keys (q f * f))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F'; t \\<in> keys (q f * f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  f \\<in> F'\n  t \\<in> keys (q f * f)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (\\<Sum>f\\<in>F'. q f * f) \\<Longrightarrow> False", "hence \"deg_pm t = poly_deg p\""], ["proof (prove)\nusing this:\n  f \\<in> F'\n  t \\<in> keys (q f * f)\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule 2)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. t \\<in> keys (\\<Sum>f\\<in>F'. q f * f) \\<Longrightarrow> False", "with \\<open>deg_pm t \\<noteq> poly_deg p\\<close>"], ["proof (chain)\npicking this:\n  deg_pm t \\<noteq> poly_deg p\n  deg_pm t = poly_deg p", "show False"], ["proof (prove)\nusing this:\n  deg_pm t \\<noteq> poly_deg p\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<notin> keys (\\<Sum>f\\<in>F'. q f * f)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "with t_in"], ["proof (chain)\npicking this:\n  t \\<in> keys\n           (\\<Sum>f\\<in>F''.\n              \\<Sum>\n               {h \\<in> hom_components (q' f).\n                poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n              f)\n  t \\<notin> keys (\\<Sum>f\\<in>F'. q f * f)", "have \"t \\<in> keys ((\\<Sum>f\\<in>F'. q f * f) + (\\<Sum>f\\<in>F''. \\<Sum>(?B f) * f))\""], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (\\<Sum>f\\<in>F''.\n              \\<Sum>\n               {h \\<in> hom_components (q' f).\n                poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n              f)\n  t \\<notin> keys (\\<Sum>f\\<in>F'. q f * f)\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             ((\\<Sum>f\\<in>F'. q f * f) +\n              (\\<Sum>f\\<in>F''.\n                 \\<Sum>\n                  {h \\<in> hom_components (q' f).\n                   poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                 f))", "by (rule in_keys_plusI2)"], ["proof (state)\nthis:\n  t \\<in> keys\n           ((\\<Sum>f\\<in>F'. q f * f) +\n            (\\<Sum>f\\<in>F''.\n               \\<Sum>\n                {h \\<in> hom_components (q' f).\n                 poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n               f))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "hence \"t \\<in> keys p\""], ["proof (prove)\nusing this:\n  t \\<in> keys\n           ((\\<Sum>f\\<in>F'. q f * f) +\n            (\\<Sum>f\\<in>F''.\n               \\<Sum>\n                {h \\<in> hom_components (q' f).\n                 poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n               f))\n\ngoal (1 subgoal):\n 1. t \\<in> keys p", "by (simp only: p)"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "with assms(3)"], ["proof (chain)\npicking this:\n  homogeneous p\n  t \\<in> keys p", "have \"deg_pm t = poly_deg p\""], ["proof (prove)\nusing this:\n  homogeneous p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys\n                (\\<Sum>f\\<in>F''.\n                   \\<Sum>\n                    {h \\<in> hom_components (q' f).\n                     poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                   f) \\<Longrightarrow>\n       x \\<in> {}\n 2. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "with \\<open>deg_pm t \\<noteq> poly_deg p\\<close>"], ["proof (chain)\npicking this:\n  deg_pm t \\<noteq> poly_deg p\n  deg_pm t = poly_deg p", "show \"t \\<in> {}\""], ["proof (prove)\nusing this:\n  deg_pm t \\<noteq> poly_deg p\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. t \\<in> {}", ".."], ["proof (state)\nthis:\n  t \\<in> {}\n\ngoal (1 subgoal):\n 1. {} \\<subseteq> keys\n                    (\\<Sum>f\\<in>F''.\n                       \\<Sum>\n                        {h \\<in> hom_components (q' f).\n                         poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n                       f)", "qed (fact empty_subsetI)"], ["proof (state)\nthis:\n  keys\n   (\\<Sum>f\\<in>F''.\n      \\<Sum>\n       {h \\<in> hom_components (q' f).\n        poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n      f) =\n  {}\n\ngoal (4 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. homogeneous (?q f)\n 3. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (?q f * f) = poly_deg p\n 4. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>f\\<in>F'. q f * f) +\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f) =\n  p\n  keys\n   (\\<Sum>f\\<in>F''.\n      \\<Sum>\n       {h \\<in> hom_components (q' f).\n        poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n      f) =\n  {}", "show \"p = (\\<Sum>f\\<in>F'. q f * f)\""], ["proof (prove)\nusing this:\n  (\\<Sum>f\\<in>F'. q f * f) +\n  (\\<Sum>f\\<in>F''.\n     \\<Sum>\n      {h \\<in> hom_components (q' f).\n       poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n     f) =\n  p\n  keys\n   (\\<Sum>f\\<in>F''.\n      \\<Sum>\n       {h \\<in> hom_components (q' f).\n        poly_deg h + poly_deg f \\<noteq> poly_deg p} *\n      f) =\n  {}\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>f\\<in>F'. q f * f)", "by simp"], ["proof (state)\nthis:\n  p = (\\<Sum>f\\<in>F'. q f * f)\n\ngoal (3 subgoals):\n 1. \\<And>f. homogeneous (q f)\n 2. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p\n 3. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f. homogeneous (q f)\n 2. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p\n 3. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "fix f"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f. homogeneous (q f)\n 2. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p\n 3. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "show \"homogeneous (q f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous (q f)", "proof (cases \"f \\<in> F'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> F' \\<Longrightarrow> homogeneous (q f)\n 2. f \\<notin> F' \\<Longrightarrow> homogeneous (q f)", "case True"], ["proof (state)\nthis:\n  f \\<in> F'\n\ngoal (2 subgoals):\n 1. f \\<in> F' \\<Longrightarrow> homogeneous (q f)\n 2. f \\<notin> F' \\<Longrightarrow> homogeneous (q f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous (q f)", "proof (rule homogeneousI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (q f); t \\<in> keys (q f)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (q f); t \\<in> keys (q f)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "assume \"s \\<in> keys (q f)\""], ["proof (state)\nthis:\n  s \\<in> keys (q f)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (q f); t \\<in> keys (q f)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "with True"], ["proof (chain)\npicking this:\n  f \\<in> F'\n  s \\<in> keys (q f)", "have *: \"deg_pm s + poly_deg f = poly_deg p\""], ["proof (prove)\nusing this:\n  f \\<in> F'\n  s \\<in> keys (q f)\n\ngoal (1 subgoal):\n 1. deg_pm s + poly_deg f = poly_deg p", "by (rule 1)"], ["proof (state)\nthis:\n  deg_pm s + poly_deg f = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (q f); t \\<in> keys (q f)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "assume \"t \\<in> keys (q f)\""], ["proof (state)\nthis:\n  t \\<in> keys (q f)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (q f); t \\<in> keys (q f)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "with True"], ["proof (chain)\npicking this:\n  f \\<in> F'\n  t \\<in> keys (q f)", "have \"deg_pm t + poly_deg f = poly_deg p\""], ["proof (prove)\nusing this:\n  f \\<in> F'\n  t \\<in> keys (q f)\n\ngoal (1 subgoal):\n 1. deg_pm t + poly_deg f = poly_deg p", "by (rule 1)"], ["proof (state)\nthis:\n  deg_pm t + poly_deg f = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (q f); t \\<in> keys (q f)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "with *"], ["proof (chain)\npicking this:\n  deg_pm s + poly_deg f = poly_deg p\n  deg_pm t + poly_deg f = poly_deg p", "show \"deg_pm s = deg_pm t\""], ["proof (prove)\nusing this:\n  deg_pm s + poly_deg f = poly_deg p\n  deg_pm t + poly_deg f = poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm s = deg_pm t", "by simp"], ["proof (state)\nthis:\n  deg_pm s = deg_pm t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  homogeneous (q f)\n\ngoal (1 subgoal):\n 1. f \\<notin> F' \\<Longrightarrow> homogeneous (q f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<notin> F' \\<Longrightarrow> homogeneous (q f)", "case False"], ["proof (state)\nthis:\n  f \\<notin> F'\n\ngoal (1 subgoal):\n 1. f \\<notin> F' \\<Longrightarrow> homogeneous (q f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f \\<notin> F'\n\ngoal (1 subgoal):\n 1. homogeneous (q f)", "by (simp add: q_def)"], ["proof (state)\nthis:\n  homogeneous (q f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  homogeneous (q f)\n\ngoal (2 subgoals):\n 1. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p\n 2. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "assume \"f \\<in> F'\""], ["proof (state)\nthis:\n  f \\<in> F'\n\ngoal (2 subgoals):\n 1. \\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg p\n 2. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "show \"poly_deg (q f * f) = poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (q f * f) = poly_deg p", "proof (intro antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_deg (q f * f) \\<le> poly_deg p\n 2. poly_deg p \\<le> poly_deg (q f * f)", "show \"poly_deg (q f * f) \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (q f * f) \\<le> poly_deg p", "proof (rule poly_deg_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (q f * f) \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (q f * f) \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "assume \"t \\<in> keys (q f * f)\""], ["proof (state)\nthis:\n  t \\<in> keys (q f * f)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (q f * f) \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "with \\<open>f \\<in> F'\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F'\n  t \\<in> keys (q f * f)", "have \"deg_pm t = poly_deg p\""], ["proof (prove)\nusing this:\n  f \\<in> F'\n  t \\<in> keys (q f * f)\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule 2)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (q f * f) \\<Longrightarrow> deg_pm t \\<le> poly_deg p", "thus \"deg_pm t \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "by simp"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg (q f * f) \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (q f * f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (q f * f)", "from \\<open>f \\<in> F'\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F'", "have \"q f * f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<in> F'\n\ngoal (1 subgoal):\n 1. q f * f \\<noteq> 0", "by (simp add: q_def F'_def)"], ["proof (state)\nthis:\n  q f * f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (q f * f)", "hence \"keys (q f * f) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  q f * f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys (q f * f) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys (q f * f) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (q f * f)", "then"], ["proof (chain)\npicking this:\n  keys (q f * f) \\<noteq> {}", "obtain t where \"t \\<in> keys (q f * f)\""], ["proof (prove)\nusing this:\n  keys (q f * f) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> keys (q f * f) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> keys (q f * f)\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (q f * f)", "with \\<open>f \\<in> F'\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F'\n  t \\<in> keys (q f * f)", "have \"deg_pm t = poly_deg p\""], ["proof (prove)\nusing this:\n  f \\<in> F'\n  t \\<in> keys (q f * f)\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule 2)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (q f * f)", "moreover"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (q f * f)", "from \\<open>t \\<in> keys (q f * f)\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys (q f * f)", "have \"deg_pm t \\<le> poly_deg (q f * f)\""], ["proof (prove)\nusing this:\n  t \\<in> keys (q f * f)\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg (q f * f)", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg (q f * f)\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (q f * f)", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm t = poly_deg p\n  deg_pm t \\<le> poly_deg (q f * f)", "show \"poly_deg p \\<le> poly_deg (q f * f)\""], ["proof (prove)\nusing this:\n  deg_pm t = poly_deg p\n  deg_pm t \\<le> poly_deg (q f * f)\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (q f * f)", "by simp"], ["proof (state)\nthis:\n  poly_deg p \\<le> poly_deg (q f * f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg (q f * f) = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "qed (simp add: q_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary homogeneous_idealE:\n  assumes \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"p \\<in> ideal F\"\n  obtains F' q where \"finite F'\" and \"F' \\<subseteq> F\" and \"p = (\\<Sum>f\\<in>F'. q f * f)\"\n    and \"\\<And>f. poly_deg (q f * f) \\<le> poly_deg p\" and \"\\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. finite ?F'\n 2. ?F' \\<subseteq> F\n 3. p = (\\<Sum>f\\<in>?F'. ?q f * f)\n 4. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 5. \\<And>f. f \\<notin> ?F' \\<Longrightarrow> ?q f = 0", "show \"p = (\\<Sum>f\\<in>{}. (\\<lambda>_. 0) f * f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = sum ((*) 0) {}", "by (simp add: True)"], ["proof (state)\nthis:\n  p = sum ((*) 0) {}\n\ngoal (4 subgoals):\n 1. finite {}\n 2. {} \\<subseteq> F\n 3. \\<And>f. poly_deg (0 * f) \\<le> poly_deg p\n 4. \\<And>f. f \\<notin> {} \\<Longrightarrow> 0 = 0", "qed simp_all"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "define P where \"P = (\\<lambda>h qf. finite (fst qf) \\<and> fst qf \\<subseteq> F \\<and> h = (\\<Sum>f\\<in>fst qf. snd qf f * f) \\<and>\n                  (\\<forall>f\\<in>fst qf. poly_deg (snd qf f * f) = poly_deg h) \\<and> (\\<forall>f. f \\<notin> fst qf \\<longrightarrow> snd qf f = 0))\""], ["proof (state)\nthis:\n  P =\n  (\\<lambda>h qf.\n      finite (fst qf) \\<and>\n      fst qf \\<subseteq> F \\<and>\n      h = (\\<Sum>f\\<in>fst qf. snd qf f * f) \\<and>\n      (\\<forall>f\\<in>fst qf. poly_deg (snd qf f * f) = poly_deg h) \\<and>\n      (\\<forall>f. f \\<notin> fst qf \\<longrightarrow> snd qf f = 0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "define q0 where \"q0 = (\\<lambda>h. SOME qf. P h qf)\""], ["proof (state)\nthis:\n  q0 = (\\<lambda>h. SOME qf. P h qf)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have 1: \"P h (q0 h)\" if \"h \\<in> hom_components p\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. P h (q0 h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P h (q0 h)", "note assms(1)"], ["proof (state)\nthis:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "moreover"], ["proof (state)\nthis:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "from assms that"], ["proof (chain)\npicking this:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f\n  p \\<in> ideal F\n  h \\<in> hom_components p", "have \"h \\<in> ideal F\""], ["proof (prove)\nusing this:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f\n  p \\<in> ideal F\n  h \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. h \\<in> ideal F", "by (rule homogeneous_ideal')"], ["proof (state)\nthis:\n  h \\<in> ideal F\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "moreover"], ["proof (state)\nthis:\n  h \\<in> ideal F\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "from that"], ["proof (chain)\npicking this:\n  h \\<in> hom_components p", "have \"homogeneous h\""], ["proof (prove)\nusing this:\n  h \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. homogeneous h", "by (rule hom_components_homogeneous)"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "ultimately"], ["proof (chain)\npicking this:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f\n  h \\<in> ideal F\n  homogeneous h", "obtain F' q where \"finite F'\" and \"F' \\<subseteq> F\" and \"h = (\\<Sum>f\\<in>F'. q f * f)\"\n      and \"\\<And>f. f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg h\" and \"\\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\""], ["proof (prove)\nusing this:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f\n  h \\<in> ideal F\n  homogeneous h\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F'; F' \\<subseteq> F; h = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f.\n            f \\<in> F' \\<Longrightarrow> poly_deg (q f * f) = poly_deg h;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule homogeneous_idealE_homogeneous) blast+"], ["proof (state)\nthis:\n  finite F'\n  F' \\<subseteq> F\n  h = (\\<Sum>f\\<in>F'. q f * f)\n  ?f \\<in> F' \\<Longrightarrow> poly_deg (q ?f * ?f) = poly_deg h\n  ?f \\<notin> F' \\<Longrightarrow> q ?f = 0\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "hence \"P h (F', q)\""], ["proof (prove)\nusing this:\n  finite F'\n  F' \\<subseteq> F\n  h = (\\<Sum>f\\<in>F'. q f * f)\n  ?f \\<in> F' \\<Longrightarrow> poly_deg (q ?f * ?f) = poly_deg h\n  ?f \\<notin> F' \\<Longrightarrow> q ?f = 0\n\ngoal (1 subgoal):\n 1. P h (F', q)", "by (simp add: P_def)"], ["proof (state)\nthis:\n  P h (F', q)\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P h (F', q)\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "unfolding q0_def"], ["proof (prove)\nusing this:\n  P h (F', q)\n\ngoal (1 subgoal):\n 1. P h (Eps (P h))", "by (rule someI)"], ["proof (state)\nthis:\n  P h (q0 h)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?h \\<in> hom_components p \\<Longrightarrow> P ?h (q0 ?h)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "define F' where \"F' = (\\<Union>h\\<in>hom_components p. fst (q0 h))\""], ["proof (state)\nthis:\n  F' = (\\<Union>h\\<in>hom_components p. fst (q0 h))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "define q where \"q = (\\<lambda>f. \\<Sum>h\\<in>hom_components p. snd (q0 h) f)\""], ["proof (state)\nthis:\n  q = (\\<lambda>f. \\<Sum>h\\<in>hom_components p. snd (q0 h) f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>F' q.\n                \\<lbrakk>finite F'; F' \\<subseteq> F;\n                 p = (\\<Sum>f\\<in>F'. q f * f);\n                 \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n                 \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. finite ?F'\n 2. ?F' \\<subseteq> F\n 3. p = (\\<Sum>f\\<in>?F'. ?q f * f)\n 4. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 5. \\<And>f. f \\<notin> ?F' \\<Longrightarrow> ?q f = 0", "have \"finite F' \\<and> F' \\<subseteq> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite F' \\<and> F' \\<subseteq> F", "unfolding F'_def UN_subset_iff finite_UN[OF finite_hom_components]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>hom_components p. finite (fst (q0 x))) \\<and>\n    (\\<forall>i\\<in>hom_components p. fst (q0 i) \\<subseteq> F)", "proof (intro conjI ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> hom_components p \\<Longrightarrow> finite (fst (q0 x))\n 2. \\<And>i.\n       i \\<in> hom_components p \\<Longrightarrow> fst (q0 i) \\<subseteq> F", "fix h"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> hom_components p \\<Longrightarrow> finite (fst (q0 x))\n 2. \\<And>i.\n       i \\<in> hom_components p \\<Longrightarrow> fst (q0 i) \\<subseteq> F", "assume \"h \\<in> hom_components p\""], ["proof (state)\nthis:\n  h \\<in> hom_components p\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> hom_components p \\<Longrightarrow> finite (fst (q0 x))\n 2. \\<And>i.\n       i \\<in> hom_components p \\<Longrightarrow> fst (q0 i) \\<subseteq> F", "hence \"P h (q0 h)\""], ["proof (prove)\nusing this:\n  h \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "by (rule 1)"], ["proof (state)\nthis:\n  P h (q0 h)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> hom_components p \\<Longrightarrow> finite (fst (q0 x))\n 2. \\<And>i.\n       i \\<in> hom_components p \\<Longrightarrow> fst (q0 i) \\<subseteq> F", "thus \"finite (fst (q0 h))\" and \"fst (q0 h) \\<subseteq> F\""], ["proof (prove)\nusing this:\n  P h (q0 h)\n\ngoal (1 subgoal):\n 1. finite (fst (q0 h)) &&& fst (q0 h) \\<subseteq> F", "by (simp_all only: P_def)"], ["proof (state)\nthis:\n  finite (fst (q0 h))\n  fst (q0 h) \\<subseteq> F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite F' \\<and> F' \\<subseteq> F\n\ngoal (5 subgoals):\n 1. finite ?F'\n 2. ?F' \\<subseteq> F\n 3. p = (\\<Sum>f\\<in>?F'. ?q f * f)\n 4. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 5. \\<And>f. f \\<notin> ?F' \\<Longrightarrow> ?q f = 0", "thus \"finite F'\" and \"F' \\<subseteq> F\""], ["proof (prove)\nusing this:\n  finite F' \\<and> F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. finite F' &&& F' \\<subseteq> F", "by simp_all"], ["proof (state)\nthis:\n  finite F'\n  F' \\<subseteq> F\n\ngoal (3 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 3. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "from sum_hom_components"], ["proof (chain)\npicking this:\n  \\<Sum> (hom_components ?p) = ?p", "have \"p = (\\<Sum>(hom_components p))\""], ["proof (prove)\nusing this:\n  \\<Sum> (hom_components ?p) = ?p\n\ngoal (1 subgoal):\n 1. p = \\<Sum> (hom_components p)", "by (rule sym)"], ["proof (state)\nthis:\n  p = \\<Sum> (hom_components p)\n\ngoal (3 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 3. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "also"], ["proof (state)\nthis:\n  p = \\<Sum> (hom_components p)\n\ngoal (3 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 3. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"\\<dots> = (\\<Sum>h\\<in>hom_components p. \\<Sum>f\\<in>F'. snd (q0 h) f * f)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. \\<Sum> (hom_components p) =\n    (\\<Sum>h\\<in>hom_components p. \\<Sum>f\\<in>F'. snd (q0 h) f * f)", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p \\<Longrightarrow>\n       x = (\\<Sum>f\\<in>F'. snd (q0 x) f * f)", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p \\<Longrightarrow>\n       x = (\\<Sum>f\\<in>F'. snd (q0 x) f * f)", "assume \"h \\<in> hom_components p\""], ["proof (state)\nthis:\n  h \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p \\<Longrightarrow>\n       x = (\\<Sum>f\\<in>F'. snd (q0 x) f * f)", "hence \"P h (q0 h)\""], ["proof (prove)\nusing this:\n  h \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "by (rule 1)"], ["proof (state)\nthis:\n  P h (q0 h)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p \\<Longrightarrow>\n       x = (\\<Sum>f\\<in>F'. snd (q0 x) f * f)", "hence \"h = (\\<Sum>f\\<in>fst (q0 h). snd (q0 h) f * f)\" and 2: \"\\<And>f. f \\<notin> fst (q0 h) \\<Longrightarrow> snd (q0 h) f = 0\""], ["proof (prove)\nusing this:\n  P h (q0 h)\n\ngoal (1 subgoal):\n 1. h = (\\<Sum>f\\<in>fst (q0 h). snd (q0 h) f * f) &&&\n    (\\<And>f. f \\<notin> fst (q0 h) \\<Longrightarrow> snd (q0 h) f = 0)", "by (simp_all add: P_def)"], ["proof (state)\nthis:\n  h = (\\<Sum>f\\<in>fst (q0 h). snd (q0 h) f * f)\n  ?f \\<notin> fst (q0 h) \\<Longrightarrow> snd (q0 h) ?f = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p \\<Longrightarrow>\n       x = (\\<Sum>f\\<in>F'. snd (q0 x) f * f)", "note this(1)"], ["proof (state)\nthis:\n  h = (\\<Sum>f\\<in>fst (q0 h). snd (q0 h) f * f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p \\<Longrightarrow>\n       x = (\\<Sum>f\\<in>F'. snd (q0 x) f * f)", "also"], ["proof (state)\nthis:\n  h = (\\<Sum>f\\<in>fst (q0 h). snd (q0 h) f * f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p \\<Longrightarrow>\n       x = (\\<Sum>f\\<in>F'. snd (q0 x) f * f)", "from \\<open>finite F'\\<close>"], ["proof (chain)\npicking this:\n  finite F'", "have \"(\\<Sum>f\\<in>fst (q0 h). (snd (q0 h)) f * f) = (\\<Sum>f\\<in>F'. snd (q0 h) f * f)\""], ["proof (prove)\nusing this:\n  finite F'\n\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>fst (q0 h). snd (q0 h) f * f) =\n    (\\<Sum>f\\<in>F'. snd (q0 h) f * f)", "proof (intro sum.mono_neutral_left ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite F' \\<Longrightarrow> finite F'\n 2. finite F' \\<Longrightarrow> fst (q0 h) \\<subseteq> F'\n 3. \\<And>i.\n       \\<lbrakk>finite F'; i \\<in> F' - fst (q0 h)\\<rbrakk>\n       \\<Longrightarrow> snd (q0 h) i * i = 0", "show \"fst (q0 h) \\<subseteq> F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (q0 h) \\<subseteq> F'", "unfolding F'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (q0 h) \\<subseteq> (\\<Union>h\\<in>hom_components p. fst (q0 h))", "using \\<open>h \\<in> hom_components p\\<close>"], ["proof (prove)\nusing this:\n  h \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. fst (q0 h) \\<subseteq> (\\<Union>h\\<in>hom_components p. fst (q0 h))", "by blast"], ["proof (state)\nthis:\n  fst (q0 h) \\<subseteq> F'\n\ngoal (2 subgoals):\n 1. finite F' \\<Longrightarrow> finite F'\n 2. \\<And>i.\n       \\<lbrakk>finite F'; i \\<in> F' - fst (q0 h)\\<rbrakk>\n       \\<Longrightarrow> snd (q0 h) i * i = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. finite F' \\<Longrightarrow> finite F'\n 2. \\<And>i.\n       \\<lbrakk>finite F'; i \\<in> F' - fst (q0 h)\\<rbrakk>\n       \\<Longrightarrow> snd (q0 h) i * i = 0", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. finite F' \\<Longrightarrow> finite F'\n 2. \\<And>i.\n       \\<lbrakk>finite F'; i \\<in> F' - fst (q0 h)\\<rbrakk>\n       \\<Longrightarrow> snd (q0 h) i * i = 0", "assume \"f \\<in> F' - fst (q0 h)\""], ["proof (state)\nthis:\n  f \\<in> F' - fst (q0 h)\n\ngoal (2 subgoals):\n 1. finite F' \\<Longrightarrow> finite F'\n 2. \\<And>i.\n       \\<lbrakk>finite F'; i \\<in> F' - fst (q0 h)\\<rbrakk>\n       \\<Longrightarrow> snd (q0 h) i * i = 0", "hence \"f \\<notin> fst (q0 h)\""], ["proof (prove)\nusing this:\n  f \\<in> F' - fst (q0 h)\n\ngoal (1 subgoal):\n 1. f \\<notin> fst (q0 h)", "by simp"], ["proof (state)\nthis:\n  f \\<notin> fst (q0 h)\n\ngoal (2 subgoals):\n 1. finite F' \\<Longrightarrow> finite F'\n 2. \\<And>i.\n       \\<lbrakk>finite F'; i \\<in> F' - fst (q0 h)\\<rbrakk>\n       \\<Longrightarrow> snd (q0 h) i * i = 0", "hence \"snd (q0 h) f = 0\""], ["proof (prove)\nusing this:\n  f \\<notin> fst (q0 h)\n\ngoal (1 subgoal):\n 1. snd (q0 h) f = 0", "by (rule 2)"], ["proof (state)\nthis:\n  snd (q0 h) f = 0\n\ngoal (2 subgoals):\n 1. finite F' \\<Longrightarrow> finite F'\n 2. \\<And>i.\n       \\<lbrakk>finite F'; i \\<in> F' - fst (q0 h)\\<rbrakk>\n       \\<Longrightarrow> snd (q0 h) i * i = 0", "thus \"snd (q0 h) f * f = 0\""], ["proof (prove)\nusing this:\n  snd (q0 h) f = 0\n\ngoal (1 subgoal):\n 1. snd (q0 h) f * f = 0", "by simp"], ["proof (state)\nthis:\n  snd (q0 h) f * f = 0\n\ngoal (1 subgoal):\n 1. finite F' \\<Longrightarrow> finite F'", "qed"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>fst (q0 h). snd (q0 h) f * f) =\n  (\\<Sum>f\\<in>F'. snd (q0 h) f * f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom_components p \\<Longrightarrow>\n       x = (\\<Sum>f\\<in>F'. snd (q0 x) f * f)", "finally"], ["proof (chain)\npicking this:\n  h = (\\<Sum>f\\<in>F'. snd (q0 h) f * f)", "show \"h = (\\<Sum>f\\<in>F'. snd (q0 h) f * f)\""], ["proof (prove)\nusing this:\n  h = (\\<Sum>f\\<in>F'. snd (q0 h) f * f)\n\ngoal (1 subgoal):\n 1. h = (\\<Sum>f\\<in>F'. snd (q0 h) f * f)", "."], ["proof (state)\nthis:\n  h = (\\<Sum>f\\<in>F'. snd (q0 h) f * f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Sum> (hom_components p) =\n  (\\<Sum>h\\<in>hom_components p. \\<Sum>f\\<in>F'. snd (q0 h) f * f)\n\ngoal (3 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 3. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "also"], ["proof (state)\nthis:\n  \\<Sum> (hom_components p) =\n  (\\<Sum>h\\<in>hom_components p. \\<Sum>f\\<in>F'. snd (q0 h) f * f)\n\ngoal (3 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 3. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "have \"\\<dots> = (\\<Sum>f\\<in>F'. \\<Sum>h\\<in>hom_components p. snd (q0 h) f * f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>h\\<in>hom_components p. \\<Sum>f\\<in>F'. snd (q0 h) f * f) =\n    (\\<Sum>f\\<in>F'. \\<Sum>h\\<in>hom_components p. snd (q0 h) f * f)", "by (rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>h\\<in>hom_components p. \\<Sum>f\\<in>F'. snd (q0 h) f * f) =\n  (\\<Sum>f\\<in>F'. \\<Sum>h\\<in>hom_components p. snd (q0 h) f * f)\n\ngoal (3 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 3. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>h\\<in>hom_components p. \\<Sum>f\\<in>F'. snd (q0 h) f * f) =\n  (\\<Sum>f\\<in>F'. \\<Sum>h\\<in>hom_components p. snd (q0 h) f * f)\n\ngoal (3 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 3. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "have \"\\<dots> = (\\<Sum>f\\<in>F'. q f * f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>F'. \\<Sum>h\\<in>hom_components p. snd (q0 h) f * f) =\n    (\\<Sum>f\\<in>F'. q f * f)", "by (simp only: q_def sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>F'. \\<Sum>h\\<in>hom_components p. snd (q0 h) f * f) =\n  (\\<Sum>f\\<in>F'. q f * f)\n\ngoal (3 subgoals):\n 1. p = (\\<Sum>f\\<in>F'. ?q f * f)\n 2. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 3. \\<And>f. f \\<notin> F' \\<Longrightarrow> ?q f = 0", "finally"], ["proof (chain)\npicking this:\n  p = (\\<Sum>f\\<in>F'. q f * f)", "show \"p = (\\<Sum>f\\<in>F'. q f * f)\""], ["proof (prove)\nusing this:\n  p = (\\<Sum>f\\<in>F'. q f * f)\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>f\\<in>F'. q f * f)", "."], ["proof (state)\nthis:\n  p = (\\<Sum>f\\<in>F'. q f * f)\n\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "have \"poly_deg (q f * f) = poly_deg (\\<Sum>h\\<in>hom_components p. snd (q0 h) f * f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (q f * f) =\n    poly_deg (\\<Sum>h\\<in>hom_components p. snd (q0 h) f * f)", "by (simp only: q_def sum_distrib_right)"], ["proof (state)\nthis:\n  poly_deg (q f * f) =\n  poly_deg (\\<Sum>h\\<in>hom_components p. snd (q0 h) f * f)\n\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "also"], ["proof (state)\nthis:\n  poly_deg (q f * f) =\n  poly_deg (\\<Sum>h\\<in>hom_components p. snd (q0 h) f * f)\n\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "have \"\\<dots> \\<le> Max (poly_deg ` (\\<lambda>h. snd (q0 h) f * f) ` hom_components p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (\\<Sum>h\\<in>hom_components p. snd (q0 h) f * f)\n    \\<le> Max (poly_deg ` (\\<lambda>h. snd (q0 h) f * f) ` hom_components p)", "by (rule poly_deg_sum_le)"], ["proof (state)\nthis:\n  poly_deg (\\<Sum>h\\<in>hom_components p. snd (q0 h) f * f)\n  \\<le> Max (poly_deg ` (\\<lambda>h. snd (q0 h) f * f) ` hom_components p)\n\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "also"], ["proof (state)\nthis:\n  poly_deg (\\<Sum>h\\<in>hom_components p. snd (q0 h) f * f)\n  \\<le> Max (poly_deg ` (\\<lambda>h. snd (q0 h) f * f) ` hom_components p)\n\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "have \"\\<dots> = Max ((\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p)\"\n      (is \"_ = Max (?f ` _)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` (\\<lambda>h. snd (q0 h) f * f) ` hom_components p) =\n    (MAX h\\<in>hom_components p. poly_deg (snd (q0 h) f * f))", "by (simp only: image_image)"], ["proof (state)\nthis:\n  Max (poly_deg ` (\\<lambda>h. snd (q0 h) f * f) ` hom_components p) =\n  (MAX h\\<in>hom_components p. poly_deg (snd (q0 h) f * f))\n\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "also"], ["proof (state)\nthis:\n  Max (poly_deg ` (\\<lambda>h. snd (q0 h) f * f) ` hom_components p) =\n  (MAX h\\<in>hom_components p. poly_deg (snd (q0 h) f * f))\n\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "have \"\\<dots> \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX h\\<in>hom_components p. poly_deg (snd (q0 h) f * f))\n    \\<le> poly_deg p", "proof (rule Max.boundedI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite ((\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p)\n 2. (\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p \\<noteq> {}\n 3. \\<And>a.\n       a \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) `\n               hom_components p \\<Longrightarrow>\n       a \\<le> poly_deg p", "from finite_hom_components"], ["proof (chain)\npicking this:\n  finite (hom_components ?p)", "show \"finite (?f ` hom_components p)\""], ["proof (prove)\nusing this:\n  finite (hom_components ?p)\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite ((\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p)\n\ngoal (2 subgoals):\n 1. (\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p \\<noteq> {}\n 2. \\<And>a.\n       a \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) `\n               hom_components p \\<Longrightarrow>\n       a \\<le> poly_deg p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p \\<noteq> {}\n 2. \\<And>a.\n       a \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) `\n               hom_components p \\<Longrightarrow>\n       a \\<le> poly_deg p", "from False"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "show \"?f ` hom_components p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) `\n               hom_components p \\<Longrightarrow>\n       a \\<le> poly_deg p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) `\n               hom_components p \\<Longrightarrow>\n       a \\<le> poly_deg p", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) `\n               hom_components p \\<Longrightarrow>\n       a \\<le> poly_deg p", "assume \"d \\<in> ?f ` hom_components p\""], ["proof (state)\nthis:\n  d \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) `\n               hom_components p \\<Longrightarrow>\n       a \\<le> poly_deg p", "then"], ["proof (chain)\npicking this:\n  d \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p", "obtain h where \"h \\<in> hom_components p\" and d: \"d = ?f h\""], ["proof (prove)\nusing this:\n  d \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) ` hom_components p\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> hom_components p;\n         d = poly_deg (snd (q0 h) f * f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  h \\<in> hom_components p\n  d = poly_deg (snd (q0 h) f * f)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) `\n               hom_components p \\<Longrightarrow>\n       a \\<le> poly_deg p", "from this(1)"], ["proof (chain)\npicking this:\n  h \\<in> hom_components p", "have \"P h (q0 h)\""], ["proof (prove)\nusing this:\n  h \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "by (rule 1)"], ["proof (state)\nthis:\n  P h (q0 h)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) `\n               hom_components p \\<Longrightarrow>\n       a \\<le> poly_deg p", "hence 2: \"\\<And>f. f \\<in> fst (q0 h) \\<Longrightarrow> poly_deg (snd (q0 h) f * f) = poly_deg h\"\n        and 3: \"\\<And>f. f \\<notin> fst (q0 h) \\<Longrightarrow> snd (q0 h) f = 0\""], ["proof (prove)\nusing this:\n  P h (q0 h)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        f \\<in> fst (q0 h) \\<Longrightarrow>\n        poly_deg (snd (q0 h) f * f) = poly_deg h) &&&\n    (\\<And>f. f \\<notin> fst (q0 h) \\<Longrightarrow> snd (q0 h) f = 0)", "by (simp_all add: P_def)"], ["proof (state)\nthis:\n  ?f \\<in> fst (q0 h) \\<Longrightarrow>\n  poly_deg (snd (q0 h) ?f * ?f) = poly_deg h\n  ?f \\<notin> fst (q0 h) \\<Longrightarrow> snd (q0 h) ?f = 0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> (\\<lambda>h. poly_deg (snd (q0 h) f * f)) `\n               hom_components p \\<Longrightarrow>\n       a \\<le> poly_deg p", "show \"d \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> poly_deg p", "proof (cases \"f \\<in> fst (q0 h)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p\n 2. f \\<notin> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p", "case True"], ["proof (state)\nthis:\n  f \\<in> fst (q0 h)\n\ngoal (2 subgoals):\n 1. f \\<in> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p\n 2. f \\<notin> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p", "hence \"poly_deg (snd (q0 h) f * f) = poly_deg h\""], ["proof (prove)\nusing this:\n  f \\<in> fst (q0 h)\n\ngoal (1 subgoal):\n 1. poly_deg (snd (q0 h) f * f) = poly_deg h", "by (rule 2)"], ["proof (state)\nthis:\n  poly_deg (snd (q0 h) f * f) = poly_deg h\n\ngoal (2 subgoals):\n 1. f \\<in> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p\n 2. f \\<notin> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p", "hence \"d = poly_deg h\""], ["proof (prove)\nusing this:\n  poly_deg (snd (q0 h) f * f) = poly_deg h\n\ngoal (1 subgoal):\n 1. d = poly_deg h", "by (simp only: d)"], ["proof (state)\nthis:\n  d = poly_deg h\n\ngoal (2 subgoals):\n 1. f \\<in> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p\n 2. f \\<notin> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p", "also"], ["proof (state)\nthis:\n  d = poly_deg h\n\ngoal (2 subgoals):\n 1. f \\<in> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p\n 2. f \\<notin> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p", "from \\<open>h \\<in> hom_components p\\<close>"], ["proof (chain)\npicking this:\n  h \\<in> hom_components p", "have \"\\<dots> \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  h \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. poly_deg h \\<le> poly_deg p", "by (rule poly_deg_hom_components_le)"], ["proof (state)\nthis:\n  poly_deg h \\<le> poly_deg p\n\ngoal (2 subgoals):\n 1. f \\<in> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p\n 2. f \\<notin> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p", "finally"], ["proof (chain)\npicking this:\n  d \\<le> poly_deg p", "show ?thesis"], ["proof (prove)\nusing this:\n  d \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. d \\<le> poly_deg p", "."], ["proof (state)\nthis:\n  d \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. f \\<notin> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<notin> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p", "case False"], ["proof (state)\nthis:\n  f \\<notin> fst (q0 h)\n\ngoal (1 subgoal):\n 1. f \\<notin> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p", "hence \"snd (q0 h) f = 0\""], ["proof (prove)\nusing this:\n  f \\<notin> fst (q0 h)\n\ngoal (1 subgoal):\n 1. snd (q0 h) f = 0", "by (rule 3)"], ["proof (state)\nthis:\n  snd (q0 h) f = 0\n\ngoal (1 subgoal):\n 1. f \\<notin> fst (q0 h) \\<Longrightarrow> d \\<le> poly_deg p", "thus ?thesis"], ["proof (prove)\nusing this:\n  snd (q0 h) f = 0\n\ngoal (1 subgoal):\n 1. d \\<le> poly_deg p", "by (simp add: d)"], ["proof (state)\nthis:\n  d \\<le> poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d \\<le> poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (MAX h\\<in>hom_components p. poly_deg (snd (q0 h) f * f)) \\<le> poly_deg p\n\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "finally"], ["proof (chain)\npicking this:\n  poly_deg (q f * f) \\<le> poly_deg p", "show \"poly_deg (q f * f) \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  poly_deg (q f * f) \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg (q f * f) \\<le> poly_deg p", "."], ["proof (state)\nthis:\n  poly_deg (q f * f) \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "assume \"f \\<notin> F'\""], ["proof (state)\nthis:\n  f \\<notin> F'\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0", "show \"q f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q f = 0", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>h\\<in>hom_components p. snd (q0 h) f) = 0", "proof (intro sum.neutral ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom_components p \\<Longrightarrow> snd (q0 x) f = 0", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom_components p \\<Longrightarrow> snd (q0 x) f = 0", "assume \"h \\<in> hom_components p\""], ["proof (state)\nthis:\n  h \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom_components p \\<Longrightarrow> snd (q0 x) f = 0", "hence \"P h (q0 h)\""], ["proof (prove)\nusing this:\n  h \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. P h (q0 h)", "by (rule 1)"], ["proof (state)\nthis:\n  P h (q0 h)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom_components p \\<Longrightarrow> snd (q0 x) f = 0", "hence 2: \"\\<And>f. f \\<notin> fst (q0 h) \\<Longrightarrow> snd (q0 h) f = 0\""], ["proof (prove)\nusing this:\n  P h (q0 h)\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<notin> fst (q0 h) \\<Longrightarrow> snd (q0 h) f = 0", "by (simp add: P_def)"], ["proof (state)\nthis:\n  ?f \\<notin> fst (q0 h) \\<Longrightarrow> snd (q0 h) ?f = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom_components p \\<Longrightarrow> snd (q0 x) f = 0", "show \"snd (q0 h) f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (q0 h) f = 0", "proof (intro 2 notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> fst (q0 h) \\<Longrightarrow> False", "assume \"f \\<in> fst (q0 h)\""], ["proof (state)\nthis:\n  f \\<in> fst (q0 h)\n\ngoal (1 subgoal):\n 1. f \\<in> fst (q0 h) \\<Longrightarrow> False", "hence \"f \\<in> F'\""], ["proof (prove)\nusing this:\n  f \\<in> fst (q0 h)\n\ngoal (1 subgoal):\n 1. f \\<in> F'", "unfolding F'_def"], ["proof (prove)\nusing this:\n  f \\<in> fst (q0 h)\n\ngoal (1 subgoal):\n 1. f \\<in> (\\<Union>h\\<in>hom_components p. fst (q0 h))", "using \\<open>h \\<in> hom_components p\\<close>"], ["proof (prove)\nusing this:\n  f \\<in> fst (q0 h)\n  h \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. f \\<in> (\\<Union>h\\<in>hom_components p. fst (q0 h))", "by blast"], ["proof (state)\nthis:\n  f \\<in> F'\n\ngoal (1 subgoal):\n 1. f \\<in> fst (q0 h) \\<Longrightarrow> False", "with \\<open>f \\<notin> F'\\<close>"], ["proof (chain)\npicking this:\n  f \\<notin> F'\n  f \\<in> F'", "show False"], ["proof (prove)\nusing this:\n  f \\<notin> F'\n  f \\<in> F'\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (q0 h) f = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q f = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary homogeneous_idealE_finite:\n  assumes \"finite F\" and \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"p \\<in> ideal F\"\n  obtains q where \"p = (\\<Sum>f\\<in>F. q f * f)\" and \"\\<And>f. poly_deg (q f * f) \\<le> poly_deg p\"\n    and \"\\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>p = (\\<Sum>f\\<in>F. q f * f);\n         \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n         \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>p = (\\<Sum>f\\<in>F. q f * f);\n         \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n         \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(2, 3)"], ["proof (chain)\npicking this:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f\n  p \\<in> ideal F", "obtain F' q where \"F' \\<subseteq> F\" and p: \"p = (\\<Sum>f\\<in>F'. q f * f)\"\n    and \"\\<And>f. poly_deg (q f * f) \\<le> poly_deg p\" and 1: \"\\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\""], ["proof (prove)\nusing this:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f\n  p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>F' \\<subseteq> F; p = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule homogeneous_idealE) blast+"], ["proof (state)\nthis:\n  F' \\<subseteq> F\n  p = (\\<Sum>f\\<in>F'. q f * f)\n  poly_deg (q ?f * ?f) \\<le> poly_deg p\n  ?f \\<notin> F' \\<Longrightarrow> q ?f = 0\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>p = (\\<Sum>f\\<in>F. q f * f);\n         \\<And>f. poly_deg (q f * f) \\<le> poly_deg p;\n         \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. p = (\\<Sum>f\\<in>F. ?q f * f)\n 2. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 3. \\<And>f. f \\<notin> F \\<Longrightarrow> ?q f = 0", "from assms(1) \\<open>F' \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  finite F\n  F' \\<subseteq> F", "have \"(\\<Sum>f\\<in>F'. q f * f) = (\\<Sum>f\\<in>F. q f * f)\""], ["proof (prove)\nusing this:\n  finite F\n  F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>F'. q f * f) = (\\<Sum>f\\<in>F. q f * f)", "proof (intro sum.mono_neutral_left ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F\n 3. \\<And>i.\n       \\<lbrakk>finite F; F' \\<subseteq> F; i \\<in> F - F'\\<rbrakk>\n       \\<Longrightarrow> q i * i = 0", "fix f"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F\n 3. \\<And>i.\n       \\<lbrakk>finite F; F' \\<subseteq> F; i \\<in> F - F'\\<rbrakk>\n       \\<Longrightarrow> q i * i = 0", "assume \"f \\<in> F - F'\""], ["proof (state)\nthis:\n  f \\<in> F - F'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F\n 3. \\<And>i.\n       \\<lbrakk>finite F; F' \\<subseteq> F; i \\<in> F - F'\\<rbrakk>\n       \\<Longrightarrow> q i * i = 0", "hence \"f \\<notin> F'\""], ["proof (prove)\nusing this:\n  f \\<in> F - F'\n\ngoal (1 subgoal):\n 1. f \\<notin> F'", "by simp"], ["proof (state)\nthis:\n  f \\<notin> F'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F\n 3. \\<And>i.\n       \\<lbrakk>finite F; F' \\<subseteq> F; i \\<in> F - F'\\<rbrakk>\n       \\<Longrightarrow> q i * i = 0", "hence \"q f = 0\""], ["proof (prove)\nusing this:\n  f \\<notin> F'\n\ngoal (1 subgoal):\n 1. q f = 0", "by (rule 1)"], ["proof (state)\nthis:\n  q f = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F\n 3. \\<And>i.\n       \\<lbrakk>finite F; F' \\<subseteq> F; i \\<in> F - F'\\<rbrakk>\n       \\<Longrightarrow> q i * i = 0", "thus \"q f * f = 0\""], ["proof (prove)\nusing this:\n  q f = 0\n\ngoal (1 subgoal):\n 1. q f * f = 0", "by simp"], ["proof (state)\nthis:\n  q f * f = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F", "qed"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>F'. q f * f) = (\\<Sum>f\\<in>F. q f * f)\n\ngoal (3 subgoals):\n 1. p = (\\<Sum>f\\<in>F. ?q f * f)\n 2. \\<And>f. poly_deg (?q f * f) \\<le> poly_deg p\n 3. \\<And>f. f \\<notin> F \\<Longrightarrow> ?q f = 0", "thus \"p = (\\<Sum>f\\<in>F. q f * f)\""], ["proof (prove)\nusing this:\n  (\\<Sum>f\\<in>F'. q f * f) = (\\<Sum>f\\<in>F. q f * f)\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>f\\<in>F. q f * f)", "by (simp only: p)"], ["proof (state)\nthis:\n  p = (\\<Sum>f\\<in>F. q f * f)\n\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f. poly_deg (q f * f) \\<le> poly_deg p\n 2. \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0", "show \"poly_deg (q f * f) \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (q f * f) \\<le> poly_deg p", "by fact"], ["proof (state)\nthis:\n  poly_deg (q f * f) \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0", "assume \"f \\<notin> F\""], ["proof (state)\nthis:\n  f \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0", "with \\<open>F' \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  F' \\<subseteq> F\n  f \\<notin> F", "have \"f \\<notin> F'\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> F\n  f \\<notin> F\n\ngoal (1 subgoal):\n 1. f \\<notin> F'", "by blast"], ["proof (state)\nthis:\n  f \\<notin> F'\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0", "thus \"q f = 0\""], ["proof (prove)\nusing this:\n  f \\<notin> F'\n\ngoal (1 subgoal):\n 1. q f = 0", "by (rule 1)"], ["proof (state)\nthis:\n  q f = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Homogenization and Dehomogenization\\<close>"], ["", "definition homogenize :: \"'x \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::semiring_1)\"\n  where \"homogenize x p = (\\<Sum>t\\<in>keys p. monomial (lookup p t) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t))\""], ["", "definition dehomo_subst :: \"'x \\<Rightarrow> 'x \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero_neq_one)\"\n  where \"dehomo_subst x = (\\<lambda>y. if y = x then 1 else monomial 1 (Poly_Mapping.single y 1))\""], ["", "definition dehomogenize :: \"'x \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1)\"\n  where \"dehomogenize x = poly_subst (dehomo_subst x)\""], ["", "lemma homogenize_zero [simp]: \"homogenize x 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x 0 = 0", "by (simp add: homogenize_def)"], ["", "lemma homogenize_uminus [simp]: \"homogenize x (- p) = - homogenize x (p::_ \\<Rightarrow>\\<^sub>0 'a::ring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x (- p) = - homogenize x p", "by (simp add: homogenize_def keys_uminus sum.reindex inj_on_def single_uminus sum_negf)"], ["", "lemma homogenize_monom_mult [simp]:\n  \"homogenize x (punit.monom_mult c t p) = punit.monom_mult c t (homogenize x p)\"\n  for c::\"'a::{semiring_1,semiring_no_zero_divisors_cancel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "by simp"], ["proof (state)\nthis:\n  homogenize x (punit.monom_mult c t p) =\n  punit.monom_mult c t (homogenize x p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "proof (cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = (0::'a) \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)\n 2. c \\<noteq> (0::'a) \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "case True"], ["proof (state)\nthis:\n  c = (0::'a)\n\ngoal (2 subgoals):\n 1. c = (0::'a) \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)\n 2. c \\<noteq> (0::'a) \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  c = (0::'a)\n\ngoal (1 subgoal):\n 1. homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "by simp"], ["proof (state)\nthis:\n  homogenize x (punit.monom_mult c t p) =\n  punit.monom_mult c t (homogenize x p)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "case False"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c t (homogenize x p)", "by (simp add: homogenize_def punit.keys_monom_mult \\<open>p \\<noteq> 0\\<close> False sum.reindex\n          punit.lookup_monom_mult punit.monom_mult_sum_right poly_deg_monom_mult\n          punit.monom_mult_monomial ac_simps deg_pm_plus)"], ["proof (state)\nthis:\n  homogenize x (punit.monom_mult c t p) =\n  punit.monom_mult c t (homogenize x p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  homogenize x (punit.monom_mult c t p) =\n  punit.monom_mult c t (homogenize x p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogenize_alt:\n  \"homogenize x p = (\\<Sum>q\\<in>hom_components p. punit.monom_mult 1 (Poly_Mapping.single x (poly_deg p - poly_deg q)) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "have \"homogenize x p = (\\<Sum>t\\<in>Keys (hom_components p). monomial (lookup p t) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>t\\<in>Keys (hom_components p).\n       monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))", "by (simp only: homogenize_def Keys_hom_components)"], ["proof (state)\nthis:\n  homogenize x p =\n  (\\<Sum>t\\<in>Keys (hom_components p).\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "also"], ["proof (state)\nthis:\n  homogenize x p =\n  (\\<Sum>t\\<in>Keys (hom_components p).\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "have \"\\<dots> = (\\<Sum>t\\<in>(\\<Union> (keys ` hom_components p)). monomial (lookup p t) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>Keys (hom_components p).\n       monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n    (\\<Sum>t\\<in>\\<Union> (keys ` hom_components p).\n       monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))", "by (simp only: Keys_def)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>Keys (hom_components p).\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n  (\\<Sum>t\\<in>\\<Union> (keys ` hom_components p).\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>Keys (hom_components p).\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n  (\\<Sum>t\\<in>\\<Union> (keys ` hom_components p).\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "have \"\\<dots> = (\\<Sum>q\\<in>hom_components p. (\\<Sum>t\\<in>keys q. monomial (lookup p t) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>\\<Union> (keys ` hom_components p).\n       monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n    (\\<Sum>q\\<in>hom_components p.\n       \\<Sum>t\\<in>keys q.\n         monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))", "by (auto intro!: sum.UNION_disjoint finite_hom_components finite_keys dest: hom_components_keys_disjoint)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>\\<Union> (keys ` hom_components p).\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n  (\\<Sum>q\\<in>hom_components p.\n     \\<Sum>t\\<in>keys q.\n       monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>\\<Union> (keys ` hom_components p).\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n  (\\<Sum>q\\<in>hom_components p.\n     \\<Sum>t\\<in>keys q.\n       monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "have \"\\<dots> = (\\<Sum>q\\<in>hom_components p. punit.monom_mult 1 (Poly_Mapping.single x (poly_deg p - poly_deg q)) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>hom_components p.\n       \\<Sum>t\\<in>keys q.\n         monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>hom_components p.\n       \\<Sum>t\\<in>keys q.\n         monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> hom_components p \\<Longrightarrow>\n       (\\<Sum>t\\<in>keys xa.\n          monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg xa) x) xa", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> hom_components p \\<Longrightarrow>\n       (\\<Sum>t\\<in>keys xa.\n          monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg xa) x) xa", "assume q: \"q \\<in> hom_components p\""], ["proof (state)\nthis:\n  q \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> hom_components p \\<Longrightarrow>\n       (\\<Sum>t\\<in>keys xa.\n          monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg xa) x) xa", "hence \"homogeneous q\""], ["proof (prove)\nusing this:\n  q \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. homogeneous q", "by (rule hom_components_homogeneous)"], ["proof (state)\nthis:\n  homogeneous q\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> hom_components p \\<Longrightarrow>\n       (\\<Sum>t\\<in>keys xa.\n          monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg xa) x) xa", "have \"(\\<Sum>t\\<in>keys q. monomial (lookup p t) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t)) =\n          (\\<Sum>t\\<in>keys q. punit.monom_mult 1 (Poly_Mapping.single x (poly_deg p - poly_deg q)) (monomial (lookup q t) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys q.\n       monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n    (\\<Sum>t\\<in>keys q.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n        (monomial (lookup q t) t))", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys q.\n       monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n    (\\<Sum>t\\<in>keys q.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n        (monomial (lookup q t) t))", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys q \\<Longrightarrow>\n       monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n        (monomial (lookup q xa) xa)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys q \\<Longrightarrow>\n       monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n        (monomial (lookup q xa) xa)", "assume \"t \\<in> keys q\""], ["proof (state)\nthis:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys q \\<Longrightarrow>\n       monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n        (monomial (lookup q xa) xa)", "with \\<open>homogeneous q\\<close>"], ["proof (chain)\npicking this:\n  homogeneous q\n  t \\<in> keys q", "have \"deg_pm t = poly_deg q\""], ["proof (prove)\nusing this:\n  homogeneous q\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg q", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg q\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys q \\<Longrightarrow>\n       monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n        (monomial (lookup q xa) xa)", "moreover"], ["proof (state)\nthis:\n  deg_pm t = poly_deg q\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys q \\<Longrightarrow>\n       monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n        (monomial (lookup q xa) xa)", "from q \\<open>t \\<in> keys q\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> hom_components p\n  t \\<in> keys q", "have \"lookup q t = lookup p t\""], ["proof (prove)\nusing this:\n  q \\<in> hom_components p\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. lookup q t = lookup p t", "by (rule lookup_hom_components)"], ["proof (state)\nthis:\n  lookup q t = lookup p t\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys q \\<Longrightarrow>\n       monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n        (monomial (lookup q xa) xa)", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm t = poly_deg q\n  lookup q t = lookup p t", "show \"monomial (lookup p t) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t) =\n            punit.monom_mult 1 (Poly_Mapping.single x (poly_deg p - poly_deg q)) (monomial (lookup q t) t)\""], ["proof (prove)\nusing this:\n  deg_pm t = poly_deg q\n  lookup q t = lookup p t\n\ngoal (1 subgoal):\n 1. monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t) =\n    punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n     (monomial (lookup q t) t)", "by (simp add: punit.monom_mult_monomial)"], ["proof (state)\nthis:\n  monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t) =\n  punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n   (monomial (lookup q t) t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys q.\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n  (\\<Sum>t\\<in>keys q.\n     punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n      (monomial (lookup q t) t))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> hom_components p \\<Longrightarrow>\n       (\\<Sum>t\\<in>keys xa.\n          monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg xa) x) xa", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys q.\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n  (\\<Sum>t\\<in>keys q.\n     punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n      (monomial (lookup q t) t))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> hom_components p \\<Longrightarrow>\n       (\\<Sum>t\\<in>keys xa.\n          monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg xa) x) xa", "have \"\\<dots> = punit.monom_mult 1 (Poly_Mapping.single x (poly_deg p - poly_deg q)) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys q.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n        (monomial (lookup q t) t)) =\n    punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q", "by (simp only: poly_mapping_sum_monomials flip: punit.monom_mult_sum_right)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys q.\n     punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n      (monomial (lookup q t) t)) =\n  punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> hom_components p \\<Longrightarrow>\n       (\\<Sum>t\\<in>keys xa.\n          monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg xa) x) xa", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>t\\<in>keys q.\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n  punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q", "show \"(\\<Sum>t\\<in>keys q. monomial (lookup p t) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t)) =\n                  punit.monom_mult 1 (Poly_Mapping.single x (poly_deg p - poly_deg q)) q\""], ["proof (prove)\nusing this:\n  (\\<Sum>t\\<in>keys q.\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n  punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys q.\n       monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n    punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q", "."], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys q.\n     monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n  punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>hom_components p.\n     \\<Sum>t\\<in>keys q.\n       monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t)) =\n  (\\<Sum>q\\<in>hom_components p.\n     punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)\n\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "finally"], ["proof (chain)\npicking this:\n  homogenize x p =\n  (\\<Sum>q\\<in>hom_components p.\n     punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "show ?thesis"], ["proof (prove)\nusing this:\n  homogenize x p =\n  (\\<Sum>q\\<in>hom_components p.\n     punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)\n\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "."], ["proof (state)\nthis:\n  homogenize x p =\n  (\\<Sum>q\\<in>hom_components p.\n     punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_homogenizeE:\n  assumes \"t \\<in> keys (homogenize x p)\"\n  obtains t' where \"t' \\<in> keys p\" and \"t = Poly_Mapping.single x (poly_deg p - deg_pm t') + t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> keys p;\n         t = monomial (poly_deg p - deg_pm t') x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> keys p;\n         t = monomial (poly_deg p - deg_pm t') x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms"], ["proof (state)\nthis:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> keys p;\n         t = monomial (poly_deg p - deg_pm t') x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> keys p;\n         t = monomial (poly_deg p - deg_pm t') x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"keys (homogenize x p) \\<subseteq>\n            (\\<Union>t\\<in>keys p. keys (monomial (lookup p t) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (homogenize x p)\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    keys\n                     (monomial (lookup p t)\n                       (monomial (poly_deg p - deg_pm t) x + t)))", "unfolding homogenize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>t\\<in>keys p.\n        monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    keys\n                     (monomial (lookup p t)\n                       (monomial (poly_deg p - deg_pm t) x + t)))", "by (rule keys_sum_subset)"], ["proof (state)\nthis:\n  keys (homogenize x p)\n  \\<subseteq> (\\<Union>t\\<in>keys p.\n                  keys\n                   (monomial (lookup p t)\n                     (monomial (poly_deg p - deg_pm t) x + t)))\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> keys p;\n         t = monomial (poly_deg p - deg_pm t') x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  t \\<in> (\\<Union>t\\<in>keys p.\n              keys\n               (monomial (lookup p t)\n                 (monomial (poly_deg p - deg_pm t) x + t)))", "obtain t' where \"t' \\<in> keys p\"\n    and \"t \\<in> keys (monomial (lookup p t') (Poly_Mapping.single x (poly_deg p - deg_pm t') + t'))\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>t\\<in>keys p.\n              keys\n               (monomial (lookup p t)\n                 (monomial (poly_deg p - deg_pm t) x + t)))\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> keys p;\n         t \\<in> keys\n                  (monomial (lookup p t')\n                    (monomial (poly_deg p - deg_pm t') x + t'))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t' \\<in> keys p\n  t \\<in> keys\n           (monomial (lookup p t')\n             (monomial (poly_deg p - deg_pm t') x + t'))\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> keys p;\n         t = monomial (poly_deg p - deg_pm t') x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(2)"], ["proof (chain)\npicking this:\n  t \\<in> keys\n           (monomial (lookup p t')\n             (monomial (poly_deg p - deg_pm t') x + t'))", "have \"t = Poly_Mapping.single x (poly_deg p - deg_pm t') + t'\""], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (monomial (lookup p t')\n             (monomial (poly_deg p - deg_pm t') x + t'))\n\ngoal (1 subgoal):\n 1. t = monomial (poly_deg p - deg_pm t') x + t'", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  t = monomial (poly_deg p - deg_pm t') x + t'\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> keys p;\n         t = monomial (poly_deg p - deg_pm t') x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>t' \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  t' \\<in> keys p\n  t = monomial (poly_deg p - deg_pm t') x + t'", "show ?thesis"], ["proof (prove)\nusing this:\n  t' \\<in> keys p\n  t = monomial (poly_deg p - deg_pm t') x + t'\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_homogenizeE_alt:\n  assumes \"t \\<in> keys (homogenize x p)\"\n  obtains q t' where \"q \\<in> hom_components p\" and \"t' \\<in> keys q\"\n    and \"t = Poly_Mapping.single x (poly_deg p - poly_deg q) + t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>q \\<in> hom_components p; t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>q \\<in> hom_components p; t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms"], ["proof (state)\nthis:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>q \\<in> hom_components p; t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>q \\<in> hom_components p; t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"keys (homogenize x p) \\<subseteq>\n            (\\<Union>q\\<in>hom_components p. keys (punit.monom_mult 1 (Poly_Mapping.single x (poly_deg p - poly_deg q)) q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (homogenize x p)\n    \\<subseteq> (\\<Union>q\\<in>hom_components p.\n                    keys\n                     (punit.monom_mult (1::'b)\n                       (monomial (poly_deg p - poly_deg q) x) q))", "unfolding homogenize_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>q\\<in>hom_components p.\n        punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)\n    \\<subseteq> (\\<Union>q\\<in>hom_components p.\n                    keys\n                     (punit.monom_mult (1::'b)\n                       (monomial (poly_deg p - poly_deg q) x) q))", "by (rule keys_sum_subset)"], ["proof (state)\nthis:\n  keys (homogenize x p)\n  \\<subseteq> (\\<Union>q\\<in>hom_components p.\n                  keys\n                   (punit.monom_mult (1::'b)\n                     (monomial (poly_deg p - poly_deg q) x) q))\n\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>q \\<in> hom_components p; t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  t \\<in> (\\<Union>q\\<in>hom_components p.\n              keys\n               (punit.monom_mult (1::'b)\n                 (monomial (poly_deg p - poly_deg q) x) q))", "obtain q where q: \"q \\<in> hom_components p\"\n    and \"t \\<in> keys (punit.monom_mult 1 (Poly_Mapping.single x (poly_deg p - poly_deg q)) q)\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>q\\<in>hom_components p.\n              keys\n               (punit.monom_mult (1::'b)\n                 (monomial (poly_deg p - poly_deg q) x) q))\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> hom_components p;\n         t \\<in> keys\n                  (punit.monom_mult (1::'b)\n                    (monomial (poly_deg p - poly_deg q) x) q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  q \\<in> hom_components p\n  t \\<in> keys\n           (punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n             q)\n\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>q \\<in> hom_components p; t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  t \\<in> keys\n           (punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n             q)\n\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>q \\<in> hom_components p; t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  t \\<in> keys\n           (punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x)\n             q)\n\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>q \\<in> hom_components p; t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> \\<subseteq> (+) (Poly_Mapping.single x (poly_deg p - poly_deg q)) ` keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)\n    \\<subseteq> (+) (monomial (poly_deg p - poly_deg q) x) ` keys q", "by (rule punit.keys_monom_mult_subset[simplified])"], ["proof (state)\nthis:\n  keys (punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)\n  \\<subseteq> (+) (monomial (poly_deg p - poly_deg q) x) ` keys q\n\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>q \\<in> hom_components p; t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  t \\<in> (+) (monomial (poly_deg p - poly_deg q) x) ` keys q", "obtain t' where \"t' \\<in> keys q\" and \"t = Poly_Mapping.single x (poly_deg p - poly_deg q) + t'\""], ["proof (prove)\nusing this:\n  t \\<in> (+) (monomial (poly_deg p - poly_deg q) x) ` keys q\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t' \\<in> keys q\n  t = monomial (poly_deg p - poly_deg q) x + t'\n\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>q \\<in> hom_components p; t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with q"], ["proof (chain)\npicking this:\n  q \\<in> hom_components p\n  t' \\<in> keys q\n  t = monomial (poly_deg p - poly_deg q) x + t'", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> hom_components p\n  t' \\<in> keys q\n  t = monomial (poly_deg p - poly_deg q) x + t'\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deg_pm_homogenize:\n  assumes \"t \\<in> keys (homogenize x p)\"\n  shows \"deg_pm t = poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "from assms"], ["proof (chain)\npicking this:\n  t \\<in> keys (homogenize x p)", "obtain q t' where q: \"q \\<in> hom_components p\" and \"t' \\<in> keys q\"\n    and t: \"t = Poly_Mapping.single x (poly_deg p - poly_deg q) + t'\""], ["proof (prove)\nusing this:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. (\\<And>q t'.\n        \\<lbrakk>q \\<in> hom_components p; t' \\<in> keys q;\n         t = monomial (poly_deg p - poly_deg q) x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule keys_homogenizeE_alt)"], ["proof (state)\nthis:\n  q \\<in> hom_components p\n  t' \\<in> keys q\n  t = monomial (poly_deg p - poly_deg q) x + t'\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "from q"], ["proof (chain)\npicking this:\n  q \\<in> hom_components p", "have \"homogeneous q\""], ["proof (prove)\nusing this:\n  q \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. homogeneous q", "by (rule hom_components_homogeneous)"], ["proof (state)\nthis:\n  homogeneous q\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "hence \"deg_pm t' = poly_deg q\""], ["proof (prove)\nusing this:\n  homogeneous q\n\ngoal (1 subgoal):\n 1. deg_pm t' = poly_deg q", "using \\<open>t' \\<in> keys q\\<close>"], ["proof (prove)\nusing this:\n  homogeneous q\n  t' \\<in> keys q\n\ngoal (1 subgoal):\n 1. deg_pm t' = poly_deg q", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t' = poly_deg q\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "moreover"], ["proof (state)\nthis:\n  deg_pm t' = poly_deg q\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "from q"], ["proof (chain)\npicking this:\n  q \\<in> hom_components p", "have \"poly_deg q \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  q \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. poly_deg q \\<le> poly_deg p", "by (rule poly_deg_hom_components_le)"], ["proof (state)\nthis:\n  poly_deg q \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm t' = poly_deg q\n  poly_deg q \\<le> poly_deg p", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t' = poly_deg q\n  poly_deg q \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (simp add: t deg_pm_plus deg_pm_single)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary homogeneous_homogenize: \"homogeneous (homogenize x p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous (homogenize x p)", "proof (rule homogeneousI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (homogenize x p);\n        t \\<in> keys (homogenize x p)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (homogenize x p);\n        t \\<in> keys (homogenize x p)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "assume \"s \\<in> keys (homogenize x p)\""], ["proof (state)\nthis:\n  s \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (homogenize x p);\n        t \\<in> keys (homogenize x p)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "hence *: \"deg_pm s = poly_deg p\""], ["proof (prove)\nusing this:\n  s \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. deg_pm s = poly_deg p", "by (rule deg_pm_homogenize)"], ["proof (state)\nthis:\n  deg_pm s = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (homogenize x p);\n        t \\<in> keys (homogenize x p)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "assume \"t \\<in> keys (homogenize x p)\""], ["proof (state)\nthis:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (homogenize x p);\n        t \\<in> keys (homogenize x p)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "hence \"deg_pm t = poly_deg p\""], ["proof (prove)\nusing this:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule deg_pm_homogenize)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> keys (homogenize x p);\n        t \\<in> keys (homogenize x p)\\<rbrakk>\n       \\<Longrightarrow> deg_pm s = deg_pm t", "with *"], ["proof (chain)\npicking this:\n  deg_pm s = poly_deg p\n  deg_pm t = poly_deg p", "show \"deg_pm s = deg_pm t\""], ["proof (prove)\nusing this:\n  deg_pm s = poly_deg p\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm s = deg_pm t", "by simp"], ["proof (state)\nthis:\n  deg_pm s = deg_pm t\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary poly_deg_homogenize_le: \"poly_deg (homogenize x p) \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (homogenize x p) \\<le> poly_deg p", "proof (rule poly_deg_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (homogenize x p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (homogenize x p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "assume \"t \\<in> keys (homogenize x p)\""], ["proof (state)\nthis:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (homogenize x p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "hence \"deg_pm t = poly_deg p\""], ["proof (prove)\nusing this:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule deg_pm_homogenize)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (homogenize x p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "thus \"deg_pm t \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "by simp"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogenize_id_iff [simp]: \"homogenize x p = p \\<longleftrightarrow> homogeneous p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (homogenize x p = p) = homogeneous p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. homogenize x p = p \\<Longrightarrow> homogeneous p\n 2. homogeneous p \\<Longrightarrow> homogenize x p = p", "assume \"homogenize x p = p\""], ["proof (state)\nthis:\n  homogenize x p = p\n\ngoal (2 subgoals):\n 1. homogenize x p = p \\<Longrightarrow> homogeneous p\n 2. homogeneous p \\<Longrightarrow> homogenize x p = p", "moreover"], ["proof (state)\nthis:\n  homogenize x p = p\n\ngoal (2 subgoals):\n 1. homogenize x p = p \\<Longrightarrow> homogeneous p\n 2. homogeneous p \\<Longrightarrow> homogenize x p = p", "have \"homogeneous (homogenize x p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous (homogenize x p)", "by (fact homogeneous_homogenize)"], ["proof (state)\nthis:\n  homogeneous (homogenize x p)\n\ngoal (2 subgoals):\n 1. homogenize x p = p \\<Longrightarrow> homogeneous p\n 2. homogeneous p \\<Longrightarrow> homogenize x p = p", "ultimately"], ["proof (chain)\npicking this:\n  homogenize x p = p\n  homogeneous (homogenize x p)", "show \"homogeneous p\""], ["proof (prove)\nusing this:\n  homogenize x p = p\n  homogeneous (homogenize x p)\n\ngoal (1 subgoal):\n 1. homogeneous p", "by simp"], ["proof (state)\nthis:\n  homogeneous p\n\ngoal (1 subgoal):\n 1. homogeneous p \\<Longrightarrow> homogenize x p = p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. homogeneous p \\<Longrightarrow> homogenize x p = p", "assume \"homogeneous p\""], ["proof (state)\nthis:\n  homogeneous p\n\ngoal (1 subgoal):\n 1. homogeneous p \\<Longrightarrow> homogenize x p = p", "hence \"hom_components p = (if p = 0 then {} else {p})\""], ["proof (prove)\nusing this:\n  homogeneous p\n\ngoal (1 subgoal):\n 1. hom_components p = (if p = 0 then {} else {p})", "by (rule hom_components_of_homogeneous)"], ["proof (state)\nthis:\n  hom_components p = (if p = 0 then {} else {p})\n\ngoal (1 subgoal):\n 1. homogeneous p \\<Longrightarrow> homogenize x p = p", "thus \"homogenize x p = p\""], ["proof (prove)\nusing this:\n  hom_components p = (if p = 0 then {} else {p})\n\ngoal (1 subgoal):\n 1. homogenize x p = p", "by (simp add: homogenize_alt split: if_split_asm)"], ["proof (state)\nthis:\n  homogenize x p = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogenize_homogenize [simp]: \"homogenize x (homogenize x p) = homogenize x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x (homogenize x p) = homogenize x p", "by (simp add: homogeneous_homogenize)"], ["", "lemma homogenize_monomial: \"homogenize x (monomial c t) = monomial c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x (monomial c t) = monomial c t", "by (simp only: homogenize_id_iff homogeneous_monomial)"], ["", "lemma indets_homogenize_subset: \"indets (homogenize x p) \\<subseteq> insert x (indets p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (homogenize x p) \\<subseteq> insert x (indets p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (homogenize x p) \\<Longrightarrow>\n       xa \\<in> insert x (indets p)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (homogenize x p) \\<Longrightarrow>\n       xa \\<in> insert x (indets p)", "assume \"y \\<in> indets (homogenize x p)\""], ["proof (state)\nthis:\n  y \\<in> indets (homogenize x p)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (homogenize x p) \\<Longrightarrow>\n       xa \\<in> insert x (indets p)", "then"], ["proof (chain)\npicking this:\n  y \\<in> indets (homogenize x p)", "obtain t where \"t \\<in> keys (homogenize x p)\" and \"y \\<in> keys t\""], ["proof (prove)\nusing this:\n  y \\<in> indets (homogenize x p)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys (homogenize x p); y \\<in> keys t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_indetsE)"], ["proof (state)\nthis:\n  t \\<in> keys (homogenize x p)\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (homogenize x p) \\<Longrightarrow>\n       xa \\<in> insert x (indets p)", "from this(1)"], ["proof (chain)\npicking this:\n  t \\<in> keys (homogenize x p)", "obtain t' where \"t' \\<in> keys p\"\n    and t: \"t = Poly_Mapping.single x (poly_deg p - deg_pm t') + t'\""], ["proof (prove)\nusing this:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> keys p;\n         t = monomial (poly_deg p - deg_pm t') x + t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule keys_homogenizeE)"], ["proof (state)\nthis:\n  t' \\<in> keys p\n  t = monomial (poly_deg p - deg_pm t') x + t'\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (homogenize x p) \\<Longrightarrow>\n       xa \\<in> insert x (indets p)", "note \\<open>y \\<in> keys t\\<close>"], ["proof (state)\nthis:\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (homogenize x p) \\<Longrightarrow>\n       xa \\<in> insert x (indets p)", "also"], ["proof (state)\nthis:\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (homogenize x p) \\<Longrightarrow>\n       xa \\<in> insert x (indets p)", "have \"keys t \\<subseteq> keys (Poly_Mapping.single x (poly_deg p - deg_pm t')) \\<union> keys t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys t\n    \\<subseteq> keys (monomial (poly_deg p - deg_pm t') x) \\<union> keys t'", "unfolding t"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial (poly_deg p - deg_pm t') x + t')\n    \\<subseteq> keys (monomial (poly_deg p - deg_pm t') x) \\<union> keys t'", "by (rule Poly_Mapping.keys_add)"], ["proof (state)\nthis:\n  keys t\n  \\<subseteq> keys (monomial (poly_deg p - deg_pm t') x) \\<union> keys t'\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (homogenize x p) \\<Longrightarrow>\n       xa \\<in> insert x (indets p)", "finally"], ["proof (chain)\npicking this:\n  y \\<in> keys (monomial (poly_deg p - deg_pm t') x) \\<union> keys t'", "show \"y \\<in> insert x (indets p)\""], ["proof (prove)\nusing this:\n  y \\<in> keys (monomial (poly_deg p - deg_pm t') x) \\<union> keys t'\n\ngoal (1 subgoal):\n 1. y \\<in> insert x (indets p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> keys (monomial (poly_deg p - deg_pm t') x) \\<Longrightarrow>\n    y \\<in> insert x (indets p)\n 2. y \\<in> keys t' \\<Longrightarrow> y \\<in> insert x (indets p)", "assume \"y \\<in> keys (Poly_Mapping.single x (poly_deg p - deg_pm t'))\""], ["proof (state)\nthis:\n  y \\<in> keys (monomial (poly_deg p - deg_pm t') x)\n\ngoal (2 subgoals):\n 1. y \\<in> keys (monomial (poly_deg p - deg_pm t') x) \\<Longrightarrow>\n    y \\<in> insert x (indets p)\n 2. y \\<in> keys t' \\<Longrightarrow> y \\<in> insert x (indets p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> keys (monomial (poly_deg p - deg_pm t') x)\n\ngoal (1 subgoal):\n 1. y \\<in> insert x (indets p)", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  y \\<in> insert x (indets p)\n\ngoal (1 subgoal):\n 1. y \\<in> keys t' \\<Longrightarrow> y \\<in> insert x (indets p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> keys t' \\<Longrightarrow> y \\<in> insert x (indets p)", "assume \"y \\<in> keys t'\""], ["proof (state)\nthis:\n  y \\<in> keys t'\n\ngoal (1 subgoal):\n 1. y \\<in> keys t' \\<Longrightarrow> y \\<in> insert x (indets p)", "hence \"y \\<in> indets p\""], ["proof (prove)\nusing this:\n  y \\<in> keys t'\n\ngoal (1 subgoal):\n 1. y \\<in> indets p", "using \\<open>t' \\<in> keys p\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> keys t'\n  t' \\<in> keys p\n\ngoal (1 subgoal):\n 1. y \\<in> indets p", "by (rule in_indetsI)"], ["proof (state)\nthis:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. y \\<in> keys t' \\<Longrightarrow> y \\<in> insert x (indets p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. y \\<in> insert x (indets p)", "by simp"], ["proof (state)\nthis:\n  y \\<in> insert x (indets p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> insert x (indets p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogenize_in_Polys: \"p \\<in> P[X] \\<Longrightarrow> homogenize x p \\<in> P[insert x X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<Longrightarrow> homogenize x p \\<in> P[insert x X]", "using indets_homogenize_subset[of x p]"], ["proof (prove)\nusing this:\n  indets (homogenize x p) \\<subseteq> insert x (indets p)\n\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<Longrightarrow> homogenize x p \\<in> P[insert x X]", "by (auto simp: Polys_alt)"], ["", "lemma lookup_homogenize:\n  assumes \"x \\<notin> indets p\" and \"x \\<notin> keys t\"\n  shows \"lookup (homogenize x p) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t) = lookup p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "let ?p = \"homogenize x p\""], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "let ?t = \"Poly_Mapping.single x (poly_deg p - deg_pm t) + t\""], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "have eq: \"(\\<Sum>s\\<in>keys p - {t}. lookup (monomial (lookup p s) (Poly_Mapping.single x (poly_deg p - deg_pm s) + s)) ?t) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>keys p - {t}.\n       lookup\n        (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n        (monomial (poly_deg p - deg_pm t) x + t)) =\n    (0::'b)", "proof (intro sum.neutral ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup\n        (monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa))\n        (monomial (poly_deg p - deg_pm t) x + t) =\n       (0::'b)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup\n        (monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa))\n        (monomial (poly_deg p - deg_pm t) x + t) =\n       (0::'b)", "assume \"s \\<in> keys p - {t}\""], ["proof (state)\nthis:\n  s \\<in> keys p - {t}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup\n        (monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa))\n        (monomial (poly_deg p - deg_pm t) x + t) =\n       (0::'b)", "hence \"s \\<in> keys p\" and \"s \\<noteq> t\""], ["proof (prove)\nusing this:\n  s \\<in> keys p - {t}\n\ngoal (1 subgoal):\n 1. s \\<in> keys p &&& s \\<noteq> t", "by simp_all"], ["proof (state)\nthis:\n  s \\<in> keys p\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup\n        (monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa))\n        (monomial (poly_deg p - deg_pm t) x + t) =\n       (0::'b)", "from this(1)"], ["proof (chain)\npicking this:\n  s \\<in> keys p", "have \"keys s \\<subseteq> indets p\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> indets p", "by (simp add: in_indetsI subsetI)"], ["proof (state)\nthis:\n  keys s \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup\n        (monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa))\n        (monomial (poly_deg p - deg_pm t) x + t) =\n       (0::'b)", "with assms(1)"], ["proof (chain)\npicking this:\n  x \\<notin> indets p\n  keys s \\<subseteq> indets p", "have \"x \\<notin> keys s\""], ["proof (prove)\nusing this:\n  x \\<notin> indets p\n  keys s \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. x \\<notin> keys s", "by blast"], ["proof (state)\nthis:\n  x \\<notin> keys s\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup\n        (monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa))\n        (monomial (poly_deg p - deg_pm t) x + t) =\n       (0::'b)", "have \"?t \\<noteq> Poly_Mapping.single x (poly_deg p - deg_pm s) + s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t \\<noteq>\n    monomial (poly_deg p - deg_pm s) x + s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t =\n    monomial (poly_deg p - deg_pm s) x + s \\<Longrightarrow>\n    False", "assume a: \"?t = Poly_Mapping.single x (poly_deg p - deg_pm s) + s\""], ["proof (state)\nthis:\n  monomial (poly_deg p - deg_pm t) x + t =\n  monomial (poly_deg p - deg_pm s) x + s\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t =\n    monomial (poly_deg p - deg_pm s) x + s \\<Longrightarrow>\n    False", "hence \"lookup ?t x = lookup (Poly_Mapping.single x (poly_deg p - deg_pm s) + s) x\""], ["proof (prove)\nusing this:\n  monomial (poly_deg p - deg_pm t) x + t =\n  monomial (poly_deg p - deg_pm s) x + s\n\ngoal (1 subgoal):\n 1. lookup (monomial (poly_deg p - deg_pm t) x + t) x =\n    lookup (monomial (poly_deg p - deg_pm s) x + s) x", "by simp"], ["proof (state)\nthis:\n  lookup (monomial (poly_deg p - deg_pm t) x + t) x =\n  lookup (monomial (poly_deg p - deg_pm s) x + s) x\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t =\n    monomial (poly_deg p - deg_pm s) x + s \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  lookup (monomial (poly_deg p - deg_pm t) x + t) x =\n  lookup (monomial (poly_deg p - deg_pm s) x + s) x\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t =\n    monomial (poly_deg p - deg_pm s) x + s \\<Longrightarrow>\n    False", "from assms(2)"], ["proof (chain)\npicking this:\n  x \\<notin> keys t", "have \"lookup t x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> keys t\n\ngoal (1 subgoal):\n 1. lookup t x = 0", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup t x = 0\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t =\n    monomial (poly_deg p - deg_pm s) x + s \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  lookup t x = 0\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t =\n    monomial (poly_deg p - deg_pm s) x + s \\<Longrightarrow>\n    False", "from \\<open>x \\<notin> keys s\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> keys s", "have \"lookup s x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> keys s\n\ngoal (1 subgoal):\n 1. lookup s x = 0", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup s x = 0\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t =\n    monomial (poly_deg p - deg_pm s) x + s \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  lookup (monomial (poly_deg p - deg_pm t) x + t) x =\n  lookup (monomial (poly_deg p - deg_pm s) x + s) x\n  lookup t x = 0\n  lookup s x = 0", "have \"poly_deg p - deg_pm t = poly_deg p - deg_pm s\""], ["proof (prove)\nusing this:\n  lookup (monomial (poly_deg p - deg_pm t) x + t) x =\n  lookup (monomial (poly_deg p - deg_pm s) x + s) x\n  lookup t x = 0\n  lookup s x = 0\n\ngoal (1 subgoal):\n 1. poly_deg p - deg_pm t = poly_deg p - deg_pm s", "by (simp add: lookup_add)"], ["proof (state)\nthis:\n  poly_deg p - deg_pm t = poly_deg p - deg_pm s\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t =\n    monomial (poly_deg p - deg_pm s) x + s \\<Longrightarrow>\n    False", "with a"], ["proof (chain)\npicking this:\n  monomial (poly_deg p - deg_pm t) x + t =\n  monomial (poly_deg p - deg_pm s) x + s\n  poly_deg p - deg_pm t = poly_deg p - deg_pm s", "have \"s = t\""], ["proof (prove)\nusing this:\n  monomial (poly_deg p - deg_pm t) x + t =\n  monomial (poly_deg p - deg_pm s) x + s\n  poly_deg p - deg_pm t = poly_deg p - deg_pm s\n\ngoal (1 subgoal):\n 1. s = t", "by simp"], ["proof (state)\nthis:\n  s = t\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t =\n    monomial (poly_deg p - deg_pm s) x + s \\<Longrightarrow>\n    False", "with \\<open>s \\<noteq> t\\<close>"], ["proof (chain)\npicking this:\n  s \\<noteq> t\n  s = t", "show False"], ["proof (prove)\nusing this:\n  s \\<noteq> t\n  s = t\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monomial (poly_deg p - deg_pm t) x + t \\<noteq>\n  monomial (poly_deg p - deg_pm s) x + s\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup\n        (monomial (lookup p xa) (monomial (poly_deg p - deg_pm xa) x + xa))\n        (monomial (poly_deg p - deg_pm t) x + t) =\n       (0::'b)", "thus \"lookup (monomial (lookup p s) (Poly_Mapping.single x (poly_deg p - deg_pm s) + s)) ?t = 0\""], ["proof (prove)\nusing this:\n  monomial (poly_deg p - deg_pm t) x + t \\<noteq>\n  monomial (poly_deg p - deg_pm s) x + s\n\ngoal (1 subgoal):\n 1. lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n     (monomial (poly_deg p - deg_pm t) x + t) =\n    (0::'b)", "by (simp add: lookup_single)"], ["proof (state)\nthis:\n  lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n   (monomial (poly_deg p - deg_pm t) x + t) =\n  (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t)) =\n  (0::'b)\n\ngoal (1 subgoal):\n 1. lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "proof (cases \"t \\<in> keys p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "case True"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "have \"lookup ?p ?t = (\\<Sum>s\\<in>keys p. lookup (monomial (lookup p s) (Poly_Mapping.single x (poly_deg p - deg_pm s) + s)) ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    (\\<Sum>s\\<in>keys p.\n       lookup\n        (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n        (monomial (poly_deg p - deg_pm t) x + t))", "by (simp add: homogenize_def lookup_sum)"], ["proof (state)\nthis:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  (\\<Sum>s\\<in>keys p.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "also"], ["proof (state)\nthis:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  (\\<Sum>s\\<in>keys p.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "have \"\\<dots> = lookup (monomial (lookup p t) ?t) ?t +\n                    (\\<Sum>s\\<in>keys p - {t}. lookup (monomial (lookup p s) (Poly_Mapping.single x (poly_deg p - deg_pm s) + s)) ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>keys p.\n       lookup\n        (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n        (monomial (poly_deg p - deg_pm t) x + t)) =\n    lookup (monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n     (monomial (poly_deg p - deg_pm t) x + t) +\n    (\\<Sum>s\\<in>keys p - {t}.\n       lookup\n        (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n        (monomial (poly_deg p - deg_pm t) x + t))", "using finite_keys True"], ["proof (prove)\nusing this:\n  finite (keys ?f)\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>keys p.\n       lookup\n        (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n        (monomial (poly_deg p - deg_pm t) x + t)) =\n    lookup (monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n     (monomial (poly_deg p - deg_pm t) x + t) +\n    (\\<Sum>s\\<in>keys p - {t}.\n       lookup\n        (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n        (monomial (poly_deg p - deg_pm t) x + t))", "by (rule sum.remove)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>keys p.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t)) =\n  lookup (monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n   (monomial (poly_deg p - deg_pm t) x + t) +\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "also"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>keys p.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t)) =\n  lookup (monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n   (monomial (poly_deg p - deg_pm t) x + t) +\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "have \"\\<dots> = lookup p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n     (monomial (poly_deg p - deg_pm t) x + t) +\n    (\\<Sum>s\\<in>keys p - {t}.\n       lookup\n        (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n        (monomial (poly_deg p - deg_pm t) x + t)) =\n    lookup p t", "by (simp add: eq)"], ["proof (state)\nthis:\n  lookup (monomial (lookup p t) (monomial (poly_deg p - deg_pm t) x + t))\n   (monomial (poly_deg p - deg_pm t) x + t) +\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t)) =\n  lookup p t\n\ngoal (2 subgoals):\n 1. t \\<in> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t\n 2. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "finally"], ["proof (chain)\npicking this:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  lookup p t", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  lookup p t\n\ngoal (1 subgoal):\n 1. lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "."], ["proof (state)\nthis:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  lookup p t\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "case False"], ["proof (state)\nthis:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "hence 1: \"keys p - {t} = keys p\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. keys p - {t} = keys p", "by simp"], ["proof (state)\nthis:\n  keys p - {t} = keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "have \"lookup ?p ?t = (\\<Sum>s\\<in>keys p - {t}. lookup (monomial (lookup p s) (Poly_Mapping.single x (poly_deg p - deg_pm s) + s)) ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    (\\<Sum>s\\<in>keys p - {t}.\n       lookup\n        (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n        (monomial (poly_deg p - deg_pm t) x + t))", "by (simp add: homogenize_def lookup_sum 1)"], ["proof (state)\nthis:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "also"], ["proof (state)\nthis:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>keys p - {t}.\n       lookup\n        (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n        (monomial (poly_deg p - deg_pm t) x + t)) =\n    (0::'b)", "by (simp only: eq)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t)) =\n  (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "also"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (monomial (poly_deg p - deg_pm s) x + s))\n      (monomial (poly_deg p - deg_pm t) x + t)) =\n  (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "from False"], ["proof (chain)\npicking this:\n  t \\<notin> keys p", "have \"\\<dots> = lookup p t\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. (0::'b) = lookup p t", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (0::'b) = lookup p t\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p \\<Longrightarrow>\n    lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "finally"], ["proof (chain)\npicking this:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  lookup p t", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  lookup p t\n\ngoal (1 subgoal):\n 1. lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "."], ["proof (state)\nthis:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  lookup p t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  lookup p t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_homogenizeI:\n  assumes \"x \\<notin> indets p\" and \"t \\<in> keys p\"\n  shows \"Poly_Mapping.single x (poly_deg p - deg_pm t) + t \\<in> keys (homogenize x p)\" (is \"?t \\<in> keys ?p\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)", "from assms(2)"], ["proof (chain)\npicking this:\n  t \\<in> keys p", "have \"keys t \\<subseteq> indets p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> indets p", "by (simp add: in_indetsI subsetI)"], ["proof (state)\nthis:\n  keys t \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)", "with assms(1)"], ["proof (chain)\npicking this:\n  x \\<notin> indets p\n  keys t \\<subseteq> indets p", "have \"x \\<notin> keys t\""], ["proof (prove)\nusing this:\n  x \\<notin> indets p\n  keys t \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. x \\<notin> keys t", "by blast"], ["proof (state)\nthis:\n  x \\<notin> keys t\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)", "with assms(1)"], ["proof (chain)\npicking this:\n  x \\<notin> indets p\n  x \\<notin> keys t", "have \"lookup ?p ?t = lookup p t\""], ["proof (prove)\nusing this:\n  x \\<notin> indets p\n  x \\<notin> keys t\n\ngoal (1 subgoal):\n 1. lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n    lookup p t", "by (rule lookup_homogenize)"], ["proof (state)\nthis:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  lookup p t\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)", "also"], ["proof (state)\nthis:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) =\n  lookup p t\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)", "from assms(2)"], ["proof (chain)\npicking this:\n  t \\<in> keys p", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. lookup p t \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup p t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)", "finally"], ["proof (chain)\npicking this:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) \\<noteq>\n  (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (homogenize x p) (monomial (poly_deg p - deg_pm t) x + t) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_homogenize:\n  \"x \\<notin> indets p \\<Longrightarrow> keys (homogenize x p) = (\\<lambda>t. Poly_Mapping.single x (poly_deg p - deg_pm t) + t) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> indets p \\<Longrightarrow>\n    keys (homogenize x p) =\n    (\\<lambda>t. monomial (poly_deg p - deg_pm t) x + t) ` keys p", "by (auto intro: keys_homogenizeI elim: keys_homogenizeE)"], ["", "lemma card_keys_homogenize:\n  assumes \"x \\<notin> indets p\"\n  shows \"card (keys (homogenize x p)) = card (keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (keys (homogenize x p)) = card (keys p)", "unfolding keys_homogenize[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>t. monomial (poly_deg p - deg_pm t) x + t) ` keys p) =\n    card (keys p)", "proof (intro card_image inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        monomial (poly_deg p - deg_pm xa) x + xa =\n        monomial (poly_deg p - deg_pm y) x + y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        monomial (poly_deg p - deg_pm xa) x + xa =\n        monomial (poly_deg p - deg_pm y) x + y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "assume \"s \\<in> keys p\" and \"t \\<in> keys p\""], ["proof (state)\nthis:\n  s \\<in> keys p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        monomial (poly_deg p - deg_pm xa) x + xa =\n        monomial (poly_deg p - deg_pm y) x + y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "with assms"], ["proof (chain)\npicking this:\n  x \\<notin> indets p\n  s \\<in> keys p\n  t \\<in> keys p", "have \"x \\<notin> keys s\" and \"x \\<notin> keys t\""], ["proof (prove)\nusing this:\n  x \\<notin> indets p\n  s \\<in> keys p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. x \\<notin> keys s &&& x \\<notin> keys t", "by (auto dest: in_indetsI simp only:)"], ["proof (state)\nthis:\n  x \\<notin> keys s\n  x \\<notin> keys t\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        monomial (poly_deg p - deg_pm xa) x + xa =\n        monomial (poly_deg p - deg_pm y) x + y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "let ?s = \"Poly_Mapping.single x (poly_deg p - deg_pm s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        monomial (poly_deg p - deg_pm xa) x + xa =\n        monomial (poly_deg p - deg_pm y) x + y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "let ?t = \"Poly_Mapping.single x (poly_deg p - deg_pm t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        monomial (poly_deg p - deg_pm xa) x + xa =\n        monomial (poly_deg p - deg_pm y) x + y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "assume \"?s + s = ?t + t\""], ["proof (state)\nthis:\n  monomial (poly_deg p - deg_pm s) x + s =\n  monomial (poly_deg p - deg_pm t) x + t\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        monomial (poly_deg p - deg_pm xa) x + xa =\n        monomial (poly_deg p - deg_pm y) x + y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "hence \"lookup (?s + s) x = lookup (?t + t) x\""], ["proof (prove)\nusing this:\n  monomial (poly_deg p - deg_pm s) x + s =\n  monomial (poly_deg p - deg_pm t) x + t\n\ngoal (1 subgoal):\n 1. lookup (monomial (poly_deg p - deg_pm s) x + s) x =\n    lookup (monomial (poly_deg p - deg_pm t) x + t) x", "by simp"], ["proof (state)\nthis:\n  lookup (monomial (poly_deg p - deg_pm s) x + s) x =\n  lookup (monomial (poly_deg p - deg_pm t) x + t) x\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        monomial (poly_deg p - deg_pm xa) x + xa =\n        monomial (poly_deg p - deg_pm y) x + y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "with \\<open>x \\<notin> keys s\\<close> \\<open>x \\<notin> keys t\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> keys s\n  x \\<notin> keys t\n  lookup (monomial (poly_deg p - deg_pm s) x + s) x =\n  lookup (monomial (poly_deg p - deg_pm t) x + t) x", "have \"?s = ?t\""], ["proof (prove)\nusing this:\n  x \\<notin> keys s\n  x \\<notin> keys t\n  lookup (monomial (poly_deg p - deg_pm s) x + s) x =\n  lookup (monomial (poly_deg p - deg_pm t) x + t) x\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm s) x = monomial (poly_deg p - deg_pm t) x", "by (simp add: lookup_add in_keys_iff)"], ["proof (state)\nthis:\n  monomial (poly_deg p - deg_pm s) x = monomial (poly_deg p - deg_pm t) x\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        monomial (poly_deg p - deg_pm xa) x + xa =\n        monomial (poly_deg p - deg_pm y) x + y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "with \\<open>?s + s = ?t + t\\<close>"], ["proof (chain)\npicking this:\n  monomial (poly_deg p - deg_pm s) x + s =\n  monomial (poly_deg p - deg_pm t) x + t\n  monomial (poly_deg p - deg_pm s) x = monomial (poly_deg p - deg_pm t) x", "show \"s = t\""], ["proof (prove)\nusing this:\n  monomial (poly_deg p - deg_pm s) x + s =\n  monomial (poly_deg p - deg_pm t) x + t\n  monomial (poly_deg p - deg_pm s) x = monomial (poly_deg p - deg_pm t) x\n\ngoal (1 subgoal):\n 1. s = t", "by simp"], ["proof (state)\nthis:\n  s = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_homogenize:\n  assumes \"x \\<notin> indets p\"\n  shows \"poly_deg (homogenize x p) = poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (homogenize x p) = poly_deg p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly_deg (homogenize x p) = poly_deg p\n 2. p \\<noteq> 0 \\<Longrightarrow> poly_deg (homogenize x p) = poly_deg p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly_deg (homogenize x p) = poly_deg p\n 2. p \\<noteq> 0 \\<Longrightarrow> poly_deg (homogenize x p) = poly_deg p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. poly_deg (homogenize x p) = poly_deg p", "by simp"], ["proof (state)\nthis:\n  poly_deg (homogenize x p) = poly_deg p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (homogenize x p) = poly_deg p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (homogenize x p) = poly_deg p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (homogenize x p) = poly_deg p", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "obtain t where \"t \\<in> keys p\" and 1: \"poly_deg p = deg_pm t\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; poly_deg p = deg_pm t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_degE)"], ["proof (state)\nthis:\n  t \\<in> keys p\n  poly_deg p = deg_pm t\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (homogenize x p) = poly_deg p", "from assms this(1)"], ["proof (chain)\npicking this:\n  x \\<notin> indets p\n  t \\<in> keys p", "have \"Poly_Mapping.single x (poly_deg p - deg_pm t) + t \\<in> keys (homogenize x p)\""], ["proof (prove)\nusing this:\n  x \\<notin> indets p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)", "by (rule keys_homogenizeI)"], ["proof (state)\nthis:\n  monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (homogenize x p) = poly_deg p", "hence \"t \\<in> keys (homogenize x p)\""], ["proof (prove)\nusing this:\n  monomial (poly_deg p - deg_pm t) x + t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (homogenize x p)", "by (simp add: 1)"], ["proof (state)\nthis:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (homogenize x p) = poly_deg p", "hence \"poly_deg p \\<le> poly_deg (homogenize x p)\""], ["proof (prove)\nusing this:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (homogenize x p)", "unfolding 1"], ["proof (prove)\nusing this:\n  t \\<in> keys (homogenize x p)\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg (homogenize x p)", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  poly_deg p \\<le> poly_deg (homogenize x p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly_deg (homogenize x p) = poly_deg p", "with poly_deg_homogenize_le"], ["proof (chain)\npicking this:\n  poly_deg (homogenize ?x ?p) \\<le> poly_deg ?p\n  poly_deg p \\<le> poly_deg (homogenize x p)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg (homogenize ?x ?p) \\<le> poly_deg ?p\n  poly_deg p \\<le> poly_deg (homogenize x p)\n\ngoal (1 subgoal):\n 1. poly_deg (homogenize x p) = poly_deg p", "by (rule antisym)"], ["proof (state)\nthis:\n  poly_deg (homogenize x p) = poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maxdeg_homogenize:\n  assumes \"x \\<notin> \\<Union> (indets ` F)\"\n  shows \"maxdeg (homogenize x ` F) = maxdeg F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxdeg (homogenize x ` F) = maxdeg F", "unfolding maxdeg_def image_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX xa\\<in>F. poly_deg (homogenize x xa)) = Max (poly_deg ` F)", "proof (rule arg_cong[where f=Max], rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> (\\<lambda>xa. poly_deg (homogenize x xa)) ` F) =\n       (xa \\<in> poly_deg ` F)", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> (\\<lambda>xa. poly_deg (homogenize x xa)) ` F) =\n       (xa \\<in> poly_deg ` F)", "show \"d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F \\<longleftrightarrow> d \\<in> poly_deg ` F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F) =\n    (d \\<in> poly_deg ` F)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F \\<Longrightarrow>\n    d \\<in> poly_deg ` F\n 2. d \\<in> poly_deg ` F \\<Longrightarrow>\n    d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "assume \"d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F\""], ["proof (state)\nthis:\n  d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F\n\ngoal (2 subgoals):\n 1. d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F \\<Longrightarrow>\n    d \\<in> poly_deg ` F\n 2. d \\<in> poly_deg ` F \\<Longrightarrow>\n    d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "then"], ["proof (chain)\npicking this:\n  d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "obtain f where \"f \\<in> F\" and d: \"d = poly_deg (homogenize x f)\""], ["proof (prove)\nusing this:\n  d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F; d = poly_deg (homogenize x f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  f \\<in> F\n  d = poly_deg (homogenize x f)\n\ngoal (2 subgoals):\n 1. d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F \\<Longrightarrow>\n    d \\<in> poly_deg ` F\n 2. d \\<in> poly_deg ` F \\<Longrightarrow>\n    d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "from assms this(1)"], ["proof (chain)\npicking this:\n  x \\<notin> \\<Union> (indets ` F)\n  f \\<in> F", "have \"x \\<notin> indets f\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<Union> (indets ` F)\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. x \\<notin> indets f", "by blast"], ["proof (state)\nthis:\n  x \\<notin> indets f\n\ngoal (2 subgoals):\n 1. d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F \\<Longrightarrow>\n    d \\<in> poly_deg ` F\n 2. d \\<in> poly_deg ` F \\<Longrightarrow>\n    d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "hence \"d = poly_deg f\""], ["proof (prove)\nusing this:\n  x \\<notin> indets f\n\ngoal (1 subgoal):\n 1. d = poly_deg f", "by (simp add: d poly_deg_homogenize)"], ["proof (state)\nthis:\n  d = poly_deg f\n\ngoal (2 subgoals):\n 1. d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F \\<Longrightarrow>\n    d \\<in> poly_deg ` F\n 2. d \\<in> poly_deg ` F \\<Longrightarrow>\n    d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "with \\<open>f \\<in> F\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F\n  d = poly_deg f", "show \"d \\<in> poly_deg ` F\""], ["proof (prove)\nusing this:\n  f \\<in> F\n  d = poly_deg f\n\ngoal (1 subgoal):\n 1. d \\<in> poly_deg ` F", "by (rule rev_image_eqI)"], ["proof (state)\nthis:\n  d \\<in> poly_deg ` F\n\ngoal (1 subgoal):\n 1. d \\<in> poly_deg ` F \\<Longrightarrow>\n    d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<in> poly_deg ` F \\<Longrightarrow>\n    d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "assume \"d \\<in> poly_deg ` F\""], ["proof (state)\nthis:\n  d \\<in> poly_deg ` F\n\ngoal (1 subgoal):\n 1. d \\<in> poly_deg ` F \\<Longrightarrow>\n    d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "then"], ["proof (chain)\npicking this:\n  d \\<in> poly_deg ` F", "obtain f where \"f \\<in> F\" and d: \"d = poly_deg f\""], ["proof (prove)\nusing this:\n  d \\<in> poly_deg ` F\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F; d = poly_deg f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  f \\<in> F\n  d = poly_deg f\n\ngoal (1 subgoal):\n 1. d \\<in> poly_deg ` F \\<Longrightarrow>\n    d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "from assms this(1)"], ["proof (chain)\npicking this:\n  x \\<notin> \\<Union> (indets ` F)\n  f \\<in> F", "have \"x \\<notin> indets f\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<Union> (indets ` F)\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. x \\<notin> indets f", "by blast"], ["proof (state)\nthis:\n  x \\<notin> indets f\n\ngoal (1 subgoal):\n 1. d \\<in> poly_deg ` F \\<Longrightarrow>\n    d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "hence \"d = poly_deg (homogenize x f)\""], ["proof (prove)\nusing this:\n  x \\<notin> indets f\n\ngoal (1 subgoal):\n 1. d = poly_deg (homogenize x f)", "by (simp add: d poly_deg_homogenize)"], ["proof (state)\nthis:\n  d = poly_deg (homogenize x f)\n\ngoal (1 subgoal):\n 1. d \\<in> poly_deg ` F \\<Longrightarrow>\n    d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "with \\<open>f \\<in> F\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F\n  d = poly_deg (homogenize x f)", "show \"d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F\""], ["proof (prove)\nusing this:\n  f \\<in> F\n  d = poly_deg (homogenize x f)\n\ngoal (1 subgoal):\n 1. d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F", "by (rule rev_image_eqI)"], ["proof (state)\nthis:\n  d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (d \\<in> (\\<lambda>f. poly_deg (homogenize x f)) ` F) =\n  (d \\<in> poly_deg ` F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogeneous_ideal_homogenize:\n  assumes \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"p \\<in> ideal F\"\n  shows \"homogenize x p \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x p \\<in> ideal F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. homogenize x p \\<in> ideal F", "have \"homogenize x p = (\\<Sum>q\\<in>hom_components p. punit.monom_mult 1 (Poly_Mapping.single x (poly_deg p - poly_deg q)) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x p =\n    (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)", "by (fact homogenize_alt)"], ["proof (state)\nthis:\n  homogenize x p =\n  (\\<Sum>q\\<in>hom_components p.\n     punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)\n\ngoal (1 subgoal):\n 1. homogenize x p \\<in> ideal F", "also"], ["proof (state)\nthis:\n  homogenize x p =\n  (\\<Sum>q\\<in>hom_components p.\n     punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)\n\ngoal (1 subgoal):\n 1. homogenize x p \\<in> ideal F", "have \"\\<dots> \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>hom_components p.\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)\n    \\<in> ideal F", "proof (rule ideal.span_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> hom_components p \\<Longrightarrow>\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg xa) x) xa\n       \\<in> ideal F", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> hom_components p \\<Longrightarrow>\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg xa) x) xa\n       \\<in> ideal F", "assume \"q \\<in> hom_components p\""], ["proof (state)\nthis:\n  q \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> hom_components p \\<Longrightarrow>\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg xa) x) xa\n       \\<in> ideal F", "with assms"], ["proof (chain)\npicking this:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f\n  p \\<in> ideal F\n  q \\<in> hom_components p", "have \"q \\<in> ideal F\""], ["proof (prove)\nusing this:\n  ?f \\<in> F \\<Longrightarrow> homogeneous ?f\n  p \\<in> ideal F\n  q \\<in> hom_components p\n\ngoal (1 subgoal):\n 1. q \\<in> ideal F", "by (rule homogeneous_ideal')"], ["proof (state)\nthis:\n  q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> hom_components p \\<Longrightarrow>\n       punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg xa) x) xa\n       \\<in> ideal F", "thus \"punit.monom_mult 1 (Poly_Mapping.single x (poly_deg p - poly_deg q)) q \\<in> ideal F\""], ["proof (prove)\nusing this:\n  q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q\n    \\<in> ideal F", "by (rule punit.pmdl_closed_monom_mult[simplified])"], ["proof (state)\nthis:\n  punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q\n  \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>hom_components p.\n     punit.monom_mult (1::'b) (monomial (poly_deg p - poly_deg q) x) q)\n  \\<in> ideal F\n\ngoal (1 subgoal):\n 1. homogenize x p \\<in> ideal F", "finally"], ["proof (chain)\npicking this:\n  homogenize x p \\<in> ideal F", "show ?thesis"], ["proof (prove)\nusing this:\n  homogenize x p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. homogenize x p \\<in> ideal F", "."], ["proof (state)\nthis:\n  homogenize x p \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_pp_dehomo_subst [simp]:\n  \"subst_pp (dehomo_subst x) t = monomial (1::'b::comm_semiring_1) (except t {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "have \"subst_pp (dehomo_subst x) t = ((\\<Prod>y\\<in>keys t. dehomo_subst x y ^ lookup t y)::_ \\<Rightarrow>\\<^sub>0 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t =\n    (\\<Prod>y\\<in>keys t. dehomo_subst x y ^ lookup t y)", "by (fact subst_pp_def)"], ["proof (state)\nthis:\n  subst_pp (dehomo_subst x) t =\n  (\\<Prod>y\\<in>keys t. dehomo_subst x y ^ lookup t y)\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "also"], ["proof (state)\nthis:\n  subst_pp (dehomo_subst x) t =\n  (\\<Prod>y\\<in>keys t. dehomo_subst x y ^ lookup t y)\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "have \"\\<dots> = (\\<Prod>y\\<in>keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = (1::_ \\<Rightarrow>\\<^sub>0 'b)}. dehomo_subst x y ^ lookup t y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>keys t. dehomo_subst x y ^ lookup t y) =\n    (\\<Prod>y\\<in>keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1}.\n       dehomo_subst x y ^ lookup t y)", "by (rule sym, rule prod.setdiff_irrelevant, fact finite_keys)"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>keys t. dehomo_subst x y ^ lookup t y) =\n  (\\<Prod>y\\<in>keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1}.\n     dehomo_subst x y ^ lookup t y)\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "also"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>keys t. dehomo_subst x y ^ lookup t y) =\n  (\\<Prod>y\\<in>keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1}.\n     dehomo_subst x y ^ lookup t y)\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "have \"\\<dots> = (\\<Prod>y\\<in>keys t - {x}. monomial 1 (Poly_Mapping.single y 1) ^ lookup t y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1}.\n       dehomo_subst x y ^ lookup t y) =\n    (\\<Prod>y\\<in>keys t - {x}.\n       monomial (1::'b) (monomial 1 y) ^ lookup t y)", "proof (rule prod.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "have \"dehomo_subst x x ^ lookup t x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomo_subst x x ^ lookup t x = 1", "by (simp add: dehomo_subst_def)"], ["proof (state)\nthis:\n  dehomo_subst x x ^ lookup t x = 1\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "moreover"], ["proof (state)\nthis:\n  dehomo_subst x x ^ lookup t x = 1\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "{"], ["proof (state)\nthis:\n  dehomo_subst x x ^ lookup t x = 1\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "assume \"y \\<noteq> x\""], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "hence \"dehomo_subst x y ^ lookup t y = monomial 1 (Poly_Mapping.single y (lookup t y))\""], ["proof (prove)\nusing this:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. dehomo_subst x y ^ lookup t y =\n    monomial (1::'c) (monomial (lookup t y) y)", "by (simp add: dehomo_subst_def monomial_single_power)"], ["proof (state)\nthis:\n  dehomo_subst x y ^ lookup t y =\n  monomial (1::?'c2) (monomial (lookup t y) y)\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "moreover"], ["proof (state)\nthis:\n  dehomo_subst x y ^ lookup t y =\n  monomial (1::?'c2) (monomial (lookup t y) y)\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "assume \"dehomo_subst x y ^ lookup t y = 1\""], ["proof (state)\nthis:\n  dehomo_subst x y ^ lookup t y = 1\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "ultimately"], ["proof (chain)\npicking this:\n  dehomo_subst x y ^ lookup t y =\n  monomial (1::?'c2) (monomial (lookup t y) y)\n  dehomo_subst x y ^ lookup t y = 1", "have \"Poly_Mapping.single y (lookup t y) = 0\""], ["proof (prove)\nusing this:\n  dehomo_subst x y ^ lookup t y =\n  monomial (1::?'c2) (monomial (lookup t y) y)\n  dehomo_subst x y ^ lookup t y = 1\n\ngoal (1 subgoal):\n 1. monomial (lookup t y) y = 0", "by (smt single_one monomial_inj zero_neq_one)"], ["proof (state)\nthis:\n  monomial (lookup t y) y = 0\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "hence \"lookup t y = 0\""], ["proof (prove)\nusing this:\n  monomial (lookup t y) y = 0\n\ngoal (1 subgoal):\n 1. lookup t y = 0", "by (rule monomial_0D)"], ["proof (state)\nthis:\n  lookup t y = 0\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "moreover"], ["proof (state)\nthis:\n  lookup t y = 0\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "assume \"y \\<in> keys t\""], ["proof (state)\nthis:\n  y \\<in> keys t\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "ultimately"], ["proof (chain)\npicking this:\n  lookup t y = 0\n  y \\<in> keys t", "have False"], ["proof (prove)\nusing this:\n  lookup t y = 0\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. False", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?y3 \\<noteq> x; dehomo_subst x ?y3 ^ lookup t ?y3 = 1;\n   ?y3 \\<in> keys t\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n 2. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "ultimately"], ["proof (chain)\npicking this:\n  dehomo_subst x x ^ lookup t x = 1\n  \\<lbrakk>?y3 \\<noteq> x; dehomo_subst x ?y3 ^ lookup t ?y3 = 1;\n   ?y3 \\<in> keys t\\<rbrakk>\n  \\<Longrightarrow> False", "show \"keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\""], ["proof (prove)\nusing this:\n  dehomo_subst x x ^ lookup t x = 1\n  \\<lbrakk>?y3 \\<noteq> x; dehomo_subst x ?y3 ^ lookup t ?y3 = 1;\n   ?y3 \\<in> keys t\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}", "by auto"], ["proof (state)\nthis:\n  keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1} = keys t - {x}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys t - {x} \\<Longrightarrow>\n       dehomo_subst x xa ^ lookup t xa =\n       monomial (1::'b) (monomial 1 xa) ^ lookup t xa", "qed (simp add: dehomo_subst_def)"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1}.\n     dehomo_subst x y ^ lookup t y) =\n  (\\<Prod>y\\<in>keys t - {x}. monomial (1::'b) (monomial 1 y) ^ lookup t y)\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "also"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>keys t - {y0. dehomo_subst x y0 ^ lookup t y0 = 1}.\n     dehomo_subst x y ^ lookup t y) =\n  (\\<Prod>y\\<in>keys t - {x}. monomial (1::'b) (monomial 1 y) ^ lookup t y)\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "have \"\\<dots> = (\\<Prod>y\\<in>keys t - {x}. monomial 1 (Poly_Mapping.single y (lookup t y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>keys t - {x}.\n       monomial (1::'b) (monomial 1 y) ^ lookup t y) =\n    (\\<Prod>y\\<in>keys t - {x}. monomial (1::'b) (monomial (lookup t y) y))", "by (simp add: monomial_single_power)"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>keys t - {x}.\n     monomial (1::'b) (monomial 1 y) ^ lookup t y) =\n  (\\<Prod>y\\<in>keys t - {x}. monomial (1::'b) (monomial (lookup t y) y))\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "also"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>keys t - {x}.\n     monomial (1::'b) (monomial 1 y) ^ lookup t y) =\n  (\\<Prod>y\\<in>keys t - {x}. monomial (1::'b) (monomial (lookup t y) y))\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "have \"\\<dots> = monomial 1 (\\<Sum>y\\<in>keys t - {x}. Poly_Mapping.single y (lookup t y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>keys t - {x}.\n       monomial (1::'b) (monomial (lookup t y) y)) =\n    monomial (1::'b) (\\<Sum>y\\<in>keys t - {x}. monomial (lookup t y) y)", "by (simp flip: punit.monomial_prod_sum)"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>keys t - {x}. monomial (1::'b) (monomial (lookup t y) y)) =\n  monomial (1::'b) (\\<Sum>y\\<in>keys t - {x}. monomial (lookup t y) y)\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "also"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>keys t - {x}. monomial (1::'b) (monomial (lookup t y) y)) =\n  monomial (1::'b) (\\<Sum>y\\<in>keys t - {x}. monomial (lookup t y) y)\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "have \"(\\<Sum>y\\<in>keys t - {x}. Poly_Mapping.single y (lookup t y)) = except t {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t - {x}. monomial (lookup t y) y) = except t {x}", "proof (rule poly_mapping_eqI, simp add: lookup_sum lookup_except lookup_single, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<noteq> x \\<Longrightarrow>\n       (\\<Sum>x\\<in>keys t - {x}. lookup t x when x = k) = lookup t k", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<noteq> x \\<Longrightarrow>\n       (\\<Sum>x\\<in>keys t - {x}. lookup t x when x = k) = lookup t k", "assume \"y \\<noteq> x\""], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<noteq> x \\<Longrightarrow>\n       (\\<Sum>x\\<in>keys t - {x}. lookup t x when x = k) = lookup t k", "show \"(\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "proof (cases \"y \\<in> keys t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "case True"], ["proof (state)\nthis:\n  y \\<in> keys t\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "have \"finite (keys t - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (keys t - {x})", "by simp"], ["proof (state)\nthis:\n  finite (keys t - {x})\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "moreover"], ["proof (state)\nthis:\n  finite (keys t - {x})\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "from True \\<open>y \\<noteq> x\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> keys t\n  y \\<noteq> x", "have \"y \\<in> keys t - {x}\""], ["proof (prove)\nusing this:\n  y \\<in> keys t\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. y \\<in> keys t - {x}", "by simp"], ["proof (state)\nthis:\n  y \\<in> keys t - {x}\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "ultimately"], ["proof (chain)\npicking this:\n  finite (keys t - {x})\n  y \\<in> keys t - {x}", "have \"(\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) =\n                        (lookup t y when y = y) + (\\<Sum>z\\<in>keys t - {x} - {y}. lookup t z when z = y)\""], ["proof (prove)\nusing this:\n  finite (keys t - {x})\n  y \\<in> keys t - {x}\n\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) =\n    (lookup t y when y = y) +\n    (\\<Sum>z\\<in>keys t - {x} - {y}. lookup t z when z = y)", "by (rule sum.remove)"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) =\n  (lookup t y when y = y) +\n  (\\<Sum>z\\<in>keys t - {x} - {y}. lookup t z when z = y)\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) =\n  (lookup t y when y = y) +\n  (\\<Sum>z\\<in>keys t - {x} - {y}. lookup t z when z = y)\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "have \"(\\<Sum>z\\<in>keys t - {x} - {y}. lookup t z when z = y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>keys t - {x} - {y}. lookup t z when z = y) = 0", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>keys t - {x} - {y}. lookup t z when z = y) = 0\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) =\n  (lookup t y when y = y) + 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) =\n  (lookup t y when y = y) + 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n\ngoal (1 subgoal):\n 1. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "case False"], ["proof (state)\nthis:\n  y \\<notin> keys t\n\ngoal (1 subgoal):\n 1. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "hence \"(\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = 0\""], ["proof (prove)\nusing this:\n  y \\<notin> keys t\n\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = 0", "by (auto simp: when_def)"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = 0\n\ngoal (1 subgoal):\n 1. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = 0\n\ngoal (1 subgoal):\n 1. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "from False"], ["proof (chain)\npicking this:\n  y \\<notin> keys t", "have \"\\<dots> = lookup t y\""], ["proof (prove)\nusing this:\n  y \\<notin> keys t\n\ngoal (1 subgoal):\n 1. 0 = lookup t y", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  0 = lookup t y\n\ngoal (1 subgoal):\n 1. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y", "."], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>keys t - {x}. lookup t z when z = y) = lookup t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>keys t - {x}. monomial (lookup t y) y) = except t {x}\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "finally"], ["proof (chain)\npicking this:\n  subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})\n\ngoal (1 subgoal):\n 1. subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})", "."], ["proof (state)\nthis:\n  subst_pp (dehomo_subst x) t = monomial (1::'b) (except t {x})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  shows dehomogenize_zero [simp]: \"dehomogenize x 0 = 0\"\n    and dehomogenize_one [simp]: \"dehomogenize x 1 = 1\"\n    and dehomogenize_monomial: \"dehomogenize x (monomial c t) = monomial c (except t {x})\"\n    and dehomogenize_plus: \"dehomogenize x (p + q) = dehomogenize x p + dehomogenize x q\"\n    and dehomogenize_uminus: \"dehomogenize x (- r) = - dehomogenize x (r::_ \\<Rightarrow>\\<^sub>0 _::comm_ring_1)\"\n    and dehomogenize_minus: \"dehomogenize x (r - r') = dehomogenize x r - dehomogenize x r'\"\n    and dehomogenize_times: \"dehomogenize x (p * q) = dehomogenize x p * dehomogenize x q\"\n    and dehomogenize_power: \"dehomogenize x (p ^ n) = dehomogenize x p ^ n\"\n    and dehomogenize_sum: \"dehomogenize x (sum f A) = (\\<Sum>a\\<in>A. dehomogenize x (f a))\"\n    and dehomogenize_prod: \"dehomogenize x (prod f A) = (\\<Prod>a\\<in>A. dehomogenize x (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((dehomogenize x 0 = 0 &&& dehomogenize x 1 = 1) &&&\n     dehomogenize x (monomial c t) = monomial c (except t {x}) &&&\n     dehomogenize x (p + q) = dehomogenize x p + dehomogenize x q &&&\n     dehomogenize x (- r) = - dehomogenize x r) &&&\n    (dehomogenize x (r - r') = dehomogenize x r - dehomogenize x r' &&&\n     dehomogenize x (p * q) = dehomogenize x p * dehomogenize x q) &&&\n    dehomogenize x (p ^ n) = dehomogenize x p ^ n &&&\n    dehomogenize x (sum f A) = (\\<Sum>a\\<in>A. dehomogenize x (f a)) &&&\n    dehomogenize x (prod f A) = (\\<Prod>a\\<in>A. dehomogenize x (f a))", "by (simp_all add: dehomogenize_def poly_subst_monomial poly_subst_plus poly_subst_uminus\n      poly_subst_minus poly_subst_times poly_subst_power poly_subst_sum poly_subst_prod punit.monom_mult_monomial)"], ["", "corollary dehomogenize_monom_mult:\n  \"dehomogenize x (punit.monom_mult c t p) = punit.monom_mult c (except t {x}) (dehomogenize x p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x (punit.monom_mult c t p) =\n    punit.monom_mult c (except t {x}) (dehomogenize x p)", "by (simp only: times_monomial_left[symmetric] dehomogenize_times dehomogenize_monomial)"], ["", "lemma poly_deg_dehomogenize_le: \"poly_deg (dehomogenize x p) \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (dehomogenize x p) \\<le> poly_deg p", "unfolding dehomogenize_def dehomo_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg\n     (poly_subst\n       (\\<lambda>y. if y = x then 1 else monomial (1::'b) (monomial 1 y)) p)\n    \\<le> poly_deg p", "by (rule poly_deg_poly_subst_le) (simp add: poly_deg_monomial deg_pm_single)"], ["", "lemma indets_dehomogenize: \"indets (dehomogenize x p) \\<subseteq> indets p - {x}\"\n  for p::\"('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (dehomogenize x p) \\<subseteq> indets p - {x}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (dehomogenize x p) \\<Longrightarrow>\n       xa \\<in> indets p - {x}", "fix y::'x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (dehomogenize x p) \\<Longrightarrow>\n       xa \\<in> indets p - {x}", "assume \"y \\<in> indets (dehomogenize x p)\""], ["proof (state)\nthis:\n  y \\<in> indets (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (dehomogenize x p) \\<Longrightarrow>\n       xa \\<in> indets p - {x}", "then"], ["proof (chain)\npicking this:\n  y \\<in> indets (dehomogenize x p)", "obtain y' where \"y' \\<in> indets p\" and \"y \\<in> indets ((dehomo_subst x y')::_ \\<Rightarrow>\\<^sub>0 'a)\""], ["proof (prove)\nusing this:\n  y \\<in> indets (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>y' \\<in> indets p;\n         y \\<in> indets (dehomo_subst x y')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dehomogenize_def"], ["proof (prove)\nusing this:\n  y \\<in> indets (poly_subst (dehomo_subst x) p)\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>y' \\<in> indets p;\n         y \\<in> indets (dehomo_subst x y')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_indets_poly_substE)"], ["proof (state)\nthis:\n  y' \\<in> indets p\n  y \\<in> indets (dehomo_subst x y')\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (dehomogenize x p) \\<Longrightarrow>\n       xa \\<in> indets p - {x}", "from this(2)"], ["proof (chain)\npicking this:\n  y \\<in> indets (dehomo_subst x y')", "have \"y = y'\" and \"y' \\<noteq> x\""], ["proof (prove)\nusing this:\n  y \\<in> indets (dehomo_subst x y')\n\ngoal (1 subgoal):\n 1. y = y' &&& y' \\<noteq> x", "by (simp_all add: dehomo_subst_def indets_monomial split: if_split_asm)"], ["proof (state)\nthis:\n  y = y'\n  y' \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets (dehomogenize x p) \\<Longrightarrow>\n       xa \\<in> indets p - {x}", "with \\<open>y' \\<in> indets p\\<close>"], ["proof (chain)\npicking this:\n  y' \\<in> indets p\n  y = y'\n  y' \\<noteq> x", "show \"y \\<in> indets p - {x}\""], ["proof (prove)\nusing this:\n  y' \\<in> indets p\n  y = y'\n  y' \\<noteq> x\n\ngoal (1 subgoal):\n 1. y \\<in> indets p - {x}", "by simp"], ["proof (state)\nthis:\n  y \\<in> indets p - {x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dehomogenize_id_iff [simp]: \"dehomogenize x p = p \\<longleftrightarrow> x \\<notin> indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dehomogenize x p = p) = (x \\<notin> indets p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. dehomogenize x p = p \\<Longrightarrow> x \\<notin> indets p\n 2. x \\<notin> indets p \\<Longrightarrow> dehomogenize x p = p", "assume eq: \"dehomogenize x p = p\""], ["proof (state)\nthis:\n  dehomogenize x p = p\n\ngoal (2 subgoals):\n 1. dehomogenize x p = p \\<Longrightarrow> x \\<notin> indets p\n 2. x \\<notin> indets p \\<Longrightarrow> dehomogenize x p = p", "from indets_dehomogenize[of x p]"], ["proof (chain)\npicking this:\n  indets (dehomogenize x p) \\<subseteq> indets p - {x}", "show \"x \\<notin> indets p\""], ["proof (prove)\nusing this:\n  indets (dehomogenize x p) \\<subseteq> indets p - {x}\n\ngoal (1 subgoal):\n 1. x \\<notin> indets p", "by (auto simp: eq)"], ["proof (state)\nthis:\n  x \\<notin> indets p\n\ngoal (1 subgoal):\n 1. x \\<notin> indets p \\<Longrightarrow> dehomogenize x p = p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> indets p \\<Longrightarrow> dehomogenize x p = p", "assume a: \"x \\<notin> indets p\""], ["proof (state)\nthis:\n  x \\<notin> indets p\n\ngoal (1 subgoal):\n 1. x \\<notin> indets p \\<Longrightarrow> dehomogenize x p = p", "show \"dehomogenize x p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x p = p", "unfolding dehomogenize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst (dehomo_subst x) p = p", "proof (rule poly_subst_id)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets p \\<Longrightarrow>\n       dehomo_subst x xa = monomial (1::'b) (monomial 1 xa)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets p \\<Longrightarrow>\n       dehomo_subst x xa = monomial (1::'b) (monomial 1 xa)", "assume \"y \\<in> indets p\""], ["proof (state)\nthis:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets p \\<Longrightarrow>\n       dehomo_subst x xa = monomial (1::'b) (monomial 1 xa)", "with a"], ["proof (chain)\npicking this:\n  x \\<notin> indets p\n  y \\<in> indets p", "have \"y \\<noteq> x\""], ["proof (prove)\nusing this:\n  x \\<notin> indets p\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. y \\<noteq> x", "by blast"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> indets p \\<Longrightarrow>\n       dehomo_subst x xa = monomial (1::'b) (monomial 1 xa)", "thus \"dehomo_subst x y = monomial 1 (Poly_Mapping.single y 1)\""], ["proof (prove)\nusing this:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. dehomo_subst x y = monomial (1::'c) (monomial 1 y)", "by (simp add: dehomo_subst_def)"], ["proof (state)\nthis:\n  dehomo_subst x y = monomial (1::?'c1) (monomial 1 y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dehomogenize x p = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dehomogenize_dehomogenize [simp]: \"dehomogenize x (dehomogenize x p) = dehomogenize x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x (dehomogenize x p) = dehomogenize x p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dehomogenize x (dehomogenize x p) = dehomogenize x p", "from indets_dehomogenize[of x p]"], ["proof (chain)\npicking this:\n  indets (dehomogenize x p) \\<subseteq> indets p - {x}", "have \"x \\<notin> indets (dehomogenize x p)\""], ["proof (prove)\nusing this:\n  indets (dehomogenize x p) \\<subseteq> indets p - {x}\n\ngoal (1 subgoal):\n 1. x \\<notin> indets (dehomogenize x p)", "by blast"], ["proof (state)\nthis:\n  x \\<notin> indets (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. dehomogenize x (dehomogenize x p) = dehomogenize x p", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> indets (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. dehomogenize x (dehomogenize x p) = dehomogenize x p", "by simp"], ["proof (state)\nthis:\n  dehomogenize x (dehomogenize x p) = dehomogenize x p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dehomogenize_homogenize [simp]: \"dehomogenize x (homogenize x p) = dehomogenize x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x (homogenize x p) = dehomogenize x p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dehomogenize x (homogenize x p) = dehomogenize x p", "have \"dehomogenize x (homogenize x p) = sum (dehomogenize x) (hom_components p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x (homogenize x p) =\n    sum (dehomogenize x) (hom_components p)", "by (simp add: homogenize_alt dehomogenize_sum dehomogenize_monom_mult except_single)"], ["proof (state)\nthis:\n  dehomogenize x (homogenize x p) = sum (dehomogenize x) (hom_components p)\n\ngoal (1 subgoal):\n 1. dehomogenize x (homogenize x p) = dehomogenize x p", "also"], ["proof (state)\nthis:\n  dehomogenize x (homogenize x p) = sum (dehomogenize x) (hom_components p)\n\ngoal (1 subgoal):\n 1. dehomogenize x (homogenize x p) = dehomogenize x p", "have \"\\<dots> = dehomogenize x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (dehomogenize x) (hom_components p) = dehomogenize x p", "by (simp only: sum_hom_components flip: dehomogenize_sum)"], ["proof (state)\nthis:\n  sum (dehomogenize x) (hom_components p) = dehomogenize x p\n\ngoal (1 subgoal):\n 1. dehomogenize x (homogenize x p) = dehomogenize x p", "finally"], ["proof (chain)\npicking this:\n  dehomogenize x (homogenize x p) = dehomogenize x p", "show ?thesis"], ["proof (prove)\nusing this:\n  dehomogenize x (homogenize x p) = dehomogenize x p\n\ngoal (1 subgoal):\n 1. dehomogenize x (homogenize x p) = dehomogenize x p", "."], ["proof (state)\nthis:\n  dehomogenize x (homogenize x p) = dehomogenize x p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary dehomogenize_homogenize_id: \"x \\<notin> indets p \\<Longrightarrow> dehomogenize x (homogenize x p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> indets p \\<Longrightarrow>\n    dehomogenize x (homogenize x p) = p", "by simp"], ["", "lemma range_dehomogenize: \"range (dehomogenize x) = (P[- {x}] :: (_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (dehomogenize x) = P[- {x}]", "proof (intro subset_antisym subsetI PolysI_alt range_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> range (dehomogenize x);\n        xaa \\<in> indets xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> - {x}\n 2. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "fix p::\"_ \\<Rightarrow>\\<^sub>0 'a\" and y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> range (dehomogenize x);\n        xaa \\<in> indets xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> - {x}\n 2. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "assume \"p \\<in> range (dehomogenize x)\""], ["proof (state)\nthis:\n  p \\<in> range (dehomogenize x)\n\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> range (dehomogenize x);\n        xaa \\<in> indets xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> - {x}\n 2. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "then"], ["proof (chain)\npicking this:\n  p \\<in> range (dehomogenize x)", "obtain q where p: \"p = dehomogenize x q\""], ["proof (prove)\nusing this:\n  p \\<in> range (dehomogenize x)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = dehomogenize x q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p = dehomogenize x q\n\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> range (dehomogenize x);\n        xaa \\<in> indets xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> - {x}\n 2. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "assume \"y \\<in> indets p\""], ["proof (state)\nthis:\n  y \\<in> indets p\n\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> range (dehomogenize x);\n        xaa \\<in> indets xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> - {x}\n 2. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "hence \"y \\<in> indets (dehomogenize x q)\""], ["proof (prove)\nusing this:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. y \\<in> indets (dehomogenize x q)", "by (simp only: p)"], ["proof (state)\nthis:\n  y \\<in> indets (dehomogenize x q)\n\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> range (dehomogenize x);\n        xaa \\<in> indets xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> - {x}\n 2. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "with indets_dehomogenize"], ["proof (chain)\npicking this:\n  indets (dehomogenize ?x ?p) \\<subseteq> indets ?p - {?x}\n  y \\<in> indets (dehomogenize x q)", "have \"y \\<in> indets q - {x}\""], ["proof (prove)\nusing this:\n  indets (dehomogenize ?x ?p) \\<subseteq> indets ?p - {?x}\n  y \\<in> indets (dehomogenize x q)\n\ngoal (1 subgoal):\n 1. y \\<in> indets q - {x}", ".."], ["proof (state)\nthis:\n  y \\<in> indets q - {x}\n\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> range (dehomogenize x);\n        xaa \\<in> indets xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> - {x}\n 2. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "thus \"y \\<in> - {x}\""], ["proof (prove)\nusing this:\n  y \\<in> indets q - {x}\n\ngoal (1 subgoal):\n 1. y \\<in> - {x}", "by simp"], ["proof (state)\nthis:\n  y \\<in> - {x}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "fix p::\"_ \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "assume \"p \\<in> P[- {x}]\""], ["proof (state)\nthis:\n  p \\<in> P[- {x}]\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "hence \"x \\<notin> indets p\""], ["proof (prove)\nusing this:\n  p \\<in> P[- {x}]\n\ngoal (1 subgoal):\n 1. x \\<notin> indets p", "by (auto dest: PolysD)"], ["proof (state)\nthis:\n  x \\<notin> indets p\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> P[- {x}] \\<Longrightarrow> xa = dehomogenize x (?x2 xa)", "thus \"p = dehomogenize x (homogenize x p)\""], ["proof (prove)\nusing this:\n  x \\<notin> indets p\n\ngoal (1 subgoal):\n 1. p = dehomogenize x (homogenize x p)", "by (rule dehomogenize_homogenize_id[symmetric])"], ["proof (state)\nthis:\n  p = dehomogenize x (homogenize x p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dehomogenize_alt: \"dehomogenize x p = (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x p =\n    (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dehomogenize x p =\n    (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))", "have \"dehomogenize x p = dehomogenize x (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x p =\n    dehomogenize x (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)", "by (simp only: poly_mapping_sum_monomials)"], ["proof (state)\nthis:\n  dehomogenize x p =\n  dehomogenize x (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)\n\ngoal (1 subgoal):\n 1. dehomogenize x p =\n    (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))", "also"], ["proof (state)\nthis:\n  dehomogenize x p =\n  dehomogenize x (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)\n\ngoal (1 subgoal):\n 1. dehomogenize x p =\n    (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))", "have \"\\<dots> = (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) =\n    (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))", "by (simp only: dehomogenize_sum dehomogenize_monomial)"], ["proof (state)\nthis:\n  dehomogenize x (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) =\n  (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))\n\ngoal (1 subgoal):\n 1. dehomogenize x p =\n    (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))", "finally"], ["proof (chain)\npicking this:\n  dehomogenize x p =\n  (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))", "show ?thesis"], ["proof (prove)\nusing this:\n  dehomogenize x p =\n  (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))\n\ngoal (1 subgoal):\n 1. dehomogenize x p =\n    (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))", "."], ["proof (state)\nthis:\n  dehomogenize x p =\n  (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_dehomogenizeE:\n  assumes \"t \\<in> keys (dehomogenize x p)\"\n  obtains s where \"s \\<in> keys p\" and \"t = except s {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = except s {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = except s {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms"], ["proof (state)\nthis:\n  t \\<in> keys (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = except s {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  t \\<in> keys (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = except s {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"keys (dehomogenize x p) \\<subseteq> (\\<Union>s\\<in>keys p. keys (monomial (lookup p s) (except s {x})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (dehomogenize x p)\n    \\<subseteq> (\\<Union>s\\<in>keys p.\n                    keys (monomial (lookup p s) (except s {x})))", "unfolding dehomogenize_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t {x}))\n    \\<subseteq> (\\<Union>s\\<in>keys p.\n                    keys (monomial (lookup p s) (except s {x})))", "by (rule keys_sum_subset)"], ["proof (state)\nthis:\n  keys (dehomogenize x p)\n  \\<subseteq> (\\<Union>s\\<in>keys p.\n                  keys (monomial (lookup p s) (except s {x})))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = except s {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  t \\<in> (\\<Union>s\\<in>keys p.\n              keys (monomial (lookup p s) (except s {x})))", "obtain s where \"s \\<in> keys p\" and \"t \\<in> keys (monomial (lookup p s) (except s {x}))\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>s\\<in>keys p.\n              keys (monomial (lookup p s) (except s {x})))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t \\<in> keys (monomial (lookup p s) (except s {x}))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> keys p\n  t \\<in> keys (monomial (lookup p s) (except s {x}))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = except s {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(2)"], ["proof (chain)\npicking this:\n  t \\<in> keys (monomial (lookup p s) (except s {x}))", "have \"t = except s {x}\""], ["proof (prove)\nusing this:\n  t \\<in> keys (monomial (lookup p s) (except s {x}))\n\ngoal (1 subgoal):\n 1. t = except s {x}", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  t = except s {x}\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = except s {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>s \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p\n  t = except s {x}", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> keys p\n  t = except s {x}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma except_inj_on_keys_homogeneous:\n  assumes \"homogeneous p\"\n  shows \"inj_on (\\<lambda>t. except t {x}) (keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>t. except t {x}) (keys p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        except xa {x} = except y {x}\\<rbrakk>\n       \\<Longrightarrow> xa = y", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        except xa {x} = except y {x}\\<rbrakk>\n       \\<Longrightarrow> xa = y", "assume \"s \\<in> keys p\" and \"t \\<in> keys p\""], ["proof (state)\nthis:\n  s \\<in> keys p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        except xa {x} = except y {x}\\<rbrakk>\n       \\<Longrightarrow> xa = y", "from assms this(1)"], ["proof (chain)\npicking this:\n  homogeneous p\n  s \\<in> keys p", "have \"deg_pm s = poly_deg p\""], ["proof (prove)\nusing this:\n  homogeneous p\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm s = poly_deg p", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm s = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        except xa {x} = except y {x}\\<rbrakk>\n       \\<Longrightarrow> xa = y", "moreover"], ["proof (state)\nthis:\n  deg_pm s = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        except xa {x} = except y {x}\\<rbrakk>\n       \\<Longrightarrow> xa = y", "from assms \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  homogeneous p\n  t \\<in> keys p", "have \"deg_pm t = poly_deg p\""], ["proof (prove)\nusing this:\n  homogeneous p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        except xa {x} = except y {x}\\<rbrakk>\n       \\<Longrightarrow> xa = y", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm s = poly_deg p\n  deg_pm t = poly_deg p", "have \"deg_pm (Poly_Mapping.single x (lookup s x) + except s {x}) =\n                   deg_pm (Poly_Mapping.single x (lookup t x) + except t {x})\""], ["proof (prove)\nusing this:\n  deg_pm s = poly_deg p\n  deg_pm t = poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm (monomial (lookup s x) x + except s {x}) =\n    deg_pm (monomial (lookup t x) x + except t {x})", "by (simp only: flip: plus_except)"], ["proof (state)\nthis:\n  deg_pm (monomial (lookup s x) x + except s {x}) =\n  deg_pm (monomial (lookup t x) x + except t {x})\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        except xa {x} = except y {x}\\<rbrakk>\n       \\<Longrightarrow> xa = y", "moreover"], ["proof (state)\nthis:\n  deg_pm (monomial (lookup s x) x + except s {x}) =\n  deg_pm (monomial (lookup t x) x + except t {x})\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        except xa {x} = except y {x}\\<rbrakk>\n       \\<Longrightarrow> xa = y", "assume 1: \"except s {x} = except t {x}\""], ["proof (state)\nthis:\n  except s {x} = except t {x}\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        except xa {x} = except y {x}\\<rbrakk>\n       \\<Longrightarrow> xa = y", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm (monomial (lookup s x) x + except s {x}) =\n  deg_pm (monomial (lookup t x) x + except t {x})\n  except s {x} = except t {x}", "have 2: \"lookup s x = lookup t x\""], ["proof (prove)\nusing this:\n  deg_pm (monomial (lookup s x) x + except s {x}) =\n  deg_pm (monomial (lookup t x) x + except t {x})\n  except s {x} = except t {x}\n\ngoal (1 subgoal):\n 1. lookup s x = lookup t x", "by (simp only: deg_pm_plus deg_pm_single)"], ["proof (state)\nthis:\n  lookup s x = lookup t x\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> keys p; y \\<in> keys p;\n        except xa {x} = except y {x}\\<rbrakk>\n       \\<Longrightarrow> xa = y", "show \"s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup s k = lookup t k", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup s k = lookup t k", "show \"lookup s y = lookup t y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup s y = lookup t y", "proof (cases \"y = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> lookup s y = lookup t y\n 2. y \\<noteq> x \\<Longrightarrow> lookup s y = lookup t y", "case True"], ["proof (state)\nthis:\n  y = x\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> lookup s y = lookup t y\n 2. y \\<noteq> x \\<Longrightarrow> lookup s y = lookup t y", "with 2"], ["proof (chain)\npicking this:\n  lookup s x = lookup t x\n  y = x", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup s x = lookup t x\n  y = x\n\ngoal (1 subgoal):\n 1. lookup s y = lookup t y", "by simp"], ["proof (state)\nthis:\n  lookup s y = lookup t y\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> lookup s y = lookup t y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> lookup s y = lookup t y", "case False"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> lookup s y = lookup t y", "hence \"lookup s y = lookup (except s {x}) y\" and \"lookup t y = lookup (except t {x}) y\""], ["proof (prove)\nusing this:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. lookup s y = lookup (except s {x}) y &&&\n    lookup t y = lookup (except t {x}) y", "by (simp_all add: lookup_except)"], ["proof (state)\nthis:\n  lookup s y = lookup (except s {x}) y\n  lookup t y = lookup (except t {x}) y\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> lookup s y = lookup t y", "with 1"], ["proof (chain)\npicking this:\n  except s {x} = except t {x}\n  lookup s y = lookup (except s {x}) y\n  lookup t y = lookup (except t {x}) y", "show ?thesis"], ["proof (prove)\nusing this:\n  except s {x} = except t {x}\n  lookup s y = lookup (except s {x}) y\n  lookup t y = lookup (except t {x}) y\n\ngoal (1 subgoal):\n 1. lookup s y = lookup t y", "by simp"], ["proof (state)\nthis:\n  lookup s y = lookup t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup s y = lookup t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_dehomogenize:\n  assumes \"homogeneous p\" and \"t \\<in> keys p\"\n  shows \"lookup (dehomogenize x p) (except t {x}) = lookup p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "let ?t = \"except t {x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "have eq: \"(\\<Sum>s\\<in>keys p - {t}. lookup (monomial (lookup p s) (except s {x})) ?t) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>keys p - {t}.\n       lookup (monomial (lookup p s) (except s {x})) (except t {x})) =\n    (0::'b)", "proof (intro sum.neutral ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup (monomial (lookup p xa) (except xa {x})) (except t {x}) =\n       (0::'b)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup (monomial (lookup p xa) (except xa {x})) (except t {x}) =\n       (0::'b)", "assume \"s \\<in> keys p - {t}\""], ["proof (state)\nthis:\n  s \\<in> keys p - {t}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup (monomial (lookup p xa) (except xa {x})) (except t {x}) =\n       (0::'b)", "hence \"s \\<in> keys p\" and \"s \\<noteq> t\""], ["proof (prove)\nusing this:\n  s \\<in> keys p - {t}\n\ngoal (1 subgoal):\n 1. s \\<in> keys p &&& s \\<noteq> t", "by simp_all"], ["proof (state)\nthis:\n  s \\<in> keys p\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup (monomial (lookup p xa) (except xa {x})) (except t {x}) =\n       (0::'b)", "have \"?t \\<noteq> except s {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except t {x} \\<noteq> except s {x}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. except t {x} = except s {x} \\<Longrightarrow> False", "from assms(1)"], ["proof (chain)\npicking this:\n  homogeneous p", "have \"inj_on (\\<lambda>t. except t {x}) (keys p)\""], ["proof (prove)\nusing this:\n  homogeneous p\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>t. except t {x}) (keys p)", "by (rule except_inj_on_keys_homogeneous)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>t. except t {x}) (keys p)\n\ngoal (1 subgoal):\n 1. except t {x} = except s {x} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  inj_on (\\<lambda>t. except t {x}) (keys p)\n\ngoal (1 subgoal):\n 1. except t {x} = except s {x} \\<Longrightarrow> False", "assume \"?t = except s {x}\""], ["proof (state)\nthis:\n  except t {x} = except s {x}\n\ngoal (1 subgoal):\n 1. except t {x} = except s {x} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  inj_on (\\<lambda>t. except t {x}) (keys p)\n  except t {x} = except s {x}", "have \"t = s\""], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>t. except t {x}) (keys p)\n  except t {x} = except s {x}\n\ngoal (1 subgoal):\n 1. t = s", "using assms(2) \\<open>s \\<in> keys p\\<close>"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>t. except t {x}) (keys p)\n  except t {x} = except s {x}\n  t \\<in> keys p\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. t = s", "by (rule inj_onD)"], ["proof (state)\nthis:\n  t = s\n\ngoal (1 subgoal):\n 1. except t {x} = except s {x} \\<Longrightarrow> False", "with \\<open>s \\<noteq> t\\<close>"], ["proof (chain)\npicking this:\n  s \\<noteq> t\n  t = s", "show False"], ["proof (prove)\nusing this:\n  s \\<noteq> t\n  t = s\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  except t {x} \\<noteq> except s {x}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p - {t} \\<Longrightarrow>\n       lookup (monomial (lookup p xa) (except xa {x})) (except t {x}) =\n       (0::'b)", "thus \"lookup (monomial (lookup p s) (except s {x})) ?t = 0\""], ["proof (prove)\nusing this:\n  except t {x} \\<noteq> except s {x}\n\ngoal (1 subgoal):\n 1. lookup (monomial (lookup p s) (except s {x})) (except t {x}) = (0::'b)", "by (simp add: lookup_single)"], ["proof (state)\nthis:\n  lookup (monomial (lookup p s) (except s {x})) (except t {x}) = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (except s {x})) (except t {x})) =\n  (0::'b)\n\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "have \"lookup (dehomogenize x p) ?t = (\\<Sum>s\\<in>keys p. lookup (monomial (lookup p s) (except s {x})) ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) =\n    (\\<Sum>s\\<in>keys p.\n       lookup (monomial (lookup p s) (except s {x})) (except t {x}))", "by (simp only: dehomogenize_alt lookup_sum)"], ["proof (state)\nthis:\n  lookup (dehomogenize x p) (except t {x}) =\n  (\\<Sum>s\\<in>keys p.\n     lookup (monomial (lookup p s) (except s {x})) (except t {x}))\n\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "also"], ["proof (state)\nthis:\n  lookup (dehomogenize x p) (except t {x}) =\n  (\\<Sum>s\\<in>keys p.\n     lookup (monomial (lookup p s) (except s {x})) (except t {x}))\n\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "have \"\\<dots> = lookup (monomial (lookup p t) ?t) ?t +\n                  (\\<Sum>s\\<in>keys p - {t}. lookup (monomial (lookup p s) (except s {x})) ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>keys p.\n       lookup (monomial (lookup p s) (except s {x})) (except t {x})) =\n    lookup (monomial (lookup p t) (except t {x})) (except t {x}) +\n    (\\<Sum>s\\<in>keys p - {t}.\n       lookup (monomial (lookup p s) (except s {x})) (except t {x}))", "using finite_keys assms(2)"], ["proof (prove)\nusing this:\n  finite (keys ?f)\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>keys p.\n       lookup (monomial (lookup p s) (except s {x})) (except t {x})) =\n    lookup (monomial (lookup p t) (except t {x})) (except t {x}) +\n    (\\<Sum>s\\<in>keys p - {t}.\n       lookup (monomial (lookup p s) (except s {x})) (except t {x}))", "by (rule sum.remove)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>keys p.\n     lookup (monomial (lookup p s) (except s {x})) (except t {x})) =\n  lookup (monomial (lookup p t) (except t {x})) (except t {x}) +\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (except s {x})) (except t {x}))\n\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "also"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>keys p.\n     lookup (monomial (lookup p s) (except s {x})) (except t {x})) =\n  lookup (monomial (lookup p t) (except t {x})) (except t {x}) +\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (except s {x})) (except t {x}))\n\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "have \"\\<dots> = lookup p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial (lookup p t) (except t {x})) (except t {x}) +\n    (\\<Sum>s\\<in>keys p - {t}.\n       lookup (monomial (lookup p s) (except s {x})) (except t {x})) =\n    lookup p t", "by (simp add: eq)"], ["proof (state)\nthis:\n  lookup (monomial (lookup p t) (except t {x})) (except t {x}) +\n  (\\<Sum>s\\<in>keys p - {t}.\n     lookup (monomial (lookup p s) (except s {x})) (except t {x})) =\n  lookup p t\n\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "finally"], ["proof (chain)\npicking this:\n  lookup (dehomogenize x p) (except t {x}) = lookup p t", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (dehomogenize x p) (except t {x}) = lookup p t\n\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "."], ["proof (state)\nthis:\n  lookup (dehomogenize x p) (except t {x}) = lookup p t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_dehomogenizeI:\n  assumes \"homogeneous p\" and \"t \\<in> keys p\"\n  shows \"except t {x} \\<in> keys (dehomogenize x p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except t {x} \\<in> keys (dehomogenize x p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. except t {x} \\<in> keys (dehomogenize x p)", "from assms"], ["proof (chain)\npicking this:\n  homogeneous p\n  t \\<in> keys p", "have \"lookup (dehomogenize x p) (except t {x}) = lookup p t\""], ["proof (prove)\nusing this:\n  homogeneous p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "by (rule lookup_dehomogenize)"], ["proof (state)\nthis:\n  lookup (dehomogenize x p) (except t {x}) = lookup p t\n\ngoal (1 subgoal):\n 1. except t {x} \\<in> keys (dehomogenize x p)", "also"], ["proof (state)\nthis:\n  lookup (dehomogenize x p) (except t {x}) = lookup p t\n\ngoal (1 subgoal):\n 1. except t {x} \\<in> keys (dehomogenize x p)", "from assms(2)"], ["proof (chain)\npicking this:\n  t \\<in> keys p", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. lookup p t \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup p t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. except t {x} \\<in> keys (dehomogenize x p)", "finally"], ["proof (chain)\npicking this:\n  lookup (dehomogenize x p) (except t {x}) \\<noteq> (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (dehomogenize x p) (except t {x}) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. except t {x} \\<in> keys (dehomogenize x p)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  except t {x} \\<in> keys (dehomogenize x p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogeneous_homogenize_dehomogenize:\n  assumes \"homogeneous p\"\n  obtains d where \"d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\"\n    and \"punit.monom_mult 1 (Poly_Mapping.single x d) (homogenize x (dehomogenize x p)) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d =\n                 poly_deg p - poly_deg (homogenize x (dehomogenize x p));\n         punit.monom_mult (1::'b) (monomial d x)\n          (homogenize x (dehomogenize x p)) =\n         p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"0 = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\"\n    and \"punit.monom_mult 1 (Poly_Mapping.single x 0) (homogenize x (dehomogenize x p)) = p\""], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. 0 = poly_deg p - poly_deg (homogenize x (dehomogenize x p)) &&&\n    punit.monom_mult (1::'b) (monomial 0 x)\n     (homogenize x (dehomogenize x p)) =\n    p", "by simp_all"], ["proof (state)\nthis:\n  0 = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n  punit.monom_mult (1::'b) (monomial 0 x)\n   (homogenize x (dehomogenize x p)) =\n  p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n  punit.monom_mult (1::'b) (monomial 0 x)\n   (homogenize x (dehomogenize x p)) =\n  p\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "let ?q = \"dehomogenize x p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "let ?p = \"homogenize x ?q\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "define d where \"d = poly_deg p - poly_deg ?p\""], ["proof (state)\nthis:\n  d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>d.\n                \\<lbrakk>d =\n                         poly_deg p -\n                         poly_deg (homogenize x (dehomogenize x p));\n                 punit.monom_mult (1::'b) (monomial d x)\n                  (homogenize x (dehomogenize x p)) =\n                 p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "have \"punit.monom_mult 1 (Poly_Mapping.single x d) ?p =\n          (\\<Sum>t\\<in>keys ?q. monomial (lookup ?q t) (Poly_Mapping.single x (d + (poly_deg ?q - deg_pm t)) + t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult (1::'b) (monomial d x)\n     (homogenize x (dehomogenize x p)) =\n    (\\<Sum>t\\<in>keys (dehomogenize x p).\n       monomial (lookup (dehomogenize x p) t)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm t)) x + t))", "by (simp add: homogenize_def punit.monom_mult_sum_right punit.monom_mult_monomial flip: add.assoc single_add)"], ["proof (state)\nthis:\n  punit.monom_mult (1::'b) (monomial d x)\n   (homogenize x (dehomogenize x p)) =\n  (\\<Sum>t\\<in>keys (dehomogenize x p).\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (d + (poly_deg (dehomogenize x p) - deg_pm t)) x + t))\n\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "also"], ["proof (state)\nthis:\n  punit.monom_mult (1::'b) (monomial d x)\n   (homogenize x (dehomogenize x p)) =\n  (\\<Sum>t\\<in>keys (dehomogenize x p).\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (d + (poly_deg (dehomogenize x p) - deg_pm t)) x + t))\n\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "have \"\\<dots> = (\\<Sum>t\\<in>keys ?q. monomial (lookup ?q t) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys (dehomogenize x p).\n       monomial (lookup (dehomogenize x p) t)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm t)) x + t)) =\n    (\\<Sum>t\\<in>keys (dehomogenize x p).\n       monomial (lookup (dehomogenize x p) t)\n        (monomial (poly_deg p - deg_pm t) x + t))", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys (dehomogenize x p).\n       monomial (lookup (dehomogenize x p) t)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm t)) x + t)) =\n    (\\<Sum>t\\<in>keys (dehomogenize x p).\n       monomial (lookup (dehomogenize x p) t)\n        (monomial (poly_deg p - deg_pm t) x + t))", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm xa)) x + xa) =\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (poly_deg p - deg_pm xa) x + xa)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm xa)) x + xa) =\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (poly_deg p - deg_pm xa) x + xa)", "assume \"t \\<in> keys ?q\""], ["proof (state)\nthis:\n  t \\<in> keys (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm xa)) x + xa) =\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (poly_deg p - deg_pm xa) x + xa)", "have \"poly_deg ?p = poly_deg ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (homogenize x (dehomogenize x p)) = poly_deg (dehomogenize x p)", "proof (rule poly_deg_homogenize)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> indets (dehomogenize x p)", "from indets_dehomogenize"], ["proof (chain)\npicking this:\n  indets (dehomogenize ?x ?p) \\<subseteq> indets ?p - {?x}", "show \"x \\<notin> indets ?q\""], ["proof (prove)\nusing this:\n  indets (dehomogenize ?x ?p) \\<subseteq> indets ?p - {?x}\n\ngoal (1 subgoal):\n 1. x \\<notin> indets (dehomogenize x p)", "by fastforce"], ["proof (state)\nthis:\n  x \\<notin> indets (dehomogenize x p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg (homogenize x (dehomogenize x p)) = poly_deg (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm xa)) x + xa) =\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (poly_deg p - deg_pm xa) x + xa)", "hence d: \"d = poly_deg p - poly_deg ?q\""], ["proof (prove)\nusing this:\n  poly_deg (homogenize x (dehomogenize x p)) = poly_deg (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. d = poly_deg p - poly_deg (dehomogenize x p)", "by (simp only: d_def)"], ["proof (state)\nthis:\n  d = poly_deg p - poly_deg (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm xa)) x + xa) =\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (poly_deg p - deg_pm xa) x + xa)", "thm poly_deg_dehomogenize_le"], ["proof (state)\nthis:\n  d = poly_deg p - poly_deg (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm xa)) x + xa) =\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (poly_deg p - deg_pm xa) x + xa)", "from \\<open>t \\<in> keys ?q\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys (dehomogenize x p)", "have \"d + (poly_deg ?q - deg_pm t) = (d + poly_deg ?q) - deg_pm t\""], ["proof (prove)\nusing this:\n  t \\<in> keys (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. d + (poly_deg (dehomogenize x p) - deg_pm t) =\n    d + poly_deg (dehomogenize x p) - deg_pm t", "by (intro add_diff_assoc poly_deg_max_keys)"], ["proof (state)\nthis:\n  d + (poly_deg (dehomogenize x p) - deg_pm t) =\n  d + poly_deg (dehomogenize x p) - deg_pm t\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm xa)) x + xa) =\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (poly_deg p - deg_pm xa) x + xa)", "also"], ["proof (state)\nthis:\n  d + (poly_deg (dehomogenize x p) - deg_pm t) =\n  d + poly_deg (dehomogenize x p) - deg_pm t\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm xa)) x + xa) =\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (poly_deg p - deg_pm xa) x + xa)", "have \"d + poly_deg ?q = poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d + poly_deg (dehomogenize x p) = poly_deg p", "by (simp add: d poly_deg_dehomogenize_le)"], ["proof (state)\nthis:\n  d + poly_deg (dehomogenize x p) = poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (d + (poly_deg (dehomogenize x p) - deg_pm xa)) x + xa) =\n       monomial (lookup (dehomogenize x p) xa)\n        (monomial (poly_deg p - deg_pm xa) x + xa)", "finally"], ["proof (chain)\npicking this:\n  d + (poly_deg (dehomogenize x p) - deg_pm t) = poly_deg p - deg_pm t", "show \"monomial (lookup ?q t) (Poly_Mapping.single x (d + (poly_deg ?q - deg_pm t)) + t) =\n                    monomial (lookup ?q t) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t)\""], ["proof (prove)\nusing this:\n  d + (poly_deg (dehomogenize x p) - deg_pm t) = poly_deg p - deg_pm t\n\ngoal (1 subgoal):\n 1. monomial (lookup (dehomogenize x p) t)\n     (monomial (d + (poly_deg (dehomogenize x p) - deg_pm t)) x + t) =\n    monomial (lookup (dehomogenize x p) t)\n     (monomial (poly_deg p - deg_pm t) x + t)", "by (simp only:)"], ["proof (state)\nthis:\n  monomial (lookup (dehomogenize x p) t)\n   (monomial (d + (poly_deg (dehomogenize x p) - deg_pm t)) x + t) =\n  monomial (lookup (dehomogenize x p) t)\n   (monomial (poly_deg p - deg_pm t) x + t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys (dehomogenize x p).\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (d + (poly_deg (dehomogenize x p) - deg_pm t)) x + t)) =\n  (\\<Sum>t\\<in>keys (dehomogenize x p).\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys (dehomogenize x p).\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (d + (poly_deg (dehomogenize x p) - deg_pm t)) x + t)) =\n  (\\<Sum>t\\<in>keys (dehomogenize x p).\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "have \"\\<dots> = (\\<Sum>t\\<in>(\\<lambda>s. except s {x}) ` keys p.\n                    monomial (lookup ?q t) (Poly_Mapping.single x (poly_deg p - deg_pm t) + t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys (dehomogenize x p).\n       monomial (lookup (dehomogenize x p) t)\n        (monomial (poly_deg p - deg_pm t) x + t)) =\n    (\\<Sum>t\\<in>(\\<lambda>s. except s {x}) ` keys p.\n       monomial (lookup (dehomogenize x p) t)\n        (monomial (poly_deg p - deg_pm t) x + t))", "proof (rule sum.mono_neutral_left)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite ((\\<lambda>s. except s {x}) ` keys p)\n 2. keys (dehomogenize x p) \\<subseteq> (\\<lambda>s. except s {x}) ` keys p\n 3. \\<forall>i\\<in>(\\<lambda>s. except s {x}) ` keys p -\n                   keys (dehomogenize x p).\n       monomial (lookup (dehomogenize x p) i)\n        (monomial (poly_deg p - deg_pm i) x + i) =\n       0", "show \"keys (dehomogenize x p) \\<subseteq> (\\<lambda>s. except s {x}) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (dehomogenize x p) \\<subseteq> (\\<lambda>s. except s {x}) ` keys p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       xa \\<in> (\\<lambda>s. except s {x}) ` keys p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       xa \\<in> (\\<lambda>s. except s {x}) ` keys p", "assume \"t \\<in> keys (dehomogenize x p)\""], ["proof (state)\nthis:\n  t \\<in> keys (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       xa \\<in> (\\<lambda>s. except s {x}) ` keys p", "then"], ["proof (chain)\npicking this:\n  t \\<in> keys (dehomogenize x p)", "obtain s where \"s \\<in> keys p\" and \"t = except s {x}\""], ["proof (prove)\nusing this:\n  t \\<in> keys (dehomogenize x p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = except s {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule keys_dehomogenizeE)"], ["proof (state)\nthis:\n  s \\<in> keys p\n  t = except s {x}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys (dehomogenize x p) \\<Longrightarrow>\n       xa \\<in> (\\<lambda>s. except s {x}) ` keys p", "thus \"t \\<in> (\\<lambda>s. except s {x}) ` keys p\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n  t = except s {x}\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<lambda>s. except s {x}) ` keys p", "by (rule rev_image_eqI)"], ["proof (state)\nthis:\n  t \\<in> (\\<lambda>s. except s {x}) ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (dehomogenize x p) \\<subseteq> (\\<lambda>s. except s {x}) ` keys p\n\ngoal (2 subgoals):\n 1. finite ((\\<lambda>s. except s {x}) ` keys p)\n 2. \\<forall>i\\<in>(\\<lambda>s. except s {x}) ` keys p -\n                   keys (dehomogenize x p).\n       monomial (lookup (dehomogenize x p) i)\n        (monomial (poly_deg p - deg_pm i) x + i) =\n       0", "qed (simp_all add: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys (dehomogenize x p).\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (poly_deg p - deg_pm t) x + t)) =\n  (\\<Sum>t\\<in>(\\<lambda>s. except s {x}) ` keys p.\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys (dehomogenize x p).\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (poly_deg p - deg_pm t) x + t)) =\n  (\\<Sum>t\\<in>(\\<lambda>s. except s {x}) ` keys p.\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (poly_deg p - deg_pm t) x + t))\n\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "from assms"], ["proof (chain)\npicking this:\n  homogeneous p", "have \"\\<dots> = (\\<Sum>t\\<in>keys p. monomial (lookup ?q (except t {x}))\n                (Poly_Mapping.single x (poly_deg p - deg_pm (except t {x})) + except t {x}))\""], ["proof (prove)\nusing this:\n  homogeneous p\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>(\\<lambda>s. except s {x}) ` keys p.\n       monomial (lookup (dehomogenize x p) t)\n        (monomial (poly_deg p - deg_pm t) x + t)) =\n    (\\<Sum>t\\<in>keys p.\n       monomial (lookup (dehomogenize x p) (except t {x}))\n        (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x}))", "by (intro sum.reindex[unfolded comp_def] except_inj_on_keys_homogeneous)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>(\\<lambda>s. except s {x}) ` keys p.\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (poly_deg p - deg_pm t) x + t)) =\n  (\\<Sum>t\\<in>keys p.\n     monomial (lookup (dehomogenize x p) (except t {x}))\n      (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x}))\n\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>(\\<lambda>s. except s {x}) ` keys p.\n     monomial (lookup (dehomogenize x p) t)\n      (monomial (poly_deg p - deg_pm t) x + t)) =\n  (\\<Sum>t\\<in>keys p.\n     monomial (lookup (dehomogenize x p) (except t {x}))\n      (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x}))\n\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"\\<dots> = (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (lookup (dehomogenize x p) (except t {x}))\n        (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})) =\n    (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) (except xa {x}))\n        (monomial (poly_deg p - deg_pm (except xa {x})) x + except xa {x}) =\n       monomial (lookup p xa) xa", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) (except xa {x}))\n        (monomial (poly_deg p - deg_pm (except xa {x})) x + except xa {x}) =\n       monomial (lookup p xa) xa", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) (except xa {x}))\n        (monomial (poly_deg p - deg_pm (except xa {x})) x + except xa {x}) =\n       monomial (lookup p xa) xa", "with assms"], ["proof (chain)\npicking this:\n  homogeneous p\n  t \\<in> keys p", "have \"lookup ?q (except t {x}) = lookup p t\""], ["proof (prove)\nusing this:\n  homogeneous p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. lookup (dehomogenize x p) (except t {x}) = lookup p t", "by (rule lookup_dehomogenize)"], ["proof (state)\nthis:\n  lookup (dehomogenize x p) (except t {x}) = lookup p t\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) (except xa {x}))\n        (monomial (poly_deg p - deg_pm (except xa {x})) x + except xa {x}) =\n       monomial (lookup p xa) xa", "moreover"], ["proof (state)\nthis:\n  lookup (dehomogenize x p) (except t {x}) = lookup p t\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) (except xa {x}))\n        (monomial (poly_deg p - deg_pm (except xa {x})) x + except xa {x}) =\n       monomial (lookup p xa) xa", "have \"Poly_Mapping.single x (poly_deg p - deg_pm (except t {x})) + except t {x} = t\"\n        (is \"?l = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (poly_deg p - deg_pm (except t {x})) x + except t {x} = t", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup\n        (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x}) k =\n       lookup t k", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup\n        (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x}) k =\n       lookup t k", "show \"lookup ?l y = lookup t y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "proof (cases \"y = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "case True"], ["proof (state)\nthis:\n  y = x\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "from assms \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  homogeneous p\n  t \\<in> keys p", "have \"deg_pm t = poly_deg p\""], ["proof (prove)\nusing this:\n  homogeneous p\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg p", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "also"], ["proof (state)\nthis:\n  deg_pm t = poly_deg p\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "have \"deg_pm t = deg_pm (Poly_Mapping.single x (lookup t x) + except t {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t = deg_pm (monomial (lookup t x) x + except t {x})", "by (simp flip: plus_except)"], ["proof (state)\nthis:\n  deg_pm t = deg_pm (monomial (lookup t x) x + except t {x})\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "also"], ["proof (state)\nthis:\n  deg_pm t = deg_pm (monomial (lookup t x) x + except t {x})\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "have \"\\<dots> = lookup t x + deg_pm (except t {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (monomial (lookup t x) x + except t {x}) =\n    lookup t x + deg_pm (except t {x})", "by (simp only: deg_pm_plus deg_pm_single)"], ["proof (state)\nthis:\n  deg_pm (monomial (lookup t x) x + except t {x}) =\n  lookup t x + deg_pm (except t {x})\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "finally"], ["proof (chain)\npicking this:\n  lookup t x + deg_pm (except t {x}) = poly_deg p", "have \"poly_deg p - deg_pm (except t {x}) = lookup t x\""], ["proof (prove)\nusing this:\n  lookup t x + deg_pm (except t {x}) = poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg p - deg_pm (except t {x}) = lookup t x", "by simp"], ["proof (state)\nthis:\n  poly_deg p - deg_pm (except t {x}) = lookup t x\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly_deg p - deg_pm (except t {x}) = lookup t x\n\ngoal (1 subgoal):\n 1. lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "by (simp add: True lookup_add lookup_except lookup_single)"], ["proof (state)\nthis:\n  lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n   y =\n  lookup t y\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "case False"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n     y =\n    lookup t y", "by (simp add: lookup_add lookup_except lookup_single)"], ["proof (state)\nthis:\n  lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n   y =\n  lookup t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})\n   y =\n  lookup t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monomial (poly_deg p - deg_pm (except t {x})) x + except t {x} = t\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys p \\<Longrightarrow>\n       monomial (lookup (dehomogenize x p) (except xa {x}))\n        (monomial (poly_deg p - deg_pm (except xa {x})) x + except xa {x}) =\n       monomial (lookup p xa) xa", "ultimately"], ["proof (chain)\npicking this:\n  lookup (dehomogenize x p) (except t {x}) = lookup p t\n  monomial (poly_deg p - deg_pm (except t {x})) x + except t {x} = t", "show \"monomial (lookup ?q (except t {x}))\n              (Poly_Mapping.single x (poly_deg p - deg_pm (except t {x})) + except t {x}) =\n            monomial (lookup p t) t\""], ["proof (prove)\nusing this:\n  lookup (dehomogenize x p) (except t {x}) = lookup p t\n  monomial (poly_deg p - deg_pm (except t {x})) x + except t {x} = t\n\ngoal (1 subgoal):\n 1. monomial (lookup (dehomogenize x p) (except t {x}))\n     (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x}) =\n    monomial (lookup p t) t", "by (simp only:)"], ["proof (state)\nthis:\n  monomial (lookup (dehomogenize x p) (except t {x}))\n   (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x}) =\n  monomial (lookup p t) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p.\n     monomial (lookup (dehomogenize x p) (except t {x}))\n      (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})) =\n  (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)\n\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p.\n     monomial (lookup (dehomogenize x p) (except t {x}))\n      (monomial (poly_deg p - deg_pm (except t {x})) x + except t {x})) =\n  (\\<Sum>t\\<in>keys p. monomial (lookup p t) t)\n\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "have \"\\<dots> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) = p", "by (fact poly_mapping_sum_monomials)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) = p\n\ngoal (2 subgoals):\n 1. ?d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))\n 2. punit.monom_mult (1::'b) (monomial ?d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "finally"], ["proof (chain)\npicking this:\n  punit.monom_mult (1::'b) (monomial d x)\n   (homogenize x (dehomogenize x p)) =\n  p", "show \"punit.monom_mult 1 (Poly_Mapping.single x d) ?p = p\""], ["proof (prove)\nusing this:\n  punit.monom_mult (1::'b) (monomial d x)\n   (homogenize x (dehomogenize x p)) =\n  p\n\ngoal (1 subgoal):\n 1. punit.monom_mult (1::'b) (monomial d x)\n     (homogenize x (dehomogenize x p)) =\n    p", "."], ["proof (state)\nthis:\n  punit.monom_mult (1::'b) (monomial d x)\n   (homogenize x (dehomogenize x p)) =\n  p\n\ngoal (1 subgoal):\n 1. d = poly_deg p - poly_deg (homogenize x (dehomogenize x p))", "qed (simp only: d_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dehomogenize_zeroD:\n  assumes \"dehomogenize x p = 0\" and \"homogeneous p\"\n  shows \"p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = 0", "from assms(2)"], ["proof (chain)\npicking this:\n  homogeneous p", "obtain d\n    where \"punit.monom_mult 1 (Poly_Mapping.single x d) (homogenize x (dehomogenize x p)) = p\""], ["proof (prove)\nusing this:\n  homogeneous p\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        punit.monom_mult (1::'b) (monomial d x)\n         (homogenize x (dehomogenize x p)) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule homogeneous_homogenize_dehomogenize)"], ["proof (state)\nthis:\n  punit.monom_mult (1::'b) (monomial d x)\n   (homogenize x (dehomogenize x p)) =\n  p\n\ngoal (1 subgoal):\n 1. p = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  punit.monom_mult (1::'b) (monomial d x)\n   (homogenize x (dehomogenize x p)) =\n  p\n\ngoal (1 subgoal):\n 1. p = 0", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dehomogenize_ideal: \"dehomogenize x ` ideal F = ideal (dehomogenize x ` F) \\<inter> P[- {x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x ` ideal F = ideal (dehomogenize x ` F) \\<inter> P[- {x}]", "unfolding range_dehomogenize[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x ` ideal F =\n    ideal (dehomogenize x ` F) \\<inter> range (dehomogenize x)", "using dehomogenize_plus dehomogenize_times dehomogenize_dehomogenize"], ["proof (prove)\nusing this:\n  dehomogenize ?x (?p + ?q) = dehomogenize ?x ?p + dehomogenize ?x ?q\n  dehomogenize ?x (?p * ?q) = dehomogenize ?x ?p * dehomogenize ?x ?q\n  dehomogenize ?x (dehomogenize ?x ?p) = dehomogenize ?x ?p\n\ngoal (1 subgoal):\n 1. dehomogenize x ` ideal F =\n    ideal (dehomogenize x ` F) \\<inter> range (dehomogenize x)", "by (rule image_ideal_eq_Int)"], ["", "corollary dehomogenize_ideal_subset: \"dehomogenize x ` ideal F \\<subseteq> ideal (dehomogenize x ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x ` ideal F \\<subseteq> ideal (dehomogenize x ` F)", "by (simp add: dehomogenize_ideal)"], ["", "lemma ideal_dehomogenize:\n  assumes \"ideal G = ideal (homogenize x ` F)\" and \"F \\<subseteq> P[UNIV - {x}]\"\n  shows \"ideal (dehomogenize x ` G) = ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (dehomogenize x ` G) = ideal F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ideal (dehomogenize x ` G) = ideal F", "have eq: \"dehomogenize x (homogenize x f) = f\" if \"f \\<in> F\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x (homogenize x f) = f", "proof (rule dehomogenize_homogenize_id)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> indets f", "from that assms(2)"], ["proof (chain)\npicking this:\n  f \\<in> F\n  F \\<subseteq> P[UNIV - {x}]", "have \"f \\<in> P[UNIV - {x}]\""], ["proof (prove)\nusing this:\n  f \\<in> F\n  F \\<subseteq> P[UNIV - {x}]\n\ngoal (1 subgoal):\n 1. f \\<in> P[UNIV - {x}]", ".."], ["proof (state)\nthis:\n  f \\<in> P[UNIV - {x}]\n\ngoal (1 subgoal):\n 1. x \\<notin> indets f", "thus \"x \\<notin> indets f\""], ["proof (prove)\nusing this:\n  f \\<in> P[UNIV - {x}]\n\ngoal (1 subgoal):\n 1. x \\<notin> indets f", "by (auto simp: Polys_alt)"], ["proof (state)\nthis:\n  x \\<notin> indets f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> F \\<Longrightarrow> dehomogenize x (homogenize x ?f) = ?f\n\ngoal (1 subgoal):\n 1. ideal (dehomogenize x ` G) = ideal F", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (dehomogenize x ` G) = ideal F", "proof (intro Set.equalityI ideal.span_subset_spanI)"], ["proof (state)\ngoal (2 subgoals):\n 1. dehomogenize x ` G \\<subseteq> ideal F\n 2. F \\<subseteq> ideal (dehomogenize x ` G)", "show \"dehomogenize x ` G \\<subseteq> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x ` G \\<subseteq> ideal F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "assume \"q \\<in> dehomogenize x ` G\""], ["proof (state)\nthis:\n  q \\<in> dehomogenize x ` G\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "then"], ["proof (chain)\npicking this:\n  q \\<in> dehomogenize x ` G", "obtain g where \"g \\<in> G\" and q: \"q = dehomogenize x g\""], ["proof (prove)\nusing this:\n  q \\<in> dehomogenize x ` G\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; q = dehomogenize x g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  g \\<in> G\n  q = dehomogenize x g\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "from this(1)"], ["proof (chain)\npicking this:\n  g \\<in> G", "have \"g \\<in> ideal G\""], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. g \\<in> ideal G", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  g \\<in> ideal G\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "also"], ["proof (state)\nthis:\n  g \\<in> ideal G\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "have \"\\<dots> = ideal (homogenize x ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal G = ideal (homogenize x ` F)", "by fact"], ["proof (state)\nthis:\n  ideal G = ideal (homogenize x ` F)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "finally"], ["proof (chain)\npicking this:\n  g \\<in> ideal (homogenize x ` F)", "have \"q \\<in> dehomogenize x ` ideal (homogenize x ` F)\""], ["proof (prove)\nusing this:\n  g \\<in> ideal (homogenize x ` F)\n\ngoal (1 subgoal):\n 1. q \\<in> dehomogenize x ` ideal (homogenize x ` F)", "using q"], ["proof (prove)\nusing this:\n  g \\<in> ideal (homogenize x ` F)\n  q = dehomogenize x g\n\ngoal (1 subgoal):\n 1. q \\<in> dehomogenize x ` ideal (homogenize x ` F)", "by (rule rev_image_eqI)"], ["proof (state)\nthis:\n  q \\<in> dehomogenize x ` ideal (homogenize x ` F)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "also"], ["proof (state)\nthis:\n  q \\<in> dehomogenize x ` ideal (homogenize x ` F)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "have \"\\<dots> \\<subseteq> ideal (dehomogenize x ` homogenize x ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x ` ideal (homogenize x ` F)\n    \\<subseteq> ideal (dehomogenize x ` homogenize x ` F)", "by (rule dehomogenize_ideal_subset)"], ["proof (state)\nthis:\n  dehomogenize x ` ideal (homogenize x ` F)\n  \\<subseteq> ideal (dehomogenize x ` homogenize x ` F)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "also"], ["proof (state)\nthis:\n  dehomogenize x ` ideal (homogenize x ` F)\n  \\<subseteq> ideal (dehomogenize x ` homogenize x ` F)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "have \"dehomogenize x ` homogenize x ` F = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x ` homogenize x ` F = F", "by (auto simp: eq image_image simp del: dehomogenize_homogenize intro!: image_eqI)"], ["proof (state)\nthis:\n  dehomogenize x ` homogenize x ` F = F\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> dehomogenize x ` G \\<Longrightarrow> xa \\<in> ideal F", "finally"], ["proof (chain)\npicking this:\n  q \\<in> ideal F", "show \"q \\<in> ideal F\""], ["proof (prove)\nusing this:\n  q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. q \\<in> ideal F", "."], ["proof (state)\nthis:\n  q \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dehomogenize x ` G \\<subseteq> ideal F\n\ngoal (1 subgoal):\n 1. F \\<subseteq> ideal (dehomogenize x ` G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. F \\<subseteq> ideal (dehomogenize x ` G)", "show \"F \\<subseteq> ideal (dehomogenize x ` G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> ideal (dehomogenize x ` G)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "assume \"f \\<in> F\""], ["proof (state)\nthis:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "hence \"homogenize x f \\<in> homogenize x ` F\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. homogenize x f \\<in> homogenize x ` F", "by (rule imageI)"], ["proof (state)\nthis:\n  homogenize x f \\<in> homogenize x ` F\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "also"], ["proof (state)\nthis:\n  homogenize x f \\<in> homogenize x ` F\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "have \"\\<dots> \\<subseteq> ideal (homogenize x ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize x ` F \\<subseteq> ideal (homogenize x ` F)", "by (rule ideal.span_superset)"], ["proof (state)\nthis:\n  homogenize x ` F \\<subseteq> ideal (homogenize x ` F)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "also"], ["proof (state)\nthis:\n  homogenize x ` F \\<subseteq> ideal (homogenize x ` F)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "from assms(1)"], ["proof (chain)\npicking this:\n  ideal G = ideal (homogenize x ` F)", "have \"\\<dots> = ideal G\""], ["proof (prove)\nusing this:\n  ideal G = ideal (homogenize x ` F)\n\ngoal (1 subgoal):\n 1. ideal (homogenize x ` F) = ideal G", "by (rule sym)"], ["proof (state)\nthis:\n  ideal (homogenize x ` F) = ideal G\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "finally"], ["proof (chain)\npicking this:\n  homogenize x f \\<in> ideal G", "have \"dehomogenize x (homogenize x f) \\<in> dehomogenize x ` ideal G\""], ["proof (prove)\nusing this:\n  homogenize x f \\<in> ideal G\n\ngoal (1 subgoal):\n 1. dehomogenize x (homogenize x f) \\<in> dehomogenize x ` ideal G", "by (rule imageI)"], ["proof (state)\nthis:\n  dehomogenize x (homogenize x f) \\<in> dehomogenize x ` ideal G\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "with \\<open>f \\<in> F\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F\n  dehomogenize x (homogenize x f) \\<in> dehomogenize x ` ideal G", "have \"f \\<in> dehomogenize x ` ideal G\""], ["proof (prove)\nusing this:\n  f \\<in> F\n  dehomogenize x (homogenize x f) \\<in> dehomogenize x ` ideal G\n\ngoal (1 subgoal):\n 1. f \\<in> dehomogenize x ` ideal G", "by (simp only: eq)"], ["proof (state)\nthis:\n  f \\<in> dehomogenize x ` ideal G\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "also"], ["proof (state)\nthis:\n  f \\<in> dehomogenize x ` ideal G\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "have \"\\<dots> \\<subseteq> ideal (dehomogenize x ` G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize x ` ideal G \\<subseteq> ideal (dehomogenize x ` G)", "by (rule dehomogenize_ideal_subset)"], ["proof (state)\nthis:\n  dehomogenize x ` ideal G \\<subseteq> ideal (dehomogenize x ` G)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> F \\<Longrightarrow> xa \\<in> ideal (dehomogenize x ` G)", "finally"], ["proof (chain)\npicking this:\n  f \\<in> ideal (dehomogenize x ` G)", "show \"f \\<in> ideal (dehomogenize x ` G)\""], ["proof (prove)\nusing this:\n  f \\<in> ideal (dehomogenize x ` G)\n\ngoal (1 subgoal):\n 1. f \\<in> ideal (dehomogenize x ` G)", "."], ["proof (state)\nthis:\n  f \\<in> ideal (dehomogenize x ` G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F \\<subseteq> ideal (dehomogenize x ` G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal (dehomogenize x ` G) = ideal F\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Embedding Polynomial Rings in Larger Polynomial Rings (With One Additional Indeterminate)\\<close>"], ["", "text \\<open>We define a homomorphism for embedding a polynomial ring in a larger polynomial ring, and its\n  inverse. This is mainly needed for homogenizing wrt. a fresh indeterminate.\\<close>"], ["", "definition extend_indets_subst :: \"'x \\<Rightarrow> ('x option \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1\"\n  where \"extend_indets_subst x = monomial 1 (Poly_Mapping.single (Some x) 1)\""], ["", "definition extend_indets :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> ('x option \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1\"\n  where \"extend_indets = poly_subst extend_indets_subst\""], ["", "definition restrict_indets_subst :: \"'x option \\<Rightarrow> 'x \\<Rightarrow>\\<^sub>0 nat\"\n  where \"restrict_indets_subst x = (case x of Some y \\<Rightarrow> Poly_Mapping.single y 1 | _ \\<Rightarrow> 0)\""], ["", "definition restrict_indets :: \"(('x option \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> ('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1\"\n  where \"restrict_indets = poly_subst (\\<lambda>x. monomial 1 (restrict_indets_subst x))\""], ["", "definition restrict_indets_pp :: \"('x option \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> ('x \\<Rightarrow>\\<^sub>0 nat)\"\n  where \"restrict_indets_pp t = (\\<Sum>x\\<in>keys t. lookup t x \\<cdot> restrict_indets_subst x)\""], ["", "lemma lookup_extend_indets_subst_aux:\n  \"lookup (\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y)) = (\\<lambda>x. case x of Some y \\<Rightarrow> lookup t y | _ \\<Rightarrow> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n    (\\<lambda>x.\n        case x of None \\<Rightarrow> 0::'b\n        | Some y \\<Rightarrow> lookup t y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n    (\\<lambda>x.\n        case x of None \\<Rightarrow> 0::'b\n        | Some y \\<Rightarrow> lookup t y)", "have \"(\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "proof (cases \"y \\<in> keys t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "case True"], ["proof (state)\nthis:\n  y \\<in> keys t\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "hence \"(\\<Sum>x\\<in>keys t. lookup t x when x = y) = (\\<Sum>x\\<in>insert y (keys t). lookup t x when x = y)\""], ["proof (prove)\nusing this:\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t. lookup t x when x = y) =\n    (\\<Sum>x\\<in>insert y (keys t). lookup t x when x = y)", "by (simp only: insert_absorb)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t. lookup t x when x = y) =\n  (\\<Sum>x\\<in>insert y (keys t). lookup t x when x = y)\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t. lookup t x when x = y) =\n  (\\<Sum>x\\<in>insert y (keys t). lookup t x when x = y)\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "have \"\\<dots> = lookup t y + (\\<Sum>x\\<in>keys t - {y}. lookup t x when x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>insert y (keys t). lookup t x when x = y) =\n    lookup t y + (\\<Sum>x\\<in>keys t - {y}. lookup t x when x = y)", "by (simp add: sum.insert_remove)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>insert y (keys t). lookup t x when x = y) =\n  lookup t y + (\\<Sum>x\\<in>keys t - {y}. lookup t x when x = y)\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>insert y (keys t). lookup t x when x = y) =\n  lookup t y + (\\<Sum>x\\<in>keys t - {y}. lookup t x when x = y)\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "have \"(\\<Sum>x\\<in>keys t - {y}. lookup t x when x = y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t - {y}. lookup t x when x = y) = (0::'b)", "by (auto simp: when_def intro: sum.neutral)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t - {y}. lookup t x when x = y) = (0::'b)\n\ngoal (2 subgoals):\n 1. y \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y\n 2. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y + (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y + (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y\n\ngoal (1 subgoal):\n 1. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "case False"], ["proof (state)\nthis:\n  y \\<notin> keys t\n\ngoal (1 subgoal):\n 1. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "hence \"(\\<Sum>x\\<in>keys t. lookup t x when x = y) = 0\""], ["proof (prove)\nusing this:\n  y \\<notin> keys t\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t. lookup t x when x = y) = (0::'b)", "by (auto simp: when_def intro: sum.neutral)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t. lookup t x when x = y) = (0::'b)\n\ngoal (1 subgoal):\n 1. y \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "with False"], ["proof (chain)\npicking this:\n  y \\<notin> keys t\n  (\\<Sum>x\\<in>keys t. lookup t x when x = y) = (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<notin> keys t\n  (\\<Sum>x\\<in>keys t. lookup t x when x = y) = (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t. lookup t x when x = y) = lookup t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t. lookup t x when x = ?y) = lookup t ?y\n\ngoal (1 subgoal):\n 1. lookup (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n    (\\<lambda>x.\n        case x of None \\<Rightarrow> 0::'b\n        | Some y \\<Rightarrow> lookup t y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>keys t. lookup t x when x = ?y) = lookup t ?y\n\ngoal (1 subgoal):\n 1. lookup (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n    (\\<lambda>x.\n        case x of None \\<Rightarrow> 0::'b\n        | Some y \\<Rightarrow> lookup t y)", "by (auto simp: lookup_sum lookup_single split: option.split)"], ["proof (state)\nthis:\n  lookup (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n  (\\<lambda>x.\n      case x of None \\<Rightarrow> 0::'b | Some y \\<Rightarrow> lookup t y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_extend_indets_subst_aux:\n  \"keys (\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y)) = Some ` keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n    Some ` keys t", "by (auto simp: lookup_extend_indets_subst_aux simp flip: lookup_not_eq_zero_eq_in_keys split: option.splits)"], ["", "lemma subst_pp_extend_indets_subst:\n  \"subst_pp extend_indets_subst t = monomial 1 (\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp extend_indets_subst t =\n    monomial (1::'b) (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_pp extend_indets_subst t =\n    monomial (1::'b) (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))", "have \"subst_pp extend_indets_subst t =\n      monomial (\\<Prod>y\\<in>keys t. 1 ^ lookup t y) (\\<Sum>y\\<in>keys t. lookup t y \\<cdot> Poly_Mapping.single (Some y) 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp extend_indets_subst t =\n    monomial (\\<Prod>y\\<in>keys t. (1::'c) ^ lookup t y)\n     (\\<Sum>y\\<in>keys t. lookup t y \\<cdot> monomial 1 (Some y))", "by (rule subst_pp_by_monomials) (simp only: extend_indets_subst_def)"], ["proof (state)\nthis:\n  subst_pp extend_indets_subst t =\n  monomial (\\<Prod>y\\<in>keys t. (1::?'c1) ^ lookup t y)\n   (\\<Sum>y\\<in>keys t. lookup t y \\<cdot> monomial 1 (Some y))\n\ngoal (1 subgoal):\n 1. subst_pp extend_indets_subst t =\n    monomial (1::'b) (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))", "also"], ["proof (state)\nthis:\n  subst_pp extend_indets_subst t =\n  monomial (\\<Prod>y\\<in>keys t. (1::?'c1) ^ lookup t y)\n   (\\<Sum>y\\<in>keys t. lookup t y \\<cdot> monomial 1 (Some y))\n\ngoal (1 subgoal):\n 1. subst_pp extend_indets_subst t =\n    monomial (1::'b) (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))", "have \"\\<dots> = monomial 1 (\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (\\<Prod>y\\<in>keys t. (1::'c) ^ lookup t y)\n     (\\<Sum>y\\<in>keys t. lookup t y \\<cdot> monomial 1 (Some y)) =\n    monomial (1::'c) (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))", "by simp"], ["proof (state)\nthis:\n  monomial (\\<Prod>y\\<in>keys t. (1::?'c2) ^ lookup t y)\n   (\\<Sum>y\\<in>keys t. lookup t y \\<cdot> monomial 1 (Some y)) =\n  monomial (1::?'c2) (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n\ngoal (1 subgoal):\n 1. subst_pp extend_indets_subst t =\n    monomial (1::'b) (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))", "finally"], ["proof (chain)\npicking this:\n  subst_pp extend_indets_subst t =\n  monomial (1::?'c3) (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_pp extend_indets_subst t =\n  monomial (1::?'c3) (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n\ngoal (1 subgoal):\n 1. subst_pp extend_indets_subst t =\n    monomial (1::'b) (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))", "."], ["proof (state)\nthis:\n  subst_pp extend_indets_subst t =\n  monomial (1::'b) (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_extend_indets:\n  \"keys (extend_indets p) = (\\<lambda>t. \\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y)) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (extend_indets p) =\n    (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) `\n    keys p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. keys (extend_indets p) =\n    (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) `\n    keys p", "have \"keys (extend_indets p) = (\\<Union>t\\<in>keys p. keys (punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (extend_indets p) =\n    (\\<Union>t\\<in>keys p.\n        keys\n         (punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t)))", "unfolding extend_indets_def poly_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>t\\<in>keys p.\n        punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t)) =\n    (\\<Union>t\\<in>keys p.\n        keys\n         (punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t)))", "using finite_keys"], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>t\\<in>keys p.\n        punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t)) =\n    (\\<Union>t\\<in>keys p.\n        keys\n         (punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t)))", "proof (rule keys_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (punit.monom_mult (lookup p a1) 0\n                            (subst_pp extend_indets_subst a1)) \\<inter>\n                         keys\n                          (punit.monom_mult (lookup p a2) 0\n                            (subst_pp extend_indets_subst a2)) =\n                         {}", "fix s t :: \"'a \\<Rightarrow>\\<^sub>0 nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (punit.monom_mult (lookup p a1) 0\n                            (subst_pp extend_indets_subst a1)) \\<inter>\n                         keys\n                          (punit.monom_mult (lookup p a2) 0\n                            (subst_pp extend_indets_subst a2)) =\n                         {}", "assume \"s \\<noteq> t\""], ["proof (state)\nthis:\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (punit.monom_mult (lookup p a1) 0\n                            (subst_pp extend_indets_subst a1)) \\<inter>\n                         keys\n                          (punit.monom_mult (lookup p a2) 0\n                            (subst_pp extend_indets_subst a2)) =\n                         {}", "then"], ["proof (chain)\npicking this:\n  s \\<noteq> t", "obtain x where \"lookup s x \\<noteq> lookup t x\""], ["proof (prove)\nusing this:\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        lookup s x \\<noteq> lookup t x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson poly_mapping_eqI)"], ["proof (state)\nthis:\n  lookup s x \\<noteq> lookup t x\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (punit.monom_mult (lookup p a1) 0\n                            (subst_pp extend_indets_subst a1)) \\<inter>\n                         keys\n                          (punit.monom_mult (lookup p a2) 0\n                            (subst_pp extend_indets_subst a2)) =\n                         {}", "have \"(\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) \\<noteq> (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y))\"\n      (is \"?l \\<noteq> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) \\<noteq>\n    (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n    (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y)) \\<Longrightarrow>\n    False", "assume \"?l = ?r\""], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n  (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y))\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n    (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y)) \\<Longrightarrow>\n    False", "hence \"lookup ?l (Some x) = lookup ?r (Some x)\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n  (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y))\n\ngoal (1 subgoal):\n 1. lookup (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) (Some x) =\n    lookup (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y)) (Some x)", "by (simp only:)"], ["proof (state)\nthis:\n  lookup (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) (Some x) =\n  lookup (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y)) (Some x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n    (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y)) \\<Longrightarrow>\n    False", "hence \"lookup s x = lookup t x\""], ["proof (prove)\nusing this:\n  lookup (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) (Some x) =\n  lookup (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y)) (Some x)\n\ngoal (1 subgoal):\n 1. lookup s x = lookup t x", "by (simp add: lookup_extend_indets_subst_aux)"], ["proof (state)\nthis:\n  lookup s x = lookup t x\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n    (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y)) \\<Longrightarrow>\n    False", "with \\<open>lookup s x \\<noteq> lookup t x\\<close>"], ["proof (chain)\npicking this:\n  lookup s x \\<noteq> lookup t x\n  lookup s x = lookup t x", "show False"], ["proof (prove)\nusing this:\n  lookup s x \\<noteq> lookup t x\n  lookup s x = lookup t x\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) \\<noteq>\n  (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (punit.monom_mult (lookup p a1) 0\n                            (subst_pp extend_indets_subst a1)) \\<inter>\n                         keys\n                          (punit.monom_mult (lookup p a2) 0\n                            (subst_pp extend_indets_subst a2)) =\n                         {}", "thus \"keys (punit.monom_mult (lookup p s) 0 (subst_pp extend_indets_subst s)) \\<inter>\n          keys (punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t)) =\n          {}\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) \\<noteq>\n  (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y))\n\ngoal (1 subgoal):\n 1. keys\n     (punit.monom_mult (lookup p s) 0\n       (subst_pp extend_indets_subst s)) \\<inter>\n    keys\n     (punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t)) =\n    {}", "by (simp add: subst_pp_extend_indets_subst punit.monom_mult_monomial)"], ["proof (state)\nthis:\n  keys\n   (punit.monom_mult (lookup p s) 0\n     (subst_pp extend_indets_subst s)) \\<inter>\n  keys (punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t)) =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (extend_indets p) =\n  (\\<Union>t\\<in>keys p.\n      keys\n       (punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t)))\n\ngoal (1 subgoal):\n 1. keys (extend_indets p) =\n    (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) `\n    keys p", "also"], ["proof (state)\nthis:\n  keys (extend_indets p) =\n  (\\<Union>t\\<in>keys p.\n      keys\n       (punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t)))\n\ngoal (1 subgoal):\n 1. keys (extend_indets p) =\n    (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) `\n    keys p", "have \"\\<dots> = (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>t\\<in>keys p.\n        keys\n         (punit.monom_mult (lookup p t) 0\n           (subst_pp extend_indets_subst t))) =\n    (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) `\n    keys p", "by (auto simp: subst_pp_extend_indets_subst punit.monom_mult_monomial split: if_split_asm)"], ["proof (state)\nthis:\n  (\\<Union>t\\<in>keys p.\n      keys\n       (punit.monom_mult (lookup p t) 0 (subst_pp extend_indets_subst t))) =\n  (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) ` keys p\n\ngoal (1 subgoal):\n 1. keys (extend_indets p) =\n    (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) `\n    keys p", "finally"], ["proof (chain)\npicking this:\n  keys (extend_indets p) =\n  (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) ` keys p", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (extend_indets p) =\n  (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) ` keys p\n\ngoal (1 subgoal):\n 1. keys (extend_indets p) =\n    (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) `\n    keys p", "."], ["proof (state)\nthis:\n  keys (extend_indets p) =\n  (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_extend_indets: \"indets (extend_indets p) = Some ` indets (p::_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (extend_indets p) = Some ` indets p", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> indets (extend_indets p)) = (x \\<in> Some ` indets p)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> indets (extend_indets p)) = (x \\<in> Some ` indets p)", "show \"x \\<in> indets (extend_indets p) \\<longleftrightarrow> x \\<in> Some ` indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> indets (extend_indets p)) = (x \\<in> Some ` indets p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> indets (extend_indets p) \\<Longrightarrow>\n    x \\<in> Some ` indets p\n 2. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "assume \"x \\<in> indets (extend_indets p)\""], ["proof (state)\nthis:\n  x \\<in> indets (extend_indets p)\n\ngoal (2 subgoals):\n 1. x \\<in> indets (extend_indets p) \\<Longrightarrow>\n    x \\<in> Some ` indets p\n 2. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "then"], ["proof (chain)\npicking this:\n  x \\<in> indets (extend_indets p)", "obtain y where \"y \\<in> indets p\" and \"x \\<in> indets (monomial (1::'a) (Poly_Mapping.single (Some y) 1))\""], ["proof (prove)\nusing this:\n  x \\<in> indets (extend_indets p)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p;\n         x \\<in> indets (monomial (1::'a) (monomial 1 (Some y)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding extend_indets_def extend_indets_subst_def"], ["proof (prove)\nusing this:\n  x \\<in> indets\n           (poly_subst (\\<lambda>x. monomial (1::'a) (monomial 1 (Some x)))\n             p)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p;\n         x \\<in> indets (monomial (1::'a) (monomial 1 (Some y)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_indets_poly_substE)"], ["proof (state)\nthis:\n  y \\<in> indets p\n  x \\<in> indets (monomial (1::'a) (monomial 1 (Some y)))\n\ngoal (2 subgoals):\n 1. x \\<in> indets (extend_indets p) \\<Longrightarrow>\n    x \\<in> Some ` indets p\n 2. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "from this(2) indets_monomial_single_subset"], ["proof (chain)\npicking this:\n  x \\<in> indets (monomial (1::'a) (monomial 1 (Some y)))\n  indets (monomial ?c (monomial ?k ?v)) \\<subseteq> {?v}", "have \"x \\<in> {Some y}\""], ["proof (prove)\nusing this:\n  x \\<in> indets (monomial (1::'a) (monomial 1 (Some y)))\n  indets (monomial ?c (monomial ?k ?v)) \\<subseteq> {?v}\n\ngoal (1 subgoal):\n 1. x \\<in> {Some y}", ".."], ["proof (state)\nthis:\n  x \\<in> {Some y}\n\ngoal (2 subgoals):\n 1. x \\<in> indets (extend_indets p) \\<Longrightarrow>\n    x \\<in> Some ` indets p\n 2. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "hence \"x = Some y\""], ["proof (prove)\nusing this:\n  x \\<in> {Some y}\n\ngoal (1 subgoal):\n 1. x = Some y", "by simp"], ["proof (state)\nthis:\n  x = Some y\n\ngoal (2 subgoals):\n 1. x \\<in> indets (extend_indets p) \\<Longrightarrow>\n    x \\<in> Some ` indets p\n 2. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "with \\<open>y \\<in> indets p\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> indets p\n  x = Some y", "show \"x \\<in> Some ` indets p\""], ["proof (prove)\nusing this:\n  y \\<in> indets p\n  x = Some y\n\ngoal (1 subgoal):\n 1. x \\<in> Some ` indets p", "by (rule rev_image_eqI)"], ["proof (state)\nthis:\n  x \\<in> Some ` indets p\n\ngoal (1 subgoal):\n 1. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "assume \"x \\<in> Some ` indets p\""], ["proof (state)\nthis:\n  x \\<in> Some ` indets p\n\ngoal (1 subgoal):\n 1. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "then"], ["proof (chain)\npicking this:\n  x \\<in> Some ` indets p", "obtain y where \"y \\<in> indets p\" and x: \"x = Some y\""], ["proof (prove)\nusing this:\n  x \\<in> Some ` indets p\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p; x = Some y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  y \\<in> indets p\n  x = Some y\n\ngoal (1 subgoal):\n 1. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "from this(1)"], ["proof (chain)\npicking this:\n  y \\<in> indets p", "obtain t where \"t \\<in> keys p\" and \"y \\<in> keys t\""], ["proof (prove)\nusing this:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; y \\<in> keys t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_indetsE)"], ["proof (state)\nthis:\n  t \\<in> keys p\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "from this(2)"], ["proof (chain)\npicking this:\n  y \\<in> keys t", "have \"Some y \\<in> keys (\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y))\""], ["proof (prove)\nusing this:\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. Some y \\<in> keys (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))", "unfolding keys_extend_indets_subst_aux"], ["proof (prove)\nusing this:\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. Some y \\<in> Some ` keys t", "by (rule imageI)"], ["proof (state)\nthis:\n  Some y \\<in> keys (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n\ngoal (1 subgoal):\n 1. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "moreover"], ["proof (state)\nthis:\n  Some y \\<in> keys (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n\ngoal (1 subgoal):\n 1. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "have \"(\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y)) \\<in> keys (extend_indets p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n    \\<in> keys (extend_indets p)", "unfolding keys_extend_indets"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n    \\<in> (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) `\n          keys p", "using \\<open>t \\<in> keys p\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n    \\<in> (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) `\n          keys p", "by (rule imageI)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n  \\<in> keys (extend_indets p)\n\ngoal (1 subgoal):\n 1. x \\<in> Some ` indets p \\<Longrightarrow>\n    x \\<in> indets (extend_indets p)", "ultimately"], ["proof (chain)\npicking this:\n  Some y \\<in> keys (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n  \\<in> keys (extend_indets p)", "show \"x \\<in> indets (extend_indets p)\""], ["proof (prove)\nusing this:\n  Some y \\<in> keys (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n  \\<in> keys (extend_indets p)\n\ngoal (1 subgoal):\n 1. x \\<in> indets (extend_indets p)", "unfolding x"], ["proof (prove)\nusing this:\n  Some y \\<in> keys (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n  \\<in> keys (extend_indets p)\n\ngoal (1 subgoal):\n 1. Some y \\<in> indets (extend_indets p)", "by (rule in_indetsI)"], ["proof (state)\nthis:\n  x \\<in> indets (extend_indets p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> indets (extend_indets p)) = (x \\<in> Some ` indets p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_extend_indets [simp]: \"poly_deg (extend_indets p) = poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (extend_indets p) = poly_deg p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg (extend_indets p) = poly_deg p", "have eq: \"deg_pm ((\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y))) = deg_pm t\"\n    for t::\"'a \\<Rightarrow>\\<^sub>0 nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) = deg_pm t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) = deg_pm t", "have \"deg_pm ((\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y))) = (\\<Sum>y\\<in>keys t. lookup t y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n    sum (lookup t) (keys t)", "by (simp add: deg_pm_sum deg_pm_single)"], ["proof (state)\nthis:\n  deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n  sum (lookup t) (keys t)\n\ngoal (1 subgoal):\n 1. deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) = deg_pm t", "also"], ["proof (state)\nthis:\n  deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) =\n  sum (lookup t) (keys t)\n\ngoal (1 subgoal):\n 1. deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) = deg_pm t", "from subset_refl finite_keys"], ["proof (chain)\npicking this:\n  ?A \\<subseteq> ?A\n  finite (keys ?f)", "have \"\\<dots> = deg_pm t\""], ["proof (prove)\nusing this:\n  ?A \\<subseteq> ?A\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. sum (lookup t) (keys t) = deg_pm t", "by (rule deg_pm_superset[symmetric])"], ["proof (state)\nthis:\n  sum (lookup t) (keys t) = deg_pm t\n\ngoal (1 subgoal):\n 1. deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) = deg_pm t", "finally"], ["proof (chain)\npicking this:\n  deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) = deg_pm t", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) = deg_pm t\n\ngoal (1 subgoal):\n 1. deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) = deg_pm t", "."], ["proof (state)\nthis:\n  deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) = deg_pm t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pm (\\<Sum>y\\<in>keys ?t. monomial (lookup ?t y) (Some y)) = deg_pm ?t\n\ngoal (1 subgoal):\n 1. poly_deg (extend_indets p) = poly_deg p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (extend_indets p) = poly_deg p", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_deg (extend_indets p) \\<le> poly_deg p\n 2. poly_deg p \\<le> poly_deg (extend_indets p)", "show \"poly_deg (extend_indets p) \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (extend_indets p) \\<le> poly_deg p", "proof (rule poly_deg_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (extend_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (extend_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "assume \"t \\<in> keys (extend_indets p)\""], ["proof (state)\nthis:\n  t \\<in> keys (extend_indets p)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (extend_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "then"], ["proof (chain)\npicking this:\n  t \\<in> keys (extend_indets p)", "obtain s where \"s \\<in> keys p\" and \"t = (\\<Sum>y\\<in>keys s. Poly_Mapping.single (Some y) (lookup s y))\""], ["proof (prove)\nusing this:\n  t \\<in> keys (extend_indets p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t = (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding keys_extend_indets"], ["proof (prove)\nusing this:\n  t \\<in> (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) `\n          keys p\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p;\n         t = (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> keys p\n  t = (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (extend_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "from this(2)"], ["proof (chain)\npicking this:\n  t = (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y))", "have \"deg_pm t = deg_pm s\""], ["proof (prove)\nusing this:\n  t = (\\<Sum>y\\<in>keys s. monomial (lookup s y) (Some y))\n\ngoal (1 subgoal):\n 1. deg_pm t = deg_pm s", "by (simp only: eq)"], ["proof (state)\nthis:\n  deg_pm t = deg_pm s\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (extend_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "also"], ["proof (state)\nthis:\n  deg_pm t = deg_pm s\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (extend_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "from \\<open>s \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p", "have \"\\<dots> \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm s \\<le> poly_deg p", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm s \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (extend_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "finally"], ["proof (chain)\npicking this:\n  deg_pm t \\<le> poly_deg p", "show \"deg_pm t \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  deg_pm t \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "."], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg (extend_indets p) \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (extend_indets p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (extend_indets p)", "show \"poly_deg p \\<le> poly_deg (extend_indets p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg p \\<le> poly_deg (extend_indets p)", "proof (rule poly_deg_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys p \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg (extend_indets p)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys p \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg (extend_indets p)", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys p \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg (extend_indets p)", "hence *: \"(\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y)) \\<in> keys (extend_indets p)\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n    \\<in> keys (extend_indets p)", "unfolding keys_extend_indets"], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n    \\<in> (\\<lambda>t. \\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y)) `\n          keys p", "by (rule imageI)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n  \\<in> keys (extend_indets p)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys p \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg (extend_indets p)", "have \"deg_pm t = deg_pm (\\<Sum>y\\<in>keys t. Poly_Mapping.single (Some y) (lookup t y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t = deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))", "by (simp only: eq)"], ["proof (state)\nthis:\n  deg_pm t = deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys p \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg (extend_indets p)", "also"], ["proof (state)\nthis:\n  deg_pm t = deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys p \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg (extend_indets p)", "from *"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n  \\<in> keys (extend_indets p)", "have \"\\<dots> \\<le> poly_deg (extend_indets p)\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n  \\<in> keys (extend_indets p)\n\ngoal (1 subgoal):\n 1. deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n    \\<le> poly_deg (extend_indets p)", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm (\\<Sum>y\\<in>keys t. monomial (lookup t y) (Some y))\n  \\<le> poly_deg (extend_indets p)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys p \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg (extend_indets p)", "finally"], ["proof (chain)\npicking this:\n  deg_pm t \\<le> poly_deg (extend_indets p)", "show \"deg_pm t \\<le> poly_deg (extend_indets p)\""], ["proof (prove)\nusing this:\n  deg_pm t \\<le> poly_deg (extend_indets p)\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg (extend_indets p)", "."], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg (extend_indets p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg p \\<le> poly_deg (extend_indets p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg (extend_indets p) = poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  shows extend_indets_zero [simp]: \"extend_indets 0 = 0\"\n    and extend_indets_one [simp]: \"extend_indets 1 = 1\"\n    and extend_indets_monomial: \"extend_indets (monomial c t) = punit.monom_mult c 0 (subst_pp extend_indets_subst t)\"\n    and extend_indets_plus: \"extend_indets (p + q) = extend_indets p + extend_indets q\"\n    and extend_indets_uminus: \"extend_indets (- r) = - extend_indets (r::_ \\<Rightarrow>\\<^sub>0 _::comm_ring_1)\"\n    and extend_indets_minus: \"extend_indets (r - r') = extend_indets r - extend_indets r'\"\n    and extend_indets_times: \"extend_indets (p * q) = extend_indets p * extend_indets q\"\n    and extend_indets_power: \"extend_indets (p ^ n) = extend_indets p ^ n\"\n    and extend_indets_sum: \"extend_indets (sum f A) = (\\<Sum>a\\<in>A. extend_indets (f a))\"\n    and extend_indets_prod: \"extend_indets (prod f A) = (\\<Prod>a\\<in>A. extend_indets (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((extend_indets 0 = 0 &&& extend_indets 1 = 1) &&&\n     extend_indets (monomial c t) =\n     punit.monom_mult c 0 (subst_pp extend_indets_subst t) &&&\n     extend_indets (p + q) = extend_indets p + extend_indets q &&&\n     extend_indets (- r) = - extend_indets r) &&&\n    (extend_indets (r - r') = extend_indets r - extend_indets r' &&&\n     extend_indets (p * q) = extend_indets p * extend_indets q) &&&\n    extend_indets (p ^ n) = extend_indets p ^ n &&&\n    extend_indets (sum f A) = (\\<Sum>a\\<in>A. extend_indets (f a)) &&&\n    extend_indets (prod f A) = (\\<Prod>a\\<in>A. extend_indets (f a))", "by (simp_all add: extend_indets_def poly_subst_monomial poly_subst_plus poly_subst_uminus\n      poly_subst_minus poly_subst_times poly_subst_power poly_subst_sum poly_subst_prod)"], ["", "lemma extend_indets_zero_iff [simp]: \"extend_indets p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (extend_indets p = 0) = (p = 0)", "by (metis (no_types, lifting) imageE imageI keys_extend_indets lookup_zero\n      not_in_keys_iff_lookup_eq_zero poly_deg_extend_indets poly_deg_zero poly_deg_zero_imp_monomial)"], ["", "lemma extend_indets_inject:\n  assumes \"extend_indets p = extend_indets (q::_ \\<Rightarrow>\\<^sub>0 _::comm_ring_1)\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = q", "from assms"], ["proof (chain)\npicking this:\n  extend_indets p = extend_indets q", "have \"extend_indets (p - q) = 0\""], ["proof (prove)\nusing this:\n  extend_indets p = extend_indets q\n\ngoal (1 subgoal):\n 1. extend_indets (p - q) = 0", "by (simp add: extend_indets_minus)"], ["proof (state)\nthis:\n  extend_indets (p - q) = 0\n\ngoal (1 subgoal):\n 1. p = q", "thus ?thesis"], ["proof (prove)\nusing this:\n  extend_indets (p - q) = 0\n\ngoal (1 subgoal):\n 1. p = q", "by simp"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary inj_extend_indets: \"inj (extend_indets::_ \\<Rightarrow> _ \\<Rightarrow>\\<^sub>0 _::comm_ring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj extend_indets", "using extend_indets_inject"], ["proof (prove)\nusing this:\n  extend_indets ?p = extend_indets ?q \\<Longrightarrow> ?p = ?q\n\ngoal (1 subgoal):\n 1. inj extend_indets", "by (intro injI)"], ["", "lemma poly_subst_extend_indets: \"poly_subst f (extend_indets p) = poly_subst (f \\<circ> Some) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst f (extend_indets p) = poly_subst (f \\<circ> Some) p", "by (simp add: extend_indets_def poly_subst_poly_subst extend_indets_subst_def poly_subst_monomial\n          subst_pp_single o_def)"], ["", "lemma poly_eval_extend_indets: \"poly_eval a (extend_indets p) = poly_eval (a \\<circ> Some) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (extend_indets p) = poly_eval (a \\<circ> Some) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval a (extend_indets p) = poly_eval (a \\<circ> Some) p", "have eq: \"poly_eval a (extend_indets (monomial c t)) = poly_eval (\\<lambda>x. a (Some x)) (monomial c t)\"\n    for c t"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (extend_indets (monomial c t)) =\n    poly_eval (\\<lambda>x. a (Some x)) (monomial c t)", "by (simp add: extend_indets_monomial poly_eval_times poly_eval_monomial poly_eval_prod poly_eval_power\n                subst_pp_def extend_indets_subst_def flip: times_monomial_left)"], ["proof (state)\nthis:\n  poly_eval a (extend_indets (monomial ?c ?t)) =\n  poly_eval (\\<lambda>x. a (Some x)) (monomial ?c ?t)\n\ngoal (1 subgoal):\n 1. poly_eval a (extend_indets p) = poly_eval (a \\<circ> Some) p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (extend_indets p) = poly_eval (a \\<circ> Some) p", "by (induct p rule: poly_mapping_plus_induct) (simp_all add: extend_indets_plus poly_eval_plus eq)"], ["proof (state)\nthis:\n  poly_eval a (extend_indets p) = poly_eval (a \\<circ> Some) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_restrict_indets_pp: \"lookup (restrict_indets_pp t) = (\\<lambda>x. lookup t (Some x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (restrict_indets_pp t) = (\\<lambda>x. lookup t (Some x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (restrict_indets_pp t) = (\\<lambda>x. lookup t (Some x))", "let ?f = \"\\<lambda>z x. lookup t x * lookup (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> Poly_Mapping.single y 1) z\""], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (restrict_indets_pp t) = (\\<lambda>x. lookup t (Some x))", "have \"sum (?f z) (keys t) = lookup t (Some z)\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "proof (cases \"Some z \\<in> keys t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Some z \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)\n 2. Some z \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "case True"], ["proof (state)\nthis:\n  Some z \\<in> keys t\n\ngoal (2 subgoals):\n 1. Some z \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)\n 2. Some z \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "hence \"sum (?f z) (keys t) = sum (?f z) (insert (Some z) (keys t))\""], ["proof (prove)\nusing this:\n  Some z \\<in> keys t\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    (\\<Sum>x\\<in>insert (Some z) (keys t).\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z)", "by (simp only: insert_absorb)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  (\\<Sum>x\\<in>insert (Some z) (keys t).\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z)\n\ngoal (2 subgoals):\n 1. Some z \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)\n 2. Some z \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  (\\<Sum>x\\<in>insert (Some z) (keys t).\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z)\n\ngoal (2 subgoals):\n 1. Some z \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)\n 2. Some z \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "have \"\\<dots> = lookup t (Some z) + sum (?f z) (keys t - {Some z})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>insert (Some z) (keys t).\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z) +\n    (\\<Sum>x\\<in>keys t - {Some z}.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z)", "by (simp add: sum.insert_remove)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>insert (Some z) (keys t).\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  lookup t (Some z) +\n  (\\<Sum>x\\<in>keys t - {Some z}.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z)\n\ngoal (2 subgoals):\n 1. Some z \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)\n 2. Some z \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>insert (Some z) (keys t).\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  lookup t (Some z) +\n  (\\<Sum>x\\<in>keys t - {Some z}.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z)\n\ngoal (2 subgoals):\n 1. Some z \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)\n 2. Some z \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "have \"sum (?f z) (keys t - {Some z}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t - {Some z}.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    0", "by (auto simp: when_def lookup_single intro: sum.neutral split: option.splits)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t - {Some z}.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  0\n\ngoal (2 subgoals):\n 1. Some z \\<in> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)\n 2. Some z \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>keys t.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  lookup t (Some z) + 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>keys t.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  lookup t (Some z) + 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  lookup t (Some z)\n\ngoal (1 subgoal):\n 1. Some z \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Some z \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "case False"], ["proof (state)\nthis:\n  Some z \\<notin> keys t\n\ngoal (1 subgoal):\n 1. Some z \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "hence \"sum (?f z) (keys t) = 0\""], ["proof (prove)\nusing this:\n  Some z \\<notin> keys t\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    0", "by (auto simp: when_def lookup_single intro: sum.neutral split: option.splits)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  0\n\ngoal (1 subgoal):\n 1. Some z \\<notin> keys t \\<Longrightarrow>\n    (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "with False"], ["proof (chain)\npicking this:\n  Some z \\<notin> keys t\n  (\\<Sum>x\\<in>keys t.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  Some z \\<notin> keys t\n  (\\<Sum>x\\<in>keys t.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t.\n       lookup t x *\n       lookup\n        (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n        z) =\n    lookup t (Some z)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      z) =\n  lookup t (Some z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      ?z) =\n  lookup t (Some ?z)\n\ngoal (1 subgoal):\n 1. lookup (restrict_indets_pp t) = (\\<lambda>x. lookup t (Some x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>keys t.\n     lookup t x *\n     lookup\n      (case x of None \\<Rightarrow> 0 | Some y \\<Rightarrow> monomial 1 y)\n      ?z) =\n  lookup t (Some ?z)\n\ngoal (1 subgoal):\n 1. lookup (restrict_indets_pp t) = (\\<lambda>x. lookup t (Some x))", "by (auto simp: restrict_indets_pp_def restrict_indets_subst_def lookup_sum)"], ["proof (state)\nthis:\n  lookup (restrict_indets_pp t) = (\\<lambda>x. lookup t (Some x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_restrict_indets_pp: \"keys (restrict_indets_pp t) = the ` (keys t - {None})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (restrict_indets_pp t) = the ` (keys t - {None})", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> keys (restrict_indets_pp t)) =\n       (x \\<in> the ` (keys t - {None}))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> keys (restrict_indets_pp t)) =\n       (x \\<in> the ` (keys t - {None}))", "show \"x \\<in> keys (restrict_indets_pp t) \\<longleftrightarrow> x \\<in> the ` (keys t - {None})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> keys (restrict_indets_pp t)) =\n    (x \\<in> the ` (keys t - {None}))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> keys (restrict_indets_pp t) \\<Longrightarrow>\n    x \\<in> the ` (keys t - {None})\n 2. x \\<in> the ` (keys t - {None}) \\<Longrightarrow>\n    x \\<in> keys (restrict_indets_pp t)", "assume \"x \\<in> keys (restrict_indets_pp t)\""], ["proof (state)\nthis:\n  x \\<in> keys (restrict_indets_pp t)\n\ngoal (2 subgoals):\n 1. x \\<in> keys (restrict_indets_pp t) \\<Longrightarrow>\n    x \\<in> the ` (keys t - {None})\n 2. x \\<in> the ` (keys t - {None}) \\<Longrightarrow>\n    x \\<in> keys (restrict_indets_pp t)", "hence \"Some x \\<in> keys t\""], ["proof (prove)\nusing this:\n  x \\<in> keys (restrict_indets_pp t)\n\ngoal (1 subgoal):\n 1. Some x \\<in> keys t", "by (simp add: lookup_restrict_indets_pp flip: lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  Some x \\<in> keys t\n\ngoal (2 subgoals):\n 1. x \\<in> keys (restrict_indets_pp t) \\<Longrightarrow>\n    x \\<in> the ` (keys t - {None})\n 2. x \\<in> the ` (keys t - {None}) \\<Longrightarrow>\n    x \\<in> keys (restrict_indets_pp t)", "hence \"Some x \\<in> keys t - {None}\""], ["proof (prove)\nusing this:\n  Some x \\<in> keys t\n\ngoal (1 subgoal):\n 1. Some x \\<in> keys t - {None}", "by blast"], ["proof (state)\nthis:\n  Some x \\<in> keys t - {None}\n\ngoal (2 subgoals):\n 1. x \\<in> keys (restrict_indets_pp t) \\<Longrightarrow>\n    x \\<in> the ` (keys t - {None})\n 2. x \\<in> the ` (keys t - {None}) \\<Longrightarrow>\n    x \\<in> keys (restrict_indets_pp t)", "moreover"], ["proof (state)\nthis:\n  Some x \\<in> keys t - {None}\n\ngoal (2 subgoals):\n 1. x \\<in> keys (restrict_indets_pp t) \\<Longrightarrow>\n    x \\<in> the ` (keys t - {None})\n 2. x \\<in> the ` (keys t - {None}) \\<Longrightarrow>\n    x \\<in> keys (restrict_indets_pp t)", "have \"x = the (Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = the (Some x)", "by simp"], ["proof (state)\nthis:\n  x = the (Some x)\n\ngoal (2 subgoals):\n 1. x \\<in> keys (restrict_indets_pp t) \\<Longrightarrow>\n    x \\<in> the ` (keys t - {None})\n 2. x \\<in> the ` (keys t - {None}) \\<Longrightarrow>\n    x \\<in> keys (restrict_indets_pp t)", "ultimately"], ["proof (chain)\npicking this:\n  Some x \\<in> keys t - {None}\n  x = the (Some x)", "show \"x \\<in> the ` (keys t - {None})\""], ["proof (prove)\nusing this:\n  Some x \\<in> keys t - {None}\n  x = the (Some x)\n\ngoal (1 subgoal):\n 1. x \\<in> the ` (keys t - {None})", "by (rule rev_image_eqI)"], ["proof (state)\nthis:\n  x \\<in> the ` (keys t - {None})\n\ngoal (1 subgoal):\n 1. x \\<in> the ` (keys t - {None}) \\<Longrightarrow>\n    x \\<in> keys (restrict_indets_pp t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> the ` (keys t - {None}) \\<Longrightarrow>\n    x \\<in> keys (restrict_indets_pp t)", "assume \"x \\<in> the ` (keys t - {None})\""], ["proof (state)\nthis:\n  x \\<in> the ` (keys t - {None})\n\ngoal (1 subgoal):\n 1. x \\<in> the ` (keys t - {None}) \\<Longrightarrow>\n    x \\<in> keys (restrict_indets_pp t)", "then"], ["proof (chain)\npicking this:\n  x \\<in> the ` (keys t - {None})", "obtain y where \"y \\<in> keys t - {None}\" and \"x = the y\""], ["proof (prove)\nusing this:\n  x \\<in> the ` (keys t - {None})\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t - {None}; x = the y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  y \\<in> keys t - {None}\n  x = the y\n\ngoal (1 subgoal):\n 1. x \\<in> the ` (keys t - {None}) \\<Longrightarrow>\n    x \\<in> keys (restrict_indets_pp t)", "hence \"Some x \\<in> keys t\""], ["proof (prove)\nusing this:\n  y \\<in> keys t - {None}\n  x = the y\n\ngoal (1 subgoal):\n 1. Some x \\<in> keys t", "by auto"], ["proof (state)\nthis:\n  Some x \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> the ` (keys t - {None}) \\<Longrightarrow>\n    x \\<in> keys (restrict_indets_pp t)", "thus \"x \\<in> keys (restrict_indets_pp t)\""], ["proof (prove)\nusing this:\n  Some x \\<in> keys t\n\ngoal (1 subgoal):\n 1. x \\<in> keys (restrict_indets_pp t)", "by (simp add: lookup_restrict_indets_pp flip: lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  x \\<in> keys (restrict_indets_pp t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> keys (restrict_indets_pp t)) = (x \\<in> the ` (keys t - {None}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_pp_restrict_indets_subst:\n  \"subst_pp (\\<lambda>x. monomial 1 (restrict_indets_subst x)) t = monomial 1 (restrict_indets_pp t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp (\\<lambda>x. monomial (1::'b) (restrict_indets_subst x)) t =\n    monomial (1::'b) (restrict_indets_pp t)", "by (simp add: subst_pp_def monomial_power_map_scale restrict_indets_pp_def flip: punit.monomial_prod_sum)"], ["", "lemma restrict_indets_pp_zero [simp]: \"restrict_indets_pp 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets_pp 0 = 0", "by (simp add: restrict_indets_pp_def)"], ["", "lemma restrict_indets_pp_plus: \"restrict_indets_pp (s + t) = restrict_indets_pp s + restrict_indets_pp t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets_pp (s + t) = restrict_indets_pp s + restrict_indets_pp t", "by (rule poly_mapping_eqI) (simp add: lookup_add lookup_restrict_indets_pp)"], ["", "lemma restrict_indets_pp_except_None [simp]:\n  \"restrict_indets_pp (except t {None}) = restrict_indets_pp t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets_pp (except t {None}) = restrict_indets_pp t", "by (rule poly_mapping_eqI) (simp add: lookup_add lookup_restrict_indets_pp lookup_except)"], ["", "lemma deg_pm_restrict_indets_pp: \"deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t", "have \"deg_pm t = sum (lookup t) (insert None (keys t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t = sum (lookup t) (insert None (keys t))", "by (rule deg_pm_superset) auto"], ["proof (state)\nthis:\n  deg_pm t = sum (lookup t) (insert None (keys t))\n\ngoal (1 subgoal):\n 1. deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t", "also"], ["proof (state)\nthis:\n  deg_pm t = sum (lookup t) (insert None (keys t))\n\ngoal (1 subgoal):\n 1. deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"\\<dots> = lookup t None + sum (lookup t) (keys t - {None})\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. sum (lookup t) (insert None (keys t)) =\n    lookup t None + sum (lookup t) (keys t - {None})", "by (rule sum.insert_remove)"], ["proof (state)\nthis:\n  sum (lookup t) (insert None (keys t)) =\n  lookup t None + sum (lookup t) (keys t - {None})\n\ngoal (1 subgoal):\n 1. deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t", "also"], ["proof (state)\nthis:\n  sum (lookup t) (insert None (keys t)) =\n  lookup t None + sum (lookup t) (keys t - {None})\n\ngoal (1 subgoal):\n 1. deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t", "have \"sum (lookup t) (keys t - {None}) = (\\<Sum>x\\<in>keys t. lookup t x * deg_pm (restrict_indets_subst x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup t) (keys t - {None}) =\n    (\\<Sum>x\\<in>keys t. lookup t x * deg_pm (restrict_indets_subst x))", "by (intro sum.mono_neutral_cong_left) (auto simp: restrict_indets_subst_def deg_pm_single)"], ["proof (state)\nthis:\n  sum (lookup t) (keys t - {None}) =\n  (\\<Sum>x\\<in>keys t. lookup t x * deg_pm (restrict_indets_subst x))\n\ngoal (1 subgoal):\n 1. deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t", "also"], ["proof (state)\nthis:\n  sum (lookup t) (keys t - {None}) =\n  (\\<Sum>x\\<in>keys t. lookup t x * deg_pm (restrict_indets_subst x))\n\ngoal (1 subgoal):\n 1. deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t", "have \"\\<dots> = deg_pm (restrict_indets_pp t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys t. lookup t x * deg_pm (restrict_indets_subst x)) =\n    deg_pm (restrict_indets_pp t)", "by (simp only: restrict_indets_pp_def deg_pm_sum deg_pm_map_scale)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys t. lookup t x * deg_pm (restrict_indets_subst x)) =\n  deg_pm (restrict_indets_pp t)\n\ngoal (1 subgoal):\n 1. deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t", "finally"], ["proof (chain)\npicking this:\n  deg_pm t = lookup t None + deg_pm (restrict_indets_pp t)", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t = lookup t None + deg_pm (restrict_indets_pp t)\n\ngoal (1 subgoal):\n 1. deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t", "by simp"], ["proof (state)\nthis:\n  deg_pm (restrict_indets_pp t) + lookup t None = deg_pm t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_restrict_indets_subset: \"keys (restrict_indets p) \\<subseteq> restrict_indets_pp ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (restrict_indets p) \\<subseteq> restrict_indets_pp ` keys p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       x \\<in> restrict_indets_pp ` keys p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       x \\<in> restrict_indets_pp ` keys p", "assume \"t \\<in> keys (restrict_indets p)\""], ["proof (state)\nthis:\n  t \\<in> keys (restrict_indets p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       x \\<in> restrict_indets_pp ` keys p", "also"], ["proof (state)\nthis:\n  t \\<in> keys (restrict_indets p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       x \\<in> restrict_indets_pp ` keys p", "have \"\\<dots> = keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (restrict_indets p) =\n    keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t))", "by (simp add: restrict_indets_def poly_subst_def subst_pp_restrict_indets_subst punit.monom_mult_monomial)"], ["proof (state)\nthis:\n  keys (restrict_indets p) =\n  keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       x \\<in> restrict_indets_pp ` keys p", "also"], ["proof (state)\nthis:\n  keys (restrict_indets p) =\n  keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       x \\<in> restrict_indets_pp ` keys p", "have \"\\<dots> \\<subseteq> (\\<Union>t\\<in>keys p. keys (monomial (lookup p t) (restrict_indets_pp t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t))\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    keys (monomial (lookup p t) (restrict_indets_pp t)))", "by (rule keys_sum_subset)"], ["proof (state)\nthis:\n  keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t))\n  \\<subseteq> (\\<Union>t\\<in>keys p.\n                  keys (monomial (lookup p t) (restrict_indets_pp t)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       x \\<in> restrict_indets_pp ` keys p", "also"], ["proof (state)\nthis:\n  keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t))\n  \\<subseteq> (\\<Union>t\\<in>keys p.\n                  keys (monomial (lookup p t) (restrict_indets_pp t)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       x \\<in> restrict_indets_pp ` keys p", "have \"\\<dots> = restrict_indets_pp ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>t\\<in>keys p.\n        keys (monomial (lookup p t) (restrict_indets_pp t))) =\n    restrict_indets_pp ` keys p", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  (\\<Union>t\\<in>keys p.\n      keys (monomial (lookup p t) (restrict_indets_pp t))) =\n  restrict_indets_pp ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       x \\<in> restrict_indets_pp ` keys p", "finally"], ["proof (chain)\npicking this:\n  t \\<in> restrict_indets_pp ` keys p", "show \"t \\<in> restrict_indets_pp ` keys p\""], ["proof (prove)\nusing this:\n  t \\<in> restrict_indets_pp ` keys p\n\ngoal (1 subgoal):\n 1. t \\<in> restrict_indets_pp ` keys p", "."], ["proof (state)\nthis:\n  t \\<in> restrict_indets_pp ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_restrict_indets:\n  assumes \"None \\<notin> indets p\"\n  shows \"keys (restrict_indets p) = restrict_indets_pp ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (restrict_indets p) = restrict_indets_pp ` keys p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. keys (restrict_indets p) = restrict_indets_pp ` keys p", "have \"keys (restrict_indets p) = keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (restrict_indets p) =\n    keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t))", "by (simp add: restrict_indets_def poly_subst_def subst_pp_restrict_indets_subst punit.monom_mult_monomial)"], ["proof (state)\nthis:\n  keys (restrict_indets p) =\n  keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t))\n\ngoal (1 subgoal):\n 1. keys (restrict_indets p) = restrict_indets_pp ` keys p", "also"], ["proof (state)\nthis:\n  keys (restrict_indets p) =\n  keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t))\n\ngoal (1 subgoal):\n 1. keys (restrict_indets p) = restrict_indets_pp ` keys p", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"\\<dots> = (\\<Union>t\\<in>keys p. keys (monomial (lookup p t) (restrict_indets_pp t)))\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t)) =\n    (\\<Union>t\\<in>keys p.\n        keys (monomial (lookup p t) (restrict_indets_pp t)))", "proof (rule keys_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "assume \"s \\<in> keys p\""], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "hence \"keys s \\<subseteq> indets p\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> indets p", "by (rule keys_subset_indets)"], ["proof (state)\nthis:\n  keys s \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "with assms"], ["proof (chain)\npicking this:\n  None \\<notin> indets p\n  keys s \\<subseteq> indets p", "have \"None \\<notin> keys s\""], ["proof (prove)\nusing this:\n  None \\<notin> indets p\n  keys s \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. None \\<notin> keys s", "by blast"], ["proof (state)\nthis:\n  None \\<notin> keys s\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "hence \"keys t \\<subseteq> indets p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> indets p", "by (rule keys_subset_indets)"], ["proof (state)\nthis:\n  keys t \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "with assms"], ["proof (chain)\npicking this:\n  None \\<notin> indets p\n  keys t \\<subseteq> indets p", "have \"None \\<notin> keys t\""], ["proof (prove)\nusing this:\n  None \\<notin> indets p\n  keys t \\<subseteq> indets p\n\ngoal (1 subgoal):\n 1. None \\<notin> keys t", "by blast"], ["proof (state)\nthis:\n  None \\<notin> keys t\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "assume \"s \\<noteq> t\""], ["proof (state)\nthis:\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "then"], ["proof (chain)\npicking this:\n  s \\<noteq> t", "obtain x where neq: \"lookup s x \\<noteq> lookup t x\""], ["proof (prove)\nusing this:\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        lookup s x \\<noteq> lookup t x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson poly_mapping_eqI)"], ["proof (state)\nthis:\n  lookup s x \\<noteq> lookup t x\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "have \"x \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> None", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x = None \\<Longrightarrow> False", "assume \"x = None\""], ["proof (state)\nthis:\n  x = None\n\ngoal (1 subgoal):\n 1. x = None \\<Longrightarrow> False", "with \\<open>None \\<notin> keys s\\<close> and \\<open>None \\<notin> keys t\\<close>"], ["proof (chain)\npicking this:\n  None \\<notin> keys s\n  None \\<notin> keys t\n  x = None", "have \"x \\<notin> keys s\" and \"x \\<notin> keys t\""], ["proof (prove)\nusing this:\n  None \\<notin> keys s\n  None \\<notin> keys t\n  x = None\n\ngoal (1 subgoal):\n 1. x \\<notin> keys s &&& x \\<notin> keys t", "by blast+"], ["proof (state)\nthis:\n  x \\<notin> keys s\n  x \\<notin> keys t\n\ngoal (1 subgoal):\n 1. x = None \\<Longrightarrow> False", "with neq"], ["proof (chain)\npicking this:\n  lookup s x \\<noteq> lookup t x\n  x \\<notin> keys s\n  x \\<notin> keys t", "show False"], ["proof (prove)\nusing this:\n  lookup s x \\<noteq> lookup t x\n  x \\<notin> keys s\n  x \\<notin> keys t\n\ngoal (1 subgoal):\n 1. False", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> None", "obtain y where x: \"x = Some y\""], ["proof (prove)\nusing this:\n  x \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>y. x = Some y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  x = Some y\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "have \"restrict_indets_pp t \\<noteq> restrict_indets_pp s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets_pp t \\<noteq> restrict_indets_pp s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict_indets_pp t = restrict_indets_pp s \\<Longrightarrow> False", "assume \"restrict_indets_pp t = restrict_indets_pp s\""], ["proof (state)\nthis:\n  restrict_indets_pp t = restrict_indets_pp s\n\ngoal (1 subgoal):\n 1. restrict_indets_pp t = restrict_indets_pp s \\<Longrightarrow> False", "hence \"lookup (restrict_indets_pp t) y = lookup (restrict_indets_pp s) y\""], ["proof (prove)\nusing this:\n  restrict_indets_pp t = restrict_indets_pp s\n\ngoal (1 subgoal):\n 1. lookup (restrict_indets_pp t) y = lookup (restrict_indets_pp s) y", "by (simp only:)"], ["proof (state)\nthis:\n  lookup (restrict_indets_pp t) y = lookup (restrict_indets_pp s) y\n\ngoal (1 subgoal):\n 1. restrict_indets_pp t = restrict_indets_pp s \\<Longrightarrow> False", "hence \"lookup s x = lookup t x\""], ["proof (prove)\nusing this:\n  lookup (restrict_indets_pp t) y = lookup (restrict_indets_pp s) y\n\ngoal (1 subgoal):\n 1. lookup s x = lookup t x", "by (simp add: x lookup_restrict_indets_pp)"], ["proof (state)\nthis:\n  lookup s x = lookup t x\n\ngoal (1 subgoal):\n 1. restrict_indets_pp t = restrict_indets_pp s \\<Longrightarrow> False", "with neq"], ["proof (chain)\npicking this:\n  lookup s x \\<noteq> lookup t x\n  lookup s x = lookup t x", "show False"], ["proof (prove)\nusing this:\n  lookup s x \\<noteq> lookup t x\n  lookup s x = lookup t x\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict_indets_pp t \\<noteq> restrict_indets_pp s\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> keys p; a2 \\<in> keys p; a1 \\<noteq> a2\\<rbrakk>\n       \\<Longrightarrow> keys\n                          (monomial (lookup p a1)\n                            (restrict_indets_pp a1)) \\<inter>\n                         keys\n                          (monomial (lookup p a2) (restrict_indets_pp a2)) =\n                         {}", "thus \"keys (monomial (lookup p s) (restrict_indets_pp s)) \\<inter>\n          keys (monomial (lookup p t) (restrict_indets_pp t)) = {}\""], ["proof (prove)\nusing this:\n  restrict_indets_pp t \\<noteq> restrict_indets_pp s\n\ngoal (1 subgoal):\n 1. keys (monomial (lookup p s) (restrict_indets_pp s)) \\<inter>\n    keys (monomial (lookup p t) (restrict_indets_pp t)) =\n    {}", "by (simp add: subst_pp_extend_indets_subst)"], ["proof (state)\nthis:\n  keys (monomial (lookup p s) (restrict_indets_pp s)) \\<inter>\n  keys (monomial (lookup p t) (restrict_indets_pp t)) =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t)) =\n  (\\<Union>t\\<in>keys p.\n      keys (monomial (lookup p t) (restrict_indets_pp t)))\n\ngoal (1 subgoal):\n 1. keys (restrict_indets p) = restrict_indets_pp ` keys p", "also"], ["proof (state)\nthis:\n  keys (\\<Sum>t\\<in>keys p. monomial (lookup p t) (restrict_indets_pp t)) =\n  (\\<Union>t\\<in>keys p.\n      keys (monomial (lookup p t) (restrict_indets_pp t)))\n\ngoal (1 subgoal):\n 1. keys (restrict_indets p) = restrict_indets_pp ` keys p", "have \"\\<dots> = restrict_indets_pp ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>t\\<in>keys p.\n        keys (monomial (lookup p t) (restrict_indets_pp t))) =\n    restrict_indets_pp ` keys p", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  (\\<Union>t\\<in>keys p.\n      keys (monomial (lookup p t) (restrict_indets_pp t))) =\n  restrict_indets_pp ` keys p\n\ngoal (1 subgoal):\n 1. keys (restrict_indets p) = restrict_indets_pp ` keys p", "finally"], ["proof (chain)\npicking this:\n  keys (restrict_indets p) = restrict_indets_pp ` keys p", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (restrict_indets p) = restrict_indets_pp ` keys p\n\ngoal (1 subgoal):\n 1. keys (restrict_indets p) = restrict_indets_pp ` keys p", "."], ["proof (state)\nthis:\n  keys (restrict_indets p) = restrict_indets_pp ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_restrict_indets_subset: \"indets (restrict_indets p) \\<subseteq> the ` (indets p - {None})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (restrict_indets p) \\<subseteq> the ` (indets p - {None})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (restrict_indets p) \\<Longrightarrow>\n       x \\<in> the ` (indets p - {None})", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (restrict_indets p) \\<Longrightarrow>\n       x \\<in> the ` (indets p - {None})", "assume \"x \\<in> indets (restrict_indets p)\""], ["proof (state)\nthis:\n  x \\<in> indets (restrict_indets p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (restrict_indets p) \\<Longrightarrow>\n       x \\<in> the ` (indets p - {None})", "then"], ["proof (chain)\npicking this:\n  x \\<in> indets (restrict_indets p)", "obtain t where \"t \\<in> keys (restrict_indets p)\" and \"x \\<in> keys t\""], ["proof (prove)\nusing this:\n  x \\<in> indets (restrict_indets p)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys (restrict_indets p); x \\<in> keys t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_indetsE)"], ["proof (state)\nthis:\n  t \\<in> keys (restrict_indets p)\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (restrict_indets p) \\<Longrightarrow>\n       x \\<in> the ` (indets p - {None})", "from this(1) keys_restrict_indets_subset"], ["proof (chain)\npicking this:\n  t \\<in> keys (restrict_indets p)\n  keys (restrict_indets ?p) \\<subseteq> restrict_indets_pp ` keys ?p", "have \"t \\<in> restrict_indets_pp ` keys p\""], ["proof (prove)\nusing this:\n  t \\<in> keys (restrict_indets p)\n  keys (restrict_indets ?p) \\<subseteq> restrict_indets_pp ` keys ?p\n\ngoal (1 subgoal):\n 1. t \\<in> restrict_indets_pp ` keys p", ".."], ["proof (state)\nthis:\n  t \\<in> restrict_indets_pp ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (restrict_indets p) \\<Longrightarrow>\n       x \\<in> the ` (indets p - {None})", "then"], ["proof (chain)\npicking this:\n  t \\<in> restrict_indets_pp ` keys p", "obtain s where \"s \\<in> keys p\" and \"t = restrict_indets_pp s\""], ["proof (prove)\nusing this:\n  t \\<in> restrict_indets_pp ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = restrict_indets_pp s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> keys p\n  t = restrict_indets_pp s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (restrict_indets p) \\<Longrightarrow>\n       x \\<in> the ` (indets p - {None})", "from \\<open>x \\<in> keys t\\<close> this(2)"], ["proof (chain)\npicking this:\n  x \\<in> keys t\n  t = restrict_indets_pp s", "have \"x \\<in> the ` (keys s - {None})\""], ["proof (prove)\nusing this:\n  x \\<in> keys t\n  t = restrict_indets_pp s\n\ngoal (1 subgoal):\n 1. x \\<in> the ` (keys s - {None})", "by (simp only: keys_restrict_indets_pp)"], ["proof (state)\nthis:\n  x \\<in> the ` (keys s - {None})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (restrict_indets p) \\<Longrightarrow>\n       x \\<in> the ` (indets p - {None})", "also"], ["proof (state)\nthis:\n  x \\<in> the ` (keys s - {None})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (restrict_indets p) \\<Longrightarrow>\n       x \\<in> the ` (indets p - {None})", "from \\<open>s \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p", "have \"\\<dots> \\<subseteq> the ` (indets p - {None})\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. the ` (keys s - {None}) \\<subseteq> the ` (indets p - {None})", "by (intro image_mono Diff_mono keys_subset_indets subset_refl)"], ["proof (state)\nthis:\n  the ` (keys s - {None}) \\<subseteq> the ` (indets p - {None})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (restrict_indets p) \\<Longrightarrow>\n       x \\<in> the ` (indets p - {None})", "finally"], ["proof (chain)\npicking this:\n  x \\<in> the ` (indets p - {None})", "show \"x \\<in> the ` (indets p - {None})\""], ["proof (prove)\nusing this:\n  x \\<in> the ` (indets p - {None})\n\ngoal (1 subgoal):\n 1. x \\<in> the ` (indets p - {None})", "."], ["proof (state)\nthis:\n  x \\<in> the ` (indets p - {None})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_deg_restrict_indets_le: \"poly_deg (restrict_indets p) \\<le> poly_deg p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (restrict_indets p) \\<le> poly_deg p", "proof (rule poly_deg_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "assume \"t \\<in> keys (restrict_indets p)\""], ["proof (state)\nthis:\n  t \\<in> keys (restrict_indets p)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "hence \"t \\<in> restrict_indets_pp ` keys p\""], ["proof (prove)\nusing this:\n  t \\<in> keys (restrict_indets p)\n\ngoal (1 subgoal):\n 1. t \\<in> restrict_indets_pp ` keys p", "using keys_restrict_indets_subset"], ["proof (prove)\nusing this:\n  t \\<in> keys (restrict_indets p)\n  keys (restrict_indets ?p) \\<subseteq> restrict_indets_pp ` keys ?p\n\ngoal (1 subgoal):\n 1. t \\<in> restrict_indets_pp ` keys p", ".."], ["proof (state)\nthis:\n  t \\<in> restrict_indets_pp ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "then"], ["proof (chain)\npicking this:\n  t \\<in> restrict_indets_pp ` keys p", "obtain s where \"s \\<in> keys p\" and \"t = restrict_indets_pp s\""], ["proof (prove)\nusing this:\n  t \\<in> restrict_indets_pp ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = restrict_indets_pp s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> keys p\n  t = restrict_indets_pp s\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "from this(2)"], ["proof (chain)\npicking this:\n  t = restrict_indets_pp s", "have \"deg_pm t + lookup s None = deg_pm s\""], ["proof (prove)\nusing this:\n  t = restrict_indets_pp s\n\ngoal (1 subgoal):\n 1. deg_pm t + lookup s None = deg_pm s", "by (simp only: deg_pm_restrict_indets_pp)"], ["proof (state)\nthis:\n  deg_pm t + lookup s None = deg_pm s\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "also"], ["proof (state)\nthis:\n  deg_pm t + lookup s None = deg_pm s\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "from \\<open>s \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p", "have \"\\<dots> \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. deg_pm s \\<le> poly_deg p", "by (rule poly_deg_max_keys)"], ["proof (state)\nthis:\n  deg_pm s \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> keys (restrict_indets p) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg p", "finally"], ["proof (chain)\npicking this:\n  deg_pm t + lookup s None \\<le> poly_deg p", "show \"deg_pm t \\<le> poly_deg p\""], ["proof (prove)\nusing this:\n  deg_pm t + lookup s None \\<le> poly_deg p\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg p", "by simp"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  shows restrict_indets_zero [simp]: \"restrict_indets 0 = 0\"\n    and restrict_indets_one [simp]: \"restrict_indets 1 = 1\"\n    and restrict_indets_monomial: \"restrict_indets (monomial c t) = monomial c (restrict_indets_pp t)\"\n    and restrict_indets_plus: \"restrict_indets (p + q) = restrict_indets p + restrict_indets q\"\n    and restrict_indets_uminus: \"restrict_indets (- r) = - restrict_indets (r::_ \\<Rightarrow>\\<^sub>0 _::comm_ring_1)\"\n    and restrict_indets_minus: \"restrict_indets (r - r') = restrict_indets r - restrict_indets r'\"\n    and restrict_indets_times: \"restrict_indets (p * q) = restrict_indets p * restrict_indets q\"\n    and restrict_indets_power: \"restrict_indets (p ^ n) = restrict_indets p ^ n\"\n    and restrict_indets_sum: \"restrict_indets (sum f A) = (\\<Sum>a\\<in>A. restrict_indets (f a))\"\n    and restrict_indets_prod: \"restrict_indets (prod f A) = (\\<Prod>a\\<in>A. restrict_indets (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((restrict_indets 0 = 0 &&& restrict_indets 1 = 1) &&&\n     restrict_indets (monomial c t) = monomial c (restrict_indets_pp t) &&&\n     restrict_indets (p + q) = restrict_indets p + restrict_indets q &&&\n     restrict_indets (- r) = - restrict_indets r) &&&\n    (restrict_indets (r - r') = restrict_indets r - restrict_indets r' &&&\n     restrict_indets (p * q) = restrict_indets p * restrict_indets q) &&&\n    restrict_indets (p ^ n) = restrict_indets p ^ n &&&\n    restrict_indets (sum f A) = (\\<Sum>a\\<in>A. restrict_indets (f a)) &&&\n    restrict_indets (prod f A) = (\\<Prod>a\\<in>A. restrict_indets (f a))", "by (simp_all add: restrict_indets_def poly_subst_monomial poly_subst_plus poly_subst_uminus\n      poly_subst_minus poly_subst_times poly_subst_power poly_subst_sum poly_subst_prod\n      subst_pp_restrict_indets_subst punit.monom_mult_monomial)"], ["", "lemma restrict_extend_indets [simp]: \"restrict_indets (extend_indets p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets (extend_indets p) = p", "unfolding extend_indets_def restrict_indets_def poly_subst_poly_subst"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst\n     (\\<lambda>x.\n         poly_subst (\\<lambda>x. monomial (1::'b) (restrict_indets_subst x))\n          (extend_indets_subst x))\n     p =\n    p", "by (rule poly_subst_id)\n    (simp add: extend_indets_subst_def restrict_indets_subst_def poly_subst_monomial subst_pp_single)"], ["", "lemma extend_restrict_indets:\n  assumes \"None \\<notin> indets p\"\n  shows \"extend_indets (restrict_indets p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_indets (restrict_indets p) = p", "unfolding extend_indets_def restrict_indets_def poly_subst_poly_subst"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst\n     (\\<lambda>x.\n         poly_subst extend_indets_subst\n          (monomial (1::'b) (restrict_indets_subst x)))\n     p =\n    p", "proof (rule poly_subst_id)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow>\n       poly_subst extend_indets_subst\n        (monomial (1::'b) (restrict_indets_subst x)) =\n       monomial (1::'b) (monomial 1 x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow>\n       poly_subst extend_indets_subst\n        (monomial (1::'b) (restrict_indets_subst x)) =\n       monomial (1::'b) (monomial 1 x)", "assume \"x \\<in> indets p\""], ["proof (state)\nthis:\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow>\n       poly_subst extend_indets_subst\n        (monomial (1::'b) (restrict_indets_subst x)) =\n       monomial (1::'b) (monomial 1 x)", "with assms"], ["proof (chain)\npicking this:\n  None \\<notin> indets p\n  x \\<in> indets p", "have \"x \\<noteq> None\""], ["proof (prove)\nusing this:\n  None \\<notin> indets p\n  x \\<in> indets p\n\ngoal (1 subgoal):\n 1. x \\<noteq> None", "by meson"], ["proof (state)\nthis:\n  x \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow>\n       poly_subst extend_indets_subst\n        (monomial (1::'b) (restrict_indets_subst x)) =\n       monomial (1::'b) (monomial 1 x)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> None", "obtain y where x: \"x = Some y\""], ["proof (prove)\nusing this:\n  x \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>y. x = Some y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  x = Some y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets p \\<Longrightarrow>\n       poly_subst extend_indets_subst\n        (monomial (1::'b) (restrict_indets_subst x)) =\n       monomial (1::'b) (monomial 1 x)", "thus \"poly_subst extend_indets_subst (monomial 1 (restrict_indets_subst x)) =\n         monomial 1 (Poly_Mapping.single x 1)\""], ["proof (prove)\nusing this:\n  x = Some y\n\ngoal (1 subgoal):\n 1. poly_subst extend_indets_subst\n     (monomial (1::'c) (restrict_indets_subst x)) =\n    monomial (1::'c) (monomial 1 x)", "by (simp add: extend_indets_subst_def restrict_indets_subst_def poly_subst_monomial subst_pp_single)"], ["proof (state)\nthis:\n  poly_subst extend_indets_subst\n   (monomial (1::?'c1) (restrict_indets_subst x)) =\n  monomial (1::?'c1) (monomial 1 x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict_indets_dehomogenize [simp]: \"restrict_indets (dehomogenize None p) = restrict_indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets (dehomogenize None p) = restrict_indets p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict_indets (dehomogenize None p) = restrict_indets p", "have eq: \"poly_subst (\\<lambda>x. (monomial 1 (restrict_indets_subst x))) (dehomo_subst None y) =\n            monomial 1 (restrict_indets_subst y)\" for y::\"'x option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst (\\<lambda>x. monomial (1::'c) (restrict_indets_subst x))\n     (dehomo_subst None y) =\n    monomial (1::'c) (restrict_indets_subst y)", "by (auto simp: restrict_indets_subst_def dehomo_subst_def poly_subst_monomial subst_pp_single)"], ["proof (state)\nthis:\n  poly_subst (\\<lambda>x. monomial (1::?'c2) (restrict_indets_subst x))\n   (dehomo_subst None ?y1) =\n  monomial (1::?'c2) (restrict_indets_subst ?y1)\n\ngoal (1 subgoal):\n 1. restrict_indets (dehomogenize None p) = restrict_indets p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets (dehomogenize None p) = restrict_indets p", "by (simp only: dehomogenize_def restrict_indets_def poly_subst_poly_subst eq)"], ["proof (state)\nthis:\n  restrict_indets (dehomogenize None p) = restrict_indets p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary restrict_indets_comp_dehomogenize: \"restrict_indets \\<circ> dehomogenize None = restrict_indets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets \\<circ> dehomogenize None = restrict_indets", "by (rule ext) (simp only: o_def restrict_indets_dehomogenize)"], ["", "corollary extend_restrict_indets_eq_dehomogenize:\n  \"extend_indets (restrict_indets p) = dehomogenize None p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_indets (restrict_indets p) = dehomogenize None p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extend_indets (restrict_indets p) = dehomogenize None p", "have \"extend_indets (restrict_indets p) = extend_indets (restrict_indets (dehomogenize None p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_indets (restrict_indets p) =\n    extend_indets (restrict_indets (dehomogenize None p))", "by simp"], ["proof (state)\nthis:\n  extend_indets (restrict_indets p) =\n  extend_indets (restrict_indets (dehomogenize None p))\n\ngoal (1 subgoal):\n 1. extend_indets (restrict_indets p) = dehomogenize None p", "also"], ["proof (state)\nthis:\n  extend_indets (restrict_indets p) =\n  extend_indets (restrict_indets (dehomogenize None p))\n\ngoal (1 subgoal):\n 1. extend_indets (restrict_indets p) = dehomogenize None p", "have \"\\<dots> = dehomogenize None p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_indets (restrict_indets (dehomogenize None p)) =\n    dehomogenize None p", "proof (intro extend_restrict_indets notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. None \\<in> indets (dehomogenize None p) \\<Longrightarrow> False", "assume \"None \\<in> indets (dehomogenize None p)\""], ["proof (state)\nthis:\n  None \\<in> indets (dehomogenize None p)\n\ngoal (1 subgoal):\n 1. None \\<in> indets (dehomogenize None p) \\<Longrightarrow> False", "hence \"None \\<in> indets p - {None}\""], ["proof (prove)\nusing this:\n  None \\<in> indets (dehomogenize None p)\n\ngoal (1 subgoal):\n 1. None \\<in> indets p - {None}", "using indets_dehomogenize"], ["proof (prove)\nusing this:\n  None \\<in> indets (dehomogenize None p)\n  indets (dehomogenize ?x ?p) \\<subseteq> indets ?p - {?x}\n\ngoal (1 subgoal):\n 1. None \\<in> indets p - {None}", ".."], ["proof (state)\nthis:\n  None \\<in> indets p - {None}\n\ngoal (1 subgoal):\n 1. None \\<in> indets (dehomogenize None p) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  None \\<in> indets p - {None}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  extend_indets (restrict_indets (dehomogenize None p)) =\n  dehomogenize None p\n\ngoal (1 subgoal):\n 1. extend_indets (restrict_indets p) = dehomogenize None p", "finally"], ["proof (chain)\npicking this:\n  extend_indets (restrict_indets p) = dehomogenize None p", "show ?thesis"], ["proof (prove)\nusing this:\n  extend_indets (restrict_indets p) = dehomogenize None p\n\ngoal (1 subgoal):\n 1. extend_indets (restrict_indets p) = dehomogenize None p", "."], ["proof (state)\nthis:\n  extend_indets (restrict_indets p) = dehomogenize None p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary extend_indets_comp_restrict_indets: \"extend_indets \\<circ> restrict_indets = dehomogenize None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_indets \\<circ> restrict_indets = dehomogenize None", "by (rule ext) (simp only: o_def extend_restrict_indets_eq_dehomogenize)"], ["", "lemma restrict_homogenize_extend_indets [simp]:\n  \"restrict_indets (homogenize None (extend_indets p)) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets (homogenize None (extend_indets p)) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict_indets (homogenize None (extend_indets p)) = p", "have \"restrict_indets (homogenize None (extend_indets p)) =\n          restrict_indets (dehomogenize None (homogenize None (extend_indets p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets (homogenize None (extend_indets p)) =\n    restrict_indets (dehomogenize None (homogenize None (extend_indets p)))", "by (simp only: restrict_indets_dehomogenize)"], ["proof (state)\nthis:\n  restrict_indets (homogenize None (extend_indets p)) =\n  restrict_indets (dehomogenize None (homogenize None (extend_indets p)))\n\ngoal (1 subgoal):\n 1. restrict_indets (homogenize None (extend_indets p)) = p", "also"], ["proof (state)\nthis:\n  restrict_indets (homogenize None (extend_indets p)) =\n  restrict_indets (dehomogenize None (homogenize None (extend_indets p)))\n\ngoal (1 subgoal):\n 1. restrict_indets (homogenize None (extend_indets p)) = p", "have \"\\<dots> = restrict_indets (dehomogenize None (extend_indets p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets\n     (dehomogenize None (homogenize None (extend_indets p))) =\n    restrict_indets (dehomogenize None (extend_indets p))", "by (simp only: dehomogenize_homogenize)"], ["proof (state)\nthis:\n  restrict_indets (dehomogenize None (homogenize None (extend_indets p))) =\n  restrict_indets (dehomogenize None (extend_indets p))\n\ngoal (1 subgoal):\n 1. restrict_indets (homogenize None (extend_indets p)) = p", "also"], ["proof (state)\nthis:\n  restrict_indets (dehomogenize None (homogenize None (extend_indets p))) =\n  restrict_indets (dehomogenize None (extend_indets p))\n\ngoal (1 subgoal):\n 1. restrict_indets (homogenize None (extend_indets p)) = p", "have \"\\<dots> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets (dehomogenize None (extend_indets p)) = p", "by simp"], ["proof (state)\nthis:\n  restrict_indets (dehomogenize None (extend_indets p)) = p\n\ngoal (1 subgoal):\n 1. restrict_indets (homogenize None (extend_indets p)) = p", "finally"], ["proof (chain)\npicking this:\n  restrict_indets (homogenize None (extend_indets p)) = p", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict_indets (homogenize None (extend_indets p)) = p\n\ngoal (1 subgoal):\n 1. restrict_indets (homogenize None (extend_indets p)) = p", "."], ["proof (state)\nthis:\n  restrict_indets (homogenize None (extend_indets p)) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dehomogenize_extend_indets [simp]: \"dehomogenize None (extend_indets p) = extend_indets p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dehomogenize None (extend_indets p) = extend_indets p", "by (simp add: indets_extend_indets)"], ["", "lemma restrict_indets_ideal: \"restrict_indets ` ideal F = ideal (restrict_indets ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_indets ` ideal F = ideal (restrict_indets ` F)", "using restrict_indets_plus restrict_indets_times"], ["proof (prove)\nusing this:\n  restrict_indets (?p + ?q) = restrict_indets ?p + restrict_indets ?q\n  restrict_indets (?p * ?q) = restrict_indets ?p * restrict_indets ?q\n\ngoal (1 subgoal):\n 1. restrict_indets ` ideal F = ideal (restrict_indets ` F)", "proof (rule image_ideal_eq_surj)"], ["proof (state)\ngoal (1 subgoal):\n 1. surj restrict_indets", "from restrict_extend_indets"], ["proof (chain)\npicking this:\n  restrict_indets (extend_indets ?p) = ?p", "show \"surj restrict_indets\""], ["proof (prove)\nusing this:\n  restrict_indets (extend_indets ?p) = ?p\n\ngoal (1 subgoal):\n 1. surj restrict_indets", "by (rule surjI)"], ["proof (state)\nthis:\n  surj restrict_indets\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ideal_restrict_indets:\n  \"ideal G = ideal (homogenize None ` extend_indets ` F) \\<Longrightarrow> ideal (restrict_indets ` G) = ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal G = ideal (homogenize None ` extend_indets ` F) \\<Longrightarrow>\n    ideal (restrict_indets ` G) = ideal F", "by (simp flip: restrict_indets_ideal) (simp add: restrict_indets_ideal image_image)"], ["", "lemma extend_indets_ideal: \"extend_indets ` ideal F = ideal (extend_indets ` F) \\<inter> P[- {None}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_indets ` ideal F = ideal (extend_indets ` F) \\<inter> P[- {None}]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extend_indets ` ideal F = ideal (extend_indets ` F) \\<inter> P[- {None}]", "have \"extend_indets ` ideal F = extend_indets ` restrict_indets ` ideal (extend_indets ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_indets ` ideal F =\n    extend_indets ` restrict_indets ` ideal (extend_indets ` F)", "by (simp add: restrict_indets_ideal image_image)"], ["proof (state)\nthis:\n  extend_indets ` ideal F =\n  extend_indets ` restrict_indets ` ideal (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. extend_indets ` ideal F = ideal (extend_indets ` F) \\<inter> P[- {None}]", "also"], ["proof (state)\nthis:\n  extend_indets ` ideal F =\n  extend_indets ` restrict_indets ` ideal (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. extend_indets ` ideal F = ideal (extend_indets ` F) \\<inter> P[- {None}]", "have \"\\<dots> = ideal (extend_indets ` F) \\<inter> P[- {None}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_indets ` restrict_indets ` ideal (extend_indets ` F) =\n    ideal (extend_indets ` F) \\<inter> P[- {None}]", "by (simp add: extend_restrict_indets_eq_dehomogenize dehomogenize_ideal image_image)"], ["proof (state)\nthis:\n  extend_indets ` restrict_indets ` ideal (extend_indets ` F) =\n  ideal (extend_indets ` F) \\<inter> P[- {None}]\n\ngoal (1 subgoal):\n 1. extend_indets ` ideal F = ideal (extend_indets ` F) \\<inter> P[- {None}]", "finally"], ["proof (chain)\npicking this:\n  extend_indets ` ideal F = ideal (extend_indets ` F) \\<inter> P[- {None}]", "show ?thesis"], ["proof (prove)\nusing this:\n  extend_indets ` ideal F = ideal (extend_indets ` F) \\<inter> P[- {None}]\n\ngoal (1 subgoal):\n 1. extend_indets ` ideal F = ideal (extend_indets ` F) \\<inter> P[- {None}]", "."], ["proof (state)\nthis:\n  extend_indets ` ideal F = ideal (extend_indets ` F) \\<inter> P[- {None}]\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary extend_indets_ideal_subset: \"extend_indets ` ideal F \\<subseteq> ideal (extend_indets ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_indets ` ideal F \\<subseteq> ideal (extend_indets ` F)", "by (simp add: extend_indets_ideal)"], ["", "subsection \\<open>Canonical Isomorphisms between \\<open>P[X,Y]\\<close> and \\<open>P[X][Y]\\<close>: \\<open>focus\\<close> and \\<open>flatten\\<close>\\<close>"], ["", "definition focus :: \"'x set \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 ('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_monoid_add)\"\n  where \"focus X p = (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) (except t X)) (except t (- X)))\""], ["", "definition flatten :: \"('a \\<Rightarrow>\\<^sub>0 'a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a::comm_powerprod \\<Rightarrow>\\<^sub>0 'b::semiring_1)\"\n  where \"flatten p = (\\<Sum>t\\<in>keys p. punit.monom_mult 1 t (lookup p t))\""], ["", "lemma focus_superset:\n  assumes \"finite A\" and \"keys p \\<subseteq> A\"\n  shows \"focus X p = (\\<Sum>t\\<in>A. monomial (monomial (lookup p t) (except t X)) (except t (- X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X p =\n    (\\<Sum>t\\<in>A.\n       monomial (monomial (lookup p t) (except t X)) (except t (- X)))", "unfolding focus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (monomial (lookup p t) (except t X)) (except t (- X))) =\n    (\\<Sum>t\\<in>A.\n       monomial (monomial (lookup p t) (except t X)) (except t (- X)))", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  keys p \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (monomial (lookup p t) (except t X)) (except t (- X))) =\n    (\\<Sum>t\\<in>A.\n       monomial (monomial (lookup p t) (except t X)) (except t (- X)))", "by (rule sum.mono_neutral_left) (simp add: in_keys_iff)"], ["", "lemma keys_focus: \"keys (focus X p) = (\\<lambda>t. except t (- X)) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (focus X p) = (\\<lambda>t. except t (- X)) ` keys p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (focus X p) \\<subseteq> (\\<lambda>t. except t (- X)) ` keys p\n 2. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "have \"keys (focus X p) \\<subseteq> (\\<Union>t\\<in>keys p. keys (monomial (monomial (lookup p t) (except t X)) (except t (- X))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (focus X p)\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    keys\n                     (monomial (monomial (lookup p t) (except t X))\n                       (except t (- X))))", "unfolding focus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>t\\<in>keys p.\n        monomial (monomial (lookup p t) (except t X)) (except t (- X)))\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    keys\n                     (monomial (monomial (lookup p t) (except t X))\n                       (except t (- X))))", "by (rule keys_sum_subset)"], ["proof (state)\nthis:\n  keys (focus X p)\n  \\<subseteq> (\\<Union>t\\<in>keys p.\n                  keys\n                   (monomial (monomial (lookup p t) (except t X))\n                     (except t (- X))))\n\ngoal (2 subgoals):\n 1. keys (focus X p) \\<subseteq> (\\<lambda>t. except t (- X)) ` keys p\n 2. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "also"], ["proof (state)\nthis:\n  keys (focus X p)\n  \\<subseteq> (\\<Union>t\\<in>keys p.\n                  keys\n                   (monomial (monomial (lookup p t) (except t X))\n                     (except t (- X))))\n\ngoal (2 subgoals):\n 1. keys (focus X p) \\<subseteq> (\\<lambda>t. except t (- X)) ` keys p\n 2. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "have \"\\<dots> \\<subseteq> (\\<Union>t\\<in>keys p. {except t (- X)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>t\\<in>keys p.\n        keys\n         (monomial (monomial (lookup p t) (except t X)) (except t (- X))))\n    \\<subseteq> (\\<Union>t\\<in>keys p. {except t (- X)})", "by (intro UN_mono subset_refl) simp"], ["proof (state)\nthis:\n  (\\<Union>t\\<in>keys p.\n      keys (monomial (monomial (lookup p t) (except t X)) (except t (- X))))\n  \\<subseteq> (\\<Union>t\\<in>keys p. {except t (- X)})\n\ngoal (2 subgoals):\n 1. keys (focus X p) \\<subseteq> (\\<lambda>t. except t (- X)) ` keys p\n 2. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "also"], ["proof (state)\nthis:\n  (\\<Union>t\\<in>keys p.\n      keys (monomial (monomial (lookup p t) (except t X)) (except t (- X))))\n  \\<subseteq> (\\<Union>t\\<in>keys p. {except t (- X)})\n\ngoal (2 subgoals):\n 1. keys (focus X p) \\<subseteq> (\\<lambda>t. except t (- X)) ` keys p\n 2. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "have \"\\<dots> = (\\<lambda>t. except t (- X)) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>t\\<in>keys p. {except t (- X)}) =\n    (\\<lambda>t. except t (- X)) ` keys p", "by (rule UNION_singleton_eq_range)"], ["proof (state)\nthis:\n  (\\<Union>t\\<in>keys p. {except t (- X)}) =\n  (\\<lambda>t. except t (- X)) ` keys p\n\ngoal (2 subgoals):\n 1. keys (focus X p) \\<subseteq> (\\<lambda>t. except t (- X)) ` keys p\n 2. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "finally"], ["proof (chain)\npicking this:\n  keys (focus X p) \\<subseteq> (\\<lambda>t. except t (- X)) ` keys p", "show \"keys (focus X p) \\<subseteq> (\\<lambda>t. except t (- X)) ` keys p\""], ["proof (prove)\nusing this:\n  keys (focus X p) \\<subseteq> (\\<lambda>t. except t (- X)) ` keys p\n\ngoal (1 subgoal):\n 1. keys (focus X p) \\<subseteq> (\\<lambda>t. except t (- X)) ` keys p", "."], ["proof (state)\nthis:\n  keys (focus X p) \\<subseteq> (\\<lambda>t. except t (- X)) ` keys p\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "assume \"s \\<in> keys p\""], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "have \"lookup (focus X p) (except s (- X)) =\n              (\\<Sum>t\\<in>keys p. monomial (lookup p t) (except t X) when except t (- X) = except s (- X))\"\n      (is \"_ = ?p\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (focus X p) (except s (- X)) =\n    (\\<Sum>t\\<in>keys p.\n       monomial (lookup p t) (except t X) when\n       except t (- X) = except s (- X))", "by (simp only: focus_def lookup_sum lookup_single)"], ["proof (state)\nthis:\n  lookup (focus X p) (except s (- X)) =\n  (\\<Sum>t\\<in>keys p.\n     monomial (lookup p t) (except t X) when\n     except t (- X) = except s (- X))\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "also"], ["proof (state)\nthis:\n  lookup (focus X p) (except s (- X)) =\n  (\\<Sum>t\\<in>keys p.\n     monomial (lookup p t) (except t X) when\n     except t (- X) = except s (- X))\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (lookup p t) (except t X) when\n       except t (- X) = except s (- X)) \\<noteq>\n    0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (lookup p t) (except t X) when\n       except t (- X) = except s (- X)) =\n    0 \\<Longrightarrow>\n    False", "have \"lookup ?p (except s X) =\n              (\\<Sum>t\\<in>keys p. lookup p t when except t X = except s X \\<and> except t (- X) = except s (- X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (\\<Sum>t\\<in>keys p.\n        monomial (lookup p t) (except t X) when\n        except t (- X) = except s (- X))\n     (except s X) =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t when\n       except t X = except s X \\<and> except t (- X) = except s (- X))", "by (simp add: lookup_sum lookup_single when_def if_distrib if_distribR)\n            (metis (no_types, hide_lams) lookup_single_eq lookup_single_not_eq lookup_zero)"], ["proof (state)\nthis:\n  lookup\n   (\\<Sum>t\\<in>keys p.\n      monomial (lookup p t) (except t X) when\n      except t (- X) = except s (- X))\n   (except s X) =\n  (\\<Sum>t\\<in>keys p.\n     lookup p t when\n     except t X = except s X \\<and> except t (- X) = except s (- X))\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (lookup p t) (except t X) when\n       except t (- X) = except s (- X)) =\n    0 \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  lookup\n   (\\<Sum>t\\<in>keys p.\n      monomial (lookup p t) (except t X) when\n      except t (- X) = except s (- X))\n   (except s X) =\n  (\\<Sum>t\\<in>keys p.\n     lookup p t when\n     except t X = except s X \\<and> except t (- X) = except s (- X))\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (lookup p t) (except t X) when\n       except t (- X) = except s (- X)) =\n    0 \\<Longrightarrow>\n    False", "have \"\\<dots> = (\\<Sum>t\\<in>{s}. lookup p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       lookup p t when\n       except t X = except s X \\<and> except t (- X) = except s (- X)) =\n    sum (lookup p) {s}", "proof (intro sum.mono_neutral_cong_right ballI)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (keys p)\n 2. {s} \\<subseteq> keys p\n 3. \\<And>i.\n       i \\<in> keys p - {s} \\<Longrightarrow>\n       (lookup p i when\n        except i X = except s X \\<and> except i (- X) = except s (- X)) =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {s} \\<Longrightarrow>\n       (lookup p x when\n        except x X = except s X \\<and> except x (- X) = except s (- X)) =\n       lookup p x", "fix t"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (keys p)\n 2. {s} \\<subseteq> keys p\n 3. \\<And>i.\n       i \\<in> keys p - {s} \\<Longrightarrow>\n       (lookup p i when\n        except i X = except s X \\<and> except i (- X) = except s (- X)) =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {s} \\<Longrightarrow>\n       (lookup p x when\n        except x X = except s X \\<and> except x (- X) = except s (- X)) =\n       lookup p x", "assume \"t \\<in> keys p - {s}\""], ["proof (state)\nthis:\n  t \\<in> keys p - {s}\n\ngoal (4 subgoals):\n 1. finite (keys p)\n 2. {s} \\<subseteq> keys p\n 3. \\<And>i.\n       i \\<in> keys p - {s} \\<Longrightarrow>\n       (lookup p i when\n        except i X = except s X \\<and> except i (- X) = except s (- X)) =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {s} \\<Longrightarrow>\n       (lookup p x when\n        except x X = except s X \\<and> except x (- X) = except s (- X)) =\n       lookup p x", "hence \"t \\<noteq> s\""], ["proof (prove)\nusing this:\n  t \\<in> keys p - {s}\n\ngoal (1 subgoal):\n 1. t \\<noteq> s", "by simp"], ["proof (state)\nthis:\n  t \\<noteq> s\n\ngoal (4 subgoals):\n 1. finite (keys p)\n 2. {s} \\<subseteq> keys p\n 3. \\<And>i.\n       i \\<in> keys p - {s} \\<Longrightarrow>\n       (lookup p i when\n        except i X = except s X \\<and> except i (- X) = except s (- X)) =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {s} \\<Longrightarrow>\n       (lookup p x when\n        except x X = except s X \\<and> except x (- X) = except s (- X)) =\n       lookup p x", "hence \"except t X + except t (- X) \\<noteq> except s X + except s (- X)\""], ["proof (prove)\nusing this:\n  t \\<noteq> s\n\ngoal (1 subgoal):\n 1. except t X + except t (- X) \\<noteq> except s X + except s (- X)", "by (simp flip: except_decomp)"], ["proof (state)\nthis:\n  except t X + except t (- X) \\<noteq> except s X + except s (- X)\n\ngoal (4 subgoals):\n 1. finite (keys p)\n 2. {s} \\<subseteq> keys p\n 3. \\<And>i.\n       i \\<in> keys p - {s} \\<Longrightarrow>\n       (lookup p i when\n        except i X = except s X \\<and> except i (- X) = except s (- X)) =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {s} \\<Longrightarrow>\n       (lookup p x when\n        except x X = except s X \\<and> except x (- X) = except s (- X)) =\n       lookup p x", "thus \"(lookup p t when except t X = except s X \\<and> except t (- X) = except s (- X)) = 0\""], ["proof (prove)\nusing this:\n  except t X + except t (- X) \\<noteq> except s X + except s (- X)\n\ngoal (1 subgoal):\n 1. (lookup p t when\n     except t X = except s X \\<and> except t (- X) = except s (- X)) =\n    (0::'b)", "by (auto simp: when_def)"], ["proof (state)\nthis:\n  (lookup p t when\n   except t X = except s X \\<and> except t (- X) = except s (- X)) =\n  (0::'b)\n\ngoal (3 subgoals):\n 1. finite (keys p)\n 2. {s} \\<subseteq> keys p\n 3. \\<And>x.\n       x \\<in> {s} \\<Longrightarrow>\n       (lookup p x when\n        except x X = except s X \\<and> except x (- X) = except s (- X)) =\n       lookup p x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (keys p)\n 2. {s} \\<subseteq> keys p\n 3. \\<And>x.\n       x \\<in> {s} \\<Longrightarrow>\n       (lookup p x when\n        except x X = except s X \\<and> except x (- X) = except s (- X)) =\n       lookup p x", "from \\<open>s \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p", "show \"{s} \\<subseteq> keys p\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. {s} \\<subseteq> keys p", "by simp"], ["proof (state)\nthis:\n  {s} \\<subseteq> keys p\n\ngoal (2 subgoals):\n 1. finite (keys p)\n 2. \\<And>x.\n       x \\<in> {s} \\<Longrightarrow>\n       (lookup p x when\n        except x X = except s X \\<and> except x (- X) = except s (- X)) =\n       lookup p x", "qed simp_all"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p.\n     lookup p t when\n     except t X = except s X \\<and> except t (- X) = except s (- X)) =\n  sum (lookup p) {s}\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (lookup p t) (except t X) when\n       except t (- X) = except s (- X)) =\n    0 \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p.\n     lookup p t when\n     except t X = except s X \\<and> except t (- X) = except s (- X)) =\n  sum (lookup p) {s}\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (lookup p t) (except t X) when\n       except t (- X) = except s (- X)) =\n    0 \\<Longrightarrow>\n    False", "from \\<open>s \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. sum (lookup p) {s} \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  sum (lookup p) {s} \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (lookup p t) (except t X) when\n       except t (- X) = except s (- X)) =\n    0 \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  lookup\n   (\\<Sum>t\\<in>keys p.\n      monomial (lookup p t) (except t X) when\n      except t (- X) = except s (- X))\n   (except s X) \\<noteq>\n  (0::'b)", "have \"except s X \\<in> keys ?p\""], ["proof (prove)\nusing this:\n  lookup\n   (\\<Sum>t\\<in>keys p.\n      monomial (lookup p t) (except t X) when\n      except t (- X) = except s (- X))\n   (except s X) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. except s X\n    \\<in> keys\n           (\\<Sum>t\\<in>keys p.\n              monomial (lookup p t) (except t X) when\n              except t (- X) = except s (- X))", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  except s X\n  \\<in> keys\n         (\\<Sum>t\\<in>keys p.\n            monomial (lookup p t) (except t X) when\n            except t (- X) = except s (- X))\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (lookup p t) (except t X) when\n       except t (- X) = except s (- X)) =\n    0 \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  except s X\n  \\<in> keys\n         (\\<Sum>t\\<in>keys p.\n            monomial (lookup p t) (except t X) when\n            except t (- X) = except s (- X))\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (lookup p t) (except t X) when\n       except t (- X) = except s (- X)) =\n    0 \\<Longrightarrow>\n    False", "assume \"?p = 0\""], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p.\n     monomial (lookup p t) (except t X) when\n     except t (- X) = except s (- X)) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (lookup p t) (except t X) when\n       except t (- X) = except s (- X)) =\n    0 \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  except s X\n  \\<in> keys\n         (\\<Sum>t\\<in>keys p.\n            monomial (lookup p t) (except t X) when\n            except t (- X) = except s (- X))\n  (\\<Sum>t\\<in>keys p.\n     monomial (lookup p t) (except t X) when\n     except t (- X) = except s (- X)) =\n  0", "show False"], ["proof (prove)\nusing this:\n  except s X\n  \\<in> keys\n         (\\<Sum>t\\<in>keys p.\n            monomial (lookup p t) (except t X) when\n            except t (- X) = except s (- X))\n  (\\<Sum>t\\<in>keys p.\n     monomial (lookup p t) (except t X) when\n     except t (- X) = except s (- X)) =\n  0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p.\n     monomial (lookup p t) (except t X) when\n     except t (- X) = except s (- X)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "finally"], ["proof (chain)\npicking this:\n  lookup (focus X p) (except s (- X)) \\<noteq> 0", "have \"except s (- X) \\<in> keys (focus X p)\""], ["proof (prove)\nusing this:\n  lookup (focus X p) (except s (- X)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. except s (- X) \\<in> keys (focus X p)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  except s (- X) \\<in> keys (focus X p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "}"], ["proof (state)\nthis:\n  ?s2 \\<in> keys p \\<Longrightarrow> except ?s2 (- X) \\<in> keys (focus X p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "thus \"(\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)\""], ["proof (prove)\nusing this:\n  ?s2 \\<in> keys p \\<Longrightarrow> except ?s2 (- X) \\<in> keys (focus X p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>t. except t (- X)) ` keys p \\<subseteq> keys (focus X p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_coeffs_focus_subset:\n  assumes \"c \\<in> range (lookup (focus X p))\"\n  shows \"keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "from assms"], ["proof (chain)\npicking this:\n  c \\<in> range (lookup (focus X p))", "obtain s where \"c = lookup (focus X p) s\""], ["proof (prove)\nusing this:\n  c \\<in> range (lookup (focus X p))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        c = lookup (focus X p) s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  c = lookup (focus X p) s\n\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "hence \"keys c = keys (lookup (focus X p) s)\""], ["proof (prove)\nusing this:\n  c = lookup (focus X p) s\n\ngoal (1 subgoal):\n 1. keys c = keys (lookup (focus X p) s)", "by (simp only:)"], ["proof (state)\nthis:\n  keys c = keys (lookup (focus X p) s)\n\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "also"], ["proof (state)\nthis:\n  keys c = keys (lookup (focus X p) s)\n\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "have \"\\<dots> \\<subseteq> (\\<Union>t\\<in>keys p. keys (lookup (monomial (monomial (lookup p t) (except t X)) (except t (- X))) s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (lookup (focus X p) s)\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    keys\n                     (lookup\n                       (monomial (monomial (lookup p t) (except t X))\n                         (except t (- X)))\n                       s))", "unfolding focus_def lookup_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>x\\<in>keys p.\n        lookup\n         (monomial (monomial (lookup p x) (except x X)) (except x (- X))) s)\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    keys\n                     (lookup\n                       (monomial (monomial (lookup p t) (except t X))\n                         (except t (- X)))\n                       s))", "by (rule keys_sum_subset)"], ["proof (state)\nthis:\n  keys (lookup (focus X p) s)\n  \\<subseteq> (\\<Union>t\\<in>keys p.\n                  keys\n                   (lookup\n                     (monomial (monomial (lookup p t) (except t X))\n                       (except t (- X)))\n                     s))\n\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "also"], ["proof (state)\nthis:\n  keys (lookup (focus X p) s)\n  \\<subseteq> (\\<Union>t\\<in>keys p.\n                  keys\n                   (lookup\n                     (monomial (monomial (lookup p t) (except t X))\n                       (except t (- X)))\n                     s))\n\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "from subset_refl"], ["proof (chain)\npicking this:\n  ?A \\<subseteq> ?A", "have \"\\<dots> \\<subseteq> (\\<Union>t\\<in>keys p. {except t X})\""], ["proof (prove)\nusing this:\n  ?A \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. (\\<Union>t\\<in>keys p.\n        keys\n         (lookup\n           (monomial (monomial (lookup p t) (except t X)) (except t (- X)))\n           s))\n    \\<subseteq> (\\<Union>t\\<in>keys p. {except t X})", "by (rule UN_mono) (simp add: lookup_single when_def)"], ["proof (state)\nthis:\n  (\\<Union>t\\<in>keys p.\n      keys\n       (lookup\n         (monomial (monomial (lookup p t) (except t X)) (except t (- X)))\n         s))\n  \\<subseteq> (\\<Union>t\\<in>keys p. {except t X})\n\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "also"], ["proof (state)\nthis:\n  (\\<Union>t\\<in>keys p.\n      keys\n       (lookup\n         (monomial (monomial (lookup p t) (except t X)) (except t (- X)))\n         s))\n  \\<subseteq> (\\<Union>t\\<in>keys p. {except t X})\n\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "have \"\\<dots> = (\\<lambda>t. except t X) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>t\\<in>keys p. {except t X}) = (\\<lambda>t. except t X) ` keys p", "by (rule UNION_singleton_eq_range)"], ["proof (state)\nthis:\n  (\\<Union>t\\<in>keys p. {except t X}) = (\\<lambda>t. except t X) ` keys p\n\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "finally"], ["proof (chain)\npicking this:\n  keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "show ?thesis"], ["proof (prove)\nusing this:\n  keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p\n\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "."], ["proof (state)\nthis:\n  keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma focus_in_Polys':\n  assumes \"p \\<in> P[Y]\"\n  shows \"focus X p \\<in> P[Y \\<inter> X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X p \\<in> P[Y \\<inter> X]", "proof (intro PolysI subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (focus X p) \\<Longrightarrow> x \\<in> .[Y \\<inter> X]", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (focus X p) \\<Longrightarrow> x \\<in> .[Y \\<inter> X]", "assume \"t \\<in> keys (focus X p)\""], ["proof (state)\nthis:\n  t \\<in> keys (focus X p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (focus X p) \\<Longrightarrow> x \\<in> .[Y \\<inter> X]", "then"], ["proof (chain)\npicking this:\n  t \\<in> keys (focus X p)", "obtain s where \"s \\<in> keys p\" and t: \"t = except s (- X)\""], ["proof (prove)\nusing this:\n  t \\<in> keys (focus X p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = except s (- X)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding keys_focus"], ["proof (prove)\nusing this:\n  t \\<in> (\\<lambda>t. except t (- X)) ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = except s (- X)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> keys p\n  t = except s (- X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (focus X p) \\<Longrightarrow> x \\<in> .[Y \\<inter> X]", "note this(1)"], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (focus X p) \\<Longrightarrow> x \\<in> .[Y \\<inter> X]", "also"], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (focus X p) \\<Longrightarrow> x \\<in> .[Y \\<inter> X]", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[Y]", "have \"keys p \\<subseteq> .[Y]\""], ["proof (prove)\nusing this:\n  p \\<in> P[Y]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[Y]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[Y]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (focus X p) \\<Longrightarrow> x \\<in> .[Y \\<inter> X]", "finally"], ["proof (chain)\npicking this:\n  s \\<in> .[Y]", "have \"keys s \\<subseteq> Y\""], ["proof (prove)\nusing this:\n  s \\<in> .[Y]\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> Y", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys s \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (focus X p) \\<Longrightarrow> x \\<in> .[Y \\<inter> X]", "hence \"keys t \\<subseteq> Y \\<inter> X\""], ["proof (prove)\nusing this:\n  keys s \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> Y \\<inter> X", "by (simp add: t keys_except le_infI1)"], ["proof (state)\nthis:\n  keys t \\<subseteq> Y \\<inter> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (focus X p) \\<Longrightarrow> x \\<in> .[Y \\<inter> X]", "thus \"t \\<in> .[Y \\<inter> X]\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> Y \\<inter> X\n\ngoal (1 subgoal):\n 1. t \\<in> .[Y \\<inter> X]", "by (rule PPsI)"], ["proof (state)\nthis:\n  t \\<in> .[Y \\<inter> X]\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary focus_in_Polys: \"focus X p \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X p \\<in> P[X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. focus X p \\<in> P[X]", "have \"p \\<in> P[UNIV]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P[UNIV]", "by simp"], ["proof (state)\nthis:\n  p \\<in> P[UNIV]\n\ngoal (1 subgoal):\n 1. focus X p \\<in> P[X]", "hence \"focus X p \\<in> P[UNIV \\<inter> X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[UNIV]\n\ngoal (1 subgoal):\n 1. focus X p \\<in> P[UNIV \\<inter> X]", "by (rule focus_in_Polys')"], ["proof (state)\nthis:\n  focus X p \\<in> P[UNIV \\<inter> X]\n\ngoal (1 subgoal):\n 1. focus X p \\<in> P[X]", "thus ?thesis"], ["proof (prove)\nusing this:\n  focus X p \\<in> P[UNIV \\<inter> X]\n\ngoal (1 subgoal):\n 1. focus X p \\<in> P[X]", "by simp"], ["proof (state)\nthis:\n  focus X p \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma focus_coeffs_subset_Polys':\n  assumes \"p \\<in> P[Y]\"\n  shows \"range (lookup (focus X p)) \\<subseteq> P[Y - X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (lookup (focus X p)) \\<subseteq> P[Y - X]", "proof (intro subsetI PolysI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "fix c t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "assume \"c \\<in> range (lookup (focus X p))\""], ["proof (state)\nthis:\n  c \\<in> range (lookup (focus X p))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "hence \"keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p\""], ["proof (prove)\nusing this:\n  c \\<in> range (lookup (focus X p))\n\ngoal (1 subgoal):\n 1. keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p", "by (rule keys_coeffs_focus_subset)"], ["proof (state)\nthis:\n  keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "moreover"], ["proof (state)\nthis:\n  keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "assume \"t \\<in> keys c\""], ["proof (state)\nthis:\n  t \\<in> keys c\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "ultimately"], ["proof (chain)\npicking this:\n  keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p\n  t \\<in> keys c", "have \"t \\<in> (\\<lambda>t. except t X) ` keys p\""], ["proof (prove)\nusing this:\n  keys c \\<subseteq> (\\<lambda>t. except t X) ` keys p\n  t \\<in> keys c\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<lambda>t. except t X) ` keys p", ".."], ["proof (state)\nthis:\n  t \\<in> (\\<lambda>t. except t X) ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "then"], ["proof (chain)\npicking this:\n  t \\<in> (\\<lambda>t. except t X) ` keys p", "obtain s where \"s \\<in> keys p\" and t: \"t = except s X\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<lambda>t. except t X) ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t = except s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> keys p\n  t = except s X\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "note this(1)"], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "also"], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[Y]", "have \"keys p \\<subseteq> .[Y]\""], ["proof (prove)\nusing this:\n  p \\<in> P[Y]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[Y]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[Y]\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "finally"], ["proof (chain)\npicking this:\n  s \\<in> .[Y]", "have \"keys s \\<subseteq> Y\""], ["proof (prove)\nusing this:\n  s \\<in> .[Y]\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> Y", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys s \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "hence \"keys t \\<subseteq> Y - X\""], ["proof (prove)\nusing this:\n  keys s \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> Y - X", "by (simp add: t keys_except Diff_mono)"], ["proof (state)\nthis:\n  keys t \\<subseteq> Y - X\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> range (lookup (focus X p)); xa \\<in> keys x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> .[Y - X]", "thus \"t \\<in> .[Y - X]\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> Y - X\n\ngoal (1 subgoal):\n 1. t \\<in> .[Y - X]", "by (rule PPsI)"], ["proof (state)\nthis:\n  t \\<in> .[Y - X]\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary focus_coeffs_subset_Polys: \"range (lookup (focus X p)) \\<subseteq> P[- X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (lookup (focus X p)) \\<subseteq> P[- X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. range (lookup (focus X p)) \\<subseteq> P[- X]", "have \"p \\<in> P[UNIV]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P[UNIV]", "by simp"], ["proof (state)\nthis:\n  p \\<in> P[UNIV]\n\ngoal (1 subgoal):\n 1. range (lookup (focus X p)) \\<subseteq> P[- X]", "hence \"range (lookup (focus X p)) \\<subseteq> P[UNIV - X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[UNIV]\n\ngoal (1 subgoal):\n 1. range (lookup (focus X p)) \\<subseteq> P[UNIV - X]", "by (rule focus_coeffs_subset_Polys')"], ["proof (state)\nthis:\n  range (lookup (focus X p)) \\<subseteq> P[UNIV - X]\n\ngoal (1 subgoal):\n 1. range (lookup (focus X p)) \\<subseteq> P[- X]", "thus ?thesis"], ["proof (prove)\nusing this:\n  range (lookup (focus X p)) \\<subseteq> P[UNIV - X]\n\ngoal (1 subgoal):\n 1. range (lookup (focus X p)) \\<subseteq> P[- X]", "by (simp only: Compl_eq_Diff_UNIV)"], ["proof (state)\nthis:\n  range (lookup (focus X p)) \\<subseteq> P[- X]\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lookup_focus_in_Polys: \"lookup (focus X p) t \\<in> P[- X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (focus X p) t \\<in> P[- X]", "using focus_coeffs_subset_Polys"], ["proof (prove)\nusing this:\n  range (lookup (focus ?X ?p)) \\<subseteq> P[- ?X]\n\ngoal (1 subgoal):\n 1. lookup (focus X p) t \\<in> P[- X]", "by blast"], ["", "lemma focus_zero [simp]: \"focus X 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X 0 = 0", "by (simp add: focus_def)"], ["", "lemma focus_eq_zero_iff [iff]: \"focus X p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (focus X p = 0) = (p = 0)", "by (simp only: keys_focus flip: keys_eq_empty_iff) simp"], ["", "lemma focus_one [simp]: \"focus X 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X 1 = 1", "by (simp add: focus_def)"], ["", "lemma focus_monomial: \"focus X (monomial c t) = monomial (monomial c (except t X)) (except t (- X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (monomial c t) =\n    monomial (monomial c (except t X)) (except t (- X))", "by (simp add: focus_def)"], ["", "lemma focus_uminus [simp]: \"focus X (- p) = - focus X p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (- p) = - focus X p", "by (simp add: focus_def keys_uminus single_uminus sum_negf)"], ["", "lemma focus_plus: \"focus X (p + q) = focus X p + focus X q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (p + q) = focus X p + focus X q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. focus X (p + q) = focus X p + focus X q", "have \"finite (keys p \\<union> keys q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (keys p \\<union> keys q)", "by simp"], ["proof (state)\nthis:\n  finite (keys p \\<union> keys q)\n\ngoal (1 subgoal):\n 1. focus X (p + q) = focus X p + focus X q", "moreover"], ["proof (state)\nthis:\n  finite (keys p \\<union> keys q)\n\ngoal (1 subgoal):\n 1. focus X (p + q) = focus X p + focus X q", "have \"keys (p + q) \\<subseteq> keys p \\<union> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p + q) \\<subseteq> keys p \\<union> keys q", "by (rule Poly_Mapping.keys_add)"], ["proof (state)\nthis:\n  keys (p + q) \\<subseteq> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. focus X (p + q) = focus X p + focus X q", "ultimately"], ["proof (chain)\npicking this:\n  finite (keys p \\<union> keys q)\n  keys (p + q) \\<subseteq> keys p \\<union> keys q", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (keys p \\<union> keys q)\n  keys (p + q) \\<subseteq> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. focus X (p + q) = focus X p + focus X q", "by (simp add: focus_superset[where A=\"keys p \\<union> keys q\"] lookup_add single_add sum.distrib)"], ["proof (state)\nthis:\n  focus X (p + q) = focus X p + focus X q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma focus_minus: \"focus X (p - q) = focus X p - focus X (q::_ \\<Rightarrow>\\<^sub>0 _::ab_group_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (p - q) = focus X p - focus X q", "by (simp only: diff_conv_add_uminus focus_plus focus_uminus)"], ["", "lemma focus_times: \"focus X (p * q) = focus X p * focus X q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (p * q) = focus X p * focus X q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. focus X (p * q) = focus X p * focus X q", "have eq: \"focus X (monomial c s * q) = focus X (monomial c s) * focus X q\" for c s"], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "have \"focus X (monomial c s * q) = focus X (punit.monom_mult c s q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (punit.monom_mult c s q)", "by (simp only: times_monomial_left)"], ["proof (state)\nthis:\n  focus X (monomial c s * q) = focus X (punit.monom_mult c s q)\n\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "also"], ["proof (state)\nthis:\n  focus X (monomial c s * q) = focus X (punit.monom_mult c s q)\n\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "have \"\\<dots> = (\\<Sum>t\\<in>(+) s ` keys q. monomial (monomial (lookup (punit.monom_mult c s q) t)\n                                            (except t X)) (except t (- X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (punit.monom_mult c s q) =\n    (\\<Sum>t\\<in>(+) s ` keys q.\n       monomial (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n        (except t (- X)))", "by (rule focus_superset) (simp_all add: punit.keys_monom_mult_subset[simplified])"], ["proof (state)\nthis:\n  focus X (punit.monom_mult c s q) =\n  (\\<Sum>t\\<in>(+) s ` keys q.\n     monomial (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n      (except t (- X)))\n\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "also"], ["proof (state)\nthis:\n  focus X (punit.monom_mult c s q) =\n  (\\<Sum>t\\<in>(+) s ` keys q.\n     monomial (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n      (except t (- X)))\n\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "have \"\\<dots> = (\\<Sum>t\\<in>keys q. ((\\<lambda>t. monomial (monomial (lookup (punit.monom_mult c s q) t)\n                                  (except t X)) (except t (- X))) \\<circ> ((+) s)) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>(+) s ` keys q.\n       monomial (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n        (except t (- X))) =\n    sum ((\\<lambda>t.\n             monomial\n              (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n              (except t (- X))) \\<circ>\n         (+) s)\n     (keys q)", "by (rule sum.reindex) simp"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>(+) s ` keys q.\n     monomial (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n      (except t (- X))) =\n  sum ((\\<lambda>t.\n           monomial\n            (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n            (except t (- X))) \\<circ>\n       (+) s)\n   (keys q)\n\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>(+) s ` keys q.\n     monomial (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n      (except t (- X))) =\n  sum ((\\<lambda>t.\n           monomial\n            (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n            (except t (- X))) \\<circ>\n       (+) s)\n   (keys q)\n\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "have \"\\<dots> = monomial (monomial c (except s X)) (except s (- X)) *\n                      (\\<Sum>t\\<in>keys q. monomial (monomial (lookup q t) (except t X)) (except t (- X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>t.\n             monomial\n              (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n              (except t (- X))) \\<circ>\n         (+) s)\n     (keys q) =\n    monomial (monomial c (except s X)) (except s (- X)) *\n    (\\<Sum>t\\<in>keys q.\n       monomial (monomial (lookup q t) (except t X)) (except t (- X)))", "by (simp add: o_def punit.lookup_monom_mult except_plus times_monomial_monomial sum_distrib_left)"], ["proof (state)\nthis:\n  sum ((\\<lambda>t.\n           monomial\n            (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n            (except t (- X))) \\<circ>\n       (+) s)\n   (keys q) =\n  monomial (monomial c (except s X)) (except s (- X)) *\n  (\\<Sum>t\\<in>keys q.\n     monomial (monomial (lookup q t) (except t X)) (except t (- X)))\n\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>t.\n           monomial\n            (monomial (lookup (punit.monom_mult c s q) t) (except t X))\n            (except t (- X))) \\<circ>\n       (+) s)\n   (keys q) =\n  monomial (monomial c (except s X)) (except s (- X)) *\n  (\\<Sum>t\\<in>keys q.\n     monomial (monomial (lookup q t) (except t X)) (except t (- X)))\n\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "have \"\\<dots> = focus X (monomial c s) * focus X q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (monomial c (except s X)) (except s (- X)) *\n    (\\<Sum>t\\<in>keys q.\n       monomial (monomial (lookup q t) (except t X)) (except t (- X))) =\n    focus X (monomial c s) * focus X q", "by (simp only: focus_monomial focus_def[where p=q])"], ["proof (state)\nthis:\n  monomial (monomial c (except s X)) (except s (- X)) *\n  (\\<Sum>t\\<in>keys q.\n     monomial (monomial (lookup q t) (except t X)) (except t (- X))) =\n  focus X (monomial c s) * focus X q\n\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "finally"], ["proof (chain)\npicking this:\n  focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "show ?thesis"], ["proof (prove)\nusing this:\n  focus X (monomial c s * q) = focus X (monomial c s) * focus X q\n\ngoal (1 subgoal):\n 1. focus X (monomial c s * q) = focus X (monomial c s) * focus X q", "."], ["proof (state)\nthis:\n  focus X (monomial c s * q) = focus X (monomial c s) * focus X q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  focus X (monomial ?c ?s * q) = focus X (monomial ?c ?s) * focus X q\n\ngoal (1 subgoal):\n 1. focus X (p * q) = focus X p * focus X q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (p * q) = focus X p * focus X q", "by (induct p rule: poly_mapping_plus_induct) (simp_all add: ring_distribs focus_plus eq)"], ["proof (state)\nthis:\n  focus X (p * q) = focus X p * focus X q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma focus_sum: \"focus X (sum f I) = (\\<Sum>i\\<in>I. focus X (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (sum f I) = (\\<Sum>i\\<in>I. focus X (f i))", "by (induct I rule: infinite_finite_induct) (simp_all add: focus_plus)"], ["", "lemma focus_prod: \"focus X (prod f I) = (\\<Prod>i\\<in>I. focus X (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (prod f I) = (\\<Prod>i\\<in>I. focus X (f i))", "by (induct I rule: infinite_finite_induct) (simp_all add: focus_times)"], ["", "lemma focus_power [simp]: \"focus X (f ^ m) = focus X f ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (f ^ m) = focus X f ^ m", "by (induct m) (simp_all add: focus_times)"], ["", "lemma focus_Polys:\n  assumes \"p \\<in> P[X]\"\n  shows \"focus X p = (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) 0) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X p = (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) 0) t)", "unfolding focus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (monomial (lookup p t) (except t X)) (except t (- X))) =\n    (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) 0) t)", "proof (rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) 0) x", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) 0) x", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) 0) x", "also"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) 0) x", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[X]", "have \"\\<dots> \\<subseteq> .[X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[X]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[X]\n\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) 0) x", "finally"], ["proof (chain)\npicking this:\n  t \\<in> .[X]", "have \"keys t \\<subseteq> X\""], ["proof (prove)\nusing this:\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> X", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys t \\<subseteq> X\n\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) 0) x", "hence \"except t X = 0\" and \"except t (- X) = t\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> X\n\ngoal (1 subgoal):\n 1. except t X = 0 &&& except t (- X) = t", "by (rule except_eq_zeroI, auto simp: except_id_iff)"], ["proof (state)\nthis:\n  except t X = 0\n  except t (- X) = t\n\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) 0) x", "thus \"monomial (monomial (lookup p t) (except t X)) (except t (- X)) =\n        monomial (monomial (lookup p t) 0) t\""], ["proof (prove)\nusing this:\n  except t X = 0\n  except t (- X) = t\n\ngoal (1 subgoal):\n 1. monomial (monomial (lookup p t) (except t X)) (except t (- X)) =\n    monomial (monomial (lookup p t) 0) t", "by simp"], ["proof (state)\nthis:\n  monomial (monomial (lookup p t) (except t X)) (except t (- X)) =\n  monomial (monomial (lookup p t) 0) t\n\ngoal (1 subgoal):\n 1. keys p = keys p", "qed (fact refl)"], ["", "corollary lookup_focus_Polys: \"p \\<in> P[X] \\<Longrightarrow> lookup (focus X p) t = monomial (lookup p t) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<Longrightarrow>\n    lookup (focus X p) t = monomial (lookup p t) 0", "by (simp add: focus_Polys lookup_sum lookup_single when_def in_keys_iff)"], ["", "lemma focus_Polys_Compl:\n  assumes \"p \\<in> P[- X]\"\n  shows \"focus X p = monomial p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X p = monomial p 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. focus X p = monomial p 0", "have \"focus X p = (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) t) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X p = (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) t) 0)", "unfolding focus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (monomial (lookup p t) (except t X)) (except t (- X))) =\n    (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) t) 0)", "proof (rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) x) 0", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) x) 0", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) x) 0", "also"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) x) 0", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[- X]", "have \"\\<dots> \\<subseteq> .[- X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[- X]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[- X]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[- X]\n\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) x) 0", "finally"], ["proof (chain)\npicking this:\n  t \\<in> .[- X]", "have \"keys t \\<subseteq> - X\""], ["proof (prove)\nusing this:\n  t \\<in> .[- X]\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> - X", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys t \\<subseteq> - X\n\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) x) 0", "hence \"except t (- X) = 0\" and \"except t X = t\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> - X\n\ngoal (1 subgoal):\n 1. except t (- X) = 0 &&& except t X = t", "by (rule except_eq_zeroI, auto simp: except_id_iff)"], ["proof (state)\nthis:\n  except t (- X) = 0\n  except t X = t\n\ngoal (2 subgoals):\n 1. keys p = keys p\n 2. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x X)) (except x (- X)) =\n       monomial (monomial (lookup p x) x) 0", "thus \"monomial (monomial (lookup p t) (except t X)) (except t (- X)) =\n          monomial (monomial (lookup p t) t) 0\""], ["proof (prove)\nusing this:\n  except t (- X) = 0\n  except t X = t\n\ngoal (1 subgoal):\n 1. monomial (monomial (lookup p t) (except t X)) (except t (- X)) =\n    monomial (monomial (lookup p t) t) 0", "by simp"], ["proof (state)\nthis:\n  monomial (monomial (lookup p t) (except t X)) (except t (- X)) =\n  monomial (monomial (lookup p t) t) 0\n\ngoal (1 subgoal):\n 1. keys p = keys p", "qed (fact refl)"], ["proof (state)\nthis:\n  focus X p = (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) t) 0)\n\ngoal (1 subgoal):\n 1. focus X p = monomial p 0", "also"], ["proof (state)\nthis:\n  focus X p = (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) t) 0)\n\ngoal (1 subgoal):\n 1. focus X p = monomial p 0", "have \"\\<dots> = monomial (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) t) 0) =\n    monomial (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) 0", "by (simp only: monomial_sum)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) t) 0) =\n  monomial (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) 0\n\ngoal (1 subgoal):\n 1. focus X p = monomial p 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p. monomial (monomial (lookup p t) t) 0) =\n  monomial (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) 0\n\ngoal (1 subgoal):\n 1. focus X p = monomial p 0", "have \"\\<dots> = monomial p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) 0 = monomial p 0", "by (simp only: poly_mapping_sum_monomials)"], ["proof (state)\nthis:\n  monomial (\\<Sum>t\\<in>keys p. monomial (lookup p t) t) 0 = monomial p 0\n\ngoal (1 subgoal):\n 1. focus X p = monomial p 0", "finally"], ["proof (chain)\npicking this:\n  focus X p = monomial p 0", "show ?thesis"], ["proof (prove)\nusing this:\n  focus X p = monomial p 0\n\ngoal (1 subgoal):\n 1. focus X p = monomial p 0", "."], ["proof (state)\nthis:\n  focus X p = monomial p 0\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary focus_empty [simp]: \"focus {} p = monomial p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus {} p = monomial p 0", "by (rule focus_Polys_Compl) simp"], ["", "lemma focus_Int:\n  assumes \"p \\<in> P[Y]\"\n  shows \"focus (X \\<inter> Y) p = focus X p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus (X \\<inter> Y) p = focus X p", "unfolding focus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (monomial (lookup p t) (except t (X \\<inter> Y)))\n        (except t (- (X \\<inter> Y)))) =\n    (\\<Sum>t\\<in>keys p.\n       monomial (monomial (lookup p t) (except t X)) (except t (- X)))", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       monomial (monomial (lookup p t) (except t (X \\<inter> Y)))\n        (except t (- (X \\<inter> Y)))) =\n    (\\<Sum>t\\<in>keys p.\n       monomial (monomial (lookup p t) (except t X)) (except t (- X)))", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "also"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[Y]", "have \"\\<dots> \\<subseteq> .[Y]\""], ["proof (prove)\nusing this:\n  p \\<in> P[Y]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[Y]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[Y]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "finally"], ["proof (chain)\npicking this:\n  t \\<in> .[Y]", "have \"keys t \\<subseteq> Y\""], ["proof (prove)\nusing this:\n  t \\<in> .[Y]\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> Y", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys t \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "hence \"keys t \\<subseteq> X \\<union> Y\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> X \\<union> Y", "by blast"], ["proof (state)\nthis:\n  keys t \\<subseteq> X \\<union> Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "hence \"except t (X \\<inter> Y) = except t X + except t Y\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> X \\<union> Y\n\ngoal (1 subgoal):\n 1. except t (X \\<inter> Y) = except t X + except t Y", "by (rule except_Int)"], ["proof (state)\nthis:\n  except t (X \\<inter> Y) = except t X + except t Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "also"], ["proof (state)\nthis:\n  except t (X \\<inter> Y) = except t X + except t Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "from \\<open>keys t \\<subseteq> Y\\<close>"], ["proof (chain)\npicking this:\n  keys t \\<subseteq> Y", "have \"except t Y = 0\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. except t Y = 0", "by (rule except_eq_zeroI)"], ["proof (state)\nthis:\n  except t Y = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "finally"], ["proof (chain)\npicking this:\n  except t (X \\<inter> Y) = except t X + 0", "have eq: \"except t (X \\<inter> Y) = except t X\""], ["proof (prove)\nusing this:\n  except t (X \\<inter> Y) = except t X + 0\n\ngoal (1 subgoal):\n 1. except t (X \\<inter> Y) = except t X", "by simp"], ["proof (state)\nthis:\n  except t (X \\<inter> Y) = except t X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "have \"except t (- (X \\<inter> Y)) = except (except t (- Y)) (- X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. except t (- (X \\<inter> Y)) = except (except t (- Y)) (- X)", "by (simp add: except_except Un_commute)"], ["proof (state)\nthis:\n  except t (- (X \\<inter> Y)) = except (except t (- Y)) (- X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "also"], ["proof (state)\nthis:\n  except t (- (X \\<inter> Y)) = except (except t (- Y)) (- X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "from \\<open>keys t \\<subseteq> Y\\<close>"], ["proof (chain)\npicking this:\n  keys t \\<subseteq> Y", "have \"except t (- Y) = t\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. except t (- Y) = t", "by (auto simp: except_id_iff)"], ["proof (state)\nthis:\n  except t (- Y) = t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial (monomial (lookup p x) (except x (X \\<inter> Y)))\n        (except x (- (X \\<inter> Y))) =\n       monomial (monomial (lookup p x) (except x X)) (except x (- X))", "finally"], ["proof (chain)\npicking this:\n  except t (- (X \\<inter> Y)) = except t (- X)", "show \"monomial (monomial (lookup p t) (except t (X \\<inter> Y))) (except t (- (X \\<inter> Y))) =\n                monomial (monomial (lookup p t) (except t X)) (except t (- X))\""], ["proof (prove)\nusing this:\n  except t (- (X \\<inter> Y)) = except t (- X)\n\ngoal (1 subgoal):\n 1. monomial (monomial (lookup p t) (except t (X \\<inter> Y)))\n     (except t (- (X \\<inter> Y))) =\n    monomial (monomial (lookup p t) (except t X)) (except t (- X))", "by (simp only: eq)"], ["proof (state)\nthis:\n  monomial (monomial (lookup p t) (except t (X \\<inter> Y)))\n   (except t (- (X \\<inter> Y))) =\n  monomial (monomial (lookup p t) (except t X)) (except t (- X))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma range_focusD:\n  assumes \"p \\<in> range (focus X)\"\n  shows \"p \\<in> P[X]\" and \"range (lookup p) \\<subseteq> P[- X]\" and \"lookup p t \\<in> P[- X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P[X] &&&\n    range (lookup p) \\<subseteq> P[- X] &&& lookup p t \\<in> P[- X]", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> range (focus X)\n\ngoal (1 subgoal):\n 1. p \\<in> P[X] &&&\n    range (lookup p) \\<subseteq> P[- X] &&& lookup p t \\<in> P[- X]", "by (auto intro: focus_in_Polys lookup_focus_in_Polys)"], ["", "lemma range_focusI:\n  assumes \"p \\<in> P[X]\" and \"lookup p ` keys (p::_ \\<Rightarrow>\\<^sub>0 _ \\<Rightarrow>\\<^sub>0 _::semiring_1) \\<subseteq> P[- X]\"\n  shows \"p \\<in> range (focus X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> range (focus X)", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n  lookup p ` keys p \\<subseteq> P[- X]\n\ngoal (1 subgoal):\n 1. p \\<in> range (focus X)", "proof (induct p rule: poly_mapping_plus_induct_Polys)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup 0 ` keys 0 \\<subseteq> P[- X] \\<Longrightarrow>\n    0 \\<in> range (focus X)\n 2. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "case 0"], ["proof (state)\nthis:\n  lookup 0 ` keys 0 \\<subseteq> P[- X]\n\ngoal (2 subgoals):\n 1. lookup 0 ` keys 0 \\<subseteq> P[- X] \\<Longrightarrow>\n    0 \\<in> range (focus X)\n 2. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> range (focus X)", "by simp"], ["proof (state)\nthis:\n  0 \\<in> range (focus X)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "case (plus p c t)"], ["proof (state)\nthis:\n  t \\<in> .[X]\n  p \\<in> P[X]\n  c \\<noteq> 0\n  t \\<notin> keys p\n  lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n  p \\<in> range (focus X)\n  lookup (monomial c t + p) ` keys (monomial c t + p) \\<subseteq> P[- X]\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "from plus.hyps(3)"], ["proof (chain)\npicking this:\n  c \\<noteq> 0", "have 1: \"keys (monomial c t) = {t}\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys (monomial c t) = {t}", "by simp"], ["proof (state)\nthis:\n  keys (monomial c t) = {t}\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "also"], ["proof (state)\nthis:\n  keys (monomial c t) = {t}\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "from plus.hyps(4)"], ["proof (chain)\npicking this:\n  t \\<notin> keys p", "have \"\\<dots> \\<inter> keys p = {}\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. {t} \\<inter> keys p = {}", "by simp"], ["proof (state)\nthis:\n  {t} \\<inter> keys p = {}\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "finally"], ["proof (chain)\npicking this:\n  keys (monomial c t) \\<inter> keys p = {}", "have \"keys (monomial c t + p) = keys (monomial c t) \\<union> keys p\""], ["proof (prove)\nusing this:\n  keys (monomial c t) \\<inter> keys p = {}\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = keys (monomial c t) \\<union> keys p", "by (rule keys_add[symmetric])"], ["proof (state)\nthis:\n  keys (monomial c t + p) = keys (monomial c t) \\<union> keys p\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "hence 2: \"keys (monomial c t + p) = insert t (keys p)\""], ["proof (prove)\nusing this:\n  keys (monomial c t + p) = keys (monomial c t) \\<union> keys p\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = insert t (keys p)", "by (simp only: 1 flip: insert_is_Un)"], ["proof (state)\nthis:\n  keys (monomial c t + p) = insert t (keys p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "from \\<open>t \\<in> .[X]\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> .[X]", "have \"keys t \\<subseteq> X\""], ["proof (prove)\nusing this:\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> X", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys t \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "hence eq1: \"except t X = 0\" and eq2: \"except t (- X) = t\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> X\n\ngoal (1 subgoal):\n 1. except t X = 0 &&& except t (- X) = t", "by (rule except_eq_zeroI, auto simp: except_id_iff)"], ["proof (state)\nthis:\n  except t X = 0\n  except t (- X) = t\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "from plus.hyps(3, 4) plus.prems"], ["proof (chain)\npicking this:\n  c \\<noteq> 0\n  t \\<notin> keys p\n  lookup (monomial c t + p) ` keys (monomial c t + p) \\<subseteq> P[- X]", "have \"c \\<in> P[- X]\" and \"lookup p ` keys p \\<subseteq> P[- X]\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  t \\<notin> keys p\n  lookup (monomial c t + p) ` keys (monomial c t + p) \\<subseteq> P[- X]\n\ngoal (1 subgoal):\n 1. c \\<in> P[- X] &&& lookup p ` keys p \\<subseteq> P[- X]", "by (simp_all add: 2 lookup_add lookup_single in_keys_iff)\n        (smt add.commute add.right_neutral image_cong plus.hyps(4) when_simps(2))"], ["proof (state)\nthis:\n  c \\<in> P[- X]\n  lookup p ` keys p \\<subseteq> P[- X]\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "from this(2)"], ["proof (chain)\npicking this:\n  lookup p ` keys p \\<subseteq> P[- X]", "have \"p \\<in> range (focus X)\""], ["proof (prove)\nusing this:\n  lookup p ` keys p \\<subseteq> P[- X]\n\ngoal (1 subgoal):\n 1. p \\<in> range (focus X)", "by (rule plus.hyps)"], ["proof (state)\nthis:\n  p \\<in> range (focus X)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "then"], ["proof (chain)\npicking this:\n  p \\<in> range (focus X)", "obtain q where p: \"p = focus X q\""], ["proof (prove)\nusing this:\n  p \\<in> range (focus X)\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = focus X q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p = focus X q\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "moreover"], ["proof (state)\nthis:\n  p = focus X q\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "from \\<open>c \\<in> P[- X]\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> P[- X]", "have \"monomial c t = focus X (monomial 1 t * c)\""], ["proof (prove)\nusing this:\n  c \\<in> P[- X]\n\ngoal (1 subgoal):\n 1. monomial c t = focus X (monomial (1::'b) t * c)", "by (simp add: focus_times focus_monomial eq1 eq2 focus_Polys_Compl times_monomial_monomial)"], ["proof (state)\nthis:\n  monomial c t = focus X (monomial (1::'b) t * c)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "ultimately"], ["proof (chain)\npicking this:\n  p = focus X q\n  monomial c t = focus X (monomial (1::'b) t * c)", "have \"monomial c t + p = focus X (monomial 1 t * c + q)\""], ["proof (prove)\nusing this:\n  p = focus X q\n  monomial c t = focus X (monomial (1::'b) t * c)\n\ngoal (1 subgoal):\n 1. monomial c t + p = focus X (monomial (1::'b) t * c + q)", "by (simp only: focus_plus)"], ["proof (state)\nthis:\n  monomial c t + p = focus X (monomial (1::'b) t * c + q)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>t \\<in> .[X]; p \\<in> P[X]; c \\<noteq> 0; t \\<notin> keys p;\n        lookup p ` keys p \\<subseteq> P[- X] \\<Longrightarrow>\n        p \\<in> range (focus X);\n        lookup (monomial c t + p) ` keys (monomial c t + p)\n        \\<subseteq> P[- X]\\<rbrakk>\n       \\<Longrightarrow> monomial c t + p \\<in> range (focus X)", "thus ?case"], ["proof (prove)\nusing this:\n  monomial c t + p = focus X (monomial (1::'b) t * c + q)\n\ngoal (1 subgoal):\n 1. monomial c t + p \\<in> range (focus X)", "by (rule range_eqI)"], ["proof (state)\nthis:\n  monomial c t + p \\<in> range (focus X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_focus: \"inj ((focus X) :: (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::ab_group_add) \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (focus X)", "proof (rule injI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. focus X x = focus X y \\<Longrightarrow> x = y", "fix p q :: \"('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. focus X x = focus X y \\<Longrightarrow> x = y", "assume \"focus X p = focus X q\""], ["proof (state)\nthis:\n  focus X p = focus X q\n\ngoal (1 subgoal):\n 1. \\<And>x y. focus X x = focus X y \\<Longrightarrow> x = y", "hence \"focus X (p - q) = 0\""], ["proof (prove)\nusing this:\n  focus X p = focus X q\n\ngoal (1 subgoal):\n 1. focus X (p - q) = 0", "by (simp add: focus_minus)"], ["proof (state)\nthis:\n  focus X (p - q) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x y. focus X x = focus X y \\<Longrightarrow> x = y", "thus \"p = q\""], ["proof (prove)\nusing this:\n  focus X (p - q) = 0\n\ngoal (1 subgoal):\n 1. p = q", "by simp"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flatten_superset:\n  assumes \"finite A\" and \"keys p \\<subseteq> A\"\n  shows \"flatten p = (\\<Sum>t\\<in>A. punit.monom_mult 1 t (lookup p t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten p = (\\<Sum>t\\<in>A. punit.monom_mult (1::'b) t (lookup p t))", "unfolding flatten_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p. punit.monom_mult (1::'b) t (lookup p t)) =\n    (\\<Sum>t\\<in>A. punit.monom_mult (1::'b) t (lookup p t))", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  keys p \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p. punit.monom_mult (1::'b) t (lookup p t)) =\n    (\\<Sum>t\\<in>A. punit.monom_mult (1::'b) t (lookup p t))", "by (rule sum.mono_neutral_left) (simp add: in_keys_iff)"], ["", "lemma keys_flatten_subset: \"keys (flatten p) \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (flatten p)\n    \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. keys (flatten p)\n    \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))", "have \"keys (flatten p) \\<subseteq> (\\<Union>t\\<in>keys p. keys (punit.monom_mult 1 t (lookup p t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (flatten p)\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    keys (punit.monom_mult (1::'b) t (lookup p t)))", "unfolding flatten_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (\\<Sum>t\\<in>keys p. punit.monom_mult (1::'b) t (lookup p t))\n    \\<subseteq> (\\<Union>t\\<in>keys p.\n                    keys (punit.monom_mult (1::'b) t (lookup p t)))", "by (rule keys_sum_subset)"], ["proof (state)\nthis:\n  keys (flatten p)\n  \\<subseteq> (\\<Union>t\\<in>keys p.\n                  keys (punit.monom_mult (1::'b) t (lookup p t)))\n\ngoal (1 subgoal):\n 1. keys (flatten p)\n    \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))", "also"], ["proof (state)\nthis:\n  keys (flatten p)\n  \\<subseteq> (\\<Union>t\\<in>keys p.\n                  keys (punit.monom_mult (1::'b) t (lookup p t)))\n\ngoal (1 subgoal):\n 1. keys (flatten p)\n    \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))", "from subset_refl"], ["proof (chain)\npicking this:\n  ?A \\<subseteq> ?A", "have \"\\<dots> \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))\""], ["proof (prove)\nusing this:\n  ?A \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. (\\<Union>t\\<in>keys p. keys (punit.monom_mult (1::'b) t (lookup p t)))\n    \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))", "by (rule UN_mono) (rule punit.keys_monom_mult_subset[simplified])"], ["proof (state)\nthis:\n  (\\<Union>t\\<in>keys p. keys (punit.monom_mult (1::'b) t (lookup p t)))\n  \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))\n\ngoal (1 subgoal):\n 1. keys (flatten p)\n    \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))", "finally"], ["proof (chain)\npicking this:\n  keys (flatten p)\n  \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (flatten p)\n  \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))\n\ngoal (1 subgoal):\n 1. keys (flatten p)\n    \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))", "."], ["proof (state)\nthis:\n  keys (flatten p)\n  \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flatten_in_Polys:\n  assumes \"p \\<in> P[X]\" and \"lookup p ` keys p \\<subseteq> P[Y]\"\n  shows \"flatten p \\<in> P[X \\<union> Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten p \\<in> P[X \\<union> Y]", "proof (intro PolysI subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "assume \"t \\<in> keys (flatten p)\""], ["proof (state)\nthis:\n  t \\<in> keys (flatten p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "also"], ["proof (state)\nthis:\n  t \\<in> keys (flatten p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "have \"\\<dots> \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (flatten p)\n    \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))", "by (rule keys_flatten_subset)"], ["proof (state)\nthis:\n  keys (flatten p)\n  \\<subseteq> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "finally"], ["proof (chain)\npicking this:\n  t \\<in> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))", "obtain s where \"s \\<in> keys p\" and \"t \\<in> (+) s ` keys (lookup p s)\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>t\\<in>keys p. (+) t ` keys (lookup p t))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys p; t \\<in> (+) s ` keys (lookup p s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> keys p\n  t \\<in> (+) s ` keys (lookup p s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "from this(2)"], ["proof (chain)\npicking this:\n  t \\<in> (+) s ` keys (lookup p s)", "obtain s' where \"s' \\<in> keys (lookup p s)\" and t: \"t = s + s'\""], ["proof (prove)\nusing this:\n  t \\<in> (+) s ` keys (lookup p s)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> keys (lookup p s); t = s + s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s' \\<in> keys (lookup p s)\n  t = s + s'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "from assms(1)"], ["proof (chain)\npicking this:\n  p \\<in> P[X]", "have \"keys p \\<subseteq> .[X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[X]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "with \\<open>s \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p\n  keys p \\<subseteq> .[X]", "have \"s \\<in> .[X]\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n  keys p \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. s \\<in> .[X]", ".."], ["proof (state)\nthis:\n  s \\<in> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "also"], ["proof (state)\nthis:\n  s \\<in> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "have \"\\<dots> \\<subseteq> .[X \\<union> Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. .[X] \\<subseteq> .[X \\<union> Y]", "by (rule PPs_mono) simp"], ["proof (state)\nthis:\n  .[X] \\<subseteq> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "finally"], ["proof (chain)\npicking this:\n  s \\<in> .[X \\<union> Y]", "have 1: \"s \\<in> .[X \\<union> Y]\""], ["proof (prove)\nusing this:\n  s \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. s \\<in> .[X \\<union> Y]", "."], ["proof (state)\nthis:\n  s \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "from \\<open>s \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys p", "have \"lookup p s \\<in> lookup p ` keys p\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. lookup p s \\<in> lookup p ` keys p", "by (rule imageI)"], ["proof (state)\nthis:\n  lookup p s \\<in> lookup p ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "also"], ["proof (state)\nthis:\n  lookup p s \\<in> lookup p ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "have \"\\<dots> \\<subseteq> P[Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup p ` keys p \\<subseteq> P[Y]", "by fact"], ["proof (state)\nthis:\n  lookup p ` keys p \\<subseteq> P[Y]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "finally"], ["proof (chain)\npicking this:\n  lookup p s \\<in> P[Y]", "have \"keys (lookup p s) \\<subseteq> .[Y]\""], ["proof (prove)\nusing this:\n  lookup p s \\<in> P[Y]\n\ngoal (1 subgoal):\n 1. keys (lookup p s) \\<subseteq> .[Y]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys (lookup p s) \\<subseteq> .[Y]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "with \\<open>s' \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  s' \\<in> keys (lookup p s)\n  keys (lookup p s) \\<subseteq> .[Y]", "have \"s' \\<in> .[Y]\""], ["proof (prove)\nusing this:\n  s' \\<in> keys (lookup p s)\n  keys (lookup p s) \\<subseteq> .[Y]\n\ngoal (1 subgoal):\n 1. s' \\<in> .[Y]", ".."], ["proof (state)\nthis:\n  s' \\<in> .[Y]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "also"], ["proof (state)\nthis:\n  s' \\<in> .[Y]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "have \"\\<dots> \\<subseteq> .[X \\<union> Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. .[Y] \\<subseteq> .[X \\<union> Y]", "by (rule PPs_mono) simp"], ["proof (state)\nthis:\n  .[Y] \\<subseteq> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "finally"], ["proof (chain)\npicking this:\n  s' \\<in> .[X \\<union> Y]", "have \"s' \\<in> .[X \\<union> Y]\""], ["proof (prove)\nusing this:\n  s' \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. s' \\<in> .[X \\<union> Y]", "."], ["proof (state)\nthis:\n  s' \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (flatten p) \\<Longrightarrow> x \\<in> .[X \\<union> Y]", "with 1"], ["proof (chain)\npicking this:\n  s \\<in> .[X \\<union> Y]\n  s' \\<in> .[X \\<union> Y]", "show \"t \\<in> .[X \\<union> Y]\""], ["proof (prove)\nusing this:\n  s \\<in> .[X \\<union> Y]\n  s' \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. t \\<in> .[X \\<union> Y]", "unfolding t"], ["proof (prove)\nusing this:\n  s \\<in> .[X \\<union> Y]\n  s' \\<in> .[X \\<union> Y]\n\ngoal (1 subgoal):\n 1. s + s' \\<in> .[X \\<union> Y]", "by (rule PPs_closed_plus)"], ["proof (state)\nthis:\n  t \\<in> .[X \\<union> Y]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flatten_zero [simp]: \"flatten 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten 0 = 0", "by (simp add: flatten_def)"], ["", "lemma flatten_one [simp]: \"flatten 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten 1 = 1", "by (simp add: flatten_def)"], ["", "lemma flatten_monomial: \"flatten (monomial c t) = punit.monom_mult 1 t c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (monomial c t) = punit.monom_mult (1::'b) t c", "by (simp add: flatten_def)"], ["", "lemma flatten_uminus [simp]: \"flatten (- p) = - flatten (p::_ \\<Rightarrow>\\<^sub>0 _ \\<Rightarrow>\\<^sub>0 _::ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (- p) = - flatten p", "by (simp add: flatten_def keys_uminus punit.monom_mult_uminus_right sum_negf)"], ["", "lemma flatten_plus: \"flatten (p + q) = flatten p + flatten q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (p + q) = flatten p + flatten q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. flatten (p + q) = flatten p + flatten q", "have \"finite (keys p \\<union> keys q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (keys p \\<union> keys q)", "by simp"], ["proof (state)\nthis:\n  finite (keys p \\<union> keys q)\n\ngoal (1 subgoal):\n 1. flatten (p + q) = flatten p + flatten q", "moreover"], ["proof (state)\nthis:\n  finite (keys p \\<union> keys q)\n\ngoal (1 subgoal):\n 1. flatten (p + q) = flatten p + flatten q", "have \"keys (p + q) \\<subseteq> keys p \\<union> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p + q) \\<subseteq> keys p \\<union> keys q", "by (rule Poly_Mapping.keys_add)"], ["proof (state)\nthis:\n  keys (p + q) \\<subseteq> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. flatten (p + q) = flatten p + flatten q", "ultimately"], ["proof (chain)\npicking this:\n  finite (keys p \\<union> keys q)\n  keys (p + q) \\<subseteq> keys p \\<union> keys q", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (keys p \\<union> keys q)\n  keys (p + q) \\<subseteq> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. flatten (p + q) = flatten p + flatten q", "by (simp add: flatten_superset[where A=\"keys p \\<union> keys q\"] punit.monom_mult_dist_right lookup_add\n                  sum.distrib)"], ["proof (state)\nthis:\n  flatten (p + q) = flatten p + flatten q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flatten_minus: \"flatten (p - q) = flatten p - flatten (q::_ \\<Rightarrow>\\<^sub>0 _ \\<Rightarrow>\\<^sub>0 _::ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (p - q) = flatten p - flatten q", "by (simp only: diff_conv_add_uminus flatten_plus flatten_uminus)"], ["", "lemma flatten_times: \"flatten (p * q) = flatten p * flatten (q::_ \\<Rightarrow>\\<^sub>0 _ \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (p * q) = flatten p * flatten q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. flatten (p * q) = flatten p * flatten q", "have eq: \"flatten (monomial c s * q) = flatten (monomial c s) * flatten q\" for c s"], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "have eq: \"monomial 1 (t + s) = monomial 1 s * monomial (1::'b) t\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (1::'b) (t + s) = monomial (1::'b) s * monomial (1::'b) t", "by (simp add: times_monomial_monomial add.commute)"], ["proof (state)\nthis:\n  monomial (1::'b) (?t + s) = monomial (1::'b) s * monomial (1::'b) ?t\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "have \"flatten (monomial c s * q) = flatten (punit.monom_mult c s q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (punit.monom_mult c s q)", "by (simp only: times_monomial_left)"], ["proof (state)\nthis:\n  flatten (monomial c s * q) = flatten (punit.monom_mult c s q)\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "also"], ["proof (state)\nthis:\n  flatten (monomial c s * q) = flatten (punit.monom_mult c s q)\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "have \"\\<dots> = (\\<Sum>t\\<in>(+) s ` keys q. punit.monom_mult 1 t (lookup (punit.monom_mult c s q) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (punit.monom_mult c s q) =\n    (\\<Sum>t\\<in>(+) s ` keys q.\n       punit.monom_mult (1::'b) t (lookup (punit.monom_mult c s q) t))", "by (rule flatten_superset) (simp_all add: punit.keys_monom_mult_subset[simplified])"], ["proof (state)\nthis:\n  flatten (punit.monom_mult c s q) =\n  (\\<Sum>t\\<in>(+) s ` keys q.\n     punit.monom_mult (1::'b) t (lookup (punit.monom_mult c s q) t))\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "also"], ["proof (state)\nthis:\n  flatten (punit.monom_mult c s q) =\n  (\\<Sum>t\\<in>(+) s ` keys q.\n     punit.monom_mult (1::'b) t (lookup (punit.monom_mult c s q) t))\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "have \"\\<dots> = (\\<Sum>t\\<in>keys q. ((\\<lambda>t. punit.monom_mult 1 t (lookup (punit.monom_mult c s q) t)) \\<circ> (+) s) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>(+) s ` keys q.\n       punit.monom_mult (1::'b) t (lookup (punit.monom_mult c s q) t)) =\n    sum ((\\<lambda>t.\n             punit.monom_mult (1::'b) t\n              (lookup (punit.monom_mult c s q) t)) \\<circ>\n         (+) s)\n     (keys q)", "by (rule sum.reindex) simp"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>(+) s ` keys q.\n     punit.monom_mult (1::'b) t (lookup (punit.monom_mult c s q) t)) =\n  sum ((\\<lambda>t.\n           punit.monom_mult (1::'b) t\n            (lookup (punit.monom_mult c s q) t)) \\<circ>\n       (+) s)\n   (keys q)\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "thm times_monomial_left"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>(+) s ` keys q.\n     punit.monom_mult (1::'b) t (lookup (punit.monom_mult c s q) t)) =\n  sum ((\\<lambda>t.\n           punit.monom_mult (1::'b) t\n            (lookup (punit.monom_mult c s q) t)) \\<circ>\n       (+) s)\n   (keys q)\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>(+) s ` keys q.\n     punit.monom_mult (1::'b) t (lookup (punit.monom_mult c s q) t)) =\n  sum ((\\<lambda>t.\n           punit.monom_mult (1::'b) t\n            (lookup (punit.monom_mult c s q) t)) \\<circ>\n       (+) s)\n   (keys q)\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "have \"\\<dots> = punit.monom_mult 1 s c *\n                      (\\<Sum>t\\<in>keys q. punit.monom_mult 1 t (lookup q t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>t.\n             punit.monom_mult (1::'b) t\n              (lookup (punit.monom_mult c s q) t)) \\<circ>\n         (+) s)\n     (keys q) =\n    punit.monom_mult (1::'b) s c *\n    (\\<Sum>t\\<in>keys q. punit.monom_mult (1::'b) t (lookup q t))", "by (simp add: o_def punit.lookup_monom_mult sum_distrib_left)\n          (simp add: algebra_simps eq flip: times_monomial_left)"], ["proof (state)\nthis:\n  sum ((\\<lambda>t.\n           punit.monom_mult (1::'b) t\n            (lookup (punit.monom_mult c s q) t)) \\<circ>\n       (+) s)\n   (keys q) =\n  punit.monom_mult (1::'b) s c *\n  (\\<Sum>t\\<in>keys q. punit.monom_mult (1::'b) t (lookup q t))\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>t.\n           punit.monom_mult (1::'b) t\n            (lookup (punit.monom_mult c s q) t)) \\<circ>\n       (+) s)\n   (keys q) =\n  punit.monom_mult (1::'b) s c *\n  (\\<Sum>t\\<in>keys q. punit.monom_mult (1::'b) t (lookup q t))\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "have \"\\<dots> = flatten (monomial c s) * flatten q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult (1::'b) s c *\n    (\\<Sum>t\\<in>keys q. punit.monom_mult (1::'b) t (lookup q t)) =\n    flatten (monomial c s) * flatten q", "by (simp only: flatten_monomial flatten_def[where p=q])"], ["proof (state)\nthis:\n  punit.monom_mult (1::'b) s c *\n  (\\<Sum>t\\<in>keys q. punit.monom_mult (1::'b) t (lookup q t)) =\n  flatten (monomial c s) * flatten q\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "finally"], ["proof (chain)\npicking this:\n  flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "show ?thesis"], ["proof (prove)\nusing this:\n  flatten (monomial c s * q) = flatten (monomial c s) * flatten q\n\ngoal (1 subgoal):\n 1. flatten (monomial c s * q) = flatten (monomial c s) * flatten q", "."], ["proof (state)\nthis:\n  flatten (monomial c s * q) = flatten (monomial c s) * flatten q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  flatten (monomial ?c ?s * q) = flatten (monomial ?c ?s) * flatten q\n\ngoal (1 subgoal):\n 1. flatten (p * q) = flatten p * flatten q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (p * q) = flatten p * flatten q", "by (induct p rule: poly_mapping_plus_induct) (simp_all add: ring_distribs flatten_plus eq)"], ["proof (state)\nthis:\n  flatten (p * q) = flatten p * flatten q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flatten_monom_mult:\n  \"flatten (punit.monom_mult c t p) = punit.monom_mult 1 t (c * flatten (p::_ \\<Rightarrow>\\<^sub>0 _ \\<Rightarrow>\\<^sub>0 'b::comm_semiring_1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (punit.monom_mult c t p) =\n    punit.monom_mult (1::'b) t (c * flatten p)", "by (simp only: flatten_times flatten_monomial mult.assoc flip: times_monomial_left)"], ["", "lemma flatten_sum: \"flatten (sum f I) = (\\<Sum>i\\<in>I. flatten (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (sum f I) = (\\<Sum>i\\<in>I. flatten (f i))", "by (induct I rule: infinite_finite_induct) (simp_all add: flatten_plus)"], ["", "lemma flatten_prod: \"flatten (prod f I) = (\\<Prod>i\\<in>I. flatten (f i :: _ \\<Rightarrow>\\<^sub>0 _::comm_semiring_1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (prod f I) = (\\<Prod>i\\<in>I. flatten (f i))", "by (induct I rule: infinite_finite_induct) (simp_all add: flatten_times)"], ["", "lemma flatten_power [simp]: \"flatten (f ^ m) = flatten (f:: _ \\<Rightarrow>\\<^sub>0 _::comm_semiring_1) ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (f ^ m) = flatten f ^ m", "by (induct m) (simp_all add: flatten_times)"], ["", "lemma surj_flatten: \"surj flatten\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj flatten", "proof (rule surjI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. flatten (?f x) = x", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. flatten (?f x) = x", "show \"flatten (monomial p 0) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (monomial p (0::'c)) = p", "by (simp add: flatten_monomial)"], ["proof (state)\nthis:\n  flatten (monomial p (0::'c)) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flatten_focus [simp]: \"flatten (focus X p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (focus X p) = p", "by (induct p rule: poly_mapping_plus_induct)\n      (simp_all add: focus_plus flatten_plus focus_monomial flatten_monomial\n                      punit.monom_mult_monomial add.commute flip: except_decomp)"], ["", "lemma focus_flatten:\n  assumes \"p \\<in> P[X]\" and \"lookup p ` keys p \\<subseteq> P[- X]\"\n  shows \"focus X (flatten p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X (flatten p) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. focus X (flatten p) = p", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[X]\n  lookup p ` keys p \\<subseteq> P[- X]", "have \"p \\<in> range (focus X)\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n  lookup p ` keys p \\<subseteq> P[- X]\n\ngoal (1 subgoal):\n 1. p \\<in> range (focus X)", "by (rule range_focusI)"], ["proof (state)\nthis:\n  p \\<in> range (focus X)\n\ngoal (1 subgoal):\n 1. focus X (flatten p) = p", "then"], ["proof (chain)\npicking this:\n  p \\<in> range (focus X)", "obtain q where \"p = focus X q\""], ["proof (prove)\nusing this:\n  p \\<in> range (focus X)\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = focus X q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p = focus X q\n\ngoal (1 subgoal):\n 1. focus X (flatten p) = p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = focus X q\n\ngoal (1 subgoal):\n 1. focus X (flatten p) = p", "by simp"], ["proof (state)\nthis:\n  focus X (flatten p) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_focus_ideal: \"focus X ` ideal F = ideal (focus X ` F) \\<inter> range (focus X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus X ` ideal F = ideal (focus X ` F) \\<inter> range (focus X)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. focus X ` ideal F\n    \\<subseteq> ideal (focus X ` F) \\<inter> range (focus X)\n 2. ideal (focus X ` F) \\<inter> range (focus X)\n    \\<subseteq> focus X ` ideal F", "from focus_plus focus_times"], ["proof (chain)\npicking this:\n  focus ?X (?p + ?q) = focus ?X ?p + focus ?X ?q\n  focus ?X (?p * ?q) = focus ?X ?p * focus ?X ?q", "have \"focus X ` ideal F \\<subseteq> ideal (focus X ` F)\""], ["proof (prove)\nusing this:\n  focus ?X (?p + ?q) = focus ?X ?p + focus ?X ?q\n  focus ?X (?p * ?q) = focus ?X ?p * focus ?X ?q\n\ngoal (1 subgoal):\n 1. focus X ` ideal F \\<subseteq> ideal (focus X ` F)", "by (rule image_ideal_subset)"], ["proof (state)\nthis:\n  focus X ` ideal F \\<subseteq> ideal (focus X ` F)\n\ngoal (2 subgoals):\n 1. focus X ` ideal F\n    \\<subseteq> ideal (focus X ` F) \\<inter> range (focus X)\n 2. ideal (focus X ` F) \\<inter> range (focus X)\n    \\<subseteq> focus X ` ideal F", "moreover"], ["proof (state)\nthis:\n  focus X ` ideal F \\<subseteq> ideal (focus X ` F)\n\ngoal (2 subgoals):\n 1. focus X ` ideal F\n    \\<subseteq> ideal (focus X ` F) \\<inter> range (focus X)\n 2. ideal (focus X ` F) \\<inter> range (focus X)\n    \\<subseteq> focus X ` ideal F", "from subset_UNIV"], ["proof (chain)\npicking this:\n  ?A \\<subseteq> UNIV", "have \"focus X ` ideal F \\<subseteq> range (focus X)\""], ["proof (prove)\nusing this:\n  ?A \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. focus X ` ideal F \\<subseteq> range (focus X)", "by (rule image_mono)"], ["proof (state)\nthis:\n  focus X ` ideal F \\<subseteq> range (focus X)\n\ngoal (2 subgoals):\n 1. focus X ` ideal F\n    \\<subseteq> ideal (focus X ` F) \\<inter> range (focus X)\n 2. ideal (focus X ` F) \\<inter> range (focus X)\n    \\<subseteq> focus X ` ideal F", "ultimately"], ["proof (chain)\npicking this:\n  focus X ` ideal F \\<subseteq> ideal (focus X ` F)\n  focus X ` ideal F \\<subseteq> range (focus X)", "show \"focus X ` ideal F \\<subseteq> ideal (focus X ` F) \\<inter> range (focus X)\""], ["proof (prove)\nusing this:\n  focus X ` ideal F \\<subseteq> ideal (focus X ` F)\n  focus X ` ideal F \\<subseteq> range (focus X)\n\ngoal (1 subgoal):\n 1. focus X ` ideal F\n    \\<subseteq> ideal (focus X ` F) \\<inter> range (focus X)", "by blast"], ["proof (state)\nthis:\n  focus X ` ideal F \\<subseteq> ideal (focus X ` F) \\<inter> range (focus X)\n\ngoal (1 subgoal):\n 1. ideal (focus X ` F) \\<inter> range (focus X)\n    \\<subseteq> focus X ` ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ideal (focus X ` F) \\<inter> range (focus X)\n    \\<subseteq> focus X ` ideal F", "show \"ideal (focus X ` F) \\<inter> range (focus X) \\<subseteq> focus X ` ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (focus X ` F) \\<inter> range (focus X)\n    \\<subseteq> focus X ` ideal F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "assume \"p \\<in> ideal (focus X ` F) \\<inter> range (focus X)\""], ["proof (state)\nthis:\n  p \\<in> ideal (focus X ` F) \\<inter> range (focus X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "hence \"p \\<in> ideal (focus X ` F)\" and \"p \\<in> range (focus X)\""], ["proof (prove)\nusing this:\n  p \\<in> ideal (focus X ` F) \\<inter> range (focus X)\n\ngoal (1 subgoal):\n 1. p \\<in> ideal (focus X ` F) &&& p \\<in> range (focus X)", "by simp_all"], ["proof (state)\nthis:\n  p \\<in> ideal (focus X ` F)\n  p \\<in> range (focus X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "from this(1)"], ["proof (chain)\npicking this:\n  p \\<in> ideal (focus X ` F)", "obtain F0 q where \"F0 \\<subseteq> focus X ` F\" and p: \"p = (\\<Sum>f'\\<in>F0. q f' * f')\""], ["proof (prove)\nusing this:\n  p \\<in> ideal (focus X ` F)\n\ngoal (1 subgoal):\n 1. (\\<And>F0 q.\n        \\<lbrakk>F0 \\<subseteq> focus X ` F;\n         p = (\\<Sum>f'\\<in>F0. q f' * f')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule ideal.spanE)"], ["proof (state)\nthis:\n  F0 \\<subseteq> focus X ` F\n  p = (\\<Sum>f'\\<in>F0. q f' * f')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "from this(1)"], ["proof (chain)\npicking this:\n  F0 \\<subseteq> focus X ` F", "obtain F' where \"F' \\<subseteq> F\" and F0: \"F0 = focus X ` F'\""], ["proof (prove)\nusing this:\n  F0 \\<subseteq> focus X ` F\n\ngoal (1 subgoal):\n 1. (\\<And>F'.\n        \\<lbrakk>F' \\<subseteq> F; F0 = focus X ` F'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule subset_imageE)"], ["proof (state)\nthis:\n  F' \\<subseteq> F\n  F0 = focus X ` F'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "from inj_focus subset_UNIV"], ["proof (chain)\npicking this:\n  inj (focus ?X)\n  ?A \\<subseteq> UNIV", "have \"inj_on (focus X) F'\""], ["proof (prove)\nusing this:\n  inj (focus ?X)\n  ?A \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. inj_on (focus X) F'", "by (rule inj_on_subset)"], ["proof (state)\nthis:\n  inj_on (focus X) F'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "from \\<open>p \\<in> range _\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> range (focus X)", "obtain p' where \"p = focus X p'\""], ["proof (prove)\nusing this:\n  p \\<in> range (focus X)\n\ngoal (1 subgoal):\n 1. (\\<And>p'. p = focus X p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p = focus X p'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "hence \"p = focus X (flatten p)\""], ["proof (prove)\nusing this:\n  p = focus X p'\n\ngoal (1 subgoal):\n 1. p = focus X (flatten p)", "by simp"], ["proof (state)\nthis:\n  p = focus X (flatten p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "also"], ["proof (state)\nthis:\n  p = focus X (flatten p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "from \\<open>inj_on _ F'\\<close>"], ["proof (chain)\npicking this:\n  inj_on (focus X) F'", "have \"\\<dots> = focus X (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f')\""], ["proof (prove)\nusing this:\n  inj_on (focus X) F'\n\ngoal (1 subgoal):\n 1. focus X (flatten p) =\n    focus X (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f')", "by (simp add: p F0 sum.reindex flatten_sum flatten_times)"], ["proof (state)\nthis:\n  focus X (flatten p) =\n  focus X (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "finally"], ["proof (chain)\npicking this:\n  p = focus X (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f')", "have \"p = focus X (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f')\""], ["proof (prove)\nusing this:\n  p = focus X (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f')\n\ngoal (1 subgoal):\n 1. p = focus X (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f')", "."], ["proof (state)\nthis:\n  p = focus X (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "moreover"], ["proof (state)\nthis:\n  p = focus X (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "have \"(\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f') \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f') \\<in> ideal F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f') \\<in> ?A\n 2. ?A \\<subseteq> ideal F", "show \"(\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f') \\<in> ideal F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f') \\<in> ideal F'", "by (rule ideal.sum_in_spanI)"], ["proof (state)\nthis:\n  (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f') \\<in> ideal F'\n\ngoal (1 subgoal):\n 1. ideal F' \\<subseteq> ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ideal F' \\<subseteq> ideal F", "from \\<open>F' \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  F' \\<subseteq> F", "show \"ideal F' \\<subseteq> ideal F\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. ideal F' \\<subseteq> ideal F", "by (rule ideal.span_mono)"], ["proof (state)\nthis:\n  ideal F' \\<subseteq> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f') \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ideal (focus X ` F) \\<inter>\n               range (focus X) \\<Longrightarrow>\n       x \\<in> focus X ` ideal F", "ultimately"], ["proof (chain)\npicking this:\n  p = focus X (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f')\n  (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f') \\<in> ideal F", "show \"p \\<in> focus X ` ideal F\""], ["proof (prove)\nusing this:\n  p = focus X (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f')\n  (\\<Sum>f'\\<in>F'. flatten (q (focus X f')) * f') \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p \\<in> focus X ` ideal F", "by (rule image_eqI)"], ["proof (state)\nthis:\n  p \\<in> focus X ` ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal (focus X ` F) \\<inter> range (focus X) \\<subseteq> focus X ` ideal F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_flatten_ideal: \"flatten ` ideal F = ideal (flatten ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten ` ideal F = ideal (flatten ` F)", "using flatten_plus flatten_times surj_flatten"], ["proof (prove)\nusing this:\n  flatten (?p + ?q) = flatten ?p + flatten ?q\n  flatten (?p * ?q) = flatten ?p * flatten ?q\n  surj flatten\n\ngoal (1 subgoal):\n 1. flatten ` ideal F = ideal (flatten ` F)", "by (rule image_ideal_eq_surj)"], ["", "lemma poly_eval_focus:\n  \"poly_eval a (focus X p) = poly_subst (\\<lambda>x. if x \\<in> X then a x else monomial 1 (Poly_Mapping.single x 1)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (focus X p) =\n    poly_subst\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval a (focus X p) =\n    poly_subst\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     p", "let ?b = \"\\<lambda>x. if x \\<in> X then a x else monomial 1 (Poly_Mapping.single x 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval a (focus X p) =\n    poly_subst\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     p", "have *: \"lookup (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n              (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X)))) 0 =\n            punit.monom_mult (lookup p t) 0 (subst_pp ?b t)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "have 1: \"subst_pp ?b (except t X) = monomial 1 (except t X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     (except t X) =\n    monomial (1::'b) (except t X)", "by (rule subst_pp_id) (simp add: keys_except)"], ["proof (state)\nthis:\n  subst_pp\n   (\\<lambda>x. if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n   (except t X) =\n  monomial (1::'b) (except t X)\n\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have 2: \"subst_pp ?b (except t (- X)) = subst_pp a (except t (-X))\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     (except t (- X)) =\n    subst_pp a (except t (- X))", "by (rule subst_pp_cong) (simp add: keys_except)"], ["proof (state)\nthis:\n  subst_pp\n   (\\<lambda>x. if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n   (except t (- X)) =\n  subst_pp a (except t (- X))\n\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "have \"lookup (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n                      (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X)))) 0 =\n          punit.monom_mult (lookup p t) (except t X) (subst_pp a (except t (- X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) (except t X) (subst_pp a (except t (- X)))", "by (simp add: lookup_times_zero subst_pp_def lookup_prod_zero lookup_power_zero\n                flip: times_monomial_left)"], ["proof (state)\nthis:\n  lookup\n   (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n     (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n   0 =\n  punit.monom_mult (lookup p t) (except t X) (subst_pp a (except t (- X)))\n\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "also"], ["proof (state)\nthis:\n  lookup\n   (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n     (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n   0 =\n  punit.monom_mult (lookup p t) (except t X) (subst_pp a (except t (- X)))\n\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "have \"\\<dots> = punit.monom_mult (lookup p t) 0 (monomial 1 (except t X) * subst_pp a (except t (- X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult (lookup p t) (except t X)\n     (subst_pp a (except t (- X))) =\n    punit.monom_mult (lookup p t) 0\n     (monomial (1::'b) (except t X) * subst_pp a (except t (- X)))", "by (simp add: times_monomial_monomial flip: times_monomial_left mult.assoc)"], ["proof (state)\nthis:\n  punit.monom_mult (lookup p t) (except t X) (subst_pp a (except t (- X))) =\n  punit.monom_mult (lookup p t) 0\n   (monomial (1::'b) (except t X) * subst_pp a (except t (- X)))\n\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "also"], ["proof (state)\nthis:\n  punit.monom_mult (lookup p t) (except t X) (subst_pp a (except t (- X))) =\n  punit.monom_mult (lookup p t) 0\n   (monomial (1::'b) (except t X) * subst_pp a (except t (- X)))\n\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "have \"\\<dots> = punit.monom_mult (lookup p t) 0 (subst_pp ?b (except t X + except t (- X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult (lookup p t) 0\n     (monomial (1::'b) (except t X) * subst_pp a (except t (- X))) =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       (except t X + except t (- X)))", "by (simp only: subst_pp_plus 1 2)"], ["proof (state)\nthis:\n  punit.monom_mult (lookup p t) 0\n   (monomial (1::'b) (except t X) * subst_pp a (except t (- X))) =\n  punit.monom_mult (lookup p t) 0\n   (subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     (except t X + except t (- X)))\n\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "also"], ["proof (state)\nthis:\n  punit.monom_mult (lookup p t) 0\n   (monomial (1::'b) (except t X) * subst_pp a (except t (- X))) =\n  punit.monom_mult (lookup p t) 0\n   (subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     (except t X + except t (- X)))\n\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "have \"\\<dots> = punit.monom_mult (lookup p t) 0 (subst_pp ?b t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       (except t X + except t (- X))) =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "by (simp flip: except_decomp)"], ["proof (state)\nthis:\n  punit.monom_mult (lookup p t) 0\n   (subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     (except t X + except t (- X))) =\n  punit.monom_mult (lookup p t) 0\n   (subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     t)\n\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "finally"], ["proof (chain)\npicking this:\n  lookup\n   (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n     (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n   0 =\n  punit.monom_mult (lookup p t) 0\n   (subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     t)", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup\n   (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n     (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n   0 =\n  punit.monom_mult (lookup p t) 0\n   (subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     t)\n\ngoal (1 subgoal):\n 1. lookup\n     (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n       (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n     0 =\n    punit.monom_mult (lookup p t) 0\n     (subst_pp\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       t)", "."], ["proof (state)\nthis:\n  lookup\n   (punit.monom_mult (monomial (lookup p t) (except t X)) 0\n     (subst_pp (\\<lambda>x. monomial (a x) 0) (except t (- X))))\n   0 =\n  punit.monom_mult (lookup p t) 0\n   (subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup\n   (punit.monom_mult (monomial (lookup p ?t1) (except ?t1 X)) 0\n     (subst_pp (\\<lambda>x. monomial (a x) 0) (except ?t1 (- X))))\n   0 =\n  punit.monom_mult (lookup p ?t1) 0\n   (subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     ?t1)\n\ngoal (1 subgoal):\n 1. poly_eval a (focus X p) =\n    poly_subst\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (focus X p) =\n    poly_subst\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     p", "by (simp add: poly_eval_def focus_def poly_subst_sum lookup_sum poly_subst_monomial *\n                        flip: poly_subst_def)"], ["proof (state)\nthis:\n  poly_eval a (focus X p) =\n  poly_subst\n   (\\<lambda>x. if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n   p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary poly_eval_poly_eval_focus:\n  \"poly_eval a (poly_eval b (focus X p)) = poly_eval (\\<lambda>x::'x. if x \\<in> X then poly_eval a (b x) else a x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (poly_eval b (focus X p)) =\n    poly_eval (\\<lambda>x. if x \\<in> X then poly_eval a (b x) else a x) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval a (poly_eval b (focus X p)) =\n    poly_eval (\\<lambda>x. if x \\<in> X then poly_eval a (b x) else a x) p", "have eq: \"monomial (lookup (poly_subst (\\<lambda>y. monomial (a y) (0::'x \\<Rightarrow>\\<^sub>0 nat)) q) 0) 0 =\n              poly_subst (\\<lambda>y. monomial (a y) (0::'x \\<Rightarrow>\\<^sub>0 nat)) q\" for q"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (lookup (poly_subst (\\<lambda>y. monomial (a y) 0) q) 0) 0 =\n    poly_subst (\\<lambda>y. monomial (a y) 0) q", "by (intro poly_deg_zero_imp_monomial poly_deg_poly_subst_eq_zeroI) simp"], ["proof (state)\nthis:\n  monomial (lookup (poly_subst (\\<lambda>y. monomial (a y) 0) ?q) 0) 0 =\n  poly_subst (\\<lambda>y. monomial (a y) 0) ?q\n\ngoal (1 subgoal):\n 1. poly_eval a (poly_eval b (focus X p)) =\n    poly_eval (\\<lambda>x. if x \\<in> X then poly_eval a (b x) else a x) p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (poly_eval b (focus X p)) =\n    poly_eval (\\<lambda>x. if x \\<in> X then poly_eval a (b x) else a x) p", "unfolding poly_eval_focus"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a\n     (poly_subst\n       (\\<lambda>x.\n           if x \\<in> X then b x else monomial (1::'a) (monomial 1 x))\n       p) =\n    poly_eval (\\<lambda>x. if x \\<in> X then poly_eval a (b x) else a x) p", "by (simp add: poly_eval_def poly_subst_poly_subst if_distrib poly_subst_monomial subst_pp_single eq\n            cong: if_cong)"], ["proof (state)\nthis:\n  poly_eval a (poly_eval b (focus X p)) =\n  poly_eval (\\<lambda>x. if x \\<in> X then poly_eval a (b x) else a x) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indets_poly_eval_focus_subset:\n  \"indets (poly_eval a (focus X p)) \\<subseteq> \\<Union> (indets ` a ` X) \\<union> (indets p - X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (poly_eval a (focus X p))\n    \\<subseteq> \\<Union> (indets ` a ` X) \\<union> (indets p - X)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (poly_eval a (focus X p)) \\<Longrightarrow>\n       x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (poly_eval a (focus X p)) \\<Longrightarrow>\n       x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)", "assume \"x \\<in> indets (poly_eval a (focus X p))\""], ["proof (state)\nthis:\n  x \\<in> indets (poly_eval a (focus X p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (poly_eval a (focus X p)) \\<Longrightarrow>\n       x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)", "also"], ["proof (state)\nthis:\n  x \\<in> indets (poly_eval a (focus X p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (poly_eval a (focus X p)) \\<Longrightarrow>\n       x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)", "have \"\\<dots> = indets (poly_subst (\\<lambda>x. if x \\<in> X then a x else monomial 1 (Poly_Mapping.single x 1)) p)\"\n    (is \"_ = indets (poly_subst ?f _)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (poly_eval a (focus X p)) =\n    indets\n     (poly_subst\n       (\\<lambda>x.\n           if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n       p)", "by (simp only: poly_eval_focus)"], ["proof (state)\nthis:\n  indets (poly_eval a (focus X p)) =\n  indets\n   (poly_subst\n     (\\<lambda>x.\n         if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n     p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (poly_eval a (focus X p)) \\<Longrightarrow>\n       x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)", "finally"], ["proof (chain)\npicking this:\n  x \\<in> indets\n           (poly_subst\n             (\\<lambda>x.\n                 if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n             p)", "obtain y where \"y \\<in> indets p\" and \"x \\<in> indets (?f y)\""], ["proof (prove)\nusing this:\n  x \\<in> indets\n           (poly_subst\n             (\\<lambda>x.\n                 if x \\<in> X then a x else monomial (1::'b) (monomial 1 x))\n             p)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> indets p;\n         x \\<in> indets\n                  (if y \\<in> X then a y\n                   else monomial (1::'b) (monomial 1 y))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_indets_poly_substE)"], ["proof (state)\nthis:\n  y \\<in> indets p\n  x \\<in> indets\n           (if y \\<in> X then a y else monomial (1::'b) (monomial 1 y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (poly_eval a (focus X p)) \\<Longrightarrow>\n       x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)", "from this(2)"], ["proof (chain)\npicking this:\n  x \\<in> indets\n           (if y \\<in> X then a y else monomial (1::'b) (monomial 1 y))", "have \"(x \\<notin> X \\<and> x = y) \\<or> (y \\<in> X \\<and> x \\<in> indets (a y))\""], ["proof (prove)\nusing this:\n  x \\<in> indets\n           (if y \\<in> X then a y else monomial (1::'b) (monomial 1 y))\n\ngoal (1 subgoal):\n 1. x \\<notin> X \\<and> x = y \\<or> y \\<in> X \\<and> x \\<in> indets (a y)", "by (simp add: indets_monomial split: if_split_asm)"], ["proof (state)\nthis:\n  x \\<notin> X \\<and> x = y \\<or> y \\<in> X \\<and> x \\<in> indets (a y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> indets (poly_eval a (focus X p)) \\<Longrightarrow>\n       x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)", "thus \"x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)\""], ["proof (prove)\nusing this:\n  x \\<notin> X \\<and> x = y \\<or> y \\<in> X \\<and> x \\<in> indets (a y)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)", "proof (elim disjE conjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> X; x = y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union> (indets ` a ` X) \\<union>\n                              (indets p - X)\n 2. \\<lbrakk>y \\<in> X; x \\<in> indets (a y)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union> (indets ` a ` X) \\<union>\n                              (indets p - X)", "assume \"x \\<notin> X\" and \"x = y\""], ["proof (state)\nthis:\n  x \\<notin> X\n  x = y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> X; x = y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union> (indets ` a ` X) \\<union>\n                              (indets p - X)\n 2. \\<lbrakk>y \\<in> X; x \\<in> indets (a y)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union> (indets ` a ` X) \\<union>\n                              (indets p - X)", "with \\<open>y \\<in> indets p\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> indets p\n  x \\<notin> X\n  x = y", "have \"x \\<in> indets p - X\""], ["proof (prove)\nusing this:\n  y \\<in> indets p\n  x \\<notin> X\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<in> indets p - X", "by simp"], ["proof (state)\nthis:\n  x \\<in> indets p - X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> X; x = y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union> (indets ` a ` X) \\<union>\n                              (indets p - X)\n 2. \\<lbrakk>y \\<in> X; x \\<in> indets (a y)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union> (indets ` a ` X) \\<union>\n                              (indets p - X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> indets p - X\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)", ".."], ["proof (state)\nthis:\n  x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> X; x \\<in> indets (a y)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union> (indets ` a ` X) \\<union>\n                              (indets p - X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> X; x \\<in> indets (a y)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union> (indets ` a ` X) \\<union>\n                              (indets p - X)", "assume \"y \\<in> X\" and \"x \\<in> indets (a y)\""], ["proof (state)\nthis:\n  y \\<in> X\n  x \\<in> indets (a y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> X; x \\<in> indets (a y)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union> (indets ` a ` X) \\<union>\n                              (indets p - X)", "hence \"x \\<in> \\<Union> (indets ` a ` X)\""], ["proof (prove)\nusing this:\n  y \\<in> X\n  x \\<in> indets (a y)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (indets ` a ` X)", "by blast"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (indets ` a ` X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> X; x \\<in> indets (a y)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union> (indets ` a ` X) \\<union>\n                              (indets p - X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (indets ` a ` X)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)", ".."], ["proof (state)\nthis:\n  x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (indets ` a ` X) \\<union> (indets p - X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_poly_eval_focus:\n  \"lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t = poly_eval a (lookup (focus (- X) p) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t =\n    poly_eval a (lookup (focus (- X) p) t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t =\n    poly_eval a (lookup (focus (- X) p) t)", "let ?f = \"\\<lambda>x. if x \\<in> X then monomial (a x) 0 else monomial 1 (Poly_Mapping.single x 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t =\n    poly_eval a (lookup (focus (- X) p) t)", "have eq: \"subst_pp ?f s = monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then monomial (a x) 0\n         else monomial (1::'a) (monomial 1 x))\n     s =\n    monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then monomial (a x) 0\n         else monomial (1::'a) (monomial 1 x))\n     s =\n    monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)", "have \"subst_pp ?f s = (\\<Prod>x\\<in>(keys s \\<inter> X) \\<union> (keys s - X). ?f x ^ lookup s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then monomial (a x) 0\n         else monomial (1::'a) (monomial 1 x))\n     s =\n    (\\<Prod>x\\<in>keys s \\<inter> X \\<union> (keys s - X).\n       (if x \\<in> X then monomial (a x) 0\n        else monomial (1::'a) (monomial 1 x)) ^\n       lookup s x)", "unfolding subst_pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>keys s.\n       (if x \\<in> X then monomial (a x) 0\n        else monomial (1::'a) (monomial 1 x)) ^\n       lookup s x) =\n    (\\<Prod>x\\<in>keys s \\<inter> X \\<union> (keys s - X).\n       (if x \\<in> X then monomial (a x) 0\n        else monomial (1::'a) (monomial 1 x)) ^\n       lookup s x)", "by (rule prod.cong) blast+"], ["proof (state)\nthis:\n  subst_pp\n   (\\<lambda>x.\n       if x \\<in> X then monomial (a x) 0\n       else monomial (1::'a) (monomial 1 x))\n   s =\n  (\\<Prod>x\\<in>keys s \\<inter> X \\<union> (keys s - X).\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x)\n\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then monomial (a x) 0\n         else monomial (1::'a) (monomial 1 x))\n     s =\n    monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)", "also"], ["proof (state)\nthis:\n  subst_pp\n   (\\<lambda>x.\n       if x \\<in> X then monomial (a x) 0\n       else monomial (1::'a) (monomial 1 x))\n   s =\n  (\\<Prod>x\\<in>keys s \\<inter> X \\<union> (keys s - X).\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x)\n\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then monomial (a x) 0\n         else monomial (1::'a) (monomial 1 x))\n     s =\n    monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)", "have \"\\<dots> = (\\<Prod>x\\<in>keys s \\<inter> X. ?f x ^ lookup s x) * (\\<Prod>x\\<in>keys s - X. ?f x ^ lookup s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>keys s \\<inter> X \\<union> (keys s - X).\n       (if x \\<in> X then monomial (a x) 0\n        else monomial (1::'a) (monomial 1 x)) ^\n       lookup s x) =\n    (\\<Prod>x\\<in>keys s \\<inter> X.\n       (if x \\<in> X then monomial (a x) 0\n        else monomial (1::'a) (monomial 1 x)) ^\n       lookup s x) *\n    (\\<Prod>x\\<in>keys s - X.\n       (if x \\<in> X then monomial (a x) 0\n        else monomial (1::'a) (monomial 1 x)) ^\n       lookup s x)", "by (rule prod.union_disjoint) auto"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>keys s \\<inter> X \\<union> (keys s - X).\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x) =\n  (\\<Prod>x\\<in>keys s \\<inter> X.\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x) *\n  (\\<Prod>x\\<in>keys s - X.\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x)\n\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then monomial (a x) 0\n         else monomial (1::'a) (monomial 1 x))\n     s =\n    monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>keys s \\<inter> X \\<union> (keys s - X).\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x) =\n  (\\<Prod>x\\<in>keys s \\<inter> X.\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x) *\n  (\\<Prod>x\\<in>keys s - X.\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x)\n\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then monomial (a x) 0\n         else monomial (1::'a) (monomial 1 x))\n     s =\n    monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)", "have \"\\<dots> = monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x)\n                              (\\<Sum>x\\<in>keys s - X. Poly_Mapping.single x (lookup s x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>keys s \\<inter> X.\n       (if x \\<in> X then monomial (a x) 0\n        else monomial (1::'a) (monomial 1 x)) ^\n       lookup s x) *\n    (\\<Prod>x\\<in>keys s - X.\n       (if x \\<in> X then monomial (a x) 0\n        else monomial (1::'a) (monomial 1 x)) ^\n       lookup s x) =\n    monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x)\n     (\\<Sum>x\\<in>keys s - X. monomial (lookup s x) x)", "by (simp add: monomial_power_map_scale times_monomial_monomial flip: punit.monomial_prod_sum)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>keys s \\<inter> X.\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x) *\n  (\\<Prod>x\\<in>keys s - X.\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x) =\n  monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x)\n   (\\<Sum>x\\<in>keys s - X. monomial (lookup s x) x)\n\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then monomial (a x) 0\n         else monomial (1::'a) (monomial 1 x))\n     s =\n    monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>keys s \\<inter> X.\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x) *\n  (\\<Prod>x\\<in>keys s - X.\n     (if x \\<in> X then monomial (a x) 0\n      else monomial (1::'a) (monomial 1 x)) ^\n     lookup s x) =\n  monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x)\n   (\\<Sum>x\\<in>keys s - X. monomial (lookup s x) x)\n\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then monomial (a x) 0\n         else monomial (1::'a) (monomial 1 x))\n     s =\n    monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)", "have \"(\\<Sum>x\\<in>keys s - X. Poly_Mapping.single x (lookup s x)) = except s X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys s - X. monomial (lookup s x) x) = except s X", "by (metis (mono_tags, lifting) DiffD2 keys_except lookup_except_eq_idI\n              poly_mapping_sum_monomials sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys s - X. monomial (lookup s x) x) = except s X\n\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then monomial (a x) 0\n         else monomial (1::'a) (monomial 1 x))\n     s =\n    monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)", "finally"], ["proof (chain)\npicking this:\n  subst_pp\n   (\\<lambda>x.\n       if x \\<in> X then monomial (a x) 0\n       else monomial (1::'a) (monomial 1 x))\n   s =\n  monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_pp\n   (\\<lambda>x.\n       if x \\<in> X then monomial (a x) 0\n       else monomial (1::'a) (monomial 1 x))\n   s =\n  monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)\n\ngoal (1 subgoal):\n 1. subst_pp\n     (\\<lambda>x.\n         if x \\<in> X then monomial (a x) 0\n         else monomial (1::'a) (monomial 1 x))\n     s =\n    monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)", "."], ["proof (state)\nthis:\n  subst_pp\n   (\\<lambda>x.\n       if x \\<in> X then monomial (a x) 0\n       else monomial (1::'a) (monomial 1 x))\n   s =\n  monomial (\\<Prod>x\\<in>keys s \\<inter> X. a x ^ lookup s x) (except s X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_pp\n   (\\<lambda>x.\n       if x \\<in> X then monomial (a x) 0\n       else monomial (1::'a) (monomial 1 x))\n   ?s1 =\n  monomial (\\<Prod>x\\<in>keys ?s1 \\<inter> X. a x ^ lookup ?s1 x)\n   (except ?s1 X)\n\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t =\n    poly_eval a (lookup (focus (- X) p) t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t =\n    poly_eval a (lookup (focus (- X) p) t)", "by (simp add: poly_eval_focus poly_subst_def lookup_sum eq flip: punit.map_scale_eq_monom_mult)\n       (simp add: focus_def lookup_sum poly_eval_sum lookup_single when_distrib poly_eval_monomial\n                  keys_except lookup_except_when)"], ["proof (state)\nthis:\n  lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t =\n  poly_eval a (lookup (focus (- X) p) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_poly_eval_focus_subset:\n  \"keys (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) \\<subseteq> (\\<lambda>t. except t X) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p))\n    \\<subseteq> (\\<lambda>t. except t X) ` keys p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys\n                (poly_eval (\\<lambda>x. monomial (a x) 0)\n                  (focus X p)) \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. except t X) ` keys p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys\n                (poly_eval (\\<lambda>x. monomial (a x) 0)\n                  (focus X p)) \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. except t X) ` keys p", "assume \"t \\<in> keys (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p))\""], ["proof (state)\nthis:\n  t \\<in> keys (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys\n                (poly_eval (\\<lambda>x. monomial (a x) 0)\n                  (focus X p)) \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. except t X) ` keys p", "hence \"lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p))\n\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t \\<noteq>\n    (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys\n                (poly_eval (\\<lambda>x. monomial (a x) 0)\n                  (focus X p)) \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. except t X) ` keys p", "hence \"poly_eval a (lookup (focus (- X) p) t) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lookup (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)) t \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. poly_eval a (lookup (focus (- X) p) t) \\<noteq> (0::'b)", "by (simp add: lookup_poly_eval_focus)"], ["proof (state)\nthis:\n  poly_eval a (lookup (focus (- X) p) t) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys\n                (poly_eval (\\<lambda>x. monomial (a x) 0)\n                  (focus X p)) \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. except t X) ` keys p", "hence \"t \\<in> keys (focus (- X) p)\""], ["proof (prove)\nusing this:\n  poly_eval a (lookup (focus (- X) p) t) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (focus (- X) p)", "by (auto simp flip: lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  t \\<in> keys (focus (- X) p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys\n                (poly_eval (\\<lambda>x. monomial (a x) 0)\n                  (focus X p)) \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. except t X) ` keys p", "thus \"t \\<in> (\\<lambda>t. except t X) ` keys p\""], ["proof (prove)\nusing this:\n  t \\<in> keys (focus (- X) p)\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<lambda>t. except t X) ` keys p", "by (simp add: keys_focus)"], ["proof (state)\nthis:\n  t \\<in> (\\<lambda>t. except t X) ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_eval_focus_in_Polys:\n  assumes \"p \\<in> P[X]\"\n  shows \"poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p) \\<in> P[X - Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p) \\<in> P[X - Y]", "proof (rule PolysI_alt)"], ["proof (state)\ngoal (1 subgoal):\n 1. indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n    \\<subseteq> X - Y", "have \"indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p)) \\<subseteq>\n          \\<Union> (indets ` (\\<lambda>x. monomial (a x) 0) ` Y) \\<union> (indets p - Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n    \\<subseteq> \\<Union>\n                 (indets ` (\\<lambda>x. monomial (a x) 0) ` Y) \\<union>\n                (indets p - Y)", "by (fact indets_poly_eval_focus_subset)"], ["proof (state)\nthis:\n  indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n  \\<subseteq> \\<Union>\n               (indets ` (\\<lambda>x. monomial (a x) 0) ` Y) \\<union>\n              (indets p - Y)\n\ngoal (1 subgoal):\n 1. indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n    \\<subseteq> X - Y", "also"], ["proof (state)\nthis:\n  indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n  \\<subseteq> \\<Union>\n               (indets ` (\\<lambda>x. monomial (a x) 0) ` Y) \\<union>\n              (indets p - Y)\n\ngoal (1 subgoal):\n 1. indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n    \\<subseteq> X - Y", "have \"\\<dots> = indets p - Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (indets ` (\\<lambda>x. monomial (a x) 0) ` Y) \\<union>\n    (indets p - Y) =\n    indets p - Y", "by simp"], ["proof (state)\nthis:\n  \\<Union> (indets ` (\\<lambda>x. monomial (a x) 0) ` Y) \\<union>\n  (indets p - Y) =\n  indets p - Y\n\ngoal (1 subgoal):\n 1. indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n    \\<subseteq> X - Y", "also"], ["proof (state)\nthis:\n  \\<Union> (indets ` (\\<lambda>x. monomial (a x) 0) ` Y) \\<union>\n  (indets p - Y) =\n  indets p - Y\n\ngoal (1 subgoal):\n 1. indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n    \\<subseteq> X - Y", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[X]", "have \"\\<dots> \\<subseteq> X - Y\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. indets p - Y \\<subseteq> X - Y", "by (auto dest: PolysD)"], ["proof (state)\nthis:\n  indets p - Y \\<subseteq> X - Y\n\ngoal (1 subgoal):\n 1. indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n    \\<subseteq> X - Y", "finally"], ["proof (chain)\npicking this:\n  indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n  \\<subseteq> X - Y", "show \"indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p)) \\<subseteq> X - Y\""], ["proof (prove)\nusing this:\n  indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n  \\<subseteq> X - Y\n\ngoal (1 subgoal):\n 1. indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n    \\<subseteq> X - Y", "."], ["proof (state)\nthis:\n  indets (poly_eval (\\<lambda>x. monomial (a x) 0) (focus Y p))\n  \\<subseteq> X - Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_poly_eval_focus_ideal:\n  \"poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n      (P[- X]::(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "let ?h = \"\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "have h_id: \"?h p = p\" if \"p \\<in> P[- X]\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p", "from that"], ["proof (chain)\npicking this:\n  p \\<in> P[- X]", "have \"focus X p \\<in> P[- X \\<inter> X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[- X]\n\ngoal (1 subgoal):\n 1. focus X p \\<in> P[- X \\<inter> X]", "by (rule focus_in_Polys')"], ["proof (state)\nthis:\n  focus X p \\<in> P[- X \\<inter> X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p", "also"], ["proof (state)\nthis:\n  focus X p \\<in> P[- X \\<inter> X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p", "have \"\\<dots> = P[{}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[- X \\<inter> X] = P[{}]", "by simp"], ["proof (state)\nthis:\n  P[- X \\<inter> X] = P[{}]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p", "finally"], ["proof (chain)\npicking this:\n  focus X p \\<in> P[{}]", "obtain c where eq: \"focus X p = monomial c 0\""], ["proof (prove)\nusing this:\n  focus X p \\<in> P[{}]\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        focus X p = monomial c 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Polys_empty"], ["proof (prove)\nusing this:\n  focus X p \\<in> range (Poly_Mapping.single 0)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        focus X p = monomial c 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  focus X p = monomial c 0\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p", "hence \"flatten (focus X p) = flatten (monomial c 0)\""], ["proof (prove)\nusing this:\n  focus X p = monomial c 0\n\ngoal (1 subgoal):\n 1. flatten (focus X p) = flatten (monomial c 0)", "by (rule arg_cong)"], ["proof (state)\nthis:\n  flatten (focus X p) = flatten (monomial c 0)\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p", "hence \"c = p\""], ["proof (prove)\nusing this:\n  flatten (focus X p) = flatten (monomial c 0)\n\ngoal (1 subgoal):\n 1. c = p", "by (simp add: flatten_monomial)"], ["proof (state)\nthis:\n  c = p\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p", "thus \"?h p = p\""], ["proof (prove)\nusing this:\n  c = p\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p", "by (simp add: eq poly_eval_monomial)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?p \\<in> P[- X] \\<Longrightarrow>\n  poly_eval (\\<lambda>x. monomial (a x) 0) (focus X ?p) = ?p\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "have rng: \"range ?h = P[- X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range\n     (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) =\n    P[- X]", "proof (intro subset_antisym subsetI, elim rangeE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x f.\n       x =\n       poly_eval (\\<lambda>x. monomial (a x) 0)\n        (focus X f) \\<Longrightarrow>\n       x \\<in> P[- X]\n 2. \\<And>x.\n       x \\<in> P[- X] \\<Longrightarrow>\n       x \\<in> range\n                (\\<lambda>f.\n                    poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "fix b f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x f.\n       x =\n       poly_eval (\\<lambda>x. monomial (a x) 0)\n        (focus X f) \\<Longrightarrow>\n       x \\<in> P[- X]\n 2. \\<And>x.\n       x \\<in> P[- X] \\<Longrightarrow>\n       x \\<in> range\n                (\\<lambda>f.\n                    poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "assume b: \"b = ?h f\""], ["proof (state)\nthis:\n  b = poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)\n\ngoal (2 subgoals):\n 1. \\<And>x f.\n       x =\n       poly_eval (\\<lambda>x. monomial (a x) 0)\n        (focus X f) \\<Longrightarrow>\n       x \\<in> P[- X]\n 2. \\<And>x.\n       x \\<in> P[- X] \\<Longrightarrow>\n       x \\<in> range\n                (\\<lambda>f.\n                    poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "have \"?h f \\<in> P[UNIV - X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f) \\<in> P[UNIV - X]", "by (rule poly_eval_focus_in_Polys) simp"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f) \\<in> P[UNIV - X]\n\ngoal (2 subgoals):\n 1. \\<And>x f.\n       x =\n       poly_eval (\\<lambda>x. monomial (a x) 0)\n        (focus X f) \\<Longrightarrow>\n       x \\<in> P[- X]\n 2. \\<And>x.\n       x \\<in> P[- X] \\<Longrightarrow>\n       x \\<in> range\n                (\\<lambda>f.\n                    poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "thus \"b \\<in> P[- X]\""], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f) \\<in> P[UNIV - X]\n\ngoal (1 subgoal):\n 1. b \\<in> P[- X]", "by (simp add: b Compl_eq_Diff_UNIV)"], ["proof (state)\nthis:\n  b \\<in> P[- X]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> P[- X] \\<Longrightarrow>\n       x \\<in> range\n                (\\<lambda>f.\n                    poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> P[- X] \\<Longrightarrow>\n       x \\<in> range\n                (\\<lambda>f.\n                    poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "fix p :: \"('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> P[- X] \\<Longrightarrow>\n       x \\<in> range\n                (\\<lambda>f.\n                    poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "assume \"p \\<in> P[- X]\""], ["proof (state)\nthis:\n  p \\<in> P[- X]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> P[- X] \\<Longrightarrow>\n       x \\<in> range\n                (\\<lambda>f.\n                    poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "hence \"?h p = p\""], ["proof (prove)\nusing this:\n  p \\<in> P[- X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p", "by (rule h_id)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> P[- X] \\<Longrightarrow>\n       x \\<in> range\n                (\\<lambda>f.\n                    poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "hence \"p = ?h p\""], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) = p\n\ngoal (1 subgoal):\n 1. p = poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)", "by (rule sym)"], ["proof (state)\nthis:\n  p = poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> P[- X] \\<Longrightarrow>\n       x \\<in> range\n                (\\<lambda>f.\n                    poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "thus \"p \\<in> range ?h\""], ["proof (prove)\nusing this:\n  p = poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)\n\ngoal (1 subgoal):\n 1. p \\<in> range\n             (\\<lambda>f.\n                 poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "by (rule range_eqI)"], ["proof (state)\nthis:\n  p \\<in> range\n           (\\<lambda>f.\n               poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) =\n  P[- X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "have \"poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F = ?h ` ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) `\n    ideal F", "by (fact image_image)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n  (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) `\n  ideal F\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "also"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n  (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) `\n  ideal F\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "have \"\\<dots> = ideal (?h ` F) \\<inter> range ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) `\n    ideal F =\n    ideal\n     ((\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) `\n      F) \\<inter>\n    range (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "proof (rule image_ideal_eq_Int)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x + y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) +\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)\n 2. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x * y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) *\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)\n 3. \\<And>x.\n       poly_eval (\\<lambda>x. monomial (a x) 0)\n        (focus X (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x))) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x)", "fix p"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x + y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) +\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)\n 2. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x * y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) *\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)\n 3. \\<And>x.\n       poly_eval (\\<lambda>x. monomial (a x) 0)\n        (focus X (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x))) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x)", "have \"?h p \\<in> range ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)\n    \\<in> range\n           (\\<lambda>f.\n               poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))", "by (fact rangeI)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)\n  \\<in> range\n         (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x + y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) +\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)\n 2. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x * y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) *\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)\n 3. \\<And>x.\n       poly_eval (\\<lambda>x. monomial (a x) 0)\n        (focus X (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x))) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x)", "also"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)\n  \\<in> range\n         (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x + y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) +\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)\n 2. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x * y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) *\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)\n 3. \\<And>x.\n       poly_eval (\\<lambda>x. monomial (a x) 0)\n        (focus X (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x))) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x)", "have \"\\<dots> = P[- X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range\n     (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) =\n    P[- X]", "by fact"], ["proof (state)\nthis:\n  range (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) =\n  P[- X]\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x + y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) +\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)\n 2. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x * y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) *\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)\n 3. \\<And>x.\n       poly_eval (\\<lambda>x. monomial (a x) 0)\n        (focus X (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x))) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x)", "finally"], ["proof (chain)\npicking this:\n  poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) \\<in> P[- X]", "show \"?h (?h p) = ?h p\""], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p) \\<in> P[- X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0)\n     (focus X (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p))) =\n    poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)", "by (rule h_id)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>x. monomial (a x) 0)\n   (focus X (poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p))) =\n  poly_eval (\\<lambda>x. monomial (a x) 0) (focus X p)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x + y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) +\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)\n 2. \\<And>x y.\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X (x * y)) =\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X x) *\n       poly_eval (\\<lambda>x. monomial (a x) 0) (focus X y)", "qed (simp_all only: focus_plus poly_eval_plus focus_times poly_eval_times)"], ["proof (state)\nthis:\n  (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) `\n  ideal F =\n  ideal\n   ((\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) `\n    F) \\<inter>\n  range (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "also"], ["proof (state)\nthis:\n  (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) `\n  ideal F =\n  ideal\n   ((\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) `\n    F) \\<inter>\n  range (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f))\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "have \"\\<dots> = ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter> P[- X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal\n     ((\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) `\n      F) \\<inter>\n    range\n     (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "by (simp only: image_image rng)"], ["proof (state)\nthis:\n  ideal\n   ((\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) `\n    F) \\<inter>\n  range (\\<lambda>f. poly_eval (\\<lambda>x. monomial (a x) 0) (focus X f)) =\n  ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n  P[- X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "finally"], ["proof (chain)\npicking this:\n  poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n  ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n  P[- X]", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n  ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n  P[- X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n    ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n    P[- X]", "."], ["proof (state)\nthis:\n  poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` ideal F =\n  ideal (poly_eval (\\<lambda>x. monomial (a x) 0) ` focus X ` F) \\<inter>\n  P[- X]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Locale @{term pm_powerprod}\\<close>"], ["", "lemma varnum_eq_zero_iff: \"varnum X t = 0 \\<longleftrightarrow> t \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (varnum X t = 0) = (t \\<in> .[X])", "by (auto simp: varnum_def PPs_def)"], ["", "lemma dgrad_set_varnum: \"dgrad_set (varnum X) 0 = .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_set (varnum X) 0 = .[X]", "by (simp add: dgrad_set_def PPs_def varnum_eq_zero_iff)"], ["", "context ordered_powerprod\nbegin"], ["", "abbreviation \"lcf \\<equiv> punit.lc\""], ["", "abbreviation \"tcf \\<equiv> punit.tc\""], ["", "abbreviation \"lpp \\<equiv> punit.lt\""], ["", "abbreviation \"tpp \\<equiv> punit.tt\""], ["", "end"], ["", "(* ordered_powerprod *)"], ["", "locale pm_powerprod =\n  ordered_powerprod ord ord_strict\n  for ord::\"('x::{countable,linorder} \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> ('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> bool\" (infixl \"\\<preceq>\" 50)\n  and ord_strict (infixl \"\\<prec>\" 50)\nbegin"], ["", "sublocale gd_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. gd_powerprod (\\<preceq>) (\\<prec>)", ".."], ["", "lemma PPs_closed_lpp:\n  assumes \"p \\<in> P[X]\"\n  shows \"lpp p \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lpp p \\<in> .[X]", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> lpp p \\<in> .[X]\n 2. p \\<noteq> 0 \\<Longrightarrow> lpp p \\<in> .[X]", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> lpp p \\<in> .[X]\n 2. p \\<noteq> 0 \\<Longrightarrow> lpp p \\<in> .[X]", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. lpp p \\<in> .[X]", "by (simp add: zero_in_PPs)"], ["proof (state)\nthis:\n  lpp p \\<in> .[X]\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> lpp p \\<in> .[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> lpp p \\<in> .[X]", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> lpp p \\<in> .[X]", "hence \"lpp p \\<in> keys p\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp p \\<in> keys p", "by (rule punit.lt_in_keys)"], ["proof (state)\nthis:\n  lpp p \\<in> keys p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> lpp p \\<in> .[X]", "also"], ["proof (state)\nthis:\n  lpp p \\<in> keys p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> lpp p \\<in> .[X]", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[X]", "have \"\\<dots> \\<subseteq> .[X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[X]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> lpp p \\<in> .[X]", "finally"], ["proof (chain)\npicking this:\n  lpp p \\<in> .[X]", "show ?thesis"], ["proof (prove)\nusing this:\n  lpp p \\<in> .[X]\n\ngoal (1 subgoal):\n 1. lpp p \\<in> .[X]", "."], ["proof (state)\nthis:\n  lpp p \\<in> .[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PPs_closed_tpp:\n  assumes \"p \\<in> P[X]\"\n  shows \"tpp p \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tpp p \\<in> .[X]", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> tpp p \\<in> .[X]\n 2. p \\<noteq> 0 \\<Longrightarrow> tpp p \\<in> .[X]", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> tpp p \\<in> .[X]\n 2. p \\<noteq> 0 \\<Longrightarrow> tpp p \\<in> .[X]", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. tpp p \\<in> .[X]", "by (simp add: zero_in_PPs)"], ["proof (state)\nthis:\n  tpp p \\<in> .[X]\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> tpp p \\<in> .[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> tpp p \\<in> .[X]", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> tpp p \\<in> .[X]", "hence \"tpp p \\<in> keys p\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. tpp p \\<in> keys p", "by (rule punit.tt_in_keys)"], ["proof (state)\nthis:\n  tpp p \\<in> keys p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> tpp p \\<in> .[X]", "also"], ["proof (state)\nthis:\n  tpp p \\<in> keys p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> tpp p \\<in> .[X]", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[X]", "have \"\\<dots> \\<subseteq> .[X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[X]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> tpp p \\<in> .[X]", "finally"], ["proof (chain)\npicking this:\n  tpp p \\<in> .[X]", "show ?thesis"], ["proof (prove)\nusing this:\n  tpp p \\<in> .[X]\n\ngoal (1 subgoal):\n 1. tpp p \\<in> .[X]", "."], ["proof (state)\nthis:\n  tpp p \\<in> .[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary PPs_closed_image_lpp: \"F \\<subseteq> P[X] \\<Longrightarrow> lpp ` F \\<subseteq> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> P[X] \\<Longrightarrow> lpp ` F \\<subseteq> .[X]", "by (auto intro: PPs_closed_lpp)"], ["", "corollary PPs_closed_image_tpp: \"F \\<subseteq> P[X] \\<Longrightarrow> tpp ` F \\<subseteq> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> P[X] \\<Longrightarrow> tpp ` F \\<subseteq> .[X]", "by (auto intro: PPs_closed_tpp)"], ["", "lemma hom_component_lpp:\n  assumes \"p \\<noteq> 0\"\n  shows \"hom_component p (deg_pm (lpp p)) \\<noteq> 0\" (is \"?p \\<noteq> 0\")\n    and \"lpp (hom_component p (deg_pm (lpp p))) = lpp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component p (deg_pm (lpp p)) \\<noteq> 0 &&&\n    lpp (hom_component p (deg_pm (lpp p))) = lpp p", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. hom_component p (deg_pm (lpp p)) \\<noteq> 0\n 2. lpp (hom_component p (deg_pm (lpp p))) = lpp p", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"lpp p \\<in> keys p\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp p \\<in> keys p", "by (rule punit.lt_in_keys)"], ["proof (state)\nthis:\n  lpp p \\<in> keys p\n\ngoal (2 subgoals):\n 1. hom_component p (deg_pm (lpp p)) \\<noteq> 0\n 2. lpp (hom_component p (deg_pm (lpp p))) = lpp p", "hence *: \"lpp p \\<in> keys ?p\""], ["proof (prove)\nusing this:\n  lpp p \\<in> keys p\n\ngoal (1 subgoal):\n 1. lpp p \\<in> keys (hom_component p (deg_pm (lpp p)))", "by (simp add: keys_hom_component)"], ["proof (state)\nthis:\n  lpp p \\<in> keys (hom_component p (deg_pm (lpp p)))\n\ngoal (2 subgoals):\n 1. hom_component p (deg_pm (lpp p)) \\<noteq> 0\n 2. lpp (hom_component p (deg_pm (lpp p))) = lpp p", "thus \"?p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lpp p \\<in> keys (hom_component p (deg_pm (lpp p)))\n\ngoal (1 subgoal):\n 1. hom_component p (deg_pm (lpp p)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  hom_component p (deg_pm (lpp p)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp (hom_component p (deg_pm (lpp p))) = lpp p", "from *"], ["proof (chain)\npicking this:\n  lpp p \\<in> keys (hom_component p (deg_pm (lpp p)))", "show \"lpp ?p = lpp p\""], ["proof (prove)\nusing this:\n  lpp p \\<in> keys (hom_component p (deg_pm (lpp p)))\n\ngoal (1 subgoal):\n 1. lpp (hom_component p (deg_pm (lpp p))) = lpp p", "proof (rule punit.lt_eqI_keys)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (hom_component p (deg_pm (lpp p))) \\<Longrightarrow>\n       u \\<preceq> lpp p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (hom_component p (deg_pm (lpp p))) \\<Longrightarrow>\n       u \\<preceq> lpp p", "assume \"t \\<in> keys ?p\""], ["proof (state)\nthis:\n  t \\<in> keys (hom_component p (deg_pm (lpp p)))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (hom_component p (deg_pm (lpp p))) \\<Longrightarrow>\n       u \\<preceq> lpp p", "hence \"t \\<in> keys p\""], ["proof (prove)\nusing this:\n  t \\<in> keys (hom_component p (deg_pm (lpp p)))\n\ngoal (1 subgoal):\n 1. t \\<in> keys p", "by (simp add: keys_hom_component)"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (hom_component p (deg_pm (lpp p))) \\<Longrightarrow>\n       u \\<preceq> lpp p", "thus \"t \\<preceq> lpp p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. t \\<preceq> lpp p", "by (rule punit.lt_max_keys)"], ["proof (state)\nthis:\n  t \\<preceq> lpp p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lpp (hom_component p (deg_pm (lpp p))) = lpp p\n\ngoal:\nNo subgoals!", "qed"], ["", "definition is_hom_ord :: \"'x \\<Rightarrow> bool\"\n  where \"is_hom_ord x \\<longleftrightarrow> (\\<forall>s t. deg_pm s = deg_pm t \\<longrightarrow> (s \\<preceq> t \\<longleftrightarrow> except s {x} \\<preceq> except t {x}))\""], ["", "lemma is_hom_ordD: \"is_hom_ord x \\<Longrightarrow> deg_pm s = deg_pm t \\<Longrightarrow> s \\<preceq> t \\<longleftrightarrow> except s {x} \\<preceq> except t {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_hom_ord x; deg_pm s = deg_pm t\\<rbrakk>\n    \\<Longrightarrow> (s \\<preceq> t) =\n                      (except s {x} \\<preceq> except t {x})", "by (simp add: is_hom_ord_def)"], ["", "lemma dgrad_p_set_varnum: \"punit.dgrad_p_set (varnum X) 0 = P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.dgrad_p_set (varnum X) 0 = P[X]", "by (simp add: punit.dgrad_p_set_def dgrad_set_varnum Polys_def)"], ["", "end"], ["", "text \\<open>We must create a copy of @{locale pm_powerprod} to avoid infinite chains of interpretations.\\<close>"], ["", "instantiation option :: (linorder) linorder\nbegin"], ["", "fun less_eq_option :: \"'a option \\<Rightarrow> 'a option \\<Rightarrow> bool\" where\n  \"less_eq_option None _ = True\" |\n  \"less_eq_option (Some x) None = False\" |\n  \"less_eq_option (Some x) (Some y) = (x \\<le> y)\""], ["", "definition less_option :: \"'a option \\<Rightarrow> 'a option \\<Rightarrow> bool\"\n  where \"less_option x y \\<longleftrightarrow> x \\<le> y \\<and> \\<not> y \\<le> x\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, linorder_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = strict (\\<le>) x y\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "fix x :: \"'a option\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = strict (\\<le>) x y\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "show \"x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "using less_eq_option.elims(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?x \\<le> ?xa;\n   \\<And>x. \\<lbrakk>?x = Some x; ?xa = None\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>x y.\n      \\<lbrakk>?x = Some x; ?xa = Some y; \\<not> x \\<le> y\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. x \\<le> x", "by fastforce"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = strict (\\<le>) x y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "qed (auto simp: less_option_def elim!: less_eq_option.elims)"], ["", "end"], ["", "locale extended_ord_pm_powerprod = pm_powerprod\nbegin"], ["", "definition extended_ord :: \"('a option \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> ('a option \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> bool\"\n  where \"extended_ord s t \\<longleftrightarrow> (restrict_indets_pp s \\<prec> restrict_indets_pp t \\<or>\n                          (restrict_indets_pp s = restrict_indets_pp t \\<and> lookup s None \\<le> lookup t None))\""], ["", "definition extended_ord_strict :: \"('a option \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> ('a option \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> bool\"\n  where \"extended_ord_strict s t \\<longleftrightarrow> (restrict_indets_pp s \\<prec> restrict_indets_pp t \\<or>\n                          (restrict_indets_pp s = restrict_indets_pp t \\<and> lookup s None < lookup t None))\""], ["", "sublocale extended_ord: pm_powerprod extended_ord extended_ord_strict"], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_powerprod extended_ord extended_ord_strict", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pm_powerprod extended_ord extended_ord_strict", "have 1: \"s = t\" if \"lookup s None = lookup t None\" and \"restrict_indets_pp s = restrict_indets_pp t\"\n    for s t :: \"'a option \\<Rightarrow>\\<^sub>0 nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup s k = lookup t k", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup s k = lookup t k", "show \"lookup s y = lookup t y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup s y = lookup t y", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. y = None \\<Longrightarrow> lookup s y = lookup t y\n 2. \\<And>a. y = Some a \\<Longrightarrow> lookup s y = lookup t y", "case None"], ["proof (state)\nthis:\n  y = None\n\ngoal (2 subgoals):\n 1. y = None \\<Longrightarrow> lookup s y = lookup t y\n 2. \\<And>a. y = Some a \\<Longrightarrow> lookup s y = lookup t y", "with that(1)"], ["proof (chain)\npicking this:\n  lookup s None = lookup t None\n  y = None", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup s None = lookup t None\n  y = None\n\ngoal (1 subgoal):\n 1. lookup s y = lookup t y", "by simp"], ["proof (state)\nthis:\n  lookup s y = lookup t y\n\ngoal (1 subgoal):\n 1. \\<And>a. y = Some a \\<Longrightarrow> lookup s y = lookup t y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. y = Some a \\<Longrightarrow> lookup s y = lookup t y", "case y: (Some z)"], ["proof (state)\nthis:\n  y = Some z\n\ngoal (1 subgoal):\n 1. \\<And>a. y = Some a \\<Longrightarrow> lookup s y = lookup t y", "have \"lookup s y = lookup (restrict_indets_pp s) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup s y = lookup (restrict_indets_pp s) z", "by (simp only: lookup_restrict_indets_pp y)"], ["proof (state)\nthis:\n  lookup s y = lookup (restrict_indets_pp s) z\n\ngoal (1 subgoal):\n 1. \\<And>a. y = Some a \\<Longrightarrow> lookup s y = lookup t y", "also"], ["proof (state)\nthis:\n  lookup s y = lookup (restrict_indets_pp s) z\n\ngoal (1 subgoal):\n 1. \\<And>a. y = Some a \\<Longrightarrow> lookup s y = lookup t y", "have \"\\<dots> = lookup (restrict_indets_pp t) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (restrict_indets_pp s) z = lookup (restrict_indets_pp t) z", "by (simp only: that(2))"], ["proof (state)\nthis:\n  lookup (restrict_indets_pp s) z = lookup (restrict_indets_pp t) z\n\ngoal (1 subgoal):\n 1. \\<And>a. y = Some a \\<Longrightarrow> lookup s y = lookup t y", "also"], ["proof (state)\nthis:\n  lookup (restrict_indets_pp s) z = lookup (restrict_indets_pp t) z\n\ngoal (1 subgoal):\n 1. \\<And>a. y = Some a \\<Longrightarrow> lookup s y = lookup t y", "have \"\\<dots> = lookup t y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (restrict_indets_pp t) z = lookup t y", "by (simp only: lookup_restrict_indets_pp y)"], ["proof (state)\nthis:\n  lookup (restrict_indets_pp t) z = lookup t y\n\ngoal (1 subgoal):\n 1. \\<And>a. y = Some a \\<Longrightarrow> lookup s y = lookup t y", "finally"], ["proof (chain)\npicking this:\n  lookup s y = lookup t y", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup s y = lookup t y\n\ngoal (1 subgoal):\n 1. lookup s y = lookup t y", "."], ["proof (state)\nthis:\n  lookup s y = lookup t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup s y = lookup t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>lookup ?s5 None = lookup ?t5 None;\n   restrict_indets_pp ?s5 = restrict_indets_pp ?t5\\<rbrakk>\n  \\<Longrightarrow> ?s5 = ?t5\n\ngoal (1 subgoal):\n 1. pm_powerprod extended_ord extended_ord_strict", "have 2: \"0 \\<prec> t\" if \"t \\<noteq> 0\" for t::\"'a \\<Rightarrow>\\<^sub>0 nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<prec> t", "using that zero_min"], ["proof (prove)\nusing this:\n  t \\<noteq> 0\n  0 \\<preceq> ?t\n\ngoal (1 subgoal):\n 1. 0 \\<prec> t", "by (rule ordered_powerprod_lin.dual_order.not_eq_order_implies_strict)"], ["proof (state)\nthis:\n  ?t5 \\<noteq> 0 \\<Longrightarrow> 0 \\<prec> ?t5\n\ngoal (1 subgoal):\n 1. pm_powerprod extended_ord extended_ord_strict", "show \"pm_powerprod extended_ord extended_ord_strict\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_powerprod extended_ord extended_ord_strict", "by standard (auto simp: extended_ord_def extended_ord_strict_def restrict_indets_pp_plus lookup_add 1\n                  dest: plus_monotone_strict 2)"], ["proof (state)\nthis:\n  pm_powerprod extended_ord extended_ord_strict\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_ord_is_hom_ord: \"extended_ord.is_hom_ord None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_ord.is_hom_ord None", "by (auto simp add: extended_ord_def lookup_restrict_indets_pp lookup_except extended_ord.is_hom_ord_def\n            simp flip: deg_pm_restrict_indets_pp)"], ["", "end"], ["", "end"], ["", "(* theory *)"]]}