{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/MPoly_Type_Class.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma when_distrib: \"f (a when b) = (f a when b)\" if \"\\<not> b \\<Longrightarrow> f 0 = 0\"", "lemma lookup_mapp_2:\n  \"lookup (mapp_2 f p q) k = (f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)\"", "lemma lookup_mapp_2_homogenous:\n  assumes \"f k 0 0 = 0\"\n  shows \"lookup (mapp_2 f p q) k = f k (lookup p k) (lookup q k)\"", "lemma mapp_2_cong [fundef_cong]:\n  assumes \"p = p'\" and \"q = q'\"\n  assumes \"\\<And>k. k \\<in> keys p' \\<union> keys q' \\<Longrightarrow> f k (lookup p' k) (lookup q' k) = f' k (lookup p' k) (lookup q' k)\"\n  shows \"mapp_2 f p q = mapp_2 f' p' q'\"", "lemma keys_mapp_subset: \"keys (mapp_2 f p q) \\<subseteq> keys p \\<union> keys q\"", "lemma mapp_2_mapp: \"mapp_2 (\\<lambda>t a. f t) 0 p = Poly_Mapping.mapp f p\"", "lemma in_keys_plusI1:\n  assumes \"t \\<in> keys p\" and \"t \\<notin> keys q\"\n  shows \"t \\<in> keys (p + q)\"", "lemma in_keys_plusI2:\n  assumes \"t \\<in> keys q\" and \"t \\<notin> keys p\"\n  shows \"t \\<in> keys (p + q)\"", "lemma keys_plus_eqI:\n  assumes \"keys p \\<inter> keys q = {}\"\n  shows \"keys (p + q) = (keys p \\<union> keys q)\"", "lemma keys_uminus: \"keys (- p) = keys p\"", "lemma keys_minus: \"keys (p - q) \\<subseteq> (keys p \\<union> keys q)\"", "lemma keys_of_monomial:\n  assumes \"c \\<noteq> 0\"\n  shows \"keys (monomial c t) = {t}\"", "lemma monomial_uminus:\n  shows \"- monomial c s = monomial (- c) s\"", "lemma monomial_inj:\n  assumes \"monomial c s = monomial (d::'b::zero_neq_one) t\"\n  shows \"(c = 0 \\<and> d = 0) \\<or> (c = d \\<and> s = t)\"", "lemma monomial_is_monomial:\n  assumes \"c \\<noteq> 0\"\n  shows \"is_monomial (monomial c t)\"", "lemma is_monomial_monomial:\n  assumes \"is_monomial p\"\n  obtains c t where \"c \\<noteq> 0\" and \"p = monomial c t\"", "lemma is_monomial_uminus: \"is_monomial (-p) \\<longleftrightarrow> is_monomial p\"", "lemma monomial_not_0:\n  assumes \"is_monomial p\"\n  shows \"p \\<noteq> 0\"", "lemma keys_subset_singleton_imp_monomial:\n  assumes \"keys p \\<subseteq> {t}\"\n  shows \"monomial (lookup p t) t = p\"", "lemma monomial_0I:\n  assumes \"c = 0\"\n  shows \"monomial c t = 0\"", "lemma monomial_0D:\n  assumes \"monomial c t = 0\"\n  shows \"c = 0\"", "lemma lookup_times_monomial_left: \"lookup (monomial c t * p) s = (c * lookup p (s - t) when t adds s)\"\n  for c::\"'b::semiring_0\" and t::\"'a::comm_powerprod\"", "lemma lookup_times_monomial_right: \"lookup (p * monomial c t) s = (lookup p (s - t) * c when t adds s)\"\n  for c::\"'b::semiring_0\" and t::\"'a::comm_powerprod\"", "lemma pair_of_term_injective:\n  assumes \"pair_of_term u = pair_of_term v\"\n  shows \"u = v\"", "lemma term_of_pair_injective:\n  assumes \"term_of_pair p = term_of_pair q\"\n  shows \"p = q\"", "lemma term_of_pair_pair [term_simps]: \"term_of_pair (pp_of_term v, component_of_term v) = v\"", "lemma pp_of_term_of_pair [term_simps]: \"pp_of_term (term_of_pair (t, k)) = t\"", "lemma component_of_term_of_pair [term_simps]: \"component_of_term (term_of_pair (t, k)) = k\"", "lemma pp_of_term_splus [term_simps]: \"pp_of_term (t \\<oplus> v) = t + pp_of_term v\"", "lemma component_of_term_splus [term_simps]: \"component_of_term (t \\<oplus> v) = component_of_term v\"", "lemma pp_of_term_sminus [term_simps]: \"pp_of_term (v \\<ominus> t) = pp_of_term v - t\"", "lemma component_of_term_sminus [term_simps]: \"component_of_term (v \\<ominus> t) = component_of_term v\"", "lemma splus_sminus [term_simps]: \"(t \\<oplus> v) \\<ominus> t = v\"", "lemma splus_zero [term_simps]: \"0 \\<oplus> v = v\"", "lemma sminus_zero [term_simps]: \"v \\<ominus> 0 = v\"", "lemma splus_assoc [ac_simps]: \"(s + t) \\<oplus> v = s \\<oplus> (t \\<oplus> v)\"", "lemma splus_left_commute [ac_simps]: \"s \\<oplus> (t \\<oplus> v) = t \\<oplus> (s \\<oplus> v)\"", "lemma splus_right_canc [term_simps]: \"t \\<oplus> v = s \\<oplus> v \\<longleftrightarrow> t = s\"", "lemma splus_left_canc [term_simps]: \"t \\<oplus> v = t \\<oplus> u \\<longleftrightarrow> v = u\"", "lemma adds_ppI [intro?]:\n  assumes \"v = t \\<oplus> u\"\n  shows \"t adds\\<^sub>p v\"", "lemma adds_ppE [elim?]:\n  assumes \"t adds\\<^sub>p v\"\n  obtains u where \"v = t \\<oplus> u\"", "lemma adds_pp_alt: \"t adds\\<^sub>p v \\<longleftrightarrow> (\\<exists>u. v = t \\<oplus> u)\"", "lemma adds_pp_refl [term_simps]: \"(pp_of_term v) adds\\<^sub>p v\"", "lemma adds_pp_trans [trans]:\n  assumes \"s adds t\" and \"t adds\\<^sub>p v\"\n  shows \"s adds\\<^sub>p v\"", "lemma zero_adds_pp [term_simps]: \"0 adds\\<^sub>p v\"", "lemma adds_pp_splus:\n  assumes \"t adds\\<^sub>p v\"\n  shows \"t adds\\<^sub>p s \\<oplus> v\"", "lemma adds_pp_triv [term_simps]: \"t adds\\<^sub>p t \\<oplus> v\"", "lemma plus_adds_pp_mono:\n  assumes \"s adds t\"\n    and \"u adds\\<^sub>p v\"\n  shows \"s + u adds\\<^sub>p t \\<oplus> v\"", "lemma plus_adds_pp_left:\n  assumes \"s + t adds\\<^sub>p v\"\n  shows \"s adds\\<^sub>p v\"", "lemma plus_adds_pp_right:\n  assumes \"s + t adds\\<^sub>p v\"\n  shows \"t adds\\<^sub>p v\"", "lemma adds_pp_sminus:\n  assumes \"t adds\\<^sub>p v\"\n  shows \"t \\<oplus> (v \\<ominus> t) = v\"", "lemma adds_pp_canc: \"t + s adds\\<^sub>p (t \\<oplus> v) \\<longleftrightarrow> s adds\\<^sub>p v\"", "lemma adds_pp_canc_2: \"s + t adds\\<^sub>p (t \\<oplus> v) \\<longleftrightarrow> s adds\\<^sub>p v\"", "lemma plus_adds_pp_0:\n  assumes \"(s + t) adds\\<^sub>p v\"\n  shows \"s adds\\<^sub>p (v \\<ominus> t)\"", "lemma plus_adds_ppI_1:\n  assumes \"t adds\\<^sub>p v\" and \"s adds\\<^sub>p (v \\<ominus> t)\"\n  shows \"(s + t) adds\\<^sub>p v\"", "lemma plus_adds_ppI_2:\n  assumes \"t adds\\<^sub>p v\" and \"s adds\\<^sub>p (v \\<ominus> t)\"\n  shows \"(t + s) adds\\<^sub>p v\"", "lemma plus_adds_pp: \"(s + t) adds\\<^sub>p v \\<longleftrightarrow> (t adds\\<^sub>p v \\<and> s adds\\<^sub>p (v \\<ominus> t))\"", "lemma minus_splus:\n  assumes \"s adds t\"\n  shows \"(t - s) \\<oplus> v = (t \\<oplus> v) \\<ominus> s\"", "lemma minus_splus_sminus:\n  assumes \"s adds t\" and \"u adds\\<^sub>p v\"\n  shows \"(t - s) \\<oplus> (v \\<ominus> u) = (t \\<oplus> v) \\<ominus> (s + u)\"", "lemma minus_splus_sminus_cancel:\n  assumes \"s adds t\" and \"t adds\\<^sub>p v\"\n  shows \"(t - s) \\<oplus> (v \\<ominus> t) = v \\<ominus> s\"", "lemma sminus_plus:\n  assumes \"s adds\\<^sub>p v\" and \"t adds\\<^sub>p (v \\<ominus> s)\"\n  shows \"v \\<ominus> (s + t) = (v \\<ominus> s) \\<ominus> t\"", "lemma adds_termI [intro?]:\n  assumes \"v = t \\<oplus> u\"\n  shows \"u adds\\<^sub>t v\"", "lemma adds_termE [elim?]:\n  assumes \"u adds\\<^sub>t v\"\n  obtains t where \"v = t \\<oplus> u\"", "lemma adds_term_alt: \"u adds\\<^sub>t v \\<longleftrightarrow> (\\<exists>t. v = t \\<oplus> u)\"", "lemma adds_term_refl [term_simps]: \"v adds\\<^sub>t v\"", "lemma adds_term_trans [trans]:\n  assumes \"u adds\\<^sub>t v\" and \"v adds\\<^sub>t w\"\n  shows \"u adds\\<^sub>t w\"", "lemma adds_term_splus:\n  assumes \"u adds\\<^sub>t v\"\n  shows \"u adds\\<^sub>t s \\<oplus> v\"", "lemma adds_term_triv [term_simps]: \"v adds\\<^sub>t t \\<oplus> v\"", "lemma splus_adds_term_mono:\n  assumes \"s adds t\"\n    and \"u adds\\<^sub>t v\"\n  shows \"s \\<oplus> u adds\\<^sub>t t \\<oplus> v\"", "lemma splus_adds_term:\n  assumes \"t \\<oplus> u adds\\<^sub>t v\"\n  shows \"u adds\\<^sub>t v\"", "lemma adds_term_adds_pp:\n  \"u adds\\<^sub>t v \\<longleftrightarrow> (component_of_term u = component_of_term v \\<and> pp_of_term u adds\\<^sub>p v)\"", "lemma adds_term_canc: \"t \\<oplus> u adds\\<^sub>t t \\<oplus> v \\<longleftrightarrow> u adds\\<^sub>t v\"", "lemma adds_term_canc_2: \"s \\<oplus> v adds\\<^sub>t t \\<oplus> v \\<longleftrightarrow> s adds t\"", "lemma splus_adds_term_0:\n  assumes \"t \\<oplus> u adds\\<^sub>t v\"\n  shows \"u adds\\<^sub>t (v \\<ominus> t)\"", "lemma splus_adds_termI_1:\n  assumes \"t adds\\<^sub>p v\" and \"u adds\\<^sub>t (v \\<ominus> t)\"\n  shows \"t \\<oplus> u adds\\<^sub>t v\"", "lemma splus_adds_term_iff: \"t \\<oplus> u adds\\<^sub>t v \\<longleftrightarrow> (t adds\\<^sub>p v \\<and> u adds\\<^sub>t (v \\<ominus> t))\"", "lemma adds_minus_splus:\n  assumes \"pp_of_term u adds t\"\n  shows \"(t - pp_of_term u) \\<oplus> u = term_of_pair (t, component_of_term u)\"", "lemma lookup_proj_poly: \"lookup (proj_poly k p) t = lookup p (term_of_pair (t, k))\"", "lemma lookup_vectorize_poly: \"lookup (vectorize_poly p) k = proj_poly k p\"", "lemma lookup_atomize_poly:\n  \"lookup (atomize_poly p) v = lookup (lookup p (component_of_term v)) (pp_of_term v)\"", "lemma keys_proj_poly: \"keys (proj_poly k p) = pp_of_term ` {x\\<in>keys p. component_of_term x = k}\"", "lemma keys_vectorize_poly: \"keys (vectorize_poly p) = component_of_term ` keys p\"", "lemma keys_atomize_poly:\n  \"keys (atomize_poly p) = (\\<Union>k\\<in>keys p. (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\" (is \"?l = ?r\")", "lemma proj_atomize_poly [term_simps]: \"proj_poly k (atomize_poly p) = lookup p k\"", "lemma vectorize_atomize_poly [term_simps]: \"vectorize_poly (atomize_poly p) = p\"", "lemma atomize_vectorize_poly [term_simps]: \"atomize_poly (vectorize_poly p) = p\"", "lemma proj_zero [term_simps]: \"proj_poly k 0 = 0\"", "lemma proj_plus: \"proj_poly k (p + q) = proj_poly k p + proj_poly k q\"", "lemma proj_uminus [term_simps]: \"proj_poly k (- p) = - proj_poly k p\"", "lemma proj_minus: \"proj_poly k (p - q) = proj_poly k p - proj_poly k q\"", "lemma vectorize_zero [term_simps]: \"vectorize_poly 0 = 0\"", "lemma vectorize_plus: \"vectorize_poly (p + q) = vectorize_poly p + vectorize_poly q\"", "lemma vectorize_uminus [term_simps]: \"vectorize_poly (- p) = - vectorize_poly p\"", "lemma vectorize_minus: \"vectorize_poly (p - q) = vectorize_poly p - vectorize_poly q\"", "lemma atomize_zero [term_simps]: \"atomize_poly 0 = 0\"", "lemma atomize_plus: \"atomize_poly (p + q) = atomize_poly p + atomize_poly q\"", "lemma atomize_uminus [term_simps]: \"atomize_poly (- p) = - atomize_poly p\"", "lemma atomize_minus: \"atomize_poly (p - q) = atomize_poly p - atomize_poly q\"", "lemma proj_monomial:\n  \"proj_poly k (monomial c v) = (monomial c (pp_of_term v) when component_of_term v = k)\"", "lemma vectorize_monomial:\n  \"vectorize_poly (monomial c v) = monomial (monomial c (pp_of_term v)) (component_of_term v)\"", "lemma atomize_monomial_monomial:\n  \"atomize_poly (monomial (monomial c t) k) = monomial c (term_of_pair (t, k))\"", "lemma poly_mapping_eqI_proj:\n  assumes \"\\<And>k. proj_poly k p = proj_poly k q\"\n  shows \"p = q\"", "lemma keys_monom_mult_aux:\n  \"{v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else 0) \\<noteq> 0} \\<subseteq> (\\<oplus>) t ` keys p\" (is \"?l \\<subseteq> ?r\")\n  for c::\"'b::semiring_0\"", "lemma lookup_monom_mult:\n  \"lookup (monom_mult c t p) v = (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else 0)\"", "lemma lookup_monom_mult_plus:\n  \"lookup (monom_mult c t p) (t \\<oplus> v) = (c::'b::semiring_0) * lookup p v\"", "lemma monom_mult_assoc: \"monom_mult c s (monom_mult d t p) = monom_mult (c * d) (s + t) p\"", "lemma monom_mult_uminus_left: \"monom_mult (- c) t p = - monom_mult (c::'b::ring) t p\"", "lemma monom_mult_uminus_right: \"monom_mult c t (- p) = - monom_mult (c::'b::ring) t p\"", "lemma uminus_monom_mult: \"- p = monom_mult (-1::'b::comm_ring_1) 0 p\"", "lemma monom_mult_dist_left: \"monom_mult (c + d) t p = (monom_mult c t p) + (monom_mult d t p)\"", "lemma monom_mult_dist_left_minus:\n  \"monom_mult (c - d) t p = (monom_mult c t p) - (monom_mult (d::'b::ring) t p)\"", "lemma monom_mult_dist_right:\n  \"monom_mult c t (p + q) = (monom_mult c t p) + (monom_mult c t q)\"", "lemma monom_mult_dist_right_minus:\n  \"monom_mult c t (p - q) = (monom_mult c t p) - (monom_mult (c::'b::ring) t q)\"", "lemma monom_mult_zero_left [simp]: \"monom_mult 0 t p = 0\"", "lemma monom_mult_zero_right [simp]: \"monom_mult c t 0 = 0\"", "lemma monom_mult_one_left [simp]: \"(monom_mult (1::'b::semiring_1) 0 p) = p\"", "lemma monom_mult_monomial:\n  \"monom_mult c s (monomial d v) = monomial (c * (d::'b::semiring_0)) (s \\<oplus> v)\"", "lemma monom_mult_eq_zero_iff: \"(monom_mult c t p = 0) \\<longleftrightarrow> ((c::'b::semiring_no_zero_divisors) = 0 \\<or> p = 0)\"", "lemma lookup_monom_mult_zero: \"lookup (monom_mult c 0 p) t = c * lookup p t\"", "lemma monom_mult_inj_1:\n  assumes \"monom_mult c1 t p = monom_mult c2 t p\"\n    and \"(p::(_ \\<Rightarrow>\\<^sub>0 'b::semiring_no_zero_divisors_cancel)) \\<noteq> 0\"\n  shows \"c1 = c2\"", "lemma monom_mult_inj_3:\n  assumes \"monom_mult c t p1 = monom_mult c t (p2::(_ \\<Rightarrow>\\<^sub>0 'b::semiring_no_zero_divisors_cancel))\"\n    and \"c \\<noteq> 0\"\n  shows \"p1 = p2\"", "lemma keys_monom_multI:\n  assumes \"v \\<in> keys p\" and \"c \\<noteq> (0::'b::semiring_no_zero_divisors)\"\n  shows \"t \\<oplus> v \\<in> keys (monom_mult c t p)\"", "lemma keys_monom_mult_subset: \"keys (monom_mult c t p) \\<subseteq> ((\\<oplus>) t) ` (keys p)\"", "lemma keys_monom_multE:\n  assumes \"v \\<in> keys (monom_mult c t p)\"\n  obtains u where \"u \\<in> keys p\" and \"v = t \\<oplus> u\"", "lemma keys_monom_mult:\n  assumes \"c \\<noteq> (0::'b::semiring_no_zero_divisors)\"\n  shows \"keys (monom_mult c t p) = ((\\<oplus>) t) ` (keys p)\"", "lemma monom_mult_when: \"monom_mult c t (p when P) = ((monom_mult c t p) when P)\"", "lemma when_monom_mult: \"monom_mult (c when P) t p = ((monom_mult c t p) when P)\"", "lemma monomial_power: \"(monomial c t) ^ n = monomial (c ^ n) (\\<Sum>i=0..<n. t)\"", "lemma lookup_lift_poly_fun_2:\n  \"lookup (lift_poly_fun_2 f p q) v =\n    (lookup (f (proj_poly (component_of_term v) p) (proj_poly (component_of_term v) q)) (pp_of_term v)\n        when component_of_term v \\<in> keys (vectorize_poly p) \\<union> keys (vectorize_poly q))\"", "lemma lookup_lift_poly_fun:\n  \"lookup (lift_poly_fun f p) v =\n    (lookup (f (proj_poly (component_of_term v) p)) (pp_of_term v) when component_of_term v \\<in> keys (vectorize_poly p))\"", "lemma lookup_lift_poly_fun_2_homogenous:\n  assumes \"f 0 0 = 0\"\n  shows \"lookup (lift_poly_fun_2 f p q) v =\n         lookup (f (proj_poly (component_of_term v) p) (proj_poly (component_of_term v) q)) (pp_of_term v)\"", "lemma proj_lift_poly_fun_2_homogenous:\n  assumes \"f 0 0 = 0\"\n  shows \"proj_poly k (lift_poly_fun_2 f p q) = f (proj_poly k p) (proj_poly k q)\"", "lemma lookup_lift_poly_fun_homogenous:\n  assumes \"f 0 = 0\"\n  shows \"lookup (lift_poly_fun f p) v = lookup (f (proj_poly (component_of_term v) p)) (pp_of_term v)\"", "lemma proj_lift_poly_fun_homogenous:\n  assumes \"f 0 = 0\"\n  shows \"proj_poly k (lift_poly_fun f p) = f (proj_poly k p)\"", "lemma lookup_mult_vec:\n  \"lookup (p ** q) v = lookup ((proj_poly (component_of_term v) p) * (proj_poly (component_of_term v) q)) (pp_of_term v)\"", "lemma proj_mult_vec [term_simps]: \"proj_poly k (p ** q) = (proj_poly k p) * (proj_poly k q)\"", "lemma mult_vec_zero_left: \"0 ** p = 0\"", "lemma mult_vec_zero_right: \"p ** 0 = 0\"", "lemma mult_vec_assoc: \"(p ** q) ** r = p ** (q ** r)\"", "lemma mult_vec_distrib_right: \"(p + q) ** r = p ** r + q ** r\"", "lemma mult_vec_distrib_left: \"r ** (p + q) = r ** p + r ** q\"", "lemma mult_vec_minus_mult_left: \"(- p) ** q = - (p ** q)\"", "lemma mult_vec_minus_mult_right: \"p ** (- q) = - (p ** q)\"", "lemma minus_mult_vec_minus: \"(- p) ** (- q) = p ** q\"", "lemma minus_mult_vec_commute: \"(- p) ** q = p ** (- q)\"", "lemma mult_vec_right_diff_distrib: \"r ** (p - q) = r ** p - r ** q\"\n  for r::\"_ \\<Rightarrow>\\<^sub>0 'b::ring\"", "lemma mult_vec_left_diff_distrib: \"(p - q) ** r = p ** r - q ** r\"\n  for p::\"_ \\<Rightarrow>\\<^sub>0 'b::ring\"", "lemma mult_vec_commute: \"p ** q = q ** p\" for p::\"_ \\<Rightarrow>\\<^sub>0 'b::comm_semiring_0\"", "lemma mult_vec_left_commute: \"p ** (q ** r) = q ** (p ** r)\"\n  for p::\"_ \\<Rightarrow>\\<^sub>0 'b::comm_semiring_0\"", "lemma mult_vec_monomial_monomial:\n  \"(monomial c u) ** (monomial d v) =\n          (monomial (c * d) (term_of_pair (pp_of_term u + pp_of_term v, component_of_term u)) when\n            component_of_term u = component_of_term v)\"", "lemma mult_vec_rec_left: \"p ** q = monomial (lookup p v) v ** q + (except p {v}) ** q\"", "lemma mult_vec_rec_right: \"p ** q = p ** monomial (lookup q v) v + p ** except q {v}\"", "lemma in_keys_mult_vecE:\n  assumes \"w \\<in> keys (p ** q)\"\n  obtains u v where \"u \\<in> keys p\" and \"v \\<in> keys q\" and \"component_of_term u = component_of_term v\"\n    and \"w = term_of_pair (pp_of_term u + pp_of_term v, component_of_term u)\"", "lemma lookup_mult_vec_monomial_left:\n  \"lookup (monomial c v ** p) u =\n        (c * lookup p (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) when v adds\\<^sub>t u)\"", "lemma lookup_mult_vec_monomial_right:\n  \"lookup (p ** monomial c v) u =\n        (lookup p (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) * c when v adds\\<^sub>t u)\"", "lemma lookup_mult_scalar:\n  \"lookup (p \\<odot> q) v = lookup (p * (proj_poly (component_of_term v) q)) (pp_of_term v)\"", "lemma lookup_mult_scalar_explicit:\n  \"lookup (p \\<odot> q) u = (\\<Sum>t\\<in>keys p. lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))\"", "lemma proj_mult_scalar [term_simps]: \"proj_poly k (p \\<odot> q) = p * (proj_poly k q)\"", "lemma mult_scalar_zero_left [simp]: \"0 \\<odot> p = 0\"", "lemma mult_scalar_zero_right [simp]: \"p \\<odot> 0 = 0\"", "lemma mult_scalar_one [simp]: \"(1::_ \\<Rightarrow>\\<^sub>0 'b::semiring_1) \\<odot> p = p\"", "lemma mult_scalar_assoc [ac_simps]: \"(p * q) \\<odot> r = p \\<odot> (q \\<odot> r)\"", "lemma mult_scalar_distrib_right [algebra_simps]: \"(p + q) \\<odot> r = p \\<odot> r + q \\<odot> r\"", "lemma mult_scalar_distrib_left [algebra_simps]: \"r \\<odot> (p + q) = r \\<odot> p + r \\<odot> q\"", "lemma mult_scalar_minus_mult_left [simp]: \"(- p) \\<odot> q = - (p \\<odot> q)\"", "lemma mult_scalar_minus_mult_right [simp]: \"p \\<odot> (- q) = - (p \\<odot> q)\"", "lemma minus_mult_scalar_minus [simp]: \"(- p) \\<odot> (- q) = p \\<odot> q\"", "lemma minus_mult_scalar_commute: \"(- p) \\<odot> q = p \\<odot> (- q)\"", "lemma mult_scalar_right_diff_distrib [algebra_simps]: \"r \\<odot> (p - q) = r \\<odot> p - r \\<odot> q\"\n  for r::\"_ \\<Rightarrow>\\<^sub>0 'b::ring\"", "lemma mult_scalar_left_diff_distrib [algebra_simps]: \"(p - q) \\<odot> r = p \\<odot> r - q \\<odot> r\"\n  for p::\"_ \\<Rightarrow>\\<^sub>0 'b::ring\"", "lemma sum_mult_scalar_distrib_left: \"r \\<odot> (sum f A) = (\\<Sum>a\\<in>A. r \\<odot> f a)\"", "lemma sum_mult_scalar_distrib_right: \"(sum f A) \\<odot> v = (\\<Sum>a\\<in>A. f a \\<odot> v)\"", "lemma mult_scalar_monomial_monomial: \"(monomial c t) \\<odot> (monomial d v) = monomial (c * d) (t \\<oplus> v)\"", "lemma mult_scalar_monomial: \"(monomial c t) \\<odot> p = monom_mult c t p\"", "lemma mult_scalar_rec_left: \"p \\<odot> q = monom_mult (lookup p t) t q + (except p {t}) \\<odot> q\"", "lemma mult_scalar_rec_right: \"p \\<odot> q = p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v}\"", "lemma in_keys_mult_scalarE:\n  assumes \"v \\<in> keys (p \\<odot> q)\"\n  obtains t u where \"t \\<in> keys p\" and \"u \\<in> keys q\" and \"v = t \\<oplus> u\"", "lemma lookup_mult_scalar_monomial_right:\n  \"lookup (p \\<odot> monomial c v) u = (lookup p (pp_of_term u - pp_of_term v) * c when v adds\\<^sub>t u)\"", "lemma lookup_mult_scalar_monomial_right_plus: \"lookup (p \\<odot> monomial c v) (t \\<oplus> v) = lookup p t * c\"", "lemma keys_mult_scalar_monomial_right_subset: \"keys (p \\<odot> monomial c v) \\<subseteq> (\\<lambda>t. t \\<oplus> v) ` keys p\"", "lemma keys_mult_scalar_monomial_right:\n  assumes \"c \\<noteq> (0::'b::semiring_no_zero_divisors)\"\n  shows \"keys (p \\<odot> monomial c v) = (\\<lambda>t. t \\<oplus> v) ` keys p\"", "lemma sum_poly_mapping_eq_zeroI:\n  assumes \"p ` A \\<subseteq> {0}\"\n  shows \"sum p A = (0::(_ \\<Rightarrow>\\<^sub>0 'b::comm_monoid_add))\"", "lemma lookup_sum_list: \"lookup (sum_list ps) a = sum_list (map (\\<lambda>p. lookup p a) ps)\"", "lemmas keys_sum_subset = Poly_Mapping.keys_sum", "lemma keys_sum_list_subset: \"keys (sum_list ps) \\<subseteq> Keys (set ps)\"", "lemma keys_sum:\n  assumes \"finite A\" and \"\\<And>a1 a2. a1 \\<in> A \\<Longrightarrow> a2 \\<in> A \\<Longrightarrow> a1 \\<noteq> a2 \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) = {}\"\n  shows \"keys (sum f A) = (\\<Union>a\\<in>A. keys (f a))\"", "lemma poly_mapping_sum_monomials: \"(\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p\"", "lemma monomial_sum: \"monomial (sum f C) a = (\\<Sum>c\\<in>C. monomial (f c) a)\"", "lemma monomial_Sum_any:\n  assumes \"finite {c. f c \\<noteq> 0}\"\n  shows \"monomial (Sum_any f) a = (\\<Sum>c. monomial (f c) a)\"", "lemma proj_sum: \"proj_poly k (sum f A) = (\\<Sum>a\\<in>A. proj_poly k (f a))\"", "lemma proj_sum_list: \"proj_poly k (sum_list xs) = sum_list (map (proj_poly k) xs)\"", "lemma mult_scalar_sum_monomials: \"q \\<odot> p = (\\<Sum>t\\<in>keys q. monom_mult (lookup q t) t p)\"", "lemma fun_mult_scalar_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n    and \"\\<And>c t. f (monom_mult c t p) = monom_mult c t (f p)\"\n  shows \"f (q \\<odot> p) = q \\<odot> (f p)\"", "lemma fun_mult_scalar_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + f y\" and \"\\<And>c t. f (monom_mult c t p) = monom_mult c t (f p)\"\n  shows \"f (q \\<odot> p) = q \\<odot> (f (p::'t \\<Rightarrow>\\<^sub>0 'b::{semiring_0,cancel_comm_monoid_add}))\"", "lemma monom_mult_sum_left: \"monom_mult (sum f C) t p = (\\<Sum>c\\<in>C. monom_mult (f c) t p)\"", "lemma monom_mult_sum_right: \"monom_mult c t (sum f P) = (\\<Sum>p\\<in>P. monom_mult c t (f p))\"", "lemma monom_mult_Sum_any_left:\n  assumes \"finite {c. f c \\<noteq> 0}\"\n  shows \"monom_mult (Sum_any f) t p = (\\<Sum>c. monom_mult (f c) t p)\"", "lemma monom_mult_Sum_any_right:\n  assumes \"finite {p. f p \\<noteq> 0}\"\n  shows \"monom_mult c t (Sum_any f) = (\\<Sum>p. monom_mult c t (f p))\"", "lemma monomial_prod_sum: \"monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))\"", "lemmas [simp del] = pmdl.scale_one pmdl.scale_zero_left pmdl.scale_zero_right pmdl.scale_scale\n  pmdl.scale_minus_left pmdl.scale_minus_right pmdl.span_eq_iff", "lemmas [algebra_simps del] = pmdl.scale_left_distrib pmdl.scale_right_distrib\n  pmdl.scale_left_diff_distrib pmdl.scale_right_diff_distrib", "lemma pmdl_closed_monom_mult:\n  assumes \"p \\<in> pmdl B\"\n  shows \"monom_mult c t p \\<in> pmdl B\"", "lemma monom_mult_in_pmdl: \"b \\<in> B \\<Longrightarrow> monom_mult c t b \\<in> pmdl B\"", "lemma pmdl_induct [consumes 1, case_names module_0 module_plus]:\n  assumes \"p \\<in> pmdl B\" and \"P 0\"\n    and \"\\<And>a p c t. a \\<in> pmdl B \\<Longrightarrow> P a \\<Longrightarrow> p \\<in> B \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> P (a + monom_mult c t p)\"\n  shows \"P p\"", "lemma components_pmdl: \"component_of_term ` Keys (pmdl B) = component_of_term ` Keys B\"", "lemma pmdl_idI:\n  assumes \"0 \\<in> B\" and \"\\<And>b1 b2. b1 \\<in> B \\<Longrightarrow> b2 \\<in> B \\<Longrightarrow> b1 + b2 \\<in> B\"\n    and \"\\<And>c t b. b \\<in> B \\<Longrightarrow> monom_mult c t b \\<in> B\"\n  shows \"pmdl B = B\"", "lemma full_pmdl_iff: \"p \\<in> full_pmdl K \\<longleftrightarrow> component_of_term ` keys p \\<subseteq> K\"", "lemma full_pmdlI:\n  assumes \"\\<And>v. v \\<in> keys p \\<Longrightarrow> component_of_term v \\<in> K\"\n  shows \"p \\<in> full_pmdl K\"", "lemma full_pmdlD:\n  assumes \"p \\<in> full_pmdl K\" and \"v \\<in> keys p\"\n  shows \"component_of_term v \\<in> K\"", "lemma full_pmdl_empty: \"full_pmdl {} = {0}\"", "lemma full_pmdl_UNIV: \"full_pmdl UNIV = UNIV\"", "lemma zero_in_full_pmdl: \"0 \\<in> full_pmdl K\"", "lemma full_pmdl_closed_plus:\n  assumes \"p \\<in> full_pmdl K\" and \"q \\<in> full_pmdl K\"\n  shows \"p + q \\<in> full_pmdl K\"", "lemma full_pmdl_closed_monom_mult:\n  assumes \"p \\<in> full_pmdl K\"\n  shows \"monom_mult c t p \\<in> full_pmdl K\"", "lemma pmdl_full_pmdl: \"pmdl (full_pmdl K) = full_pmdl K\"", "lemma components_full_pmdl_subset:\n  \"component_of_term ` Keys ((full_pmdl K)::('t \\<Rightarrow>\\<^sub>0 'b::zero) set) \\<subseteq> K\" (is \"?l \\<subseteq> _\")", "lemma components_full_pmdl:\n  \"component_of_term ` Keys ((full_pmdl K)::('t \\<Rightarrow>\\<^sub>0 'b::zero_neq_one) set) = K\" (is \"?l = _\")", "lemma is_full_pmdlI:\n  assumes \"\\<And>p. component_of_term ` keys p \\<subseteq> component_of_term ` Keys B \\<Longrightarrow> p \\<in> pmdl B\"\n  shows \"is_full_pmdl B\"", "lemma is_full_pmdlD:\n  assumes \"is_full_pmdl B\" and \"component_of_term ` keys p \\<subseteq> component_of_term ` Keys B\"\n  shows \"p \\<in> pmdl B\"", "lemma is_full_pmdl_alt: \"is_full_pmdl B \\<longleftrightarrow> pmdl B = full_pmdl (component_of_term ` Keys B)\"", "lemma is_full_pmdl_pmdl: \"is_full_pmdl (pmdl B) \\<longleftrightarrow> is_full_pmdl B\"", "lemma is_full_pmdl_subset:\n  assumes \"is_full_pmdl B1\" and \"is_full_pmdl B2\"\n    and \"component_of_term ` Keys B1 \\<subseteq> component_of_term ` Keys B2\"\n  shows \"pmdl B1 \\<subseteq> pmdl B2\"", "lemma is_full_pmdl_eq:\n  assumes \"is_full_pmdl B1\" and \"is_full_pmdl B2\"\n    and \"component_of_term ` Keys B1 = component_of_term ` Keys B2\"\n  shows \"pmdl B1 = pmdl B2\"", "lemma lookup_map_scale [simp]: \"lookup (c \\<cdot> p) = (\\<lambda>x. c * lookup p x)\"", "lemma map_scale_single [simp]: \"k \\<cdot> Poly_Mapping.single x l = Poly_Mapping.single x (k * l)\"", "lemma map_scale_zero_left [simp]: \"0 \\<cdot> t = 0\"", "lemma map_scale_zero_right [simp]: \"k \\<cdot> 0 = 0\"", "lemma map_scale_eq_0_iff: \"c \\<cdot> t = 0 \\<longleftrightarrow> ((c::_::semiring_no_zero_divisors) = 0 \\<or> t = 0)\"", "lemma keys_map_scale_subset: \"keys (k \\<cdot> t) \\<subseteq> keys t\"", "lemma keys_map_scale: \"keys ((k::'b::semiring_no_zero_divisors) \\<cdot> t) = (if k = 0 then {} else keys t)\"", "lemma map_scale_one_left [simp]: \"(1::'b::{mult_zero,monoid_mult}) \\<cdot> t = t\"", "lemma map_scale_assoc [ac_simps]: \"c \\<cdot> d \\<cdot> t = (c * d) \\<cdot> (t::_ \\<Rightarrow>\\<^sub>0 _::{semigroup_mult,zero})\"", "lemma map_scale_distrib_left [algebra_simps]: \"(k::'b::semiring_0) \\<cdot> (s + t) = k \\<cdot> s + k \\<cdot> t\"", "lemma map_scale_distrib_right [algebra_simps]: \"(k + (l::'b::semiring_0)) \\<cdot> t = k \\<cdot> t + l \\<cdot> t\"", "lemma map_scale_Suc: \"(Suc k) \\<cdot> t = k \\<cdot> t + t\"", "lemma map_scale_uminus_left: \"(- k::'b::ring) \\<cdot> p = - (k \\<cdot> p)\"", "lemma map_scale_uminus_right: \"(k::'b::ring) \\<cdot> (- p) = - (k \\<cdot> p)\"", "lemma map_scale_uminus_uminus [simp]: \"(- k::'b::ring) \\<cdot> (- p) = k \\<cdot> p\"", "lemma map_scale_minus_distrib_left [algebra_simps]:\n  \"(k::'b::comm_semiring_1_cancel) \\<cdot> (p - q) = k \\<cdot> p - k \\<cdot> q\"", "lemma map_scale_minus_distrib_right [algebra_simps]:\n  \"(k - (l::'b::comm_semiring_1_cancel)) \\<cdot> f = k \\<cdot> f - l \\<cdot> f\"", "lemma map_scale_sum_distrib_left: \"(k::'b::semiring_0) \\<cdot> (sum f A) = (\\<Sum>a\\<in>A. k \\<cdot> f a)\"", "lemma map_scale_sum_distrib_right: \"(sum (f::_ \\<Rightarrow> 'b::semiring_0) A) \\<cdot> p = (\\<Sum>a\\<in>A. f a \\<cdot> p)\"", "lemma deg_pm_map_scale: \"deg_pm (k \\<cdot> t) = (k::'b::semiring_0) * deg_pm t\"", "lemmas [simp del] = phull.scale_one phull.scale_zero_left phull.scale_zero_right phull.scale_scale\n  phull.scale_minus_left phull.scale_minus_right phull.span_eq_iff", "lemmas [algebra_simps del] = phull.scale_left_distrib phull.scale_right_distrib\n  phull.scale_left_diff_distrib phull.scale_right_diff_distrib", "lemma map_scale_eq_monom_mult: \"c \\<cdot> p = monom_mult c 0 p\"", "lemma map_scale_eq_mult_scalar: \"c \\<cdot> p = monomial c 0 \\<odot> p\"", "lemma phull_closed_mult_scalar: \"p \\<in> phull B \\<Longrightarrow> monomial c 0 \\<odot> p \\<in> phull B\"", "lemma mult_scalar_in_phull: \"b \\<in> B \\<Longrightarrow> monomial c 0 \\<odot> b \\<in> phull B\"", "lemma phull_subset_module: \"phull B \\<subseteq> pmdl B\"", "lemma components_phull: \"component_of_term ` Keys (phull B) = component_of_term ` Keys B\"", "lemma fst_to_pair_unit: \"fst (to_pair_unit x) = x\"", "lemma to_pair_unit_fst: \"to_pair_unit (fst x) = (x::_ \\<times> unit)\"", "lemma punit_pp_of_term [simp]: \"punit.pp_of_term = (\\<lambda>x. x)\"", "lemma punit_component_of_term [simp]: \"punit.component_of_term = (\\<lambda>_. ())\"", "lemma punit_splus [simp]: \"punit.splus = (+)\"", "lemma punit_sminus [simp]: \"punit.sminus = (-)\"", "lemma punit_adds_pp [simp]: \"punit.adds_pp = (adds)\"", "lemma punit_adds_term [simp]: \"punit.adds_term = (adds)\"", "lemma punit_proj_poly [simp]: \"punit.proj_poly = (\\<lambda>_. id)\"", "lemma punit_mult_vec [simp]: \"punit.mult_vec = (*)\"", "lemma punit_mult_scalar [simp]: \"punit.mult_scalar = (*)\"", "lemma proj_monom_mult: \"proj_poly k (monom_mult c t p) = punit.monom_mult c t (proj_poly k p)\"", "lemma mult_scalar_monom_mult: \"(punit.monom_mult c t p) \\<odot> q = monom_mult c t (p \\<odot> q)\"", "lemma pprod_pp_of_term [simp]: \"pprod.pp_of_term = fst\"", "lemma pprod_component_of_term [simp]: \"pprod.component_of_term = snd\"", "lemmas [term_simps del] = term_simps", "lemmas times_monomial_monomial = punit.mult_scalar_monomial_monomial[simplified]", "lemmas times_monomial_left = punit.mult_scalar_monomial[simplified]", "lemmas times_rec_left = punit.mult_scalar_rec_left[simplified]", "lemmas times_rec_right = punit.mult_scalar_rec_right[simplified]", "lemmas in_keys_timesE = punit.in_keys_mult_scalarE[simplified]", "lemmas punit_monom_mult_monomial = punit.monom_mult_monomial[simplified]", "lemmas lookup_times = punit.lookup_mult_scalar_explicit[simplified]", "lemmas map_scale_eq_times = punit.map_scale_eq_mult_scalar[simplified]"], "translations": [["", "lemma when_distrib: \"f (a when b) = (f a when b)\" if \"\\<not> b \\<Longrightarrow> f 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (a when b) = (f a when b)", "using that"], ["proof (prove)\nusing this:\n  \\<not> b \\<Longrightarrow> f (0::'b) = (0::'a)\n\ngoal (1 subgoal):\n 1. f (a when b) = (f a when b)", "by (auto simp: when_def)"], ["", "definition mapp_2 :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b::zero) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'c::zero) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'd::zero)\"\n  where \"mapp_2 f p q = Abs_poly_mapping (\\<lambda>k. f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)\""], ["", "lemma lookup_mapp_2:\n  \"lookup (mapp_2 f p q) k = (f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (mapp_2 f p q) k =\n    (f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (mapp_2 f p q) k =\n    (f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)", "have \"lookup (Abs_poly_mapping (\\<lambda>k. f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)) =\n        (\\<lambda>k. f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Abs_poly_mapping\n       (\\<lambda>k.\n           f k (lookup p k) (lookup q k) when\n           k \\<in> keys p \\<union> keys q)) =\n    (\\<lambda>k.\n        f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)", "by (rule Abs_poly_mapping_inverse, simp)"], ["proof (state)\nthis:\n  lookup\n   (Abs_poly_mapping\n     (\\<lambda>k.\n         f k (lookup p k) (lookup q k) when\n         k \\<in> keys p \\<union> keys q)) =\n  (\\<lambda>k.\n      f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)\n\ngoal (1 subgoal):\n 1. lookup (mapp_2 f p q) k =\n    (f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup\n   (Abs_poly_mapping\n     (\\<lambda>k.\n         f k (lookup p k) (lookup q k) when\n         k \\<in> keys p \\<union> keys q)) =\n  (\\<lambda>k.\n      f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)\n\ngoal (1 subgoal):\n 1. lookup (mapp_2 f p q) k =\n    (f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)", "by (simp add: mapp_2_def)"], ["proof (state)\nthis:\n  lookup (mapp_2 f p q) k =\n  (f k (lookup p k) (lookup q k) when k \\<in> keys p \\<union> keys q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_mapp_2_homogenous:\n  assumes \"f k 0 0 = 0\"\n  shows \"lookup (mapp_2 f p q) k = f k (lookup p k) (lookup q k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (mapp_2 f p q) k = f k (lookup p k) (lookup q k)", "by (simp add: lookup_mapp_2 when_def in_keys_iff assms)"], ["", "lemma mapp_2_cong [fundef_cong]:\n  assumes \"p = p'\" and \"q = q'\"\n  assumes \"\\<And>k. k \\<in> keys p' \\<union> keys q' \\<Longrightarrow> f k (lookup p' k) (lookup q' k) = f' k (lookup p' k) (lookup q' k)\"\n  shows \"mapp_2 f p q = mapp_2 f' p' q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapp_2 f p q = mapp_2 f' p' q'", "by (rule poly_mapping_eqI, simp add: assms(1, 2) lookup_mapp_2, rule when_cong, fact refl, rule assms(3), blast)"], ["", "lemma keys_mapp_subset: \"keys (mapp_2 f p q) \\<subseteq> keys p \\<union> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapp_2 f p q) \\<subseteq> keys p \\<union> keys q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (mapp_2 f p q) \\<Longrightarrow>\n       x \\<in> keys p \\<union> keys q", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (mapp_2 f p q) \\<Longrightarrow>\n       x \\<in> keys p \\<union> keys q", "assume \"t \\<in> keys (mapp_2 f p q)\""], ["proof (state)\nthis:\n  t \\<in> keys (mapp_2 f p q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (mapp_2 f p q) \\<Longrightarrow>\n       x \\<in> keys p \\<union> keys q", "hence \"lookup (mapp_2 f p q) t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys (mapp_2 f p q)\n\ngoal (1 subgoal):\n 1. lookup (mapp_2 f p q) t \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup (mapp_2 f p q) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (mapp_2 f p q) \\<Longrightarrow>\n       x \\<in> keys p \\<union> keys q", "thus \"t \\<in> keys p \\<union> keys q\""], ["proof (prove)\nusing this:\n  lookup (mapp_2 f p q) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<in> keys p \\<union> keys q", "by (simp add: lookup_mapp_2 when_def split: if_split_asm)"], ["proof (state)\nthis:\n  t \\<in> keys p \\<union> keys q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mapp_2_mapp: \"mapp_2 (\\<lambda>t a. f t) 0 p = Poly_Mapping.mapp f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapp_2 (\\<lambda>t a. f t) 0 p = Poly_Mapping.mapp f p", "by (rule poly_mapping_eqI, simp add: lookup_mapp lookup_mapp_2)"], ["", "subsection \\<open>@{const keys}\\<close>"], ["", "lemma in_keys_plusI1:\n  assumes \"t \\<in> keys p\" and \"t \\<notin> keys q\"\n  shows \"t \\<in> keys (p + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> keys (p + q)", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  t \\<notin> keys q\n\ngoal (1 subgoal):\n 1. t \\<in> keys (p + q)", "unfolding in_keys_iff lookup_add"], ["proof (prove)\nusing this:\n  lookup p t \\<noteq> (0::'b)\n  \\<not> lookup q t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup p t + lookup q t \\<noteq> (0::'b)", "by simp"], ["", "lemma in_keys_plusI2:\n  assumes \"t \\<in> keys q\" and \"t \\<notin> keys p\"\n  shows \"t \\<in> keys (p + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> keys (p + q)", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> keys q\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<in> keys (p + q)", "unfolding in_keys_iff lookup_add"], ["proof (prove)\nusing this:\n  lookup q t \\<noteq> (0::'b)\n  \\<not> lookup p t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup p t + lookup q t \\<noteq> (0::'b)", "by simp"], ["", "lemma keys_plus_eqI:\n  assumes \"keys p \\<inter> keys q = {}\"\n  shows \"keys (p + q) = (keys p \\<union> keys q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p + q) = keys p \\<union> keys q", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (p + q) \\<subseteq> keys p \\<union> keys q\n 2. keys p \\<union> keys q \\<subseteq> keys (p + q)", "show \"keys (p + q) \\<subseteq> keys p \\<union> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p + q) \\<subseteq> keys p \\<union> keys q", "by (simp add: Poly_Mapping.keys_add)"], ["proof (state)\nthis:\n  keys (p + q) \\<subseteq> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. keys p \\<union> keys q \\<subseteq> keys (p + q)", "show \"keys p \\<union> keys q \\<subseteq> keys (p + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys p \\<union> keys q \\<subseteq> keys (p + q)", "by (simp add: More_MPoly_Type.keys_add assms)"], ["proof (state)\nthis:\n  keys p \\<union> keys q \\<subseteq> keys (p + q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_uminus: \"keys (- p) = keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (- p) = keys p", "by (transfer, auto)"], ["", "lemma keys_minus: \"keys (p - q) \\<subseteq> (keys p \\<union> keys q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p - q) \\<subseteq> keys p \\<union> keys q", "by (transfer, auto)"], ["", "subsection \\<open>Monomials\\<close>"], ["", "abbreviation \"monomial \\<equiv> (\\<lambda>c t. Poly_Mapping.single t c)\""], ["", "lemma keys_of_monomial:\n  assumes \"c \\<noteq> 0\"\n  shows \"keys (monomial c t) = {t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial c t) = {t}", "using assms"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. keys (monomial c t) = {t}", "by simp"], ["", "lemma monomial_uminus:\n  shows \"- monomial c s = monomial (- c) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - monomial c s = monomial (- c) s", "by (transfer, rule ext, simp add: Poly_Mapping.when_def)"], ["", "lemma monomial_inj:\n  assumes \"monomial c s = monomial (d::'b::zero_neq_one) t\"\n  shows \"(c = 0 \\<and> d = 0) \\<or> (c = d \\<and> s = t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = (0::'b) \\<and> d = (0::'b) \\<or> c = d \\<and> s = t", "using assms"], ["proof (prove)\nusing this:\n  monomial c s = monomial d t\n\ngoal (1 subgoal):\n 1. c = (0::'b) \\<and> d = (0::'b) \\<or> c = d \\<and> s = t", "unfolding poly_mapping_eq_iff"], ["proof (prove)\nusing this:\n  lookup (monomial c s) = lookup (monomial d t)\n\ngoal (1 subgoal):\n 1. c = (0::'b) \\<and> d = (0::'b) \\<or> c = d \\<and> s = t", "by (metis (mono_tags, hide_lams) lookup_single_eq lookup_single_not_eq)"], ["", "definition is_monomial :: \"('a \\<Rightarrow>\\<^sub>0 'b::zero) \\<Rightarrow> bool\"\n  where \"is_monomial p \\<longleftrightarrow> card (keys p) = 1\""], ["", "lemma monomial_is_monomial:\n  assumes \"c \\<noteq> 0\"\n  shows \"is_monomial (monomial c t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monomial (monomial c t)", "using keys_single[of t c] assms"], ["proof (prove)\nusing this:\n  keys (monomial c t) = (if c = (0::'a) then {} else {t})\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. is_monomial (monomial c t)", "by (simp add: is_monomial_def)"], ["", "lemma is_monomial_monomial:\n  assumes \"is_monomial p\"\n  obtains c t where \"c \\<noteq> 0\" and \"p = monomial c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c t.\n        \\<lbrakk>c \\<noteq> (0::'b); p = monomial c t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c t.\n        \\<lbrakk>c \\<noteq> (0::'b); p = monomial c t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  is_monomial p", "have \"card (keys p) = 1\""], ["proof (prove)\nusing this:\n  is_monomial p\n\ngoal (1 subgoal):\n 1. card (keys p) = 1", "unfolding is_monomial_def"], ["proof (prove)\nusing this:\n  card (keys p) = 1\n\ngoal (1 subgoal):\n 1. card (keys p) = 1", "."], ["proof (state)\nthis:\n  card (keys p) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>c t.\n        \\<lbrakk>c \\<noteq> (0::'b); p = monomial c t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  card (keys p) = 1", "obtain t where sp: \"keys p = {t}\""], ["proof (prove)\nusing this:\n  card (keys p) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>t. keys p = {t} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule card_1_singletonE)"], ["proof (state)\nthis:\n  keys p = {t}\n\ngoal (1 subgoal):\n 1. (\\<And>c t.\n        \\<lbrakk>c \\<noteq> (0::'b); p = monomial c t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?c = \"lookup p t\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c t.\n        \\<lbrakk>c \\<noteq> (0::'b); p = monomial c t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from sp"], ["proof (chain)\npicking this:\n  keys p = {t}", "have \"?c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  keys p = {t}\n\ngoal (1 subgoal):\n 1. lookup p t \\<noteq> (0::'b)", "by fastforce"], ["proof (state)\nthis:\n  lookup p t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<And>c t.\n        \\<lbrakk>c \\<noteq> (0::'b); p = monomial c t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ?c \\<noteq> (0::'b)\n 2. p = monomial ?c ?t", "show \"p = monomial ?c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = monomial (lookup p t) t", "proof (intro poly_mapping_keys_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys p = keys (monomial (lookup p t) t)\n 2. \\<And>ta.\n       ta \\<in> keys p \\<Longrightarrow>\n       lookup p ta = lookup (monomial (lookup p t) t) ta", "from sp"], ["proof (chain)\npicking this:\n  keys p = {t}", "show \"keys p = keys (monomial ?c t)\""], ["proof (prove)\nusing this:\n  keys p = {t}\n\ngoal (1 subgoal):\n 1. keys p = keys (monomial (lookup p t) t)", "using \\<open>?c \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  keys p = {t}\n  lookup p t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. keys p = keys (monomial (lookup p t) t)", "by simp"], ["proof (state)\nthis:\n  keys p = keys (monomial (lookup p t) t)\n\ngoal (1 subgoal):\n 1. \\<And>ta.\n       ta \\<in> keys p \\<Longrightarrow>\n       lookup p ta = lookup (monomial (lookup p t) t) ta", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ta.\n       ta \\<in> keys p \\<Longrightarrow>\n       lookup p ta = lookup (monomial (lookup p t) t) ta", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ta.\n       ta \\<in> keys p \\<Longrightarrow>\n       lookup p ta = lookup (monomial (lookup p t) t) ta", "assume \"s \\<in> keys p\""], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>ta.\n       ta \\<in> keys p \\<Longrightarrow>\n       lookup p ta = lookup (monomial (lookup p t) t) ta", "with sp"], ["proof (chain)\npicking this:\n  keys p = {t}\n  s \\<in> keys p", "have \"s = t\""], ["proof (prove)\nusing this:\n  keys p = {t}\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. s = t", "by simp"], ["proof (state)\nthis:\n  s = t\n\ngoal (1 subgoal):\n 1. \\<And>ta.\n       ta \\<in> keys p \\<Longrightarrow>\n       lookup p ta = lookup (monomial (lookup p t) t) ta", "show \"lookup p s = lookup (monomial ?c t) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup p s = lookup (monomial (lookup p t) t) s", "by (simp add: \\<open>s = t\\<close>)"], ["proof (state)\nthis:\n  lookup p s = lookup (monomial (lookup p t) t) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = monomial (lookup p t) t\n\ngoal (1 subgoal):\n 1. lookup p t \\<noteq> (0::'b)", "qed fact"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_monomial_uminus: \"is_monomial (-p) \\<longleftrightarrow> is_monomial p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monomial (- p) = is_monomial p", "unfolding is_monomial_def keys_uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. (card (keys p) = 1) = (card (keys p) = 1)", ".."], ["", "lemma monomial_not_0:\n  assumes \"is_monomial p\"\n  shows \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  is_monomial p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "unfolding is_monomial_def"], ["proof (prove)\nusing this:\n  card (keys p) = 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["", "lemma keys_subset_singleton_imp_monomial:\n  assumes \"keys p \\<subseteq> {t}\"\n  shows \"monomial (lookup p t) t = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (lookup p t) t = p", "proof (rule poly_mapping_eqI, simp add: lookup_single when_def, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. t \\<noteq> k \\<Longrightarrow> lookup p k = (0::'b)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. t \\<noteq> k \\<Longrightarrow> lookup p k = (0::'b)", "assume \"t \\<noteq> s\""], ["proof (state)\nthis:\n  t \\<noteq> s\n\ngoal (1 subgoal):\n 1. \\<And>k. t \\<noteq> k \\<Longrightarrow> lookup p k = (0::'b)", "hence \"s \\<notin> keys p\""], ["proof (prove)\nusing this:\n  t \\<noteq> s\n\ngoal (1 subgoal):\n 1. s \\<notin> keys p", "using assms"], ["proof (prove)\nusing this:\n  t \\<noteq> s\n  keys p \\<subseteq> {t}\n\ngoal (1 subgoal):\n 1. s \\<notin> keys p", "by blast"], ["proof (state)\nthis:\n  s \\<notin> keys p\n\ngoal (1 subgoal):\n 1. \\<And>k. t \\<noteq> k \\<Longrightarrow> lookup p k = (0::'b)", "thus \"lookup p s = 0\""], ["proof (prove)\nusing this:\n  s \\<notin> keys p\n\ngoal (1 subgoal):\n 1. lookup p s = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup p s = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_0I:\n  assumes \"c = 0\"\n  shows \"monomial c t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c t = 0", "using assms"], ["proof (prove)\nusing this:\n  c = (0::'a)\n\ngoal (1 subgoal):\n 1. monomial c t = 0", "by transfer (auto)"], ["", "lemma monomial_0D:\n  assumes \"monomial c t = 0\"\n  shows \"c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = (0::'b)", "using assms"], ["proof (prove)\nusing this:\n  monomial c t = 0\n\ngoal (1 subgoal):\n 1. c = (0::'b)", "by transfer (auto simp: fun_eq_iff when_def; meson)"], ["", "corollary monomial_0_iff: \"monomial c t = 0 \\<longleftrightarrow> c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monomial c t = 0) = (c = (0::'b))", "by (rule, erule monomial_0D, erule monomial_0I)"], ["", "lemma lookup_times_monomial_left: \"lookup (monomial c t * p) s = (c * lookup p (s - t) when t adds s)\"\n  for c::\"'b::semiring_0\" and t::\"'a::comm_powerprod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial c t * p) s = (c * lookup p (s - t) when t adds s)", "proof (induct p rule: poly_mapping_except_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "fix p::\"'a \\<Rightarrow>\\<^sub>0 'b\" and w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "assume \"p \\<noteq> 0\" and \"w \\<in> keys p\"\n    and IH: \"lookup (monomial c t * except p {w}) s =\n             (c * lookup (except p {w}) (s - t) when t adds s)\" (is \"_ = ?x\")"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  w \\<in> keys p\n  lookup (monomial c t * except p {w}) s =\n  (c * lookup (except p {w}) (s - t) when t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "have \"monomial c t * p = monomial c t * (monomial (lookup p w) w + except p {w})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c t * p =\n    monomial c t * (monomial (lookup p w) w + except p {w})", "by (simp only: plus_except[symmetric])"], ["proof (state)\nthis:\n  monomial c t * p = monomial c t * (monomial (lookup p w) w + except p {w})\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "also"], ["proof (state)\nthis:\n  monomial c t * p = monomial c t * (monomial (lookup p w) w + except p {w})\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "have \"... = monomial c t * monomial (lookup p w) w + monomial c t * except p {w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c t * (monomial (lookup p w) w + except p {w}) =\n    monomial c t * monomial (lookup p w) w + monomial c t * except p {w}", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  monomial c t * (monomial (lookup p w) w + except p {w}) =\n  monomial c t * monomial (lookup p w) w + monomial c t * except p {w}\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "also"], ["proof (state)\nthis:\n  monomial c t * (monomial (lookup p w) w + except p {w}) =\n  monomial c t * monomial (lookup p w) w + monomial c t * except p {w}\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "have \"... = monomial (c * lookup p w) (t + w) + monomial c t * except p {w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c t * monomial (lookup p w) w + monomial c t * except p {w} =\n    monomial (c * lookup p w) (t + w) + monomial c t * except p {w}", "by (simp only: mult_single)"], ["proof (state)\nthis:\n  monomial c t * monomial (lookup p w) w + monomial c t * except p {w} =\n  monomial (c * lookup p w) (t + w) + monomial c t * except p {w}\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "finally"], ["proof (chain)\npicking this:\n  monomial c t * p =\n  monomial (c * lookup p w) (t + w) + monomial c t * except p {w}", "have \"lookup (monomial c t * p) s = lookup (monomial (c * lookup p w) (t + w)) s + ?x\""], ["proof (prove)\nusing this:\n  monomial c t * p =\n  monomial (c * lookup p w) (t + w) + monomial c t * except p {w}\n\ngoal (1 subgoal):\n 1. lookup (monomial c t * p) s =\n    lookup (monomial (c * lookup p w) (t + w)) s +\n    (c * lookup (except p {w}) (s - t) when t adds s)", "by (simp only: lookup_add IH)"], ["proof (state)\nthis:\n  lookup (monomial c t * p) s =\n  lookup (monomial (c * lookup p w) (t + w)) s +\n  (c * lookup (except p {w}) (s - t) when t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "also"], ["proof (state)\nthis:\n  lookup (monomial c t * p) s =\n  lookup (monomial (c * lookup p w) (t + w)) s +\n  (c * lookup (except p {w}) (s - t) when t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "have \"... = (lookup (monomial (c * lookup p w) (t + w)) s +\n                    c * lookup (except p {w}) (s - t) when t adds s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial (c * lookup p w) (t + w)) s +\n    (c * lookup (except p {w}) (s - t) when t adds s) =\n    (lookup (monomial (c * lookup p w) (t + w)) s +\n     c * lookup (except p {w}) (s - t) when\n     t adds s)", "by (rule when_distrib, auto simp add: lookup_single when_def)"], ["proof (state)\nthis:\n  lookup (monomial (c * lookup p w) (t + w)) s +\n  (c * lookup (except p {w}) (s - t) when t adds s) =\n  (lookup (monomial (c * lookup p w) (t + w)) s +\n   c * lookup (except p {w}) (s - t) when\n   t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "also"], ["proof (state)\nthis:\n  lookup (monomial (c * lookup p w) (t + w)) s +\n  (c * lookup (except p {w}) (s - t) when t adds s) =\n  (lookup (monomial (c * lookup p w) (t + w)) s +\n   c * lookup (except p {w}) (s - t) when\n   t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"... = (c * lookup p (s - t) when t adds s)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (lookup (monomial (c * lookup p w) (t + w)) s +\n     c * lookup (except p {w}) (s - t) when\n     t adds s) =\n    (c * lookup p (s - t) when t adds s)", "proof (rule when_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. t adds s \\<Longrightarrow>\n    lookup (monomial (c * lookup p w) (t + w)) s +\n    c * lookup (except p {w}) (s - t) =\n    c * lookup p (s - t)", "assume \"t adds s\""], ["proof (state)\nthis:\n  t adds s\n\ngoal (1 subgoal):\n 1. t adds s \\<Longrightarrow>\n    lookup (monomial (c * lookup p w) (t + w)) s +\n    c * lookup (except p {w}) (s - t) =\n    c * lookup p (s - t)", "then"], ["proof (chain)\npicking this:\n  t adds s", "obtain u where u: \"s = t + u\""], ["proof (prove)\nusing this:\n  t adds s\n\ngoal (1 subgoal):\n 1. (\\<And>u. s = t + u \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  s = t + u\n\ngoal (1 subgoal):\n 1. t adds s \\<Longrightarrow>\n    lookup (monomial (c * lookup p w) (t + w)) s +\n    c * lookup (except p {w}) (s - t) =\n    c * lookup p (s - t)", "show \"lookup (monomial (c * lookup p w) (t + w)) s + c * lookup (except p {w}) (s - t) =\n          c * lookup p (s - t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial (c * lookup p w) (t + w)) s +\n    c * lookup (except p {w}) (s - t) =\n    c * lookup p (s - t)", "by (simp add: u, cases \"u = w\", simp_all add: lookup_except lookup_single add.commute)"], ["proof (state)\nthis:\n  lookup (monomial (c * lookup p w) (t + w)) s +\n  c * lookup (except p {w}) (s - t) =\n  c * lookup p (s - t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (lookup (monomial (c * lookup p w) (t + w)) s +\n   c * lookup (except p {w}) (s - t) when\n   t adds s) =\n  (c * lookup p (s - t) when t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (monomial c t * except p {ta}) s =\n        (c * lookup (except p {ta}) (s - t) when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (monomial c t * p) s =\n                         (c * lookup p (s - t) when t adds s)", "finally"], ["proof (chain)\npicking this:\n  lookup (monomial c t * p) s = (c * lookup p (s - t) when t adds s)", "show \"lookup (monomial c t * p) s = (c * lookup p (s - t) when t adds s)\""], ["proof (prove)\nusing this:\n  lookup (monomial c t * p) s = (c * lookup p (s - t) when t adds s)\n\ngoal (1 subgoal):\n 1. lookup (monomial c t * p) s = (c * lookup p (s - t) when t adds s)", "."], ["proof (state)\nthis:\n  lookup (monomial c t * p) s = (c * lookup p (s - t) when t adds s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_times_monomial_right: \"lookup (p * monomial c t) s = (lookup p (s - t) * c when t adds s)\"\n  for c::\"'b::semiring_0\" and t::\"'a::comm_powerprod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p * monomial c t) s = (lookup p (s - t) * c when t adds s)", "proof (induct p rule: poly_mapping_except_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "fix p::\"'a \\<Rightarrow>\\<^sub>0 'b\" and w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "assume \"p \\<noteq> 0\" and \"w \\<in> keys p\"\n    and IH: \"lookup (except p {w} * monomial c t) s =\n             ((lookup (except p {w}) (s - t)) * c when t adds s)\"\n            (is \"_ = ?x\")"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  w \\<in> keys p\n  lookup (except p {w} * monomial c t) s =\n  (lookup (except p {w}) (s - t) * c when t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "have \"p * monomial c t = (monomial (lookup p w) w + except p {w}) * monomial c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * monomial c t =\n    (monomial (lookup p w) w + except p {w}) * monomial c t", "by (simp only: plus_except[symmetric])"], ["proof (state)\nthis:\n  p * monomial c t = (monomial (lookup p w) w + except p {w}) * monomial c t\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "also"], ["proof (state)\nthis:\n  p * monomial c t = (monomial (lookup p w) w + except p {w}) * monomial c t\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "have \"... = monomial (lookup p w) w * monomial c t + except p {w} * monomial c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monomial (lookup p w) w + except p {w}) * monomial c t =\n    monomial (lookup p w) w * monomial c t + except p {w} * monomial c t", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (monomial (lookup p w) w + except p {w}) * monomial c t =\n  monomial (lookup p w) w * monomial c t + except p {w} * monomial c t\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "also"], ["proof (state)\nthis:\n  (monomial (lookup p w) w + except p {w}) * monomial c t =\n  monomial (lookup p w) w * monomial c t + except p {w} * monomial c t\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "have \"... = monomial (lookup p w * c) (w + t) + except p {w} * monomial c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (lookup p w) w * monomial c t + except p {w} * monomial c t =\n    monomial (lookup p w * c) (w + t) + except p {w} * monomial c t", "by (simp only: mult_single)"], ["proof (state)\nthis:\n  monomial (lookup p w) w * monomial c t + except p {w} * monomial c t =\n  monomial (lookup p w * c) (w + t) + except p {w} * monomial c t\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "finally"], ["proof (chain)\npicking this:\n  p * monomial c t =\n  monomial (lookup p w * c) (w + t) + except p {w} * monomial c t", "have \"lookup (p * monomial c t) s = lookup (monomial (lookup p w * c) (w + t)) s + ?x\""], ["proof (prove)\nusing this:\n  p * monomial c t =\n  monomial (lookup p w * c) (w + t) + except p {w} * monomial c t\n\ngoal (1 subgoal):\n 1. lookup (p * monomial c t) s =\n    lookup (monomial (lookup p w * c) (w + t)) s +\n    (lookup (except p {w}) (s - t) * c when t adds s)", "by (simp only: lookup_add IH)"], ["proof (state)\nthis:\n  lookup (p * monomial c t) s =\n  lookup (monomial (lookup p w * c) (w + t)) s +\n  (lookup (except p {w}) (s - t) * c when t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "also"], ["proof (state)\nthis:\n  lookup (p * monomial c t) s =\n  lookup (monomial (lookup p w * c) (w + t)) s +\n  (lookup (except p {w}) (s - t) * c when t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "have \"... = (lookup (monomial (lookup p w * c) (w + t)) s +\n                    lookup (except p {w}) (s - t) * c when t adds s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial (lookup p w * c) (w + t)) s +\n    (lookup (except p {w}) (s - t) * c when t adds s) =\n    (lookup (monomial (lookup p w * c) (w + t)) s +\n     lookup (except p {w}) (s - t) * c when\n     t adds s)", "by (rule when_distrib, auto simp add: lookup_single when_def)"], ["proof (state)\nthis:\n  lookup (monomial (lookup p w * c) (w + t)) s +\n  (lookup (except p {w}) (s - t) * c when t adds s) =\n  (lookup (monomial (lookup p w * c) (w + t)) s +\n   lookup (except p {w}) (s - t) * c when\n   t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "also"], ["proof (state)\nthis:\n  lookup (monomial (lookup p w * c) (w + t)) s +\n  (lookup (except p {w}) (s - t) * c when t adds s) =\n  (lookup (monomial (lookup p w * c) (w + t)) s +\n   lookup (except p {w}) (s - t) * c when\n   t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"... = (lookup p (s - t) * c when t adds s)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (lookup (monomial (lookup p w * c) (w + t)) s +\n     lookup (except p {w}) (s - t) * c when\n     t adds s) =\n    (lookup p (s - t) * c when t adds s)", "proof (rule when_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. t adds s \\<Longrightarrow>\n    lookup (monomial (lookup p w * c) (w + t)) s +\n    lookup (except p {w}) (s - t) * c =\n    lookup p (s - t) * c", "assume \"t adds s\""], ["proof (state)\nthis:\n  t adds s\n\ngoal (1 subgoal):\n 1. t adds s \\<Longrightarrow>\n    lookup (monomial (lookup p w * c) (w + t)) s +\n    lookup (except p {w}) (s - t) * c =\n    lookup p (s - t) * c", "then"], ["proof (chain)\npicking this:\n  t adds s", "obtain u where u: \"s = t + u\""], ["proof (prove)\nusing this:\n  t adds s\n\ngoal (1 subgoal):\n 1. (\\<And>u. s = t + u \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  s = t + u\n\ngoal (1 subgoal):\n 1. t adds s \\<Longrightarrow>\n    lookup (monomial (lookup p w * c) (w + t)) s +\n    lookup (except p {w}) (s - t) * c =\n    lookup p (s - t) * c", "show \"lookup (monomial (lookup p w * c) (w + t)) s + lookup (except p {w}) (s - t) * c =\n          lookup p (s - t) * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial (lookup p w * c) (w + t)) s +\n    lookup (except p {w}) (s - t) * c =\n    lookup p (s - t) * c", "by (simp add: u, cases \"u = w\", simp_all add: lookup_except lookup_single add.commute)"], ["proof (state)\nthis:\n  lookup (monomial (lookup p w * c) (w + t)) s +\n  lookup (except p {w}) (s - t) * c =\n  lookup p (s - t) * c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (lookup (monomial (lookup p w * c) (w + t)) s +\n   lookup (except p {w}) (s - t) * c when\n   t adds s) =\n  (lookup p (s - t) * c when t adds s)\n\ngoal (1 subgoal):\n 1. \\<And>p ta.\n       \\<lbrakk>p \\<noteq> 0; ta \\<in> keys p;\n        lookup (except p {ta} * monomial c t) s =\n        (lookup (except p {ta}) (s - t) * c when t adds s)\\<rbrakk>\n       \\<Longrightarrow> lookup (p * monomial c t) s =\n                         (lookup p (s - t) * c when t adds s)", "finally"], ["proof (chain)\npicking this:\n  lookup (p * monomial c t) s = (lookup p (s - t) * c when t adds s)", "show \"lookup (p * monomial c t) s = (lookup p (s - t) * c when t adds s)\""], ["proof (prove)\nusing this:\n  lookup (p * monomial c t) s = (lookup p (s - t) * c when t adds s)\n\ngoal (1 subgoal):\n 1. lookup (p * monomial c t) s = (lookup p (s - t) * c when t adds s)", "."], ["proof (state)\nthis:\n  lookup (p * monomial c t) s = (lookup p (s - t) * c when t adds s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Vector-Polynomials\\<close>"], ["", "text \\<open>From now on we consider multivariate vector-polynomials, i.\\,e. vectors of scalar polynomials.\n  We do this by adding a @{emph \\<open>component\\<close>} to each power-product, yielding\n  @{emph \\<open>terms\\<close>}. Vector-polynomials are then again just linear combinations of terms.\n  Note that a term is @{emph \\<open>not\\<close>} the same as a vector of power-products!\\<close>"], ["", "text \\<open>We use define terms in a locale, such that later on we can interpret the\n  locale also by ordinary power-products (without components), exploiting the canonical isomorphism\n  between @{typ 'a} and @{typ \\<open>'a \\<times> unit\\<close>}.\\<close>"], ["", "named_theorems term_simps \"simplification rules for terms\""], ["", "locale term_powerprod =\n\t\tfixes pair_of_term::\"'t \\<Rightarrow> ('a::comm_powerprod \\<times> 'k::linorder)\"\n\t\tfixes term_of_pair::\"('a \\<times> 'k) \\<Rightarrow> 't\"\n\t\tassumes term_pair [term_simps]: \"term_of_pair (pair_of_term v) = v\"\n\t\tassumes pair_term [term_simps]: \"pair_of_term (term_of_pair p) = p\"\nbegin"], ["", "lemma pair_of_term_injective:\n  assumes \"pair_of_term u = pair_of_term v\"\n  shows \"u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u = v", "from assms"], ["proof (chain)\npicking this:\n  pair_of_term u = pair_of_term v", "have \"term_of_pair (pair_of_term u) = term_of_pair (pair_of_term v)\""], ["proof (prove)\nusing this:\n  pair_of_term u = pair_of_term v\n\ngoal (1 subgoal):\n 1. term_of_pair (pair_of_term u) = term_of_pair (pair_of_term v)", "by (simp only:)"], ["proof (state)\nthis:\n  term_of_pair (pair_of_term u) = term_of_pair (pair_of_term v)\n\ngoal (1 subgoal):\n 1. u = v", "thus ?thesis"], ["proof (prove)\nusing this:\n  term_of_pair (pair_of_term u) = term_of_pair (pair_of_term v)\n\ngoal (1 subgoal):\n 1. u = v", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  u = v\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary pair_of_term_inj: \"inj pair_of_term\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj pair_of_term", "using pair_of_term_injective"], ["proof (prove)\nusing this:\n  pair_of_term ?u = pair_of_term ?v \\<Longrightarrow> ?u = ?v\n\ngoal (1 subgoal):\n 1. inj pair_of_term", "by (rule injI)"], ["", "lemma term_of_pair_injective:\n  assumes \"term_of_pair p = term_of_pair q\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = q", "from assms"], ["proof (chain)\npicking this:\n  term_of_pair p = term_of_pair q", "have \"pair_of_term (term_of_pair p) = pair_of_term (term_of_pair q)\""], ["proof (prove)\nusing this:\n  term_of_pair p = term_of_pair q\n\ngoal (1 subgoal):\n 1. pair_of_term (term_of_pair p) = pair_of_term (term_of_pair q)", "by (simp only:)"], ["proof (state)\nthis:\n  pair_of_term (term_of_pair p) = pair_of_term (term_of_pair q)\n\ngoal (1 subgoal):\n 1. p = q", "thus ?thesis"], ["proof (prove)\nusing this:\n  pair_of_term (term_of_pair p) = pair_of_term (term_of_pair q)\n\ngoal (1 subgoal):\n 1. p = q", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary term_of_pair_inj: \"inj term_of_pair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj term_of_pair", "using term_of_pair_injective"], ["proof (prove)\nusing this:\n  term_of_pair ?p = term_of_pair ?q \\<Longrightarrow> ?p = ?q\n\ngoal (1 subgoal):\n 1. inj term_of_pair", "by (rule injI)"], ["", "definition pp_of_term :: \"'t \\<Rightarrow> 'a\"\n  where \"pp_of_term v = fst (pair_of_term v)\""], ["", "definition component_of_term :: \"'t \\<Rightarrow> 'k\"\n  where \"component_of_term v = snd (pair_of_term v)\""], ["", "lemma term_of_pair_pair [term_simps]: \"term_of_pair (pp_of_term v, component_of_term v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_of_pair (pp_of_term v, component_of_term v) = v", "by (simp add: pp_of_term_def component_of_term_def term_pair)"], ["", "lemma pp_of_term_of_pair [term_simps]: \"pp_of_term (term_of_pair (t, k)) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_term (term_of_pair (t, k)) = t", "by (simp add: pp_of_term_def pair_term)"], ["", "lemma component_of_term_of_pair [term_simps]: \"component_of_term (term_of_pair (t, k)) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term (term_of_pair (t, k)) = k", "by (simp add: component_of_term_def pair_term)"], ["", "subsubsection \\<open>Additive Structure of Terms\\<close>"], ["", "definition splus :: \"'a \\<Rightarrow> 't \\<Rightarrow> 't\" (infixl \"\\<oplus>\" 75)\n  where \"splus t v = term_of_pair (t + pp_of_term v, component_of_term v)\""], ["", "definition sminus :: \"'t \\<Rightarrow> 'a \\<Rightarrow> 't\" (infixl \"\\<ominus>\" 75)\n  where \"sminus v t = term_of_pair (pp_of_term v - t, component_of_term v)\""], ["", "text \\<open>Note that the argument order in @{const sminus} is reversed compared to the order in @{const splus}.\\<close>"], ["", "definition adds_pp :: \"'a \\<Rightarrow> 't \\<Rightarrow> bool\" (infix \"adds\\<^sub>p\" 50)\n  where \"adds_pp t v \\<longleftrightarrow> t adds pp_of_term v\""], ["", "definition adds_term :: \"'t \\<Rightarrow> 't \\<Rightarrow> bool\" (infix \"adds\\<^sub>t\" 50)\n  where \"adds_term u v \\<longleftrightarrow> component_of_term u = component_of_term v \\<and> pp_of_term u adds pp_of_term v\""], ["", "lemma pp_of_term_splus [term_simps]: \"pp_of_term (t \\<oplus> v) = t + pp_of_term v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_term (t \\<oplus> v) = t + pp_of_term v", "by (simp add: splus_def term_simps)"], ["", "lemma component_of_term_splus [term_simps]: \"component_of_term (t \\<oplus> v) = component_of_term v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term (t \\<oplus> v) = component_of_term v", "by (simp add: splus_def term_simps)"], ["", "lemma pp_of_term_sminus [term_simps]: \"pp_of_term (v \\<ominus> t) = pp_of_term v - t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_term (v \\<ominus> t) = pp_of_term v - t", "by (simp add: sminus_def term_simps)"], ["", "lemma component_of_term_sminus [term_simps]: \"component_of_term (v \\<ominus> t) = component_of_term v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term (v \\<ominus> t) = component_of_term v", "by (simp add: sminus_def term_simps)"], ["", "lemma splus_sminus [term_simps]: \"(t \\<oplus> v) \\<ominus> t = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<oplus> v \\<ominus> t = v", "by (simp add: sminus_def term_simps)"], ["", "lemma splus_zero [term_simps]: \"0 \\<oplus> v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<oplus> v = v", "by (simp add: splus_def term_simps)"], ["", "lemma sminus_zero [term_simps]: \"v \\<ominus> 0 = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<ominus> (0::'a) = v", "by (simp add: sminus_def term_simps)"], ["", "lemma splus_assoc [ac_simps]: \"(s + t) \\<oplus> v = s \\<oplus> (t \\<oplus> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s + t) \\<oplus> v = s \\<oplus> (t \\<oplus> v)", "by (simp add: splus_def ac_simps term_simps)"], ["", "lemma splus_left_commute [ac_simps]: \"s \\<oplus> (t \\<oplus> v) = t \\<oplus> (s \\<oplus> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<oplus> (t \\<oplus> v) = t \\<oplus> (s \\<oplus> v)", "by (simp add: splus_def ac_simps term_simps)"], ["", "lemma splus_right_canc [term_simps]: \"t \\<oplus> v = s \\<oplus> v \\<longleftrightarrow> t = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<oplus> v = s \\<oplus> v) = (t = s)", "by (metis add_right_cancel pp_of_term_splus)"], ["", "lemma splus_left_canc [term_simps]: \"t \\<oplus> v = t \\<oplus> u \\<longleftrightarrow> v = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<oplus> v = t \\<oplus> u) = (v = u)", "by (metis splus_sminus)"], ["", "lemma adds_ppI [intro?]:\n  assumes \"v = t \\<oplus> u\"\n  shows \"t adds\\<^sub>p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t adds\\<^sub>p v", "by (simp add: adds_pp_def assms splus_def term_simps)"], ["", "lemma adds_ppE [elim?]:\n  assumes \"t adds\\<^sub>p v\"\n  obtains u where \"v = t \\<oplus> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u. v = t \\<oplus> u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u. v = t \\<oplus> u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  t adds\\<^sub>p v", "obtain s where *: \"pp_of_term v = t + s\""], ["proof (prove)\nusing this:\n  t adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        pp_of_term v = t + s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding adds_pp_def"], ["proof (prove)\nusing this:\n  t adds pp_of_term v\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        pp_of_term v = t + s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  pp_of_term v = t + s\n\ngoal (1 subgoal):\n 1. (\\<And>u. v = t \\<oplus> u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v = t \\<oplus> (term_of_pair (s, component_of_term v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = t \\<oplus> term_of_pair (s, component_of_term v)", "by (simp add: splus_def term_simps, metis * add.commute term_of_pair_pair)"], ["proof (state)\nthis:\n  v = t \\<oplus> term_of_pair (s, component_of_term v)\n\ngoal (1 subgoal):\n 1. (\\<And>u. v = t \\<oplus> u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = t \\<oplus> term_of_pair (s, component_of_term v)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adds_pp_alt: \"t adds\\<^sub>p v \\<longleftrightarrow> (\\<exists>u. v = t \\<oplus> u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t adds\\<^sub>p v) = (\\<exists>u. v = t \\<oplus> u)", "by (meson adds_ppE adds_ppI)"], ["", "lemma adds_pp_refl [term_simps]: \"(pp_of_term v) adds\\<^sub>p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_term v adds\\<^sub>p v", "by (simp add: adds_pp_def)"], ["", "lemma adds_pp_trans [trans]:\n  assumes \"s adds t\" and \"t adds\\<^sub>p v\"\n  shows \"s adds\\<^sub>p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds\\<^sub>p v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s adds\\<^sub>p v", "note assms(1)"], ["proof (state)\nthis:\n  s adds t\n\ngoal (1 subgoal):\n 1. s adds\\<^sub>p v", "also"], ["proof (state)\nthis:\n  s adds t\n\ngoal (1 subgoal):\n 1. s adds\\<^sub>p v", "from assms(2)"], ["proof (chain)\npicking this:\n  t adds\\<^sub>p v", "have \"t adds pp_of_term v\""], ["proof (prove)\nusing this:\n  t adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. t adds pp_of_term v", "by (simp only: adds_pp_def)"], ["proof (state)\nthis:\n  t adds pp_of_term v\n\ngoal (1 subgoal):\n 1. s adds\\<^sub>p v", "finally"], ["proof (chain)\npicking this:\n  s adds pp_of_term v", "show ?thesis"], ["proof (prove)\nusing this:\n  s adds pp_of_term v\n\ngoal (1 subgoal):\n 1. s adds\\<^sub>p v", "by (simp only: adds_pp_def)"], ["proof (state)\nthis:\n  s adds\\<^sub>p v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_adds_pp [term_simps]: \"0 adds\\<^sub>p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) adds\\<^sub>p v", "by (simp add: adds_pp_def)"], ["", "lemma adds_pp_splus:\n  assumes \"t adds\\<^sub>p v\"\n  shows \"t adds\\<^sub>p s \\<oplus> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t adds\\<^sub>p s \\<oplus> v", "using assms"], ["proof (prove)\nusing this:\n  t adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. t adds\\<^sub>p s \\<oplus> v", "by (simp add: adds_pp_def term_simps)"], ["", "lemma adds_pp_triv [term_simps]: \"t adds\\<^sub>p t \\<oplus> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t adds\\<^sub>p t \\<oplus> v", "by (simp add: adds_pp_def term_simps)"], ["", "lemma plus_adds_pp_mono:\n  assumes \"s adds t\"\n    and \"u adds\\<^sub>p v\"\n  shows \"s + u adds\\<^sub>p t \\<oplus> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + u adds\\<^sub>p t \\<oplus> v", "using assms"], ["proof (prove)\nusing this:\n  s adds t\n  u adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. s + u adds\\<^sub>p t \\<oplus> v", "by (simp add: adds_pp_def term_simps) (rule plus_adds_mono)"], ["", "lemma plus_adds_pp_left:\n  assumes \"s + t adds\\<^sub>p v\"\n  shows \"s adds\\<^sub>p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds\\<^sub>p v", "using assms"], ["proof (prove)\nusing this:\n  s + t adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. s adds\\<^sub>p v", "by (simp add: adds_pp_def plus_adds_left)"], ["", "lemma plus_adds_pp_right:\n  assumes \"s + t adds\\<^sub>p v\"\n  shows \"t adds\\<^sub>p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t adds\\<^sub>p v", "using assms"], ["proof (prove)\nusing this:\n  s + t adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. t adds\\<^sub>p v", "by (simp add: adds_pp_def plus_adds_right)"], ["", "lemma adds_pp_sminus:\n  assumes \"t adds\\<^sub>p v\"\n  shows \"t \\<oplus> (v \\<ominus> t) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<oplus> (v \\<ominus> t) = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<oplus> (v \\<ominus> t) = v", "from assms adds_pp_alt[of t v]"], ["proof (chain)\npicking this:\n  t adds\\<^sub>p v\n  (t adds\\<^sub>p v) = (\\<exists>u. v = t \\<oplus> u)", "obtain u where u: \"v = t \\<oplus> u\""], ["proof (prove)\nusing this:\n  t adds\\<^sub>p v\n  (t adds\\<^sub>p v) = (\\<exists>u. v = t \\<oplus> u)\n\ngoal (1 subgoal):\n 1. (\\<And>u. v = t \\<oplus> u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  v = t \\<oplus> u\n\ngoal (1 subgoal):\n 1. t \\<oplus> (v \\<ominus> t) = v", "hence \"v \\<ominus> t = u\""], ["proof (prove)\nusing this:\n  v = t \\<oplus> u\n\ngoal (1 subgoal):\n 1. v \\<ominus> t = u", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  v \\<ominus> t = u\n\ngoal (1 subgoal):\n 1. t \\<oplus> (v \\<ominus> t) = v", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<ominus> t = u\n\ngoal (1 subgoal):\n 1. t \\<oplus> (v \\<ominus> t) = v", "using u"], ["proof (prove)\nusing this:\n  v \\<ominus> t = u\n  v = t \\<oplus> u\n\ngoal (1 subgoal):\n 1. t \\<oplus> (v \\<ominus> t) = v", "by simp"], ["proof (state)\nthis:\n  t \\<oplus> (v \\<ominus> t) = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adds_pp_canc: \"t + s adds\\<^sub>p (t \\<oplus> v) \\<longleftrightarrow> s adds\\<^sub>p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t + s adds\\<^sub>p t \\<oplus> v) = (s adds\\<^sub>p v)", "by (simp add: adds_pp_def adds_canc_2 term_simps)"], ["", "lemma adds_pp_canc_2: \"s + t adds\\<^sub>p (t \\<oplus> v) \\<longleftrightarrow> s adds\\<^sub>p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s + t adds\\<^sub>p t \\<oplus> v) = (s adds\\<^sub>p v)", "by (simp add: adds_pp_canc add.commute[of s t])"], ["", "lemma plus_adds_pp_0:\n  assumes \"(s + t) adds\\<^sub>p v\"\n  shows \"s adds\\<^sub>p (v \\<ominus> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds\\<^sub>p v \\<ominus> t", "using assms"], ["proof (prove)\nusing this:\n  s + t adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. s adds\\<^sub>p v \\<ominus> t", "by (simp add: adds_pp_def term_simps) (rule plus_adds_0)"], ["", "lemma plus_adds_ppI_1:\n  assumes \"t adds\\<^sub>p v\" and \"s adds\\<^sub>p (v \\<ominus> t)\"\n  shows \"(s + t) adds\\<^sub>p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + t adds\\<^sub>p v", "using assms"], ["proof (prove)\nusing this:\n  t adds\\<^sub>p v\n  s adds\\<^sub>p v \\<ominus> t\n\ngoal (1 subgoal):\n 1. s + t adds\\<^sub>p v", "by (simp add: adds_pp_def term_simps) (rule plus_adds_2)"], ["", "lemma plus_adds_ppI_2:\n  assumes \"t adds\\<^sub>p v\" and \"s adds\\<^sub>p (v \\<ominus> t)\"\n  shows \"(t + s) adds\\<^sub>p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t + s adds\\<^sub>p v", "unfolding add.commute[of t s]"], ["proof (prove)\ngoal (1 subgoal):\n 1. s + t adds\\<^sub>p v", "using assms"], ["proof (prove)\nusing this:\n  t adds\\<^sub>p v\n  s adds\\<^sub>p v \\<ominus> t\n\ngoal (1 subgoal):\n 1. s + t adds\\<^sub>p v", "by (rule plus_adds_ppI_1)"], ["", "lemma plus_adds_pp: \"(s + t) adds\\<^sub>p v \\<longleftrightarrow> (t adds\\<^sub>p v \\<and> s adds\\<^sub>p (v \\<ominus> t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s + t adds\\<^sub>p v) =\n    (t adds\\<^sub>p v \\<and> s adds\\<^sub>p v \\<ominus> t)", "by (simp add: adds_pp_def plus_adds term_simps)"], ["", "lemma minus_splus:\n  assumes \"s adds t\"\n  shows \"(t - s) \\<oplus> v = (t \\<oplus> v) \\<ominus> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t - s) \\<oplus> v = t \\<oplus> v \\<ominus> s", "by (simp add: assms minus_plus sminus_def splus_def term_simps)"], ["", "lemma minus_splus_sminus:\n  assumes \"s adds t\" and \"u adds\\<^sub>p v\"\n  shows \"(t - s) \\<oplus> (v \\<ominus> u) = (t \\<oplus> v) \\<ominus> (s + u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t - s) \\<oplus> (v \\<ominus> u) = t \\<oplus> v \\<ominus> (s + u)", "using assms minus_plus_minus term_powerprod.adds_pp_def term_powerprod_axioms sminus_def\n    splus_def term_simps"], ["proof (prove)\nusing this:\n  s adds t\n  u adds\\<^sub>p v\n  \\<lbrakk>?s adds ?t; ?u adds ?v\\<rbrakk>\n  \\<Longrightarrow> ?t - ?s + (?v - ?u) = ?t + ?v - (?s + ?u)\n  term_powerprod ?pair_of_term ?term_of_pair \\<Longrightarrow>\n  term_powerprod.adds_pp ?pair_of_term ?t ?v =\n  (?t adds term_powerprod.pp_of_term ?pair_of_term ?v)\n  term_powerprod pair_of_term term_of_pair\n  ?v \\<ominus> ?t = term_of_pair (pp_of_term ?v - ?t, component_of_term ?v)\n  ?t \\<oplus> ?v = term_of_pair (?t + pp_of_term ?v, component_of_term ?v)\n  term_of_pair (pair_of_term ?v) = ?v\n  pair_of_term (term_of_pair ?p) = ?p\n  term_of_pair (pp_of_term ?v, component_of_term ?v) = ?v\n  pp_of_term (term_of_pair (?t, ?k)) = ?t\n  component_of_term (term_of_pair (?t, ?k)) = ?k\n  pp_of_term (?t \\<oplus> ?v) = ?t + pp_of_term ?v\n  component_of_term (?t \\<oplus> ?v) = component_of_term ?v\n  pp_of_term (?v \\<ominus> ?t) = pp_of_term ?v - ?t\n  component_of_term (?v \\<ominus> ?t) = component_of_term ?v\n  ?t \\<oplus> ?v \\<ominus> ?t = ?v\n  (0::'a) \\<oplus> ?v = ?v\n  ?v \\<ominus> (0::'a) = ?v\n  (?t \\<oplus> ?v = ?s \\<oplus> ?v) = (?t = ?s)\n  (?t \\<oplus> ?v = ?t \\<oplus> ?u) = (?v = ?u)\n  pp_of_term ?v adds\\<^sub>p ?v\n  (0::'a) adds\\<^sub>p ?v\n  ?t adds\\<^sub>p ?t \\<oplus> ?v\n\ngoal (1 subgoal):\n 1. (t - s) \\<oplus> (v \\<ominus> u) = t \\<oplus> v \\<ominus> (s + u)", "by fastforce"], ["", "lemma minus_splus_sminus_cancel:\n  assumes \"s adds t\" and \"t adds\\<^sub>p v\"\n  shows \"(t - s) \\<oplus> (v \\<ominus> t) = v \\<ominus> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t - s) \\<oplus> (v \\<ominus> t) = v \\<ominus> s", "by (simp add: adds_pp_sminus assms minus_splus)"], ["", "lemma sminus_plus:\n  assumes \"s adds\\<^sub>p v\" and \"t adds\\<^sub>p (v \\<ominus> s)\"\n  shows \"v \\<ominus> (s + t) = (v \\<ominus> s) \\<ominus> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<ominus> (s + t) = v \\<ominus> s \\<ominus> t", "by (simp add: diff_diff_add sminus_def term_simps)"], ["", "lemma adds_termI [intro?]:\n  assumes \"v = t \\<oplus> u\"\n  shows \"u adds\\<^sub>t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u adds\\<^sub>t v", "by (simp add: adds_term_def assms splus_def term_simps)"], ["", "lemma adds_termE [elim?]:\n  assumes \"u adds\\<^sub>t v\"\n  obtains t where \"v = t \\<oplus> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. v = t \\<oplus> u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t. v = t \\<oplus> u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  u adds\\<^sub>t v", "have eq: \"component_of_term u = component_of_term v\" and \"pp_of_term u adds pp_of_term v\""], ["proof (prove)\nusing this:\n  u adds\\<^sub>t v\n\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term v &&&\n    pp_of_term u adds pp_of_term v", "by (simp_all add: adds_term_def)"], ["proof (state)\nthis:\n  component_of_term u = component_of_term v\n  pp_of_term u adds pp_of_term v\n\ngoal (1 subgoal):\n 1. (\\<And>t. v = t \\<oplus> u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(2)"], ["proof (chain)\npicking this:\n  pp_of_term u adds pp_of_term v", "obtain s where *: \"s + pp_of_term u = pp_of_term v\""], ["proof (prove)\nusing this:\n  pp_of_term u adds pp_of_term v\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s + pp_of_term u = pp_of_term v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding adds_term_def"], ["proof (prove)\nusing this:\n  pp_of_term u adds pp_of_term v\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s + pp_of_term u = pp_of_term v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using adds_minus"], ["proof (prove)\nusing this:\n  pp_of_term u adds pp_of_term v\n  ?s adds ?t \\<Longrightarrow> ?t - ?s + ?s = ?t\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s + pp_of_term u = pp_of_term v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s + pp_of_term u = pp_of_term v\n\ngoal (1 subgoal):\n 1. (\\<And>t. v = t \\<oplus> u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v = s \\<oplus> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = s \\<oplus> u", "by (simp add: splus_def eq * term_simps)"], ["proof (state)\nthis:\n  v = s \\<oplus> u\n\ngoal (1 subgoal):\n 1. (\\<And>t. v = t \\<oplus> u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = s \\<oplus> u\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adds_term_alt: \"u adds\\<^sub>t v \\<longleftrightarrow> (\\<exists>t. v = t \\<oplus> u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u adds\\<^sub>t v) = (\\<exists>t. v = t \\<oplus> u)", "by (meson adds_termE adds_termI)"], ["", "lemma adds_term_refl [term_simps]: \"v adds\\<^sub>t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v adds\\<^sub>t v", "by (simp add: adds_term_def)"], ["", "lemma adds_term_trans [trans]:\n  assumes \"u adds\\<^sub>t v\" and \"v adds\\<^sub>t w\"\n  shows \"u adds\\<^sub>t w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u adds\\<^sub>t w", "using assms"], ["proof (prove)\nusing this:\n  u adds\\<^sub>t v\n  v adds\\<^sub>t w\n\ngoal (1 subgoal):\n 1. u adds\\<^sub>t w", "unfolding adds_term_def"], ["proof (prove)\nusing this:\n  component_of_term u = component_of_term v \\<and>\n  pp_of_term u adds pp_of_term v\n  component_of_term v = component_of_term w \\<and>\n  pp_of_term v adds pp_of_term w\n\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term w \\<and>\n    pp_of_term u adds pp_of_term w", "using adds_trans"], ["proof (prove)\nusing this:\n  component_of_term u = component_of_term v \\<and>\n  pp_of_term u adds pp_of_term v\n  component_of_term v = component_of_term w \\<and>\n  pp_of_term v adds pp_of_term w\n  \\<lbrakk>?a adds ?b; ?b adds ?c\\<rbrakk> \\<Longrightarrow> ?a adds ?c\n\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term w \\<and>\n    pp_of_term u adds pp_of_term w", "by auto"], ["", "lemma adds_term_splus:\n  assumes \"u adds\\<^sub>t v\"\n  shows \"u adds\\<^sub>t s \\<oplus> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u adds\\<^sub>t s \\<oplus> v", "using assms"], ["proof (prove)\nusing this:\n  u adds\\<^sub>t v\n\ngoal (1 subgoal):\n 1. u adds\\<^sub>t s \\<oplus> v", "by (simp add: adds_term_def term_simps)"], ["", "lemma adds_term_triv [term_simps]: \"v adds\\<^sub>t t \\<oplus> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v adds\\<^sub>t t \\<oplus> v", "by (simp add: adds_term_def term_simps)"], ["", "lemma splus_adds_term_mono:\n  assumes \"s adds t\"\n    and \"u adds\\<^sub>t v\"\n  shows \"s \\<oplus> u adds\\<^sub>t t \\<oplus> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<oplus> u adds\\<^sub>t t \\<oplus> v", "using assms"], ["proof (prove)\nusing this:\n  s adds t\n  u adds\\<^sub>t v\n\ngoal (1 subgoal):\n 1. s \\<oplus> u adds\\<^sub>t t \\<oplus> v", "by (auto simp: adds_term_def term_simps intro: plus_adds_mono)"], ["", "lemma splus_adds_term:\n  assumes \"t \\<oplus> u adds\\<^sub>t v\"\n  shows \"u adds\\<^sub>t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u adds\\<^sub>t v", "using assms"], ["proof (prove)\nusing this:\n  t \\<oplus> u adds\\<^sub>t v\n\ngoal (1 subgoal):\n 1. u adds\\<^sub>t v", "by (auto simp add: adds_term_def term_simps elim: plus_adds_right)"], ["", "lemma adds_term_adds_pp:\n  \"u adds\\<^sub>t v \\<longleftrightarrow> (component_of_term u = component_of_term v \\<and> pp_of_term u adds\\<^sub>p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u adds\\<^sub>t v) =\n    (component_of_term u = component_of_term v \\<and>\n     pp_of_term u adds\\<^sub>p v)", "by (simp add: adds_term_def adds_pp_def)"], ["", "lemma adds_term_canc: \"t \\<oplus> u adds\\<^sub>t t \\<oplus> v \\<longleftrightarrow> u adds\\<^sub>t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<oplus> u adds\\<^sub>t t \\<oplus> v) = (u adds\\<^sub>t v)", "by (simp add: adds_term_def adds_canc_2 term_simps)"], ["", "lemma adds_term_canc_2: \"s \\<oplus> v adds\\<^sub>t t \\<oplus> v \\<longleftrightarrow> s adds t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<oplus> v adds\\<^sub>t t \\<oplus> v) = (s adds t)", "by (simp add: adds_term_def adds_canc term_simps)"], ["", "lemma splus_adds_term_0:\n  assumes \"t \\<oplus> u adds\\<^sub>t v\"\n  shows \"u adds\\<^sub>t (v \\<ominus> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u adds\\<^sub>t v \\<ominus> t", "using assms"], ["proof (prove)\nusing this:\n  t \\<oplus> u adds\\<^sub>t v\n\ngoal (1 subgoal):\n 1. u adds\\<^sub>t v \\<ominus> t", "by (simp add: adds_term_def add.commute[of t] term_simps) (auto intro: plus_adds_0)"], ["", "lemma splus_adds_termI_1:\n  assumes \"t adds\\<^sub>p v\" and \"u adds\\<^sub>t (v \\<ominus> t)\"\n  shows \"t \\<oplus> u adds\\<^sub>t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<oplus> u adds\\<^sub>t v", "using assms"], ["proof (prove)\nusing this:\n  t adds\\<^sub>p v\n  u adds\\<^sub>t v \\<ominus> t\n\ngoal (1 subgoal):\n 1. t \\<oplus> u adds\\<^sub>t v", "apply (simp add: adds_term_def term_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t adds\\<^sub>p v;\n     component_of_term u = component_of_term v \\<and>\n     pp_of_term u adds pp_of_term v - t\\<rbrakk>\n    \\<Longrightarrow> t + pp_of_term u adds pp_of_term v", "by (metis add.commute adds_pp_def plus_adds_2)"], ["", "lemma splus_adds_term_iff: \"t \\<oplus> u adds\\<^sub>t v \\<longleftrightarrow> (t adds\\<^sub>p v \\<and> u adds\\<^sub>t (v \\<ominus> t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<oplus> u adds\\<^sub>t v) =\n    (t adds\\<^sub>p v \\<and> u adds\\<^sub>t v \\<ominus> t)", "by (metis adds_ppI adds_pp_splus adds_termE splus_adds_termI_1 splus_adds_term_0)"], ["", "lemma adds_minus_splus:\n  assumes \"pp_of_term u adds t\"\n  shows \"(t - pp_of_term u) \\<oplus> u = term_of_pair (t, component_of_term u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t - pp_of_term u) \\<oplus> u = term_of_pair (t, component_of_term u)", "by (simp add: splus_def adds_minus[OF assms])"], ["", "subsubsection \\<open>Projections and Conversions\\<close>"], ["", "lift_definition proj_poly :: \"'k \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b::zero)\"\n  is \"\\<lambda>k p t. p (term_of_pair (t, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k fun.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. fun (term_of_pair (x, k)) \\<noteq> (0::'b)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k fun.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. fun (term_of_pair (x, k)) \\<noteq> (0::'b)}", "fix k::'k and p::\"'t \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k fun.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. fun (term_of_pair (x, k)) \\<noteq> (0::'b)}", "assume fin: \"finite {v. p v \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {v. p v \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>k fun.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. fun (term_of_pair (x, k)) \\<noteq> (0::'b)}", "have \"{t. p (term_of_pair (t, k)) \\<noteq> 0} \\<subseteq> pp_of_term ` {v. p v \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. p (term_of_pair (t, k)) \\<noteq> (0::'b)}\n    \\<subseteq> pp_of_term ` {v. p v \\<noteq> (0::'b)}", "proof (rule, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       p (term_of_pair (x, k)) \\<noteq> (0::'b) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {v. p v \\<noteq> (0::'b)}", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       p (term_of_pair (x, k)) \\<noteq> (0::'b) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {v. p v \\<noteq> (0::'b)}", "assume \"p (term_of_pair (t, k)) \\<noteq> 0\""], ["proof (state)\nthis:\n  p (term_of_pair (t, k)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       p (term_of_pair (x, k)) \\<noteq> (0::'b) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {v. p v \\<noteq> (0::'b)}", "hence *: \"term_of_pair (t, k) \\<in> {v. p v \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  p (term_of_pair (t, k)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. term_of_pair (t, k) \\<in> {v. p v \\<noteq> (0::'b)}", "by simp"], ["proof (state)\nthis:\n  term_of_pair (t, k) \\<in> {v. p v \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       p (term_of_pair (x, k)) \\<noteq> (0::'b) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {v. p v \\<noteq> (0::'b)}", "have \"t = pp_of_term (term_of_pair (t, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = pp_of_term (term_of_pair (t, k))", "by (simp add: pp_of_term_def pair_term)"], ["proof (state)\nthis:\n  t = pp_of_term (term_of_pair (t, k))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       p (term_of_pair (x, k)) \\<noteq> (0::'b) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {v. p v \\<noteq> (0::'b)}", "from this *"], ["proof (chain)\npicking this:\n  t = pp_of_term (term_of_pair (t, k))\n  term_of_pair (t, k) \\<in> {v. p v \\<noteq> (0::'b)}", "show \"t \\<in> pp_of_term ` {v. p v \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  t = pp_of_term (term_of_pair (t, k))\n  term_of_pair (t, k) \\<in> {v. p v \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. t \\<in> pp_of_term ` {v. p v \\<noteq> (0::'b)}", ".."], ["proof (state)\nthis:\n  t \\<in> pp_of_term ` {v. p v \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {t. p (term_of_pair (t, k)) \\<noteq> (0::'b)}\n  \\<subseteq> pp_of_term ` {v. p v \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>k fun.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. fun (term_of_pair (x, k)) \\<noteq> (0::'b)}", "moreover"], ["proof (state)\nthis:\n  {t. p (term_of_pair (t, k)) \\<noteq> (0::'b)}\n  \\<subseteq> pp_of_term ` {v. p v \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>k fun.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. fun (term_of_pair (x, k)) \\<noteq> (0::'b)}", "from fin"], ["proof (chain)\npicking this:\n  finite {v. p v \\<noteq> (0::'b)}", "have \"finite (pp_of_term ` {v. p v \\<noteq> 0})\""], ["proof (prove)\nusing this:\n  finite {v. p v \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. finite (pp_of_term ` {v. p v \\<noteq> (0::'b)})", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite (pp_of_term ` {v. p v \\<noteq> (0::'b)})\n\ngoal (1 subgoal):\n 1. \\<And>k fun.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. fun (term_of_pair (x, k)) \\<noteq> (0::'b)}", "ultimately"], ["proof (chain)\npicking this:\n  {t. p (term_of_pair (t, k)) \\<noteq> (0::'b)}\n  \\<subseteq> pp_of_term ` {v. p v \\<noteq> (0::'b)}\n  finite (pp_of_term ` {v. p v \\<noteq> (0::'b)})", "show \"finite {t. p (term_of_pair (t, k)) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  {t. p (term_of_pair (t, k)) \\<noteq> (0::'b)}\n  \\<subseteq> pp_of_term ` {v. p v \\<noteq> (0::'b)}\n  finite (pp_of_term ` {v. p v \\<noteq> (0::'b)})\n\ngoal (1 subgoal):\n 1. finite {t. p (term_of_pair (t, k)) \\<noteq> (0::'b)}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {t. p (term_of_pair (t, k)) \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition vectorize_poly :: \"('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('k \\<Rightarrow>\\<^sub>0 ('a \\<Rightarrow>\\<^sub>0 'b::zero))\"\n  where \"vectorize_poly p = Abs_poly_mapping (\\<lambda>k. proj_poly k p)\""], ["", "definition atomize_poly :: \"('k \\<Rightarrow>\\<^sub>0 ('a \\<Rightarrow>\\<^sub>0 'b)) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::zero)\"\n  where \"atomize_poly p = Abs_poly_mapping (\\<lambda>v. lookup (lookup p (component_of_term v)) (pp_of_term v))\""], ["", "lemma lookup_proj_poly: \"lookup (proj_poly k p) t = lookup p (term_of_pair (t, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (proj_poly k p) t = lookup p (term_of_pair (t, k))", "by (transfer, simp)"], ["", "lemma lookup_vectorize_poly: \"lookup (vectorize_poly p) k = proj_poly k p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (vectorize_poly p) k = proj_poly k p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (vectorize_poly p) k = proj_poly k p", "have \"lookup (Abs_poly_mapping (\\<lambda>k. proj_poly k p)) = (\\<lambda>k. proj_poly k p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping (\\<lambda>k. proj_poly k p)) =\n    (\\<lambda>k. proj_poly k p)", "proof (rule Abs_poly_mapping_inverse, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. proj_poly x p \\<noteq> 0}", "have \"{k. proj_poly k p \\<noteq> 0} \\<subseteq> component_of_term ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k. proj_poly k p \\<noteq> 0} \\<subseteq> component_of_term ` keys p", "proof (rule, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       proj_poly x p \\<noteq> 0 \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       proj_poly x p \\<noteq> 0 \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "assume \"proj_poly k p \\<noteq> 0\""], ["proof (state)\nthis:\n  proj_poly k p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       proj_poly x p \\<noteq> 0 \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "hence \"keys (proj_poly k p) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  proj_poly k p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys (proj_poly k p) \\<noteq> {}", "using poly_mapping_eq_zeroI"], ["proof (prove)\nusing this:\n  proj_poly k p \\<noteq> 0\n  keys ?s = {} \\<Longrightarrow> ?s = 0\n\ngoal (1 subgoal):\n 1. keys (proj_poly k p) \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  keys (proj_poly k p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       proj_poly x p \\<noteq> 0 \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "then"], ["proof (chain)\npicking this:\n  keys (proj_poly k p) \\<noteq> {}", "obtain t where \"lookup (proj_poly k p) t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  keys (proj_poly k p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        lookup (proj_poly k p) t \\<noteq> (0::'b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lookup (proj_poly k p) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       proj_poly x p \\<noteq> 0 \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "hence \"term_of_pair (t, k) \\<in> keys p\""], ["proof (prove)\nusing this:\n  lookup (proj_poly k p) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. term_of_pair (t, k) \\<in> keys p", "by (simp add: lookup_proj_poly in_keys_iff)"], ["proof (state)\nthis:\n  term_of_pair (t, k) \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       proj_poly x p \\<noteq> 0 \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "hence \"component_of_term (term_of_pair (t, k)) \\<in> component_of_term ` keys p\""], ["proof (prove)\nusing this:\n  term_of_pair (t, k) \\<in> keys p\n\ngoal (1 subgoal):\n 1. component_of_term (term_of_pair (t, k)) \\<in> component_of_term ` keys p", "by fastforce"], ["proof (state)\nthis:\n  component_of_term (term_of_pair (t, k)) \\<in> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       proj_poly x p \\<noteq> 0 \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "thus \"k \\<in> component_of_term ` keys p\""], ["proof (prove)\nusing this:\n  component_of_term (term_of_pair (t, k)) \\<in> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. k \\<in> component_of_term ` keys p", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  k \\<in> component_of_term ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {k. proj_poly k p \\<noteq> 0} \\<subseteq> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. finite {x. proj_poly x p \\<noteq> 0}", "moreover"], ["proof (state)\nthis:\n  {k. proj_poly k p \\<noteq> 0} \\<subseteq> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. finite {x. proj_poly x p \\<noteq> 0}", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"finite (component_of_term ` keys p)\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. finite (component_of_term ` keys p)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite (component_of_term ` keys p)\n\ngoal (1 subgoal):\n 1. finite {x. proj_poly x p \\<noteq> 0}", "ultimately"], ["proof (chain)\npicking this:\n  {k. proj_poly k p \\<noteq> 0} \\<subseteq> component_of_term ` keys p\n  finite (component_of_term ` keys p)", "show \"finite {k. proj_poly k p \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  {k. proj_poly k p \\<noteq> 0} \\<subseteq> component_of_term ` keys p\n  finite (component_of_term ` keys p)\n\ngoal (1 subgoal):\n 1. finite {k. proj_poly k p \\<noteq> 0}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {k. proj_poly k p \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (Abs_poly_mapping (\\<lambda>k. proj_poly k p)) =\n  (\\<lambda>k. proj_poly k p)\n\ngoal (1 subgoal):\n 1. lookup (vectorize_poly p) k = proj_poly k p", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup (Abs_poly_mapping (\\<lambda>k. proj_poly k p)) =\n  (\\<lambda>k. proj_poly k p)\n\ngoal (1 subgoal):\n 1. lookup (vectorize_poly p) k = proj_poly k p", "by (simp add: vectorize_poly_def)"], ["proof (state)\nthis:\n  lookup (vectorize_poly p) k = proj_poly k p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_atomize_poly:\n  \"lookup (atomize_poly p) v = lookup (lookup p (component_of_term v)) (pp_of_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (atomize_poly p) v =\n    lookup (lookup p (component_of_term v)) (pp_of_term v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (atomize_poly p) v =\n    lookup (lookup p (component_of_term v)) (pp_of_term v)", "have \"lookup (Abs_poly_mapping (\\<lambda>v. lookup (lookup p (component_of_term v)) (pp_of_term v))) =\n        (\\<lambda>v. lookup (lookup p (component_of_term v)) (pp_of_term v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Abs_poly_mapping\n       (\\<lambda>v.\n           lookup (lookup p (component_of_term v)) (pp_of_term v))) =\n    (\\<lambda>v. lookup (lookup p (component_of_term v)) (pp_of_term v))", "proof (rule Abs_poly_mapping_inverse, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {x. lookup (lookup p (component_of_term x)) (pp_of_term x) \\<noteq>\n         (0::'b)}", "have \"{v. pp_of_term v \\<in> keys (lookup p (component_of_term v))} \\<subseteq>\n          (\\<Union>k\\<in>keys p. (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\" (is \"_ \\<subseteq> ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. pp_of_term v \\<in> keys (lookup p (component_of_term v))}\n    \\<subseteq> (\\<Union>k\\<in>keys p.\n                    (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "proof (rule, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       pp_of_term x\n       \\<in> keys (lookup p (component_of_term x)) \\<Longrightarrow>\n       \\<exists>xa\\<in>keys p.\n          x \\<in> (\\<lambda>t. term_of_pair (t, xa)) ` keys (lookup p xa)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       pp_of_term x\n       \\<in> keys (lookup p (component_of_term x)) \\<Longrightarrow>\n       \\<exists>xa\\<in>keys p.\n          x \\<in> (\\<lambda>t. term_of_pair (t, xa)) ` keys (lookup p xa)", "assume *: \"pp_of_term v \\<in> keys (lookup p (component_of_term v))\""], ["proof (state)\nthis:\n  pp_of_term v \\<in> keys (lookup p (component_of_term v))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       pp_of_term x\n       \\<in> keys (lookup p (component_of_term x)) \\<Longrightarrow>\n       \\<exists>xa\\<in>keys p.\n          x \\<in> (\\<lambda>t. term_of_pair (t, xa)) ` keys (lookup p xa)", "hence \"keys (lookup p (component_of_term v)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  pp_of_term v \\<in> keys (lookup p (component_of_term v))\n\ngoal (1 subgoal):\n 1. keys (lookup p (component_of_term v)) \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  keys (lookup p (component_of_term v)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       pp_of_term x\n       \\<in> keys (lookup p (component_of_term x)) \\<Longrightarrow>\n       \\<exists>xa\\<in>keys p.\n          x \\<in> (\\<lambda>t. term_of_pair (t, xa)) ` keys (lookup p xa)", "hence \"lookup p (component_of_term v) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  keys (lookup p (component_of_term v)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lookup p (component_of_term v) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lookup p (component_of_term v) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       pp_of_term x\n       \\<in> keys (lookup p (component_of_term x)) \\<Longrightarrow>\n       \\<exists>xa\\<in>keys p.\n          x \\<in> (\\<lambda>t. term_of_pair (t, xa)) ` keys (lookup p xa)", "hence \"component_of_term v \\<in> keys p\" (is \"?k \\<in> _\")"], ["proof (prove)\nusing this:\n  lookup p (component_of_term v) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. component_of_term v \\<in> keys p", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  component_of_term v \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       pp_of_term x\n       \\<in> keys (lookup p (component_of_term x)) \\<Longrightarrow>\n       \\<exists>xa\\<in>keys p.\n          x \\<in> (\\<lambda>t. term_of_pair (t, xa)) ` keys (lookup p xa)", "thus \"\\<exists>k\\<in>keys p. v \\<in> (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k)\""], ["proof (prove)\nusing this:\n  component_of_term v \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>keys p.\n       v \\<in> (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) `\n            keys (lookup p (component_of_term v))", "have \"v = term_of_pair (pp_of_term v, component_of_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = term_of_pair (pp_of_term v, component_of_term v)", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  v = term_of_pair (pp_of_term v, component_of_term v)\n\ngoal (1 subgoal):\n 1. v \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) `\n            keys (lookup p (component_of_term v))", "from this *"], ["proof (chain)\npicking this:\n  v = term_of_pair (pp_of_term v, component_of_term v)\n  pp_of_term v \\<in> keys (lookup p (component_of_term v))", "show \"v \\<in> (\\<lambda>t. term_of_pair (t, ?k)) ` keys (lookup p ?k)\""], ["proof (prove)\nusing this:\n  v = term_of_pair (pp_of_term v, component_of_term v)\n  pp_of_term v \\<in> keys (lookup p (component_of_term v))\n\ngoal (1 subgoal):\n 1. v \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) `\n            keys (lookup p (component_of_term v))", ".."], ["proof (state)\nthis:\n  v \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) `\n          keys (lookup p (component_of_term v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k\\<in>keys p.\n     v \\<in> (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {v. pp_of_term v \\<in> keys (lookup p (component_of_term v))}\n  \\<subseteq> (\\<Union>k\\<in>keys p.\n                  (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n\ngoal (1 subgoal):\n 1. finite\n     {x. lookup (lookup p (component_of_term x)) (pp_of_term x) \\<noteq>\n         (0::'b)}", "moreover"], ["proof (state)\nthis:\n  {v. pp_of_term v \\<in> keys (lookup p (component_of_term v))}\n  \\<subseteq> (\\<Union>k\\<in>keys p.\n                  (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n\ngoal (1 subgoal):\n 1. finite\n     {x. lookup (lookup p (component_of_term x)) (pp_of_term x) \\<noteq>\n         (0::'b)}", "have \"finite ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>k\\<in>keys p.\n         (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "by (rule, fact finite_keys, rule finite_imageI, rule finite_keys)"], ["proof (state)\nthis:\n  finite\n   (\\<Union>k\\<in>keys p.\n       (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n\ngoal (1 subgoal):\n 1. finite\n     {x. lookup (lookup p (component_of_term x)) (pp_of_term x) \\<noteq>\n         (0::'b)}", "ultimately"], ["proof (chain)\npicking this:\n  {v. pp_of_term v \\<in> keys (lookup p (component_of_term v))}\n  \\<subseteq> (\\<Union>k\\<in>keys p.\n                  (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n  finite\n   (\\<Union>k\\<in>keys p.\n       (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "show \"finite {x. lookup (lookup p (component_of_term x)) (pp_of_term x) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  {v. pp_of_term v \\<in> keys (lookup p (component_of_term v))}\n  \\<subseteq> (\\<Union>k\\<in>keys p.\n                  (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n  finite\n   (\\<Union>k\\<in>keys p.\n       (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n\ngoal (1 subgoal):\n 1. finite\n     {x. lookup (lookup p (component_of_term x)) (pp_of_term x) \\<noteq>\n         (0::'b)}", "by (simp add: finite_subset in_keys_iff)"], ["proof (state)\nthis:\n  finite\n   {x. lookup (lookup p (component_of_term x)) (pp_of_term x) \\<noteq>\n       (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup\n   (Abs_poly_mapping\n     (\\<lambda>v. lookup (lookup p (component_of_term v)) (pp_of_term v))) =\n  (\\<lambda>v. lookup (lookup p (component_of_term v)) (pp_of_term v))\n\ngoal (1 subgoal):\n 1. lookup (atomize_poly p) v =\n    lookup (lookup p (component_of_term v)) (pp_of_term v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup\n   (Abs_poly_mapping\n     (\\<lambda>v. lookup (lookup p (component_of_term v)) (pp_of_term v))) =\n  (\\<lambda>v. lookup (lookup p (component_of_term v)) (pp_of_term v))\n\ngoal (1 subgoal):\n 1. lookup (atomize_poly p) v =\n    lookup (lookup p (component_of_term v)) (pp_of_term v)", "by (simp add: atomize_poly_def)"], ["proof (state)\nthis:\n  lookup (atomize_poly p) v =\n  lookup (lookup p (component_of_term v)) (pp_of_term v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_proj_poly: \"keys (proj_poly k p) = pp_of_term ` {x\\<in>keys p. component_of_term x = k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (proj_poly k p) =\n    pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (proj_poly k p)\n    \\<subseteq> pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n 2. pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n    \\<subseteq> keys (proj_poly k p)", "show \"keys (proj_poly k p) \\<subseteq> pp_of_term ` {x\\<in>keys p. component_of_term x = k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (proj_poly k p)\n    \\<subseteq> pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (proj_poly k p) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (proj_poly k p) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "assume \"t \\<in> keys (proj_poly k p)\""], ["proof (state)\nthis:\n  t \\<in> keys (proj_poly k p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (proj_poly k p) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "hence \"lookup (proj_poly k p) t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys (proj_poly k p)\n\ngoal (1 subgoal):\n 1. lookup (proj_poly k p) t \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup (proj_poly k p) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (proj_poly k p) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "hence \"term_of_pair (t, k) \\<in> keys p\""], ["proof (prove)\nusing this:\n  lookup (proj_poly k p) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. term_of_pair (t, k) \\<in> keys p", "by (simp add: in_keys_iff lookup_proj_poly)"], ["proof (state)\nthis:\n  term_of_pair (t, k) \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (proj_poly k p) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "hence \"term_of_pair (t, k) \\<in> {x\\<in>keys p. component_of_term x = k}\""], ["proof (prove)\nusing this:\n  term_of_pair (t, k) \\<in> keys p\n\ngoal (1 subgoal):\n 1. term_of_pair (t, k) \\<in> {x \\<in> keys p. component_of_term x = k}", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  term_of_pair (t, k) \\<in> {x \\<in> keys p. component_of_term x = k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (proj_poly k p) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "hence \"pp_of_term (term_of_pair (t, k)) \\<in> pp_of_term ` {x\\<in>keys p. component_of_term x = k}\""], ["proof (prove)\nusing this:\n  term_of_pair (t, k) \\<in> {x \\<in> keys p. component_of_term x = k}\n\ngoal (1 subgoal):\n 1. pp_of_term (term_of_pair (t, k))\n    \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "by (rule imageI)"], ["proof (state)\nthis:\n  pp_of_term (term_of_pair (t, k))\n  \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (proj_poly k p) \\<Longrightarrow>\n       x \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "thus \"t \\<in> pp_of_term ` {x\\<in>keys p. component_of_term x = k}\""], ["proof (prove)\nusing this:\n  pp_of_term (term_of_pair (t, k))\n  \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n\ngoal (1 subgoal):\n 1. t \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "by (simp only: pp_of_term_of_pair)"], ["proof (state)\nthis:\n  t \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (proj_poly k p)\n  \\<subseteq> pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n\ngoal (1 subgoal):\n 1. pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n    \\<subseteq> keys (proj_poly k p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n    \\<subseteq> keys (proj_poly k p)", "show \"pp_of_term ` {x\\<in>keys p. component_of_term x = k} \\<subseteq> keys (proj_poly k p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n    \\<subseteq> keys (proj_poly k p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term `\n               {x \\<in> keys p. component_of_term x = k} \\<Longrightarrow>\n       x \\<in> keys (proj_poly k p)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term `\n               {x \\<in> keys p. component_of_term x = k} \\<Longrightarrow>\n       x \\<in> keys (proj_poly k p)", "assume \"t \\<in> pp_of_term ` {x\\<in>keys p. component_of_term x = k}\""], ["proof (state)\nthis:\n  t \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term `\n               {x \\<in> keys p. component_of_term x = k} \\<Longrightarrow>\n       x \\<in> keys (proj_poly k p)", "then"], ["proof (chain)\npicking this:\n  t \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}", "obtain x where \"x \\<in> {x\\<in>keys p. component_of_term x = k}\" and \"t = pp_of_term x\""], ["proof (prove)\nusing this:\n  t \\<in> pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> {x \\<in> keys p. component_of_term x = k};\n         t = pp_of_term x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> {x \\<in> keys p. component_of_term x = k}\n  t = pp_of_term x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term `\n               {x \\<in> keys p. component_of_term x = k} \\<Longrightarrow>\n       x \\<in> keys (proj_poly k p)", "from this(1)"], ["proof (chain)\npicking this:\n  x \\<in> {x \\<in> keys p. component_of_term x = k}", "have \"x \\<in> keys p\" and \"k = component_of_term x\""], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> keys p. component_of_term x = k}\n\ngoal (1 subgoal):\n 1. x \\<in> keys p &&& k = component_of_term x", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> keys p\n  k = component_of_term x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term `\n               {x \\<in> keys p. component_of_term x = k} \\<Longrightarrow>\n       x \\<in> keys (proj_poly k p)", "from this(2)"], ["proof (chain)\npicking this:\n  k = component_of_term x", "have \"x = term_of_pair (t, k)\""], ["proof (prove)\nusing this:\n  k = component_of_term x\n\ngoal (1 subgoal):\n 1. x = term_of_pair (t, k)", "by (simp add: term_of_pair_pair \\<open>t = pp_of_term x\\<close>)"], ["proof (state)\nthis:\n  x = term_of_pair (t, k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term `\n               {x \\<in> keys p. component_of_term x = k} \\<Longrightarrow>\n       x \\<in> keys (proj_poly k p)", "with \\<open>x \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> keys p\n  x = term_of_pair (t, k)", "have \"lookup p (term_of_pair (t, k)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> keys p\n  x = term_of_pair (t, k)\n\ngoal (1 subgoal):\n 1. lookup p (term_of_pair (t, k)) \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup p (term_of_pair (t, k)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term `\n               {x \\<in> keys p. component_of_term x = k} \\<Longrightarrow>\n       x \\<in> keys (proj_poly k p)", "hence \"lookup (proj_poly k p) t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lookup p (term_of_pair (t, k)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup (proj_poly k p) t \\<noteq> (0::'b)", "by (simp add: lookup_proj_poly)"], ["proof (state)\nthis:\n  lookup (proj_poly k p) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term `\n               {x \\<in> keys p. component_of_term x = k} \\<Longrightarrow>\n       x \\<in> keys (proj_poly k p)", "thus \"t \\<in> keys (proj_poly k p)\""], ["proof (prove)\nusing this:\n  lookup (proj_poly k p) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (proj_poly k p)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  t \\<in> keys (proj_poly k p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pp_of_term ` {x \\<in> keys p. component_of_term x = k}\n  \\<subseteq> keys (proj_poly k p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_vectorize_poly: \"keys (vectorize_poly p) = component_of_term ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (vectorize_poly p) = component_of_term ` keys p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (vectorize_poly p) \\<subseteq> component_of_term ` keys p\n 2. component_of_term ` keys p \\<subseteq> keys (vectorize_poly p)", "show \"keys (vectorize_poly p) \\<subseteq> component_of_term ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (vectorize_poly p) \\<subseteq> component_of_term ` keys p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (vectorize_poly p) \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (vectorize_poly p) \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "assume \"k \\<in> keys (vectorize_poly p)\""], ["proof (state)\nthis:\n  k \\<in> keys (vectorize_poly p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (vectorize_poly p) \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "hence \"lookup (vectorize_poly p) k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k \\<in> keys (vectorize_poly p)\n\ngoal (1 subgoal):\n 1. lookup (vectorize_poly p) k \\<noteq> 0", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup (vectorize_poly p) k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (vectorize_poly p) \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "hence \"proj_poly k p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lookup (vectorize_poly p) k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj_poly k p \\<noteq> 0", "by (simp add: lookup_vectorize_poly)"], ["proof (state)\nthis:\n  proj_poly k p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (vectorize_poly p) \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "then"], ["proof (chain)\npicking this:\n  proj_poly k p \\<noteq> 0", "obtain t where \"lookup (proj_poly k p) t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  proj_poly k p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        lookup (proj_poly k p) t \\<noteq> (0::'b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using aux"], ["proof (prove)\nusing this:\n  proj_poly k p \\<noteq> 0\n  (lookup ?f = (\\<lambda>_. 0::?'b)) = (?f = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        lookup (proj_poly k p) t \\<noteq> (0::'b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lookup (proj_poly k p) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (vectorize_poly p) \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "hence \"term_of_pair (t, k) \\<in> keys p\""], ["proof (prove)\nusing this:\n  lookup (proj_poly k p) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. term_of_pair (t, k) \\<in> keys p", "by (simp add: lookup_proj_poly in_keys_iff)"], ["proof (state)\nthis:\n  term_of_pair (t, k) \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (vectorize_poly p) \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "hence \"component_of_term (term_of_pair (t, k)) \\<in> component_of_term ` keys p\""], ["proof (prove)\nusing this:\n  term_of_pair (t, k) \\<in> keys p\n\ngoal (1 subgoal):\n 1. component_of_term (term_of_pair (t, k)) \\<in> component_of_term ` keys p", "by (rule imageI)"], ["proof (state)\nthis:\n  component_of_term (term_of_pair (t, k)) \\<in> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (vectorize_poly p) \\<Longrightarrow>\n       x \\<in> component_of_term ` keys p", "thus \"k \\<in> component_of_term ` keys p\""], ["proof (prove)\nusing this:\n  component_of_term (term_of_pair (t, k)) \\<in> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. k \\<in> component_of_term ` keys p", "by (simp only: component_of_term_of_pair)"], ["proof (state)\nthis:\n  k \\<in> component_of_term ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (vectorize_poly p) \\<subseteq> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> keys (vectorize_poly p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> keys (vectorize_poly p)", "show \"component_of_term ` keys p \\<subseteq> keys (vectorize_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> keys (vectorize_poly p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` keys p \\<Longrightarrow>\n       x \\<in> keys (vectorize_poly p)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` keys p \\<Longrightarrow>\n       x \\<in> keys (vectorize_poly p)", "assume \"k \\<in> component_of_term ` keys p\""], ["proof (state)\nthis:\n  k \\<in> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` keys p \\<Longrightarrow>\n       x \\<in> keys (vectorize_poly p)", "then"], ["proof (chain)\npicking this:\n  k \\<in> component_of_term ` keys p", "obtain x where \"x \\<in> keys p\" and \"k = component_of_term x\""], ["proof (prove)\nusing this:\n  k \\<in> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> keys p; k = component_of_term x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> keys p\n  k = component_of_term x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` keys p \\<Longrightarrow>\n       x \\<in> keys (vectorize_poly p)", "from this(2)"], ["proof (chain)\npicking this:\n  k = component_of_term x", "have \"term_of_pair (pp_of_term x, k) = x\""], ["proof (prove)\nusing this:\n  k = component_of_term x\n\ngoal (1 subgoal):\n 1. term_of_pair (pp_of_term x, k) = x", "by (simp add: term_of_pair_pair)"], ["proof (state)\nthis:\n  term_of_pair (pp_of_term x, k) = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` keys p \\<Longrightarrow>\n       x \\<in> keys (vectorize_poly p)", "with \\<open>x \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> keys p\n  term_of_pair (pp_of_term x, k) = x", "have \"lookup p (term_of_pair (pp_of_term x, k)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> keys p\n  term_of_pair (pp_of_term x, k) = x\n\ngoal (1 subgoal):\n 1. lookup p (term_of_pair (pp_of_term x, k)) \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup p (term_of_pair (pp_of_term x, k)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` keys p \\<Longrightarrow>\n       x \\<in> keys (vectorize_poly p)", "hence \"lookup (proj_poly k p) (pp_of_term x) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lookup p (term_of_pair (pp_of_term x, k)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup (proj_poly k p) (pp_of_term x) \\<noteq> (0::'b)", "by (simp add: lookup_proj_poly)"], ["proof (state)\nthis:\n  lookup (proj_poly k p) (pp_of_term x) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` keys p \\<Longrightarrow>\n       x \\<in> keys (vectorize_poly p)", "hence \"proj_poly k p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lookup (proj_poly k p) (pp_of_term x) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. proj_poly k p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  proj_poly k p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` keys p \\<Longrightarrow>\n       x \\<in> keys (vectorize_poly p)", "hence \"lookup (vectorize_poly p) k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  proj_poly k p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lookup (vectorize_poly p) k \\<noteq> 0", "by (simp add: lookup_vectorize_poly)"], ["proof (state)\nthis:\n  lookup (vectorize_poly p) k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` keys p \\<Longrightarrow>\n       x \\<in> keys (vectorize_poly p)", "thus \"k \\<in> keys (vectorize_poly p)\""], ["proof (prove)\nusing this:\n  lookup (vectorize_poly p) k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<in> keys (vectorize_poly p)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  k \\<in> keys (vectorize_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  component_of_term ` keys p \\<subseteq> keys (vectorize_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_atomize_poly:\n  \"keys (atomize_poly p) = (\\<Union>k\\<in>keys p. (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (atomize_poly p) =\n    (\\<Union>k\\<in>keys p.\n        (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (atomize_poly p)\n    \\<subseteq> (\\<Union>k\\<in>keys p.\n                    (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n 2. (\\<Union>k\\<in>keys p.\n        (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n    \\<subseteq> keys (atomize_poly p)", "show \"?l \\<subseteq> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (atomize_poly p)\n    \\<subseteq> (\\<Union>k\\<in>keys p.\n                    (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (atomize_poly p) \\<Longrightarrow>\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (atomize_poly p) \\<Longrightarrow>\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "assume \"v \\<in> ?l\""], ["proof (state)\nthis:\n  v \\<in> keys (atomize_poly p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (atomize_poly p) \\<Longrightarrow>\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "hence \"lookup (atomize_poly p) v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<in> keys (atomize_poly p)\n\ngoal (1 subgoal):\n 1. lookup (atomize_poly p) v \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup (atomize_poly p) v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (atomize_poly p) \\<Longrightarrow>\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "hence *: \"pp_of_term v \\<in> keys (lookup p (component_of_term v))\""], ["proof (prove)\nusing this:\n  lookup (atomize_poly p) v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. pp_of_term v \\<in> keys (lookup p (component_of_term v))", "by (simp add: in_keys_iff lookup_atomize_poly)"], ["proof (state)\nthis:\n  pp_of_term v \\<in> keys (lookup p (component_of_term v))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (atomize_poly p) \\<Longrightarrow>\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "hence \"lookup p (component_of_term v) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  pp_of_term v \\<in> keys (lookup p (component_of_term v))\n\ngoal (1 subgoal):\n 1. lookup p (component_of_term v) \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  lookup p (component_of_term v) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (atomize_poly p) \\<Longrightarrow>\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "hence \"component_of_term v \\<in> keys p\""], ["proof (prove)\nusing this:\n  lookup p (component_of_term v) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. component_of_term v \\<in> keys p", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  component_of_term v \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (atomize_poly p) \\<Longrightarrow>\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "thus \"v \\<in> ?r\""], ["proof (prove)\nusing this:\n  component_of_term v \\<in> keys p\n\ngoal (1 subgoal):\n 1. v \\<in> (\\<Union>k\\<in>keys p.\n                (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) `\n            keys (lookup p (component_of_term v))", "from *"], ["proof (chain)\npicking this:\n  pp_of_term v \\<in> keys (lookup p (component_of_term v))", "have \"term_of_pair (pp_of_term v, component_of_term v) \\<in>\n                    (\\<lambda>t. term_of_pair (t, component_of_term v)) ` keys (lookup p (component_of_term v))\""], ["proof (prove)\nusing this:\n  pp_of_term v \\<in> keys (lookup p (component_of_term v))\n\ngoal (1 subgoal):\n 1. term_of_pair (pp_of_term v, component_of_term v)\n    \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) `\n          keys (lookup p (component_of_term v))", "by (rule imageI)"], ["proof (state)\nthis:\n  term_of_pair (pp_of_term v, component_of_term v)\n  \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) `\n        keys (lookup p (component_of_term v))\n\ngoal (1 subgoal):\n 1. v \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) `\n            keys (lookup p (component_of_term v))", "thus \"v \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) ` keys (lookup p (component_of_term v))\""], ["proof (prove)\nusing this:\n  term_of_pair (pp_of_term v, component_of_term v)\n  \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) `\n        keys (lookup p (component_of_term v))\n\ngoal (1 subgoal):\n 1. v \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) `\n            keys (lookup p (component_of_term v))", "by (simp only: term_of_pair_pair)"], ["proof (state)\nthis:\n  v \\<in> (\\<lambda>t. term_of_pair (t, component_of_term v)) `\n          keys (lookup p (component_of_term v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> (\\<Union>k\\<in>keys p.\n              (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (atomize_poly p)\n  \\<subseteq> (\\<Union>k\\<in>keys p.\n                  (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n\ngoal (1 subgoal):\n 1. (\\<Union>k\\<in>keys p.\n        (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n    \\<subseteq> keys (atomize_poly p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>k\\<in>keys p.\n        (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n    \\<subseteq> keys (atomize_poly p)", "show \"?r \\<subseteq> ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>k\\<in>keys p.\n        (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n    \\<subseteq> keys (atomize_poly p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) `\n                   keys (lookup p k)) \\<Longrightarrow>\n       x \\<in> keys (atomize_poly p)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) `\n                   keys (lookup p k)) \\<Longrightarrow>\n       x \\<in> keys (atomize_poly p)", "assume \"v \\<in> ?r\""], ["proof (state)\nthis:\n  v \\<in> (\\<Union>k\\<in>keys p.\n              (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) `\n                   keys (lookup p k)) \\<Longrightarrow>\n       x \\<in> keys (atomize_poly p)", "then"], ["proof (chain)\npicking this:\n  v \\<in> (\\<Union>k\\<in>keys p.\n              (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))", "obtain k where \"k \\<in> keys p\" and \"v \\<in> (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k)\""], ["proof (prove)\nusing this:\n  v \\<in> (\\<Union>k\\<in>keys p.\n              (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> keys p;\n         v \\<in> (\\<lambda>t. term_of_pair (t, k)) `\n                 keys (lookup p k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  k \\<in> keys p\n  v \\<in> (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) `\n                   keys (lookup p k)) \\<Longrightarrow>\n       x \\<in> keys (atomize_poly p)", "from this(2)"], ["proof (chain)\npicking this:\n  v \\<in> (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k)", "obtain t where \"t \\<in> keys (lookup p k)\" and v: \"v = term_of_pair (t, k)\""], ["proof (prove)\nusing this:\n  v \\<in> (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys (lookup p k); v = term_of_pair (t, k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t \\<in> keys (lookup p k)\n  v = term_of_pair (t, k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) `\n                   keys (lookup p k)) \\<Longrightarrow>\n       x \\<in> keys (atomize_poly p)", "from this(1)"], ["proof (chain)\npicking this:\n  t \\<in> keys (lookup p k)", "have \"lookup (atomize_poly p) v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys (lookup p k)\n\ngoal (1 subgoal):\n 1. lookup (atomize_poly p) v \\<noteq> (0::'b)", "by (simp add: v lookup_atomize_poly in_keys_iff term_simps)"], ["proof (state)\nthis:\n  lookup (atomize_poly p) v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>k\\<in>keys p.\n                   (\\<lambda>t. term_of_pair (t, k)) `\n                   keys (lookup p k)) \\<Longrightarrow>\n       x \\<in> keys (atomize_poly p)", "thus \"v \\<in> ?l\""], ["proof (prove)\nusing this:\n  lookup (atomize_poly p) v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. v \\<in> keys (atomize_poly p)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  v \\<in> keys (atomize_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>k\\<in>keys p.\n      (\\<lambda>t. term_of_pair (t, k)) ` keys (lookup p k))\n  \\<subseteq> keys (atomize_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_atomize_poly [term_simps]: \"proj_poly k (atomize_poly p) = lookup p k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (atomize_poly p) = lookup p k", "by (rule poly_mapping_eqI, simp add: lookup_proj_poly lookup_atomize_poly term_simps)"], ["", "lemma vectorize_atomize_poly [term_simps]: \"vectorize_poly (atomize_poly p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorize_poly (atomize_poly p) = p", "by (rule poly_mapping_eqI, simp add: lookup_vectorize_poly term_simps)"], ["", "lemma atomize_vectorize_poly [term_simps]: \"atomize_poly (vectorize_poly p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomize_poly (vectorize_poly p) = p", "by (rule poly_mapping_eqI, simp add: lookup_atomize_poly lookup_vectorize_poly lookup_proj_poly term_simps)"], ["", "lemma proj_zero [term_simps]: \"proj_poly k 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k 0 = 0", "by (rule poly_mapping_eqI, simp add: lookup_proj_poly)"], ["", "lemma proj_plus: \"proj_poly k (p + q) = proj_poly k p + proj_poly k q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (p + q) = proj_poly k p + proj_poly k q", "by (rule poly_mapping_eqI, simp add: lookup_proj_poly lookup_add)"], ["", "lemma proj_uminus [term_simps]: \"proj_poly k (- p) = - proj_poly k p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (- p) = - proj_poly k p", "by (rule poly_mapping_eqI, simp add: lookup_proj_poly)"], ["", "lemma proj_minus: \"proj_poly k (p - q) = proj_poly k p - proj_poly k q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (p - q) = proj_poly k p - proj_poly k q", "by (rule poly_mapping_eqI, simp add: lookup_proj_poly lookup_minus)"], ["", "lemma vectorize_zero [term_simps]: \"vectorize_poly 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorize_poly 0 = 0", "by (rule poly_mapping_eqI, simp add: lookup_vectorize_poly term_simps)"], ["", "lemma vectorize_plus: \"vectorize_poly (p + q) = vectorize_poly p + vectorize_poly q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorize_poly (p + q) = vectorize_poly p + vectorize_poly q", "by (rule poly_mapping_eqI, simp add: lookup_vectorize_poly lookup_add proj_plus)"], ["", "lemma vectorize_uminus [term_simps]: \"vectorize_poly (- p) = - vectorize_poly p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorize_poly (- p) = - vectorize_poly p", "by (rule poly_mapping_eqI, simp add: lookup_vectorize_poly term_simps)"], ["", "lemma vectorize_minus: \"vectorize_poly (p - q) = vectorize_poly p - vectorize_poly q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorize_poly (p - q) = vectorize_poly p - vectorize_poly q", "by (rule poly_mapping_eqI, simp add: lookup_vectorize_poly lookup_minus proj_minus)"], ["", "lemma atomize_zero [term_simps]: \"atomize_poly 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomize_poly 0 = 0", "by (rule poly_mapping_eqI, simp add: lookup_atomize_poly)"], ["", "lemma atomize_plus: \"atomize_poly (p + q) = atomize_poly p + atomize_poly q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomize_poly (p + q) = atomize_poly p + atomize_poly q", "by (rule poly_mapping_eqI, simp add: lookup_atomize_poly lookup_add)"], ["", "lemma atomize_uminus [term_simps]: \"atomize_poly (- p) = - atomize_poly p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomize_poly (- p) = - atomize_poly p", "by (rule poly_mapping_eqI, simp add: lookup_atomize_poly)"], ["", "lemma atomize_minus: \"atomize_poly (p - q) = atomize_poly p - atomize_poly q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomize_poly (p - q) = atomize_poly p - atomize_poly q", "by (rule poly_mapping_eqI, simp add: lookup_atomize_poly lookup_minus)"], ["", "lemma proj_monomial:\n  \"proj_poly k (monomial c v) = (monomial c (pp_of_term v) when component_of_term v = k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (monomial c v) =\n    (monomial c (pp_of_term v) when component_of_term v = k)", "proof (rule poly_mapping_eqI, simp add: lookup_proj_poly lookup_single when_def term_simps, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>pp_of_term v = ka; component_of_term v = k;\n        v \\<noteq> term_of_pair (ka, k)\\<rbrakk>\n       \\<Longrightarrow> c = (0::'b)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>pp_of_term v = ka; component_of_term v = k;\n        v \\<noteq> term_of_pair (ka, k)\\<rbrakk>\n       \\<Longrightarrow> c = (0::'b)", "assume 1: \"pp_of_term v = t\" and 2: \"component_of_term v = k\""], ["proof (state)\nthis:\n  pp_of_term v = t\n  component_of_term v = k\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>pp_of_term v = ka; component_of_term v = k;\n        v \\<noteq> term_of_pair (ka, k)\\<rbrakk>\n       \\<Longrightarrow> c = (0::'b)", "assume \"v \\<noteq> term_of_pair (t, k)\""], ["proof (state)\nthis:\n  v \\<noteq> term_of_pair (t, k)\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>pp_of_term v = ka; component_of_term v = k;\n        v \\<noteq> term_of_pair (ka, k)\\<rbrakk>\n       \\<Longrightarrow> c = (0::'b)", "moreover"], ["proof (state)\nthis:\n  v \\<noteq> term_of_pair (t, k)\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>pp_of_term v = ka; component_of_term v = k;\n        v \\<noteq> term_of_pair (ka, k)\\<rbrakk>\n       \\<Longrightarrow> c = (0::'b)", "have \"v = term_of_pair (t, k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = term_of_pair (t, k)", "by (simp add: 1[symmetric] 2[symmetric] term_simps)"], ["proof (state)\nthis:\n  v = term_of_pair (t, k)\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>pp_of_term v = ka; component_of_term v = k;\n        v \\<noteq> term_of_pair (ka, k)\\<rbrakk>\n       \\<Longrightarrow> c = (0::'b)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<noteq> term_of_pair (t, k)\n  v = term_of_pair (t, k)", "show \"c = 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> term_of_pair (t, k)\n  v = term_of_pair (t, k)\n\ngoal (1 subgoal):\n 1. c = (0::'b)", ".."], ["proof (state)\nthis:\n  c = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vectorize_monomial:\n  \"vectorize_poly (monomial c v) = monomial (monomial c (pp_of_term v)) (component_of_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorize_poly (monomial c v) =\n    monomial (monomial c (pp_of_term v)) (component_of_term v)", "by (rule poly_mapping_eqI, simp add: lookup_vectorize_poly proj_monomial lookup_single)"], ["", "lemma atomize_monomial_monomial:\n  \"atomize_poly (monomial (monomial c t) k) = monomial c (term_of_pair (t, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomize_poly (monomial (monomial c t) k) =\n    monomial c (term_of_pair (t, k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atomize_poly (monomial (monomial c t) k) =\n    monomial c (term_of_pair (t, k))", "define v where \"v = term_of_pair (t, k)\""], ["proof (state)\nthis:\n  v = term_of_pair (t, k)\n\ngoal (1 subgoal):\n 1. atomize_poly (monomial (monomial c t) k) =\n    monomial c (term_of_pair (t, k))", "have t: \"t = pp_of_term v\" and k: \"k = component_of_term v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = pp_of_term v &&& k = component_of_term v", "by (simp_all add: v_def term_simps)"], ["proof (state)\nthis:\n  t = pp_of_term v\n  k = component_of_term v\n\ngoal (1 subgoal):\n 1. atomize_poly (monomial (monomial c t) k) =\n    monomial c (term_of_pair (t, k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. atomize_poly (monomial (monomial c t) k) =\n    monomial c (term_of_pair (t, k))", "by (simp add: t k vectorize_monomial[symmetric] term_simps)"], ["proof (state)\nthis:\n  atomize_poly (monomial (monomial c t) k) =\n  monomial c (term_of_pair (t, k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_mapping_eqI_proj:\n  assumes \"\\<And>k. proj_poly k p = proj_poly k q\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup p k = lookup q k", "fix v::'t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup p k = lookup q k", "have \"proj_poly (component_of_term v) p = proj_poly (component_of_term v) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly (component_of_term v) p = proj_poly (component_of_term v) q", "by (rule assms)"], ["proof (state)\nthis:\n  proj_poly (component_of_term v) p = proj_poly (component_of_term v) q\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup p k = lookup q k", "hence \"lookup (proj_poly (component_of_term v) p) (pp_of_term v) =\n          lookup (proj_poly (component_of_term v) q) (pp_of_term v)\""], ["proof (prove)\nusing this:\n  proj_poly (component_of_term v) p = proj_poly (component_of_term v) q\n\ngoal (1 subgoal):\n 1. lookup (proj_poly (component_of_term v) p) (pp_of_term v) =\n    lookup (proj_poly (component_of_term v) q) (pp_of_term v)", "by simp"], ["proof (state)\nthis:\n  lookup (proj_poly (component_of_term v) p) (pp_of_term v) =\n  lookup (proj_poly (component_of_term v) q) (pp_of_term v)\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup p k = lookup q k", "thus \"lookup p v = lookup q v\""], ["proof (prove)\nusing this:\n  lookup (proj_poly (component_of_term v) p) (pp_of_term v) =\n  lookup (proj_poly (component_of_term v) q) (pp_of_term v)\n\ngoal (1 subgoal):\n 1. lookup p v = lookup q v", "by (simp add: lookup_proj_poly term_simps)"], ["proof (state)\nthis:\n  lookup p v = lookup q v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Scalar Multiplication by Monomials\\<close>"], ["", "definition monom_mult :: \"'b::semiring_0 \\<Rightarrow> 'a::comm_powerprod \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b)\"\n  where \"monom_mult c t p = Abs_poly_mapping (\\<lambda>v. if t adds\\<^sub>p v then c * (lookup p (v \\<ominus> t)) else 0)\""], ["", "lemma keys_monom_mult_aux:\n  \"{v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else 0) \\<noteq> 0} \\<subseteq> (\\<oplus>) t ` keys p\" (is \"?l \\<subseteq> ?r\")\n  for c::\"'b::semiring_0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n         else (0::'b)) \\<noteq>\n        (0::'b)}\n    \\<subseteq> (\\<oplus>) t ` keys p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                    else (0::'b)) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> (\\<oplus>) t ` keys p", "fix v::'t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                    else (0::'b)) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> (\\<oplus>) t ` keys p", "assume \"v \\<in> ?l\""], ["proof (state)\nthis:\n  v \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n               else (0::'b)) \\<noteq>\n              (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                    else (0::'b)) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> (\\<oplus>) t ` keys p", "hence \"(if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n               else (0::'b)) \\<noteq>\n              (0::'b)}\n\ngoal (1 subgoal):\n 1. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n     else (0::'b)) \\<noteq>\n    (0::'b)", "by simp"], ["proof (state)\nthis:\n  (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n   else (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                    else (0::'b)) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> (\\<oplus>) t ` keys p", "hence \"t adds\\<^sub>p v\" and cp_not_zero: \"c * lookup p (v \\<ominus> t) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n   else (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. t adds\\<^sub>p v &&& c * lookup p (v \\<ominus> t) \\<noteq> (0::'b)", "by (simp_all split: if_split_asm)"], ["proof (state)\nthis:\n  t adds\\<^sub>p v\n  c * lookup p (v \\<ominus> t) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                    else (0::'b)) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> (\\<oplus>) t ` keys p", "show \"v \\<in> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> (\\<oplus>) t ` keys p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. v = t \\<oplus> ?x\n 2. ?x \\<in> keys p", "from adds_pp_sminus[OF \\<open>t adds\\<^sub>p v\\<close>]"], ["proof (chain)\npicking this:\n  t \\<oplus> (v \\<ominus> t) = v", "show \"v = t \\<oplus> (v \\<ominus> t)\""], ["proof (prove)\nusing this:\n  t \\<oplus> (v \\<ominus> t) = v\n\ngoal (1 subgoal):\n 1. v = t \\<oplus> (v \\<ominus> t)", "by simp"], ["proof (state)\nthis:\n  v = t \\<oplus> (v \\<ominus> t)\n\ngoal (1 subgoal):\n 1. v \\<ominus> t \\<in> keys p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<ominus> t \\<in> keys p", "from mult_not_zero[OF cp_not_zero]"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'b) \\<and> lookup p (v \\<ominus> t) \\<noteq> (0::'b)", "show \"v \\<ominus> t \\<in> keys p\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b) \\<and> lookup p (v \\<ominus> t) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. v \\<ominus> t \\<in> keys p", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  v \\<ominus> t \\<in> keys p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> (\\<oplus>) t ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_monom_mult:\n  \"lookup (monom_mult c t p) v = (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_mult c t p) v =\n    (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (monom_mult c t p) v =\n    (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))", "have \"lookup (monom_mult c t p) = (\\<lambda>v. if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_mult c t p) =\n    (\\<lambda>v.\n        if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))", "unfolding monom_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Abs_poly_mapping\n       (\\<lambda>v.\n           if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n           else (0::'b))) =\n    (\\<lambda>v.\n        if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))", "proof (rule Abs_poly_mapping_inverse)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))\n    \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"finite ((\\<oplus>) t ` keys p)\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. finite ((\\<oplus>) t ` keys p)", ".."], ["proof (state)\nthis:\n  finite ((\\<oplus>) t ` keys p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))\n    \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}", "with keys_monom_mult_aux"], ["proof (chain)\npicking this:\n  {v. (if ?t adds\\<^sub>p v then ?c * lookup ?p (v \\<ominus> ?t)\n       else (0::?'b)) \\<noteq>\n      (0::?'b)}\n  \\<subseteq> (\\<oplus>) ?t ` keys ?p\n  finite ((\\<oplus>) t ` keys p)", "have \"finite {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else 0) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  {v. (if ?t adds\\<^sub>p v then ?c * lookup ?p (v \\<ominus> ?t)\n       else (0::?'b)) \\<noteq>\n      (0::?'b)}\n  \\<subseteq> (\\<oplus>) ?t ` keys ?p\n  finite ((\\<oplus>) t ` keys p)\n\ngoal (1 subgoal):\n 1. finite\n     {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n          else (0::'b)) \\<noteq>\n         (0::'b)}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite\n   {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n        else (0::'b)) \\<noteq>\n       (0::'b)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))\n    \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}", "thus \"(\\<lambda>v. if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else 0) \\<in> {f. finite {x. f x \\<noteq> 0}}\""], ["proof (prove)\nusing this:\n  finite\n   {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n        else (0::'b)) \\<noteq>\n       (0::'b)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))\n    \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>v.\n      if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))\n  \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (monom_mult c t p) =\n  (\\<lambda>v.\n      if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))\n\ngoal (1 subgoal):\n 1. lookup (monom_mult c t p) v =\n    (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup (monom_mult c t p) =\n  (\\<lambda>v.\n      if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))\n\ngoal (1 subgoal):\n 1. lookup (monom_mult c t p) v =\n    (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))", "by simp"], ["proof (state)\nthis:\n  lookup (monom_mult c t p) v =\n  (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_monom_mult_plus:\n  \"lookup (monom_mult c t p) (t \\<oplus> v) = (c::'b::semiring_0) * lookup p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_mult c t p) (t \\<oplus> v) = c * lookup p v", "by (simp add: lookup_monom_mult term_simps)"], ["", "lemma monom_mult_assoc: \"monom_mult c s (monom_mult d t p) = monom_mult (c * d) (s + t) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c s (monom_mult d t p) = monom_mult (c * d) (s + t) p", "proof (rule poly_mapping_eqI, simp add: lookup_monom_mult sminus_plus ac_simps, intro conjI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 3. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; s adds\\<^sub>p k;\n        \\<not> s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> s \\<ominus> t)) =\n                         (0::'b)", "fix v"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 3. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; s adds\\<^sub>p k;\n        \\<not> s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> s \\<ominus> t)) =\n                         (0::'b)", "assume \"s adds\\<^sub>p v\" and \"t adds\\<^sub>p v \\<ominus> s\""], ["proof (state)\nthis:\n  s adds\\<^sub>p v\n  t adds\\<^sub>p v \\<ominus> s\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 3. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; s adds\\<^sub>p k;\n        \\<not> s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> s \\<ominus> t)) =\n                         (0::'b)", "hence \"s + t adds\\<^sub>p v\""], ["proof (prove)\nusing this:\n  s adds\\<^sub>p v\n  t adds\\<^sub>p v \\<ominus> s\n\ngoal (1 subgoal):\n 1. s + t adds\\<^sub>p v", "by (rule plus_adds_ppI_2)"], ["proof (state)\nthis:\n  s + t adds\\<^sub>p v\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 3. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; s adds\\<^sub>p k;\n        \\<not> s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> s \\<ominus> t)) =\n                         (0::'b)", "moreover"], ["proof (state)\nthis:\n  s + t adds\\<^sub>p v\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 3. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; s adds\\<^sub>p k;\n        \\<not> s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> s \\<ominus> t)) =\n                         (0::'b)", "assume \"\\<not> s + t adds\\<^sub>p v\""], ["proof (state)\nthis:\n  \\<not> s + t adds\\<^sub>p v\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 3. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; s adds\\<^sub>p k;\n        \\<not> s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> s \\<ominus> t)) =\n                         (0::'b)", "ultimately"], ["proof (chain)\npicking this:\n  s + t adds\\<^sub>p v\n  \\<not> s + t adds\\<^sub>p v", "show \"c * (d * lookup p (v \\<ominus> s \\<ominus> t)) = 0\""], ["proof (prove)\nusing this:\n  s + t adds\\<^sub>p v\n  \\<not> s + t adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. c * (d * lookup p (v \\<ominus> s \\<ominus> t)) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  c * (d * lookup p (v \\<ominus> s \\<ominus> t)) = (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "assume \"s + t adds\\<^sub>p v\""], ["proof (state)\nthis:\n  s + t adds\\<^sub>p v\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "hence \"s adds\\<^sub>p v\""], ["proof (prove)\nusing this:\n  s + t adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. s adds\\<^sub>p v", "by (rule plus_adds_pp_left)"], ["proof (state)\nthis:\n  s adds\\<^sub>p v\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "moreover"], ["proof (state)\nthis:\n  s adds\\<^sub>p v\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "assume \"\\<not> s adds\\<^sub>p v\""], ["proof (state)\nthis:\n  \\<not> s adds\\<^sub>p v\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)\n 2. \\<And>k.\n       \\<lbrakk>t adds\\<^sub>p k \\<ominus> s; \\<not> s adds\\<^sub>p k;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "ultimately"], ["proof (chain)\npicking this:\n  s adds\\<^sub>p v\n  \\<not> s adds\\<^sub>p v", "show \"c * (d * lookup p (v \\<ominus> (s + t))) = 0\""], ["proof (prove)\nusing this:\n  s adds\\<^sub>p v\n  \\<not> s adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. c * (d * lookup p (v \\<ominus> (s + t))) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  c * (d * lookup p (v \\<ominus> (s + t))) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "assume \"s + t adds\\<^sub>p v\""], ["proof (state)\nthis:\n  s + t adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "hence \"t adds\\<^sub>p v \\<ominus> s\""], ["proof (prove)\nusing this:\n  s + t adds\\<^sub>p v\n\ngoal (1 subgoal):\n 1. t adds\\<^sub>p v \\<ominus> s", "by (simp add: add.commute plus_adds_pp_0)"], ["proof (state)\nthis:\n  t adds\\<^sub>p v \\<ominus> s\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "moreover"], ["proof (state)\nthis:\n  t adds\\<^sub>p v \\<ominus> s\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "assume \"\\<not> t adds\\<^sub>p v \\<ominus> s\""], ["proof (state)\nthis:\n  \\<not> t adds\\<^sub>p v \\<ominus> s\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<not> t adds\\<^sub>p k \\<ominus> s;\n        s + t adds\\<^sub>p k\\<rbrakk>\n       \\<Longrightarrow> c * (d * lookup p (k \\<ominus> (s + t))) = (0::'b)", "ultimately"], ["proof (chain)\npicking this:\n  t adds\\<^sub>p v \\<ominus> s\n  \\<not> t adds\\<^sub>p v \\<ominus> s", "show \"c * (d * lookup p (v \\<ominus> (s + t))) = 0\""], ["proof (prove)\nusing this:\n  t adds\\<^sub>p v \\<ominus> s\n  \\<not> t adds\\<^sub>p v \\<ominus> s\n\ngoal (1 subgoal):\n 1. c * (d * lookup p (v \\<ominus> (s + t))) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  c * (d * lookup p (v \\<ominus> (s + t))) = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monom_mult_uminus_left: \"monom_mult (- c) t p = - monom_mult (c::'b::ring) t p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (- c) t p = - monom_mult c t p", "by (rule poly_mapping_eqI, simp add: lookup_monom_mult)"], ["", "lemma monom_mult_uminus_right: \"monom_mult c t (- p) = - monom_mult (c::'b::ring) t p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t (- p) = - monom_mult c t p", "by (rule poly_mapping_eqI, simp add: lookup_monom_mult)"], ["", "lemma uminus_monom_mult: \"- p = monom_mult (-1::'b::comm_ring_1) 0 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p = monom_mult (- (1::'b)) (0::'a) p", "by (rule poly_mapping_eqI, simp add: lookup_monom_mult term_simps)"], ["", "lemma monom_mult_dist_left: \"monom_mult (c + d) t p = (monom_mult c t p) + (monom_mult d t p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (c + d) t p = monom_mult c t p + monom_mult d t p", "by (rule poly_mapping_eqI, simp add: lookup_monom_mult lookup_add algebra_simps)"], ["", "lemma monom_mult_dist_left_minus:\n  \"monom_mult (c - d) t p = (monom_mult c t p) - (monom_mult (d::'b::ring) t p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (c - d) t p = monom_mult c t p - monom_mult d t p", "using monom_mult_dist_left[of c \"-d\" t p] monom_mult_uminus_left[of d t p]"], ["proof (prove)\nusing this:\n  monom_mult (c + - d) t p = monom_mult c t p + monom_mult (- d) t p\n  monom_mult (- d) t p = - monom_mult d t p\n\ngoal (1 subgoal):\n 1. monom_mult (c - d) t p = monom_mult c t p - monom_mult d t p", "by simp"], ["", "lemma monom_mult_dist_right:\n  \"monom_mult c t (p + q) = (monom_mult c t p) + (monom_mult c t q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t (p + q) = monom_mult c t p + monom_mult c t q", "by (rule poly_mapping_eqI, simp add: lookup_monom_mult lookup_add algebra_simps)"], ["", "lemma monom_mult_dist_right_minus:\n  \"monom_mult c t (p - q) = (monom_mult c t p) - (monom_mult (c::'b::ring) t q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t (p - q) = monom_mult c t p - monom_mult c t q", "using monom_mult_dist_right[of c t p \"-q\"] monom_mult_uminus_right[of c t q]"], ["proof (prove)\nusing this:\n  monom_mult c t (p + - q) = monom_mult c t p + monom_mult c t (- q)\n  monom_mult c t (- q) = - monom_mult c t q\n\ngoal (1 subgoal):\n 1. monom_mult c t (p - q) = monom_mult c t p - monom_mult c t q", "by simp"], ["", "lemma monom_mult_zero_left [simp]: \"monom_mult 0 t p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (0::'b) t p = 0", "by (rule poly_mapping_eqI, simp add: lookup_monom_mult)"], ["", "lemma monom_mult_zero_right [simp]: \"monom_mult c t 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t 0 = 0", "by (rule poly_mapping_eqI, simp add: lookup_monom_mult)"], ["", "lemma monom_mult_one_left [simp]: \"(monom_mult (1::'b::semiring_1) 0 p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (1::'b) (0::'a) p = p", "by (rule poly_mapping_eqI, simp add: lookup_monom_mult term_simps)"], ["", "lemma monom_mult_monomial:\n  \"monom_mult c s (monomial d v) = monomial (c * (d::'b::semiring_0)) (s \\<oplus> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c s (monomial d v) = monomial (c * d) (s \\<oplus> v)", "by (rule poly_mapping_eqI, auto simp add: lookup_monom_mult lookup_single adds_pp_alt when_def term_simps, metis)"], ["", "lemma monom_mult_eq_zero_iff: \"(monom_mult c t p = 0) \\<longleftrightarrow> ((c::'b::semiring_no_zero_divisors) = 0 \\<or> p = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monom_mult c t p = 0) = (c = (0::'b) \\<or> p = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. monom_mult c t p = 0 \\<Longrightarrow> c = (0::'b) \\<or> p = 0\n 2. c = (0::'b) \\<or> p = 0 \\<Longrightarrow> monom_mult c t p = 0", "assume eq: \"monom_mult c t p = 0\""], ["proof (state)\nthis:\n  monom_mult c t p = 0\n\ngoal (2 subgoals):\n 1. monom_mult c t p = 0 \\<Longrightarrow> c = (0::'b) \\<or> p = 0\n 2. c = (0::'b) \\<or> p = 0 \\<Longrightarrow> monom_mult c t p = 0", "show \"c = 0 \\<or> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = (0::'b) \\<or> p = 0", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<and> p \\<noteq> 0 \\<Longrightarrow> False", "assume \"c \\<noteq> 0 \\<and> p \\<noteq> 0\""], ["proof (state)\nthis:\n  c \\<noteq> (0::'b) \\<and> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<and> p \\<noteq> 0 \\<Longrightarrow> False", "hence \"c \\<noteq> 0\" and \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b) \\<and> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) &&& p \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  c \\<noteq> (0::'b)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<and> p \\<noteq> 0 \\<Longrightarrow> False", "from lookup_zero poly_mapping_eq_iff[of p 0] \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  lookup 0 ?k = (0::?'a)\n  (p = 0) = (lookup p = lookup 0)\n  p \\<noteq> 0", "obtain v where \"lookup p v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lookup 0 ?k = (0::?'a)\n  (p = 0) = (lookup p = lookup 0)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        lookup p v \\<noteq> (0::'b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  lookup p v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<and> p \\<noteq> 0 \\<Longrightarrow> False", "from eq lookup_zero"], ["proof (chain)\npicking this:\n  monom_mult c t p = 0\n  lookup 0 ?k = (0::?'a)", "have \"lookup (monom_mult c t p) (t \\<oplus> v) = 0\""], ["proof (prove)\nusing this:\n  monom_mult c t p = 0\n  lookup 0 ?k = (0::?'a)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult c t p) (t \\<oplus> v) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  lookup (monom_mult c t p) (t \\<oplus> v) = (0::'b)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<and> p \\<noteq> 0 \\<Longrightarrow> False", "hence \"c * lookup p v = 0\""], ["proof (prove)\nusing this:\n  lookup (monom_mult c t p) (t \\<oplus> v) = (0::'b)\n\ngoal (1 subgoal):\n 1. c * lookup p v = (0::'b)", "by (simp only: lookup_monom_mult_plus)"], ["proof (state)\nthis:\n  c * lookup p v = (0::'b)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b) \\<and> p \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>c \\<noteq> 0\\<close> \\<open>lookup p v \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'b)\n  lookup p v \\<noteq> (0::'b)\n  c * lookup p v = (0::'b)", "show False"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n  lookup p v \\<noteq> (0::'b)\n  c * lookup p v = (0::'b)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c = (0::'b) \\<or> p = 0\n\ngoal (1 subgoal):\n 1. c = (0::'b) \\<or> p = 0 \\<Longrightarrow> monom_mult c t p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c = (0::'b) \\<or> p = 0 \\<Longrightarrow> monom_mult c t p = 0", "assume \"c = 0 \\<or> p = 0\""], ["proof (state)\nthis:\n  c = (0::'b) \\<or> p = 0\n\ngoal (1 subgoal):\n 1. c = (0::'b) \\<or> p = 0 \\<Longrightarrow> monom_mult c t p = 0", "with monom_mult_zero_left[of t p] monom_mult_zero_right[of c t]"], ["proof (chain)\npicking this:\n  monom_mult (0::'b) t p = 0\n  monom_mult c t 0 = 0\n  c = (0::'b) \\<or> p = 0", "show \"monom_mult c t p = 0\""], ["proof (prove)\nusing this:\n  monom_mult (0::'b) t p = 0\n  monom_mult c t 0 = 0\n  c = (0::'b) \\<or> p = 0\n\ngoal (1 subgoal):\n 1. monom_mult c t p = 0", "by auto"], ["proof (state)\nthis:\n  monom_mult c t p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_monom_mult_zero: \"lookup (monom_mult c 0 p) t = c * lookup p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_mult c (0::'a) p) t = c * lookup p t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (monom_mult c (0::'a) p) t = c * lookup p t", "have \"lookup (monom_mult c 0 p) t = lookup (monom_mult c 0 p) (0 \\<oplus> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_mult c (0::'a) p) t =\n    lookup (monom_mult c (0::'a) p) ((0::'a) \\<oplus> t)", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  lookup (monom_mult c (0::'a) p) t =\n  lookup (monom_mult c (0::'a) p) ((0::'a) \\<oplus> t)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult c (0::'a) p) t = c * lookup p t", "also"], ["proof (state)\nthis:\n  lookup (monom_mult c (0::'a) p) t =\n  lookup (monom_mult c (0::'a) p) ((0::'a) \\<oplus> t)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult c (0::'a) p) t = c * lookup p t", "have \"... = c * lookup p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_mult c (0::'a) p) ((0::'a) \\<oplus> t) = c * lookup p t", "by (rule lookup_monom_mult_plus)"], ["proof (state)\nthis:\n  lookup (monom_mult c (0::'a) p) ((0::'a) \\<oplus> t) = c * lookup p t\n\ngoal (1 subgoal):\n 1. lookup (monom_mult c (0::'a) p) t = c * lookup p t", "finally"], ["proof (chain)\npicking this:\n  lookup (monom_mult c (0::'a) p) t = c * lookup p t", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (monom_mult c (0::'a) p) t = c * lookup p t\n\ngoal (1 subgoal):\n 1. lookup (monom_mult c (0::'a) p) t = c * lookup p t", "."], ["proof (state)\nthis:\n  lookup (monom_mult c (0::'a) p) t = c * lookup p t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monom_mult_inj_1:\n  assumes \"monom_mult c1 t p = monom_mult c2 t p\"\n    and \"(p::(_ \\<Rightarrow>\\<^sub>0 'b::semiring_no_zero_divisors_cancel)) \\<noteq> 0\"\n  shows \"c1 = c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 = c2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c1 = c2", "from assms(2)"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"keys p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys p \\<noteq> {}", "using poly_mapping_eq_zeroI"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  keys ?s = {} \\<Longrightarrow> ?s = 0\n\ngoal (1 subgoal):\n 1. keys p \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. c1 = c2", "then"], ["proof (chain)\npicking this:\n  keys p \\<noteq> {}", "obtain v where \"v \\<in> keys p\""], ["proof (prove)\nusing this:\n  keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>v. v \\<in> keys p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> keys p\n\ngoal (1 subgoal):\n 1. c1 = c2", "hence *: \"lookup p v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<in> keys p\n\ngoal (1 subgoal):\n 1. lookup p v \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup p v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. c1 = c2", "from assms(1)"], ["proof (chain)\npicking this:\n  monom_mult c1 t p = monom_mult c2 t p", "have \"lookup (monom_mult c1 t p) (t \\<oplus> v) = lookup (monom_mult c2 t p) (t \\<oplus> v)\""], ["proof (prove)\nusing this:\n  monom_mult c1 t p = monom_mult c2 t p\n\ngoal (1 subgoal):\n 1. lookup (monom_mult c1 t p) (t \\<oplus> v) =\n    lookup (monom_mult c2 t p) (t \\<oplus> v)", "by simp"], ["proof (state)\nthis:\n  lookup (monom_mult c1 t p) (t \\<oplus> v) =\n  lookup (monom_mult c2 t p) (t \\<oplus> v)\n\ngoal (1 subgoal):\n 1. c1 = c2", "hence \"c1 * lookup p v = c2 * lookup p v\""], ["proof (prove)\nusing this:\n  lookup (monom_mult c1 t p) (t \\<oplus> v) =\n  lookup (monom_mult c2 t p) (t \\<oplus> v)\n\ngoal (1 subgoal):\n 1. c1 * lookup p v = c2 * lookup p v", "by (simp only: lookup_monom_mult_plus)"], ["proof (state)\nthis:\n  c1 * lookup p v = c2 * lookup p v\n\ngoal (1 subgoal):\n 1. c1 = c2", "with *"], ["proof (chain)\npicking this:\n  lookup p v \\<noteq> (0::'b)\n  c1 * lookup p v = c2 * lookup p v", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup p v \\<noteq> (0::'b)\n  c1 * lookup p v = c2 * lookup p v\n\ngoal (1 subgoal):\n 1. c1 = c2", "by auto"], ["proof (state)\nthis:\n  c1 = c2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Multiplication by a monomial is injective in the second argument (the power-product) only in\n  context @{locale ordered_powerprod}; see lemma \\<open>monom_mult_inj_2\\<close> below.\\<close>"], ["", "lemma monom_mult_inj_3:\n  assumes \"monom_mult c t p1 = monom_mult c t (p2::(_ \\<Rightarrow>\\<^sub>0 'b::semiring_no_zero_divisors_cancel))\"\n    and \"c \\<noteq> 0\"\n  shows \"p1 = p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 = p2", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup p1 k = lookup p2 k", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup p1 k = lookup p2 k", "from assms(1)"], ["proof (chain)\npicking this:\n  monom_mult c t p1 = monom_mult c t p2", "have \"lookup (monom_mult c t p1) (t \\<oplus> v) = lookup (monom_mult c t p2) (t \\<oplus> v)\""], ["proof (prove)\nusing this:\n  monom_mult c t p1 = monom_mult c t p2\n\ngoal (1 subgoal):\n 1. lookup (monom_mult c t p1) (t \\<oplus> v) =\n    lookup (monom_mult c t p2) (t \\<oplus> v)", "by simp"], ["proof (state)\nthis:\n  lookup (monom_mult c t p1) (t \\<oplus> v) =\n  lookup (monom_mult c t p2) (t \\<oplus> v)\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup p1 k = lookup p2 k", "hence \"c * lookup p1 v = c * lookup p2 v\""], ["proof (prove)\nusing this:\n  lookup (monom_mult c t p1) (t \\<oplus> v) =\n  lookup (monom_mult c t p2) (t \\<oplus> v)\n\ngoal (1 subgoal):\n 1. c * lookup p1 v = c * lookup p2 v", "by (simp only: lookup_monom_mult_plus)"], ["proof (state)\nthis:\n  c * lookup p1 v = c * lookup p2 v\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup p1 k = lookup p2 k", "with assms(2)"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'b)\n  c * lookup p1 v = c * lookup p2 v", "show \"lookup p1 v = lookup p2 v\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n  c * lookup p1 v = c * lookup p2 v\n\ngoal (1 subgoal):\n 1. lookup p1 v = lookup p2 v", "by simp"], ["proof (state)\nthis:\n  lookup p1 v = lookup p2 v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_monom_multI:\n  assumes \"v \\<in> keys p\" and \"c \\<noteq> (0::'b::semiring_no_zero_divisors)\"\n  shows \"t \\<oplus> v \\<in> keys (monom_mult c t p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<oplus> v \\<in> keys (monom_mult c t p)", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> keys p\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<oplus> v \\<in> keys (monom_mult c t p)", "unfolding in_keys_iff lookup_monom_mult_plus"], ["proof (prove)\nusing this:\n  lookup p v \\<noteq> (0::'b)\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. c * lookup p v \\<noteq> (0::'b)", "by simp"], ["", "lemma keys_monom_mult_subset: \"keys (monom_mult c t p) \\<subseteq> ((\\<oplus>) t) ` (keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p", "have \"keys (monom_mult c t p) \\<subseteq> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t) else 0) \\<noteq> 0}\" (is \"_ \\<subseteq> ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monom_mult c t p)\n    \\<subseteq> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                     else (0::'b)) \\<noteq>\n                    (0::'b)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       x \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                    else (0::'b)) \\<noteq>\n                   (0::'b)}", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       x \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                    else (0::'b)) \\<noteq>\n                   (0::'b)}", "assume \"v \\<in> keys (monom_mult c t p)\""], ["proof (state)\nthis:\n  v \\<in> keys (monom_mult c t p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       x \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                    else (0::'b)) \\<noteq>\n                   (0::'b)}", "hence \"lookup (monom_mult c t p) v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<in> keys (monom_mult c t p)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult c t p) v \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup (monom_mult c t p) v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       x \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                    else (0::'b)) \\<noteq>\n                   (0::'b)}", "thus \"v \\<in> ?A\""], ["proof (prove)\nusing this:\n  lookup (monom_mult c t p) v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. v \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                 else (0::'b)) \\<noteq>\n                (0::'b)}", "unfolding lookup_monom_mult"], ["proof (prove)\nusing this:\n  (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n   else (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. v \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                 else (0::'b)) \\<noteq>\n                (0::'b)}", "by simp"], ["proof (state)\nthis:\n  v \\<in> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n               else (0::'b)) \\<noteq>\n              (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (monom_mult c t p)\n  \\<subseteq> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                   else (0::'b)) \\<noteq>\n                  (0::'b)}\n\ngoal (1 subgoal):\n 1. keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p", "also"], ["proof (state)\nthis:\n  keys (monom_mult c t p)\n  \\<subseteq> {v. (if t adds\\<^sub>p v then c * lookup p (v \\<ominus> t)\n                   else (0::'b)) \\<noteq>\n                  (0::'b)}\n\ngoal (1 subgoal):\n 1. keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p", "note keys_monom_mult_aux"], ["proof (state)\nthis:\n  {v. (if ?t adds\\<^sub>p v then ?c * lookup ?p (v \\<ominus> ?t)\n       else (0::?'b)) \\<noteq>\n      (0::?'b)}\n  \\<subseteq> (\\<oplus>) ?t ` keys ?p\n\ngoal (1 subgoal):\n 1. keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p", "finally"], ["proof (chain)\npicking this:\n  keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p\n\ngoal (1 subgoal):\n 1. keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p", "."], ["proof (state)\nthis:\n  keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_monom_multE:\n  assumes \"v \\<in> keys (monom_mult c t p)\"\n  obtains u where \"u \\<in> keys p\" and \"v = t \\<oplus> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys p; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys p; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms"], ["proof (state)\nthis:\n  v \\<in> keys (monom_mult c t p)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys p; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  v \\<in> keys (monom_mult c t p)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys p; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"keys (monom_mult c t p) \\<subseteq> ((\\<oplus>) t) ` (keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p", "by (fact keys_monom_mult_subset)"], ["proof (state)\nthis:\n  keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys p; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  v \\<in> (\\<oplus>) t ` keys p", "have \"v \\<in> ((\\<oplus>) t) ` (keys p)\""], ["proof (prove)\nusing this:\n  v \\<in> (\\<oplus>) t ` keys p\n\ngoal (1 subgoal):\n 1. v \\<in> (\\<oplus>) t ` keys p", "."], ["proof (state)\nthis:\n  v \\<in> (\\<oplus>) t ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys p; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  v \\<in> (\\<oplus>) t ` keys p", "obtain u where \"u \\<in> keys p\" and \"v = t \\<oplus> u\""], ["proof (prove)\nusing this:\n  v \\<in> (\\<oplus>) t ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys p; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> keys p\n  v = t \\<oplus> u\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys p; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> keys p\n  v = t \\<oplus> u\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_monom_mult:\n  assumes \"c \\<noteq> (0::'b::semiring_no_zero_divisors)\"\n  shows \"keys (monom_mult c t p) = ((\\<oplus>) t) ` (keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monom_mult c t p) = (\\<oplus>) t ` keys p", "proof (rule, fact keys_monom_mult_subset, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<oplus>) t ` keys p \\<Longrightarrow>\n       x \\<in> keys (monom_mult c t p)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<oplus>) t ` keys p \\<Longrightarrow>\n       x \\<in> keys (monom_mult c t p)", "assume \"v \\<in> (\\<oplus>) t ` keys p\""], ["proof (state)\nthis:\n  v \\<in> (\\<oplus>) t ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<oplus>) t ` keys p \\<Longrightarrow>\n       x \\<in> keys (monom_mult c t p)", "then"], ["proof (chain)\npicking this:\n  v \\<in> (\\<oplus>) t ` keys p", "obtain u where \"u \\<in> keys p\" and v: \"v = t \\<oplus> u\""], ["proof (prove)\nusing this:\n  v \\<in> (\\<oplus>) t ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys p; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> keys p\n  v = t \\<oplus> u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<oplus>) t ` keys p \\<Longrightarrow>\n       x \\<in> keys (monom_mult c t p)", "from \\<open>u \\<in> keys p\\<close> assms"], ["proof (chain)\npicking this:\n  u \\<in> keys p\n  c \\<noteq> (0::'b)", "show \"v \\<in> keys (monom_mult c t p)\""], ["proof (prove)\nusing this:\n  u \\<in> keys p\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. v \\<in> keys (monom_mult c t p)", "unfolding v"], ["proof (prove)\nusing this:\n  u \\<in> keys p\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<oplus> u \\<in> keys (monom_mult c t p)", "by (rule keys_monom_multI)"], ["proof (state)\nthis:\n  v \\<in> keys (monom_mult c t p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monom_mult_when: \"monom_mult c t (p when P) = ((monom_mult c t p) when P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t (p when P) = (monom_mult c t p when P)", "by (cases P, simp_all)"], ["", "lemma when_monom_mult: \"monom_mult (c when P) t p = ((monom_mult c t p) when P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (c when P) t p = (monom_mult c t p when P)", "by (cases P, simp_all)"], ["", "lemma monomial_power: \"(monomial c t) ^ n = monomial (c ^ n) (\\<Sum>i=0..<n. t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c t ^ n = monomial (c ^ n) (\\<Sum>i = 0..<n. t)", "by (induct n, simp_all add: mult_single monom_mult_monomial add.commute)"], ["", "subsection \\<open>Component-wise Lifting\\<close>"], ["", "text \\<open>Component-wise lifting of functions on @{typ \"'a \\<Rightarrow>\\<^sub>0 'b\"} to functions on @{typ \"'t \\<Rightarrow>\\<^sub>0 'b\"}.\\<close>"], ["", "definition lift_poly_fun_2 :: \"(('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b)) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::zero)\"\n  where \"lift_poly_fun_2 f p q = atomize_poly (mapp_2 (\\<lambda>_. f) (vectorize_poly p) (vectorize_poly q))\""], ["", "definition lift_poly_fun :: \"(('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b)) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::zero)\"\n  where \"lift_poly_fun f p = lift_poly_fun_2 (\\<lambda>_. f) 0 p\""], ["", "lemma lookup_lift_poly_fun_2:\n  \"lookup (lift_poly_fun_2 f p q) v =\n    (lookup (f (proj_poly (component_of_term v) p) (proj_poly (component_of_term v) q)) (pp_of_term v)\n        when component_of_term v \\<in> keys (vectorize_poly p) \\<union> keys (vectorize_poly q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lift_poly_fun_2 f p q) v =\n    (lookup\n      (f (proj_poly (component_of_term v) p)\n        (proj_poly (component_of_term v) q))\n      (pp_of_term v) when\n     component_of_term v\n     \\<in> keys (vectorize_poly p) \\<union> keys (vectorize_poly q))", "by (simp add: lift_poly_fun_2_def lookup_atomize_poly lookup_mapp_2 lookup_vectorize_poly\n      when_distrib[of _ \"\\<lambda>q. lookup q (pp_of_term v)\", OF lookup_zero])"], ["", "lemma lookup_lift_poly_fun:\n  \"lookup (lift_poly_fun f p) v =\n    (lookup (f (proj_poly (component_of_term v) p)) (pp_of_term v) when component_of_term v \\<in> keys (vectorize_poly p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lift_poly_fun f p) v =\n    (lookup (f (proj_poly (component_of_term v) p)) (pp_of_term v) when\n     component_of_term v \\<in> keys (vectorize_poly p))", "by (simp add: lift_poly_fun_def lookup_lift_poly_fun_2 term_simps)"], ["", "lemma lookup_lift_poly_fun_2_homogenous:\n  assumes \"f 0 0 = 0\"\n  shows \"lookup (lift_poly_fun_2 f p q) v =\n         lookup (f (proj_poly (component_of_term v) p) (proj_poly (component_of_term v) q)) (pp_of_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lift_poly_fun_2 f p q) v =\n    lookup\n     (f (proj_poly (component_of_term v) p)\n       (proj_poly (component_of_term v) q))\n     (pp_of_term v)", "by (simp add: lookup_lift_poly_fun_2 when_def in_keys_iff lookup_vectorize_poly assms)"], ["", "lemma proj_lift_poly_fun_2_homogenous:\n  assumes \"f 0 0 = 0\"\n  shows \"proj_poly k (lift_poly_fun_2 f p q) = f (proj_poly k p) (proj_poly k q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (lift_poly_fun_2 f p q) = f (proj_poly k p) (proj_poly k q)", "by (rule poly_mapping_eqI,\n      simp add: lookup_proj_poly lookup_lift_poly_fun_2_homogenous[of f, OF assms] term_simps)"], ["", "lemma lookup_lift_poly_fun_homogenous:\n  assumes \"f 0 = 0\"\n  shows \"lookup (lift_poly_fun f p) v = lookup (f (proj_poly (component_of_term v) p)) (pp_of_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lift_poly_fun f p) v =\n    lookup (f (proj_poly (component_of_term v) p)) (pp_of_term v)", "by (simp add: lookup_lift_poly_fun when_def in_keys_iff lookup_vectorize_poly assms)"], ["", "lemma proj_lift_poly_fun_homogenous:\n  assumes \"f 0 = 0\"\n  shows \"proj_poly k (lift_poly_fun f p) = f (proj_poly k p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (lift_poly_fun f p) = f (proj_poly k p)", "by (rule poly_mapping_eqI,\n      simp add: lookup_proj_poly lookup_lift_poly_fun_homogenous[of f, OF assms] term_simps)"], ["", "subsection \\<open>Component-wise Multiplication\\<close>"], ["", "definition mult_vec :: \"('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::semiring_0)\" (infixl \"**\" 75)\n  where \"mult_vec = lift_poly_fun_2 (*)\""], ["", "lemma lookup_mult_vec:\n  \"lookup (p ** q) v = lookup ((proj_poly (component_of_term v) p) * (proj_poly (component_of_term v) q)) (pp_of_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p ** q) v =\n    lookup\n     (proj_poly (component_of_term v) p * proj_poly (component_of_term v) q)\n     (pp_of_term v)", "unfolding mult_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lift_poly_fun_2 (*) p q) v =\n    lookup\n     (proj_poly (component_of_term v) p * proj_poly (component_of_term v) q)\n     (pp_of_term v)", "by (rule lookup_lift_poly_fun_2_homogenous, simp)"], ["", "lemma proj_mult_vec [term_simps]: \"proj_poly k (p ** q) = (proj_poly k p) * (proj_poly k q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (p ** q) = proj_poly k p * proj_poly k q", "unfolding mult_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (lift_poly_fun_2 (*) p q) = proj_poly k p * proj_poly k q", "by (rule proj_lift_poly_fun_2_homogenous, simp)"], ["", "lemma mult_vec_zero_left: \"0 ** p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 ** p = 0", "by (rule poly_mapping_eqI_proj, simp add: term_simps)"], ["", "lemma mult_vec_zero_right: \"p ** 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ** 0 = 0", "by (rule poly_mapping_eqI_proj, simp add: term_simps)"], ["", "lemma mult_vec_assoc: \"(p ** q) ** r = p ** (q ** r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ** q ** r = p ** (q ** r)", "by (rule poly_mapping_eqI_proj, simp add: ac_simps term_simps)"], ["", "lemma mult_vec_distrib_right: \"(p + q) ** r = p ** r + q ** r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p + q) ** r = p ** r + q ** r", "by (rule poly_mapping_eqI_proj, simp add: algebra_simps proj_plus term_simps)"], ["", "lemma mult_vec_distrib_left: \"r ** (p + q) = r ** p + r ** q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ** (p + q) = r ** p + r ** q", "by (rule poly_mapping_eqI_proj, simp add: algebra_simps proj_plus term_simps)"], ["", "lemma mult_vec_minus_mult_left: \"(- p) ** q = - (p ** q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p ** q = - (p ** q)", "by (rule sym, rule minus_unique, simp add: mult_vec_distrib_right[symmetric] mult_vec_zero_left)"], ["", "lemma mult_vec_minus_mult_right: \"p ** (- q) = - (p ** q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ** - q = - (p ** q)", "by (rule sym, rule minus_unique, simp add: mult_vec_distrib_left [symmetric] mult_vec_zero_right)"], ["", "lemma minus_mult_vec_minus: \"(- p) ** (- q) = p ** q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p ** - q = p ** q", "by (simp add: mult_vec_minus_mult_left mult_vec_minus_mult_right)"], ["", "lemma minus_mult_vec_commute: \"(- p) ** q = p ** (- q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p ** q = p ** - q", "by (simp add: mult_vec_minus_mult_left mult_vec_minus_mult_right)"], ["", "lemma mult_vec_right_diff_distrib: \"r ** (p - q) = r ** p - r ** q\"\n  for r::\"_ \\<Rightarrow>\\<^sub>0 'b::ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ** (p - q) = r ** p - r ** q", "using mult_vec_distrib_left [of r p \"- q\"]"], ["proof (prove)\nusing this:\n  r ** (p + - q) = r ** p + r ** - q\n\ngoal (1 subgoal):\n 1. r ** (p - q) = r ** p - r ** q", "by (simp add: mult_vec_minus_mult_right)"], ["", "lemma mult_vec_left_diff_distrib: \"(p - q) ** r = p ** r - q ** r\"\n  for p::\"_ \\<Rightarrow>\\<^sub>0 'b::ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p - q) ** r = p ** r - q ** r", "using mult_vec_distrib_right [of p \"- q\" r]"], ["proof (prove)\nusing this:\n  (p + - q) ** r = p ** r + - q ** r\n\ngoal (1 subgoal):\n 1. (p - q) ** r = p ** r - q ** r", "by (simp add: mult_vec_minus_mult_left)"], ["", "lemma mult_vec_commute: \"p ** q = q ** p\" for p::\"_ \\<Rightarrow>\\<^sub>0 'b::comm_semiring_0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ** q = q ** p", "by (rule poly_mapping_eqI_proj, simp add: term_simps ac_simps)"], ["", "lemma mult_vec_left_commute: \"p ** (q ** r) = q ** (p ** r)\"\n  for p::\"_ \\<Rightarrow>\\<^sub>0 'b::comm_semiring_0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ** (q ** r) = q ** (p ** r)", "by (rule poly_mapping_eqI_proj, simp add: term_simps ac_simps)"], ["", "lemma mult_vec_monomial_monomial:\n  \"(monomial c u) ** (monomial d v) =\n          (monomial (c * d) (term_of_pair (pp_of_term u + pp_of_term v, component_of_term u)) when\n            component_of_term u = component_of_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c u ** monomial d v =\n    (monomial (c * d)\n      (term_of_pair (pp_of_term u + pp_of_term v, component_of_term u)) when\n     component_of_term u = component_of_term v)", "by (rule poly_mapping_eqI_proj, simp add: proj_monomial mult_single when_def term_simps)"], ["", "lemma mult_vec_rec_left: \"p ** q = monomial (lookup p v) v ** q + (except p {v}) ** q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ** q = monomial (lookup p v) v ** q + except p {v} ** q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p ** q = monomial (lookup p v) v ** q + except p {v} ** q", "from plus_except[of p v]"], ["proof (chain)\npicking this:\n  p = monomial (lookup p v) v + except p {v}", "have \"p ** q = (monomial (lookup p v) v + except p {v}) ** q\""], ["proof (prove)\nusing this:\n  p = monomial (lookup p v) v + except p {v}\n\ngoal (1 subgoal):\n 1. p ** q = (monomial (lookup p v) v + except p {v}) ** q", "by simp"], ["proof (state)\nthis:\n  p ** q = (monomial (lookup p v) v + except p {v}) ** q\n\ngoal (1 subgoal):\n 1. p ** q = monomial (lookup p v) v ** q + except p {v} ** q", "also"], ["proof (state)\nthis:\n  p ** q = (monomial (lookup p v) v + except p {v}) ** q\n\ngoal (1 subgoal):\n 1. p ** q = monomial (lookup p v) v ** q + except p {v} ** q", "have \"... = monomial (lookup p v) v ** q + except p {v} ** q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monomial (lookup p v) v + except p {v}) ** q =\n    monomial (lookup p v) v ** q + except p {v} ** q", "by (simp only: mult_vec_distrib_right)"], ["proof (state)\nthis:\n  (monomial (lookup p v) v + except p {v}) ** q =\n  monomial (lookup p v) v ** q + except p {v} ** q\n\ngoal (1 subgoal):\n 1. p ** q = monomial (lookup p v) v ** q + except p {v} ** q", "finally"], ["proof (chain)\npicking this:\n  p ** q = monomial (lookup p v) v ** q + except p {v} ** q", "show ?thesis"], ["proof (prove)\nusing this:\n  p ** q = monomial (lookup p v) v ** q + except p {v} ** q\n\ngoal (1 subgoal):\n 1. p ** q = monomial (lookup p v) v ** q + except p {v} ** q", "."], ["proof (state)\nthis:\n  p ** q = monomial (lookup p v) v ** q + except p {v} ** q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_vec_rec_right: \"p ** q = p ** monomial (lookup q v) v + p ** except q {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ** q = p ** monomial (lookup q v) v + p ** except q {v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p ** q = p ** monomial (lookup q v) v + p ** except q {v}", "have \"p ** monomial (lookup q v) v + p ** except q {v} = p ** (monomial (lookup q v) v + except q {v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ** monomial (lookup q v) v + p ** except q {v} =\n    p ** (monomial (lookup q v) v + except q {v})", "by (simp only: mult_vec_distrib_left)"], ["proof (state)\nthis:\n  p ** monomial (lookup q v) v + p ** except q {v} =\n  p ** (monomial (lookup q v) v + except q {v})\n\ngoal (1 subgoal):\n 1. p ** q = p ** monomial (lookup q v) v + p ** except q {v}", "also"], ["proof (state)\nthis:\n  p ** monomial (lookup q v) v + p ** except q {v} =\n  p ** (monomial (lookup q v) v + except q {v})\n\ngoal (1 subgoal):\n 1. p ** q = p ** monomial (lookup q v) v + p ** except q {v}", "have \"... = p ** q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ** (monomial (lookup q v) v + except q {v}) = p ** q", "by (simp only: plus_except[of q v, symmetric])"], ["proof (state)\nthis:\n  p ** (monomial (lookup q v) v + except q {v}) = p ** q\n\ngoal (1 subgoal):\n 1. p ** q = p ** monomial (lookup q v) v + p ** except q {v}", "finally"], ["proof (chain)\npicking this:\n  p ** monomial (lookup q v) v + p ** except q {v} = p ** q", "show ?thesis"], ["proof (prove)\nusing this:\n  p ** monomial (lookup q v) v + p ** except q {v} = p ** q\n\ngoal (1 subgoal):\n 1. p ** q = p ** monomial (lookup q v) v + p ** except q {v}", "by simp"], ["proof (state)\nthis:\n  p ** q = p ** monomial (lookup q v) v + p ** except q {v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_keys_mult_vecE:\n  assumes \"w \\<in> keys (p ** q)\"\n  obtains u v where \"u \\<in> keys p\" and \"v \\<in> keys q\" and \"component_of_term u = component_of_term v\"\n    and \"w = term_of_pair (pp_of_term u + pp_of_term v, component_of_term u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  w \\<in> keys (p ** q)", "have \"0 \\<noteq> lookup (p ** q) w\""], ["proof (prove)\nusing this:\n  w \\<in> keys (p ** q)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<noteq> lookup (p ** q) w", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (0::'b) \\<noteq> lookup (p ** q) w\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (0::'b) \\<noteq> lookup (p ** q) w\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"lookup (p ** q) w =\n      lookup ((proj_poly (component_of_term w) p) * (proj_poly (component_of_term w) q)) (pp_of_term w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p ** q) w =\n    lookup\n     (proj_poly (component_of_term w) p * proj_poly (component_of_term w) q)\n     (pp_of_term w)", "by (fact lookup_mult_vec)"], ["proof (state)\nthis:\n  lookup (p ** q) w =\n  lookup\n   (proj_poly (component_of_term w) p * proj_poly (component_of_term w) q)\n   (pp_of_term w)\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  (0::'b) \\<noteq>\n  lookup\n   (proj_poly (component_of_term w) p * proj_poly (component_of_term w) q)\n   (pp_of_term w)", "have \"pp_of_term w \\<in> keys ((proj_poly (component_of_term w) p) * (proj_poly (component_of_term w) q))\""], ["proof (prove)\nusing this:\n  (0::'b) \\<noteq>\n  lookup\n   (proj_poly (component_of_term w) p * proj_poly (component_of_term w) q)\n   (pp_of_term w)\n\ngoal (1 subgoal):\n 1. pp_of_term w\n    \\<in> keys\n           (proj_poly (component_of_term w) p *\n            proj_poly (component_of_term w) q)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  pp_of_term w\n  \\<in> keys\n         (proj_poly (component_of_term w) p *\n          proj_poly (component_of_term w) q)\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this keys_mult"], ["proof (chain)\npicking this:\n  pp_of_term w\n  \\<in> keys\n         (proj_poly (component_of_term w) p *\n          proj_poly (component_of_term w) q)\n  keys (?f * ?g)\n  \\<subseteq> {a + b |a b. a \\<in> keys ?f \\<and> b \\<in> keys ?g}", "have \"pp_of_term w \\<in> {t + s |t s. t \\<in> keys (proj_poly (component_of_term w) p) \\<and>\n                                   s \\<in> keys (proj_poly (component_of_term w) q)}\""], ["proof (prove)\nusing this:\n  pp_of_term w\n  \\<in> keys\n         (proj_poly (component_of_term w) p *\n          proj_poly (component_of_term w) q)\n  keys (?f * ?g)\n  \\<subseteq> {a + b |a b. a \\<in> keys ?f \\<and> b \\<in> keys ?g}\n\ngoal (1 subgoal):\n 1. pp_of_term w\n    \\<in> {t + s |t s.\n           t \\<in> keys (proj_poly (component_of_term w) p) \\<and>\n           s \\<in> keys (proj_poly (component_of_term w) q)}", ".."], ["proof (state)\nthis:\n  pp_of_term w\n  \\<in> {t + s |t s.\n         t \\<in> keys (proj_poly (component_of_term w) p) \\<and>\n         s \\<in> keys (proj_poly (component_of_term w) q)}\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  pp_of_term w\n  \\<in> {t + s |t s.\n         t \\<in> keys (proj_poly (component_of_term w) p) \\<and>\n         s \\<in> keys (proj_poly (component_of_term w) q)}", "obtain t s where 1: \"t \\<in> keys (proj_poly (component_of_term w) p)\"\n    and 2: \"s \\<in> keys (proj_poly (component_of_term w) q)\"\n    and eq: \"pp_of_term w = t + s\""], ["proof (prove)\nusing this:\n  pp_of_term w\n  \\<in> {t + s |t s.\n         t \\<in> keys (proj_poly (component_of_term w) p) \\<and>\n         s \\<in> keys (proj_poly (component_of_term w) q)}\n\ngoal (1 subgoal):\n 1. (\\<And>t s.\n        \\<lbrakk>t \\<in> keys (proj_poly (component_of_term w) p);\n         s \\<in> keys (proj_poly (component_of_term w) q);\n         pp_of_term w = t + s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  t \\<in> keys (proj_poly (component_of_term w) p)\n  s \\<in> keys (proj_poly (component_of_term w) q)\n  pp_of_term w = t + s\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?u = \"term_of_pair (t, component_of_term w)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?v = \"term_of_pair (s, component_of_term w)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from 1"], ["proof (chain)\npicking this:\n  t \\<in> keys (proj_poly (component_of_term w) p)", "have \"?u \\<in> keys p\""], ["proof (prove)\nusing this:\n  t \\<in> keys (proj_poly (component_of_term w) p)\n\ngoal (1 subgoal):\n 1. term_of_pair (t, component_of_term w) \\<in> keys p", "by (simp only: in_keys_iff lookup_proj_poly not_False_eq_True)"], ["proof (state)\nthis:\n  term_of_pair (t, component_of_term w) \\<in> keys p\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  term_of_pair (t, component_of_term w) \\<in> keys p\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from 2"], ["proof (chain)\npicking this:\n  s \\<in> keys (proj_poly (component_of_term w) q)", "have \"?v \\<in> keys q\""], ["proof (prove)\nusing this:\n  s \\<in> keys (proj_poly (component_of_term w) q)\n\ngoal (1 subgoal):\n 1. term_of_pair (s, component_of_term w) \\<in> keys q", "by (simp only: in_keys_iff lookup_proj_poly not_False_eq_True)"], ["proof (state)\nthis:\n  term_of_pair (s, component_of_term w) \\<in> keys q\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  term_of_pair (s, component_of_term w) \\<in> keys q\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"component_of_term ?u = component_of_term ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term (term_of_pair (t, component_of_term w)) =\n    component_of_term (term_of_pair (s, component_of_term w))", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  component_of_term (term_of_pair (t, component_of_term w)) =\n  component_of_term (term_of_pair (s, component_of_term w))\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  component_of_term (term_of_pair (t, component_of_term w)) =\n  component_of_term (term_of_pair (s, component_of_term w))\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"w = term_of_pair (pp_of_term ?u + pp_of_term ?v, component_of_term ?u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w =\n    term_of_pair\n     (pp_of_term (term_of_pair (t, component_of_term w)) +\n      pp_of_term (term_of_pair (s, component_of_term w)),\n      component_of_term (term_of_pair (t, component_of_term w)))", "by (simp add: eq[symmetric] term_simps)"], ["proof (state)\nthis:\n  w =\n  term_of_pair\n   (pp_of_term (term_of_pair (t, component_of_term w)) +\n    pp_of_term (term_of_pair (s, component_of_term w)),\n    component_of_term (term_of_pair (t, component_of_term w)))\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> keys p; v \\<in> keys q;\n         component_of_term u = component_of_term v;\n         w =\n         term_of_pair\n          (pp_of_term u + pp_of_term v, component_of_term u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  term_of_pair (t, component_of_term w) \\<in> keys p\n  term_of_pair (s, component_of_term w) \\<in> keys q\n  component_of_term (term_of_pair (t, component_of_term w)) =\n  component_of_term (term_of_pair (s, component_of_term w))\n  w =\n  term_of_pair\n   (pp_of_term (term_of_pair (t, component_of_term w)) +\n    pp_of_term (term_of_pair (s, component_of_term w)),\n    component_of_term (term_of_pair (t, component_of_term w)))", "show ?thesis"], ["proof (prove)\nusing this:\n  term_of_pair (t, component_of_term w) \\<in> keys p\n  term_of_pair (s, component_of_term w) \\<in> keys q\n  component_of_term (term_of_pair (t, component_of_term w)) =\n  component_of_term (term_of_pair (s, component_of_term w))\n  w =\n  term_of_pair\n   (pp_of_term (term_of_pair (t, component_of_term w)) +\n    pp_of_term (term_of_pair (s, component_of_term w)),\n    component_of_term (term_of_pair (t, component_of_term w)))\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_mult_vec_monomial_left:\n  \"lookup (monomial c v ** p) u =\n        (c * lookup p (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) when v adds\\<^sub>t u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial c v ** p) u =\n    (c *\n     lookup p\n      (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) when\n     v adds\\<^sub>t u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (monomial c v ** p) u =\n    (c *\n     lookup p\n      (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) when\n     v adds\\<^sub>t u)", "have eq1: \"lookup ((monomial c (pp_of_term v) when component_of_term v = component_of_term u) * proj_poly (component_of_term u) p)\n                (pp_of_term u) =\n        (lookup ((monomial c (pp_of_term v)) * proj_poly (component_of_term u) p) (pp_of_term u) when\n                component_of_term v = component_of_term u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     ((monomial c (pp_of_term v) when\n       component_of_term v = component_of_term u) *\n      proj_poly (component_of_term u) p)\n     (pp_of_term u) =\n    (lookup (monomial c (pp_of_term v) * proj_poly (component_of_term u) p)\n      (pp_of_term u) when\n     component_of_term v = component_of_term u)", "by (rule when_distrib, simp)"], ["proof (state)\nthis:\n  lookup\n   ((monomial c (pp_of_term v) when\n     component_of_term v = component_of_term u) *\n    proj_poly (component_of_term u) p)\n   (pp_of_term u) =\n  (lookup (monomial c (pp_of_term v) * proj_poly (component_of_term u) p)\n    (pp_of_term u) when\n   component_of_term v = component_of_term u)\n\ngoal (1 subgoal):\n 1. lookup (monomial c v ** p) u =\n    (c *\n     lookup p\n      (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) when\n     v adds\\<^sub>t u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial c v ** p) u =\n    (c *\n     lookup p\n      (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) when\n     v adds\\<^sub>t u)", "by (simp add: lookup_mult_vec proj_monomial eq1 lookup_times_monomial_left when_when\n        adds_term_def lookup_proj_poly conj_commute)"], ["proof (state)\nthis:\n  lookup (monomial c v ** p) u =\n  (c *\n   lookup p\n    (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) when\n   v adds\\<^sub>t u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_mult_vec_monomial_right:\n  \"lookup (p ** monomial c v) u =\n        (lookup p (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) * c when v adds\\<^sub>t u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p ** monomial c v) u =\n    (lookup p\n      (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) *\n     c when\n     v adds\\<^sub>t u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (p ** monomial c v) u =\n    (lookup p\n      (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) *\n     c when\n     v adds\\<^sub>t u)", "have eq1: \"lookup (proj_poly (component_of_term u) p * (monomial c (pp_of_term v) when component_of_term v = component_of_term u))\n                (pp_of_term u) =\n        (lookup (proj_poly (component_of_term u) p * (monomial c (pp_of_term v))) (pp_of_term u) when\n                component_of_term v = component_of_term u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (proj_poly (component_of_term u) p *\n      (monomial c (pp_of_term v) when\n       component_of_term v = component_of_term u))\n     (pp_of_term u) =\n    (lookup (proj_poly (component_of_term u) p * monomial c (pp_of_term v))\n      (pp_of_term u) when\n     component_of_term v = component_of_term u)", "by (rule when_distrib, simp)"], ["proof (state)\nthis:\n  lookup\n   (proj_poly (component_of_term u) p *\n    (monomial c (pp_of_term v) when\n     component_of_term v = component_of_term u))\n   (pp_of_term u) =\n  (lookup (proj_poly (component_of_term u) p * monomial c (pp_of_term v))\n    (pp_of_term u) when\n   component_of_term v = component_of_term u)\n\ngoal (1 subgoal):\n 1. lookup (p ** monomial c v) u =\n    (lookup p\n      (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) *\n     c when\n     v adds\\<^sub>t u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p ** monomial c v) u =\n    (lookup p\n      (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) *\n     c when\n     v adds\\<^sub>t u)", "by (simp add: lookup_mult_vec proj_monomial eq1 lookup_times_monomial_right when_when\n        adds_term_def lookup_proj_poly conj_commute)"], ["proof (state)\nthis:\n  lookup (p ** monomial c v) u =\n  (lookup p\n    (term_of_pair (pp_of_term u - pp_of_term v, component_of_term u)) *\n   c when\n   v adds\\<^sub>t u)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Scalar Multiplication\\<close>"], ["", "definition mult_scalar :: \"('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::semiring_0)\" (infixl \"\\<odot>\" 75)\n  where \"mult_scalar p = lift_poly_fun ((*) p)\""], ["", "lemma lookup_mult_scalar:\n  \"lookup (p \\<odot> q) v = lookup (p * (proj_poly (component_of_term v) q)) (pp_of_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) v =\n    lookup (p * proj_poly (component_of_term v) q) (pp_of_term v)", "unfolding mult_scalar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lift_poly_fun ((*) p) q) v =\n    lookup (p * proj_poly (component_of_term v) q) (pp_of_term v)", "by (rule lookup_lift_poly_fun_homogenous, simp)"], ["", "lemma lookup_mult_scalar_explicit:\n  \"lookup (p \\<odot> q) u = (\\<Sum>t\\<in>keys p. lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) u =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) u =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "let ?f = \"\\<lambda>t s. lookup (proj_poly (component_of_term u) q) s when pp_of_term u = t + s\""], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) u =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "note lookup_mult_scalar"], ["proof (state)\nthis:\n  lookup (?p \\<odot> ?q) ?v =\n  lookup (?p * proj_poly (component_of_term ?v) ?q) (pp_of_term ?v)\n\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) u =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "also"], ["proof (state)\nthis:\n  lookup (?p \\<odot> ?q) ?v =\n  lookup (?p * proj_poly (component_of_term ?v) ?q) (pp_of_term ?v)\n\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) u =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "have \"lookup (p * proj_poly (component_of_term u) q) (pp_of_term u) =\n              (\\<Sum>t. lookup p t * (Sum_any (?f t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p * proj_poly (component_of_term u) q) (pp_of_term u) =\n    (\\<Sum>t. lookup p t *\n              (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                        pp_of_term u = t + s))", "by (fact lookup_mult)"], ["proof (state)\nthis:\n  lookup (p * proj_poly (component_of_term u) q) (pp_of_term u) =\n  (\\<Sum>t. lookup p t *\n            (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                      pp_of_term u = t + s))\n\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) u =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "also"], ["proof (state)\nthis:\n  lookup (p * proj_poly (component_of_term u) q) (pp_of_term u) =\n  (\\<Sum>t. lookup p t *\n            (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                      pp_of_term u = t + s))\n\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) u =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"\\<dots> = (\\<Sum>t\\<in>keys p. lookup p t * (Sum_any (?f t)))\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>t. lookup p t *\n              (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                        pp_of_term u = t + s)) =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t *\n       (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                 pp_of_term u = t + s))", "by (rule Sum_any.expand_superset) (auto simp: in_keys_iff dest: mult_not_zero)"], ["proof (state)\nthis:\n  (\\<Sum>t. lookup p t *\n            (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                      pp_of_term u = t + s)) =\n  (\\<Sum>t\\<in>keys p.\n     lookup p t *\n     (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n               pp_of_term u = t + s))\n\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) u =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "also"], ["proof (state)\nthis:\n  (\\<Sum>t. lookup p t *\n            (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                      pp_of_term u = t + s)) =\n  (\\<Sum>t\\<in>keys p.\n     lookup p t *\n     (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n               pp_of_term u = t + s))\n\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) u =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"\\<dots> = (\\<Sum>t\\<in>keys p. lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>keys p.\n       lookup p t *\n       (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                 pp_of_term u = t + s)) =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       lookup p x *\n       (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                 pp_of_term u = x + s) =\n       lookup p x * (\\<Sum>v\\<in>keys q. lookup q v when u = x \\<oplus> v)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       lookup p x *\n       (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                 pp_of_term u = x + s) =\n       lookup p x * (\\<Sum>v\\<in>keys q. lookup q v when u = x \\<oplus> v)", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       lookup p x *\n       (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                 pp_of_term u = x + s) =\n       lookup p x * (\\<Sum>v\\<in>keys q. lookup q v when u = x \\<oplus> v)", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"Sum_any (?f t) = (\\<Sum>s\\<in>keys (proj_poly (component_of_term u) q). ?f t s)\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n              pp_of_term u = t + s) =\n    (\\<Sum>s\\<in>keys (proj_poly (component_of_term u) q).\n       lookup (proj_poly (component_of_term u) q) s when\n       pp_of_term u = t + s)", "by (rule Sum_any.expand_superset) (auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n            pp_of_term u = t + s) =\n  (\\<Sum>s\\<in>keys (proj_poly (component_of_term u) q).\n     lookup (proj_poly (component_of_term u) q) s when pp_of_term u = t + s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       lookup p x *\n       (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                 pp_of_term u = x + s) =\n       lookup p x * (\\<Sum>v\\<in>keys q. lookup q v when u = x \\<oplus> v)", "also"], ["proof (state)\nthis:\n  (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n            pp_of_term u = t + s) =\n  (\\<Sum>s\\<in>keys (proj_poly (component_of_term u) q).\n     lookup (proj_poly (component_of_term u) q) s when pp_of_term u = t + s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       lookup p x *\n       (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                 pp_of_term u = x + s) =\n       lookup p x * (\\<Sum>v\\<in>keys q. lookup q v when u = x \\<oplus> v)", "have \"\\<dots> = (\\<Sum>v\\<in>{x \\<in> keys q. component_of_term x = component_of_term u}. ?f t (pp_of_term v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>keys (proj_poly (component_of_term u) q).\n       lookup (proj_poly (component_of_term u) q) s when\n       pp_of_term u = t + s) =\n    (\\<Sum>v\\<in>{x \\<in> keys q.\n                  component_of_term x = component_of_term u}.\n       lookup (proj_poly (component_of_term u) q) (pp_of_term v) when\n       pp_of_term u = t + pp_of_term v)", "unfolding keys_proj_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>pp_of_term `\n                 {x \\<in> keys q.\n                  component_of_term x = component_of_term u}.\n       lookup (proj_poly (component_of_term u) q) s when\n       pp_of_term u = t + s) =\n    (\\<Sum>v\\<in>{x \\<in> keys q.\n                  component_of_term x = component_of_term u}.\n       lookup (proj_poly (component_of_term u) q) (pp_of_term v) when\n       pp_of_term u = t + pp_of_term v)", "proof (intro sum.reindex[simplified o_def] inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> keys q.\n                         component_of_term x = component_of_term u};\n        y \\<in> {x \\<in> keys q. component_of_term x = component_of_term u};\n        pp_of_term x = pp_of_term y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix v1 v2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> keys q.\n                         component_of_term x = component_of_term u};\n        y \\<in> {x \\<in> keys q. component_of_term x = component_of_term u};\n        pp_of_term x = pp_of_term y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"v1 \\<in> {x \\<in> keys q. component_of_term x = component_of_term u}\"\n        and \"v2 \\<in> {x \\<in> keys q. component_of_term x = component_of_term u}\""], ["proof (state)\nthis:\n  v1 \\<in> {x \\<in> keys q. component_of_term x = component_of_term u}\n  v2 \\<in> {x \\<in> keys q. component_of_term x = component_of_term u}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> keys q.\n                         component_of_term x = component_of_term u};\n        y \\<in> {x \\<in> keys q. component_of_term x = component_of_term u};\n        pp_of_term x = pp_of_term y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"component_of_term v1 = component_of_term v2\""], ["proof (prove)\nusing this:\n  v1 \\<in> {x \\<in> keys q. component_of_term x = component_of_term u}\n  v2 \\<in> {x \\<in> keys q. component_of_term x = component_of_term u}\n\ngoal (1 subgoal):\n 1. component_of_term v1 = component_of_term v2", "by simp"], ["proof (state)\nthis:\n  component_of_term v1 = component_of_term v2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> keys q.\n                         component_of_term x = component_of_term u};\n        y \\<in> {x \\<in> keys q. component_of_term x = component_of_term u};\n        pp_of_term x = pp_of_term y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  component_of_term v1 = component_of_term v2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> keys q.\n                         component_of_term x = component_of_term u};\n        y \\<in> {x \\<in> keys q. component_of_term x = component_of_term u};\n        pp_of_term x = pp_of_term y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"pp_of_term v1 = pp_of_term v2\""], ["proof (state)\nthis:\n  pp_of_term v1 = pp_of_term v2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> keys q.\n                         component_of_term x = component_of_term u};\n        y \\<in> {x \\<in> keys q. component_of_term x = component_of_term u};\n        pp_of_term x = pp_of_term y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  component_of_term v1 = component_of_term v2\n  pp_of_term v1 = pp_of_term v2", "show \"v1 = v2\""], ["proof (prove)\nusing this:\n  component_of_term v1 = component_of_term v2\n  pp_of_term v1 = pp_of_term v2\n\ngoal (1 subgoal):\n 1. v1 = v2", "by (metis term_of_pair_pair)"], ["proof (state)\nthis:\n  v1 = v2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>keys (proj_poly (component_of_term u) q).\n     lookup (proj_poly (component_of_term u) q) s when\n     pp_of_term u = t + s) =\n  (\\<Sum>v\\<in>{x \\<in> keys q. component_of_term x = component_of_term u}.\n     lookup (proj_poly (component_of_term u) q) (pp_of_term v) when\n     pp_of_term u = t + pp_of_term v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       lookup p x *\n       (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                 pp_of_term u = x + s) =\n       lookup p x * (\\<Sum>v\\<in>keys q. lookup q v when u = x \\<oplus> v)", "also"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>keys (proj_poly (component_of_term u) q).\n     lookup (proj_poly (component_of_term u) q) s when\n     pp_of_term u = t + s) =\n  (\\<Sum>v\\<in>{x \\<in> keys q. component_of_term x = component_of_term u}.\n     lookup (proj_poly (component_of_term u) q) (pp_of_term v) when\n     pp_of_term u = t + pp_of_term v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       lookup p x *\n       (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                 pp_of_term u = x + s) =\n       lookup p x * (\\<Sum>v\\<in>keys q. lookup q v when u = x \\<oplus> v)", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"\\<dots> = (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v)\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>{x \\<in> keys q.\n                  component_of_term x = component_of_term u}.\n       lookup (proj_poly (component_of_term u) q) (pp_of_term v) when\n       pp_of_term u = t + pp_of_term v) =\n    (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v)", "proof (intro sum.mono_neutral_cong_left ballI)"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<And>f. finite (keys f)) \\<Longrightarrow> finite (keys q)\n 2. (\\<And>f. finite (keys f)) \\<Longrightarrow>\n    {x \\<in> keys q. component_of_term x = component_of_term u}\n    \\<subseteq> keys q\n 3. \\<And>i.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        i \\<in> keys q -\n                {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup q i when u = t \\<oplus> i) = (0::'b)\n 4. \\<And>x.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        x \\<in> {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup (proj_poly (component_of_term u) q)\n                           (pp_of_term x) when\n                          pp_of_term u = t + pp_of_term x) =\n                         (lookup q x when u = t \\<oplus> x)", "fix v"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<And>f. finite (keys f)) \\<Longrightarrow> finite (keys q)\n 2. (\\<And>f. finite (keys f)) \\<Longrightarrow>\n    {x \\<in> keys q. component_of_term x = component_of_term u}\n    \\<subseteq> keys q\n 3. \\<And>i.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        i \\<in> keys q -\n                {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup q i when u = t \\<oplus> i) = (0::'b)\n 4. \\<And>x.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        x \\<in> {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup (proj_poly (component_of_term u) q)\n                           (pp_of_term x) when\n                          pp_of_term u = t + pp_of_term x) =\n                         (lookup q x when u = t \\<oplus> x)", "assume \"v \\<in> keys q - {x \\<in> keys q. component_of_term x = component_of_term u}\""], ["proof (state)\nthis:\n  v \\<in> keys q -\n          {x \\<in> keys q. component_of_term x = component_of_term u}\n\ngoal (4 subgoals):\n 1. (\\<And>f. finite (keys f)) \\<Longrightarrow> finite (keys q)\n 2. (\\<And>f. finite (keys f)) \\<Longrightarrow>\n    {x \\<in> keys q. component_of_term x = component_of_term u}\n    \\<subseteq> keys q\n 3. \\<And>i.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        i \\<in> keys q -\n                {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup q i when u = t \\<oplus> i) = (0::'b)\n 4. \\<And>x.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        x \\<in> {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup (proj_poly (component_of_term u) q)\n                           (pp_of_term x) when\n                          pp_of_term u = t + pp_of_term x) =\n                         (lookup q x when u = t \\<oplus> x)", "hence \"u \\<noteq> t \\<oplus> v\""], ["proof (prove)\nusing this:\n  v \\<in> keys q -\n          {x \\<in> keys q. component_of_term x = component_of_term u}\n\ngoal (1 subgoal):\n 1. u \\<noteq> t \\<oplus> v", "by (auto simp: component_of_term_splus)"], ["proof (state)\nthis:\n  u \\<noteq> t \\<oplus> v\n\ngoal (4 subgoals):\n 1. (\\<And>f. finite (keys f)) \\<Longrightarrow> finite (keys q)\n 2. (\\<And>f. finite (keys f)) \\<Longrightarrow>\n    {x \\<in> keys q. component_of_term x = component_of_term u}\n    \\<subseteq> keys q\n 3. \\<And>i.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        i \\<in> keys q -\n                {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup q i when u = t \\<oplus> i) = (0::'b)\n 4. \\<And>x.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        x \\<in> {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup (proj_poly (component_of_term u) q)\n                           (pp_of_term x) when\n                          pp_of_term u = t + pp_of_term x) =\n                         (lookup q x when u = t \\<oplus> x)", "thus \"(lookup q v when u = t \\<oplus> v) = 0\""], ["proof (prove)\nusing this:\n  u \\<noteq> t \\<oplus> v\n\ngoal (1 subgoal):\n 1. (lookup q v when u = t \\<oplus> v) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  (lookup q v when u = t \\<oplus> v) = (0::'b)\n\ngoal (3 subgoals):\n 1. (\\<And>f. finite (keys f)) \\<Longrightarrow> finite (keys q)\n 2. (\\<And>f. finite (keys f)) \\<Longrightarrow>\n    {x \\<in> keys q. component_of_term x = component_of_term u}\n    \\<subseteq> keys q\n 3. \\<And>x.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        x \\<in> {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup (proj_poly (component_of_term u) q)\n                           (pp_of_term x) when\n                          pp_of_term u = t + pp_of_term x) =\n                         (lookup q x when u = t \\<oplus> x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>f. finite (keys f)) \\<Longrightarrow> finite (keys q)\n 2. (\\<And>f. finite (keys f)) \\<Longrightarrow>\n    {x \\<in> keys q. component_of_term x = component_of_term u}\n    \\<subseteq> keys q\n 3. \\<And>x.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        x \\<in> {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup (proj_poly (component_of_term u) q)\n                           (pp_of_term x) when\n                          pp_of_term u = t + pp_of_term x) =\n                         (lookup q x when u = t \\<oplus> x)", "fix v"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>f. finite (keys f)) \\<Longrightarrow> finite (keys q)\n 2. (\\<And>f. finite (keys f)) \\<Longrightarrow>\n    {x \\<in> keys q. component_of_term x = component_of_term u}\n    \\<subseteq> keys q\n 3. \\<And>x.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        x \\<in> {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup (proj_poly (component_of_term u) q)\n                           (pp_of_term x) when\n                          pp_of_term u = t + pp_of_term x) =\n                         (lookup q x when u = t \\<oplus> x)", "assume \"v \\<in> {x \\<in> keys q. component_of_term x = component_of_term u}\""], ["proof (state)\nthis:\n  v \\<in> {x \\<in> keys q. component_of_term x = component_of_term u}\n\ngoal (3 subgoals):\n 1. (\\<And>f. finite (keys f)) \\<Longrightarrow> finite (keys q)\n 2. (\\<And>f. finite (keys f)) \\<Longrightarrow>\n    {x \\<in> keys q. component_of_term x = component_of_term u}\n    \\<subseteq> keys q\n 3. \\<And>x.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        x \\<in> {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup (proj_poly (component_of_term u) q)\n                           (pp_of_term x) when\n                          pp_of_term u = t + pp_of_term x) =\n                         (lookup q x when u = t \\<oplus> x)", "hence eq[symmetric]: \"component_of_term v = component_of_term u\""], ["proof (prove)\nusing this:\n  v \\<in> {x \\<in> keys q. component_of_term x = component_of_term u}\n\ngoal (1 subgoal):\n 1. component_of_term v = component_of_term u", "by simp"], ["proof (state)\nthis:\n  component_of_term u = component_of_term v\n\ngoal (3 subgoals):\n 1. (\\<And>f. finite (keys f)) \\<Longrightarrow> finite (keys q)\n 2. (\\<And>f. finite (keys f)) \\<Longrightarrow>\n    {x \\<in> keys q. component_of_term x = component_of_term u}\n    \\<subseteq> keys q\n 3. \\<And>x.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        x \\<in> {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup (proj_poly (component_of_term u) q)\n                           (pp_of_term x) when\n                          pp_of_term u = t + pp_of_term x) =\n                         (lookup q x when u = t \\<oplus> x)", "have \"u = t \\<oplus> v \\<longleftrightarrow> pp_of_term u = t + pp_of_term v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u = t \\<oplus> v) = (pp_of_term u = t + pp_of_term v)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. u = t \\<oplus> v \\<Longrightarrow> pp_of_term u = t + pp_of_term v\n 2. pp_of_term u = t + pp_of_term v \\<Longrightarrow> u = t \\<oplus> v", "assume \"pp_of_term u = t + pp_of_term v\""], ["proof (state)\nthis:\n  pp_of_term u = t + pp_of_term v\n\ngoal (2 subgoals):\n 1. u = t \\<oplus> v \\<Longrightarrow> pp_of_term u = t + pp_of_term v\n 2. pp_of_term u = t + pp_of_term v \\<Longrightarrow> u = t \\<oplus> v", "hence \"pp_of_term u = pp_of_term (t \\<oplus> v)\""], ["proof (prove)\nusing this:\n  pp_of_term u = t + pp_of_term v\n\ngoal (1 subgoal):\n 1. pp_of_term u = pp_of_term (t \\<oplus> v)", "by (simp only: pp_of_term_splus)"], ["proof (state)\nthis:\n  pp_of_term u = pp_of_term (t \\<oplus> v)\n\ngoal (2 subgoals):\n 1. u = t \\<oplus> v \\<Longrightarrow> pp_of_term u = t + pp_of_term v\n 2. pp_of_term u = t + pp_of_term v \\<Longrightarrow> u = t \\<oplus> v", "moreover"], ["proof (state)\nthis:\n  pp_of_term u = pp_of_term (t \\<oplus> v)\n\ngoal (2 subgoals):\n 1. u = t \\<oplus> v \\<Longrightarrow> pp_of_term u = t + pp_of_term v\n 2. pp_of_term u = t + pp_of_term v \\<Longrightarrow> u = t \\<oplus> v", "have \"component_of_term u = component_of_term (t \\<oplus> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term (t \\<oplus> v)", "by (simp only: eq component_of_term_splus)"], ["proof (state)\nthis:\n  component_of_term u = component_of_term (t \\<oplus> v)\n\ngoal (2 subgoals):\n 1. u = t \\<oplus> v \\<Longrightarrow> pp_of_term u = t + pp_of_term v\n 2. pp_of_term u = t + pp_of_term v \\<Longrightarrow> u = t \\<oplus> v", "ultimately"], ["proof (chain)\npicking this:\n  pp_of_term u = pp_of_term (t \\<oplus> v)\n  component_of_term u = component_of_term (t \\<oplus> v)", "show \"u = t \\<oplus> v\""], ["proof (prove)\nusing this:\n  pp_of_term u = pp_of_term (t \\<oplus> v)\n  component_of_term u = component_of_term (t \\<oplus> v)\n\ngoal (1 subgoal):\n 1. u = t \\<oplus> v", "by (metis term_of_pair_pair)"], ["proof (state)\nthis:\n  u = t \\<oplus> v\n\ngoal (1 subgoal):\n 1. u = t \\<oplus> v \\<Longrightarrow> pp_of_term u = t + pp_of_term v", "qed (simp add: pp_of_term_splus)"], ["proof (state)\nthis:\n  (u = t \\<oplus> v) = (pp_of_term u = t + pp_of_term v)\n\ngoal (3 subgoals):\n 1. (\\<And>f. finite (keys f)) \\<Longrightarrow> finite (keys q)\n 2. (\\<And>f. finite (keys f)) \\<Longrightarrow>\n    {x \\<in> keys q. component_of_term x = component_of_term u}\n    \\<subseteq> keys q\n 3. \\<And>x.\n       \\<lbrakk>\\<And>f. finite (keys f);\n        x \\<in> {x \\<in> keys q.\n                 component_of_term x = component_of_term u}\\<rbrakk>\n       \\<Longrightarrow> (lookup (proj_poly (component_of_term u) q)\n                           (pp_of_term x) when\n                          pp_of_term u = t + pp_of_term x) =\n                         (lookup q x when u = t \\<oplus> x)", "thus \"?f t (pp_of_term v) = (lookup q v when u = t \\<oplus> v)\""], ["proof (prove)\nusing this:\n  (u = t \\<oplus> v) = (pp_of_term u = t + pp_of_term v)\n\ngoal (1 subgoal):\n 1. (lookup (proj_poly (component_of_term u) q) (pp_of_term v) when\n     pp_of_term u = t + pp_of_term v) =\n    (lookup q v when u = t \\<oplus> v)", "by (simp add: lookup_proj_poly eq term_of_pair_pair)"], ["proof (state)\nthis:\n  (lookup (proj_poly (component_of_term u) q) (pp_of_term v) when\n   pp_of_term u = t + pp_of_term v) =\n  (lookup q v when u = t \\<oplus> v)\n\ngoal (2 subgoals):\n 1. (\\<And>f. finite (keys f)) \\<Longrightarrow> finite (keys q)\n 2. (\\<And>f. finite (keys f)) \\<Longrightarrow>\n    {x \\<in> keys q. component_of_term x = component_of_term u}\n    \\<subseteq> keys q", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>{x \\<in> keys q. component_of_term x = component_of_term u}.\n     lookup (proj_poly (component_of_term u) q) (pp_of_term v) when\n     pp_of_term u = t + pp_of_term v) =\n  (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       lookup p x *\n       (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n                 pp_of_term u = x + s) =\n       lookup p x * (\\<Sum>v\\<in>keys q. lookup q v when u = x \\<oplus> v)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n            pp_of_term u = t + s) =\n  (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v)", "show \"lookup p t * (Sum_any (?f t)) = lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v)\""], ["proof (prove)\nusing this:\n  (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n            pp_of_term u = t + s) =\n  (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v)\n\ngoal (1 subgoal):\n 1. lookup p t *\n    (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n              pp_of_term u = t + s) =\n    lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v)", "by (simp only:)"], ["proof (state)\nthis:\n  lookup p t *\n  (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n            pp_of_term u = t + s) =\n  lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>keys p.\n     lookup p t *\n     (\\<Sum>s. lookup (proj_poly (component_of_term u) q) s when\n               pp_of_term u = t + s)) =\n  (\\<Sum>t\\<in>keys p.\n     lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))\n\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) u =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "finally"], ["proof (chain)\npicking this:\n  lookup (p \\<odot> q) u =\n  (\\<Sum>t\\<in>keys p.\n     lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (p \\<odot> q) u =\n  (\\<Sum>t\\<in>keys p.\n     lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))\n\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) u =\n    (\\<Sum>t\\<in>keys p.\n       lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))", "."], ["proof (state)\nthis:\n  lookup (p \\<odot> q) u =\n  (\\<Sum>t\\<in>keys p.\n     lookup p t * (\\<Sum>v\\<in>keys q. lookup q v when u = t \\<oplus> v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_mult_scalar [term_simps]: \"proj_poly k (p \\<odot> q) = p * (proj_poly k q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (p \\<odot> q) = p * proj_poly k q", "unfolding mult_scalar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (lift_poly_fun ((*) p) q) = p * proj_poly k q", "by (rule proj_lift_poly_fun_homogenous, simp)"], ["", "lemma mult_scalar_zero_left [simp]: \"0 \\<odot> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<odot> p = 0", "by (rule poly_mapping_eqI_proj, simp add: term_simps)"], ["", "lemma mult_scalar_zero_right [simp]: \"p \\<odot> 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<odot> 0 = 0", "by (rule poly_mapping_eqI_proj, simp add: term_simps)"], ["", "lemma mult_scalar_one [simp]: \"(1::_ \\<Rightarrow>\\<^sub>0 'b::semiring_1) \\<odot> p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<odot> p = p", "by (rule poly_mapping_eqI_proj, simp add: term_simps)"], ["", "lemma mult_scalar_assoc [ac_simps]: \"(p * q) \\<odot> r = p \\<odot> (q \\<odot> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p * q) \\<odot> r = p \\<odot> (q \\<odot> r)", "by (rule poly_mapping_eqI_proj, simp add: ac_simps term_simps)"], ["", "lemma mult_scalar_distrib_right [algebra_simps]: \"(p + q) \\<odot> r = p \\<odot> r + q \\<odot> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p + q) \\<odot> r = p \\<odot> r + q \\<odot> r", "by (rule poly_mapping_eqI_proj, simp add: algebra_simps proj_plus term_simps)"], ["", "lemma mult_scalar_distrib_left [algebra_simps]: \"r \\<odot> (p + q) = r \\<odot> p + r \\<odot> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<odot> (p + q) = r \\<odot> p + r \\<odot> q", "by (rule poly_mapping_eqI_proj, simp add: algebra_simps proj_plus term_simps)"], ["", "lemma mult_scalar_minus_mult_left [simp]: \"(- p) \\<odot> q = - (p \\<odot> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<odot> q = - (p \\<odot> q)", "by (rule sym, rule minus_unique, simp add: mult_scalar_distrib_right[symmetric])"], ["", "lemma mult_scalar_minus_mult_right [simp]: \"p \\<odot> (- q) = - (p \\<odot> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<odot> - q = - (p \\<odot> q)", "by (rule sym, rule minus_unique, simp add: mult_scalar_distrib_left [symmetric])"], ["", "lemma minus_mult_scalar_minus [simp]: \"(- p) \\<odot> (- q) = p \\<odot> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<odot> - q = p \\<odot> q", "by simp"], ["", "lemma minus_mult_scalar_commute: \"(- p) \\<odot> q = p \\<odot> (- q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<odot> q = p \\<odot> - q", "by simp"], ["", "lemma mult_scalar_right_diff_distrib [algebra_simps]: \"r \\<odot> (p - q) = r \\<odot> p - r \\<odot> q\"\n  for r::\"_ \\<Rightarrow>\\<^sub>0 'b::ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<odot> (p - q) = r \\<odot> p - r \\<odot> q", "using mult_scalar_distrib_left [of r p \"- q\"]"], ["proof (prove)\nusing this:\n  r \\<odot> (p + - q) = r \\<odot> p + r \\<odot> - q\n\ngoal (1 subgoal):\n 1. r \\<odot> (p - q) = r \\<odot> p - r \\<odot> q", "by simp"], ["", "lemma mult_scalar_left_diff_distrib [algebra_simps]: \"(p - q) \\<odot> r = p \\<odot> r - q \\<odot> r\"\n  for p::\"_ \\<Rightarrow>\\<^sub>0 'b::ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p - q) \\<odot> r = p \\<odot> r - q \\<odot> r", "using mult_scalar_distrib_right [of p \"- q\" r]"], ["proof (prove)\nusing this:\n  (p + - q) \\<odot> r = p \\<odot> r + - q \\<odot> r\n\ngoal (1 subgoal):\n 1. (p - q) \\<odot> r = p \\<odot> r - q \\<odot> r", "by simp"], ["", "lemma sum_mult_scalar_distrib_left: \"r \\<odot> (sum f A) = (\\<Sum>a\\<in>A. r \\<odot> f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<odot> sum f A = (\\<Sum>a\\<in>A. r \\<odot> f a)", "by (induct A rule: infinite_finite_induct, simp_all add: algebra_simps)"], ["", "lemma sum_mult_scalar_distrib_right: \"(sum f A) \\<odot> v = (\\<Sum>a\\<in>A. f a \\<odot> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f A \\<odot> v = (\\<Sum>a\\<in>A. f a \\<odot> v)", "by (induct A rule: infinite_finite_induct, simp_all add: algebra_simps)"], ["", "lemma mult_scalar_monomial_monomial: \"(monomial c t) \\<odot> (monomial d v) = monomial (c * d) (t \\<oplus> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c t \\<odot> monomial d v = monomial (c * d) (t \\<oplus> v)", "by (rule poly_mapping_eqI_proj, simp add: proj_monomial mult_single when_def term_simps)"], ["", "lemma mult_scalar_monomial: \"(monomial c t) \\<odot> p = monom_mult c t p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c t \\<odot> p = monom_mult c t p", "by (rule poly_mapping_eqI_proj, rule poly_mapping_eqI,\n      auto simp add: lookup_times_monomial_left lookup_proj_poly lookup_monom_mult when_def\n        adds_pp_def sminus_def term_simps)"], ["", "lemma mult_scalar_rec_left: \"p \\<odot> q = monom_mult (lookup p t) t q + (except p {t}) \\<odot> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<odot> q = monom_mult (lookup p t) t q + except p {t} \\<odot> q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<odot> q = monom_mult (lookup p t) t q + except p {t} \\<odot> q", "from plus_except[of p t]"], ["proof (chain)\npicking this:\n  p = monomial (lookup p t) t + except p {t}", "have \"p \\<odot> q = (monomial (lookup p t) t + except p {t}) \\<odot> q\""], ["proof (prove)\nusing this:\n  p = monomial (lookup p t) t + except p {t}\n\ngoal (1 subgoal):\n 1. p \\<odot> q = (monomial (lookup p t) t + except p {t}) \\<odot> q", "by simp"], ["proof (state)\nthis:\n  p \\<odot> q = (monomial (lookup p t) t + except p {t}) \\<odot> q\n\ngoal (1 subgoal):\n 1. p \\<odot> q = monom_mult (lookup p t) t q + except p {t} \\<odot> q", "also"], ["proof (state)\nthis:\n  p \\<odot> q = (monomial (lookup p t) t + except p {t}) \\<odot> q\n\ngoal (1 subgoal):\n 1. p \\<odot> q = monom_mult (lookup p t) t q + except p {t} \\<odot> q", "have \"... = monomial (lookup p t) t \\<odot> q + except p {t} \\<odot> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monomial (lookup p t) t + except p {t}) \\<odot> q =\n    monomial (lookup p t) t \\<odot> q + except p {t} \\<odot> q", "by (simp only: algebra_simps)"], ["proof (state)\nthis:\n  (monomial (lookup p t) t + except p {t}) \\<odot> q =\n  monomial (lookup p t) t \\<odot> q + except p {t} \\<odot> q\n\ngoal (1 subgoal):\n 1. p \\<odot> q = monom_mult (lookup p t) t q + except p {t} \\<odot> q", "finally"], ["proof (chain)\npicking this:\n  p \\<odot> q = monomial (lookup p t) t \\<odot> q + except p {t} \\<odot> q", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<odot> q = monomial (lookup p t) t \\<odot> q + except p {t} \\<odot> q\n\ngoal (1 subgoal):\n 1. p \\<odot> q = monom_mult (lookup p t) t q + except p {t} \\<odot> q", "by (simp only: mult_scalar_monomial)"], ["proof (state)\nthis:\n  p \\<odot> q = monom_mult (lookup p t) t q + except p {t} \\<odot> q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_scalar_rec_right: \"p \\<odot> q = p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<odot> q = p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<odot> q = p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v}", "have \"p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v} = p \\<odot> (monomial (lookup q v) v + except q {v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v} =\n    p \\<odot> (monomial (lookup q v) v + except q {v})", "by (simp only: mult_scalar_distrib_left)"], ["proof (state)\nthis:\n  p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v} =\n  p \\<odot> (monomial (lookup q v) v + except q {v})\n\ngoal (1 subgoal):\n 1. p \\<odot> q = p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v}", "also"], ["proof (state)\nthis:\n  p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v} =\n  p \\<odot> (monomial (lookup q v) v + except q {v})\n\ngoal (1 subgoal):\n 1. p \\<odot> q = p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v}", "have \"... = p \\<odot> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<odot> (monomial (lookup q v) v + except q {v}) = p \\<odot> q", "by (simp only: plus_except[of q v, symmetric])"], ["proof (state)\nthis:\n  p \\<odot> (monomial (lookup q v) v + except q {v}) = p \\<odot> q\n\ngoal (1 subgoal):\n 1. p \\<odot> q = p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v}", "finally"], ["proof (chain)\npicking this:\n  p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v} = p \\<odot> q", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v} = p \\<odot> q\n\ngoal (1 subgoal):\n 1. p \\<odot> q = p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v}", "by simp"], ["proof (state)\nthis:\n  p \\<odot> q = p \\<odot> monomial (lookup q v) v + p \\<odot> except q {v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_keys_mult_scalarE:\n  assumes \"v \\<in> keys (p \\<odot> q)\"\n  obtains t u where \"t \\<in> keys p\" and \"u \\<in> keys q\" and \"v = t \\<oplus> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  v \\<in> keys (p \\<odot> q)", "have \"0 \\<noteq> lookup (p \\<odot> q) v\""], ["proof (prove)\nusing this:\n  v \\<in> keys (p \\<odot> q)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<noteq> lookup (p \\<odot> q) v", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (0::'b) \\<noteq> lookup (p \\<odot> q) v\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (0::'b) \\<noteq> lookup (p \\<odot> q) v\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"lookup (p \\<odot> q) v = lookup (p * (proj_poly (component_of_term v) q)) (pp_of_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p \\<odot> q) v =\n    lookup (p * proj_poly (component_of_term v) q) (pp_of_term v)", "by (fact lookup_mult_scalar)"], ["proof (state)\nthis:\n  lookup (p \\<odot> q) v =\n  lookup (p * proj_poly (component_of_term v) q) (pp_of_term v)\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  (0::'b) \\<noteq>\n  lookup (p * proj_poly (component_of_term v) q) (pp_of_term v)", "have \"pp_of_term v \\<in> keys (p * proj_poly (component_of_term v) q)\""], ["proof (prove)\nusing this:\n  (0::'b) \\<noteq>\n  lookup (p * proj_poly (component_of_term v) q) (pp_of_term v)\n\ngoal (1 subgoal):\n 1. pp_of_term v \\<in> keys (p * proj_poly (component_of_term v) q)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  pp_of_term v \\<in> keys (p * proj_poly (component_of_term v) q)\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this keys_mult"], ["proof (chain)\npicking this:\n  pp_of_term v \\<in> keys (p * proj_poly (component_of_term v) q)\n  keys (?f * ?g)\n  \\<subseteq> {a + b |a b. a \\<in> keys ?f \\<and> b \\<in> keys ?g}", "have \"pp_of_term v \\<in> {t + s |t s. t \\<in> keys p \\<and> s \\<in> keys (proj_poly (component_of_term v) q)}\""], ["proof (prove)\nusing this:\n  pp_of_term v \\<in> keys (p * proj_poly (component_of_term v) q)\n  keys (?f * ?g)\n  \\<subseteq> {a + b |a b. a \\<in> keys ?f \\<and> b \\<in> keys ?g}\n\ngoal (1 subgoal):\n 1. pp_of_term v\n    \\<in> {t + s |t s.\n           t \\<in> keys p \\<and>\n           s \\<in> keys (proj_poly (component_of_term v) q)}", ".."], ["proof (state)\nthis:\n  pp_of_term v\n  \\<in> {t + s |t s.\n         t \\<in> keys p \\<and>\n         s \\<in> keys (proj_poly (component_of_term v) q)}\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  pp_of_term v\n  \\<in> {t + s |t s.\n         t \\<in> keys p \\<and>\n         s \\<in> keys (proj_poly (component_of_term v) q)}", "obtain t s where \"t \\<in> keys p\" and *: \"s \\<in> keys (proj_poly (component_of_term v) q)\"\n    and eq: \"pp_of_term v = t + s\""], ["proof (prove)\nusing this:\n  pp_of_term v\n  \\<in> {t + s |t s.\n         t \\<in> keys p \\<and>\n         s \\<in> keys (proj_poly (component_of_term v) q)}\n\ngoal (1 subgoal):\n 1. (\\<And>t s.\n        \\<lbrakk>t \\<in> keys p;\n         s \\<in> keys (proj_poly (component_of_term v) q);\n         pp_of_term v = t + s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  t \\<in> keys p\n  s \\<in> keys (proj_poly (component_of_term v) q)\n  pp_of_term v = t + s\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(1)"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from *"], ["proof (chain)\npicking this:\n  s \\<in> keys (proj_poly (component_of_term v) q)", "have \"term_of_pair (s, component_of_term v) \\<in> keys q\""], ["proof (prove)\nusing this:\n  s \\<in> keys (proj_poly (component_of_term v) q)\n\ngoal (1 subgoal):\n 1. term_of_pair (s, component_of_term v) \\<in> keys q", "by (simp only: in_keys_iff lookup_proj_poly not_False_eq_True)"], ["proof (state)\nthis:\n  term_of_pair (s, component_of_term v) \\<in> keys q\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  term_of_pair (s, component_of_term v) \\<in> keys q\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v = t \\<oplus> term_of_pair (s, component_of_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = t \\<oplus> term_of_pair (s, component_of_term v)", "by (simp add: splus_def eq[symmetric] term_simps)"], ["proof (state)\nthis:\n  v = t \\<oplus> term_of_pair (s, component_of_term v)\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys q; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> keys p\n  term_of_pair (s, component_of_term v) \\<in> keys q\n  v = t \\<oplus> term_of_pair (s, component_of_term v)", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  term_of_pair (s, component_of_term v) \\<in> keys q\n  v = t \\<oplus> term_of_pair (s, component_of_term v)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_mult_scalar_monomial_right:\n  \"lookup (p \\<odot> monomial c v) u = (lookup p (pp_of_term u - pp_of_term v) * c when v adds\\<^sub>t u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p \\<odot> monomial c v) u =\n    (lookup p (pp_of_term u - pp_of_term v) * c when v adds\\<^sub>t u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (p \\<odot> monomial c v) u =\n    (lookup p (pp_of_term u - pp_of_term v) * c when v adds\\<^sub>t u)", "have eq1: \"lookup (p * (monomial c (pp_of_term v) when component_of_term v = component_of_term u)) (pp_of_term u) =\n             (lookup (p * (monomial c (pp_of_term v))) (pp_of_term u) when component_of_term v = component_of_term u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (p *\n      (monomial c (pp_of_term v) when\n       component_of_term v = component_of_term u))\n     (pp_of_term u) =\n    (lookup (p * monomial c (pp_of_term v)) (pp_of_term u) when\n     component_of_term v = component_of_term u)", "by (rule when_distrib, simp)"], ["proof (state)\nthis:\n  lookup\n   (p *\n    (monomial c (pp_of_term v) when\n     component_of_term v = component_of_term u))\n   (pp_of_term u) =\n  (lookup (p * monomial c (pp_of_term v)) (pp_of_term u) when\n   component_of_term v = component_of_term u)\n\ngoal (1 subgoal):\n 1. lookup (p \\<odot> monomial c v) u =\n    (lookup p (pp_of_term u - pp_of_term v) * c when v adds\\<^sub>t u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p \\<odot> monomial c v) u =\n    (lookup p (pp_of_term u - pp_of_term v) * c when v adds\\<^sub>t u)", "by (simp add: lookup_mult_scalar eq1 proj_monomial lookup_times_monomial_right when_when\n        adds_term_def lookup_proj_poly conj_commute)"], ["proof (state)\nthis:\n  lookup (p \\<odot> monomial c v) u =\n  (lookup p (pp_of_term u - pp_of_term v) * c when v adds\\<^sub>t u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_mult_scalar_monomial_right_plus: \"lookup (p \\<odot> monomial c v) (t \\<oplus> v) = lookup p t * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p \\<odot> monomial c v) (t \\<oplus> v) = lookup p t * c", "by (simp add: lookup_mult_scalar_monomial_right term_simps)"], ["", "lemma keys_mult_scalar_monomial_right_subset: \"keys (p \\<odot> monomial c v) \\<subseteq> (\\<lambda>t. t \\<oplus> v) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p \\<odot> monomial c v)\n    \\<subseteq> (\\<lambda>t. t \\<oplus> v) ` keys p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (p \\<odot> monomial c v) \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (p \\<odot> monomial c v) \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p", "assume \"u \\<in> keys (p \\<odot> monomial c v)\""], ["proof (state)\nthis:\n  u \\<in> keys (p \\<odot> monomial c v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (p \\<odot> monomial c v) \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p", "then"], ["proof (chain)\npicking this:\n  u \\<in> keys (p \\<odot> monomial c v)", "obtain t w where \"t \\<in> keys p\" and \"w \\<in> keys (monomial c v)\" and \"u = t \\<oplus> w\""], ["proof (prove)\nusing this:\n  u \\<in> keys (p \\<odot> monomial c v)\n\ngoal (1 subgoal):\n 1. (\\<And>t w.\n        \\<lbrakk>t \\<in> keys p; w \\<in> keys (monomial c v);\n         u = t \\<oplus> w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_mult_scalarE)"], ["proof (state)\nthis:\n  t \\<in> keys p\n  w \\<in> keys (monomial c v)\n  u = t \\<oplus> w\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (p \\<odot> monomial c v) \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p", "from this(2)"], ["proof (chain)\npicking this:\n  w \\<in> keys (monomial c v)", "have \"w = v\""], ["proof (prove)\nusing this:\n  w \\<in> keys (monomial c v)\n\ngoal (1 subgoal):\n 1. w = v", "by (metis empty_iff insert_iff keys_single)"], ["proof (state)\nthis:\n  w = v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (p \\<odot> monomial c v) \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p", "from \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys p", "show \"u \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. u \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p", "unfolding \\<open>u = t \\<oplus> w\\<close> \\<open>w = v\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. t \\<oplus> v \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p", "by fastforce"], ["proof (state)\nthis:\n  u \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_mult_scalar_monomial_right:\n  assumes \"c \\<noteq> (0::'b::semiring_no_zero_divisors)\"\n  shows \"keys (p \\<odot> monomial c v) = (\\<lambda>t. t \\<oplus> v) ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p \\<odot> monomial c v) = (\\<lambda>t. t \\<oplus> v) ` keys p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (p \\<odot> monomial c v)\n    \\<subseteq> (\\<lambda>t. t \\<oplus> v) ` keys p\n 2. (\\<lambda>t. t \\<oplus> v) ` keys p\n    \\<subseteq> keys (p \\<odot> monomial c v)", "show \"(\\<lambda>t. t \\<oplus> v) ` keys p \\<subseteq> keys (p \\<odot> monomial c v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. t \\<oplus> v) ` keys p\n    \\<subseteq> keys (p \\<odot> monomial c v)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p \\<Longrightarrow>\n       x \\<in> keys (p \\<odot> monomial c v)", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p \\<Longrightarrow>\n       x \\<in> keys (p \\<odot> monomial c v)", "assume \"u \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p\""], ["proof (state)\nthis:\n  u \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p \\<Longrightarrow>\n       x \\<in> keys (p \\<odot> monomial c v)", "then"], ["proof (chain)\npicking this:\n  u \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p", "obtain t where \"t \\<in> keys p\" and \"u = t \\<oplus> v\""], ["proof (prove)\nusing this:\n  u \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; u = t \\<oplus> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t \\<in> keys p\n  u = t \\<oplus> v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p \\<Longrightarrow>\n       x \\<in> keys (p \\<odot> monomial c v)", "have \"lookup (p \\<odot> monomial c v) (t \\<oplus> v) = lookup p t * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p \\<odot> monomial c v) (t \\<oplus> v) = lookup p t * c", "by (fact lookup_mult_scalar_monomial_right_plus)"], ["proof (state)\nthis:\n  lookup (p \\<odot> monomial c v) (t \\<oplus> v) = lookup p t * c\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p \\<Longrightarrow>\n       x \\<in> keys (p \\<odot> monomial c v)", "also"], ["proof (state)\nthis:\n  lookup (p \\<odot> monomial c v) (t \\<oplus> v) = lookup p t * c\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p \\<Longrightarrow>\n       x \\<in> keys (p \\<odot> monomial c v)", "from \\<open>t \\<in> keys p\\<close> assms"], ["proof (chain)\npicking this:\n  t \\<in> keys p\n  c \\<noteq> (0::'b)", "have \"... \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup p t * c \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup p t * c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t \\<oplus> v) ` keys p \\<Longrightarrow>\n       x \\<in> keys (p \\<odot> monomial c v)", "finally"], ["proof (chain)\npicking this:\n  lookup (p \\<odot> monomial c v) (t \\<oplus> v) \\<noteq> (0::'b)", "show \"u \\<in> keys (p \\<odot> monomial c v)\""], ["proof (prove)\nusing this:\n  lookup (p \\<odot> monomial c v) (t \\<oplus> v) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. u \\<in> keys (p \\<odot> monomial c v)", "by (simp add: in_keys_iff \\<open>u = t \\<oplus> v\\<close>)"], ["proof (state)\nthis:\n  u \\<in> keys (p \\<odot> monomial c v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>t. t \\<oplus> v) ` keys p\n  \\<subseteq> keys (p \\<odot> monomial c v)\n\ngoal (1 subgoal):\n 1. keys (p \\<odot> monomial c v)\n    \\<subseteq> (\\<lambda>t. t \\<oplus> v) ` keys p", "qed (fact keys_mult_scalar_monomial_right_subset)"], ["", "end"], ["", "(* term_powerprod *)"], ["", "subsection \\<open>Sums and Products\\<close>"], ["", "lemma sum_poly_mapping_eq_zeroI:\n  assumes \"p ` A \\<subseteq> {0}\"\n  shows \"sum p A = (0::(_ \\<Rightarrow>\\<^sub>0 'b::comm_monoid_add))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum p A = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. sum p A \\<noteq> 0 \\<Longrightarrow> False", "assume \"sum p A \\<noteq> 0\""], ["proof (state)\nthis:\n  sum p A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sum p A \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  sum p A \\<noteq> 0", "obtain a where \"a \\<in> A\" and \"p a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  sum p A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A; p a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule comm_monoid_add_class.sum.not_neutral_contains_not_neutral)"], ["proof (state)\nthis:\n  a \\<in> A\n  p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sum p A \\<noteq> 0 \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  p ` A \\<subseteq> {0}\n  a \\<in> A\n  p a \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  p ` A \\<subseteq> {0}\n  a \\<in> A\n  p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_sum_list: \"lookup (sum_list ps) a = sum_list (map (\\<lambda>p. lookup p a) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (sum_list ps) a = (\\<Sum>p\\<leftarrow>ps. lookup p a)", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup (sum_list []) a = (\\<Sum>p\\<leftarrow>[]. lookup p a)\n 2. \\<And>aa ps.\n       lookup (sum_list ps) a =\n       (\\<Sum>p\\<leftarrow>ps. lookup p a) \\<Longrightarrow>\n       lookup (sum_list (aa # ps)) a =\n       (\\<Sum>p\\<leftarrow>aa # ps. lookup p a)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lookup (sum_list []) a = (\\<Sum>p\\<leftarrow>[]. lookup p a)\n 2. \\<And>aa ps.\n       lookup (sum_list ps) a =\n       (\\<Sum>p\\<leftarrow>ps. lookup p a) \\<Longrightarrow>\n       lookup (sum_list (aa # ps)) a =\n       (\\<Sum>p\\<leftarrow>aa # ps. lookup p a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (sum_list []) a = (\\<Sum>p\\<leftarrow>[]. lookup p a)", "by simp"], ["proof (state)\nthis:\n  lookup (sum_list []) a = (\\<Sum>p\\<leftarrow>[]. lookup p a)\n\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       lookup (sum_list ps) a =\n       (\\<Sum>p\\<leftarrow>ps. lookup p a) \\<Longrightarrow>\n       lookup (sum_list (aa # ps)) a =\n       (\\<Sum>p\\<leftarrow>aa # ps. lookup p a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       lookup (sum_list ps) a =\n       (\\<Sum>p\\<leftarrow>ps. lookup p a) \\<Longrightarrow>\n       lookup (sum_list (aa # ps)) a =\n       (\\<Sum>p\\<leftarrow>aa # ps. lookup p a)", "case (Cons p ps)"], ["proof (state)\nthis:\n  lookup (sum_list ps) a = (\\<Sum>p\\<leftarrow>ps. lookup p a)\n\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       lookup (sum_list ps) a =\n       (\\<Sum>p\\<leftarrow>ps. lookup p a) \\<Longrightarrow>\n       lookup (sum_list (aa # ps)) a =\n       (\\<Sum>p\\<leftarrow>aa # ps. lookup p a)", "thus ?case"], ["proof (prove)\nusing this:\n  lookup (sum_list ps) a = (\\<Sum>p\\<leftarrow>ps. lookup p a)\n\ngoal (1 subgoal):\n 1. lookup (sum_list (p # ps)) a = (\\<Sum>p\\<leftarrow>p # ps. lookup p a)", "by (simp add: lookup_add)"], ["proof (state)\nthis:\n  lookup (sum_list (p # ps)) a = (\\<Sum>p\\<leftarrow>p # ps. lookup p a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Legacy:\\<close>"], ["", "lemmas keys_sum_subset = Poly_Mapping.keys_sum"], ["", "lemma keys_sum_list_subset: \"keys (sum_list ps) \\<subseteq> Keys (set ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (sum_list ps) \\<subseteq> Keys (set ps)", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (sum_list []) \\<subseteq> Keys (set [])\n 2. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. keys (sum_list []) \\<subseteq> Keys (set [])\n 2. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (sum_list []) \\<subseteq> Keys (set [])", "by simp"], ["proof (state)\nthis:\n  keys (sum_list []) \\<subseteq> Keys (set [])\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "case (Cons p ps)"], ["proof (state)\nthis:\n  keys (sum_list ps) \\<subseteq> Keys (set ps)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "have \"keys (sum_list (p # ps)) = keys (p + sum_list ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (sum_list (p # ps)) = keys (p + sum_list ps)", "by simp"], ["proof (state)\nthis:\n  keys (sum_list (p # ps)) = keys (p + sum_list ps)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "also"], ["proof (state)\nthis:\n  keys (sum_list (p # ps)) = keys (p + sum_list ps)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "have \"\\<dots> \\<subseteq> keys p \\<union> keys (sum_list ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p + sum_list ps) \\<subseteq> keys p \\<union> keys (sum_list ps)", "by (fact Poly_Mapping.keys_add)"], ["proof (state)\nthis:\n  keys (p + sum_list ps) \\<subseteq> keys p \\<union> keys (sum_list ps)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "also"], ["proof (state)\nthis:\n  keys (p + sum_list ps) \\<subseteq> keys p \\<union> keys (sum_list ps)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "from Cons"], ["proof (chain)\npicking this:\n  keys (sum_list ps) \\<subseteq> Keys (set ps)", "have \"\\<dots> \\<subseteq> keys p \\<union> Keys (set ps)\""], ["proof (prove)\nusing this:\n  keys (sum_list ps) \\<subseteq> Keys (set ps)\n\ngoal (1 subgoal):\n 1. keys p \\<union> keys (sum_list ps)\n    \\<subseteq> keys p \\<union> Keys (set ps)", "by blast"], ["proof (state)\nthis:\n  keys p \\<union> keys (sum_list ps)\n  \\<subseteq> keys p \\<union> Keys (set ps)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "also"], ["proof (state)\nthis:\n  keys p \\<union> keys (sum_list ps)\n  \\<subseteq> keys p \\<union> Keys (set ps)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "have \"\\<dots> = Keys (set (p # ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys p \\<union> Keys (set ps) = Keys (set (p # ps))", "by (simp add: Keys_insert)"], ["proof (state)\nthis:\n  keys p \\<union> Keys (set ps) = Keys (set (p # ps))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       keys (sum_list ps) \\<subseteq> Keys (set ps) \\<Longrightarrow>\n       keys (sum_list (a # ps)) \\<subseteq> Keys (set (a # ps))", "finally"], ["proof (chain)\npicking this:\n  keys (sum_list (p # ps)) \\<subseteq> Keys (set (p # ps))", "show ?case"], ["proof (prove)\nusing this:\n  keys (sum_list (p # ps)) \\<subseteq> Keys (set (p # ps))\n\ngoal (1 subgoal):\n 1. keys (sum_list (p # ps)) \\<subseteq> Keys (set (p # ps))", "."], ["proof (state)\nthis:\n  keys (sum_list (p # ps)) \\<subseteq> Keys (set (p # ps))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_sum:\n  assumes \"finite A\" and \"\\<And>a1 a2. a1 \\<in> A \\<Longrightarrow> a2 \\<in> A \\<Longrightarrow> a1 \\<noteq> a2 \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) = {}\"\n  shows \"keys (sum f A) = (\\<Union>a\\<in>A. keys (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (sum f A) = (\\<Union>a\\<in>A. keys (f a))", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  \\<lbrakk>?a1.0 \\<in> A; ?a2.0 \\<in> A; ?a1.0 \\<noteq> ?a2.0\\<rbrakk>\n  \\<Longrightarrow> keys (f ?a1.0) \\<inter> keys (f ?a2.0) = {}\n\ngoal (1 subgoal):\n 1. keys (sum f A) = (\\<Union>a\\<in>A. keys (f a))", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>a1 a2.\n        \\<lbrakk>a1 \\<in> {}; a2 \\<in> {}; a1 \\<noteq> a2\\<rbrakk>\n        \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                          {}) \\<Longrightarrow>\n    keys (sum f {}) = (\\<Union>a\\<in>{}. keys (f a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a1 a2.\n            \\<lbrakk>a1 \\<in> F; a2 \\<in> F; a1 \\<noteq> a2\\<rbrakk>\n            \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                              {}) \\<Longrightarrow>\n        keys (sum f F) = (\\<Union>a\\<in>F. keys (f a));\n        \\<And>a1 a2.\n           \\<lbrakk>a1 \\<in> insert x F; a2 \\<in> insert x F;\n            a1 \\<noteq> a2\\<rbrakk>\n           \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) = {}\\<rbrakk>\n       \\<Longrightarrow> keys (sum f (insert x F)) =\n                         (\\<Union>a\\<in>insert x F. keys (f a))", "case empty"], ["proof (state)\nthis:\n  \\<lbrakk>?a1.0 \\<in> {}; ?a2.0 \\<in> {}; ?a1.0 \\<noteq> ?a2.0\\<rbrakk>\n  \\<Longrightarrow> keys (f ?a1.0) \\<inter> keys (f ?a2.0) = {}\n\ngoal (2 subgoals):\n 1. (\\<And>a1 a2.\n        \\<lbrakk>a1 \\<in> {}; a2 \\<in> {}; a1 \\<noteq> a2\\<rbrakk>\n        \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                          {}) \\<Longrightarrow>\n    keys (sum f {}) = (\\<Union>a\\<in>{}. keys (f a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a1 a2.\n            \\<lbrakk>a1 \\<in> F; a2 \\<in> F; a1 \\<noteq> a2\\<rbrakk>\n            \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                              {}) \\<Longrightarrow>\n        keys (sum f F) = (\\<Union>a\\<in>F. keys (f a));\n        \\<And>a1 a2.\n           \\<lbrakk>a1 \\<in> insert x F; a2 \\<in> insert x F;\n            a1 \\<noteq> a2\\<rbrakk>\n           \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) = {}\\<rbrakk>\n       \\<Longrightarrow> keys (sum f (insert x F)) =\n                         (\\<Union>a\\<in>insert x F. keys (f a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (sum f {}) = (\\<Union>a\\<in>{}. keys (f a))", "by simp"], ["proof (state)\nthis:\n  keys (sum f {}) = (\\<Union>a\\<in>{}. keys (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a1 a2.\n            \\<lbrakk>a1 \\<in> F; a2 \\<in> F; a1 \\<noteq> a2\\<rbrakk>\n            \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                              {}) \\<Longrightarrow>\n        keys (sum f F) = (\\<Union>a\\<in>F. keys (f a));\n        \\<And>a1 a2.\n           \\<lbrakk>a1 \\<in> insert x F; a2 \\<in> insert x F;\n            a1 \\<noteq> a2\\<rbrakk>\n           \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) = {}\\<rbrakk>\n       \\<Longrightarrow> keys (sum f (insert x F)) =\n                         (\\<Union>a\\<in>insert x F. keys (f a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a1 a2.\n            \\<lbrakk>a1 \\<in> F; a2 \\<in> F; a1 \\<noteq> a2\\<rbrakk>\n            \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                              {}) \\<Longrightarrow>\n        keys (sum f F) = (\\<Union>a\\<in>F. keys (f a));\n        \\<And>a1 a2.\n           \\<lbrakk>a1 \\<in> insert x F; a2 \\<in> insert x F;\n            a1 \\<noteq> a2\\<rbrakk>\n           \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) = {}\\<rbrakk>\n       \\<Longrightarrow> keys (sum f (insert x F)) =\n                         (\\<Union>a\\<in>insert x F. keys (f a))", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  (\\<And>a1 a2.\n      \\<lbrakk>a1 \\<in> A; a2 \\<in> A; a1 \\<noteq> a2\\<rbrakk>\n      \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                        {}) \\<Longrightarrow>\n  keys (sum f A) = (\\<Union>a\\<in>A. keys (f a))\n  \\<lbrakk>?a1.0 \\<in> insert a A; ?a2.0 \\<in> insert a A;\n   ?a1.0 \\<noteq> ?a2.0\\<rbrakk>\n  \\<Longrightarrow> keys (f ?a1.0) \\<inter> keys (f ?a2.0) = {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a1 a2.\n            \\<lbrakk>a1 \\<in> F; a2 \\<in> F; a1 \\<noteq> a2\\<rbrakk>\n            \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                              {}) \\<Longrightarrow>\n        keys (sum f F) = (\\<Union>a\\<in>F. keys (f a));\n        \\<And>a1 a2.\n           \\<lbrakk>a1 \\<in> insert x F; a2 \\<in> insert x F;\n            a1 \\<noteq> a2\\<rbrakk>\n           \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) = {}\\<rbrakk>\n       \\<Longrightarrow> keys (sum f (insert x F)) =\n                         (\\<Union>a\\<in>insert x F. keys (f a))", "have IH: \"keys (sum f A) = (\\<Union>i\\<in>A. keys (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (sum f A) = (\\<Union>i\\<in>A. keys (f i))", "by (rule insert(3), rule insert.prems, simp_all)"], ["proof (state)\nthis:\n  keys (sum f A) = (\\<Union>i\\<in>A. keys (f i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a1 a2.\n            \\<lbrakk>a1 \\<in> F; a2 \\<in> F; a1 \\<noteq> a2\\<rbrakk>\n            \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                              {}) \\<Longrightarrow>\n        keys (sum f F) = (\\<Union>a\\<in>F. keys (f a));\n        \\<And>a1 a2.\n           \\<lbrakk>a1 \\<in> insert x F; a2 \\<in> insert x F;\n            a1 \\<noteq> a2\\<rbrakk>\n           \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) = {}\\<rbrakk>\n       \\<Longrightarrow> keys (sum f (insert x F)) =\n                         (\\<Union>a\\<in>insert x F. keys (f a))", "have \"keys (sum f (insert a A)) = keys (f a) \\<union> keys (sum f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (sum f (insert a A)) = keys (f a) \\<union> keys (sum f A)", "proof (simp only: comm_monoid_add_class.sum.insert[OF insert(1) insert(2)], rule keys_add[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. keys (f a) \\<inter> keys (sum f A) = {}", "have \"keys (f a) \\<inter> keys (sum f A) = (\\<Union>i\\<in>A. keys (f a) \\<inter> keys (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (f a) \\<inter> keys (sum f A) =\n    (\\<Union>i\\<in>A. keys (f a) \\<inter> keys (f i))", "by (simp only: IH Int_UN_distrib)"], ["proof (state)\nthis:\n  keys (f a) \\<inter> keys (sum f A) =\n  (\\<Union>i\\<in>A. keys (f a) \\<inter> keys (f i))\n\ngoal (1 subgoal):\n 1. keys (f a) \\<inter> keys (sum f A) = {}", "also"], ["proof (state)\nthis:\n  keys (f a) \\<inter> keys (sum f A) =\n  (\\<Union>i\\<in>A. keys (f a) \\<inter> keys (f i))\n\ngoal (1 subgoal):\n 1. keys (f a) \\<inter> keys (sum f A) = {}", "have \"... = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>A. keys (f a) \\<inter> keys (f i)) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>A. keys (f a) \\<inter> keys (f i)) = {}", "have \"i \\<in> A \\<Longrightarrow> keys (f a) \\<inter> keys (f i) = {}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow> keys (f a) \\<inter> keys (f i) = {}", "proof (rule insert.prems)"], ["proof (state)\ngoal (3 subgoals):\n 1. i \\<in> A \\<Longrightarrow> a \\<in> insert a A\n 2. i \\<in> A \\<Longrightarrow> i \\<in> insert a A\n 3. i \\<in> A \\<Longrightarrow> a \\<noteq> i", "assume \"i \\<in> A\""], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (3 subgoals):\n 1. i \\<in> A \\<Longrightarrow> a \\<in> insert a A\n 2. i \\<in> A \\<Longrightarrow> i \\<in> insert a A\n 3. i \\<in> A \\<Longrightarrow> a \\<noteq> i", "with insert(2)"], ["proof (chain)\npicking this:\n  a \\<notin> A\n  i \\<in> A", "show \"a \\<noteq> i\""], ["proof (prove)\nusing this:\n  a \\<notin> A\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. a \\<noteq> i", "by blast"], ["proof (state)\nthis:\n  a \\<noteq> i\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow> a \\<in> insert a A\n 2. i \\<in> A \\<Longrightarrow> i \\<in> insert a A", "qed simp_all"], ["proof (state)\nthis:\n  ?i \\<in> A \\<Longrightarrow> keys (f a) \\<inter> keys (f ?i) = {}\n\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>A. keys (f a) \\<inter> keys (f i)) = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?i \\<in> A \\<Longrightarrow> keys (f a) \\<inter> keys (f ?i) = {}\n\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>A. keys (f a) \\<inter> keys (f i)) = {}", "by simp"], ["proof (state)\nthis:\n  (\\<Union>i\\<in>A. keys (f a) \\<inter> keys (f i)) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>i\\<in>A. keys (f a) \\<inter> keys (f i)) = {}\n\ngoal (1 subgoal):\n 1. keys (f a) \\<inter> keys (sum f A) = {}", "finally"], ["proof (chain)\npicking this:\n  keys (f a) \\<inter> keys (sum f A) = {}", "show \"keys (f a) \\<inter> keys (sum f A) = {}\""], ["proof (prove)\nusing this:\n  keys (f a) \\<inter> keys (sum f A) = {}\n\ngoal (1 subgoal):\n 1. keys (f a) \\<inter> keys (sum f A) = {}", "."], ["proof (state)\nthis:\n  keys (f a) \\<inter> keys (sum f A) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (sum f (insert a A)) = keys (f a) \\<union> keys (sum f A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a1 a2.\n            \\<lbrakk>a1 \\<in> F; a2 \\<in> F; a1 \\<noteq> a2\\<rbrakk>\n            \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                              {}) \\<Longrightarrow>\n        keys (sum f F) = (\\<Union>a\\<in>F. keys (f a));\n        \\<And>a1 a2.\n           \\<lbrakk>a1 \\<in> insert x F; a2 \\<in> insert x F;\n            a1 \\<noteq> a2\\<rbrakk>\n           \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) = {}\\<rbrakk>\n       \\<Longrightarrow> keys (sum f (insert x F)) =\n                         (\\<Union>a\\<in>insert x F. keys (f a))", "also"], ["proof (state)\nthis:\n  keys (sum f (insert a A)) = keys (f a) \\<union> keys (sum f A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a1 a2.\n            \\<lbrakk>a1 \\<in> F; a2 \\<in> F; a1 \\<noteq> a2\\<rbrakk>\n            \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                              {}) \\<Longrightarrow>\n        keys (sum f F) = (\\<Union>a\\<in>F. keys (f a));\n        \\<And>a1 a2.\n           \\<lbrakk>a1 \\<in> insert x F; a2 \\<in> insert x F;\n            a1 \\<noteq> a2\\<rbrakk>\n           \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) = {}\\<rbrakk>\n       \\<Longrightarrow> keys (sum f (insert x F)) =\n                         (\\<Union>a\\<in>insert x F. keys (f a))", "have \"... = (\\<Union>a\\<in>insert a A. keys (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (f a) \\<union> keys (sum f A) =\n    (\\<Union>a\\<in>insert a A. keys (f a))", "by (simp add: IH)"], ["proof (state)\nthis:\n  keys (f a) \\<union> keys (sum f A) =\n  (\\<Union>a\\<in>insert a A. keys (f a))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a1 a2.\n            \\<lbrakk>a1 \\<in> F; a2 \\<in> F; a1 \\<noteq> a2\\<rbrakk>\n            \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) =\n                              {}) \\<Longrightarrow>\n        keys (sum f F) = (\\<Union>a\\<in>F. keys (f a));\n        \\<And>a1 a2.\n           \\<lbrakk>a1 \\<in> insert x F; a2 \\<in> insert x F;\n            a1 \\<noteq> a2\\<rbrakk>\n           \\<Longrightarrow> keys (f a1) \\<inter> keys (f a2) = {}\\<rbrakk>\n       \\<Longrightarrow> keys (sum f (insert x F)) =\n                         (\\<Union>a\\<in>insert x F. keys (f a))", "finally"], ["proof (chain)\npicking this:\n  keys (sum f (insert a A)) = (\\<Union>a\\<in>insert a A. keys (f a))", "show ?case"], ["proof (prove)\nusing this:\n  keys (sum f (insert a A)) = (\\<Union>a\\<in>insert a A. keys (f a))\n\ngoal (1 subgoal):\n 1. keys (sum f (insert a A)) = (\\<Union>a\\<in>insert a A. keys (f a))", "."], ["proof (state)\nthis:\n  keys (sum f (insert a A)) = (\\<Union>a\\<in>insert a A. keys (f a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_mapping_sum_monomials: \"(\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p", "proof (induct p rule: poly_mapping_plus_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>a\\<in>keys 0. monomial (lookup 0 a) a) = 0\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        (\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a\\<in>keys (monomial c t + p).\n                            monomial (lookup (monomial c t + p) a) a) =\n                         monomial c t + p", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<Sum>a\\<in>keys 0. monomial (lookup 0 a) a) = 0\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        (\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a\\<in>keys (monomial c t + p).\n                            monomial (lookup (monomial c t + p) a) a) =\n                         monomial c t + p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>keys 0. monomial (lookup 0 a) a) = 0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>keys 0. monomial (lookup 0 a) a) = 0\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        (\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a\\<in>keys (monomial c t + p).\n                            monomial (lookup (monomial c t + p) a) a) =\n                         monomial c t + p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        (\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a\\<in>keys (monomial c t + p).\n                            monomial (lookup (monomial c t + p) a) a) =\n                         monomial c t + p", "case step: (2 p c t)"], ["proof (state)\nthis:\n  c \\<noteq> (0::'b)\n  t \\<notin> keys p\n  (\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        (\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a\\<in>keys (monomial c t + p).\n                            monomial (lookup (monomial c t + p) a) a) =\n                         monomial c t + p", "from step(2)"], ["proof (chain)\npicking this:\n  t \\<notin> keys p", "have \"lookup p t = 0\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. lookup p t = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup p t = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        (\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a\\<in>keys (monomial c t + p).\n                            monomial (lookup (monomial c t + p) a) a) =\n                         monomial c t + p", "have *: \"keys (monomial c t + p) = insert t (keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = insert t (keys p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = insert t (keys p)", "from step(1)"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'b)", "have a: \"keys (monomial c t) = {t}\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. keys (monomial c t) = {t}", "by simp"], ["proof (state)\nthis:\n  keys (monomial c t) = {t}\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = insert t (keys p)", "with step(2)"], ["proof (chain)\npicking this:\n  t \\<notin> keys p\n  keys (monomial c t) = {t}", "have \"keys (monomial c t) \\<inter> keys p = {}\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n  keys (monomial c t) = {t}\n\ngoal (1 subgoal):\n 1. keys (monomial c t) \\<inter> keys p = {}", "by simp"], ["proof (state)\nthis:\n  keys (monomial c t) \\<inter> keys p = {}\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = insert t (keys p)", "hence \"keys (monomial c t + p) = {t} \\<union> keys p\""], ["proof (prove)\nusing this:\n  keys (monomial c t) \\<inter> keys p = {}\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = {t} \\<union> keys p", "by (simp only: a keys_plus_eqI)"], ["proof (state)\nthis:\n  keys (monomial c t + p) = {t} \\<union> keys p\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = insert t (keys p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  keys (monomial c t + p) = {t} \\<union> keys p\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) = insert t (keys p)", "by simp"], ["proof (state)\nthis:\n  keys (monomial c t + p) = insert t (keys p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (monomial c t + p) = insert t (keys p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        (\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a\\<in>keys (monomial c t + p).\n                            monomial (lookup (monomial c t + p) a) a) =\n                         monomial c t + p", "have **: \"(\\<Sum>ta\\<in>keys p. monomial ((c when t = ta) + lookup p ta) ta) = (\\<Sum>ta\\<in>keys p. monomial (lookup p ta) ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ta\\<in>keys p. monomial ((c when t = ta) + lookup p ta) ta) =\n    (\\<Sum>ta\\<in>keys p. monomial (lookup p ta) ta)", "proof (rule comm_monoid_add_class.sum.cong, rule refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial ((c when t = x) + lookup p x) x = monomial (lookup p x) x", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial ((c when t = x) + lookup p x) x = monomial (lookup p x) x", "assume \"s \\<in> keys p\""], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial ((c when t = x) + lookup p x) x = monomial (lookup p x) x", "with step(2)"], ["proof (chain)\npicking this:\n  t \\<notin> keys p\n  s \\<in> keys p", "have \"t \\<noteq> s\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. t \\<noteq> s", "by auto"], ["proof (state)\nthis:\n  t \\<noteq> s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys p \\<Longrightarrow>\n       monomial ((c when t = x) + lookup p x) x = monomial (lookup p x) x", "thus \"monomial ((c when t = s) + lookup p s) s = monomial (lookup p s) s\""], ["proof (prove)\nusing this:\n  t \\<noteq> s\n\ngoal (1 subgoal):\n 1. monomial ((c when t = s) + lookup p s) s = monomial (lookup p s) s", "by simp"], ["proof (state)\nthis:\n  monomial ((c when t = s) + lookup p s) s = monomial (lookup p s) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>ta\\<in>keys p. monomial ((c when t = ta) + lookup p ta) ta) =\n  (\\<Sum>ta\\<in>keys p. monomial (lookup p ta) ta)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'b); t \\<notin> keys p;\n        (\\<Sum>a\\<in>keys p. monomial (lookup p a) a) = p\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a\\<in>keys (monomial c t + p).\n                            monomial (lookup (monomial c t + p) a) a) =\n                         monomial c t + p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>keys (monomial c t + p).\n       monomial (lookup (monomial c t + p) a) a) =\n    monomial c t + p", "by (simp only: * comm_monoid_add_class.sum.insert[OF finite_keys step(2)],\n                   simp add: lookup_add lookup_single \\<open>lookup p t = 0\\<close> ** step(3))"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>keys (monomial c t + p).\n     monomial (lookup (monomial c t + p) a) a) =\n  monomial c t + p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_sum: \"monomial (sum f C) a = (\\<Sum>c\\<in>C. monomial (f c) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (sum f C) a = (\\<Sum>c\\<in>C. monomial (f c) a)", "by (rule fun_sum_commute, simp_all add: single_add)"], ["", "lemma monomial_Sum_any:\n  assumes \"finite {c. f c \\<noteq> 0}\"\n  shows \"monomial (Sum_any f) a = (\\<Sum>c. monomial (f c) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (Sum_any f) a = (\\<Sum>c. monomial (f c) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial (Sum_any f) a = (\\<Sum>c. monomial (f c) a)", "have \"{c. monomial (f c) a \\<noteq> 0} \\<subseteq> {c. f c \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {c. monomial (f c) a \\<noteq> 0} \\<subseteq> {c. f c \\<noteq> (0::'b)}", "by (rule, auto)"], ["proof (state)\nthis:\n  {c. monomial (f c) a \\<noteq> 0} \\<subseteq> {c. f c \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. monomial (Sum_any f) a = (\\<Sum>c. monomial (f c) a)", "with assms"], ["proof (chain)\npicking this:\n  finite {c. f c \\<noteq> (0::'b)}\n  {c. monomial (f c) a \\<noteq> 0} \\<subseteq> {c. f c \\<noteq> (0::'b)}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {c. f c \\<noteq> (0::'b)}\n  {c. monomial (f c) a \\<noteq> 0} \\<subseteq> {c. f c \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. monomial (Sum_any f) a = (\\<Sum>c. monomial (f c) a)", "by (simp add: Groups_Big_Fun.comm_monoid_add_class.Sum_any.expand_superset monomial_sum)"], ["proof (state)\nthis:\n  monomial (Sum_any f) a = (\\<Sum>c. monomial (f c) a)\n\ngoal:\nNo subgoals!", "qed"], ["", "context term_powerprod\nbegin"], ["", "lemma proj_sum: \"proj_poly k (sum f A) = (\\<Sum>a\\<in>A. proj_poly k (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (sum f A) = (\\<Sum>a\\<in>A. proj_poly k (f a))", "using proj_zero proj_plus"], ["proof (prove)\nusing this:\n  proj_poly ?k 0 = 0\n  proj_poly ?k (?p + ?q) = proj_poly ?k ?p + proj_poly ?k ?q\n\ngoal (1 subgoal):\n 1. proj_poly k (sum f A) = (\\<Sum>a\\<in>A. proj_poly k (f a))", "by (rule fun_sum_commute)"], ["", "lemma proj_sum_list: \"proj_poly k (sum_list xs) = sum_list (map (proj_poly k) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (sum_list xs) = sum_list (map (proj_poly k) xs)", "using proj_zero proj_plus"], ["proof (prove)\nusing this:\n  proj_poly ?k 0 = 0\n  proj_poly ?k (?p + ?q) = proj_poly ?k ?p + proj_poly ?k ?q\n\ngoal (1 subgoal):\n 1. proj_poly k (sum_list xs) = sum_list (map (proj_poly k) xs)", "by (rule fun_sum_list_commute)"], ["", "lemma mult_scalar_sum_monomials: \"q \\<odot> p = (\\<Sum>t\\<in>keys q. monom_mult (lookup q t) t p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<odot> p = (\\<Sum>t\\<in>keys q. monom_mult (lookup q t) t p)", "by (rule poly_mapping_eqI_proj, simp add: proj_sum mult_scalar_monomial[symmetric]\n      sum_distrib_right[symmetric] poly_mapping_sum_monomials term_simps)"], ["", "lemma fun_mult_scalar_commute:\n  assumes \"f 0 = 0\" and \"\\<And>x y. f (x + y) = f x + f y\"\n    and \"\\<And>c t. f (monom_mult c t p) = monom_mult c t (f p)\"\n  shows \"f (q \\<odot> p) = q \\<odot> (f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (q \\<odot> p) = q \\<odot> f p", "by (simp add: mult_scalar_sum_monomials assms(3)[symmetric], rule fun_sum_commute, fact+)"], ["", "lemma fun_mult_scalar_commute_canc:\n  assumes \"\\<And>x y. f (x + y) = f x + f y\" and \"\\<And>c t. f (monom_mult c t p) = monom_mult c t (f p)\"\n  shows \"f (q \\<odot> p) = q \\<odot> (f (p::'t \\<Rightarrow>\\<^sub>0 'b::{semiring_0,cancel_comm_monoid_add}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (q \\<odot> p) = q \\<odot> f p", "by (simp add: mult_scalar_sum_monomials assms(2)[symmetric], rule fun_sum_commute_canc, fact)"], ["", "lemma monom_mult_sum_left: \"monom_mult (sum f C) t p = (\\<Sum>c\\<in>C. monom_mult (f c) t p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (sum f C) t p = (\\<Sum>c\\<in>C. monom_mult (f c) t p)", "by (rule fun_sum_commute, simp_all add: monom_mult_dist_left)"], ["", "lemma monom_mult_sum_right: \"monom_mult c t (sum f P) = (\\<Sum>p\\<in>P. monom_mult c t (f p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t (sum f P) = (\\<Sum>p\\<in>P. monom_mult c t (f p))", "by (rule fun_sum_commute, simp_all add: monom_mult_dist_right)"], ["", "lemma monom_mult_Sum_any_left:\n  assumes \"finite {c. f c \\<noteq> 0}\"\n  shows \"monom_mult (Sum_any f) t p = (\\<Sum>c. monom_mult (f c) t p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (Sum_any f) t p = (\\<Sum>c. monom_mult (f c) t p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monom_mult (Sum_any f) t p = (\\<Sum>c. monom_mult (f c) t p)", "have \"{c. monom_mult (f c) t p \\<noteq> 0} \\<subseteq> {c. f c \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {c. monom_mult (f c) t p \\<noteq> 0}\n    \\<subseteq> {c. f c \\<noteq> (0::'c)}", "by (rule, auto)"], ["proof (state)\nthis:\n  {c. monom_mult (f c) t p \\<noteq> 0} \\<subseteq> {c. f c \\<noteq> (0::'c)}\n\ngoal (1 subgoal):\n 1. monom_mult (Sum_any f) t p = (\\<Sum>c. monom_mult (f c) t p)", "with assms"], ["proof (chain)\npicking this:\n  finite {c. f c \\<noteq> (0::'c)}\n  {c. monom_mult (f c) t p \\<noteq> 0} \\<subseteq> {c. f c \\<noteq> (0::'c)}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {c. f c \\<noteq> (0::'c)}\n  {c. monom_mult (f c) t p \\<noteq> 0} \\<subseteq> {c. f c \\<noteq> (0::'c)}\n\ngoal (1 subgoal):\n 1. monom_mult (Sum_any f) t p = (\\<Sum>c. monom_mult (f c) t p)", "by (simp add: Groups_Big_Fun.comm_monoid_add_class.Sum_any.expand_superset monom_mult_sum_left)"], ["proof (state)\nthis:\n  monom_mult (Sum_any f) t p = (\\<Sum>c. monom_mult (f c) t p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monom_mult_Sum_any_right:\n  assumes \"finite {p. f p \\<noteq> 0}\"\n  shows \"monom_mult c t (Sum_any f) = (\\<Sum>p. monom_mult c t (f p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t (Sum_any f) = (\\<Sum>p. monom_mult c t (f p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monom_mult c t (Sum_any f) = (\\<Sum>p. monom_mult c t (f p))", "have \"{p. monom_mult c t (f p) \\<noteq> 0} \\<subseteq> {p. f p \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. monom_mult c t (f p) \\<noteq> 0} \\<subseteq> {p. f p \\<noteq> 0}", "by (rule, auto)"], ["proof (state)\nthis:\n  {p. monom_mult c t (f p) \\<noteq> 0} \\<subseteq> {p. f p \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. monom_mult c t (Sum_any f) = (\\<Sum>p. monom_mult c t (f p))", "with assms"], ["proof (chain)\npicking this:\n  finite {p. f p \\<noteq> 0}\n  {p. monom_mult c t (f p) \\<noteq> 0} \\<subseteq> {p. f p \\<noteq> 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {p. f p \\<noteq> 0}\n  {p. monom_mult c t (f p) \\<noteq> 0} \\<subseteq> {p. f p \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. monom_mult c t (Sum_any f) = (\\<Sum>p. monom_mult c t (f p))", "by (simp add: Groups_Big_Fun.comm_monoid_add_class.Sum_any.expand_superset monom_mult_sum_right)"], ["proof (state)\nthis:\n  monom_mult c t (Sum_any f) = (\\<Sum>p. monom_mult c t (f p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_prod_sum: \"monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))", "proof (cases \"finite I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite I \\<Longrightarrow>\n    monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))\n 2. infinite I \\<Longrightarrow>\n    monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))", "case True"], ["proof (state)\nthis:\n  finite I\n\ngoal (2 subgoals):\n 1. finite I \\<Longrightarrow>\n    monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))\n 2. infinite I \\<Longrightarrow>\n    monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite I\n\ngoal (1 subgoal):\n 1. monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))", "proof (induct I)"], ["proof (state)\ngoal (2 subgoals):\n 1. monomial (prod c {}) (sum a {}) =\n    (\\<Prod>i\\<in>{}. monomial (c i) (a i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        monomial (prod c F) (sum a F) =\n        (\\<Prod>i\\<in>F. monomial (c i) (a i))\\<rbrakk>\n       \\<Longrightarrow> monomial (prod c (insert x F))\n                          (sum a (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. monomial (c i) (a i))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. monomial (prod c {}) (sum a {}) =\n    (\\<Prod>i\\<in>{}. monomial (c i) (a i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        monomial (prod c F) (sum a F) =\n        (\\<Prod>i\\<in>F. monomial (c i) (a i))\\<rbrakk>\n       \\<Longrightarrow> monomial (prod c (insert x F))\n                          (sum a (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. monomial (c i) (a i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (prod c {}) (sum a {}) =\n    (\\<Prod>i\\<in>{}. monomial (c i) (a i))", "by simp"], ["proof (state)\nthis:\n  monomial (prod c {}) (sum a {}) = (\\<Prod>i\\<in>{}. monomial (c i) (a i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        monomial (prod c F) (sum a F) =\n        (\\<Prod>i\\<in>F. monomial (c i) (a i))\\<rbrakk>\n       \\<Longrightarrow> monomial (prod c (insert x F))\n                          (sum a (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. monomial (c i) (a i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        monomial (prod c F) (sum a F) =\n        (\\<Prod>i\\<in>F. monomial (c i) (a i))\\<rbrakk>\n       \\<Longrightarrow> monomial (prod c (insert x F))\n                          (sum a (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. monomial (c i) (a i))", "case (insert i I)"], ["proof (state)\nthis:\n  finite I\n  i \\<notin> I\n  monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        monomial (prod c F) (sum a F) =\n        (\\<Prod>i\\<in>F. monomial (c i) (a i))\\<rbrakk>\n       \\<Longrightarrow> monomial (prod c (insert x F))\n                          (sum a (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. monomial (c i) (a i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (prod c (insert i I)) (sum a (insert i I)) =\n    (\\<Prod>i\\<in>insert i I. monomial (c i) (a i))", "by (simp only: comm_monoid_add_class.sum.insert[OF insert(1) insert(2)]\n         comm_monoid_mult_class.prod.insert[OF insert(1) insert(2)] insert(3) mult_single[symmetric])"], ["proof (state)\nthis:\n  monomial (prod c (insert i I)) (sum a (insert i I)) =\n  (\\<Prod>i\\<in>insert i I. monomial (c i) (a i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))\n\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))", "case False"], ["proof (state)\nthis:\n  infinite I\n\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite I\n\ngoal (1 subgoal):\n 1. monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))", "by simp"], ["proof (state)\nthis:\n  monomial (prod c I) (sum a I) = (\\<Prod>i\\<in>I. monomial (c i) (a i))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Submodules\\<close>"], ["", "sublocale pmdl: module mult_scalar"], ["proof (prove)\ngoal (1 subgoal):\n 1. module (\\<odot>)", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a x y. a \\<odot> (x + y) = a \\<odot> x + a \\<odot> y\n 2. \\<And>a b x. (a + b) \\<odot> x = a \\<odot> x + b \\<odot> x\n 3. \\<And>a b x. a \\<odot> (b \\<odot> x) = (a * b) \\<odot> x\n 4. \\<And>x. 1 \\<odot> x = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<odot> (x_ + y_) = a_ \\<odot> x_ + a_ \\<odot> y_", "by (rule poly_mapping_eqI_proj, simp add: algebra_simps proj_plus)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x. (a + b) \\<odot> x = a \\<odot> x + b \\<odot> x\n 2. \\<And>a b x. a \\<odot> (b \\<odot> x) = (a * b) \\<odot> x\n 3. \\<And>x. 1 \\<odot> x = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a_ + b_) \\<odot> x_ = a_ \\<odot> x_ + b_ \\<odot> x_", "by (rule poly_mapping_eqI_proj, simp add: algebra_simps proj_plus)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x. a \\<odot> (b \\<odot> x) = (a * b) \\<odot> x\n 2. \\<And>x. 1 \\<odot> x = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<odot> (b_ \\<odot> x_) = (a_ * b_) \\<odot> x_", "by (rule poly_mapping_eqI_proj, simp add: ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 1 \\<odot> x = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<odot> x_ = x_", "by (rule poly_mapping_eqI_proj, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [simp del] = pmdl.scale_one pmdl.scale_zero_left pmdl.scale_zero_right pmdl.scale_scale\n  pmdl.scale_minus_left pmdl.scale_minus_right pmdl.span_eq_iff"], ["", "lemmas [algebra_simps del] = pmdl.scale_left_distrib pmdl.scale_right_distrib\n  pmdl.scale_left_diff_distrib pmdl.scale_right_diff_distrib"], ["", "abbreviation \"pmdl \\<equiv> pmdl.span\""], ["", "lemma pmdl_closed_monom_mult:\n  assumes \"p \\<in> pmdl B\"\n  shows \"monom_mult c t p \\<in> pmdl B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t p \\<in> pmdl B", "unfolding mult_scalar_monomial[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c t \\<odot> p \\<in> pmdl B", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. monomial c t \\<odot> p \\<in> pmdl B", "by (rule pmdl.span_scale)"], ["", "lemma monom_mult_in_pmdl: \"b \\<in> B \\<Longrightarrow> monom_mult c t b \\<in> pmdl B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> B \\<Longrightarrow> monom_mult c t b \\<in> pmdl B", "by (intro pmdl_closed_monom_mult pmdl.span_base)"], ["", "lemma pmdl_induct [consumes 1, case_names module_0 module_plus]:\n  assumes \"p \\<in> pmdl B\" and \"P 0\"\n    and \"\\<And>a p c t. a \\<in> pmdl B \\<Longrightarrow> P a \\<Longrightarrow> p \\<in> B \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> P (a + monom_mult c t p)\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "using assms(1)"], ["proof (prove)\nusing this:\n  p \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. P p", "proof (induct p rule: pmdl.span_induct')"], ["proof (state)\ngoal (2 subgoals):\n 1. P 0\n 2. \\<And>a q p.\n       \\<lbrakk>a \\<in> pmdl B; P a; p \\<in> B; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> P (a + q \\<odot> p)", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. P 0\n 2. \\<And>a q p.\n       \\<lbrakk>a \\<in> pmdl B; P a; p \\<in> B; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> P (a + q \\<odot> p)", "from assms(2)"], ["proof (chain)\npicking this:\n  P 0", "show ?case"], ["proof (prove)\nusing this:\n  P 0\n\ngoal (1 subgoal):\n 1. P 0", "."], ["proof (state)\nthis:\n  P 0\n\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> pmdl B; P a; p \\<in> B; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> P (a + q \\<odot> p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> pmdl B; P a; p \\<in> B; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> P (a + q \\<odot> p)", "case (step a q b)"], ["proof (state)\nthis:\n  a \\<in> pmdl B\n  P a\n  b \\<in> B\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> pmdl B; P a; p \\<in> B; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> P (a + q \\<odot> p)", "from this(1) this(2)"], ["proof (chain)\npicking this:\n  a \\<in> pmdl B\n  P a", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> pmdl B\n  P a\n\ngoal (1 subgoal):\n 1. P (a + q \\<odot> b)", "proof (induct q arbitrary: a rule: poly_mapping_except_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> pmdl B; P a\\<rbrakk>\n       \\<Longrightarrow> P (a + 0 \\<odot> b)\n 2. \\<And>p t a.\n       \\<lbrakk>p \\<noteq> 0; t \\<in> keys p;\n        \\<And>a.\n           \\<lbrakk>a \\<in> pmdl B; P a\\<rbrakk>\n           \\<Longrightarrow> P (a + except p {t} \\<odot> b);\n        a \\<in> pmdl B; P a\\<rbrakk>\n       \\<Longrightarrow> P (a + p \\<odot> b)", "case 1"], ["proof (state)\nthis:\n  a \\<in> pmdl B\n  P a\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> pmdl B; P a\\<rbrakk>\n       \\<Longrightarrow> P (a + 0 \\<odot> b)\n 2. \\<And>p t a.\n       \\<lbrakk>p \\<noteq> 0; t \\<in> keys p;\n        \\<And>a.\n           \\<lbrakk>a \\<in> pmdl B; P a\\<rbrakk>\n           \\<Longrightarrow> P (a + except p {t} \\<odot> b);\n        a \\<in> pmdl B; P a\\<rbrakk>\n       \\<Longrightarrow> P (a + p \\<odot> b)", "thus ?case"], ["proof (prove)\nusing this:\n  a \\<in> pmdl B\n  P a\n\ngoal (1 subgoal):\n 1. P (a + 0 \\<odot> b)", "by simp"], ["proof (state)\nthis:\n  P (a + 0 \\<odot> b)\n\ngoal (1 subgoal):\n 1. \\<And>p t a.\n       \\<lbrakk>p \\<noteq> 0; t \\<in> keys p;\n        \\<And>a.\n           \\<lbrakk>a \\<in> pmdl B; P a\\<rbrakk>\n           \\<Longrightarrow> P (a + except p {t} \\<odot> b);\n        a \\<in> pmdl B; P a\\<rbrakk>\n       \\<Longrightarrow> P (a + p \\<odot> b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p t a.\n       \\<lbrakk>p \\<noteq> 0; t \\<in> keys p;\n        \\<And>a.\n           \\<lbrakk>a \\<in> pmdl B; P a\\<rbrakk>\n           \\<Longrightarrow> P (a + except p {t} \\<odot> b);\n        a \\<in> pmdl B; P a\\<rbrakk>\n       \\<Longrightarrow> P (a + p \\<odot> b)", "case step: (2 q0 t)"], ["proof (state)\nthis:\n  q0 \\<noteq> 0\n  t \\<in> keys q0\n  \\<lbrakk>?a9 \\<in> pmdl B; P ?a9\\<rbrakk>\n  \\<Longrightarrow> P (?a9 + except q0 {t} \\<odot> b)\n  a \\<in> pmdl B\n  P a\n\ngoal (1 subgoal):\n 1. \\<And>p t a.\n       \\<lbrakk>p \\<noteq> 0; t \\<in> keys p;\n        \\<And>a.\n           \\<lbrakk>a \\<in> pmdl B; P a\\<rbrakk>\n           \\<Longrightarrow> P (a + except p {t} \\<odot> b);\n        a \\<in> pmdl B; P a\\<rbrakk>\n       \\<Longrightarrow> P (a + p \\<odot> b)", "from this(4) step(5) \\<open>b \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> pmdl B\n  P a\n  b \\<in> B", "have \"P (a + monomial (lookup q0 t) t \\<odot> b)\""], ["proof (prove)\nusing this:\n  a \\<in> pmdl B\n  P a\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. P (a + monomial (lookup q0 t) t \\<odot> b)", "unfolding mult_scalar_monomial"], ["proof (prove)\nusing this:\n  a \\<in> pmdl B\n  P a\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. P (a + monom_mult (lookup q0 t) t b)", "proof (rule assms(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup q0 t \\<noteq> (0::'b)", "from step(2)"], ["proof (chain)\npicking this:\n  t \\<in> keys q0", "show \"lookup q0 t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys q0\n\ngoal (1 subgoal):\n 1. lookup q0 t \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup q0 t \\<noteq> (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (a + monomial (lookup q0 t) t \\<odot> b)\n\ngoal (1 subgoal):\n 1. \\<And>p t a.\n       \\<lbrakk>p \\<noteq> 0; t \\<in> keys p;\n        \\<And>a.\n           \\<lbrakk>a \\<in> pmdl B; P a\\<rbrakk>\n           \\<Longrightarrow> P (a + except p {t} \\<odot> b);\n        a \\<in> pmdl B; P a\\<rbrakk>\n       \\<Longrightarrow> P (a + p \\<odot> b)", "with _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  P (a + monomial (lookup q0 t) t \\<odot> b)", "have \"P ((a + monomial (lookup q0 t) t \\<odot> b) + except q0 {t} \\<odot> b)\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  P (a + monomial (lookup q0 t) t \\<odot> b)\n\ngoal (1 subgoal):\n 1. P (a + monomial (lookup q0 t) t \\<odot> b + except q0 {t} \\<odot> b)", "proof (rule step(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. a + monomial (lookup q0 t) t \\<odot> b \\<in> pmdl B", "from \\<open>b \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  b \\<in> B", "have \"b \\<in> pmdl B\""], ["proof (prove)\nusing this:\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. b \\<in> pmdl B", "by (rule pmdl.span_base)"], ["proof (state)\nthis:\n  b \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. a + monomial (lookup q0 t) t \\<odot> b \\<in> pmdl B", "hence \"monomial (lookup q0 t) t \\<odot> b \\<in> pmdl B\""], ["proof (prove)\nusing this:\n  b \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. monomial (lookup q0 t) t \\<odot> b \\<in> pmdl B", "by (rule pmdl.span_scale)"], ["proof (state)\nthis:\n  monomial (lookup q0 t) t \\<odot> b \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. a + monomial (lookup q0 t) t \\<odot> b \\<in> pmdl B", "with step(4)"], ["proof (chain)\npicking this:\n  a \\<in> pmdl B\n  monomial (lookup q0 t) t \\<odot> b \\<in> pmdl B", "show \"a + monomial (lookup q0 t) t \\<odot> b \\<in> pmdl B\""], ["proof (prove)\nusing this:\n  a \\<in> pmdl B\n  monomial (lookup q0 t) t \\<odot> b \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. a + monomial (lookup q0 t) t \\<odot> b \\<in> pmdl B", "by (rule pmdl.span_add)"], ["proof (state)\nthis:\n  a + monomial (lookup q0 t) t \\<odot> b \\<in> pmdl B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (a + monomial (lookup q0 t) t \\<odot> b + except q0 {t} \\<odot> b)\n\ngoal (1 subgoal):\n 1. \\<And>p t a.\n       \\<lbrakk>p \\<noteq> 0; t \\<in> keys p;\n        \\<And>a.\n           \\<lbrakk>a \\<in> pmdl B; P a\\<rbrakk>\n           \\<Longrightarrow> P (a + except p {t} \\<odot> b);\n        a \\<in> pmdl B; P a\\<rbrakk>\n       \\<Longrightarrow> P (a + p \\<odot> b)", "hence \"P (a + (monomial (lookup q0 t) t + except q0 {t}) \\<odot> b)\""], ["proof (prove)\nusing this:\n  P (a + monomial (lookup q0 t) t \\<odot> b + except q0 {t} \\<odot> b)\n\ngoal (1 subgoal):\n 1. P (a + (monomial (lookup q0 t) t + except q0 {t}) \\<odot> b)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  P (a + (monomial (lookup q0 t) t + except q0 {t}) \\<odot> b)\n\ngoal (1 subgoal):\n 1. \\<And>p t a.\n       \\<lbrakk>p \\<noteq> 0; t \\<in> keys p;\n        \\<And>a.\n           \\<lbrakk>a \\<in> pmdl B; P a\\<rbrakk>\n           \\<Longrightarrow> P (a + except p {t} \\<odot> b);\n        a \\<in> pmdl B; P a\\<rbrakk>\n       \\<Longrightarrow> P (a + p \\<odot> b)", "thus ?case"], ["proof (prove)\nusing this:\n  P (a + (monomial (lookup q0 t) t + except q0 {t}) \\<odot> b)\n\ngoal (1 subgoal):\n 1. P (a + q0 \\<odot> b)", "by (simp only: plus_except[of q0 t, symmetric])"], ["proof (state)\nthis:\n  P (a + q0 \\<odot> b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (a + q \\<odot> b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma components_pmdl: \"component_of_term ` Keys (pmdl B) = component_of_term ` Keys B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (pmdl B) = component_of_term ` Keys B", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. component_of_term ` Keys (pmdl B) \\<subseteq> component_of_term ` Keys B\n 2. component_of_term ` Keys B \\<subseteq> component_of_term ` Keys (pmdl B)", "show \"component_of_term ` Keys (pmdl B) \\<subseteq> component_of_term ` Keys B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (pmdl B) \\<subseteq> component_of_term ` Keys B", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` Keys (pmdl B) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys B", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` Keys (pmdl B) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys B", "assume \"k \\<in> component_of_term ` Keys (pmdl B)\""], ["proof (state)\nthis:\n  k \\<in> component_of_term ` Keys (pmdl B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` Keys (pmdl B) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys B", "then"], ["proof (chain)\npicking this:\n  k \\<in> component_of_term ` Keys (pmdl B)", "obtain v where \"v \\<in> Keys (pmdl B)\" and \"k = component_of_term v\""], ["proof (prove)\nusing this:\n  k \\<in> component_of_term ` Keys (pmdl B)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> Keys (pmdl B); k = component_of_term v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> Keys (pmdl B)\n  k = component_of_term v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` Keys (pmdl B) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys B", "from this(1)"], ["proof (chain)\npicking this:\n  v \\<in> Keys (pmdl B)", "obtain b where \"b \\<in> pmdl B\" and \"v \\<in> keys b\""], ["proof (prove)\nusing this:\n  v \\<in> Keys (pmdl B)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> pmdl B; v \\<in> keys b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_KeysE)"], ["proof (state)\nthis:\n  b \\<in> pmdl B\n  v \\<in> keys b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` Keys (pmdl B) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys B", "thus \"k \\<in> component_of_term ` Keys B\""], ["proof (prove)\nusing this:\n  b \\<in> pmdl B\n  v \\<in> keys b\n\ngoal (1 subgoal):\n 1. k \\<in> component_of_term ` Keys B", "proof (induct b rule: pmdl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> keys 0 \\<Longrightarrow> k \\<in> component_of_term ` Keys B\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B;\n        v \\<in> keys a \\<Longrightarrow> k \\<in> component_of_term ` Keys B;\n        p \\<in> B; c \\<noteq> (0::'b);\n        v \\<in> keys (a + monom_mult c t p)\\<rbrakk>\n       \\<Longrightarrow> k \\<in> component_of_term ` Keys B", "case module_0"], ["proof (state)\nthis:\n  v \\<in> keys 0\n\ngoal (2 subgoals):\n 1. v \\<in> keys 0 \\<Longrightarrow> k \\<in> component_of_term ` Keys B\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B;\n        v \\<in> keys a \\<Longrightarrow> k \\<in> component_of_term ` Keys B;\n        p \\<in> B; c \\<noteq> (0::'b);\n        v \\<in> keys (a + monom_mult c t p)\\<rbrakk>\n       \\<Longrightarrow> k \\<in> component_of_term ` Keys B", "thus ?case"], ["proof (prove)\nusing this:\n  v \\<in> keys 0\n\ngoal (1 subgoal):\n 1. k \\<in> component_of_term ` Keys B", "by simp"], ["proof (state)\nthis:\n  k \\<in> component_of_term ` Keys B\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B;\n        v \\<in> keys a \\<Longrightarrow> k \\<in> component_of_term ` Keys B;\n        p \\<in> B; c \\<noteq> (0::'b);\n        v \\<in> keys (a + monom_mult c t p)\\<rbrakk>\n       \\<Longrightarrow> k \\<in> component_of_term ` Keys B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B;\n        v \\<in> keys a \\<Longrightarrow> k \\<in> component_of_term ` Keys B;\n        p \\<in> B; c \\<noteq> (0::'b);\n        v \\<in> keys (a + monom_mult c t p)\\<rbrakk>\n       \\<Longrightarrow> k \\<in> component_of_term ` Keys B", "case ind: (module_plus a p c t)"], ["proof (state)\nthis:\n  a \\<in> pmdl B\n  v \\<in> keys a \\<Longrightarrow> k \\<in> component_of_term ` Keys B\n  p \\<in> B\n  c \\<noteq> (0::'b)\n  v \\<in> keys (a + monom_mult c t p)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B;\n        v \\<in> keys a \\<Longrightarrow> k \\<in> component_of_term ` Keys B;\n        p \\<in> B; c \\<noteq> (0::'b);\n        v \\<in> keys (a + monom_mult c t p)\\<rbrakk>\n       \\<Longrightarrow> k \\<in> component_of_term ` Keys B", "from ind.prems Poly_Mapping.keys_add"], ["proof (chain)\npicking this:\n  v \\<in> keys (a + monom_mult c t p)\n  keys (?f + ?g) \\<subseteq> keys ?f \\<union> keys ?g", "have \"v \\<in> keys a \\<union> keys (monom_mult c t p)\""], ["proof (prove)\nusing this:\n  v \\<in> keys (a + monom_mult c t p)\n  keys (?f + ?g) \\<subseteq> keys ?f \\<union> keys ?g\n\ngoal (1 subgoal):\n 1. v \\<in> keys a \\<union> keys (monom_mult c t p)", ".."], ["proof (state)\nthis:\n  v \\<in> keys a \\<union> keys (monom_mult c t p)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B;\n        v \\<in> keys a \\<Longrightarrow> k \\<in> component_of_term ` Keys B;\n        p \\<in> B; c \\<noteq> (0::'b);\n        v \\<in> keys (a + monom_mult c t p)\\<rbrakk>\n       \\<Longrightarrow> k \\<in> component_of_term ` Keys B", "thus ?case"], ["proof (prove)\nusing this:\n  v \\<in> keys a \\<union> keys (monom_mult c t p)\n\ngoal (1 subgoal):\n 1. k \\<in> component_of_term ` Keys B", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> keys a \\<Longrightarrow> k \\<in> component_of_term ` Keys B\n 2. v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n    k \\<in> component_of_term ` Keys B", "assume \"v \\<in> keys a\""], ["proof (state)\nthis:\n  v \\<in> keys a\n\ngoal (2 subgoals):\n 1. v \\<in> keys a \\<Longrightarrow> k \\<in> component_of_term ` Keys B\n 2. v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n    k \\<in> component_of_term ` Keys B", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> keys a\n\ngoal (1 subgoal):\n 1. k \\<in> component_of_term ` Keys B", "by (rule ind.hyps(2))"], ["proof (state)\nthis:\n  k \\<in> component_of_term ` Keys B\n\ngoal (1 subgoal):\n 1. v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n    k \\<in> component_of_term ` Keys B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n    k \\<in> component_of_term ` Keys B", "assume \"v \\<in> keys (monom_mult c t p)\""], ["proof (state)\nthis:\n  v \\<in> keys (monom_mult c t p)\n\ngoal (1 subgoal):\n 1. v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n    k \\<in> component_of_term ` Keys B", "from this keys_monom_mult_subset"], ["proof (chain)\npicking this:\n  v \\<in> keys (monom_mult c t p)\n  keys (monom_mult ?c ?t ?p) \\<subseteq> (\\<oplus>) ?t ` keys ?p", "have \"v \\<in> (\\<oplus>) t ` keys p\""], ["proof (prove)\nusing this:\n  v \\<in> keys (monom_mult c t p)\n  keys (monom_mult ?c ?t ?p) \\<subseteq> (\\<oplus>) ?t ` keys ?p\n\ngoal (1 subgoal):\n 1. v \\<in> (\\<oplus>) t ` keys p", ".."], ["proof (state)\nthis:\n  v \\<in> (\\<oplus>) t ` keys p\n\ngoal (1 subgoal):\n 1. v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n    k \\<in> component_of_term ` Keys B", "then"], ["proof (chain)\npicking this:\n  v \\<in> (\\<oplus>) t ` keys p", "obtain u where \"u \\<in> keys p\" and \"v = t \\<oplus> u\""], ["proof (prove)\nusing this:\n  v \\<in> (\\<oplus>) t ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys p; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> keys p\n  v = t \\<oplus> u\n\ngoal (1 subgoal):\n 1. v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n    k \\<in> component_of_term ` Keys B", "have \"k = component_of_term u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = component_of_term u", "by (simp add: \\<open>k = component_of_term v\\<close> \\<open>v = t \\<oplus> u\\<close> term_simps)"], ["proof (state)\nthis:\n  k = component_of_term u\n\ngoal (1 subgoal):\n 1. v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n    k \\<in> component_of_term ` Keys B", "moreover"], ["proof (state)\nthis:\n  k = component_of_term u\n\ngoal (1 subgoal):\n 1. v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n    k \\<in> component_of_term ` Keys B", "from \\<open>u \\<in> keys p\\<close> ind.hyps(3)"], ["proof (chain)\npicking this:\n  u \\<in> keys p\n  p \\<in> B", "have \"u \\<in> Keys B\""], ["proof (prove)\nusing this:\n  u \\<in> keys p\n  p \\<in> B\n\ngoal (1 subgoal):\n 1. u \\<in> Keys B", "by (rule in_KeysI)"], ["proof (state)\nthis:\n  u \\<in> Keys B\n\ngoal (1 subgoal):\n 1. v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n    k \\<in> component_of_term ` Keys B", "ultimately"], ["proof (chain)\npicking this:\n  k = component_of_term u\n  u \\<in> Keys B", "show ?thesis"], ["proof (prove)\nusing this:\n  k = component_of_term u\n  u \\<in> Keys B\n\ngoal (1 subgoal):\n 1. k \\<in> component_of_term ` Keys B", ".."], ["proof (state)\nthis:\n  k \\<in> component_of_term ` Keys B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<in> component_of_term ` Keys B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<in> component_of_term ` Keys B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  component_of_term ` Keys (pmdl B) \\<subseteq> component_of_term ` Keys B\n\ngoal (1 subgoal):\n 1. component_of_term ` Keys B \\<subseteq> component_of_term ` Keys (pmdl B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term ` Keys B \\<subseteq> component_of_term ` Keys (pmdl B)", "show \"component_of_term ` Keys B \\<subseteq> component_of_term ` Keys (pmdl B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys B \\<subseteq> component_of_term ` Keys (pmdl B)", "by (rule image_mono, rule Keys_mono, fact pmdl.span_superset)"], ["proof (state)\nthis:\n  component_of_term ` Keys B \\<subseteq> component_of_term ` Keys (pmdl B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pmdl_idI:\n  assumes \"0 \\<in> B\" and \"\\<And>b1 b2. b1 \\<in> B \\<Longrightarrow> b2 \\<in> B \\<Longrightarrow> b1 + b2 \\<in> B\"\n    and \"\\<And>c t b. b \\<in> B \\<Longrightarrow> monom_mult c t b \\<in> B\"\n  shows \"pmdl B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl B = B", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pmdl B \\<subseteq> B\n 2. B \\<subseteq> pmdl B", "show \"pmdl B \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl B \\<subseteq> B", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl B \\<Longrightarrow> x \\<in> B", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl B \\<Longrightarrow> x \\<in> B", "assume \"p \\<in> pmdl B\""], ["proof (state)\nthis:\n  p \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl B \\<Longrightarrow> x \\<in> B", "thus \"p \\<in> B\""], ["proof (prove)\nusing this:\n  p \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. p \\<in> B", "proof (induct p rule: pmdl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> B\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B; a \\<in> B; p \\<in> B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> B", "case module_0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 \\<in> B\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B; a \\<in> B; p \\<in> B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> B", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> B", "by (fact assms(1))"], ["proof (state)\nthis:\n  0 \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B; a \\<in> B; p \\<in> B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B; a \\<in> B; p \\<in> B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> B", "case step: (module_plus a b c t)"], ["proof (state)\nthis:\n  a \\<in> pmdl B\n  a \\<in> B\n  b \\<in> B\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B; a \\<in> B; p \\<in> B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> B", "from step(2)"], ["proof (chain)\npicking this:\n  a \\<in> B", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> B\n\ngoal (1 subgoal):\n 1. a + monom_mult c t b \\<in> B", "proof (rule assms(2))"], ["proof (state)\ngoal (1 subgoal):\n 1. monom_mult c t b \\<in> B", "from step(3)"], ["proof (chain)\npicking this:\n  b \\<in> B", "show \"monom_mult c t b \\<in> B\""], ["proof (prove)\nusing this:\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. monom_mult c t b \\<in> B", "by (rule assms(3))"], ["proof (state)\nthis:\n  monom_mult c t b \\<in> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a + monom_mult c t b \\<in> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmdl B \\<subseteq> B\n\ngoal (1 subgoal):\n 1. B \\<subseteq> pmdl B", "qed (fact pmdl.span_superset)"], ["", "definition full_pmdl :: \"'k set \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::zero) set\"\n  where \"full_pmdl K = {p. component_of_term ` keys p \\<subseteq> K}\""], ["", "definition is_full_pmdl :: \"('t \\<Rightarrow>\\<^sub>0 'b::comm_ring_1) set \\<Rightarrow> bool\"\n  where \"is_full_pmdl B \\<longleftrightarrow> (\\<forall>p. component_of_term ` keys p \\<subseteq> component_of_term ` Keys B \\<longrightarrow> p \\<in> pmdl B)\""], ["", "lemma full_pmdl_iff: \"p \\<in> full_pmdl K \\<longleftrightarrow> component_of_term ` keys p \\<subseteq> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<in> full_pmdl K) = (component_of_term ` keys p \\<subseteq> K)", "by (simp add: full_pmdl_def)"], ["", "lemma full_pmdlI:\n  assumes \"\\<And>v. v \\<in> keys p \\<Longrightarrow> component_of_term v \\<in> K\"\n  shows \"p \\<in> full_pmdl K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> full_pmdl K", "using assms"], ["proof (prove)\nusing this:\n  ?v11 \\<in> keys p \\<Longrightarrow> component_of_term ?v11 \\<in> K\n\ngoal (1 subgoal):\n 1. p \\<in> full_pmdl K", "by (auto simp add: full_pmdl_iff)"], ["", "lemma full_pmdlD:\n  assumes \"p \\<in> full_pmdl K\" and \"v \\<in> keys p\"\n  shows \"component_of_term v \\<in> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term v \\<in> K", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> full_pmdl K\n  v \\<in> keys p\n\ngoal (1 subgoal):\n 1. component_of_term v \\<in> K", "by (auto simp add: full_pmdl_iff)"], ["", "lemma full_pmdl_empty: \"full_pmdl {} = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_pmdl {} = {0}", "by (simp add: full_pmdl_def)"], ["", "lemma full_pmdl_UNIV: \"full_pmdl UNIV = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_pmdl UNIV = UNIV", "by (simp add: full_pmdl_def)"], ["", "lemma zero_in_full_pmdl: \"0 \\<in> full_pmdl K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> full_pmdl K", "by (simp add: full_pmdl_iff)"], ["", "lemma full_pmdl_closed_plus:\n  assumes \"p \\<in> full_pmdl K\" and \"q \\<in> full_pmdl K\"\n  shows \"p + q \\<in> full_pmdl K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p + q \\<in> full_pmdl K", "proof (rule full_pmdlI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p + q) \\<Longrightarrow> component_of_term v \\<in> K", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p + q) \\<Longrightarrow> component_of_term v \\<in> K", "assume \"v \\<in> keys (p + q)\""], ["proof (state)\nthis:\n  v \\<in> keys (p + q)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p + q) \\<Longrightarrow> component_of_term v \\<in> K", "also"], ["proof (state)\nthis:\n  v \\<in> keys (p + q)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p + q) \\<Longrightarrow> component_of_term v \\<in> K", "have \"... \\<subseteq> keys p \\<union> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p + q) \\<subseteq> keys p \\<union> keys q", "by (fact Poly_Mapping.keys_add)"], ["proof (state)\nthis:\n  keys (p + q) \\<subseteq> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p + q) \\<Longrightarrow> component_of_term v \\<in> K", "finally"], ["proof (chain)\npicking this:\n  v \\<in> keys p \\<union> keys q", "show \"component_of_term v \\<in> K\""], ["proof (prove)\nusing this:\n  v \\<in> keys p \\<union> keys q\n\ngoal (1 subgoal):\n 1. component_of_term v \\<in> K", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> keys p \\<Longrightarrow> component_of_term v \\<in> K\n 2. v \\<in> keys q \\<Longrightarrow> component_of_term v \\<in> K", "assume \"v \\<in> keys p\""], ["proof (state)\nthis:\n  v \\<in> keys p\n\ngoal (2 subgoals):\n 1. v \\<in> keys p \\<Longrightarrow> component_of_term v \\<in> K\n 2. v \\<in> keys q \\<Longrightarrow> component_of_term v \\<in> K", "with assms(1)"], ["proof (chain)\npicking this:\n  p \\<in> full_pmdl K\n  v \\<in> keys p", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> full_pmdl K\n  v \\<in> keys p\n\ngoal (1 subgoal):\n 1. component_of_term v \\<in> K", "by (rule full_pmdlD)"], ["proof (state)\nthis:\n  component_of_term v \\<in> K\n\ngoal (1 subgoal):\n 1. v \\<in> keys q \\<Longrightarrow> component_of_term v \\<in> K", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> keys q \\<Longrightarrow> component_of_term v \\<in> K", "assume \"v \\<in> keys q\""], ["proof (state)\nthis:\n  v \\<in> keys q\n\ngoal (1 subgoal):\n 1. v \\<in> keys q \\<Longrightarrow> component_of_term v \\<in> K", "with assms(2)"], ["proof (chain)\npicking this:\n  q \\<in> full_pmdl K\n  v \\<in> keys q", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> full_pmdl K\n  v \\<in> keys q\n\ngoal (1 subgoal):\n 1. component_of_term v \\<in> K", "by (rule full_pmdlD)"], ["proof (state)\nthis:\n  component_of_term v \\<in> K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  component_of_term v \\<in> K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma full_pmdl_closed_monom_mult:\n  assumes \"p \\<in> full_pmdl K\"\n  shows \"monom_mult c t p \\<in> full_pmdl K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t p \\<in> full_pmdl K", "proof (rule full_pmdlI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       component_of_term v \\<in> K", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       component_of_term v \\<in> K", "assume \"v \\<in> keys (monom_mult c t p)\""], ["proof (state)\nthis:\n  v \\<in> keys (monom_mult c t p)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       component_of_term v \\<in> K", "also"], ["proof (state)\nthis:\n  v \\<in> keys (monom_mult c t p)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       component_of_term v \\<in> K", "have \"... \\<subseteq> (\\<oplus>) t ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p", "by (fact keys_monom_mult_subset)"], ["proof (state)\nthis:\n  keys (monom_mult c t p) \\<subseteq> (\\<oplus>) t ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       component_of_term v \\<in> K", "finally"], ["proof (chain)\npicking this:\n  v \\<in> (\\<oplus>) t ` keys p", "obtain u where \"u \\<in> keys p\" and v: \"v = t \\<oplus> u\""], ["proof (prove)\nusing this:\n  v \\<in> (\\<oplus>) t ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys p; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> keys p\n  v = t \\<oplus> u\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       component_of_term v \\<in> K", "have \"component_of_term v = component_of_term u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term v = component_of_term u", "by (simp add: v term_simps)"], ["proof (state)\nthis:\n  component_of_term v = component_of_term u\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       component_of_term v \\<in> K", "also"], ["proof (state)\nthis:\n  component_of_term v = component_of_term u\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       component_of_term v \\<in> K", "from assms \\<open>u \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> full_pmdl K\n  u \\<in> keys p", "have \"... \\<in> K\""], ["proof (prove)\nusing this:\n  p \\<in> full_pmdl K\n  u \\<in> keys p\n\ngoal (1 subgoal):\n 1. component_of_term u \\<in> K", "by (rule full_pmdlD)"], ["proof (state)\nthis:\n  component_of_term u \\<in> K\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (monom_mult c t p) \\<Longrightarrow>\n       component_of_term v \\<in> K", "finally"], ["proof (chain)\npicking this:\n  component_of_term v \\<in> K", "show \"component_of_term v \\<in> K\""], ["proof (prove)\nusing this:\n  component_of_term v \\<in> K\n\ngoal (1 subgoal):\n 1. component_of_term v \\<in> K", "."], ["proof (state)\nthis:\n  component_of_term v \\<in> K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pmdl_full_pmdl: \"pmdl (full_pmdl K) = full_pmdl K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (full_pmdl K) = full_pmdl K", "using zero_in_full_pmdl full_pmdl_closed_plus full_pmdl_closed_monom_mult"], ["proof (prove)\nusing this:\n  0 \\<in> full_pmdl ?K\n  \\<lbrakk>?p \\<in> full_pmdl ?K; ?q \\<in> full_pmdl ?K\\<rbrakk>\n  \\<Longrightarrow> ?p + ?q \\<in> full_pmdl ?K\n  ?p \\<in> full_pmdl ?K \\<Longrightarrow>\n  monom_mult ?c ?t ?p \\<in> full_pmdl ?K\n\ngoal (1 subgoal):\n 1. pmdl (full_pmdl K) = full_pmdl K", "by (rule pmdl_idI)"], ["", "lemma components_full_pmdl_subset:\n  \"component_of_term ` Keys ((full_pmdl K)::('t \\<Rightarrow>\\<^sub>0 'b::zero) set) \\<subseteq> K\" (is \"?l \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (full_pmdl K) \\<subseteq> K", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` Keys (full_pmdl K) \\<Longrightarrow>\n       x \\<in> K", "let ?M = \"(full_pmdl K)::('t \\<Rightarrow>\\<^sub>0 'b) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` Keys (full_pmdl K) \\<Longrightarrow>\n       x \\<in> K", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` Keys (full_pmdl K) \\<Longrightarrow>\n       x \\<in> K", "assume \"k \\<in> ?l\""], ["proof (state)\nthis:\n  k \\<in> component_of_term ` Keys (full_pmdl K)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` Keys (full_pmdl K) \\<Longrightarrow>\n       x \\<in> K", "then"], ["proof (chain)\npicking this:\n  k \\<in> component_of_term ` Keys (full_pmdl K)", "obtain v where \"v \\<in> Keys ?M\" and k: \"k = component_of_term v\""], ["proof (prove)\nusing this:\n  k \\<in> component_of_term ` Keys (full_pmdl K)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> Keys (full_pmdl K);\n         k = component_of_term v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> Keys (full_pmdl K)\n  k = component_of_term v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` Keys (full_pmdl K) \\<Longrightarrow>\n       x \\<in> K", "from this(1)"], ["proof (chain)\npicking this:\n  v \\<in> Keys (full_pmdl K)", "obtain p where \"p \\<in> ?M\" and \"v \\<in> keys p\""], ["proof (prove)\nusing this:\n  v \\<in> Keys (full_pmdl K)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> full_pmdl K; v \\<in> keys p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_KeysE)"], ["proof (state)\nthis:\n  p \\<in> full_pmdl K\n  v \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term ` Keys (full_pmdl K) \\<Longrightarrow>\n       x \\<in> K", "thus \"k \\<in> K\""], ["proof (prove)\nusing this:\n  p \\<in> full_pmdl K\n  v \\<in> keys p\n\ngoal (1 subgoal):\n 1. k \\<in> K", "unfolding k"], ["proof (prove)\nusing this:\n  p \\<in> full_pmdl K\n  v \\<in> keys p\n\ngoal (1 subgoal):\n 1. component_of_term v \\<in> K", "by (rule full_pmdlD)"], ["proof (state)\nthis:\n  k \\<in> K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma components_full_pmdl:\n  \"component_of_term ` Keys ((full_pmdl K)::('t \\<Rightarrow>\\<^sub>0 'b::zero_neq_one) set) = K\" (is \"?l = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (full_pmdl K) = K", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. component_of_term ` Keys (full_pmdl K) \\<subseteq> K\n 2. K \\<subseteq> component_of_term ` Keys (full_pmdl K)", "let ?M = \"(full_pmdl K)::('t \\<Rightarrow>\\<^sub>0 'b) set\""], ["proof (state)\ngoal (2 subgoals):\n 1. component_of_term ` Keys (full_pmdl K) \\<subseteq> K\n 2. K \\<subseteq> component_of_term ` Keys (full_pmdl K)", "show \"K \\<subseteq> ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<subseteq> component_of_term ` Keys (full_pmdl K)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> K \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (full_pmdl K)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> K \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (full_pmdl K)", "assume \"k \\<in> K\""], ["proof (state)\nthis:\n  k \\<in> K\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> K \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (full_pmdl K)", "hence \"monomial 1 (term_of_pair (0, k)) \\<in> ?M\""], ["proof (prove)\nusing this:\n  k \\<in> K\n\ngoal (1 subgoal):\n 1. monomial (1::'b) (term_of_pair (0::'a, k)) \\<in> full_pmdl K", "by (simp add: full_pmdl_iff term_simps)"], ["proof (state)\nthis:\n  monomial (1::'b) (term_of_pair (0::'a, k)) \\<in> full_pmdl K\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> K \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (full_pmdl K)", "hence \"keys (monomial (1::'b) (term_of_pair (0, k))) \\<subseteq> Keys ?M\""], ["proof (prove)\nusing this:\n  monomial (1::'b) (term_of_pair (0::'a, k)) \\<in> full_pmdl K\n\ngoal (1 subgoal):\n 1. keys (monomial (1::'b) (term_of_pair (0::'a, k)))\n    \\<subseteq> Keys (full_pmdl K)", "by (rule keys_subset_Keys)"], ["proof (state)\nthis:\n  keys (monomial (1::'b) (term_of_pair (0::'a, k)))\n  \\<subseteq> Keys (full_pmdl K)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> K \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (full_pmdl K)", "hence \"term_of_pair (0, k) \\<in> Keys ?M\""], ["proof (prove)\nusing this:\n  keys (monomial (1::'b) (term_of_pair (0::'a, k)))\n  \\<subseteq> Keys (full_pmdl K)\n\ngoal (1 subgoal):\n 1. term_of_pair (0::'a, k) \\<in> Keys (full_pmdl K)", "by simp"], ["proof (state)\nthis:\n  term_of_pair (0::'a, k) \\<in> Keys (full_pmdl K)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> K \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (full_pmdl K)", "hence \"component_of_term (term_of_pair (0, k)) \\<in> component_of_term ` Keys ?M\""], ["proof (prove)\nusing this:\n  term_of_pair (0::'a, k) \\<in> Keys (full_pmdl K)\n\ngoal (1 subgoal):\n 1. component_of_term (term_of_pair (0::'a, k))\n    \\<in> component_of_term ` Keys (full_pmdl K)", "by (rule imageI)"], ["proof (state)\nthis:\n  component_of_term (term_of_pair (0::'a, k))\n  \\<in> component_of_term ` Keys (full_pmdl K)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> K \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (full_pmdl K)", "thus \"k \\<in> ?l\""], ["proof (prove)\nusing this:\n  component_of_term (term_of_pair (0::'a, k))\n  \\<in> component_of_term ` Keys (full_pmdl K)\n\ngoal (1 subgoal):\n 1. k \\<in> component_of_term ` Keys (full_pmdl K)", "by (simp only: component_of_term_of_pair)"], ["proof (state)\nthis:\n  k \\<in> component_of_term ` Keys (full_pmdl K)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  K \\<subseteq> component_of_term ` Keys (full_pmdl K)\n\ngoal (1 subgoal):\n 1. component_of_term ` Keys (full_pmdl K) \\<subseteq> K", "qed (fact components_full_pmdl_subset)"], ["", "lemma is_full_pmdlI:\n  assumes \"\\<And>p. component_of_term ` keys p \\<subseteq> component_of_term ` Keys B \\<Longrightarrow> p \\<in> pmdl B\"\n  shows \"is_full_pmdl B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_full_pmdl B", "unfolding is_full_pmdl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       component_of_term ` keys p\n       \\<subseteq> component_of_term ` Keys B \\<longrightarrow>\n       p \\<in> pmdl B", "using assms"], ["proof (prove)\nusing this:\n  component_of_term ` keys ?p11\n  \\<subseteq> component_of_term ` Keys B \\<Longrightarrow>\n  ?p11 \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       component_of_term ` keys p\n       \\<subseteq> component_of_term ` Keys B \\<longrightarrow>\n       p \\<in> pmdl B", "by blast"], ["", "lemma is_full_pmdlD:\n  assumes \"is_full_pmdl B\" and \"component_of_term ` keys p \\<subseteq> component_of_term ` Keys B\"\n  shows \"p \\<in> pmdl B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> pmdl B", "using assms"], ["proof (prove)\nusing this:\n  is_full_pmdl B\n  component_of_term ` keys p \\<subseteq> component_of_term ` Keys B\n\ngoal (1 subgoal):\n 1. p \\<in> pmdl B", "unfolding is_full_pmdl_def"], ["proof (prove)\nusing this:\n  \\<forall>p.\n     component_of_term ` keys p\n     \\<subseteq> component_of_term ` Keys B \\<longrightarrow>\n     p \\<in> pmdl B\n  component_of_term ` keys p \\<subseteq> component_of_term ` Keys B\n\ngoal (1 subgoal):\n 1. p \\<in> pmdl B", "by blast"], ["", "lemma is_full_pmdl_alt: \"is_full_pmdl B \\<longleftrightarrow> pmdl B = full_pmdl (component_of_term ` Keys B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_full_pmdl B = (pmdl B = full_pmdl (component_of_term ` Keys B))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_full_pmdl B = (pmdl B = full_pmdl (component_of_term ` Keys B))", "have \"b \\<in> pmdl B \\<Longrightarrow> v \\<in> keys b \\<Longrightarrow> component_of_term v \\<in> component_of_term ` Keys B\" for b v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> pmdl B; v \\<in> keys b\\<rbrakk>\n    \\<Longrightarrow> component_of_term v \\<in> component_of_term ` Keys B", "by (metis components_pmdl image_eqI in_KeysI)"], ["proof (state)\nthis:\n  \\<lbrakk>?b11 \\<in> pmdl B; ?v11 \\<in> keys ?b11\\<rbrakk>\n  \\<Longrightarrow> component_of_term ?v11 \\<in> component_of_term ` Keys B\n\ngoal (1 subgoal):\n 1. is_full_pmdl B = (pmdl B = full_pmdl (component_of_term ` Keys B))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b11 \\<in> pmdl B; ?v11 \\<in> keys ?b11\\<rbrakk>\n  \\<Longrightarrow> component_of_term ?v11 \\<in> component_of_term ` Keys B\n\ngoal (1 subgoal):\n 1. is_full_pmdl B = (pmdl B = full_pmdl (component_of_term ` Keys B))", "by (auto simp add: is_full_pmdl_def full_pmdl_def)"], ["proof (state)\nthis:\n  is_full_pmdl B = (pmdl B = full_pmdl (component_of_term ` Keys B))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_full_pmdl_pmdl: \"is_full_pmdl (pmdl B) \\<longleftrightarrow> is_full_pmdl B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_full_pmdl (pmdl B) = is_full_pmdl B", "by (simp only: is_full_pmdl_def pmdl.span_span components_pmdl)"], ["", "lemma is_full_pmdl_subset:\n  assumes \"is_full_pmdl B1\" and \"is_full_pmdl B2\"\n    and \"component_of_term ` Keys B1 \\<subseteq> component_of_term ` Keys B2\"\n  shows \"pmdl B1 \\<subseteq> pmdl B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl B1 \\<subseteq> pmdl B2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl B1 \\<Longrightarrow> x \\<in> pmdl B2", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl B1 \\<Longrightarrow> x \\<in> pmdl B2", "assume \"p \\<in> pmdl B1\""], ["proof (state)\nthis:\n  p \\<in> pmdl B1\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl B1 \\<Longrightarrow> x \\<in> pmdl B2", "from assms(2)"], ["proof (chain)\npicking this:\n  is_full_pmdl B2", "show \"p \\<in> pmdl B2\""], ["proof (prove)\nusing this:\n  is_full_pmdl B2\n\ngoal (1 subgoal):\n 1. p \\<in> pmdl B2", "proof (rule is_full_pmdlD)"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> component_of_term ` Keys B2", "have \"component_of_term ` keys p \\<subseteq> component_of_term ` Keys (pmdl B1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` keys p\n    \\<subseteq> component_of_term ` Keys (pmdl B1)", "by (rule image_mono, rule keys_subset_Keys, fact)"], ["proof (state)\nthis:\n  component_of_term ` keys p \\<subseteq> component_of_term ` Keys (pmdl B1)\n\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> component_of_term ` Keys B2", "also"], ["proof (state)\nthis:\n  component_of_term ` keys p \\<subseteq> component_of_term ` Keys (pmdl B1)\n\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> component_of_term ` Keys B2", "have \"... = component_of_term ` Keys B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (pmdl B1) = component_of_term ` Keys B1", "by (fact components_pmdl)"], ["proof (state)\nthis:\n  component_of_term ` Keys (pmdl B1) = component_of_term ` Keys B1\n\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> component_of_term ` Keys B2", "finally"], ["proof (chain)\npicking this:\n  component_of_term ` keys p \\<subseteq> component_of_term ` Keys B1", "show \"component_of_term ` keys p \\<subseteq> component_of_term ` Keys B2\""], ["proof (prove)\nusing this:\n  component_of_term ` keys p \\<subseteq> component_of_term ` Keys B1\n\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> component_of_term ` Keys B2", "using assms(3)"], ["proof (prove)\nusing this:\n  component_of_term ` keys p \\<subseteq> component_of_term ` Keys B1\n  component_of_term ` Keys B1 \\<subseteq> component_of_term ` Keys B2\n\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> component_of_term ` Keys B2", "by (rule subset_trans)"], ["proof (state)\nthis:\n  component_of_term ` keys p \\<subseteq> component_of_term ` Keys B2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> pmdl B2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_full_pmdl_eq:\n  assumes \"is_full_pmdl B1\" and \"is_full_pmdl B2\"\n    and \"component_of_term ` Keys B1 = component_of_term ` Keys B2\"\n  shows \"pmdl B1 = pmdl B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl B1 = pmdl B2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pmdl B1 \\<subseteq> pmdl B2\n 2. pmdl B2 \\<subseteq> pmdl B1", "have \"component_of_term ` Keys B1 \\<subseteq> component_of_term ` Keys B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys B1 \\<subseteq> component_of_term ` Keys B2", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  component_of_term ` Keys B1 \\<subseteq> component_of_term ` Keys B2\n\ngoal (2 subgoals):\n 1. pmdl B1 \\<subseteq> pmdl B2\n 2. pmdl B2 \\<subseteq> pmdl B1", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  is_full_pmdl B1\n  is_full_pmdl B2\n  component_of_term ` Keys B1 \\<subseteq> component_of_term ` Keys B2", "show \"pmdl B1 \\<subseteq> pmdl B2\""], ["proof (prove)\nusing this:\n  is_full_pmdl B1\n  is_full_pmdl B2\n  component_of_term ` Keys B1 \\<subseteq> component_of_term ` Keys B2\n\ngoal (1 subgoal):\n 1. pmdl B1 \\<subseteq> pmdl B2", "by (rule is_full_pmdl_subset)"], ["proof (state)\nthis:\n  pmdl B1 \\<subseteq> pmdl B2\n\ngoal (1 subgoal):\n 1. pmdl B2 \\<subseteq> pmdl B1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pmdl B2 \\<subseteq> pmdl B1", "have \"component_of_term ` Keys B2 \\<subseteq> component_of_term ` Keys B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys B2 \\<subseteq> component_of_term ` Keys B1", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  component_of_term ` Keys B2 \\<subseteq> component_of_term ` Keys B1\n\ngoal (1 subgoal):\n 1. pmdl B2 \\<subseteq> pmdl B1", "with assms(2, 1)"], ["proof (chain)\npicking this:\n  is_full_pmdl B2\n  is_full_pmdl B1\n  component_of_term ` Keys B2 \\<subseteq> component_of_term ` Keys B1", "show \"pmdl B2 \\<subseteq> pmdl B1\""], ["proof (prove)\nusing this:\n  is_full_pmdl B2\n  is_full_pmdl B1\n  component_of_term ` Keys B2 \\<subseteq> component_of_term ` Keys B1\n\ngoal (1 subgoal):\n 1. pmdl B2 \\<subseteq> pmdl B1", "by (rule is_full_pmdl_subset)"], ["proof (state)\nthis:\n  pmdl B2 \\<subseteq> pmdl B1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* term_powerprod *)"], ["", "definition map_scale :: \"'b \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b::mult_zero)\" (infixr \"\\<cdot>\" 71)\n  where \"map_scale c = Poly_Mapping.map ((*) c)\""], ["", "text \\<open>If the polynomial mapping \\<open>p\\<close> is interpreted as a power-product, then @{term \"c \\<cdot> p\"}\n  corresponds to exponentiation; if it is interpreted as a (vector-) polynomial, then @{term \"c \\<cdot> p\"}\n  corresponds to multiplication by scalar from the coefficient type.\\<close>"], ["", "lemma lookup_map_scale [simp]: \"lookup (c \\<cdot> p) = (\\<lambda>x. c * lookup p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (c \\<cdot> p) = (\\<lambda>x. c * lookup p x)", "by (auto simp: map_scale_def map.rep_eq when_def)"], ["", "lemma map_scale_single [simp]: \"k \\<cdot> Poly_Mapping.single x l = Poly_Mapping.single x (k * l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<cdot> monomial l x = monomial (k * l) x", "by (simp add: map_scale_def)"], ["", "lemma map_scale_zero_left [simp]: \"0 \\<cdot> t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<cdot> t = 0", "by (rule poly_mapping_eqI) simp"], ["", "lemma map_scale_zero_right [simp]: \"k \\<cdot> 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<cdot> 0 = 0", "by (rule poly_mapping_eqI) simp"], ["", "lemma map_scale_eq_0_iff: \"c \\<cdot> t = 0 \\<longleftrightarrow> ((c::_::semiring_no_zero_divisors) = 0 \\<or> t = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c \\<cdot> t = 0) = (c = (0::'b) \\<or> t = 0)", "by (metis aux lookup_map_scale mult_eq_0_iff)"], ["", "lemma keys_map_scale_subset: \"keys (k \\<cdot> t) \\<subseteq> keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (k \\<cdot> t) \\<subseteq> keys t", "by (metis in_keys_iff lookup_map_scale mult_zero_right subsetI)"], ["", "lemma keys_map_scale: \"keys ((k::'b::semiring_no_zero_divisors) \\<cdot> t) = (if k = 0 then {} else keys t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (k \\<cdot> t) = (if k = (0::'b) then {} else keys t)", "proof (split if_split, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = (0::'b) \\<Longrightarrow> keys (k \\<cdot> t) = {}\n 2. k \\<noteq> (0::'b) \\<Longrightarrow> keys (k \\<cdot> t) = keys t", "assume \"k = 0\""], ["proof (state)\nthis:\n  k = (0::'b)\n\ngoal (2 subgoals):\n 1. k = (0::'b) \\<Longrightarrow> keys (k \\<cdot> t) = {}\n 2. k \\<noteq> (0::'b) \\<Longrightarrow> keys (k \\<cdot> t) = keys t", "thus \"keys (k \\<cdot> t) = {}\""], ["proof (prove)\nusing this:\n  k = (0::'b)\n\ngoal (1 subgoal):\n 1. keys (k \\<cdot> t) = {}", "by simp"], ["proof (state)\nthis:\n  keys (k \\<cdot> t) = {}\n\ngoal (1 subgoal):\n 1. k \\<noteq> (0::'b) \\<Longrightarrow> keys (k \\<cdot> t) = keys t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> (0::'b) \\<Longrightarrow> keys (k \\<cdot> t) = keys t", "assume \"k \\<noteq> 0\""], ["proof (state)\nthis:\n  k \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. k \\<noteq> (0::'b) \\<Longrightarrow> keys (k \\<cdot> t) = keys t", "show \"keys (k \\<cdot> t) = keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (k \\<cdot> t) = keys t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (k \\<cdot> t) \\<subseteq> keys t\n 2. keys t \\<subseteq> keys (k \\<cdot> t)", "show \"keys t \\<subseteq> keys (k \\<cdot> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys t \\<subseteq> keys (k \\<cdot> t)", "by rule (simp add: \\<open>k \\<noteq> 0\\<close> flip: lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  keys t \\<subseteq> keys (k \\<cdot> t)\n\ngoal (1 subgoal):\n 1. keys (k \\<cdot> t) \\<subseteq> keys t", "qed (fact keys_map_scale_subset)"], ["proof (state)\nthis:\n  keys (k \\<cdot> t) = keys t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_scale_one_left [simp]: \"(1::'b::{mult_zero,monoid_mult}) \\<cdot> t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'b) \\<cdot> t = t", "by (rule poly_mapping_eqI) simp"], ["", "lemma map_scale_assoc [ac_simps]: \"c \\<cdot> d \\<cdot> t = (c * d) \\<cdot> (t::_ \\<Rightarrow>\\<^sub>0 _::{semigroup_mult,zero})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot> d \\<cdot> t = (c * d) \\<cdot> t", "by (rule poly_mapping_eqI) (simp add: ac_simps)"], ["", "lemma map_scale_distrib_left [algebra_simps]: \"(k::'b::semiring_0) \\<cdot> (s + t) = k \\<cdot> s + k \\<cdot> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<cdot> (s + t) = k \\<cdot> s + k \\<cdot> t", "by (rule poly_mapping_eqI) (simp add: lookup_add distrib_left)"], ["", "lemma map_scale_distrib_right [algebra_simps]: \"(k + (l::'b::semiring_0)) \\<cdot> t = k \\<cdot> t + l \\<cdot> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k + l) \\<cdot> t = k \\<cdot> t + l \\<cdot> t", "by (rule poly_mapping_eqI) (simp add: lookup_add distrib_right)"], ["", "lemma map_scale_Suc: \"(Suc k) \\<cdot> t = k \\<cdot> t + t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k \\<cdot> t = k \\<cdot> t + t", "by (rule poly_mapping_eqI) (simp add: lookup_add distrib_right)"], ["", "lemma map_scale_uminus_left: \"(- k::'b::ring) \\<cdot> p = - (k \\<cdot> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - k \\<cdot> p = - (k \\<cdot> p)", "by (rule poly_mapping_eqI) auto"], ["", "lemma map_scale_uminus_right: \"(k::'b::ring) \\<cdot> (- p) = - (k \\<cdot> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<cdot> - p = - (k \\<cdot> p)", "by (rule poly_mapping_eqI) auto"], ["", "lemma map_scale_uminus_uminus [simp]: \"(- k::'b::ring) \\<cdot> (- p) = k \\<cdot> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - k \\<cdot> - p = k \\<cdot> p", "by (simp add: map_scale_uminus_left map_scale_uminus_right)"], ["", "lemma map_scale_minus_distrib_left [algebra_simps]:\n  \"(k::'b::comm_semiring_1_cancel) \\<cdot> (p - q) = k \\<cdot> p - k \\<cdot> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<cdot> (p - q) = k \\<cdot> p - k \\<cdot> q", "by (rule poly_mapping_eqI) (auto simp add: lookup_minus right_diff_distrib')"], ["", "lemma map_scale_minus_distrib_right [algebra_simps]:\n  \"(k - (l::'b::comm_semiring_1_cancel)) \\<cdot> f = k \\<cdot> f - l \\<cdot> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k - l) \\<cdot> f = k \\<cdot> f - l \\<cdot> f", "by (rule poly_mapping_eqI) (auto simp add: lookup_minus left_diff_distrib')"], ["", "lemma map_scale_sum_distrib_left: \"(k::'b::semiring_0) \\<cdot> (sum f A) = (\\<Sum>a\\<in>A. k \\<cdot> f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<cdot> sum f A = (\\<Sum>a\\<in>A. k \\<cdot> f a)", "by (induct A rule: infinite_finite_induct) (simp_all add: map_scale_distrib_left)"], ["", "lemma map_scale_sum_distrib_right: \"(sum (f::_ \\<Rightarrow> 'b::semiring_0) A) \\<cdot> p = (\\<Sum>a\\<in>A. f a \\<cdot> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f A \\<cdot> p = (\\<Sum>a\\<in>A. f a \\<cdot> p)", "by (induct A rule: infinite_finite_induct) (simp_all add: map_scale_distrib_right)"], ["", "lemma deg_pm_map_scale: \"deg_pm (k \\<cdot> t) = (k::'b::semiring_0) * deg_pm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm (k \\<cdot> t) = k * deg_pm t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pm (k \\<cdot> t) = k * deg_pm t", "from keys_map_scale_subset finite_keys"], ["proof (chain)\npicking this:\n  keys (?k \\<cdot> ?t) \\<subseteq> keys ?t\n  finite (keys ?f)", "have \"deg_pm (k \\<cdot> t) = sum (lookup (k \\<cdot> t)) (keys t)\""], ["proof (prove)\nusing this:\n  keys (?k \\<cdot> ?t) \\<subseteq> keys ?t\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. deg_pm (k \\<cdot> t) = sum (lookup (k \\<cdot> t)) (keys t)", "by (rule deg_pm_superset)"], ["proof (state)\nthis:\n  deg_pm (k \\<cdot> t) = sum (lookup (k \\<cdot> t)) (keys t)\n\ngoal (1 subgoal):\n 1. deg_pm (k \\<cdot> t) = k * deg_pm t", "also"], ["proof (state)\nthis:\n  deg_pm (k \\<cdot> t) = sum (lookup (k \\<cdot> t)) (keys t)\n\ngoal (1 subgoal):\n 1. deg_pm (k \\<cdot> t) = k * deg_pm t", "have \"\\<dots> = k * sum (lookup t) (keys t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup (k \\<cdot> t)) (keys t) = k * sum (lookup t) (keys t)", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  sum (lookup (k \\<cdot> t)) (keys t) = k * sum (lookup t) (keys t)\n\ngoal (1 subgoal):\n 1. deg_pm (k \\<cdot> t) = k * deg_pm t", "also"], ["proof (state)\nthis:\n  sum (lookup (k \\<cdot> t)) (keys t) = k * sum (lookup t) (keys t)\n\ngoal (1 subgoal):\n 1. deg_pm (k \\<cdot> t) = k * deg_pm t", "from subset_refl finite_keys"], ["proof (chain)\npicking this:\n  ?A \\<subseteq> ?A\n  finite (keys ?f)", "have \"sum (lookup t) (keys t) = deg_pm t\""], ["proof (prove)\nusing this:\n  ?A \\<subseteq> ?A\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. sum (lookup t) (keys t) = deg_pm t", "by (rule deg_pm_superset[symmetric])"], ["proof (state)\nthis:\n  sum (lookup t) (keys t) = deg_pm t\n\ngoal (1 subgoal):\n 1. deg_pm (k \\<cdot> t) = k * deg_pm t", "finally"], ["proof (chain)\npicking this:\n  deg_pm (k \\<cdot> t) = k * deg_pm t", "show ?thesis"], ["proof (prove)\nusing this:\n  deg_pm (k \\<cdot> t) = k * deg_pm t\n\ngoal (1 subgoal):\n 1. deg_pm (k \\<cdot> t) = k * deg_pm t", "."], ["proof (state)\nthis:\n  deg_pm (k \\<cdot> t) = k * deg_pm t\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation phull: module map_scale"], ["proof (prove)\ngoal (1 subgoal):\n 1. module (\\<cdot>)", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a x y. a \\<cdot> (x + y) = a \\<cdot> x + a \\<cdot> y\n 2. \\<And>a b x. (a + b) \\<cdot> x = a \\<cdot> x + b \\<cdot> x\n 3. \\<And>a b x. a \\<cdot> b \\<cdot> x = (a * b) \\<cdot> x\n 4. \\<And>x. (1::'a) \\<cdot> x = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<cdot> (x_ + y_) = a_ \\<cdot> x_ + a_ \\<cdot> y_", "by (fact map_scale_distrib_left)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x. (a + b) \\<cdot> x = a \\<cdot> x + b \\<cdot> x\n 2. \\<And>a b x. a \\<cdot> b \\<cdot> x = (a * b) \\<cdot> x\n 3. \\<And>x. (1::'a) \\<cdot> x = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a_ + b_) \\<cdot> x_ = a_ \\<cdot> x_ + b_ \\<cdot> x_", "by (fact map_scale_distrib_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x. a \\<cdot> b \\<cdot> x = (a * b) \\<cdot> x\n 2. \\<And>x. (1::'a) \\<cdot> x = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<cdot> b_ \\<cdot> x_ = (a_ * b_) \\<cdot> x_", "by (fact map_scale_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (1::'a) \\<cdot> x = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<cdot> x_ = x_", "by (fact map_scale_one_left)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Since the following lemmas are proved for more general ring-types above, we do not need to\n  have them in the simpset.\\<close>"], ["", "lemmas [simp del] = phull.scale_one phull.scale_zero_left phull.scale_zero_right phull.scale_scale\n  phull.scale_minus_left phull.scale_minus_right phull.span_eq_iff"], ["", "lemmas [algebra_simps del] = phull.scale_left_distrib phull.scale_right_distrib\n  phull.scale_left_diff_distrib phull.scale_right_diff_distrib"], ["", "abbreviation \"phull \\<equiv> phull.span\""], ["", "text \\<open>@{term \\<open>phull B\\<close>} is a module over the coefficient ring @{typ 'b}, whereas\n  @{term \\<open>term_powerprod.pmdl B\\<close>} is a module over the (scalar) polynomial ring @{typ \\<open>'a \\<Rightarrow>\\<^sub>0 'b\\<close>}.\n  Nevertheless, both modules can be sets of @{emph \\<open>vector-polynomials\\<close>} of type @{typ \\<open>'t \\<Rightarrow>\\<^sub>0 'b\\<close>}.\\<close>"], ["", "context term_powerprod\nbegin"], ["", "lemma map_scale_eq_monom_mult: \"c \\<cdot> p = monom_mult c 0 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot> p = monom_mult c (0::'a) p", "by (rule poly_mapping_eqI) (simp only: lookup_map_scale lookup_monom_mult_zero)"], ["", "lemma map_scale_eq_mult_scalar: \"c \\<cdot> p = monomial c 0 \\<odot> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot> p = monomial c (0::'a) \\<odot> p", "by (simp only: map_scale_eq_monom_mult mult_scalar_monomial)"], ["", "lemma phull_closed_mult_scalar: \"p \\<in> phull B \\<Longrightarrow> monomial c 0 \\<odot> p \\<in> phull B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> phull B \\<Longrightarrow>\n    monomial c (0::'a) \\<odot> p \\<in> phull B", "unfolding map_scale_eq_mult_scalar[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> phull B \\<Longrightarrow> c \\<cdot> p \\<in> phull B", "by (rule phull.span_scale)"], ["", "lemma mult_scalar_in_phull: \"b \\<in> B \\<Longrightarrow> monomial c 0 \\<odot> b \\<in> phull B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> B \\<Longrightarrow> monomial c (0::'a) \\<odot> b \\<in> phull B", "by (intro phull_closed_mult_scalar phull.span_base)"], ["", "lemma phull_subset_module: \"phull B \\<subseteq> pmdl B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phull B \\<subseteq> pmdl B", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> phull B \\<Longrightarrow> x \\<in> pmdl B", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> phull B \\<Longrightarrow> x \\<in> pmdl B", "assume \"p \\<in> phull B\""], ["proof (state)\nthis:\n  p \\<in> phull B\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> phull B \\<Longrightarrow> x \\<in> pmdl B", "thus \"p \\<in> pmdl B\""], ["proof (prove)\nusing this:\n  p \\<in> phull B\n\ngoal (1 subgoal):\n 1. p \\<in> pmdl B", "proof (induct p rule: phull.span_induct')"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> pmdl B\n 2. \\<And>a q p.\n       \\<lbrakk>a \\<in> phull B; a \\<in> pmdl B; p \\<in> B;\n        q \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + q \\<cdot> p \\<in> pmdl B", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 \\<in> pmdl B\n 2. \\<And>a q p.\n       \\<lbrakk>a \\<in> phull B; a \\<in> pmdl B; p \\<in> B;\n        q \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + q \\<cdot> p \\<in> pmdl B", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> pmdl B", "by (fact pmdl.span_zero)"], ["proof (state)\nthis:\n  0 \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> phull B; a \\<in> pmdl B; p \\<in> B;\n        q \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + q \\<cdot> p \\<in> pmdl B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> phull B; a \\<in> pmdl B; p \\<in> B;\n        q \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + q \\<cdot> p \\<in> pmdl B", "case (step a c p)"], ["proof (state)\nthis:\n  a \\<in> phull B\n  a \\<in> pmdl B\n  p \\<in> B\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> phull B; a \\<in> pmdl B; p \\<in> B;\n        q \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + q \\<cdot> p \\<in> pmdl B", "from step(3)"], ["proof (chain)\npicking this:\n  p \\<in> B", "have \"p \\<in> pmdl B\""], ["proof (prove)\nusing this:\n  p \\<in> B\n\ngoal (1 subgoal):\n 1. p \\<in> pmdl B", "by (rule pmdl.span_base)"], ["proof (state)\nthis:\n  p \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> phull B; a \\<in> pmdl B; p \\<in> B;\n        q \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + q \\<cdot> p \\<in> pmdl B", "hence \"c \\<cdot> p \\<in> pmdl B\""], ["proof (prove)\nusing this:\n  p \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. c \\<cdot> p \\<in> pmdl B", "unfolding map_scale_eq_monom_mult"], ["proof (prove)\nusing this:\n  p \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. monom_mult c (0::'a) p \\<in> pmdl B", "by (rule pmdl_closed_monom_mult)"], ["proof (state)\nthis:\n  c \\<cdot> p \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> phull B; a \\<in> pmdl B; p \\<in> B;\n        q \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + q \\<cdot> p \\<in> pmdl B", "with step(2)"], ["proof (chain)\npicking this:\n  a \\<in> pmdl B\n  c \\<cdot> p \\<in> pmdl B", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> pmdl B\n  c \\<cdot> p \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. a + c \\<cdot> p \\<in> pmdl B", "by (rule pmdl.span_add)"], ["proof (state)\nthis:\n  a + c \\<cdot> p \\<in> pmdl B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> pmdl B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma components_phull: \"component_of_term ` Keys (phull B) = component_of_term ` Keys B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (phull B) = component_of_term ` Keys B", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. component_of_term ` Keys (phull B)\n    \\<subseteq> component_of_term ` Keys B\n 2. component_of_term ` Keys B\n    \\<subseteq> component_of_term ` Keys (phull B)", "have \"component_of_term ` Keys (phull B) \\<subseteq> component_of_term ` Keys (pmdl B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (phull B)\n    \\<subseteq> component_of_term ` Keys (pmdl B)", "by (rule image_mono, rule Keys_mono, fact phull_subset_module)"], ["proof (state)\nthis:\n  component_of_term ` Keys (phull B)\n  \\<subseteq> component_of_term ` Keys (pmdl B)\n\ngoal (2 subgoals):\n 1. component_of_term ` Keys (phull B)\n    \\<subseteq> component_of_term ` Keys B\n 2. component_of_term ` Keys B\n    \\<subseteq> component_of_term ` Keys (phull B)", "also"], ["proof (state)\nthis:\n  component_of_term ` Keys (phull B)\n  \\<subseteq> component_of_term ` Keys (pmdl B)\n\ngoal (2 subgoals):\n 1. component_of_term ` Keys (phull B)\n    \\<subseteq> component_of_term ` Keys B\n 2. component_of_term ` Keys B\n    \\<subseteq> component_of_term ` Keys (phull B)", "have \"... = component_of_term ` Keys B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (pmdl B) = component_of_term ` Keys B", "by (fact components_pmdl)"], ["proof (state)\nthis:\n  component_of_term ` Keys (pmdl B) = component_of_term ` Keys B\n\ngoal (2 subgoals):\n 1. component_of_term ` Keys (phull B)\n    \\<subseteq> component_of_term ` Keys B\n 2. component_of_term ` Keys B\n    \\<subseteq> component_of_term ` Keys (phull B)", "finally"], ["proof (chain)\npicking this:\n  component_of_term ` Keys (phull B) \\<subseteq> component_of_term ` Keys B", "show \"component_of_term ` Keys (phull B) \\<subseteq> component_of_term ` Keys B\""], ["proof (prove)\nusing this:\n  component_of_term ` Keys (phull B) \\<subseteq> component_of_term ` Keys B\n\ngoal (1 subgoal):\n 1. component_of_term ` Keys (phull B)\n    \\<subseteq> component_of_term ` Keys B", "."], ["proof (state)\nthis:\n  component_of_term ` Keys (phull B) \\<subseteq> component_of_term ` Keys B\n\ngoal (1 subgoal):\n 1. component_of_term ` Keys B\n    \\<subseteq> component_of_term ` Keys (phull B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term ` Keys B\n    \\<subseteq> component_of_term ` Keys (phull B)", "show \"component_of_term ` Keys B \\<subseteq> component_of_term ` Keys (phull B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys B\n    \\<subseteq> component_of_term ` Keys (phull B)", "by (rule image_mono, rule Keys_mono, fact phull.span_superset)"], ["proof (state)\nthis:\n  component_of_term ` Keys B \\<subseteq> component_of_term ` Keys (phull B)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Interpretations\\<close>"], ["", "subsubsection \\<open>Isomorphism between @{typ 'a} and @{typ \"'a \\<times> unit\"}\\<close>"], ["", "definition to_pair_unit :: \"'a \\<Rightarrow> ('a \\<times> unit)\"\n  where \"to_pair_unit x = (x, ())\""], ["", "lemma fst_to_pair_unit: \"fst (to_pair_unit x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (to_pair_unit x) = x", "by (simp add: to_pair_unit_def)"], ["", "lemma to_pair_unit_fst: \"to_pair_unit (fst x) = (x::_ \\<times> unit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_pair_unit (fst x) = x", "by (metis (full_types) old.unit.exhaust prod.collapse to_pair_unit_def)"], ["", "interpretation punit: term_powerprod to_pair_unit fst"], ["proof (prove)\ngoal (1 subgoal):\n 1. term_powerprod to_pair_unit fst", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v. fst (to_pair_unit v) = v\n 2. \\<And>p. to_pair_unit (fst p) = p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (to_pair_unit v_) = v_", "by (fact fst_to_pair_unit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. to_pair_unit (fst p) = p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_pair_unit (fst p_) = p_", "by (fact to_pair_unit_fst)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>For technical reasons it seems to be better not to put the following lemmas as rewrite-rules\n  of interpretation \\<open>punit\\<close>.\\<close>"], ["", "lemma punit_pp_of_term [simp]: \"punit.pp_of_term = (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.pp_of_term = (\\<lambda>x. x)", "by (rule, simp add: punit.pp_of_term_def punit.term_pair)"], ["", "lemma punit_component_of_term [simp]: \"punit.component_of_term = (\\<lambda>_. ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.component_of_term = (\\<lambda>_. ())", "by (rule, simp add: punit.component_of_term_def)"], ["", "lemma punit_splus [simp]: \"punit.splus = (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.splus = (+)", "by (rule, rule, simp add: punit.splus_def)"], ["", "lemma punit_sminus [simp]: \"punit.sminus = (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.sminus = (-)", "by (rule, rule, simp add: punit.sminus_def)"], ["", "lemma punit_adds_pp [simp]: \"punit.adds_pp = (adds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.adds_pp = (adds)", "by (rule, rule, simp add: punit.adds_pp_def)"], ["", "lemma punit_adds_term [simp]: \"punit.adds_term = (adds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.adds_term = (adds)", "by (rule, rule, simp add: punit.adds_term_def)"], ["", "lemma punit_proj_poly [simp]: \"punit.proj_poly = (\\<lambda>_. id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.proj_poly = (\\<lambda>_. id)", "by (rule, rule, rule poly_mapping_eqI, simp add: punit.lookup_proj_poly)"], ["", "lemma punit_mult_vec [simp]: \"punit.mult_vec = (*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.mult_vec = (*)", "by (rule, rule, rule poly_mapping_eqI, simp add: punit.lookup_mult_vec)"], ["", "lemma punit_mult_scalar [simp]: \"punit.mult_scalar = (*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.mult_scalar = (*)", "by (rule, rule, rule poly_mapping_eqI, simp add: punit.lookup_mult_scalar)"], ["", "context term_powerprod\nbegin"], ["", "lemma proj_monom_mult: \"proj_poly k (monom_mult c t p) = punit.monom_mult c t (proj_poly k p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (monom_mult c t p) = punit.monom_mult c t (proj_poly k p)", "by (metis mult_scalar_monomial proj_mult_scalar punit.mult_scalar_monomial punit_mult_scalar)"], ["", "lemma mult_scalar_monom_mult: \"(punit.monom_mult c t p) \\<odot> q = monom_mult c t (p \\<odot> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult c t p \\<odot> q = monom_mult c t (p \\<odot> q)", "by (simp add: punit.mult_scalar_monomial[symmetric] mult_scalar_assoc mult_scalar_monomial)"], ["", "end"], ["", "(* term_powerprod *)"], ["", "subsubsection \\<open>Interpretation of @{locale term_powerprod} by @{typ \"'a \\<times> 'k\"}\\<close>"], ["", "interpretation pprod: term_powerprod \"(\\<lambda>x::'a::comm_powerprod \\<times> 'k::linorder. x)\" \"\\<lambda>x. x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_powerprod (\\<lambda>x. x) (\\<lambda>x. x)", "by (standard, simp)"], ["", "lemma pprod_pp_of_term [simp]: \"pprod.pp_of_term = fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.pp_of_term = fst", "by (rule, simp add: pprod.pp_of_term_def)"], ["", "lemma pprod_component_of_term [simp]: \"pprod.component_of_term = snd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.component_of_term = snd", "by (rule, simp add: pprod.component_of_term_def)"], ["", "subsubsection \\<open>Simplifier Setup\\<close>"], ["", "text \\<open>There is no reason to keep the interpreted theorems as simplification rules.\\<close>"], ["", "lemmas [term_simps del] = term_simps"], ["", "lemmas times_monomial_monomial = punit.mult_scalar_monomial_monomial[simplified]"], ["", "lemmas times_monomial_left = punit.mult_scalar_monomial[simplified]"], ["", "lemmas times_rec_left = punit.mult_scalar_rec_left[simplified]"], ["", "lemmas times_rec_right = punit.mult_scalar_rec_right[simplified]"], ["", "lemmas in_keys_timesE = punit.in_keys_mult_scalarE[simplified]"], ["", "lemmas punit_monom_mult_monomial = punit.monom_mult_monomial[simplified]"], ["", "lemmas lookup_times = punit.lookup_mult_scalar_explicit[simplified]"], ["", "lemmas map_scale_eq_times = punit.map_scale_eq_mult_scalar[simplified]"], ["", "end"], ["", "(* theory *)"]]}