{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/OAlist.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma min_list_param_in:\n  assumes \"xs \\<noteq> []\"\n  shows \"min_list_param rel xs \\<in> set xs\"", "lemma min_list_param_minimal:\n  assumes \"transp rel\" and \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set xs \\<Longrightarrow> rel x y \\<or> rel y x\"\n    and \"z \\<in> set xs\"\n  shows \"rel (min_list_param rel xs) z\"", "lemma comp_of_ord_eq_comp_of_ords:\n  assumes \"antisymp le\"\n  shows \"comp_of_ord le = comp_of_ords le (\\<lambda>x y. le x y \\<and> \\<not> le y x)\"", "lemma comparator_converse:\n  assumes \"comparator cmp\"\n  shows \"comparator (\\<lambda>x y. cmp y x)\"", "lemma comparator_composition:\n  assumes \"comparator cmp\" and \"inj f\"\n  shows \"comparator (\\<lambda>x y. cmp (f x) (f y))\"", "lemma comparator_key_compare [simp, intro!]: \"comparator (key_compare ko)\"", "lemma le_of_key_order_alt: \"le_of_key_order ko x y = (key_compare ko x y \\<noteq> Gt)\"", "lemma lt_of_key_order_alt: \"lt_of_key_order ko x y = (key_compare ko x y = Lt)\"", "lemma key_compare_Gt: \"key_compare ko x y = Gt \\<longleftrightarrow> key_compare ko y x = Lt\"", "lemma key_compare_Eq: \"key_compare ko x y = Eq \\<longleftrightarrow> x = y\"", "lemma key_compare_same [simp]: \"key_compare ko x x = Eq\"", "lemma uminus_key_compare [simp]: \"invert_order (key_compare ko x y) = key_compare ko y x\"", "lemma key_compare_uminus [simp]: \"key_compare (- ko) x y = key_compare ko y x\"", "lemma uminus_key_order_sameD:\n  assumes \"- ko = (ko::'a key_order)\"\n  shows \"x = (y::'a)\"", "lemma key_compare_key_order_of_ord:\n  assumes \"antisymp ord\" and \"transp ord\" and \"\\<And>x y. ord x y \\<or> ord y x\"\n  shows \"key_compare (key_order_of_ord ord) = (\\<lambda>x y. if ord x y then if x = y then Eq else Lt else Gt)\"", "lemma key_compare_key_order_of_le:\n  \"key_compare key_order_of_le = (\\<lambda>x y. if x < y then Lt else if x = y then Eq else Gt)\"", "lemma oalist_inv_rawI:\n  assumes \"0 \\<notin> snd ` set xs\" and \"sorted_wrt lt (map fst xs)\"\n  shows \"oalist_inv_raw xs\"", "lemma oalist_inv_rawD1:\n  assumes \"oalist_inv_raw xs\"\n  shows \"0 \\<notin> snd ` set xs\"", "lemma oalist_inv_rawD2:\n  assumes \"oalist_inv_raw xs\"\n  shows \"sorted_wrt lt (map fst xs)\"", "lemma oalist_inv_raw_Nil: \"oalist_inv_raw []\"", "lemma oalist_inv_raw_singleton: \"oalist_inv_raw [(k, v)] \\<longleftrightarrow> (v \\<noteq> 0)\"", "lemma oalist_inv_raw_ConsI:\n  assumes \"oalist_inv_raw xs\" and \"v \\<noteq> 0\" and \"xs \\<noteq> [] \\<Longrightarrow> lt k (fst (hd xs))\"\n  shows \"oalist_inv_raw ((k, v) # xs)\"", "lemma oalist_inv_raw_ConsD1:\n  assumes \"oalist_inv_raw (x # xs)\"\n  shows \"oalist_inv_raw xs\"", "lemma oalist_inv_raw_ConsD2:\n  assumes \"oalist_inv_raw ((k, v) # xs)\"\n  shows \"v \\<noteq> 0\"", "lemma oalist_inv_raw_ConsD3:\n  assumes \"oalist_inv_raw ((k, v) # xs)\" and \"k' \\<in> fst ` set xs\"\n  shows \"lt k k'\"", "lemma oalist_inv_raw_tl:\n  assumes \"oalist_inv_raw xs\"\n  shows \"oalist_inv_raw (tl xs)\"", "lemma oalist_inv_raw_filter:\n  assumes \"oalist_inv_raw xs\"\n  shows \"oalist_inv_raw (filter P xs)\"", "lemma oalist_inv_raw_map:\n  assumes \"oalist_inv_raw xs\"\n    and \"\\<And>a. snd (f a) = 0 \\<Longrightarrow> snd a = 0\"\n    and \"\\<And>a b. comp (fst (f a)) (fst (f b)) = comp (fst a) (fst b)\"\n  shows \"oalist_inv_raw (map f xs)\"", "lemma oalist_inv_raw_induct [consumes 1, case_names Nil Cons]:\n  assumes \"oalist_inv_raw xs\"\n  assumes \"P []\"\n  assumes \"\\<And>k v xs. oalist_inv_raw ((k, v) # xs) \\<Longrightarrow> oalist_inv_raw xs \\<Longrightarrow> v \\<noteq> 0 \\<Longrightarrow>\n              (\\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k') \\<Longrightarrow> P xs \\<Longrightarrow> P ((k, v) # xs)\"\n  shows \"P xs\"", "lemma lookup_pair_eq_0:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair xs k = 0 \\<longleftrightarrow> (k \\<notin> fst ` set xs)\"", "lemma lookup_pair_eq_value:\n  assumes \"oalist_inv_raw xs\" and \"v \\<noteq> 0\"\n  shows \"lookup_pair xs k = v \\<longleftrightarrow> ((k, v) \\<in> set xs)\"", "lemma lookup_pair_eq_valueI:\n  assumes \"oalist_inv_raw xs\" and \"(k, v) \\<in> set xs\"\n  shows \"lookup_pair xs k = v\"", "lemma lookup_dflt_eq_lookup_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_dflt xs = lookup_pair xs\"", "lemma lookup_pair_inj:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\" and \"lookup_pair xs = lookup_pair ys\"\n  shows \"xs = ys\"", "lemma lookup_pair_tl:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair (tl xs) k = (if (\\<forall>k'\\<in>fst ` set xs. le k k') then 0 else lookup_pair xs k)\"", "lemma lookup_pair_tl':\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair (tl xs) k = (if k = fst (hd xs) then 0 else lookup_pair xs k)\"", "lemma lookup_pair_filter:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair (filter P xs) k = (let v = lookup_pair xs k in if P (k, v) then v else 0)\"", "lemma lookup_pair_map:\n  assumes \"oalist_inv_raw xs\"\n    and \"\\<And>k'. snd (f (k', 0)) = 0\"\n    and \"\\<And>a b. comp (fst (f a)) (fst (f b)) = comp (fst a) (fst b)\"\n  shows \"lookup_pair (map f xs) (fst (f (k, v))) = snd (f (k, lookup_pair xs k))\"", "lemma lookup_pair_Cons:\n  assumes \"oalist_inv_raw ((k, v) # xs)\"\n  shows \"lookup_pair ((k, v) # xs) k0 = (if k = k0 then v else lookup_pair xs k0)\"", "lemma lookup_pair_single: \"lookup_pair [(k, v)] k0 = (if k = k0 then v else 0)\"", "lemma set_update_by_pair_subset: \"set (update_by_pair kv xs) \\<subseteq> insert kv (set xs)\"", "lemma update_by_pair_sorted:\n  assumes \"sorted_wrt lt (map fst xs)\"\n  shows \"sorted_wrt lt (map fst (update_by_pair kv xs))\"", "lemma update_by_pair_not_0:\n  assumes \"0 \\<notin> snd ` set xs\"\n  shows \"0 \\<notin> snd ` set (update_by_pair kv xs)\"", "lemma update_by_pair_less:\n  assumes \"v \\<noteq> 0\" and \"xs = [] \\<or> comp k (fst (hd xs)) = Lt\"\n  shows \"update_by_pair (k, v) xs = (k, v) # xs\"", "lemma lookup_pair_update_by_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair (update_by_pair (k1, v) xs) k2 = (if k1 = k2 then v else lookup_pair xs k2)\"", "lemma set_update_by_pair:\n  assumes \"oalist_inv_raw xs\" and \"v \\<noteq> 0\"\n  shows \"set (update_by_pair (k, v) xs) = insert (k, v) (set xs - range (Pair k))\" (is \"?A = ?B\")", "lemma set_update_by_pair_zero:\n  assumes \"oalist_inv_raw xs\"\n  shows \"set (update_by_pair (k, 0) xs) = set xs - range (Pair k)\" (is \"?A = ?B\")", "lemma update_by_fun_pair_eq_update_by_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"update_by_fun_pair k f xs = update_by_pair (k, f (lookup_pair xs k)) xs\"", "lemma update_by_fun_pair_gr:\n  assumes \"oalist_inv_raw xs\" and \"xs = [] \\<or> comp k (fst (last xs)) = Gt\"\n  shows \"update_by_fun_pair k f xs = xs @ (if f 0 = 0 then [] else [(k, f 0)])\"", "lemma map_pair_cong:\n  assumes \"\\<And>kv. kv \\<in> set xs \\<Longrightarrow> f kv = g kv\"\n  shows \"map_pair f xs = map_pair g xs\"", "lemma map_pair_subset: \"set (map_pair f xs) \\<subseteq> f ` set xs\"", "lemma oalist_inv_raw_map_pair:\n  assumes \"oalist_inv_raw xs\"\n    and \"\\<And>a b. comp (fst (f a)) (fst (f b)) = comp (fst a) (fst b)\"\n  shows \"oalist_inv_raw (map_pair f xs)\"", "lemma lookup_pair_map_pair:\n  assumes \"oalist_inv_raw xs\" and \"snd (f (k, 0)) = 0\"\n    and \"\\<And>a b. comp (fst (f a)) (fst (f b)) = comp (fst a) (fst b)\"\n  shows \"lookup_pair (map_pair f xs) (fst (f (k, v))) = snd (f (k, lookup_pair xs k))\"", "lemma lookup_dflt_map_pair:\n  assumes \"distinct (map fst xs)\" and \"snd (f (k, 0)) = 0\"\n    and \"\\<And>a b. (fst (f a) = fst (f b)) \\<longleftrightarrow> (fst a = fst b)\"\n  shows \"lookup_dflt (map_pair f xs) (fst (f (k, v))) = snd (f (k, lookup_dflt xs k))\"", "lemma distinct_map_pair:\n  assumes \"distinct (map fst xs)\" and \"\\<And>a b. fst (f a) = fst (f b) \\<Longrightarrow> fst a = fst b\"\n  shows \"distinct (map fst (map_pair f xs))\"", "lemma map_val_pair_cong:\n  assumes \"\\<And>k v. (k, v) \\<in> set xs \\<Longrightarrow> f k v = g k v\"\n  shows \"map_val_pair f xs = map_val_pair g xs\"", "lemma oalist_inv_raw_map_val_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"oalist_inv_raw (map_val_pair f xs)\"", "lemma lookup_pair_map_val_pair:\n  assumes \"oalist_inv_raw xs\" and \"f k 0 = 0\"\n  shows \"lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)\"", "lemma map_pair_id:\n  assumes \"oalist_inv_raw xs\"\n  shows \"map_pair id xs = xs\"", "lemma map2_val_compatI:\n  assumes \"\\<And>zs. oalist_inv_raw zs \\<Longrightarrow> oalist_inv_raw (f zs)\"\n    and \"\\<And>zs. oalist_inv_raw zs \\<Longrightarrow> fst ` set (f zs) \\<subseteq> fst ` set zs\"\n  shows \"map2_val_compat f\"", "lemma map2_val_compatD1:\n  assumes \"map2_val_compat f\" and \"oalist_inv_raw zs\"\n  shows \"oalist_inv_raw (f zs)\"", "lemma map2_val_compatD2:\n  assumes \"map2_val_compat f\" and \"oalist_inv_raw zs\"\n  shows \"fst ` set (f zs) \\<subseteq> fst ` set zs\"", "lemma map2_val_compat_Nil:\n  assumes \"map2_val_compat (f::('a \\<times> 'b::zero) list \\<Rightarrow> ('a \\<times> 'c::zero) list)\"\n  shows \"f [] = []\"", "lemma map2_val_compat_id: \"map2_val_compat id\"", "lemma map2_val_compat_map_val_pair: \"map2_val_compat (map_val_pair f)\"", "lemma fst_map2_val_pair_subset:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\"\n  assumes \"map2_val_compat g\" and \"map2_val_compat h\"\n  shows \"fst ` set (map2_val_pair f g h xs ys) \\<subseteq> fst ` set xs \\<union> fst ` set ys\"", "lemma oalist_inv_raw_map2_val_pair:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\"\n  assumes \"map2_val_compat g\" and \"map2_val_compat h\"\n  shows \"oalist_inv_raw (map2_val_pair f g h xs ys)\"", "lemma lookup_pair_map2_val_pair:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\"\n  assumes \"map2_val_compat g\" and \"map2_val_compat h\"\n  assumes \"\\<And>zs. oalist_inv_raw zs \\<Longrightarrow> g zs = map_val_pair (\\<lambda>k v. f k v 0) zs\"\n    and \"\\<And>zs. oalist_inv_raw zs \\<Longrightarrow> h zs = map_val_pair (\\<lambda>k. f k 0) zs\"\n    and \"\\<And>k. f k 0 0 = 0\"\n  shows \"lookup_pair (map2_val_pair f g h xs ys) k0 = f k0 (lookup_pair xs k0) (lookup_pair ys k0)\"", "lemma map2_val_pair_singleton_eq_update_by_fun_pair:\n  assumes \"oalist_inv_raw xs\"\n  assumes \"\\<And>k x. f k x 0 = x\" and \"\\<And>zs. oalist_inv_raw zs \\<Longrightarrow> g zs = zs\"\n    and \"h [(k, v)] = map_val_pair (\\<lambda>k. f k 0) [(k, v)]\"\n  shows \"map2_val_pair f g h xs [(k, v)] = update_by_fun_pair k (\\<lambda>x. f k x v) xs\"", "lemma lex_ord_pair_EqI:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\"\n    and \"\\<And>k. k \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow> f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq\"\n  shows \"lex_ord_pair f xs ys = Some Eq\"", "lemma lex_ord_pair_valI:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\" and \"aux \\<noteq> Some Eq\"\n  assumes \"k \\<in> fst ` set xs \\<union> fst ` set ys\" and \"aux = f k (lookup_pair xs k) (lookup_pair ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow> lt k' k \\<Longrightarrow>\n              f k' (lookup_pair xs k') (lookup_pair ys k') = Some Eq\"\n  shows \"lex_ord_pair f xs ys = aux\"", "lemma lex_ord_pair_EqD:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\" and \"lex_ord_pair f xs ys = Some Eq\"\n    and \"k \\<in> fst ` set xs \\<union> fst ` set ys\"\n  shows \"f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq\"", "lemma lex_ord_pair_valE:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\" and \"lex_ord_pair f xs ys = aux\"\n    and \"aux \\<noteq> Some Eq\"\n  obtains k where \"k \\<in> fst ` set xs \\<union> fst ` set ys\" and \"aux = f k (lookup_pair xs k) (lookup_pair ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow> lt k' k \\<Longrightarrow>\n            f k' (lookup_pair xs k') (lookup_pair ys k') = Some Eq\"", "lemma prod_ord_pair_eq_lex_ord_pair:\n  \"prod_ord_pair P xs ys = (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) xs ys = Some Eq)\"", "lemma prod_ord_pairI:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\"\n    and \"\\<And>k. k \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow> P k (lookup_pair xs k) (lookup_pair ys k)\"\n  shows \"prod_ord_pair P xs ys\"", "lemma prod_ord_pairD:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\" and \"prod_ord_pair P xs ys\"\n    and \"k \\<in> fst ` set xs \\<union> fst ` set ys\"\n  shows \"P k (lookup_pair xs k) (lookup_pair ys k)\"", "lemma oalist_inv_raw_foldr_update_by_pair:\n  assumes \"oalist_inv_raw ys\"\n  shows \"oalist_inv_raw (foldr update_by_pair xs ys)\"", "lemma sort_oalist_id:\n  assumes \"oalist_inv_raw xs\"\n  shows \"sort_oalist xs = xs\"", "lemma set_sort_oalist:\n  assumes \"distinct (map fst xs)\"\n  shows \"set (sort_oalist xs) = {kv. kv \\<in> set xs \\<and> snd kv \\<noteq> 0}\"", "lemma lookup_pair_sort_oalist':\n  assumes \"distinct (map fst xs)\"\n  shows \"lookup_pair (sort_oalist xs) = lookup_dflt xs\"", "lemma set_sort_oalist:\n  assumes \"cmp2.oalist_inv_raw xs\"\n  shows \"set (sort_oalist xs) = set xs\"", "lemma lookup_pair_eqI:\n  assumes \"oalist_inv_raw xs\" and \"cmp2.oalist_inv_raw ys\" and \"set xs = set ys\"\n  shows \"lookup_pair xs = cmp2.lookup_pair ys\"", "lemma oalist_inv_alt: \"oalist_inv (xs, ko) \\<longleftrightarrow> oalist_inv_raw ko xs\"", "lemma set_sort_oalist_aux:\n  assumes \"oalist_inv xs\"\n  shows \"set (sort_oalist_aux ko xs) = set (fst xs)\"", "lemma oalist_inv_raw_sort_oalist_aux:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv_raw ko (sort_oalist_aux ko xs)\"", "lemma oalist_inv_sort_oalist_aux:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (sort_oalist_aux ko xs, ko)\"", "lemma lookup_pair_sort_oalist_aux:\n  assumes \"oalist_inv xs\"\n  shows \"lookup_pair ko (sort_oalist_aux ko xs) = lookup_raw xs\"", "lemma lookup_raw_eq_value:\n  assumes \"oalist_inv xs\" and \"v \\<noteq> 0\"\n  shows \"lookup_raw xs k = v \\<longleftrightarrow> ((k, v) \\<in> set (fst xs))\"", "lemma lookup_raw_eq_valueI:\n  assumes \"oalist_inv xs\" and \"(k, v) \\<in> set (fst xs)\"\n  shows \"lookup_raw xs k = v\"", "lemma lookup_raw_inj:\n  assumes \"oalist_inv (xs, ko)\" and \"oalist_inv (ys, ko)\" and \"lookup_raw (xs, ko) = lookup_raw (ys, ko)\"\n  shows \"xs = ys\"", "lemma set_sorted_domain_raw:\n  assumes \"oalist_inv xs\"\n  shows \"set (sorted_domain_raw ko xs) = fst ` set (fst xs)\"", "lemma sorted_sorted_domain_raw:\n  assumes \"oalist_inv xs\"\n  shows \"sorted_wrt (lt_of_key_order (rep_key_order ko)) (sorted_domain_raw ko xs)\"", "lemma oalist_inv_tl_raw:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (tl_raw xs)\"", "lemma lookup_raw_tl_raw:\n  assumes \"oalist_inv xs\"\n  shows \"lookup_raw (tl_raw xs) k =\n          (if (\\<forall>k'\\<in>fst ` set (fst xs). le (snd xs) k k') then 0 else lookup_raw xs k)\"", "lemma lookup_raw_tl_raw':\n  assumes \"oalist_inv xs\"\n  shows \"lookup_raw (tl_raw xs) k = (if k = fst (List.hd (fst xs)) then 0 else lookup_raw xs k)\"", "lemma min_key_val_raw_alt:\n  assumes \"oalist_inv xs\" and \"fst xs \\<noteq> []\"\n  shows \"min_key_val_raw ko xs = List.hd (sort_oalist_aux ko xs)\"", "lemma min_key_val_raw_in:\n  assumes \"fst xs \\<noteq> []\"\n  shows \"min_key_val_raw ko xs \\<in> set (fst xs)\"", "lemma snd_min_key_val_raw:\n  assumes \"oalist_inv xs\" and \"fst xs \\<noteq> []\"\n  shows \"snd (min_key_val_raw ko xs) = lookup_raw xs (fst (min_key_val_raw ko xs))\"", "lemma min_key_val_raw_minimal:\n  assumes \"oalist_inv xs\" and \"z \\<in> set (fst xs)\"\n  shows \"le ko (fst (min_key_val_raw ko xs)) (fst z)\"", "lemma oalist_inv_filter_raw:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (filter_raw P xs)\"", "lemma lookup_raw_filter_raw:\n  assumes \"oalist_inv xs\"\n  shows \"lookup_raw (filter_raw P xs) k = (let v = lookup_raw xs k in if P (k, v) then v else 0)\"", "lemma oalist_inv_update_by_raw:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (update_by_raw kv xs)\"", "lemma lookup_raw_update_by_raw:\n  assumes \"oalist_inv xs\"\n  shows \"lookup_raw (update_by_raw (k1, v) xs) k2 = (if k1 = k2 then v else lookup_raw xs k2)\"", "lemma update_by_fun_raw_eq_update_by_raw:\n  assumes \"oalist_inv xs\"\n  shows \"update_by_fun_raw k f xs = update_by_raw (k, f (lookup_raw xs k)) xs\"", "lemma update_by_fun_gr_raw_eq_update_by_fun_raw:\n  assumes \"oalist_inv xs\"\n  shows \"update_by_fun_gr_raw k f xs = update_by_fun_raw k f xs\"", "lemma map_raw_cong:\n  assumes \"\\<And>kv. kv \\<in> set (fst xs) \\<Longrightarrow> f kv = g kv\"\n  shows \"map_raw f xs = map_raw g xs\"", "lemma map_raw_subset: \"set (fst (map_raw f xs)) \\<subseteq> f ` set (fst xs)\"", "lemma oalist_inv_map_raw:\n  assumes \"oalist_inv xs\"\n    and \"\\<And>a b. key_compare (rep_key_order (snd xs)) (fst (f a)) (fst (f b)) = key_compare (rep_key_order (snd xs)) (fst a) (fst b)\"\n  shows \"oalist_inv (map_raw f xs)\"", "lemma lookup_raw_map_raw:\n  assumes \"oalist_inv xs\" and \"snd (f (k, 0)) = 0\"\n    and \"\\<And>a b. key_compare (rep_key_order (snd xs)) (fst (f a)) (fst (f b)) = key_compare (rep_key_order (snd xs)) (fst a) (fst b)\"\n  shows \"lookup_raw (map_raw f xs) (fst (f (k, v))) = snd (f (k, lookup_raw xs k))\"", "lemma map_raw_id:\n  assumes \"oalist_inv xs\"\n  shows \"map_raw id xs = xs\"", "lemma map_val_raw_cong:\n  assumes \"\\<And>k v. (k, v) \\<in> set (fst xs) \\<Longrightarrow> f k v = g k v\"\n  shows \"map_val_raw f xs = map_val_raw g xs\"", "lemma oalist_inv_map_val_raw:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (map_val_raw f xs)\"", "lemma lookup_raw_map_val_raw:\n  assumes \"oalist_inv xs\" and \"f k 0 = 0\"\n  shows \"lookup_raw (map_val_raw f xs) k = f k (lookup_raw xs k)\"", "lemma map2_val_compat'I:\n  assumes \"\\<And>zs. oalist_inv zs \\<Longrightarrow> oalist_inv (f zs)\"\n    and \"\\<And>zs. oalist_inv zs \\<Longrightarrow> snd (f zs) = snd zs\"\n    and \"\\<And>zs. oalist_inv zs \\<Longrightarrow> fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)\"\n  shows \"map2_val_compat' f\"", "lemma map2_val_compat'D1:\n  assumes \"map2_val_compat' f\" and \"oalist_inv zs\"\n  shows \"oalist_inv (f zs)\"", "lemma map2_val_compat'D2:\n  assumes \"map2_val_compat' f\" and \"oalist_inv zs\"\n  shows \"snd (f zs) = snd zs\"", "lemma map2_val_compat'D3:\n  assumes \"map2_val_compat' f\" and \"oalist_inv zs\"\n  shows \"fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)\"", "lemma map2_val_compat'_map_val_raw: \"map2_val_compat' (map_val_raw f)\"", "lemma map2_val_compat'_id: \"map2_val_compat' id\"", "lemma map2_val_compat'_imp_map2_val_compat:\n  assumes \"map2_val_compat' g\"\n  shows \"map2_val_compat ko (\\<lambda>zs. fst (g (zs, ko)))\"", "lemma oalist_inv_map2_val_raw:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n  assumes \"map2_val_compat' g\" and \"map2_val_compat' h\"\n  shows \"oalist_inv (map2_val_raw f g h xs ys)\"", "lemma lookup_raw_map2_val_raw:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n  assumes \"map2_val_compat' g\" and \"map2_val_compat' h\"\n  assumes \"\\<And>zs. oalist_inv zs \\<Longrightarrow> g zs = map_val_raw (\\<lambda>k v. f k v 0) zs\"\n    and \"\\<And>zs. oalist_inv zs \\<Longrightarrow> h zs = map_val_raw (\\<lambda>k. f k 0) zs\"\n    and \"\\<And>k. f k 0 0 = 0\"\n  shows \"lookup_raw (map2_val_raw f g h xs ys) k0 = f k0 (lookup_raw xs k0) (lookup_raw ys k0)\"", "lemma map2_val_raw_singleton_eq_update_by_fun_raw:\n  assumes \"oalist_inv xs\"\n  assumes \"\\<And>k x. f k x 0 = x\" and \"\\<And>zs. oalist_inv zs \\<Longrightarrow> g zs = zs\"\n    and \"\\<And>ko. h ([(k, v)], ko) = map_val_raw (\\<lambda>k. f k 0) ([(k, v)], ko)\"\n  shows \"map2_val_raw f g h xs ([(k, v)], ko) = update_by_fun_raw k (\\<lambda>x. f k x v) xs\"", "lemma lex_ord_raw_EqI:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n    and \"\\<And>k. k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys) \\<Longrightarrow> f k (lookup_raw xs k) (lookup_raw ys k) = Some Eq\"\n  shows \"lex_ord_raw ko f xs ys = Some Eq\"", "lemma lex_ord_raw_valI:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\" and \"aux \\<noteq> Some Eq\"\n  assumes \"k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\" and \"aux = f k (lookup_raw xs k) (lookup_raw ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys) \\<Longrightarrow> lt ko k' k \\<Longrightarrow>\n              f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq\"\n  shows \"lex_ord_raw ko f xs ys = aux\"", "lemma lex_ord_raw_EqD:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\" and \"lex_ord_raw ko f xs ys = Some Eq\"\n    and \"k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\"\n  shows \"f k (lookup_raw xs k) (lookup_raw ys k) = Some Eq\"", "lemma lex_ord_raw_valE:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\" and \"lex_ord_raw ko f xs ys = aux\"\n    and \"aux \\<noteq> Some Eq\"\n  obtains k where \"k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\"\n    and \"aux = f k (lookup_raw xs k) (lookup_raw ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys) \\<Longrightarrow> lt ko k' k \\<Longrightarrow>\n            f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq\"", "lemma prod_ord_rawI:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n    and \"\\<And>k. k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys) \\<Longrightarrow> P k (lookup_raw xs k) (lookup_raw ys k)\"\n  shows \"prod_ord_raw P xs ys\"", "lemma prod_ord_rawD:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\" and \"prod_ord_raw P xs ys\"\n    and \"k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\"\n  shows \"P k (lookup_raw xs k) (lookup_raw ys k)\"", "lemma oalist_eq_rawI:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n    and \"\\<And>k. k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys) \\<Longrightarrow> lookup_raw xs k = lookup_raw ys k\"\n  shows \"oalist_eq_raw xs ys\"", "lemma oalist_eq_rawD:\n  assumes \"oalist_inv ys\" and \"oalist_eq_raw xs ys\"\n  shows \"lookup_raw xs = lookup_raw ys\"", "lemma oalist_eq_raw_alt:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n  shows \"oalist_eq_raw xs ys \\<longleftrightarrow> (lookup_raw xs = lookup_raw ys)\"", "lemma oalist_inv_sort_oalist_raw: \"oalist_inv (sort_oalist_raw xs)\"", "lemma sort_oalist_raw_id:\n  assumes \"oalist_inv xs\"\n  shows \"sort_oalist_raw xs = xs\"", "lemma set_sort_oalist_raw:\n  assumes \"distinct (map fst (fst xs))\"\n  shows \"set (fst (sort_oalist_raw xs)) = {kv. kv \\<in> set (fst xs) \\<and> snd kv \\<noteq> 0}\"", "lemma list_of_oalist_of_list_id:\n  assumes \"oalist_inv xs\"\n  shows \"list_of_oalist (oalist_of_list xs) = xs\"", "lemma zero_notin_list_of_oalist: \"0 \\<notin> snd ` set (fst (list_of_oalist xs))\"", "lemma list_of_oalist_sorted: \"sorted_wrt (lt (snd (list_of_oalist xs))) (map fst (fst (list_of_oalist xs)))\"", "lemma lookup_eq_value: \"v \\<noteq> 0 \\<Longrightarrow> lookup xs k = v \\<longleftrightarrow> ((k, v) \\<in> set (fst (list_of_oalist xs)))\"", "lemma lookup_eq_valueI: \"(k, v) \\<in> set (fst (list_of_oalist xs)) \\<Longrightarrow> lookup xs k = v\"", "lemma lookup_oalist_of_list:\n  \"distinct (map fst xs) \\<Longrightarrow> lookup (oalist_of_list (xs, ko)) = lookup_dflt xs\"", "lemma set_sorted_domain: \"set (sorted_domain ko xs) = fst ` set (fst (list_of_oalist xs))\"", "lemma in_sorted_domain_iff_lookup: \"k \\<in> set (sorted_domain ko xs) \\<longleftrightarrow> (lookup xs k \\<noteq> 0)\"", "lemma sorted_sorted_domain: \"sorted_wrt (lt ko) (sorted_domain ko xs)\"", "lemma list_of_oalist_empty [simp, code abstract]: \"list_of_oalist (empty ko) = ([], ko)\"", "lemma lookup_empty: \"lookup (empty ko) k = 0\"", "lemma lookup_oalist_of_list_single:\n  \"lookup (oalist_of_list ([(k, v)], ko)) k' = (if k = k' then v else 0)\"", "lemma list_of_oalist_reorder [simp, code abstract]:\n  \"list_of_oalist (reorder ko xs) = (sort_oalist_aux ko (list_of_oalist xs), ko)\"", "lemma lookup_reorder: \"lookup (reorder ko xs) k = lookup xs k\"", "lemma list_of_oalist_tl [simp, code abstract]: \"list_of_oalist (tl xs) = tl_raw (list_of_oalist xs)\"", "lemma lookup_tl:\n  \"lookup (tl xs) k =\n        (if (\\<forall>k'\\<in>fst ` set (fst (list_of_oalist xs)). le (snd (list_of_oalist xs)) k k') then 0 else lookup xs k)\"", "lemma hd_in:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"hd xs \\<in> set (fst (list_of_oalist xs))\"", "lemma snd_hd:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"snd (hd xs) = lookup xs (fst (hd xs))\"", "lemma lookup_tl': \"lookup (tl xs) k = (if k = fst (hd xs) then 0 else lookup xs k)\"", "lemma hd_tl:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"list_of_oalist xs = ((hd xs) # (fst (list_of_oalist (tl xs))), snd (list_of_oalist (tl xs)))\"", "lemma min_key_val_alt:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"min_key_val ko xs = hd (reorder ko xs)\"", "lemma min_key_val_in:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"min_key_val ko xs \\<in> set (fst (list_of_oalist xs))\"", "lemma snd_min_key_val:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"snd (min_key_val ko xs) = lookup xs (fst (min_key_val ko xs))\"", "lemma min_key_val_minimal:\n  assumes \"z \\<in> set (fst (list_of_oalist xs))\"\n  shows \"le ko (fst (min_key_val ko xs)) (fst z)\"", "lemma list_of_oalist_except_min [simp, code abstract]:\n  \"list_of_oalist (except_min ko xs) = (List.tl (sort_oalist_aux ko (list_of_oalist xs)), ko)\"", "lemma except_min_Nil:\n  assumes \"fst (list_of_oalist xs) = []\"\n  shows \"fst (list_of_oalist (except_min ko xs)) = []\"", "lemma lookup_except_min:\n  \"lookup (except_min ko xs) k =\n        (if (\\<forall>k'\\<in>fst ` set (fst (list_of_oalist xs)). le ko k k') then 0 else lookup xs k)\"", "lemma lookup_except_min':\n  \"lookup (except_min ko xs) k = (if k = fst (min_key_val ko xs) then 0 else lookup xs k)\"", "lemma list_of_oalist_insert [simp, code abstract]:\n  \"list_of_oalist (insert x xs) = update_by_raw x (list_of_oalist xs)\"", "lemma lookup_insert: \"lookup (insert (k, v) xs) k' = (if k = k' then v else lookup xs k')\"", "lemma list_of_oalist_update_by_fun [simp, code abstract]:\n  \"list_of_oalist (update_by_fun k f xs) = update_by_fun_raw k f (list_of_oalist xs)\"", "lemma lookup_update_by_fun:\n  \"lookup (update_by_fun k f xs) k' = (if k = k' then f else id) (lookup xs k')\"", "lemma list_of_oalist_update_by_fun_gr [simp, code abstract]:\n  \"list_of_oalist (update_by_fun_gr k f xs) = update_by_fun_gr_raw k f (list_of_oalist xs)\"", "lemma update_by_fun_gr_eq_update_by_fun: \"update_by_fun_gr = update_by_fun\"", "lemma list_of_oalist_filter [simp, code abstract]:\n  \"list_of_oalist (filter P xs) = filter_raw P (list_of_oalist xs)\"", "lemma lookup_filter: \"lookup (filter P xs) k = (let v = lookup xs k in if P (k, v) then v else 0)\"", "lemma list_of_oalist_map2_val_neutr [simp, code abstract]:\n  \"list_of_oalist (map2_val_neutr f xs ys) = map2_val_raw f id id (list_of_oalist xs) (list_of_oalist ys)\"", "lemma lookup_map2_val_neutr:\n  assumes \"\\<And>k x. f k x 0 = x\" and \"\\<And>k x. f k 0 x = x\"\n  shows \"lookup (map2_val_neutr f xs ys) k = f k (lookup xs k) (lookup ys k)\"", "lemma oalist_eq_alt: \"oalist_eq xs ys \\<longleftrightarrow> (lookup xs = lookup ys)\"", "lemma map_val_cong:\n  assumes \"\\<And>k v. (k, v) \\<in> set (fst (list_of_oalistx xs)) \\<Longrightarrow> f k v = g k v\"\n  shows \"map_val f xs = map_val g xs\"", "lemma list_of_oalist_map_val [simp, code abstract]:\n  \"list_of_oalisty (map_val f xs) = map_val_raw f (list_of_oalistx xs)\"", "lemma lookup_map_val: \"f k 0 = 0 \\<Longrightarrow> oay.lookup (map_val f xs) k = f k (lookup xs k)\"", "lemma list_of_oalist_map2_val [simp, code abstract]:\n  \"list_of_oalistz (map2_val f xs ys) =\n      map2_val_raw f (map_val_raw (\\<lambda>k b. f k b 0)) (map_val_raw (\\<lambda>k. f k 0)) (list_of_oalistx xs) (list_of_oalisty ys)\"", "lemma list_of_oalist_map2_val_rneutr [simp, code abstract]:\n  \"list_of_oalistx (map2_val_rneutr f xs ys) =\n      map2_val_raw f id (map_val_raw (\\<lambda>k c. f k 0 c)) (list_of_oalistx xs) (list_of_oalisty ys)\"", "lemma lookup_map2_val:\n  assumes \"\\<And>k. f k 0 0 = 0\"\n  shows \"oaz.lookup (map2_val f xs ys) k = f k (lookup xs k) (oay.lookup ys k)\"", "lemma lookup_map2_val_rneutr:\n  assumes \"\\<And>k x. f k x 0 = x\"\n  shows \"lookup (map2_val_rneutr f xs ys) k = f k (lookup xs k) (oay.lookup ys k)\"", "lemma map2_val_rneutr_singleton_eq_update_by_fun:\n  assumes \"\\<And>a x. f a x 0 = x\" and \"list_of_oalisty ys = ([(k, v)], oy)\"\n  shows \"map2_val_rneutr f xs ys = update_by_fun k (\\<lambda>x. f k x v) xs\"", "lemma lex_ord_EqI:\n  \"(\\<And>k. k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)) \\<Longrightarrow>\n     f k (lookup xs k) (oay.lookup ys k) = Some Eq) \\<Longrightarrow>\n  lex_ord ko f xs ys = Some Eq\"", "lemma lex_ord_valI:\n  assumes \"aux \\<noteq> Some Eq\" and \"k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys))\"\n  shows \"aux = f k (lookup xs k) (oay.lookup ys k) \\<Longrightarrow>\n         (\\<And>k'. k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)) \\<Longrightarrow>\n              lt ko k' k \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') = Some Eq) \\<Longrightarrow>\n          lex_ord ko f xs ys = aux\"", "lemma lex_ord_EqD:\n  \"lex_ord ko f xs ys = Some Eq \\<Longrightarrow>\n   k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)) \\<Longrightarrow>\n   f k (lookup xs k) (oay.lookup ys k) = Some Eq\"", "lemma lex_ord_valE:\n  assumes \"lex_ord ko f xs ys = aux\" and \"aux \\<noteq> Some Eq\"\n  obtains k where \"k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys))\"\n    and \"aux = f k (lookup xs k) (oay.lookup ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)) \\<Longrightarrow>\n            lt ko k' k \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') = Some Eq\"", "lemma prod_ord_alt:\n  \"prod_ord P xs ys \\<longleftrightarrow>\n                  (\\<forall>k\\<in>fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)).\n                      P k (lookup xs k) (oay.lookup ys k))\"", "lemma ko_le: \"ko.le = le_of_key_order\"", "lemma oalist_eq_iff: \"xs = ys \\<longleftrightarrow> list_of_oalist xs = list_of_oalist ys\"", "lemma oalist_eqI: \"list_of_oalist xs = list_of_oalist ys \\<Longrightarrow> xs = ys\"", "lemma oalist_inv_list_of_oalist: \"ko.oalist_inv (list_of_oalist xs)\"", "lemma list_of_oalist_OAlist: \"list_of_oalist (OAlist xs) = sort_oalist_ko xs\"", "lemma OAlist_list_of_oalist [code abstype]: \"OAlist (list_of_oalist xs) = xs\"", "lemma [code abstract]: \"list_of_oalist (oalist_of_list xs) = sort_oalist_ko xs\"", "lemmas OAlist_lookup_single = oa.lookup_oalist_of_list_single[folded oalist_of_list_def]", "lemma tc_le_lt [simp]: \"tc.le = (\\<le>)\" \"tc.lt = (<)\"", "lemma oalist_tc_eq_iff: \"xs = ys \\<longleftrightarrow> list_of_oalist_tc xs = list_of_oalist_tc ys\"", "lemma oalist_tc_eqI: \"list_of_oalist_tc xs = list_of_oalist_tc ys \\<Longrightarrow> xs = ys\"", "lemma oalist_inv_list_of_oalist_tc: \"tc.oalist_inv_raw (list_of_oalist_tc xs)\"", "lemma list_of_oalist_OAlist_tc: \"list_of_oalist_tc (OAlist_tc xs) = sort_oalist_tc xs\"", "lemma OAlist_list_of_oalist_tc [code abstype]: \"OAlist_tc (list_of_oalist_tc xs) = xs\"", "lemma list_of_oalist_tc_of_list [code abstract]: \"list_of_oalist_tc (oalist_tc_of_list xs) = sort_oalist_tc xs\"", "lemma list_of_oalist_tc_of_list_id:\n  assumes \"tc.oalist_inv_raw xs\"\n  shows \"list_of_oalist_tc (OAlist_tc xs) = xs\"", "lemma OAlist_tc_lookup_eq_valueI: \"(k, v) \\<in> set (list_of_oalist_tc xs) \\<Longrightarrow> OAlist_tc_lookup xs k = v\"", "lemma OAlist_tc_lookup_inj: \"OAlist_tc_lookup xs = OAlist_tc_lookup ys \\<Longrightarrow> xs = ys\"", "lemma OAlist_tc_lookup_oalist_of_list:\n  \"distinct (map fst xs) \\<Longrightarrow> OAlist_tc_lookup (oalist_tc_of_list xs) = lookup_dflt xs\"", "lemma set_OAlist_tc_sorted_domain: \"set (OAlist_tc_sorted_domain xs) = fst ` set (list_of_oalist_tc xs)\"", "lemma in_OAlist_tc_sorted_domain_iff_lookup: \"k \\<in> set (OAlist_tc_sorted_domain xs) \\<longleftrightarrow> (OAlist_tc_lookup xs k \\<noteq> 0)\"", "lemma sorted_OAlist_tc_sorted_domain: \"sorted_wrt (<) (OAlist_tc_sorted_domain xs)\"", "lemma list_of_oalist_OAlist_tc_empty [simp, code abstract]: \"list_of_oalist_tc OAlist_tc_empty = []\"", "lemma lookup_OAlist_tc_empty: \"OAlist_tc_lookup OAlist_tc_empty k = 0\"", "lemma OAlist_tc_lookup_single:\n  \"OAlist_tc_lookup (oalist_tc_of_list [(k, v)]) k' = (if k = k' then v else 0)\"", "lemma list_of_oalist_OAlist_tc_except_min [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_except_min xs) = tl (list_of_oalist_tc xs)\"", "lemma lookup_OAlist_tc_except_min:\n  \"OAlist_tc_lookup (OAlist_tc_except_min xs) k =\n        (if (\\<forall>k'\\<in>fst ` set (list_of_oalist_tc xs). k \\<le> k') then 0 else OAlist_tc_lookup xs k)\"", "lemma OAlist_tc_min_key_val_in:\n  assumes \"list_of_oalist_tc xs \\<noteq> []\"\n  shows \"OAlist_tc_min_key_val xs \\<in> set (list_of_oalist_tc xs)\"", "lemma snd_OAlist_tc_min_key_val:\n  assumes \"list_of_oalist_tc xs \\<noteq> []\"\n  shows \"snd (OAlist_tc_min_key_val xs) = OAlist_tc_lookup xs (fst (OAlist_tc_min_key_val xs))\"", "lemma OAlist_tc_min_key_val_minimal:\n  assumes \"z \\<in> set (list_of_oalist_tc xs)\"\n  shows \"fst (OAlist_tc_min_key_val xs) \\<le> fst z\"", "lemma list_of_oalist_OAlist_tc_insert [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_insert x xs) = update_by_pair_tc x (list_of_oalist_tc xs)\"", "lemma lookup_OAlist_tc_insert: \"OAlist_tc_lookup (OAlist_tc_insert (k, v) xs) k' = (if k = k' then v else OAlist_tc_lookup xs k')\"", "lemma list_of_oalist_OAlist_tc_update_by_fun [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_update_by_fun k f xs) = update_by_fun_pair_tc k f (list_of_oalist_tc xs)\"", "lemma lookup_OAlist_tc_update_by_fun:\n  \"OAlist_tc_lookup (OAlist_tc_update_by_fun k f xs) k' = (if k = k' then f else id) (OAlist_tc_lookup xs k')\"", "lemma list_of_oalist_OAlist_tc_update_by_fun_gr [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_update_by_fun_gr k f xs) = update_by_fun_gr_pair_tc k f (list_of_oalist_tc xs)\"", "lemma OAlist_tc_update_by_fun_gr_eq_OAlist_tc_update_by_fun: \"OAlist_tc_update_by_fun_gr = OAlist_tc_update_by_fun\"", "lemma list_of_oalist_OAlist_tc_filter [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_filter P xs) = filter P (list_of_oalist_tc xs)\"", "lemma lookup_OAlist_tc_filter: \"OAlist_tc_lookup (OAlist_tc_filter P xs) k = (let v = OAlist_tc_lookup xs k in if P (k, v) then v else 0)\"", "lemma list_of_oalist_OAlist_tc_map_val [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_map_val f xs) = map_val_pair f (list_of_oalist_tc xs)\"", "lemma OAlist_tc_map_val_cong:\n  assumes \"\\<And>k v. (k, v) \\<in> set (list_of_oalist_tc xs) \\<Longrightarrow> f k v = g k v\"\n  shows \"OAlist_tc_map_val f xs = OAlist_tc_map_val g xs\"", "lemma lookup_OAlist_tc_map_val: \"f k 0 = 0 \\<Longrightarrow> OAlist_tc_lookup (OAlist_tc_map_val f xs) k = f k (OAlist_tc_lookup xs k)\"", "lemma list_of_oalist_map2_val [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_map2_val f xs ys) =\n      map2_val_pair_tc f (map_val_pair (\\<lambda>k b. f k b 0)) (map_val_pair (\\<lambda>k. f k 0)) (list_of_oalist_tc xs) (list_of_oalist_tc ys)\"", "lemma list_of_oalist_OAlist_tc_map2_val_rneutr [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_map2_val_rneutr f xs ys) =\n      map2_val_pair_tc f id (map_val_pair (\\<lambda>k c. f k 0 c)) (list_of_oalist_tc xs) (list_of_oalist_tc ys)\"", "lemma list_of_oalist_OAlist_tc_map2_val_neutr [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_map2_val_neutr f xs ys) = map2_val_pair_tc f id id (list_of_oalist_tc xs) (list_of_oalist_tc ys)\"", "lemma lookup_OAlist_tc_map2_val:\n  assumes \"\\<And>k. f k 0 0 = 0\"\n  shows \"OAlist_tc_lookup (OAlist_tc_map2_val f xs ys) k = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\"", "lemma lookup_OAlist_tc_map2_val_rneutr:\n  assumes \"\\<And>k x. f k x 0 = x\"\n  shows \"OAlist_tc_lookup (OAlist_tc_map2_val_rneutr f xs ys) k = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\"", "lemma lookup_OAlist_tc_map2_val_neutr:\n  assumes \"\\<And>k x. f k x 0 = x\" and \"\\<And>k x. f k 0 x = x\"\n  shows \"OAlist_tc_lookup (OAlist_tc_map2_val_neutr f xs ys) k = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\"", "lemma OAlist_tc_map2_val_rneutr_singleton_eq_OAlist_tc_update_by_fun:\n  assumes \"\\<And>a x. f a x 0 = x\" and \"list_of_oalist_tc ys = [(k, v)]\"\n  shows \"OAlist_tc_map2_val_rneutr f xs ys = OAlist_tc_update_by_fun k (\\<lambda>x. f k x v) xs\"", "lemma OAlist_tc_lex_ord_EqI:\n  \"(\\<And>k. k \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys) \\<Longrightarrow>\n     f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k) = Some Eq) \\<Longrightarrow>\n  OAlist_tc_lex_ord f xs ys = Some Eq\"", "lemma OAlist_tc_lex_ord_valI:\n  assumes \"aux \\<noteq> Some Eq\" and \"k \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys)\"\n  shows \"aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k) \\<Longrightarrow>\n         (\\<And>k'. k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys) \\<Longrightarrow>\n              k' < k \\<Longrightarrow> f k' (OAlist_tc_lookup xs k') (OAlist_tc_lookup ys k') = Some Eq) \\<Longrightarrow>\n          OAlist_tc_lex_ord f xs ys = aux\"", "lemma OAlist_tc_lex_ord_EqD:\n  \"OAlist_tc_lex_ord f xs ys = Some Eq \\<Longrightarrow>\n   k \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys) \\<Longrightarrow>\n   f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k) = Some Eq\"", "lemma OAlist_tc_lex_ord_valE:\n  assumes \"OAlist_tc_lex_ord f xs ys = aux\" and \"aux \\<noteq> Some Eq\"\n  obtains k where \"k \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys)\"\n    and \"aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys) \\<Longrightarrow>\n            k' < k \\<Longrightarrow> f k' (OAlist_tc_lookup xs k') (OAlist_tc_lookup ys k') = Some Eq\"", "lemma OAlist_tc_prod_ord_alt:\n  \"OAlist_tc_prod_ord P xs ys \\<longleftrightarrow>\n                  (\\<forall>k\\<in>fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys).\n                      P k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k))\"", "lemma \"oalist_tc_of_list [(0::nat, 4::nat), (1, 3), (0, 2), (1, 1)] = oalist_tc_of_list [(0, 4), (1, 3)]\"", "lemma \"OAlist_tc_except_min (oalist_tc_of_list ([(1, 3), (0::nat, 4::nat), (0, 2), (1, 1)])) = oalist_tc_of_list [(1, 3)]\"", "lemma \"OAlist_tc_min_key_val (oalist_tc_of_list [(1, 3), (0::nat, 4::nat), (0, 2), (1, 1)]) = (0, 4)\"", "lemma \"OAlist_tc_lookup (oalist_tc_of_list [(0::nat, 4::nat), (1, 3), (0, 2), (1, 1)]) 1 = 3\"", "lemma \"OAlist_tc_prod_ord (\\<lambda>_. greater_eq)\n                (oalist_tc_of_list [(1, 4), (0::nat, 4::nat), (1, 3), (0, 2), (3, 1)])\n                (oalist_tc_of_list [(0, 4), (1, 3), (2, 2), (1, 1)]) = False\"", "lemma \"OAlist_tc_map2_val_rneutr (\\<lambda>_. minus)\n                (oalist_tc_of_list [(1, 4), (0::nat, 4::int), (1, 3), (0, 2), (3, 1)])\n                (oalist_tc_of_list [(0, 4), (1, 3), (2, 2), (1, 1)]) =\n             oalist_tc_of_list [(1, 1), (2, - 2), (3, 1)]\""], "translations": [["", "lemma min_list_param_in:\n  assumes \"xs \\<noteq> []\"\n  shows \"min_list_param rel xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_list_param rel xs \\<in> set xs", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. min_list_param rel xs \\<in> set xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow> min_list_param rel [] \\<in> set []\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                min_list_param rel xs \\<in> set xs;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (a # xs) \\<in> set (a # xs)", "case Nil"], ["proof (state)\nthis:\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow> min_list_param rel [] \\<in> set []\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                min_list_param rel xs \\<in> set xs;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (a # xs) \\<in> set (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. min_list_param rel [] \\<in> set []", "by simp"], ["proof (state)\nthis:\n  min_list_param rel [] \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                min_list_param rel xs \\<in> set xs;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (a # xs) \\<in> set (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                min_list_param rel xs \\<in> set xs;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (a # xs) \\<in> set (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<Longrightarrow> min_list_param rel xs \\<in> set xs\n  x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                min_list_param rel xs \\<in> set xs;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (a # xs) \\<in> set (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_list_param rel (x # xs) \\<in> set (x # xs)", "proof (simp add: min_list_param.simps[of rel x xs] Let_def del: min_list_param.simps set_simps(2) split: list.split,\n        intro conjI impI allI, simp, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (x21 # x22)\n                         \\<in> set (x # x21 # x22)", "fix y ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (x21 # x22)\n                         \\<in> set (x # x21 # x22)", "assume xs: \"xs = y # ys\""], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (x21 # x22)\n                         \\<in> set (x # x21 # x22)", "have \"min_list_param rel (y # ys) = min_list_param rel xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_list_param rel (y # ys) = min_list_param rel xs", "by (simp only: xs)"], ["proof (state)\nthis:\n  min_list_param rel (y # ys) = min_list_param rel xs\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (x21 # x22)\n                         \\<in> set (x # x21 # x22)", "also"], ["proof (state)\nthis:\n  min_list_param rel (y # ys) = min_list_param rel xs\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (x21 # x22)\n                         \\<in> set (x # x21 # x22)", "have \"... \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_list_param rel xs \\<in> set xs", "by (rule Cons(1), simp add: xs)"], ["proof (state)\nthis:\n  min_list_param rel xs \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (x21 # x22)\n                         \\<in> set (x # x21 # x22)", "also"], ["proof (state)\nthis:\n  min_list_param rel xs \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (x21 # x22)\n                         \\<in> set (x # x21 # x22)", "have \"... \\<subseteq> set (x # y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set (x # y # ys)", "by (auto simp: xs)"], ["proof (state)\nthis:\n  set xs \\<subseteq> set (x # y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> min_list_param rel (x21 # x22)\n                         \\<in> set (x # x21 # x22)", "finally"], ["proof (chain)\npicking this:\n  min_list_param rel (y # ys) \\<in> set (x # y # ys)", "show \"min_list_param rel (y # ys) \\<in> set (x # y # ys)\""], ["proof (prove)\nusing this:\n  min_list_param rel (y # ys) \\<in> set (x # y # ys)\n\ngoal (1 subgoal):\n 1. min_list_param rel (y # ys) \\<in> set (x # y # ys)", "."], ["proof (state)\nthis:\n  min_list_param rel (y # ys) \\<in> set (x # y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min_list_param rel (x # xs) \\<in> set (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_list_param_minimal:\n  assumes \"transp rel\" and \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set xs \\<Longrightarrow> rel x y \\<or> rel y x\"\n    and \"z \\<in> set xs\"\n  shows \"rel (min_list_param rel xs) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel (min_list_param rel xs) z", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; ?y \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel (min_list_param rel xs) z", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x y.\n                \\<lbrakk>x \\<in> set []; y \\<in> set []\\<rbrakk>\n                \\<Longrightarrow> rel x y \\<or> rel y x;\n     z \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> rel (min_list_param rel []) z\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x y.\n                            \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n                            \\<Longrightarrow> rel x y \\<or> rel y x;\n                 z \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> rel (min_list_param rel xs) z;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (a # xs); y \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> rel x y \\<or> rel y x;\n        z \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (a # xs)) z", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set []; ?y \\<in> set []\\<rbrakk>\n  \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  z \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x y.\n                \\<lbrakk>x \\<in> set []; y \\<in> set []\\<rbrakk>\n                \\<Longrightarrow> rel x y \\<or> rel y x;\n     z \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> rel (min_list_param rel []) z\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x y.\n                            \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n                            \\<Longrightarrow> rel x y \\<or> rel y x;\n                 z \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> rel (min_list_param rel xs) z;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (a # xs); y \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> rel x y \\<or> rel y x;\n        z \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (a # xs)) z", "from Nil(2)"], ["proof (chain)\npicking this:\n  z \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  z \\<in> set []\n\ngoal (1 subgoal):\n 1. rel (min_list_param rel []) z", "by simp"], ["proof (state)\nthis:\n  rel (min_list_param rel []) z\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x y.\n                            \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n                            \\<Longrightarrow> rel x y \\<or> rel y x;\n                 z \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> rel (min_list_param rel xs) z;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (a # xs); y \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> rel x y \\<or> rel y x;\n        z \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (a # xs)) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x y.\n                            \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n                            \\<Longrightarrow> rel x y \\<or> rel y x;\n                 z \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> rel (min_list_param rel xs) z;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (a # xs); y \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> rel x y \\<or> rel y x;\n        z \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (a # xs)) z", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n              \\<Longrightarrow> rel x y \\<or> rel y x;\n   z \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> rel (min_list_param rel xs) z\n  \\<lbrakk>?x \\<in> set (x # xs); ?y \\<in> set (x # xs)\\<rbrakk>\n  \\<Longrightarrow> rel ?x ?y \\<or> rel ?y ?x\n  z \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x y.\n                            \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n                            \\<Longrightarrow> rel x y \\<or> rel y x;\n                 z \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> rel (min_list_param rel xs) z;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (a # xs); y \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> rel x y \\<or> rel y x;\n        z \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (a # xs)) z", "from Cons(3)"], ["proof (chain)\npicking this:\n  z \\<in> set (x # xs)", "have disj1: \"z = x \\<or> z \\<in> set xs\""], ["proof (prove)\nusing this:\n  z \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. z = x \\<or> z \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  z = x \\<or> z \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x y.\n                            \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n                            \\<Longrightarrow> rel x y \\<or> rel y x;\n                 z \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> rel (min_list_param rel xs) z;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (a # xs); y \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> rel x y \\<or> rel y x;\n        z \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (a # xs)) z", "have \"x \\<in> set (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (x # xs)", "by simp"], ["proof (state)\nthis:\n  x \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x y.\n                            \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n                            \\<Longrightarrow> rel x y \\<or> rel y x;\n                 z \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> rel (min_list_param rel xs) z;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (a # xs); y \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> rel x y \\<or> rel y x;\n        z \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (a # xs)) z", "hence disj2: \"rel x z \\<or> rel z x\""], ["proof (prove)\nusing this:\n  x \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. rel x z \\<or> rel z x", "using Cons(3)"], ["proof (prove)\nusing this:\n  x \\<in> set (x # xs)\n  z \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. rel x z \\<or> rel z x", "by (rule Cons(2))"], ["proof (state)\nthis:\n  rel x z \\<or> rel z x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x y.\n                            \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n                            \\<Longrightarrow> rel x y \\<or> rel y x;\n                 z \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> rel (min_list_param rel xs) z;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (a # xs); y \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> rel x y \\<or> rel y x;\n        z \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (a # xs)) z", "have *: \"rel (min_list_param rel xs) z\" if \"z \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel (min_list_param rel xs) z", "using _ that"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel (min_list_param rel xs) z", "proof (rule Cons(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> rel x y \\<or> rel y x", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> rel x y \\<or> rel y x", "assume \"a \\<in> set xs\" and \"b \\<in> set xs\""], ["proof (state)\nthis:\n  a \\<in> set xs\n  b \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> rel x y \\<or> rel y x", "hence \"a \\<in> set (x # xs)\" and \"b \\<in> set (x # xs)\""], ["proof (prove)\nusing this:\n  a \\<in> set xs\n  b \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<in> set (x # xs) &&& b \\<in> set (x # xs)", "by simp_all"], ["proof (state)\nthis:\n  a \\<in> set (x # xs)\n  b \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> rel x y \\<or> rel y x", "thus \"rel a b \\<or> rel b a\""], ["proof (prove)\nusing this:\n  a \\<in> set (x # xs)\n  b \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. rel a b \\<or> rel b a", "by (rule Cons(2))"], ["proof (state)\nthis:\n  rel a b \\<or> rel b a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> set xs \\<Longrightarrow> rel (min_list_param rel xs) z\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x y.\n                            \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n                            \\<Longrightarrow> rel x y \\<or> rel y x;\n                 z \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> rel (min_list_param rel xs) z;\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (a # xs); y \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> rel x y \\<or> rel y x;\n        z \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (a # xs)) z", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel (min_list_param rel (x # xs)) z", "proof (simp add: min_list_param.simps[of rel x xs] Let_def del: min_list_param.simps set_simps(2) split: list.split,\n        intro conjI impI allI)"], ["proof (state)\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> rel x z\n 2. \\<And>x21 x22.\n       \\<lbrakk>rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel x z\n 3. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (x21 # x22)) z", "assume \"xs = []\""], ["proof (state)\nthis:\n  xs = []\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> rel x z\n 2. \\<And>x21 x22.\n       \\<lbrakk>rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel x z\n 3. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (x21 # x22)) z", "with disj1 disj2"], ["proof (chain)\npicking this:\n  z = x \\<or> z \\<in> set xs\n  rel x z \\<or> rel z x\n  xs = []", "show \"rel x z\""], ["proof (prove)\nusing this:\n  z = x \\<or> z \\<in> set xs\n  rel x z \\<or> rel z x\n  xs = []\n\ngoal (1 subgoal):\n 1. rel x z", "by simp"], ["proof (state)\nthis:\n  rel x z\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel x z\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (x21 # x22)) z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel x z\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (x21 # x22)) z", "fix y ys"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel x z\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (x21 # x22)) z", "assume \"xs = y # ys\" and \"rel x (min_list_param rel (y # ys))\""], ["proof (state)\nthis:\n  xs = y # ys\n  rel x (min_list_param rel (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel x z\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (x21 # x22)) z", "hence \"rel x (min_list_param rel xs)\""], ["proof (prove)\nusing this:\n  xs = y # ys\n  rel x (min_list_param rel (y # ys))\n\ngoal (1 subgoal):\n 1. rel x (min_list_param rel xs)", "by simp"], ["proof (state)\nthis:\n  rel x (min_list_param rel xs)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel x z\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (x21 # x22)) z", "from disj1"], ["proof (chain)\npicking this:\n  z = x \\<or> z \\<in> set xs", "show \"rel x z\""], ["proof (prove)\nusing this:\n  z = x \\<or> z \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel x z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel x z\n 2. z \\<in> set xs \\<Longrightarrow> rel x z", "assume \"z = x\""], ["proof (state)\nthis:\n  z = x\n\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel x z\n 2. z \\<in> set xs \\<Longrightarrow> rel x z", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = x\n\ngoal (1 subgoal):\n 1. rel x z", "using disj2"], ["proof (prove)\nusing this:\n  z = x\n  rel x z \\<or> rel z x\n\ngoal (1 subgoal):\n 1. rel x z", "by simp"], ["proof (state)\nthis:\n  rel x z\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<Longrightarrow> rel x z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<Longrightarrow> rel x z", "assume \"z \\<in> set xs\""], ["proof (state)\nthis:\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<Longrightarrow> rel x z", "hence \"rel (min_list_param rel xs) z\""], ["proof (prove)\nusing this:\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel (min_list_param rel xs) z", "by (rule *)"], ["proof (state)\nthis:\n  rel (min_list_param rel xs) z\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<Longrightarrow> rel x z", "with assms(1) \\<open>rel x (min_list_param rel xs)\\<close>"], ["proof (chain)\npicking this:\n  transp rel\n  rel x (min_list_param rel xs)\n  rel (min_list_param rel xs) z", "show ?thesis"], ["proof (prove)\nusing this:\n  transp rel\n  rel x (min_list_param rel xs)\n  rel (min_list_param rel xs) z\n\ngoal (1 subgoal):\n 1. rel x z", "by (rule transpD)"], ["proof (state)\nthis:\n  rel x z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel x z\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (x21 # x22)) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (x21 # x22)) z", "fix y ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (x21 # x22)) z", "assume xs: \"xs = y # ys\" and \"\\<not> rel x (min_list_param rel (y # ys))\""], ["proof (state)\nthis:\n  xs = y # ys\n  \\<not> rel x (min_list_param rel (y # ys))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> rel x (min_list_param rel (x21 # x22));\n        xs = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> rel (min_list_param rel (x21 # x22)) z", "from disj1"], ["proof (chain)\npicking this:\n  z = x \\<or> z \\<in> set xs", "show \"rel (min_list_param rel (y # ys)) z\""], ["proof (prove)\nusing this:\n  z = x \\<or> z \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel (min_list_param rel (y # ys)) z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel (min_list_param rel (y # ys)) z\n 2. z \\<in> set xs \\<Longrightarrow> rel (min_list_param rel (y # ys)) z", "assume \"z = x\""], ["proof (state)\nthis:\n  z = x\n\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel (min_list_param rel (y # ys)) z\n 2. z \\<in> set xs \\<Longrightarrow> rel (min_list_param rel (y # ys)) z", "have \"min_list_param rel (y # ys) \\<in> set (y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_list_param rel (y # ys) \\<in> set (y # ys)", "by (rule min_list_param_in, simp)"], ["proof (state)\nthis:\n  min_list_param rel (y # ys) \\<in> set (y # ys)\n\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel (min_list_param rel (y # ys)) z\n 2. z \\<in> set xs \\<Longrightarrow> rel (min_list_param rel (y # ys)) z", "hence \"min_list_param rel (y # ys) \\<in> set (x # xs)\""], ["proof (prove)\nusing this:\n  min_list_param rel (y # ys) \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. min_list_param rel (y # ys) \\<in> set (x # xs)", "by (simp add: xs)"], ["proof (state)\nthis:\n  min_list_param rel (y # ys) \\<in> set (x # xs)\n\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel (min_list_param rel (y # ys)) z\n 2. z \\<in> set xs \\<Longrightarrow> rel (min_list_param rel (y # ys)) z", "with \\<open>x \\<in> set (x # xs)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set (x # xs)\n  min_list_param rel (y # ys) \\<in> set (x # xs)", "have \"rel x (min_list_param rel (y # ys)) \\<or> rel (min_list_param rel (y # ys)) x\""], ["proof (prove)\nusing this:\n  x \\<in> set (x # xs)\n  min_list_param rel (y # ys) \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. rel x (min_list_param rel (y # ys)) \\<or>\n    rel (min_list_param rel (y # ys)) x", "by (rule Cons(2))"], ["proof (state)\nthis:\n  rel x (min_list_param rel (y # ys)) \\<or>\n  rel (min_list_param rel (y # ys)) x\n\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel (min_list_param rel (y # ys)) z\n 2. z \\<in> set xs \\<Longrightarrow> rel (min_list_param rel (y # ys)) z", "with \\<open>\\<not> rel x (min_list_param rel (y # ys))\\<close>"], ["proof (chain)\npicking this:\n  \\<not> rel x (min_list_param rel (y # ys))\n  rel x (min_list_param rel (y # ys)) \\<or>\n  rel (min_list_param rel (y # ys)) x", "have \"rel (min_list_param rel (y # ys)) x\""], ["proof (prove)\nusing this:\n  \\<not> rel x (min_list_param rel (y # ys))\n  rel x (min_list_param rel (y # ys)) \\<or>\n  rel (min_list_param rel (y # ys)) x\n\ngoal (1 subgoal):\n 1. rel (min_list_param rel (y # ys)) x", "by simp"], ["proof (state)\nthis:\n  rel (min_list_param rel (y # ys)) x\n\ngoal (2 subgoals):\n 1. z = x \\<Longrightarrow> rel (min_list_param rel (y # ys)) z\n 2. z \\<in> set xs \\<Longrightarrow> rel (min_list_param rel (y # ys)) z", "thus ?thesis"], ["proof (prove)\nusing this:\n  rel (min_list_param rel (y # ys)) x\n\ngoal (1 subgoal):\n 1. rel (min_list_param rel (y # ys)) z", "by (simp only: \\<open>z = x\\<close>)"], ["proof (state)\nthis:\n  rel (min_list_param rel (y # ys)) z\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<Longrightarrow> rel (min_list_param rel (y # ys)) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<Longrightarrow> rel (min_list_param rel (y # ys)) z", "assume \"z \\<in> set xs\""], ["proof (state)\nthis:\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<Longrightarrow> rel (min_list_param rel (y # ys)) z", "hence \"rel (min_list_param rel xs) z\""], ["proof (prove)\nusing this:\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. rel (min_list_param rel xs) z", "by (rule *)"], ["proof (state)\nthis:\n  rel (min_list_param rel xs) z\n\ngoal (1 subgoal):\n 1. z \\<in> set xs \\<Longrightarrow> rel (min_list_param rel (y # ys)) z", "thus ?thesis"], ["proof (prove)\nusing this:\n  rel (min_list_param rel xs) z\n\ngoal (1 subgoal):\n 1. rel (min_list_param rel (y # ys)) z", "by (simp only: xs)"], ["proof (state)\nthis:\n  rel (min_list_param rel (y # ys)) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel (min_list_param rel (y # ys)) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel (min_list_param rel (x # xs)) z\n\ngoal:\nNo subgoals!", "qed"], ["", "definition comp_of_ord :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a comparator\" where\n  \"comp_of_ord le x y = (if le x y then if x = y then Eq else Lt else Gt)\""], ["", "lemma comp_of_ord_eq_comp_of_ords:\n  assumes \"antisymp le\"\n  shows \"comp_of_ord le = comp_of_ords le (\\<lambda>x y. le x y \\<and> \\<not> le y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_of_ord le =\n    comp_of_ords le (\\<lambda>x y. le x y \\<and> \\<not> le y x)", "by (intro ext, auto simp: comp_of_ord_def comp_of_ords_def intro: assms antisympD)"], ["", "lemma comparator_converse:\n  assumes \"comparator cmp\"\n  shows \"comparator (\\<lambda>x y. cmp y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. cmp y x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. cmp y x)", "from assms"], ["proof (chain)\npicking this:\n  comparator cmp", "interpret comp: comparator cmp"], ["proof (prove)\nusing this:\n  comparator cmp\n\ngoal (1 subgoal):\n 1. comparator cmp", "."], ["proof (state)\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. cmp y x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. cmp y x)", "by (unfold_locales, auto simp: comp.eq comp.sym intro: comp.trans)"], ["proof (state)\nthis:\n  comparator (\\<lambda>x y. cmp y x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comparator_composition:\n  assumes \"comparator cmp\" and \"inj f\"\n  shows \"comparator (\\<lambda>x y. cmp (f x) (f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. cmp (f x) (f y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. cmp (f x) (f y))", "from assms(1)"], ["proof (chain)\npicking this:\n  comparator cmp", "interpret comp: comparator cmp"], ["proof (prove)\nusing this:\n  comparator cmp\n\ngoal (1 subgoal):\n 1. comparator cmp", "."], ["proof (state)\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. cmp (f x) (f y))", "from assms(2)"], ["proof (chain)\npicking this:\n  inj f", "have *: \"x = y\" if \"f x = f y\" for x y"], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. x = y", "using that"], ["proof (prove)\nusing this:\n  inj f\n  f x = f y\n\ngoal (1 subgoal):\n 1. x = y", "by (rule injD)"], ["proof (state)\nthis:\n  f ?x1 = f ?y1 \\<Longrightarrow> ?x1 = ?y1\n\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. cmp (f x) (f y))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. cmp (f x) (f y))", "by (unfold_locales, auto simp: comp.sym comp.eq * intro: comp.trans)"], ["proof (state)\nthis:\n  comparator (\\<lambda>x y. cmp (f x) (f y))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nsubsection \\<open>Syntactic Type Class for Default Elements\\<close>\n\ntext \\<open>We do not want to use the existing type-class @{class default}, but instead introduce a new one:\\<close>\n\nclass oalist_dflt = fixes dflt::'a\n\nsimproc_setup reorient_dflt (\"dflt = x\") = Reorient_Proc.proc\n*)"], ["", "subsection \\<open>Type \\<open>key_order\\<close>\\<close>"], ["", "typedef 'a key_order = \"{compare :: 'a comparator. comparator compare}\"\n  morphisms key_compare Abs_key_order"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {compare. comparator compare}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {compare. comparator compare}", "from well_order_on"], ["proof (chain)\npicking this:\n  \\<exists>r. well_order_on ?A r", "obtain r where \"well_order_on (UNIV::'a set) r\""], ["proof (prove)\nusing this:\n  \\<exists>r. well_order_on ?A r\n\ngoal (1 subgoal):\n 1. (\\<And>r. well_order r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  well_order r\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {compare. comparator compare}", "hence \"linear_order r\""], ["proof (prove)\nusing this:\n  well_order r\n\ngoal (1 subgoal):\n 1. linear_order r", "by (simp only: well_order_on_def)"], ["proof (state)\nthis:\n  linear_order r\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {compare. comparator compare}", "hence lin: \"(x, y) \\<in> r \\<or> (y, x) \\<in> r\" for x y"], ["proof (prove)\nusing this:\n  linear_order r\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> r \\<or> (y, x) \\<in> r", "by (metis Diff_iff Linear_order_in_diff_Id UNIV_I \\<open>well_order r\\<close> well_order_on_Field)"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> r \\<or> (?y, ?x) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {compare. comparator compare}", "have antisym: \"(x, y) \\<in> r \\<Longrightarrow> (y, x) \\<in> r \\<Longrightarrow> x = y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> r; (y, x) \\<in> r\\<rbrakk> \\<Longrightarrow> x = y", "by (meson \\<open>linear_order r\\<close> antisymD linear_order_on_def partial_order_on_def)"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?y) \\<in> r; (?y, ?x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {compare. comparator compare}", "have trans: \"(x, y) \\<in> r \\<Longrightarrow> (y, z) \\<in> r \\<Longrightarrow> (x, z) \\<in> r\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n    \\<Longrightarrow> (x, z) \\<in> r", "by (meson \\<open>linear_order r\\<close> linear_order_on_def order_on_defs(1) partial_order_on_def trans_def)"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?y) \\<in> r; (?y, ?z) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {compare. comparator compare}", "define comp where \"comp = (\\<lambda>x y. if (x, y) \\<in> r then if (y, x) \\<in> r then Eq else Lt else Gt)\""], ["proof (state)\nthis:\n  comp =\n  (\\<lambda>x y.\n      if (x, y) \\<in> r then if (y, x) \\<in> r then Eq else Lt else Gt)\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {compare. comparator compare}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {compare. comparator compare}", "proof (rule, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. comparator ?x", "show \"comparator comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator comp", "proof (standard, simp_all add: comp_def split: if_splits, intro impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. (x, y) \\<notin> r \\<Longrightarrow> (y, x) \\<in> r\n 2. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "fix x y"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. (x, y) \\<notin> r \\<Longrightarrow> (y, x) \\<in> r\n 2. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "assume \"(x, y) \\<in> r\" and \"(y, x) \\<in> r\""], ["proof (state)\nthis:\n  (x, y) \\<in> r\n  (y, x) \\<in> r\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x, y) \\<notin> r \\<Longrightarrow> (y, x) \\<in> r\n 2. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "thus \"x = y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\n  (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. x = y", "by (rule antisym)"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<notin> r \\<Longrightarrow> (y, x) \\<in> r\n 2. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<notin> r \\<Longrightarrow> (y, x) \\<in> r\n 2. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<notin> r \\<Longrightarrow> (y, x) \\<in> r\n 2. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "assume \"(x, y) \\<notin> r\""], ["proof (state)\nthis:\n  (x, y) \\<notin> r\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x, y) \\<notin> r \\<Longrightarrow> (y, x) \\<in> r\n 2. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "with lin"], ["proof (chain)\npicking this:\n  (?x, ?y) \\<in> r \\<or> (?y, ?x) \\<in> r\n  (x, y) \\<notin> r", "show \"(y, x) \\<in> r\""], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> r \\<or> (?y, ?x) \\<in> r\n  (x, y) \\<notin> r\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "by blast"], ["proof (state)\nthis:\n  (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "assume \"(y, x) \\<notin> r\" and \"(z, y) \\<notin> r\""], ["proof (state)\nthis:\n  (y, x) \\<notin> r\n  (z, y) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "assume \"(x, y) \\<in> r\" and \"(y, z) \\<in> r\""], ["proof (state)\nthis:\n  (x, y) \\<in> r\n  (y, z) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "hence \"(x, z) \\<in> r\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\n  (y, z) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r", "by (rule trans)"], ["proof (state)\nthis:\n  (x, z) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "moreover"], ["proof (state)\nthis:\n  (x, z) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "have \"(z, x) \\<notin> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z, x) \\<notin> r", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (z, x) \\<in> r \\<Longrightarrow> False", "assume \"(z, x) \\<in> r\""], ["proof (state)\nthis:\n  (z, x) \\<in> r\n\ngoal (1 subgoal):\n 1. (z, x) \\<in> r \\<Longrightarrow> False", "with \\<open>(x, z) \\<in> r\\<close>"], ["proof (chain)\npicking this:\n  (x, z) \\<in> r\n  (z, x) \\<in> r", "have \"x = z\""], ["proof (prove)\nusing this:\n  (x, z) \\<in> r\n  (z, x) \\<in> r\n\ngoal (1 subgoal):\n 1. x = z", "by (rule antisym)"], ["proof (state)\nthis:\n  x = z\n\ngoal (1 subgoal):\n 1. (z, x) \\<in> r \\<Longrightarrow> False", "from \\<open>(z, y) \\<notin> r\\<close> \\<open>(x, y) \\<in> r\\<close>"], ["proof (chain)\npicking this:\n  (z, y) \\<notin> r\n  (x, y) \\<in> r", "show False"], ["proof (prove)\nusing this:\n  (z, y) \\<notin> r\n  (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. False", "unfolding \\<open>x = z\\<close>"], ["proof (prove)\nusing this:\n  (z, y) \\<notin> r\n  (z, y) \\<in> r\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (z, x) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, x) \\<notin> r; (y, z) \\<in> r;\n        (z, y) \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> (z, x) \\<notin> r \\<and>\n                         ((z, x) \\<notin> r \\<longrightarrow>\n                          (x, z) \\<in> r)", "ultimately"], ["proof (chain)\npicking this:\n  (x, z) \\<in> r\n  (z, x) \\<notin> r", "show \"(z, x) \\<notin> r \\<and> ((z, x) \\<notin> r \\<longrightarrow> (x, z) \\<in> r)\""], ["proof (prove)\nusing this:\n  (x, z) \\<in> r\n  (z, x) \\<notin> r\n\ngoal (1 subgoal):\n 1. (z, x) \\<notin> r \\<and>\n    ((z, x) \\<notin> r \\<longrightarrow> (x, z) \\<in> r)", "by simp"], ["proof (state)\nthis:\n  (z, x) \\<notin> r \\<and>\n  ((z, x) \\<notin> r \\<longrightarrow> (x, z) \\<in> r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comparator comp\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> {compare. comparator compare}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comparator_key_compare [simp, intro!]: \"comparator (key_compare ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (key_compare ko)", "using key_compare[of ko]"], ["proof (prove)\nusing this:\n  key_compare ko \\<in> {compare. comparator compare}\n\ngoal (1 subgoal):\n 1. comparator (key_compare ko)", "by simp"], ["", "instantiation key_order :: (type) equal\nbegin"], ["", "definition equal_key_order :: \"'a key_order \\<Rightarrow> 'a key_order \\<Rightarrow> bool\" where \"equal_key_order = (=)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a key_order, equal_class)", "by (standard, simp add: equal_key_order_def)"], ["", "end"], ["", "setup_lifting type_definition_key_order"], ["", "instantiation key_order :: (type) uminus\nbegin"], ["", "lift_definition uminus_key_order :: \"'a key_order \\<Rightarrow> 'a key_order\" is \"\\<lambda>c x y. c y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       comparator fun \\<Longrightarrow> comparator (\\<lambda>x y. fun y x)", "by (fact comparator_converse)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a key_order, uminus_class)", ".."], ["", "end"], ["", "lift_definition le_of_key_order :: \"'a key_order \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" is \"\\<lambda>cmp. le_of_comp cmp\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition lt_of_key_order :: \"'a key_order \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" is \"\\<lambda>cmp. lt_of_comp cmp\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition key_order_of_ord :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a key_order\"\n  where \"key_order_of_ord ord = Abs_key_order (comp_of_ord ord)\""], ["", "lift_definition key_order_of_le :: \"'a::linorder key_order\" is comparator_of"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator comparator_of", "by (fact comparator_of)"], ["", "interpretation key_order_lin: linorder \"le_of_key_order ko\" \"lt_of_key_order ko\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (le_of_key_order ko) (lt_of_key_order ko)", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ko.\n       comparator ko \\<Longrightarrow>\n       class.linorder (le_of_comp ko) (lt_of_comp ko)", "fix comp::\"'a comparator\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ko.\n       comparator ko \\<Longrightarrow>\n       class.linorder (le_of_comp ko) (lt_of_comp ko)", "assume \"comparator comp\""], ["proof (state)\nthis:\n  comparator comp\n\ngoal (1 subgoal):\n 1. \\<And>ko.\n       comparator ko \\<Longrightarrow>\n       class.linorder (le_of_comp ko) (lt_of_comp ko)", "then"], ["proof (chain)\npicking this:\n  comparator comp", "interpret comp: comparator comp"], ["proof (prove)\nusing this:\n  comparator comp\n\ngoal (1 subgoal):\n 1. comparator comp", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ko.\n       comparator ko \\<Longrightarrow>\n       class.linorder (le_of_comp ko) (lt_of_comp ko)", "show \"class.linorder comp.le comp.lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder comp.le comp.lt", "by (fact comp.linorder)"], ["proof (state)\nthis:\n  class.linorder comp.le comp.lt\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_of_key_order_alt: \"le_of_key_order ko x y = (key_compare ko x y \\<noteq> Gt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_of_key_order ko x y = (key_compare ko x y \\<noteq> Gt)", "by (transfer, simp add: comparator.nGt_le_conv)"], ["", "lemma lt_of_key_order_alt: \"lt_of_key_order ko x y = (key_compare ko x y = Lt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_of_key_order ko x y = (key_compare ko x y = Lt)", "by (transfer, meson comparator.Lt_lt_conv)"], ["", "lemma key_compare_Gt: \"key_compare ko x y = Gt \\<longleftrightarrow> key_compare ko y x = Lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (key_compare ko x y = Gt) = (key_compare ko y x = Lt)", "by (transfer, meson comparator.nGt_le_conv comparator.nLt_le_conv)"], ["", "lemma key_compare_Eq: \"key_compare ko x y = Eq \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (key_compare ko x y = Eq) = (x = y)", "by (transfer, simp add: comparator.eq)"], ["", "lemma key_compare_same [simp]: \"key_compare ko x x = Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_compare ko x x = Eq", "by (simp add: key_compare_Eq)"], ["", "lemma uminus_key_compare [simp]: \"invert_order (key_compare ko x y) = key_compare ko y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invert_order (key_compare ko x y) = key_compare ko y x", "by (transfer, simp add: comparator.sym)"], ["", "lemma key_compare_uminus [simp]: \"key_compare (- ko) x y = key_compare ko y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_compare (- ko) x y = key_compare ko y x", "by (transfer, rule refl)"], ["", "lemma uminus_key_order_sameD:\n  assumes \"- ko = (ko::'a key_order)\"\n  shows \"x = (y::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "hence \"key_compare ko x y \\<noteq> Eq\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. key_compare ko x y \\<noteq> Eq", "by (simp add: key_compare_Eq)"], ["proof (state)\nthis:\n  key_compare ko x y \\<noteq> Eq\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "hence \"key_compare ko x y \\<noteq> invert_order (key_compare ko x y)\""], ["proof (prove)\nusing this:\n  key_compare ko x y \\<noteq> Eq\n\ngoal (1 subgoal):\n 1. key_compare ko x y \\<noteq> invert_order (key_compare ko x y)", "by (metis invert_order.elims order.distinct(5))"], ["proof (state)\nthis:\n  key_compare ko x y \\<noteq> invert_order (key_compare ko x y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  key_compare ko x y \\<noteq> invert_order (key_compare ko x y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have \"invert_order (key_compare ko x y) = key_compare (- ko) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invert_order (key_compare ko x y) = key_compare (- ko) x y", "by simp"], ["proof (state)\nthis:\n  invert_order (key_compare ko x y) = key_compare (- ko) x y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  key_compare ko x y \\<noteq> key_compare (- ko) x y", "have \"- ko \\<noteq> ko\""], ["proof (prove)\nusing this:\n  key_compare ko x y \\<noteq> key_compare (- ko) x y\n\ngoal (1 subgoal):\n 1. - ko \\<noteq> ko", "by (auto simp del: key_compare_uminus)"], ["proof (state)\nthis:\n  - ko \\<noteq> ko\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  - ko \\<noteq> ko\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  - ko \\<noteq> ko\n  - ko = ko\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma key_compare_key_order_of_ord:\n  assumes \"antisymp ord\" and \"transp ord\" and \"\\<And>x y. ord x y \\<or> ord y x\"\n  shows \"key_compare (key_order_of_ord ord) = (\\<lambda>x y. if ord x y then if x = y then Eq else Lt else Gt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_compare (key_order_of_ord ord) =\n    (\\<lambda>x y. if ord x y then if x = y then Eq else Lt else Gt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. key_compare (key_order_of_ord ord) =\n    (\\<lambda>x y. if ord x y then if x = y then Eq else Lt else Gt)", "have eq: \"key_compare (key_order_of_ord ord) = comp_of_ord ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_compare (key_order_of_ord ord) = comp_of_ord ord", "unfolding key_order_of_ord_def comp_of_ord_eq_comp_of_ords[OF assms(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. key_compare\n     (Abs_key_order\n       (comp_of_ords ord (\\<lambda>x y. ord x y \\<and> \\<not> ord y x))) =\n    comp_of_ords ord (\\<lambda>x y. ord x y \\<and> \\<not> ord y x)", "proof (rule Abs_key_order_inverse, simp, rule comp_of_ords, unfold_locales)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       (ord x y \\<and> \\<not> ord y x) = (ord x y \\<and> \\<not> ord y x)\n 2. \\<And>x. ord x x\n 3. \\<And>x y z.\n       \\<lbrakk>ord x y; ord y z\\<rbrakk> \\<Longrightarrow> ord x z\n 4. \\<And>x y. \\<lbrakk>ord x y; ord y x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. ord x y \\<or> ord y x", "fix x"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       (ord x y \\<and> \\<not> ord y x) = (ord x y \\<and> \\<not> ord y x)\n 2. \\<And>x. ord x x\n 3. \\<And>x y z.\n       \\<lbrakk>ord x y; ord y z\\<rbrakk> \\<Longrightarrow> ord x z\n 4. \\<And>x y. \\<lbrakk>ord x y; ord y x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. ord x y \\<or> ord y x", "from assms(3)"], ["proof (chain)\npicking this:\n  ord ?x ?y \\<or> ord ?y ?x", "show \"ord x x\""], ["proof (prove)\nusing this:\n  ord ?x ?y \\<or> ord ?y ?x\n\ngoal (1 subgoal):\n 1. ord x x", "by blast"], ["proof (state)\nthis:\n  ord x x\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       (ord x y \\<and> \\<not> ord y x) = (ord x y \\<and> \\<not> ord y x)\n 2. \\<And>x y z.\n       \\<lbrakk>ord x y; ord y z\\<rbrakk> \\<Longrightarrow> ord x z\n 3. \\<And>x y. \\<lbrakk>ord x y; ord y x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. ord x y \\<or> ord y x", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       (ord x y \\<and> \\<not> ord y x) = (ord x y \\<and> \\<not> ord y x)\n 2. \\<And>x y z.\n       \\<lbrakk>ord x y; ord y z\\<rbrakk> \\<Longrightarrow> ord x z\n 3. \\<And>x y. \\<lbrakk>ord x y; ord y x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. ord x y \\<or> ord y x", "fix x y z"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       (ord x y \\<and> \\<not> ord y x) = (ord x y \\<and> \\<not> ord y x)\n 2. \\<And>x y z.\n       \\<lbrakk>ord x y; ord y z\\<rbrakk> \\<Longrightarrow> ord x z\n 3. \\<And>x y. \\<lbrakk>ord x y; ord y x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. ord x y \\<or> ord y x", "assume \"ord x y\" and \"ord y z\""], ["proof (state)\nthis:\n  ord x y\n  ord y z\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       (ord x y \\<and> \\<not> ord y x) = (ord x y \\<and> \\<not> ord y x)\n 2. \\<And>x y z.\n       \\<lbrakk>ord x y; ord y z\\<rbrakk> \\<Longrightarrow> ord x z\n 3. \\<And>x y. \\<lbrakk>ord x y; ord y x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. ord x y \\<or> ord y x", "with assms(2)"], ["proof (chain)\npicking this:\n  transp ord\n  ord x y\n  ord y z", "show \"ord x z\""], ["proof (prove)\nusing this:\n  transp ord\n  ord x y\n  ord y z\n\ngoal (1 subgoal):\n 1. ord x z", "by (rule transpD)"], ["proof (state)\nthis:\n  ord x z\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       (ord x y \\<and> \\<not> ord y x) = (ord x y \\<and> \\<not> ord y x)\n 2. \\<And>x y. \\<lbrakk>ord x y; ord y x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. ord x y \\<or> ord y x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       (ord x y \\<and> \\<not> ord y x) = (ord x y \\<and> \\<not> ord y x)\n 2. \\<And>x y. \\<lbrakk>ord x y; ord y x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. ord x y \\<or> ord y x", "fix x y"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       (ord x y \\<and> \\<not> ord y x) = (ord x y \\<and> \\<not> ord y x)\n 2. \\<And>x y. \\<lbrakk>ord x y; ord y x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. ord x y \\<or> ord y x", "assume \"ord x y\" and \"ord y x\""], ["proof (state)\nthis:\n  ord x y\n  ord y x\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       (ord x y \\<and> \\<not> ord y x) = (ord x y \\<and> \\<not> ord y x)\n 2. \\<And>x y. \\<lbrakk>ord x y; ord y x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. ord x y \\<or> ord y x", "with assms(1)"], ["proof (chain)\npicking this:\n  antisymp ord\n  ord x y\n  ord y x", "show \"x = y\""], ["proof (prove)\nusing this:\n  antisymp ord\n  ord x y\n  ord y x\n\ngoal (1 subgoal):\n 1. x = y", "by (rule antisympD)"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (ord x y \\<and> \\<not> ord y x) = (ord x y \\<and> \\<not> ord y x)\n 2. \\<And>x y. ord x y \\<or> ord y x", "qed (rule refl, rule assms(3))"], ["proof (state)\nthis:\n  key_compare (key_order_of_ord ord) = comp_of_ord ord\n\ngoal (1 subgoal):\n 1. key_compare (key_order_of_ord ord) =\n    (\\<lambda>x y. if ord x y then if x = y then Eq else Lt else Gt)", "have *: \"x = y\" if \"ord x y\" and \"ord y x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using assms(1) that"], ["proof (prove)\nusing this:\n  antisymp ord\n  ord x y\n  ord y x\n\ngoal (1 subgoal):\n 1. x = y", "by (rule antisympD)"], ["proof (state)\nthis:\n  \\<lbrakk>ord ?x ?y; ord ?y ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. key_compare (key_order_of_ord ord) =\n    (\\<lambda>x y. if ord x y then if x = y then Eq else Lt else Gt)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. key_compare (key_order_of_ord ord) =\n    (\\<lambda>x y. if ord x y then if x = y then Eq else Lt else Gt)", "by (rule, rule, auto simp: eq comp_of_ord_def intro: *)"], ["proof (state)\nthis:\n  key_compare (key_order_of_ord ord) =\n  (\\<lambda>x y. if ord x y then if x = y then Eq else Lt else Gt)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma key_compare_key_order_of_le:\n  \"key_compare key_order_of_le = (\\<lambda>x y. if x < y then Lt else if x = y then Eq else Gt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_compare key_order_of_le =\n    (\\<lambda>x y. if x < y then Lt else if x = y then Eq else Gt)", "by (transfer, intro ext, fact comparator_of_def)"], ["", "subsection \\<open>Invariant in Context @{locale comparator}\\<close>"], ["", "context comparator\nbegin"], ["", "definition oalist_inv_raw :: \"('a \\<times> 'b::zero) list \\<Rightarrow> bool\"\n  where \"oalist_inv_raw xs \\<longleftrightarrow> (0 \\<notin> snd ` set xs \\<and> sorted_wrt lt (map fst xs))\""], ["", "lemma oalist_inv_rawI:\n  assumes \"0 \\<notin> snd ` set xs\" and \"sorted_wrt lt (map fst xs)\"\n  shows \"oalist_inv_raw xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw xs", "unfolding oalist_inv_raw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs \\<and> sorted_wrt lt (map fst xs)", "using assms"], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set xs\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs \\<and> sorted_wrt lt (map fst xs)", "unfolding fst_conv snd_conv"], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set xs\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs \\<and> sorted_wrt lt (map fst xs)", "by blast"], ["", "lemma oalist_inv_rawD1:\n  assumes \"oalist_inv_raw xs\"\n  shows \"0 \\<notin> snd ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs", "unfolding oalist_inv_raw_def fst_conv"], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set xs \\<and> sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs", "by blast"], ["", "lemma oalist_inv_rawD2:\n  assumes \"oalist_inv_raw xs\"\n  shows \"sorted_wrt lt (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "unfolding oalist_inv_raw_def fst_conv snd_conv"], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set xs \\<and> sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "by blast"], ["", "lemma oalist_inv_raw_Nil: \"oalist_inv_raw []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw []", "by (simp add: oalist_inv_raw_def)"], ["", "lemma oalist_inv_raw_singleton: \"oalist_inv_raw [(k, v)] \\<longleftrightarrow> (v \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw [(k, v)] = (v \\<noteq> (0::'b))", "by (auto simp: oalist_inv_raw_def)"], ["", "lemma oalist_inv_raw_ConsI:\n  assumes \"oalist_inv_raw xs\" and \"v \\<noteq> 0\" and \"xs \\<noteq> [] \\<Longrightarrow> lt k (fst (hd xs))\"\n  shows \"oalist_inv_raw ((k, v) # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw ((k, v) # xs)", "proof (rule oalist_inv_rawI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'b) \\<notin> snd ` set ((k, v) # xs)\n 2. sorted_wrt lt (map fst ((k, v) # xs))", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"0 \\<notin> snd ` set xs\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs", "by (rule oalist_inv_rawD1)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (2 subgoals):\n 1. (0::'b) \\<notin> snd ` set ((k, v) # xs)\n 2. sorted_wrt lt (map fst ((k, v) # xs))", "with assms(2)"], ["proof (chain)\npicking this:\n  v \\<noteq> (0::'b)\n  (0::'b) \\<notin> snd ` set xs", "show \"0 \\<notin> snd ` set ((k, v) # xs)\""], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'b)\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set ((k, v) # xs)", "by simp"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set ((k, v) # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst ((k, v) # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst ((k, v) # xs))", "show \"sorted_wrt lt (map fst ((k, v) # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst ((k, v) # xs))", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sorted_wrt lt (map fst ((k, v) # xs))\n 2. xs \\<noteq> [] \\<Longrightarrow> sorted_wrt lt (map fst ((k, v) # xs))", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sorted_wrt lt (map fst ((k, v) # xs))\n 2. xs \\<noteq> [] \\<Longrightarrow> sorted_wrt lt (map fst ((k, v) # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst ((k, v) # xs))", "by simp"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst ((k, v) # xs))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> sorted_wrt lt (map fst ((k, v) # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> sorted_wrt lt (map fst ((k, v) # xs))", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> sorted_wrt lt (map fst ((k, v) # xs))", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain k' v' xs' where xs: \"xs = (k', v') # xs'\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k' v' xs'.\n        xs = (k', v') # xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.exhaust prod.exhaust)"], ["proof (state)\nthis:\n  xs = (k', v') # xs'\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> sorted_wrt lt (map fst ((k, v) # xs))", "from assms(3)[OF False]"], ["proof (chain)\npicking this:\n  lt k (fst (hd xs))", "have \"lt k k'\""], ["proof (prove)\nusing this:\n  lt k (fst (hd xs))\n\ngoal (1 subgoal):\n 1. lt k k'", "by (simp add: xs)"], ["proof (state)\nthis:\n  lt k k'\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> sorted_wrt lt (map fst ((k, v) # xs))", "moreover"], ["proof (state)\nthis:\n  lt k k'\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> sorted_wrt lt (map fst ((k, v) # xs))", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"sorted_wrt lt (map fst xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "by (rule oalist_inv_rawD2)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> sorted_wrt lt (map fst ((k, v) # xs))", "ultimately"], ["proof (chain)\npicking this:\n  lt k k'\n  sorted_wrt lt (map fst xs)", "show \"sorted_wrt lt (map fst ((k, v) # xs))\""], ["proof (prove)\nusing this:\n  lt k k'\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst ((k, v) # xs))", "by (simp add: xs sorted_wrt2[OF transp_less] del: sorted_wrt.simps)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst ((k, v) # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst ((k, v) # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_raw_ConsD1:\n  assumes \"oalist_inv_raw (x # xs)\"\n  shows \"oalist_inv_raw xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw xs", "proof (rule oalist_inv_rawI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'b) \\<notin> snd ` set xs\n 2. sorted_wrt lt (map fst xs)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw (x # xs)", "have \"0 \\<notin> snd ` set (x # xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (x # xs)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (x # xs)", "by (rule oalist_inv_rawD1)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set (x # xs)\n\ngoal (2 subgoals):\n 1. (0::'b) \\<notin> snd ` set xs\n 2. sorted_wrt lt (map fst xs)", "thus \"0 \\<notin> snd ` set xs\""], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set (x # xs)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs", "by simp"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw (x # xs)", "have \"sorted_wrt lt (map fst (x # xs))\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (x # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (x # xs))", "by (rule oalist_inv_rawD2)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "thus \"sorted_wrt lt (map fst xs)\""], ["proof (prove)\nusing this:\n  sorted_wrt lt (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_raw_ConsD2:\n  assumes \"oalist_inv_raw ((k, v) # xs)\"\n  shows \"v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs)", "have \"0 \\<notin> snd ` set ((k, v) # xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set ((k, v) # xs)", "by (rule oalist_inv_rawD1)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set ((k, v) # xs)\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set ((k, v) # xs)\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b)", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_raw_ConsD3:\n  assumes \"oalist_inv_raw ((k, v) # xs)\" and \"k' \\<in> fst ` set xs\"\n  shows \"lt k k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt k k'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lt k k'", "from assms(2)"], ["proof (chain)\npicking this:\n  k' \\<in> fst ` set xs", "obtain x where \"x \\<in> set xs\" and \"k' = fst x\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set xs; k' = fst x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> set xs\n  k' = fst x\n\ngoal (1 subgoal):\n 1. lt k k'", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs)", "have \"sorted_wrt lt (map fst ((k, v) # xs))\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst ((k, v) # xs))", "by (rule oalist_inv_rawD2)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst ((k, v) # xs))\n\ngoal (1 subgoal):\n 1. lt k k'", "hence \"\\<forall>x\\<in>set xs. lt k (fst x)\""], ["proof (prove)\nusing this:\n  sorted_wrt lt (map fst ((k, v) # xs))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. lt k (fst x)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. lt k (fst x)\n\ngoal (1 subgoal):\n 1. lt k k'", "hence \"lt k (fst x)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. lt k (fst x)\n\ngoal (1 subgoal):\n 1. lt k (fst x)", "using \\<open>x \\<in> set xs\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. lt k (fst x)\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. lt k (fst x)", ".."], ["proof (state)\nthis:\n  lt k (fst x)\n\ngoal (1 subgoal):\n 1. lt k k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k (fst x)\n\ngoal (1 subgoal):\n 1. lt k k'", "by (simp only: \\<open>k' = fst x\\<close>)"], ["proof (state)\nthis:\n  lt k k'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_raw_tl:\n  assumes \"oalist_inv_raw xs\"\n  shows \"oalist_inv_raw (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (tl xs)", "proof (rule oalist_inv_rawI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'b) \\<notin> snd ` set (tl xs)\n 2. sorted_wrt lt (map fst (tl xs))", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"0 \\<notin> snd ` set xs\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs", "by (rule oalist_inv_rawD1)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (2 subgoals):\n 1. (0::'b) \\<notin> snd ` set (tl xs)\n 2. sorted_wrt lt (map fst (tl xs))", "thus \"0 \\<notin> snd ` set (tl xs)\""], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (tl xs)", "by (metis (no_types, lifting) image_iff list.set_sel(2) tl_Nil)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set (tl xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (tl xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (tl xs))", "show \"sorted_wrt lt (map fst (tl xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (tl xs))", "by (metis hd_Cons_tl oalist_inv_rawD2 oalist_inv_raw_ConsD1 assms tl_Nil)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst (tl xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_raw_filter:\n  assumes \"oalist_inv_raw xs\"\n  shows \"oalist_inv_raw (filter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (filter P xs)", "proof (rule oalist_inv_rawI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'b) \\<notin> snd ` set (filter P xs)\n 2. sorted_wrt lt (map fst (filter P xs))", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"0 \\<notin> snd ` set xs\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs", "by (rule oalist_inv_rawD1)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (2 subgoals):\n 1. (0::'b) \\<notin> snd ` set (filter P xs)\n 2. sorted_wrt lt (map fst (filter P xs))", "thus \"0 \\<notin> snd ` set (filter P xs)\""], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (filter P xs)", "by auto"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set (filter P xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (filter P xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (filter P xs))", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"sorted_wrt lt (map fst xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "by (rule oalist_inv_rawD2)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (filter P xs))", "thus \"sorted_wrt lt (map fst (filter P xs))\""], ["proof (prove)\nusing this:\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (filter P xs))", "by (induct xs, simp, simp)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst (filter P xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_raw_map:\n  assumes \"oalist_inv_raw xs\"\n    and \"\\<And>a. snd (f a) = 0 \\<Longrightarrow> snd a = 0\"\n    and \"\\<And>a b. comp (fst (f a)) (fst (f b)) = comp (fst a) (fst b)\"\n  shows \"oalist_inv_raw (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (map f xs)", "proof (rule oalist_inv_rawI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'c) \\<notin> snd ` set (map f xs)\n 2. sorted_wrt lt (map fst (map f xs))", "show \"0 \\<notin> snd ` set (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'c) \\<notin> snd ` set (map f xs)", "proof (simp, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'c) \\<in> snd ` f ` set xs \\<Longrightarrow> False", "assume \"0 \\<in> snd ` f ` set xs\""], ["proof (state)\nthis:\n  (0::'c) \\<in> snd ` f ` set xs\n\ngoal (1 subgoal):\n 1. (0::'c) \\<in> snd ` f ` set xs \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (0::'c) \\<in> snd ` f ` set xs", "obtain a where \"a \\<in> set xs\" and \"snd (f a) = 0\""], ["proof (prove)\nusing this:\n  (0::'c) \\<in> snd ` f ` set xs\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set xs; snd (f a) = (0::'c)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a \\<in> set xs\n  snd (f a) = (0::'c)\n\ngoal (1 subgoal):\n 1. (0::'c) \\<in> snd ` f ` set xs \\<Longrightarrow> False", "from this(2)"], ["proof (chain)\npicking this:\n  snd (f a) = (0::'c)", "have \"snd a = 0\""], ["proof (prove)\nusing this:\n  snd (f a) = (0::'c)\n\ngoal (1 subgoal):\n 1. snd a = (0::'b)", "by (rule assms(2))"], ["proof (state)\nthis:\n  snd a = (0::'b)\n\ngoal (1 subgoal):\n 1. (0::'c) \\<in> snd ` f ` set xs \\<Longrightarrow> False", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"0 \\<notin> snd ` set xs\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs", "by (rule oalist_inv_rawD1)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. (0::'c) \\<in> snd ` f ` set xs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. (0::'c) \\<in> snd ` f ` set xs \\<Longrightarrow> False", "from \\<open>a \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> set xs", "have \"0 \\<in> snd ` set xs\""], ["proof (prove)\nusing this:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<in> snd ` set xs", "by (simp add: \\<open>snd a = 0\\<close>[symmetric])"], ["proof (state)\nthis:\n  (0::'b) \\<in> snd ` set xs\n\ngoal (1 subgoal):\n 1. (0::'c) \\<in> snd ` f ` set xs \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (0::'b) \\<notin> snd ` set xs\n  (0::'b) \\<in> snd ` set xs", "show False"], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set xs\n  (0::'b) \\<in> snd ` set xs\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0::'c) \\<notin> snd ` set (map f xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (map f xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (map f xs))", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"sorted_wrt lt (map fst xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "by (rule oalist_inv_rawD2)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (map f xs))", "hence \"sorted_wrt (\\<lambda>x y. comp (fst x) (fst y) = Lt) xs\""], ["proof (prove)\nusing this:\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. comp (fst x) (fst y) = Lt) xs", "by (simp only: sorted_wrt_map Lt_lt_conv)"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. comp (fst x) (fst y) = Lt) xs\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (map f xs))", "thus \"sorted_wrt lt (map fst (map f xs))\""], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>x y. comp (fst x) (fst y) = Lt) xs\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (map f xs))", "by (simp add: sorted_wrt_map Lt_lt_conv[symmetric] assms(3))"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst (map f xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_raw_induct [consumes 1, case_names Nil Cons]:\n  assumes \"oalist_inv_raw xs\"\n  assumes \"P []\"\n  assumes \"\\<And>k v xs. oalist_inv_raw ((k, v) # xs) \\<Longrightarrow> oalist_inv_raw xs \\<Longrightarrow> v \\<noteq> 0 \\<Longrightarrow>\n              (\\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k') \\<Longrightarrow> P xs \\<Longrightarrow> P ((k, v) # xs)\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using assms(1)"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. P xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. oalist_inv_raw [] \\<Longrightarrow> P []\n 2. \\<And>a xs.\n       \\<lbrakk>oalist_inv_raw xs \\<Longrightarrow> P xs;\n        oalist_inv_raw (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "case Nil"], ["proof (state)\nthis:\n  oalist_inv_raw []\n\ngoal (2 subgoals):\n 1. oalist_inv_raw [] \\<Longrightarrow> P []\n 2. \\<And>a xs.\n       \\<lbrakk>oalist_inv_raw xs \\<Longrightarrow> P xs;\n        oalist_inv_raw (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "from assms(2)"], ["proof (chain)\npicking this:\n  P []", "show ?case"], ["proof (prove)\nusing this:\n  P []\n\ngoal (1 subgoal):\n 1. P []", "."], ["proof (state)\nthis:\n  P []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oalist_inv_raw xs \\<Longrightarrow> P xs;\n        oalist_inv_raw (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oalist_inv_raw xs \\<Longrightarrow> P xs;\n        oalist_inv_raw (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  oalist_inv_raw xs \\<Longrightarrow> P xs\n  oalist_inv_raw (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oalist_inv_raw xs \\<Longrightarrow> P xs;\n        oalist_inv_raw (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "obtain k v where x: \"x = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. x = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oalist_inv_raw xs \\<Longrightarrow> P xs;\n        oalist_inv_raw (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "from Cons(2)"], ["proof (chain)\npicking this:\n  oalist_inv_raw (x # xs)", "have \"oalist_inv_raw ((k, v) # xs)\" and \"oalist_inv_raw xs\" and \"v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (x # xs)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ((k, v) # xs) &&&\n    oalist_inv_raw xs &&& v \\<noteq> (0::'b)", "unfolding x"], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ((k, v) # xs) &&&\n    oalist_inv_raw xs &&& v \\<noteq> (0::'b)", "by (this, rule oalist_inv_raw_ConsD1, rule oalist_inv_raw_ConsD2)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oalist_inv_raw xs \\<Longrightarrow> P xs;\n        oalist_inv_raw (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oalist_inv_raw xs \\<Longrightarrow> P xs;\n        oalist_inv_raw (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "from Cons(2)"], ["proof (chain)\npicking this:\n  oalist_inv_raw (x # xs)", "have \"lt k k'\" if \"k' \\<in> fst ` set xs\" for k'"], ["proof (prove)\nusing this:\n  oalist_inv_raw (x # xs)\n\ngoal (1 subgoal):\n 1. lt k k'", "using that"], ["proof (prove)\nusing this:\n  oalist_inv_raw (x # xs)\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k'", "unfolding x"], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k'", "by (rule oalist_inv_raw_ConsD3)"], ["proof (state)\nthis:\n  ?k'2 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'2\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oalist_inv_raw xs \\<Longrightarrow> P xs;\n        oalist_inv_raw (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "moreover"], ["proof (state)\nthis:\n  ?k'2 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'2\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oalist_inv_raw xs \\<Longrightarrow> P xs;\n        oalist_inv_raw (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "from \\<open>oalist_inv_raw xs\\<close>"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"P xs\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. P xs", "by (rule Cons(1))"], ["proof (state)\nthis:\n  P xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oalist_inv_raw xs \\<Longrightarrow> P xs;\n        oalist_inv_raw (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  ?k'2 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'2\n  P xs", "show ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  ?k'2 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'2\n  P xs\n\ngoal (1 subgoal):\n 1. P (x # xs)", "unfolding x"], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  ?k'2 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'2\n  P xs\n\ngoal (1 subgoal):\n 1. P ((k, v) # xs)", "by (rule assms(3))"], ["proof (state)\nthis:\n  P (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Operations on Lists of Pairs in Context @{locale comparator}\\<close>"], ["", "type_synonym (in -) ('a, 'b) comp_opt = \"'a \\<Rightarrow> 'b \\<Rightarrow> (order option)\""], ["", "definition (in -) lookup_dflt :: \"('a \\<times> 'b) list \\<Rightarrow> 'a \\<Rightarrow> 'b::zero\"\n  where \"lookup_dflt xs k = (case map_of xs k of Some v \\<Rightarrow> v | None \\<Rightarrow> 0)\""], ["", "text \\<open>@{const lookup_dflt} is only an auxiliary function needed for proving some lemmas.\\<close>"], ["", "fun lookup_pair :: \"('a \\<times> 'b) list \\<Rightarrow> 'a \\<Rightarrow> 'b::zero\"\nwhere\n  \"lookup_pair [] x = 0\"|\n  \"lookup_pair ((k, v) # xs) x =\n    (case comp x k of\n       Lt \\<Rightarrow> 0\n     | Eq \\<Rightarrow> v\n     | Gt \\<Rightarrow> lookup_pair xs x)\""], ["", "fun update_by_pair :: \"('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'b) list \\<Rightarrow> ('a \\<times> 'b::zero) list\"\nwhere\n  \"update_by_pair (k, v) [] = (if v = 0 then [] else [(k, v)])\"\n| \"update_by_pair (k, v) ((k', v') # xs) =\n  (case comp k k' of Lt \\<Rightarrow> (if v = 0 then (k', v') # xs else (k, v) # (k', v') # xs)\n                     | Eq \\<Rightarrow> (if v = 0 then xs else (k, v) # xs)\n                   | Gt \\<Rightarrow> (k', v') # update_by_pair (k, v) xs)\""], ["", "(* TODO: Add update_by_gr_pair. *)"], ["", "definition sort_oalist :: \"('a \\<times> 'b) list \\<Rightarrow> ('a \\<times> 'b::zero) list\"\n  where \"sort_oalist xs = foldr update_by_pair xs []\""], ["", "fun update_by_fun_pair :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<times> 'b) list \\<Rightarrow> ('a \\<times> 'b::zero) list\"\nwhere\n  \"update_by_fun_pair k f [] = (let v = f 0 in if v = 0 then [] else [(k, v)])\"\n| \"update_by_fun_pair k f ((k', v') # xs) =\n  (case comp k k' of Lt \\<Rightarrow> (let v = f 0 in if v = 0 then (k', v') # xs else (k, v) # (k', v') # xs)\n                     | Eq \\<Rightarrow> (let v = f v' in if v = 0 then xs else (k, v) # xs)\n                   | Gt \\<Rightarrow> (k', v') # update_by_fun_pair k f xs)\""], ["", "definition update_by_fun_gr_pair :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<times> 'b) list \\<Rightarrow> ('a \\<times> 'b::zero) list\"\n  where \"update_by_fun_gr_pair k f xs =\n          (if xs = [] then\n            (let v = f 0 in if v = 0 then [] else [(k, v)])\n          else if comp k (fst (last xs)) = Gt then\n            (let v = f 0 in if v = 0 then xs else xs @ [(k, v)])\n          else\n            update_by_fun_pair k f xs\n          )\""], ["", "fun (in -) map_pair :: \"(('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'c)) \\<Rightarrow> ('a \\<times> 'b::zero) list \\<Rightarrow> ('a \\<times> 'c::zero) list\"\nwhere\n  \"map_pair f [] = []\"\n| \"map_pair f (kv # xs) =\n    (let (k, v) = f kv; aux = map_pair f xs in if v = 0 then aux else (k, v) # aux)\""], ["", "text \\<open>The difference between @{const List.map} and @{const map_pair} is that the latter removes\n  @{term 0} values, whereas the former does not.\\<close>"], ["", "abbreviation (in -) map_val_pair :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<times> 'b::zero) list \\<Rightarrow> ('a \\<times> 'c::zero) list\"\n  where \"map_val_pair f \\<equiv> map_pair (\\<lambda>(k, v). (k, f k v))\""], ["", "fun map2_val_pair :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd) \\<Rightarrow> (('a \\<times> 'b) list \\<Rightarrow> ('a \\<times> 'd) list) \\<Rightarrow>\n                      (('a \\<times> 'c) list \\<Rightarrow> ('a \\<times> 'd) list) \\<Rightarrow>\n                      ('a \\<times> 'b::zero) list \\<Rightarrow> ('a \\<times> 'c::zero) list \\<Rightarrow> ('a \\<times> 'd::zero) list\"\nwhere\n  \"map2_val_pair f g h xs [] = g xs\"\n| \"map2_val_pair f g h [] ys = h ys\"\n| \"map2_val_pair f g h ((kx, vx) # xs) ((ky, vy) # ys) =\n    (case comp kx ky of\n             Lt    \\<Rightarrow> (let v = f kx vx 0; aux = map2_val_pair f g h xs ((ky, vy) # ys) in if v = 0 then aux else (kx, v) # aux)\n           | Eq   \\<Rightarrow> (let v = f kx vx vy; aux = map2_val_pair f g h xs ys in if v = 0 then aux else (kx, v) # aux)\n           | Gt \\<Rightarrow> (let v = f ky 0 vy; aux = map2_val_pair f g h ((kx, vx) # xs) ys in if v = 0 then aux else (ky, v) # aux))\""], ["", "fun lex_ord_pair :: \"('a \\<Rightarrow> (('b, 'c) comp_opt)) \\<Rightarrow> (('a \\<times> 'b::zero) list, ('a \\<times> 'c::zero) list) comp_opt\"\nwhere\n  \"lex_ord_pair f []       []       = Some Eq\"|\n  \"lex_ord_pair f []       ((ky, vy) # ys) =\n    (let aux = f ky 0 vy in if aux = Some Eq then lex_ord_pair f [] ys else aux)\"|\n  \"lex_ord_pair f ((kx, vx) # xs) []       =\n    (let aux = f kx vx 0 in if aux = Some Eq then lex_ord_pair f xs [] else aux)\"|\n  \"lex_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n    (case comp kx ky of\n             Lt    \\<Rightarrow> (let aux = f kx vx 0 in if aux = Some Eq then lex_ord_pair f xs ((ky, vy) # ys) else aux)\n           | Eq   \\<Rightarrow> (let aux = f kx vx vy in if aux = Some Eq then lex_ord_pair f xs ys else aux)\n           | Gt \\<Rightarrow> (let aux = f ky 0 vy in if aux = Some Eq then lex_ord_pair f ((kx, vx) # xs) ys else aux))\""], ["", "fun prod_ord_pair :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> ('a \\<times> 'b::zero) list \\<Rightarrow> ('a \\<times> 'c::zero) list \\<Rightarrow> bool\"\nwhere\n  \"prod_ord_pair f []       []       = True\"|\n  \"prod_ord_pair f []       ((ky, vy) # ys) = (f ky 0 vy \\<and> prod_ord_pair f [] ys)\"|\n  \"prod_ord_pair f ((kx, vx) # xs) []       = (f kx vx 0 \\<and> prod_ord_pair f xs [])\"|\n  \"prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n    (case comp kx ky of\n             Lt    \\<Rightarrow> (f kx vx 0 \\<and> prod_ord_pair f xs ((ky, vy) # ys))\n           | Eq   \\<Rightarrow> (f kx vx vy \\<and> prod_ord_pair f xs ys)\n           | Gt \\<Rightarrow> (f ky 0 vy \\<and> prod_ord_pair f ((kx, vx) # xs) ys))\""], ["", "text \\<open>@{const prod_ord_pair} is actually just a special case of @{const lex_ord_pair}, as proved below\n  in lemma \\<open>prod_ord_pair_eq_lex_ord_pair\\<close>.\\<close>"], ["", "subsubsection \\<open>@{const lookup_pair}\\<close>"], ["", "lemma lookup_pair_eq_0:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair xs k = 0 \\<longleftrightarrow> (k \\<notin> fst ` set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup_pair xs k = (0::'b)) = (k \\<notin> fst ` set xs)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. (lookup_pair xs k = (0::'b)) = (k \\<notin> fst ` set xs)", "proof (induct xs rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (lookup_pair [] k = (0::'b)) = (k \\<notin> fst ` set [])\n 2. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (lookup_pair xs k = (0::'b)) = (k \\<notin> fst ` set xs)\\<rbrakk>\n       \\<Longrightarrow> (lookup_pair ((ka, v) # xs) k = (0::'b)) =\n                         (k \\<notin> fst ` set ((ka, v) # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (lookup_pair [] k = (0::'b)) = (k \\<notin> fst ` set [])\n 2. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (lookup_pair xs k = (0::'b)) = (k \\<notin> fst ` set xs)\\<rbrakk>\n       \\<Longrightarrow> (lookup_pair ((ka, v) # xs) k = (0::'b)) =\n                         (k \\<notin> fst ` set ((ka, v) # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup_pair [] k = (0::'b)) = (k \\<notin> fst ` set [])", "by simp"], ["proof (state)\nthis:\n  (lookup_pair [] k = (0::'b)) = (k \\<notin> fst ` set [])\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (lookup_pair xs k = (0::'b)) = (k \\<notin> fst ` set xs)\\<rbrakk>\n       \\<Longrightarrow> (lookup_pair ((ka, v) # xs) k = (0::'b)) =\n                         (k \\<notin> fst ` set ((ka, v) # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (lookup_pair xs k = (0::'b)) = (k \\<notin> fst ` set xs)\\<rbrakk>\n       \\<Longrightarrow> (lookup_pair ((ka, v) # xs) k = (0::'b)) =\n                         (k \\<notin> fst ` set ((ka, v) # xs))", "case (Cons k' v' xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # xs)\n  oalist_inv_raw xs\n  v' \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'34\n  (lookup_pair xs k = (0::'b)) = (k \\<notin> fst ` set xs)\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (lookup_pair xs k = (0::'b)) = (k \\<notin> fst ` set xs)\\<rbrakk>\n       \\<Longrightarrow> (lookup_pair ((ka, v) # xs) k = (0::'b)) =\n                         (k \\<notin> fst ` set ((ka, v) # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup_pair ((k', v') # xs) k = (0::'b)) =\n    (k \\<notin> fst ` set ((k', v') # xs))", "proof (simp add: Cons(3) eq split: order.splits, rule, simp_all only: atomize_imp[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. comp k k' = Lt \\<Longrightarrow>\n    k \\<noteq> k' \\<and> k \\<notin> fst ` set xs\n 2. comp k k' = Gt \\<Longrightarrow>\n    (lookup_pair xs k = (0::'b)) =\n    (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)", "assume \"comp k k' = Lt\""], ["proof (state)\nthis:\n  comp k k' = Lt\n\ngoal (2 subgoals):\n 1. comp k k' = Lt \\<Longrightarrow>\n    k \\<noteq> k' \\<and> k \\<notin> fst ` set xs\n 2. comp k k' = Gt \\<Longrightarrow>\n    (lookup_pair xs k = (0::'b)) =\n    (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)", "hence \"k \\<noteq> k'\""], ["proof (prove)\nusing this:\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. k \\<noteq> k'", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (2 subgoals):\n 1. comp k k' = Lt \\<Longrightarrow>\n    k \\<noteq> k' \\<and> k \\<notin> fst ` set xs\n 2. comp k k' = Gt \\<Longrightarrow>\n    (lookup_pair xs k = (0::'b)) =\n    (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)", "moreover"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (2 subgoals):\n 1. comp k k' = Lt \\<Longrightarrow>\n    k \\<noteq> k' \\<and> k \\<notin> fst ` set xs\n 2. comp k k' = Gt \\<Longrightarrow>\n    (lookup_pair xs k = (0::'b)) =\n    (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)", "have \"k \\<notin> fst ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False", "assume \"k \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False", "hence \"lt k' k\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False", "with \\<open>comp k k' = Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k k' = Lt\n  lt k' k", "show False"], ["proof (prove)\nusing this:\n  comp k k' = Lt\n  lt k' k\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<notin> fst ` set xs\n\ngoal (2 subgoals):\n 1. comp k k' = Lt \\<Longrightarrow>\n    k \\<noteq> k' \\<and> k \\<notin> fst ` set xs\n 2. comp k k' = Gt \\<Longrightarrow>\n    (lookup_pair xs k = (0::'b)) =\n    (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)", "ultimately"], ["proof (chain)\npicking this:\n  k \\<noteq> k'\n  k \\<notin> fst ` set xs", "show \"k \\<noteq> k' \\<and> k \\<notin> fst ` set xs\""], ["proof (prove)\nusing this:\n  k \\<noteq> k'\n  k \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. k \\<noteq> k' \\<and> k \\<notin> fst ` set xs", ".."], ["proof (state)\nthis:\n  k \\<noteq> k' \\<and> k \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    (lookup_pair xs k = (0::'b)) =\n    (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    (lookup_pair xs k = (0::'b)) =\n    (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)", "assume \"comp k k' = Gt\""], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    (lookup_pair xs k = (0::'b)) =\n    (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)", "hence \"k \\<noteq> k'\""], ["proof (prove)\nusing this:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. k \\<noteq> k'", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    (lookup_pair xs k = (0::'b)) =\n    (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)", "thus \"(lookup_pair xs k = 0) = (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)\""], ["proof (prove)\nusing this:\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. (lookup_pair xs k = (0::'b)) =\n    (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)", "by (simp add: Cons(5))"], ["proof (state)\nthis:\n  (lookup_pair xs k = (0::'b)) =\n  (k \\<noteq> k' \\<and> k \\<notin> fst ` set xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (lookup_pair ((k', v') # xs) k = (0::'b)) =\n  (k \\<notin> fst ` set ((k', v') # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_eq_value:\n  assumes \"oalist_inv_raw xs\" and \"v \\<noteq> 0\"\n  shows \"lookup_pair xs k = v \\<longleftrightarrow> ((k, v) \\<in> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup_pair xs k = v) = ((k, v) \\<in> set xs)", "using assms(1)"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. (lookup_pair xs k = v) = ((k, v) \\<in> set xs)", "proof (induct xs rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (lookup_pair [] k = v) = ((k, v) \\<in> set [])\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (lookup_pair xs k = v) = ((k, v) \\<in> set xs)\\<rbrakk>\n       \\<Longrightarrow> (lookup_pair ((ka, va) # xs) k = v) =\n                         ((k, v) \\<in> set ((ka, va) # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (lookup_pair [] k = v) = ((k, v) \\<in> set [])\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (lookup_pair xs k = v) = ((k, v) \\<in> set xs)\\<rbrakk>\n       \\<Longrightarrow> (lookup_pair ((ka, va) # xs) k = v) =\n                         ((k, v) \\<in> set ((ka, va) # xs))", "from assms(2)"], ["proof (chain)\npicking this:\n  v \\<noteq> (0::'b)", "show ?case"], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (lookup_pair [] k = v) = ((k, v) \\<in> set [])", "by simp"], ["proof (state)\nthis:\n  (lookup_pair [] k = v) = ((k, v) \\<in> set [])\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (lookup_pair xs k = v) = ((k, v) \\<in> set xs)\\<rbrakk>\n       \\<Longrightarrow> (lookup_pair ((ka, va) # xs) k = v) =\n                         ((k, v) \\<in> set ((ka, va) # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (lookup_pair xs k = v) = ((k, v) \\<in> set xs)\\<rbrakk>\n       \\<Longrightarrow> (lookup_pair ((ka, va) # xs) k = v) =\n                         ((k, v) \\<in> set ((ka, va) # xs))", "case (Cons k' v' xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # xs)\n  oalist_inv_raw xs\n  v' \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'34\n  (lookup_pair xs k = v) = ((k, v) \\<in> set xs)\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (lookup_pair xs k = v) = ((k, v) \\<in> set xs)\\<rbrakk>\n       \\<Longrightarrow> (lookup_pair ((ka, va) # xs) k = v) =\n                         ((k, v) \\<in> set ((ka, va) # xs))", "have *: \"(k', u) \\<notin> set xs\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k', u) \\<notin> set xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (k', u) \\<in> set xs \\<Longrightarrow> False", "assume \"(k', u) \\<in> set xs\""], ["proof (state)\nthis:\n  (k', u) \\<in> set xs\n\ngoal (1 subgoal):\n 1. (k', u) \\<in> set xs \\<Longrightarrow> False", "hence \"fst (k', u) \\<in> fst ` set xs\""], ["proof (prove)\nusing this:\n  (k', u) \\<in> set xs\n\ngoal (1 subgoal):\n 1. fst (k', u) \\<in> fst ` set xs", "by fastforce"], ["proof (state)\nthis:\n  fst (k', u) \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. (k', u) \\<in> set xs \\<Longrightarrow> False", "hence \"k' \\<in> fst ` set xs\""], ["proof (prove)\nusing this:\n  fst (k', u) \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs", "by simp"], ["proof (state)\nthis:\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. (k', u) \\<in> set xs \\<Longrightarrow> False", "hence \"lt k' k'\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k'", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k'\n\ngoal (1 subgoal):\n 1. (k', u) \\<in> set xs \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lt k' k'\n\ngoal (1 subgoal):\n 1. False", "by (simp add: lt_of_key_order_alt[symmetric])"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (k', ?u34) \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (lookup_pair xs k = v) = ((k, v) \\<in> set xs)\\<rbrakk>\n       \\<Longrightarrow> (lookup_pair ((ka, va) # xs) k = v) =\n                         ((k, v) \\<in> set ((ka, va) # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup_pair ((k', v') # xs) k = v) = ((k, v) \\<in> set ((k', v') # xs))", "proof (simp add: assms(2) Cons(5) eq split: order.split, intro conjI impI)"], ["proof (state)\ngoal (4 subgoals):\n 1. k = k' \\<Longrightarrow> (v' = v) = (v = v' \\<or> (k', v) \\<in> set xs)\n 2. \\<lbrakk>comp k k' = Lt; k = k'\\<rbrakk> \\<Longrightarrow> v \\<noteq> v'\n 3. comp k k' = Lt \\<Longrightarrow> (k, v) \\<notin> set xs\n 4. comp k k' = Gt \\<Longrightarrow>\n    ((k, v) \\<in> set xs) = (k = k' \\<and> v = v' \\<or> (k, v) \\<in> set xs)", "assume \"comp k k' = Lt\""], ["proof (state)\nthis:\n  comp k k' = Lt\n\ngoal (4 subgoals):\n 1. k = k' \\<Longrightarrow> (v' = v) = (v = v' \\<or> (k', v) \\<in> set xs)\n 2. \\<lbrakk>comp k k' = Lt; k = k'\\<rbrakk> \\<Longrightarrow> v \\<noteq> v'\n 3. comp k k' = Lt \\<Longrightarrow> (k, v) \\<notin> set xs\n 4. comp k k' = Gt \\<Longrightarrow>\n    ((k, v) \\<in> set xs) = (k = k' \\<and> v = v' \\<or> (k, v) \\<in> set xs)", "show \"(k, v) \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, v) \\<notin> set xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (k, v) \\<in> set xs \\<Longrightarrow> False", "assume \"(k, v) \\<in> set xs\""], ["proof (state)\nthis:\n  (k, v) \\<in> set xs\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set xs \\<Longrightarrow> False", "hence \"fst (k, v) \\<in> fst ` set xs\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set xs\n\ngoal (1 subgoal):\n 1. fst (k, v) \\<in> fst ` set xs", "by fastforce"], ["proof (state)\nthis:\n  fst (k, v) \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set xs \\<Longrightarrow> False", "hence \"k \\<in> fst ` set xs\""], ["proof (prove)\nusing this:\n  fst (k, v) \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs", "by simp"], ["proof (state)\nthis:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set xs \\<Longrightarrow> False", "hence \"lt k' k\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set xs \\<Longrightarrow> False", "with \\<open>comp k k' = Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k k' = Lt\n  lt k' k", "show False"], ["proof (prove)\nusing this:\n  comp k k' = Lt\n  lt k' k\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (k, v) \\<notin> set xs\n\ngoal (3 subgoals):\n 1. k = k' \\<Longrightarrow> (v' = v) = (v = v' \\<or> (k', v) \\<in> set xs)\n 2. \\<lbrakk>comp k k' = Lt; k = k'\\<rbrakk> \\<Longrightarrow> v \\<noteq> v'\n 3. comp k k' = Gt \\<Longrightarrow>\n    ((k, v) \\<in> set xs) = (k = k' \\<and> v = v' \\<or> (k, v) \\<in> set xs)", "qed (auto simp: *)"], ["proof (state)\nthis:\n  (lookup_pair ((k', v') # xs) k = v) = ((k, v) \\<in> set ((k', v') # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_eq_valueI:\n  assumes \"oalist_inv_raw xs\" and \"(k, v) \\<in> set xs\"\n  shows \"lookup_pair xs k = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair xs k = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_pair xs k = v", "from assms(2)"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set xs", "have \"v \\<in> snd ` set xs\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set xs\n\ngoal (1 subgoal):\n 1. v \\<in> snd ` set xs", "by force"], ["proof (state)\nthis:\n  v \\<in> snd ` set xs\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = v", "moreover"], ["proof (state)\nthis:\n  v \\<in> snd ` set xs\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = v", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"0 \\<notin> snd ` set xs\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs", "by (rule oalist_inv_rawD1)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = v", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> snd ` set xs\n  (0::'b) \\<notin> snd ` set xs", "have \"v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<in> snd ` set xs\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b)", "by blast"], ["proof (state)\nthis:\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = v", "with assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  (k, v) \\<in> set xs\n  v \\<noteq> (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  (k, v) \\<in> set xs\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = v", "by (simp add: lookup_pair_eq_value)"], ["proof (state)\nthis:\n  lookup_pair xs k = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_dflt_eq_lookup_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_dflt xs = lookup_pair xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_dflt xs = lookup_pair xs", "proof (rule, simp add: lookup_dflt_def split: option.split, intro conjI impI allI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. map_of xs x = None \\<Longrightarrow> lookup_pair xs x = (0::'b)\n 2. \\<And>x x2.\n       map_of xs x = Some x2 \\<Longrightarrow> x2 = lookup_pair xs x", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. map_of xs x = None \\<Longrightarrow> lookup_pair xs x = (0::'b)\n 2. \\<And>x x2.\n       map_of xs x = Some x2 \\<Longrightarrow> x2 = lookup_pair xs x", "assume \"map_of xs k = None\""], ["proof (state)\nthis:\n  map_of xs k = None\n\ngoal (2 subgoals):\n 1. \\<And>x. map_of xs x = None \\<Longrightarrow> lookup_pair xs x = (0::'b)\n 2. \\<And>x x2.\n       map_of xs x = Some x2 \\<Longrightarrow> x2 = lookup_pair xs x", "with assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  map_of xs k = None", "show \"lookup_pair xs k = 0\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  map_of xs k = None\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = (0::'b)", "by (simp add: lookup_pair_eq_0 map_of_eq_None_iff)"], ["proof (state)\nthis:\n  lookup_pair xs k = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       map_of xs x = Some x2 \\<Longrightarrow> x2 = lookup_pair xs x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       map_of xs x = Some x2 \\<Longrightarrow> x2 = lookup_pair xs x", "fix k v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       map_of xs x = Some x2 \\<Longrightarrow> x2 = lookup_pair xs x", "assume \"map_of xs k = Some v\""], ["proof (state)\nthis:\n  map_of xs k = Some v\n\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       map_of xs x = Some x2 \\<Longrightarrow> x2 = lookup_pair xs x", "hence \"(k, v) \\<in> set xs\""], ["proof (prove)\nusing this:\n  map_of xs k = Some v\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set xs", "by (rule map_of_SomeD)"], ["proof (state)\nthis:\n  (k, v) \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       map_of xs x = Some x2 \\<Longrightarrow> x2 = lookup_pair xs x", "with assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  (k, v) \\<in> set xs", "have \"lookup_pair xs k = v\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  (k, v) \\<in> set xs\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = v", "by (rule lookup_pair_eq_valueI)"], ["proof (state)\nthis:\n  lookup_pair xs k = v\n\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       map_of xs x = Some x2 \\<Longrightarrow> x2 = lookup_pair xs x", "thus \"v = lookup_pair xs k\""], ["proof (prove)\nusing this:\n  lookup_pair xs k = v\n\ngoal (1 subgoal):\n 1. v = lookup_pair xs k", "by (rule HOL.sym)"], ["proof (state)\nthis:\n  v = lookup_pair xs k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_inj:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\" and \"lookup_pair xs = lookup_pair ys\"\n  shows \"xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  lookup_pair xs = lookup_pair ys\n\ngoal (1 subgoal):\n 1. xs = ys", "proof (induct xs arbitrary: ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>oalist_inv_raw ys; lookup_pair [] = lookup_pair ys\\<rbrakk>\n       \\<Longrightarrow> [] = ys\n 2. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            lookup_pair xs = lookup_pair ys\\<rbrakk>\n           \\<Longrightarrow> xs = ys;\n        oalist_inv_raw ys;\n        lookup_pair ((k, v) # xs) = lookup_pair ys\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = ys", "case Nil"], ["proof (state)\nthis:\n  oalist_inv_raw ys\n  lookup_pair [] = lookup_pair ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>oalist_inv_raw ys; lookup_pair [] = lookup_pair ys\\<rbrakk>\n       \\<Longrightarrow> [] = ys\n 2. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            lookup_pair xs = lookup_pair ys\\<rbrakk>\n           \\<Longrightarrow> xs = ys;\n        oalist_inv_raw ys;\n        lookup_pair ((k, v) # xs) = lookup_pair ys\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = ys", "thus ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n  lookup_pair [] = lookup_pair ys\n\ngoal (1 subgoal):\n 1. [] = ys", "proof (induct ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup_pair [] = lookup_pair [] \\<Longrightarrow> [] = []\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        lookup_pair [] = lookup_pair xs \\<Longrightarrow> [] = xs;\n        lookup_pair [] = lookup_pair ((k, v) # xs)\\<rbrakk>\n       \\<Longrightarrow> [] = (k, v) # xs", "case Nil"], ["proof (state)\nthis:\n  lookup_pair [] = lookup_pair []\n\ngoal (2 subgoals):\n 1. lookup_pair [] = lookup_pair [] \\<Longrightarrow> [] = []\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        lookup_pair [] = lookup_pair xs \\<Longrightarrow> [] = xs;\n        lookup_pair [] = lookup_pair ((k, v) # xs)\\<rbrakk>\n       \\<Longrightarrow> [] = (k, v) # xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] = []", "by simp"], ["proof (state)\nthis:\n  [] = []\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        lookup_pair [] = lookup_pair xs \\<Longrightarrow> [] = xs;\n        lookup_pair [] = lookup_pair ((k, v) # xs)\\<rbrakk>\n       \\<Longrightarrow> [] = (k, v) # xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        lookup_pair [] = lookup_pair xs \\<Longrightarrow> [] = xs;\n        lookup_pair [] = lookup_pair ((k, v) # xs)\\<rbrakk>\n       \\<Longrightarrow> [] = (k, v) # xs", "case (Cons k' v' ys)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n  oalist_inv_raw ys\n  v' \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set ys \\<Longrightarrow> lt k' ?k'34\n  lookup_pair [] = lookup_pair ys \\<Longrightarrow> [] = ys\n  lookup_pair [] = lookup_pair ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        lookup_pair [] = lookup_pair xs \\<Longrightarrow> [] = xs;\n        lookup_pair [] = lookup_pair ((k, v) # xs)\\<rbrakk>\n       \\<Longrightarrow> [] = (k, v) # xs", "have \"v' = lookup_pair ((k', v') # ys) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' = lookup_pair ((k', v') # ys) k'", "by simp"], ["proof (state)\nthis:\n  v' = lookup_pair ((k', v') # ys) k'\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        lookup_pair [] = lookup_pair xs \\<Longrightarrow> [] = xs;\n        lookup_pair [] = lookup_pair ((k, v) # xs)\\<rbrakk>\n       \\<Longrightarrow> [] = (k, v) # xs", "also"], ["proof (state)\nthis:\n  v' = lookup_pair ((k', v') # ys) k'\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        lookup_pair [] = lookup_pair xs \\<Longrightarrow> [] = xs;\n        lookup_pair [] = lookup_pair ((k, v) # xs)\\<rbrakk>\n       \\<Longrightarrow> [] = (k, v) # xs", "have \"... = lookup_pair [] k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k', v') # ys) k' = lookup_pair [] k'", "by (simp only: Cons(6))"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # ys) k' = lookup_pair [] k'\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        lookup_pair [] = lookup_pair xs \\<Longrightarrow> [] = xs;\n        lookup_pair [] = lookup_pair ((k, v) # xs)\\<rbrakk>\n       \\<Longrightarrow> [] = (k, v) # xs", "also"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # ys) k' = lookup_pair [] k'\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        lookup_pair [] = lookup_pair xs \\<Longrightarrow> [] = xs;\n        lookup_pair [] = lookup_pair ((k, v) # xs)\\<rbrakk>\n       \\<Longrightarrow> [] = (k, v) # xs", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair [] k' = (0::'b)", "by simp"], ["proof (state)\nthis:\n  lookup_pair [] k' = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        lookup_pair [] = lookup_pair xs \\<Longrightarrow> [] = xs;\n        lookup_pair [] = lookup_pair ((k, v) # xs)\\<rbrakk>\n       \\<Longrightarrow> [] = (k, v) # xs", "finally"], ["proof (chain)\npicking this:\n  v' = (0::'b)", "have \"v' = 0\""], ["proof (prove)\nusing this:\n  v' = (0::'b)\n\ngoal (1 subgoal):\n 1. v' = (0::'b)", "."], ["proof (state)\nthis:\n  v' = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        lookup_pair [] = lookup_pair xs \\<Longrightarrow> [] = xs;\n        lookup_pair [] = lookup_pair ((k, v) # xs)\\<rbrakk>\n       \\<Longrightarrow> [] = (k, v) # xs", "with Cons(3)"], ["proof (chain)\npicking this:\n  v' \\<noteq> (0::'b)\n  v' = (0::'b)", "show ?case"], ["proof (prove)\nusing this:\n  v' \\<noteq> (0::'b)\n  v' = (0::'b)\n\ngoal (1 subgoal):\n 1. [] = (k', v') # ys", ".."], ["proof (state)\nthis:\n  [] = (k', v') # ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [] = ys\n\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            lookup_pair xs = lookup_pair ys\\<rbrakk>\n           \\<Longrightarrow> xs = ys;\n        oalist_inv_raw ys;\n        lookup_pair ((k, v) # xs) = lookup_pair ys\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            lookup_pair xs = lookup_pair ys\\<rbrakk>\n           \\<Longrightarrow> xs = ys;\n        oalist_inv_raw ys;\n        lookup_pair ((k, v) # xs) = lookup_pair ys\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = ys", "case *: (Cons k v xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'34\n  \\<lbrakk>oalist_inv_raw ?ys34; lookup_pair xs = lookup_pair ?ys34\\<rbrakk>\n  \\<Longrightarrow> xs = ?ys34\n  oalist_inv_raw ys\n  lookup_pair ((k, v) # xs) = lookup_pair ys\n\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            lookup_pair xs = lookup_pair ys\\<rbrakk>\n           \\<Longrightarrow> xs = ys;\n        oalist_inv_raw ys;\n        lookup_pair ((k, v) # xs) = lookup_pair ys\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = ys", "from *(6, 7)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys\n  lookup_pair ((k, v) # xs) = lookup_pair ys", "show ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n  lookup_pair ((k, v) # xs) = lookup_pair ys\n\ngoal (1 subgoal):\n 1. (k, v) # xs = ys", "proof (induct ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup_pair ((k, v) # xs) = lookup_pair [] \\<Longrightarrow>\n    (k, v) # xs = []\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair ((k, v) # xs) = lookup_pair xs \\<Longrightarrow>\n        (k, v) # xs = xs;\n        lookup_pair ((k, v) # xs) = lookup_pair ((ka, va) # xs)\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = (ka, va) # xs", "case Nil"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) = lookup_pair []\n\ngoal (2 subgoals):\n 1. lookup_pair ((k, v) # xs) = lookup_pair [] \\<Longrightarrow>\n    (k, v) # xs = []\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair ((k, v) # xs) = lookup_pair xs \\<Longrightarrow>\n        (k, v) # xs = xs;\n        lookup_pair ((k, v) # xs) = lookup_pair ((ka, va) # xs)\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = (ka, va) # xs", "have \"v = lookup_pair ((k, v) # xs) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = lookup_pair ((k, v) # xs) k", "by simp"], ["proof (state)\nthis:\n  v = lookup_pair ((k, v) # xs) k\n\ngoal (2 subgoals):\n 1. lookup_pair ((k, v) # xs) = lookup_pair [] \\<Longrightarrow>\n    (k, v) # xs = []\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair ((k, v) # xs) = lookup_pair xs \\<Longrightarrow>\n        (k, v) # xs = xs;\n        lookup_pair ((k, v) # xs) = lookup_pair ((ka, va) # xs)\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = (ka, va) # xs", "also"], ["proof (state)\nthis:\n  v = lookup_pair ((k, v) # xs) k\n\ngoal (2 subgoals):\n 1. lookup_pair ((k, v) # xs) = lookup_pair [] \\<Longrightarrow>\n    (k, v) # xs = []\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair ((k, v) # xs) = lookup_pair xs \\<Longrightarrow>\n        (k, v) # xs = xs;\n        lookup_pair ((k, v) # xs) = lookup_pair ((ka, va) # xs)\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = (ka, va) # xs", "have \"... = lookup_pair [] k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k, v) # xs) k = lookup_pair [] k", "by (simp only: Nil)"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k = lookup_pair [] k\n\ngoal (2 subgoals):\n 1. lookup_pair ((k, v) # xs) = lookup_pair [] \\<Longrightarrow>\n    (k, v) # xs = []\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair ((k, v) # xs) = lookup_pair xs \\<Longrightarrow>\n        (k, v) # xs = xs;\n        lookup_pair ((k, v) # xs) = lookup_pair ((ka, va) # xs)\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = (ka, va) # xs", "also"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k = lookup_pair [] k\n\ngoal (2 subgoals):\n 1. lookup_pair ((k, v) # xs) = lookup_pair [] \\<Longrightarrow>\n    (k, v) # xs = []\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair ((k, v) # xs) = lookup_pair xs \\<Longrightarrow>\n        (k, v) # xs = xs;\n        lookup_pair ((k, v) # xs) = lookup_pair ((ka, va) # xs)\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = (ka, va) # xs", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair [] k = (0::'b)", "by simp"], ["proof (state)\nthis:\n  lookup_pair [] k = (0::'b)\n\ngoal (2 subgoals):\n 1. lookup_pair ((k, v) # xs) = lookup_pair [] \\<Longrightarrow>\n    (k, v) # xs = []\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair ((k, v) # xs) = lookup_pair xs \\<Longrightarrow>\n        (k, v) # xs = xs;\n        lookup_pair ((k, v) # xs) = lookup_pair ((ka, va) # xs)\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = (ka, va) # xs", "finally"], ["proof (chain)\npicking this:\n  v = (0::'b)", "have \"v = 0\""], ["proof (prove)\nusing this:\n  v = (0::'b)\n\ngoal (1 subgoal):\n 1. v = (0::'b)", "."], ["proof (state)\nthis:\n  v = (0::'b)\n\ngoal (2 subgoals):\n 1. lookup_pair ((k, v) # xs) = lookup_pair [] \\<Longrightarrow>\n    (k, v) # xs = []\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair ((k, v) # xs) = lookup_pair xs \\<Longrightarrow>\n        (k, v) # xs = xs;\n        lookup_pair ((k, v) # xs) = lookup_pair ((ka, va) # xs)\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = (ka, va) # xs", "with *(3)"], ["proof (chain)\npicking this:\n  v \\<noteq> (0::'b)\n  v = (0::'b)", "show ?case"], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'b)\n  v = (0::'b)\n\ngoal (1 subgoal):\n 1. (k, v) # xs = []", ".."], ["proof (state)\nthis:\n  (k, v) # xs = []\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair ((k, v) # xs) = lookup_pair xs \\<Longrightarrow>\n        (k, v) # xs = xs;\n        lookup_pair ((k, v) # xs) = lookup_pair ((ka, va) # xs)\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = (ka, va) # xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair ((k, v) # xs) = lookup_pair xs \\<Longrightarrow>\n        (k, v) # xs = xs;\n        lookup_pair ((k, v) # xs) = lookup_pair ((ka, va) # xs)\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = (ka, va) # xs", "case (Cons k' v' ys)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n  oalist_inv_raw ys\n  v' \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set ys \\<Longrightarrow> lt k' ?k'34\n  lookup_pair ((k, v) # xs) = lookup_pair ys \\<Longrightarrow>\n  (k, v) # xs = ys\n  lookup_pair ((k, v) # xs) = lookup_pair ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair ((k, v) # xs) = lookup_pair xs \\<Longrightarrow>\n        (k, v) # xs = xs;\n        lookup_pair ((k, v) # xs) = lookup_pair ((ka, va) # xs)\\<rbrakk>\n       \\<Longrightarrow> (k, v) # xs = (ka, va) # xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, v) # xs = (k', v') # ys", "proof (cases \"comp k k'\")"], ["proof (state)\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "case Lt"], ["proof (state)\nthis:\n  comp k k' = Lt\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "hence \"\\<not> lt k' k\""], ["proof (prove)\nusing this:\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. \\<not> lt k' k", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  \\<not> lt k' k\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "with Cons(4)"], ["proof (chain)\npicking this:\n  ?k'34 \\<in> fst ` set ys \\<Longrightarrow> lt k' ?k'34\n  \\<not> lt k' k", "have \"k \\<notin> fst ` set ys\""], ["proof (prove)\nusing this:\n  ?k'34 \\<in> fst ` set ys \\<Longrightarrow> lt k' ?k'34\n  \\<not> lt k' k\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set ys", "by blast"], ["proof (state)\nthis:\n  k \\<notin> fst ` set ys\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "moreover"], ["proof (state)\nthis:\n  k \\<notin> fst ` set ys\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "from Lt"], ["proof (chain)\npicking this:\n  comp k k' = Lt", "have \"k \\<noteq> k'\""], ["proof (prove)\nusing this:\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. k \\<noteq> k'", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "ultimately"], ["proof (chain)\npicking this:\n  k \\<notin> fst ` set ys\n  k \\<noteq> k'", "have \"k \\<notin> fst ` set ((k', v') # ys)\""], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set ys\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set ((k', v') # ys)", "by simp"], ["proof (state)\nthis:\n  k \\<notin> fst ` set ((k', v') # ys)\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "hence \"0 = lookup_pair ((k', v') # ys) k\""], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. (0::'b) = lookup_pair ((k', v') # ys) k", "by (simp add: lookup_pair_eq_0[OF Cons(1)] del: lookup_pair.simps)"], ["proof (state)\nthis:\n  (0::'b) = lookup_pair ((k', v') # ys) k\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "also"], ["proof (state)\nthis:\n  (0::'b) = lookup_pair ((k', v') # ys) k\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "have \"... = lookup_pair ((k, v) # xs) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k', v') # ys) k = lookup_pair ((k, v) # xs) k", "by (simp only: Cons(6))"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # ys) k = lookup_pair ((k, v) # xs) k\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "also"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # ys) k = lookup_pair ((k, v) # xs) k\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "have \"... = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k, v) # xs) k = v", "by simp"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k = v\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "finally"], ["proof (chain)\npicking this:\n  (0::'b) = v", "have \"v = 0\""], ["proof (prove)\nusing this:\n  (0::'b) = v\n\ngoal (1 subgoal):\n 1. v = (0::'b)", "by simp"], ["proof (state)\nthis:\n  v = (0::'b)\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Lt \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 3. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "with *(3)"], ["proof (chain)\npicking this:\n  v \\<noteq> (0::'b)\n  v = (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'b)\n  v = (0::'b)\n\ngoal (1 subgoal):\n 1. (k, v) # xs = (k', v') # ys", ".."], ["proof (state)\nthis:\n  (k, v) # xs = (k', v') # ys\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "case Eq"], ["proof (state)\nthis:\n  comp k k' = Eq\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "hence \"k' = k\""], ["proof (prove)\nusing this:\n  comp k k' = Eq\n\ngoal (1 subgoal):\n 1. k' = k", "by (simp only: eq)"], ["proof (state)\nthis:\n  k' = k\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "have \"v' = lookup_pair ((k', v') # ys) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' = lookup_pair ((k', v') # ys) k'", "by simp"], ["proof (state)\nthis:\n  v' = lookup_pair ((k', v') # ys) k'\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "also"], ["proof (state)\nthis:\n  v' = lookup_pair ((k', v') # ys) k'\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "have \"... = lookup_pair ((k, v) # xs) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k', v') # ys) k' = lookup_pair ((k, v) # xs) k", "by (simp only: Cons(6) \\<open>k' = k\\<close>)"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # ys) k' = lookup_pair ((k, v) # xs) k\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "also"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # ys) k' = lookup_pair ((k, v) # xs) k\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "have \"... = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k, v) # xs) k = v", "by simp"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k = v\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "finally"], ["proof (chain)\npicking this:\n  v' = v", "have \"v' = v\""], ["proof (prove)\nusing this:\n  v' = v\n\ngoal (1 subgoal):\n 1. v' = v", "."], ["proof (state)\nthis:\n  v' = v\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "moreover"], ["proof (state)\nthis:\n  v' = v\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "note \\<open>k' = k\\<close>"], ["proof (state)\nthis:\n  k' = k\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "moreover"], ["proof (state)\nthis:\n  k' = k\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "from Cons(2)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys", "have \"xs = ys\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. xs = ys", "proof (rule *(5))"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_pair xs = lookup_pair ys", "show \"lookup_pair xs = lookup_pair ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair xs = lookup_pair ys", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup_pair xs x = lookup_pair ys x", "fix k0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup_pair xs x = lookup_pair ys x", "show \"lookup_pair xs k0 = lookup_pair ys k0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair xs k0 = lookup_pair ys k0", "proof (cases \"lt k k0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0\n 2. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "case True"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (2 subgoals):\n 1. lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0\n 2. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "hence eq: \"comp k0 k = Gt\""], ["proof (prove)\nusing this:\n  lt k k0\n\ngoal (1 subgoal):\n 1. comp k0 k = Gt", "by (simp add: Gt_lt_conv)"], ["proof (state)\nthis:\n  comp k0 k = Gt\n\ngoal (2 subgoals):\n 1. lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0\n 2. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "have \"lookup_pair xs k0 = lookup_pair ((k, v) # xs) k0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair xs k0 = lookup_pair ((k, v) # xs) k0", "by (simp add: eq)"], ["proof (state)\nthis:\n  lookup_pair xs k0 = lookup_pair ((k, v) # xs) k0\n\ngoal (2 subgoals):\n 1. lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0\n 2. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "also"], ["proof (state)\nthis:\n  lookup_pair xs k0 = lookup_pair ((k, v) # xs) k0\n\ngoal (2 subgoals):\n 1. lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0\n 2. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "have \"... = lookup_pair ((k, v') # ys) k0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k, v) # xs) k0 = lookup_pair ((k, v') # ys) k0", "by (simp only: Cons(6) \\<open>k' = k\\<close>)"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k0 = lookup_pair ((k, v') # ys) k0\n\ngoal (2 subgoals):\n 1. lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0\n 2. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "also"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k0 = lookup_pair ((k, v') # ys) k0\n\ngoal (2 subgoals):\n 1. lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0\n 2. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "have \"... = lookup_pair ys k0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k, v') # ys) k0 = lookup_pair ys k0", "by (simp add: eq)"], ["proof (state)\nthis:\n  lookup_pair ((k, v') # ys) k0 = lookup_pair ys k0\n\ngoal (2 subgoals):\n 1. lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0\n 2. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "finally"], ["proof (chain)\npicking this:\n  lookup_pair xs k0 = lookup_pair ys k0", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup_pair xs k0 = lookup_pair ys k0\n\ngoal (1 subgoal):\n 1. lookup_pair xs k0 = lookup_pair ys k0", "."], ["proof (state)\nthis:\n  lookup_pair xs k0 = lookup_pair ys k0\n\ngoal (1 subgoal):\n 1. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "case False"], ["proof (state)\nthis:\n  \\<not> lt k k0\n\ngoal (1 subgoal):\n 1. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "with *(4)"], ["proof (chain)\npicking this:\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'34\n  \\<not> lt k k0", "have \"k0 \\<notin> fst ` set xs\""], ["proof (prove)\nusing this:\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'34\n  \\<not> lt k k0\n\ngoal (1 subgoal):\n 1. k0 \\<notin> fst ` set xs", "by blast"], ["proof (state)\nthis:\n  k0 \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "with *(2)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  k0 \\<notin> fst ` set xs", "have eq: \"lookup_pair xs k0 = 0\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  k0 \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. lookup_pair xs k0 = (0::'b)", "by (simp add: lookup_pair_eq_0)"], ["proof (state)\nthis:\n  lookup_pair xs k0 = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "from False Cons(4)"], ["proof (chain)\npicking this:\n  \\<not> lt k k0\n  ?k'34 \\<in> fst ` set ys \\<Longrightarrow> lt k' ?k'34", "have \"k0 \\<notin> fst ` set ys\""], ["proof (prove)\nusing this:\n  \\<not> lt k k0\n  ?k'34 \\<in> fst ` set ys \\<Longrightarrow> lt k' ?k'34\n\ngoal (1 subgoal):\n 1. k0 \\<notin> fst ` set ys", "unfolding \\<open>k' = k\\<close>"], ["proof (prove)\nusing this:\n  \\<not> lt k k0\n  ?k'34 \\<in> fst ` set ys \\<Longrightarrow> lt k ?k'34\n\ngoal (1 subgoal):\n 1. k0 \\<notin> fst ` set ys", "by blast"], ["proof (state)\nthis:\n  k0 \\<notin> fst ` set ys\n\ngoal (1 subgoal):\n 1. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "with Cons(2)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys\n  k0 \\<notin> fst ` set ys", "have \"lookup_pair ys k0 = 0\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n  k0 \\<notin> fst ` set ys\n\ngoal (1 subgoal):\n 1. lookup_pair ys k0 = (0::'b)", "by (simp add: lookup_pair_eq_0)"], ["proof (state)\nthis:\n  lookup_pair ys k0 = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> lt k k0 \\<Longrightarrow> lookup_pair xs k0 = lookup_pair ys k0", "with eq"], ["proof (chain)\npicking this:\n  lookup_pair xs k0 = (0::'b)\n  lookup_pair ys k0 = (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup_pair xs k0 = (0::'b)\n  lookup_pair ys k0 = (0::'b)\n\ngoal (1 subgoal):\n 1. lookup_pair xs k0 = lookup_pair ys k0", "by simp"], ["proof (state)\nthis:\n  lookup_pair xs k0 = lookup_pair ys k0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair xs k0 = lookup_pair ys k0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair xs = lookup_pair ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = ys\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow> (k, v) # xs = (k', v') # ys\n 2. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "ultimately"], ["proof (chain)\npicking this:\n  v' = v\n  k' = k\n  xs = ys", "show ?thesis"], ["proof (prove)\nusing this:\n  v' = v\n  k' = k\n  xs = ys\n\ngoal (1 subgoal):\n 1. (k, v) # xs = (k', v') # ys", "by simp"], ["proof (state)\nthis:\n  (k, v) # xs = (k', v') # ys\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "case Gt"], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "hence \"\\<not> lt k k'\""], ["proof (prove)\nusing this:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. \\<not> lt k k'", "by (simp add: Gt_lt_conv)"], ["proof (state)\nthis:\n  \\<not> lt k k'\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "with *(4)"], ["proof (chain)\npicking this:\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'34\n  \\<not> lt k k'", "have \"k' \\<notin> fst ` set xs\""], ["proof (prove)\nusing this:\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'34\n  \\<not> lt k k'\n\ngoal (1 subgoal):\n 1. k' \\<notin> fst ` set xs", "by blast"], ["proof (state)\nthis:\n  k' \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "moreover"], ["proof (state)\nthis:\n  k' \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "from Gt"], ["proof (chain)\npicking this:\n  comp k k' = Gt", "have \"k' \\<noteq> k\""], ["proof (prove)\nusing this:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k", "by auto"], ["proof (state)\nthis:\n  k' \\<noteq> k\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "ultimately"], ["proof (chain)\npicking this:\n  k' \\<notin> fst ` set xs\n  k' \\<noteq> k", "have \"k' \\<notin> fst ` set ((k, v) # xs)\""], ["proof (prove)\nusing this:\n  k' \\<notin> fst ` set xs\n  k' \\<noteq> k\n\ngoal (1 subgoal):\n 1. k' \\<notin> fst ` set ((k, v) # xs)", "by simp"], ["proof (state)\nthis:\n  k' \\<notin> fst ` set ((k, v) # xs)\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "hence \"0 = lookup_pair ((k, v) # xs) k'\""], ["proof (prove)\nusing this:\n  k' \\<notin> fst ` set ((k, v) # xs)\n\ngoal (1 subgoal):\n 1. (0::'b) = lookup_pair ((k, v) # xs) k'", "by (simp add: lookup_pair_eq_0[OF *(1)] del: lookup_pair.simps)"], ["proof (state)\nthis:\n  (0::'b) = lookup_pair ((k, v) # xs) k'\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "also"], ["proof (state)\nthis:\n  (0::'b) = lookup_pair ((k, v) # xs) k'\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "have \"... = lookup_pair ((k', v') # ys) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k, v) # xs) k' = lookup_pair ((k', v') # ys) k'", "by (simp only: Cons(6))"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k' = lookup_pair ((k', v') # ys) k'\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "also"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k' = lookup_pair ((k', v') # ys) k'\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "have \"... = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k', v') # ys) k' = v'", "by simp"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # ys) k' = v'\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "finally"], ["proof (chain)\npicking this:\n  (0::'b) = v'", "have \"v' = 0\""], ["proof (prove)\nusing this:\n  (0::'b) = v'\n\ngoal (1 subgoal):\n 1. v' = (0::'b)", "by simp"], ["proof (state)\nthis:\n  v' = (0::'b)\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow> (k, v) # xs = (k', v') # ys", "with Cons(3)"], ["proof (chain)\npicking this:\n  v' \\<noteq> (0::'b)\n  v' = (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  v' \\<noteq> (0::'b)\n  v' = (0::'b)\n\ngoal (1 subgoal):\n 1. (k, v) # xs = (k', v') # ys", ".."], ["proof (state)\nthis:\n  (k, v) # xs = (k', v') # ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (k, v) # xs = (k', v') # ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (k, v) # xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_tl:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair (tl xs) k = (if (\\<forall>k'\\<in>fst ` set xs. le k k') then 0 else lookup_pair xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k =\n    (if \\<forall>k'\\<in>fst ` set xs. le k k' then 0::'b\n     else lookup_pair xs k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k =\n    (if \\<forall>k'\\<in>fst ` set xs. le k k' then 0::'b\n     else lookup_pair xs k)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have 1: \"oalist_inv_raw (tl xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (tl xs)", "by (rule oalist_inv_raw_tl)"], ["proof (state)\nthis:\n  oalist_inv_raw (tl xs)\n\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k =\n    (if \\<forall>k'\\<in>fst ` set xs. le k k' then 0::'b\n     else lookup_pair xs k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k =\n    (if \\<forall>k'\\<in>fst ` set xs. le k k' then 0::'b\n     else lookup_pair xs k)", "proof (split if_split, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>k'\\<in>fst ` set xs. le k k' \\<Longrightarrow>\n    lookup_pair (tl xs) k = (0::'b)\n 2. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "assume *: \"\\<forall>x\\<in>fst ` set xs. le k x\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>fst ` set xs. le k x\n\ngoal (2 subgoals):\n 1. \\<forall>k'\\<in>fst ` set xs. le k k' \\<Longrightarrow>\n    lookup_pair (tl xs) k = (0::'b)\n 2. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "show \"lookup_pair (tl xs) k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k = (0::'b)", "proof (simp add: lookup_pair_eq_0[OF 1], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "assume k_in: \"k \\<in> fst ` set (tl xs)\""], ["proof (state)\nthis:\n  k \\<in> fst ` set (tl xs)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "hence \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (tl xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain k' v' ys where xs: \"xs = (k', v') # ys\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k' v' ys.\n        xs = (k', v') # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust list.exhaust"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>k' v' ys.\n        xs = (k', v') # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs = (k', v') # ys\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "have \"k' \\<in> fst ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs", "unfolding xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set ((k', v') # ys)", "by fastforce"], ["proof (state)\nthis:\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>fst ` set xs. le k x\n  k' \\<in> fst ` set xs", "have \"le k k'\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>fst ` set xs. le k x\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. le k k'", ".."], ["proof (state)\nthis:\n  le k k'\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"oalist_inv_raw ((k', v') # ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ((k', v') # ys)", "by (simp only: xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "from k_in"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set (tl xs)", "have \"k \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (tl xs)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys", "by (simp add: xs)"], ["proof (state)\nthis:\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k', v') # ys)\n  k \\<in> fst ` set ys", "have \"lt k' k\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k', v') # ys)\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k", "by (rule oalist_inv_raw_ConsD3)"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "with \\<open>le k k'\\<close>"], ["proof (chain)\npicking this:\n  le k k'\n  lt k' k", "show False"], ["proof (prove)\nusing this:\n  le k k'\n  lt k' k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (tl xs) k = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "assume \"\\<not> (\\<forall>k'\\<in>fst ` set xs. le k k')\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "hence \"\\<exists>x\\<in>fst ` set xs. \\<not> le k x\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k')\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>fst ` set xs. \\<not> le k x", "by simp"], ["proof (state)\nthis:\n  \\<exists>x\\<in>fst ` set xs. \\<not> le k x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>fst ` set xs. \\<not> le k x", "obtain k'' where k''_in: \"k'' \\<in> fst ` set xs\" and \"\\<not> le k k''\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>fst ` set xs. \\<not> le k x\n\ngoal (1 subgoal):\n 1. (\\<And>k''.\n        \\<lbrakk>k'' \\<in> fst ` set xs; \\<not> le k k''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  k'' \\<in> fst ` set xs\n  \\<not> le k k''\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "from this(2)"], ["proof (chain)\npicking this:\n  \\<not> le k k''", "have \"lt k'' k\""], ["proof (prove)\nusing this:\n  \\<not> le k k''\n\ngoal (1 subgoal):\n 1. lt k'' k", "by simp"], ["proof (state)\nthis:\n  lt k'' k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "from k''_in"], ["proof (chain)\npicking this:\n  k'' \\<in> fst ` set xs", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  k'' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain k' v' ys where xs: \"xs = (k', v') # ys\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k' v' ys.\n        xs = (k', v') # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust list.exhaust"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>k' v' ys.\n        xs = (k', v') # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs = (k', v') # ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "from k''_in"], ["proof (chain)\npicking this:\n  k'' \\<in> fst ` set xs", "have \"k'' = k' \\<or> k'' \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k'' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k'' = k' \\<or> k'' \\<in> fst ` set ys", "by (simp add: xs)"], ["proof (state)\nthis:\n  k'' = k' \\<or> k'' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "hence \"lt k' k\""], ["proof (prove)\nusing this:\n  k'' = k' \\<or> k'' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k'' = k' \\<Longrightarrow> lt k' k\n 2. k'' \\<in> fst ` set ys \\<Longrightarrow> lt k' k", "assume \"k'' = k'\""], ["proof (state)\nthis:\n  k'' = k'\n\ngoal (2 subgoals):\n 1. k'' = k' \\<Longrightarrow> lt k' k\n 2. k'' \\<in> fst ` set ys \\<Longrightarrow> lt k' k", "with \\<open>lt k'' k\\<close>"], ["proof (chain)\npicking this:\n  lt k'' k\n  k'' = k'", "show ?thesis"], ["proof (prove)\nusing this:\n  lt k'' k\n  k'' = k'\n\ngoal (1 subgoal):\n 1. lt k' k", "by simp"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> lt k' k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> lt k' k", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"oalist_inv_raw ((k', v') # ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ((k', v') # ys)", "by (simp only: xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> lt k' k", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> lt k' k", "assume \"k'' \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k'' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> lt k' k", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k', v') # ys)\n  k'' \\<in> fst ` set ys", "have \"lt k' k''\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k', v') # ys)\n  k'' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k''", "by (rule oalist_inv_raw_ConsD3)"], ["proof (state)\nthis:\n  lt k' k''\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> lt k' k", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k' k''\n\ngoal (1 subgoal):\n 1. lt k' k", "using \\<open>lt k'' k\\<close>"], ["proof (prove)\nusing this:\n  lt k' k''\n  lt k'' k\n\ngoal (1 subgoal):\n 1. lt k' k", "by (rule less_trans)"], ["proof (state)\nthis:\n  lt k' k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "hence \"comp k k' = Gt\""], ["proof (prove)\nusing this:\n  lt k' k\n\ngoal (1 subgoal):\n 1. comp k k' = Gt", "by (simp add: Gt_lt_conv)"], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k'\\<in>fst ` set xs. le k k') \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "thus \"lookup_pair (tl xs) k = lookup_pair xs k\""], ["proof (prove)\nusing this:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k = lookup_pair xs k", "by (simp add: xs lt_of_key_order_alt)"], ["proof (state)\nthis:\n  lookup_pair (tl xs) k = lookup_pair xs k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (tl xs) k =\n  (if \\<forall>k'\\<in>fst ` set xs. le k k' then 0::'b\n   else lookup_pair xs k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_tl':\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair (tl xs) k = (if k = fst (hd xs) then 0 else lookup_pair xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k =\n    (if k = fst (hd xs) then 0::'b else lookup_pair xs k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k =\n    (if k = fst (hd xs) then 0::'b else lookup_pair xs k)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have 1: \"oalist_inv_raw (tl xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (tl xs)", "by (rule oalist_inv_raw_tl)"], ["proof (state)\nthis:\n  oalist_inv_raw (tl xs)\n\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k =\n    (if k = fst (hd xs) then 0::'b else lookup_pair xs k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k =\n    (if k = fst (hd xs) then 0::'b else lookup_pair xs k)", "proof (split if_split, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = fst (hd xs) \\<Longrightarrow> lookup_pair (tl xs) k = (0::'b)\n 2. k \\<noteq> fst (hd xs) \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "assume k: \"k = fst (hd xs)\""], ["proof (state)\nthis:\n  k = fst (hd xs)\n\ngoal (2 subgoals):\n 1. k = fst (hd xs) \\<Longrightarrow> lookup_pair (tl xs) k = (0::'b)\n 2. k \\<noteq> fst (hd xs) \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "show \"lookup_pair (tl xs) k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k = (0::'b)", "proof (simp add: lookup_pair_eq_0[OF 1], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "assume k_in: \"k \\<in> fst ` set (tl xs)\""], ["proof (state)\nthis:\n  k \\<in> fst ` set (tl xs)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "hence \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (tl xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain k' v' ys where xs: \"xs = (k', v') # ys\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k' v' ys.\n        xs = (k', v') # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust list.exhaust"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>k' v' ys.\n        xs = (k', v') # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs = (k', v') # ys\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"oalist_inv_raw ((k', v') # ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ((k', v') # ys)", "by (simp only: xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "from k_in"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set (tl xs)", "have \"k' \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (tl xs)\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set ys", "by (simp add: k xs)"], ["proof (state)\nthis:\n  k' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k', v') # ys)\n  k' \\<in> fst ` set ys", "have \"lt k' k'\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k', v') # ys)\n  k' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k'", "by (rule oalist_inv_raw_ConsD3)"], ["proof (state)\nthis:\n  lt k' k'\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (tl xs) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lt k' k'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (tl xs) k = (0::'b)\n\ngoal (1 subgoal):\n 1. k \\<noteq> fst (hd xs) \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> fst (hd xs) \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "assume \"k \\<noteq> fst (hd xs)\""], ["proof (state)\nthis:\n  k \\<noteq> fst (hd xs)\n\ngoal (1 subgoal):\n 1. k \\<noteq> fst (hd xs) \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "show \"lookup_pair (tl xs) k = lookup_pair xs k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k = lookup_pair xs k", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> lookup_pair (tl xs) k = lookup_pair xs k\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> lookup_pair (tl xs) k = lookup_pair xs k\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k = lookup_pair xs k", "by (simp add: True)"], ["proof (state)\nthis:\n  lookup_pair (tl xs) k = lookup_pair xs k\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain k' v' ys where xs: \"xs = (k', v') # ys\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k' v' ys.\n        xs = (k', v') # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust list.exhaust"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>k' v' ys.\n        xs = (k', v') # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs = (k', v') # ys\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    lookup_pair (tl xs) k = lookup_pair xs k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (tl xs) k = lookup_pair xs k", "proof (simp add: xs eq Lt_lt_conv split: order.split, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow> lookup_pair ys k' = v'\n 2. lt k k' \\<Longrightarrow> lookup_pair ys k = (0::'b)", "from \\<open>k \\<noteq> fst (hd xs)\\<close>"], ["proof (chain)\npicking this:\n  k \\<noteq> fst (hd xs)", "have \"k \\<noteq> k'\""], ["proof (prove)\nusing this:\n  k \\<noteq> fst (hd xs)\n\ngoal (1 subgoal):\n 1. k \\<noteq> k'", "by (simp add: xs)"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow> lookup_pair ys k' = v'\n 2. lt k k' \\<Longrightarrow> lookup_pair ys k = (0::'b)", "moreover"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow> lookup_pair ys k' = v'\n 2. lt k k' \\<Longrightarrow> lookup_pair ys k = (0::'b)", "assume \"k = k'\""], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow> lookup_pair ys k' = v'\n 2. lt k k' \\<Longrightarrow> lookup_pair ys k = (0::'b)", "ultimately"], ["proof (chain)\npicking this:\n  k \\<noteq> k'\n  k = k'", "show \"lookup_pair ys k' = v'\""], ["proof (prove)\nusing this:\n  k \\<noteq> k'\n  k = k'\n\ngoal (1 subgoal):\n 1. lookup_pair ys k' = v'", ".."], ["proof (state)\nthis:\n  lookup_pair ys k' = v'\n\ngoal (1 subgoal):\n 1. lt k k' \\<Longrightarrow> lookup_pair ys k = (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lt k k' \\<Longrightarrow> lookup_pair ys k = (0::'b)", "assume \"lt k k'\""], ["proof (state)\nthis:\n  lt k k'\n\ngoal (1 subgoal):\n 1. lt k k' \\<Longrightarrow> lookup_pair ys k = (0::'b)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"oalist_inv_raw ys\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ys", "unfolding xs"], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ys", "by (rule oalist_inv_raw_ConsD1)"], ["proof (state)\nthis:\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. lt k k' \\<Longrightarrow> lookup_pair ys k = (0::'b)", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. lt k k' \\<Longrightarrow> lookup_pair ys k = (0::'b)", "have \"k \\<notin> fst ` set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set ys", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  k \\<in> fst ` set ys", "have \"lt k' k\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k", "unfolding xs"], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k', v') # ys)\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k", "by (rule oalist_inv_raw_ConsD3)"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow> False", "with \\<open>lt k k'\\<close>"], ["proof (chain)\npicking this:\n  lt k k'\n  lt k' k", "show False"], ["proof (prove)\nusing this:\n  lt k k'\n  lt k' k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<notin> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k k' \\<Longrightarrow> lookup_pair ys k = (0::'b)", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys\n  k \\<notin> fst ` set ys", "show \"lookup_pair ys k = 0\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n  k \\<notin> fst ` set ys\n\ngoal (1 subgoal):\n 1. lookup_pair ys k = (0::'b)", "by (simp add: lookup_pair_eq_0)"], ["proof (state)\nthis:\n  lookup_pair ys k = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (tl xs) k = lookup_pair xs k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (tl xs) k = lookup_pair xs k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (tl xs) k =\n  (if k = fst (hd xs) then 0::'b else lookup_pair xs k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_filter:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair (filter P xs) k = (let v = lookup_pair xs k in if P (k, v) then v else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (filter P xs) k =\n    (let v = lookup_pair xs k in if P (k, v) then v else (0::'b))", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. lookup_pair (filter P xs) k =\n    (let v = lookup_pair xs k in if P (k, v) then v else (0::'b))", "proof (induct xs rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup_pair (filter P []) k =\n    (let v = lookup_pair [] k in if P (k, v) then v else (0::'b))\n 2. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (filter P xs) k =\n        (let v = lookup_pair xs k\n         in if P (k, v) then v else (0::'b))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (filter P ((ka, v) # xs)) k =\n                         (let v = lookup_pair ((ka, v) # xs) k\n                          in if P (k, v) then v else (0::'b))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lookup_pair (filter P []) k =\n    (let v = lookup_pair [] k in if P (k, v) then v else (0::'b))\n 2. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (filter P xs) k =\n        (let v = lookup_pair xs k\n         in if P (k, v) then v else (0::'b))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (filter P ((ka, v) # xs)) k =\n                         (let v = lookup_pair ((ka, v) # xs) k\n                          in if P (k, v) then v else (0::'b))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (filter P []) k =\n    (let v = lookup_pair [] k in if P (k, v) then v else (0::'b))", "by simp"], ["proof (state)\nthis:\n  lookup_pair (filter P []) k =\n  (let v = lookup_pair [] k in if P (k, v) then v else (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (filter P xs) k =\n        (let v = lookup_pair xs k\n         in if P (k, v) then v else (0::'b))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (filter P ((ka, v) # xs)) k =\n                         (let v = lookup_pair ((ka, v) # xs) k\n                          in if P (k, v) then v else (0::'b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (filter P xs) k =\n        (let v = lookup_pair xs k\n         in if P (k, v) then v else (0::'b))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (filter P ((ka, v) # xs)) k =\n                         (let v = lookup_pair ((ka, v) # xs) k\n                          in if P (k, v) then v else (0::'b))", "case (Cons k' v' xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # xs)\n  oalist_inv_raw xs\n  v' \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'34\n  lookup_pair (filter P xs) k =\n  (let v = lookup_pair xs k in if P (k, v) then v else (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (filter P xs) k =\n        (let v = lookup_pair xs k\n         in if P (k, v) then v else (0::'b))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (filter P ((ka, v) # xs)) k =\n                         (let v = lookup_pair ((ka, v) # xs) k\n                          in if P (k, v) then v else (0::'b))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (filter P ((k', v') # xs)) k =\n    (let v = lookup_pair ((k', v') # xs) k\n     in if P (k, v) then v else (0::'b))", "proof (simp add: Cons(5) Let_def eq split: order.split, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k = k'; P (k', lookup_pair xs k'); \\<not> P (k', v')\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k' = (0::'b)\n 2. \\<lbrakk>comp k k' = Lt; P (k, lookup_pair xs k);\n     \\<not> P (k', v')\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k = (0::'b)", "show \"lookup_pair xs k' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair xs k' = (0::'b)", "proof (simp add: lookup_pair_eq_0 Cons(2), rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False", "assume \"k' \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False", "hence \"lt k' k'\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k'", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k'\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lt k' k'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair xs k' = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k k' = Lt; P (k, lookup_pair xs k);\n     \\<not> P (k', v')\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k = (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k k' = Lt; P (k, lookup_pair xs k);\n     \\<not> P (k', v')\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k = (0::'b)", "assume \"comp k k' = Lt\""], ["proof (state)\nthis:\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k k' = Lt; P (k, lookup_pair xs k);\n     \\<not> P (k', v')\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k = (0::'b)", "hence \"lt k k'\""], ["proof (prove)\nusing this:\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. lt k k'", "by (simp only: Lt_lt_conv)"], ["proof (state)\nthis:\n  lt k k'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k k' = Lt; P (k, lookup_pair xs k);\n     \\<not> P (k', v')\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k = (0::'b)", "show \"lookup_pair xs k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair xs k = (0::'b)", "proof (simp add: lookup_pair_eq_0 Cons(2), rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False", "assume \"k \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False", "hence \"lt k' k\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False", "with \\<open>lt k k'\\<close>"], ["proof (chain)\npicking this:\n  lt k k'\n  lt k' k", "show False"], ["proof (prove)\nusing this:\n  lt k k'\n  lt k' k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair xs k = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (filter P ((k', v') # xs)) k =\n  (let v = lookup_pair ((k', v') # xs) k in if P (k, v) then v else (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_map:\n  assumes \"oalist_inv_raw xs\"\n    and \"\\<And>k'. snd (f (k', 0)) = 0\"\n    and \"\\<And>a b. comp (fst (f a)) (fst (f b)) = comp (fst a) (fst b)\"\n  shows \"lookup_pair (map f xs) (fst (f (k, v))) = snd (f (k, lookup_pair xs k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map f xs) (fst (f (k, v))) = snd (f (k, lookup_pair xs k))", "using assms(1)"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. lookup_pair (map f xs) (fst (f (k, v))) = snd (f (k, lookup_pair xs k))", "proof (induct xs rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup_pair (map f []) (fst (f (k, v))) = snd (f (k, lookup_pair [] k))\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lookup_pair (map f []) (fst (f (k, v))) = snd (f (k, lookup_pair [] k))\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map f []) (fst (f (k, v))) = snd (f (k, lookup_pair [] k))", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  lookup_pair (map f []) (fst (f (k, v))) = snd (f (k, lookup_pair [] k))\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "case (Cons k' v' xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # xs)\n  oalist_inv_raw xs\n  v' \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'34\n  lookup_pair (map f xs) (fst (f (k, v))) = snd (f (k, lookup_pair xs k))\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "obtain k'' v'' where f: \"f (k', v') = (k'', v'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'' v''.\n        f (k', v') = (k'', v'') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  f (k', v') = (k'', v'')\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "have \"comp k k' = comp (fst (f (k, v))) (fst (f (k', v')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp k k' = comp (fst (f (k, v))) (fst (f (k', v')))", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  comp k k' = comp (fst (f (k, v))) (fst (f (k', v')))\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "also"], ["proof (state)\nthis:\n  comp k k' = comp (fst (f (k, v))) (fst (f (k', v')))\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "have \"... = comp (fst (f (k, v))) k''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp (fst (f (k, v))) (fst (f (k', v'))) = comp (fst (f (k, v))) k''", "by (simp add: f)"], ["proof (state)\nthis:\n  comp (fst (f (k, v))) (fst (f (k', v'))) = comp (fst (f (k, v))) k''\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "finally"], ["proof (chain)\npicking this:\n  comp k k' = comp (fst (f (k, v))) k''", "have eq0: \"comp k k' = comp (fst (f (k, v))) k''\""], ["proof (prove)\nusing this:\n  comp k k' = comp (fst (f (k, v))) k''\n\ngoal (1 subgoal):\n 1. comp k k' = comp (fst (f (k, v))) k''", "."], ["proof (state)\nthis:\n  comp k k' = comp (fst (f (k, v))) k''\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map f ((k', v') # xs)) (fst (f (k, v))) =\n    snd (f (k, lookup_pair ((k', v') # xs) k))", "proof (simp add: assms(2) split: order.split, intro conjI impI, simp add: eq)"], ["proof (state)\ngoal (3 subgoals):\n 1. k = k' \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) = snd (f (k', v'))\n 2. comp k k' = Lt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) = (0::'c)\n 3. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_pair xs k))", "assume \"k = k'\""], ["proof (state)\nthis:\n  k = k'\n\ngoal (3 subgoals):\n 1. k = k' \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) = snd (f (k', v'))\n 2. comp k k' = Lt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) = (0::'c)\n 3. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_pair xs k))", "hence \"lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) =\n            lookup_pair (f (k', v') # map f xs) (fst (f (k, v)))\""], ["proof (prove)\nusing this:\n  k = k'\n\ngoal (1 subgoal):\n 1. lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) =\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v)))", "by simp"], ["proof (state)\nthis:\n  lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) =\n  lookup_pair (f (k', v') # map f xs) (fst (f (k, v)))\n\ngoal (3 subgoals):\n 1. k = k' \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) = snd (f (k', v'))\n 2. comp k k' = Lt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) = (0::'c)\n 3. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_pair xs k))", "also"], ["proof (state)\nthis:\n  lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) =\n  lookup_pair (f (k', v') # map f xs) (fst (f (k, v)))\n\ngoal (3 subgoals):\n 1. k = k' \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) = snd (f (k', v'))\n 2. comp k k' = Lt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) = (0::'c)\n 3. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_pair xs k))", "have \"... = snd (f (k', v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) = snd (f (k', v'))", "by (simp add: f eq0[symmetric], simp add: \\<open>k = k'\\<close>)"], ["proof (state)\nthis:\n  lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) = snd (f (k', v'))\n\ngoal (3 subgoals):\n 1. k = k' \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) = snd (f (k', v'))\n 2. comp k k' = Lt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) = (0::'c)\n 3. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_pair xs k))", "finally"], ["proof (chain)\npicking this:\n  lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) = snd (f (k', v'))", "show \"lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) = snd (f (k', v'))\""], ["proof (prove)\nusing this:\n  lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) = snd (f (k', v'))\n\ngoal (1 subgoal):\n 1. lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) = snd (f (k', v'))", "."], ["proof (state)\nthis:\n  lookup_pair (f (k', v') # map f xs) (fst (f (k', v))) = snd (f (k', v'))\n\ngoal (2 subgoals):\n 1. comp k k' = Lt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) = (0::'c)\n 2. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair (f (k', v') # map f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_pair xs k))", "qed (simp_all add: f eq0 Cons(5))"], ["proof (state)\nthis:\n  lookup_pair (map f ((k', v') # xs)) (fst (f (k, v))) =\n  snd (f (k, lookup_pair ((k', v') # xs) k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_Cons:\n  assumes \"oalist_inv_raw ((k, v) # xs)\"\n  shows \"lookup_pair ((k, v) # xs) k0 = (if k = k0 then v else lookup_pair xs k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k, v) # xs) k0 = (if k = k0 then v else lookup_pair xs k0)", "proof (simp add: eq split: order.split, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k0 k = Lt; k \\<noteq> k0\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k0 = (0::'b)", "assume \"comp k0 k = Lt\""], ["proof (state)\nthis:\n  comp k0 k = Lt\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k0 k = Lt; k \\<noteq> k0\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k0 = (0::'b)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs)", "have inv: \"oalist_inv_raw xs\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw xs", "by (rule oalist_inv_raw_ConsD1)"], ["proof (state)\nthis:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k0 k = Lt; k \\<noteq> k0\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k0 = (0::'b)", "show \"lookup_pair xs k0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair xs k0 = (0::'b)", "proof (simp only: lookup_pair_eq_0[OF inv], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> False", "assume \"k0 \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs)\n  k0 \\<in> fst ` set xs", "have \"lt k k0\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n  k0 \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k0", "by (rule oalist_inv_raw_ConsD3)"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> False", "with \\<open>comp k0 k = Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k0 k = Lt\n  lt k k0", "show False"], ["proof (prove)\nusing this:\n  comp k0 k = Lt\n  lt k k0\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair xs k0 = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_single: \"lookup_pair [(k, v)] k0 = (if k = k0 then v else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair [(k, v)] k0 = (if k = k0 then v else (0::'b))", "by (simp add: eq split: order.split)"], ["", "subsubsection \\<open>@{const update_by_pair}\\<close>"], ["", "lemma set_update_by_pair_subset: \"set (update_by_pair kv xs) \\<subseteq> insert kv (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (update_by_pair kv xs) \\<subseteq> insert kv (set xs)", "proof (induct xs arbitrary: kv)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>kv. set (update_by_pair kv []) \\<subseteq> insert kv (set [])\n 2. \\<And>a xs kv.\n       (\\<And>kv.\n           set (update_by_pair kv xs)\n           \\<subseteq> insert kv (set xs)) \\<Longrightarrow>\n       set (update_by_pair kv (a # xs)) \\<subseteq> insert kv (set (a # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>kv. set (update_by_pair kv []) \\<subseteq> insert kv (set [])\n 2. \\<And>a xs kv.\n       (\\<And>kv.\n           set (update_by_pair kv xs)\n           \\<subseteq> insert kv (set xs)) \\<Longrightarrow>\n       set (update_by_pair kv (a # xs)) \\<subseteq> insert kv (set (a # xs))", "obtain k v where kv: \"kv = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (2 subgoals):\n 1. \\<And>kv. set (update_by_pair kv []) \\<subseteq> insert kv (set [])\n 2. \\<And>a xs kv.\n       (\\<And>kv.\n           set (update_by_pair kv xs)\n           \\<subseteq> insert kv (set xs)) \\<Longrightarrow>\n       set (update_by_pair kv (a # xs)) \\<subseteq> insert kv (set (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. set (update_by_pair kv []) \\<subseteq> insert kv (set [])", "by simp"], ["proof (state)\nthis:\n  set (update_by_pair kv []) \\<subseteq> insert kv (set [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       (\\<And>kv.\n           set (update_by_pair kv xs)\n           \\<subseteq> insert kv (set xs)) \\<Longrightarrow>\n       set (update_by_pair kv (a # xs)) \\<subseteq> insert kv (set (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       (\\<And>kv.\n           set (update_by_pair kv xs)\n           \\<subseteq> insert kv (set xs)) \\<Longrightarrow>\n       set (update_by_pair kv (a # xs)) \\<subseteq> insert kv (set (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  set (update_by_pair ?kv34 xs) \\<subseteq> insert ?kv34 (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       (\\<And>kv.\n           set (update_by_pair kv xs)\n           \\<subseteq> insert kv (set xs)) \\<Longrightarrow>\n       set (update_by_pair kv (a # xs)) \\<subseteq> insert kv (set (a # xs))", "obtain k' v' where x: \"x = (k', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v'. x = (k', v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k', v')\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       (\\<And>kv.\n           set (update_by_pair kv xs)\n           \\<subseteq> insert kv (set xs)) \\<Longrightarrow>\n       set (update_by_pair kv (a # xs)) \\<subseteq> insert kv (set (a # xs))", "obtain k v where kv: \"kv = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       (\\<And>kv.\n           set (update_by_pair kv xs)\n           \\<subseteq> insert kv (set xs)) \\<Longrightarrow>\n       set (update_by_pair kv (a # xs)) \\<subseteq> insert kv (set (a # xs))", "have 1: \"set xs \\<subseteq> insert a (insert b (set xs))\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> insert a (insert b (set xs))", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> insert ?a34 (insert ?b34 (set xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       (\\<And>kv.\n           set (update_by_pair kv xs)\n           \\<subseteq> insert kv (set xs)) \\<Longrightarrow>\n       set (update_by_pair kv (a # xs)) \\<subseteq> insert kv (set (a # xs))", "have 2: \"set (update_by_pair kv xs) \\<subseteq> insert kv (insert (k', v') (set xs))\" for kv"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (update_by_pair kv xs)\n    \\<subseteq> insert kv (insert (k', v') (set xs))", "using Cons"], ["proof (prove)\nusing this:\n  set (update_by_pair ?kv34 xs) \\<subseteq> insert ?kv34 (set xs)\n\ngoal (1 subgoal):\n 1. set (update_by_pair kv xs)\n    \\<subseteq> insert kv (insert (k', v') (set xs))", "by blast"], ["proof (state)\nthis:\n  set (update_by_pair ?kv34 xs)\n  \\<subseteq> insert ?kv34 (insert (k', v') (set xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       (\\<And>kv.\n           set (update_by_pair kv xs)\n           \\<subseteq> insert kv (set xs)) \\<Longrightarrow>\n       set (update_by_pair kv (a # xs)) \\<subseteq> insert kv (set (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (update_by_pair kv (x # xs)) \\<subseteq> insert kv (set (x # xs))", "by (simp add: x kv 1 2 split: order.split)"], ["proof (state)\nthis:\n  set (update_by_pair kv (x # xs)) \\<subseteq> insert kv (set (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma update_by_pair_sorted:\n  assumes \"sorted_wrt lt (map fst xs)\"\n  shows \"sorted_wrt lt (map fst (update_by_pair kv xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (update_by_pair kv xs))", "using assms"], ["proof (prove)\nusing this:\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (update_by_pair kv xs))", "proof (induct xs arbitrary: kv)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>kv.\n       sorted_wrt lt (map fst []) \\<Longrightarrow>\n       sorted_wrt lt (map fst (update_by_pair kv []))\n 2. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "case Nil"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst [])\n\ngoal (2 subgoals):\n 1. \\<And>kv.\n       sorted_wrt lt (map fst []) \\<Longrightarrow>\n       sorted_wrt lt (map fst (update_by_pair kv []))\n 2. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "obtain k v where kv: \"kv = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (2 subgoals):\n 1. \\<And>kv.\n       sorted_wrt lt (map fst []) \\<Longrightarrow>\n       sorted_wrt lt (map fst (update_by_pair kv []))\n 2. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (update_by_pair kv []))", "by simp"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst (update_by_pair kv []))\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst xs) \\<Longrightarrow>\n  sorted_wrt lt (map fst (update_by_pair ?kv34 xs))\n  sorted_wrt lt (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "obtain k' v' where x: \"x = (k', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v'. x = (k', v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k', v')\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "obtain k v where kv: \"kv = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "from Cons(2)"], ["proof (chain)\npicking this:\n  sorted_wrt lt (map fst (x # xs))", "have 1: \"sorted_wrt lt (k' # (map fst xs))\""], ["proof (prove)\nusing this:\n  sorted_wrt lt (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (k' # map fst xs)", "by (simp add: x)"], ["proof (state)\nthis:\n  sorted_wrt lt (k' # map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "hence 2: \"sorted_wrt lt (map fst xs)\""], ["proof (prove)\nusing this:\n  sorted_wrt lt (k' # map fst xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "using sorted_wrt.elims(3)"], ["proof (prove)\nusing this:\n  sorted_wrt lt (k' # map fst xs)\n  \\<lbrakk>\\<not> sorted_wrt ?x ?xa;\n   \\<And>P x ys.\n      \\<lbrakk>?x = P; ?xa = x # ys;\n       \\<not> (Ball (set ys) (P x) \\<and> sorted_wrt P ys)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "by fastforce"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "hence 3: \"sorted_wrt lt (map fst (update_by_pair (k, u) xs))\" for u"], ["proof (prove)\nusing this:\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (update_by_pair (k, u) xs))", "by (rule Cons(1))"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst (update_by_pair (k, ?u34) xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "have 4: \"sorted_wrt lt (k' # map fst (update_by_pair (k, u) xs))\"\n    if *: \"comp k k' = Gt\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt lt (k' # map fst (update_by_pair (k, u) xs))", "proof (simp, intro conjI ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (update_by_pair (k, u) xs) \\<Longrightarrow>\n       lt k' (fst x)\n 2. sorted_wrt lt (map fst (update_by_pair (k, u) xs))", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (update_by_pair (k, u) xs) \\<Longrightarrow>\n       lt k' (fst x)\n 2. sorted_wrt lt (map fst (update_by_pair (k, u) xs))", "assume \"y \\<in> set (update_by_pair (k, u) xs)\""], ["proof (state)\nthis:\n  y \\<in> set (update_by_pair (k, u) xs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (update_by_pair (k, u) xs) \\<Longrightarrow>\n       lt k' (fst x)\n 2. sorted_wrt lt (map fst (update_by_pair (k, u) xs))", "also"], ["proof (state)\nthis:\n  y \\<in> set (update_by_pair (k, u) xs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (update_by_pair (k, u) xs) \\<Longrightarrow>\n       lt k' (fst x)\n 2. sorted_wrt lt (map fst (update_by_pair (k, u) xs))", "from set_update_by_pair_subset"], ["proof (chain)\npicking this:\n  set (update_by_pair ?kv ?xs) \\<subseteq> insert ?kv (set ?xs)", "have \"... \\<subseteq> insert (k, u) (set xs)\""], ["proof (prove)\nusing this:\n  set (update_by_pair ?kv ?xs) \\<subseteq> insert ?kv (set ?xs)\n\ngoal (1 subgoal):\n 1. set (update_by_pair (k, u) xs) \\<subseteq> insert (k, u) (set xs)", "."], ["proof (state)\nthis:\n  set (update_by_pair (k, u) xs) \\<subseteq> insert (k, u) (set xs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (update_by_pair (k, u) xs) \\<Longrightarrow>\n       lt k' (fst x)\n 2. sorted_wrt lt (map fst (update_by_pair (k, u) xs))", "finally"], ["proof (chain)\npicking this:\n  y \\<in> insert (k, u) (set xs)", "have \"y = (k, u) \\<or> y \\<in> set xs\""], ["proof (prove)\nusing this:\n  y \\<in> insert (k, u) (set xs)\n\ngoal (1 subgoal):\n 1. y = (k, u) \\<or> y \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  y = (k, u) \\<or> y \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (update_by_pair (k, u) xs) \\<Longrightarrow>\n       lt k' (fst x)\n 2. sorted_wrt lt (map fst (update_by_pair (k, u) xs))", "thus \"lt k' (fst y)\""], ["proof (prove)\nusing this:\n  y = (k, u) \\<or> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. lt k' (fst y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. y = (k, u) \\<Longrightarrow> lt k' (fst y)\n 2. y \\<in> set xs \\<Longrightarrow> lt k' (fst y)", "assume \"y = (k, u)\""], ["proof (state)\nthis:\n  y = (k, u)\n\ngoal (2 subgoals):\n 1. y = (k, u) \\<Longrightarrow> lt k' (fst y)\n 2. y \\<in> set xs \\<Longrightarrow> lt k' (fst y)", "hence \"fst y = k\""], ["proof (prove)\nusing this:\n  y = (k, u)\n\ngoal (1 subgoal):\n 1. fst y = k", "by simp"], ["proof (state)\nthis:\n  fst y = k\n\ngoal (2 subgoals):\n 1. y = (k, u) \\<Longrightarrow> lt k' (fst y)\n 2. y \\<in> set xs \\<Longrightarrow> lt k' (fst y)", "with *"], ["proof (chain)\npicking this:\n  comp k k' = Gt\n  fst y = k", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k k' = Gt\n  fst y = k\n\ngoal (1 subgoal):\n 1. lt k' (fst y)", "by (simp only: Gt_lt_conv)"], ["proof (state)\nthis:\n  lt k' (fst y)\n\ngoal (1 subgoal):\n 1. y \\<in> set xs \\<Longrightarrow> lt k' (fst y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> set xs \\<Longrightarrow> lt k' (fst y)", "from 1"], ["proof (chain)\npicking this:\n  sorted_wrt lt (k' # map fst xs)", "have 5: \"\\<forall>y \\<in> fst ` set xs. lt k' y\""], ["proof (prove)\nusing this:\n  sorted_wrt lt (k' # map fst xs)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>fst ` set xs. lt k' y", "by simp"], ["proof (state)\nthis:\n  \\<forall>y\\<in>fst ` set xs. lt k' y\n\ngoal (1 subgoal):\n 1. y \\<in> set xs \\<Longrightarrow> lt k' (fst y)", "assume \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. y \\<in> set xs \\<Longrightarrow> lt k' (fst y)", "hence \"fst y \\<in> fst ` set xs\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. fst y \\<in> fst ` set xs", "by simp"], ["proof (state)\nthis:\n  fst y \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. y \\<in> set xs \\<Longrightarrow> lt k' (fst y)", "with 5"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>fst ` set xs. lt k' y\n  fst y \\<in> fst ` set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>fst ` set xs. lt k' y\n  fst y \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' (fst y)", ".."], ["proof (state)\nthis:\n  lt k' (fst y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt k' (fst y)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (update_by_pair (k, u) xs))", "qed (fact 3)"], ["proof (state)\nthis:\n  comp k k' = Gt \\<Longrightarrow>\n  sorted_wrt lt (k' # map fst (update_by_pair (k, ?u34) xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   sorted_wrt lt (map fst xs) \\<Longrightarrow>\n                   sorted_wrt lt (map fst (update_by_pair kv xs));\n        sorted_wrt lt (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt lt\n                          (map fst (update_by_pair kv (a # xs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (update_by_pair kv (x # xs)))", "by (simp add: kv x 1 2 4 sorted_wrt2 split: order.split del: sorted_wrt.simps,\n        intro conjI impI, simp add: 1 eq del: sorted_wrt.simps, simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst (update_by_pair kv (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma update_by_pair_not_0:\n  assumes \"0 \\<notin> snd ` set xs\"\n  shows \"0 \\<notin> snd ` set (update_by_pair kv xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (update_by_pair kv xs)", "using assms"], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (update_by_pair kv xs)", "proof (induct xs arbitrary: kv)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>kv.\n       (0::'b) \\<notin> snd ` set [] \\<Longrightarrow>\n       (0::'b) \\<notin> snd ` set (update_by_pair kv [])\n 2. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   (0::'b) \\<notin> snd ` set xs \\<Longrightarrow>\n                   (0::'b) \\<notin> snd ` set (update_by_pair kv xs);\n        (0::'b) \\<notin> snd ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (0::'b)\n                         \\<notin> snd ` set (update_by_pair kv (a # xs))", "case Nil"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set []\n\ngoal (2 subgoals):\n 1. \\<And>kv.\n       (0::'b) \\<notin> snd ` set [] \\<Longrightarrow>\n       (0::'b) \\<notin> snd ` set (update_by_pair kv [])\n 2. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   (0::'b) \\<notin> snd ` set xs \\<Longrightarrow>\n                   (0::'b) \\<notin> snd ` set (update_by_pair kv xs);\n        (0::'b) \\<notin> snd ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (0::'b)\n                         \\<notin> snd ` set (update_by_pair kv (a # xs))", "obtain k v where kv: \"kv = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (2 subgoals):\n 1. \\<And>kv.\n       (0::'b) \\<notin> snd ` set [] \\<Longrightarrow>\n       (0::'b) \\<notin> snd ` set (update_by_pair kv [])\n 2. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   (0::'b) \\<notin> snd ` set xs \\<Longrightarrow>\n                   (0::'b) \\<notin> snd ` set (update_by_pair kv xs);\n        (0::'b) \\<notin> snd ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (0::'b)\n                         \\<notin> snd ` set (update_by_pair kv (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (update_by_pair kv [])", "by simp"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set (update_by_pair kv [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   (0::'b) \\<notin> snd ` set xs \\<Longrightarrow>\n                   (0::'b) \\<notin> snd ` set (update_by_pair kv xs);\n        (0::'b) \\<notin> snd ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (0::'b)\n                         \\<notin> snd ` set (update_by_pair kv (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   (0::'b) \\<notin> snd ` set xs \\<Longrightarrow>\n                   (0::'b) \\<notin> snd ` set (update_by_pair kv xs);\n        (0::'b) \\<notin> snd ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (0::'b)\n                         \\<notin> snd ` set (update_by_pair kv (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set xs \\<Longrightarrow>\n  (0::'b) \\<notin> snd ` set (update_by_pair ?kv34 xs)\n  (0::'b) \\<notin> snd ` set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   (0::'b) \\<notin> snd ` set xs \\<Longrightarrow>\n                   (0::'b) \\<notin> snd ` set (update_by_pair kv xs);\n        (0::'b) \\<notin> snd ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (0::'b)\n                         \\<notin> snd ` set (update_by_pair kv (a # xs))", "obtain k' v' where x: \"x = (k', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v'. x = (k', v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k', v')\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   (0::'b) \\<notin> snd ` set xs \\<Longrightarrow>\n                   (0::'b) \\<notin> snd ` set (update_by_pair kv xs);\n        (0::'b) \\<notin> snd ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (0::'b)\n                         \\<notin> snd ` set (update_by_pair kv (a # xs))", "obtain k v where kv: \"kv = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   (0::'b) \\<notin> snd ` set xs \\<Longrightarrow>\n                   (0::'b) \\<notin> snd ` set (update_by_pair kv xs);\n        (0::'b) \\<notin> snd ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (0::'b)\n                         \\<notin> snd ` set (update_by_pair kv (a # xs))", "from Cons(2)"], ["proof (chain)\npicking this:\n  (0::'b) \\<notin> snd ` set (x # xs)", "have 1: \"v' \\<noteq> 0\" and 2: \"0 \\<notin> snd ` set xs\""], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set (x # xs)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> (0::'b) &&& (0::'b) \\<notin> snd ` set xs", "by (auto simp: x)"], ["proof (state)\nthis:\n  v' \\<noteq> (0::'b)\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   (0::'b) \\<notin> snd ` set xs \\<Longrightarrow>\n                   (0::'b) \\<notin> snd ` set (update_by_pair kv xs);\n        (0::'b) \\<notin> snd ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (0::'b)\n                         \\<notin> snd ` set (update_by_pair kv (a # xs))", "from 2"], ["proof (chain)\npicking this:\n  (0::'b) \\<notin> snd ` set xs", "have 3: \"0 \\<notin> snd ` set (update_by_pair (k, u) xs)\" for u"], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (update_by_pair (k, u) xs)", "by (rule Cons(1))"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set (update_by_pair (k, ?u34) xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs kv.\n       \\<lbrakk>\\<And>kv.\n                   (0::'b) \\<notin> snd ` set xs \\<Longrightarrow>\n                   (0::'b) \\<notin> snd ` set (update_by_pair kv xs);\n        (0::'b) \\<notin> snd ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (0::'b)\n                         \\<notin> snd ` set (update_by_pair kv (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (update_by_pair kv (x # xs))", "by (auto simp: kv x 1 2 3 split: order.split)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set (update_by_pair kv (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary oalist_inv_raw_update_by_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"oalist_inv_raw (update_by_pair kv xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (update_by_pair kv xs)", "proof (rule oalist_inv_rawI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'b) \\<notin> snd ` set (update_by_pair kv xs)\n 2. sorted_wrt lt (map fst (update_by_pair kv xs))", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"0 \\<notin> snd ` set xs\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set xs", "by (rule oalist_inv_rawD1)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (2 subgoals):\n 1. (0::'b) \\<notin> snd ` set (update_by_pair kv xs)\n 2. sorted_wrt lt (map fst (update_by_pair kv xs))", "thus \"0 \\<notin> snd ` set (update_by_pair kv xs)\""], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (update_by_pair kv xs)", "by (rule update_by_pair_not_0)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set (update_by_pair kv xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (update_by_pair kv xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (update_by_pair kv xs))", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have \"sorted_wrt lt (map fst xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst xs)", "by (rule oalist_inv_rawD2)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (update_by_pair kv xs))", "thus \"sorted_wrt lt (map fst (update_by_pair kv xs))\""], ["proof (prove)\nusing this:\n  sorted_wrt lt (map fst xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt lt (map fst (update_by_pair kv xs))", "by (rule update_by_pair_sorted)"], ["proof (state)\nthis:\n  sorted_wrt lt (map fst (update_by_pair kv xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma update_by_pair_less:\n  assumes \"v \\<noteq> 0\" and \"xs = [] \\<or> comp k (fst (hd xs)) = Lt\"\n  shows \"update_by_pair (k, v) xs = (k, v) # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_pair (k, v) xs = (k, v) # xs", "using assms(2)"], ["proof (prove)\nusing this:\n  xs = [] \\<or> comp k (fst (hd xs)) = Lt\n\ngoal (1 subgoal):\n 1. update_by_pair (k, v) xs = (k, v) # xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] = [] \\<or> comp k (fst (hd [])) = Lt \\<Longrightarrow>\n    update_by_pair (k, v) [] = [(k, v)]\n 2. \\<And>a xs.\n       \\<lbrakk>xs = [] \\<or> comp k (fst (hd xs)) = Lt \\<Longrightarrow>\n                update_by_pair (k, v) xs = (k, v) # xs;\n        a # xs = [] \\<or> comp k (fst (hd (a # xs))) = Lt\\<rbrakk>\n       \\<Longrightarrow> update_by_pair (k, v) (a # xs) = (k, v) # a # xs", "case Nil"], ["proof (state)\nthis:\n  [] = [] \\<or> comp k (fst (hd [])) = Lt\n\ngoal (2 subgoals):\n 1. [] = [] \\<or> comp k (fst (hd [])) = Lt \\<Longrightarrow>\n    update_by_pair (k, v) [] = [(k, v)]\n 2. \\<And>a xs.\n       \\<lbrakk>xs = [] \\<or> comp k (fst (hd xs)) = Lt \\<Longrightarrow>\n                update_by_pair (k, v) xs = (k, v) # xs;\n        a # xs = [] \\<or> comp k (fst (hd (a # xs))) = Lt\\<rbrakk>\n       \\<Longrightarrow> update_by_pair (k, v) (a # xs) = (k, v) # a # xs", "from assms(1)"], ["proof (chain)\npicking this:\n  v \\<noteq> (0::'b)", "show ?case"], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. update_by_pair (k, v) [] = [(k, v)]", "by simp"], ["proof (state)\nthis:\n  update_by_pair (k, v) [] = [(k, v)]\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs = [] \\<or> comp k (fst (hd xs)) = Lt \\<Longrightarrow>\n                update_by_pair (k, v) xs = (k, v) # xs;\n        a # xs = [] \\<or> comp k (fst (hd (a # xs))) = Lt\\<rbrakk>\n       \\<Longrightarrow> update_by_pair (k, v) (a # xs) = (k, v) # a # xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs = [] \\<or> comp k (fst (hd xs)) = Lt \\<Longrightarrow>\n                update_by_pair (k, v) xs = (k, v) # xs;\n        a # xs = [] \\<or> comp k (fst (hd (a # xs))) = Lt\\<rbrakk>\n       \\<Longrightarrow> update_by_pair (k, v) (a # xs) = (k, v) # a # xs", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs = [] \\<or> comp k (fst (hd xs)) = Lt \\<Longrightarrow>\n  update_by_pair (k, v) xs = (k, v) # xs\n  x # xs = [] \\<or> comp k (fst (hd (x # xs))) = Lt\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs = [] \\<or> comp k (fst (hd xs)) = Lt \\<Longrightarrow>\n                update_by_pair (k, v) xs = (k, v) # xs;\n        a # xs = [] \\<or> comp k (fst (hd (a # xs))) = Lt\\<rbrakk>\n       \\<Longrightarrow> update_by_pair (k, v) (a # xs) = (k, v) # a # xs", "obtain k' v' where x: \"x = (k', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v'. x = (k', v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k', v')\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs = [] \\<or> comp k (fst (hd xs)) = Lt \\<Longrightarrow>\n                update_by_pair (k, v) xs = (k, v) # xs;\n        a # xs = [] \\<or> comp k (fst (hd (a # xs))) = Lt\\<rbrakk>\n       \\<Longrightarrow> update_by_pair (k, v) (a # xs) = (k, v) # a # xs", "from Cons(2)"], ["proof (chain)\npicking this:\n  x # xs = [] \\<or> comp k (fst (hd (x # xs))) = Lt", "have \"comp k k' = Lt\""], ["proof (prove)\nusing this:\n  x # xs = [] \\<or> comp k (fst (hd (x # xs))) = Lt\n\ngoal (1 subgoal):\n 1. comp k k' = Lt", "by (simp add: x)"], ["proof (state)\nthis:\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs = [] \\<or> comp k (fst (hd xs)) = Lt \\<Longrightarrow>\n                update_by_pair (k, v) xs = (k, v) # xs;\n        a # xs = [] \\<or> comp k (fst (hd (a # xs))) = Lt\\<rbrakk>\n       \\<Longrightarrow> update_by_pair (k, v) (a # xs) = (k, v) # a # xs", "with assms(1)"], ["proof (chain)\npicking this:\n  v \\<noteq> (0::'b)\n  comp k k' = Lt", "show ?case"], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'b)\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. update_by_pair (k, v) (x # xs) = (k, v) # x # xs", "by (simp add: x)"], ["proof (state)\nthis:\n  update_by_pair (k, v) (x # xs) = (k, v) # x # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_update_by_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair (update_by_pair (k1, v) xs) k2 = (if k1 = k2 then v else lookup_pair xs k2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (update_by_pair (k1, v) xs) k2 =\n    (if k1 = k2 then v else lookup_pair xs k2)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. lookup_pair (update_by_pair (k1, v) xs) k2 =\n    (if k1 = k2 then v else lookup_pair xs k2)", "proof (induct xs arbitrary: v rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       lookup_pair (update_by_pair (k1, v) []) k2 =\n       (if k1 = k2 then v else lookup_pair [] k2)\n 2. \\<And>k v xs va.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>v.\n           lookup_pair (update_by_pair (k1, v) xs) k2 =\n           (if k1 = k2 then v else lookup_pair xs k2)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (update_by_pair (k1, va) ((k, v) # xs))\n                          k2 =\n                         (if k1 = k2 then va\n                          else lookup_pair ((k, v) # xs) k2)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>v.\n       lookup_pair (update_by_pair (k1, v) []) k2 =\n       (if k1 = k2 then v else lookup_pair [] k2)\n 2. \\<And>k v xs va.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>v.\n           lookup_pair (update_by_pair (k1, v) xs) k2 =\n           (if k1 = k2 then v else lookup_pair xs k2)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (update_by_pair (k1, va) ((k, v) # xs))\n                          k2 =\n                         (if k1 = k2 then va\n                          else lookup_pair ((k, v) # xs) k2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (update_by_pair (k1, v) []) k2 =\n    (if k1 = k2 then v else lookup_pair [] k2)", "by (simp split: order.split, simp add: eq)"], ["proof (state)\nthis:\n  lookup_pair (update_by_pair (k1, v) []) k2 =\n  (if k1 = k2 then v else lookup_pair [] k2)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs va.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>v.\n           lookup_pair (update_by_pair (k1, v) xs) k2 =\n           (if k1 = k2 then v else lookup_pair xs k2)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (update_by_pair (k1, va) ((k, v) # xs))\n                          k2 =\n                         (if k1 = k2 then va\n                          else lookup_pair ((k, v) # xs) k2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs va.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>v.\n           lookup_pair (update_by_pair (k1, v) xs) k2 =\n           (if k1 = k2 then v else lookup_pair xs k2)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (update_by_pair (k1, va) ((k, v) # xs))\n                          k2 =\n                         (if k1 = k2 then va\n                          else lookup_pair ((k, v) # xs) k2)", "case (Cons k' v' xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # xs)\n  oalist_inv_raw xs\n  v' \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'34\n  lookup_pair (update_by_pair (k1, ?v34) xs) k2 =\n  (if k1 = k2 then ?v34 else lookup_pair xs k2)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs va.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>v.\n           lookup_pair (update_by_pair (k1, v) xs) k2 =\n           (if k1 = k2 then v else lookup_pair xs k2)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (update_by_pair (k1, va) ((k, v) # xs))\n                          k2 =\n                         (if k1 = k2 then va\n                          else lookup_pair ((k, v) # xs) k2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n    (if k1 = k2 then v else lookup_pair ((k', v') # xs) k2)", "proof (split if_split, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. k1 = k2 \\<Longrightarrow>\n    lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 = v\n 2. k1 \\<noteq> k2 \\<Longrightarrow>\n    lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n    lookup_pair ((k', v') # xs) k2", "assume \"k1 = k2\""], ["proof (state)\nthis:\n  k1 = k2\n\ngoal (2 subgoals):\n 1. k1 = k2 \\<Longrightarrow>\n    lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 = v\n 2. k1 \\<noteq> k2 \\<Longrightarrow>\n    lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n    lookup_pair ((k', v') # xs) k2", "with Cons(5)"], ["proof (chain)\npicking this:\n  lookup_pair (update_by_pair (k1, ?v34) xs) k2 =\n  (if k1 = k2 then ?v34 else lookup_pair xs k2)\n  k1 = k2", "have eq0: \"lookup_pair (update_by_pair (k2, u) xs) k2 = u\" for u"], ["proof (prove)\nusing this:\n  lookup_pair (update_by_pair (k1, ?v34) xs) k2 =\n  (if k1 = k2 then ?v34 else lookup_pair xs k2)\n  k1 = k2\n\ngoal (1 subgoal):\n 1. lookup_pair (update_by_pair (k2, u) xs) k2 = u", "by (simp del: update_by_pair.simps)"], ["proof (state)\nthis:\n  lookup_pair (update_by_pair (k2, ?u34) xs) k2 = ?u34\n\ngoal (2 subgoals):\n 1. k1 = k2 \\<Longrightarrow>\n    lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 = v\n 2. k1 \\<noteq> k2 \\<Longrightarrow>\n    lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n    lookup_pair ((k', v') # xs) k2", "show \"lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 = v", "proof (simp add: \\<open>k1 = k2\\<close> eq0 split: order.split, intro conjI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k2 k' = Eq; v = (0::'b)\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k2 = (0::'b)", "assume \"comp k2 k' = Eq\""], ["proof (state)\nthis:\n  comp k2 k' = Eq\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k2 k' = Eq; v = (0::'b)\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k2 = (0::'b)", "hence \"\\<not> lt k' k2\""], ["proof (prove)\nusing this:\n  comp k2 k' = Eq\n\ngoal (1 subgoal):\n 1. \\<not> lt k' k2", "by (simp add: eq)"], ["proof (state)\nthis:\n  \\<not> lt k' k2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k2 k' = Eq; v = (0::'b)\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k2 = (0::'b)", "with Cons(4)"], ["proof (chain)\npicking this:\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'34\n  \\<not> lt k' k2", "have \"k2 \\<notin> fst ` set xs\""], ["proof (prove)\nusing this:\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'34\n  \\<not> lt k' k2\n\ngoal (1 subgoal):\n 1. k2 \\<notin> fst ` set xs", "by auto"], ["proof (state)\nthis:\n  k2 \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k2 k' = Eq; v = (0::'b)\\<rbrakk>\n    \\<Longrightarrow> lookup_pair xs k2 = (0::'b)", "thus \"lookup_pair xs k2 = 0\""], ["proof (prove)\nusing this:\n  k2 \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. lookup_pair xs k2 = (0::'b)", "using Cons(2)"], ["proof (prove)\nusing this:\n  k2 \\<notin> fst ` set xs\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. lookup_pair xs k2 = (0::'b)", "by (simp add: lookup_pair_eq_0)"], ["proof (state)\nthis:\n  lookup_pair xs k2 = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 = v\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> k2 \\<Longrightarrow>\n    lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n    lookup_pair ((k', v') # xs) k2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k1 \\<noteq> k2 \\<Longrightarrow>\n    lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n    lookup_pair ((k', v') # xs) k2", "assume \"k1 \\<noteq> k2\""], ["proof (state)\nthis:\n  k1 \\<noteq> k2\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> k2 \\<Longrightarrow>\n    lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n    lookup_pair ((k', v') # xs) k2", "with Cons(5)"], ["proof (chain)\npicking this:\n  lookup_pair (update_by_pair (k1, ?v34) xs) k2 =\n  (if k1 = k2 then ?v34 else lookup_pair xs k2)\n  k1 \\<noteq> k2", "have eq0: \"lookup_pair (update_by_pair (k1, u) xs) k2 = lookup_pair xs k2\" for u"], ["proof (prove)\nusing this:\n  lookup_pair (update_by_pair (k1, ?v34) xs) k2 =\n  (if k1 = k2 then ?v34 else lookup_pair xs k2)\n  k1 \\<noteq> k2\n\ngoal (1 subgoal):\n 1. lookup_pair (update_by_pair (k1, u) xs) k2 = lookup_pair xs k2", "by (simp del: update_by_pair.simps)"], ["proof (state)\nthis:\n  lookup_pair (update_by_pair (k1, ?u34) xs) k2 = lookup_pair xs k2\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> k2 \\<Longrightarrow>\n    lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n    lookup_pair ((k', v') # xs) k2", "have *: \"lookup_pair xs k2 = 0\" if \"lt k2 k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair xs k2 = (0::'b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_pair xs k2 = (0::'b)", "from \\<open>lt k2 k'\\<close>"], ["proof (chain)\npicking this:\n  lt k2 k'", "have \"\\<not> lt k' k2\""], ["proof (prove)\nusing this:\n  lt k2 k'\n\ngoal (1 subgoal):\n 1. \\<not> lt k' k2", "by auto"], ["proof (state)\nthis:\n  \\<not> lt k' k2\n\ngoal (1 subgoal):\n 1. lookup_pair xs k2 = (0::'b)", "with Cons(4)"], ["proof (chain)\npicking this:\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'34\n  \\<not> lt k' k2", "have \"k2 \\<notin> fst ` set xs\""], ["proof (prove)\nusing this:\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'34\n  \\<not> lt k' k2\n\ngoal (1 subgoal):\n 1. k2 \\<notin> fst ` set xs", "by auto"], ["proof (state)\nthis:\n  k2 \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. lookup_pair xs k2 = (0::'b)", "thus \"lookup_pair xs k2 = 0\""], ["proof (prove)\nusing this:\n  k2 \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. lookup_pair xs k2 = (0::'b)", "using Cons(2)"], ["proof (prove)\nusing this:\n  k2 \\<notin> fst ` set xs\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. lookup_pair xs k2 = (0::'b)", "by (simp add: lookup_pair_eq_0)"], ["proof (state)\nthis:\n  lookup_pair xs k2 = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt k2 k' \\<Longrightarrow> lookup_pair xs k2 = (0::'b)\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> k2 \\<Longrightarrow>\n    lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n    lookup_pair ((k', v') # xs) k2", "show \"lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 = lookup_pair ((k', v') # xs) k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n    lookup_pair ((k', v') # xs) k2", "by (simp add: \\<open>k1 \\<noteq> k2\\<close> eq0 split: order.split,\n          auto intro: * simp: \\<open>k1 \\<noteq> k2\\<close>[symmetric] eq Gt_lt_conv Lt_lt_conv)"], ["proof (state)\nthis:\n  lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n  lookup_pair ((k', v') # xs) k2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (update_by_pair (k1, v) ((k', v') # xs)) k2 =\n  (if k1 = k2 then v else lookup_pair ((k', v') # xs) k2)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary update_by_pair_id:\n  assumes \"oalist_inv_raw xs\" and \"lookup_pair xs k = v\"\n  shows \"update_by_pair (k, v) xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_pair (k, v) xs = xs", "proof (rule lookup_pair_inj, rule oalist_inv_raw_update_by_pair)"], ["proof (state)\ngoal (3 subgoals):\n 1. oalist_inv_raw xs\n 2. oalist_inv_raw xs\n 3. lookup_pair (update_by_pair (k, v) xs) = lookup_pair xs", "show \"lookup_pair (update_by_pair (k, v) xs) = lookup_pair xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (update_by_pair (k, v) xs) = lookup_pair xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup_pair (update_by_pair (k, v) xs) x = lookup_pair xs x", "fix k0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup_pair (update_by_pair (k, v) xs) x = lookup_pair xs x", "from assms(2)"], ["proof (chain)\npicking this:\n  lookup_pair xs k = v", "show \"lookup_pair (update_by_pair (k, v) xs) k0 = lookup_pair xs k0\""], ["proof (prove)\nusing this:\n  lookup_pair xs k = v\n\ngoal (1 subgoal):\n 1. lookup_pair (update_by_pair (k, v) xs) k0 = lookup_pair xs k0", "by (auto simp: lookup_pair_update_by_pair[OF assms(1)])"], ["proof (state)\nthis:\n  lookup_pair (update_by_pair (k, v) xs) k0 = lookup_pair xs k0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (update_by_pair (k, v) xs) = lookup_pair xs\n\ngoal (2 subgoals):\n 1. oalist_inv_raw xs\n 2. oalist_inv_raw xs", "qed fact+"], ["", "lemma set_update_by_pair:\n  assumes \"oalist_inv_raw xs\" and \"v \\<noteq> 0\"\n  shows \"set (update_by_pair (k, v) xs) = insert (k, v) (set xs - range (Pair k))\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (update_by_pair (k, v) xs) = insert (k, v) (set xs - range (Pair k))", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (update_by_pair (k, v) xs)) =\n       (x \\<in> insert (k, v) (set xs - range (Pair k)))", "fix x::\"'a \\<times> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (update_by_pair (k, v) xs)) =\n       (x \\<in> insert (k, v) (set xs - range (Pair k)))", "obtain k' v' where x: \"x = (k', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v'. x = (k', v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k', v')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (update_by_pair (k, v) xs)) =\n       (x \\<in> insert (k, v) (set xs - range (Pair k)))", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have inv: \"oalist_inv_raw (update_by_pair (k, v) xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (update_by_pair (k, v) xs)", "by (rule oalist_inv_raw_update_by_pair)"], ["proof (state)\nthis:\n  oalist_inv_raw (update_by_pair (k, v) xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (update_by_pair (k, v) xs)) =\n       (x \\<in> insert (k, v) (set xs - range (Pair k)))", "show \"(x \\<in> ?A) \\<longleftrightarrow> (x \\<in> ?B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))", "proof (cases \"v' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' = (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))\n 2. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))", "case True"], ["proof (state)\nthis:\n  v' = (0::'b)\n\ngoal (2 subgoals):\n 1. v' = (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))\n 2. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))", "have \"0 \\<notin> snd ` set (update_by_pair (k, v) xs)\" and \"0 \\<notin> snd ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (update_by_pair (k, v) xs) &&&\n    (0::'b) \\<notin> snd ` set xs", "by (rule oalist_inv_rawD1, fact)+"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set (update_by_pair (k, v) xs)\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (2 subgoals):\n 1. v' = (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))\n 2. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))", "hence \"(k', 0) \\<notin> set (update_by_pair (k, v) xs)\" and \"(k', 0) \\<notin> set xs\""], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set (update_by_pair (k, v) xs)\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. (k', 0::'b) \\<notin> set (update_by_pair (k, v) xs) &&&\n    (k', 0::'b) \\<notin> set xs", "using image_iff"], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set (update_by_pair (k, v) xs)\n  (0::'b) \\<notin> snd ` set xs\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. (k', 0::'b) \\<notin> set (update_by_pair (k, v) xs) &&&\n    (k', 0::'b) \\<notin> set xs", "by fastforce+"], ["proof (state)\nthis:\n  (k', 0::'b) \\<notin> set (update_by_pair (k, v) xs)\n  (k', 0::'b) \\<notin> set xs\n\ngoal (2 subgoals):\n 1. v' = (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))\n 2. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (k', 0::'b) \\<notin> set (update_by_pair (k, v) xs)\n  (k', 0::'b) \\<notin> set xs\n\ngoal (1 subgoal):\n 1. (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))", "by (simp add: x True assms(2))"], ["proof (state)\nthis:\n  (x \\<in> set (update_by_pair (k, v) xs)) =\n  (x \\<in> insert (k, v) (set xs - range (Pair k)))\n\ngoal (1 subgoal):\n 1. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))", "case False"], ["proof (state)\nthis:\n  v' \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (update_by_pair (k, v) xs)) =\n    (x \\<in> insert (k, v) (set xs - range (Pair k)))", "by (auto simp: x lookup_pair_eq_value[OF inv False, symmetric] lookup_pair_eq_value[OF assms(1) False]\n          lookup_pair_update_by_pair[OF assms(1)])"], ["proof (state)\nthis:\n  (x \\<in> set (update_by_pair (k, v) xs)) =\n  (x \\<in> insert (k, v) (set xs - range (Pair k)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> set (update_by_pair (k, v) xs)) =\n  (x \\<in> insert (k, v) (set xs - range (Pair k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_update_by_pair_zero:\n  assumes \"oalist_inv_raw xs\"\n  shows \"set (update_by_pair (k, 0) xs) = set xs - range (Pair k)\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (update_by_pair (k, 0::'b) xs) = set xs - range (Pair k)", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n       (x \\<in> set xs - range (Pair k))", "fix x::\"'a \\<times> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n       (x \\<in> set xs - range (Pair k))", "obtain k' v' where x: \"x = (k', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v'. x = (k', v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k', v')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n       (x \\<in> set xs - range (Pair k))", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs", "have inv: \"oalist_inv_raw (update_by_pair (k, 0) xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (update_by_pair (k, 0::'b) xs)", "by (rule oalist_inv_raw_update_by_pair)"], ["proof (state)\nthis:\n  oalist_inv_raw (update_by_pair (k, 0::'b) xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n       (x \\<in> set xs - range (Pair k))", "show \"(x \\<in> ?A) \\<longleftrightarrow> (x \\<in> ?B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))", "proof (cases \"v' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' = (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))\n 2. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))", "case True"], ["proof (state)\nthis:\n  v' = (0::'b)\n\ngoal (2 subgoals):\n 1. v' = (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))\n 2. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))", "have \"0 \\<notin> snd ` set (update_by_pair (k, 0) xs)\" and \"0 \\<notin> snd ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (update_by_pair (k, 0::'b) xs) &&&\n    (0::'b) \\<notin> snd ` set xs", "by (rule oalist_inv_rawD1, fact)+"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set (update_by_pair (k, 0::'b) xs)\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (2 subgoals):\n 1. v' = (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))\n 2. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))", "hence \"(k', 0) \\<notin> set (update_by_pair (k, 0) xs)\" and \"(k', 0) \\<notin> set xs\""], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set (update_by_pair (k, 0::'b) xs)\n  (0::'b) \\<notin> snd ` set xs\n\ngoal (1 subgoal):\n 1. (k', 0::'b) \\<notin> set (update_by_pair (k, 0::'b) xs) &&&\n    (k', 0::'b) \\<notin> set xs", "using image_iff"], ["proof (prove)\nusing this:\n  (0::'b) \\<notin> snd ` set (update_by_pair (k, 0::'b) xs)\n  (0::'b) \\<notin> snd ` set xs\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. (k', 0::'b) \\<notin> set (update_by_pair (k, 0::'b) xs) &&&\n    (k', 0::'b) \\<notin> set xs", "by fastforce+"], ["proof (state)\nthis:\n  (k', 0::'b) \\<notin> set (update_by_pair (k, 0::'b) xs)\n  (k', 0::'b) \\<notin> set xs\n\ngoal (2 subgoals):\n 1. v' = (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))\n 2. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (k', 0::'b) \\<notin> set (update_by_pair (k, 0::'b) xs)\n  (k', 0::'b) \\<notin> set xs\n\ngoal (1 subgoal):\n 1. (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))", "by (simp add: x True)"], ["proof (state)\nthis:\n  (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n  (x \\<in> set xs - range (Pair k))\n\ngoal (1 subgoal):\n 1. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))", "case False"], ["proof (state)\nthis:\n  v' \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> (0::'b) \\<Longrightarrow>\n    (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n    (x \\<in> set xs - range (Pair k))", "by (auto simp: x lookup_pair_eq_value[OF inv False, symmetric] lookup_pair_eq_value[OF assms False]\n          lookup_pair_update_by_pair[OF assms] False)"], ["proof (state)\nthis:\n  (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n  (x \\<in> set xs - range (Pair k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> set (update_by_pair (k, 0::'b) xs)) =\n  (x \\<in> set xs - range (Pair k))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const update_by_fun_pair} and @{const update_by_fun_gr_pair}\\<close>"], ["", "lemma update_by_fun_pair_eq_update_by_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"update_by_fun_pair k f xs = update_by_pair (k, f (lookup_pair xs k)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_fun_pair k f xs = update_by_pair (k, f (lookup_pair xs k)) xs", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. update_by_fun_pair k f xs = update_by_pair (k, f (lookup_pair xs k)) xs", "by (induct xs rule: oalist_inv_raw_induct, simp, simp split: order.split)"], ["", "corollary oalist_inv_raw_update_by_fun_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"oalist_inv_raw (update_by_fun_pair k f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (update_by_fun_pair k f xs)", "unfolding update_by_fun_pair_eq_update_by_pair[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (update_by_pair (k, f (lookup_pair xs k)) xs)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (update_by_pair (k, f (lookup_pair xs k)) xs)", "by (rule oalist_inv_raw_update_by_pair)"], ["", "corollary lookup_pair_update_by_fun_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair (update_by_fun_pair k1 f xs) k2 = (if k1 = k2 then f else id) (lookup_pair xs k2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (update_by_fun_pair k1 f xs) k2 =\n    (if k1 = k2 then f else id) (lookup_pair xs k2)", "by (simp add: update_by_fun_pair_eq_update_by_pair[OF assms] lookup_pair_update_by_pair[OF assms])"], ["", "lemma update_by_fun_pair_gr:\n  assumes \"oalist_inv_raw xs\" and \"xs = [] \\<or> comp k (fst (last xs)) = Gt\"\n  shows \"update_by_fun_pair k f xs = xs @ (if f 0 = 0 then [] else [(k, f 0)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_fun_pair k f xs =\n    xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))])", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  xs = [] \\<or> comp k (fst (last xs)) = Gt\n\ngoal (1 subgoal):\n 1. update_by_fun_pair k f xs =\n    xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))])", "proof (induct xs rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] = [] \\<or> comp k (fst (last [])) = Gt \\<Longrightarrow>\n    update_by_fun_pair k f [] =\n    [] @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))])\n 2. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        xs = [] \\<or> comp k (fst (last xs)) = Gt \\<Longrightarrow>\n        update_by_fun_pair k f xs =\n        xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))]);\n        (ka, v) # xs = [] \\<or>\n        comp k (fst (last ((ka, v) # xs))) = Gt\\<rbrakk>\n       \\<Longrightarrow> update_by_fun_pair k f ((ka, v) # xs) =\n                         ((ka, v) # xs) @\n                         (if f (0::'b) = (0::'b) then []\n                          else [(k, f (0::'b))])", "case Nil"], ["proof (state)\nthis:\n  [] = [] \\<or> comp k (fst (last [])) = Gt\n\ngoal (2 subgoals):\n 1. [] = [] \\<or> comp k (fst (last [])) = Gt \\<Longrightarrow>\n    update_by_fun_pair k f [] =\n    [] @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))])\n 2. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        xs = [] \\<or> comp k (fst (last xs)) = Gt \\<Longrightarrow>\n        update_by_fun_pair k f xs =\n        xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))]);\n        (ka, v) # xs = [] \\<or>\n        comp k (fst (last ((ka, v) # xs))) = Gt\\<rbrakk>\n       \\<Longrightarrow> update_by_fun_pair k f ((ka, v) # xs) =\n                         ((ka, v) # xs) @\n                         (if f (0::'b) = (0::'b) then []\n                          else [(k, f (0::'b))])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_fun_pair k f [] =\n    [] @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))])", "by simp"], ["proof (state)\nthis:\n  update_by_fun_pair k f [] =\n  [] @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))])\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        xs = [] \\<or> comp k (fst (last xs)) = Gt \\<Longrightarrow>\n        update_by_fun_pair k f xs =\n        xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))]);\n        (ka, v) # xs = [] \\<or>\n        comp k (fst (last ((ka, v) # xs))) = Gt\\<rbrakk>\n       \\<Longrightarrow> update_by_fun_pair k f ((ka, v) # xs) =\n                         ((ka, v) # xs) @\n                         (if f (0::'b) = (0::'b) then []\n                          else [(k, f (0::'b))])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        xs = [] \\<or> comp k (fst (last xs)) = Gt \\<Longrightarrow>\n        update_by_fun_pair k f xs =\n        xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))]);\n        (ka, v) # xs = [] \\<or>\n        comp k (fst (last ((ka, v) # xs))) = Gt\\<rbrakk>\n       \\<Longrightarrow> update_by_fun_pair k f ((ka, v) # xs) =\n                         ((ka, v) # xs) @\n                         (if f (0::'b) = (0::'b) then []\n                          else [(k, f (0::'b))])", "case (Cons k' v' xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # xs)\n  oalist_inv_raw xs\n  v' \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'34\n  xs = [] \\<or> comp k (fst (last xs)) = Gt \\<Longrightarrow>\n  update_by_fun_pair k f xs =\n  xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))])\n  (k', v') # xs = [] \\<or> comp k (fst (last ((k', v') # xs))) = Gt\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        xs = [] \\<or> comp k (fst (last xs)) = Gt \\<Longrightarrow>\n        update_by_fun_pair k f xs =\n        xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))]);\n        (ka, v) # xs = [] \\<or>\n        comp k (fst (last ((ka, v) # xs))) = Gt\\<rbrakk>\n       \\<Longrightarrow> update_by_fun_pair k f ((ka, v) # xs) =\n                         ((ka, v) # xs) @\n                         (if f (0::'b) = (0::'b) then []\n                          else [(k, f (0::'b))])", "from Cons(6)"], ["proof (chain)\npicking this:\n  (k', v') # xs = [] \\<or> comp k (fst (last ((k', v') # xs))) = Gt", "have 1: \"comp k (fst (last ((k', v') # xs))) = Gt\""], ["proof (prove)\nusing this:\n  (k', v') # xs = [] \\<or> comp k (fst (last ((k', v') # xs))) = Gt\n\ngoal (1 subgoal):\n 1. comp k (fst (last ((k', v') # xs))) = Gt", "by simp"], ["proof (state)\nthis:\n  comp k (fst (last ((k', v') # xs))) = Gt\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        xs = [] \\<or> comp k (fst (last xs)) = Gt \\<Longrightarrow>\n        update_by_fun_pair k f xs =\n        xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))]);\n        (ka, v) # xs = [] \\<or>\n        comp k (fst (last ((ka, v) # xs))) = Gt\\<rbrakk>\n       \\<Longrightarrow> update_by_fun_pair k f ((ka, v) # xs) =\n                         ((ka, v) # xs) @\n                         (if f (0::'b) = (0::'b) then []\n                          else [(k, f (0::'b))])", "have eq1: \"comp k k' = Gt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp k k' = Gt", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> comp k k' = Gt\n 2. xs \\<noteq> [] \\<Longrightarrow> comp k k' = Gt", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> comp k k' = Gt\n 2. xs \\<noteq> [] \\<Longrightarrow> comp k k' = Gt", "with 1"], ["proof (chain)\npicking this:\n  comp k (fst (last ((k', v') # xs))) = Gt\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k (fst (last ((k', v') # xs))) = Gt\n  xs = []\n\ngoal (1 subgoal):\n 1. comp k k' = Gt", "by simp"], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> comp k k' = Gt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> comp k k' = Gt", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> comp k k' = Gt", "have \"lt k' (fst (last xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt k' (fst (last xs))", "by (rule Cons(4), simp add: False)"], ["proof (state)\nthis:\n  lt k' (fst (last xs))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> comp k k' = Gt", "from False 1"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  comp k (fst (last ((k', v') # xs))) = Gt", "have \"comp k (fst (last xs)) = Gt\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  comp k (fst (last ((k', v') # xs))) = Gt\n\ngoal (1 subgoal):\n 1. comp k (fst (last xs)) = Gt", "by simp"], ["proof (state)\nthis:\n  comp k (fst (last xs)) = Gt\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> comp k k' = Gt", "moreover"], ["proof (state)\nthis:\n  comp k (fst (last xs)) = Gt\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> comp k k' = Gt", "from \\<open>lt k' (fst (last xs))\\<close>"], ["proof (chain)\npicking this:\n  lt k' (fst (last xs))", "have \"comp (fst (last xs)) k' = Gt\""], ["proof (prove)\nusing this:\n  lt k' (fst (last xs))\n\ngoal (1 subgoal):\n 1. comp (fst (last xs)) k' = Gt", "by (simp add: Gt_lt_conv)"], ["proof (state)\nthis:\n  comp (fst (last xs)) k' = Gt\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> comp k k' = Gt", "ultimately"], ["proof (chain)\npicking this:\n  comp k (fst (last xs)) = Gt\n  comp (fst (last xs)) k' = Gt", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k (fst (last xs)) = Gt\n  comp (fst (last xs)) k' = Gt\n\ngoal (1 subgoal):\n 1. comp k k' = Gt", "by (meson Gt_lt_conv less_trans Lt_lt_conv[symmetric])"], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        xs = [] \\<or> comp k (fst (last xs)) = Gt \\<Longrightarrow>\n        update_by_fun_pair k f xs =\n        xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))]);\n        (ka, v) # xs = [] \\<or>\n        comp k (fst (last ((ka, v) # xs))) = Gt\\<rbrakk>\n       \\<Longrightarrow> update_by_fun_pair k f ((ka, v) # xs) =\n                         ((ka, v) # xs) @\n                         (if f (0::'b) = (0::'b) then []\n                          else [(k, f (0::'b))])", "have eq2: \"update_by_fun_pair k f xs = xs @ (if f 0 = 0 then [] else [(k, f 0)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_fun_pair k f xs =\n    xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))])", "proof (rule Cons(5), simp only: disj_commute[of \"xs = []\"], rule disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> comp k (fst (last xs)) = Gt", "assume \"xs \\<noteq> []\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> comp k (fst (last xs)) = Gt", "with 1"], ["proof (chain)\npicking this:\n  comp k (fst (last ((k', v') # xs))) = Gt\n  xs \\<noteq> []", "show \"comp k (fst (last xs)) = Gt\""], ["proof (prove)\nusing this:\n  comp k (fst (last ((k', v') # xs))) = Gt\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. comp k (fst (last xs)) = Gt", "by simp"], ["proof (state)\nthis:\n  comp k (fst (last xs)) = Gt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  update_by_fun_pair k f xs =\n  xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))])\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        xs = [] \\<or> comp k (fst (last xs)) = Gt \\<Longrightarrow>\n        update_by_fun_pair k f xs =\n        xs @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))]);\n        (ka, v) # xs = [] \\<or>\n        comp k (fst (last ((ka, v) # xs))) = Gt\\<rbrakk>\n       \\<Longrightarrow> update_by_fun_pair k f ((ka, v) # xs) =\n                         ((ka, v) # xs) @\n                         (if f (0::'b) = (0::'b) then []\n                          else [(k, f (0::'b))])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_fun_pair k f ((k', v') # xs) =\n    ((k', v') # xs) @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))])", "by (simp split: order.split add: Let_def eq1 eq2)"], ["proof (state)\nthis:\n  update_by_fun_pair k f ((k', v') # xs) =\n  ((k', v') # xs) @ (if f (0::'b) = (0::'b) then [] else [(k, f (0::'b))])\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary update_by_fun_gr_pair_eq_update_by_fun_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"update_by_fun_gr_pair k f xs = update_by_fun_pair k f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_fun_gr_pair k f xs = update_by_fun_pair k f xs", "by (simp add: update_by_fun_gr_pair_def Let_def update_by_fun_pair_gr[OF assms] split: order.split)"], ["", "corollary oalist_inv_raw_update_by_fun_gr_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"oalist_inv_raw (update_by_fun_gr_pair k f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (update_by_fun_gr_pair k f xs)", "unfolding update_by_fun_pair_eq_update_by_pair[OF assms] update_by_fun_gr_pair_eq_update_by_fun_pair[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (update_by_pair (k, f (lookup_pair xs k)) xs)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (update_by_pair (k, f (lookup_pair xs k)) xs)", "by (rule oalist_inv_raw_update_by_pair)"], ["", "corollary lookup_pair_update_by_fun_gr_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"lookup_pair (update_by_fun_gr_pair k1 f xs) k2 = (if k1 = k2 then f else id) (lookup_pair xs k2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (update_by_fun_gr_pair k1 f xs) k2 =\n    (if k1 = k2 then f else id) (lookup_pair xs k2)", "by (simp add: update_by_fun_pair_eq_update_by_pair[OF assms]\n      update_by_fun_gr_pair_eq_update_by_fun_pair[OF assms] lookup_pair_update_by_pair[OF assms])"], ["", "subsubsection \\<open>@{const map_pair}\\<close>"], ["", "lemma map_pair_cong:\n  assumes \"\\<And>kv. kv \\<in> set xs \\<Longrightarrow> f kv = g kv\"\n  shows \"map_pair f xs = map_pair g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pair f xs = map_pair g xs", "using assms"], ["proof (prove)\nusing this:\n  ?kv34 \\<in> set xs \\<Longrightarrow> f ?kv34 = g ?kv34\n\ngoal (1 subgoal):\n 1. map_pair f xs = map_pair g xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>kv.\n        kv \\<in> set [] \\<Longrightarrow> f kv = g kv) \\<Longrightarrow>\n    map_pair f [] = map_pair g []\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>kv.\n                    kv \\<in> set xs \\<Longrightarrow>\n                    f kv = g kv) \\<Longrightarrow>\n                map_pair f xs = map_pair g xs;\n        \\<And>kv.\n           kv \\<in> set (a # xs) \\<Longrightarrow> f kv = g kv\\<rbrakk>\n       \\<Longrightarrow> map_pair f (a # xs) = map_pair g (a # xs)", "case Nil"], ["proof (state)\nthis:\n  ?kv34 \\<in> set [] \\<Longrightarrow> f ?kv34 = g ?kv34\n\ngoal (2 subgoals):\n 1. (\\<And>kv.\n        kv \\<in> set [] \\<Longrightarrow> f kv = g kv) \\<Longrightarrow>\n    map_pair f [] = map_pair g []\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>kv.\n                    kv \\<in> set xs \\<Longrightarrow>\n                    f kv = g kv) \\<Longrightarrow>\n                map_pair f xs = map_pair g xs;\n        \\<And>kv.\n           kv \\<in> set (a # xs) \\<Longrightarrow> f kv = g kv\\<rbrakk>\n       \\<Longrightarrow> map_pair f (a # xs) = map_pair g (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pair f [] = map_pair g []", "by simp"], ["proof (state)\nthis:\n  map_pair f [] = map_pair g []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>kv.\n                    kv \\<in> set xs \\<Longrightarrow>\n                    f kv = g kv) \\<Longrightarrow>\n                map_pair f xs = map_pair g xs;\n        \\<And>kv.\n           kv \\<in> set (a # xs) \\<Longrightarrow> f kv = g kv\\<rbrakk>\n       \\<Longrightarrow> map_pair f (a # xs) = map_pair g (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>kv.\n                    kv \\<in> set xs \\<Longrightarrow>\n                    f kv = g kv) \\<Longrightarrow>\n                map_pair f xs = map_pair g xs;\n        \\<And>kv.\n           kv \\<in> set (a # xs) \\<Longrightarrow> f kv = g kv\\<rbrakk>\n       \\<Longrightarrow> map_pair f (a # xs) = map_pair g (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  (\\<And>kv.\n      kv \\<in> set xs \\<Longrightarrow> f kv = g kv) \\<Longrightarrow>\n  map_pair f xs = map_pair g xs\n  ?kv34 \\<in> set (x # xs) \\<Longrightarrow> f ?kv34 = g ?kv34\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>kv.\n                    kv \\<in> set xs \\<Longrightarrow>\n                    f kv = g kv) \\<Longrightarrow>\n                map_pair f xs = map_pair g xs;\n        \\<And>kv.\n           kv \\<in> set (a # xs) \\<Longrightarrow> f kv = g kv\\<rbrakk>\n       \\<Longrightarrow> map_pair f (a # xs) = map_pair g (a # xs)", "have \"f x = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = g x", "by (rule Cons(2), simp)"], ["proof (state)\nthis:\n  f x = g x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>kv.\n                    kv \\<in> set xs \\<Longrightarrow>\n                    f kv = g kv) \\<Longrightarrow>\n                map_pair f xs = map_pair g xs;\n        \\<And>kv.\n           kv \\<in> set (a # xs) \\<Longrightarrow> f kv = g kv\\<rbrakk>\n       \\<Longrightarrow> map_pair f (a # xs) = map_pair g (a # xs)", "moreover"], ["proof (state)\nthis:\n  f x = g x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>kv.\n                    kv \\<in> set xs \\<Longrightarrow>\n                    f kv = g kv) \\<Longrightarrow>\n                map_pair f xs = map_pair g xs;\n        \\<And>kv.\n           kv \\<in> set (a # xs) \\<Longrightarrow> f kv = g kv\\<rbrakk>\n       \\<Longrightarrow> map_pair f (a # xs) = map_pair g (a # xs)", "have \"map_pair f xs = map_pair g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pair f xs = map_pair g xs", "by (rule Cons(1), rule Cons(2), simp)"], ["proof (state)\nthis:\n  map_pair f xs = map_pair g xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>kv.\n                    kv \\<in> set xs \\<Longrightarrow>\n                    f kv = g kv) \\<Longrightarrow>\n                map_pair f xs = map_pair g xs;\n        \\<And>kv.\n           kv \\<in> set (a # xs) \\<Longrightarrow> f kv = g kv\\<rbrakk>\n       \\<Longrightarrow> map_pair f (a # xs) = map_pair g (a # xs)", "ultimately"], ["proof (chain)\npicking this:\n  f x = g x\n  map_pair f xs = map_pair g xs", "show ?case"], ["proof (prove)\nusing this:\n  f x = g x\n  map_pair f xs = map_pair g xs\n\ngoal (1 subgoal):\n 1. map_pair f (x # xs) = map_pair g (x # xs)", "by simp"], ["proof (state)\nthis:\n  map_pair f (x # xs) = map_pair g (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_pair_subset: \"set (map_pair f xs) \\<subseteq> f ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map_pair f xs) \\<subseteq> f ` set xs", "proof (induct xs rule: map_pair.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f. set (map_pair f []) \\<subseteq> f ` set []\n 2. \\<And>f kv xs.\n       (\\<And>x xa y.\n           \\<lbrakk>x = f kv; (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> set (map_pair f xs)\n                             \\<subseteq> f ` set xs) \\<Longrightarrow>\n       set (map_pair f (kv # xs)) \\<subseteq> f ` set (kv # xs)", "case (1 f)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>f. set (map_pair f []) \\<subseteq> f ` set []\n 2. \\<And>f kv xs.\n       (\\<And>x xa y.\n           \\<lbrakk>x = f kv; (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> set (map_pair f xs)\n                             \\<subseteq> f ` set xs) \\<Longrightarrow>\n       set (map_pair f (kv # xs)) \\<subseteq> f ` set (kv # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map_pair f []) \\<subseteq> f ` set []", "by simp"], ["proof (state)\nthis:\n  set (map_pair f []) \\<subseteq> f ` set []\n\ngoal (1 subgoal):\n 1. \\<And>f kv xs.\n       (\\<And>x xa y.\n           \\<lbrakk>x = f kv; (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> set (map_pair f xs)\n                             \\<subseteq> f ` set xs) \\<Longrightarrow>\n       set (map_pair f (kv # xs)) \\<subseteq> f ` set (kv # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f kv xs.\n       (\\<And>x xa y.\n           \\<lbrakk>x = f kv; (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> set (map_pair f xs)\n                             \\<subseteq> f ` set xs) \\<Longrightarrow>\n       set (map_pair f (kv # xs)) \\<subseteq> f ` set (kv # xs)", "case (2 f kv xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x34 = f kv; (?xa34, ?y34) = ?x34\\<rbrakk>\n  \\<Longrightarrow> set (map_pair f xs) \\<subseteq> f ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>f kv xs.\n       (\\<And>x xa y.\n           \\<lbrakk>x = f kv; (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> set (map_pair f xs)\n                             \\<subseteq> f ` set xs) \\<Longrightarrow>\n       set (map_pair f (kv # xs)) \\<subseteq> f ` set (kv # xs)", "obtain k v where f: \"f kv = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. f kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  f kv = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>f kv xs.\n       (\\<And>x xa y.\n           \\<lbrakk>x = f kv; (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> set (map_pair f xs)\n                             \\<subseteq> f ` set xs) \\<Longrightarrow>\n       set (map_pair f (kv # xs)) \\<subseteq> f ` set (kv # xs)", "from f[symmetric] refl"], ["proof (chain)\npicking this:\n  (k, v) = f kv\n  ?t = ?t", "have *: \"set (map_pair f xs) \\<subseteq> f ` set xs\""], ["proof (prove)\nusing this:\n  (k, v) = f kv\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. set (map_pair f xs) \\<subseteq> f ` set xs", "by (rule 2)"], ["proof (state)\nthis:\n  set (map_pair f xs) \\<subseteq> f ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>f kv xs.\n       (\\<And>x xa y.\n           \\<lbrakk>x = f kv; (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> set (map_pair f xs)\n                             \\<subseteq> f ` set xs) \\<Longrightarrow>\n       set (map_pair f (kv # xs)) \\<subseteq> f ` set (kv # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map_pair f (kv # xs)) \\<subseteq> f ` set (kv # xs)", "by (simp add: f Let_def, intro conjI impI subset_insertI2 *)"], ["proof (state)\nthis:\n  set (map_pair f (kv # xs)) \\<subseteq> f ` set (kv # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_raw_map_pair:\n  assumes \"oalist_inv_raw xs\"\n    and \"\\<And>a b. comp (fst (f a)) (fst (f b)) = comp (fst a) (fst b)\"\n  shows \"oalist_inv_raw (map_pair f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (map_pair f xs)", "using assms(1)"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (map_pair f xs)", "proof (induct xs rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. oalist_inv_raw (map_pair f [])\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (map_pair f xs)\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw (map_pair f ((k, v) # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. oalist_inv_raw (map_pair f [])\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (map_pair f xs)\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw (map_pair f ((k, v) # xs))", "from oalist_inv_raw_Nil"], ["proof (chain)\npicking this:\n  oalist_inv_raw []", "show ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw []\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (map_pair f [])", "by simp"], ["proof (state)\nthis:\n  oalist_inv_raw (map_pair f [])\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (map_pair f xs)\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw (map_pair f ((k, v) # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (map_pair f xs)\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw (map_pair f ((k, v) # xs))", "case (Cons k v xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'34\n  oalist_inv_raw (map_pair f xs)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (map_pair f xs)\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw (map_pair f ((k, v) # xs))", "obtain k' v' where f: \"f (k, v) = (k', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v'.\n        f (k, v) = (k', v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  f (k, v) = (k', v')\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (map_pair f xs)\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw (map_pair f ((k, v) # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (map_pair f ((k, v) # xs))", "proof (simp add: f Let_def Cons(5), rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<noteq> (0::'c) \\<Longrightarrow>\n    oalist_inv_raw ((k', v') # map_pair f xs)", "assume \"v' \\<noteq> 0\""], ["proof (state)\nthis:\n  v' \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> (0::'c) \\<Longrightarrow>\n    oalist_inv_raw ((k', v') # map_pair f xs)", "with Cons(5)"], ["proof (chain)\npicking this:\n  oalist_inv_raw (map_pair f xs)\n  v' \\<noteq> (0::'c)", "show \"oalist_inv_raw ((k', v') # map_pair f xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (map_pair f xs)\n  v' \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ((k', v') # map_pair f xs)", "proof (rule oalist_inv_raw_ConsI)"], ["proof (state)\ngoal (1 subgoal):\n 1. map_pair f xs \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map_pair f xs)))", "assume \"map_pair f xs \\<noteq> []\""], ["proof (state)\nthis:\n  map_pair f xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. map_pair f xs \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map_pair f xs)))", "hence \"hd (map_pair f xs) \\<in> set (map_pair f xs)\""], ["proof (prove)\nusing this:\n  map_pair f xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (map_pair f xs) \\<in> set (map_pair f xs)", "by simp"], ["proof (state)\nthis:\n  hd (map_pair f xs) \\<in> set (map_pair f xs)\n\ngoal (1 subgoal):\n 1. map_pair f xs \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map_pair f xs)))", "also"], ["proof (state)\nthis:\n  hd (map_pair f xs) \\<in> set (map_pair f xs)\n\ngoal (1 subgoal):\n 1. map_pair f xs \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map_pair f xs)))", "have \"... \\<subseteq> f ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map_pair f xs) \\<subseteq> f ` set xs", "by (fact map_pair_subset)"], ["proof (state)\nthis:\n  set (map_pair f xs) \\<subseteq> f ` set xs\n\ngoal (1 subgoal):\n 1. map_pair f xs \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map_pair f xs)))", "finally"], ["proof (chain)\npicking this:\n  hd (map_pair f xs) \\<in> f ` set xs", "obtain x where \"x \\<in> set xs\" and eq: \"hd (map_pair f xs) = f x\""], ["proof (prove)\nusing this:\n  hd (map_pair f xs) \\<in> f ` set xs\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set xs; hd (map_pair f xs) = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> set xs\n  hd (map_pair f xs) = f x\n\ngoal (1 subgoal):\n 1. map_pair f xs \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map_pair f xs)))", "from this(1)"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "have \"fst x \\<in> fst ` set xs\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. fst x \\<in> fst ` set xs", "by fastforce"], ["proof (state)\nthis:\n  fst x \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. map_pair f xs \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map_pair f xs)))", "hence \"lt k (fst x)\""], ["proof (prove)\nusing this:\n  fst x \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k (fst x)", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k (fst x)\n\ngoal (1 subgoal):\n 1. map_pair f xs \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map_pair f xs)))", "hence \"lt (fst (f (k, v))) (fst (f x))\""], ["proof (prove)\nusing this:\n  lt k (fst x)\n\ngoal (1 subgoal):\n 1. lt (fst (f (k, v))) (fst (f x))", "by (simp add: Lt_lt_conv[symmetric] assms(2))"], ["proof (state)\nthis:\n  lt (fst (f (k, v))) (fst (f x))\n\ngoal (1 subgoal):\n 1. map_pair f xs \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map_pair f xs)))", "thus \"lt k' (fst (hd (map_pair f xs)))\""], ["proof (prove)\nusing this:\n  lt (fst (f (k, v))) (fst (f x))\n\ngoal (1 subgoal):\n 1. lt k' (fst (hd (map_pair f xs)))", "by (simp add: f eq)"], ["proof (state)\nthis:\n  lt k' (fst (hd (map_pair f xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # map_pair f xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oalist_inv_raw (map_pair f ((k, v) # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_map_pair:\n  assumes \"oalist_inv_raw xs\" and \"snd (f (k, 0)) = 0\"\n    and \"\\<And>a b. comp (fst (f a)) (fst (f b)) = comp (fst a) (fst b)\"\n  shows \"lookup_pair (map_pair f xs) (fst (f (k, v))) = snd (f (k, lookup_pair xs k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map_pair f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_pair xs k))", "using assms(1)"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. lookup_pair (map_pair f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_pair xs k))", "proof (induct xs rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup_pair (map_pair f []) (fst (f (k, v))) =\n    snd (f (k, lookup_pair [] k))\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map_pair f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map_pair f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lookup_pair (map_pair f []) (fst (f (k, v))) =\n    snd (f (k, lookup_pair [] k))\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map_pair f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map_pair f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map_pair f []) (fst (f (k, v))) =\n    snd (f (k, lookup_pair [] k))", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  lookup_pair (map_pair f []) (fst (f (k, v))) =\n  snd (f (k, lookup_pair [] k))\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map_pair f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map_pair f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map_pair f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map_pair f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "case (Cons k' v' xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # xs)\n  oalist_inv_raw xs\n  v' \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'34\n  lookup_pair (map_pair f xs) (fst (f (k, v))) =\n  snd (f (k, lookup_pair xs k))\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map_pair f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map_pair f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "obtain k'' v'' where f: \"f (k', v') = (k'', v'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'' v''.\n        f (k', v') = (k'', v'') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  f (k', v') = (k'', v'')\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map_pair f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map_pair f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "have \"comp (fst (f (k, v))) k'' = comp (fst (f (k, v))) (fst (f (k', v')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp (fst (f (k, v))) k'' = comp (fst (f (k, v))) (fst (f (k', v')))", "by (simp add: f)"], ["proof (state)\nthis:\n  comp (fst (f (k, v))) k'' = comp (fst (f (k, v))) (fst (f (k', v')))\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map_pair f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map_pair f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "also"], ["proof (state)\nthis:\n  comp (fst (f (k, v))) k'' = comp (fst (f (k, v))) (fst (f (k', v')))\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map_pair f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map_pair f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "have \"... = comp k k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp (fst (f (k, v))) (fst (f (k', v'))) = comp k k'", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  comp (fst (f (k, v))) (fst (f (k', v'))) = comp k k'\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map_pair f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map_pair f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "finally"], ["proof (chain)\npicking this:\n  comp (fst (f (k, v))) k'' = comp k k'", "have eq0: \"comp (fst (f (k, v))) k'' = comp k k'\""], ["proof (prove)\nusing this:\n  comp (fst (f (k, v))) k'' = comp k k'\n\ngoal (1 subgoal):\n 1. comp (fst (f (k, v))) k'' = comp k k'", "."], ["proof (state)\nthis:\n  comp (fst (f (k, v))) k'' = comp k k'\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map_pair f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map_pair f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "have *: \"lookup_pair xs k = 0\" if \"comp k k' \\<noteq> Gt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair xs k = (0::'b)", "proof (simp add: lookup_pair_eq_0[OF Cons(2)], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False", "assume \"k \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False", "hence \"lt k' k\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False", "hence \"comp k k' = Gt\""], ["proof (prove)\nusing this:\n  lt k' k\n\ngoal (1 subgoal):\n 1. comp k k' = Gt", "by (simp add: Gt_lt_conv)"], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False", "with \\<open>comp k k' \\<noteq> Gt\\<close>"], ["proof (chain)\npicking this:\n  comp k k' \\<noteq> Gt\n  comp k k' = Gt", "show False"], ["proof (prove)\nusing this:\n  comp k k' \\<noteq> Gt\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comp k k' \\<noteq> Gt \\<Longrightarrow> lookup_pair xs k = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map_pair f xs) (fst (f (k, v))) =\n        snd (f (k, lookup_pair xs k))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map_pair f ((ka, va) # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_pair ((ka, va) # xs) k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map_pair f ((k', v') # xs)) (fst (f (k, v))) =\n    snd (f (k, lookup_pair ((k', v') # xs) k))", "proof (simp add: assms(2) f Let_def eq0 Cons(5) split: order.split, intro conjI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))\n 3. \\<lbrakk>comp k k' = Lt; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = (0::'c)", "assume \"comp k k' = Lt\""], ["proof (state)\nthis:\n  comp k k' = Lt\n\ngoal (3 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))\n 3. \\<lbrakk>comp k k' = Lt; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = (0::'c)", "hence \"comp k k' \\<noteq> Gt\""], ["proof (prove)\nusing this:\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. comp k k' \\<noteq> Gt", "by simp"], ["proof (state)\nthis:\n  comp k k' \\<noteq> Gt\n\ngoal (3 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))\n 3. \\<lbrakk>comp k k' = Lt; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = (0::'c)", "hence \"lookup_pair xs k = 0\""], ["proof (prove)\nusing this:\n  comp k k' \\<noteq> Gt\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = (0::'b)", "by (rule *)"], ["proof (state)\nthis:\n  lookup_pair xs k = (0::'b)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))\n 3. \\<lbrakk>comp k k' = Lt; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = (0::'c)", "thus \"snd (f (k, lookup_pair xs k)) = 0\""], ["proof (prove)\nusing this:\n  lookup_pair xs k = (0::'b)\n\ngoal (1 subgoal):\n 1. snd (f (k, lookup_pair xs k)) = (0::'c)", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  snd (f (k, lookup_pair xs k)) = (0::'c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))", "assume \"v'' = 0\""], ["proof (state)\nthis:\n  v'' = (0::'c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))", "assume \"comp k k' = Eq\""], ["proof (state)\nthis:\n  comp k k' = Eq\n\ngoal (2 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))", "hence \"k = k'\" and \"comp k k' \\<noteq> Gt\""], ["proof (prove)\nusing this:\n  comp k k' = Eq\n\ngoal (1 subgoal):\n 1. k = k' &&& comp k k' \\<noteq> Gt", "by (simp only: eq, simp)"], ["proof (state)\nthis:\n  k = k'\n  comp k k' \\<noteq> Gt\n\ngoal (2 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))", "from this(2)"], ["proof (chain)\npicking this:\n  comp k k' \\<noteq> Gt", "have \"lookup_pair xs k = 0\""], ["proof (prove)\nusing this:\n  comp k k' \\<noteq> Gt\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = (0::'b)", "by (rule *)"], ["proof (state)\nthis:\n  lookup_pair xs k = (0::'b)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))", "hence \"snd (f (k, lookup_pair xs k)) = 0\""], ["proof (prove)\nusing this:\n  lookup_pair xs k = (0::'b)\n\ngoal (1 subgoal):\n 1. snd (f (k, lookup_pair xs k)) = (0::'c)", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  snd (f (k, lookup_pair xs k)) = (0::'c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))", "also"], ["proof (state)\nthis:\n  snd (f (k, lookup_pair xs k)) = (0::'c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))", "have \"... = snd (f (k, v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'c) = snd (f (k, v'))", "by (simp add: \\<open>k = k'\\<close> f \\<open>v'' = 0\\<close>)"], ["proof (state)\nthis:\n  (0::'c) = snd (f (k, v'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>comp k k' = Eq; v'' = (0::'c)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n 2. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))", "finally"], ["proof (chain)\npicking this:\n  snd (f (k, lookup_pair xs k)) = snd (f (k, v'))", "show \"snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\""], ["proof (prove)\nusing this:\n  snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n\ngoal (1 subgoal):\n 1. snd (f (k, lookup_pair xs k)) = snd (f (k, v'))", "."], ["proof (state)\nthis:\n  snd (f (k, lookup_pair xs k)) = snd (f (k, v'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comp k k' = Eq; v'' \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, v'))", "qed (simp add: f eq)"], ["proof (state)\nthis:\n  lookup_pair (map_pair f ((k', v') # xs)) (fst (f (k, v))) =\n  snd (f (k, lookup_pair ((k', v') # xs) k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_dflt_map_pair:\n  assumes \"distinct (map fst xs)\" and \"snd (f (k, 0)) = 0\"\n    and \"\\<And>a b. (fst (f a) = fst (f b)) \\<longleftrightarrow> (fst a = fst b)\"\n  shows \"lookup_dflt (map_pair f xs) (fst (f (k, v))) = snd (f (k, lookup_dflt xs k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_dflt xs k))", "using assms(1)"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_dflt xs k))", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    lookup_dflt (map_pair f []) (fst (f (k, v))) =\n    snd (f (k, lookup_dflt [] k))\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    lookup_dflt (map_pair f []) (fst (f (k, v))) =\n    snd (f (k, lookup_dflt [] k))\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_dflt (map_pair f []) (fst (f (k, v))) =\n    snd (f (k, lookup_dflt [] k))", "by (simp add: lookup_dflt_def assms(2))"], ["proof (state)\nthis:\n  lookup_dflt (map_pair f []) (fst (f (k, v))) =\n  snd (f (k, lookup_dflt [] k))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct (map fst xs) \\<Longrightarrow>\n  lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n  snd (f (k, lookup_dflt xs k))\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "obtain k' v' where x: \"x = (k', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v'. x = (k', v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k', v')\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "obtain k'' v'' where f: \"f (k', v') = (k'', v'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'' v''.\n        f (k', v') = (k'', v'') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  f (k', v') = (k'', v'')\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "from Cons(2)"], ["proof (chain)\npicking this:\n  distinct (map fst (x # xs))", "have \"distinct (map fst xs)\" and \"k' \\<notin> fst ` set xs\""], ["proof (prove)\nusing this:\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. distinct (map fst xs) &&& k' \\<notin> fst ` set xs", "by (simp_all add: x)"], ["proof (state)\nthis:\n  distinct (map fst xs)\n  k' \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "from this(1)"], ["proof (chain)\npicking this:\n  distinct (map fst xs)", "have eq1: \"lookup_dflt (map_pair f xs) (fst (f (k, v))) = snd (f (k, lookup_dflt xs k))\""], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_dflt xs k))", "by (rule Cons(1))"], ["proof (state)\nthis:\n  lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n  snd (f (k, lookup_dflt xs k))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "have eq2: \"lookup_dflt ((a, b) # ys) c = (if c = a then b else lookup_dflt ys c)\"\n    for a b c and ys::\"('b \\<times> 'e::zero) list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_dflt ((a, b) # ys) c = (if c = a then b else lookup_dflt ys c)", "by (simp add: lookup_dflt_def map_of_Cons_code)"], ["proof (state)\nthis:\n  lookup_dflt ((?a35, ?b35) # ?ys35) ?c35 =\n  (if ?c35 = ?a35 then ?b35 else lookup_dflt ?ys35 ?c35)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "from \\<open>k' \\<notin> fst ` set xs\\<close>"], ["proof (chain)\npicking this:\n  k' \\<notin> fst ` set xs", "have \"map_of xs k' = None\""], ["proof (prove)\nusing this:\n  k' \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. map_of xs k' = None", "by (simp add: map_of_eq_None_iff)"], ["proof (state)\nthis:\n  map_of xs k' = None\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "hence eq3: \"lookup_dflt xs k' = 0\""], ["proof (prove)\nusing this:\n  map_of xs k' = None\n\ngoal (1 subgoal):\n 1. lookup_dflt xs k' = (0::'c)", "by (simp add: lookup_dflt_def)"], ["proof (state)\nthis:\n  lookup_dflt xs k' = (0::'c)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_dflt (map_pair f xs) (fst (f (k, v))) =\n                snd (f (k, lookup_dflt xs k));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_dflt (map_pair f (a # xs))\n                          (fst (f (k, v))) =\n                         snd (f (k, lookup_dflt (a # xs) k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_dflt (map_pair f (x # xs)) (fst (f (k, v))) =\n    snd (f (k, lookup_dflt (x # xs) k))", "proof (simp add: f Let_def x eq1 eq2 eq3, intro conjI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>k = k'; fst (f (k', v)) = k''; v'' = (0::'d)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = (0::'d)\n 2. \\<lbrakk>k = k'; fst (f (k', v)) \\<noteq> k''\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = v''\n 3. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "assume \"k = k'\""], ["proof (state)\nthis:\n  k = k'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>k = k'; fst (f (k', v)) = k''; v'' = (0::'d)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = (0::'d)\n 2. \\<lbrakk>k = k'; fst (f (k', v)) \\<noteq> k''\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = v''\n 3. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "hence \"snd (f (k', 0)) = snd (f (k, 0))\""], ["proof (prove)\nusing this:\n  k = k'\n\ngoal (1 subgoal):\n 1. snd (f (k', 0::'c)) = snd (f (k, 0::'c))", "by simp"], ["proof (state)\nthis:\n  snd (f (k', 0::'c)) = snd (f (k, 0::'c))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>k = k'; fst (f (k', v)) = k''; v'' = (0::'d)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = (0::'d)\n 2. \\<lbrakk>k = k'; fst (f (k', v)) \\<noteq> k''\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = v''\n 3. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "also"], ["proof (state)\nthis:\n  snd (f (k', 0::'c)) = snd (f (k, 0::'c))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>k = k'; fst (f (k', v)) = k''; v'' = (0::'d)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = (0::'d)\n 2. \\<lbrakk>k = k'; fst (f (k', v)) \\<noteq> k''\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = v''\n 3. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (f (k, 0::'c)) = (0::'d)", "by (fact assms(2))"], ["proof (state)\nthis:\n  snd (f (k, 0::'c)) = (0::'d)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>k = k'; fst (f (k', v)) = k''; v'' = (0::'d)\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = (0::'d)\n 2. \\<lbrakk>k = k'; fst (f (k', v)) \\<noteq> k''\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = v''\n 3. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "finally"], ["proof (chain)\npicking this:\n  snd (f (k', 0::'c)) = (0::'d)", "show \"snd (f (k', 0)) = 0\""], ["proof (prove)\nusing this:\n  snd (f (k', 0::'c)) = (0::'d)\n\ngoal (1 subgoal):\n 1. snd (f (k', 0::'c)) = (0::'d)", "."], ["proof (state)\nthis:\n  snd (f (k', 0::'c)) = (0::'d)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k = k'; fst (f (k', v)) \\<noteq> k''\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = v''\n 2. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k = k'; fst (f (k', v)) \\<noteq> k''\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = v''\n 2. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "assume \"fst (f (k', v)) \\<noteq> k''\""], ["proof (state)\nthis:\n  fst (f (k', v)) \\<noteq> k''\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k = k'; fst (f (k', v)) \\<noteq> k''\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = v''\n 2. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "hence \"fst (f (k', v)) \\<noteq> fst (f (k', v'))\""], ["proof (prove)\nusing this:\n  fst (f (k', v)) \\<noteq> k''\n\ngoal (1 subgoal):\n 1. fst (f (k', v)) \\<noteq> fst (f (k', v'))", "by (simp add: f)"], ["proof (state)\nthis:\n  fst (f (k', v)) \\<noteq> fst (f (k', v'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k = k'; fst (f (k', v)) \\<noteq> k''\\<rbrakk>\n    \\<Longrightarrow> snd (f (k', 0::'c)) = v''\n 2. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "thus \"snd (f (k', 0)) = v''\""], ["proof (prove)\nusing this:\n  fst (f (k', v)) \\<noteq> fst (f (k', v'))\n\ngoal (1 subgoal):\n 1. snd (f (k', 0::'c)) = v''", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  snd (f (k', 0::'c)) = v''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "assume \"k \\<noteq> k'\""], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "assume \"fst (f (k, v)) = k''\""], ["proof (state)\nthis:\n  fst (f (k, v)) = k''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "also"], ["proof (state)\nthis:\n  fst (f (k, v)) = k''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "have \"... = fst (f (k', v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k'' = fst (f (k', v'))", "by (simp add: f)"], ["proof (state)\nthis:\n  k'' = fst (f (k', v'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "finally"], ["proof (chain)\npicking this:\n  fst (f (k, v)) = fst (f (k', v'))", "have \"k = k'\""], ["proof (prove)\nusing this:\n  fst (f (k, v)) = fst (f (k', v'))\n\ngoal (1 subgoal):\n 1. k = k'", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  k = k'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> k'; fst (f (k, v)) = k'';\n     v'' \\<noteq> (0::'d)\\<rbrakk>\n    \\<Longrightarrow> v'' = snd (f (k, lookup_dflt xs k))", "with \\<open>k \\<noteq> k'\\<close>"], ["proof (chain)\npicking this:\n  k \\<noteq> k'\n  k = k'", "show \"v'' = snd (f (k, lookup_dflt xs k))\""], ["proof (prove)\nusing this:\n  k \\<noteq> k'\n  k = k'\n\ngoal (1 subgoal):\n 1. v'' = snd (f (k, lookup_dflt xs k))", ".."], ["proof (state)\nthis:\n  v'' = snd (f (k, lookup_dflt xs k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_dflt (map_pair f (x # xs)) (fst (f (k, v))) =\n  snd (f (k, lookup_dflt (x # xs) k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_map_pair:\n  assumes \"distinct (map fst xs)\" and \"\\<And>a b. fst (f a) = fst (f b) \\<Longrightarrow> fst a = fst b\"\n  shows \"distinct (map fst (map_pair f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (map_pair f xs))", "using assms(1)"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. distinct (map fst (map_pair f xs))", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map fst (map_pair f []))\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (map_pair f xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (map_pair f (a # xs)))", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map fst (map_pair f []))\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (map_pair f xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (map_pair f (a # xs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (map_pair f []))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (map_pair f []))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (map_pair f xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (map_pair f (a # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (map_pair f xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (map_pair f (a # xs)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct (map fst xs) \\<Longrightarrow> distinct (map fst (map_pair f xs))\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (map_pair f xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (map_pair f (a # xs)))", "obtain k v where x: \"x = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. x = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (map_pair f xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (map_pair f (a # xs)))", "obtain k' v' where f: \"f (k, v) = (k', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v'.\n        f (k, v) = (k', v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  f (k, v) = (k', v')\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (map_pair f xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (map_pair f (a # xs)))", "from Cons(2)"], ["proof (chain)\npicking this:\n  distinct (map fst (x # xs))", "have \"distinct (map fst xs)\" and \"k \\<notin> fst ` set xs\""], ["proof (prove)\nusing this:\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. distinct (map fst xs) &&& k \\<notin> fst ` set xs", "by (simp_all add: x)"], ["proof (state)\nthis:\n  distinct (map fst xs)\n  k \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (map_pair f xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (map_pair f (a # xs)))", "from this(1)"], ["proof (chain)\npicking this:\n  distinct (map fst xs)", "have 1: \"distinct (map fst (map_pair f xs))\""], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. distinct (map fst (map_pair f xs))", "by (rule Cons(1))"], ["proof (state)\nthis:\n  distinct (map fst (map_pair f xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (map_pair f xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (map_pair f (a # xs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (map_pair f (x # xs)))", "proof (simp add: x f Let_def 1, intro impI notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"v' \\<noteq> 0\""], ["proof (state)\nthis:\n  v' \\<noteq> (0::'d)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"k' \\<in> fst ` set (map_pair f xs)\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set (map_pair f xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k' \\<in> fst ` set (map_pair f xs)", "obtain y where \"y \\<in> set (map_pair f xs)\" and \"k' = fst y\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set (map_pair f xs)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (map_pair f xs); k' = fst y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  y \\<in> set (map_pair f xs)\n  k' = fst y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "from this(1) map_pair_subset"], ["proof (chain)\npicking this:\n  y \\<in> set (map_pair f xs)\n  set (map_pair ?f ?xs) \\<subseteq> ?f ` set ?xs", "have \"y \\<in> f ` set xs\""], ["proof (prove)\nusing this:\n  y \\<in> set (map_pair f xs)\n  set (map_pair ?f ?xs) \\<subseteq> ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. y \\<in> f ` set xs", ".."], ["proof (state)\nthis:\n  y \\<in> f ` set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  y \\<in> f ` set xs", "obtain z where \"z \\<in> set xs\" and \"y = f z\""], ["proof (prove)\nusing this:\n  y \\<in> f ` set xs\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> set xs; y = f z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  z \\<in> set xs\n  y = f z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "from this(2)"], ["proof (chain)\npicking this:\n  y = f z", "have \"fst (f z) = k'\""], ["proof (prove)\nusing this:\n  y = f z\n\ngoal (1 subgoal):\n 1. fst (f z) = k'", "by (simp add: \\<open>k' = fst y\\<close>)"], ["proof (state)\nthis:\n  fst (f z) = k'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  fst (f z) = k'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"... = fst (f (k, v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' = fst (f (k, v))", "by (simp add: f)"], ["proof (state)\nthis:\n  k' = fst (f (k, v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  fst (f z) = fst (f (k, v))", "have \"fst z = fst (k, v)\""], ["proof (prove)\nusing this:\n  fst (f z) = fst (f (k, v))\n\ngoal (1 subgoal):\n 1. fst z = fst (k, v)", "by (rule assms(2))"], ["proof (state)\nthis:\n  fst z = fst (k, v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  fst z = fst (k, v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"... = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (k, v) = k", "by simp"], ["proof (state)\nthis:\n  fst (k, v) = k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  fst z = k", "have \"k \\<in> fst ` set xs\""], ["proof (prove)\nusing this:\n  fst z = k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs", "using \\<open>z \\<in> set xs\\<close>"], ["proof (prove)\nusing this:\n  fst z = k\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs", "by blast"], ["proof (state)\nthis:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v' \\<noteq> (0::'d);\n     k' \\<in> fst ` set (map_pair f xs)\\<rbrakk>\n    \\<Longrightarrow> False", "with \\<open>k \\<notin> fst ` set xs\\<close>"], ["proof (chain)\npicking this:\n  k \\<notin> fst ` set xs\n  k \\<in> fst ` set xs", "show False"], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set xs\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map fst (map_pair f (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_val_pair_cong:\n  assumes \"\\<And>k v. (k, v) \\<in> set xs \\<Longrightarrow> f k v = g k v\"\n  shows \"map_val_pair f xs = map_val_pair g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_val_pair f xs = map_val_pair g xs", "proof (rule map_pair_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> set xs \\<Longrightarrow>\n       (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n       (case kv of (k, v) \\<Rightarrow> (k, g k v))", "fix kv"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> set xs \\<Longrightarrow>\n       (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n       (case kv of (k, v) \\<Rightarrow> (k, g k v))", "assume \"kv \\<in> set xs\""], ["proof (state)\nthis:\n  kv \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> set xs \\<Longrightarrow>\n       (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n       (case kv of (k, v) \\<Rightarrow> (k, g k v))", "moreover"], ["proof (state)\nthis:\n  kv \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> set xs \\<Longrightarrow>\n       (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n       (case kv of (k, v) \\<Rightarrow> (k, g k v))", "obtain k v where \"kv = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> set xs \\<Longrightarrow>\n       (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n       (case kv of (k, v) \\<Rightarrow> (k, g k v))", "ultimately"], ["proof (chain)\npicking this:\n  kv \\<in> set xs\n  kv = (k, v)", "show \"(case kv of (k, v) \\<Rightarrow> (k, f k v)) = (case kv of (k, v) \\<Rightarrow> (k, g k v))\""], ["proof (prove)\nusing this:\n  kv \\<in> set xs\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n    (case kv of (k, v) \\<Rightarrow> (k, g k v))", "by (simp add: assms)"], ["proof (state)\nthis:\n  (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n  (case kv of (k, v) \\<Rightarrow> (k, g k v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_raw_map_val_pair:\n  assumes \"oalist_inv_raw xs\"\n  shows \"oalist_inv_raw (map_val_pair f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (map_val_pair f xs)", "by (rule oalist_inv_raw_map_pair, fact assms, auto)"], ["", "lemma lookup_pair_map_val_pair:\n  assumes \"oalist_inv_raw xs\" and \"f k 0 = 0\"\n  shows \"lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)", "let ?f = \"\\<lambda>(k', v'). (k', f k' v')\""], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)", "have \"lookup_pair (map_val_pair f xs) k = lookup_pair (map_val_pair f xs) (fst (?f (k, 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair f xs) k =\n    lookup_pair (map_val_pair f xs)\n     (fst (case (k, 0::'b) of (k', v') \\<Rightarrow> (k', f k' v')))", "by simp"], ["proof (state)\nthis:\n  lookup_pair (map_val_pair f xs) k =\n  lookup_pair (map_val_pair f xs)\n   (fst (case (k, 0::'b) of (k', v') \\<Rightarrow> (k', f k' v')))\n\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)", "also"], ["proof (state)\nthis:\n  lookup_pair (map_val_pair f xs) k =\n  lookup_pair (map_val_pair f xs)\n   (fst (case (k, 0::'b) of (k', v') \\<Rightarrow> (k', f k' v')))\n\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)", "have \"... = snd (?f (k, local.lookup_pair xs k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair f xs)\n     (fst (case (k, 0::'b) of (k', v') \\<Rightarrow> (k', f k' v'))) =\n    snd (case (k, lookup_pair xs k) of (k', v') \\<Rightarrow> (k', f k' v'))", "by (rule lookup_pair_map_pair, fact assms(1), auto simp: assms(2))"], ["proof (state)\nthis:\n  lookup_pair (map_val_pair f xs)\n   (fst (case (k, 0::'b) of (k', v') \\<Rightarrow> (k', f k' v'))) =\n  snd (case (k, lookup_pair xs k) of (k', v') \\<Rightarrow> (k', f k' v'))\n\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)", "also"], ["proof (state)\nthis:\n  lookup_pair (map_val_pair f xs)\n   (fst (case (k, 0::'b) of (k', v') \\<Rightarrow> (k', f k' v'))) =\n  snd (case (k, lookup_pair xs k) of (k', v') \\<Rightarrow> (k', f k' v'))\n\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)", "have \"... = f k (lookup_pair xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (case (k, lookup_pair xs k) of\n         (k', v') \\<Rightarrow> (k', f k' v')) =\n    f k (lookup_pair xs k)", "by simp"], ["proof (state)\nthis:\n  snd (case (k, lookup_pair xs k) of (k', v') \\<Rightarrow> (k', f k' v')) =\n  f k (lookup_pair xs k)\n\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)", "finally"], ["proof (chain)\npicking this:\n  lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)\n\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)", "."], ["proof (state)\nthis:\n  lookup_pair (map_val_pair f xs) k = f k (lookup_pair xs k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_pair_id:\n  assumes \"oalist_inv_raw xs\"\n  shows \"map_pair id xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pair id xs = xs", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. map_pair id xs = xs", "proof (induct xs rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. map_pair id [] = []\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        map_pair id xs = xs\\<rbrakk>\n       \\<Longrightarrow> map_pair id ((k, v) # xs) = (k, v) # xs", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. map_pair id [] = []\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        map_pair id xs = xs\\<rbrakk>\n       \\<Longrightarrow> map_pair id ((k, v) # xs) = (k, v) # xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pair id [] = []", "by simp"], ["proof (state)\nthis:\n  map_pair id [] = []\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        map_pair id xs = xs\\<rbrakk>\n       \\<Longrightarrow> map_pair id ((k, v) # xs) = (k, v) # xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        map_pair id xs = xs\\<rbrakk>\n       \\<Longrightarrow> map_pair id ((k, v) # xs) = (k, v) # xs", "case (Cons k v xs')"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, v) # xs')\n  oalist_inv_raw xs'\n  v \\<noteq> (0::'b)\n  ?k'34 \\<in> fst ` set xs' \\<Longrightarrow> lt k ?k'34\n  map_pair id xs' = xs'\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        map_pair id xs = xs\\<rbrakk>\n       \\<Longrightarrow> map_pair id ((k, v) # xs) = (k, v) # xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pair id ((k, v) # xs') = (k, v) # xs'", "by (simp add: Let_def Cons(3, 5) id_def[symmetric])"], ["proof (state)\nthis:\n  map_pair id ((k, v) # xs') = (k, v) # xs'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const map2_val_pair}\\<close>"], ["", "definition map2_val_compat :: \"(('a \\<times> 'b::zero) list \\<Rightarrow> ('a \\<times> 'c::zero) list) \\<Rightarrow> bool\"\n  where \"map2_val_compat f \\<longleftrightarrow> (\\<forall>zs. (oalist_inv_raw zs \\<longrightarrow>\n                                (oalist_inv_raw (f zs) \\<and> fst ` set (f zs) \\<subseteq> fst ` set zs)))\""], ["", "lemma map2_val_compatI:\n  assumes \"\\<And>zs. oalist_inv_raw zs \\<Longrightarrow> oalist_inv_raw (f zs)\"\n    and \"\\<And>zs. oalist_inv_raw zs \\<Longrightarrow> fst ` set (f zs) \\<subseteq> fst ` set zs\"\n  shows \"map2_val_compat f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_compat f", "unfolding map2_val_compat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs.\n       oalist_inv_raw zs \\<longrightarrow>\n       oalist_inv_raw (f zs) \\<and>\n       fst ` set (f zs) \\<subseteq> fst ` set zs", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw ?zs35 \\<Longrightarrow> oalist_inv_raw (f ?zs35)\n  oalist_inv_raw ?zs35 \\<Longrightarrow>\n  fst ` set (f ?zs35) \\<subseteq> fst ` set ?zs35\n\ngoal (1 subgoal):\n 1. \\<forall>zs.\n       oalist_inv_raw zs \\<longrightarrow>\n       oalist_inv_raw (f zs) \\<and>\n       fst ` set (f zs) \\<subseteq> fst ` set zs", "by blast"], ["", "lemma map2_val_compatD1:\n  assumes \"map2_val_compat f\" and \"oalist_inv_raw zs\"\n  shows \"oalist_inv_raw (f zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (f zs)", "using assms"], ["proof (prove)\nusing this:\n  map2_val_compat f\n  oalist_inv_raw zs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (f zs)", "unfolding map2_val_compat_def"], ["proof (prove)\nusing this:\n  \\<forall>zs.\n     oalist_inv_raw zs \\<longrightarrow>\n     oalist_inv_raw (f zs) \\<and> fst ` set (f zs) \\<subseteq> fst ` set zs\n  oalist_inv_raw zs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (f zs)", "by blast"], ["", "lemma map2_val_compatD2:\n  assumes \"map2_val_compat f\" and \"oalist_inv_raw zs\"\n  shows \"fst ` set (f zs) \\<subseteq> fst ` set zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (f zs) \\<subseteq> fst ` set zs", "using assms"], ["proof (prove)\nusing this:\n  map2_val_compat f\n  oalist_inv_raw zs\n\ngoal (1 subgoal):\n 1. fst ` set (f zs) \\<subseteq> fst ` set zs", "unfolding map2_val_compat_def"], ["proof (prove)\nusing this:\n  \\<forall>zs.\n     oalist_inv_raw zs \\<longrightarrow>\n     oalist_inv_raw (f zs) \\<and> fst ` set (f zs) \\<subseteq> fst ` set zs\n  oalist_inv_raw zs\n\ngoal (1 subgoal):\n 1. fst ` set (f zs) \\<subseteq> fst ` set zs", "by blast"], ["", "lemma map2_val_compat_Nil:\n  assumes \"map2_val_compat (f::('a \\<times> 'b::zero) list \\<Rightarrow> ('a \\<times> 'c::zero) list)\"\n  shows \"f [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f [] = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f [] = []", "from assms oalist_inv_raw_Nil"], ["proof (chain)\npicking this:\n  map2_val_compat f\n  oalist_inv_raw []", "have \"fst ` set (f []) \\<subseteq> fst ` set ([]::('a \\<times> 'b) list)\""], ["proof (prove)\nusing this:\n  map2_val_compat f\n  oalist_inv_raw []\n\ngoal (1 subgoal):\n 1. fst ` set (f []) \\<subseteq> fst ` set []", "by (rule map2_val_compatD2)"], ["proof (state)\nthis:\n  fst ` set (f []) \\<subseteq> fst ` set []\n\ngoal (1 subgoal):\n 1. f [] = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst ` set (f []) \\<subseteq> fst ` set []\n\ngoal (1 subgoal):\n 1. f [] = []", "by simp"], ["proof (state)\nthis:\n  f [] = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map2_val_compat_id: \"map2_val_compat id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_compat id", "by (rule map2_val_compatI, auto)"], ["", "lemma map2_val_compat_map_val_pair: \"map2_val_compat (map_val_pair f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_compat (map_val_pair f)", "proof (rule map2_val_compatI, erule oalist_inv_raw_map_val_pair)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw zs \\<Longrightarrow>\n       fst ` set (map_val_pair f zs) \\<subseteq> fst ` set zs", "fix zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw zs \\<Longrightarrow>\n       fst ` set (map_val_pair f zs) \\<subseteq> fst ` set zs", "from map_pair_subset image_iff"], ["proof (chain)\npicking this:\n  set (map_pair ?f ?xs) \\<subseteq> ?f ` set ?xs\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)", "show \"fst ` set (map_val_pair f zs) \\<subseteq> fst ` set zs\""], ["proof (prove)\nusing this:\n  set (map_pair ?f ?xs) \\<subseteq> ?f ` set ?xs\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. fst ` set (map_val_pair f zs) \\<subseteq> fst ` set zs", "by fastforce"], ["proof (state)\nthis:\n  fst ` set (map_val_pair f zs) \\<subseteq> fst ` set zs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fst_map2_val_pair_subset:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\"\n  assumes \"map2_val_compat g\" and \"map2_val_compat h\"\n  shows \"fst ` set (map2_val_pair f g h xs ys) \\<subseteq> fst ` set xs \\<union> fst ` set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h xs ys)\n    \\<subseteq> fst ` set xs \\<union> fst ` set ys", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h xs ys)\n    \\<subseteq> fst ` set xs \\<union> fst ` set ys", "proof (induct f g h xs ys rule: map2_val_pair.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f g h xs.\n       \\<lbrakk>oalist_inv_raw xs; oalist_inv_raw []; map2_val_compat g;\n        map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst ` set (map2_val_pair f g h xs [])\n                         \\<subseteq> fst ` set xs \\<union> fst ` set []\n 2. \\<And>f g h v va.\n       \\<lbrakk>oalist_inv_raw []; oalist_inv_raw (v # va);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst ` set (map2_val_pair f g h [] (v # va))\n                         \\<subseteq> fst ` set [] \\<union>\n                                     fst ` set (v # va)\n 3. \\<And>f g h kx vx xs ky vy ys.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>comp kx ky = Eq; x = f kx vx vy;\n                    oalist_inv_raw xs; oalist_inv_raw ys; map2_val_compat g;\n                    map2_val_compat h\\<rbrakk>\n                   \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ys)\n                                     \\<subseteq> fst ` set xs \\<union>\n           fst ` set ys;\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Lt; x = f kx vx (0::'c); oalist_inv_raw xs;\n            oalist_inv_raw ((ky, vy) # ys); map2_val_compat g;\n            map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h xs ((ky, vy) # ys))\n                             \\<subseteq> fst ` set xs \\<union>\n   fst ` set ((ky, vy) # ys);\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Gt; x = f ky (0::'b) vy;\n            oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ys;\n            map2_val_compat g; map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h ((kx, vx) # xs) ys)\n                             \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n   fst ` set ys;\n        oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ((ky, vy) # ys);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         set (map2_val_pair f g h ((kx, vx) # xs)\n                               ((ky, vy) # ys))\n                         \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n                                     fst ` set ((ky, vy) # ys)", "case (1 f g h xs)"], ["proof (state)\nthis:\n  oalist_inv_raw xs\n  oalist_inv_raw []\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (3 subgoals):\n 1. \\<And>f g h xs.\n       \\<lbrakk>oalist_inv_raw xs; oalist_inv_raw []; map2_val_compat g;\n        map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst ` set (map2_val_pair f g h xs [])\n                         \\<subseteq> fst ` set xs \\<union> fst ` set []\n 2. \\<And>f g h v va.\n       \\<lbrakk>oalist_inv_raw []; oalist_inv_raw (v # va);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst ` set (map2_val_pair f g h [] (v # va))\n                         \\<subseteq> fst ` set [] \\<union>\n                                     fst ` set (v # va)\n 3. \\<And>f g h kx vx xs ky vy ys.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>comp kx ky = Eq; x = f kx vx vy;\n                    oalist_inv_raw xs; oalist_inv_raw ys; map2_val_compat g;\n                    map2_val_compat h\\<rbrakk>\n                   \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ys)\n                                     \\<subseteq> fst ` set xs \\<union>\n           fst ` set ys;\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Lt; x = f kx vx (0::'c); oalist_inv_raw xs;\n            oalist_inv_raw ((ky, vy) # ys); map2_val_compat g;\n            map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h xs ((ky, vy) # ys))\n                             \\<subseteq> fst ` set xs \\<union>\n   fst ` set ((ky, vy) # ys);\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Gt; x = f ky (0::'b) vy;\n            oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ys;\n            map2_val_compat g; map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h ((kx, vx) # xs) ys)\n                             \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n   fst ` set ys;\n        oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ((ky, vy) # ys);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         set (map2_val_pair f g h ((kx, vx) # xs)\n                               ((ky, vy) # ys))\n                         \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n                                     fst ` set ((ky, vy) # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h xs [])\n    \\<subseteq> fst ` set xs \\<union> fst ` set []", "by (simp, rule map2_val_compatD2, fact+)"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h xs [])\n  \\<subseteq> fst ` set xs \\<union> fst ` set []\n\ngoal (2 subgoals):\n 1. \\<And>f g h v va.\n       \\<lbrakk>oalist_inv_raw []; oalist_inv_raw (v # va);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst ` set (map2_val_pair f g h [] (v # va))\n                         \\<subseteq> fst ` set [] \\<union>\n                                     fst ` set (v # va)\n 2. \\<And>f g h kx vx xs ky vy ys.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>comp kx ky = Eq; x = f kx vx vy;\n                    oalist_inv_raw xs; oalist_inv_raw ys; map2_val_compat g;\n                    map2_val_compat h\\<rbrakk>\n                   \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ys)\n                                     \\<subseteq> fst ` set xs \\<union>\n           fst ` set ys;\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Lt; x = f kx vx (0::'c); oalist_inv_raw xs;\n            oalist_inv_raw ((ky, vy) # ys); map2_val_compat g;\n            map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h xs ((ky, vy) # ys))\n                             \\<subseteq> fst ` set xs \\<union>\n   fst ` set ((ky, vy) # ys);\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Gt; x = f ky (0::'b) vy;\n            oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ys;\n            map2_val_compat g; map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h ((kx, vx) # xs) ys)\n                             \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n   fst ` set ys;\n        oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ((ky, vy) # ys);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         set (map2_val_pair f g h ((kx, vx) # xs)\n                               ((ky, vy) # ys))\n                         \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n                                     fst ` set ((ky, vy) # ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f g h v va.\n       \\<lbrakk>oalist_inv_raw []; oalist_inv_raw (v # va);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst ` set (map2_val_pair f g h [] (v # va))\n                         \\<subseteq> fst ` set [] \\<union>\n                                     fst ` set (v # va)\n 2. \\<And>f g h kx vx xs ky vy ys.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>comp kx ky = Eq; x = f kx vx vy;\n                    oalist_inv_raw xs; oalist_inv_raw ys; map2_val_compat g;\n                    map2_val_compat h\\<rbrakk>\n                   \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ys)\n                                     \\<subseteq> fst ` set xs \\<union>\n           fst ` set ys;\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Lt; x = f kx vx (0::'c); oalist_inv_raw xs;\n            oalist_inv_raw ((ky, vy) # ys); map2_val_compat g;\n            map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h xs ((ky, vy) # ys))\n                             \\<subseteq> fst ` set xs \\<union>\n   fst ` set ((ky, vy) # ys);\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Gt; x = f ky (0::'b) vy;\n            oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ys;\n            map2_val_compat g; map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h ((kx, vx) # xs) ys)\n                             \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n   fst ` set ys;\n        oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ((ky, vy) # ys);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         set (map2_val_pair f g h ((kx, vx) # xs)\n                               ((ky, vy) # ys))\n                         \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n                                     fst ` set ((ky, vy) # ys)", "case (2 f g h v va)"], ["proof (state)\nthis:\n  oalist_inv_raw []\n  oalist_inv_raw (v # va)\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (2 subgoals):\n 1. \\<And>f g h v va.\n       \\<lbrakk>oalist_inv_raw []; oalist_inv_raw (v # va);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst ` set (map2_val_pair f g h [] (v # va))\n                         \\<subseteq> fst ` set [] \\<union>\n                                     fst ` set (v # va)\n 2. \\<And>f g h kx vx xs ky vy ys.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>comp kx ky = Eq; x = f kx vx vy;\n                    oalist_inv_raw xs; oalist_inv_raw ys; map2_val_compat g;\n                    map2_val_compat h\\<rbrakk>\n                   \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ys)\n                                     \\<subseteq> fst ` set xs \\<union>\n           fst ` set ys;\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Lt; x = f kx vx (0::'c); oalist_inv_raw xs;\n            oalist_inv_raw ((ky, vy) # ys); map2_val_compat g;\n            map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h xs ((ky, vy) # ys))\n                             \\<subseteq> fst ` set xs \\<union>\n   fst ` set ((ky, vy) # ys);\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Gt; x = f ky (0::'b) vy;\n            oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ys;\n            map2_val_compat g; map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h ((kx, vx) # xs) ys)\n                             \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n   fst ` set ys;\n        oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ((ky, vy) # ys);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         set (map2_val_pair f g h ((kx, vx) # xs)\n                               ((ky, vy) # ys))\n                         \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n                                     fst ` set ((ky, vy) # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h [] (v # va))\n    \\<subseteq> fst ` set [] \\<union> fst ` set (v # va)", "by (simp del: set_simps(2), rule map2_val_compatD2, fact+)"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h [] (v # va))\n  \\<subseteq> fst ` set [] \\<union> fst ` set (v # va)\n\ngoal (1 subgoal):\n 1. \\<And>f g h kx vx xs ky vy ys.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>comp kx ky = Eq; x = f kx vx vy;\n                    oalist_inv_raw xs; oalist_inv_raw ys; map2_val_compat g;\n                    map2_val_compat h\\<rbrakk>\n                   \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ys)\n                                     \\<subseteq> fst ` set xs \\<union>\n           fst ` set ys;\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Lt; x = f kx vx (0::'c); oalist_inv_raw xs;\n            oalist_inv_raw ((ky, vy) # ys); map2_val_compat g;\n            map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h xs ((ky, vy) # ys))\n                             \\<subseteq> fst ` set xs \\<union>\n   fst ` set ((ky, vy) # ys);\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Gt; x = f ky (0::'b) vy;\n            oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ys;\n            map2_val_compat g; map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h ((kx, vx) # xs) ys)\n                             \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n   fst ` set ys;\n        oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ((ky, vy) # ys);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         set (map2_val_pair f g h ((kx, vx) # xs)\n                               ((ky, vy) # ys))\n                         \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n                                     fst ` set ((ky, vy) # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g h kx vx xs ky vy ys.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>comp kx ky = Eq; x = f kx vx vy;\n                    oalist_inv_raw xs; oalist_inv_raw ys; map2_val_compat g;\n                    map2_val_compat h\\<rbrakk>\n                   \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ys)\n                                     \\<subseteq> fst ` set xs \\<union>\n           fst ` set ys;\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Lt; x = f kx vx (0::'c); oalist_inv_raw xs;\n            oalist_inv_raw ((ky, vy) # ys); map2_val_compat g;\n            map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h xs ((ky, vy) # ys))\n                             \\<subseteq> fst ` set xs \\<union>\n   fst ` set ((ky, vy) # ys);\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Gt; x = f ky (0::'b) vy;\n            oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ys;\n            map2_val_compat g; map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h ((kx, vx) # xs) ys)\n                             \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n   fst ` set ys;\n        oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ((ky, vy) # ys);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         set (map2_val_pair f g h ((kx, vx) # xs)\n                               ((ky, vy) # ys))\n                         \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n                                     fst ` set ((ky, vy) # ys)", "case (3 f g h kx vx xs ky vy ys)"], ["proof (state)\nthis:\n  \\<lbrakk>comp kx ky = Eq; ?x35 = f kx vx vy; oalist_inv_raw xs;\n   oalist_inv_raw ys; map2_val_compat g; map2_val_compat h\\<rbrakk>\n  \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ys)\n                    \\<subseteq> fst ` set xs \\<union> fst ` set ys\n  \\<lbrakk>comp kx ky = Lt; ?x35 = f kx vx (0::'c); oalist_inv_raw xs;\n   oalist_inv_raw ((ky, vy) # ys); map2_val_compat g;\n   map2_val_compat h\\<rbrakk>\n  \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ((ky, vy) # ys))\n                    \\<subseteq> fst ` set xs \\<union>\n                                fst ` set ((ky, vy) # ys)\n  \\<lbrakk>comp kx ky = Gt; ?x35 = f ky (0::'b) vy;\n   oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ys; map2_val_compat g;\n   map2_val_compat h\\<rbrakk>\n  \\<Longrightarrow> fst ` set (map2_val_pair f g h ((kx, vx) # xs) ys)\n                    \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n                                fst ` set ys\n  oalist_inv_raw ((kx, vx) # xs)\n  oalist_inv_raw ((ky, vy) # ys)\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. \\<And>f g h kx vx xs ky vy ys.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>comp kx ky = Eq; x = f kx vx vy;\n                    oalist_inv_raw xs; oalist_inv_raw ys; map2_val_compat g;\n                    map2_val_compat h\\<rbrakk>\n                   \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ys)\n                                     \\<subseteq> fst ` set xs \\<union>\n           fst ` set ys;\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Lt; x = f kx vx (0::'c); oalist_inv_raw xs;\n            oalist_inv_raw ((ky, vy) # ys); map2_val_compat g;\n            map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h xs ((ky, vy) # ys))\n                             \\<subseteq> fst ` set xs \\<union>\n   fst ` set ((ky, vy) # ys);\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Gt; x = f ky (0::'b) vy;\n            oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ys;\n            map2_val_compat g; map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h ((kx, vx) # xs) ys)\n                             \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n   fst ` set ys;\n        oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ((ky, vy) # ys);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         set (map2_val_pair f g h ((kx, vx) # xs)\n                               ((ky, vy) # ys))\n                         \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n                                     fst ` set ((ky, vy) # ys)", "from 3(4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((kx, vx) # xs)", "have \"oalist_inv_raw xs\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((kx, vx) # xs)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw xs", "by (rule oalist_inv_raw_ConsD1)"], ["proof (state)\nthis:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. \\<And>f g h kx vx xs ky vy ys.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>comp kx ky = Eq; x = f kx vx vy;\n                    oalist_inv_raw xs; oalist_inv_raw ys; map2_val_compat g;\n                    map2_val_compat h\\<rbrakk>\n                   \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ys)\n                                     \\<subseteq> fst ` set xs \\<union>\n           fst ` set ys;\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Lt; x = f kx vx (0::'c); oalist_inv_raw xs;\n            oalist_inv_raw ((ky, vy) # ys); map2_val_compat g;\n            map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h xs ((ky, vy) # ys))\n                             \\<subseteq> fst ` set xs \\<union>\n   fst ` set ((ky, vy) # ys);\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Gt; x = f ky (0::'b) vy;\n            oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ys;\n            map2_val_compat g; map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h ((kx, vx) # xs) ys)\n                             \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n   fst ` set ys;\n        oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ((ky, vy) # ys);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         set (map2_val_pair f g h ((kx, vx) # xs)\n                               ((ky, vy) # ys))\n                         \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n                                     fst ` set ((ky, vy) # ys)", "from 3(5)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((ky, vy) # ys)", "have \"oalist_inv_raw ys\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((ky, vy) # ys)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ys", "by (rule oalist_inv_raw_ConsD1)"], ["proof (state)\nthis:\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. \\<And>f g h kx vx xs ky vy ys.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>comp kx ky = Eq; x = f kx vx vy;\n                    oalist_inv_raw xs; oalist_inv_raw ys; map2_val_compat g;\n                    map2_val_compat h\\<rbrakk>\n                   \\<Longrightarrow> fst ` set (map2_val_pair f g h xs ys)\n                                     \\<subseteq> fst ` set xs \\<union>\n           fst ` set ys;\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Lt; x = f kx vx (0::'c); oalist_inv_raw xs;\n            oalist_inv_raw ((ky, vy) # ys); map2_val_compat g;\n            map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h xs ((ky, vy) # ys))\n                             \\<subseteq> fst ` set xs \\<union>\n   fst ` set ((ky, vy) # ys);\n        \\<And>x.\n           \\<lbrakk>comp kx ky = Gt; x = f ky (0::'b) vy;\n            oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ys;\n            map2_val_compat g; map2_val_compat h\\<rbrakk>\n           \\<Longrightarrow> fst `\n                             set (map2_val_pair f g h ((kx, vx) # xs) ys)\n                             \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n   fst ` set ys;\n        oalist_inv_raw ((kx, vx) # xs); oalist_inv_raw ((ky, vy) # ys);\n        map2_val_compat g; map2_val_compat h\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         set (map2_val_pair f g h ((kx, vx) # xs)\n                               ((ky, vy) # ys))\n                         \\<subseteq> fst ` set ((kx, vx) # xs) \\<union>\n                                     fst ` set ((ky, vy) # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h ((kx, vx) # xs) ((ky, vy) # ys))\n    \\<subseteq> fst ` set ((kx, vx) # xs) \\<union> fst ` set ((ky, vy) # ys)", "proof (simp split: order.split, intro conjI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    fst `\n    set (let v = f kx vx vy; aux = map2_val_pair f g h xs ys\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n 2. comp kx ky = Lt \\<Longrightarrow>\n    fst `\n    set (let v = f kx vx (0::'c);\n             aux = map2_val_pair f g h xs ((ky, vy) # ys)\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n 3. comp kx ky = Gt \\<Longrightarrow>\n    fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "assume \"comp kx ky = Lt\""], ["proof (state)\nthis:\n  comp kx ky = Lt\n\ngoal (3 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    fst `\n    set (let v = f kx vx vy; aux = map2_val_pair f g h xs ys\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n 2. comp kx ky = Lt \\<Longrightarrow>\n    fst `\n    set (let v = f kx vx (0::'c);\n             aux = map2_val_pair f g h xs ((ky, vy) # ys)\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n 3. comp kx ky = Gt \\<Longrightarrow>\n    fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "hence \"fst ` set (map2_val_pair f g h xs ((ky, vy) # ys)) \\<subseteq> fst ` set xs \\<union> fst ` set ((ky, vy) # ys)\""], ["proof (prove)\nusing this:\n  comp kx ky = Lt\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h xs ((ky, vy) # ys))\n    \\<subseteq> fst ` set xs \\<union> fst ` set ((ky, vy) # ys)", "using refl \\<open>oalist_inv_raw xs\\<close> 3(5, 6, 7)"], ["proof (prove)\nusing this:\n  comp kx ky = Lt\n  ?t = ?t\n  oalist_inv_raw xs\n  oalist_inv_raw ((ky, vy) # ys)\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h xs ((ky, vy) # ys))\n    \\<subseteq> fst ` set xs \\<union> fst ` set ((ky, vy) # ys)", "by (rule 3(2))"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h xs ((ky, vy) # ys))\n  \\<subseteq> fst ` set xs \\<union> fst ` set ((ky, vy) # ys)\n\ngoal (3 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    fst `\n    set (let v = f kx vx vy; aux = map2_val_pair f g h xs ys\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n 2. comp kx ky = Lt \\<Longrightarrow>\n    fst `\n    set (let v = f kx vx (0::'c);\n             aux = map2_val_pair f g h xs ((ky, vy) # ys)\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n 3. comp kx ky = Gt \\<Longrightarrow>\n    fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "thus \"fst ` set (let v = f kx vx 0; aux = map2_val_pair f g h xs ((ky, vy) # ys)\n                       in if v = 0 then aux else (kx, v) # aux)\n          \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\""], ["proof (prove)\nusing this:\n  fst ` set (map2_val_pair f g h xs ((ky, vy) # ys))\n  \\<subseteq> fst ` set xs \\<union> fst ` set ((ky, vy) # ys)\n\ngoal (1 subgoal):\n 1. fst `\n    set (let v = f kx vx (0::'c);\n             aux = map2_val_pair f g h xs ((ky, vy) # ys)\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  fst `\n  set (let v = f kx vx (0::'c); aux = map2_val_pair f g h xs ((ky, vy) # ys)\n       in if v = (0::'d) then aux else (kx, v) # aux)\n  \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n\ngoal (2 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    fst `\n    set (let v = f kx vx vy; aux = map2_val_pair f g h xs ys\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n 2. comp kx ky = Gt \\<Longrightarrow>\n    fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    fst `\n    set (let v = f kx vx vy; aux = map2_val_pair f g h xs ys\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n 2. comp kx ky = Gt \\<Longrightarrow>\n    fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "assume \"comp kx ky = Eq\""], ["proof (state)\nthis:\n  comp kx ky = Eq\n\ngoal (2 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    fst `\n    set (let v = f kx vx vy; aux = map2_val_pair f g h xs ys\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n 2. comp kx ky = Gt \\<Longrightarrow>\n    fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "hence \"fst ` set (map2_val_pair f g h xs ys) \\<subseteq> fst ` set xs \\<union> fst ` set ys\""], ["proof (prove)\nusing this:\n  comp kx ky = Eq\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h xs ys)\n    \\<subseteq> fst ` set xs \\<union> fst ` set ys", "using refl \\<open>oalist_inv_raw xs\\<close> \\<open>oalist_inv_raw ys\\<close> 3(6, 7)"], ["proof (prove)\nusing this:\n  comp kx ky = Eq\n  ?t = ?t\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h xs ys)\n    \\<subseteq> fst ` set xs \\<union> fst ` set ys", "by (rule 3(1))"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h xs ys)\n  \\<subseteq> fst ` set xs \\<union> fst ` set ys\n\ngoal (2 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    fst `\n    set (let v = f kx vx vy; aux = map2_val_pair f g h xs ys\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n 2. comp kx ky = Gt \\<Longrightarrow>\n    fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "thus \"fst ` set (let v = f kx vx vy; aux = map2_val_pair f g h xs ys in if v = 0 then aux else (kx, v) # aux)\n          \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\""], ["proof (prove)\nusing this:\n  fst ` set (map2_val_pair f g h xs ys)\n  \\<subseteq> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. fst `\n    set (let v = f kx vx vy; aux = map2_val_pair f g h xs ys\n         in if v = (0::'d) then aux else (kx, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  fst `\n  set (let v = f kx vx vy; aux = map2_val_pair f g h xs ys\n       in if v = (0::'d) then aux else (kx, v) # aux)\n  \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n\ngoal (1 subgoal):\n 1. comp kx ky = Gt \\<Longrightarrow>\n    fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp kx ky = Gt \\<Longrightarrow>\n    fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "assume \"comp kx ky = Gt\""], ["proof (state)\nthis:\n  comp kx ky = Gt\n\ngoal (1 subgoal):\n 1. comp kx ky = Gt \\<Longrightarrow>\n    fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "hence \"fst ` set (map2_val_pair f g h ((kx, vx) # xs) ys) \\<subseteq> fst ` set ((kx, vx) # xs) \\<union> fst ` set ys\""], ["proof (prove)\nusing this:\n  comp kx ky = Gt\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h ((kx, vx) # xs) ys)\n    \\<subseteq> fst ` set ((kx, vx) # xs) \\<union> fst ` set ys", "using refl 3(4) \\<open>oalist_inv_raw ys\\<close> 3(6, 7)"], ["proof (prove)\nusing this:\n  comp kx ky = Gt\n  ?t = ?t\n  oalist_inv_raw ((kx, vx) # xs)\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h ((kx, vx) # xs) ys)\n    \\<subseteq> fst ` set ((kx, vx) # xs) \\<union> fst ` set ys", "by (rule 3(3))"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h ((kx, vx) # xs) ys)\n  \\<subseteq> fst ` set ((kx, vx) # xs) \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. comp kx ky = Gt \\<Longrightarrow>\n    fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "thus \"fst ` set (let v = f ky 0 vy; aux = map2_val_pair f g h ((kx, vx) # xs) ys\n                        in if v = 0 then aux else (ky, v) # aux)\n          \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\""], ["proof (prove)\nusing this:\n  fst ` set (map2_val_pair f g h ((kx, vx) # xs) ys)\n  \\<subseteq> fst ` set ((kx, vx) # xs) \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. fst `\n    set (let v = f ky (0::'b) vy;\n             aux = map2_val_pair f g h ((kx, vx) # xs) ys\n         in if v = (0::'d) then aux else (ky, v) # aux)\n    \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  fst `\n  set (let v = f ky (0::'b) vy; aux = map2_val_pair f g h ((kx, vx) # xs) ys\n       in if v = (0::'d) then aux else (ky, v) # aux)\n  \\<subseteq> insert ky (insert kx (fst ` set xs \\<union> fst ` set ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h ((kx, vx) # xs) ((ky, vy) # ys))\n  \\<subseteq> fst ` set ((kx, vx) # xs) \\<union> fst ` set ((ky, vy) # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_raw_map2_val_pair:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\"\n  assumes \"map2_val_compat g\" and \"map2_val_compat h\"\n  shows \"oalist_inv_raw (map2_val_pair f g h xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h xs ys)", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h xs ys)", "proof (induct xs arbitrary: ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       oalist_inv_raw ys \\<Longrightarrow>\n       oalist_inv_raw (map2_val_pair f g h [] ys)\n 2. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           oalist_inv_raw ys \\<Longrightarrow>\n           oalist_inv_raw (map2_val_pair f g h xs ys);\n        oalist_inv_raw ys\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw\n                          (map2_val_pair f g h ((k, v) # xs) ys)", "case Nil"], ["proof (state)\nthis:\n  oalist_inv_raw ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       oalist_inv_raw ys \\<Longrightarrow>\n       oalist_inv_raw (map2_val_pair f g h [] ys)\n 2. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           oalist_inv_raw ys \\<Longrightarrow>\n           oalist_inv_raw (map2_val_pair f g h xs ys);\n        oalist_inv_raw ys\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw\n                          (map2_val_pair f g h ((k, v) # xs) ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h [] ys)", "proof (cases ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> oalist_inv_raw (map2_val_pair f g h [] ys)\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       oalist_inv_raw (map2_val_pair f g h [] ys)", "case Nil"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> oalist_inv_raw (map2_val_pair f g h [] ys)\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       oalist_inv_raw (map2_val_pair f g h [] ys)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h [] ys)", "by (simp add: Nil, rule map2_val_compatD1, fact assms(3), fact oalist_inv_raw_Nil)"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h [] ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       oalist_inv_raw (map2_val_pair f g h [] ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       oalist_inv_raw (map2_val_pair f g h [] ys)", "case (Cons y ys')"], ["proof (state)\nthis:\n  ys = y # ys'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       oalist_inv_raw (map2_val_pair f g h [] ys)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h [] ys)", "by (simp add: Cons, rule map2_val_compatD1, fact assms(4), simp only: Cons[symmetric], fact Nil)"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h [] ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h [] ys)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           oalist_inv_raw ys \\<Longrightarrow>\n           oalist_inv_raw (map2_val_pair f g h xs ys);\n        oalist_inv_raw ys\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw\n                          (map2_val_pair f g h ((k, v) # xs) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           oalist_inv_raw ys \\<Longrightarrow>\n           oalist_inv_raw (map2_val_pair f g h xs ys);\n        oalist_inv_raw ys\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw\n                          (map2_val_pair f g h ((k, v) # xs) ys)", "case *: (Cons k v xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  ?k'35 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'35\n  oalist_inv_raw ?ys35 \\<Longrightarrow>\n  oalist_inv_raw (map2_val_pair f g h xs ?ys35)\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           oalist_inv_raw ys \\<Longrightarrow>\n           oalist_inv_raw (map2_val_pair f g h xs ys);\n        oalist_inv_raw ys\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw\n                          (map2_val_pair f g h ((k, v) # xs) ys)", "from *(6)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys", "show ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ys)", "proof (induct ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) [])\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) xs)\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) [])\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) xs)\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) [])", "by (simp, rule map2_val_compatD1, fact assms(3), fact *(1))"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) [])\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) xs)\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) xs)\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))", "case (Cons k' v' ys)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n  oalist_inv_raw ys\n  v' \\<noteq> (0::'c)\n  ?k'35 \\<in> fst ` set ys \\<Longrightarrow> lt k' ?k'35\n  oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) xs)\\<rbrakk>\n       \\<Longrightarrow> oalist_inv_raw\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys))", "proof (simp split: order.split, intro conjI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n 2. comp k k' = Lt \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n 3. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "assume \"comp k k' = Lt\""], ["proof (state)\nthis:\n  comp k k' = Lt\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n 2. comp k k' = Lt \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n 3. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "hence 0: \"lt k k'\""], ["proof (prove)\nusing this:\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. lt k k'", "by (simp only: Lt_lt_conv)"], ["proof (state)\nthis:\n  lt k k'\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n 2. comp k k' = Lt \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n 3. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "from Cons(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k', v') # ys)", "have 1: \"oalist_inv_raw (map2_val_pair f g h xs ((k', v') # ys))\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h xs ((k', v') # ys))", "by (rule *(5))"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h xs ((k', v') # ys))\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n 2. comp k k' = Lt \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n 3. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "show \"oalist_inv_raw (let v = f k v 0; aux = map2_val_pair f g h xs ((k', v') # ys)\n              in if v = 0 then aux else (k, v) # aux)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)", "proof (simp add: Let_def, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f k v (0::'c) = (0::'d) \\<Longrightarrow>\n    oalist_inv_raw (map2_val_pair f g h xs ((k', v') # ys))\n 2. f k v (0::'c) \\<noteq> (0::'d) \\<Longrightarrow>\n    oalist_inv_raw\n     ((k, f k v (0::'c)) # map2_val_pair f g h xs ((k', v') # ys))", "assume \"f k v 0 \\<noteq> 0\""], ["proof (state)\nthis:\n  f k v (0::'c) \\<noteq> (0::'d)\n\ngoal (2 subgoals):\n 1. f k v (0::'c) = (0::'d) \\<Longrightarrow>\n    oalist_inv_raw (map2_val_pair f g h xs ((k', v') # ys))\n 2. f k v (0::'c) \\<noteq> (0::'d) \\<Longrightarrow>\n    oalist_inv_raw\n     ((k, f k v (0::'c)) # map2_val_pair f g h xs ((k', v') # ys))", "with 1"], ["proof (chain)\npicking this:\n  oalist_inv_raw (map2_val_pair f g h xs ((k', v') # ys))\n  f k v (0::'c) \\<noteq> (0::'d)", "show \"oalist_inv_raw ((k, f k v 0) # map2_val_pair f g h xs ((k', v') # ys))\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (map2_val_pair f g h xs ((k', v') # ys))\n  f k v (0::'c) \\<noteq> (0::'d)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw\n     ((k, f k v (0::'c)) # map2_val_pair f g h xs ((k', v') # ys))", "proof (rule oalist_inv_raw_ConsI)"], ["proof (state)\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ((k', v') # ys) \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ((k', v') # ys))))", "define k0 where \"k0 = fst (hd (local.map2_val_pair f g h xs ((k', v') # ys)))\""], ["proof (state)\nthis:\n  k0 = fst (hd (map2_val_pair f g h xs ((k', v') # ys)))\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ((k', v') # ys) \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ((k', v') # ys))))", "assume \"map2_val_pair f g h xs ((k', v') # ys) \\<noteq> []\""], ["proof (state)\nthis:\n  map2_val_pair f g h xs ((k', v') # ys) \\<noteq> []\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ((k', v') # ys) \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ((k', v') # ys))))", "hence \"k0 \\<in> fst ` set (map2_val_pair f g h xs ((k', v') # ys))\""], ["proof (prove)\nusing this:\n  map2_val_pair f g h xs ((k', v') # ys) \\<noteq> []\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set (map2_val_pair f g h xs ((k', v') # ys))", "by (simp add: k0_def)"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set (map2_val_pair f g h xs ((k', v') # ys))\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ((k', v') # ys) \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ((k', v') # ys))))", "also"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set (map2_val_pair f g h xs ((k', v') # ys))\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ((k', v') # ys) \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ((k', v') # ys))))", "from *(2) Cons(1) assms(3, 4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  oalist_inv_raw ((k', v') # ys)\n  map2_val_compat g\n  map2_val_compat h", "have \"... \\<subseteq> fst ` set xs \\<union> fst ` set ((k', v') # ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ((k', v') # ys)\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h xs ((k', v') # ys))\n    \\<subseteq> fst ` set xs \\<union> fst ` set ((k', v') # ys)", "by (rule fst_map2_val_pair_subset)"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h xs ((k', v') # ys))\n  \\<subseteq> fst ` set xs \\<union> fst ` set ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ((k', v') # ys) \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ((k', v') # ys))))", "finally"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)", "have \"k0 \\<in> fst ` set xs \\<or> k0 = k' \\<or> k0 \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs \\<or> k0 = k' \\<or> k0 \\<in> fst ` set ys", "by auto"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<or> k0 = k' \\<or> k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ((k', v') # ys) \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ((k', v') # ys))))", "thus \"lt k k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<or> k0 = k' \\<or> k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k k0", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k k0\n 2. k0 = k' \\<Longrightarrow> lt k k0\n 3. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k k0", "assume \"k0 = k'\""], ["proof (state)\nthis:\n  k0 = k'\n\ngoal (3 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k k0\n 2. k0 = k' \\<Longrightarrow> lt k k0\n 3. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k k0", "with 0"], ["proof (chain)\npicking this:\n  lt k k'\n  k0 = k'", "show ?thesis"], ["proof (prove)\nusing this:\n  lt k k'\n  k0 = k'\n\ngoal (1 subgoal):\n 1. lt k k0", "by simp"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k k0\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k k0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k k0\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k k0", "assume \"k0 \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ys\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k k0\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k k0", "hence \"lt k' k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k0", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k0\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k k0\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k k0", "with 0"], ["proof (chain)\npicking this:\n  lt k k'\n  lt k' k0", "show ?thesis"], ["proof (prove)\nusing this:\n  lt k k'\n  lt k' k0\n\ngoal (1 subgoal):\n 1. lt k k0", "by (rule less_trans)"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k k0", "qed (rule *(4))"], ["proof (state)\nthis:\n  lt k k0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oalist_inv_raw\n   ((k, f k v (0::'c)) # map2_val_pair f g h xs ((k', v') # ys))\n\ngoal (1 subgoal):\n 1. f k v (0::'c) = (0::'d) \\<Longrightarrow>\n    oalist_inv_raw (map2_val_pair f g h xs ((k', v') # ys))", "qed (rule 1)"], ["proof (state)\nthis:\n  oalist_inv_raw\n   (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n    in if v = (0::'d) then aux else (k, v) # aux)\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n 2. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n 2. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "assume \"comp k k' = Eq\""], ["proof (state)\nthis:\n  comp k k' = Eq\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n 2. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "hence \"k = k'\""], ["proof (prove)\nusing this:\n  comp k k' = Eq\n\ngoal (1 subgoal):\n 1. k = k'", "by (simp only: eq)"], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n 2. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "from Cons(2)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys", "have 1: \"oalist_inv_raw (map2_val_pair f g h xs ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h xs ys)", "by (rule *(5))"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h xs ys)\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    oalist_inv_raw\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n 2. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "show \"oalist_inv_raw (let v = f k v v'; aux = map2_val_pair f g h xs ys in if v = 0 then aux else (k, v) # aux)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)", "proof (simp add: Let_def, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f k v v' = (0::'d) \\<Longrightarrow>\n    oalist_inv_raw (map2_val_pair f g h xs ys)\n 2. f k v v' \\<noteq> (0::'d) \\<Longrightarrow>\n    oalist_inv_raw ((k, f k v v') # map2_val_pair f g h xs ys)", "assume \"f k v v' \\<noteq> 0\""], ["proof (state)\nthis:\n  f k v v' \\<noteq> (0::'d)\n\ngoal (2 subgoals):\n 1. f k v v' = (0::'d) \\<Longrightarrow>\n    oalist_inv_raw (map2_val_pair f g h xs ys)\n 2. f k v v' \\<noteq> (0::'d) \\<Longrightarrow>\n    oalist_inv_raw ((k, f k v v') # map2_val_pair f g h xs ys)", "with 1"], ["proof (chain)\npicking this:\n  oalist_inv_raw (map2_val_pair f g h xs ys)\n  f k v v' \\<noteq> (0::'d)", "show \"oalist_inv_raw ((k, f k v v') # map2_val_pair f g h xs ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (map2_val_pair f g h xs ys)\n  f k v v' \\<noteq> (0::'d)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ((k, f k v v') # map2_val_pair f g h xs ys)", "proof (rule oalist_inv_raw_ConsI)"], ["proof (state)\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ys \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ys)))", "define k0 where \"k0 = fst (hd (map2_val_pair f g h xs ys))\""], ["proof (state)\nthis:\n  k0 = fst (hd (map2_val_pair f g h xs ys))\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ys \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ys)))", "assume \"map2_val_pair f g h xs ys \\<noteq> []\""], ["proof (state)\nthis:\n  map2_val_pair f g h xs ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ys \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ys)))", "hence \"k0 \\<in> fst ` set (map2_val_pair f g h xs ys)\""], ["proof (prove)\nusing this:\n  map2_val_pair f g h xs ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set (map2_val_pair f g h xs ys)", "by (simp add: k0_def)"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set (map2_val_pair f g h xs ys)\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ys \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ys)))", "also"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set (map2_val_pair f g h xs ys)\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ys \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ys)))", "from *(2) Cons(2) assms(3, 4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h", "have \"... \\<subseteq> fst ` set xs \\<union> fst ` set ys\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h xs ys)\n    \\<subseteq> fst ` set xs \\<union> fst ` set ys", "by (rule fst_map2_val_pair_subset)"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h xs ys)\n  \\<subseteq> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs ys \\<noteq> [] \\<Longrightarrow>\n    lt k (fst (hd (map2_val_pair f g h xs ys)))", "finally"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys", "show \"lt k k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k k0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k k0\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k k0", "assume \"k0 \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ys\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k k0\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k k0", "hence \"lt k' k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k0", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k0\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k k0\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k k0", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. lt k k0", "by (simp only: \\<open>k = k'\\<close>)"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k k0", "qed (rule *(4))"], ["proof (state)\nthis:\n  lt k k0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, f k v v') # map2_val_pair f g h xs ys)\n\ngoal (1 subgoal):\n 1. f k v v' = (0::'d) \\<Longrightarrow>\n    oalist_inv_raw (map2_val_pair f g h xs ys)", "qed (rule 1)"], ["proof (state)\nthis:\n  oalist_inv_raw\n   (let v = f k v v'; aux = map2_val_pair f g h xs ys\n    in if v = (0::'d) then aux else (k, v) # aux)\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "assume \"comp k k' = Gt\""], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "hence 0: \"lt k' k\""], ["proof (prove)\nusing this:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. lt k' k", "by (simp only: Gt_lt_conv)"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "show \"oalist_inv_raw (let va = f k' 0 v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n              in if va = 0 then aux else (k', va) # aux)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)", "proof (simp add: Let_def, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f k' (0::'b) v' = (0::'d) \\<Longrightarrow>\n    oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ys)\n 2. f k' (0::'b) v' \\<noteq> (0::'d) \\<Longrightarrow>\n    oalist_inv_raw\n     ((k', f k' (0::'b) v') # map2_val_pair f g h ((k, v) # xs) ys)", "assume \"f k' 0 v' \\<noteq> 0\""], ["proof (state)\nthis:\n  f k' (0::'b) v' \\<noteq> (0::'d)\n\ngoal (2 subgoals):\n 1. f k' (0::'b) v' = (0::'d) \\<Longrightarrow>\n    oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ys)\n 2. f k' (0::'b) v' \\<noteq> (0::'d) \\<Longrightarrow>\n    oalist_inv_raw\n     ((k', f k' (0::'b) v') # map2_val_pair f g h ((k, v) # xs) ys)", "with Cons(5)"], ["proof (chain)\npicking this:\n  oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ys)\n  f k' (0::'b) v' \\<noteq> (0::'d)", "show \"oalist_inv_raw ((k', f k' 0 v') # map2_val_pair f g h ((k, v) # xs) ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ys)\n  f k' (0::'b) v' \\<noteq> (0::'d)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw\n     ((k', f k' (0::'b) v') # map2_val_pair f g h ((k, v) # xs) ys)", "proof (rule oalist_inv_raw_ConsI)"], ["proof (state)\ngoal (1 subgoal):\n 1. map2_val_pair f g h ((k, v) # xs) ys \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map2_val_pair f g h ((k, v) # xs) ys)))", "define k0 where \"k0 = fst (hd (map2_val_pair f g h ((k, v) # xs) ys))\""], ["proof (state)\nthis:\n  k0 = fst (hd (map2_val_pair f g h ((k, v) # xs) ys))\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h ((k, v) # xs) ys \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map2_val_pair f g h ((k, v) # xs) ys)))", "assume \"map2_val_pair f g h ((k, v) # xs) ys \\<noteq> []\""], ["proof (state)\nthis:\n  map2_val_pair f g h ((k, v) # xs) ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h ((k, v) # xs) ys \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map2_val_pair f g h ((k, v) # xs) ys)))", "hence \"k0 \\<in> fst ` set (map2_val_pair f g h ((k, v) # xs) ys)\""], ["proof (prove)\nusing this:\n  map2_val_pair f g h ((k, v) # xs) ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set (map2_val_pair f g h ((k, v) # xs) ys)", "by (simp add: k0_def)"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set (map2_val_pair f g h ((k, v) # xs) ys)\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h ((k, v) # xs) ys \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map2_val_pair f g h ((k, v) # xs) ys)))", "also"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set (map2_val_pair f g h ((k, v) # xs) ys)\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h ((k, v) # xs) ys \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map2_val_pair f g h ((k, v) # xs) ys)))", "from *(1) Cons(2) assms(3, 4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h", "have \"... \\<subseteq> fst ` set ((k, v) # xs) \\<union> fst ` set ys\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h ((k, v) # xs) ys)\n    \\<subseteq> fst ` set ((k, v) # xs) \\<union> fst ` set ys", "by (rule fst_map2_val_pair_subset)"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h ((k, v) # xs) ys)\n  \\<subseteq> fst ` set ((k, v) # xs) \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h ((k, v) # xs) ys \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map2_val_pair f g h ((k, v) # xs) ys)))", "finally"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys", "have \"k0 = k \\<or> k0 \\<in> fst ` set xs \\<or> k0 \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 = k \\<or> k0 \\<in> fst ` set xs \\<or> k0 \\<in> fst ` set ys", "by auto"], ["proof (state)\nthis:\n  k0 = k \\<or> k0 \\<in> fst ` set xs \\<or> k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h ((k, v) # xs) ys \\<noteq> [] \\<Longrightarrow>\n    lt k' (fst (hd (map2_val_pair f g h ((k, v) # xs) ys)))", "thus \"lt k' k0\""], ["proof (prove)\nusing this:\n  k0 = k \\<or> k0 \\<in> fst ` set xs \\<or> k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k0", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. k0 = k \\<Longrightarrow> lt k' k0\n 2. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k' k0\n 3. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k' k0", "assume \"k0 = k\""], ["proof (state)\nthis:\n  k0 = k\n\ngoal (3 subgoals):\n 1. k0 = k \\<Longrightarrow> lt k' k0\n 2. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k' k0\n 3. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k' k0", "with 0"], ["proof (chain)\npicking this:\n  lt k' k\n  k0 = k", "show ?thesis"], ["proof (prove)\nusing this:\n  lt k' k\n  k0 = k\n\ngoal (1 subgoal):\n 1. lt k' k0", "by simp"], ["proof (state)\nthis:\n  lt k' k0\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k' k0\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k' k0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k' k0\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k' k0", "assume \"k0 \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k' k0\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k' k0", "hence \"lt k k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k0", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> lt k' k0\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k' k0", "with 0"], ["proof (chain)\npicking this:\n  lt k' k\n  lt k k0", "show ?thesis"], ["proof (prove)\nusing this:\n  lt k' k\n  lt k k0\n\ngoal (1 subgoal):\n 1. lt k' k0", "by (rule less_trans)"], ["proof (state)\nthis:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> lt k' k0", "qed (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oalist_inv_raw\n   ((k', f k' (0::'b) v') # map2_val_pair f g h ((k, v) # xs) ys)\n\ngoal (1 subgoal):\n 1. f k' (0::'b) v' = (0::'d) \\<Longrightarrow>\n    oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ys)", "qed (rule Cons(5))"], ["proof (state)\nthis:\n  oalist_inv_raw\n   (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n    in if va = (0::'d) then aux else (k', va) # aux)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_map2_val_pair:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\"\n  assumes \"map2_val_compat g\" and \"map2_val_compat h\"\n  assumes \"\\<And>zs. oalist_inv_raw zs \\<Longrightarrow> g zs = map_val_pair (\\<lambda>k v. f k v 0) zs\"\n    and \"\\<And>zs. oalist_inv_raw zs \\<Longrightarrow> h zs = map_val_pair (\\<lambda>k. f k 0) zs\"\n    and \"\\<And>k. f k 0 0 = 0\"\n  shows \"lookup_pair (map2_val_pair f g h xs ys) k0 = f k0 (lookup_pair xs k0) (lookup_pair ys k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h xs ys) k0 =\n    f k0 (lookup_pair xs k0) (lookup_pair ys k0)", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h xs ys) k0 =\n    f k0 (lookup_pair xs k0) (lookup_pair ys k0)", "proof (induct xs arbitrary: ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       oalist_inv_raw ys \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)\n 2. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           oalist_inv_raw ys \\<Longrightarrow>\n           lookup_pair (map2_val_pair f g h xs ys) k0 =\n           f k0 (lookup_pair xs k0) (lookup_pair ys k0);\n        oalist_inv_raw ys\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map2_val_pair f g h ((k, v) # xs) ys)\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ys k0)", "case Nil"], ["proof (state)\nthis:\n  oalist_inv_raw ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       oalist_inv_raw ys \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)\n 2. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           oalist_inv_raw ys \\<Longrightarrow>\n           lookup_pair (map2_val_pair f g h xs ys) k0 =\n           f k0 (lookup_pair xs k0) (lookup_pair ys k0);\n        oalist_inv_raw ys\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map2_val_pair f g h ((k, v) # xs) ys)\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ys k0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h [] ys) k0 =\n    f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "proof (cases ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h [] ys) k0 =\n    f k0 (lookup_pair [] k0) (lookup_pair ys k0)\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "case Nil"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h [] ys) k0 =\n    f k0 (lookup_pair [] k0) (lookup_pair ys k0)\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h [] ys) k0 =\n    f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "by (simp add: Nil map2_val_compat_Nil[OF assms(3)] assms(7))"], ["proof (state)\nthis:\n  lookup_pair (map2_val_pair f g h [] ys) k0 =\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "case (Cons y ys')"], ["proof (state)\nthis:\n  ys = y # ys'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "then"], ["proof (chain)\npicking this:\n  ys = y # ys'", "obtain k v ys' where ys: \"ys = (k, v) # ys'\""], ["proof (prove)\nusing this:\n  ys = y # ys'\n\ngoal (1 subgoal):\n 1. (\\<And>k v ys'.\n        ys = (k, v) # ys' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ys = (k, v) # ys'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "from Nil"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys", "have \"lookup_pair (h ys) k0 = lookup_pair (map_val_pair (\\<lambda>k. f k 0) ys) k0\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. lookup_pair (h ys) k0 =\n    lookup_pair (map_val_pair (\\<lambda>k. f k (0::'b)) ys) k0", "by (simp only: assms(6))"], ["proof (state)\nthis:\n  lookup_pair (h ys) k0 =\n  lookup_pair (map_val_pair (\\<lambda>k. f k (0::'b)) ys) k0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "also"], ["proof (state)\nthis:\n  lookup_pair (h ys) k0 =\n  lookup_pair (map_val_pair (\\<lambda>k. f k (0::'b)) ys) k0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "have \"... = f k0 0 (lookup_pair ys k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair (\\<lambda>k. f k (0::'b)) ys) k0 =\n    f k0 (0::'b) (lookup_pair ys k0)", "by (rule lookup_pair_map_val_pair, fact Nil, fact assms(7))"], ["proof (state)\nthis:\n  lookup_pair (map_val_pair (\\<lambda>k. f k (0::'b)) ys) k0 =\n  f k0 (0::'b) (lookup_pair ys k0)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "finally"], ["proof (chain)\npicking this:\n  lookup_pair (h ys) k0 = f k0 (0::'b) (lookup_pair ys k0)", "have \"lookup_pair (h ((k, v) # ys')) k0 = f k0 0 (lookup_pair ((k, v) # ys') k0)\""], ["proof (prove)\nusing this:\n  lookup_pair (h ys) k0 = f k0 (0::'b) (lookup_pair ys k0)\n\ngoal (1 subgoal):\n 1. lookup_pair (h ((k, v) # ys')) k0 =\n    f k0 (0::'b) (lookup_pair ((k, v) # ys') k0)", "by (simp only: ys)"], ["proof (state)\nthis:\n  lookup_pair (h ((k, v) # ys')) k0 =\n  f k0 (0::'b) (lookup_pair ((k, v) # ys') k0)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       lookup_pair (map2_val_pair f g h [] ys) k0 =\n       f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup_pair (h ((k, v) # ys')) k0 =\n  f k0 (0::'b) (lookup_pair ((k, v) # ys') k0)\n\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h [] ys) k0 =\n    f k0 (lookup_pair [] k0) (lookup_pair ys k0)", "by (simp add: ys)"], ["proof (state)\nthis:\n  lookup_pair (map2_val_pair f g h [] ys) k0 =\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (map2_val_pair f g h [] ys) k0 =\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           oalist_inv_raw ys \\<Longrightarrow>\n           lookup_pair (map2_val_pair f g h xs ys) k0 =\n           f k0 (lookup_pair xs k0) (lookup_pair ys k0);\n        oalist_inv_raw ys\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map2_val_pair f g h ((k, v) # xs) ys)\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ys k0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           oalist_inv_raw ys \\<Longrightarrow>\n           lookup_pair (map2_val_pair f g h xs ys) k0 =\n           f k0 (lookup_pair xs k0) (lookup_pair ys k0);\n        oalist_inv_raw ys\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map2_val_pair f g h ((k, v) # xs) ys)\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ys k0)", "case *: (Cons k v xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  ?k'35 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'35\n  oalist_inv_raw ?ys35 \\<Longrightarrow>\n  lookup_pair (map2_val_pair f g h xs ?ys35) k0 =\n  f k0 (lookup_pair xs k0) (lookup_pair ?ys35 k0)\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           oalist_inv_raw ys \\<Longrightarrow>\n           lookup_pair (map2_val_pair f g h xs ys) k0 =\n           f k0 (lookup_pair xs k0) (lookup_pair ys k0);\n        oalist_inv_raw ys\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (map2_val_pair f g h ((k, v) # xs) ys)\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ys k0)", "from *(6)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys", "show ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h ((k, v) # xs) ys) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0)", "proof (induct ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup_pair (map2_val_pair f g h ((k, v) # xs) []) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0)\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map2_val_pair f g h ((k, v) # xs) xs) k0 =\n        f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair xs k0)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ((ka, va) # xs) k0)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lookup_pair (map2_val_pair f g h ((k, v) # xs) []) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0)\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map2_val_pair f g h ((k, v) # xs) xs) k0 =\n        f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair xs k0)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ((ka, va) # xs) k0)", "from *(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs)", "have \"lookup_pair (g ((k, v) # xs)) k0 = lookup_pair (map_val_pair (\\<lambda>k v. f k v 0) ((k, v) # xs)) k0\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n\ngoal (1 subgoal):\n 1. lookup_pair (g ((k, v) # xs)) k0 =\n    lookup_pair (map_val_pair (\\<lambda>k v. f k v (0::'c)) ((k, v) # xs))\n     k0", "by (simp only: assms(5))"], ["proof (state)\nthis:\n  lookup_pair (g ((k, v) # xs)) k0 =\n  lookup_pair (map_val_pair (\\<lambda>k v. f k v (0::'c)) ((k, v) # xs)) k0\n\ngoal (2 subgoals):\n 1. lookup_pair (map2_val_pair f g h ((k, v) # xs) []) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0)\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map2_val_pair f g h ((k, v) # xs) xs) k0 =\n        f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair xs k0)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ((ka, va) # xs) k0)", "also"], ["proof (state)\nthis:\n  lookup_pair (g ((k, v) # xs)) k0 =\n  lookup_pair (map_val_pair (\\<lambda>k v. f k v (0::'c)) ((k, v) # xs)) k0\n\ngoal (2 subgoals):\n 1. lookup_pair (map2_val_pair f g h ((k, v) # xs) []) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0)\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map2_val_pair f g h ((k, v) # xs) xs) k0 =\n        f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair xs k0)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ((ka, va) # xs) k0)", "have \"... = f k0 (lookup_pair ((k, v) # xs) k0) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map_val_pair (\\<lambda>k v. f k v (0::'c)) ((k, v) # xs))\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (0::'c)", "by (rule lookup_pair_map_val_pair, fact *(1), fact assms(7))"], ["proof (state)\nthis:\n  lookup_pair (map_val_pair (\\<lambda>k v. f k v (0::'c)) ((k, v) # xs))\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (0::'c)\n\ngoal (2 subgoals):\n 1. lookup_pair (map2_val_pair f g h ((k, v) # xs) []) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0)\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map2_val_pair f g h ((k, v) # xs) xs) k0 =\n        f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair xs k0)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ((ka, va) # xs) k0)", "finally"], ["proof (chain)\npicking this:\n  lookup_pair (g ((k, v) # xs)) k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (0::'c)", "show ?case"], ["proof (prove)\nusing this:\n  lookup_pair (g ((k, v) # xs)) k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (0::'c)\n\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h ((k, v) # xs) []) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0)", "by simp"], ["proof (state)\nthis:\n  lookup_pair (map2_val_pair f g h ((k, v) # xs) []) k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0)\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map2_val_pair f g h ((k, v) # xs) xs) k0 =\n        f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair xs k0)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ((ka, va) # xs) k0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map2_val_pair f g h ((k, v) # xs) xs) k0 =\n        f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair xs k0)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ((ka, va) # xs) k0)", "case (Cons k' v' ys)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n  oalist_inv_raw ys\n  v' \\<noteq> (0::'c)\n  ?k'35 \\<in> fst ` set ys \\<Longrightarrow> lt k' ?k'35\n  lookup_pair (map2_val_pair f g h ((k, v) # xs) ys) k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0)\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        lookup_pair (map2_val_pair f g h ((k, v) # xs) xs) k0 =\n        f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair xs k0)\\<rbrakk>\n       \\<Longrightarrow> lookup_pair\n                          (map2_val_pair f g h ((k, v) # xs)\n                            ((ka, va) # xs))\n                          k0 =\n                         f k0 (lookup_pair ((k, v) # xs) k0)\n                          (lookup_pair ((ka, va) # xs) k0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "proof (cases \"comp k0 k = Lt \\<and> comp k0 k' = Lt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. comp k0 k = Lt \\<and> comp k0 k' = Lt \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "case True"], ["proof (state)\nthis:\n  comp k0 k = Lt \\<and> comp k0 k' = Lt\n\ngoal (2 subgoals):\n 1. comp k0 k = Lt \\<and> comp k0 k' = Lt \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence 1: \"comp k0 k = Lt\" and 2: \"comp k0 k' = Lt\""], ["proof (prove)\nusing this:\n  comp k0 k = Lt \\<and> comp k0 k' = Lt\n\ngoal (1 subgoal):\n 1. comp k0 k = Lt &&& comp k0 k' = Lt", "by simp_all"], ["proof (state)\nthis:\n  comp k0 k = Lt\n  comp k0 k' = Lt\n\ngoal (2 subgoals):\n 1. comp k0 k = Lt \\<and> comp k0 k' = Lt \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence eq: \"f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0) = 0\""], ["proof (prove)\nusing this:\n  comp k0 k = Lt\n  comp k0 k' = Lt\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0) =\n    (0::'d)", "by (simp add: assms(7))"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0) =\n  (0::'d)\n\ngoal (2 subgoals):\n 1. comp k0 k = Lt \\<and> comp k0 k' = Lt \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "from *(1) Cons(1) assms(3, 4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw ((k', v') # ys)\n  map2_val_compat g\n  map2_val_compat h", "have inv: \"oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys))\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw ((k', v') # ys)\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys))", "by (rule oalist_inv_raw_map2_val_pair)"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys))\n\ngoal (2 subgoals):\n 1. comp k0 k = Lt \\<and> comp k0 k' = Lt \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "proof (simp only: eq lookup_pair_eq_0[OF inv], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. k0 \\<in> fst `\n             set (map2_val_pair f g h ((k, v) # xs)\n                   ((k', v') # ys)) \\<Longrightarrow>\n    False", "assume \"k0 \\<in> fst ` set (local.map2_val_pair f g h ((k, v) # xs) ((k', v') # ys))\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys))\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst `\n             set (map2_val_pair f g h ((k, v) # xs)\n                   ((k', v') # ys)) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys))\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst `\n             set (map2_val_pair f g h ((k, v) # xs)\n                   ((k', v') # ys)) \\<Longrightarrow>\n    False", "from *(1) Cons(1) assms(3, 4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw ((k', v') # ys)\n  map2_val_compat g\n  map2_val_compat h", "have \"... \\<subseteq> fst ` set ((k, v) # xs) \\<union> fst ` set ((k', v') # ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw ((k', v') # ys)\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys))\n    \\<subseteq> fst ` set ((k, v) # xs) \\<union> fst ` set ((k', v') # ys)", "by (rule fst_map2_val_pair_subset)"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys))\n  \\<subseteq> fst ` set ((k, v) # xs) \\<union> fst ` set ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst `\n             set (map2_val_pair f g h ((k, v) # xs)\n                   ((k', v') # ys)) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ((k', v') # ys)", "have \"k0 \\<in> fst ` set xs \\<or> k0 \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs \\<or> k0 \\<in> fst ` set ys", "using 1 2"], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ((k', v') # ys)\n  comp k0 k = Lt\n  comp k0 k' = Lt\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs \\<or> k0 \\<in> fst ` set ys", "by auto"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<or> k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst `\n             set (map2_val_pair f g h ((k, v) # xs)\n                   ((k', v') # ys)) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<or> k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k0 \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k0", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> False", "with 1"], ["proof (chain)\npicking this:\n  comp k0 k = Lt\n  lt k k0", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k0 k = Lt\n  lt k k0\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k0 \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k' k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k0", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> False", "with 2"], ["proof (chain)\npicking this:\n  comp k0 k' = Lt\n  lt k' k0", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k0 k' = Lt\n  lt k' k0\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (1 subgoal):\n 1. \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "case False"], ["proof (state)\nthis:\n  \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt)\n\ngoal (1 subgoal):\n 1. \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "proof (simp split: order.split del: lookup_pair.simps, intro conjI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k k' = Lt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 3. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "assume \"comp k k' = Lt\""], ["proof (state)\nthis:\n  comp k k' = Lt\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k k' = Lt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 3. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "with False"], ["proof (chain)\npicking this:\n  \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt)\n  comp k k' = Lt", "have \"comp k0 k \\<noteq> Lt\""], ["proof (prove)\nusing this:\n  \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt)\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. comp k0 k \\<noteq> Lt", "by (auto simp: Lt_lt_conv)"], ["proof (state)\nthis:\n  comp k0 k \\<noteq> Lt\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k k' = Lt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 3. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "show \"lookup_pair (let v = f k v 0; aux = map2_val_pair f g h xs ((k', v') # ys)\n                            in if v = 0 then aux else (k, v) # aux) k0 =\n              f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "proof (cases \"comp k0 k\")"], ["proof (state)\ngoal (3 subgoals):\n 1. comp k0 k = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k = Lt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 3. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "case Lt"], ["proof (state)\nthis:\n  comp k0 k = Lt\n\ngoal (3 subgoals):\n 1. comp k0 k = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k = Lt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 3. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "with \\<open>comp k0 k \\<noteq> Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k0 k \\<noteq> Lt\n  comp k0 k = Lt", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k0 k \\<noteq> Lt\n  comp k0 k = Lt\n\ngoal (1 subgoal):\n 1. lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", ".."], ["proof (state)\nthis:\n  lookup_pair\n   (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n    in if v = (0::'d) then aux else (k, v) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (2 subgoals):\n 1. comp k0 k = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comp k0 k = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "case Eq"], ["proof (state)\nthis:\n  comp k0 k = Eq\n\ngoal (2 subgoals):\n 1. comp k0 k = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence \"k0 = k\""], ["proof (prove)\nusing this:\n  comp k0 k = Eq\n\ngoal (1 subgoal):\n 1. k0 = k", "by (simp only: eq)"], ["proof (state)\nthis:\n  k0 = k\n\ngoal (2 subgoals):\n 1. comp k0 k = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "with \\<open>comp k k' = Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k k' = Lt\n  k0 = k", "have \"comp k0 k' = Lt\""], ["proof (prove)\nusing this:\n  comp k k' = Lt\n  k0 = k\n\ngoal (1 subgoal):\n 1. comp k0 k' = Lt", "by simp"], ["proof (state)\nthis:\n  comp k0 k' = Lt\n\ngoal (2 subgoals):\n 1. comp k0 k = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence eq1: \"lookup_pair ((k', v') # ys) k = 0\""], ["proof (prove)\nusing this:\n  comp k0 k' = Lt\n\ngoal (1 subgoal):\n 1. lookup_pair ((k', v') # ys) k = (0::'c)", "by (simp add: \\<open>k0 = k\\<close>)"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # ys) k = (0::'c)\n\ngoal (2 subgoals):\n 1. comp k0 k = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "have eq2: \"lookup_pair ((k, v) # xs) k = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k, v) # xs) k = v", "by simp"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k = v\n\ngoal (2 subgoals):\n 1. comp k0 k = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "proof (simp add: Let_def eq1 eq2 \\<open>k0 = k\\<close> del: lookup_pair.simps, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f k v (0::'c) = (0::'d) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h xs ((k', v') # ys)) k = (0::'d)\n 2. f k v (0::'c) \\<noteq> (0::'d) \\<Longrightarrow>\n    lookup_pair\n     ((k, f k v (0::'c)) # map2_val_pair f g h xs ((k', v') # ys)) k =\n    f k v (0::'c)", "from *(2) Cons(1) assms(3, 4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  oalist_inv_raw ((k', v') # ys)\n  map2_val_compat g\n  map2_val_compat h", "have inv: \"oalist_inv_raw (map2_val_pair f g h xs ((k', v') # ys))\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ((k', v') # ys)\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h xs ((k', v') # ys))", "by (rule oalist_inv_raw_map2_val_pair)"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h xs ((k', v') # ys))\n\ngoal (2 subgoals):\n 1. f k v (0::'c) = (0::'d) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h xs ((k', v') # ys)) k = (0::'d)\n 2. f k v (0::'c) \\<noteq> (0::'d) \\<Longrightarrow>\n    lookup_pair\n     ((k, f k v (0::'c)) # map2_val_pair f g h xs ((k', v') # ys)) k =\n    f k v (0::'c)", "show \"lookup_pair (map2_val_pair f g h xs ((k', v') # ys)) k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h xs ((k', v') # ys)) k = (0::'d)", "proof (simp only: lookup_pair_eq_0[OF inv], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst `\n            set (map2_val_pair f g h xs ((k', v') # ys)) \\<Longrightarrow>\n    False", "assume \"k \\<in> fst ` set (local.map2_val_pair f g h xs ((k', v') # ys))\""], ["proof (state)\nthis:\n  k \\<in> fst ` set (map2_val_pair f g h xs ((k', v') # ys))\n\ngoal (1 subgoal):\n 1. k \\<in> fst `\n            set (map2_val_pair f g h xs ((k', v') # ys)) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  k \\<in> fst ` set (map2_val_pair f g h xs ((k', v') # ys))\n\ngoal (1 subgoal):\n 1. k \\<in> fst `\n            set (map2_val_pair f g h xs ((k', v') # ys)) \\<Longrightarrow>\n    False", "from *(2) Cons(1) assms(3, 4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  oalist_inv_raw ((k', v') # ys)\n  map2_val_compat g\n  map2_val_compat h", "have \"... \\<subseteq> fst ` set xs \\<union> fst ` set ((k', v') # ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ((k', v') # ys)\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h xs ((k', v') # ys))\n    \\<subseteq> fst ` set xs \\<union> fst ` set ((k', v') # ys)", "by (rule fst_map2_val_pair_subset)"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h xs ((k', v') # ys))\n  \\<subseteq> fst ` set xs \\<union> fst ` set ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst `\n            set (map2_val_pair f g h xs ((k', v') # ys)) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)", "have \"k \\<in> fst ` set xs \\<or> k \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<or> k \\<in> fst ` set ys", "using \\<open>comp k k' = Lt\\<close>"], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<or> k \\<in> fst ` set ys", "by auto"], ["proof (state)\nthis:\n  k \\<in> fst ` set xs \\<or> k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k \\<in> fst `\n            set (map2_val_pair f g h xs ((k', v') # ys)) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs \\<or> k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k \\<in> fst ` set xs\n\ngoal (2 subgoals):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k k\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k k\n\ngoal (2 subgoals):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k \\<in> fst ` set ys \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k' k\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow> False", "with \\<open>comp k k' = Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k k' = Lt\n  lt k' k", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k k' = Lt\n  lt k' k\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (map2_val_pair f g h xs ((k', v') # ys)) k = (0::'d)\n\ngoal (1 subgoal):\n 1. f k v (0::'c) \\<noteq> (0::'d) \\<Longrightarrow>\n    lookup_pair\n     ((k, f k v (0::'c)) # map2_val_pair f g h xs ((k', v') # ys)) k =\n    f k v (0::'c)", "qed simp"], ["proof (state)\nthis:\n  lookup_pair\n   (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n    in if v = (0::'d) then aux else (k, v) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (1 subgoal):\n 1. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "case Gt"], ["proof (state)\nthis:\n  comp k0 k = Gt\n\ngoal (1 subgoal):\n 1. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence eq1: \"lookup_pair ((k, v) # xs) k0 = lookup_pair xs k0\"\n            and eq2: \"lookup_pair ((k, f k v 0) # map2_val_pair f g h xs ((k', v') # ys)) k0 =\n                  lookup_pair (map2_val_pair f g h xs ((k', v') # ys)) k0\""], ["proof (prove)\nusing this:\n  comp k0 k = Gt\n\ngoal (1 subgoal):\n 1. lookup_pair ((k, v) # xs) k0 = lookup_pair xs k0 &&&\n    lookup_pair\n     ((k, f k v (0::'c)) # map2_val_pair f g h xs ((k', v') # ys)) k0 =\n    lookup_pair (map2_val_pair f g h xs ((k', v') # ys)) k0", "by simp_all"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k0 = lookup_pair xs k0\n  lookup_pair ((k, f k v (0::'c)) # map2_val_pair f g h xs ((k', v') # ys))\n   k0 =\n  lookup_pair (map2_val_pair f g h xs ((k', v') # ys)) k0\n\ngoal (1 subgoal):\n 1. comp k0 k = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair\n     (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "by (simp add: Let_def eq1 eq2 del: lookup_pair.simps, rule *(5), fact Cons(1))"], ["proof (state)\nthis:\n  lookup_pair\n   (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n    in if v = (0::'d) then aux else (k, v) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair\n   (let v = f k v (0::'c); aux = map2_val_pair f g h xs ((k', v') # ys)\n    in if v = (0::'d) then aux else (k, v) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "assume \"comp k k' = Eq\""], ["proof (state)\nthis:\n  comp k k' = Eq\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence \"k = k'\""], ["proof (prove)\nusing this:\n  comp k k' = Eq\n\ngoal (1 subgoal):\n 1. k = k'", "by (simp only: eq)"], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "with False"], ["proof (chain)\npicking this:\n  \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt)\n  k = k'", "have \"comp k0 k' \\<noteq> Lt\""], ["proof (prove)\nusing this:\n  \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt)\n  k = k'\n\ngoal (1 subgoal):\n 1. comp k0 k' \\<noteq> Lt", "by (auto simp: Lt_lt_conv)"], ["proof (state)\nthis:\n  comp k0 k' \\<noteq> Lt\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "show \"lookup_pair (let v = f k v v'; aux = map2_val_pair f g h xs ys in\n                            if v = 0 then aux else (k, v) # aux) k0 =\n              f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "proof (cases \"comp k0 k'\")"], ["proof (state)\ngoal (3 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Lt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 3. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "case Lt"], ["proof (state)\nthis:\n  comp k0 k' = Lt\n\ngoal (3 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Lt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 3. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "with \\<open>comp k0 k' \\<noteq> Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k0 k' \\<noteq> Lt\n  comp k0 k' = Lt", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k0 k' \\<noteq> Lt\n  comp k0 k' = Lt\n\ngoal (1 subgoal):\n 1. lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", ".."], ["proof (state)\nthis:\n  lookup_pair\n   (let v = f k v v'; aux = map2_val_pair f g h xs ys\n    in if v = (0::'d) then aux else (k, v) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (2 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "case Eq"], ["proof (state)\nthis:\n  comp k0 k' = Eq\n\ngoal (2 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence \"k0 = k'\""], ["proof (prove)\nusing this:\n  comp k0 k' = Eq\n\ngoal (1 subgoal):\n 1. k0 = k'", "by (simp only: eq)"], ["proof (state)\nthis:\n  k0 = k'\n\ngoal (2 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "proof (simp add: Let_def \\<open>k = k'\\<close> \\<open>k0 = k'\\<close>, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. f k' v v' = (0::'d) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h xs ys) k' = (0::'d)", "from *(2) Cons(2) assms(3, 4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h", "have inv: \"oalist_inv_raw (map2_val_pair f g h xs ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h xs ys)", "by (rule oalist_inv_raw_map2_val_pair)"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h xs ys)\n\ngoal (1 subgoal):\n 1. f k' v v' = (0::'d) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h xs ys) k' = (0::'d)", "show \"lookup_pair (map2_val_pair f g h xs ys) k' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h xs ys) k' = (0::'d)", "proof (simp only: lookup_pair_eq_0[OF inv], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set (map2_val_pair f g h xs ys) \\<Longrightarrow> False", "assume \"k' \\<in> fst ` set (map2_val_pair f g h xs ys)\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set (map2_val_pair f g h xs ys)\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set (map2_val_pair f g h xs ys) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  k' \\<in> fst ` set (map2_val_pair f g h xs ys)\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set (map2_val_pair f g h xs ys) \\<Longrightarrow> False", "from *(2) Cons(2) assms(3, 4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h", "have \"... \\<subseteq> fst ` set xs \\<union> fst ` set ys\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h xs ys)\n    \\<subseteq> fst ` set xs \\<union> fst ` set ys", "by (rule fst_map2_val_pair_subset)"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h xs ys)\n  \\<subseteq> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set (map2_val_pair f g h xs ys) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  k' \\<in> fst ` set xs \\<union> fst ` set ys", "show False"], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k' \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k' \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set ys\n\ngoal (2 subgoals):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k' \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k' k'\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k'", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k'\n\ngoal (2 subgoals):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k' \\<in> fst ` set ys \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k' k'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False", "assume \"k' \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False", "hence \"lt k k'\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k'", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k k'\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k k'\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>k = k'\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (map2_val_pair f g h xs ys) k' = (0::'d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair\n   (let v = f k v v'; aux = map2_val_pair f g h xs ys\n    in if v = (0::'d) then aux else (k, v) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (1 subgoal):\n 1. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "case Gt"], ["proof (state)\nthis:\n  comp k0 k' = Gt\n\ngoal (1 subgoal):\n 1. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence eq1: \"lookup_pair ((k, v) # xs) k0 = lookup_pair xs k0\"\n            and eq2: \"lookup_pair ((k', v') # ys) k0 = lookup_pair ys k0\"\n            and eq3: \"lookup_pair ((k, f k v v') # map2_val_pair f g h xs ys) k0 =\n                  lookup_pair (map2_val_pair f g h xs ys) k0\""], ["proof (prove)\nusing this:\n  comp k0 k' = Gt\n\ngoal (1 subgoal):\n 1. lookup_pair ((k, v) # xs) k0 = lookup_pair xs k0 &&&\n    lookup_pair ((k', v') # ys) k0 = lookup_pair ys k0 &&&\n    lookup_pair ((k, f k v v') # map2_val_pair f g h xs ys) k0 =\n    lookup_pair (map2_val_pair f g h xs ys) k0", "by (simp_all add: \\<open>k = k'\\<close>)"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k0 = lookup_pair xs k0\n  lookup_pair ((k', v') # ys) k0 = lookup_pair ys k0\n  lookup_pair ((k, f k v v') # map2_val_pair f g h xs ys) k0 =\n  lookup_pair (map2_val_pair f g h xs ys) k0\n\ngoal (1 subgoal):\n 1. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair\n     (let v = f k v v'; aux = map2_val_pair f g h xs ys\n      in if v = (0::'d) then aux else (k, v) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "by (simp add: Let_def eq1 eq2 eq3 del: lookup_pair.simps, rule *(5), fact Cons(2))"], ["proof (state)\nthis:\n  lookup_pair\n   (let v = f k v v'; aux = map2_val_pair f g h xs ys\n    in if v = (0::'d) then aux else (k, v) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair\n   (let v = f k v v'; aux = map2_val_pair f g h xs ys\n    in if v = (0::'d) then aux else (k, v) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "assume \"comp k k' = Gt\""], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence \"comp k' k = Lt\""], ["proof (prove)\nusing this:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. comp k' k = Lt", "by (simp only: Gt_lt_conv Lt_lt_conv)"], ["proof (state)\nthis:\n  comp k' k = Lt\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "with False"], ["proof (chain)\npicking this:\n  \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt)\n  comp k' k = Lt", "have \"comp k0 k' \\<noteq> Lt\""], ["proof (prove)\nusing this:\n  \\<not> (comp k0 k = Lt \\<and> comp k0 k' = Lt)\n  comp k' k = Lt\n\ngoal (1 subgoal):\n 1. comp k0 k' \\<noteq> Lt", "by (auto simp: Lt_lt_conv)"], ["proof (state)\nthis:\n  comp k0 k' \\<noteq> Lt\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "show \"lookup_pair (let va = f k' 0 v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n                            in if va = 0 then aux else (k', va) # aux) k0 =\n              f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "proof (cases \"comp k0 k'\")"], ["proof (state)\ngoal (3 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Lt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 3. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "case Lt"], ["proof (state)\nthis:\n  comp k0 k' = Lt\n\ngoal (3 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Lt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 3. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "with \\<open>comp k0 k' \\<noteq> Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k0 k' \\<noteq> Lt\n  comp k0 k' = Lt", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k0 k' \\<noteq> Lt\n  comp k0 k' = Lt\n\ngoal (1 subgoal):\n 1. lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", ".."], ["proof (state)\nthis:\n  lookup_pair\n   (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n    in if va = (0::'d) then aux else (k', va) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (2 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "case Eq"], ["proof (state)\nthis:\n  comp k0 k' = Eq\n\ngoal (2 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence \"k0 = k'\""], ["proof (prove)\nusing this:\n  comp k0 k' = Eq\n\ngoal (1 subgoal):\n 1. k0 = k'", "by (simp only: eq)"], ["proof (state)\nthis:\n  k0 = k'\n\ngoal (2 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "with \\<open>comp k' k = Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k' k = Lt\n  k0 = k'", "have \"comp k0 k = Lt\""], ["proof (prove)\nusing this:\n  comp k' k = Lt\n  k0 = k'\n\ngoal (1 subgoal):\n 1. comp k0 k = Lt", "by simp"], ["proof (state)\nthis:\n  comp k0 k = Lt\n\ngoal (2 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence eq1: \"lookup_pair ((k, v) # xs) k' = 0\""], ["proof (prove)\nusing this:\n  comp k0 k = Lt\n\ngoal (1 subgoal):\n 1. lookup_pair ((k, v) # xs) k' = (0::'b)", "by (simp add: \\<open>k0 = k'\\<close>)"], ["proof (state)\nthis:\n  lookup_pair ((k, v) # xs) k' = (0::'b)\n\ngoal (2 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "have eq2: \"lookup_pair ((k', v') # ys) k' = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ((k', v') # ys) k' = v'", "by simp"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # ys) k' = v'\n\ngoal (2 subgoals):\n 1. comp k0 k' = Eq \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n 2. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "proof (simp add: Let_def eq1 eq2 \\<open>k0 = k'\\<close> del: lookup_pair.simps, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f k' (0::'b) v' = (0::'d) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ys) k' = (0::'d)\n 2. f k' (0::'b) v' \\<noteq> (0::'d) \\<Longrightarrow>\n    lookup_pair\n     ((k', f k' (0::'b) v') # map2_val_pair f g h ((k, v) # xs) ys) k' =\n    f k' (0::'b) v'", "from *(1) Cons(2) assms(3, 4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h", "have inv: \"oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ys)", "by (rule oalist_inv_raw_map2_val_pair)"], ["proof (state)\nthis:\n  oalist_inv_raw (map2_val_pair f g h ((k, v) # xs) ys)\n\ngoal (2 subgoals):\n 1. f k' (0::'b) v' = (0::'d) \\<Longrightarrow>\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ys) k' = (0::'d)\n 2. f k' (0::'b) v' \\<noteq> (0::'d) \\<Longrightarrow>\n    lookup_pair\n     ((k', f k' (0::'b) v') # map2_val_pair f g h ((k, v) # xs) ys) k' =\n    f k' (0::'b) v'", "show \"lookup_pair (map2_val_pair f g h ((k, v) # xs) ys) k' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (map2_val_pair f g h ((k, v) # xs) ys) k' = (0::'d)", "proof (simp only: lookup_pair_eq_0[OF inv], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. k' \\<in> fst `\n             set (map2_val_pair f g h ((k, v) # xs) ys) \\<Longrightarrow>\n    False", "assume \"k' \\<in> fst ` set (map2_val_pair f g h ((k, v) # xs) ys)\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set (map2_val_pair f g h ((k, v) # xs) ys)\n\ngoal (1 subgoal):\n 1. k' \\<in> fst `\n             set (map2_val_pair f g h ((k, v) # xs) ys) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  k' \\<in> fst ` set (map2_val_pair f g h ((k, v) # xs) ys)\n\ngoal (1 subgoal):\n 1. k' \\<in> fst `\n             set (map2_val_pair f g h ((k, v) # xs) ys) \\<Longrightarrow>\n    False", "from *(1) Cons(2) assms(3, 4)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h", "have \"... \\<subseteq> fst ` set ((k, v) # xs) \\<union> fst ` set ys\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw ys\n  map2_val_compat g\n  map2_val_compat h\n\ngoal (1 subgoal):\n 1. fst ` set (map2_val_pair f g h ((k, v) # xs) ys)\n    \\<subseteq> fst ` set ((k, v) # xs) \\<union> fst ` set ys", "by (rule fst_map2_val_pair_subset)"], ["proof (state)\nthis:\n  fst ` set (map2_val_pair f g h ((k, v) # xs) ys)\n  \\<subseteq> fst ` set ((k, v) # xs) \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. k' \\<in> fst `\n             set (map2_val_pair f g h ((k, v) # xs) ys) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  k' \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys", "have \"k' \\<in> fst ` set xs \\<or> k' \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<or> k' \\<in> fst ` set ys", "using \\<open>comp k' k = Lt\\<close>"], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\n  comp k' k = Lt\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<or> k' \\<in> fst ` set ys", "by auto"], ["proof (state)\nthis:\n  k' \\<in> fst ` set xs \\<or> k' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k' \\<in> fst `\n             set (map2_val_pair f g h ((k, v) # xs) ys) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set xs \\<or> k' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k' \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k' \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set ys\n\ngoal (2 subgoals):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k' \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k' k'\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k'", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k'\n\ngoal (2 subgoals):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k' \\<in> fst ` set ys \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k' k'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False", "assume \"k' \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False", "hence \"lt k k'\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k'", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k k'\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False", "with \\<open>comp k' k = Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k' k = Lt\n  lt k k'", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k' k = Lt\n  lt k k'\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (map2_val_pair f g h ((k, v) # xs) ys) k' = (0::'d)\n\ngoal (1 subgoal):\n 1. f k' (0::'b) v' \\<noteq> (0::'d) \\<Longrightarrow>\n    lookup_pair\n     ((k', f k' (0::'b) v') # map2_val_pair f g h ((k, v) # xs) ys) k' =\n    f k' (0::'b) v'", "qed simp"], ["proof (state)\nthis:\n  lookup_pair\n   (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n    in if va = (0::'d) then aux else (k', va) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (1 subgoal):\n 1. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "case Gt"], ["proof (state)\nthis:\n  comp k0 k' = Gt\n\ngoal (1 subgoal):\n 1. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "hence eq1: \"lookup_pair ((k', v') # ys) k0 = lookup_pair ys k0\"\n            and eq2: \"lookup_pair ((k', f k' 0 v') # map2_val_pair f g h ((k, v) # xs) ys) k0 =\n                  lookup_pair (map2_val_pair f g h ((k, v) # xs) ys) k0\""], ["proof (prove)\nusing this:\n  comp k0 k' = Gt\n\ngoal (1 subgoal):\n 1. lookup_pair ((k', v') # ys) k0 = lookup_pair ys k0 &&&\n    lookup_pair\n     ((k', f k' (0::'b) v') # map2_val_pair f g h ((k, v) # xs) ys) k0 =\n    lookup_pair (map2_val_pair f g h ((k, v) # xs) ys) k0", "by simp_all"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # ys) k0 = lookup_pair ys k0\n  lookup_pair ((k', f k' (0::'b) v') # map2_val_pair f g h ((k, v) # xs) ys)\n   k0 =\n  lookup_pair (map2_val_pair f g h ((k, v) # xs) ys) k0\n\ngoal (1 subgoal):\n 1. comp k0 k' = Gt \\<Longrightarrow>\n    lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair\n     (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n      in if va = (0::'d) then aux else (k', va) # aux)\n     k0 =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "by (simp add: Let_def eq1 eq2 del: lookup_pair.simps, rule Cons(5))"], ["proof (state)\nthis:\n  lookup_pair\n   (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n    in if va = (0::'d) then aux else (k', va) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair\n   (let va = f k' (0::'b) v'; aux = map2_val_pair f g h ((k, v) # xs) ys\n    in if va = (0::'d) then aux else (k', va) # aux)\n   k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (map2_val_pair f g h ((k, v) # xs) ((k', v') # ys)) k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (map2_val_pair f g h ((k, v) # xs) ys) k0 =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map2_val_pair_singleton_eq_update_by_fun_pair:\n  assumes \"oalist_inv_raw xs\"\n  assumes \"\\<And>k x. f k x 0 = x\" and \"\\<And>zs. oalist_inv_raw zs \\<Longrightarrow> g zs = zs\"\n    and \"h [(k, v)] = map_val_pair (\\<lambda>k. f k 0) [(k, v)]\"\n  shows \"map2_val_pair f g h xs [(k, v)] = update_by_fun_pair k (\\<lambda>x. f k x v) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) xs", "using assms(1)"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. map2_val_pair f g h xs [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) xs", "proof (induct xs rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. map2_val_pair f g h [] [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) []\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        map2_val_pair f g h xs [(k, v)] =\n        update_by_fun_pair k (\\<lambda>x. f k x v) xs\\<rbrakk>\n       \\<Longrightarrow> map2_val_pair f g h ((ka, va) # xs) [(k, v)] =\n                         update_by_fun_pair k (\\<lambda>x. f k x v)\n                          ((ka, va) # xs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. map2_val_pair f g h [] [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) []\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        map2_val_pair f g h xs [(k, v)] =\n        update_by_fun_pair k (\\<lambda>x. f k x v) xs\\<rbrakk>\n       \\<Longrightarrow> map2_val_pair f g h ((ka, va) # xs) [(k, v)] =\n                         update_by_fun_pair k (\\<lambda>x. f k x v)\n                          ((ka, va) # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_pair f g h [] [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) []", "by (simp add: Let_def assms(4))"], ["proof (state)\nthis:\n  map2_val_pair f g h [] [(k, v)] =\n  update_by_fun_pair k (\\<lambda>x. f k x v) []\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        map2_val_pair f g h xs [(k, v)] =\n        update_by_fun_pair k (\\<lambda>x. f k x v) xs\\<rbrakk>\n       \\<Longrightarrow> map2_val_pair f g h ((ka, va) # xs) [(k, v)] =\n                         update_by_fun_pair k (\\<lambda>x. f k x v)\n                          ((ka, va) # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        map2_val_pair f g h xs [(k, v)] =\n        update_by_fun_pair k (\\<lambda>x. f k x v) xs\\<rbrakk>\n       \\<Longrightarrow> map2_val_pair f g h ((ka, va) # xs) [(k, v)] =\n                         update_by_fun_pair k (\\<lambda>x. f k x v)\n                          ((ka, va) # xs)", "case (Cons k' v' xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # xs)\n  oalist_inv_raw xs\n  v' \\<noteq> (0::'b)\n  ?k'35 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'35\n  map2_val_pair f g h xs [(k, v)] =\n  update_by_fun_pair k (\\<lambda>x. f k x v) xs\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        map2_val_pair f g h xs [(k, v)] =\n        update_by_fun_pair k (\\<lambda>x. f k x v) xs\\<rbrakk>\n       \\<Longrightarrow> map2_val_pair f g h ((ka, va) # xs) [(k, v)] =\n                         update_by_fun_pair k (\\<lambda>x. f k x v)\n                          ((ka, va) # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "proof (cases \"comp k' k\")"], ["proof (state)\ngoal (3 subgoals):\n 1. comp k' k = Eq \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n 2. comp k' k = Lt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n 3. comp k' k = Gt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "case Lt"], ["proof (state)\nthis:\n  comp k' k = Lt\n\ngoal (3 subgoals):\n 1. comp k' k = Eq \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n 2. comp k' k = Lt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n 3. comp k' k = Gt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "hence gr: \"comp k k' = Gt\""], ["proof (prove)\nusing this:\n  comp k' k = Lt\n\ngoal (1 subgoal):\n 1. comp k k' = Gt", "by (simp only: Gt_lt_conv Lt_lt_conv)"], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (3 subgoals):\n 1. comp k' k = Eq \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n 2. comp k' k = Lt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n 3. comp k' k = Gt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "by (simp add: Lt gr Let_def assms(2) Cons(3, 5))"], ["proof (state)\nthis:\n  map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n  update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n\ngoal (2 subgoals):\n 1. comp k' k = Eq \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n 2. comp k' k = Gt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comp k' k = Eq \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n 2. comp k' k = Gt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "case Eq"], ["proof (state)\nthis:\n  comp k' k = Eq\n\ngoal (2 subgoals):\n 1. comp k' k = Eq \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n 2. comp k' k = Gt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "hence eq1: \"comp k k' = Eq\" and eq2: \"k = k'\""], ["proof (prove)\nusing this:\n  comp k' k = Eq\n\ngoal (1 subgoal):\n 1. comp k k' = Eq &&& k = k'", "by (simp_all only: eq)"], ["proof (state)\nthis:\n  comp k k' = Eq\n  k = k'\n\ngoal (2 subgoals):\n 1. comp k' k = Eq \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n 2. comp k' k = Gt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "by (simp add: Eq eq1 eq2 Let_def assms(3)[OF Cons(2)])"], ["proof (state)\nthis:\n  map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n  update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n\ngoal (1 subgoal):\n 1. comp k' k = Gt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp k' k = Gt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "case Gt"], ["proof (state)\nthis:\n  comp k' k = Gt\n\ngoal (1 subgoal):\n 1. comp k' k = Gt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "hence less: \"comp k k' = Lt\""], ["proof (prove)\nusing this:\n  comp k' k = Gt\n\ngoal (1 subgoal):\n 1. comp k k' = Lt", "by (simp only: Gt_lt_conv Lt_lt_conv)"], ["proof (state)\nthis:\n  comp k k' = Lt\n\ngoal (1 subgoal):\n 1. comp k' k = Gt \\<Longrightarrow>\n    map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n    update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)", "by (simp add: Gt less Let_def assms(3)[OF Cons(1)])"], ["proof (state)\nthis:\n  map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n  update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map2_val_pair f g h ((k', v') # xs) [(k, v)] =\n  update_by_fun_pair k (\\<lambda>x. f k x v) ((k', v') # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const lex_ord_pair}\\<close>"], ["", "lemma lex_ord_pair_EqI:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\"\n    and \"\\<And>k. k \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow> f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq\"\n  shows \"lex_ord_pair f xs ys = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair f xs ys = Some Eq", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  ?k35 \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow>\n  f ?k35 (lookup_pair xs ?k35) (lookup_pair ys ?k35) = Some Eq\n\ngoal (1 subgoal):\n 1. lex_ord_pair f xs ys = Some Eq", "proof (induct xs arbitrary: ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>oalist_inv_raw ys;\n        \\<And>k.\n           k \\<in> fst ` set [] \\<union> fst ` set ys \\<Longrightarrow>\n           f k (lookup_pair [] k) (lookup_pair ys k) = Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ys = Some Eq\n 2. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            \\<And>k.\n               k \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow>\n               f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq\\<rbrakk>\n           \\<Longrightarrow> lex_ord_pair f xs ys = Some Eq;\n        oalist_inv_raw ys;\n        \\<And>ka.\n           ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                    fst ` set ys \\<Longrightarrow>\n           f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair ys ka) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k, v) # xs) ys = Some Eq", "case Nil"], ["proof (state)\nthis:\n  oalist_inv_raw ys\n  ?k35 \\<in> fst ` set [] \\<union> fst ` set ys \\<Longrightarrow>\n  f ?k35 (lookup_pair [] ?k35) (lookup_pair ys ?k35) = Some Eq\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>oalist_inv_raw ys;\n        \\<And>k.\n           k \\<in> fst ` set [] \\<union> fst ` set ys \\<Longrightarrow>\n           f k (lookup_pair [] k) (lookup_pair ys k) = Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ys = Some Eq\n 2. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            \\<And>k.\n               k \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow>\n               f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq\\<rbrakk>\n           \\<Longrightarrow> lex_ord_pair f xs ys = Some Eq;\n        oalist_inv_raw ys;\n        \\<And>ka.\n           ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                    fst ` set ys \\<Longrightarrow>\n           f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair ys ka) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k, v) # xs) ys = Some Eq", "thus ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n  ?k35 \\<in> fst ` set [] \\<union> fst ` set ys \\<Longrightarrow>\n  f ?k35 (lookup_pair [] ?k35) (lookup_pair ys ?k35) = Some Eq\n\ngoal (1 subgoal):\n 1. lex_ord_pair f [] ys = Some Eq", "proof (induct ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>k.\n        k \\<in> fst ` set [] \\<union> fst ` set [] \\<Longrightarrow>\n        f k (lookup_pair [] k) (lookup_pair [] k) =\n        Some Eq) \\<Longrightarrow>\n    lex_ord_pair f [] [] = Some Eq\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        (\\<And>k.\n            k \\<in> fst ` set [] \\<union> fst ` set xs \\<Longrightarrow>\n            f k (lookup_pair [] k) (lookup_pair xs k) =\n            Some Eq) \\<Longrightarrow>\n        lex_ord_pair f [] xs = Some Eq;\n        \\<And>ka.\n           ka \\<in> fst ` set [] \\<union>\n                    fst ` set ((k, v) # xs) \\<Longrightarrow>\n           f ka (lookup_pair [] ka) (lookup_pair ((k, v) # xs) ka) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ((k, v) # xs) = Some Eq", "case Nil"], ["proof (state)\nthis:\n  ?k35 \\<in> fst ` set [] \\<union> fst ` set [] \\<Longrightarrow>\n  f ?k35 (lookup_pair [] ?k35) (lookup_pair [] ?k35) = Some Eq\n\ngoal (2 subgoals):\n 1. (\\<And>k.\n        k \\<in> fst ` set [] \\<union> fst ` set [] \\<Longrightarrow>\n        f k (lookup_pair [] k) (lookup_pair [] k) =\n        Some Eq) \\<Longrightarrow>\n    lex_ord_pair f [] [] = Some Eq\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        (\\<And>k.\n            k \\<in> fst ` set [] \\<union> fst ` set xs \\<Longrightarrow>\n            f k (lookup_pair [] k) (lookup_pair xs k) =\n            Some Eq) \\<Longrightarrow>\n        lex_ord_pair f [] xs = Some Eq;\n        \\<And>ka.\n           ka \\<in> fst ` set [] \\<union>\n                    fst ` set ((k, v) # xs) \\<Longrightarrow>\n           f ka (lookup_pair [] ka) (lookup_pair ((k, v) # xs) ka) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ((k, v) # xs) = Some Eq", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair f [] [] = Some Eq", "by simp"], ["proof (state)\nthis:\n  lex_ord_pair f [] [] = Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        (\\<And>k.\n            k \\<in> fst ` set [] \\<union> fst ` set xs \\<Longrightarrow>\n            f k (lookup_pair [] k) (lookup_pair xs k) =\n            Some Eq) \\<Longrightarrow>\n        lex_ord_pair f [] xs = Some Eq;\n        \\<And>ka.\n           ka \\<in> fst ` set [] \\<union>\n                    fst ` set ((k, v) # xs) \\<Longrightarrow>\n           f ka (lookup_pair [] ka) (lookup_pair ((k, v) # xs) ka) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ((k, v) # xs) = Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        (\\<And>k.\n            k \\<in> fst ` set [] \\<union> fst ` set xs \\<Longrightarrow>\n            f k (lookup_pair [] k) (lookup_pair xs k) =\n            Some Eq) \\<Longrightarrow>\n        lex_ord_pair f [] xs = Some Eq;\n        \\<And>ka.\n           ka \\<in> fst ` set [] \\<union>\n                    fst ` set ((k, v) # xs) \\<Longrightarrow>\n           f ka (lookup_pair [] ka) (lookup_pair ((k, v) # xs) ka) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ((k, v) # xs) = Some Eq", "case (Cons k v ys)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, v) # ys)\n  oalist_inv_raw ys\n  v \\<noteq> (0::'c)\n  ?k'35 \\<in> fst ` set ys \\<Longrightarrow> lt k ?k'35\n  (\\<And>k.\n      k \\<in> fst ` set [] \\<union> fst ` set ys \\<Longrightarrow>\n      f k (lookup_pair [] k) (lookup_pair ys k) = Some Eq) \\<Longrightarrow>\n  lex_ord_pair f [] ys = Some Eq\n  ?k35 \\<in> fst ` set [] \\<union> fst ` set ((k, v) # ys) \\<Longrightarrow>\n  f ?k35 (lookup_pair [] ?k35) (lookup_pair ((k, v) # ys) ?k35) = Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        (\\<And>k.\n            k \\<in> fst ` set [] \\<union> fst ` set xs \\<Longrightarrow>\n            f k (lookup_pair [] k) (lookup_pair xs k) =\n            Some Eq) \\<Longrightarrow>\n        lex_ord_pair f [] xs = Some Eq;\n        \\<And>ka.\n           ka \\<in> fst ` set [] \\<union>\n                    fst ` set ((k, v) # xs) \\<Longrightarrow>\n           f ka (lookup_pair [] ka) (lookup_pair ((k, v) # xs) ka) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ((k, v) # xs) = Some Eq", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair f [] ((k, v) # ys) = Some Eq", "proof (simp add: Let_def, intro conjI impI, rule Cons(5))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k (0::'b) v = Some Eq;\n        ka \\<in> fst ` set [] \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair [] ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k (0::'b) v = Some Eq", "fix k0"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k (0::'b) v = Some Eq;\n        ka \\<in> fst ` set [] \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair [] ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k (0::'b) v = Some Eq", "assume \"k0 \\<in> fst ` set [] \\<union> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set [] \\<union> fst ` set ys\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k (0::'b) v = Some Eq;\n        ka \\<in> fst ` set [] \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair [] ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k (0::'b) v = Some Eq", "hence \"k0 \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set [] \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys", "by simp"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ys\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k (0::'b) v = Some Eq;\n        ka \\<in> fst ` set [] \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair [] ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k (0::'b) v = Some Eq", "hence \"lt k k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k k0", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k (0::'b) v = Some Eq;\n        ka \\<in> fst ` set [] \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair [] ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k (0::'b) v = Some Eq", "hence \"f k0 (lookup_pair [] k0) (lookup_pair ys k0) = f k0 (lookup_pair [] k0) (lookup_pair ((k, v) # ys) k0)\""], ["proof (prove)\nusing this:\n  lt k k0\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair [] k0) (lookup_pair ys k0) =\n    f k0 (lookup_pair [] k0) (lookup_pair ((k, v) # ys) k0)", "by (auto simp add: lookup_pair_Cons[OF Cons(1)] simp del: lookup_pair.simps)"], ["proof (state)\nthis:\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair [] k0) (lookup_pair ((k, v) # ys) k0)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k (0::'b) v = Some Eq;\n        ka \\<in> fst ` set [] \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair [] ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k (0::'b) v = Some Eq", "also"], ["proof (state)\nthis:\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair [] k0) (lookup_pair ((k, v) # ys) k0)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k (0::'b) v = Some Eq;\n        ka \\<in> fst ` set [] \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair [] ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k (0::'b) v = Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k0 (lookup_pair [] k0) (lookup_pair ((k, v) # ys) k0) = Some Eq", "by (rule Cons(6), simp add: \\<open>k0 \\<in> fst ` set ys\\<close>)"], ["proof (state)\nthis:\n  f k0 (lookup_pair [] k0) (lookup_pair ((k, v) # ys) k0) = Some Eq\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k (0::'b) v = Some Eq;\n        ka \\<in> fst ` set [] \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair [] ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k (0::'b) v = Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0) = Some Eq", "show \"f k0 (lookup_pair [] k0) (lookup_pair ys k0) = Some Eq\""], ["proof (prove)\nusing this:\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair [] k0) (lookup_pair ys k0) = Some Eq", "."], ["proof (state)\nthis:\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k (0::'b) v = Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f k (0::'b) v = Some Eq", "have \"f k 0 v = f k (lookup_pair [] k) (lookup_pair ((k, v) # ys) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k (0::'b) v = f k (lookup_pair [] k) (lookup_pair ((k, v) # ys) k)", "by simp"], ["proof (state)\nthis:\n  f k (0::'b) v = f k (lookup_pair [] k) (lookup_pair ((k, v) # ys) k)\n\ngoal (1 subgoal):\n 1. f k (0::'b) v = Some Eq", "also"], ["proof (state)\nthis:\n  f k (0::'b) v = f k (lookup_pair [] k) (lookup_pair ((k, v) # ys) k)\n\ngoal (1 subgoal):\n 1. f k (0::'b) v = Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k (lookup_pair [] k) (lookup_pair ((k, v) # ys) k) = Some Eq", "by (rule Cons(6), simp)"], ["proof (state)\nthis:\n  f k (lookup_pair [] k) (lookup_pair ((k, v) # ys) k) = Some Eq\n\ngoal (1 subgoal):\n 1. f k (0::'b) v = Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k (0::'b) v = Some Eq", "show \"f k 0 v = Some Eq\""], ["proof (prove)\nusing this:\n  f k (0::'b) v = Some Eq\n\ngoal (1 subgoal):\n 1. f k (0::'b) v = Some Eq", "."], ["proof (state)\nthis:\n  f k (0::'b) v = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f [] ((k, v) # ys) = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f [] ys = Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            \\<And>k.\n               k \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow>\n               f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq\\<rbrakk>\n           \\<Longrightarrow> lex_ord_pair f xs ys = Some Eq;\n        oalist_inv_raw ys;\n        \\<And>ka.\n           ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                    fst ` set ys \\<Longrightarrow>\n           f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair ys ka) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k, v) # xs) ys = Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            \\<And>k.\n               k \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow>\n               f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq\\<rbrakk>\n           \\<Longrightarrow> lex_ord_pair f xs ys = Some Eq;\n        oalist_inv_raw ys;\n        \\<And>ka.\n           ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                    fst ` set ys \\<Longrightarrow>\n           f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair ys ka) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k, v) # xs) ys = Some Eq", "case *: (Cons k v xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  ?k'35 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'35\n  \\<lbrakk>oalist_inv_raw ?ys35;\n   \\<And>k.\n      k \\<in> fst ` set xs \\<union> fst ` set ?ys35 \\<Longrightarrow>\n      f k (lookup_pair xs k) (lookup_pair ?ys35 k) = Some Eq\\<rbrakk>\n  \\<Longrightarrow> lex_ord_pair f xs ?ys35 = Some Eq\n  oalist_inv_raw ys\n  ?k35 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys \\<Longrightarrow>\n  f ?k35 (lookup_pair ((k, v) # xs) ?k35) (lookup_pair ys ?k35) = Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>k v xs ys.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            \\<And>k.\n               k \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow>\n               f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq\\<rbrakk>\n           \\<Longrightarrow> lex_ord_pair f xs ys = Some Eq;\n        oalist_inv_raw ys;\n        \\<And>ka.\n           ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                    fst ` set ys \\<Longrightarrow>\n           f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair ys ka) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k, v) # xs) ys = Some Eq", "from *(6, 7)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys\n  ?k35 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys \\<Longrightarrow>\n  f ?k35 (lookup_pair ((k, v) # xs) ?k35) (lookup_pair ys ?k35) = Some Eq", "show ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n  ?k35 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys \\<Longrightarrow>\n  f ?k35 (lookup_pair ((k, v) # xs) ?k35) (lookup_pair ys ?k35) = Some Eq\n\ngoal (1 subgoal):\n 1. lex_ord_pair f ((k, v) # xs) ys = Some Eq", "proof (induct ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>ka.\n        ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                 fst ` set [] \\<Longrightarrow>\n        f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair [] ka) =\n        Some Eq) \\<Longrightarrow>\n    lex_ord_pair f ((k, v) # xs) [] = Some Eq\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (\\<And>ka.\n            ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                     fst ` set xs \\<Longrightarrow>\n            f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair xs ka) =\n            Some Eq) \\<Longrightarrow>\n        lex_ord_pair f ((k, v) # xs) xs = Some Eq;\n        \\<And>kb.\n           kb \\<in> fst ` set ((k, v) # xs) \\<union>\n                    fst ` set ((ka, va) # xs) \\<Longrightarrow>\n           f kb (lookup_pair ((k, v) # xs) kb)\n            (lookup_pair ((ka, va) # xs) kb) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k, v) # xs) ((ka, va) # xs) =\n                         Some Eq", "case Nil"], ["proof (state)\nthis:\n  ?k35 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set [] \\<Longrightarrow>\n  f ?k35 (lookup_pair ((k, v) # xs) ?k35) (lookup_pair [] ?k35) = Some Eq\n\ngoal (2 subgoals):\n 1. (\\<And>ka.\n        ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                 fst ` set [] \\<Longrightarrow>\n        f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair [] ka) =\n        Some Eq) \\<Longrightarrow>\n    lex_ord_pair f ((k, v) # xs) [] = Some Eq\n 2. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (\\<And>ka.\n            ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                     fst ` set xs \\<Longrightarrow>\n            f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair xs ka) =\n            Some Eq) \\<Longrightarrow>\n        lex_ord_pair f ((k, v) # xs) xs = Some Eq;\n        \\<And>kb.\n           kb \\<in> fst ` set ((k, v) # xs) \\<union>\n                    fst ` set ((ka, va) # xs) \\<Longrightarrow>\n           f kb (lookup_pair ((k, v) # xs) kb)\n            (lookup_pair ((ka, va) # xs) kb) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k, v) # xs) ((ka, va) # xs) =\n                         Some Eq", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair f ((k, v) # xs) [] = Some Eq", "proof (simp add: Let_def, intro conjI impI, rule *(5), rule oalist_inv_raw_Nil)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair [] ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "fix k0"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair [] ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "assume \"k0 \\<in> fst ` set xs \\<union> fst ` set []\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<union> fst ` set []\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair [] ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "hence \"k0 \\<in> fst ` set xs\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set []\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs", "by simp"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair [] ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "hence \"lt k k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k0", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair [] ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "hence \"f k0 (lookup_pair xs k0) (lookup_pair [] k0) = f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0)\""], ["proof (prove)\nusing this:\n  lt k k0\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair [] k0) =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0)", "by (auto simp add: lookup_pair_Cons[OF *(1)] simp del: lookup_pair.simps)"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair [] k0) =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair [] ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "also"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair [] k0) =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair [] ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0) = Some Eq", "by (rule Nil, simp add: \\<open>k0 \\<in> fst ` set xs\\<close>)"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair [] k0) = Some Eq\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair [] ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k0 (lookup_pair xs k0) (lookup_pair [] k0) = Some Eq", "show \"f k0 (lookup_pair xs k0) (lookup_pair [] k0) = Some Eq\""], ["proof (prove)\nusing this:\n  f k0 (lookup_pair xs k0) (lookup_pair [] k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair [] k0) = Some Eq", "."], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair [] k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "have \"f k v 0 = f k (lookup_pair ((k, v) # xs) k) (lookup_pair [] k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k v (0::'c) = f k (lookup_pair ((k, v) # xs) k) (lookup_pair [] k)", "by simp"], ["proof (state)\nthis:\n  f k v (0::'c) = f k (lookup_pair ((k, v) # xs) k) (lookup_pair [] k)\n\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "also"], ["proof (state)\nthis:\n  f k v (0::'c) = f k (lookup_pair ((k, v) # xs) k) (lookup_pair [] k)\n\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k (lookup_pair ((k, v) # xs) k) (lookup_pair [] k) = Some Eq", "by (rule Nil, simp)"], ["proof (state)\nthis:\n  f k (lookup_pair ((k, v) # xs) k) (lookup_pair [] k) = Some Eq\n\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k v (0::'c) = Some Eq", "show \"f k v 0 = Some Eq\""], ["proof (prove)\nusing this:\n  f k v (0::'c) = Some Eq\n\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "."], ["proof (state)\nthis:\n  f k v (0::'c) = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f ((k, v) # xs) [] = Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (\\<And>ka.\n            ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                     fst ` set xs \\<Longrightarrow>\n            f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair xs ka) =\n            Some Eq) \\<Longrightarrow>\n        lex_ord_pair f ((k, v) # xs) xs = Some Eq;\n        \\<And>kb.\n           kb \\<in> fst ` set ((k, v) # xs) \\<union>\n                    fst ` set ((ka, va) # xs) \\<Longrightarrow>\n           f kb (lookup_pair ((k, v) # xs) kb)\n            (lookup_pair ((ka, va) # xs) kb) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k, v) # xs) ((ka, va) # xs) =\n                         Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (\\<And>ka.\n            ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                     fst ` set xs \\<Longrightarrow>\n            f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair xs ka) =\n            Some Eq) \\<Longrightarrow>\n        lex_ord_pair f ((k, v) # xs) xs = Some Eq;\n        \\<And>kb.\n           kb \\<in> fst ` set ((k, v) # xs) \\<union>\n                    fst ` set ((ka, va) # xs) \\<Longrightarrow>\n           f kb (lookup_pair ((k, v) # xs) kb)\n            (lookup_pair ((ka, va) # xs) kb) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k, v) # xs) ((ka, va) # xs) =\n                         Some Eq", "case (Cons k' v' ys)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n  oalist_inv_raw ys\n  v' \\<noteq> (0::'c)\n  ?k'35 \\<in> fst ` set ys \\<Longrightarrow> lt k' ?k'35\n  (\\<And>ka.\n      ka \\<in> fst ` set ((k, v) # xs) \\<union>\n               fst ` set ys \\<Longrightarrow>\n      f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair ys ka) =\n      Some Eq) \\<Longrightarrow>\n  lex_ord_pair f ((k, v) # xs) ys = Some Eq\n  ?k35\n  \\<in> fst ` set ((k, v) # xs) \\<union>\n        fst ` set ((k', v') # ys) \\<Longrightarrow>\n  f ?k35 (lookup_pair ((k, v) # xs) ?k35)\n   (lookup_pair ((k', v') # ys) ?k35) =\n  Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>ka va xs.\n       \\<lbrakk>oalist_inv_raw ((ka, va) # xs); oalist_inv_raw xs;\n        va \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        (\\<And>ka.\n            ka \\<in> fst ` set ((k, v) # xs) \\<union>\n                     fst ` set xs \\<Longrightarrow>\n            f ka (lookup_pair ((k, v) # xs) ka) (lookup_pair xs ka) =\n            Some Eq) \\<Longrightarrow>\n        lex_ord_pair f ((k, v) # xs) xs = Some Eq;\n        \\<And>kb.\n           kb \\<in> fst ` set ((k, v) # xs) \\<union>\n                    fst ` set ((ka, va) # xs) \\<Longrightarrow>\n           f kb (lookup_pair ((k, v) # xs) kb)\n            (lookup_pair ((ka, va) # xs) kb) =\n           Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k, v) # xs) ((ka, va) # xs) =\n                         Some Eq", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair f ((k, v) # xs) ((k', v') # ys) = Some Eq", "proof (simp split: order.split, intro conjI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    (let aux = f k v v'\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    Some Eq\n 2. comp k k' = Lt \\<Longrightarrow>\n    (let aux = f k v (0::'c)\n     in if aux = Some Eq then lex_ord_pair f xs ((k', v') # ys) else aux) =\n    Some Eq\n 3. comp k k' = Gt \\<Longrightarrow>\n    (let aux = f k' (0::'b) v'\n     in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n    Some Eq", "assume \"comp k k' = Lt\""], ["proof (state)\nthis:\n  comp k k' = Lt\n\ngoal (3 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    (let aux = f k v v'\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    Some Eq\n 2. comp k k' = Lt \\<Longrightarrow>\n    (let aux = f k v (0::'c)\n     in if aux = Some Eq then lex_ord_pair f xs ((k', v') # ys) else aux) =\n    Some Eq\n 3. comp k k' = Gt \\<Longrightarrow>\n    (let aux = f k' (0::'b) v'\n     in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n    Some Eq", "show \"(let aux = f k v 0 in if aux = Some Eq then lex_ord_pair f xs ((k', v') # ys) else aux) = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let aux = f k v (0::'c)\n     in if aux = Some Eq then lex_ord_pair f xs ((k', v') # ys) else aux) =\n    Some Eq", "proof (simp add: Let_def, intro conjI impI, rule *(5), rule Cons(1))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka)\n                          (lookup_pair ((k', v') # ys) ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "fix k0"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka)\n                          (lookup_pair ((k', v') # ys) ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "assume k0_in: \"k0 \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka)\n                          (lookup_pair ((k', v') # ys) ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "hence \"k0 \\<in> fst ` set xs \\<or> k0 = k' \\<or> k0 \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs \\<or> k0 = k' \\<or> k0 \\<in> fst ` set ys", "by auto"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<or> k0 = k' \\<or> k0 \\<in> fst ` set ys\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka)\n                          (lookup_pair ((k', v') # ys) ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "hence \"k0 \\<noteq> k\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<or> k0 = k' \\<or> k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 \\<noteq> k", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> k0 \\<noteq> k\n 2. k0 = k' \\<Longrightarrow> k0 \\<noteq> k\n 3. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k", "assume \"k0 \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs\n\ngoal (3 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> k0 \\<noteq> k\n 2. k0 = k' \\<Longrightarrow> k0 \\<noteq> k\n 3. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k", "hence \"lt k k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k0", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (3 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> k0 \\<noteq> k\n 2. k0 = k' \\<Longrightarrow> k0 \\<noteq> k\n 3. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k k0\n\ngoal (1 subgoal):\n 1. k0 \\<noteq> k", "by simp"], ["proof (state)\nthis:\n  k0 \\<noteq> k\n\ngoal (2 subgoals):\n 1. k0 = k' \\<Longrightarrow> k0 \\<noteq> k\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. k0 = k' \\<Longrightarrow> k0 \\<noteq> k\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k", "assume \"k0 = k'\""], ["proof (state)\nthis:\n  k0 = k'\n\ngoal (2 subgoals):\n 1. k0 = k' \\<Longrightarrow> k0 \\<noteq> k\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k", "with \\<open>comp k k' = Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k k' = Lt\n  k0 = k'", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k k' = Lt\n  k0 = k'\n\ngoal (1 subgoal):\n 1. k0 \\<noteq> k", "by auto"], ["proof (state)\nthis:\n  k0 \\<noteq> k\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k", "assume \"k0 \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k", "hence \"lt k' k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k0", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k", "with \\<open>comp k k' = Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k k' = Lt\n  lt k' k0", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k k' = Lt\n  lt k' k0\n\ngoal (1 subgoal):\n 1. k0 \\<noteq> k", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  k0 \\<noteq> k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k0 \\<noteq> k\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka)\n                          (lookup_pair ((k', v') # ys) ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "hence \"f k0 (lookup_pair xs k0) (lookup_pair ((k', v') # ys) k0) =\n                f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\""], ["proof (prove)\nusing this:\n  k0 \\<noteq> k\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair ((k', v') # ys) k0) =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "by (auto simp add: lookup_pair_Cons[OF *(1)] simp del: lookup_pair.simps)"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ((k', v') # ys) k0) =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka)\n                          (lookup_pair ((k', v') # ys) ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "also"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ((k', v') # ys) k0) =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka)\n                          (lookup_pair ((k', v') # ys) ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0) =\n    Some Eq", "by (rule Cons(6), rule rev_subsetD, fact k0_in, auto)"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0) =\n  Some Eq\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v (0::'c) = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ((k', v') # ys)\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka)\n                          (lookup_pair ((k', v') # ys) ka) =\n                         Some Eq\n 2. f k v (0::'c) = Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k0 (lookup_pair xs k0) (lookup_pair ((k', v') # ys) k0) = Some Eq", "show \"f k0 (lookup_pair xs k0) (lookup_pair ((k', v') # ys) k0) = Some Eq\""], ["proof (prove)\nusing this:\n  f k0 (lookup_pair xs k0) (lookup_pair ((k', v') # ys) k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair ((k', v') # ys) k0) = Some Eq", "."], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ((k', v') # ys) k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "have \"f k v 0 = f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k v (0::'c) =\n    f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k)", "by (simp add: \\<open>comp k k' = Lt\\<close>)"], ["proof (state)\nthis:\n  f k v (0::'c) =\n  f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k)\n\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "also"], ["proof (state)\nthis:\n  f k v (0::'c) =\n  f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k)\n\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k) =\n    Some Eq", "by (rule Cons(6), simp)"], ["proof (state)\nthis:\n  f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k) =\n  Some Eq\n\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k v (0::'c) = Some Eq", "show \"f k v 0 = Some Eq\""], ["proof (prove)\nusing this:\n  f k v (0::'c) = Some Eq\n\ngoal (1 subgoal):\n 1. f k v (0::'c) = Some Eq", "."], ["proof (state)\nthis:\n  f k v (0::'c) = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (let aux = f k v (0::'c)\n   in if aux = Some Eq then lex_ord_pair f xs ((k', v') # ys) else aux) =\n  Some Eq\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    (let aux = f k v v'\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    Some Eq\n 2. comp k k' = Gt \\<Longrightarrow>\n    (let aux = f k' (0::'b) v'\n     in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n    Some Eq", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    (let aux = f k v v'\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    Some Eq\n 2. comp k k' = Gt \\<Longrightarrow>\n    (let aux = f k' (0::'b) v'\n     in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n    Some Eq", "assume \"comp k k' = Eq\""], ["proof (state)\nthis:\n  comp k k' = Eq\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    (let aux = f k v v'\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    Some Eq\n 2. comp k k' = Gt \\<Longrightarrow>\n    (let aux = f k' (0::'b) v'\n     in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n    Some Eq", "hence \"k = k'\""], ["proof (prove)\nusing this:\n  comp k k' = Eq\n\ngoal (1 subgoal):\n 1. k = k'", "by (simp only: eq)"], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. comp k k' = Eq \\<Longrightarrow>\n    (let aux = f k v v'\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    Some Eq\n 2. comp k k' = Gt \\<Longrightarrow>\n    (let aux = f k' (0::'b) v'\n     in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n    Some Eq", "show \"(let aux = f k v v' in if aux = Some Eq then lex_ord_pair f xs ys else aux) = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let aux = f k v v'\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    Some Eq", "proof (simp add: Let_def, intro conjI impI, rule *(5), rule Cons(2))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v v' = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k v v' = Some Eq", "fix k0"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v v' = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k v v' = Some Eq", "assume k0_in: \"k0 \\<in> fst ` set xs \\<union> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v v' = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k v v' = Some Eq", "hence \"k0 \\<noteq> k'\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 \\<noteq> k'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> k0 \\<noteq> k'\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "assume \"k0 \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> k0 \\<noteq> k'\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "hence \"lt k k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k0", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (2 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> k0 \\<noteq> k'\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k k0\n\ngoal (1 subgoal):\n 1. k0 \\<noteq> k'", "by (simp add: \\<open>k = k'\\<close>)"], ["proof (state)\nthis:\n  k0 \\<noteq> k'\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "assume \"k0 \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "hence \"lt k' k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k0", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. k0 \\<noteq> k'", "by simp"], ["proof (state)\nthis:\n  k0 \\<noteq> k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k0 \\<noteq> k'\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v v' = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k v v' = Some Eq", "hence \"f k0 (lookup_pair xs k0) (lookup_pair ys k0) =\n                f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\""], ["proof (prove)\nusing this:\n  k0 \\<noteq> k'\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair ys k0) =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "by (simp add: lookup_pair_Cons[OF *(1)] lookup_pair_Cons[OF Cons(1)] del: lookup_pair.simps,\n              auto simp: \\<open>k = k'\\<close>)"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v v' = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k v v' = Some Eq", "also"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v v' = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k v v' = Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0) =\n    Some Eq", "by (rule Cons(6), rule rev_subsetD, fact k0_in, auto)"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0) =\n  Some Eq\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k v v' = Some Eq;\n        ka \\<in> fst ` set xs \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair xs ka) (lookup_pair ys ka) =\n                         Some Eq\n 2. f k v v' = Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) = Some Eq", "show \"f k0 (lookup_pair xs k0) (lookup_pair ys k0) = Some Eq\""], ["proof (prove)\nusing this:\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair ys k0) = Some Eq", "."], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k v v' = Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f k v v' = Some Eq", "have \"f k v v' = f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k v v' =\n    f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k)", "by (simp add: \\<open>k = k'\\<close>)"], ["proof (state)\nthis:\n  f k v v' =\n  f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k)\n\ngoal (1 subgoal):\n 1. f k v v' = Some Eq", "also"], ["proof (state)\nthis:\n  f k v v' =\n  f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k)\n\ngoal (1 subgoal):\n 1. f k v v' = Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k) =\n    Some Eq", "by (rule Cons(6), simp)"], ["proof (state)\nthis:\n  f k (lookup_pair ((k, v) # xs) k) (lookup_pair ((k', v') # ys) k) =\n  Some Eq\n\ngoal (1 subgoal):\n 1. f k v v' = Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k v v' = Some Eq", "show \"f k v v' = Some Eq\""], ["proof (prove)\nusing this:\n  f k v v' = Some Eq\n\ngoal (1 subgoal):\n 1. f k v v' = Some Eq", "."], ["proof (state)\nthis:\n  f k v v' = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (let aux = f k v v'\n   in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n  Some Eq\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    (let aux = f k' (0::'b) v'\n     in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n    Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    (let aux = f k' (0::'b) v'\n     in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n    Some Eq", "assume \"comp k k' = Gt\""], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    (let aux = f k' (0::'b) v'\n     in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n    Some Eq", "hence \"comp k' k = Lt\""], ["proof (prove)\nusing this:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. comp k' k = Lt", "by (simp only: Gt_lt_conv Lt_lt_conv)"], ["proof (state)\nthis:\n  comp k' k = Lt\n\ngoal (1 subgoal):\n 1. comp k k' = Gt \\<Longrightarrow>\n    (let aux = f k' (0::'b) v'\n     in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n    Some Eq", "show \"(let aux = f k' 0 v' in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let aux = f k' (0::'b) v'\n     in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n    Some Eq", "proof (simp add: Let_def, intro conjI impI, rule Cons(5))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k' (0::'b) v' = Some Eq;\n        ka \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair ((k, v) # xs) ka)\n                          (lookup_pair ys ka) =\n                         Some Eq\n 2. f k' (0::'b) v' = Some Eq", "fix k0"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k' (0::'b) v' = Some Eq;\n        ka \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair ((k, v) # xs) ka)\n                          (lookup_pair ys ka) =\n                         Some Eq\n 2. f k' (0::'b) v' = Some Eq", "assume k0_in: \"k0 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k' (0::'b) v' = Some Eq;\n        ka \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair ((k, v) # xs) ka)\n                          (lookup_pair ys ka) =\n                         Some Eq\n 2. f k' (0::'b) v' = Some Eq", "hence \"k0 \\<in> fst ` set xs \\<or> k0 = k \\<or> k0 \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs \\<or> k0 = k \\<or> k0 \\<in> fst ` set ys", "by auto"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<or> k0 = k \\<or> k0 \\<in> fst ` set ys\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k' (0::'b) v' = Some Eq;\n        ka \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair ((k, v) # xs) ka)\n                          (lookup_pair ys ka) =\n                         Some Eq\n 2. f k' (0::'b) v' = Some Eq", "hence \"k0 \\<noteq> k'\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<or> k0 = k \\<or> k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 \\<noteq> k'", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> k0 \\<noteq> k'\n 2. k0 = k \\<Longrightarrow> k0 \\<noteq> k'\n 3. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "assume \"k0 \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs\n\ngoal (3 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> k0 \\<noteq> k'\n 2. k0 = k \\<Longrightarrow> k0 \\<noteq> k'\n 3. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "hence \"lt k k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k k0", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k k0\n\ngoal (3 subgoals):\n 1. k0 \\<in> fst ` set xs \\<Longrightarrow> k0 \\<noteq> k'\n 2. k0 = k \\<Longrightarrow> k0 \\<noteq> k'\n 3. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "with \\<open>comp k' k = Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k' k = Lt\n  lt k k0", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k' k = Lt\n  lt k k0\n\ngoal (1 subgoal):\n 1. k0 \\<noteq> k'", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  k0 \\<noteq> k'\n\ngoal (2 subgoals):\n 1. k0 = k \\<Longrightarrow> k0 \\<noteq> k'\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. k0 = k \\<Longrightarrow> k0 \\<noteq> k'\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "assume \"k0 = k\""], ["proof (state)\nthis:\n  k0 = k\n\ngoal (2 subgoals):\n 1. k0 = k \\<Longrightarrow> k0 \\<noteq> k'\n 2. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "with \\<open>comp k' k = Lt\\<close>"], ["proof (chain)\npicking this:\n  comp k' k = Lt\n  k0 = k", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k' k = Lt\n  k0 = k\n\ngoal (1 subgoal):\n 1. k0 \\<noteq> k'", "by auto"], ["proof (state)\nthis:\n  k0 \\<noteq> k'\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "assume \"k0 \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "hence \"lt k' k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k0", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys \\<Longrightarrow> k0 \\<noteq> k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. k0 \\<noteq> k'", "by simp"], ["proof (state)\nthis:\n  k0 \\<noteq> k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k0 \\<noteq> k'\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k' (0::'b) v' = Some Eq;\n        ka \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair ((k, v) # xs) ka)\n                          (lookup_pair ys ka) =\n                         Some Eq\n 2. f k' (0::'b) v' = Some Eq", "hence \"f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0) =\n                f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\""], ["proof (prove)\nusing this:\n  k0 \\<noteq> k'\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0) =\n    f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)", "by (auto simp add: lookup_pair_Cons[OF Cons(1)] simp del: lookup_pair.simps)"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k' (0::'b) v' = Some Eq;\n        ka \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair ((k, v) # xs) ka)\n                          (lookup_pair ys ka) =\n                         Some Eq\n 2. f k' (0::'b) v' = Some Eq", "also"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k' (0::'b) v' = Some Eq;\n        ka \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair ((k, v) # xs) ka)\n                          (lookup_pair ys ka) =\n                         Some Eq\n 2. f k' (0::'b) v' = Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0) =\n    Some Eq", "by (rule Cons(6), rule rev_subsetD, fact k0_in, auto)"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ((k', v') # ys) k0) =\n  Some Eq\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>f k' (0::'b) v' = Some Eq;\n        ka \\<in> fst ` set ((k, v) # xs) \\<union> fst ` set ys\\<rbrakk>\n       \\<Longrightarrow> f ka (lookup_pair ((k, v) # xs) ka)\n                          (lookup_pair ys ka) =\n                         Some Eq\n 2. f k' (0::'b) v' = Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0) = Some Eq", "show \"f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0) = Some Eq\""], ["proof (prove)\nusing this:\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0) = Some Eq", "."], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k, v) # xs) k0) (lookup_pair ys k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k' (0::'b) v' = Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f k' (0::'b) v' = Some Eq", "have \"f k' 0 v' = f k' (lookup_pair ((k, v) # xs) k') (lookup_pair ((k', v') # ys) k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k' (0::'b) v' =\n    f k' (lookup_pair ((k, v) # xs) k') (lookup_pair ((k', v') # ys) k')", "by (simp add: \\<open>comp k' k = Lt\\<close>)"], ["proof (state)\nthis:\n  f k' (0::'b) v' =\n  f k' (lookup_pair ((k, v) # xs) k') (lookup_pair ((k', v') # ys) k')\n\ngoal (1 subgoal):\n 1. f k' (0::'b) v' = Some Eq", "also"], ["proof (state)\nthis:\n  f k' (0::'b) v' =\n  f k' (lookup_pair ((k, v) # xs) k') (lookup_pair ((k', v') # ys) k')\n\ngoal (1 subgoal):\n 1. f k' (0::'b) v' = Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k' (lookup_pair ((k, v) # xs) k') (lookup_pair ((k', v') # ys) k') =\n    Some Eq", "by (rule Cons(6), simp)"], ["proof (state)\nthis:\n  f k' (lookup_pair ((k, v) # xs) k') (lookup_pair ((k', v') # ys) k') =\n  Some Eq\n\ngoal (1 subgoal):\n 1. f k' (0::'b) v' = Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k' (0::'b) v' = Some Eq", "show \"f k' 0 v' = Some Eq\""], ["proof (prove)\nusing this:\n  f k' (0::'b) v' = Some Eq\n\ngoal (1 subgoal):\n 1. f k' (0::'b) v' = Some Eq", "."], ["proof (state)\nthis:\n  f k' (0::'b) v' = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (let aux = f k' (0::'b) v'\n   in if aux = Some Eq then lex_ord_pair f ((k, v) # xs) ys else aux) =\n  Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f ((k, v) # xs) ((k', v') # ys) = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f ((k, v) # xs) ys = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_ord_pair_valI:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\" and \"aux \\<noteq> Some Eq\"\n  assumes \"k \\<in> fst ` set xs \\<union> fst ` set ys\" and \"aux = f k (lookup_pair xs k) (lookup_pair ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow> lt k' k \\<Longrightarrow>\n              f k' (lookup_pair xs k') (lookup_pair ys k') = Some Eq\"\n  shows \"lex_ord_pair f xs ys = aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair f xs ys = aux", "using assms(1, 2, 4, 5, 6)"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n  aux = f k (lookup_pair xs k) (lookup_pair ys k)\n  \\<lbrakk>?k'35 \\<in> fst ` set xs \\<union> fst ` set ys;\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair xs ?k'35) (lookup_pair ys ?k'35) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. lex_ord_pair f xs ys = aux", "proof (induct xs arbitrary: ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>oalist_inv_raw ys;\n        k \\<in> fst ` set [] \\<union> fst ` set ys;\n        aux = f k (lookup_pair [] k) (lookup_pair ys k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ys = aux\n 2. \\<And>ka v xs ys.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            k \\<in> fst ` set xs \\<union> fst ` set ys;\n            aux = f k (lookup_pair xs k) (lookup_pair ys k);\n            \\<And>k'.\n               \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n                lt k' k\\<rbrakk>\n               \\<Longrightarrow> f k' (lookup_pair xs k')\n                                  (lookup_pair ys k') =\n                                 Some Eq\\<rbrakk>\n           \\<Longrightarrow> lex_ord_pair f xs ys = aux;\n        oalist_inv_raw ys;\n        k \\<in> fst ` set ((ka, v) # xs) \\<union> fst ` set ys;\n        aux = f k (lookup_pair ((ka, v) # xs) k) (lookup_pair ys k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set ((ka, v) # xs) \\<union> fst ` set ys;\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair ((ka, v) # xs) k')\n                              (lookup_pair ys k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((ka, v) # xs) ys = aux", "case Nil"], ["proof (state)\nthis:\n  oalist_inv_raw ys\n  k \\<in> fst ` set [] \\<union> fst ` set ys\n  aux = f k (lookup_pair [] k) (lookup_pair ys k)\n  \\<lbrakk>?k'35 \\<in> fst ` set [] \\<union> fst ` set ys;\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair [] ?k'35) (lookup_pair ys ?k'35) =\n                    Some Eq\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>oalist_inv_raw ys;\n        k \\<in> fst ` set [] \\<union> fst ` set ys;\n        aux = f k (lookup_pair [] k) (lookup_pair ys k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ys = aux\n 2. \\<And>ka v xs ys.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            k \\<in> fst ` set xs \\<union> fst ` set ys;\n            aux = f k (lookup_pair xs k) (lookup_pair ys k);\n            \\<And>k'.\n               \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n                lt k' k\\<rbrakk>\n               \\<Longrightarrow> f k' (lookup_pair xs k')\n                                  (lookup_pair ys k') =\n                                 Some Eq\\<rbrakk>\n           \\<Longrightarrow> lex_ord_pair f xs ys = aux;\n        oalist_inv_raw ys;\n        k \\<in> fst ` set ((ka, v) # xs) \\<union> fst ` set ys;\n        aux = f k (lookup_pair ((ka, v) # xs) k) (lookup_pair ys k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set ((ka, v) # xs) \\<union> fst ` set ys;\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair ((ka, v) # xs) k')\n                              (lookup_pair ys k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((ka, v) # xs) ys = aux", "thus ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n  k \\<in> fst ` set [] \\<union> fst ` set ys\n  aux = f k (lookup_pair [] k) (lookup_pair ys k)\n  \\<lbrakk>?k'35 \\<in> fst ` set [] \\<union> fst ` set ys;\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair [] ?k'35) (lookup_pair ys ?k'35) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. lex_ord_pair f [] ys = aux", "proof (induct ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<in> fst ` set [] \\<union> fst ` set [];\n     aux = f k (lookup_pair [] k) (lookup_pair [] k);\n     \\<And>k'.\n        \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set [];\n         lt k' k\\<rbrakk>\n        \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair [] k') =\n                          Some Eq\\<rbrakk>\n    \\<Longrightarrow> lex_ord_pair f [] [] = aux\n 2. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set [] \\<union> fst ` set xs;\n         aux = f k (lookup_pair [] k) (lookup_pair xs k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set xs;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair xs k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f [] xs = aux;\n        k \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n        aux = f k (lookup_pair [] k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair [] k')\n                              (lookup_pair ((ka, v) # xs) k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ((ka, v) # xs) = aux", "case Nil"], ["proof (state)\nthis:\n  k \\<in> fst ` set [] \\<union> fst ` set []\n  aux = f k (lookup_pair [] k) (lookup_pair [] k)\n  \\<lbrakk>?k'35 \\<in> fst ` set [] \\<union> fst ` set [];\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair [] ?k'35) (lookup_pair [] ?k'35) =\n                    Some Eq\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<in> fst ` set [] \\<union> fst ` set [];\n     aux = f k (lookup_pair [] k) (lookup_pair [] k);\n     \\<And>k'.\n        \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set [];\n         lt k' k\\<rbrakk>\n        \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair [] k') =\n                          Some Eq\\<rbrakk>\n    \\<Longrightarrow> lex_ord_pair f [] [] = aux\n 2. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set [] \\<union> fst ` set xs;\n         aux = f k (lookup_pair [] k) (lookup_pair xs k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set xs;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair xs k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f [] xs = aux;\n        k \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n        aux = f k (lookup_pair [] k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair [] k')\n                              (lookup_pair ((ka, v) # xs) k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ((ka, v) # xs) = aux", "from Nil(1)"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set [] \\<union> fst ` set []", "show ?case"], ["proof (prove)\nusing this:\n  k \\<in> fst ` set [] \\<union> fst ` set []\n\ngoal (1 subgoal):\n 1. lex_ord_pair f [] [] = aux", "by simp"], ["proof (state)\nthis:\n  lex_ord_pair f [] [] = aux\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set [] \\<union> fst ` set xs;\n         aux = f k (lookup_pair [] k) (lookup_pair xs k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set xs;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair xs k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f [] xs = aux;\n        k \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n        aux = f k (lookup_pair [] k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair [] k')\n                              (lookup_pair ((ka, v) # xs) k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ((ka, v) # xs) = aux", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set [] \\<union> fst ` set xs;\n         aux = f k (lookup_pair [] k) (lookup_pair xs k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set xs;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair xs k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f [] xs = aux;\n        k \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n        aux = f k (lookup_pair [] k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair [] k')\n                              (lookup_pair ((ka, v) # xs) k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ((ka, v) # xs) = aux", "case (Cons k' v' ys)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # ys)\n  oalist_inv_raw ys\n  v' \\<noteq> (0::'c)\n  ?k'35 \\<in> fst ` set ys \\<Longrightarrow> lt k' ?k'35\n  \\<lbrakk>k \\<in> fst ` set [] \\<union> fst ` set ys;\n   aux = f k (lookup_pair [] k) (lookup_pair ys k);\n   \\<And>k'.\n      \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys; lt k' k\\<rbrakk>\n      \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                        Some Eq\\<rbrakk>\n  \\<Longrightarrow> lex_ord_pair f [] ys = aux\n  k \\<in> fst ` set [] \\<union> fst ` set ((k', v') # ys)\n  aux = f k (lookup_pair [] k) (lookup_pair ((k', v') # ys) k)\n  \\<lbrakk>?k'35 \\<in> fst ` set [] \\<union> fst ` set ((k', v') # ys);\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair [] ?k'35)\n                     (lookup_pair ((k', v') # ys) ?k'35) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set [] \\<union> fst ` set xs;\n         aux = f k (lookup_pair [] k) (lookup_pair xs k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set xs;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair xs k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f [] xs = aux;\n        k \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n        aux = f k (lookup_pair [] k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair [] k')\n                              (lookup_pair ((ka, v) # xs) k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ((ka, v) # xs) = aux", "from Cons(6)"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set [] \\<union> fst ` set ((k', v') # ys)", "have \"k = k' \\<or> k \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set [] \\<union> fst ` set ((k', v') # ys)\n\ngoal (1 subgoal):\n 1. k = k' \\<or> k \\<in> fst ` set ys", "by simp"], ["proof (state)\nthis:\n  k = k' \\<or> k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set [] \\<union> fst ` set xs;\n         aux = f k (lookup_pair [] k) (lookup_pair xs k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set xs;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair xs k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f [] xs = aux;\n        k \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n        aux = f k (lookup_pair [] k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ((ka, v) # xs);\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair [] k')\n                              (lookup_pair ((ka, v) # xs) k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f [] ((ka, v) # xs) = aux", "thus ?case"], ["proof (prove)\nusing this:\n  k = k' \\<or> k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lex_ord_pair f [] ((k', v') # ys) = aux", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow> lex_ord_pair f [] ((k', v') # ys) = aux\n 2. k \\<in> fst ` set ys \\<Longrightarrow>\n    lex_ord_pair f [] ((k', v') # ys) = aux", "assume \"k = k'\""], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow> lex_ord_pair f [] ((k', v') # ys) = aux\n 2. k \\<in> fst ` set ys \\<Longrightarrow>\n    lex_ord_pair f [] ((k', v') # ys) = aux", "with Cons(7)"], ["proof (chain)\npicking this:\n  aux = f k (lookup_pair [] k) (lookup_pair ((k', v') # ys) k)\n  k = k'", "have \"f k' 0 v' = aux\""], ["proof (prove)\nusing this:\n  aux = f k (lookup_pair [] k) (lookup_pair ((k', v') # ys) k)\n  k = k'\n\ngoal (1 subgoal):\n 1. f k' (0::'b) v' = aux", "by simp"], ["proof (state)\nthis:\n  f k' (0::'b) v' = aux\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow> lex_ord_pair f [] ((k', v') # ys) = aux\n 2. k \\<in> fst ` set ys \\<Longrightarrow>\n    lex_ord_pair f [] ((k', v') # ys) = aux", "thus ?thesis"], ["proof (prove)\nusing this:\n  f k' (0::'b) v' = aux\n\ngoal (1 subgoal):\n 1. lex_ord_pair f [] ((k', v') # ys) = aux", "by (simp add: Let_def \\<open>k = k'\\<close> assms(3))"], ["proof (state)\nthis:\n  lex_ord_pair f [] ((k', v') # ys) = aux\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow>\n    lex_ord_pair f [] ((k', v') # ys) = aux", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow>\n    lex_ord_pair f [] ((k', v') # ys) = aux", "assume \"k \\<in> fst `set ys\""], ["proof (state)\nthis:\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow>\n    lex_ord_pair f [] ((k', v') # ys) = aux", "hence \"lt k' k\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow>\n    lex_ord_pair f [] ((k', v') # ys) = aux", "hence \"comp k k' = Gt\""], ["proof (prove)\nusing this:\n  lt k' k\n\ngoal (1 subgoal):\n 1. comp k k' = Gt", "by (simp add: Gt_lt_conv)"], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow>\n    lex_ord_pair f [] ((k', v') # ys) = aux", "hence eq1: \"lookup_pair ((k', v') # ys) k = lookup_pair ys k\""], ["proof (prove)\nusing this:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. lookup_pair ((k', v') # ys) k = lookup_pair ys k", "by simp"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # ys) k = lookup_pair ys k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow>\n    lex_ord_pair f [] ((k', v') # ys) = aux", "have \"f k' (lookup_pair [] k') (lookup_pair ((k', v') # ys) k') = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k' (lookup_pair [] k') (lookup_pair ((k', v') # ys) k') = Some Eq", "by (rule Cons(8), simp, fact)"], ["proof (state)\nthis:\n  f k' (lookup_pair [] k') (lookup_pair ((k', v') # ys) k') = Some Eq\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow>\n    lex_ord_pair f [] ((k', v') # ys) = aux", "hence eq2: \"f k' 0 v' = Some Eq\""], ["proof (prove)\nusing this:\n  f k' (lookup_pair [] k') (lookup_pair ((k', v') # ys) k') = Some Eq\n\ngoal (1 subgoal):\n 1. f k' (0::'b) v' = Some Eq", "by simp"], ["proof (state)\nthis:\n  f k' (0::'b) v' = Some Eq\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow>\n    lex_ord_pair f [] ((k', v') # ys) = aux", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair f [] ((k', v') # ys) = aux", "proof (simp add: Let_def eq2, rule Cons(5))"], ["proof (state)\ngoal (3 subgoals):\n 1. k \\<in> fst ` set [] \\<union> fst ` set ys\n 2. aux = f k (lookup_pair [] k) (lookup_pair ys k)\n 3. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "from \\<open>k \\<in> fst `set ys\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set ys", "show \"k \\<in> fst ` set [] \\<union> fst ` set ys\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set [] \\<union> fst ` set ys", "by simp"], ["proof (state)\nthis:\n  k \\<in> fst ` set [] \\<union> fst ` set ys\n\ngoal (2 subgoals):\n 1. aux = f k (lookup_pair [] k) (lookup_pair ys k)\n 2. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. aux = f k (lookup_pair [] k) (lookup_pair ys k)\n 2. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "show \"aux = f k (lookup_pair [] k) (lookup_pair ys k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aux = f k (lookup_pair [] k) (lookup_pair ys k)", "by (simp only: Cons(7) eq1)"], ["proof (state)\nthis:\n  aux = f k (lookup_pair [] k) (lookup_pair ys k)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "fix k0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "assume \"lt k0 k\""], ["proof (state)\nthis:\n  lt k0 k\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "assume \"k0 \\<in> fst ` set [] \\<union> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set [] \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "hence k0_in: \"k0 \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set [] \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ys", "by simp"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "hence \"lt k' k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k' k0", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "hence \"comp k0 k' = Gt\""], ["proof (prove)\nusing this:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. comp k0 k' = Gt", "by (simp add: Gt_lt_conv)"], ["proof (state)\nthis:\n  comp k0 k' = Gt\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "hence \"f k0 (lookup_pair [] k0) (lookup_pair ys k0) =\n                f k0 (lookup_pair [] k0) (lookup_pair ((k', v') # ys) k0)\""], ["proof (prove)\nusing this:\n  comp k0 k' = Gt\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair [] k0) (lookup_pair ys k0) =\n    f k0 (lookup_pair [] k0) (lookup_pair ((k', v') # ys) k0)", "by simp"], ["proof (state)\nthis:\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair [] k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "also"], ["proof (state)\nthis:\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair [] k0) (lookup_pair ((k', v') # ys) k0)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k0 (lookup_pair [] k0) (lookup_pair ((k', v') # ys) k0) = Some Eq", "by (rule Cons(8), simp add: k0_in, fact)"], ["proof (state)\nthis:\n  f k0 (lookup_pair [] k0) (lookup_pair ((k', v') # ys) k0) = Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set [] \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair [] k') (lookup_pair ys k') =\n                         Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0) = Some Eq", "show \"f k0 (lookup_pair [] k0) (lookup_pair ys k0) = Some Eq\""], ["proof (prove)\nusing this:\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair [] k0) (lookup_pair ys k0) = Some Eq", "."], ["proof (state)\nthis:\n  f k0 (lookup_pair [] k0) (lookup_pair ys k0) = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f [] ((k', v') # ys) = aux\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f [] ((k', v') # ys) = aux\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f [] ys = aux\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs ys.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            k \\<in> fst ` set xs \\<union> fst ` set ys;\n            aux = f k (lookup_pair xs k) (lookup_pair ys k);\n            \\<And>k'.\n               \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n                lt k' k\\<rbrakk>\n               \\<Longrightarrow> f k' (lookup_pair xs k')\n                                  (lookup_pair ys k') =\n                                 Some Eq\\<rbrakk>\n           \\<Longrightarrow> lex_ord_pair f xs ys = aux;\n        oalist_inv_raw ys;\n        k \\<in> fst ` set ((ka, v) # xs) \\<union> fst ` set ys;\n        aux = f k (lookup_pair ((ka, v) # xs) k) (lookup_pair ys k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set ((ka, v) # xs) \\<union> fst ` set ys;\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair ((ka, v) # xs) k')\n                              (lookup_pair ys k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((ka, v) # xs) ys = aux", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka v xs ys.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            k \\<in> fst ` set xs \\<union> fst ` set ys;\n            aux = f k (lookup_pair xs k) (lookup_pair ys k);\n            \\<And>k'.\n               \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n                lt k' k\\<rbrakk>\n               \\<Longrightarrow> f k' (lookup_pair xs k')\n                                  (lookup_pair ys k') =\n                                 Some Eq\\<rbrakk>\n           \\<Longrightarrow> lex_ord_pair f xs ys = aux;\n        oalist_inv_raw ys;\n        k \\<in> fst ` set ((ka, v) # xs) \\<union> fst ` set ys;\n        aux = f k (lookup_pair ((ka, v) # xs) k) (lookup_pair ys k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set ((ka, v) # xs) \\<union> fst ` set ys;\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair ((ka, v) # xs) k')\n                              (lookup_pair ys k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((ka, v) # xs) ys = aux", "case *: (Cons k' v' xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k', v') # xs)\n  oalist_inv_raw xs\n  v' \\<noteq> (0::'b)\n  ?k'35 \\<in> fst ` set xs \\<Longrightarrow> lt k' ?k'35\n  \\<lbrakk>oalist_inv_raw ?ys35;\n   k \\<in> fst ` set xs \\<union> fst ` set ?ys35;\n   aux = f k (lookup_pair xs k) (lookup_pair ?ys35 k);\n   \\<And>k'.\n      \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ?ys35;\n       lt k' k\\<rbrakk>\n      \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ?ys35 k') =\n                        Some Eq\\<rbrakk>\n  \\<Longrightarrow> lex_ord_pair f xs ?ys35 = aux\n  oalist_inv_raw ys\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\n  aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair ys k)\n  \\<lbrakk>?k'35 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair ((k', v') # xs) ?k'35)\n                     (lookup_pair ys ?k'35) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs ys.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<And>ys.\n           \\<lbrakk>oalist_inv_raw ys;\n            k \\<in> fst ` set xs \\<union> fst ` set ys;\n            aux = f k (lookup_pair xs k) (lookup_pair ys k);\n            \\<And>k'.\n               \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n                lt k' k\\<rbrakk>\n               \\<Longrightarrow> f k' (lookup_pair xs k')\n                                  (lookup_pair ys k') =\n                                 Some Eq\\<rbrakk>\n           \\<Longrightarrow> lex_ord_pair f xs ys = aux;\n        oalist_inv_raw ys;\n        k \\<in> fst ` set ((ka, v) # xs) \\<union> fst ` set ys;\n        aux = f k (lookup_pair ((ka, v) # xs) k) (lookup_pair ys k);\n        \\<And>k'.\n           \\<lbrakk>k' \\<in> fst ` set ((ka, v) # xs) \\<union> fst ` set ys;\n            lt k' k\\<rbrakk>\n           \\<Longrightarrow> f k' (lookup_pair ((ka, v) # xs) k')\n                              (lookup_pair ys k') =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((ka, v) # xs) ys = aux", "from *(6, 7, 8, 9)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\n  aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair ys k)\n  \\<lbrakk>?k'35 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair ((k', v') # xs) ?k'35)\n                     (lookup_pair ys ?k'35) =\n                    Some Eq", "show ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\n  aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair ys k)\n  \\<lbrakk>?k'35 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair ((k', v') # xs) ?k'35)\n                     (lookup_pair ys ?k'35) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. lex_ord_pair f ((k', v') # xs) ys = aux", "proof (induct ys rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set [];\n     aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair [] k);\n     \\<And>k'a.\n        \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set [];\n         lt k'a k\\<rbrakk>\n        \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                           (lookup_pair [] k'a) =\n                          Some Eq\\<rbrakk>\n    \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) [] = aux\n 2. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n         aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair xs k);\n         \\<And>k'a.\n            \\<lbrakk>k'a\n                     \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n             lt k'a k\\<rbrakk>\n            \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                               (lookup_pair xs k'a) =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) xs = aux;\n        k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((ka, v) # xs);\n        aux =\n        f k (lookup_pair ((k', v') # xs) k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'a.\n           \\<lbrakk>k'a\n                    \\<in> fst ` set ((k', v') # xs) \\<union>\n                          fst ` set ((ka, v) # xs);\n            lt k'a k\\<rbrakk>\n           \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                              (lookup_pair ((ka, v) # xs) k'a) =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) ((ka, v) # xs) = aux", "case Nil"], ["proof (state)\nthis:\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set []\n  aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair [] k)\n  \\<lbrakk>?k'35 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set [];\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair ((k', v') # xs) ?k'35)\n                     (lookup_pair [] ?k'35) =\n                    Some Eq\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set [];\n     aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair [] k);\n     \\<And>k'a.\n        \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set [];\n         lt k'a k\\<rbrakk>\n        \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                           (lookup_pair [] k'a) =\n                          Some Eq\\<rbrakk>\n    \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) [] = aux\n 2. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n         aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair xs k);\n         \\<And>k'a.\n            \\<lbrakk>k'a\n                     \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n             lt k'a k\\<rbrakk>\n            \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                               (lookup_pair xs k'a) =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) xs = aux;\n        k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((ka, v) # xs);\n        aux =\n        f k (lookup_pair ((k', v') # xs) k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'a.\n           \\<lbrakk>k'a\n                    \\<in> fst ` set ((k', v') # xs) \\<union>\n                          fst ` set ((ka, v) # xs);\n            lt k'a k\\<rbrakk>\n           \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                              (lookup_pair ((ka, v) # xs) k'a) =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) ((ka, v) # xs) = aux", "from Nil(1)"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set []", "have \"k = k' \\<or> k \\<in> fst ` set xs\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set []\n\ngoal (1 subgoal):\n 1. k = k' \\<or> k \\<in> fst ` set xs", "by simp"], ["proof (state)\nthis:\n  k = k' \\<or> k \\<in> fst ` set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set [];\n     aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair [] k);\n     \\<And>k'a.\n        \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set [];\n         lt k'a k\\<rbrakk>\n        \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                           (lookup_pair [] k'a) =\n                          Some Eq\\<rbrakk>\n    \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) [] = aux\n 2. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n         aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair xs k);\n         \\<And>k'a.\n            \\<lbrakk>k'a\n                     \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n             lt k'a k\\<rbrakk>\n            \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                               (lookup_pair xs k'a) =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) xs = aux;\n        k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((ka, v) # xs);\n        aux =\n        f k (lookup_pair ((k', v') # xs) k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'a.\n           \\<lbrakk>k'a\n                    \\<in> fst ` set ((k', v') # xs) \\<union>\n                          fst ` set ((ka, v) # xs);\n            lt k'a k\\<rbrakk>\n           \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                              (lookup_pair ((ka, v) # xs) k'a) =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) ((ka, v) # xs) = aux", "thus ?case"], ["proof (prove)\nusing this:\n  k = k' \\<or> k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lex_ord_pair f ((k', v') # xs) [] = aux", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) [] = aux\n 2. k \\<in> fst ` set xs \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) [] = aux", "assume \"k = k'\""], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) [] = aux\n 2. k \\<in> fst ` set xs \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) [] = aux", "with Nil(2)"], ["proof (chain)\npicking this:\n  aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair [] k)\n  k = k'", "have \"f k' v' 0 = aux\""], ["proof (prove)\nusing this:\n  aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair [] k)\n  k = k'\n\ngoal (1 subgoal):\n 1. f k' v' (0::'c) = aux", "by simp"], ["proof (state)\nthis:\n  f k' v' (0::'c) = aux\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) [] = aux\n 2. k \\<in> fst ` set xs \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) [] = aux", "thus ?thesis"], ["proof (prove)\nusing this:\n  f k' v' (0::'c) = aux\n\ngoal (1 subgoal):\n 1. lex_ord_pair f ((k', v') # xs) [] = aux", "by (simp add: Let_def \\<open>k = k'\\<close> assms(3))"], ["proof (state)\nthis:\n  lex_ord_pair f ((k', v') # xs) [] = aux\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) [] = aux", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) [] = aux", "assume \"k \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) [] = aux", "hence \"lt k' k\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) [] = aux", "hence \"comp k k' = Gt\""], ["proof (prove)\nusing this:\n  lt k' k\n\ngoal (1 subgoal):\n 1. comp k k' = Gt", "by (simp add: Gt_lt_conv)"], ["proof (state)\nthis:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) [] = aux", "hence eq1: \"lookup_pair ((k', v') # xs) k = lookup_pair xs k\""], ["proof (prove)\nusing this:\n  comp k k' = Gt\n\ngoal (1 subgoal):\n 1. lookup_pair ((k', v') # xs) k = lookup_pair xs k", "by simp"], ["proof (state)\nthis:\n  lookup_pair ((k', v') # xs) k = lookup_pair xs k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) [] = aux", "have \"f k' (lookup_pair ((k', v') # xs) k') (lookup_pair [] k') = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k' (lookup_pair ((k', v') # xs) k') (lookup_pair [] k') = Some Eq", "by (rule Nil(3), simp, fact)"], ["proof (state)\nthis:\n  f k' (lookup_pair ((k', v') # xs) k') (lookup_pair [] k') = Some Eq\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) [] = aux", "hence eq2: \"f k' v' 0 = Some Eq\""], ["proof (prove)\nusing this:\n  f k' (lookup_pair ((k', v') # xs) k') (lookup_pair [] k') = Some Eq\n\ngoal (1 subgoal):\n 1. f k' v' (0::'c) = Some Eq", "by simp"], ["proof (state)\nthis:\n  f k' v' (0::'c) = Some Eq\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) [] = aux", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair f ((k', v') # xs) [] = aux", "proof (simp add: Let_def eq2, rule *(5), fact oalist_inv_raw_Nil)"], ["proof (state)\ngoal (3 subgoals):\n 1. k \\<in> fst ` set xs \\<union> fst ` set []\n 2. aux = f k (lookup_pair xs k) (lookup_pair [] k)\n 3. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "from \\<open>k \\<in> fst `set xs\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set xs", "show \"k \\<in> fst ` set xs \\<union> fst ` set []\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<union> fst ` set []", "by simp"], ["proof (state)\nthis:\n  k \\<in> fst ` set xs \\<union> fst ` set []\n\ngoal (2 subgoals):\n 1. aux = f k (lookup_pair xs k) (lookup_pair [] k)\n 2. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. aux = f k (lookup_pair xs k) (lookup_pair [] k)\n 2. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "show \"aux = f k (lookup_pair xs k) (lookup_pair [] k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aux = f k (lookup_pair xs k) (lookup_pair [] k)", "by (simp only: Nil(2) eq1)"], ["proof (state)\nthis:\n  aux = f k (lookup_pair xs k) (lookup_pair [] k)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "fix k0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "assume \"lt k0 k\""], ["proof (state)\nthis:\n  lt k0 k\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "assume \"k0 \\<in> fst ` set xs \\<union> fst ` set []\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<union> fst ` set []\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "hence k0_in: \"k0 \\<in> fst ` set xs\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set []\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs", "by simp"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "hence \"lt k' k0\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k0", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "hence \"comp k0 k' = Gt\""], ["proof (prove)\nusing this:\n  lt k' k0\n\ngoal (1 subgoal):\n 1. comp k0 k' = Gt", "by (simp add: Gt_lt_conv)"], ["proof (state)\nthis:\n  comp k0 k' = Gt\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "hence \"f k0 (lookup_pair xs k0) (lookup_pair [] k0) =\n                f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair [] k0)\""], ["proof (prove)\nusing this:\n  comp k0 k' = Gt\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair [] k0) =\n    f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair [] k0)", "by simp"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair [] k0) =\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair [] k0)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "also"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair [] k0) =\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair [] k0)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair [] k0) = Some Eq", "by (rule Nil(3), simp add: k0_in, fact)"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair [] k0) = Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set [];\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair [] k') =\n                         Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k0 (lookup_pair xs k0) (lookup_pair [] k0) = Some Eq", "show \"f k0 (lookup_pair xs k0) (lookup_pair [] k0) = Some Eq\""], ["proof (prove)\nusing this:\n  f k0 (lookup_pair xs k0) (lookup_pair [] k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair [] k0) = Some Eq", "."], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair [] k0) = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f ((k', v') # xs) [] = aux\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f ((k', v') # xs) [] = aux\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n         aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair xs k);\n         \\<And>k'a.\n            \\<lbrakk>k'a\n                     \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n             lt k'a k\\<rbrakk>\n            \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                               (lookup_pair xs k'a) =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) xs = aux;\n        k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((ka, v) # xs);\n        aux =\n        f k (lookup_pair ((k', v') # xs) k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'a.\n           \\<lbrakk>k'a\n                    \\<in> fst ` set ((k', v') # xs) \\<union>\n                          fst ` set ((ka, v) # xs);\n            lt k'a k\\<rbrakk>\n           \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                              (lookup_pair ((ka, v) # xs) k'a) =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) ((ka, v) # xs) = aux", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n         aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair xs k);\n         \\<And>k'a.\n            \\<lbrakk>k'a\n                     \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n             lt k'a k\\<rbrakk>\n            \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                               (lookup_pair xs k'a) =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) xs = aux;\n        k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((ka, v) # xs);\n        aux =\n        f k (lookup_pair ((k', v') # xs) k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'a.\n           \\<lbrakk>k'a\n                    \\<in> fst ` set ((k', v') # xs) \\<union>\n                          fst ` set ((ka, v) # xs);\n            lt k'a k\\<rbrakk>\n           \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                              (lookup_pair ((ka, v) # xs) k'a) =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) ((ka, v) # xs) = aux", "case (Cons k'' v'' ys)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k'', v'') # ys)\n  oalist_inv_raw ys\n  v'' \\<noteq> (0::'c)\n  ?k'35 \\<in> fst ` set ys \\<Longrightarrow> lt k'' ?k'35\n  \\<lbrakk>k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n   aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair ys k);\n   \\<And>k'a.\n      \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n       lt k'a k\\<rbrakk>\n      \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                         (lookup_pair ys k'a) =\n                        Some Eq\\<rbrakk>\n  \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) ys = aux\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  aux =\n  f k (lookup_pair ((k', v') # xs) k) (lookup_pair ((k'', v'') # ys) k)\n  \\<lbrakk>?k'35\n           \\<in> fst ` set ((k', v') # xs) \\<union>\n                 fst ` set ((k'', v'') # ys);\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair ((k', v') # xs) ?k'35)\n                     (lookup_pair ((k'', v'') # ys) ?k'35) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n         aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair xs k);\n         \\<And>k'a.\n            \\<lbrakk>k'a\n                     \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n             lt k'a k\\<rbrakk>\n            \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                               (lookup_pair xs k'a) =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) xs = aux;\n        k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((ka, v) # xs);\n        aux =\n        f k (lookup_pair ((k', v') # xs) k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'a.\n           \\<lbrakk>k'a\n                    \\<in> fst ` set ((k', v') # xs) \\<union>\n                          fst ` set ((ka, v) # xs);\n            lt k'a k\\<rbrakk>\n           \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                              (lookup_pair ((ka, v) # xs) k'a) =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) ((ka, v) # xs) = aux", "have 0: thesis if 1: \"lt k k'\" and 2: \"lt k k''\" for thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. thesis", "from 1"], ["proof (chain)\npicking this:\n  lt k k'", "have \"k \\<noteq> k'\""], ["proof (prove)\nusing this:\n  lt k k'\n\ngoal (1 subgoal):\n 1. k \\<noteq> k'", "by simp"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. thesis", "moreover"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. thesis", "from 2"], ["proof (chain)\npicking this:\n  lt k k''", "have \"k \\<noteq> k''\""], ["proof (prove)\nusing this:\n  lt k k''\n\ngoal (1 subgoal):\n 1. k \\<noteq> k''", "by simp"], ["proof (state)\nthis:\n  k \\<noteq> k''\n\ngoal (1 subgoal):\n 1. thesis", "ultimately"], ["proof (chain)\npicking this:\n  k \\<noteq> k'\n  k \\<noteq> k''", "have \"k \\<in> fst ` set xs \\<or> k \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  k \\<noteq> k'\n  k \\<noteq> k''\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<or> k \\<in> fst ` set ys", "using Cons(6)"], ["proof (prove)\nusing this:\n  k \\<noteq> k'\n  k \\<noteq> k''\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<or> k \\<in> fst ` set ys", "by simp"], ["proof (state)\nthis:\n  k \\<in> fst ` set xs \\<or> k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs \\<or> k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> thesis\n 2. k \\<in> fst ` set ys \\<Longrightarrow> thesis", "assume \"k \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k \\<in> fst ` set xs\n\ngoal (2 subgoals):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> thesis\n 2. k \\<in> fst ` set ys \\<Longrightarrow> thesis", "hence \"lt k' k\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k' k\n\ngoal (2 subgoals):\n 1. k \\<in> fst ` set xs \\<Longrightarrow> thesis\n 2. k \\<in> fst ` set ys \\<Longrightarrow> thesis", "with 1"], ["proof (chain)\npicking this:\n  lt k k'\n  lt k' k", "show ?thesis"], ["proof (prove)\nusing this:\n  lt k k'\n  lt k' k\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow> thesis", "assume \"k \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow> thesis", "hence \"lt k'' k\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k'' k", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k'' k\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ys \\<Longrightarrow> thesis", "with 2"], ["proof (chain)\npicking this:\n  lt k k''\n  lt k'' k", "show ?thesis"], ["proof (prove)\nusing this:\n  lt k k''\n  lt k'' k\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>lt k k'; lt k k''\\<rbrakk> \\<Longrightarrow> ?thesis35\n\ngoal (1 subgoal):\n 1. \\<And>ka v xs.\n       \\<lbrakk>oalist_inv_raw ((ka, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'c);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ka k';\n        \\<lbrakk>k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n         aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair xs k);\n         \\<And>k'a.\n            \\<lbrakk>k'a\n                     \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set xs;\n             lt k'a k\\<rbrakk>\n            \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                               (lookup_pair xs k'a) =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) xs = aux;\n        k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((ka, v) # xs);\n        aux =\n        f k (lookup_pair ((k', v') # xs) k) (lookup_pair ((ka, v) # xs) k);\n        \\<And>k'a.\n           \\<lbrakk>k'a\n                    \\<in> fst ` set ((k', v') # xs) \\<union>\n                          fst ` set ((ka, v) # xs);\n            lt k'a k\\<rbrakk>\n           \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                              (lookup_pair ((ka, v) # xs) k'a) =\n                             Some Eq\\<rbrakk>\n       \\<Longrightarrow> lex_ord_pair f ((k', v') # xs) ((ka, v) # xs) = aux", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair f ((k', v') # xs) ((k'', v'') # ys) = aux", "proof (simp split: order.split, intro conjI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. comp k' k'' = Eq \\<Longrightarrow>\n    (let aux = f k' v' v''\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    aux\n 2. comp k' k'' = Lt \\<Longrightarrow>\n    (let aux = f k' v' (0::'c)\n     in if aux = Some Eq then lex_ord_pair f xs ((k'', v'') # ys)\n        else aux) =\n    aux\n 3. comp k' k'' = Gt \\<Longrightarrow>\n    (let aux = f k'' (0::'b) v''\n     in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n    aux", "assume Lt: \"comp k' k'' = Lt\""], ["proof (state)\nthis:\n  comp k' k'' = Lt\n\ngoal (3 subgoals):\n 1. comp k' k'' = Eq \\<Longrightarrow>\n    (let aux = f k' v' v''\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    aux\n 2. comp k' k'' = Lt \\<Longrightarrow>\n    (let aux = f k' v' (0::'c)\n     in if aux = Some Eq then lex_ord_pair f xs ((k'', v'') # ys)\n        else aux) =\n    aux\n 3. comp k' k'' = Gt \\<Longrightarrow>\n    (let aux = f k'' (0::'b) v''\n     in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n    aux", "show \"(let aux = f k' v' 0 in if aux = Some Eq then lex_ord_pair f xs ((k'', v'') # ys) else aux) = aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let aux = f k' v' (0::'c)\n     in if aux = Some Eq then lex_ord_pair f xs ((k'', v'') # ys)\n        else aux) =\n    aux", "proof (simp add: Let_def split: order.split, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f k' v' (0::'c) = Some Eq \\<Longrightarrow>\n    lex_ord_pair f xs ((k'', v'') # ys) = aux\n 2. f k' v' (0::'c) \\<noteq> Some Eq \\<Longrightarrow> f k' v' (0::'c) = aux", "assume \"f k' v' 0 = Some Eq\""], ["proof (state)\nthis:\n  f k' v' (0::'c) = Some Eq\n\ngoal (2 subgoals):\n 1. f k' v' (0::'c) = Some Eq \\<Longrightarrow>\n    lex_ord_pair f xs ((k'', v'') # ys) = aux\n 2. f k' v' (0::'c) \\<noteq> Some Eq \\<Longrightarrow> f k' v' (0::'c) = aux", "have \"k \\<noteq> k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> k'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k = k' \\<Longrightarrow> False", "assume \"k = k'\""], ["proof (state)\nthis:\n  k = k'\n\ngoal (1 subgoal):\n 1. k = k' \\<Longrightarrow> False", "have \"aux = f k v' 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aux = f k v' (0::'c)", "by (simp add: Cons(7) \\<open>k = k'\\<close> Lt)"], ["proof (state)\nthis:\n  aux = f k v' (0::'c)\n\ngoal (1 subgoal):\n 1. k = k' \\<Longrightarrow> False", "with \\<open>f k' v' 0 = Some Eq\\<close> assms(3)"], ["proof (chain)\npicking this:\n  f k' v' (0::'c) = Some Eq\n  aux \\<noteq> Some Eq\n  aux = f k v' (0::'c)", "show False"], ["proof (prove)\nusing this:\n  f k' v' (0::'c) = Some Eq\n  aux \\<noteq> Some Eq\n  aux = f k v' (0::'c)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>k = k'\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (2 subgoals):\n 1. f k' v' (0::'c) = Some Eq \\<Longrightarrow>\n    lex_ord_pair f xs ((k'', v'') # ys) = aux\n 2. f k' v' (0::'c) \\<noteq> Some Eq \\<Longrightarrow> f k' v' (0::'c) = aux", "from Cons(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k'', v'') # ys)", "show \"lex_ord_pair f xs ((k'', v'') # ys) = aux\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. lex_ord_pair f xs ((k'', v'') # ys) = aux", "proof (rule *(5))"], ["proof (state)\ngoal (3 subgoals):\n 1. k \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\n 2. aux = f k (lookup_pair xs k) (lookup_pair ((k'', v'') # ys) k)\n 3. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "from Cons(6) \\<open>k \\<noteq> k'\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  k \\<noteq> k'", "show \"k \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)", "by simp"], ["proof (state)\nthis:\n  k \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (2 subgoals):\n 1. aux = f k (lookup_pair xs k) (lookup_pair ((k'', v'') # ys) k)\n 2. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. aux = f k (lookup_pair xs k) (lookup_pair ((k'', v'') # ys) k)\n 2. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "show \"aux = f k (lookup_pair xs k) (lookup_pair ((k'', v'') # ys) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aux = f k (lookup_pair xs k) (lookup_pair ((k'', v'') # ys) k)", "by (simp add: Cons(7) lookup_pair_Cons[OF *(1)] \\<open>k \\<noteq> k'\\<close>[symmetric] del: lookup_pair.simps)"], ["proof (state)\nthis:\n  aux = f k (lookup_pair xs k) (lookup_pair ((k'', v'') # ys) k)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "fix k0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "assume \"lt k0 k\""], ["proof (state)\nthis:\n  lt k0 k\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "assume k0_in: \"k0 \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "also"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "have \"... \\<subseteq> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\n    \\<subseteq> fst ` set ((k', v') # xs) \\<union>\n                fst ` set ((k'', v'') # ys)", "by fastforce"], ["proof (state)\nthis:\n  fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\n  \\<subseteq> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "finally"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)", "have k0_in': \"k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)", "."], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "have \"k' \\<noteq> k0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<noteq> k0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k' = k0 \\<Longrightarrow> False", "assume \"k' = k0\""], ["proof (state)\nthis:\n  k' = k0\n\ngoal (1 subgoal):\n 1. k' = k0 \\<Longrightarrow> False", "with k0_in"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\n  k' = k0", "have \"k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\n  k' = k0\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)", "by simp"], ["proof (state)\nthis:\n  k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. k' = k0 \\<Longrightarrow> False", "with Lt"], ["proof (chain)\npicking this:\n  comp k' k'' = Lt\n  k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)", "have \"k' \\<in> fst ` set xs \\<or> k' \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  comp k' k'' = Lt\n  k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs \\<or> k' \\<in> fst ` set ys", "by auto"], ["proof (state)\nthis:\n  k' \\<in> fst ` set xs \\<or> k' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k' = k0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set xs \\<or> k' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k' \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k' \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set xs\n\ngoal (2 subgoals):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k' \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k' k'\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k'", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k' k'\n\ngoal (2 subgoals):\n 1. k' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k' \\<in> fst ` set ys \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k' k'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set ys \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k' \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k'' k'\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k'' k'", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k'' k'\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set ys \\<Longrightarrow> False", "with Lt"], ["proof (chain)\npicking this:\n  comp k' k'' = Lt\n  lt k'' k'", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k' k'' = Lt\n  lt k'' k'\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k' \\<noteq> k0\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "hence \"f k0 (lookup_pair xs k0) (lookup_pair ((k'', v'') # ys) k0) =\n                  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)\""], ["proof (prove)\nusing this:\n  k' \\<noteq> k0\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair ((k'', v'') # ys) k0) =\n    f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)", "by (simp add: lookup_pair_Cons[OF *(1)] del: lookup_pair.simps)"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ((k'', v'') # ys) k0) =\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "also"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ((k'', v'') # ys) k0) =\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "from k0_in' \\<open>lt k0 k\\<close>"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k0 k", "have \"... = Some Eq\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k0 k\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k', v') # xs) k0)\n     (lookup_pair ((k'', v'') # ys) k0) =\n    Some Eq", "by (rule Cons(8))"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0) =\n  Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ((k'', v'') # ys);\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k')\n                          (lookup_pair ((k'', v'') # ys) k') =\n                         Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k0 (lookup_pair xs k0) (lookup_pair ((k'', v'') # ys) k0) = Some Eq", "show \"f k0 (lookup_pair xs k0) (lookup_pair ((k'', v'') # ys) k0) = Some Eq\""], ["proof (prove)\nusing this:\n  f k0 (lookup_pair xs k0) (lookup_pair ((k'', v'') # ys) k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair ((k'', v'') # ys) k0) = Some Eq", "."], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ((k'', v'') # ys) k0) = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f xs ((k'', v'') # ys) = aux\n\ngoal (1 subgoal):\n 1. f k' v' (0::'c) \\<noteq> Some Eq \\<Longrightarrow> f k' v' (0::'c) = aux", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f k' v' (0::'c) \\<noteq> Some Eq \\<Longrightarrow> f k' v' (0::'c) = aux", "assume \"f k' v' 0 \\<noteq> Some Eq\""], ["proof (state)\nthis:\n  f k' v' (0::'c) \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. f k' v' (0::'c) \\<noteq> Some Eq \\<Longrightarrow> f k' v' (0::'c) = aux", "have \"\\<not> lt k' k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt k' k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lt k' k \\<Longrightarrow> False", "have \"k' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)", "by simp"], ["proof (state)\nthis:\n  k' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. lt k' k \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  k' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. lt k' k \\<Longrightarrow> False", "assume \"lt k' k\""], ["proof (state)\nthis:\n  lt k' k\n\ngoal (1 subgoal):\n 1. lt k' k \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  k' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k' k", "have \"f k' (lookup_pair ((k', v') # xs) k') (lookup_pair ((k'', v'') # ys) k') = Some Eq\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k' k\n\ngoal (1 subgoal):\n 1. f k' (lookup_pair ((k', v') # xs) k')\n     (lookup_pair ((k'', v'') # ys) k') =\n    Some Eq", "by (rule Cons(8))"], ["proof (state)\nthis:\n  f k' (lookup_pair ((k', v') # xs) k') (lookup_pair ((k'', v'') # ys) k') =\n  Some Eq\n\ngoal (1 subgoal):\n 1. lt k' k \\<Longrightarrow> False", "hence \"f k' v' 0 = Some Eq\""], ["proof (prove)\nusing this:\n  f k' (lookup_pair ((k', v') # xs) k') (lookup_pair ((k'', v'') # ys) k') =\n  Some Eq\n\ngoal (1 subgoal):\n 1. f k' v' (0::'c) = Some Eq", "by (simp add: Lt)"], ["proof (state)\nthis:\n  f k' v' (0::'c) = Some Eq\n\ngoal (1 subgoal):\n 1. lt k' k \\<Longrightarrow> False", "with \\<open>f k' v' 0 \\<noteq> Some Eq\\<close>"], ["proof (chain)\npicking this:\n  f k' v' (0::'c) \\<noteq> Some Eq\n  f k' v' (0::'c) = Some Eq", "show False"], ["proof (prove)\nusing this:\n  f k' v' (0::'c) \\<noteq> Some Eq\n  f k' v' (0::'c) = Some Eq\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lt k' k\n\ngoal (1 subgoal):\n 1. f k' v' (0::'c) \\<noteq> Some Eq \\<Longrightarrow> f k' v' (0::'c) = aux", "moreover"], ["proof (state)\nthis:\n  \\<not> lt k' k\n\ngoal (1 subgoal):\n 1. f k' v' (0::'c) \\<noteq> Some Eq \\<Longrightarrow> f k' v' (0::'c) = aux", "have \"\\<not> lt k k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt k k'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lt k k' \\<Longrightarrow> False", "assume \"lt k k'\""], ["proof (state)\nthis:\n  lt k k'\n\ngoal (1 subgoal):\n 1. lt k k' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  lt k k'\n\ngoal (1 subgoal):\n 1. lt k k' \\<Longrightarrow> False", "from this Lt"], ["proof (chain)\npicking this:\n  lt k k'\n  comp k' k'' = Lt", "have \"lt k k''\""], ["proof (prove)\nusing this:\n  lt k k'\n  comp k' k'' = Lt\n\ngoal (1 subgoal):\n 1. lt k k''", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  lt k k''\n\ngoal (1 subgoal):\n 1. lt k k' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  lt k k'\n  lt k k''", "show False"], ["proof (prove)\nusing this:\n  lt k k'\n  lt k k''\n\ngoal (1 subgoal):\n 1. False", "by (rule 0)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lt k k'\n\ngoal (1 subgoal):\n 1. f k' v' (0::'c) \\<noteq> Some Eq \\<Longrightarrow> f k' v' (0::'c) = aux", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> lt k' k\n  \\<not> lt k k'", "have \"k = k'\""], ["proof (prove)\nusing this:\n  \\<not> lt k' k\n  \\<not> lt k k'\n\ngoal (1 subgoal):\n 1. k = k'", "by simp"], ["proof (state)\nthis:\n  k = k'\n\ngoal (1 subgoal):\n 1. f k' v' (0::'c) \\<noteq> Some Eq \\<Longrightarrow> f k' v' (0::'c) = aux", "show \"f k' v' 0 = aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k' v' (0::'c) = aux", "by (simp add: Cons(7) \\<open>k = k'\\<close> Lt)"], ["proof (state)\nthis:\n  f k' v' (0::'c) = aux\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (let aux = f k' v' (0::'c)\n   in if aux = Some Eq then lex_ord_pair f xs ((k'', v'') # ys) else aux) =\n  aux\n\ngoal (2 subgoals):\n 1. comp k' k'' = Eq \\<Longrightarrow>\n    (let aux = f k' v' v''\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    aux\n 2. comp k' k'' = Gt \\<Longrightarrow>\n    (let aux = f k'' (0::'b) v''\n     in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n    aux", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comp k' k'' = Eq \\<Longrightarrow>\n    (let aux = f k' v' v''\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    aux\n 2. comp k' k'' = Gt \\<Longrightarrow>\n    (let aux = f k'' (0::'b) v''\n     in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n    aux", "assume \"comp k' k'' = Eq\""], ["proof (state)\nthis:\n  comp k' k'' = Eq\n\ngoal (2 subgoals):\n 1. comp k' k'' = Eq \\<Longrightarrow>\n    (let aux = f k' v' v''\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    aux\n 2. comp k' k'' = Gt \\<Longrightarrow>\n    (let aux = f k'' (0::'b) v''\n     in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n    aux", "hence \"k' = k''\""], ["proof (prove)\nusing this:\n  comp k' k'' = Eq\n\ngoal (1 subgoal):\n 1. k' = k''", "by (simp only: eq)"], ["proof (state)\nthis:\n  k' = k''\n\ngoal (2 subgoals):\n 1. comp k' k'' = Eq \\<Longrightarrow>\n    (let aux = f k' v' v''\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    aux\n 2. comp k' k'' = Gt \\<Longrightarrow>\n    (let aux = f k'' (0::'b) v''\n     in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n    aux", "show \"(let aux = f k' v' v'' in if aux = Some Eq then lex_ord_pair f xs ys else aux) = aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let aux = f k' v' v''\n     in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n    aux", "proof (simp add: Let_def \\<open>k' = k''\\<close> split: order.split, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f k'' v' v'' = Some Eq \\<Longrightarrow> lex_ord_pair f xs ys = aux\n 2. f k'' v' v'' \\<noteq> Some Eq \\<Longrightarrow> f k'' v' v'' = aux", "assume \"f k'' v' v'' = Some Eq\""], ["proof (state)\nthis:\n  f k'' v' v'' = Some Eq\n\ngoal (2 subgoals):\n 1. f k'' v' v'' = Some Eq \\<Longrightarrow> lex_ord_pair f xs ys = aux\n 2. f k'' v' v'' \\<noteq> Some Eq \\<Longrightarrow> f k'' v' v'' = aux", "have \"k \\<noteq> k''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> k''", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k = k'' \\<Longrightarrow> False", "assume \"k = k''\""], ["proof (state)\nthis:\n  k = k''\n\ngoal (1 subgoal):\n 1. k = k'' \\<Longrightarrow> False", "have \"aux = f k v' v''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aux = f k v' v''", "by (simp add: Cons(7) \\<open>k = k''\\<close> \\<open>k' = k''\\<close>)"], ["proof (state)\nthis:\n  aux = f k v' v''\n\ngoal (1 subgoal):\n 1. k = k'' \\<Longrightarrow> False", "with \\<open>f k'' v' v'' = Some Eq\\<close> assms(3)"], ["proof (chain)\npicking this:\n  f k'' v' v'' = Some Eq\n  aux \\<noteq> Some Eq\n  aux = f k v' v''", "show False"], ["proof (prove)\nusing this:\n  f k'' v' v'' = Some Eq\n  aux \\<noteq> Some Eq\n  aux = f k v' v''\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>k = k''\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<noteq> k''\n\ngoal (2 subgoals):\n 1. f k'' v' v'' = Some Eq \\<Longrightarrow> lex_ord_pair f xs ys = aux\n 2. f k'' v' v'' \\<noteq> Some Eq \\<Longrightarrow> f k'' v' v'' = aux", "from Cons(2)"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys", "show \"lex_ord_pair f xs ys = aux\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. lex_ord_pair f xs ys = aux", "proof (rule *(5))"], ["proof (state)\ngoal (3 subgoals):\n 1. k \\<in> fst ` set xs \\<union> fst ` set ys\n 2. aux = f k (lookup_pair xs k) (lookup_pair ys k)\n 3. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "from Cons(6) \\<open>k \\<noteq> k''\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  k \\<noteq> k''", "show \"k \\<in> fst ` set xs \\<union> fst ` set ys\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  k \\<noteq> k''\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<union> fst ` set ys", "by (simp add: \\<open>k' = k''\\<close>)"], ["proof (state)\nthis:\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (2 subgoals):\n 1. aux = f k (lookup_pair xs k) (lookup_pair ys k)\n 2. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. aux = f k (lookup_pair xs k) (lookup_pair ys k)\n 2. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "show \"aux = f k (lookup_pair xs k) (lookup_pair ys k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aux = f k (lookup_pair xs k) (lookup_pair ys k)", "by (simp add: Cons(7) lookup_pair_Cons[OF *(1)] lookup_pair_Cons[OF Cons(1)] del: lookup_pair.simps,\n                simp add: \\<open>k' = k''\\<close> \\<open>k \\<noteq> k''\\<close>[symmetric])"], ["proof (state)\nthis:\n  aux = f k (lookup_pair xs k) (lookup_pair ys k)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "fix k0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "assume \"lt k0 k\""], ["proof (state)\nthis:\n  lt k0 k\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "assume k0_in: \"k0 \\<in> fst ` set xs \\<union> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "also"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "have \"... \\<subseteq> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set xs \\<union> fst ` set ys\n    \\<subseteq> fst ` set ((k', v') # xs) \\<union>\n                fst ` set ((k'', v'') # ys)", "by fastforce"], ["proof (state)\nthis:\n  fst ` set xs \\<union> fst ` set ys\n  \\<subseteq> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "finally"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)", "have k0_in': \"k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)", "."], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "have \"k'' \\<noteq> k0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k'' \\<noteq> k0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k'' = k0 \\<Longrightarrow> False", "assume \"k'' = k0\""], ["proof (state)\nthis:\n  k'' = k0\n\ngoal (1 subgoal):\n 1. k'' = k0 \\<Longrightarrow> False", "with k0_in"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n  k'' = k0", "have \"k'' \\<in> fst ` set xs \\<union> fst ` set ys\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n  k'' = k0\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set xs \\<union> fst ` set ys", "by simp"], ["proof (state)\nthis:\n  k'' \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. k'' = k0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  k'' \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k'' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k'' \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k'' \\<in> fst ` set xs\n\ngoal (2 subgoals):\n 1. k'' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k' k''\""], ["proof (prove)\nusing this:\n  k'' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k''", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k' k''\n\ngoal (2 subgoals):\n 1. k'' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k' k''\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>k' = k''\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k'' \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k'' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k'' k''\""], ["proof (prove)\nusing this:\n  k'' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k'' k''", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k'' k''\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k'' k''\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k'' \\<noteq> k0\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "hence \"f k0 (lookup_pair xs k0) (lookup_pair ys k0) =\n                  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)\""], ["proof (prove)\nusing this:\n  k'' \\<noteq> k0\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair ys k0) =\n    f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)", "by (simp add: lookup_pair_Cons[OF *(1)] lookup_pair_Cons[OF Cons(1)] del: lookup_pair.simps,\n                simp add: \\<open>k' = k''\\<close>)"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "also"], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "from k0_in' \\<open>lt k0 k\\<close>"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k0 k", "have \"... = Some Eq\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k0 k\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k', v') # xs) k0)\n     (lookup_pair ((k'', v'') # ys) k0) =\n    Some Eq", "by (rule Cons(8))"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0) =\n  Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) = Some Eq", "show \"f k0 (lookup_pair xs k0) (lookup_pair ys k0) = Some Eq\""], ["proof (prove)\nusing this:\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair xs k0) (lookup_pair ys k0) = Some Eq", "."], ["proof (state)\nthis:\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f xs ys = aux\n\ngoal (1 subgoal):\n 1. f k'' v' v'' \\<noteq> Some Eq \\<Longrightarrow> f k'' v' v'' = aux", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f k'' v' v'' \\<noteq> Some Eq \\<Longrightarrow> f k'' v' v'' = aux", "assume \"f k'' v' v'' \\<noteq> Some Eq\""], ["proof (state)\nthis:\n  f k'' v' v'' \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. f k'' v' v'' \\<noteq> Some Eq \\<Longrightarrow> f k'' v' v'' = aux", "have \"\\<not> lt k'' k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt k'' k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "have \"k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)", "by simp"], ["proof (state)\nthis:\n  k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "assume \"lt k'' k\""], ["proof (state)\nthis:\n  lt k'' k\n\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k'' k", "have \"f k'' (lookup_pair ((k', v') # xs) k'') (lookup_pair ((k'', v'') # ys) k'') = Some Eq\""], ["proof (prove)\nusing this:\n  k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k'' k\n\ngoal (1 subgoal):\n 1. f k'' (lookup_pair ((k', v') # xs) k'')\n     (lookup_pair ((k'', v'') # ys) k'') =\n    Some Eq", "by (rule Cons(8))"], ["proof (state)\nthis:\n  f k'' (lookup_pair ((k', v') # xs) k'')\n   (lookup_pair ((k'', v'') # ys) k'') =\n  Some Eq\n\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "hence \"f k'' v' v'' = Some Eq\""], ["proof (prove)\nusing this:\n  f k'' (lookup_pair ((k', v') # xs) k'')\n   (lookup_pair ((k'', v'') # ys) k'') =\n  Some Eq\n\ngoal (1 subgoal):\n 1. f k'' v' v'' = Some Eq", "by (simp add: \\<open>k' = k''\\<close>)"], ["proof (state)\nthis:\n  f k'' v' v'' = Some Eq\n\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "with \\<open>f k'' v' v'' \\<noteq> Some Eq\\<close>"], ["proof (chain)\npicking this:\n  f k'' v' v'' \\<noteq> Some Eq\n  f k'' v' v'' = Some Eq", "show False"], ["proof (prove)\nusing this:\n  f k'' v' v'' \\<noteq> Some Eq\n  f k'' v' v'' = Some Eq\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lt k'' k\n\ngoal (1 subgoal):\n 1. f k'' v' v'' \\<noteq> Some Eq \\<Longrightarrow> f k'' v' v'' = aux", "moreover"], ["proof (state)\nthis:\n  \\<not> lt k'' k\n\ngoal (1 subgoal):\n 1. f k'' v' v'' \\<noteq> Some Eq \\<Longrightarrow> f k'' v' v'' = aux", "have \"\\<not> lt k k''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt k k''", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lt k k'' \\<Longrightarrow> False", "assume \"lt k k''\""], ["proof (state)\nthis:\n  lt k k''\n\ngoal (1 subgoal):\n 1. lt k k'' \\<Longrightarrow> False", "hence \"lt k k'\""], ["proof (prove)\nusing this:\n  lt k k''\n\ngoal (1 subgoal):\n 1. lt k k'", "by (simp only: \\<open>k' = k''\\<close>)"], ["proof (state)\nthis:\n  lt k k'\n\ngoal (1 subgoal):\n 1. lt k k'' \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lt k k'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>lt k k''\\<close>"], ["proof (prove)\nusing this:\n  lt k k'\n  lt k k''\n\ngoal (1 subgoal):\n 1. False", "by (rule 0)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lt k k''\n\ngoal (1 subgoal):\n 1. f k'' v' v'' \\<noteq> Some Eq \\<Longrightarrow> f k'' v' v'' = aux", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> lt k'' k\n  \\<not> lt k k''", "have \"k = k''\""], ["proof (prove)\nusing this:\n  \\<not> lt k'' k\n  \\<not> lt k k''\n\ngoal (1 subgoal):\n 1. k = k''", "by simp"], ["proof (state)\nthis:\n  k = k''\n\ngoal (1 subgoal):\n 1. f k'' v' v'' \\<noteq> Some Eq \\<Longrightarrow> f k'' v' v'' = aux", "show \"f k'' v' v'' = aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k'' v' v'' = aux", "by (simp add: Cons(7) \\<open>k = k''\\<close> \\<open>k' = k''\\<close>)"], ["proof (state)\nthis:\n  f k'' v' v'' = aux\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (let aux = f k' v' v''\n   in if aux = Some Eq then lex_ord_pair f xs ys else aux) =\n  aux\n\ngoal (1 subgoal):\n 1. comp k' k'' = Gt \\<Longrightarrow>\n    (let aux = f k'' (0::'b) v''\n     in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n    aux", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp k' k'' = Gt \\<Longrightarrow>\n    (let aux = f k'' (0::'b) v''\n     in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n    aux", "assume Gt: \"comp k' k'' = Gt\""], ["proof (state)\nthis:\n  comp k' k'' = Gt\n\ngoal (1 subgoal):\n 1. comp k' k'' = Gt \\<Longrightarrow>\n    (let aux = f k'' (0::'b) v''\n     in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n    aux", "hence Lt: \"comp k'' k' = Lt\""], ["proof (prove)\nusing this:\n  comp k' k'' = Gt\n\ngoal (1 subgoal):\n 1. comp k'' k' = Lt", "by (simp only: Gt_lt_conv Lt_lt_conv)"], ["proof (state)\nthis:\n  comp k'' k' = Lt\n\ngoal (1 subgoal):\n 1. comp k' k'' = Gt \\<Longrightarrow>\n    (let aux = f k'' (0::'b) v''\n     in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n    aux", "show \"(let aux = f k'' 0 v'' in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) = aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let aux = f k'' (0::'b) v''\n     in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n    aux", "proof (simp add: Let_def split: order.split, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f k'' (0::'b) v'' = Some Eq \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) ys = aux\n 2. f k'' (0::'b) v'' \\<noteq> Some Eq \\<Longrightarrow>\n    f k'' (0::'b) v'' = aux", "assume \"f k'' 0 v'' = Some Eq\""], ["proof (state)\nthis:\n  f k'' (0::'b) v'' = Some Eq\n\ngoal (2 subgoals):\n 1. f k'' (0::'b) v'' = Some Eq \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) ys = aux\n 2. f k'' (0::'b) v'' \\<noteq> Some Eq \\<Longrightarrow>\n    f k'' (0::'b) v'' = aux", "have \"k \\<noteq> k''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> k''", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k = k'' \\<Longrightarrow> False", "assume \"k = k''\""], ["proof (state)\nthis:\n  k = k''\n\ngoal (1 subgoal):\n 1. k = k'' \\<Longrightarrow> False", "have \"aux = f k 0 v''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aux = f k (0::'b) v''", "by (simp add: Cons(7) \\<open>k = k''\\<close> Lt)"], ["proof (state)\nthis:\n  aux = f k (0::'b) v''\n\ngoal (1 subgoal):\n 1. k = k'' \\<Longrightarrow> False", "with \\<open>f k'' 0 v'' = Some Eq\\<close> assms(3)"], ["proof (chain)\npicking this:\n  f k'' (0::'b) v'' = Some Eq\n  aux \\<noteq> Some Eq\n  aux = f k (0::'b) v''", "show False"], ["proof (prove)\nusing this:\n  f k'' (0::'b) v'' = Some Eq\n  aux \\<noteq> Some Eq\n  aux = f k (0::'b) v''\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>k = k''\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<noteq> k''\n\ngoal (2 subgoals):\n 1. f k'' (0::'b) v'' = Some Eq \\<Longrightarrow>\n    lex_ord_pair f ((k', v') # xs) ys = aux\n 2. f k'' (0::'b) v'' \\<noteq> Some Eq \\<Longrightarrow>\n    f k'' (0::'b) v'' = aux", "show \"lex_ord_pair f ((k', v') # xs) ys = aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair f ((k', v') # xs) ys = aux", "proof (rule Cons(5))"], ["proof (state)\ngoal (3 subgoals):\n 1. k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\n 2. aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair ys k)\n 3. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "from Cons(6) \\<open>k \\<noteq> k''\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  k \\<noteq> k''", "show \"k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  k \\<noteq> k''\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys", "by simp"], ["proof (state)\nthis:\n  k \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\n\ngoal (2 subgoals):\n 1. aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair ys k)\n 2. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair ys k)\n 2. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "show \"aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair ys k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair ys k)", "by (simp add: Cons(7) lookup_pair_Cons[OF Cons(1)] \\<open>k \\<noteq> k''\\<close>[symmetric] del: lookup_pair.simps)"], ["proof (state)\nthis:\n  aux = f k (lookup_pair ((k', v') # xs) k) (lookup_pair ys k)\n\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "fix k0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "assume \"lt k0 k\""], ["proof (state)\nthis:\n  lt k0 k\n\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "assume k0_in: \"k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\""], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "also"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "have \"... \\<subseteq> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set ((k', v') # xs) \\<union> fst ` set ys\n    \\<subseteq> fst ` set ((k', v') # xs) \\<union>\n                fst ` set ((k'', v'') # ys)", "by fastforce"], ["proof (state)\nthis:\n  fst ` set ((k', v') # xs) \\<union> fst ` set ys\n  \\<subseteq> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "finally"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)", "have k0_in': \"k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)", "."], ["proof (state)\nthis:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "have \"k'' \\<noteq> k0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k'' \\<noteq> k0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k'' = k0 \\<Longrightarrow> False", "assume \"k'' = k0\""], ["proof (state)\nthis:\n  k'' = k0\n\ngoal (1 subgoal):\n 1. k'' = k0 \\<Longrightarrow> False", "with k0_in"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\n  k'' = k0", "have \"k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\n  k'' = k0\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys", "by simp"], ["proof (state)\nthis:\n  k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. k'' = k0 \\<Longrightarrow> False", "with Lt"], ["proof (chain)\npicking this:\n  comp k'' k' = Lt\n  k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys", "have \"k'' \\<in> fst ` set xs \\<or> k'' \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  comp k'' k' = Lt\n  k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set xs \\<or> k'' \\<in> fst ` set ys", "by auto"], ["proof (state)\nthis:\n  k'' \\<in> fst ` set xs \\<or> k'' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k'' = k0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  k'' \\<in> fst ` set xs \\<or> k'' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k'' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k'' \\<in> fst ` set xs\""], ["proof (state)\nthis:\n  k'' \\<in> fst ` set xs\n\ngoal (2 subgoals):\n 1. k'' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k' k''\""], ["proof (prove)\nusing this:\n  k'' \\<in> fst ` set xs\n\ngoal (1 subgoal):\n 1. lt k' k''", "by (rule *(4))"], ["proof (state)\nthis:\n  lt k' k''\n\ngoal (2 subgoals):\n 1. k'' \\<in> fst ` set xs \\<Longrightarrow> False\n 2. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "with Lt"], ["proof (chain)\npicking this:\n  comp k'' k' = Lt\n  lt k' k''", "show ?thesis"], ["proof (prove)\nusing this:\n  comp k'' k' = Lt\n  lt k' k''\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "assume \"k'' \\<in> fst ` set ys\""], ["proof (state)\nthis:\n  k'' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "hence \"lt k'' k''\""], ["proof (prove)\nusing this:\n  k'' \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt k'' k''", "by (rule Cons(4))"], ["proof (state)\nthis:\n  lt k'' k''\n\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ys \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt k'' k''\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k'' \\<noteq> k0\n\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "hence \"f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ys k0) =\n                  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)\""], ["proof (prove)\nusing this:\n  k'' \\<noteq> k0\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ys k0) =\n    f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)", "by (simp add: lookup_pair_Cons[OF Cons(1)] del: lookup_pair.simps)"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)\n\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "also"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ys k0) =\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0)\n\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "from k0_in' \\<open>lt k0 k\\<close>"], ["proof (chain)\npicking this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k0 k", "have \"... = Some Eq\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k0 k\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k', v') # xs) k0)\n     (lookup_pair ((k'', v'') # ys) k0) =\n    Some Eq", "by (rule Cons(8))"], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ((k'', v'') # ys) k0) =\n  Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>k'a.\n       \\<lbrakk>k'a \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ys;\n        lt k'a k\\<rbrakk>\n       \\<Longrightarrow> f k'a (lookup_pair ((k', v') # xs) k'a)\n                          (lookup_pair ys k'a) =\n                         Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ys k0) = Some Eq", "show \"f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ys k0) = Some Eq\""], ["proof (prove)\nusing this:\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ys k0) = Some Eq\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ys k0) = Some Eq", "."], ["proof (state)\nthis:\n  f k0 (lookup_pair ((k', v') # xs) k0) (lookup_pair ys k0) = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f ((k', v') # xs) ys = aux\n\ngoal (1 subgoal):\n 1. f k'' (0::'b) v'' \\<noteq> Some Eq \\<Longrightarrow>\n    f k'' (0::'b) v'' = aux", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f k'' (0::'b) v'' \\<noteq> Some Eq \\<Longrightarrow>\n    f k'' (0::'b) v'' = aux", "assume \"f k'' 0 v'' \\<noteq> Some Eq\""], ["proof (state)\nthis:\n  f k'' (0::'b) v'' \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. f k'' (0::'b) v'' \\<noteq> Some Eq \\<Longrightarrow>\n    f k'' (0::'b) v'' = aux", "have \"\\<not> lt k'' k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt k'' k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "have \"k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)", "by simp"], ["proof (state)\nthis:\n  k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "assume \"lt k'' k\""], ["proof (state)\nthis:\n  lt k'' k\n\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k'' k", "have \"f k'' (lookup_pair ((k', v') # xs) k'') (lookup_pair ((k'', v'') # ys) k'') = Some Eq\""], ["proof (prove)\nusing this:\n  k'' \\<in> fst ` set ((k', v') # xs) \\<union> fst ` set ((k'', v'') # ys)\n  lt k'' k\n\ngoal (1 subgoal):\n 1. f k'' (lookup_pair ((k', v') # xs) k'')\n     (lookup_pair ((k'', v'') # ys) k'') =\n    Some Eq", "by (rule Cons(8))"], ["proof (state)\nthis:\n  f k'' (lookup_pair ((k', v') # xs) k'')\n   (lookup_pair ((k'', v'') # ys) k'') =\n  Some Eq\n\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "hence \"f k'' 0 v'' = Some Eq\""], ["proof (prove)\nusing this:\n  f k'' (lookup_pair ((k', v') # xs) k'')\n   (lookup_pair ((k'', v'') # ys) k'') =\n  Some Eq\n\ngoal (1 subgoal):\n 1. f k'' (0::'b) v'' = Some Eq", "by (simp add: Lt)"], ["proof (state)\nthis:\n  f k'' (0::'b) v'' = Some Eq\n\ngoal (1 subgoal):\n 1. lt k'' k \\<Longrightarrow> False", "with \\<open>f k'' 0 v'' \\<noteq> Some Eq\\<close>"], ["proof (chain)\npicking this:\n  f k'' (0::'b) v'' \\<noteq> Some Eq\n  f k'' (0::'b) v'' = Some Eq", "show False"], ["proof (prove)\nusing this:\n  f k'' (0::'b) v'' \\<noteq> Some Eq\n  f k'' (0::'b) v'' = Some Eq\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lt k'' k\n\ngoal (1 subgoal):\n 1. f k'' (0::'b) v'' \\<noteq> Some Eq \\<Longrightarrow>\n    f k'' (0::'b) v'' = aux", "moreover"], ["proof (state)\nthis:\n  \\<not> lt k'' k\n\ngoal (1 subgoal):\n 1. f k'' (0::'b) v'' \\<noteq> Some Eq \\<Longrightarrow>\n    f k'' (0::'b) v'' = aux", "have \"\\<not> lt k k''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt k k''", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lt k k'' \\<Longrightarrow> False", "assume \"lt k k''\""], ["proof (state)\nthis:\n  lt k k''\n\ngoal (1 subgoal):\n 1. lt k k'' \\<Longrightarrow> False", "with Lt"], ["proof (chain)\npicking this:\n  comp k'' k' = Lt\n  lt k k''", "have \"lt k k'\""], ["proof (prove)\nusing this:\n  comp k'' k' = Lt\n  lt k k''\n\ngoal (1 subgoal):\n 1. lt k k'", "by (simp add: Lt_lt_conv)"], ["proof (state)\nthis:\n  lt k k'\n\ngoal (1 subgoal):\n 1. lt k k'' \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lt k k'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>lt k k''\\<close>"], ["proof (prove)\nusing this:\n  lt k k'\n  lt k k''\n\ngoal (1 subgoal):\n 1. False", "by (rule 0)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lt k k''\n\ngoal (1 subgoal):\n 1. f k'' (0::'b) v'' \\<noteq> Some Eq \\<Longrightarrow>\n    f k'' (0::'b) v'' = aux", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> lt k'' k\n  \\<not> lt k k''", "have \"k = k''\""], ["proof (prove)\nusing this:\n  \\<not> lt k'' k\n  \\<not> lt k k''\n\ngoal (1 subgoal):\n 1. k = k''", "by simp"], ["proof (state)\nthis:\n  k = k''\n\ngoal (1 subgoal):\n 1. f k'' (0::'b) v'' \\<noteq> Some Eq \\<Longrightarrow>\n    f k'' (0::'b) v'' = aux", "show \"f k'' 0 v'' = aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k'' (0::'b) v'' = aux", "by (simp add: Cons(7) \\<open>k = k''\\<close> Lt)"], ["proof (state)\nthis:\n  f k'' (0::'b) v'' = aux\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (let aux = f k'' (0::'b) v''\n   in if aux = Some Eq then lex_ord_pair f ((k', v') # xs) ys else aux) =\n  aux\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f ((k', v') # xs) ((k'', v'') # ys) = aux\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_ord_pair f ((k', v') # xs) ys = aux\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_ord_pair_EqD:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\" and \"lex_ord_pair f xs ys = Some Eq\"\n    and \"k \\<in> fst ` set xs \\<union> fst ` set ys\"\n  shows \"f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "let ?A = \"(fst ` set xs \\<union> fst ` set ys) \\<inter> {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\""], ["proof (state)\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "define k0 where \"k0 = Min ?A\""], ["proof (state)\nthis:\n  k0 =\n  local.Min\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "have \"finite ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n      {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})", "by auto"], ["proof (state)\nthis:\n  finite\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "assume \"f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq\""], ["proof (state)\nthis:\n  f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "with assms(4)"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n  f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq", "have \"k \\<in> ?A\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n  f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. k \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n            {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}", "by simp"], ["proof (state)\nthis:\n  k \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n          {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "hence \"?A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  k \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n          {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\n\ngoal (1 subgoal):\n 1. (fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq} \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  (fst ` set xs \\<union> fst ` set ys) \\<inter>\n  {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "with \\<open>finite ?A\\<close>"], ["proof (chain)\npicking this:\n  finite\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n  (fst ` set xs \\<union> fst ` set ys) \\<inter>\n  {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq} \\<noteq>\n  {}", "have \"k0 \\<in> ?A\""], ["proof (prove)\nusing this:\n  finite\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n  (fst ` set xs \\<union> fst ` set ys) \\<inter>\n  {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. k0 \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n             {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}", "unfolding k0_def"], ["proof (prove)\nusing this:\n  finite\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n  (fst ` set xs \\<union> fst ` set ys) \\<inter>\n  {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. local.Min\n     ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n      {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n    \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n          {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}", "by (rule Min_in)"], ["proof (state)\nthis:\n  k0 \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n           {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "hence k0_in: \"k0 \\<in> fst ` set xs \\<union> fst ` set ys\"\n    and neq: \"f k0 (lookup_pair xs k0) (lookup_pair ys k0) \\<noteq> Some Eq\""], ["proof (prove)\nusing this:\n  k0 \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n           {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\n\ngoal (1 subgoal):\n 1. k0 \\<in> fst ` set xs \\<union> fst ` set ys &&&\n    f k0 (lookup_pair xs k0) (lookup_pair ys k0) \\<noteq> Some Eq", "by simp_all"], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "have \"le k0 k'\" if \"k' \\<in> ?A\" for k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. le k0 k'", "unfolding k0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. le (local.Min\n         ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n          {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}))\n     k'", "using \\<open>finite ?A\\<close> that"], ["proof (prove)\nusing this:\n  finite\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n  k' \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n           {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\n\ngoal (1 subgoal):\n 1. le (local.Min\n         ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n          {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}))\n     k'", "by (rule Min_le)"], ["proof (state)\nthis:\n  ?k'35\n  \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n        {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n            Some Eq} \\<Longrightarrow>\n  le k0 ?k'35\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "hence \"f k' (lookup_pair xs k') (lookup_pair ys k') = Some Eq\"\n    if \"k' \\<in> fst ` set xs \\<union> fst ` set ys\" and \"lt k' k0\" for k'"], ["proof (prove)\nusing this:\n  ?k'35\n  \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n        {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n            Some Eq} \\<Longrightarrow>\n  le k0 ?k'35\n\ngoal (1 subgoal):\n 1. f k' (lookup_pair xs k') (lookup_pair ys k') = Some Eq", "using that"], ["proof (prove)\nusing this:\n  ?k'35\n  \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n        {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n            Some Eq} \\<Longrightarrow>\n  le k0 ?k'35\n  k' \\<in> fst ` set xs \\<union> fst ` set ys\n  lt k' k0\n\ngoal (1 subgoal):\n 1. f k' (lookup_pair xs k') (lookup_pair ys k') = Some Eq", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?k'35 \\<in> fst ` set xs \\<union> fst ` set ys;\n   lt ?k'35 k0\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair xs ?k'35) (lookup_pair ys ?k'35) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "with assms(1, 2) neq k0_in refl"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) \\<noteq> Some Eq\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n  ?t = ?t\n  \\<lbrakk>?k'35 \\<in> fst ` set xs \\<union> fst ` set ys;\n   lt ?k'35 k0\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair xs ?k'35) (lookup_pair ys ?k'35) =\n                    Some Eq", "have \"lex_ord_pair f xs ys = f k0 (lookup_pair xs k0) (lookup_pair ys k0)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) \\<noteq> Some Eq\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n  ?t = ?t\n  \\<lbrakk>?k'35 \\<in> fst ` set xs \\<union> fst ` set ys;\n   lt ?k'35 k0\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair xs ?k'35) (lookup_pair ys ?k'35) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. lex_ord_pair f xs ys = f k0 (lookup_pair xs k0) (lookup_pair ys k0)", "by (rule lex_ord_pair_valI)"], ["proof (state)\nthis:\n  lex_ord_pair f xs ys = f k0 (lookup_pair xs k0) (lookup_pair ys k0)\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n    Some Eq \\<Longrightarrow>\n    False", "with assms(3) neq"], ["proof (chain)\npicking this:\n  lex_ord_pair f xs ys = Some Eq\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) \\<noteq> Some Eq\n  lex_ord_pair f xs ys = f k0 (lookup_pair xs k0) (lookup_pair ys k0)", "show False"], ["proof (prove)\nusing this:\n  lex_ord_pair f xs ys = Some Eq\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) \\<noteq> Some Eq\n  lex_ord_pair f xs ys = f k0 (lookup_pair xs k0) (lookup_pair ys k0)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_ord_pair_valE:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\" and \"lex_ord_pair f xs ys = aux\"\n    and \"aux \\<noteq> Some Eq\"\n  obtains k where \"k \\<in> fst ` set xs \\<union> fst ` set ys\" and \"aux = f k (lookup_pair xs k) (lookup_pair ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow> lt k' k \\<Longrightarrow>\n            f k' (lookup_pair xs k') (lookup_pair ys k') = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?A = \"(fst ` set xs \\<union> fst ` set ys) \\<inter> {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define k where \"k = Min ?A\""], ["proof (state)\nthis:\n  k =\n  local.Min\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"finite ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n      {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})", "by auto"], ["proof (state)\nthis:\n  finite\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>k \\<in> fst ` set xs \\<union> fst ` set ys. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq\" (is ?prop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>fst ` set xs \\<union> fst ` set ys.\n       f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k\\<in>fst ` set xs \\<union> fst ` set ys.\n               f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n               Some Eq) \\<Longrightarrow>\n    False", "assume \"\\<not> ?prop\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>k\\<in>fst ` set xs \\<union> fst ` set ys.\n             f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k\\<in>fst ` set xs \\<union> fst ` set ys.\n               f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n               Some Eq) \\<Longrightarrow>\n    False", "hence \"f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq\"\n      if \"k \\<in> fst ` set xs \\<union> fst ` set ys\" for k"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>k\\<in>fst ` set xs \\<union> fst ` set ys.\n             f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq)\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq", "using that"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>k\\<in>fst ` set xs \\<union> fst ` set ys.\n             f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq)\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. f k (lookup_pair xs k) (lookup_pair ys k) = Some Eq", "by auto"], ["proof (state)\nthis:\n  ?k35 \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow>\n  f ?k35 (lookup_pair xs ?k35) (lookup_pair ys ?k35) = Some Eq\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k\\<in>fst ` set xs \\<union> fst ` set ys.\n               f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n               Some Eq) \\<Longrightarrow>\n    False", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  ?k35 \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow>\n  f ?k35 (lookup_pair xs ?k35) (lookup_pair ys ?k35) = Some Eq", "have \"lex_ord_pair f xs ys = Some Eq\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  ?k35 \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow>\n  f ?k35 (lookup_pair xs ?k35) (lookup_pair ys ?k35) = Some Eq\n\ngoal (1 subgoal):\n 1. lex_ord_pair f xs ys = Some Eq", "by (rule lex_ord_pair_EqI)"], ["proof (state)\nthis:\n  lex_ord_pair f xs ys = Some Eq\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k\\<in>fst ` set xs \\<union> fst ` set ys.\n               f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n               Some Eq) \\<Longrightarrow>\n    False", "with assms(3, 4)"], ["proof (chain)\npicking this:\n  lex_ord_pair f xs ys = aux\n  aux \\<noteq> Some Eq\n  lex_ord_pair f xs ys = Some Eq", "show False"], ["proof (prove)\nusing this:\n  lex_ord_pair f xs ys = aux\n  aux \\<noteq> Some Eq\n  lex_ord_pair f xs ys = Some Eq\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k\\<in>fst ` set xs \\<union> fst ` set ys.\n     f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>k\\<in>fst ` set xs \\<union> fst ` set ys.\n     f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq", "obtain k0 where \"k0 \\<in> fst ` set xs \\<union> fst ` set ys\"\n    and \"f k0 (lookup_pair xs k0) (lookup_pair ys k0) \\<noteq> Some Eq\""], ["proof (prove)\nusing this:\n  \\<exists>k\\<in>fst ` set xs \\<union> fst ` set ys.\n     f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k0.\n        \\<lbrakk>k0 \\<in> fst ` set xs \\<union> fst ` set ys;\n         f k0 (lookup_pair xs k0) (lookup_pair ys k0) \\<noteq>\n         Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"k0 \\<in> ?A\""], ["proof (prove)\nusing this:\n  k0 \\<in> fst ` set xs \\<union> fst ` set ys\n  f k0 (lookup_pair xs k0) (lookup_pair ys k0) \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. k0 \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n             {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}", "by simp"], ["proof (state)\nthis:\n  k0 \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n           {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"?A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  k0 \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n           {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\n\ngoal (1 subgoal):\n 1. (fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq} \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  (fst ` set xs \\<union> fst ` set ys) \\<inter>\n  {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>finite ?A\\<close>"], ["proof (chain)\npicking this:\n  finite\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n  (fst ` set xs \\<union> fst ` set ys) \\<inter>\n  {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq} \\<noteq>\n  {}", "have \"k \\<in> ?A\""], ["proof (prove)\nusing this:\n  finite\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n  (fst ` set xs \\<union> fst ` set ys) \\<inter>\n  {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. k \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n            {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}", "unfolding k_def"], ["proof (prove)\nusing this:\n  finite\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n  (fst ` set xs \\<union> fst ` set ys) \\<inter>\n  {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. local.Min\n     ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n      {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n    \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n          {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}", "by (rule Min_in)"], ["proof (state)\nthis:\n  k \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n          {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence k_in: \"k \\<in> fst ` set xs \\<union> fst ` set ys\"\n    and neq: \"f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq\""], ["proof (prove)\nusing this:\n  k \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n          {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs \\<union> fst ` set ys &&&\n    f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq", "by simp_all"], ["proof (state)\nthis:\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n  f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"le k k'\" if \"k' \\<in> ?A\" for k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. le k k'", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. le (local.Min\n         ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n          {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}))\n     k'", "using \\<open>finite ?A\\<close> that"], ["proof (prove)\nusing this:\n  finite\n   ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n    {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq})\n  k' \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n           {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}\n\ngoal (1 subgoal):\n 1. le (local.Min\n         ((fst ` set xs \\<union> fst ` set ys) \\<inter>\n          {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq}))\n     k'", "by (rule Min_le)"], ["proof (state)\nthis:\n  ?k'35\n  \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n        {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n            Some Eq} \\<Longrightarrow>\n  le k ?k'35\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence *: \"\\<And>k'. k' \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow> lt k' k \\<Longrightarrow>\n            f k' (lookup_pair xs k') (lookup_pair ys k') = Some Eq\""], ["proof (prove)\nusing this:\n  ?k'35\n  \\<in> (fst ` set xs \\<union> fst ` set ys) \\<inter>\n        {k. f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq>\n            Some Eq} \\<Longrightarrow>\n  le k ?k'35\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n        lt k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                         Some Eq", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?k'35 \\<in> fst ` set xs \\<union> fst ` set ys;\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair xs ?k'35) (lookup_pair ys ?k'35) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(1, 2) neq k_in refl"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n  ?t = ?t\n  \\<lbrakk>?k'35 \\<in> fst ` set xs \\<union> fst ` set ys;\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair xs ?k'35) (lookup_pair ys ?k'35) =\n                    Some Eq", "have \"lex_ord_pair f xs ys = f k (lookup_pair xs k) (lookup_pair ys k)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  f k (lookup_pair xs k) (lookup_pair ys k) \\<noteq> Some Eq\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n  ?t = ?t\n  \\<lbrakk>?k'35 \\<in> fst ` set xs \\<union> fst ` set ys;\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair xs ?k'35) (lookup_pair ys ?k'35) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. lex_ord_pair f xs ys = f k (lookup_pair xs k) (lookup_pair ys k)", "by (rule lex_ord_pair_valI)"], ["proof (state)\nthis:\n  lex_ord_pair f xs ys = f k (lookup_pair xs k) (lookup_pair ys k)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"aux = f k (lookup_pair xs k) (lookup_pair ys k)\""], ["proof (prove)\nusing this:\n  lex_ord_pair f xs ys = f k (lookup_pair xs k) (lookup_pair ys k)\n\ngoal (1 subgoal):\n 1. aux = f k (lookup_pair xs k) (lookup_pair ys k)", "by (simp only: assms(3))"], ["proof (state)\nthis:\n  aux = f k (lookup_pair xs k) (lookup_pair ys k)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set xs \\<union> fst ` set ys;\n         aux = f k (lookup_pair xs k) (lookup_pair ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set xs \\<union> fst ` set ys;\n             lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_pair xs k') (lookup_pair ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with k_in"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n  aux = f k (lookup_pair xs k) (lookup_pair ys k)", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n  aux = f k (lookup_pair xs k) (lookup_pair ys k)\n\ngoal (1 subgoal):\n 1. thesis", "using *"], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n  aux = f k (lookup_pair xs k) (lookup_pair ys k)\n  \\<lbrakk>?k'35 \\<in> fst ` set xs \\<union> fst ` set ys;\n   lt ?k'35 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'35 (lookup_pair xs ?k'35) (lookup_pair ys ?k'35) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const prod_ord_pair}\\<close>"], ["", "lemma prod_ord_pair_eq_lex_ord_pair:\n  \"prod_ord_pair P xs ys = (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) xs ys = Some Eq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_ord_pair P xs ys =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) xs\n      ys =\n     Some Eq)", "proof (induct P xs ys rule: prod_ord_pair.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f.\n       prod_ord_pair f [] [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         [] =\n        Some Eq)\n 2. \\<And>f ky vy ys.\n       prod_ord_pair f [] ys =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         ys =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f [] ((ky, vy) # ys) =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         ((ky, vy) # ys) =\n        Some Eq)\n 3. \\<And>f kx vx xs.\n       prod_ord_pair f xs [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n         [] =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f ((kx, vx) # xs) [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n         ((kx, vx) # xs) [] =\n        Some Eq)\n 4. \\<And>f kx vx xs ky vy ys.\n       \\<lbrakk>comp kx ky = Eq \\<Longrightarrow>\n                prod_ord_pair f xs ys =\n                (lex_ord_pair\n                  (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n                  ys =\n                 Some Eq);\n        comp kx ky = Lt \\<Longrightarrow>\n        prod_ord_pair f xs ((ky, vy) # ys) =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n          ((ky, vy) # ys) =\n         Some Eq);\n        comp kx ky = Gt \\<Longrightarrow>\n        prod_ord_pair f ((kx, vx) # xs) ys =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n          ((kx, vx) # xs) ys =\n         Some Eq)\\<rbrakk>\n       \\<Longrightarrow> prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n                         (lex_ord_pair\n                           (\\<lambda>k x y.\n                               if f k x y then Some Eq else None)\n                           ((kx, vx) # xs) ((ky, vy) # ys) =\n                          Some Eq)", "case (1 P)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>f.\n       prod_ord_pair f [] [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         [] =\n        Some Eq)\n 2. \\<And>f ky vy ys.\n       prod_ord_pair f [] ys =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         ys =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f [] ((ky, vy) # ys) =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         ((ky, vy) # ys) =\n        Some Eq)\n 3. \\<And>f kx vx xs.\n       prod_ord_pair f xs [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n         [] =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f ((kx, vx) # xs) [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n         ((kx, vx) # xs) [] =\n        Some Eq)\n 4. \\<And>f kx vx xs ky vy ys.\n       \\<lbrakk>comp kx ky = Eq \\<Longrightarrow>\n                prod_ord_pair f xs ys =\n                (lex_ord_pair\n                  (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n                  ys =\n                 Some Eq);\n        comp kx ky = Lt \\<Longrightarrow>\n        prod_ord_pair f xs ((ky, vy) # ys) =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n          ((ky, vy) # ys) =\n         Some Eq);\n        comp kx ky = Gt \\<Longrightarrow>\n        prod_ord_pair f ((kx, vx) # xs) ys =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n          ((kx, vx) # xs) ys =\n         Some Eq)\\<rbrakk>\n       \\<Longrightarrow> prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n                         (lex_ord_pair\n                           (\\<lambda>k x y.\n                               if f k x y then Some Eq else None)\n                           ((kx, vx) # xs) ((ky, vy) # ys) =\n                          Some Eq)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_ord_pair P [] [] =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) []\n      [] =\n     Some Eq)", "by simp"], ["proof (state)\nthis:\n  prod_ord_pair P [] [] =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) [] [] =\n   Some Eq)\n\ngoal (3 subgoals):\n 1. \\<And>f ky vy ys.\n       prod_ord_pair f [] ys =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         ys =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f [] ((ky, vy) # ys) =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         ((ky, vy) # ys) =\n        Some Eq)\n 2. \\<And>f kx vx xs.\n       prod_ord_pair f xs [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n         [] =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f ((kx, vx) # xs) [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n         ((kx, vx) # xs) [] =\n        Some Eq)\n 3. \\<And>f kx vx xs ky vy ys.\n       \\<lbrakk>comp kx ky = Eq \\<Longrightarrow>\n                prod_ord_pair f xs ys =\n                (lex_ord_pair\n                  (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n                  ys =\n                 Some Eq);\n        comp kx ky = Lt \\<Longrightarrow>\n        prod_ord_pair f xs ((ky, vy) # ys) =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n          ((ky, vy) # ys) =\n         Some Eq);\n        comp kx ky = Gt \\<Longrightarrow>\n        prod_ord_pair f ((kx, vx) # xs) ys =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n          ((kx, vx) # xs) ys =\n         Some Eq)\\<rbrakk>\n       \\<Longrightarrow> prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n                         (lex_ord_pair\n                           (\\<lambda>k x y.\n                               if f k x y then Some Eq else None)\n                           ((kx, vx) # xs) ((ky, vy) # ys) =\n                          Some Eq)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f ky vy ys.\n       prod_ord_pair f [] ys =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         ys =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f [] ((ky, vy) # ys) =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         ((ky, vy) # ys) =\n        Some Eq)\n 2. \\<And>f kx vx xs.\n       prod_ord_pair f xs [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n         [] =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f ((kx, vx) # xs) [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n         ((kx, vx) # xs) [] =\n        Some Eq)\n 3. \\<And>f kx vx xs ky vy ys.\n       \\<lbrakk>comp kx ky = Eq \\<Longrightarrow>\n                prod_ord_pair f xs ys =\n                (lex_ord_pair\n                  (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n                  ys =\n                 Some Eq);\n        comp kx ky = Lt \\<Longrightarrow>\n        prod_ord_pair f xs ((ky, vy) # ys) =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n          ((ky, vy) # ys) =\n         Some Eq);\n        comp kx ky = Gt \\<Longrightarrow>\n        prod_ord_pair f ((kx, vx) # xs) ys =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n          ((kx, vx) # xs) ys =\n         Some Eq)\\<rbrakk>\n       \\<Longrightarrow> prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n                         (lex_ord_pair\n                           (\\<lambda>k x y.\n                               if f k x y then Some Eq else None)\n                           ((kx, vx) # xs) ((ky, vy) # ys) =\n                          Some Eq)", "case (2 P ky vy ys)"], ["proof (state)\nthis:\n  prod_ord_pair P [] ys =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) [] ys =\n   Some Eq)\n\ngoal (3 subgoals):\n 1. \\<And>f ky vy ys.\n       prod_ord_pair f [] ys =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         ys =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f [] ((ky, vy) # ys) =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) []\n         ((ky, vy) # ys) =\n        Some Eq)\n 2. \\<And>f kx vx xs.\n       prod_ord_pair f xs [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n         [] =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f ((kx, vx) # xs) [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n         ((kx, vx) # xs) [] =\n        Some Eq)\n 3. \\<And>f kx vx xs ky vy ys.\n       \\<lbrakk>comp kx ky = Eq \\<Longrightarrow>\n                prod_ord_pair f xs ys =\n                (lex_ord_pair\n                  (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n                  ys =\n                 Some Eq);\n        comp kx ky = Lt \\<Longrightarrow>\n        prod_ord_pair f xs ((ky, vy) # ys) =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n          ((ky, vy) # ys) =\n         Some Eq);\n        comp kx ky = Gt \\<Longrightarrow>\n        prod_ord_pair f ((kx, vx) # xs) ys =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n          ((kx, vx) # xs) ys =\n         Some Eq)\\<rbrakk>\n       \\<Longrightarrow> prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n                         (lex_ord_pair\n                           (\\<lambda>k x y.\n                               if f k x y then Some Eq else None)\n                           ((kx, vx) # xs) ((ky, vy) # ys) =\n                          Some Eq)", "thus ?case"], ["proof (prove)\nusing this:\n  prod_ord_pair P [] ys =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) [] ys =\n   Some Eq)\n\ngoal (1 subgoal):\n 1. prod_ord_pair P [] ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) []\n      ((ky, vy) # ys) =\n     Some Eq)", "by simp"], ["proof (state)\nthis:\n  prod_ord_pair P [] ((ky, vy) # ys) =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) []\n    ((ky, vy) # ys) =\n   Some Eq)\n\ngoal (2 subgoals):\n 1. \\<And>f kx vx xs.\n       prod_ord_pair f xs [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n         [] =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f ((kx, vx) # xs) [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n         ((kx, vx) # xs) [] =\n        Some Eq)\n 2. \\<And>f kx vx xs ky vy ys.\n       \\<lbrakk>comp kx ky = Eq \\<Longrightarrow>\n                prod_ord_pair f xs ys =\n                (lex_ord_pair\n                  (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n                  ys =\n                 Some Eq);\n        comp kx ky = Lt \\<Longrightarrow>\n        prod_ord_pair f xs ((ky, vy) # ys) =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n          ((ky, vy) # ys) =\n         Some Eq);\n        comp kx ky = Gt \\<Longrightarrow>\n        prod_ord_pair f ((kx, vx) # xs) ys =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n          ((kx, vx) # xs) ys =\n         Some Eq)\\<rbrakk>\n       \\<Longrightarrow> prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n                         (lex_ord_pair\n                           (\\<lambda>k x y.\n                               if f k x y then Some Eq else None)\n                           ((kx, vx) # xs) ((ky, vy) # ys) =\n                          Some Eq)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f kx vx xs.\n       prod_ord_pair f xs [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n         [] =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f ((kx, vx) # xs) [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n         ((kx, vx) # xs) [] =\n        Some Eq)\n 2. \\<And>f kx vx xs ky vy ys.\n       \\<lbrakk>comp kx ky = Eq \\<Longrightarrow>\n                prod_ord_pair f xs ys =\n                (lex_ord_pair\n                  (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n                  ys =\n                 Some Eq);\n        comp kx ky = Lt \\<Longrightarrow>\n        prod_ord_pair f xs ((ky, vy) # ys) =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n          ((ky, vy) # ys) =\n         Some Eq);\n        comp kx ky = Gt \\<Longrightarrow>\n        prod_ord_pair f ((kx, vx) # xs) ys =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n          ((kx, vx) # xs) ys =\n         Some Eq)\\<rbrakk>\n       \\<Longrightarrow> prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n                         (lex_ord_pair\n                           (\\<lambda>k x y.\n                               if f k x y then Some Eq else None)\n                           ((kx, vx) # xs) ((ky, vy) # ys) =\n                          Some Eq)", "case (3 P kx vx xs)"], ["proof (state)\nthis:\n  prod_ord_pair P xs [] =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) xs [] =\n   Some Eq)\n\ngoal (2 subgoals):\n 1. \\<And>f kx vx xs.\n       prod_ord_pair f xs [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n         [] =\n        Some Eq) \\<Longrightarrow>\n       prod_ord_pair f ((kx, vx) # xs) [] =\n       (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n         ((kx, vx) # xs) [] =\n        Some Eq)\n 2. \\<And>f kx vx xs ky vy ys.\n       \\<lbrakk>comp kx ky = Eq \\<Longrightarrow>\n                prod_ord_pair f xs ys =\n                (lex_ord_pair\n                  (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n                  ys =\n                 Some Eq);\n        comp kx ky = Lt \\<Longrightarrow>\n        prod_ord_pair f xs ((ky, vy) # ys) =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n          ((ky, vy) # ys) =\n         Some Eq);\n        comp kx ky = Gt \\<Longrightarrow>\n        prod_ord_pair f ((kx, vx) # xs) ys =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n          ((kx, vx) # xs) ys =\n         Some Eq)\\<rbrakk>\n       \\<Longrightarrow> prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n                         (lex_ord_pair\n                           (\\<lambda>k x y.\n                               if f k x y then Some Eq else None)\n                           ((kx, vx) # xs) ((ky, vy) # ys) =\n                          Some Eq)", "thus ?case"], ["proof (prove)\nusing this:\n  prod_ord_pair P xs [] =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) xs [] =\n   Some Eq)\n\ngoal (1 subgoal):\n 1. prod_ord_pair P ((kx, vx) # xs) [] =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) [] =\n     Some Eq)", "by simp"], ["proof (state)\nthis:\n  prod_ord_pair P ((kx, vx) # xs) [] =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n    ((kx, vx) # xs) [] =\n   Some Eq)\n\ngoal (1 subgoal):\n 1. \\<And>f kx vx xs ky vy ys.\n       \\<lbrakk>comp kx ky = Eq \\<Longrightarrow>\n                prod_ord_pair f xs ys =\n                (lex_ord_pair\n                  (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n                  ys =\n                 Some Eq);\n        comp kx ky = Lt \\<Longrightarrow>\n        prod_ord_pair f xs ((ky, vy) # ys) =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n          ((ky, vy) # ys) =\n         Some Eq);\n        comp kx ky = Gt \\<Longrightarrow>\n        prod_ord_pair f ((kx, vx) # xs) ys =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n          ((kx, vx) # xs) ys =\n         Some Eq)\\<rbrakk>\n       \\<Longrightarrow> prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n                         (lex_ord_pair\n                           (\\<lambda>k x y.\n                               if f k x y then Some Eq else None)\n                           ((kx, vx) # xs) ((ky, vy) # ys) =\n                          Some Eq)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f kx vx xs ky vy ys.\n       \\<lbrakk>comp kx ky = Eq \\<Longrightarrow>\n                prod_ord_pair f xs ys =\n                (lex_ord_pair\n                  (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n                  ys =\n                 Some Eq);\n        comp kx ky = Lt \\<Longrightarrow>\n        prod_ord_pair f xs ((ky, vy) # ys) =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n          ((ky, vy) # ys) =\n         Some Eq);\n        comp kx ky = Gt \\<Longrightarrow>\n        prod_ord_pair f ((kx, vx) # xs) ys =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n          ((kx, vx) # xs) ys =\n         Some Eq)\\<rbrakk>\n       \\<Longrightarrow> prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n                         (lex_ord_pair\n                           (\\<lambda>k x y.\n                               if f k x y then Some Eq else None)\n                           ((kx, vx) # xs) ((ky, vy) # ys) =\n                          Some Eq)", "case (4 P kx vx xs ky vy ys)"], ["proof (state)\nthis:\n  comp kx ky = Eq \\<Longrightarrow>\n  prod_ord_pair P xs ys =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) xs ys =\n   Some Eq)\n  comp kx ky = Lt \\<Longrightarrow>\n  prod_ord_pair P xs ((ky, vy) # ys) =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) xs\n    ((ky, vy) # ys) =\n   Some Eq)\n  comp kx ky = Gt \\<Longrightarrow>\n  prod_ord_pair P ((kx, vx) # xs) ys =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n    ((kx, vx) # xs) ys =\n   Some Eq)\n\ngoal (1 subgoal):\n 1. \\<And>f kx vx xs ky vy ys.\n       \\<lbrakk>comp kx ky = Eq \\<Longrightarrow>\n                prod_ord_pair f xs ys =\n                (lex_ord_pair\n                  (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n                  ys =\n                 Some Eq);\n        comp kx ky = Lt \\<Longrightarrow>\n        prod_ord_pair f xs ((ky, vy) # ys) =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None) xs\n          ((ky, vy) # ys) =\n         Some Eq);\n        comp kx ky = Gt \\<Longrightarrow>\n        prod_ord_pair f ((kx, vx) # xs) ys =\n        (lex_ord_pair (\\<lambda>k x y. if f k x y then Some Eq else None)\n          ((kx, vx) # xs) ys =\n         Some Eq)\\<rbrakk>\n       \\<Longrightarrow> prod_ord_pair f ((kx, vx) # xs) ((ky, vy) # ys) =\n                         (lex_ord_pair\n                           (\\<lambda>k x y.\n                               if f k x y then Some Eq else None)\n                           ((kx, vx) # xs) ((ky, vy) # ys) =\n                          Some Eq)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "proof (cases \"comp kx ky\")"], ["proof (state)\ngoal (3 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)\n 2. comp kx ky = Lt \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)\n 3. comp kx ky = Gt \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "case Lt"], ["proof (state)\nthis:\n  comp kx ky = Lt\n\ngoal (3 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)\n 2. comp kx ky = Lt \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)\n 3. comp kx ky = Gt \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "thus ?thesis"], ["proof (prove)\nusing this:\n  comp kx ky = Lt\n\ngoal (1 subgoal):\n 1. prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "by (simp add: 4(2)[OF Lt])"], ["proof (state)\nthis:\n  prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n    ((kx, vx) # xs) ((ky, vy) # ys) =\n   Some Eq)\n\ngoal (2 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)\n 2. comp kx ky = Gt \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)\n 2. comp kx ky = Gt \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "case Eq"], ["proof (state)\nthis:\n  comp kx ky = Eq\n\ngoal (2 subgoals):\n 1. comp kx ky = Eq \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)\n 2. comp kx ky = Gt \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "thus ?thesis"], ["proof (prove)\nusing this:\n  comp kx ky = Eq\n\ngoal (1 subgoal):\n 1. prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "by (simp add: 4(1)[OF Eq])"], ["proof (state)\nthis:\n  prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n    ((kx, vx) # xs) ((ky, vy) # ys) =\n   Some Eq)\n\ngoal (1 subgoal):\n 1. comp kx ky = Gt \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. comp kx ky = Gt \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "case Gt"], ["proof (state)\nthis:\n  comp kx ky = Gt\n\ngoal (1 subgoal):\n 1. comp kx ky = Gt \\<Longrightarrow>\n    prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "thus ?thesis"], ["proof (prove)\nusing this:\n  comp kx ky = Gt\n\ngoal (1 subgoal):\n 1. prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n    (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n      ((kx, vx) # xs) ((ky, vy) # ys) =\n     Some Eq)", "by (simp add: 4(3)[OF Gt])"], ["proof (state)\nthis:\n  prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n    ((kx, vx) # xs) ((ky, vy) # ys) =\n   Some Eq)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod_ord_pair P ((kx, vx) # xs) ((ky, vy) # ys) =\n  (lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None)\n    ((kx, vx) # xs) ((ky, vy) # ys) =\n   Some Eq)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_ord_pairI:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\"\n    and \"\\<And>k. k \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow> P k (lookup_pair xs k) (lookup_pair ys k)\"\n  shows \"prod_ord_pair P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_ord_pair P xs ys", "unfolding prod_ord_pair_eq_lex_ord_pair"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) xs ys =\n    Some Eq", "by (rule lex_ord_pair_EqI, fact, fact, simp add: assms(3))"], ["", "lemma prod_ord_pairD:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\" and \"prod_ord_pair P xs ys\"\n    and \"k \\<in> fst ` set xs \\<union> fst ` set ys\"\n  shows \"P k (lookup_pair xs k) (lookup_pair ys k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P k (lookup_pair xs k) (lookup_pair ys k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P k (lookup_pair xs k) (lookup_pair ys k)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  prod_ord_pair P xs ys\n  k \\<in> fst ` set xs \\<union> fst ` set ys", "have \"(if P k (lookup_pair xs k) (lookup_pair ys k) then Some Eq else None) = Some Eq\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  prod_ord_pair P xs ys\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. (if P k (lookup_pair xs k) (lookup_pair ys k) then Some Eq else None) =\n    Some Eq", "unfolding prod_ord_pair_eq_lex_ord_pair"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw ys\n  lex_ord_pair (\\<lambda>k x y. if P k x y then Some Eq else None) xs ys =\n  Some Eq\n  k \\<in> fst ` set xs \\<union> fst ` set ys\n\ngoal (1 subgoal):\n 1. (if P k (lookup_pair xs k) (lookup_pair ys k) then Some Eq else None) =\n    Some Eq", "by (rule lex_ord_pair_EqD)"], ["proof (state)\nthis:\n  (if P k (lookup_pair xs k) (lookup_pair ys k) then Some Eq else None) =\n  Some Eq\n\ngoal (1 subgoal):\n 1. P k (lookup_pair xs k) (lookup_pair ys k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (if P k (lookup_pair xs k) (lookup_pair ys k) then Some Eq else None) =\n  Some Eq\n\ngoal (1 subgoal):\n 1. P k (lookup_pair xs k) (lookup_pair ys k)", "by (simp split: if_splits)"], ["proof (state)\nthis:\n  P k (lookup_pair xs k) (lookup_pair ys k)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary prod_ord_pair_alt:\n  assumes \"oalist_inv_raw xs\" and \"oalist_inv_raw ys\"\n  shows \"(prod_ord_pair P xs ys) \\<longleftrightarrow> (\\<forall>k\\<in>fst ` set xs \\<union> fst ` set ys. P k (lookup_pair xs k) (lookup_pair ys k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_ord_pair P xs ys =\n    (\\<forall>k\\<in>fst ` set xs \\<union> fst ` set ys.\n        P k (lookup_pair xs k) (lookup_pair ys k))", "using prod_ord_pairI[OF assms] prod_ord_pairD[OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>k.\n      k \\<in> fst ` set xs \\<union> fst ` set ys \\<Longrightarrow>\n      ?P k (lookup_pair xs k) (lookup_pair ys k)) \\<Longrightarrow>\n  prod_ord_pair ?P xs ys\n  \\<lbrakk>prod_ord_pair ?P xs ys;\n   ?k \\<in> fst ` set xs \\<union> fst ` set ys\\<rbrakk>\n  \\<Longrightarrow> ?P ?k (lookup_pair xs ?k) (lookup_pair ys ?k)\n\ngoal (1 subgoal):\n 1. prod_ord_pair P xs ys =\n    (\\<forall>k\\<in>fst ` set xs \\<union> fst ` set ys.\n        P k (lookup_pair xs k) (lookup_pair ys k))", "by meson"], ["", "subsubsection \\<open>@{const sort_oalist}\\<close>"], ["", "lemma oalist_inv_raw_foldr_update_by_pair:\n  assumes \"oalist_inv_raw ys\"\n  shows \"oalist_inv_raw (foldr update_by_pair xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (foldr update_by_pair xs ys)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. oalist_inv_raw (foldr update_by_pair [] ys)\n 2. \\<And>a xs.\n       oalist_inv_raw (foldr update_by_pair xs ys) \\<Longrightarrow>\n       oalist_inv_raw (foldr update_by_pair (a # xs) ys)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. oalist_inv_raw (foldr update_by_pair [] ys)\n 2. \\<And>a xs.\n       oalist_inv_raw (foldr update_by_pair xs ys) \\<Longrightarrow>\n       oalist_inv_raw (foldr update_by_pair (a # xs) ys)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys", "show ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (foldr update_by_pair [] ys)", "by simp"], ["proof (state)\nthis:\n  oalist_inv_raw (foldr update_by_pair [] ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       oalist_inv_raw (foldr update_by_pair xs ys) \\<Longrightarrow>\n       oalist_inv_raw (foldr update_by_pair (a # xs) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       oalist_inv_raw (foldr update_by_pair xs ys) \\<Longrightarrow>\n       oalist_inv_raw (foldr update_by_pair (a # xs) ys)", "case (Cons x xs)"], ["proof (state)\nthis:\n  oalist_inv_raw (foldr update_by_pair xs ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       oalist_inv_raw (foldr update_by_pair xs ys) \\<Longrightarrow>\n       oalist_inv_raw (foldr update_by_pair (a # xs) ys)", "hence \"oalist_inv_raw (update_by_pair x (foldr update_by_pair xs ys))\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (foldr update_by_pair xs ys)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (update_by_pair x (foldr update_by_pair xs ys))", "by (rule oalist_inv_raw_update_by_pair)"], ["proof (state)\nthis:\n  oalist_inv_raw (update_by_pair x (foldr update_by_pair xs ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       oalist_inv_raw (foldr update_by_pair xs ys) \\<Longrightarrow>\n       oalist_inv_raw (foldr update_by_pair (a # xs) ys)", "thus ?case"], ["proof (prove)\nusing this:\n  oalist_inv_raw (update_by_pair x (foldr update_by_pair xs ys))\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (foldr update_by_pair (x # xs) ys)", "by simp"], ["proof (state)\nthis:\n  oalist_inv_raw (foldr update_by_pair (x # xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary oalist_inv_raw_sort_oalist: \"oalist_inv_raw (sort_oalist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw (sort_oalist xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. oalist_inv_raw (sort_oalist xs)", "from oalist_inv_raw_Nil"], ["proof (chain)\npicking this:\n  oalist_inv_raw []", "have \"oalist_inv_raw (foldr local.update_by_pair xs [])\""], ["proof (prove)\nusing this:\n  oalist_inv_raw []\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (foldr update_by_pair xs [])", "by (rule oalist_inv_raw_foldr_update_by_pair)"], ["proof (state)\nthis:\n  oalist_inv_raw (foldr update_by_pair xs [])\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (sort_oalist xs)", "thus \"oalist_inv_raw (sort_oalist xs)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (foldr update_by_pair xs [])\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (sort_oalist xs)", "by (simp only: sort_oalist_def)"], ["proof (state)\nthis:\n  oalist_inv_raw (sort_oalist xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sort_oalist_id:\n  assumes \"oalist_inv_raw xs\"\n  shows \"sort_oalist xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_oalist xs = xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sort_oalist xs = xs", "have \"foldr update_by_pair xs ys = xs @ ys\" if \"oalist_inv_raw (xs @ ys)\" for ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr update_by_pair xs ys = xs @ ys", "using assms that"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw (xs @ ys)\n\ngoal (1 subgoal):\n 1. foldr update_by_pair xs ys = xs @ ys", "proof (induct xs rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. oalist_inv_raw ([] @ ys) \\<Longrightarrow>\n    foldr update_by_pair [] ys = [] @ ys\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (xs @ ys) \\<Longrightarrow>\n        foldr update_by_pair xs ys = xs @ ys;\n        oalist_inv_raw (((k, v) # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldr update_by_pair ((k, v) # xs) ys =\n                         ((k, v) # xs) @ ys", "case Nil"], ["proof (state)\nthis:\n  oalist_inv_raw ([] @ ys)\n\ngoal (2 subgoals):\n 1. oalist_inv_raw ([] @ ys) \\<Longrightarrow>\n    foldr update_by_pair [] ys = [] @ ys\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (xs @ ys) \\<Longrightarrow>\n        foldr update_by_pair xs ys = xs @ ys;\n        oalist_inv_raw (((k, v) # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldr update_by_pair ((k, v) # xs) ys =\n                         ((k, v) # xs) @ ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr update_by_pair [] ys = [] @ ys", "by simp"], ["proof (state)\nthis:\n  foldr update_by_pair [] ys = [] @ ys\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (xs @ ys) \\<Longrightarrow>\n        foldr update_by_pair xs ys = xs @ ys;\n        oalist_inv_raw (((k, v) # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldr update_by_pair ((k, v) # xs) ys =\n                         ((k, v) # xs) @ ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (xs @ ys) \\<Longrightarrow>\n        foldr update_by_pair xs ys = xs @ ys;\n        oalist_inv_raw (((k, v) # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldr update_by_pair ((k, v) # xs) ys =\n                         ((k, v) # xs) @ ys", "case (Cons k v xs)"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, v) # xs)\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  ?k'35 \\<in> fst ` set xs \\<Longrightarrow> lt k ?k'35\n  oalist_inv_raw (xs @ ys) \\<Longrightarrow>\n  foldr update_by_pair xs ys = xs @ ys\n  oalist_inv_raw (((k, v) # xs) @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (xs @ ys) \\<Longrightarrow>\n        foldr update_by_pair xs ys = xs @ ys;\n        oalist_inv_raw (((k, v) # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldr update_by_pair ((k, v) # xs) ys =\n                         ((k, v) # xs) @ ys", "from Cons(6)"], ["proof (chain)\npicking this:\n  oalist_inv_raw (((k, v) # xs) @ ys)", "have *: \"oalist_inv_raw ((k, v) # (xs @ ys))\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (((k, v) # xs) @ ys)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ((k, v) # xs @ ys)", "by simp"], ["proof (state)\nthis:\n  oalist_inv_raw ((k, v) # xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (xs @ ys) \\<Longrightarrow>\n        foldr update_by_pair xs ys = xs @ ys;\n        oalist_inv_raw (((k, v) # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldr update_by_pair ((k, v) # xs) ys =\n                         ((k, v) # xs) @ ys", "hence 1: \"oalist_inv_raw (xs @ ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs @ ys)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (xs @ ys)", "by (rule oalist_inv_raw_ConsD1)"], ["proof (state)\nthis:\n  oalist_inv_raw (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (xs @ ys) \\<Longrightarrow>\n        foldr update_by_pair xs ys = xs @ ys;\n        oalist_inv_raw (((k, v) # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldr update_by_pair ((k, v) # xs) ys =\n                         ((k, v) # xs) @ ys", "hence 2: \"foldr update_by_pair xs ys = xs @ ys\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (xs @ ys)\n\ngoal (1 subgoal):\n 1. foldr update_by_pair xs ys = xs @ ys", "by (rule Cons(5))"], ["proof (state)\nthis:\n  foldr update_by_pair xs ys = xs @ ys\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ((k, v) # xs); oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt k k';\n        oalist_inv_raw (xs @ ys) \\<Longrightarrow>\n        foldr update_by_pair xs ys = xs @ ys;\n        oalist_inv_raw (((k, v) # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldr update_by_pair ((k, v) # xs) ys =\n                         ((k, v) # xs) @ ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr update_by_pair ((k, v) # xs) ys = ((k, v) # xs) @ ys", "proof (simp add: 2, rule update_by_pair_less)"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<noteq> (0::'b)\n 2. xs @ ys = [] \\<or> comp k (fst (hd (xs @ ys))) = Lt", "from *"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs @ ys)", "show \"v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs @ ys)\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b)", "by (auto simp: oalist_inv_raw_def)"], ["proof (state)\nthis:\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. xs @ ys = [] \\<or> comp k (fst (hd (xs @ ys))) = Lt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs @ ys = [] \\<or> comp k (fst (hd (xs @ ys))) = Lt", "have \"comp k (fst (hd (xs @ ys))) = Lt \\<or> xs @ ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp k (fst (hd (xs @ ys))) = Lt \\<or> xs @ ys = []", "proof (rule disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. xs @ ys \\<noteq> [] \\<Longrightarrow> comp k (fst (hd (xs @ ys))) = Lt", "assume \"xs @ ys \\<noteq> []\""], ["proof (state)\nthis:\n  xs @ ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs @ ys \\<noteq> [] \\<Longrightarrow> comp k (fst (hd (xs @ ys))) = Lt", "then"], ["proof (chain)\npicking this:\n  xs @ ys \\<noteq> []", "obtain k'' v'' zs where eq0: \"xs @ ys = (k'', v'') # zs\""], ["proof (prove)\nusing this:\n  xs @ ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k'' v'' zs.\n        xs @ ys = (k'', v'') # zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using list.exhaust prod.exhaust"], ["proof (prove)\nusing this:\n  xs @ ys \\<noteq> []\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>k'' v'' zs.\n        xs @ ys = (k'', v'') # zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs @ ys = (k'', v'') # zs\n\ngoal (1 subgoal):\n 1. xs @ ys \\<noteq> [] \\<Longrightarrow> comp k (fst (hd (xs @ ys))) = Lt", "from *"], ["proof (chain)\npicking this:\n  oalist_inv_raw ((k, v) # xs @ ys)", "have \"lt k k''\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ((k, v) # xs @ ys)\n\ngoal (1 subgoal):\n 1. lt k k''", "by (simp add: eq0 oalist_inv_raw_def)"], ["proof (state)\nthis:\n  lt k k''\n\ngoal (1 subgoal):\n 1. xs @ ys \\<noteq> [] \\<Longrightarrow> comp k (fst (hd (xs @ ys))) = Lt", "thus \"comp k (fst (hd (xs @ ys))) = Lt\""], ["proof (prove)\nusing this:\n  lt k k''\n\ngoal (1 subgoal):\n 1. comp k (fst (hd (xs @ ys))) = Lt", "by (simp add: eq0 Lt_lt_conv)"], ["proof (state)\nthis:\n  comp k (fst (hd (xs @ ys))) = Lt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comp k (fst (hd (xs @ ys))) = Lt \\<or> xs @ ys = []\n\ngoal (1 subgoal):\n 1. xs @ ys = [] \\<or> comp k (fst (hd (xs @ ys))) = Lt", "thus \"xs @ ys = [] \\<or> comp k (fst (hd (xs @ ys))) = Lt\""], ["proof (prove)\nusing this:\n  comp k (fst (hd (xs @ ys))) = Lt \\<or> xs @ ys = []\n\ngoal (1 subgoal):\n 1. xs @ ys = [] \\<or> comp k (fst (hd (xs @ ys))) = Lt", "by auto"], ["proof (state)\nthis:\n  xs @ ys = [] \\<or> comp k (fst (hd (xs @ ys))) = Lt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldr update_by_pair ((k, v) # xs) ys = ((k, v) # xs) @ ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oalist_inv_raw (xs @ ?ys35) \\<Longrightarrow>\n  foldr update_by_pair xs ?ys35 = xs @ ?ys35\n\ngoal (1 subgoal):\n 1. sort_oalist xs = xs", "with assms"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  oalist_inv_raw (xs @ ?ys35) \\<Longrightarrow>\n  foldr update_by_pair xs ?ys35 = xs @ ?ys35", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  oalist_inv_raw (xs @ ?ys35) \\<Longrightarrow>\n  foldr update_by_pair xs ?ys35 = xs @ ?ys35\n\ngoal (1 subgoal):\n 1. sort_oalist xs = xs", "by (simp add: sort_oalist_def)"], ["proof (state)\nthis:\n  sort_oalist xs = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_sort_oalist:\n  assumes \"distinct (map fst xs)\"\n  shows \"set (sort_oalist xs) = {kv. kv \\<in> set xs \\<and> snd kv \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sort_oalist xs) = {kv \\<in> set xs. snd kv \\<noteq> (0::'b)}", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. set (sort_oalist xs) = {kv \\<in> set xs. snd kv \\<noteq> (0::'b)}", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    set (sort_oalist []) = {kv \\<in> set []. snd kv \\<noteq> (0::'b)}\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    set (sort_oalist []) = {kv \\<in> set []. snd kv \\<noteq> (0::'b)}\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sort_oalist []) = {kv \\<in> set []. snd kv \\<noteq> (0::'b)}", "by (simp add: sort_oalist_def)"], ["proof (state)\nthis:\n  set (sort_oalist []) = {kv \\<in> set []. snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct (map fst xs) \\<Longrightarrow>\n  set (sort_oalist xs) = {kv \\<in> set xs. snd kv \\<noteq> (0::'b)}\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "obtain k v where x: \"x = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. x = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "from Cons(2)"], ["proof (chain)\npicking this:\n  distinct (map fst (x # xs))", "have \"distinct (map fst xs)\" and \"k \\<notin> fst ` set xs\""], ["proof (prove)\nusing this:\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. distinct (map fst xs) &&& k \\<notin> fst ` set xs", "by (simp_all add: x)"], ["proof (state)\nthis:\n  distinct (map fst xs)\n  k \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "from this(1)"], ["proof (chain)\npicking this:\n  distinct (map fst xs)", "have \"set (sort_oalist xs) = {kv \\<in> set xs. snd kv \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. set (sort_oalist xs) = {kv \\<in> set xs. snd kv \\<noteq> (0::'b)}", "by (rule Cons(1))"], ["proof (state)\nthis:\n  set (sort_oalist xs) = {kv \\<in> set xs. snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "with \\<open>k \\<notin> fst ` set xs\\<close>"], ["proof (chain)\npicking this:\n  k \\<notin> fst ` set xs\n  set (sort_oalist xs) = {kv \\<in> set xs. snd kv \\<noteq> (0::'b)}", "have eq: \"set (sort_oalist xs) - range (Pair k) = {kv \\<in> set xs. snd kv \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set xs\n  set (sort_oalist xs) = {kv \\<in> set xs. snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. set (sort_oalist xs) - range (Pair k) =\n    {kv \\<in> set xs. snd kv \\<noteq> (0::'b)}", "by (auto simp: image_iff)"], ["proof (state)\nthis:\n  set (sort_oalist xs) - range (Pair k) =\n  {kv \\<in> set xs. snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "have \"set (sort_oalist (x # xs)) = set (update_by_pair (k, v) (sort_oalist xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sort_oalist (x # xs)) =\n    set (update_by_pair (k, v) (sort_oalist xs))", "by (simp add: sort_oalist_def x)"], ["proof (state)\nthis:\n  set (sort_oalist (x # xs)) = set (update_by_pair (k, v) (sort_oalist xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "also"], ["proof (state)\nthis:\n  set (sort_oalist (x # xs)) = set (update_by_pair (k, v) (sort_oalist xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "have \"... = {kv \\<in> set (x # xs). snd kv \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "proof (cases \"v = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n 2. v \\<noteq> (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "case True"], ["proof (state)\nthis:\n  v = (0::'b)\n\ngoal (2 subgoals):\n 1. v = (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n 2. v \\<noteq> (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "have \"set (update_by_pair (k, v) (sort_oalist xs)) = set (sort_oalist xs) - range (Pair k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (update_by_pair (k, v) (sort_oalist xs)) =\n    set (sort_oalist xs) - range (Pair k)", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (update_by_pair (k, 0::'b) (sort_oalist xs)) =\n    set (sort_oalist xs) - range (Pair k)", "using oalist_inv_raw_sort_oalist"], ["proof (prove)\nusing this:\n  oalist_inv_raw (sort_oalist ?xs)\n\ngoal (1 subgoal):\n 1. set (update_by_pair (k, 0::'b) (sort_oalist xs)) =\n    set (sort_oalist xs) - range (Pair k)", "by (rule set_update_by_pair_zero)"], ["proof (state)\nthis:\n  set (update_by_pair (k, v) (sort_oalist xs)) =\n  set (sort_oalist xs) - range (Pair k)\n\ngoal (2 subgoals):\n 1. v = (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n 2. v \\<noteq> (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "also"], ["proof (state)\nthis:\n  set (update_by_pair (k, v) (sort_oalist xs)) =\n  set (sort_oalist xs) - range (Pair k)\n\ngoal (2 subgoals):\n 1. v = (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n 2. v \\<noteq> (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "have \"... = {kv \\<in> set (x # xs). snd kv \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sort_oalist xs) - range (Pair k) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "by (auto simp: eq x True)"], ["proof (state)\nthis:\n  set (sort_oalist xs) - range (Pair k) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n\ngoal (2 subgoals):\n 1. v = (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n 2. v \\<noteq> (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "finally"], ["proof (chain)\npicking this:\n  set (update_by_pair (k, v) (sort_oalist xs)) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "show ?thesis"], ["proof (prove)\nusing this:\n  set (update_by_pair (k, v) (sort_oalist xs)) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "."], ["proof (state)\nthis:\n  set (update_by_pair (k, v) (sort_oalist xs)) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "case False"], ["proof (state)\nthis:\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "with oalist_inv_raw_sort_oalist"], ["proof (chain)\npicking this:\n  oalist_inv_raw (sort_oalist ?xs)\n  v \\<noteq> (0::'b)", "have \"set (update_by_pair (k, v) (sort_oalist xs)) = insert (k, v) (set (sort_oalist xs) - range (Pair k))\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (sort_oalist ?xs)\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. set (update_by_pair (k, v) (sort_oalist xs)) =\n    insert (k, v) (set (sort_oalist xs) - range (Pair k))", "by (rule set_update_by_pair)"], ["proof (state)\nthis:\n  set (update_by_pair (k, v) (sort_oalist xs)) =\n  insert (k, v) (set (sort_oalist xs) - range (Pair k))\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "also"], ["proof (state)\nthis:\n  set (update_by_pair (k, v) (sort_oalist xs)) =\n  insert (k, v) (set (sort_oalist xs) - range (Pair k))\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "have \"... = {kv \\<in> set (x # xs). snd kv \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (k, v) (set (sort_oalist xs) - range (Pair k)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "by (auto simp: eq x False)"], ["proof (state)\nthis:\n  insert (k, v) (set (sort_oalist xs) - range (Pair k)) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b) \\<Longrightarrow>\n    set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "finally"], ["proof (chain)\npicking this:\n  set (update_by_pair (k, v) (sort_oalist xs)) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "show ?thesis"], ["proof (prove)\nusing this:\n  set (update_by_pair (k, v) (sort_oalist xs)) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. set (update_by_pair (k, v) (sort_oalist xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "."], ["proof (state)\nthis:\n  set (update_by_pair (k, v) (sort_oalist xs)) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (update_by_pair (k, v) (sort_oalist xs)) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (sort_oalist xs) =\n                {kv \\<in> set xs. snd kv \\<noteq> (0::'b)};\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (sort_oalist (a # xs)) =\n                         {kv \\<in> set (a # xs). snd kv \\<noteq> (0::'b)}", "finally"], ["proof (chain)\npicking this:\n  set (sort_oalist (x # xs)) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "show ?case"], ["proof (prove)\nusing this:\n  set (sort_oalist (x # xs)) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. set (sort_oalist (x # xs)) =\n    {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}", "."], ["proof (state)\nthis:\n  set (sort_oalist (x # xs)) =\n  {kv \\<in> set (x # xs). snd kv \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_sort_oalist':\n  assumes \"distinct (map fst xs)\"\n  shows \"lookup_pair (sort_oalist xs) = lookup_dflt xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (sort_oalist xs) = lookup_dflt xs", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. lookup_pair (sort_oalist xs) = lookup_dflt xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    lookup_pair (sort_oalist []) = lookup_dflt []\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_pair (sort_oalist xs) = lookup_dflt xs;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (sort_oalist (a # xs)) =\n                         lookup_dflt (a # xs)", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    lookup_pair (sort_oalist []) = lookup_dflt []\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_pair (sort_oalist xs) = lookup_dflt xs;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (sort_oalist (a # xs)) =\n                         lookup_dflt (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (sort_oalist []) = lookup_dflt []", "by (simp add: sort_oalist_def lookup_dflt_def)"], ["proof (state)\nthis:\n  lookup_pair (sort_oalist []) = lookup_dflt []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_pair (sort_oalist xs) = lookup_dflt xs;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (sort_oalist (a # xs)) =\n                         lookup_dflt (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_pair (sort_oalist xs) = lookup_dflt xs;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (sort_oalist (a # xs)) =\n                         lookup_dflt (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct (map fst xs) \\<Longrightarrow>\n  lookup_pair (sort_oalist xs) = lookup_dflt xs\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_pair (sort_oalist xs) = lookup_dflt xs;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (sort_oalist (a # xs)) =\n                         lookup_dflt (a # xs)", "obtain k v where x: \"x = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. x = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_pair (sort_oalist xs) = lookup_dflt xs;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (sort_oalist (a # xs)) =\n                         lookup_dflt (a # xs)", "from Cons(2)"], ["proof (chain)\npicking this:\n  distinct (map fst (x # xs))", "have \"distinct (map fst xs)\" and \"k \\<notin> fst ` set xs\""], ["proof (prove)\nusing this:\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. distinct (map fst xs) &&& k \\<notin> fst ` set xs", "by (simp_all add: x)"], ["proof (state)\nthis:\n  distinct (map fst xs)\n  k \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_pair (sort_oalist xs) = lookup_dflt xs;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (sort_oalist (a # xs)) =\n                         lookup_dflt (a # xs)", "from this(1)"], ["proof (chain)\npicking this:\n  distinct (map fst xs)", "have eq1: \"lookup_pair (sort_oalist xs) = lookup_dflt xs\""], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. lookup_pair (sort_oalist xs) = lookup_dflt xs", "by (rule Cons(1))"], ["proof (state)\nthis:\n  lookup_pair (sort_oalist xs) = lookup_dflt xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_pair (sort_oalist xs) = lookup_dflt xs;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (sort_oalist (a # xs)) =\n                         lookup_dflt (a # xs)", "have eq2: \"sort_oalist (x # xs) = update_by_pair (k, v) (sort_oalist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_oalist (x # xs) = update_by_pair (k, v) (sort_oalist xs)", "by (simp add: x sort_oalist_def)"], ["proof (state)\nthis:\n  sort_oalist (x # xs) = update_by_pair (k, v) (sort_oalist xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                lookup_pair (sort_oalist xs) = lookup_dflt xs;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> lookup_pair (sort_oalist (a # xs)) =\n                         lookup_dflt (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (sort_oalist (x # xs)) = lookup_dflt (x # xs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       lookup_pair (sort_oalist (x # xs)) xa = lookup_dflt (x # xs) xa", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       lookup_pair (sort_oalist (x # xs)) xa = lookup_dflt (x # xs) xa", "have \"lookup_pair (sort_oalist (x # xs)) k' = (if k = k' then v else lookup_dflt xs k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (sort_oalist (x # xs)) k' =\n    (if k = k' then v else lookup_dflt xs k')", "by (simp add: eq1 eq2 lookup_pair_update_by_pair[OF oalist_inv_raw_sort_oalist])"], ["proof (state)\nthis:\n  lookup_pair (sort_oalist (x # xs)) k' =\n  (if k = k' then v else lookup_dflt xs k')\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       lookup_pair (sort_oalist (x # xs)) xa = lookup_dflt (x # xs) xa", "also"], ["proof (state)\nthis:\n  lookup_pair (sort_oalist (x # xs)) k' =\n  (if k = k' then v else lookup_dflt xs k')\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       lookup_pair (sort_oalist (x # xs)) xa = lookup_dflt (x # xs) xa", "have \"... = lookup_dflt (x # xs) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k = k' then v else lookup_dflt xs k') = lookup_dflt (x # xs) k'", "by (simp add: x lookup_dflt_def)"], ["proof (state)\nthis:\n  (if k = k' then v else lookup_dflt xs k') = lookup_dflt (x # xs) k'\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       lookup_pair (sort_oalist (x # xs)) xa = lookup_dflt (x # xs) xa", "finally"], ["proof (chain)\npicking this:\n  lookup_pair (sort_oalist (x # xs)) k' = lookup_dflt (x # xs) k'", "show \"lookup_pair (sort_oalist (x # xs)) k' = lookup_dflt (x # xs) k'\""], ["proof (prove)\nusing this:\n  lookup_pair (sort_oalist (x # xs)) k' = lookup_dflt (x # xs) k'\n\ngoal (1 subgoal):\n 1. lookup_pair (sort_oalist (x # xs)) k' = lookup_dflt (x # xs) k'", "."], ["proof (state)\nthis:\n  lookup_pair (sort_oalist (x # xs)) k' = lookup_dflt (x # xs) k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair (sort_oalist (x # xs)) = lookup_dflt (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale comparator2 = comparator comp1 + cmp2: comparator comp2 for comp1 comp2 :: \"'a comparator\"\nbegin"], ["", "lemma set_sort_oalist:\n  assumes \"cmp2.oalist_inv_raw xs\"\n  shows \"set (sort_oalist xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sort_oalist xs) = set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (sort_oalist xs) = set xs", "have rl: \"set (foldr update_by_pair xs ys) = set xs \\<union> set ys\"\n    if \"oalist_inv_raw ys\" and \"fst ` set xs \\<inter> fst ` set ys = {}\" for ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (foldr update_by_pair xs ys) = set xs \\<union> set ys", "using assms that(2)"], ["proof (prove)\nusing this:\n  cmp2.oalist_inv_raw xs\n  fst ` set xs \\<inter> fst ` set ys = {}\n\ngoal (1 subgoal):\n 1. set (foldr update_by_pair xs ys) = set xs \\<union> set ys", "proof (induct xs rule: cmp2.oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst ` set [] \\<inter> fst ` set ys = {} \\<Longrightarrow>\n    set (foldr update_by_pair [] ys) = set [] \\<union> set ys\n 2. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "case Nil"], ["proof (state)\nthis:\n  fst ` set [] \\<inter> fst ` set ys = {}\n\ngoal (2 subgoals):\n 1. fst ` set [] \\<inter> fst ` set ys = {} \\<Longrightarrow>\n    set (foldr update_by_pair [] ys) = set [] \\<union> set ys\n 2. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (foldr update_by_pair [] ys) = set [] \\<union> set ys", "by simp"], ["proof (state)\nthis:\n  set (foldr update_by_pair [] ys) = set [] \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "case (Cons k v xs)"], ["proof (state)\nthis:\n  cmp2.oalist_inv_raw ((k, v) # xs)\n  cmp2.oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  ?k'35 \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k ?k'35\n  fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n  set (foldr update_by_pair xs ys) = set xs \\<union> set ys\n  fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "from Cons(6)"], ["proof (chain)\npicking this:\n  fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}", "have \"k \\<notin> fst ` set ys\" and \"fst ` set xs \\<inter> fst ` set ys = {}\""], ["proof (prove)\nusing this:\n  fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set ys &&& fst ` set xs \\<inter> fst ` set ys = {}", "by simp_all"], ["proof (state)\nthis:\n  k \\<notin> fst ` set ys\n  fst ` set xs \\<inter> fst ` set ys = {}\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "from this(2)"], ["proof (chain)\npicking this:\n  fst ` set xs \\<inter> fst ` set ys = {}", "have eq1: \"set (foldr update_by_pair xs ys) = set xs \\<union> set ys\""], ["proof (prove)\nusing this:\n  fst ` set xs \\<inter> fst ` set ys = {}\n\ngoal (1 subgoal):\n 1. set (foldr update_by_pair xs ys) = set xs \\<union> set ys", "by (rule Cons(5))"], ["proof (state)\nthis:\n  set (foldr update_by_pair xs ys) = set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "have \"\\<not> cmp2.lt k k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> cmp2.lt k k", "by auto"], ["proof (state)\nthis:\n  \\<not> cmp2.lt k k\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "with Cons(4)"], ["proof (chain)\npicking this:\n  ?k'35 \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k ?k'35\n  \\<not> cmp2.lt k k", "have \"k \\<notin> fst ` set xs\""], ["proof (prove)\nusing this:\n  ?k'35 \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k ?k'35\n  \\<not> cmp2.lt k k\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set xs", "by blast"], ["proof (state)\nthis:\n  k \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "with \\<open>k \\<notin> fst ` set ys\\<close>"], ["proof (chain)\npicking this:\n  k \\<notin> fst ` set ys\n  k \\<notin> fst ` set xs", "have \"k \\<notin> fst ` (set xs \\<union> set ys)\""], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set ys\n  k \\<notin> fst ` set xs\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` (set xs \\<union> set ys)", "by (simp add: image_Un)"], ["proof (state)\nthis:\n  k \\<notin> fst ` (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "hence \"(set xs \\<union> set ys) \\<inter> range (Pair k) = {}\""], ["proof (prove)\nusing this:\n  k \\<notin> fst ` (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. (set xs \\<union> set ys) \\<inter> range (Pair k) = {}", "by (smt Int_emptyI fstI image_iff)"], ["proof (state)\nthis:\n  (set xs \\<union> set ys) \\<inter> range (Pair k) = {}\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "hence eq2: \"(set xs \\<union> set ys) - range (Pair k) = set xs \\<union> set ys\""], ["proof (prove)\nusing this:\n  (set xs \\<union> set ys) \\<inter> range (Pair k) = {}\n\ngoal (1 subgoal):\n 1. set xs \\<union> set ys - range (Pair k) = set xs \\<union> set ys", "by (rule Diff_triv)"], ["proof (state)\nthis:\n  set xs \\<union> set ys - range (Pair k) = set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "from \\<open>oalist_inv_raw ys\\<close>"], ["proof (chain)\npicking this:\n  oalist_inv_raw ys", "have \"oalist_inv_raw (foldr update_by_pair xs ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ys\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (foldr update_by_pair xs ys)", "by (rule oalist_inv_raw_foldr_update_by_pair)"], ["proof (state)\nthis:\n  oalist_inv_raw (foldr update_by_pair xs ys)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "hence \"set (update_by_pair (k, v) (foldr update_by_pair xs ys)) =\n            insert (k, v) (set (foldr update_by_pair xs ys) - range (Pair k))\""], ["proof (prove)\nusing this:\n  oalist_inv_raw (foldr update_by_pair xs ys)\n\ngoal (1 subgoal):\n 1. set (update_by_pair (k, v) (foldr update_by_pair xs ys)) =\n    insert (k, v) (set (foldr update_by_pair xs ys) - range (Pair k))", "using Cons(3)"], ["proof (prove)\nusing this:\n  oalist_inv_raw (foldr update_by_pair xs ys)\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. set (update_by_pair (k, v) (foldr update_by_pair xs ys)) =\n    insert (k, v) (set (foldr update_by_pair xs ys) - range (Pair k))", "by (rule set_update_by_pair)"], ["proof (state)\nthis:\n  set (update_by_pair (k, v) (foldr update_by_pair xs ys)) =\n  insert (k, v) (set (foldr update_by_pair xs ys) - range (Pair k))\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "also"], ["proof (state)\nthis:\n  set (update_by_pair (k, v) (foldr update_by_pair xs ys)) =\n  insert (k, v) (set (foldr update_by_pair xs ys) - range (Pair k))\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "have \"... = insert (k, v) (set xs \\<union> set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (k, v) (set (foldr update_by_pair xs ys) - range (Pair k)) =\n    insert (k, v) (set xs \\<union> set ys)", "by (simp only: eq1 eq2)"], ["proof (state)\nthis:\n  insert (k, v) (set (foldr update_by_pair xs ys) - range (Pair k)) =\n  insert (k, v) (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>cmp2.oalist_inv_raw ((k, v) # xs); cmp2.oalist_inv_raw xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> cmp2.lt k k';\n        fst ` set xs \\<inter> fst ` set ys = {} \\<Longrightarrow>\n        set (foldr update_by_pair xs ys) = set xs \\<union> set ys;\n        fst ` set ((k, v) # xs) \\<inter> fst ` set ys = {}\\<rbrakk>\n       \\<Longrightarrow> set (foldr update_by_pair ((k, v) # xs) ys) =\n                         set ((k, v) # xs) \\<union> set ys", "finally"], ["proof (chain)\npicking this:\n  set (update_by_pair (k, v) (foldr update_by_pair xs ys)) =\n  insert (k, v) (set xs \\<union> set ys)", "show ?case"], ["proof (prove)\nusing this:\n  set (update_by_pair (k, v) (foldr update_by_pair xs ys)) =\n  insert (k, v) (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. set (foldr update_by_pair ((k, v) # xs) ys) =\n    set ((k, v) # xs) \\<union> set ys", "by simp"], ["proof (state)\nthis:\n  set (foldr update_by_pair ((k, v) # xs) ys) =\n  set ((k, v) # xs) \\<union> set ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>oalist_inv_raw ?ys35;\n   fst ` set xs \\<inter> fst ` set ?ys35 = {}\\<rbrakk>\n  \\<Longrightarrow> set (foldr update_by_pair xs ?ys35) =\n                    set xs \\<union> set ?ys35\n\ngoal (1 subgoal):\n 1. set (sort_oalist xs) = set xs", "have \"set (foldr update_by_pair xs []) = set xs \\<union> set []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (foldr update_by_pair xs []) = set xs \\<union> set []", "by (rule rl, fact oalist_inv_raw_Nil, simp)"], ["proof (state)\nthis:\n  set (foldr update_by_pair xs []) = set xs \\<union> set []\n\ngoal (1 subgoal):\n 1. set (sort_oalist xs) = set xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (foldr update_by_pair xs []) = set xs \\<union> set []\n\ngoal (1 subgoal):\n 1. set (sort_oalist xs) = set xs", "by (simp add: sort_oalist_def)"], ["proof (state)\nthis:\n  set (sort_oalist xs) = set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_pair_eqI:\n  assumes \"oalist_inv_raw xs\" and \"cmp2.oalist_inv_raw ys\" and \"set xs = set ys\"\n  shows \"lookup_pair xs = cmp2.lookup_pair ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair xs = cmp2.lookup_pair ys", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup_pair xs x = cmp2.lookup_pair ys x", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup_pair xs x = cmp2.lookup_pair ys x", "show \"lookup_pair xs k = cmp2.lookup_pair ys k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair xs k = cmp2.lookup_pair ys k", "proof (cases \"cmp2.lookup_pair ys k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cmp2.lookup_pair ys k = (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k\n 2. cmp2.lookup_pair ys k \\<noteq> (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k", "case True"], ["proof (state)\nthis:\n  cmp2.lookup_pair ys k = (0::'b)\n\ngoal (2 subgoals):\n 1. cmp2.lookup_pair ys k = (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k\n 2. cmp2.lookup_pair ys k \\<noteq> (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k", "with assms(2)"], ["proof (chain)\npicking this:\n  cmp2.oalist_inv_raw ys\n  cmp2.lookup_pair ys k = (0::'b)", "have \"k \\<notin> fst ` set ys\""], ["proof (prove)\nusing this:\n  cmp2.oalist_inv_raw ys\n  cmp2.lookup_pair ys k = (0::'b)\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set ys", "by (simp add: cmp2.lookup_pair_eq_0)"], ["proof (state)\nthis:\n  k \\<notin> fst ` set ys\n\ngoal (2 subgoals):\n 1. cmp2.lookup_pair ys k = (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k\n 2. cmp2.lookup_pair ys k \\<noteq> (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k", "with assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  k \\<notin> fst ` set ys", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  k \\<notin> fst ` set ys\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = cmp2.lookup_pair ys k", "by (simp add: True assms(3)[symmetric] lookup_pair_eq_0)"], ["proof (state)\nthis:\n  lookup_pair xs k = cmp2.lookup_pair ys k\n\ngoal (1 subgoal):\n 1. cmp2.lookup_pair ys k \\<noteq> (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cmp2.lookup_pair ys k \\<noteq> (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k", "case False"], ["proof (state)\nthis:\n  cmp2.lookup_pair ys k \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. cmp2.lookup_pair ys k \\<noteq> (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k", "define v where \"v = cmp2.lookup_pair ys k\""], ["proof (state)\nthis:\n  v = cmp2.lookup_pair ys k\n\ngoal (1 subgoal):\n 1. cmp2.lookup_pair ys k \\<noteq> (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k", "from False"], ["proof (chain)\npicking this:\n  cmp2.lookup_pair ys k \\<noteq> (0::'b)", "have \"v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  cmp2.lookup_pair ys k \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b)", "by (simp add: v_def)"], ["proof (state)\nthis:\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. cmp2.lookup_pair ys k \\<noteq> (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k", "with assms(2) v_def[symmetric]"], ["proof (chain)\npicking this:\n  cmp2.oalist_inv_raw ys\n  cmp2.lookup_pair ys k = v\n  v \\<noteq> (0::'b)", "have \"(k, v) \\<in> set ys\""], ["proof (prove)\nusing this:\n  cmp2.oalist_inv_raw ys\n  cmp2.lookup_pair ys k = v\n  v \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set ys", "by (simp add: cmp2.lookup_pair_eq_value)"], ["proof (state)\nthis:\n  (k, v) \\<in> set ys\n\ngoal (1 subgoal):\n 1. cmp2.lookup_pair ys k \\<noteq> (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k", "with assms(1) \\<open>v \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  (k, v) \\<in> set ys", "have \"lookup_pair xs k = v\""], ["proof (prove)\nusing this:\n  oalist_inv_raw xs\n  v \\<noteq> (0::'b)\n  (k, v) \\<in> set ys\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = v", "by (simp add: assms(3)[symmetric] lookup_pair_eq_value)"], ["proof (state)\nthis:\n  lookup_pair xs k = v\n\ngoal (1 subgoal):\n 1. cmp2.lookup_pair ys k \\<noteq> (0::'b) \\<Longrightarrow>\n    lookup_pair xs k = cmp2.lookup_pair ys k", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup_pair xs k = v\n\ngoal (1 subgoal):\n 1. lookup_pair xs k = cmp2.lookup_pair ys k", "by (simp only: v_def)"], ["proof (state)\nthis:\n  lookup_pair xs k = cmp2.lookup_pair ys k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair xs k = cmp2.lookup_pair ys k\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lookup_pair_sort_oalist:\n  assumes \"cmp2.oalist_inv_raw xs\"\n  shows \"lookup_pair (sort_oalist xs) = cmp2.lookup_pair xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair (sort_oalist xs) = cmp2.lookup_pair xs", "by (rule lookup_pair_eqI, rule oalist_inv_raw_sort_oalist, fact, rule set_sort_oalist, fact)"], ["", "end"], ["", "(* comparator2 *)"], ["", "subsection \\<open>Invariant on Pairs\\<close>"], ["", "type_synonym ('a, 'b, 'c) oalist_raw = \"('a \\<times> 'b) list \\<times> 'c\""], ["", "locale oalist_raw = fixes rep_key_order::\"'o \\<Rightarrow> 'a key_order\"\nbegin"], ["", "sublocale comparator \"key_compare (rep_key_order x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (key_compare (rep_key_order x))", "by (fact comparator_key_compare)"], ["", "definition oalist_inv :: \"('a, 'b::zero, 'o) oalist_raw \\<Rightarrow> bool\"\n  where \"oalist_inv xs \\<longleftrightarrow> oalist_inv_raw (snd xs) (fst xs)\""], ["", "lemma oalist_inv_alt: \"oalist_inv (xs, ko) \\<longleftrightarrow> oalist_inv_raw ko xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (xs, ko) = oalist_inv_raw ko xs", "by (simp add: oalist_inv_def)"], ["", "subsection \\<open>Operations on Raw Ordered Associative Lists\\<close>"], ["", "fun sort_oalist_aux :: \"'o \\<Rightarrow> ('a, 'b, 'o) oalist_raw \\<Rightarrow> ('a \\<times> 'b::zero) list\"\n  where \"sort_oalist_aux ko (xs, ox) = (if ko = ox then xs else sort_oalist ko xs)\""], ["", "fun lookup_raw :: \"('a, 'b, 'o) oalist_raw \\<Rightarrow> 'a \\<Rightarrow> 'b::zero\"\n  where \"lookup_raw (xs, ko) = lookup_pair ko xs\""], ["", "definition sorted_domain_raw :: \"'o \\<Rightarrow> ('a, 'b::zero, 'o) oalist_raw \\<Rightarrow> 'a list\"\n  where \"sorted_domain_raw ko xs = map fst (sort_oalist_aux ko xs)\""], ["", "fun tl_raw :: \"('a, 'b, 'o) oalist_raw \\<Rightarrow> ('a, 'b::zero, 'o) oalist_raw\"\n  where \"tl_raw (xs, ko) = (List.tl xs, ko)\""], ["", "fun min_key_val_raw :: \"'o \\<Rightarrow> ('a, 'b, 'o) oalist_raw \\<Rightarrow> ('a \\<times> 'b::zero)\"\n  where \"min_key_val_raw ko (xs, ox) =\n      (if ko = ox then List.hd else min_list_param (\\<lambda>x y. le ko (fst x) (fst y))) xs\""], ["", "fun update_by_raw :: \"('a \\<times> 'b) \\<Rightarrow> ('a, 'b, 'o) oalist_raw \\<Rightarrow> ('a, 'b::zero, 'o) oalist_raw\"\n  where \"update_by_raw kv (xs, ko) = (update_by_pair ko kv xs, ko)\""], ["", "fun update_by_fun_raw :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> ('a, 'b, 'o) oalist_raw \\<Rightarrow> ('a, 'b::zero, 'o) oalist_raw\"\n  where \"update_by_fun_raw k f (xs, ko) = (update_by_fun_pair ko k f xs, ko)\""], ["", "fun update_by_fun_gr_raw :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> ('a, 'b, 'o) oalist_raw \\<Rightarrow> ('a, 'b::zero, 'o) oalist_raw\"\n  where \"update_by_fun_gr_raw k f (xs, ko) = (update_by_fun_gr_pair ko k f xs, ko)\""], ["", "fun (in -) filter_raw :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a list \\<times> 'b) \\<Rightarrow> ('a list \\<times> 'b)\"\n  where \"filter_raw P (xs, ko) = (filter P xs, ko)\""], ["", "fun (in -) map_raw :: \"(('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'c)) \\<Rightarrow> (('a \\<times> 'b::zero) list \\<times> 'd) \\<Rightarrow> ('a \\<times> 'c::zero) list \\<times> 'd\"\n  where \"map_raw f (xs, ko) = (map_pair f xs, ko)\""], ["", "abbreviation (in -) \"map_val_raw f \\<equiv> map_raw (\\<lambda>(k, v). (k, f k v))\""], ["", "fun map2_val_raw :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd) \\<Rightarrow> (('a, 'b, 'o) oalist_raw \\<Rightarrow> ('a, 'd, 'o) oalist_raw) \\<Rightarrow>\n                      (('a, 'c, 'o) oalist_raw \\<Rightarrow> ('a, 'd, 'o) oalist_raw) \\<Rightarrow>\n                      ('a, 'b::zero, 'o) oalist_raw \\<Rightarrow> ('a, 'c::zero, 'o) oalist_raw \\<Rightarrow>\n                      ('a, 'd::zero, 'o) oalist_raw\"\n  where \"map2_val_raw f g h (xs, ox) ys =\n            (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox))) (\\<lambda>zs. fst (h (zs, ox)))\n                    xs (sort_oalist_aux ox ys), ox)\""], ["", "definition lex_ord_raw :: \"'o \\<Rightarrow> ('a \\<Rightarrow> (('b, 'c) comp_opt)) \\<Rightarrow>\n                      (('a, 'b::zero, 'o) oalist_raw, ('a, 'c::zero, 'o) oalist_raw) comp_opt\"\n  where \"lex_ord_raw ko f xs ys = lex_ord_pair ko f (sort_oalist_aux ko xs) (sort_oalist_aux ko ys)\""], ["", "fun prod_ord_raw :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b::zero, 'o) oalist_raw \\<Rightarrow>\n                      ('a, 'c::zero, 'o) oalist_raw \\<Rightarrow> bool\"\n  where \"prod_ord_raw f (xs, ox) ys = prod_ord_pair ox f xs (sort_oalist_aux ox ys)\""], ["", "fun oalist_eq_raw :: \"('a, 'b, 'o) oalist_raw \\<Rightarrow> ('a, 'b::zero, 'o) oalist_raw \\<Rightarrow> bool\"\n  where \"oalist_eq_raw (xs, ox) ys = (xs = (sort_oalist_aux ox ys))\""], ["", "fun sort_oalist_raw :: \"('a, 'b, 'o) oalist_raw \\<Rightarrow> ('a, 'b::zero, 'o) oalist_raw\"\n  where \"sort_oalist_raw (xs, ko) = (sort_oalist ko xs, ko)\""], ["", "subsubsection \\<open>@{const sort_oalist_aux}\\<close>"], ["", "lemma set_sort_oalist_aux:\n  assumes \"oalist_inv xs\"\n  shows \"set (sort_oalist_aux ko xs) = set (fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sort_oalist_aux ko xs) = set (fst xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (sort_oalist_aux ko xs) = set (fst xs)", "obtain xs' ko' where xs: \"xs = (xs', ko')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko'.\n        xs = (xs', ko') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko')\n\ngoal (1 subgoal):\n 1. set (sort_oalist_aux ko xs) = set (fst xs)", "interpret ko2: comparator2 \"key_compare (rep_key_order ko)\" \"key_compare (rep_key_order ko')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator2 (key_compare (rep_key_order ko))\n     (key_compare (rep_key_order ko'))", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. set (sort_oalist_aux ko xs) = set (fst xs)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. set (sort_oalist_aux ko xs) = set (fst xs)", "by (simp add: xs oalist_inv_alt ko2.set_sort_oalist)"], ["proof (state)\nthis:\n  set (sort_oalist_aux ko xs) = set (fst xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_raw_sort_oalist_aux:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv_raw ko (sort_oalist_aux ko xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (sort_oalist_aux ko xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (sort_oalist_aux ko xs)", "obtain xs' ko' where xs: \"xs = (xs', ko')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko'.\n        xs = (xs', ko') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko')\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (sort_oalist_aux ko xs)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (sort_oalist_aux ko xs)", "by (simp add: xs oalist_inv_alt oalist_inv_raw_sort_oalist)"], ["proof (state)\nthis:\n  oalist_inv_raw ko (sort_oalist_aux ko xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_sort_oalist_aux:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (sort_oalist_aux ko xs, ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (sort_oalist_aux ko xs, ko)", "unfolding oalist_inv_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (sort_oalist_aux ko xs)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (sort_oalist_aux ko xs)", "by (rule oalist_inv_raw_sort_oalist_aux)"], ["", "lemma lookup_pair_sort_oalist_aux:\n  assumes \"oalist_inv xs\"\n  shows \"lookup_pair ko (sort_oalist_aux ko xs) = lookup_raw xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ko (sort_oalist_aux ko xs) = lookup_raw xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_pair ko (sort_oalist_aux ko xs) = lookup_raw xs", "obtain xs' ko' where xs: \"xs = (xs', ko')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko'.\n        xs = (xs', ko') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko')\n\ngoal (1 subgoal):\n 1. lookup_pair ko (sort_oalist_aux ko xs) = lookup_raw xs", "interpret ko2: comparator2 \"key_compare (rep_key_order ko)\" \"key_compare (rep_key_order ko')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator2 (key_compare (rep_key_order ko))\n     (key_compare (rep_key_order ko'))", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_pair ko (sort_oalist_aux ko xs) = lookup_raw xs", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. lookup_pair ko (sort_oalist_aux ko xs) = lookup_raw xs", "by (simp add: xs oalist_inv_alt ko2.lookup_pair_sort_oalist)"], ["proof (state)\nthis:\n  lookup_pair ko (sort_oalist_aux ko xs) = lookup_raw xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const lookup_raw}\\<close>"], ["", "lemma lookup_raw_eq_value:\n  assumes \"oalist_inv xs\" and \"v \\<noteq> 0\"\n  shows \"lookup_raw xs k = v \\<longleftrightarrow> ((k, v) \\<in> set (fst xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup_raw xs k = v) = ((k, v) \\<in> set (fst xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (lookup_raw xs k = v) = ((k, v) \\<in> set (fst xs))", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. (lookup_raw xs k = v) = ((k, v) \\<in> set (fst xs))", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ox xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox xs'", "by (simp add: xs oalist_inv_def)"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. (lookup_raw xs k = v) = ((k, v) \\<in> set (fst xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup_raw xs k = v) = ((k, v) \\<in> set (fst xs))", "by (simp add: xs, rule lookup_pair_eq_value, fact+)"], ["proof (state)\nthis:\n  (lookup_raw xs k = v) = ((k, v) \\<in> set (fst xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_raw_eq_valueI:\n  assumes \"oalist_inv xs\" and \"(k, v) \\<in> set (fst xs)\"\n  shows \"lookup_raw xs k = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw xs k = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_raw xs k = v", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. lookup_raw xs k = v", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ox xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox xs'", "by (simp add: xs oalist_inv_def)"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. lookup_raw xs k = v", "from assms(2)"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set (fst xs)", "have \"(k, v) \\<in> set xs'\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set (fst xs)\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set xs'", "by (simp add: xs)"], ["proof (state)\nthis:\n  (k, v) \\<in> set xs'\n\ngoal (1 subgoal):\n 1. lookup_raw xs k = v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw xs k = v", "by (simp add: xs, rule lookup_pair_eq_valueI, fact+)"], ["proof (state)\nthis:\n  lookup_raw xs k = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_raw_inj:\n  assumes \"oalist_inv (xs, ko)\" and \"oalist_inv (ys, ko)\" and \"lookup_raw (xs, ko) = lookup_raw (ys, ko)\"\n  shows \"xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv (xs, ko)\n  oalist_inv (ys, ko)\n  lookup_raw (xs, ko) = lookup_raw (ys, ko)\n\ngoal (1 subgoal):\n 1. xs = ys", "unfolding lookup_raw.simps oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs\n  oalist_inv_raw ko ys\n  lookup_pair ko xs = lookup_pair ko ys\n\ngoal (1 subgoal):\n 1. xs = ys", "by (rule lookup_pair_inj)"], ["", "subsubsection \\<open>@{const sorted_domain_raw}\\<close>"], ["", "lemma set_sorted_domain_raw:\n  assumes \"oalist_inv xs\"\n  shows \"set (sorted_domain_raw ko xs) = fst ` set (fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sorted_domain_raw ko xs) = fst ` set (fst xs)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. set (sorted_domain_raw ko xs) = fst ` set (fst xs)", "by (simp add: sorted_domain_raw_def set_sort_oalist_aux)"], ["", "corollary in_sorted_domain_raw_iff_lookup_raw:\n  assumes \"oalist_inv xs\"\n  shows \"k \\<in> set (sorted_domain_raw ko xs) \\<longleftrightarrow> (lookup_raw xs k \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> set (sorted_domain_raw ko xs)) =\n    (lookup_raw xs k \\<noteq> (0::'b))", "unfolding set_sorted_domain_raw[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> fst ` set (fst xs)) = (lookup_raw xs k \\<noteq> (0::'b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (k \\<in> fst ` set (fst xs)) = (lookup_raw xs k \\<noteq> (0::'b))", "obtain xs' ko' where xs: \"xs = (xs', ko')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko'.\n        xs = (xs', ko') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko')\n\ngoal (1 subgoal):\n 1. (k \\<in> fst ` set (fst xs)) = (lookup_raw xs k \\<noteq> (0::'b))", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show \"k \\<in> fst ` set (fst xs) \\<longleftrightarrow> (lookup_raw xs k \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. (k \\<in> fst ` set (fst xs)) = (lookup_raw xs k \\<noteq> (0::'b))", "by (simp add: xs oalist_inv_alt lookup_pair_eq_0)"], ["proof (state)\nthis:\n  (k \\<in> fst ` set (fst xs)) = (lookup_raw xs k \\<noteq> (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_sorted_domain_raw:\n  assumes \"oalist_inv xs\"\n  shows \"sorted_wrt (lt_of_key_order (rep_key_order ko)) (sorted_domain_raw ko xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (lt_of_key_order (rep_key_order ko))\n     (sorted_domain_raw ko xs)", "unfolding sorted_domain_raw_def oalist_inv_alt lt_of_key_order.rep_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (lt ko) (map fst (sort_oalist_aux ko xs))", "by (rule oalist_inv_rawD2, rule oalist_inv_raw_sort_oalist_aux, fact)"], ["", "subsubsection \\<open>@{const tl_raw}\\<close>"], ["", "lemma oalist_inv_tl_raw:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (tl_raw xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (tl_raw xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. oalist_inv (tl_raw xs)", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. oalist_inv (tl_raw xs)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv (tl_raw xs)", "unfolding xs tl_raw.simps oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (tl xs')", "by (rule oalist_inv_raw_tl)"], ["proof (state)\nthis:\n  oalist_inv (tl_raw xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_raw_tl_raw:\n  assumes \"oalist_inv xs\"\n  shows \"lookup_raw (tl_raw xs) k =\n          (if (\\<forall>k'\\<in>fst ` set (fst xs). le (snd xs) k k') then 0 else lookup_raw xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw (tl_raw xs) k =\n    (if \\<forall>k'\\<in>fst ` set (fst xs). le (snd xs) k k' then 0::'b\n     else lookup_raw xs k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_raw (tl_raw xs) k =\n    (if \\<forall>k'\\<in>fst ` set (fst xs). le (snd xs) k k' then 0::'b\n     else lookup_raw xs k)", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. lookup_raw (tl_raw xs) k =\n    (if \\<forall>k'\\<in>fst ` set (fst xs). le (snd xs) k k' then 0::'b\n     else lookup_raw xs k)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. lookup_raw (tl_raw xs) k =\n    (if \\<forall>k'\\<in>fst ` set (fst xs). le (snd xs) k k' then 0::'b\n     else lookup_raw xs k)", "by (simp add: xs lookup_pair_tl oalist_inv_alt split del: if_split cong: if_cong)"], ["proof (state)\nthis:\n  lookup_raw (tl_raw xs) k =\n  (if \\<forall>k'\\<in>fst ` set (fst xs). le (snd xs) k k' then 0::'b\n   else lookup_raw xs k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_raw_tl_raw':\n  assumes \"oalist_inv xs\"\n  shows \"lookup_raw (tl_raw xs) k = (if k = fst (List.hd (fst xs)) then 0 else lookup_raw xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw (tl_raw xs) k =\n    (if k = fst (hd (fst xs)) then 0::'b else lookup_raw xs k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_raw (tl_raw xs) k =\n    (if k = fst (hd (fst xs)) then 0::'b else lookup_raw xs k)", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. lookup_raw (tl_raw xs) k =\n    (if k = fst (hd (fst xs)) then 0::'b else lookup_raw xs k)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. lookup_raw (tl_raw xs) k =\n    (if k = fst (hd (fst xs)) then 0::'b else lookup_raw xs k)", "by (simp add: xs lookup_pair_tl' oalist_inv_alt)"], ["proof (state)\nthis:\n  lookup_raw (tl_raw xs) k =\n  (if k = fst (hd (fst xs)) then 0::'b else lookup_raw xs k)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const min_key_val_raw}\\<close>"], ["", "lemma min_key_val_raw_alt:\n  assumes \"oalist_inv xs\" and \"fst xs \\<noteq> []\"\n  shows \"min_key_val_raw ko xs = List.hd (sort_oalist_aux ko xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "from assms(2)"], ["proof (chain)\npicking this:\n  fst xs \\<noteq> []", "have \"xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  fst xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> []", "by (simp add: xs)"], ["proof (state)\nthis:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "interpret ko2: comparator2 \"key_compare (rep_key_order ko)\" \"key_compare (rep_key_order ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator2 (key_compare (rep_key_order ko))\n     (key_compare (rep_key_order ox))", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ox xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox xs'", "by (simp only: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "hence set_sort: \"set (sort_oalist ko xs') = set xs'\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. set (sort_oalist ko xs') = set xs'", "by (rule ko2.set_sort_oalist)"], ["proof (state)\nthis:\n  set (sort_oalist ko xs') = set xs'\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "also"], ["proof (state)\nthis:\n  set (sort_oalist ko xs') = set xs'\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "from \\<open>xs' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  xs' \\<noteq> []", "have \"... \\<noteq> {}\""], ["proof (prove)\nusing this:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. set xs' \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  set xs' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "finally"], ["proof (chain)\npicking this:\n  set (sort_oalist ko xs') \\<noteq> {}", "have \"sort_oalist ko xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  set (sort_oalist ko xs') \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sort_oalist ko xs' \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  sort_oalist ko xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "then"], ["proof (chain)\npicking this:\n  sort_oalist ko xs' \\<noteq> []", "obtain k v xs'' where eq: \"sort_oalist ko xs' = (k, v) # xs''\""], ["proof (prove)\nusing this:\n  sort_oalist ko xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k v xs''.\n        sort_oalist ko xs' = (k, v) # xs'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust list.exhaust"], ["proof (prove)\nusing this:\n  sort_oalist ko xs' \\<noteq> []\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>k v xs''.\n        sort_oalist ko xs' = (k, v) # xs'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  sort_oalist ko xs' = (k, v) # xs''\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "hence \"(k, v) \\<in> set xs'\""], ["proof (prove)\nusing this:\n  sort_oalist ko xs' = (k, v) # xs''\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set xs'", "by (simp add: set_sort[symmetric])"], ["proof (state)\nthis:\n  (k, v) \\<in> set xs'\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "have *: \"le ko k k'\" if \"k' \\<in> fst ` set xs'\" for k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. le ko k k'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. le ko k k'", "from that"], ["proof (chain)\npicking this:\n  k' \\<in> fst ` set xs'", "have \"k' = k \\<or> k' \\<in> fst ` set xs''\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set xs'\n\ngoal (1 subgoal):\n 1. k' = k \\<or> k' \\<in> fst ` set xs''", "by (simp add: set_sort[symmetric] eq)"], ["proof (state)\nthis:\n  k' = k \\<or> k' \\<in> fst ` set xs''\n\ngoal (1 subgoal):\n 1. le ko k k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  k' = k \\<or> k' \\<in> fst ` set xs''\n\ngoal (1 subgoal):\n 1. le ko k k'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow> le ko k k'\n 2. k' \\<in> fst ` set xs'' \\<Longrightarrow> le ko k k'", "assume \"k' = k\""], ["proof (state)\nthis:\n  k' = k\n\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow> le ko k k'\n 2. k' \\<in> fst ` set xs'' \\<Longrightarrow> le ko k k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  k' = k\n\ngoal (1 subgoal):\n 1. le ko k k'", "by simp"], ["proof (state)\nthis:\n  le ko k k'\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs'' \\<Longrightarrow> le ko k k'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs'' \\<Longrightarrow> le ko k k'", "have \"oalist_inv_raw ko ((k, v) # xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw ko ((k, v) # xs'')", "unfolding eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (sort_oalist ko xs')", "by (fact oalist_inv_raw_sort_oalist)"], ["proof (state)\nthis:\n  oalist_inv_raw ko ((k, v) # xs'')\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs'' \\<Longrightarrow> le ko k k'", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ko ((k, v) # xs'')\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs'' \\<Longrightarrow> le ko k k'", "assume \"k' \\<in> fst ` set xs''\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set xs''\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs'' \\<Longrightarrow> le ko k k'", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv_raw ko ((k, v) # xs'')\n  k' \\<in> fst ` set xs''", "have \"lt ko k k'\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ko ((k, v) # xs'')\n  k' \\<in> fst ` set xs''\n\ngoal (1 subgoal):\n 1. lt ko k k'", "by (rule oalist_inv_raw_ConsD3)"], ["proof (state)\nthis:\n  lt ko k k'\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set xs'' \\<Longrightarrow> le ko k k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt ko k k'\n\ngoal (1 subgoal):\n 1. le ko k k'", "by simp"], ["proof (state)\nthis:\n  le ko k k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  le ko k k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k'59 \\<in> fst ` set xs' \\<Longrightarrow> le ko k ?k'59\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "from \\<open>xs' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  xs' \\<noteq> []", "have \"min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' \\<in> set xs'\""], ["proof (prove)\nusing this:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' \\<in> set xs'", "by (rule min_list_param_in)"], ["proof (state)\nthis:\n  min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' \\<in> set xs'\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "with \\<open>oalist_inv_raw ox xs'\\<close>"], ["proof (chain)\npicking this:\n  oalist_inv_raw ox xs'\n  min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' \\<in> set xs'", "have \"lookup_pair ox xs' (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')) =\n    snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n  min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' \\<in> set xs'\n\ngoal (1 subgoal):\n 1. lookup_pair ox xs'\n     (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')) =\n    snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')", "by (auto intro: lookup_pair_eq_valueI)"], ["proof (state)\nthis:\n  lookup_pair ox xs'\n   (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')) =\n  snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "moreover"], ["proof (state)\nthis:\n  lookup_pair ox xs'\n   (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')) =\n  snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "have 1: \"fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = k", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. le ?xa (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     k\n 2. le ?xa k\n     (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))", "from order.trans"], ["proof (chain)\npicking this:\n  \\<lbrakk>le ?x ?a ?b; le ?x ?b ?c\\<rbrakk> \\<Longrightarrow> le ?x ?a ?c", "have \"transp (\\<lambda>x y. le ko (fst x) (fst y))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>le ?x ?a ?b; le ?x ?b ?c\\<rbrakk> \\<Longrightarrow> le ?x ?a ?c\n\ngoal (1 subgoal):\n 1. transp (\\<lambda>x y. le ko (fst x) (fst y))", "by (rule transpI)"], ["proof (state)\nthis:\n  transp (\\<lambda>x y. le ko (fst x) (fst y))\n\ngoal (2 subgoals):\n 1. le ?xa (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     k\n 2. le ?xa k\n     (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))", "hence \"le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')) (fst (k, v))\""], ["proof (prove)\nusing this:\n  transp (\\<lambda>x y. le ko (fst x) (fst y))\n\ngoal (1 subgoal):\n 1. le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     (fst (k, v))", "using linear \\<open>(k, v) \\<in> set xs'\\<close>"], ["proof (prove)\nusing this:\n  transp (\\<lambda>x y. le ko (fst x) (fst y))\n  le ?xa ?x ?y \\<or> le ?xa ?y ?x\n  (k, v) \\<in> set xs'\n\ngoal (1 subgoal):\n 1. le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     (fst (k, v))", "by (rule min_list_param_minimal)"], ["proof (state)\nthis:\n  le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n   (fst (k, v))\n\ngoal (2 subgoals):\n 1. le ?xa (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     k\n 2. le ?xa k\n     (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))", "thus \"le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')) k\""], ["proof (prove)\nusing this:\n  le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n   (fst (k, v))\n\ngoal (1 subgoal):\n 1. le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')) k", "by simp"], ["proof (state)\nthis:\n  le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')) k\n\ngoal (1 subgoal):\n 1. le ko k (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. le ko k (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))", "show \"le ko k (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le ko k (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))", "by (rule *, rule imageI, fact)"], ["proof (state)\nthis:\n  le ko k (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = k\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "ultimately"], ["proof (chain)\npicking this:\n  lookup_pair ox xs'\n   (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')) =\n  snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')\n  fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = k", "have \"snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = lookup_pair ox xs' k\""], ["proof (prove)\nusing this:\n  lookup_pair ox xs'\n   (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')) =\n  snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')\n  fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = k\n\ngoal (1 subgoal):\n 1. snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') =\n    lookup_pair ox xs' k", "by simp"], ["proof (state)\nthis:\n  snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') =\n  lookup_pair ox xs' k\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "also"], ["proof (state)\nthis:\n  snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') =\n  lookup_pair ox xs' k\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "from \\<open>oalist_inv_raw ox xs'\\<close> \\<open>(k, v) \\<in> set xs'\\<close>"], ["proof (chain)\npicking this:\n  oalist_inv_raw ox xs'\n  (k, v) \\<in> set xs'", "have \"... = v\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n  (k, v) \\<in> set xs'\n\ngoal (1 subgoal):\n 1. lookup_pair ox xs' k = v", "by (rule lookup_pair_eq_valueI)"], ["proof (state)\nthis:\n  lookup_pair ox xs' k = v\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "finally"], ["proof (chain)\npicking this:\n  snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = v", "have \"snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = v\""], ["proof (prove)\nusing this:\n  snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = v\n\ngoal (1 subgoal):\n 1. snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = v", "."], ["proof (state)\nthis:\n  snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = v\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "with 1"], ["proof (chain)\npicking this:\n  fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = k\n  snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = v", "have \"min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' = (k, v)\""], ["proof (prove)\nusing this:\n  fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = k\n  snd (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs') = v\n\ngoal (1 subgoal):\n 1. min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' = (k, v)", "by auto"], ["proof (state)\nthis:\n  min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' = (k, v)\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' = (k, v)\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)", "by (simp add: xs eq)"], ["proof (state)\nthis:\n  min_key_val_raw ko xs = hd (sort_oalist_aux ko xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_key_val_raw_in:\n  assumes \"fst xs \\<noteq> []\"\n  shows \"min_key_val_raw ko xs \\<in> set (fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs \\<in> set (fst xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs \\<in> set (fst xs)", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs \\<in> set (fst xs)", "from assms"], ["proof (chain)\npicking this:\n  fst xs \\<noteq> []", "have \"xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  fst xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> []", "by (simp add: xs)"], ["proof (state)\nthis:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs \\<in> set (fst xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs \\<in> set (fst xs)", "unfolding xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_key_val_raw ko (xs', ox) \\<in> set (fst (xs', ox))", "proof (simp, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ko = ox \\<Longrightarrow> hd xs' \\<in> set xs'\n 2. ko \\<noteq> ox \\<Longrightarrow>\n    min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' \\<in> set xs'", "from \\<open>xs' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  xs' \\<noteq> []", "show \"hd xs' \\<in> set xs'\""], ["proof (prove)\nusing this:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd xs' \\<in> set xs'", "by simp"], ["proof (state)\nthis:\n  hd xs' \\<in> set xs'\n\ngoal (1 subgoal):\n 1. ko \\<noteq> ox \\<Longrightarrow>\n    min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' \\<in> set xs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ko \\<noteq> ox \\<Longrightarrow>\n    min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' \\<in> set xs'", "from \\<open>xs' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  xs' \\<noteq> []", "show \"min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' \\<in> set xs'\""], ["proof (prove)\nusing this:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' \\<in> set xs'", "by (rule min_list_param_in)"], ["proof (state)\nthis:\n  min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs' \\<in> set xs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min_key_val_raw ko xs \\<in> set (fst xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snd_min_key_val_raw:\n  assumes \"oalist_inv xs\" and \"fst xs \\<noteq> []\"\n  shows \"snd (min_key_val_raw ko xs) = lookup_raw xs (fst (min_key_val_raw ko xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (min_key_val_raw ko xs) =\n    lookup_raw xs (fst (min_key_val_raw ko xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (min_key_val_raw ko xs) =\n    lookup_raw xs (fst (min_key_val_raw ko xs))", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. snd (min_key_val_raw ko xs) =\n    lookup_raw xs (fst (min_key_val_raw ko xs))", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ox xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox xs'", "by (simp only: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. snd (min_key_val_raw ko xs) =\n    lookup_raw xs (fst (min_key_val_raw ko xs))", "from assms(2)"], ["proof (chain)\npicking this:\n  fst xs \\<noteq> []", "have \"min_key_val_raw ko xs \\<in> set (fst xs)\""], ["proof (prove)\nusing this:\n  fst xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko xs \\<in> set (fst xs)", "by (rule min_key_val_raw_in)"], ["proof (state)\nthis:\n  min_key_val_raw ko xs \\<in> set (fst xs)\n\ngoal (1 subgoal):\n 1. snd (min_key_val_raw ko xs) =\n    lookup_raw xs (fst (min_key_val_raw ko xs))", "hence *: \"min_key_val_raw ko (xs', ox) \\<in> set xs'\""], ["proof (prove)\nusing this:\n  min_key_val_raw ko xs \\<in> set (fst xs)\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko (xs', ox) \\<in> set xs'", "by (simp add: xs)"], ["proof (state)\nthis:\n  min_key_val_raw ko (xs', ox) \\<in> set xs'\n\ngoal (1 subgoal):\n 1. snd (min_key_val_raw ko xs) =\n    lookup_raw xs (fst (min_key_val_raw ko xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (min_key_val_raw ko xs) =\n    lookup_raw xs (fst (min_key_val_raw ko xs))", "unfolding xs lookup_raw.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (min_key_val_raw ko (xs', ox)) =\n    lookup_pair ox xs' (fst (min_key_val_raw ko (xs', ox)))", "by (rule HOL.sym, rule lookup_pair_eq_valueI, fact, simp add: * del: min_key_val_raw.simps)"], ["proof (state)\nthis:\n  snd (min_key_val_raw ko xs) = lookup_raw xs (fst (min_key_val_raw ko xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_key_val_raw_minimal:\n  assumes \"oalist_inv xs\" and \"z \\<in> set (fst xs)\"\n  shows \"le ko (fst (min_key_val_raw ko xs)) (fst z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le ko (fst (min_key_val_raw ko xs)) (fst z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. le ko (fst (min_key_val_raw ko xs)) (fst z)", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. le ko (fst (min_key_val_raw ko xs)) (fst z)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs\n  z \\<in> set (fst xs)", "have \"oalist_inv (xs', ox)\" and \"z \\<in> set xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n  z \\<in> set (fst xs)\n\ngoal (1 subgoal):\n 1. oalist_inv (xs', ox) &&& z \\<in> set xs'", "by (simp_all add: xs)"], ["proof (state)\nthis:\n  oalist_inv (xs', ox)\n  z \\<in> set xs'\n\ngoal (1 subgoal):\n 1. le ko (fst (min_key_val_raw ko xs)) (fst z)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. le ko (fst (min_key_val_raw ko xs)) (fst z)", "unfolding xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. le ko (fst (min_key_val_raw ko (xs', ox))) (fst z)", "proof (simp, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ko = ox \\<Longrightarrow> le ox (fst (hd xs')) (fst z)\n 2. ko \\<noteq> ox \\<Longrightarrow>\n    le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     (fst z)", "from \\<open>z \\<in> set xs'\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> set xs'", "have \"xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  z \\<in> set xs'\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs' \\<noteq> []\n\ngoal (2 subgoals):\n 1. ko = ox \\<Longrightarrow> le ox (fst (hd xs')) (fst z)\n 2. ko \\<noteq> ox \\<Longrightarrow>\n    le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     (fst z)", "then"], ["proof (chain)\npicking this:\n  xs' \\<noteq> []", "obtain k v ys where xs': \"xs' = (k, v) # ys\""], ["proof (prove)\nusing this:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k v ys.\n        xs' = (k, v) # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust list.exhaust"], ["proof (prove)\nusing this:\n  xs' \\<noteq> []\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>k v ys.\n        xs' = (k, v) # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs' = (k, v) # ys\n\ngoal (2 subgoals):\n 1. ko = ox \\<Longrightarrow> le ox (fst (hd xs')) (fst z)\n 2. ko \\<noteq> ox \\<Longrightarrow>\n    le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     (fst z)", "from \\<open>z \\<in> set xs'\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> set xs'", "have \"z = (k, v) \\<or> z \\<in> set ys\""], ["proof (prove)\nusing this:\n  z \\<in> set xs'\n\ngoal (1 subgoal):\n 1. z = (k, v) \\<or> z \\<in> set ys", "by (simp add: xs')"], ["proof (state)\nthis:\n  z = (k, v) \\<or> z \\<in> set ys\n\ngoal (2 subgoals):\n 1. ko = ox \\<Longrightarrow> le ox (fst (hd xs')) (fst z)\n 2. ko \\<noteq> ox \\<Longrightarrow>\n    le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     (fst z)", "thus \"le ox (fst (hd xs')) (fst z)\""], ["proof (prove)\nusing this:\n  z = (k, v) \\<or> z \\<in> set ys\n\ngoal (1 subgoal):\n 1. le ox (fst (hd xs')) (fst z)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z = (k, v) \\<Longrightarrow> le ox (fst (hd xs')) (fst z)\n 2. z \\<in> set ys \\<Longrightarrow> le ox (fst (hd xs')) (fst z)", "assume \"z = (k, v)\""], ["proof (state)\nthis:\n  z = (k, v)\n\ngoal (2 subgoals):\n 1. z = (k, v) \\<Longrightarrow> le ox (fst (hd xs')) (fst z)\n 2. z \\<in> set ys \\<Longrightarrow> le ox (fst (hd xs')) (fst z)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. le ox (fst (hd xs')) (fst z)", "by (simp add: xs' \\<open>z = (k, v)\\<close>)"], ["proof (state)\nthis:\n  le ox (fst (hd xs')) (fst z)\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> le ox (fst (hd xs')) (fst z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> le ox (fst (hd xs')) (fst z)", "assume \"z \\<in> set ys\""], ["proof (state)\nthis:\n  z \\<in> set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> le ox (fst (hd xs')) (fst z)", "hence \"fst z \\<in> fst ` set ys\""], ["proof (prove)\nusing this:\n  z \\<in> set ys\n\ngoal (1 subgoal):\n 1. fst z \\<in> fst ` set ys", "by fastforce"], ["proof (state)\nthis:\n  fst z \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> le ox (fst (hd xs')) (fst z)", "with \\<open>oalist_inv (xs', ox)\\<close>"], ["proof (chain)\npicking this:\n  oalist_inv (xs', ox)\n  fst z \\<in> fst ` set ys", "have \"lt ox k (fst z)\""], ["proof (prove)\nusing this:\n  oalist_inv (xs', ox)\n  fst z \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt ox k (fst z)", "unfolding xs' oalist_inv_alt lt_of_key_order.rep_eq"], ["proof (prove)\nusing this:\n  oalist_inv_raw ox ((k, v) # ys)\n  fst z \\<in> fst ` set ys\n\ngoal (1 subgoal):\n 1. lt ox k (fst z)", "by (rule oalist_inv_raw_ConsD3)"], ["proof (state)\nthis:\n  lt ox k (fst z)\n\ngoal (1 subgoal):\n 1. z \\<in> set ys \\<Longrightarrow> le ox (fst (hd xs')) (fst z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt ox k (fst z)\n\ngoal (1 subgoal):\n 1. le ox (fst (hd xs')) (fst z)", "by (simp add: xs')"], ["proof (state)\nthis:\n  le ox (fst (hd xs')) (fst z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  le ox (fst (hd xs')) (fst z)\n\ngoal (1 subgoal):\n 1. ko \\<noteq> ox \\<Longrightarrow>\n    le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     (fst z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ko \\<noteq> ox \\<Longrightarrow>\n    le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     (fst z)", "show \"le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs')) (fst z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n     (fst z)", "proof (rule min_list_param_minimal[of \"\\<lambda>x y. le ko (fst x) (fst y)\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. transp (\\<lambda>x y. le ko (fst x) (fst y))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs'; y \\<in> set xs'\\<rbrakk>\n       \\<Longrightarrow> le ko (fst x) (fst y) \\<or> le ko (fst y) (fst x)\n 3. z \\<in> set xs'", "show \"transp (\\<lambda>x y. le ko (fst x) (fst y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp (\\<lambda>x y. le ko (fst x) (fst y))", "by (metis (no_types, lifting) order.trans transpI)"], ["proof (state)\nthis:\n  transp (\\<lambda>x y. le ko (fst x) (fst y))\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs'; y \\<in> set xs'\\<rbrakk>\n       \\<Longrightarrow> le ko (fst x) (fst y) \\<or> le ko (fst y) (fst x)\n 2. z \\<in> set xs'", "qed (auto intro: \\<open>z \\<in> set xs'\\<close>)"], ["proof (state)\nthis:\n  le ko (fst (min_list_param (\\<lambda>x y. le ko (fst x) (fst y)) xs'))\n   (fst z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  le ko (fst (min_key_val_raw ko xs)) (fst z)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const filter_raw}\\<close>"], ["", "lemma oalist_inv_filter_raw:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (filter_raw P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (filter_raw P xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. oalist_inv (filter_raw P xs)", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. oalist_inv (filter_raw P xs)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv (filter_raw P xs)", "unfolding xs filter_raw.simps oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (filter P xs')", "by (rule oalist_inv_raw_filter)"], ["proof (state)\nthis:\n  oalist_inv (filter_raw P xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_raw_filter_raw:\n  assumes \"oalist_inv xs\"\n  shows \"lookup_raw (filter_raw P xs) k = (let v = lookup_raw xs k in if P (k, v) then v else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw (filter_raw P xs) k =\n    (let v = lookup_raw xs k in if P (k, v) then v else (0::'b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_raw (filter_raw P xs) k =\n    (let v = lookup_raw xs k in if P (k, v) then v else (0::'b))", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. lookup_raw (filter_raw P xs) k =\n    (let v = lookup_raw xs k in if P (k, v) then v else (0::'b))", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. lookup_raw (filter_raw P xs) k =\n    (let v = lookup_raw xs k in if P (k, v) then v else (0::'b))", "unfolding xs lookup_raw.simps filter_raw.simps oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. lookup_pair ko (filter P xs') k =\n    (let v = lookup_pair ko xs' k in if P (k, v) then v else (0::'b))", "by (rule lookup_pair_filter)"], ["proof (state)\nthis:\n  lookup_raw (filter_raw P xs) k =\n  (let v = lookup_raw xs k in if P (k, v) then v else (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const update_by_raw}\\<close>"], ["", "lemma oalist_inv_update_by_raw:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (update_by_raw kv xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (update_by_raw kv xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. oalist_inv (update_by_raw kv xs)", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. oalist_inv (update_by_raw kv xs)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv (update_by_raw kv xs)", "unfolding xs update_by_raw.simps oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (update_by_pair ko kv xs')", "by (rule oalist_inv_raw_update_by_pair)"], ["proof (state)\nthis:\n  oalist_inv (update_by_raw kv xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_raw_update_by_raw:\n  assumes \"oalist_inv xs\"\n  shows \"lookup_raw (update_by_raw (k1, v) xs) k2 = (if k1 = k2 then v else lookup_raw xs k2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw (update_by_raw (k1, v) xs) k2 =\n    (if k1 = k2 then v else lookup_raw xs k2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_raw (update_by_raw (k1, v) xs) k2 =\n    (if k1 = k2 then v else lookup_raw xs k2)", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. lookup_raw (update_by_raw (k1, v) xs) k2 =\n    (if k1 = k2 then v else lookup_raw xs k2)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. lookup_raw (update_by_raw (k1, v) xs) k2 =\n    (if k1 = k2 then v else lookup_raw xs k2)", "unfolding xs lookup_raw.simps update_by_raw.simps oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. lookup_pair ko (update_by_pair ko (k1, v) xs') k2 =\n    (if k1 = k2 then v else lookup_pair ko xs' k2)", "by (rule lookup_pair_update_by_pair)"], ["proof (state)\nthis:\n  lookup_raw (update_by_raw (k1, v) xs) k2 =\n  (if k1 = k2 then v else lookup_raw xs k2)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const update_by_fun_raw} and @{const update_by_fun_gr_raw}\\<close>"], ["", "lemma update_by_fun_raw_eq_update_by_raw:\n  assumes \"oalist_inv xs\"\n  shows \"update_by_fun_raw k f xs = update_by_raw (k, f (lookup_raw xs k)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_fun_raw k f xs = update_by_raw (k, f (lookup_raw xs k)) xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. update_by_fun_raw k f xs = update_by_raw (k, f (lookup_raw xs k)) xs", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. update_by_fun_raw k f xs = update_by_raw (k, f (lookup_raw xs k)) xs", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ko xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko xs'", "by (simp only: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. update_by_fun_raw k f xs = update_by_raw (k, f (lookup_raw xs k)) xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_fun_raw k f xs = update_by_raw (k, f (lookup_raw xs k)) xs", "unfolding xs update_by_fun_raw.simps lookup_raw.simps update_by_raw.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (update_by_fun_pair ko k f xs', ko) =\n    (update_by_pair ko (k, f (lookup_pair ko xs' k)) xs', ko)", "by (rule, rule conjI, rule update_by_fun_pair_eq_update_by_pair, fact, fact refl)"], ["proof (state)\nthis:\n  update_by_fun_raw k f xs = update_by_raw (k, f (lookup_raw xs k)) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary oalist_inv_update_by_fun_raw:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (update_by_fun_raw k f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (update_by_fun_raw k f xs)", "unfolding update_by_fun_raw_eq_update_by_raw[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (update_by_raw (k, f (lookup_raw xs k)) xs)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv (update_by_raw (k, f (lookup_raw xs k)) xs)", "by (rule oalist_inv_update_by_raw)"], ["", "corollary lookup_raw_update_by_fun_raw:\n  assumes \"oalist_inv xs\"\n  shows \"lookup_raw (update_by_fun_raw k1 f xs) k2 = (if k1 = k2 then f else id) (lookup_raw xs k2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw (update_by_fun_raw k1 f xs) k2 =\n    (if k1 = k2 then f else id) (lookup_raw xs k2)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. lookup_raw (update_by_fun_raw k1 f xs) k2 =\n    (if k1 = k2 then f else id) (lookup_raw xs k2)", "by (simp add: update_by_fun_raw_eq_update_by_raw lookup_raw_update_by_raw)"], ["", "lemma update_by_fun_gr_raw_eq_update_by_fun_raw:\n  assumes \"oalist_inv xs\"\n  shows \"update_by_fun_gr_raw k f xs = update_by_fun_raw k f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_fun_gr_raw k f xs = update_by_fun_raw k f xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. update_by_fun_gr_raw k f xs = update_by_fun_raw k f xs", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. update_by_fun_gr_raw k f xs = update_by_fun_raw k f xs", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ko xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko xs'", "by (simp only: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. update_by_fun_gr_raw k f xs = update_by_fun_raw k f xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_fun_gr_raw k f xs = update_by_fun_raw k f xs", "unfolding xs update_by_fun_raw.simps lookup_raw.simps update_by_fun_gr_raw.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (update_by_fun_gr_pair ko k f xs', ko) =\n    (update_by_fun_pair ko k f xs', ko)", "by (rule, rule conjI, rule update_by_fun_gr_pair_eq_update_by_fun_pair, fact, fact refl)"], ["proof (state)\nthis:\n  update_by_fun_gr_raw k f xs = update_by_fun_raw k f xs\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary oalist_inv_update_by_fun_gr_raw:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (update_by_fun_gr_raw k f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (update_by_fun_gr_raw k f xs)", "unfolding update_by_fun_gr_raw_eq_update_by_fun_raw[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (update_by_fun_raw k f xs)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv (update_by_fun_raw k f xs)", "by (rule oalist_inv_update_by_fun_raw)"], ["", "corollary lookup_raw_update_by_fun_gr_raw:\n  assumes \"oalist_inv xs\"\n  shows \"lookup_raw (update_by_fun_gr_raw k1 f xs) k2 = (if k1 = k2 then f else id) (lookup_raw xs k2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw (update_by_fun_gr_raw k1 f xs) k2 =\n    (if k1 = k2 then f else id) (lookup_raw xs k2)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. lookup_raw (update_by_fun_gr_raw k1 f xs) k2 =\n    (if k1 = k2 then f else id) (lookup_raw xs k2)", "by (simp add: update_by_fun_gr_raw_eq_update_by_fun_raw lookup_raw_update_by_fun_raw)"], ["", "subsubsection \\<open>@{const map_raw} and @{const map_val_raw}\\<close>"], ["", "lemma map_raw_cong:\n  assumes \"\\<And>kv. kv \\<in> set (fst xs) \\<Longrightarrow> f kv = g kv\"\n  shows \"map_raw f xs = map_raw g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_raw f xs = map_raw g xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_raw f xs = map_raw g xs", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. map_raw f xs = map_raw g xs", "from assms"], ["proof (chain)\npicking this:\n  ?kv59 \\<in> set (fst xs) \\<Longrightarrow> f ?kv59 = g ?kv59", "have \"f kv = g kv\" if \"kv \\<in> set xs'\" for kv"], ["proof (prove)\nusing this:\n  ?kv59 \\<in> set (fst xs) \\<Longrightarrow> f ?kv59 = g ?kv59\n\ngoal (1 subgoal):\n 1. f kv = g kv", "using that"], ["proof (prove)\nusing this:\n  ?kv59 \\<in> set (fst xs) \\<Longrightarrow> f ?kv59 = g ?kv59\n  kv \\<in> set xs'\n\ngoal (1 subgoal):\n 1. f kv = g kv", "by (simp add: xs)"], ["proof (state)\nthis:\n  ?kv59 \\<in> set xs' \\<Longrightarrow> f ?kv59 = g ?kv59\n\ngoal (1 subgoal):\n 1. map_raw f xs = map_raw g xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?kv59 \\<in> set xs' \\<Longrightarrow> f ?kv59 = g ?kv59\n\ngoal (1 subgoal):\n 1. map_raw f xs = map_raw g xs", "by (simp add: xs, rule map_pair_cong)"], ["proof (state)\nthis:\n  map_raw f xs = map_raw g xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_raw_subset: \"set (fst (map_raw f xs)) \\<subseteq> f ` set (fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (map_raw f xs)) \\<subseteq> f ` set (fst xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (fst (map_raw f xs)) \\<subseteq> f ` set (fst xs)", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. set (fst (map_raw f xs)) \\<subseteq> f ` set (fst xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (map_raw f xs)) \\<subseteq> f ` set (fst xs)", "by (simp add: xs map_pair_subset)"], ["proof (state)\nthis:\n  set (fst (map_raw f xs)) \\<subseteq> f ` set (fst xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_map_raw:\n  assumes \"oalist_inv xs\"\n    and \"\\<And>a b. key_compare (rep_key_order (snd xs)) (fst (f a)) (fst (f b)) = key_compare (rep_key_order (snd xs)) (fst a) (fst b)\"\n  shows \"oalist_inv (map_raw f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (map_raw f xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. oalist_inv (map_raw f xs)", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. oalist_inv (map_raw f xs)", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv (xs', ko)\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv (xs', ko)", "by (simp only: xs)"], ["proof (state)\nthis:\n  oalist_inv (xs', ko)\n\ngoal (1 subgoal):\n 1. oalist_inv (map_raw f xs)", "moreover"], ["proof (state)\nthis:\n  oalist_inv (xs', ko)\n\ngoal (1 subgoal):\n 1. oalist_inv (map_raw f xs)", "from assms(2)"], ["proof (chain)\npicking this:\n  key_compare (rep_key_order (snd xs)) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order (snd xs)) (fst ?a59) (fst ?b59)", "have \"\\<And>a b. key_compare (rep_key_order ko) (fst (f a)) (fst (f b)) = key_compare (rep_key_order ko) (fst a) (fst b)\""], ["proof (prove)\nusing this:\n  key_compare (rep_key_order (snd xs)) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order (snd xs)) (fst ?a59) (fst ?b59)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       key_compare (rep_key_order ko) (fst (f a)) (fst (f b)) =\n       key_compare (rep_key_order ko) (fst a) (fst b)", "by (simp add: xs)"], ["proof (state)\nthis:\n  key_compare (rep_key_order ko) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order ko) (fst ?a59) (fst ?b59)\n\ngoal (1 subgoal):\n 1. oalist_inv (map_raw f xs)", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv (xs', ko)\n  key_compare (rep_key_order ko) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order ko) (fst ?a59) (fst ?b59)", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv (xs', ko)\n  key_compare (rep_key_order ko) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order ko) (fst ?a59) (fst ?b59)\n\ngoal (1 subgoal):\n 1. oalist_inv (map_raw f xs)", "unfolding xs map_raw.simps oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n  key_compare (rep_key_order ko) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order ko) (fst ?a59) (fst ?b59)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (map_pair f xs')", "by (rule oalist_inv_raw_map_pair)"], ["proof (state)\nthis:\n  oalist_inv (map_raw f xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_raw_map_raw:\n  assumes \"oalist_inv xs\" and \"snd (f (k, 0)) = 0\"\n    and \"\\<And>a b. key_compare (rep_key_order (snd xs)) (fst (f a)) (fst (f b)) = key_compare (rep_key_order (snd xs)) (fst a) (fst b)\"\n  shows \"lookup_raw (map_raw f xs) (fst (f (k, v))) = snd (f (k, lookup_raw xs k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw (map_raw f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_raw xs k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_raw (map_raw f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_raw xs k))", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. lookup_raw (map_raw f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_raw xs k))", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv (xs', ko)\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv (xs', ko)", "by (simp only: xs)"], ["proof (state)\nthis:\n  oalist_inv (xs', ko)\n\ngoal (1 subgoal):\n 1. lookup_raw (map_raw f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_raw xs k))", "moreover"], ["proof (state)\nthis:\n  oalist_inv (xs', ko)\n\ngoal (1 subgoal):\n 1. lookup_raw (map_raw f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_raw xs k))", "note assms(2)"], ["proof (state)\nthis:\n  snd (f (k, 0::'b)) = (0::'c)\n\ngoal (1 subgoal):\n 1. lookup_raw (map_raw f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_raw xs k))", "moreover"], ["proof (state)\nthis:\n  snd (f (k, 0::'b)) = (0::'c)\n\ngoal (1 subgoal):\n 1. lookup_raw (map_raw f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_raw xs k))", "from assms(3)"], ["proof (chain)\npicking this:\n  key_compare (rep_key_order (snd xs)) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order (snd xs)) (fst ?a59) (fst ?b59)", "have \"\\<And>a b. key_compare (rep_key_order ko) (fst (f a)) (fst (f b)) = key_compare (rep_key_order ko) (fst a) (fst b)\""], ["proof (prove)\nusing this:\n  key_compare (rep_key_order (snd xs)) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order (snd xs)) (fst ?a59) (fst ?b59)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       key_compare (rep_key_order ko) (fst (f a)) (fst (f b)) =\n       key_compare (rep_key_order ko) (fst a) (fst b)", "by (simp add: xs)"], ["proof (state)\nthis:\n  key_compare (rep_key_order ko) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order ko) (fst ?a59) (fst ?b59)\n\ngoal (1 subgoal):\n 1. lookup_raw (map_raw f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_raw xs k))", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv (xs', ko)\n  snd (f (k, 0::'b)) = (0::'c)\n  key_compare (rep_key_order ko) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order ko) (fst ?a59) (fst ?b59)", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv (xs', ko)\n  snd (f (k, 0::'b)) = (0::'c)\n  key_compare (rep_key_order ko) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order ko) (fst ?a59) (fst ?b59)\n\ngoal (1 subgoal):\n 1. lookup_raw (map_raw f xs) (fst (f (k, v))) =\n    snd (f (k, lookup_raw xs k))", "unfolding xs lookup_raw.simps map_raw.simps oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n  snd (f (k, 0::'b)) = (0::'c)\n  key_compare (rep_key_order ko) (fst (f ?a59)) (fst (f ?b59)) =\n  key_compare (rep_key_order ko) (fst ?a59) (fst ?b59)\n\ngoal (1 subgoal):\n 1. lookup_pair ko (map_pair f xs') (fst (f (k, v))) =\n    snd (f (k, lookup_pair ko xs' k))", "by (rule lookup_pair_map_pair)"], ["proof (state)\nthis:\n  lookup_raw (map_raw f xs) (fst (f (k, v))) = snd (f (k, lookup_raw xs k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_raw_id:\n  assumes \"oalist_inv xs\"\n  shows \"map_raw id xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_raw id xs = xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_raw id xs = xs", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. map_raw id xs = xs", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ko xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko xs'", "by (simp only: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. map_raw id xs = xs", "hence \"map_pair id xs' = xs'\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. map_pair id xs' = xs'", "proof (induct xs' rule: oalist_inv_raw_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. map_pair id [] = []\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ko ((k, v) # xs); oalist_inv_raw ko xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ko k k';\n        map_pair id xs = xs\\<rbrakk>\n       \\<Longrightarrow> map_pair id ((k, v) # xs) = (k, v) # xs", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. map_pair id [] = []\n 2. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ko ((k, v) # xs); oalist_inv_raw ko xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ko k k';\n        map_pair id xs = xs\\<rbrakk>\n       \\<Longrightarrow> map_pair id ((k, v) # xs) = (k, v) # xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pair id [] = []", "by simp"], ["proof (state)\nthis:\n  map_pair id [] = []\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ko ((k, v) # xs); oalist_inv_raw ko xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ko k k';\n        map_pair id xs = xs\\<rbrakk>\n       \\<Longrightarrow> map_pair id ((k, v) # xs) = (k, v) # xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ko ((k, v) # xs); oalist_inv_raw ko xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ko k k';\n        map_pair id xs = xs\\<rbrakk>\n       \\<Longrightarrow> map_pair id ((k, v) # xs) = (k, v) # xs", "case (Cons k v xs')"], ["proof (state)\nthis:\n  oalist_inv_raw ko ((k, v) # xs')\n  oalist_inv_raw ko xs'\n  v \\<noteq> (0::'b)\n  ?k'59 \\<in> fst ` set xs' \\<Longrightarrow> lt ko k ?k'59\n  map_pair id xs' = xs'\n\ngoal (1 subgoal):\n 1. \\<And>k v xs.\n       \\<lbrakk>oalist_inv_raw ko ((k, v) # xs); oalist_inv_raw ko xs;\n        v \\<noteq> (0::'b);\n        \\<And>k'. k' \\<in> fst ` set xs \\<Longrightarrow> lt ko k k';\n        map_pair id xs = xs\\<rbrakk>\n       \\<Longrightarrow> map_pair id ((k, v) # xs) = (k, v) # xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pair id ((k, v) # xs') = (k, v) # xs'", "by (simp add: Let_def Cons(3, 5) id_def[symmetric])"], ["proof (state)\nthis:\n  map_pair id ((k, v) # xs') = (k, v) # xs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_pair id xs' = xs'\n\ngoal (1 subgoal):\n 1. map_raw id xs = xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_pair id xs' = xs'\n\ngoal (1 subgoal):\n 1. map_raw id xs = xs", "by (simp add: xs)"], ["proof (state)\nthis:\n  map_raw id xs = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_val_raw_cong:\n  assumes \"\\<And>k v. (k, v) \\<in> set (fst xs) \\<Longrightarrow> f k v = g k v\"\n  shows \"map_val_raw f xs = map_val_raw g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_val_raw f xs = map_val_raw g xs", "proof (rule map_raw_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> set (fst xs) \\<Longrightarrow>\n       (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n       (case kv of (k, v) \\<Rightarrow> (k, g k v))", "fix kv"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> set (fst xs) \\<Longrightarrow>\n       (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n       (case kv of (k, v) \\<Rightarrow> (k, g k v))", "assume \"kv \\<in> set (fst xs)\""], ["proof (state)\nthis:\n  kv \\<in> set (fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> set (fst xs) \\<Longrightarrow>\n       (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n       (case kv of (k, v) \\<Rightarrow> (k, g k v))", "moreover"], ["proof (state)\nthis:\n  kv \\<in> set (fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> set (fst xs) \\<Longrightarrow>\n       (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n       (case kv of (k, v) \\<Rightarrow> (k, g k v))", "obtain k v where \"kv = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> set (fst xs) \\<Longrightarrow>\n       (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n       (case kv of (k, v) \\<Rightarrow> (k, g k v))", "ultimately"], ["proof (chain)\npicking this:\n  kv \\<in> set (fst xs)\n  kv = (k, v)", "show \"(case kv of (k, v) \\<Rightarrow> (k, f k v)) = (case kv of (k, v) \\<Rightarrow> (k, g k v))\""], ["proof (prove)\nusing this:\n  kv \\<in> set (fst xs)\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n    (case kv of (k, v) \\<Rightarrow> (k, g k v))", "by (simp add: assms)"], ["proof (state)\nthis:\n  (case kv of (k, v) \\<Rightarrow> (k, f k v)) =\n  (case kv of (k, v) \\<Rightarrow> (k, g k v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_map_val_raw:\n  assumes \"oalist_inv xs\"\n  shows \"oalist_inv (map_val_raw f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (map_val_raw f xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. oalist_inv (map_val_raw f xs)", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. oalist_inv (map_val_raw f xs)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv (map_val_raw f xs)", "unfolding xs map_raw.simps oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (map_val_pair f xs')", "by (rule oalist_inv_raw_map_val_pair)"], ["proof (state)\nthis:\n  oalist_inv (map_val_raw f xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_raw_map_val_raw:\n  assumes \"oalist_inv xs\" and \"f k 0 = 0\"\n  shows \"lookup_raw (map_val_raw f xs) k = f k (lookup_raw xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw (map_val_raw f xs) k = f k (lookup_raw xs k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_raw (map_val_raw f xs) k = f k (lookup_raw xs k)", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. lookup_raw (map_val_raw f xs) k = f k (lookup_raw xs k)", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs\n  f k (0::'b) = (0::'c)", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n  f k (0::'b) = (0::'c)\n\ngoal (1 subgoal):\n 1. lookup_raw (map_val_raw f xs) k = f k (lookup_raw xs k)", "unfolding xs map_raw.simps lookup_raw.simps oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n  f k (0::'b) = (0::'c)\n\ngoal (1 subgoal):\n 1. lookup_pair ko (map_val_pair f xs') k = f k (lookup_pair ko xs' k)", "by (rule lookup_pair_map_val_pair)"], ["proof (state)\nthis:\n  lookup_raw (map_val_raw f xs) k = f k (lookup_raw xs k)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const map2_val_raw}\\<close>"], ["", "definition map2_val_compat' :: \"(('a, 'b::zero, 'o) oalist_raw \\<Rightarrow> ('a, 'c::zero, 'o) oalist_raw) \\<Rightarrow> bool\"\n  where \"map2_val_compat' f \\<longleftrightarrow>\n      (\\<forall>zs. (oalist_inv zs \\<longrightarrow> (oalist_inv (f zs) \\<and> snd (f zs) = snd zs \\<and> fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs))))\""], ["", "lemma map2_val_compat'I:\n  assumes \"\\<And>zs. oalist_inv zs \\<Longrightarrow> oalist_inv (f zs)\"\n    and \"\\<And>zs. oalist_inv zs \\<Longrightarrow> snd (f zs) = snd zs\"\n    and \"\\<And>zs. oalist_inv zs \\<Longrightarrow> fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)\"\n  shows \"map2_val_compat' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_compat' f", "unfolding map2_val_compat'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs.\n       oalist_inv zs \\<longrightarrow>\n       oalist_inv (f zs) \\<and>\n       snd (f zs) = snd zs \\<and>\n       fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)", "using assms"], ["proof (prove)\nusing this:\n  oalist_inv ?zs60 \\<Longrightarrow> oalist_inv (f ?zs60)\n  oalist_inv ?zs60 \\<Longrightarrow> snd (f ?zs60) = snd ?zs60\n  oalist_inv ?zs60 \\<Longrightarrow>\n  fst ` set (fst (f ?zs60)) \\<subseteq> fst ` set (fst ?zs60)\n\ngoal (1 subgoal):\n 1. \\<forall>zs.\n       oalist_inv zs \\<longrightarrow>\n       oalist_inv (f zs) \\<and>\n       snd (f zs) = snd zs \\<and>\n       fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)", "by blast"], ["", "lemma map2_val_compat'D1:\n  assumes \"map2_val_compat' f\" and \"oalist_inv zs\"\n  shows \"oalist_inv (f zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (f zs)", "using assms"], ["proof (prove)\nusing this:\n  map2_val_compat' f\n  oalist_inv zs\n\ngoal (1 subgoal):\n 1. oalist_inv (f zs)", "unfolding map2_val_compat'_def"], ["proof (prove)\nusing this:\n  \\<forall>zs.\n     oalist_inv zs \\<longrightarrow>\n     oalist_inv (f zs) \\<and>\n     snd (f zs) = snd zs \\<and>\n     fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)\n  oalist_inv zs\n\ngoal (1 subgoal):\n 1. oalist_inv (f zs)", "by blast"], ["", "lemma map2_val_compat'D2:\n  assumes \"map2_val_compat' f\" and \"oalist_inv zs\"\n  shows \"snd (f zs) = snd zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (f zs) = snd zs", "using assms"], ["proof (prove)\nusing this:\n  map2_val_compat' f\n  oalist_inv zs\n\ngoal (1 subgoal):\n 1. snd (f zs) = snd zs", "unfolding map2_val_compat'_def"], ["proof (prove)\nusing this:\n  \\<forall>zs.\n     oalist_inv zs \\<longrightarrow>\n     oalist_inv (f zs) \\<and>\n     snd (f zs) = snd zs \\<and>\n     fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)\n  oalist_inv zs\n\ngoal (1 subgoal):\n 1. snd (f zs) = snd zs", "by blast"], ["", "lemma map2_val_compat'D3:\n  assumes \"map2_val_compat' f\" and \"oalist_inv zs\"\n  shows \"fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)", "using assms"], ["proof (prove)\nusing this:\n  map2_val_compat' f\n  oalist_inv zs\n\ngoal (1 subgoal):\n 1. fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)", "unfolding map2_val_compat'_def"], ["proof (prove)\nusing this:\n  \\<forall>zs.\n     oalist_inv zs \\<longrightarrow>\n     oalist_inv (f zs) \\<and>\n     snd (f zs) = snd zs \\<and>\n     fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)\n  oalist_inv zs\n\ngoal (1 subgoal):\n 1. fst ` set (fst (f zs)) \\<subseteq> fst ` set (fst zs)", "by blast"], ["", "lemma map2_val_compat'_map_val_raw: \"map2_val_compat' (map_val_raw f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_compat' (map_val_raw f)", "proof (rule map2_val_compat'I, erule oalist_inv_map_val_raw)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow> snd (map_val_raw f zs) = snd zs\n 2. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       fst ` set (fst (map_val_raw f zs)) \\<subseteq> fst ` set (fst zs)", "fix zs::\"('a, 'b, 'o) oalist_raw\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow> snd (map_val_raw f zs) = snd zs\n 2. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       fst ` set (fst (map_val_raw f zs)) \\<subseteq> fst ` set (fst zs)", "obtain zs' ko where \"zs = (zs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>zs' ko.\n        zs = (zs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  zs = (zs', ko)\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow> snd (map_val_raw f zs) = snd zs\n 2. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       fst ` set (fst (map_val_raw f zs)) \\<subseteq> fst ` set (fst zs)", "thus \"snd (map_val_raw f zs) = snd zs\""], ["proof (prove)\nusing this:\n  zs = (zs', ko)\n\ngoal (1 subgoal):\n 1. snd (map_val_raw f zs) = snd zs", "by simp"], ["proof (state)\nthis:\n  snd (map_val_raw f zs) = snd zs\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       fst ` set (fst (map_val_raw f zs)) \\<subseteq> fst ` set (fst zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       fst ` set (fst (map_val_raw f zs)) \\<subseteq> fst ` set (fst zs)", "fix zs::\"('a, 'b, 'o) oalist_raw\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       fst ` set (fst (map_val_raw f zs)) \\<subseteq> fst ` set (fst zs)", "obtain zs' ko where zs: \"zs = (zs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>zs' ko.\n        zs = (zs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  zs = (zs', ko)\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       fst ` set (fst (map_val_raw f zs)) \\<subseteq> fst ` set (fst zs)", "show \"fst ` set (fst (map_val_raw f zs)) \\<subseteq> fst ` set (fst zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (fst (map_val_raw f zs)) \\<subseteq> fst ` set (fst zs)", "proof (simp add: zs)"], ["proof (state)\ngoal (1 subgoal):\n 1. fst ` set (map_val_pair f zs') \\<subseteq> fst ` set zs'", "from map_pair_subset"], ["proof (chain)\npicking this:\n  set (map_pair ?f ?xs) \\<subseteq> ?f ` set ?xs", "have \"fst ` set (map_val_pair f zs') \\<subseteq> fst ` (\\<lambda>(k, v). (k, f k v)) ` set zs'\""], ["proof (prove)\nusing this:\n  set (map_pair ?f ?xs) \\<subseteq> ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. fst ` set (map_val_pair f zs')\n    \\<subseteq> fst ` (\\<lambda>(k, v). (k, f k v)) ` set zs'", "by (rule image_mono)"], ["proof (state)\nthis:\n  fst ` set (map_val_pair f zs')\n  \\<subseteq> fst ` (\\<lambda>(k, v). (k, f k v)) ` set zs'\n\ngoal (1 subgoal):\n 1. fst ` set (map_val_pair f zs') \\<subseteq> fst ` set zs'", "also"], ["proof (state)\nthis:\n  fst ` set (map_val_pair f zs')\n  \\<subseteq> fst ` (\\<lambda>(k, v). (k, f k v)) ` set zs'\n\ngoal (1 subgoal):\n 1. fst ` set (map_val_pair f zs') \\<subseteq> fst ` set zs'", "have \"... = fst ` set zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` (\\<lambda>(k, v). (k, f k v)) ` set zs' = fst ` set zs'", "by force"], ["proof (state)\nthis:\n  fst ` (\\<lambda>(k, v). (k, f k v)) ` set zs' = fst ` set zs'\n\ngoal (1 subgoal):\n 1. fst ` set (map_val_pair f zs') \\<subseteq> fst ` set zs'", "finally"], ["proof (chain)\npicking this:\n  fst ` set (map_val_pair f zs') \\<subseteq> fst ` set zs'", "show \"fst ` set (map_val_pair f zs') \\<subseteq> fst ` set zs'\""], ["proof (prove)\nusing this:\n  fst ` set (map_val_pair f zs') \\<subseteq> fst ` set zs'\n\ngoal (1 subgoal):\n 1. fst ` set (map_val_pair f zs') \\<subseteq> fst ` set zs'", "."], ["proof (state)\nthis:\n  fst ` set (map_val_pair f zs') \\<subseteq> fst ` set zs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst ` set (fst (map_val_raw f zs)) \\<subseteq> fst ` set (fst zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map2_val_compat'_id: \"map2_val_compat' id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_compat' id", "by (rule map2_val_compat'I, auto)"], ["", "lemma map2_val_compat'_imp_map2_val_compat:\n  assumes \"map2_val_compat' g\"\n  shows \"map2_val_compat ko (\\<lambda>zs. fst (g (zs, ko)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_compat ko (\\<lambda>zs. fst (g (zs, ko)))", "proof (rule map2_val_compatI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       oalist_inv_raw ko (fst (g (zs, ko)))\n 2. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "fix zs::\"('a \\<times> 'b) list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       oalist_inv_raw ko (fst (g (zs, ko)))\n 2. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "assume a: \"oalist_inv_raw ko zs\""], ["proof (state)\nthis:\n  oalist_inv_raw ko zs\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       oalist_inv_raw ko (fst (g (zs, ko)))\n 2. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "hence \"oalist_inv (zs, ko)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ko zs\n\ngoal (1 subgoal):\n 1. oalist_inv (zs, ko)", "by (simp only: oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv (zs, ko)\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       oalist_inv_raw ko (fst (g (zs, ko)))\n 2. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "with assms"], ["proof (chain)\npicking this:\n  map2_val_compat' g\n  oalist_inv (zs, ko)", "have \"oalist_inv (g (zs, ko))\""], ["proof (prove)\nusing this:\n  map2_val_compat' g\n  oalist_inv (zs, ko)\n\ngoal (1 subgoal):\n 1. oalist_inv (g (zs, ko))", "by (rule map2_val_compat'D1)"], ["proof (state)\nthis:\n  oalist_inv (g (zs, ko))\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       oalist_inv_raw ko (fst (g (zs, ko)))\n 2. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "hence \"oalist_inv (fst (g (zs, ko)), snd (g (zs, ko)))\""], ["proof (prove)\nusing this:\n  oalist_inv (g (zs, ko))\n\ngoal (1 subgoal):\n 1. oalist_inv (fst (g (zs, ko)), snd (g (zs, ko)))", "by simp"], ["proof (state)\nthis:\n  oalist_inv (fst (g (zs, ko)), snd (g (zs, ko)))\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       oalist_inv_raw ko (fst (g (zs, ko)))\n 2. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "thus \"oalist_inv_raw ko (fst (g (zs, ko)))\""], ["proof (prove)\nusing this:\n  oalist_inv (fst (g (zs, ko)), snd (g (zs, ko)))\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (fst (g (zs, ko)))", "using assms a"], ["proof (prove)\nusing this:\n  oalist_inv (fst (g (zs, ko)), snd (g (zs, ko)))\n  map2_val_compat' g\n  oalist_inv_raw ko zs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko (fst (g (zs, ko)))", "by (simp add: oalist_inv_alt map2_val_compat'D2)"], ["proof (state)\nthis:\n  oalist_inv_raw ko (fst (g (zs, ko)))\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "fix zs::\"('a \\<times> 'b) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "assume a: \"oalist_inv_raw ko zs\""], ["proof (state)\nthis:\n  oalist_inv_raw ko zs\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "hence \"oalist_inv (zs, ko)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ko zs\n\ngoal (1 subgoal):\n 1. oalist_inv (zs, ko)", "by (simp only: oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv (zs, ko)\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "with assms"], ["proof (chain)\npicking this:\n  map2_val_compat' g\n  oalist_inv (zs, ko)", "have \"fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set (fst (zs, ko))\""], ["proof (prove)\nusing this:\n  map2_val_compat' g\n  oalist_inv (zs, ko)\n\ngoal (1 subgoal):\n 1. fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set (fst (zs, ko))", "by (rule map2_val_compat'D3)"], ["proof (state)\nthis:\n  fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set (fst (zs, ko))\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ko zs \\<Longrightarrow>\n       fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "thus \"fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs\""], ["proof (prove)\nusing this:\n  fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set (fst (zs, ko))\n\ngoal (1 subgoal):\n 1. fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs", "by simp"], ["proof (state)\nthis:\n  fst ` set (fst (g (zs, ko))) \\<subseteq> fst ` set zs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_inv_map2_val_raw:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n  assumes \"map2_val_compat' g\" and \"map2_val_compat' h\"\n  shows \"oalist_inv (map2_val_raw f g h xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "let ?ys = \"sort_oalist_aux ox ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ox xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox xs'", "by (simp add: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "from assms(2)"], ["proof (chain)\npicking this:\n  oalist_inv ys", "have \"oalist_inv_raw ox (sort_oalist_aux ox ys)\""], ["proof (prove)\nusing this:\n  oalist_inv ys\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox (sort_oalist_aux ox ys)", "by (rule oalist_inv_raw_sort_oalist_aux)"], ["proof (state)\nthis:\n  oalist_inv_raw ox (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ox (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "from assms(3)"], ["proof (chain)\npicking this:\n  map2_val_compat' g", "have \"map2_val_compat ko (\\<lambda>zs. fst (g (zs, ko)))\" for ko"], ["proof (prove)\nusing this:\n  map2_val_compat' g\n\ngoal (1 subgoal):\n 1. map2_val_compat ko (\\<lambda>zs. fst (g (zs, ko)))", "by (rule map2_val_compat'_imp_map2_val_compat)"], ["proof (state)\nthis:\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (g (zs, ?ko60)))\n\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "moreover"], ["proof (state)\nthis:\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (g (zs, ?ko60)))\n\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "from assms(4)"], ["proof (chain)\npicking this:\n  map2_val_compat' h", "have \"map2_val_compat ko (\\<lambda>zs. fst (h (zs, ko)))\" for ko"], ["proof (prove)\nusing this:\n  map2_val_compat' h\n\ngoal (1 subgoal):\n 1. map2_val_compat ko (\\<lambda>zs. fst (h (zs, ko)))", "by (rule map2_val_compat'_imp_map2_val_compat)"], ["proof (state)\nthis:\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (h (zs, ?ko60)))\n\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv_raw ox xs'\n  oalist_inv_raw ox (sort_oalist_aux ox ys)\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (g (zs, ?ko60)))\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (h (zs, ?ko60)))", "have \"oalist_inv_raw ox (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox))) (\\<lambda>zs. fst (h (zs, ox))) xs' ?ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n  oalist_inv_raw ox (sort_oalist_aux ox ys)\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (g (zs, ?ko60)))\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (h (zs, ?ko60)))\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox\n     (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n       (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))", "by (rule oalist_inv_raw_map2_val_pair)"], ["proof (state)\nthis:\n  oalist_inv_raw ox\n   (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))\n\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv_raw ox\n   (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))\n\ngoal (1 subgoal):\n 1. oalist_inv (map2_val_raw f g h xs ys)", "by (simp add: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv (map2_val_raw f g h xs ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_raw_map2_val_raw:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n  assumes \"map2_val_compat' g\" and \"map2_val_compat' h\"\n  assumes \"\\<And>zs. oalist_inv zs \\<Longrightarrow> g zs = map_val_raw (\\<lambda>k v. f k v 0) zs\"\n    and \"\\<And>zs. oalist_inv zs \\<Longrightarrow> h zs = map_val_raw (\\<lambda>k. f k 0) zs\"\n    and \"\\<And>k. f k 0 0 = 0\"\n  shows \"lookup_raw (map2_val_raw f g h xs ys) k0 = f k0 (lookup_raw xs k0) (lookup_raw ys k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "let ?ys = \"sort_oalist_aux ox ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ox xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox xs'", "by (simp add: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "from assms(2)"], ["proof (chain)\npicking this:\n  oalist_inv ys", "have \"oalist_inv_raw ox (sort_oalist_aux ox ys)\""], ["proof (prove)\nusing this:\n  oalist_inv ys\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox (sort_oalist_aux ox ys)", "by (rule oalist_inv_raw_sort_oalist_aux)"], ["proof (state)\nthis:\n  oalist_inv_raw ox (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ox (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "from assms(3)"], ["proof (chain)\npicking this:\n  map2_val_compat' g", "have \"map2_val_compat ko (\\<lambda>zs. fst (g (zs, ko)))\" for ko"], ["proof (prove)\nusing this:\n  map2_val_compat' g\n\ngoal (1 subgoal):\n 1. map2_val_compat ko (\\<lambda>zs. fst (g (zs, ko)))", "by (rule map2_val_compat'_imp_map2_val_compat)"], ["proof (state)\nthis:\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (g (zs, ?ko60)))\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "moreover"], ["proof (state)\nthis:\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (g (zs, ?ko60)))\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "from assms(4)"], ["proof (chain)\npicking this:\n  map2_val_compat' h", "have \"map2_val_compat ko (\\<lambda>zs. fst (h (zs, ko)))\" for ko"], ["proof (prove)\nusing this:\n  map2_val_compat' h\n\ngoal (1 subgoal):\n 1. map2_val_compat ko (\\<lambda>zs. fst (h (zs, ko)))", "by (rule map2_val_compat'_imp_map2_val_compat)"], ["proof (state)\nthis:\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (h (zs, ?ko60)))\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv_raw ox xs'\n  oalist_inv_raw ox (sort_oalist_aux ox ys)\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (g (zs, ?ko60)))\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (h (zs, ?ko60)))", "have \"lookup_pair ox (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox))) (\\<lambda>zs. fst (h (zs, ox))) xs' ?ys) k0 =\n                      f k0 (lookup_pair ox xs' k0) (lookup_pair ox ?ys k0)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n  oalist_inv_raw ox (sort_oalist_aux ox ys)\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (g (zs, ?ko60)))\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (h (zs, ?ko60)))\n\ngoal (1 subgoal):\n 1. lookup_pair ox\n     (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n       (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))\n     k0 =\n    f k0 (lookup_pair ox xs' k0) (lookup_pair ox (sort_oalist_aux ox ys) k0)", "using _ _ assms(7)"], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n  oalist_inv_raw ox (sort_oalist_aux ox ys)\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (g (zs, ?ko60)))\n  map2_val_compat ?ko60 (\\<lambda>zs. fst (h (zs, ?ko60)))\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  f ?k60 (0::'b) (0::'c) = (0::'d)\n\ngoal (1 subgoal):\n 1. lookup_pair ox\n     (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n       (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))\n     k0 =\n    f k0 (lookup_pair ox xs' k0) (lookup_pair ox (sort_oalist_aux ox ys) k0)", "proof (rule lookup_pair_map2_val_pair)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (g (zs, ox)) = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs\n 2. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "fix zs::\"('a \\<times> 'b) list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (g (zs, ox)) = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs\n 2. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "assume \"oalist_inv_raw ox zs\""], ["proof (state)\nthis:\n  oalist_inv_raw ox zs\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (g (zs, ox)) = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs\n 2. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "hence \"oalist_inv (zs, ox)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox zs\n\ngoal (1 subgoal):\n 1. oalist_inv (zs, ox)", "by (simp only: oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv (zs, ox)\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (g (zs, ox)) = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs\n 2. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "hence \"g (zs, ox) = map_val_raw (\\<lambda>k v. f k v 0) (zs, ox)\""], ["proof (prove)\nusing this:\n  oalist_inv (zs, ox)\n\ngoal (1 subgoal):\n 1. g (zs, ox) = map_val_raw (\\<lambda>k v. f k v (0::'c)) (zs, ox)", "by (rule assms(5))"], ["proof (state)\nthis:\n  g (zs, ox) = map_val_raw (\\<lambda>k v. f k v (0::'c)) (zs, ox)\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (g (zs, ox)) = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs\n 2. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "thus \"fst (g (zs, ox)) = map_val_pair (\\<lambda>k v. f k v 0) zs\""], ["proof (prove)\nusing this:\n  g (zs, ox) = map_val_raw (\\<lambda>k v. f k v (0::'c)) (zs, ox)\n\ngoal (1 subgoal):\n 1. fst (g (zs, ox)) = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs", "by simp"], ["proof (state)\nthis:\n  fst (g (zs, ox)) = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "fix zs::\"('a \\<times> 'c) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "assume \"oalist_inv_raw ox zs\""], ["proof (state)\nthis:\n  oalist_inv_raw ox zs\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "hence \"oalist_inv (zs, ox)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox zs\n\ngoal (1 subgoal):\n 1. oalist_inv (zs, ox)", "by (simp only: oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv (zs, ox)\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "hence \"h (zs, ox) = map_val_raw (\\<lambda>k. f k 0) (zs, ox)\""], ["proof (prove)\nusing this:\n  oalist_inv (zs, ox)\n\ngoal (1 subgoal):\n 1. h (zs, ox) = map_val_raw (\\<lambda>k. f k (0::'b)) (zs, ox)", "by (rule assms(6))"], ["proof (state)\nthis:\n  h (zs, ox) = map_val_raw (\\<lambda>k. f k (0::'b)) (zs, ox)\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       oalist_inv_raw ox zs \\<Longrightarrow>\n       fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "thus \"fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k 0) zs\""], ["proof (prove)\nusing this:\n  h (zs, ox) = map_val_raw (\\<lambda>k. f k (0::'b)) (zs, ox)\n\ngoal (1 subgoal):\n 1. fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "by simp"], ["proof (state)\nthis:\n  fst (h (zs, ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair ox\n   (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))\n   k0 =\n  f k0 (lookup_pair ox xs' k0) (lookup_pair ox (sort_oalist_aux ox ys) k0)\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "also"], ["proof (state)\nthis:\n  lookup_pair ox\n   (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))\n   k0 =\n  f k0 (lookup_pair ox xs' k0) (lookup_pair ox (sort_oalist_aux ox ys) k0)\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "from assms(2)"], ["proof (chain)\npicking this:\n  oalist_inv ys", "have \"... = f k0 (lookup_pair ox xs' k0) (lookup_raw ys k0)\""], ["proof (prove)\nusing this:\n  oalist_inv ys\n\ngoal (1 subgoal):\n 1. f k0 (lookup_pair ox xs' k0)\n     (lookup_pair ox (sort_oalist_aux ox ys) k0) =\n    f k0 (lookup_pair ox xs' k0) (lookup_raw ys k0)", "by (simp only: lookup_pair_sort_oalist_aux)"], ["proof (state)\nthis:\n  f k0 (lookup_pair ox xs' k0) (lookup_pair ox (sort_oalist_aux ox ys) k0) =\n  f k0 (lookup_pair ox xs' k0) (lookup_raw ys k0)\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "finally"], ["proof (chain)\npicking this:\n  lookup_pair ox\n   (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))\n   k0 =\n  f k0 (lookup_pair ox xs' k0) (lookup_raw ys k0)", "have *: \"lookup_pair ox (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox))) (\\<lambda>zs. fst (h (zs, ox))) xs' ?ys) k0 =\n                    f k0 (lookup_pair ox xs' k0) (lookup_raw ys k0)\""], ["proof (prove)\nusing this:\n  lookup_pair ox\n   (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))\n   k0 =\n  f k0 (lookup_pair ox xs' k0) (lookup_raw ys k0)\n\ngoal (1 subgoal):\n 1. lookup_pair ox\n     (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n       (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))\n     k0 =\n    f k0 (lookup_pair ox xs' k0) (lookup_raw ys k0)", "."], ["proof (state)\nthis:\n  lookup_pair ox\n   (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))\n   k0 =\n  f k0 (lookup_pair ox xs' k0) (lookup_raw ys k0)\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup_pair ox\n   (map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist_aux ox ys))\n   k0 =\n  f k0 (lookup_pair ox xs' k0) (lookup_raw ys k0)\n\ngoal (1 subgoal):\n 1. lookup_raw (map2_val_raw f g h xs ys) k0 =\n    f k0 (lookup_raw xs k0) (lookup_raw ys k0)", "by (simp add: xs)"], ["proof (state)\nthis:\n  lookup_raw (map2_val_raw f g h xs ys) k0 =\n  f k0 (lookup_raw xs k0) (lookup_raw ys k0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map2_val_raw_singleton_eq_update_by_fun_raw:\n  assumes \"oalist_inv xs\"\n  assumes \"\\<And>k x. f k x 0 = x\" and \"\\<And>zs. oalist_inv zs \\<Longrightarrow> g zs = zs\"\n    and \"\\<And>ko. h ([(k, v)], ko) = map_val_raw (\\<lambda>k. f k 0) ([(k, v)], ko)\"\n  shows \"map2_val_raw f g h xs ([(k, v)], ko) = update_by_fun_raw k (\\<lambda>x. f k x v) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_raw f g h xs ([(k, v)], ko) =\n    update_by_fun_raw k (\\<lambda>x. f k x v) xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map2_val_raw f g h xs ([(k, v)], ko) =\n    update_by_fun_raw k (\\<lambda>x. f k x v) xs", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. map2_val_raw f g h xs ([(k, v)], ko) =\n    update_by_fun_raw k (\\<lambda>x. f k x v) xs", "let ?ys = \"sort_oalist ox [(k, v)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. map2_val_raw f g h xs ([(k, v)], ko) =\n    update_by_fun_raw k (\\<lambda>x. f k x v) xs", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have inv: \"oalist_inv (xs', ox)\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv (xs', ox)", "by (simp only: xs)"], ["proof (state)\nthis:\n  oalist_inv (xs', ox)\n\ngoal (1 subgoal):\n 1. map2_val_raw f g h xs ([(k, v)], ko) =\n    update_by_fun_raw k (\\<lambda>x. f k x v) xs", "hence inv_raw: \"oalist_inv_raw ox xs'\""], ["proof (prove)\nusing this:\n  oalist_inv (xs', ox)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox xs'", "by (simp only: oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. map2_val_raw f g h xs ([(k, v)], ko) =\n    update_by_fun_raw k (\\<lambda>x. f k x v) xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_raw f g h xs ([(k, v)], ko) =\n    update_by_fun_raw k (\\<lambda>x. f k x v) xs", "proof (simp add: xs, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ox = ko \\<Longrightarrow>\n    map2_val_pair ko f (\\<lambda>zs. fst (g (zs, ko)))\n     (\\<lambda>zs. fst (h (zs, ko))) xs' [(k, v)] =\n    update_by_fun_pair ko k (\\<lambda>x. f k x v) xs'\n 2. ox \\<noteq> ko \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "assume \"ox = ko\""], ["proof (state)\nthis:\n  ox = ko\n\ngoal (2 subgoals):\n 1. ox = ko \\<Longrightarrow>\n    map2_val_pair ko f (\\<lambda>zs. fst (g (zs, ko)))\n     (\\<lambda>zs. fst (h (zs, ko))) xs' [(k, v)] =\n    update_by_fun_pair ko k (\\<lambda>x. f k x v) xs'\n 2. ox \\<noteq> ko \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "from inv_raw"], ["proof (chain)\npicking this:\n  oalist_inv_raw ox xs'", "have \"oalist_inv_raw ko xs'\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko xs'", "by (simp only: \\<open>ox = ko\\<close>)"], ["proof (state)\nthis:\n  oalist_inv_raw ko xs'\n\ngoal (2 subgoals):\n 1. ox = ko \\<Longrightarrow>\n    map2_val_pair ko f (\\<lambda>zs. fst (g (zs, ko)))\n     (\\<lambda>zs. fst (h (zs, ko))) xs' [(k, v)] =\n    update_by_fun_pair ko k (\\<lambda>x. f k x v) xs'\n 2. ox \\<noteq> ko \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "thus \"map2_val_pair ko f (\\<lambda>zs. fst (g (zs, ko))) (\\<lambda>zs. fst (h (zs, ko))) xs' [(k, v)] =\n              update_by_fun_pair ko k (\\<lambda>x. f k x v) xs'\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. map2_val_pair ko f (\\<lambda>zs. fst (g (zs, ko)))\n     (\\<lambda>zs. fst (h (zs, ko))) xs' [(k, v)] =\n    update_by_fun_pair ko k (\\<lambda>x. f k x v) xs'", "using assms(2)"], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n  f ?k60 ?x60 (0::'c) = ?x60\n\ngoal (1 subgoal):\n 1. map2_val_pair ko f (\\<lambda>zs. fst (g (zs, ko)))\n     (\\<lambda>zs. fst (h (zs, ko))) xs' [(k, v)] =\n    update_by_fun_pair ko k (\\<lambda>x. f k x v) xs'", "proof (rule map2_val_pair_singleton_eq_update_by_fun_pair)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs. oalist_inv_raw ko zs \\<Longrightarrow> fst (g (zs, ko)) = zs\n 2. fst (h ([(k, v)], ko)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "fix zs::\"('a \\<times> 'b) list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs. oalist_inv_raw ko zs \\<Longrightarrow> fst (g (zs, ko)) = zs\n 2. fst (h ([(k, v)], ko)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "assume \"oalist_inv_raw ko zs\""], ["proof (state)\nthis:\n  oalist_inv_raw ko zs\n\ngoal (2 subgoals):\n 1. \\<And>zs. oalist_inv_raw ko zs \\<Longrightarrow> fst (g (zs, ko)) = zs\n 2. fst (h ([(k, v)], ko)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "hence \"oalist_inv (zs, ko)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ko zs\n\ngoal (1 subgoal):\n 1. oalist_inv (zs, ko)", "by (simp only: oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv (zs, ko)\n\ngoal (2 subgoals):\n 1. \\<And>zs. oalist_inv_raw ko zs \\<Longrightarrow> fst (g (zs, ko)) = zs\n 2. fst (h ([(k, v)], ko)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "hence \"g (zs, ko) = (zs, ko)\""], ["proof (prove)\nusing this:\n  oalist_inv (zs, ko)\n\ngoal (1 subgoal):\n 1. g (zs, ko) = (zs, ko)", "by (rule assms(3))"], ["proof (state)\nthis:\n  g (zs, ko) = (zs, ko)\n\ngoal (2 subgoals):\n 1. \\<And>zs. oalist_inv_raw ko zs \\<Longrightarrow> fst (g (zs, ko)) = zs\n 2. fst (h ([(k, v)], ko)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "thus \"fst (g (zs, ko)) = zs\""], ["proof (prove)\nusing this:\n  g (zs, ko) = (zs, ko)\n\ngoal (1 subgoal):\n 1. fst (g (zs, ko)) = zs", "by simp"], ["proof (state)\nthis:\n  fst (g (zs, ko)) = zs\n\ngoal (1 subgoal):\n 1. fst (h ([(k, v)], ko)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (h ([(k, v)], ko)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "show \"fst (h ([(k, v)], ko)) = map_val_pair (\\<lambda>k. f k 0) [(k, v)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (h ([(k, v)], ko)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "by (simp add: assms(4))"], ["proof (state)\nthis:\n  fst (h ([(k, v)], ko)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map2_val_pair ko f (\\<lambda>zs. fst (g (zs, ko)))\n   (\\<lambda>zs. fst (h (zs, ko))) xs' [(k, v)] =\n  update_by_fun_pair ko k (\\<lambda>x. f k x v) xs'\n\ngoal (1 subgoal):\n 1. ox \\<noteq> ko \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ox \\<noteq> ko \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "show \"map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox))) (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n          update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "proof (cases \"v = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'\n 2. v \\<noteq> (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "case True"], ["proof (state)\nthis:\n  v = (0::'c)\n\ngoal (2 subgoals):\n 1. v = (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'\n 2. v \\<noteq> (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "have eq1: \"sort_oalist ox [(k, 0)] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_oalist ox [(k, 0::'d)] = []", "by (simp add: sort_oalist_def)"], ["proof (state)\nthis:\n  sort_oalist ox [(k, 0::?'d61)] = []\n\ngoal (2 subgoals):\n 1. v = (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'\n 2. v \\<noteq> (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "from inv"], ["proof (chain)\npicking this:\n  oalist_inv (xs', ox)", "have eq2: \"g (xs', ox) = (xs', ox)\""], ["proof (prove)\nusing this:\n  oalist_inv (xs', ox)\n\ngoal (1 subgoal):\n 1. g (xs', ox) = (xs', ox)", "by (rule assms(3))"], ["proof (state)\nthis:\n  g (xs', ox) = (xs', ox)\n\ngoal (2 subgoals):\n 1. v = (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'\n 2. v \\<noteq> (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "by (simp add: True eq1 eq2 assms(2) update_by_fun_pair_eq_update_by_pair[OF inv_raw],\n            rule HOL.sym, rule update_by_pair_id, fact inv_raw, fact refl)"], ["proof (state)\nthis:\n  map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n   (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n  update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "case False"], ["proof (state)\nthis:\n  v \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "hence \"oalist_inv_raw ox [(k, v)]\""], ["proof (prove)\nusing this:\n  v \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox [(k, v)]", "by (simp add: oalist_inv_raw_singleton)"], ["proof (state)\nthis:\n  oalist_inv_raw ox [(k, v)]\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "hence eq: \"sort_oalist ox [(k, v)] = [(k, v)]\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox [(k, v)]\n\ngoal (1 subgoal):\n 1. sort_oalist ox [(k, v)] = [(k, v)]", "by (rule sort_oalist_id)"], ["proof (state)\nthis:\n  sort_oalist ox [(k, v)] = [(k, v)]\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'c) \\<Longrightarrow>\n    map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' [(k, v)] =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "using inv_raw assms(2)"], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n  f ?k60 ?x60 (0::'c) = ?x60\n\ngoal (1 subgoal):\n 1. map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n     (\\<lambda>zs. fst (h (zs, ox))) xs' [(k, v)] =\n    update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'", "proof (rule map2_val_pair_singleton_eq_update_by_fun_pair)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs. oalist_inv_raw ox zs \\<Longrightarrow> fst (g (zs, ox)) = zs\n 2. fst (h ([(k, v)], ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "fix zs::\"('a \\<times> 'b) list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs. oalist_inv_raw ox zs \\<Longrightarrow> fst (g (zs, ox)) = zs\n 2. fst (h ([(k, v)], ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "assume \"oalist_inv_raw ox zs\""], ["proof (state)\nthis:\n  oalist_inv_raw ox zs\n\ngoal (2 subgoals):\n 1. \\<And>zs. oalist_inv_raw ox zs \\<Longrightarrow> fst (g (zs, ox)) = zs\n 2. fst (h ([(k, v)], ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "hence \"oalist_inv (zs, ox)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox zs\n\ngoal (1 subgoal):\n 1. oalist_inv (zs, ox)", "by (simp only: oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv (zs, ox)\n\ngoal (2 subgoals):\n 1. \\<And>zs. oalist_inv_raw ox zs \\<Longrightarrow> fst (g (zs, ox)) = zs\n 2. fst (h ([(k, v)], ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "hence \"g (zs, ox) = (zs, ox)\""], ["proof (prove)\nusing this:\n  oalist_inv (zs, ox)\n\ngoal (1 subgoal):\n 1. g (zs, ox) = (zs, ox)", "by (rule assms(3))"], ["proof (state)\nthis:\n  g (zs, ox) = (zs, ox)\n\ngoal (2 subgoals):\n 1. \\<And>zs. oalist_inv_raw ox zs \\<Longrightarrow> fst (g (zs, ox)) = zs\n 2. fst (h ([(k, v)], ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "thus \"fst (g (zs, ox)) = zs\""], ["proof (prove)\nusing this:\n  g (zs, ox) = (zs, ox)\n\ngoal (1 subgoal):\n 1. fst (g (zs, ox)) = zs", "by simp"], ["proof (state)\nthis:\n  fst (g (zs, ox)) = zs\n\ngoal (1 subgoal):\n 1. fst (h ([(k, v)], ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (h ([(k, v)], ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "show \"fst (h ([(k, v)], ox)) = map_val_pair (\\<lambda>k. f k 0) [(k, v)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (h ([(k, v)], ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]", "by (simp add: assms(4))"], ["proof (state)\nthis:\n  fst (h ([(k, v)], ox)) = map_val_pair (\\<lambda>k. f k (0::'b)) [(k, v)]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n   (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n  update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map2_val_pair ox f (\\<lambda>zs. fst (g (zs, ox)))\n   (\\<lambda>zs. fst (h (zs, ox))) xs' (sort_oalist ox [(k, v)]) =\n  update_by_fun_pair ox k (\\<lambda>x. f k x v) xs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map2_val_raw f g h xs ([(k, v)], ko) =\n  update_by_fun_raw k (\\<lambda>x. f k x v) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const lex_ord_raw}\\<close>"], ["", "lemma lex_ord_raw_EqI:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n    and \"\\<And>k. k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys) \\<Longrightarrow> f k (lookup_raw xs k) (lookup_raw ys k) = Some Eq\"\n  shows \"lex_ord_raw ko f xs ys = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_raw ko f xs ys = Some Eq", "unfolding lex_ord_raw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair ko f (sort_oalist_aux ko xs) (sort_oalist_aux ko ys) =\n    Some Eq", "by (rule lex_ord_pair_EqI, simp_all add: assms oalist_inv_raw_sort_oalist_aux lookup_pair_sort_oalist_aux set_sort_oalist_aux)"], ["", "lemma lex_ord_raw_valI:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\" and \"aux \\<noteq> Some Eq\"\n  assumes \"k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\" and \"aux = f k (lookup_raw xs k) (lookup_raw ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys) \\<Longrightarrow> lt ko k' k \\<Longrightarrow>\n              f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq\"\n  shows \"lex_ord_raw ko f xs ys = aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_raw ko f xs ys = aux", "unfolding lex_ord_raw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_ord_pair ko f (sort_oalist_aux ko xs) (sort_oalist_aux ko ys) = aux", "using oalist_inv_sort_oalist_aux[OF assms(1)] oalist_inv_raw_sort_oalist_aux[OF assms(2)] assms(3)"], ["proof (prove)\nusing this:\n  oalist_inv (sort_oalist_aux ?ko xs, ?ko)\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko ys)\n  aux \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. lex_ord_pair ko f (sort_oalist_aux ko xs) (sort_oalist_aux ko ys) = aux", "unfolding oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko xs)\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko ys)\n  aux \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. lex_ord_pair ko f (sort_oalist_aux ko xs) (sort_oalist_aux ko ys) = aux", "proof (rule lex_ord_pair_valI)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?k \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n             fst ` set (sort_oalist_aux ko ys)\n 2. aux =\n    f ?k (lookup_pair ko (sort_oalist_aux ko xs) ?k)\n     (lookup_pair ko (sort_oalist_aux ko ys) ?k)\n 3. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n        lt ko k' ?k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n                          (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                         Some Eq", "from assms(1, 2, 4)"], ["proof (chain)\npicking this:\n  oalist_inv xs\n  oalist_inv ys\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)", "show \"k \\<in> fst ` set (sort_oalist_aux ko xs) \\<union> fst ` set (sort_oalist_aux ko ys)\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n  oalist_inv ys\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n            fst ` set (sort_oalist_aux ko ys)", "by (simp add: set_sort_oalist_aux)"], ["proof (state)\nthis:\n  k \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n          fst ` set (sort_oalist_aux ko ys)\n\ngoal (2 subgoals):\n 1. aux =\n    f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n     (lookup_pair ko (sort_oalist_aux ko ys) k)\n 2. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n        lt ko k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n                          (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                         Some Eq", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. aux =\n    f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n     (lookup_pair ko (sort_oalist_aux ko ys) k)\n 2. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n        lt ko k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n                          (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                         Some Eq", "from assms(1, 2, 5)"], ["proof (chain)\npicking this:\n  oalist_inv xs\n  oalist_inv ys\n  aux = f k (lookup_raw xs k) (lookup_raw ys k)", "show \"aux = f k (lookup_pair ko (sort_oalist_aux ko xs) k) (lookup_pair ko (sort_oalist_aux ko ys) k)\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n  oalist_inv ys\n  aux = f k (lookup_raw xs k) (lookup_raw ys k)\n\ngoal (1 subgoal):\n 1. aux =\n    f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n     (lookup_pair ko (sort_oalist_aux ko ys) k)", "by (simp add: lookup_pair_sort_oalist_aux)"], ["proof (state)\nthis:\n  aux =\n  f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n   (lookup_pair ko (sort_oalist_aux ko ys) k)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n        lt ko k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n                          (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                         Some Eq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n        lt ko k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n                          (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                         Some Eq", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n        lt ko k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n                          (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                         Some Eq", "assume \"k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union> fst ` set (sort_oalist_aux ko ys)\""], ["proof (state)\nthis:\n  k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n           fst ` set (sort_oalist_aux ko ys)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n        lt ko k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n                          (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                         Some Eq", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  oalist_inv xs\n  oalist_inv ys\n  k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n           fst ` set (sort_oalist_aux ko ys)", "have \"k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n  oalist_inv ys\n  k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n           fst ` set (sort_oalist_aux ko ys)\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)", "by (simp add: set_sort_oalist_aux)"], ["proof (state)\nthis:\n  k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n        lt ko k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n                          (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                         Some Eq", "moreover"], ["proof (state)\nthis:\n  k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n        lt ko k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n                          (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                         Some Eq", "assume \"lt ko k' k\""], ["proof (state)\nthis:\n  lt ko k' k\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n        lt ko k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n                          (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                         Some Eq", "ultimately"], ["proof (chain)\npicking this:\n  k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n  lt ko k' k", "have \"f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n  lt ko k' k\n\ngoal (1 subgoal):\n 1. f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq", "by (rule assms(6))"], ["proof (state)\nthis:\n  f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n        lt ko k' k\\<rbrakk>\n       \\<Longrightarrow> f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n                          (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                         Some Eq", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  oalist_inv xs\n  oalist_inv ys\n  f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq", "show \"f k' (lookup_pair ko (sort_oalist_aux ko xs) k') (lookup_pair ko (sort_oalist_aux ko ys) k') = Some Eq\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n  oalist_inv ys\n  f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq\n\ngoal (1 subgoal):\n 1. f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n     (lookup_pair ko (sort_oalist_aux ko ys) k') =\n    Some Eq", "by (simp add: lookup_pair_sort_oalist_aux)"], ["proof (state)\nthis:\n  f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n   (lookup_pair ko (sort_oalist_aux ko ys) k') =\n  Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_ord_raw_EqD:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\" and \"lex_ord_raw ko f xs ys = Some Eq\"\n    and \"k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\"\n  shows \"f k (lookup_raw xs k) (lookup_raw ys k) = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k (lookup_raw xs k) (lookup_raw ys k) = Some Eq", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f k (lookup_raw xs k) (lookup_raw ys k) = Some Eq", "have \"f k (lookup_pair ko (sort_oalist_aux ko xs) k) (lookup_pair ko (sort_oalist_aux ko ys) k) = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n     (lookup_pair ko (sort_oalist_aux ko ys) k) =\n    Some Eq", "by (rule lex_ord_pair_EqD[where f=f],\n        simp_all add: oalist_inv_raw_sort_oalist_aux assms lex_ord_raw_def[symmetric] set_sort_oalist_aux del: Un_iff)"], ["proof (state)\nthis:\n  f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n   (lookup_pair ko (sort_oalist_aux ko ys) k) =\n  Some Eq\n\ngoal (1 subgoal):\n 1. f k (lookup_raw xs k) (lookup_raw ys k) = Some Eq", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  oalist_inv xs\n  oalist_inv ys\n  f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n   (lookup_pair ko (sort_oalist_aux ko ys) k) =\n  Some Eq", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n  oalist_inv ys\n  f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n   (lookup_pair ko (sort_oalist_aux ko ys) k) =\n  Some Eq\n\ngoal (1 subgoal):\n 1. f k (lookup_raw xs k) (lookup_raw ys k) = Some Eq", "by (simp add: lookup_pair_sort_oalist_aux)"], ["proof (state)\nthis:\n  f k (lookup_raw xs k) (lookup_raw ys k) = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_ord_raw_valE:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\" and \"lex_ord_raw ko f xs ys = aux\"\n    and \"aux \\<noteq> Some Eq\"\n  obtains k where \"k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\"\n    and \"aux = f k (lookup_raw xs k) (lookup_raw ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys) \\<Longrightarrow> lt ko k' k \\<Longrightarrow>\n            f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n         aux = f k (lookup_raw xs k) (lookup_raw ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst xs) \\<union>\n                              fst ` set (fst ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw xs k') (lookup_raw ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n         aux = f k (lookup_raw xs k) (lookup_raw ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst xs) \\<union>\n                              fst ` set (fst ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw xs k') (lookup_raw ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?xs = \"sort_oalist_aux ko xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n         aux = f k (lookup_raw xs k) (lookup_raw ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst xs) \\<union>\n                              fst ` set (fst ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw xs k') (lookup_raw ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?ys = \"sort_oalist_aux ko ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n         aux = f k (lookup_raw xs k) (lookup_raw ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst xs) \\<union>\n                              fst ` set (fst ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw xs k') (lookup_raw ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(3)"], ["proof (chain)\npicking this:\n  lex_ord_raw ko f xs ys = aux", "have \"lex_ord_pair ko f ?xs ?ys = aux\""], ["proof (prove)\nusing this:\n  lex_ord_raw ko f xs ys = aux\n\ngoal (1 subgoal):\n 1. lex_ord_pair ko f (sort_oalist_aux ko xs) (sort_oalist_aux ko ys) = aux", "by (simp only: lex_ord_raw_def)"], ["proof (state)\nthis:\n  lex_ord_pair ko f (sort_oalist_aux ko xs) (sort_oalist_aux ko ys) = aux\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n         aux = f k (lookup_raw xs k) (lookup_raw ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst xs) \\<union>\n                              fst ` set (fst ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw xs k') (lookup_raw ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with oalist_inv_sort_oalist_aux[OF assms(1)] oalist_inv_sort_oalist_aux[OF assms(2)]"], ["proof (chain)\npicking this:\n  oalist_inv (sort_oalist_aux ?ko xs, ?ko)\n  oalist_inv (sort_oalist_aux ?ko ys, ?ko)\n  lex_ord_pair ko f (sort_oalist_aux ko xs) (sort_oalist_aux ko ys) = aux", "obtain k where a: \"k \\<in> fst ` set ?xs \\<union> fst ` set ?ys\"\n    and b: \"aux = f k (lookup_pair ko ?xs k) (lookup_pair ko ?ys k)\"\n    and c: \"\\<And>k'. k' \\<in> fst ` set ?xs \\<union> fst ` set ?ys \\<Longrightarrow> lt ko k' k \\<Longrightarrow>\n            f k' (lookup_pair ko ?xs k') (lookup_pair ko ?ys k') = Some Eq\""], ["proof (prove)\nusing this:\n  oalist_inv (sort_oalist_aux ?ko xs, ?ko)\n  oalist_inv (sort_oalist_aux ?ko ys, ?ko)\n  lex_ord_pair ko f (sort_oalist_aux ko xs) (sort_oalist_aux ko ys) = aux\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n         aux =\n         f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n          (lookup_pair ko (sort_oalist_aux ko ys) k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                              fst ` set (sort_oalist_aux ko ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k'\n                               (lookup_pair ko (sort_oalist_aux ko xs) k')\n                               (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(4)"], ["proof (prove)\nusing this:\n  oalist_inv (sort_oalist_aux ?ko xs, ?ko)\n  oalist_inv (sort_oalist_aux ?ko ys, ?ko)\n  lex_ord_pair ko f (sort_oalist_aux ko xs) (sort_oalist_aux ko ys) = aux\n  aux \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n         aux =\n         f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n          (lookup_pair ko (sort_oalist_aux ko ys) k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                              fst ` set (sort_oalist_aux ko ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k'\n                               (lookup_pair ko (sort_oalist_aux ko xs) k')\n                               (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding oalist_inv_alt"], ["proof (prove)\nusing this:\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko xs)\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko ys)\n  lex_ord_pair ko f (sort_oalist_aux ko xs) (sort_oalist_aux ko ys) = aux\n  aux \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                         fst ` set (sort_oalist_aux ko ys);\n         aux =\n         f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n          (lookup_pair ko (sort_oalist_aux ko ys) k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                              fst ` set (sort_oalist_aux ko ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k'\n                               (lookup_pair ko (sort_oalist_aux ko xs) k')\n                               (lookup_pair ko (sort_oalist_aux ko ys) k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule lex_ord_pair_valE, blast)"], ["proof (state)\nthis:\n  k \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n          fst ` set (sort_oalist_aux ko ys)\n  aux =\n  f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n   (lookup_pair ko (sort_oalist_aux ko ys) k)\n  \\<lbrakk>?k'60\n           \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n                 fst ` set (sort_oalist_aux ko ys);\n   lt ko ?k'60 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'60 (lookup_pair ko (sort_oalist_aux ko xs) ?k'60)\n                     (lookup_pair ko (sort_oalist_aux ko ys) ?k'60) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n         aux = f k (lookup_raw xs k) (lookup_raw ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst xs) \\<union>\n                              fst ` set (fst ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw xs k') (lookup_raw ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from a"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n          fst ` set (sort_oalist_aux ko ys)", "have \"k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n          fst ` set (sort_oalist_aux ko ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)", "by (simp add: set_sort_oalist_aux assms(1, 2))"], ["proof (state)\nthis:\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n         aux = f k (lookup_raw xs k) (lookup_raw ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst xs) \\<union>\n                              fst ` set (fst ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw xs k') (lookup_raw ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n         aux = f k (lookup_raw xs k) (lookup_raw ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst xs) \\<union>\n                              fst ` set (fst ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw xs k') (lookup_raw ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from b"], ["proof (chain)\npicking this:\n  aux =\n  f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n   (lookup_pair ko (sort_oalist_aux ko ys) k)", "have \"aux = f k (lookup_raw xs k) (lookup_raw ys k)\""], ["proof (prove)\nusing this:\n  aux =\n  f k (lookup_pair ko (sort_oalist_aux ko xs) k)\n   (lookup_pair ko (sort_oalist_aux ko ys) k)\n\ngoal (1 subgoal):\n 1. aux = f k (lookup_raw xs k) (lookup_raw ys k)", "by (simp add: lookup_pair_sort_oalist_aux assms(1, 2))"], ["proof (state)\nthis:\n  aux = f k (lookup_raw xs k) (lookup_raw ys k)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n         aux = f k (lookup_raw xs k) (lookup_raw ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst xs) \\<union>\n                              fst ` set (fst ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw xs k') (lookup_raw ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  aux = f k (lookup_raw xs k) (lookup_raw ys k)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n         aux = f k (lookup_raw xs k) (lookup_raw ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst xs) \\<union>\n                              fst ` set (fst ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw xs k') (lookup_raw ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq\"\n    if k'_in: \"k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\" and k'_less: \"lt ko k' k\" for k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq", "have \"f k' (lookup_raw xs k') (lookup_raw ys k') = f k' (lookup_pair ko ?xs k') (lookup_pair ko ?ys k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k' (lookup_raw xs k') (lookup_raw ys k') =\n    f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n     (lookup_pair ko (sort_oalist_aux ko ys) k')", "by (simp add: lookup_pair_sort_oalist_aux assms(1, 2))"], ["proof (state)\nthis:\n  f k' (lookup_raw xs k') (lookup_raw ys k') =\n  f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n   (lookup_pair ko (sort_oalist_aux ko ys) k')\n\ngoal (1 subgoal):\n 1. f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq", "also"], ["proof (state)\nthis:\n  f k' (lookup_raw xs k') (lookup_raw ys k') =\n  f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n   (lookup_pair ko (sort_oalist_aux ko ys) k')\n\ngoal (1 subgoal):\n 1. f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq", "have \"... = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n     (lookup_pair ko (sort_oalist_aux ko ys) k') =\n    Some Eq", "proof (rule c)"], ["proof (state)\ngoal (2 subgoals):\n 1. k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n             fst ` set (sort_oalist_aux ko ys)\n 2. lt ko k' k", "from k'_in"], ["proof (chain)\npicking this:\n  k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)", "show \"k' \\<in> fst ` set ?xs \\<union> fst ` set ?ys\""], ["proof (prove)\nusing this:\n  k' \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n             fst ` set (sort_oalist_aux ko ys)", "by (simp add:  set_sort_oalist_aux assms(1, 2))"], ["proof (state)\nthis:\n  k' \\<in> fst ` set (sort_oalist_aux ko xs) \\<union>\n           fst ` set (sort_oalist_aux ko ys)\n\ngoal (1 subgoal):\n 1. lt ko k' k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lt ko k' k", "from k'_less"], ["proof (chain)\npicking this:\n  lt ko k' k", "show \"lt ko k' k\""], ["proof (prove)\nusing this:\n  lt ko k' k\n\ngoal (1 subgoal):\n 1. lt ko k' k", "by (simp only: lt_of_key_order.rep_eq)"], ["proof (state)\nthis:\n  lt ko k' k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f k' (lookup_pair ko (sort_oalist_aux ko xs) k')\n   (lookup_pair ko (sort_oalist_aux ko ys) k') =\n  Some Eq\n\ngoal (1 subgoal):\n 1. f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq", "finally"], ["proof (chain)\npicking this:\n  f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq", "show ?thesis"], ["proof (prove)\nusing this:\n  f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq\n\ngoal (1 subgoal):\n 1. f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq", "."], ["proof (state)\nthis:\n  f k' (lookup_raw xs k') (lookup_raw ys k') = Some Eq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?k'60 \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n   lt ko ?k'60 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'60 (lookup_raw xs ?k'60) (lookup_raw ys ?k'60) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n         aux = f k (lookup_raw xs k) (lookup_raw ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst xs) \\<union>\n                              fst ` set (fst ys);\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw xs k') (lookup_raw ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n  aux = f k (lookup_raw xs k) (lookup_raw ys k)\n  \\<lbrakk>?k'60 \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n   lt ko ?k'60 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'60 (lookup_raw xs ?k'60) (lookup_raw ys ?k'60) =\n                    Some Eq", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n  aux = f k (lookup_raw xs k) (lookup_raw ys k)\n  \\<lbrakk>?k'60 \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys);\n   lt ko ?k'60 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'60 (lookup_raw xs ?k'60) (lookup_raw ys ?k'60) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const prod_ord_raw}\\<close>"], ["", "lemma prod_ord_rawI:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n    and \"\\<And>k. k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys) \\<Longrightarrow> P k (lookup_raw xs k) (lookup_raw ys k)\"\n  shows \"prod_ord_raw P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_ord_raw P xs ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_ord_raw P xs ys", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. prod_ord_raw P xs ys", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ox xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox xs'", "by (simp only: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. prod_ord_raw P xs ys", "hence *: \"prod_ord_pair ox P xs' (sort_oalist_aux ox ys)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. prod_ord_pair ox P xs' (sort_oalist_aux ox ys)", "using oalist_inv_raw_sort_oalist_aux"], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n  oalist_inv ?xs \\<Longrightarrow>\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko ?xs)\n\ngoal (1 subgoal):\n 1. prod_ord_pair ox P xs' (sort_oalist_aux ox ys)", "proof (rule prod_ord_pairI)"], ["proof (state)\ngoal (2 subgoals):\n 1. oalist_inv ys\n 2. \\<And>k.\n       k \\<in> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n       P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. oalist_inv ys\n 2. \\<And>k.\n       k \\<in> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n       P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)", "assume \"k \\<in> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)\""], ["proof (state)\nthis:\n  k \\<in> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)\n\ngoal (2 subgoals):\n 1. oalist_inv ys\n 2. \\<And>k.\n       k \\<in> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n       P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)", "hence \"k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)", "by (simp add: xs set_sort_oalist_aux assms(2))"], ["proof (state)\nthis:\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n\ngoal (2 subgoals):\n 1. oalist_inv ys\n 2. \\<And>k.\n       k \\<in> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n       P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)", "hence \"P k (lookup_raw xs k) (lookup_raw ys k)\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "by (rule assms(3))"], ["proof (state)\nthis:\n  P k (lookup_raw xs k) (lookup_raw ys k)\n\ngoal (2 subgoals):\n 1. oalist_inv ys\n 2. \\<And>k.\n       k \\<in> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n       P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)", "thus \"P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)\""], ["proof (prove)\nusing this:\n  P k (lookup_raw xs k) (lookup_raw ys k)\n\ngoal (1 subgoal):\n 1. P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)", "by (simp add: xs lookup_pair_sort_oalist_aux assms(2))"], ["proof (state)\nthis:\n  P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)\n\ngoal (1 subgoal):\n 1. oalist_inv ys", "qed fact"], ["proof (state)\nthis:\n  prod_ord_pair ox P xs' (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. prod_ord_raw P xs ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  prod_ord_pair ox P xs' (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. prod_ord_raw P xs ys", "by (simp add: xs)"], ["proof (state)\nthis:\n  prod_ord_raw P xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_ord_rawD:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\" and \"prod_ord_raw P xs ys\"\n    and \"k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\"\n  shows \"P k (lookup_raw xs k) (lookup_raw ys k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ox xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox xs'", "by (simp only: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "note oalist_inv_raw_sort_oalist_aux[OF assms(2)]"], ["proof (state)\nthis:\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko ys)\n\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "moreover"], ["proof (state)\nthis:\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko ys)\n\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "from assms(3)"], ["proof (chain)\npicking this:\n  prod_ord_raw P xs ys", "have \"prod_ord_pair ox P xs' (sort_oalist_aux ox ys)\""], ["proof (prove)\nusing this:\n  prod_ord_raw P xs ys\n\ngoal (1 subgoal):\n 1. prod_ord_pair ox P xs' (sort_oalist_aux ox ys)", "by (simp add: xs)"], ["proof (state)\nthis:\n  prod_ord_pair ox P xs' (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "moreover"], ["proof (state)\nthis:\n  prod_ord_pair ox P xs' (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "from assms(4)"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)", "have \"k \\<in> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)", "by (simp add: xs set_sort_oalist_aux assms(2))"], ["proof (state)\nthis:\n  k \\<in> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv_raw ox xs'\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko ys)\n  prod_ord_pair ox P xs' (sort_oalist_aux ox ys)\n  k \\<in> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)", "have *: \"P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko ys)\n  prod_ord_pair ox P xs' (sort_oalist_aux ox ys)\n  k \\<in> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)", "by (rule prod_ord_pairD)"], ["proof (state)\nthis:\n  P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)\n\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P k (lookup_pair ox xs' k) (lookup_pair ox (sort_oalist_aux ox ys) k)\n\ngoal (1 subgoal):\n 1. P k (lookup_raw xs k) (lookup_raw ys k)", "by (simp add: xs lookup_pair_sort_oalist_aux assms(2))"], ["proof (state)\nthis:\n  P k (lookup_raw xs k) (lookup_raw ys k)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary prod_ord_raw_alt:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n  shows \"prod_ord_raw P xs ys \\<longleftrightarrow>\n          (\\<forall>k\\<in>fst ` set (fst xs) \\<union> fst ` set (fst ys). P k (lookup_raw xs k) (lookup_raw ys k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_ord_raw P xs ys =\n    (\\<forall>k\\<in>fst ` set (fst xs) \\<union> fst ` set (fst ys).\n        P k (lookup_raw xs k) (lookup_raw ys k))", "using prod_ord_rawI[OF assms] prod_ord_rawD[OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>k.\n      k \\<in> fst ` set (fst xs) \\<union>\n              fst ` set (fst ys) \\<Longrightarrow>\n      ?P k (lookup_raw xs k) (lookup_raw ys k)) \\<Longrightarrow>\n  prod_ord_raw ?P xs ys\n  \\<lbrakk>prod_ord_raw ?P xs ys;\n   ?k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\\<rbrakk>\n  \\<Longrightarrow> ?P ?k (lookup_raw xs ?k) (lookup_raw ys ?k)\n\ngoal (1 subgoal):\n 1. prod_ord_raw P xs ys =\n    (\\<forall>k\\<in>fst ` set (fst xs) \\<union> fst ` set (fst ys).\n        P k (lookup_raw xs k) (lookup_raw ys k))", "by meson"], ["", "subsubsection \\<open>@{const oalist_eq_raw}\\<close>"], ["", "lemma oalist_eq_rawI:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n    and \"\\<And>k. k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys) \\<Longrightarrow> lookup_raw xs k = lookup_raw ys k\"\n  shows \"oalist_eq_raw xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_eq_raw xs ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. oalist_eq_raw xs ys", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. oalist_eq_raw xs ys", "from assms(1)"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ox xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ox xs'", "by (simp only: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. oalist_eq_raw xs ys", "hence *: \"xs' = sort_oalist_aux ox ys\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. xs' = sort_oalist_aux ox ys", "using oalist_inv_raw_sort_oalist_aux[OF assms(2)]"], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko ys)\n\ngoal (1 subgoal):\n 1. xs' = sort_oalist_aux ox ys", "proof (rule lookup_pair_inj)"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_pair ox xs' = lookup_pair ox (sort_oalist_aux ox ys)", "show \"lookup_pair ox xs' = lookup_pair ox (sort_oalist_aux ox ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ox xs' = lookup_pair ox (sort_oalist_aux ox ys)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup_pair ox xs' x = lookup_pair ox (sort_oalist_aux ox ys) x", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup_pair ox xs' x = lookup_pair ox (sort_oalist_aux ox ys) x", "show \"lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "proof (cases \"k \\<in> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<in> fst ` set xs' \\<union>\n            fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k\n 2. k \\<notin> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "case True"], ["proof (state)\nthis:\n  k \\<in> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)\n\ngoal (2 subgoals):\n 1. k \\<in> fst ` set xs' \\<union>\n            fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k\n 2. k \\<notin> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "hence \"k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)", "by (simp add: xs set_sort_oalist_aux assms(2))"], ["proof (state)\nthis:\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n\ngoal (2 subgoals):\n 1. k \\<in> fst ` set xs' \\<union>\n            fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k\n 2. k \\<notin> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "hence \"lookup_raw xs k = lookup_raw ys k\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (fst xs) \\<union> fst ` set (fst ys)\n\ngoal (1 subgoal):\n 1. lookup_raw xs k = lookup_raw ys k", "by (rule assms(3))"], ["proof (state)\nthis:\n  lookup_raw xs k = lookup_raw ys k\n\ngoal (2 subgoals):\n 1. k \\<in> fst ` set xs' \\<union>\n            fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k\n 2. k \\<notin> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup_raw xs k = lookup_raw ys k\n\ngoal (1 subgoal):\n 1. lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "by (simp add: xs lookup_pair_sort_oalist_aux assms(2))"], ["proof (state)\nthis:\n  lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "case False"], ["proof (state)\nthis:\n  k \\<notin> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "hence \"k \\<notin> fst ` set xs'\" and \"k \\<notin> fst ` set (sort_oalist_aux ox ys)\""], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set xs' \\<union> fst ` set (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set xs' &&&\n    k \\<notin> fst ` set (sort_oalist_aux ox ys)", "by simp_all"], ["proof (state)\nthis:\n  k \\<notin> fst ` set xs'\n  k \\<notin> fst ` set (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "with \\<open>oalist_inv_raw ox xs'\\<close> oalist_inv_raw_sort_oalist_aux[OF assms(2)]"], ["proof (chain)\npicking this:\n  oalist_inv_raw ox xs'\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko ys)\n  k \\<notin> fst ` set xs'\n  k \\<notin> fst ` set (sort_oalist_aux ox ys)", "have \"lookup_pair ox xs' k = 0\" and \"lookup_pair ox (sort_oalist_aux ox ys) k = 0\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ox xs'\n  oalist_inv_raw ?ko (sort_oalist_aux ?ko ys)\n  k \\<notin> fst ` set xs'\n  k \\<notin> fst ` set (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. lookup_pair ox xs' k = (0::'b) &&&\n    lookup_pair ox (sort_oalist_aux ox ys) k = (0::'b)", "by (simp_all add: lookup_pair_eq_0)"], ["proof (state)\nthis:\n  lookup_pair ox xs' k = (0::'b)\n  lookup_pair ox (sort_oalist_aux ox ys) k = (0::'b)\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set xs' \\<union>\n               fst ` set (sort_oalist_aux ox ys) \\<Longrightarrow>\n    lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup_pair ox xs' k = (0::'b)\n  lookup_pair ox (sort_oalist_aux ox ys) k = (0::'b)\n\ngoal (1 subgoal):\n 1. lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k", "by simp"], ["proof (state)\nthis:\n  lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair ox xs' k = lookup_pair ox (sort_oalist_aux ox ys) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pair ox xs' = lookup_pair ox (sort_oalist_aux ox ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs' = sort_oalist_aux ox ys\n\ngoal (1 subgoal):\n 1. oalist_eq_raw xs ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs' = sort_oalist_aux ox ys\n\ngoal (1 subgoal):\n 1. oalist_eq_raw xs ys", "by (simp add: xs)"], ["proof (state)\nthis:\n  oalist_eq_raw xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_eq_rawD:\n  assumes \"oalist_inv ys\" and \"oalist_eq_raw xs ys\"\n  shows \"lookup_raw xs = lookup_raw ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_raw xs = lookup_raw ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup_raw xs = lookup_raw ys", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. lookup_raw xs = lookup_raw ys", "from assms(2)"], ["proof (chain)\npicking this:\n  oalist_eq_raw xs ys", "have \"xs' = sort_oalist_aux ox ys\""], ["proof (prove)\nusing this:\n  oalist_eq_raw xs ys\n\ngoal (1 subgoal):\n 1. xs' = sort_oalist_aux ox ys", "by (simp add: xs)"], ["proof (state)\nthis:\n  xs' = sort_oalist_aux ox ys\n\ngoal (1 subgoal):\n 1. lookup_raw xs = lookup_raw ys", "hence \"lookup_pair ox xs' = lookup_pair ox (sort_oalist_aux ox ys)\""], ["proof (prove)\nusing this:\n  xs' = sort_oalist_aux ox ys\n\ngoal (1 subgoal):\n 1. lookup_pair ox xs' = lookup_pair ox (sort_oalist_aux ox ys)", "by simp"], ["proof (state)\nthis:\n  lookup_pair ox xs' = lookup_pair ox (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. lookup_raw xs = lookup_raw ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup_pair ox xs' = lookup_pair ox (sort_oalist_aux ox ys)\n\ngoal (1 subgoal):\n 1. lookup_raw xs = lookup_raw ys", "by (simp add: xs lookup_pair_sort_oalist_aux assms(1))"], ["proof (state)\nthis:\n  lookup_raw xs = lookup_raw ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oalist_eq_raw_alt:\n  assumes \"oalist_inv xs\" and \"oalist_inv ys\"\n  shows \"oalist_eq_raw xs ys \\<longleftrightarrow> (lookup_raw xs = lookup_raw ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_eq_raw xs ys = (lookup_raw xs = lookup_raw ys)", "using oalist_eq_rawI[OF assms] oalist_eq_rawD[OF assms(2)]"], ["proof (prove)\nusing this:\n  (\\<And>k.\n      k \\<in> fst ` set (fst xs) \\<union>\n              fst ` set (fst ys) \\<Longrightarrow>\n      lookup_raw xs k = lookup_raw ys k) \\<Longrightarrow>\n  oalist_eq_raw xs ys\n  oalist_eq_raw ?xs ys \\<Longrightarrow> lookup_raw ?xs = lookup_raw ys\n\ngoal (1 subgoal):\n 1. oalist_eq_raw xs ys = (lookup_raw xs = lookup_raw ys)", "by metis"], ["", "subsubsection \\<open>@{const sort_oalist_raw}\\<close>"], ["", "lemma oalist_inv_sort_oalist_raw: \"oalist_inv (sort_oalist_raw xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (sort_oalist_raw xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. oalist_inv (sort_oalist_raw xs)", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. oalist_inv (sort_oalist_raw xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_inv (sort_oalist_raw xs)", "by (simp add: xs oalist_inv_raw_sort_oalist oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv (sort_oalist_raw xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sort_oalist_raw_id:\n  assumes \"oalist_inv xs\"\n  shows \"sort_oalist_raw xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_oalist_raw xs = xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sort_oalist_raw xs = xs", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. sort_oalist_raw xs = xs", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "have \"oalist_inv_raw ko xs'\""], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. oalist_inv_raw ko xs'", "by (simp only: xs oalist_inv_alt)"], ["proof (state)\nthis:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. sort_oalist_raw xs = xs", "hence \"sort_oalist ko xs' = xs'\""], ["proof (prove)\nusing this:\n  oalist_inv_raw ko xs'\n\ngoal (1 subgoal):\n 1. sort_oalist ko xs' = xs'", "by (rule sort_oalist_id)"], ["proof (state)\nthis:\n  sort_oalist ko xs' = xs'\n\ngoal (1 subgoal):\n 1. sort_oalist_raw xs = xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  sort_oalist ko xs' = xs'\n\ngoal (1 subgoal):\n 1. sort_oalist_raw xs = xs", "by (simp add: xs)"], ["proof (state)\nthis:\n  sort_oalist_raw xs = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_sort_oalist_raw:\n  assumes \"distinct (map fst (fst xs))\"\n  shows \"set (fst (sort_oalist_raw xs)) = {kv. kv \\<in> set (fst xs) \\<and> snd kv \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (sort_oalist_raw xs)) =\n    {kv \\<in> set (fst xs). snd kv \\<noteq> (0::'b)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (fst (sort_oalist_raw xs)) =\n    {kv \\<in> set (fst xs). snd kv \\<noteq> (0::'b)}", "obtain xs' ko where xs: \"xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        xs = (xs', ko) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. set (fst (sort_oalist_raw xs)) =\n    {kv \\<in> set (fst xs). snd kv \\<noteq> (0::'b)}", "from assms"], ["proof (chain)\npicking this:\n  distinct (map fst (fst xs))", "have \"distinct (map fst xs')\""], ["proof (prove)\nusing this:\n  distinct (map fst (fst xs))\n\ngoal (1 subgoal):\n 1. distinct (map fst xs')", "by (simp add: xs)"], ["proof (state)\nthis:\n  distinct (map fst xs')\n\ngoal (1 subgoal):\n 1. set (fst (sort_oalist_raw xs)) =\n    {kv \\<in> set (fst xs). snd kv \\<noteq> (0::'b)}", "hence \"set (sort_oalist ko xs') = {kv \\<in> set xs'. snd kv \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  distinct (map fst xs')\n\ngoal (1 subgoal):\n 1. set (sort_oalist ko xs') = {kv \\<in> set xs'. snd kv \\<noteq> (0::'b)}", "by (rule set_sort_oalist)"], ["proof (state)\nthis:\n  set (sort_oalist ko xs') = {kv \\<in> set xs'. snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. set (fst (sort_oalist_raw xs)) =\n    {kv \\<in> set (fst xs). snd kv \\<noteq> (0::'b)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (sort_oalist ko xs') = {kv \\<in> set xs'. snd kv \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. set (fst (sort_oalist_raw xs)) =\n    {kv \\<in> set (fst xs). snd kv \\<noteq> (0::'b)}", "by (simp add: xs)"], ["proof (state)\nthis:\n  set (fst (sort_oalist_raw xs)) =\n  {kv \\<in> set (fst xs). snd kv \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* oalist_raw *)"], ["", "subsection \\<open>Fundamental Operations on One List\\<close>"], ["", "locale oalist_abstract = oalist_raw rep_key_order for rep_key_order::\"'o \\<Rightarrow> 'a key_order\" +\n  fixes list_of_oalist :: \"'x \\<Rightarrow> ('a, 'b::zero, 'o) oalist_raw\"\n  fixes oalist_of_list :: \"('a, 'b, 'o) oalist_raw \\<Rightarrow> 'x\"\n  assumes oalist_inv_list_of_oalist: \"oalist_inv (list_of_oalist x)\"\n  and list_of_oalist_of_list: \"list_of_oalist (oalist_of_list xs) = sort_oalist_raw xs\"\n  and oalist_of_list_of_oalist: \"oalist_of_list (list_of_oalist x) = x\"\nbegin"], ["", "lemma list_of_oalist_of_list_id:\n  assumes \"oalist_inv xs\"\n  shows \"list_of_oalist (oalist_of_list xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (oalist_of_list xs) = xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_oalist (oalist_of_list xs) = xs", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. list_of_oalist (oalist_of_list xs) = xs", "from assms"], ["proof (chain)\npicking this:\n  oalist_inv xs", "show ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv xs\n\ngoal (1 subgoal):\n 1. list_of_oalist (oalist_of_list xs) = xs", "by (simp add: xs list_of_oalist_of_list sort_oalist_id oalist_inv_alt)"], ["proof (state)\nthis:\n  list_of_oalist (oalist_of_list xs) = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "definition lookup :: \"'x \\<Rightarrow> 'a \\<Rightarrow> 'b\"\n  where \"lookup xs = lookup_raw (list_of_oalist xs)\""], ["", "definition sorted_domain :: \"'o \\<Rightarrow> 'x \\<Rightarrow> 'a list\"\n  where \"sorted_domain ko xs = sorted_domain_raw ko (list_of_oalist xs)\""], ["", "definition empty :: \"'o \\<Rightarrow> 'x\"\n  where \"empty ko = oalist_of_list ([], ko)\""], ["", "definition reorder :: \"'o \\<Rightarrow> 'x \\<Rightarrow> 'x\"\n  where \"reorder ko xs = oalist_of_list (sort_oalist_aux ko (list_of_oalist xs), ko)\""], ["", "definition tl :: \"'x \\<Rightarrow> 'x\"\n  where \"tl xs = oalist_of_list (tl_raw (list_of_oalist xs))\""], ["", "definition hd :: \"'x \\<Rightarrow> ('a \\<times> 'b)\"\n  where \"hd xs = List.hd (fst (list_of_oalist xs))\""], ["", "definition except_min :: \"'o \\<Rightarrow> 'x \\<Rightarrow> 'x\"\n  where \"except_min ko xs = tl (reorder ko xs)\""], ["", "definition min_key_val :: \"'o \\<Rightarrow> 'x \\<Rightarrow> ('a \\<times> 'b)\"\n  where \"min_key_val ko xs = min_key_val_raw ko (list_of_oalist xs)\""], ["", "definition insert :: \"('a \\<times> 'b) \\<Rightarrow> 'x \\<Rightarrow> 'x\"\n  where \"insert x xs = oalist_of_list (update_by_raw x (list_of_oalist xs))\""], ["", "definition update_by_fun :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> 'x \\<Rightarrow> 'x\"\n  where \"update_by_fun k f xs = oalist_of_list (update_by_fun_raw k f (list_of_oalist xs))\""], ["", "definition update_by_fun_gr :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> 'x \\<Rightarrow> 'x\"\n  where \"update_by_fun_gr k f xs = oalist_of_list (update_by_fun_gr_raw k f (list_of_oalist xs))\""], ["", "definition filter :: \"(('a \\<times> 'b) \\<Rightarrow> bool) \\<Rightarrow> 'x \\<Rightarrow> 'x\"\n  where \"filter P xs = oalist_of_list (filter_raw P (list_of_oalist xs))\""], ["", "definition map2_val_neutr :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'x \\<Rightarrow> 'x \\<Rightarrow> 'x\"\n  where \"map2_val_neutr f xs ys = oalist_of_list (map2_val_raw f id id (list_of_oalist xs) (list_of_oalist ys))\""], ["", "definition oalist_eq :: \"'x \\<Rightarrow> 'x \\<Rightarrow> bool\"\n  where \"oalist_eq xs ys = oalist_eq_raw (list_of_oalist xs) (list_of_oalist ys)\""], ["", "subsubsection \\<open>Invariant\\<close>"], ["", "lemma zero_notin_list_of_oalist: \"0 \\<notin> snd ` set (fst (list_of_oalist xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (fst (list_of_oalist xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (fst (list_of_oalist xs))", "from oalist_inv_list_of_oalist"], ["proof (chain)\npicking this:\n  oalist_inv (list_of_oalist ?x)", "have \"oalist_inv_raw (snd (list_of_oalist xs)) (fst (list_of_oalist xs))\""], ["proof (prove)\nusing this:\n  oalist_inv (list_of_oalist ?x)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (snd (list_of_oalist xs)) (fst (list_of_oalist xs))", "by (simp only: oalist_inv_def)"], ["proof (state)\nthis:\n  oalist_inv_raw (snd (list_of_oalist xs)) (fst (list_of_oalist xs))\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (fst (list_of_oalist xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv_raw (snd (list_of_oalist xs)) (fst (list_of_oalist xs))\n\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> snd ` set (fst (list_of_oalist xs))", "by (rule oalist_inv_rawD1)"], ["proof (state)\nthis:\n  (0::'b) \\<notin> snd ` set (fst (list_of_oalist xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_of_oalist_sorted: \"sorted_wrt (lt (snd (list_of_oalist xs))) (map fst (fst (list_of_oalist xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (lt (snd (list_of_oalist xs)))\n     (map fst (fst (list_of_oalist xs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt (lt (snd (list_of_oalist xs)))\n     (map fst (fst (list_of_oalist xs)))", "from oalist_inv_list_of_oalist"], ["proof (chain)\npicking this:\n  oalist_inv (list_of_oalist ?x)", "have \"oalist_inv_raw (snd (list_of_oalist xs)) (fst (list_of_oalist xs))\""], ["proof (prove)\nusing this:\n  oalist_inv (list_of_oalist ?x)\n\ngoal (1 subgoal):\n 1. oalist_inv_raw (snd (list_of_oalist xs)) (fst (list_of_oalist xs))", "by (simp only: oalist_inv_def)"], ["proof (state)\nthis:\n  oalist_inv_raw (snd (list_of_oalist xs)) (fst (list_of_oalist xs))\n\ngoal (1 subgoal):\n 1. sorted_wrt (lt (snd (list_of_oalist xs)))\n     (map fst (fst (list_of_oalist xs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  oalist_inv_raw (snd (list_of_oalist xs)) (fst (list_of_oalist xs))\n\ngoal (1 subgoal):\n 1. sorted_wrt (lt (snd (list_of_oalist xs)))\n     (map fst (fst (list_of_oalist xs)))", "by (rule oalist_inv_rawD2)"], ["proof (state)\nthis:\n  sorted_wrt (lt (snd (list_of_oalist xs)))\n   (map fst (fst (list_of_oalist xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const lookup}\\<close>"], ["", "lemma lookup_eq_value: \"v \\<noteq> 0 \\<Longrightarrow> lookup xs k = v \\<longleftrightarrow> ((k, v) \\<in> set (fst (list_of_oalist xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b) \\<Longrightarrow>\n    (lookup xs k = v) = ((k, v) \\<in> set (fst (list_of_oalist xs)))", "unfolding lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b) \\<Longrightarrow>\n    (lookup_raw (list_of_oalist xs) k = v) =\n    ((k, v) \\<in> set (fst (list_of_oalist xs)))", "using oalist_inv_list_of_oalist"], ["proof (prove)\nusing this:\n  oalist_inv (list_of_oalist ?x)\n\ngoal (1 subgoal):\n 1. v \\<noteq> (0::'b) \\<Longrightarrow>\n    (lookup_raw (list_of_oalist xs) k = v) =\n    ((k, v) \\<in> set (fst (list_of_oalist xs)))", "by (rule lookup_raw_eq_value)"], ["", "lemma lookup_eq_valueI: \"(k, v) \\<in> set (fst (list_of_oalist xs)) \\<Longrightarrow> lookup xs k = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (fst (list_of_oalist xs)) \\<Longrightarrow>\n    lookup xs k = v", "unfolding lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (fst (list_of_oalist xs)) \\<Longrightarrow>\n    lookup_raw (list_of_oalist xs) k = v", "using oalist_inv_list_of_oalist"], ["proof (prove)\nusing this:\n  oalist_inv (list_of_oalist ?x)\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (fst (list_of_oalist xs)) \\<Longrightarrow>\n    lookup_raw (list_of_oalist xs) k = v", "by (rule lookup_raw_eq_valueI)"], ["", "lemma lookup_oalist_of_list:\n  \"distinct (map fst xs) \\<Longrightarrow> lookup (oalist_of_list (xs, ko)) = lookup_dflt xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow>\n    lookup (oalist_of_list (xs, ko)) = lookup_dflt xs", "by (simp add: list_of_oalist_of_list lookup_def lookup_pair_sort_oalist')"], ["", "subsubsection \\<open>@{const sorted_domain}\\<close>"], ["", "lemma set_sorted_domain: \"set (sorted_domain ko xs) = fst ` set (fst (list_of_oalist xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sorted_domain ko xs) = fst ` set (fst (list_of_oalist xs))", "unfolding sorted_domain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sorted_domain_raw ko (list_of_oalist xs)) =\n    fst ` set (fst (list_of_oalist xs))", "using oalist_inv_list_of_oalist"], ["proof (prove)\nusing this:\n  oalist_inv (list_of_oalist ?x)\n\ngoal (1 subgoal):\n 1. set (sorted_domain_raw ko (list_of_oalist xs)) =\n    fst ` set (fst (list_of_oalist xs))", "by (rule set_sorted_domain_raw)"], ["", "lemma in_sorted_domain_iff_lookup: \"k \\<in> set (sorted_domain ko xs) \\<longleftrightarrow> (lookup xs k \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> set (sorted_domain ko xs)) = (lookup xs k \\<noteq> (0::'b))", "unfolding sorted_domain_def lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> set (sorted_domain_raw ko (list_of_oalist xs))) =\n    (lookup_raw (list_of_oalist xs) k \\<noteq> (0::'b))", "using oalist_inv_list_of_oalist"], ["proof (prove)\nusing this:\n  oalist_inv (list_of_oalist ?x)\n\ngoal (1 subgoal):\n 1. (k \\<in> set (sorted_domain_raw ko (list_of_oalist xs))) =\n    (lookup_raw (list_of_oalist xs) k \\<noteq> (0::'b))", "by (rule in_sorted_domain_raw_iff_lookup_raw)"], ["", "lemma sorted_sorted_domain: \"sorted_wrt (lt ko) (sorted_domain ko xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (lt ko) (sorted_domain ko xs)", "unfolding sorted_domain_def lt_of_key_order.rep_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (lt_of_key_order (rep_key_order ko))\n     (sorted_domain_raw ko (list_of_oalist xs))", "using oalist_inv_list_of_oalist"], ["proof (prove)\nusing this:\n  oalist_inv (list_of_oalist ?x)\n\ngoal (1 subgoal):\n 1. sorted_wrt (lt_of_key_order (rep_key_order ko))\n     (sorted_domain_raw ko (list_of_oalist xs))", "by (rule sorted_sorted_domain_raw)"], ["", "subsubsection \\<open>@{const empty} and Singletons\\<close>"], ["", "lemma list_of_oalist_empty [simp, code abstract]: \"list_of_oalist (empty ko) = ([], ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (local.empty ko) = ([], ko)", "by (simp add: empty_def sort_oalist_def list_of_oalist_of_list)"], ["", "lemma lookup_empty: \"lookup (empty ko) k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (local.empty ko) k = (0::'b)", "by (simp add: lookup_def)"], ["", "lemma lookup_oalist_of_list_single:\n  \"lookup (oalist_of_list ([(k, v)], ko)) k' = (if k = k' then v else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (oalist_of_list ([(k, v)], ko)) k' =\n    (if k = k' then v else (0::'b))", "by (simp add: lookup_def list_of_oalist_of_list sort_oalist_def key_compare_Eq split: order.split)"], ["", "subsubsection \\<open>@{const reorder}\\<close>"], ["", "lemma list_of_oalist_reorder [simp, code abstract]:\n  \"list_of_oalist (reorder ko xs) = (sort_oalist_aux ko (list_of_oalist xs), ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (reorder ko xs) =\n    (sort_oalist_aux ko (list_of_oalist xs), ko)", "unfolding reorder_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist\n     (oalist_of_list (sort_oalist_aux ko (list_of_oalist xs), ko)) =\n    (sort_oalist_aux ko (list_of_oalist xs), ko)", "by (rule list_of_oalist_of_list_id, simp add: oalist_inv_def, rule oalist_inv_raw_sort_oalist_aux, fact oalist_inv_list_of_oalist)"], ["", "lemma lookup_reorder: \"lookup (reorder ko xs) k = lookup xs k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (reorder ko xs) k = lookup xs k", "by (simp add: lookup_def lookup_pair_sort_oalist_aux oalist_inv_list_of_oalist)"], ["", "subsubsection \\<open>@{const hd} and @{const tl}\\<close>"], ["", "lemma list_of_oalist_tl [simp, code abstract]: \"list_of_oalist (tl xs) = tl_raw (list_of_oalist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (local.tl xs) = tl_raw (list_of_oalist xs)", "unfolding tl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (oalist_of_list (tl_raw (list_of_oalist xs))) =\n    tl_raw (list_of_oalist xs)", "by (rule list_of_oalist_of_list_id, rule oalist_inv_tl_raw, fact oalist_inv_list_of_oalist)"], ["", "lemma lookup_tl:\n  \"lookup (tl xs) k =\n        (if (\\<forall>k'\\<in>fst ` set (fst (list_of_oalist xs)). le (snd (list_of_oalist xs)) k k') then 0 else lookup xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (local.tl xs) k =\n    (if \\<forall>k'\\<in>fst ` set (fst (list_of_oalist xs)).\n           le (snd (list_of_oalist xs)) k k'\n     then 0::'b else lookup xs k)", "by (simp add: lookup_def lookup_raw_tl_raw oalist_inv_list_of_oalist)"], ["", "lemma hd_in:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"hd xs \\<in> set (fst (list_of_oalist xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.hd xs \\<in> set (fst (list_of_oalist xs))", "unfolding hd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.hd (fst (list_of_oalist xs)) \\<in> set (fst (list_of_oalist xs))", "using assms"], ["proof (prove)\nusing this:\n  fst (list_of_oalist xs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. list.hd (fst (list_of_oalist xs)) \\<in> set (fst (list_of_oalist xs))", "by (rule hd_in_set)"], ["", "lemma snd_hd:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"snd (hd xs) = lookup xs (fst (hd xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (local.hd xs) = lookup xs (fst (local.hd xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (local.hd xs) = lookup xs (fst (local.hd xs))", "from assms"], ["proof (chain)\npicking this:\n  fst (list_of_oalist xs) \\<noteq> []", "have *: \"hd xs \\<in> set (fst (list_of_oalist xs))\""], ["proof (prove)\nusing this:\n  fst (list_of_oalist xs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. local.hd xs \\<in> set (fst (list_of_oalist xs))", "by (rule hd_in)"], ["proof (state)\nthis:\n  local.hd xs \\<in> set (fst (list_of_oalist xs))\n\ngoal (1 subgoal):\n 1. snd (local.hd xs) = lookup xs (fst (local.hd xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (local.hd xs) = lookup xs (fst (local.hd xs))", "by (rule HOL.sym, rule lookup_eq_valueI, simp add: *)"], ["proof (state)\nthis:\n  snd (local.hd xs) = lookup xs (fst (local.hd xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_tl': \"lookup (tl xs) k = (if k = fst (hd xs) then 0 else lookup xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (local.tl xs) k =\n    (if k = fst (local.hd xs) then 0::'b else lookup xs k)", "by (simp add: lookup_def lookup_raw_tl_raw' oalist_inv_list_of_oalist hd_def)"], ["", "lemma hd_tl:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"list_of_oalist xs = ((hd xs) # (fst (list_of_oalist (tl xs))), snd (list_of_oalist (tl xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist xs =\n    (local.hd xs # fst (list_of_oalist (local.tl xs)),\n     snd (list_of_oalist (local.tl xs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_oalist xs =\n    (local.hd xs # fst (list_of_oalist (local.tl xs)),\n     snd (list_of_oalist (local.tl xs)))", "obtain xs' ko where xs: \"list_of_oalist xs = (xs', ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ko.\n        list_of_oalist xs = (xs', ko) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  list_of_oalist xs = (xs', ko)\n\ngoal (1 subgoal):\n 1. list_of_oalist xs =\n    (local.hd xs # fst (list_of_oalist (local.tl xs)),\n     snd (list_of_oalist (local.tl xs)))", "from assms"], ["proof (chain)\npicking this:\n  fst (list_of_oalist xs) \\<noteq> []", "obtain x xs'' where xs': \"xs' = x # xs''\""], ["proof (prove)\nusing this:\n  fst (list_of_oalist xs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x xs''.\n        xs' = x # xs'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding xs fst_conv"], ["proof (prove)\nusing this:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x xs''.\n        xs' = x # xs'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using list.exhaust"], ["proof (prove)\nusing this:\n  xs' \\<noteq> []\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>x xs''.\n        xs' = x # xs'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs' = x # xs''\n\ngoal (1 subgoal):\n 1. list_of_oalist xs =\n    (local.hd xs # fst (list_of_oalist (local.tl xs)),\n     snd (list_of_oalist (local.tl xs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist xs =\n    (local.hd xs # fst (list_of_oalist (local.tl xs)),\n     snd (list_of_oalist (local.tl xs)))", "by (simp add: xs xs' hd_def)"], ["proof (state)\nthis:\n  list_of_oalist xs =\n  (local.hd xs # fst (list_of_oalist (local.tl xs)),\n   snd (list_of_oalist (local.tl xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const min_key_val}\\<close>"], ["", "lemma min_key_val_alt:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"min_key_val ko xs = hd (reorder ko xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_key_val ko xs = local.hd (reorder ko xs)", "using assms oalist_inv_list_of_oalist"], ["proof (prove)\nusing this:\n  fst (list_of_oalist xs) \\<noteq> []\n  oalist_inv (list_of_oalist ?x)\n\ngoal (1 subgoal):\n 1. min_key_val ko xs = local.hd (reorder ko xs)", "by (simp add: min_key_val_def hd_def min_key_val_raw_alt)"], ["", "lemma min_key_val_in:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"min_key_val ko xs \\<in> set (fst (list_of_oalist xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_key_val ko xs \\<in> set (fst (list_of_oalist xs))", "unfolding min_key_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_key_val_raw ko (list_of_oalist xs)\n    \\<in> set (fst (list_of_oalist xs))", "using assms"], ["proof (prove)\nusing this:\n  fst (list_of_oalist xs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. min_key_val_raw ko (list_of_oalist xs)\n    \\<in> set (fst (list_of_oalist xs))", "by (rule min_key_val_raw_in)"], ["", "lemma snd_min_key_val:\n  assumes \"fst (list_of_oalist xs) \\<noteq> []\"\n  shows \"snd (min_key_val ko xs) = lookup xs (fst (min_key_val ko xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (min_key_val ko xs) = lookup xs (fst (min_key_val ko xs))", "unfolding lookup_def min_key_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (min_key_val_raw ko (list_of_oalist xs)) =\n    lookup_raw (list_of_oalist xs)\n     (fst (min_key_val_raw ko (list_of_oalist xs)))", "using oalist_inv_list_of_oalist assms"], ["proof (prove)\nusing this:\n  oalist_inv (list_of_oalist ?x)\n  fst (list_of_oalist xs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. snd (min_key_val_raw ko (list_of_oalist xs)) =\n    lookup_raw (list_of_oalist xs)\n     (fst (min_key_val_raw ko (list_of_oalist xs)))", "by (rule snd_min_key_val_raw)"], ["", "lemma min_key_val_minimal:\n  assumes \"z \\<in> set (fst (list_of_oalist xs))\"\n  shows \"le ko (fst (min_key_val ko xs)) (fst z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le ko (fst (min_key_val ko xs)) (fst z)", "unfolding min_key_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. le ko (fst (min_key_val_raw ko (list_of_oalist xs))) (fst z)", "by (rule min_key_val_raw_minimal, fact oalist_inv_list_of_oalist, fact)"], ["", "subsubsection \\<open>@{const except_min}\\<close>"], ["", "lemma list_of_oalist_except_min [simp, code abstract]:\n  \"list_of_oalist (except_min ko xs) = (List.tl (sort_oalist_aux ko (list_of_oalist xs)), ko)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (except_min ko xs) =\n    (list.tl (sort_oalist_aux ko (list_of_oalist xs)), ko)", "by (simp add: except_min_def)"], ["", "lemma except_min_Nil:\n  assumes \"fst (list_of_oalist xs) = []\"\n  shows \"fst (list_of_oalist (except_min ko xs)) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (list_of_oalist (except_min ko xs)) = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (list_of_oalist (except_min ko xs)) = []", "obtain xs' ox where eq: \"list_of_oalist xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        list_of_oalist xs = (xs', ox) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  list_of_oalist xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. fst (list_of_oalist (except_min ko xs)) = []", "from assms"], ["proof (chain)\npicking this:\n  fst (list_of_oalist xs) = []", "have \"xs' = []\""], ["proof (prove)\nusing this:\n  fst (list_of_oalist xs) = []\n\ngoal (1 subgoal):\n 1. xs' = []", "by (simp add: eq)"], ["proof (state)\nthis:\n  xs' = []\n\ngoal (1 subgoal):\n 1. fst (list_of_oalist (except_min ko xs)) = []", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (list_of_oalist (except_min ko xs)) = []", "by (simp add: eq \\<open>xs' = []\\<close> sort_oalist_def)"], ["proof (state)\nthis:\n  fst (list_of_oalist (except_min ko xs)) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_except_min:\n  \"lookup (except_min ko xs) k =\n        (if (\\<forall>k'\\<in>fst ` set (fst (list_of_oalist xs)). le ko k k') then 0 else lookup xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (except_min ko xs) k =\n    (if \\<forall>k'\\<in>fst ` set (fst (list_of_oalist xs)). le ko k k'\n     then 0::'b else lookup xs k)", "by (simp add: except_min_def lookup_tl set_sort_oalist_aux oalist_inv_list_of_oalist lookup_reorder)"], ["", "lemma lookup_except_min':\n  \"lookup (except_min ko xs) k = (if k = fst (min_key_val ko xs) then 0 else lookup xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)", "proof (cases \"fst (list_of_oalist xs) = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (list_of_oalist xs) = [] \\<Longrightarrow>\n    lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)\n 2. fst (list_of_oalist xs) \\<noteq> [] \\<Longrightarrow>\n    lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)", "case True"], ["proof (state)\nthis:\n  fst (list_of_oalist xs) = []\n\ngoal (2 subgoals):\n 1. fst (list_of_oalist xs) = [] \\<Longrightarrow>\n    lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)\n 2. fst (list_of_oalist xs) \\<noteq> [] \\<Longrightarrow>\n    lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)", "hence \"lookup xs k = 0\""], ["proof (prove)\nusing this:\n  fst (list_of_oalist xs) = []\n\ngoal (1 subgoal):\n 1. lookup xs k = (0::'b)", "by (metis empty_def lookup_empty oalist_of_list_of_oalist prod.collapse)"], ["proof (state)\nthis:\n  lookup xs k = (0::'b)\n\ngoal (2 subgoals):\n 1. fst (list_of_oalist xs) = [] \\<Longrightarrow>\n    lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)\n 2. fst (list_of_oalist xs) \\<noteq> [] \\<Longrightarrow>\n    lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup xs k = (0::'b)\n\ngoal (1 subgoal):\n 1. lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)", "by (simp add: lookup_except_min True)"], ["proof (state)\nthis:\n  lookup (except_min ko xs) k =\n  (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)\n\ngoal (1 subgoal):\n 1. fst (list_of_oalist xs) \\<noteq> [] \\<Longrightarrow>\n    lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (list_of_oalist xs) \\<noteq> [] \\<Longrightarrow>\n    lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)", "case False"], ["proof (state)\nthis:\n  fst (list_of_oalist xs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. fst (list_of_oalist xs) \\<noteq> [] \\<Longrightarrow>\n    lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst (list_of_oalist xs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. lookup (except_min ko xs) k =\n    (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)", "by (simp add: except_min_def lookup_tl' min_key_val_alt lookup_reorder)"], ["proof (state)\nthis:\n  lookup (except_min ko xs) k =\n  (if k = fst (min_key_val ko xs) then 0::'b else lookup xs k)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const insert}\\<close>"], ["", "lemma list_of_oalist_insert [simp, code abstract]:\n  \"list_of_oalist (insert x xs) = update_by_raw x (list_of_oalist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (local.insert x xs) = update_by_raw x (list_of_oalist xs)", "unfolding insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (oalist_of_list (update_by_raw x (list_of_oalist xs))) =\n    update_by_raw x (list_of_oalist xs)", "by (rule list_of_oalist_of_list_id, rule oalist_inv_update_by_raw, fact oalist_inv_list_of_oalist)"], ["", "lemma lookup_insert: \"lookup (insert (k, v) xs) k' = (if k = k' then v else lookup xs k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (local.insert (k, v) xs) k' =\n    (if k = k' then v else lookup xs k')", "by (simp add: lookup_def lookup_raw_update_by_raw oalist_inv_list_of_oalist split del: if_split cong: if_cong)"], ["", "subsubsection \\<open>@{const update_by_fun} and @{const update_by_fun_gr}\\<close>"], ["", "lemma list_of_oalist_update_by_fun [simp, code abstract]:\n  \"list_of_oalist (update_by_fun k f xs) = update_by_fun_raw k f (list_of_oalist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (update_by_fun k f xs) =\n    update_by_fun_raw k f (list_of_oalist xs)", "unfolding update_by_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist\n     (oalist_of_list (update_by_fun_raw k f (list_of_oalist xs))) =\n    update_by_fun_raw k f (list_of_oalist xs)", "by (rule list_of_oalist_of_list_id, rule oalist_inv_update_by_fun_raw, fact oalist_inv_list_of_oalist)"], ["", "lemma lookup_update_by_fun:\n  \"lookup (update_by_fun k f xs) k' = (if k = k' then f else id) (lookup xs k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (update_by_fun k f xs) k' =\n    (if k = k' then f else id) (lookup xs k')", "by (simp add: lookup_def lookup_raw_update_by_fun_raw oalist_inv_list_of_oalist split del: if_split cong: if_cong)"], ["", "lemma list_of_oalist_update_by_fun_gr [simp, code abstract]:\n  \"list_of_oalist (update_by_fun_gr k f xs) = update_by_fun_gr_raw k f (list_of_oalist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (update_by_fun_gr k f xs) =\n    update_by_fun_gr_raw k f (list_of_oalist xs)", "unfolding update_by_fun_gr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist\n     (oalist_of_list (update_by_fun_gr_raw k f (list_of_oalist xs))) =\n    update_by_fun_gr_raw k f (list_of_oalist xs)", "by (rule list_of_oalist_of_list_id, rule oalist_inv_update_by_fun_gr_raw, fact oalist_inv_list_of_oalist)"], ["", "lemma update_by_fun_gr_eq_update_by_fun: \"update_by_fun_gr = update_by_fun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_by_fun_gr = update_by_fun", "by (rule, rule, rule,\n      simp add: update_by_fun_gr_def update_by_fun_def update_by_fun_gr_raw_eq_update_by_fun_raw oalist_inv_list_of_oalist)"], ["", "subsubsection \\<open>@{const filter}\\<close>"], ["", "lemma list_of_oalist_filter [simp, code abstract]:\n  \"list_of_oalist (filter P xs) = filter_raw P (list_of_oalist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (local.filter P xs) = filter_raw P (list_of_oalist xs)", "unfolding filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (oalist_of_list (filter_raw P (list_of_oalist xs))) =\n    filter_raw P (list_of_oalist xs)", "by (rule list_of_oalist_of_list_id, rule oalist_inv_filter_raw, fact oalist_inv_list_of_oalist)"], ["", "lemma lookup_filter: \"lookup (filter P xs) k = (let v = lookup xs k in if P (k, v) then v else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (local.filter P xs) k =\n    (let v = lookup xs k in if P (k, v) then v else (0::'b))", "by (simp add: lookup_def lookup_raw_filter_raw oalist_inv_list_of_oalist)"], ["", "subsubsection \\<open>@{const map2_val_neutr}\\<close>"], ["", "lemma list_of_oalist_map2_val_neutr [simp, code abstract]:\n  \"list_of_oalist (map2_val_neutr f xs ys) = map2_val_raw f id id (list_of_oalist xs) (list_of_oalist ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (map2_val_neutr f xs ys) =\n    map2_val_raw f id id (list_of_oalist xs) (list_of_oalist ys)", "unfolding map2_val_neutr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist\n     (oalist_of_list\n       (map2_val_raw f id id (list_of_oalist xs) (list_of_oalist ys))) =\n    map2_val_raw f id id (list_of_oalist xs) (list_of_oalist ys)", "by (rule list_of_oalist_of_list_id, rule oalist_inv_map2_val_raw,\n      fact oalist_inv_list_of_oalist, fact oalist_inv_list_of_oalist,\n      fact map2_val_compat'_id, fact map2_val_compat'_id)"], ["", "lemma lookup_map2_val_neutr:\n  assumes \"\\<And>k x. f k x 0 = x\" and \"\\<And>k x. f k 0 x = x\"\n  shows \"lookup (map2_val_neutr f xs ys) k = f k (lookup xs k) (lookup ys k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (map2_val_neutr f xs ys) k = f k (lookup xs k) (lookup ys k)", "proof (simp add: lookup_def, rule lookup_raw_map2_val_raw)"], ["proof (state)\ngoal (7 subgoals):\n 1. oalist_inv (list_of_oalist xs)\n 2. oalist_inv (list_of_oalist ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' id\n 5. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k v. f k v (0::'b)) zs\n 6. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "fix zs::\"('a, 'b, 'o) oalist_raw\""], ["proof (state)\ngoal (7 subgoals):\n 1. oalist_inv (list_of_oalist xs)\n 2. oalist_inv (list_of_oalist ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' id\n 5. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k v. f k v (0::'b)) zs\n 6. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "assume \"oalist_inv zs\""], ["proof (state)\nthis:\n  oalist_inv zs\n\ngoal (7 subgoals):\n 1. oalist_inv (list_of_oalist xs)\n 2. oalist_inv (list_of_oalist ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' id\n 5. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k v. f k v (0::'b)) zs\n 6. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "thus \"id zs = map_val_raw (\\<lambda>k v. f k v 0) zs\""], ["proof (prove)\nusing this:\n  oalist_inv zs\n\ngoal (1 subgoal):\n 1. id zs = map_val_raw (\\<lambda>k v. f k v (0::'b)) zs", "by (simp add: assms(1) map_raw_id)"], ["proof (state)\nthis:\n  id zs = map_val_raw (\\<lambda>k v. f k v (0::'b)) zs\n\ngoal (6 subgoals):\n 1. oalist_inv (list_of_oalist xs)\n 2. oalist_inv (list_of_oalist ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' id\n 5. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k. f k (0::'b)) zs\n 6. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. oalist_inv (list_of_oalist xs)\n 2. oalist_inv (list_of_oalist ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' id\n 5. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k. f k (0::'b)) zs\n 6. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "fix zs::\"('a, 'b, 'o) oalist_raw\""], ["proof (state)\ngoal (6 subgoals):\n 1. oalist_inv (list_of_oalist xs)\n 2. oalist_inv (list_of_oalist ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' id\n 5. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k. f k (0::'b)) zs\n 6. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "assume \"oalist_inv zs\""], ["proof (state)\nthis:\n  oalist_inv zs\n\ngoal (6 subgoals):\n 1. oalist_inv (list_of_oalist xs)\n 2. oalist_inv (list_of_oalist ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' id\n 5. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k. f k (0::'b)) zs\n 6. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "thus \"id zs = map_val_raw (\\<lambda>k. f k 0) zs\""], ["proof (prove)\nusing this:\n  oalist_inv zs\n\ngoal (1 subgoal):\n 1. id zs = map_val_raw (\\<lambda>k. f k (0::'b)) zs", "by (simp add: assms(2) map_raw_id)"], ["proof (state)\nthis:\n  id zs = map_val_raw (\\<lambda>k. f k (0::'b)) zs\n\ngoal (5 subgoals):\n 1. oalist_inv (list_of_oalist xs)\n 2. oalist_inv (list_of_oalist ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' id\n 5. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "qed (fact oalist_inv_list_of_oalist, fact oalist_inv_list_of_oalist,\n    fact map2_val_compat'_id, fact map2_val_compat'_id, simp only: assms(1))"], ["", "subsubsection \\<open>@{const oalist_eq}\\<close>"], ["", "lemma oalist_eq_alt: \"oalist_eq xs ys \\<longleftrightarrow> (lookup xs = lookup ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_eq xs ys = (lookup xs = lookup ys)", "by (simp add: oalist_eq_def lookup_def oalist_eq_raw_alt oalist_inv_list_of_oalist)"], ["", "end"], ["", "(* oalist_abstract *)"], ["", "subsection \\<open>Fundamental Operations on Three Lists\\<close>"], ["", "locale oalist_abstract3 =\n  oalist_abstract rep_key_order list_of_oalistx oalist_of_listx +\n  oay: oalist_abstract rep_key_order list_of_oalisty oalist_of_listy +\n  oaz: oalist_abstract rep_key_order list_of_oalistz oalist_of_listz\n  for rep_key_order :: \"'o \\<Rightarrow> 'a key_order\"\n  and list_of_oalistx :: \"'x \\<Rightarrow> ('a, 'b::zero, 'o) oalist_raw\"\n  and oalist_of_listx :: \"('a, 'b, 'o) oalist_raw \\<Rightarrow> 'x\"\n  and list_of_oalisty :: \"'y \\<Rightarrow> ('a, 'c::zero, 'o) oalist_raw\"\n  and oalist_of_listy :: \"('a, 'c, 'o) oalist_raw \\<Rightarrow> 'y\"\n  and list_of_oalistz :: \"'z \\<Rightarrow> ('a, 'd::zero, 'o) oalist_raw\"\n  and oalist_of_listz :: \"('a, 'd, 'o) oalist_raw \\<Rightarrow> 'z\"\nbegin"], ["", "definition map_val :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> 'x \\<Rightarrow> 'y\"\n  where \"map_val f xs = oalist_of_listy (map_val_raw f (list_of_oalistx xs))\""], ["", "definition map2_val :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd) \\<Rightarrow> 'x \\<Rightarrow> 'y \\<Rightarrow> 'z\"\n  where \"map2_val f xs ys =\n            oalist_of_listz (map2_val_raw f (map_val_raw (\\<lambda>k b. f k b 0)) (map_val_raw (\\<lambda>k. f k 0))\n              (list_of_oalistx xs) (list_of_oalisty ys))\""], ["", "definition map2_val_rneutr :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'b) \\<Rightarrow> 'x \\<Rightarrow> 'y \\<Rightarrow> 'x\"\n  where \"map2_val_rneutr f xs ys =\n            oalist_of_listx (map2_val_raw f id (map_val_raw (\\<lambda>k. f k 0)) (list_of_oalistx xs) (list_of_oalisty ys))\""], ["", "definition lex_ord :: \"'o \\<Rightarrow> ('a \\<Rightarrow> ('b, 'c) comp_opt) \\<Rightarrow> ('x, 'y) comp_opt\"\n  where \"lex_ord ko f xs ys = lex_ord_raw ko f (list_of_oalistx xs) (list_of_oalisty ys)\""], ["", "definition prod_ord :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> 'x \\<Rightarrow> 'y \\<Rightarrow> bool\"\n  where \"prod_ord f xs ys = prod_ord_raw f (list_of_oalistx xs) (list_of_oalisty ys)\""], ["", "subsubsection \\<open>@{const map_val}\\<close>"], ["", "lemma map_val_cong:\n  assumes \"\\<And>k v. (k, v) \\<in> set (fst (list_of_oalistx xs)) \\<Longrightarrow> f k v = g k v\"\n  shows \"map_val f xs = map_val g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_val f xs = map_val g xs", "unfolding map_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_of_listy (map_val_raw f (list_of_oalistx xs)) =\n    oalist_of_listy (map_val_raw g (list_of_oalistx xs))", "by (rule arg_cong[where f=oalist_of_listy], rule map_val_raw_cong, elim assms)"], ["", "lemma list_of_oalist_map_val [simp, code abstract]:\n  \"list_of_oalisty (map_val f xs) = map_val_raw f (list_of_oalistx xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalisty (map_val f xs) = map_val_raw f (list_of_oalistx xs)", "unfolding map_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalisty (oalist_of_listy (map_val_raw f (list_of_oalistx xs))) =\n    map_val_raw f (list_of_oalistx xs)", "by (rule oay.list_of_oalist_of_list_id, rule oalist_inv_map_val_raw, fact oalist_inv_list_of_oalist)"], ["", "lemma lookup_map_val: \"f k 0 = 0 \\<Longrightarrow> oay.lookup (map_val f xs) k = f k (lookup xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k (0::'b) = (0::'c) \\<Longrightarrow>\n    oay.lookup (map_val f xs) k = f k (lookup xs k)", "by (simp add: oay.lookup_def lookup_def lookup_raw_map_val_raw oalist_inv_list_of_oalist)"], ["", "subsubsection \\<open>@{const map2_val} and @{const map2_val_rneutr}\\<close>"], ["", "lemma list_of_oalist_map2_val [simp, code abstract]:\n  \"list_of_oalistz (map2_val f xs ys) =\n      map2_val_raw f (map_val_raw (\\<lambda>k b. f k b 0)) (map_val_raw (\\<lambda>k. f k 0)) (list_of_oalistx xs) (list_of_oalisty ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalistz (map2_val f xs ys) =\n    map2_val_raw f (map_val_raw (\\<lambda>k v. f k v (0::'c)))\n     (map_val_raw (\\<lambda>k. f k (0::'b))) (list_of_oalistx xs)\n     (list_of_oalisty ys)", "unfolding map2_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalistz\n     (oalist_of_listz\n       (map2_val_raw f (map_val_raw (\\<lambda>k v. f k v (0::'c)))\n         (map_val_raw (\\<lambda>k. f k (0::'b))) (list_of_oalistx xs)\n         (list_of_oalisty ys))) =\n    map2_val_raw f (map_val_raw (\\<lambda>k v. f k v (0::'c)))\n     (map_val_raw (\\<lambda>k. f k (0::'b))) (list_of_oalistx xs)\n     (list_of_oalisty ys)", "by (rule oaz.list_of_oalist_of_list_id, rule oalist_inv_map2_val_raw,\n      fact oalist_inv_list_of_oalist, fact oay.oalist_inv_list_of_oalist,\n      fact map2_val_compat'_map_val_raw, fact map2_val_compat'_map_val_raw)"], ["", "lemma list_of_oalist_map2_val_rneutr [simp, code abstract]:\n  \"list_of_oalistx (map2_val_rneutr f xs ys) =\n      map2_val_raw f id (map_val_raw (\\<lambda>k c. f k 0 c)) (list_of_oalistx xs) (list_of_oalisty ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalistx (map2_val_rneutr f xs ys) =\n    map2_val_raw f id (map_val_raw (\\<lambda>k. f k (0::'b)))\n     (list_of_oalistx xs) (list_of_oalisty ys)", "unfolding map2_val_rneutr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalistx\n     (oalist_of_listx\n       (map2_val_raw f id (map_val_raw (\\<lambda>k. f k (0::'b)))\n         (list_of_oalistx xs) (list_of_oalisty ys))) =\n    map2_val_raw f id (map_val_raw (\\<lambda>k. f k (0::'b)))\n     (list_of_oalistx xs) (list_of_oalisty ys)", "by (rule list_of_oalist_of_list_id, rule oalist_inv_map2_val_raw,\n      fact oalist_inv_list_of_oalist, fact oay.oalist_inv_list_of_oalist,\n      fact map2_val_compat'_id, fact map2_val_compat'_map_val_raw)"], ["", "lemma lookup_map2_val:\n  assumes \"\\<And>k. f k 0 0 = 0\"\n  shows \"oaz.lookup (map2_val f xs ys) k = f k (lookup xs k) (oay.lookup ys k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oaz.lookup (map2_val f xs ys) k = f k (lookup xs k) (oay.lookup ys k)", "by (simp add: oaz.lookup_def oay.lookup_def lookup_def lookup_raw_map2_val_raw\n      map2_val_compat'_map_val_raw assms oalist_inv_list_of_oalist oay.oalist_inv_list_of_oalist)"], ["", "lemma lookup_map2_val_rneutr:\n  assumes \"\\<And>k x. f k x 0 = x\"\n  shows \"lookup (map2_val_rneutr f xs ys) k = f k (lookup xs k) (oay.lookup ys k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (map2_val_rneutr f xs ys) k = f k (lookup xs k) (oay.lookup ys k)", "proof (simp add: lookup_def oay.lookup_def, rule lookup_raw_map2_val_raw)"], ["proof (state)\ngoal (7 subgoals):\n 1. oalist_inv (list_of_oalistx xs)\n 2. oalist_inv (list_of_oalisty ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' (map_val_raw (\\<lambda>k. f k (0::'b)))\n 5. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k v. f k v (0::'c)) zs\n 6. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       map_val_raw (\\<lambda>k. f k (0::'b)) zs =\n       map_val_raw (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'c) = (0::'b)", "fix zs::\"('a, 'b, 'o) oalist_raw\""], ["proof (state)\ngoal (7 subgoals):\n 1. oalist_inv (list_of_oalistx xs)\n 2. oalist_inv (list_of_oalisty ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' (map_val_raw (\\<lambda>k. f k (0::'b)))\n 5. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k v. f k v (0::'c)) zs\n 6. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       map_val_raw (\\<lambda>k. f k (0::'b)) zs =\n       map_val_raw (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'c) = (0::'b)", "assume \"oalist_inv zs\""], ["proof (state)\nthis:\n  oalist_inv zs\n\ngoal (7 subgoals):\n 1. oalist_inv (list_of_oalistx xs)\n 2. oalist_inv (list_of_oalisty ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' (map_val_raw (\\<lambda>k. f k (0::'b)))\n 5. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       id zs = map_val_raw (\\<lambda>k v. f k v (0::'c)) zs\n 6. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       map_val_raw (\\<lambda>k. f k (0::'b)) zs =\n       map_val_raw (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'c) = (0::'b)", "thus \"id zs = map_val_raw (\\<lambda>k v. f k v 0) zs\""], ["proof (prove)\nusing this:\n  oalist_inv zs\n\ngoal (1 subgoal):\n 1. id zs = map_val_raw (\\<lambda>k v. f k v (0::'c)) zs", "by (simp add: assms map_raw_id)"], ["proof (state)\nthis:\n  id zs = map_val_raw (\\<lambda>k v. f k v (0::'c)) zs\n\ngoal (6 subgoals):\n 1. oalist_inv (list_of_oalistx xs)\n 2. oalist_inv (list_of_oalisty ys)\n 3. map2_val_compat' id\n 4. map2_val_compat' (map_val_raw (\\<lambda>k. f k (0::'b)))\n 5. \\<And>zs.\n       oalist_inv zs \\<Longrightarrow>\n       map_val_raw (\\<lambda>k. f k (0::'b)) zs =\n       map_val_raw (\\<lambda>k. f k (0::'b)) zs\n 6. \\<And>k. f k (0::'b) (0::'c) = (0::'b)", "qed (fact oalist_inv_list_of_oalist, fact oay.oalist_inv_list_of_oalist,\n    fact map2_val_compat'_id, fact map2_val_compat'_map_val_raw, rule refl, simp only: assms)"], ["", "lemma map2_val_rneutr_singleton_eq_update_by_fun:\n  assumes \"\\<And>a x. f a x 0 = x\" and \"list_of_oalisty ys = ([(k, v)], oy)\"\n  shows \"map2_val_rneutr f xs ys = update_by_fun k (\\<lambda>x. f k x v) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2_val_rneutr f xs ys = update_by_fun k (\\<lambda>x. f k x v) xs", "by (simp add: map2_val_rneutr_def update_by_fun_def assms map2_val_raw_singleton_eq_update_by_fun_raw oalist_inv_list_of_oalist)"], ["", "subsubsection \\<open>@{const lex_ord} and @{const prod_ord}\\<close>"], ["", "lemma lex_ord_EqI:\n  \"(\\<And>k. k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)) \\<Longrightarrow>\n     f k (lookup xs k) (oay.lookup ys k) = Some Eq) \\<Longrightarrow>\n  lex_ord ko f xs ys = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                fst ` set (fst (list_of_oalisty ys)) \\<Longrightarrow>\n        f k (lookup xs k) (oay.lookup ys k) = Some Eq) \\<Longrightarrow>\n    lex_ord ko f xs ys = Some Eq", "by (simp add: lex_ord_def lookup_def oay.lookup_def, rule lex_ord_raw_EqI,\n      rule oalist_inv_list_of_oalist, rule oay.oalist_inv_list_of_oalist, blast)"], ["", "lemma lex_ord_valI:\n  assumes \"aux \\<noteq> Some Eq\" and \"k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys))\"\n  shows \"aux = f k (lookup xs k) (oay.lookup ys k) \\<Longrightarrow>\n         (\\<And>k'. k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)) \\<Longrightarrow>\n              lt ko k' k \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') = Some Eq) \\<Longrightarrow>\n          lex_ord ko f xs ys = aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aux = f k (lookup xs k) (oay.lookup ys k);\n     \\<And>k'.\n        \\<lbrakk>k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                          fst ` set (fst (list_of_oalisty ys));\n         lt ko k' k\\<rbrakk>\n        \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') =\n                          Some Eq\\<rbrakk>\n    \\<Longrightarrow> lex_ord ko f xs ys = aux", "by (simp (no_asm_use) add: lex_ord_def lookup_def oay.lookup_def, rule lex_ord_raw_valI,\n      rule oalist_inv_list_of_oalist, rule oay.oalist_inv_list_of_oalist, rule assms(1), rule assms(2), blast+)"], ["", "lemma lex_ord_EqD:\n  \"lex_ord ko f xs ys = Some Eq \\<Longrightarrow>\n   k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)) \\<Longrightarrow>\n   f k (lookup xs k) (oay.lookup ys k) = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lex_ord ko f xs ys = Some Eq;\n     k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n             fst ` set (fst (list_of_oalisty ys))\\<rbrakk>\n    \\<Longrightarrow> f k (lookup xs k) (oay.lookup ys k) = Some Eq", "by (simp add: lex_ord_def lookup_def oay.lookup_def, rule lex_ord_raw_EqD[where f=f],\n      rule oalist_inv_list_of_oalist, rule oay.oalist_inv_list_of_oalist, assumption, simp)"], ["", "lemma lex_ord_valE:\n  assumes \"lex_ord ko f xs ys = aux\" and \"aux \\<noteq> Some Eq\"\n  obtains k where \"k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys))\"\n    and \"aux = f k (lookup xs k) (oay.lookup ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)) \\<Longrightarrow>\n            lt ko k' k \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                         fst ` set (fst (list_of_oalisty ys));\n         aux = f k (lookup xs k) (oay.lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                              fst ` set (fst (list_of_oalisty ys));\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                         fst ` set (fst (list_of_oalisty ys));\n         aux = f k (lookup xs k) (oay.lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                              fst ` set (fst (list_of_oalisty ys));\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note oalist_inv_list_of_oalist oay.oalist_inv_list_of_oalist"], ["proof (state)\nthis:\n  oalist_inv (list_of_oalistx ?x)\n  oalist_inv (list_of_oalisty ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                         fst ` set (fst (list_of_oalisty ys));\n         aux = f k (lookup xs k) (oay.lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                              fst ` set (fst (list_of_oalisty ys));\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  oalist_inv (list_of_oalistx ?x)\n  oalist_inv (list_of_oalisty ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                         fst ` set (fst (list_of_oalisty ys));\n         aux = f k (lookup xs k) (oay.lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                              fst ` set (fst (list_of_oalisty ys));\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(1)"], ["proof (chain)\npicking this:\n  lex_ord ko f xs ys = aux", "have \"lex_ord_raw ko f (list_of_oalistx xs) (list_of_oalisty ys) = aux\""], ["proof (prove)\nusing this:\n  lex_ord ko f xs ys = aux\n\ngoal (1 subgoal):\n 1. lex_ord_raw ko f (list_of_oalistx xs) (list_of_oalisty ys) = aux", "by (simp only: lex_ord_def)"], ["proof (state)\nthis:\n  lex_ord_raw ko f (list_of_oalistx xs) (list_of_oalisty ys) = aux\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                         fst ` set (fst (list_of_oalisty ys));\n         aux = f k (lookup xs k) (oay.lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                              fst ` set (fst (list_of_oalisty ys));\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  oalist_inv (list_of_oalistx ?x)\n  oalist_inv (list_of_oalisty ?x)\n  lex_ord_raw ko f (list_of_oalistx xs) (list_of_oalisty ys) = aux", "obtain k where 1: \"k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys))\"\n    and \"aux = f k (lookup_raw (list_of_oalistx xs) k) (lookup_raw (list_of_oalisty ys) k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)) \\<Longrightarrow>\n            lt ko k' k \\<Longrightarrow>\n            f k' (lookup_raw (list_of_oalistx xs) k') (lookup_raw (list_of_oalisty ys) k') = Some Eq\""], ["proof (prove)\nusing this:\n  oalist_inv (list_of_oalistx ?x)\n  oalist_inv (list_of_oalisty ?x)\n  lex_ord_raw ko f (list_of_oalistx xs) (list_of_oalisty ys) = aux\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                         fst ` set (fst (list_of_oalisty ys));\n         aux =\n         f k (lookup_raw (list_of_oalistx xs) k)\n          (lookup_raw (list_of_oalisty ys) k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                              fst ` set (fst (list_of_oalisty ys));\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw (list_of_oalistx xs) k')\n                               (lookup_raw (list_of_oalisty ys) k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  oalist_inv (list_of_oalistx ?x)\n  oalist_inv (list_of_oalisty ?x)\n  lex_ord_raw ko f (list_of_oalistx xs) (list_of_oalisty ys) = aux\n  aux \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                         fst ` set (fst (list_of_oalisty ys));\n         aux =\n         f k (lookup_raw (list_of_oalistx xs) k)\n          (lookup_raw (list_of_oalisty ys) k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                              fst ` set (fst (list_of_oalisty ys));\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup_raw (list_of_oalistx xs) k')\n                               (lookup_raw (list_of_oalisty ys) k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule lex_ord_raw_valE, blast)"], ["proof (state)\nthis:\n  k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n          fst ` set (fst (list_of_oalisty ys))\n  aux =\n  f k (lookup_raw (list_of_oalistx xs) k)\n   (lookup_raw (list_of_oalisty ys) k)\n  \\<lbrakk>?k'60\n           \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                 fst ` set (fst (list_of_oalisty ys));\n   lt ko ?k'60 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'60 (lookup_raw (list_of_oalistx xs) ?k'60)\n                     (lookup_raw (list_of_oalisty ys) ?k'60) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                         fst ` set (fst (list_of_oalisty ys));\n         aux = f k (lookup xs k) (oay.lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                              fst ` set (fst (list_of_oalisty ys));\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(2, 3)"], ["proof (chain)\npicking this:\n  aux =\n  f k (lookup_raw (list_of_oalistx xs) k)\n   (lookup_raw (list_of_oalisty ys) k)\n  \\<lbrakk>?k'60\n           \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                 fst ` set (fst (list_of_oalisty ys));\n   lt ko ?k'60 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'60 (lookup_raw (list_of_oalistx xs) ?k'60)\n                     (lookup_raw (list_of_oalisty ys) ?k'60) =\n                    Some Eq", "have \"aux = f k (lookup xs k) (oay.lookup ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)) \\<Longrightarrow>\n            lt ko k' k \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') = Some Eq\""], ["proof (prove)\nusing this:\n  aux =\n  f k (lookup_raw (list_of_oalistx xs) k)\n   (lookup_raw (list_of_oalisty ys) k)\n  \\<lbrakk>?k'60\n           \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                 fst ` set (fst (list_of_oalisty ys));\n   lt ko ?k'60 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'60 (lookup_raw (list_of_oalistx xs) ?k'60)\n                     (lookup_raw (list_of_oalisty ys) ?k'60) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. aux = f k (lookup xs k) (oay.lookup ys k) &&&\n    (\\<And>k'.\n        \\<lbrakk>k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                          fst ` set (fst (list_of_oalisty ys));\n         lt ko k' k\\<rbrakk>\n        \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') = Some Eq)", "by (simp_all only: lookup_def oay.lookup_def)"], ["proof (state)\nthis:\n  aux = f k (lookup xs k) (oay.lookup ys k)\n  \\<lbrakk>?k'60\n           \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                 fst ` set (fst (list_of_oalisty ys));\n   lt ko ?k'60 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'60 (lookup xs ?k'60) (oay.lookup ys ?k'60) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                         fst ` set (fst (list_of_oalisty ys));\n         aux = f k (lookup xs k) (oay.lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                              fst ` set (fst (list_of_oalisty ys));\n             lt ko k' k\\<rbrakk>\n            \\<Longrightarrow> f k' (lookup xs k') (oay.lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with 1"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n          fst ` set (fst (list_of_oalisty ys))\n  aux = f k (lookup xs k) (oay.lookup ys k)\n  \\<lbrakk>?k'60\n           \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                 fst ` set (fst (list_of_oalisty ys));\n   lt ko ?k'60 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'60 (lookup xs ?k'60) (oay.lookup ys ?k'60) =\n                    Some Eq", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n          fst ` set (fst (list_of_oalisty ys))\n  aux = f k (lookup xs k) (oay.lookup ys k)\n  \\<lbrakk>?k'60\n           \\<in> fst ` set (fst (list_of_oalistx xs)) \\<union>\n                 fst ` set (fst (list_of_oalisty ys));\n   lt ko ?k'60 k\\<rbrakk>\n  \\<Longrightarrow> f ?k'60 (lookup xs ?k'60) (oay.lookup ys ?k'60) =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_ord_alt:\n  \"prod_ord P xs ys \\<longleftrightarrow>\n                  (\\<forall>k\\<in>fst ` set (fst (list_of_oalistx xs)) \\<union> fst ` set (fst (list_of_oalisty ys)).\n                      P k (lookup xs k) (oay.lookup ys k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_ord P xs ys =\n    (\\<forall>k\\<in>fst ` set (fst (list_of_oalistx xs)) \\<union>\n                    fst ` set (fst (list_of_oalisty ys)).\n        P k (lookup xs k) (oay.lookup ys k))", "by (simp add: prod_ord_def lookup_def oay.lookup_def prod_ord_raw_alt oalist_inv_list_of_oalist oay.oalist_inv_list_of_oalist)"], ["", "end"], ["", "(* oalist_abstract3 *)"], ["", "subsection \\<open>Type \\<open>oalist\\<close>\\<close>"], ["", "global_interpretation ko: comparator \"key_compare ko\"\n  defines lookup_pair_ko = ko.lookup_pair\n  and update_by_pair_ko = ko.update_by_pair\n  and update_by_fun_pair_ko = ko.update_by_fun_pair\n  and update_by_fun_gr_pair_ko = ko.update_by_fun_gr_pair\n  and map2_val_pair_ko = ko.map2_val_pair\n  and lex_ord_pair_ko = ko.lex_ord_pair\n  and prod_ord_pair_ko = ko.prod_ord_pair\n  and sort_oalist_ko' = ko.sort_oalist"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (key_compare ko)", "by (fact comparator_key_compare)"], ["", "lemma ko_le: \"ko.le = le_of_key_order\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ko.le = le_of_key_order", "by (intro ext, simp add: le_of_comp_def le_of_key_order_alt split: order.split)"], ["", "global_interpretation ko: oalist_raw \"\\<lambda>x. x\"\n  rewrites \"comparator.lookup_pair (key_compare ko) = lookup_pair_ko ko\"\n  and \"comparator.update_by_pair (key_compare ko) = update_by_pair_ko ko\"\n  and \"comparator.update_by_fun_pair (key_compare ko) = update_by_fun_pair_ko ko\"\n  and \"comparator.update_by_fun_gr_pair (key_compare ko) = update_by_fun_gr_pair_ko ko\"\n  and \"comparator.map2_val_pair (key_compare ko) = map2_val_pair_ko ko\"\n  and \"comparator.lex_ord_pair (key_compare ko) = lex_ord_pair_ko ko\"\n  and \"comparator.prod_ord_pair (key_compare ko) = prod_ord_pair_ko ko\"\n  and \"comparator.sort_oalist (key_compare ko) = sort_oalist_ko' ko\"\n  defines sort_oalist_aux_ko = ko.sort_oalist_aux\n  and lookup_ko = ko.lookup_raw\n  and sorted_domain_ko = ko.sorted_domain_raw\n  and tl_ko = ko.tl_raw\n  and min_key_val_ko = ko.min_key_val_raw\n  and update_by_ko = ko.update_by_raw\n  and update_by_fun_ko = ko.update_by_fun_raw\n  and update_by_fun_gr_ko = ko.update_by_fun_gr_raw\n  and map2_val_ko = ko.map2_val_raw\n  and lex_ord_ko = ko.lex_ord_raw\n  and prod_ord_ko = ko.prod_ord_raw\n  and oalist_eq_ko = ko.oalist_eq_raw\n  and sort_oalist_ko = ko.sort_oalist_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((comparator.lookup_pair (key_compare ko) = lookup_pair_ko ko &&&\n      comparator.update_by_pair (key_compare ko) = update_by_pair_ko ko) &&&\n     comparator.update_by_fun_pair (key_compare ko) =\n     update_by_fun_pair_ko ko &&&\n     comparator.update_by_fun_gr_pair (key_compare ko) =\n     update_by_fun_gr_pair_ko ko) &&&\n    (comparator.map2_val_pair (key_compare ko) = map2_val_pair_ko ko &&&\n     comparator.lex_ord_pair (key_compare ko) = lex_ord_pair_ko ko) &&&\n    comparator.prod_ord_pair (key_compare ko) = prod_ord_pair_ko ko &&&\n    comparator.sort_oalist (key_compare ko) = sort_oalist_ko' ko", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator.lookup_pair (key_compare ko) = lookup_pair_ko ko", "by (simp only: lookup_pair_ko_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. comparator.update_by_pair (key_compare ko) = update_by_pair_ko ko\n 2. comparator.update_by_fun_pair (key_compare ko) =\n    update_by_fun_pair_ko ko\n 3. comparator.update_by_fun_gr_pair (key_compare ko) =\n    update_by_fun_gr_pair_ko ko\n 4. comparator.map2_val_pair (key_compare ko) = map2_val_pair_ko ko\n 5. comparator.lex_ord_pair (key_compare ko) = lex_ord_pair_ko ko\n 6. comparator.prod_ord_pair (key_compare ko) = prod_ord_pair_ko ko\n 7. comparator.sort_oalist (key_compare ko) = sort_oalist_ko' ko", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator.update_by_pair (key_compare ko) = update_by_pair_ko ko", "by (simp only: update_by_pair_ko_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. comparator.update_by_fun_pair (key_compare ko) =\n    update_by_fun_pair_ko ko\n 2. comparator.update_by_fun_gr_pair (key_compare ko) =\n    update_by_fun_gr_pair_ko ko\n 3. comparator.map2_val_pair (key_compare ko) = map2_val_pair_ko ko\n 4. comparator.lex_ord_pair (key_compare ko) = lex_ord_pair_ko ko\n 5. comparator.prod_ord_pair (key_compare ko) = prod_ord_pair_ko ko\n 6. comparator.sort_oalist (key_compare ko) = sort_oalist_ko' ko", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator.update_by_fun_pair (key_compare ko) =\n    update_by_fun_pair_ko ko", "by (simp only: update_by_fun_pair_ko_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. comparator.update_by_fun_gr_pair (key_compare ko) =\n    update_by_fun_gr_pair_ko ko\n 2. comparator.map2_val_pair (key_compare ko) = map2_val_pair_ko ko\n 3. comparator.lex_ord_pair (key_compare ko) = lex_ord_pair_ko ko\n 4. comparator.prod_ord_pair (key_compare ko) = prod_ord_pair_ko ko\n 5. comparator.sort_oalist (key_compare ko) = sort_oalist_ko' ko", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator.update_by_fun_gr_pair (key_compare ko) =\n    update_by_fun_gr_pair_ko ko", "by (simp only: update_by_fun_gr_pair_ko_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. comparator.map2_val_pair (key_compare ko) = map2_val_pair_ko ko\n 2. comparator.lex_ord_pair (key_compare ko) = lex_ord_pair_ko ko\n 3. comparator.prod_ord_pair (key_compare ko) = prod_ord_pair_ko ko\n 4. comparator.sort_oalist (key_compare ko) = sort_oalist_ko' ko", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator.map2_val_pair (key_compare ko) = map2_val_pair_ko ko", "by (simp only: map2_val_pair_ko_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. comparator.lex_ord_pair (key_compare ko) = lex_ord_pair_ko ko\n 2. comparator.prod_ord_pair (key_compare ko) = prod_ord_pair_ko ko\n 3. comparator.sort_oalist (key_compare ko) = sort_oalist_ko' ko", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator.lex_ord_pair (key_compare ko) = lex_ord_pair_ko ko", "by (simp only: lex_ord_pair_ko_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. comparator.prod_ord_pair (key_compare ko) = prod_ord_pair_ko ko\n 2. comparator.sort_oalist (key_compare ko) = sort_oalist_ko' ko", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator.prod_ord_pair (key_compare ko) = prod_ord_pair_ko ko", "by (simp only: prod_ord_pair_ko_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator.sort_oalist (key_compare ko) = sort_oalist_ko' ko", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator.sort_oalist (key_compare ko) = sort_oalist_ko' ko", "by (simp only: sort_oalist_ko'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "typedef (overloaded) ('a, 'b) oalist = \"{xs::('a, 'b::zero, 'a key_order) oalist_raw. ko.oalist_inv xs}\"\n  morphisms list_of_oalist Abs_oalist"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Collect ko.oalist_inv", "by (auto simp: ko.oalist_inv_def intro: ko.oalist_inv_raw_Nil)"], ["", "lemma oalist_eq_iff: \"xs = ys \\<longleftrightarrow> list_of_oalist xs = list_of_oalist ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = ys) = (list_of_oalist xs = list_of_oalist ys)", "by (simp add: list_of_oalist_inject)"], ["", "lemma oalist_eqI: \"list_of_oalist xs = list_of_oalist ys \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist xs = list_of_oalist ys \\<Longrightarrow> xs = ys", "by (simp add: oalist_eq_iff)"], ["", "text \\<open>Formal, totalized constructor for @{typ \"('a, 'b) oalist\"}:\\<close>"], ["", "definition OAlist :: \"('a \\<times> 'b) list \\<times> 'a key_order \\<Rightarrow> ('a, 'b::zero) oalist\" where\n  \"OAlist xs = Abs_oalist (sort_oalist_ko xs)\""], ["", "definition \"oalist_of_list = OAlist\""], ["", "lemma oalist_inv_list_of_oalist: \"ko.oalist_inv (list_of_oalist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ko.oalist_inv (list_of_oalist xs)", "using list_of_oalist [of xs]"], ["proof (prove)\nusing this:\n  list_of_oalist xs \\<in> Collect ko.oalist_inv\n\ngoal (1 subgoal):\n 1. ko.oalist_inv (list_of_oalist xs)", "by simp"], ["", "lemma list_of_oalist_OAlist: \"list_of_oalist (OAlist xs) = sort_oalist_ko xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (OAlist xs) = sort_oalist_ko xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_oalist (OAlist xs) = sort_oalist_ko xs", "obtain xs' ox where xs: \"xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        xs = (xs', ox) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. list_of_oalist (OAlist xs) = sort_oalist_ko xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (OAlist xs) = sort_oalist_ko xs", "by (simp add: xs OAlist_def Abs_oalist_inverse ko.oalist_inv_raw_sort_oalist ko.oalist_inv_alt)"], ["proof (state)\nthis:\n  list_of_oalist (OAlist xs) = sort_oalist_ko xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OAlist_list_of_oalist [code abstype]: \"OAlist (list_of_oalist xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist (list_of_oalist xs) = xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OAlist (list_of_oalist xs) = xs", "obtain xs' ox where xs: \"list_of_oalist xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        list_of_oalist xs = (xs', ox) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  list_of_oalist xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. OAlist (list_of_oalist xs) = xs", "have \"ko.oalist_inv_raw ox xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ko.oalist_inv_raw ox xs'", "by (simp add: xs[symmetric] ko.oalist_inv_alt[symmetric] oalist_inv_list_of_oalist)"], ["proof (state)\nthis:\n  ko.oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. OAlist (list_of_oalist xs) = xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  ko.oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. OAlist (list_of_oalist xs) = xs", "by (simp add: xs OAlist_def ko.sort_oalist_id, simp add: list_of_oalist_inverse xs[symmetric])"], ["proof (state)\nthis:\n  OAlist (list_of_oalist xs) = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [code abstract]: \"list_of_oalist (oalist_of_list xs) = sort_oalist_ko xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (oalist_of_list xs) = sort_oalist_ko xs", "by (simp add: list_of_oalist_OAlist oalist_of_list_def)"], ["", "global_interpretation oa: oalist_abstract \"\\<lambda>x. x\" list_of_oalist OAlist\n  defines OAlist_lookup = oa.lookup\n  and OAlist_sorted_domain = oa.sorted_domain\n  and OAlist_empty = oa.empty\n  and OAlist_reorder = oa.reorder\n  and OAlist_tl = oa.tl\n  and OAlist_hd = oa.hd\n  and OAlist_except_min = oa.except_min\n  and OAlist_min_key_val = oa.min_key_val\n  and OAlist_insert = oa.insert\n  and OAlist_update_by_fun = oa.update_by_fun\n  and OAlist_update_by_fun_gr = oa.update_by_fun_gr\n  and OAlist_filter = oa.filter\n  and OAlist_map2_val_neutr = oa.map2_val_neutr\n  and OAlist_eq = oa.oalist_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_abstract (\\<lambda>x. x) list_of_oalist OAlist", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. ko.oalist_inv (list_of_oalist x)\n 2. \\<And>xs.\n       list_of_oalist (OAlist xs) =\n       oalist_raw.sort_oalist_raw (\\<lambda>x. x) xs\n 3. \\<And>x. OAlist (list_of_oalist x) = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ko.oalist_inv (list_of_oalist x_)", "by (fact oalist_inv_list_of_oalist)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       list_of_oalist (OAlist xs) =\n       oalist_raw.sort_oalist_raw (\\<lambda>x. x) xs\n 2. \\<And>x. OAlist (list_of_oalist x) = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist (OAlist xs_) =\n    oalist_raw.sort_oalist_raw (\\<lambda>x. x) xs_", "by (simp only: list_of_oalist_OAlist sort_oalist_ko_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. OAlist (list_of_oalist x) = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist (list_of_oalist x_) = x_", "by (fact OAlist_list_of_oalist)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "global_interpretation oa: oalist_abstract3 \"\\<lambda>x. x\"\n    \"list_of_oalist::('a, 'b) oalist \\<Rightarrow> ('a, 'b::zero, 'a key_order) oalist_raw\" OAlist\n    \"list_of_oalist::('a, 'c) oalist \\<Rightarrow> ('a, 'c::zero, 'a key_order) oalist_raw\" OAlist\n    \"list_of_oalist::('a, 'd) oalist \\<Rightarrow> ('a, 'd::zero, 'a key_order) oalist_raw\" OAlist\n  defines OAlist_map_val = oa.map_val\n  and OAlist_map2_val = oa.map2_val\n  and OAlist_map2_val_rneutr = oa.map2_val_rneutr\n  and OAlist_lex_ord = oa.lex_ord\n  and OAlist_prod_ord = oa.prod_ord"], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_abstract3 (\\<lambda>x. x) list_of_oalist OAlist list_of_oalist\n     OAlist list_of_oalist OAlist", ".."], ["", "lemmas OAlist_lookup_single = oa.lookup_oalist_of_list_single[folded oalist_of_list_def]"], ["", "subsection \\<open>Type \\<open>oalist_tc\\<close>\\<close>"], ["", "text \\<open>``tc'' stands for ``type class''.\\<close>"], ["", "global_interpretation tc: comparator \"comparator_of\"\n  defines lookup_pair_tc = tc.lookup_pair\n  and update_by_pair_tc = tc.update_by_pair\n  and update_by_fun_pair_tc = tc.update_by_fun_pair\n  and update_by_fun_gr_pair_tc = tc.update_by_fun_gr_pair\n  and map2_val_pair_tc = tc.map2_val_pair\n  and lex_ord_pair_tc = tc.lex_ord_pair\n  and prod_ord_pair_tc = tc.prod_ord_pair\n  and sort_oalist_tc = tc.sort_oalist"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator comparator_of", "by (fact comparator_of)"], ["", "lemma tc_le_lt [simp]: \"tc.le = (\\<le>)\" \"tc.lt = (<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tc.le = (\\<le>) &&& tc.lt = (<)", "by (auto simp: le_of_comp_def lt_of_comp_def comparator_of_def intro!: ext split: order.split_asm if_split_asm)"], ["", "typedef (overloaded) ('a, 'b) oalist_tc = \"{xs::('a::linorder \\<times> 'b::zero) list. tc.oalist_inv_raw xs}\"\n  morphisms list_of_oalist_tc Abs_oalist_tc"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Collect tc.oalist_inv_raw", "by (auto intro: tc.oalist_inv_raw_Nil)"], ["", "lemma oalist_tc_eq_iff: \"xs = ys \\<longleftrightarrow> list_of_oalist_tc xs = list_of_oalist_tc ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = ys) = (list_of_oalist_tc xs = list_of_oalist_tc ys)", "by (simp add: list_of_oalist_tc_inject)"], ["", "lemma oalist_tc_eqI: \"list_of_oalist_tc xs = list_of_oalist_tc ys \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc xs = list_of_oalist_tc ys \\<Longrightarrow> xs = ys", "by (simp add: oalist_tc_eq_iff)"], ["", "text \\<open>Formal, totalized constructor for @{typ \"('a, 'b) oalist_tc\"}:\\<close>"], ["", "definition OAlist_tc :: \"('a \\<times> 'b) list \\<Rightarrow> ('a::linorder, 'b::zero) oalist_tc\" where\n  \"OAlist_tc xs = Abs_oalist_tc (sort_oalist_tc xs)\""], ["", "definition \"oalist_tc_of_list = OAlist_tc\""], ["", "lemma oalist_inv_list_of_oalist_tc: \"tc.oalist_inv_raw (list_of_oalist_tc xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)", "using list_of_oalist_tc[of xs]"], ["proof (prove)\nusing this:\n  list_of_oalist_tc xs \\<in> Collect tc.oalist_inv_raw\n\ngoal (1 subgoal):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)", "by simp"], ["", "lemma list_of_oalist_OAlist_tc: \"list_of_oalist_tc (OAlist_tc xs) = sort_oalist_tc xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc xs) = sort_oalist_tc xs", "by (simp add: OAlist_tc_def Abs_oalist_tc_inverse tc.oalist_inv_raw_sort_oalist)"], ["", "lemma OAlist_list_of_oalist_tc [code abstype]: \"OAlist_tc (list_of_oalist_tc xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc (list_of_oalist_tc xs) = xs", "by (simp add: OAlist_tc_def tc.sort_oalist_id list_of_oalist_tc_inverse oalist_inv_list_of_oalist_tc)"], ["", "lemma list_of_oalist_tc_of_list [code abstract]: \"list_of_oalist_tc (oalist_tc_of_list xs) = sort_oalist_tc xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (oalist_tc_of_list xs) = sort_oalist_tc xs", "by (simp add: list_of_oalist_OAlist_tc oalist_tc_of_list_def)"], ["", "lemma list_of_oalist_tc_of_list_id:\n  assumes \"tc.oalist_inv_raw xs\"\n  shows \"list_of_oalist_tc (OAlist_tc xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc xs) = xs", "using assms"], ["proof (prove)\nusing this:\n  tc.oalist_inv_raw xs\n\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc xs) = xs", "by (simp add: list_of_oalist_OAlist_tc tc.sort_oalist_id)"], ["", "text \\<open>It is better to define the following operations directly instead of interpreting\n  @{locale oalist_abstract}, because @{locale oalist_abstract} defines the operations via their\n  \\<open>_raw\\<close> analogues, whereas in this case we can define them directly via their \\<open>_pair\\<close> analogues.\\<close>"], ["", "definition OAlist_tc_lookup :: \"('a::linorder, 'b::zero) oalist_tc \\<Rightarrow> 'a \\<Rightarrow> 'b\"\n  where \"OAlist_tc_lookup xs = lookup_pair_tc (list_of_oalist_tc xs)\""], ["", "definition OAlist_tc_sorted_domain :: \"('a::linorder, 'b::zero) oalist_tc \\<Rightarrow> 'a list\"\n  where \"OAlist_tc_sorted_domain xs = map fst (list_of_oalist_tc xs)\""], ["", "definition OAlist_tc_empty :: \"('a::linorder, 'b::zero) oalist_tc\"\n  where \"OAlist_tc_empty = OAlist_tc []\""], ["", "definition OAlist_tc_except_min :: \"('a, 'b) oalist_tc \\<Rightarrow> ('a::linorder, 'b::zero) oalist_tc\"\n  where \"OAlist_tc_except_min xs = OAlist_tc (tl (list_of_oalist_tc xs))\""], ["", "definition OAlist_tc_min_key_val :: \"('a::linorder, 'b::zero) oalist_tc \\<Rightarrow> ('a \\<times> 'b)\"\n  where \"OAlist_tc_min_key_val xs = hd (list_of_oalist_tc xs)\""], ["", "definition OAlist_tc_insert :: \"('a \\<times> 'b) \\<Rightarrow> ('a, 'b) oalist_tc \\<Rightarrow> ('a::linorder, 'b::zero) oalist_tc\"\n  where \"OAlist_tc_insert x xs = OAlist_tc (update_by_pair_tc x (list_of_oalist_tc xs))\""], ["", "definition OAlist_tc_update_by_fun :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> ('a, 'b) oalist_tc \\<Rightarrow> ('a::linorder, 'b::zero) oalist_tc\"\n  where \"OAlist_tc_update_by_fun k f xs = OAlist_tc (update_by_fun_pair_tc k f (list_of_oalist_tc xs))\""], ["", "definition OAlist_tc_update_by_fun_gr :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> ('a, 'b) oalist_tc \\<Rightarrow> ('a::linorder, 'b::zero) oalist_tc\"\n  where \"OAlist_tc_update_by_fun_gr k f xs = OAlist_tc (update_by_fun_gr_pair_tc k f (list_of_oalist_tc xs))\""], ["", "definition OAlist_tc_filter :: \"(('a \\<times> 'b) \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) oalist_tc \\<Rightarrow> ('a::linorder, 'b::zero) oalist_tc\"\n  where \"OAlist_tc_filter P xs = OAlist_tc (filter P (list_of_oalist_tc xs))\""], ["", "definition OAlist_tc_map_val :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> ('a, 'b::zero) oalist_tc \\<Rightarrow> ('a::linorder, 'c::zero) oalist_tc\"\n  where \"OAlist_tc_map_val f xs = OAlist_tc (map_val_pair f (list_of_oalist_tc xs))\""], ["", "definition OAlist_tc_map2_val :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd) \\<Rightarrow> ('a, 'b::zero) oalist_tc \\<Rightarrow> ('a, 'c::zero) oalist_tc \\<Rightarrow>\n                                    ('a::linorder, 'd::zero) oalist_tc\"\n  where \"OAlist_tc_map2_val f xs ys =\n            OAlist_tc (map2_val_pair_tc f (map_val_pair (\\<lambda>k b. f k b 0)) (map_val_pair (\\<lambda>k. f k 0))\n              (list_of_oalist_tc xs) (list_of_oalist_tc ys))\""], ["", "definition OAlist_tc_map2_val_rneutr :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'b) \\<Rightarrow> ('a, 'b) oalist_tc \\<Rightarrow> ('a, 'c::zero) oalist_tc \\<Rightarrow>\n                                    ('a::linorder, 'b::zero) oalist_tc\"\n  where \"OAlist_tc_map2_val_rneutr f xs ys =\n            OAlist_tc (map2_val_pair_tc f id (map_val_pair (\\<lambda>k. f k 0)) (list_of_oalist_tc xs) (list_of_oalist_tc ys))\""], ["", "definition OAlist_tc_map2_val_neutr :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> ('a, 'b) oalist_tc \\<Rightarrow>\n                                          ('a, 'b) oalist_tc \\<Rightarrow> ('a::linorder, 'b::zero) oalist_tc\"\n  where \"OAlist_tc_map2_val_neutr f xs ys = OAlist_tc (map2_val_pair_tc f id id (list_of_oalist_tc xs) (list_of_oalist_tc ys))\""], ["", "definition OAlist_tc_lex_ord :: \"('a \\<Rightarrow> ('b, 'c) comp_opt) \\<Rightarrow> (('a, 'b::zero) oalist_tc, ('a::linorder, 'c::zero) oalist_tc) comp_opt\"\n  where \"OAlist_tc_lex_ord f xs ys = lex_ord_pair_tc f (list_of_oalist_tc xs) (list_of_oalist_tc ys)\""], ["", "definition OAlist_tc_prod_ord :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b::zero) oalist_tc \\<Rightarrow> ('a::linorder, 'c::zero) oalist_tc \\<Rightarrow> bool\"\n  where \"OAlist_tc_prod_ord f xs ys = prod_ord_pair_tc f (list_of_oalist_tc xs) (list_of_oalist_tc ys)\""], ["", "subsubsection \\<open>@{const OAlist_tc_lookup}\\<close>"], ["", "lemma OAlist_tc_lookup_eq_valueI: \"(k, v) \\<in> set (list_of_oalist_tc xs) \\<Longrightarrow> OAlist_tc_lookup xs k = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (list_of_oalist_tc xs) \\<Longrightarrow>\n    OAlist_tc_lookup xs k = v", "unfolding OAlist_tc_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (list_of_oalist_tc xs) \\<Longrightarrow>\n    lookup_pair_tc (list_of_oalist_tc xs) k = v", "using oalist_inv_list_of_oalist_tc"], ["proof (prove)\nusing this:\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (list_of_oalist_tc xs) \\<Longrightarrow>\n    lookup_pair_tc (list_of_oalist_tc xs) k = v", "by (rule tc.lookup_pair_eq_valueI)"], ["", "lemma OAlist_tc_lookup_inj: \"OAlist_tc_lookup xs = OAlist_tc_lookup ys \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_lookup xs = OAlist_tc_lookup ys \\<Longrightarrow> xs = ys", "by (simp add: OAlist_tc_lookup_def oalist_inv_list_of_oalist_tc oalist_tc_eqI tc.lookup_pair_inj)"], ["", "lemma OAlist_tc_lookup_oalist_of_list:\n  \"distinct (map fst xs) \\<Longrightarrow> OAlist_tc_lookup (oalist_tc_of_list xs) = lookup_dflt xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow>\n    OAlist_tc_lookup (oalist_tc_of_list xs) = lookup_dflt xs", "by (simp add: OAlist_tc_lookup_def list_of_oalist_tc_of_list tc.lookup_pair_sort_oalist')"], ["", "subsubsection \\<open>@{const OAlist_tc_sorted_domain}\\<close>"], ["", "lemma set_OAlist_tc_sorted_domain: \"set (OAlist_tc_sorted_domain xs) = fst ` set (list_of_oalist_tc xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (OAlist_tc_sorted_domain xs) = fst ` set (list_of_oalist_tc xs)", "unfolding OAlist_tc_sorted_domain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (list_of_oalist_tc xs)) = fst ` set (list_of_oalist_tc xs)", "by simp"], ["", "lemma in_OAlist_tc_sorted_domain_iff_lookup: \"k \\<in> set (OAlist_tc_sorted_domain xs) \\<longleftrightarrow> (OAlist_tc_lookup xs k \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> set (OAlist_tc_sorted_domain xs)) =\n    (OAlist_tc_lookup xs k \\<noteq> (0::'b))", "unfolding OAlist_tc_sorted_domain_def OAlist_tc_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> set (map fst (list_of_oalist_tc xs))) =\n    (lookup_pair_tc (list_of_oalist_tc xs) k \\<noteq> (0::'b))", "using oalist_inv_list_of_oalist_tc tc.lookup_pair_eq_0"], ["proof (prove)\nusing this:\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n  tc.oalist_inv_raw ?xs \\<Longrightarrow>\n  (lookup_pair_tc ?xs ?k = (0::?'b)) = (?k \\<notin> fst ` set ?xs)\n\ngoal (1 subgoal):\n 1. (k \\<in> set (map fst (list_of_oalist_tc xs))) =\n    (lookup_pair_tc (list_of_oalist_tc xs) k \\<noteq> (0::'b))", "by fastforce"], ["", "lemma sorted_OAlist_tc_sorted_domain: \"sorted_wrt (<) (OAlist_tc_sorted_domain xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (<) (OAlist_tc_sorted_domain xs)", "unfolding OAlist_tc_sorted_domain_def tc_le_lt[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt tc.lt (map fst (list_of_oalist_tc xs))", "using oalist_inv_list_of_oalist_tc"], ["proof (prove)\nusing this:\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt tc.lt (map fst (list_of_oalist_tc xs))", "by (rule tc.oalist_inv_rawD2)"], ["", "subsubsection \\<open>@{const OAlist_tc_empty} and Singletons\\<close>"], ["", "lemma list_of_oalist_OAlist_tc_empty [simp, code abstract]: \"list_of_oalist_tc OAlist_tc_empty = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc OAlist_tc_empty = []", "unfolding OAlist_tc_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc []) = []", "using tc.oalist_inv_raw_Nil"], ["proof (prove)\nusing this:\n  tc.oalist_inv_raw []\n\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc []) = []", "by (rule list_of_oalist_tc_of_list_id)"], ["", "lemma lookup_OAlist_tc_empty: \"OAlist_tc_lookup OAlist_tc_empty k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_lookup OAlist_tc_empty k = (0::'a)", "by (simp add: OAlist_tc_lookup_def)"], ["", "lemma OAlist_tc_lookup_single:\n  \"OAlist_tc_lookup (oalist_tc_of_list [(k, v)]) k' = (if k = k' then v else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_lookup (oalist_tc_of_list [(k, v)]) k' =\n    (if k = k' then v else (0::'a))", "by (simp add: OAlist_tc_lookup_def list_of_oalist_tc_of_list tc.sort_oalist_def comparator_of_def split: order.split)"], ["", "subsubsection \\<open>@{const OAlist_tc_except_min}\\<close>"], ["", "lemma list_of_oalist_OAlist_tc_except_min [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_except_min xs) = tl (list_of_oalist_tc xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc_except_min xs) = tl (list_of_oalist_tc xs)", "unfolding OAlist_tc_except_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc (tl (list_of_oalist_tc xs))) =\n    tl (list_of_oalist_tc xs)", "by (rule list_of_oalist_tc_of_list_id, rule tc.oalist_inv_raw_tl, fact oalist_inv_list_of_oalist_tc)"], ["", "lemma lookup_OAlist_tc_except_min:\n  \"OAlist_tc_lookup (OAlist_tc_except_min xs) k =\n        (if (\\<forall>k'\\<in>fst ` set (list_of_oalist_tc xs). k \\<le> k') then 0 else OAlist_tc_lookup xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_lookup (OAlist_tc_except_min xs) k =\n    (if \\<forall>k'\\<in>fst ` set (list_of_oalist_tc xs). k \\<le> k'\n     then 0::'a else OAlist_tc_lookup xs k)", "by (simp add: OAlist_tc_lookup_def tc.lookup_pair_tl oalist_inv_list_of_oalist_tc split del: if_split cong: if_cong)"], ["", "subsubsection \\<open>@{const OAlist_tc_min_key_val}\\<close>"], ["", "lemma OAlist_tc_min_key_val_in:\n  assumes \"list_of_oalist_tc xs \\<noteq> []\"\n  shows \"OAlist_tc_min_key_val xs \\<in> set (list_of_oalist_tc xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_min_key_val xs \\<in> set (list_of_oalist_tc xs)", "unfolding OAlist_tc_min_key_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (list_of_oalist_tc xs) \\<in> set (list_of_oalist_tc xs)", "using assms"], ["proof (prove)\nusing this:\n  list_of_oalist_tc xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (list_of_oalist_tc xs) \\<in> set (list_of_oalist_tc xs)", "by simp"], ["", "lemma snd_OAlist_tc_min_key_val:\n  assumes \"list_of_oalist_tc xs \\<noteq> []\"\n  shows \"snd (OAlist_tc_min_key_val xs) = OAlist_tc_lookup xs (fst (OAlist_tc_min_key_val xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (OAlist_tc_min_key_val xs) =\n    OAlist_tc_lookup xs (fst (OAlist_tc_min_key_val xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (OAlist_tc_min_key_val xs) =\n    OAlist_tc_lookup xs (fst (OAlist_tc_min_key_val xs))", "let ?xs = \"list_of_oalist_tc xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. snd (OAlist_tc_min_key_val xs) =\n    OAlist_tc_lookup xs (fst (OAlist_tc_min_key_val xs))", "from assms"], ["proof (chain)\npicking this:\n  list_of_oalist_tc xs \\<noteq> []", "have *: \"OAlist_tc_min_key_val xs \\<in> set ?xs\""], ["proof (prove)\nusing this:\n  list_of_oalist_tc xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. OAlist_tc_min_key_val xs \\<in> set (list_of_oalist_tc xs)", "by (rule OAlist_tc_min_key_val_in)"], ["proof (state)\nthis:\n  OAlist_tc_min_key_val xs \\<in> set (list_of_oalist_tc xs)\n\ngoal (1 subgoal):\n 1. snd (OAlist_tc_min_key_val xs) =\n    OAlist_tc_lookup xs (fst (OAlist_tc_min_key_val xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (OAlist_tc_min_key_val xs) =\n    OAlist_tc_lookup xs (fst (OAlist_tc_min_key_val xs))", "unfolding OAlist_tc_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (OAlist_tc_min_key_val xs) =\n    lookup_pair_tc (list_of_oalist_tc xs) (fst (OAlist_tc_min_key_val xs))", "by (rule HOL.sym, rule tc.lookup_pair_eq_valueI, fact oalist_inv_list_of_oalist_tc, simp add: *)"], ["proof (state)\nthis:\n  snd (OAlist_tc_min_key_val xs) =\n  OAlist_tc_lookup xs (fst (OAlist_tc_min_key_val xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OAlist_tc_min_key_val_minimal:\n  assumes \"z \\<in> set (list_of_oalist_tc xs)\"\n  shows \"fst (OAlist_tc_min_key_val xs) \\<le> fst z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "let ?xs = \"list_of_oalist_tc xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "from assms"], ["proof (chain)\npicking this:\n  z \\<in> set (list_of_oalist_tc xs)", "have \"?xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  z \\<in> set (list_of_oalist_tc xs)\n\ngoal (1 subgoal):\n 1. list_of_oalist_tc xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  list_of_oalist_tc xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "hence \"OAlist_tc_sorted_domain xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  list_of_oalist_tc xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. OAlist_tc_sorted_domain xs \\<noteq> []", "by (simp add: OAlist_tc_sorted_domain_def)"], ["proof (state)\nthis:\n  OAlist_tc_sorted_domain xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "then"], ["proof (chain)\npicking this:\n  OAlist_tc_sorted_domain xs \\<noteq> []", "obtain h xs' where eq: \"OAlist_tc_sorted_domain xs = h # xs'\""], ["proof (prove)\nusing this:\n  OAlist_tc_sorted_domain xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>h xs'.\n        OAlist_tc_sorted_domain xs = h # xs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using list.exhaust"], ["proof (prove)\nusing this:\n  OAlist_tc_sorted_domain xs \\<noteq> []\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h xs'.\n        OAlist_tc_sorted_domain xs = h # xs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  OAlist_tc_sorted_domain xs = h # xs'\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "with sorted_OAlist_tc_sorted_domain[of xs]"], ["proof (chain)\npicking this:\n  sorted_wrt (<) (OAlist_tc_sorted_domain xs)\n  OAlist_tc_sorted_domain xs = h # xs'", "have *: \"\\<forall>y\\<in>set xs'. h < y\""], ["proof (prove)\nusing this:\n  sorted_wrt (<) (OAlist_tc_sorted_domain xs)\n  OAlist_tc_sorted_domain xs = h # xs'\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set xs'. h < y", "by simp"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set xs'. h < y\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "from assms"], ["proof (chain)\npicking this:\n  z \\<in> set (list_of_oalist_tc xs)", "have \"fst z \\<in> set (OAlist_tc_sorted_domain xs)\""], ["proof (prove)\nusing this:\n  z \\<in> set (list_of_oalist_tc xs)\n\ngoal (1 subgoal):\n 1. fst z \\<in> set (OAlist_tc_sorted_domain xs)", "by (simp add: OAlist_tc_sorted_domain_def)"], ["proof (state)\nthis:\n  fst z \\<in> set (OAlist_tc_sorted_domain xs)\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "hence disj: \"fst z = h \\<or> fst z \\<in> set xs'\""], ["proof (prove)\nusing this:\n  fst z \\<in> set (OAlist_tc_sorted_domain xs)\n\ngoal (1 subgoal):\n 1. fst z = h \\<or> fst z \\<in> set xs'", "by (simp add: eq)"], ["proof (state)\nthis:\n  fst z = h \\<or> fst z \\<in> set xs'\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "from \\<open>?xs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  list_of_oalist_tc xs \\<noteq> []", "have \"fst (OAlist_tc_min_key_val xs) = hd (OAlist_tc_sorted_domain xs)\""], ["proof (prove)\nusing this:\n  list_of_oalist_tc xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) = hd (OAlist_tc_sorted_domain xs)", "by (simp add: OAlist_tc_min_key_val_def OAlist_tc_sorted_domain_def hd_map)"], ["proof (state)\nthis:\n  fst (OAlist_tc_min_key_val xs) = hd (OAlist_tc_sorted_domain xs)\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "also"], ["proof (state)\nthis:\n  fst (OAlist_tc_min_key_val xs) = hd (OAlist_tc_sorted_domain xs)\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "have \"... = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (OAlist_tc_sorted_domain xs) = h", "by (simp add: eq)"], ["proof (state)\nthis:\n  hd (OAlist_tc_sorted_domain xs) = h\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "also"], ["proof (state)\nthis:\n  hd (OAlist_tc_sorted_domain xs) = h\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "from disj"], ["proof (chain)\npicking this:\n  fst z = h \\<or> fst z \\<in> set xs'", "have \"... \\<le> fst z\""], ["proof (prove)\nusing this:\n  fst z = h \\<or> fst z \\<in> set xs'\n\ngoal (1 subgoal):\n 1. h \\<le> fst z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst z = h \\<Longrightarrow> h \\<le> fst z\n 2. fst z \\<in> set xs' \\<Longrightarrow> h \\<le> fst z", "assume \"fst z = h\""], ["proof (state)\nthis:\n  fst z = h\n\ngoal (2 subgoals):\n 1. fst z = h \\<Longrightarrow> h \\<le> fst z\n 2. fst z \\<in> set xs' \\<Longrightarrow> h \\<le> fst z", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst z = h\n\ngoal (1 subgoal):\n 1. h \\<le> fst z", "by simp"], ["proof (state)\nthis:\n  h \\<le> fst z\n\ngoal (1 subgoal):\n 1. fst z \\<in> set xs' \\<Longrightarrow> h \\<le> fst z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst z \\<in> set xs' \\<Longrightarrow> h \\<le> fst z", "assume \"fst z \\<in> set xs'\""], ["proof (state)\nthis:\n  fst z \\<in> set xs'\n\ngoal (1 subgoal):\n 1. fst z \\<in> set xs' \\<Longrightarrow> h \\<le> fst z", "with *"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set xs'. h < y\n  fst z \\<in> set xs'", "have \"h < fst z\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set xs'. h < y\n  fst z \\<in> set xs'\n\ngoal (1 subgoal):\n 1. h < fst z", ".."], ["proof (state)\nthis:\n  h < fst z\n\ngoal (1 subgoal):\n 1. fst z \\<in> set xs' \\<Longrightarrow> h \\<le> fst z", "thus ?thesis"], ["proof (prove)\nusing this:\n  h < fst z\n\ngoal (1 subgoal):\n 1. h \\<le> fst z", "by simp"], ["proof (state)\nthis:\n  h \\<le> fst z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h \\<le> fst z\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "finally"], ["proof (chain)\npicking this:\n  fst (OAlist_tc_min_key_val xs) \\<le> fst z", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (OAlist_tc_min_key_val xs) \\<le> fst z\n\ngoal (1 subgoal):\n 1. fst (OAlist_tc_min_key_val xs) \\<le> fst z", "."], ["proof (state)\nthis:\n  fst (OAlist_tc_min_key_val xs) \\<le> fst z\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const OAlist_tc_insert}\\<close>"], ["", "lemma list_of_oalist_OAlist_tc_insert [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_insert x xs) = update_by_pair_tc x (list_of_oalist_tc xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc_insert x xs) =\n    update_by_pair_tc x (list_of_oalist_tc xs)", "unfolding OAlist_tc_insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc\n     (OAlist_tc (update_by_pair_tc x (list_of_oalist_tc xs))) =\n    update_by_pair_tc x (list_of_oalist_tc xs)", "by (rule list_of_oalist_tc_of_list_id, rule tc.oalist_inv_raw_update_by_pair, fact oalist_inv_list_of_oalist_tc)"], ["", "lemma lookup_OAlist_tc_insert: \"OAlist_tc_lookup (OAlist_tc_insert (k, v) xs) k' = (if k = k' then v else OAlist_tc_lookup xs k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_lookup (OAlist_tc_insert (k, v) xs) k' =\n    (if k = k' then v else OAlist_tc_lookup xs k')", "by (simp add: OAlist_tc_lookup_def tc.lookup_pair_update_by_pair oalist_inv_list_of_oalist_tc split del: if_split cong: if_cong)"], ["", "subsubsection \\<open>@{const OAlist_tc_update_by_fun} and @{const OAlist_tc_update_by_fun_gr}\\<close>"], ["", "lemma list_of_oalist_OAlist_tc_update_by_fun [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_update_by_fun k f xs) = update_by_fun_pair_tc k f (list_of_oalist_tc xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc_update_by_fun k f xs) =\n    update_by_fun_pair_tc k f (list_of_oalist_tc xs)", "unfolding OAlist_tc_update_by_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc\n     (OAlist_tc (update_by_fun_pair_tc k f (list_of_oalist_tc xs))) =\n    update_by_fun_pair_tc k f (list_of_oalist_tc xs)", "by (rule list_of_oalist_tc_of_list_id, rule tc.oalist_inv_raw_update_by_fun_pair, fact oalist_inv_list_of_oalist_tc)"], ["", "lemma lookup_OAlist_tc_update_by_fun:\n  \"OAlist_tc_lookup (OAlist_tc_update_by_fun k f xs) k' = (if k = k' then f else id) (OAlist_tc_lookup xs k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_lookup (OAlist_tc_update_by_fun k f xs) k' =\n    (if k = k' then f else id) (OAlist_tc_lookup xs k')", "by (simp add: OAlist_tc_lookup_def tc.lookup_pair_update_by_fun_pair oalist_inv_list_of_oalist_tc split del: if_split cong: if_cong)"], ["", "lemma list_of_oalist_OAlist_tc_update_by_fun_gr [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_update_by_fun_gr k f xs) = update_by_fun_gr_pair_tc k f (list_of_oalist_tc xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc_update_by_fun_gr k f xs) =\n    update_by_fun_gr_pair_tc k f (list_of_oalist_tc xs)", "unfolding OAlist_tc_update_by_fun_gr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc\n     (OAlist_tc (update_by_fun_gr_pair_tc k f (list_of_oalist_tc xs))) =\n    update_by_fun_gr_pair_tc k f (list_of_oalist_tc xs)", "by (rule list_of_oalist_tc_of_list_id, rule tc.oalist_inv_raw_update_by_fun_gr_pair, fact oalist_inv_list_of_oalist_tc)"], ["", "lemma OAlist_tc_update_by_fun_gr_eq_OAlist_tc_update_by_fun: \"OAlist_tc_update_by_fun_gr = OAlist_tc_update_by_fun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_update_by_fun_gr = OAlist_tc_update_by_fun", "by (rule, rule, rule,\n      simp add: OAlist_tc_update_by_fun_gr_def OAlist_tc_update_by_fun_def\n                tc.update_by_fun_gr_pair_eq_update_by_fun_pair oalist_inv_list_of_oalist_tc)"], ["", "subsubsection \\<open>@{const OAlist_tc_filter}\\<close>"], ["", "lemma list_of_oalist_OAlist_tc_filter [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_filter P xs) = filter P (list_of_oalist_tc xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc_filter P xs) =\n    filter P (list_of_oalist_tc xs)", "unfolding OAlist_tc_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc (filter P (list_of_oalist_tc xs))) =\n    filter P (list_of_oalist_tc xs)", "by (rule list_of_oalist_tc_of_list_id, rule tc.oalist_inv_raw_filter, fact oalist_inv_list_of_oalist_tc)"], ["", "lemma lookup_OAlist_tc_filter: \"OAlist_tc_lookup (OAlist_tc_filter P xs) k = (let v = OAlist_tc_lookup xs k in if P (k, v) then v else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_lookup (OAlist_tc_filter P xs) k =\n    (let v = OAlist_tc_lookup xs k in if P (k, v) then v else (0::'a))", "by (simp add: OAlist_tc_lookup_def tc.lookup_pair_filter oalist_inv_list_of_oalist_tc)"], ["", "subsubsection \\<open>@{const OAlist_tc_map_val}\\<close>"], ["", "lemma list_of_oalist_OAlist_tc_map_val [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_map_val f xs) = map_val_pair f (list_of_oalist_tc xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc_map_val f xs) =\n    map_val_pair f (list_of_oalist_tc xs)", "unfolding OAlist_tc_map_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc (map_val_pair f (list_of_oalist_tc xs))) =\n    map_val_pair f (list_of_oalist_tc xs)", "by (rule list_of_oalist_tc_of_list_id, rule tc.oalist_inv_raw_map_val_pair, fact oalist_inv_list_of_oalist_tc)"], ["", "lemma OAlist_tc_map_val_cong:\n  assumes \"\\<And>k v. (k, v) \\<in> set (list_of_oalist_tc xs) \\<Longrightarrow> f k v = g k v\"\n  shows \"OAlist_tc_map_val f xs = OAlist_tc_map_val g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_map_val f xs = OAlist_tc_map_val g xs", "unfolding OAlist_tc_map_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc (map_val_pair f (list_of_oalist_tc xs)) =\n    OAlist_tc (map_val_pair g (list_of_oalist_tc xs))", "by (rule arg_cong[where f=OAlist_tc], rule tc.map_val_pair_cong, elim assms)"], ["", "lemma lookup_OAlist_tc_map_val: \"f k 0 = 0 \\<Longrightarrow> OAlist_tc_lookup (OAlist_tc_map_val f xs) k = f k (OAlist_tc_lookup xs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k (0::'c) = (0::'a) \\<Longrightarrow>\n    OAlist_tc_lookup (OAlist_tc_map_val f xs) k =\n    f k (OAlist_tc_lookup xs k)", "by (simp add: OAlist_tc_lookup_def tc.lookup_pair_map_val_pair oalist_inv_list_of_oalist_tc)"], ["", "subsubsection \\<open>@{const OAlist_tc_map2_val} @{const OAlist_tc_map2_val_rneutr} and @{const OAlist_tc_map2_val_neutr}\\<close>"], ["", "lemma list_of_oalist_map2_val [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_map2_val f xs ys) =\n      map2_val_pair_tc f (map_val_pair (\\<lambda>k b. f k b 0)) (map_val_pair (\\<lambda>k. f k 0)) (list_of_oalist_tc xs) (list_of_oalist_tc ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc_map2_val f xs ys) =\n    map2_val_pair_tc f (map_val_pair (\\<lambda>k v. f k v (0::'d)))\n     (map_val_pair (\\<lambda>k. f k (0::'c))) (list_of_oalist_tc xs)\n     (list_of_oalist_tc ys)", "unfolding OAlist_tc_map2_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc\n     (OAlist_tc\n       (map2_val_pair_tc f (map_val_pair (\\<lambda>k v. f k v (0::'d)))\n         (map_val_pair (\\<lambda>k. f k (0::'c))) (list_of_oalist_tc xs)\n         (list_of_oalist_tc ys))) =\n    map2_val_pair_tc f (map_val_pair (\\<lambda>k v. f k v (0::'d)))\n     (map_val_pair (\\<lambda>k. f k (0::'c))) (list_of_oalist_tc xs)\n     (list_of_oalist_tc ys)", "by (rule list_of_oalist_tc_of_list_id, rule tc.oalist_inv_raw_map2_val_pair,\n      fact oalist_inv_list_of_oalist_tc, fact oalist_inv_list_of_oalist_tc,\n      fact tc.map2_val_compat_map_val_pair, fact tc.map2_val_compat_map_val_pair)"], ["", "lemma list_of_oalist_OAlist_tc_map2_val_rneutr [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_map2_val_rneutr f xs ys) =\n      map2_val_pair_tc f id (map_val_pair (\\<lambda>k c. f k 0 c)) (list_of_oalist_tc xs) (list_of_oalist_tc ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc_map2_val_rneutr f xs ys) =\n    map2_val_pair_tc f id (map_val_pair (\\<lambda>k. f k (0::'b)))\n     (list_of_oalist_tc xs) (list_of_oalist_tc ys)", "unfolding OAlist_tc_map2_val_rneutr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc\n     (OAlist_tc\n       (map2_val_pair_tc f id (map_val_pair (\\<lambda>k. f k (0::'b)))\n         (list_of_oalist_tc xs) (list_of_oalist_tc ys))) =\n    map2_val_pair_tc f id (map_val_pair (\\<lambda>k. f k (0::'b)))\n     (list_of_oalist_tc xs) (list_of_oalist_tc ys)", "by (rule list_of_oalist_tc_of_list_id, rule tc.oalist_inv_raw_map2_val_pair,\n      fact oalist_inv_list_of_oalist_tc, fact oalist_inv_list_of_oalist_tc,\n      fact tc.map2_val_compat_id, fact tc.map2_val_compat_map_val_pair)"], ["", "lemma list_of_oalist_OAlist_tc_map2_val_neutr [simp, code abstract]:\n  \"list_of_oalist_tc (OAlist_tc_map2_val_neutr f xs ys) = map2_val_pair_tc f id id (list_of_oalist_tc xs) (list_of_oalist_tc ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc (OAlist_tc_map2_val_neutr f xs ys) =\n    map2_val_pair_tc f id id (list_of_oalist_tc xs) (list_of_oalist_tc ys)", "unfolding OAlist_tc_map2_val_neutr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_tc\n     (OAlist_tc\n       (map2_val_pair_tc f id id (list_of_oalist_tc xs)\n         (list_of_oalist_tc ys))) =\n    map2_val_pair_tc f id id (list_of_oalist_tc xs) (list_of_oalist_tc ys)", "by (rule list_of_oalist_tc_of_list_id, rule tc.oalist_inv_raw_map2_val_pair,\n      fact oalist_inv_list_of_oalist_tc, fact oalist_inv_list_of_oalist_tc,\n      fact tc.map2_val_compat_id, fact tc.map2_val_compat_id)"], ["", "lemma lookup_OAlist_tc_map2_val:\n  assumes \"\\<And>k. f k 0 0 = 0\"\n  shows \"OAlist_tc_lookup (OAlist_tc_map2_val f xs ys) k = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_lookup (OAlist_tc_map2_val f xs ys) k =\n    f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)", "by (simp add: OAlist_tc_lookup_def tc.lookup_pair_map2_val_pair\n      tc.map2_val_compat_map_val_pair assms oalist_inv_list_of_oalist_tc)"], ["", "lemma lookup_OAlist_tc_map2_val_rneutr:\n  assumes \"\\<And>k x. f k x 0 = x\"\n  shows \"OAlist_tc_lookup (OAlist_tc_map2_val_rneutr f xs ys) k = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_lookup (OAlist_tc_map2_val_rneutr f xs ys) k =\n    f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)", "proof (simp add: OAlist_tc_lookup_def, rule tc.lookup_pair_map2_val_pair)"], ["proof (state)\ngoal (7 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat (map_val_pair (\\<lambda>k. f k (0::'b)))\n 5. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs\n 6. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       map_val_pair (\\<lambda>k. f k (0::'b)) zs =\n       map_val_pair (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'c) = (0::'b)", "fix zs::\"('a \\<times> 'b) list\""], ["proof (state)\ngoal (7 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat (map_val_pair (\\<lambda>k. f k (0::'b)))\n 5. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs\n 6. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       map_val_pair (\\<lambda>k. f k (0::'b)) zs =\n       map_val_pair (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'c) = (0::'b)", "assume \"tc.oalist_inv_raw zs\""], ["proof (state)\nthis:\n  tc.oalist_inv_raw zs\n\ngoal (7 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat (map_val_pair (\\<lambda>k. f k (0::'b)))\n 5. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs\n 6. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       map_val_pair (\\<lambda>k. f k (0::'b)) zs =\n       map_val_pair (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'c) = (0::'b)", "thus \"id zs = map_val_pair (\\<lambda>k v. f k v 0) zs\""], ["proof (prove)\nusing this:\n  tc.oalist_inv_raw zs\n\ngoal (1 subgoal):\n 1. id zs = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs", "by (simp add: assms tc.map_pair_id)"], ["proof (state)\nthis:\n  id zs = map_val_pair (\\<lambda>k v. f k v (0::'c)) zs\n\ngoal (6 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat (map_val_pair (\\<lambda>k. f k (0::'b)))\n 5. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       map_val_pair (\\<lambda>k. f k (0::'b)) zs =\n       map_val_pair (\\<lambda>k. f k (0::'b)) zs\n 6. \\<And>k. f k (0::'b) (0::'c) = (0::'b)", "qed (fact oalist_inv_list_of_oalist_tc, fact oalist_inv_list_of_oalist_tc,\n    fact tc.map2_val_compat_id, fact tc.map2_val_compat_map_val_pair, rule refl, simp only: assms)"], ["", "lemma lookup_OAlist_tc_map2_val_neutr:\n  assumes \"\\<And>k x. f k x 0 = x\" and \"\\<And>k x. f k 0 x = x\"\n  shows \"OAlist_tc_lookup (OAlist_tc_map2_val_neutr f xs ys) k = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_lookup (OAlist_tc_map2_val_neutr f xs ys) k =\n    f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)", "proof (simp add: OAlist_tc_lookup_def, rule tc.lookup_pair_map2_val_pair)"], ["proof (state)\ngoal (7 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat id\n 5. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k v. f k v (0::'b)) zs\n 6. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "fix zs::\"('a \\<times> 'b) list\""], ["proof (state)\ngoal (7 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat id\n 5. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k v. f k v (0::'b)) zs\n 6. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "assume \"tc.oalist_inv_raw zs\""], ["proof (state)\nthis:\n  tc.oalist_inv_raw zs\n\ngoal (7 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat id\n 5. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k v. f k v (0::'b)) zs\n 6. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k. f k (0::'b)) zs\n 7. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "thus \"id zs = map_val_pair (\\<lambda>k v. f k v 0) zs\""], ["proof (prove)\nusing this:\n  tc.oalist_inv_raw zs\n\ngoal (1 subgoal):\n 1. id zs = map_val_pair (\\<lambda>k v. f k v (0::'b)) zs", "by (simp add: assms(1) tc.map_pair_id)"], ["proof (state)\nthis:\n  id zs = map_val_pair (\\<lambda>k v. f k v (0::'b)) zs\n\ngoal (6 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat id\n 5. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k. f k (0::'b)) zs\n 6. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat id\n 5. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k. f k (0::'b)) zs\n 6. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "fix zs::\"('a \\<times> 'b) list\""], ["proof (state)\ngoal (6 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat id\n 5. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k. f k (0::'b)) zs\n 6. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "assume \"tc.oalist_inv_raw zs\""], ["proof (state)\nthis:\n  tc.oalist_inv_raw zs\n\ngoal (6 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat id\n 5. \\<And>zs.\n       tc.oalist_inv_raw zs \\<Longrightarrow>\n       id zs = map_val_pair (\\<lambda>k. f k (0::'b)) zs\n 6. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "thus \"id zs = map_val_pair (\\<lambda>k. f k 0) zs\""], ["proof (prove)\nusing this:\n  tc.oalist_inv_raw zs\n\ngoal (1 subgoal):\n 1. id zs = map_val_pair (\\<lambda>k. f k (0::'b)) zs", "by (simp add: assms(2) tc.map_pair_id)"], ["proof (state)\nthis:\n  id zs = map_val_pair (\\<lambda>k. f k (0::'b)) zs\n\ngoal (5 subgoals):\n 1. tc.oalist_inv_raw (list_of_oalist_tc xs)\n 2. tc.oalist_inv_raw (list_of_oalist_tc ys)\n 3. tc.map2_val_compat id\n 4. tc.map2_val_compat id\n 5. \\<And>k. f k (0::'b) (0::'b) = (0::'b)", "qed (fact oalist_inv_list_of_oalist_tc, fact oalist_inv_list_of_oalist_tc,\n    fact tc.map2_val_compat_id, fact tc.map2_val_compat_id, simp only: assms(1))"], ["", "lemma OAlist_tc_map2_val_rneutr_singleton_eq_OAlist_tc_update_by_fun:\n  assumes \"\\<And>a x. f a x 0 = x\" and \"list_of_oalist_tc ys = [(k, v)]\"\n  shows \"OAlist_tc_map2_val_rneutr f xs ys = OAlist_tc_update_by_fun k (\\<lambda>x. f k x v) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_map2_val_rneutr f xs ys =\n    OAlist_tc_update_by_fun k (\\<lambda>x. f k x v) xs", "by (simp add: OAlist_tc_map2_val_rneutr_def OAlist_tc_update_by_fun_def assms\n      tc.map2_val_pair_singleton_eq_update_by_fun_pair oalist_inv_list_of_oalist_tc)"], ["", "subsubsection \\<open>@{const OAlist_tc_lex_ord} and @{const OAlist_tc_prod_ord}\\<close>"], ["", "lemma OAlist_tc_lex_ord_EqI:\n  \"(\\<And>k. k \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys) \\<Longrightarrow>\n     f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k) = Some Eq) \\<Longrightarrow>\n  OAlist_tc_lex_ord f xs ys = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                fst ` set (list_of_oalist_tc ys) \\<Longrightarrow>\n        f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k) =\n        Some Eq) \\<Longrightarrow>\n    OAlist_tc_lex_ord f xs ys = Some Eq", "by (simp add: OAlist_tc_lex_ord_def OAlist_tc_lookup_def, rule tc.lex_ord_pair_EqI,\n      rule oalist_inv_list_of_oalist_tc, rule oalist_inv_list_of_oalist_tc, blast)"], ["", "lemma OAlist_tc_lex_ord_valI:\n  assumes \"aux \\<noteq> Some Eq\" and \"k \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys)\"\n  shows \"aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k) \\<Longrightarrow>\n         (\\<And>k'. k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys) \\<Longrightarrow>\n              k' < k \\<Longrightarrow> f k' (OAlist_tc_lookup xs k') (OAlist_tc_lookup ys k') = Some Eq) \\<Longrightarrow>\n          OAlist_tc_lex_ord f xs ys = aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k);\n     \\<And>k'.\n        \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                          fst ` set (list_of_oalist_tc ys);\n         k' < k\\<rbrakk>\n        \\<Longrightarrow> f k' (OAlist_tc_lookup xs k')\n                           (OAlist_tc_lookup ys k') =\n                          Some Eq\\<rbrakk>\n    \\<Longrightarrow> OAlist_tc_lex_ord f xs ys = aux", "by (simp (no_asm_use) add: OAlist_tc_lex_ord_def OAlist_tc_lookup_def, rule tc.lex_ord_pair_valI,\n      rule oalist_inv_list_of_oalist_tc, rule oalist_inv_list_of_oalist_tc, rule assms(1), rule assms(2), simp_all)"], ["", "lemma OAlist_tc_lex_ord_EqD:\n  \"OAlist_tc_lex_ord f xs ys = Some Eq \\<Longrightarrow>\n   k \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys) \\<Longrightarrow>\n   f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k) = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OAlist_tc_lex_ord f xs ys = Some Eq;\n     k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n             fst ` set (list_of_oalist_tc ys)\\<rbrakk>\n    \\<Longrightarrow> f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k) =\n                      Some Eq", "by (simp add: OAlist_tc_lex_ord_def OAlist_tc_lookup_def, rule tc.lex_ord_pair_EqD[where f=f],\n      rule oalist_inv_list_of_oalist_tc, rule oalist_inv_list_of_oalist_tc, assumption, simp)"], ["", "lemma OAlist_tc_lex_ord_valE:\n  assumes \"OAlist_tc_lex_ord f xs ys = aux\" and \"aux \\<noteq> Some Eq\"\n  obtains k where \"k \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys)\"\n    and \"aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys) \\<Longrightarrow>\n            k' < k \\<Longrightarrow> f k' (OAlist_tc_lookup xs k') (OAlist_tc_lookup ys k') = Some Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                         fst ` set (list_of_oalist_tc ys);\n         aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                              fst ` set (list_of_oalist_tc ys);\n             k' < k\\<rbrakk>\n            \\<Longrightarrow> f k' (OAlist_tc_lookup xs k')\n                               (OAlist_tc_lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                         fst ` set (list_of_oalist_tc ys);\n         aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                              fst ` set (list_of_oalist_tc ys);\n             k' < k\\<rbrakk>\n            \\<Longrightarrow> f k' (OAlist_tc_lookup xs k')\n                               (OAlist_tc_lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note oalist_inv_list_of_oalist_tc oalist_inv_list_of_oalist_tc"], ["proof (state)\nthis:\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                         fst ` set (list_of_oalist_tc ys);\n         aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                              fst ` set (list_of_oalist_tc ys);\n             k' < k\\<rbrakk>\n            \\<Longrightarrow> f k' (OAlist_tc_lookup xs k')\n                               (OAlist_tc_lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                         fst ` set (list_of_oalist_tc ys);\n         aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                              fst ` set (list_of_oalist_tc ys);\n             k' < k\\<rbrakk>\n            \\<Longrightarrow> f k' (OAlist_tc_lookup xs k')\n                               (OAlist_tc_lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(1)"], ["proof (chain)\npicking this:\n  OAlist_tc_lex_ord f xs ys = aux", "have \"lex_ord_pair_tc f (list_of_oalist_tc xs) (list_of_oalist_tc ys) = aux\""], ["proof (prove)\nusing this:\n  OAlist_tc_lex_ord f xs ys = aux\n\ngoal (1 subgoal):\n 1. lex_ord_pair_tc f (list_of_oalist_tc xs) (list_of_oalist_tc ys) = aux", "by (simp only: OAlist_tc_lex_ord_def)"], ["proof (state)\nthis:\n  lex_ord_pair_tc f (list_of_oalist_tc xs) (list_of_oalist_tc ys) = aux\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                         fst ` set (list_of_oalist_tc ys);\n         aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                              fst ` set (list_of_oalist_tc ys);\n             k' < k\\<rbrakk>\n            \\<Longrightarrow> f k' (OAlist_tc_lookup xs k')\n                               (OAlist_tc_lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n  lex_ord_pair_tc f (list_of_oalist_tc xs) (list_of_oalist_tc ys) = aux", "obtain k where 1: \"k \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys)\"\n    and \"aux = f k (lookup_pair_tc (list_of_oalist_tc xs) k) (lookup_pair_tc (list_of_oalist_tc ys) k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys) \\<Longrightarrow>\n            k' < k \\<Longrightarrow>\n            f k' (lookup_pair_tc (list_of_oalist_tc xs) k') (lookup_pair_tc (list_of_oalist_tc ys) k') = Some Eq\""], ["proof (prove)\nusing this:\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n  lex_ord_pair_tc f (list_of_oalist_tc xs) (list_of_oalist_tc ys) = aux\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                         fst ` set (list_of_oalist_tc ys);\n         aux =\n         f k (lookup_pair_tc (list_of_oalist_tc xs) k)\n          (lookup_pair_tc (list_of_oalist_tc ys) k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                              fst ` set (list_of_oalist_tc ys);\n             k' < k\\<rbrakk>\n            \\<Longrightarrow> f k'\n                               (lookup_pair_tc (list_of_oalist_tc xs) k')\n                               (lookup_pair_tc (list_of_oalist_tc ys) k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n  lex_ord_pair_tc f (list_of_oalist_tc xs) (list_of_oalist_tc ys) = aux\n  aux \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                         fst ` set (list_of_oalist_tc ys);\n         aux =\n         f k (lookup_pair_tc (list_of_oalist_tc xs) k)\n          (lookup_pair_tc (list_of_oalist_tc ys) k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                              fst ` set (list_of_oalist_tc ys);\n             k' < k\\<rbrakk>\n            \\<Longrightarrow> f k'\n                               (lookup_pair_tc (list_of_oalist_tc xs) k')\n                               (lookup_pair_tc (list_of_oalist_tc ys) k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding tc_le_lt[symmetric]"], ["proof (prove)\nusing this:\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n  tc.oalist_inv_raw (list_of_oalist_tc ?xs)\n  lex_ord_pair_tc f (list_of_oalist_tc xs) (list_of_oalist_tc ys) = aux\n  aux \\<noteq> Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                         fst ` set (list_of_oalist_tc ys);\n         aux =\n         f k (lookup_pair_tc (list_of_oalist_tc xs) k)\n          (lookup_pair_tc (list_of_oalist_tc ys) k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                              fst ` set (list_of_oalist_tc ys);\n             tc.lt k' k\\<rbrakk>\n            \\<Longrightarrow> f k'\n                               (lookup_pair_tc (list_of_oalist_tc xs) k')\n                               (lookup_pair_tc (list_of_oalist_tc ys) k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule tc.lex_ord_pair_valE, blast)"], ["proof (state)\nthis:\n  k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n          fst ` set (list_of_oalist_tc ys)\n  aux =\n  f k (lookup_pair_tc (list_of_oalist_tc xs) k)\n   (lookup_pair_tc (list_of_oalist_tc ys) k)\n  \\<lbrakk>?k'\n           \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                 fst ` set (list_of_oalist_tc ys);\n   ?k' < k\\<rbrakk>\n  \\<Longrightarrow> f ?k' (lookup_pair_tc (list_of_oalist_tc xs) ?k')\n                     (lookup_pair_tc (list_of_oalist_tc ys) ?k') =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                         fst ` set (list_of_oalist_tc ys);\n         aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                              fst ` set (list_of_oalist_tc ys);\n             k' < k\\<rbrakk>\n            \\<Longrightarrow> f k' (OAlist_tc_lookup xs k')\n                               (OAlist_tc_lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(2, 3)"], ["proof (chain)\npicking this:\n  aux =\n  f k (lookup_pair_tc (list_of_oalist_tc xs) k)\n   (lookup_pair_tc (list_of_oalist_tc ys) k)\n  \\<lbrakk>?k'\n           \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                 fst ` set (list_of_oalist_tc ys);\n   ?k' < k\\<rbrakk>\n  \\<Longrightarrow> f ?k' (lookup_pair_tc (list_of_oalist_tc xs) ?k')\n                     (lookup_pair_tc (list_of_oalist_tc ys) ?k') =\n                    Some Eq", "have \"aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\"\n    and \"\\<And>k'. k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys) \\<Longrightarrow>\n            k' < k \\<Longrightarrow> f k' (OAlist_tc_lookup xs k') (OAlist_tc_lookup ys k') = Some Eq\""], ["proof (prove)\nusing this:\n  aux =\n  f k (lookup_pair_tc (list_of_oalist_tc xs) k)\n   (lookup_pair_tc (list_of_oalist_tc ys) k)\n  \\<lbrakk>?k'\n           \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                 fst ` set (list_of_oalist_tc ys);\n   ?k' < k\\<rbrakk>\n  \\<Longrightarrow> f ?k' (lookup_pair_tc (list_of_oalist_tc xs) ?k')\n                     (lookup_pair_tc (list_of_oalist_tc ys) ?k') =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k) &&&\n    (\\<And>k'.\n        \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                          fst ` set (list_of_oalist_tc ys);\n         k' < k\\<rbrakk>\n        \\<Longrightarrow> f k' (OAlist_tc_lookup xs k')\n                           (OAlist_tc_lookup ys k') =\n                          Some Eq)", "by (simp_all only: OAlist_tc_lookup_def)"], ["proof (state)\nthis:\n  aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\n  \\<lbrakk>?k'\n           \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                 fst ` set (list_of_oalist_tc ys);\n   ?k' < k\\<rbrakk>\n  \\<Longrightarrow> f ?k' (OAlist_tc_lookup xs ?k')\n                     (OAlist_tc_lookup ys ?k') =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                         fst ` set (list_of_oalist_tc ys);\n         aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k);\n         \\<And>k'.\n            \\<lbrakk>k' \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                              fst ` set (list_of_oalist_tc ys);\n             k' < k\\<rbrakk>\n            \\<Longrightarrow> f k' (OAlist_tc_lookup xs k')\n                               (OAlist_tc_lookup ys k') =\n                              Some Eq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with 1"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n          fst ` set (list_of_oalist_tc ys)\n  aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\n  \\<lbrakk>?k'\n           \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                 fst ` set (list_of_oalist_tc ys);\n   ?k' < k\\<rbrakk>\n  \\<Longrightarrow> f ?k' (OAlist_tc_lookup xs ?k')\n                     (OAlist_tc_lookup ys ?k') =\n                    Some Eq", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n          fst ` set (list_of_oalist_tc ys)\n  aux = f k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k)\n  \\<lbrakk>?k'\n           \\<in> fst ` set (list_of_oalist_tc xs) \\<union>\n                 fst ` set (list_of_oalist_tc ys);\n   ?k' < k\\<rbrakk>\n  \\<Longrightarrow> f ?k' (OAlist_tc_lookup xs ?k')\n                     (OAlist_tc_lookup ys ?k') =\n                    Some Eq\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OAlist_tc_prod_ord_alt:\n  \"OAlist_tc_prod_ord P xs ys \\<longleftrightarrow>\n                  (\\<forall>k\\<in>fst ` set (list_of_oalist_tc xs) \\<union> fst ` set (list_of_oalist_tc ys).\n                      P k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_prod_ord P xs ys =\n    (\\<forall>k\\<in>fst ` set (list_of_oalist_tc xs) \\<union>\n                    fst ` set (list_of_oalist_tc ys).\n        P k (OAlist_tc_lookup xs k) (OAlist_tc_lookup ys k))", "by (simp add: OAlist_tc_prod_ord_def OAlist_tc_lookup_def tc.prod_ord_pair_alt oalist_inv_list_of_oalist_tc)"], ["", "subsubsection \\<open>Instance of @{class equal}\\<close>"], ["", "instantiation oalist_tc :: (linorder, zero) equal\nbegin"], ["", "definition equal_oalist_tc :: \"('a, 'b) oalist_tc \\<Rightarrow> ('a, 'b) oalist_tc \\<Rightarrow> bool\"\n  where \"equal_oalist_tc xs ys = (list_of_oalist_tc xs = list_of_oalist_tc ys)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) oalist_tc, equal_class)", "by (intro_classes, simp add: equal_oalist_tc_def list_of_oalist_tc_inject)"], ["", "end"], ["", "subsection \\<open>Experiment\\<close>"], ["", "lemma \"oalist_tc_of_list [(0::nat, 4::nat), (1, 3), (0, 2), (1, 1)] = oalist_tc_of_list [(0, 4), (1, 3)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oalist_tc_of_list [(0, 4), (1, 3), (0, 2), (1, 1)] =\n    oalist_tc_of_list [(0, 4), (1, 3)]", "by eval"], ["", "lemma \"OAlist_tc_except_min (oalist_tc_of_list ([(1, 3), (0::nat, 4::nat), (0, 2), (1, 1)])) = oalist_tc_of_list [(1, 3)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_except_min\n     (oalist_tc_of_list [(1, 3), (0, 4), (0, 2), (1, 1)]) =\n    oalist_tc_of_list [(1, 3)]", "by eval"], ["", "lemma \"OAlist_tc_min_key_val (oalist_tc_of_list [(1, 3), (0::nat, 4::nat), (0, 2), (1, 1)]) = (0, 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_min_key_val\n     (oalist_tc_of_list [(1, 3), (0, 4), (0, 2), (1, 1)]) =\n    (0, 4)", "by eval"], ["", "lemma \"OAlist_tc_lookup (oalist_tc_of_list [(0::nat, 4::nat), (1, 3), (0, 2), (1, 1)]) 1 = 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_lookup (oalist_tc_of_list [(0, 4), (1, 3), (0, 2), (1, 1)])\n     1 =\n    3", "by eval"], ["", "lemma \"OAlist_tc_prod_ord (\\<lambda>_. greater_eq)\n                (oalist_tc_of_list [(1, 4), (0::nat, 4::nat), (1, 3), (0, 2), (3, 1)])\n                (oalist_tc_of_list [(0, 4), (1, 3), (2, 2), (1, 1)]) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_prod_ord (\\<lambda>_ x y. y \\<le> x)\n     (oalist_tc_of_list [(1, 4), (0, 4), (1, 3), (0, 2), (3, 1)])\n     (oalist_tc_of_list [(0, 4), (1, 3), (2, 2), (1, 1)]) =\n    False", "by eval"], ["", "lemma \"OAlist_tc_map2_val_rneutr (\\<lambda>_. minus)\n                (oalist_tc_of_list [(1, 4), (0::nat, 4::int), (1, 3), (0, 2), (3, 1)])\n                (oalist_tc_of_list [(0, 4), (1, 3), (2, 2), (1, 1)]) =\n             oalist_tc_of_list [(1, 1), (2, - 2), (3, 1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OAlist_tc_map2_val_rneutr (\\<lambda>_. (-))\n     (oalist_tc_of_list [(1, 4), (0, 4), (1, 3), (0, 2), (3, 1)])\n     (oalist_tc_of_list [(0, 4), (1, 3), (2, 2), (1, 1)]) =\n    oalist_tc_of_list [(1, 1), (2, - 2), (3, 1)]", "by eval"], ["", "end"], ["", "(* theory *)"]]}