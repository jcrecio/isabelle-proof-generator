{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/PP_Type.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma lookup_pp_of_fun: \"finite {x. f x \\<noteq> 0} \\<Longrightarrow> lookup_pp (pp_of_fun f) = f\"", "lemma pp_of_lookup: \"pp_of_fun (lookup_pp t) = t\"", "lemma pp_eqI: \"(\\<And>u. lookup_pp s u = lookup_pp t u) \\<Longrightarrow> s = t\"", "lemma pp_eq_iff: \"(s = t) \\<longleftrightarrow> (lookup_pp s = lookup_pp t)\"", "lemma keys_pp_iff: \"x \\<in> keys_pp t \\<longleftrightarrow> (lookup_pp t x \\<noteq> 0)\"", "lemma pp_eqI':\n  assumes \"\\<And>u. u \\<in> keys_pp s \\<union> keys_pp t \\<Longrightarrow> lookup_pp s u = lookup_pp t u\"\n  shows \"s = t\"", "lemma lookup_single_pp: \"lookup_pp (single_pp x e) y = (e when x = y)\"", "lemma lookup_zero_pp [simp]: \"lookup_pp 0 = 0\"", "lemma single_pp_zero [simp]: \"single_pp x 0 = 0\"", "lemma lookup_plus_pp: \"lookup_pp (s + t) = lookup_pp s + lookup_pp t\"", "lemma single_pp_plus: \"single_pp x a + single_pp x b = single_pp x (a + b)\"", "lemma lookup_minus_pp: \"lookup_pp (s - t) = lookup_pp s - lookup_pp t\"", "lemma adds_pp_iff: \"(s adds t) \\<longleftrightarrow> (mapping_of s adds mapping_of t)\"", "lemma lookup_lcs_pp: \"lookup_pp (lcs s t) x = max (lookup_pp s x) (lookup_pp t x)\"", "lemma almost_full_on_pp_iff:\n  \"almost_full_on (adds) A \\<longleftrightarrow> almost_full_on (adds) (mapping_of ` A)\" (is \"?l \\<longleftrightarrow> ?r\")", "lemma dickson_grading_varnum_pp:\n  \"dickson_grading (varnum_pp::('a::countable, 'b::add_wellorder) pp \\<Rightarrow> nat)\"", "lemma lex_pp_alt: \"lex_pp s t = (s = t \\<or> (\\<exists>x. lookup_pp s x < lookup_pp t x \\<and> (\\<forall>y<x. lookup_pp s y = lookup_pp t y)))\"", "lemma lex_pp_refl: \"lex_pp s s\"", "lemma lex_pp_antisym: \"lex_pp s t \\<Longrightarrow> lex_pp t s \\<Longrightarrow> s = t\"", "lemma lex_pp_trans: \"lex_pp s t \\<Longrightarrow> lex_pp t u \\<Longrightarrow> lex_pp s u\"", "lemma lex_pp_lin: \"lex_pp s t \\<or> lex_pp t s\"", "lemma lex_pp_lin': \"\\<not> lex_pp t s \\<Longrightarrow> lex_pp s t\"", "lemma lex_pp_zero_min: \"lex_pp 0 s\" for s::\"(_, _::add_linorder_min) pp\"", "lemma lex_pp_plus_monotone: \"lex_pp s t \\<Longrightarrow> lex_pp (s + u) (t + u)\"\n  for s t::\"(_, _::{ordered_comm_monoid_add, ordered_ab_semigroup_add_imp_le}) pp\"", "lemma lex_pp_plus_monotone': \"lex_pp s t \\<Longrightarrow> lex_pp (u + s) (u + t)\"\n  for s t::\"(_, _::{ordered_comm_monoid_add, ordered_ab_semigroup_add_imp_le}) pp\"", "lemma deg_pp_alt: \"deg_pp s = sum (lookup_pp s) (keys_pp s)\"", "lemma deg_pp_zero [simp]: \"deg_pp 0 = 0\"", "lemma deg_pp_eq_0_iff [simp]: \"deg_pp s = 0 \\<longleftrightarrow> s = 0\" for s::\"('a, 'b::add_linorder_min) pp\"", "lemma deg_pp_plus: \"deg_pp (s + t) = deg_pp s + deg_pp (t::('a, 'b::comm_monoid_add) pp)\"", "lemma deg_pp_single: \"deg_pp (single_pp x k) = k\"", "lemma dlex_pp_alt: \"dlex_pp s t \\<longleftrightarrow> (deg_pp s < deg_pp t \\<or> (deg_pp s = deg_pp t \\<and> lex_pp s t))\"", "lemma dlex_pp_refl: \"dlex_pp s s\"", "lemma dlex_pp_antisym: \"dlex_pp s t \\<Longrightarrow> dlex_pp t s \\<Longrightarrow> s = t\"", "lemma dlex_pp_trans: \"dlex_pp s t \\<Longrightarrow> dlex_pp t u \\<Longrightarrow> dlex_pp s u\"", "lemma dlex_pp_lin: \"dlex_pp s t \\<or> dlex_pp t s\"", "lemma dlex_pp_zero_min: \"dlex_pp 0 s\"\n  for s t::\"(_, _::add_linorder_min) pp\"", "lemma dlex_pp_plus_monotone: \"dlex_pp s t \\<Longrightarrow> dlex_pp (s + u) (t + u)\"\n  for s t::\"(_, _::{ordered_ab_semigroup_add_imp_le, ordered_cancel_comm_monoid_add}) pp\"", "lemma drlex_pp_alt: \"drlex_pp s t \\<longleftrightarrow> (deg_pp s < deg_pp t \\<or> (deg_pp s = deg_pp t \\<and> lex_pp t s))\"", "lemma drlex_pp_refl: \"drlex_pp s s\"", "lemma drlex_pp_antisym: \"drlex_pp s t \\<Longrightarrow> drlex_pp t s \\<Longrightarrow> s = t\"", "lemma drlex_pp_trans: \"drlex_pp s t \\<Longrightarrow> drlex_pp t u \\<Longrightarrow> drlex_pp s u\"", "lemma drlex_pp_lin: \"drlex_pp s t \\<or> drlex_pp t s\"", "lemma drlex_pp_zero_min: \"drlex_pp 0 s\"\n  for s t::\"(_, _::add_linorder_min) pp\"", "lemma drlex_pp_plus_monotone: \"drlex_pp s t \\<Longrightarrow> drlex_pp (s + u) (t + u)\"\n  for s t::\"(_, _::{ordered_ab_semigroup_add_imp_le, ordered_cancel_comm_monoid_add}) pp\""], "translations": [["", "lemma lookup_pp_of_fun: \"finite {x. f x \\<noteq> 0} \\<Longrightarrow> lookup_pp (pp_of_fun f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> (0::'b)} \\<Longrightarrow>\n    lookup_pp (pp_of_fun f) = f", "by (transfer, rule Abs_poly_mapping_inverse, simp)"], ["", "lemma pp_of_lookup: \"pp_of_fun (lookup_pp t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_fun (lookup_pp t) = t", "by (transfer, fact lookup_inverse)"], ["", "lemma pp_eqI: \"(\\<And>u. lookup_pp s u = lookup_pp t u) \\<Longrightarrow> s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u. lookup_pp s u = lookup_pp t u) \\<Longrightarrow> s = t", "by (transfer, rule poly_mapping_eqI)"], ["", "lemma pp_eq_iff: \"(s = t) \\<longleftrightarrow> (lookup_pp s = lookup_pp t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s = t) = (lookup_pp s = lookup_pp t)", "by (auto intro: pp_eqI)"], ["", "lemma keys_pp_iff: \"x \\<in> keys_pp t \\<longleftrightarrow> (lookup_pp t x \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> keys_pp t) = (lookup_pp t x \\<noteq> (0::'b))", "by (simp add: in_keys_iff keys_pp.rep_eq lookup_pp.rep_eq)"], ["", "lemma pp_eqI':\n  assumes \"\\<And>u. u \\<in> keys_pp s \\<union> keys_pp t \\<Longrightarrow> lookup_pp s u = lookup_pp t u\"\n  shows \"s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "proof (rule pp_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u. lookup_pp s u = lookup_pp t u", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u. lookup_pp s u = lookup_pp t u", "show \"lookup_pp s u = lookup_pp t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp s u = lookup_pp t u", "proof (cases \"u \\<in> keys_pp s \\<union> keys_pp t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> keys_pp s \\<union> keys_pp t \\<Longrightarrow>\n    lookup_pp s u = lookup_pp t u\n 2. u \\<notin> keys_pp s \\<union> keys_pp t \\<Longrightarrow>\n    lookup_pp s u = lookup_pp t u", "case True"], ["proof (state)\nthis:\n  u \\<in> keys_pp s \\<union> keys_pp t\n\ngoal (2 subgoals):\n 1. u \\<in> keys_pp s \\<union> keys_pp t \\<Longrightarrow>\n    lookup_pp s u = lookup_pp t u\n 2. u \\<notin> keys_pp s \\<union> keys_pp t \\<Longrightarrow>\n    lookup_pp s u = lookup_pp t u", "thus ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> keys_pp s \\<union> keys_pp t\n\ngoal (1 subgoal):\n 1. lookup_pp s u = lookup_pp t u", "by (rule assms)"], ["proof (state)\nthis:\n  lookup_pp s u = lookup_pp t u\n\ngoal (1 subgoal):\n 1. u \\<notin> keys_pp s \\<union> keys_pp t \\<Longrightarrow>\n    lookup_pp s u = lookup_pp t u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> keys_pp s \\<union> keys_pp t \\<Longrightarrow>\n    lookup_pp s u = lookup_pp t u", "case False"], ["proof (state)\nthis:\n  u \\<notin> keys_pp s \\<union> keys_pp t\n\ngoal (1 subgoal):\n 1. u \\<notin> keys_pp s \\<union> keys_pp t \\<Longrightarrow>\n    lookup_pp s u = lookup_pp t u", "thus ?thesis"], ["proof (prove)\nusing this:\n  u \\<notin> keys_pp s \\<union> keys_pp t\n\ngoal (1 subgoal):\n 1. lookup_pp s u = lookup_pp t u", "by (simp add: keys_pp_iff)"], ["proof (state)\nthis:\n  lookup_pp s u = lookup_pp t u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_pp s u = lookup_pp t u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_single_pp: \"lookup_pp (single_pp x e) y = (e when x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp (single_pp x e) y = (e when x = y)", "by (transfer, simp only: lookup_single)"], ["", "subsection \\<open>Additive Structure\\<close>"], ["", "instantiation pp :: (type, zero) zero\nbegin"], ["", "lift_definition zero_pp :: \"('a, 'b) pp\" is \"0::'a \\<Rightarrow>\\<^sub>0 'b\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lookup_zero_pp [simp]: \"lookup_pp 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp 0 = 0", "by (transfer, simp add: lookup_zero_fun)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, zero_class)", ".."], ["", "end"], ["", "lemma single_pp_zero [simp]: \"single_pp x 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_pp x (0::'b) = 0", "by (rule pp_eqI, simp add: lookup_single_pp)"], ["", "instantiation pp :: (type, monoid_add) monoid_add\nbegin"], ["", "lift_definition plus_pp :: \"('a, 'b) pp \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> ('a, 'b) pp\" is \"(+)::('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> _\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lookup_plus_pp: \"lookup_pp (s + t) = lookup_pp s + lookup_pp t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp (s + t) = lookup_pp s + lookup_pp t", "by (transfer, simp add: lookup_plus_fun)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, monoid_add_class)", "by intro_classes (transfer, simp add: fun_eq_iff add.assoc)+"], ["", "end"], ["", "lemma single_pp_plus: \"single_pp x a + single_pp x b = single_pp x (a + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_pp x a + single_pp x b = single_pp x (a + b)", "by (rule pp_eqI, simp add: lookup_single_pp lookup_plus_pp when_def)"], ["", "instance pp :: (type, comm_monoid_add) comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, comm_monoid_add_class)", "by intro_classes (transfer, simp add: fun_eq_iff ac_simps)+"], ["", "instantiation pp :: (type, cancel_comm_monoid_add) cancel_comm_monoid_add\nbegin"], ["", "lift_definition minus_pp :: \"('a, 'b) pp \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> ('a, 'b) pp\" is \"(-)::('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> _\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lookup_minus_pp: \"lookup_pp (s - t) = lookup_pp s - lookup_pp t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp (s - t) = lookup_pp s - lookup_pp t", "by (transfer, simp only: lookup_minus_fun)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, cancel_comm_monoid_add_class)", "by intro_classes (transfer, simp add: fun_eq_iff diff_diff_add)+"], ["", "end"], ["", "subsection \\<open>@{typ \"('a, 'b) poly_mapping\"} belongs to class @{class comm_powerprod}\\<close>"], ["", "instance poly_mapping :: (type, cancel_comm_monoid_add) comm_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>0 'b, comm_powerprod_class)", "by standard"], ["", "subsection \\<open>@{typ \"('a, 'b) poly_mapping\"} belongs to class @{class ninv_comm_monoid_add}\\<close>"], ["", "instance poly_mapping :: (type, ninv_comm_monoid_add) ninv_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>0 'b, ninv_comm_monoid_add_class)", "proof (standard, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>finite {x. s x \\<noteq> (0::'b)};\n        finite {x. t x \\<noteq> (0::'b)};\n        (\\<lambda>k. s k + t k) = (\\<lambda>k. 0::'b)\\<rbrakk>\n       \\<Longrightarrow> s = (\\<lambda>k. 0::'b)", "fix s t::\"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>finite {x. s x \\<noteq> (0::'b)};\n        finite {x. t x \\<noteq> (0::'b)};\n        (\\<lambda>k. s k + t k) = (\\<lambda>k. 0::'b)\\<rbrakk>\n       \\<Longrightarrow> s = (\\<lambda>k. 0::'b)", "assume \"(\\<lambda>k. s k + t k) = (\\<lambda>_. 0)\""], ["proof (state)\nthis:\n  (\\<lambda>k. s k + t k) = (\\<lambda>_. 0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>finite {x. s x \\<noteq> (0::'b)};\n        finite {x. t x \\<noteq> (0::'b)};\n        (\\<lambda>k. s k + t k) = (\\<lambda>k. 0::'b)\\<rbrakk>\n       \\<Longrightarrow> s = (\\<lambda>k. 0::'b)", "hence \"s + t = 0\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. s k + t k) = (\\<lambda>_. 0::'b)\n\ngoal (1 subgoal):\n 1. s + t = 0", "by (simp only: plus_fun_def zero_fun_def)"], ["proof (state)\nthis:\n  s + t = 0\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>finite {x. s x \\<noteq> (0::'b)};\n        finite {x. t x \\<noteq> (0::'b)};\n        (\\<lambda>k. s k + t k) = (\\<lambda>k. 0::'b)\\<rbrakk>\n       \\<Longrightarrow> s = (\\<lambda>k. 0::'b)", "hence \"s = 0\""], ["proof (prove)\nusing this:\n  s + t = 0\n\ngoal (1 subgoal):\n 1. s = 0", "by (rule plus_eq_zero)"], ["proof (state)\nthis:\n  s = 0\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>finite {x. s x \\<noteq> (0::'b)};\n        finite {x. t x \\<noteq> (0::'b)};\n        (\\<lambda>k. s k + t k) = (\\<lambda>k. 0::'b)\\<rbrakk>\n       \\<Longrightarrow> s = (\\<lambda>k. 0::'b)", "thus \"s = (\\<lambda>_. 0)\""], ["proof (prove)\nusing this:\n  s = 0\n\ngoal (1 subgoal):\n 1. s = (\\<lambda>_. 0::'b)", "by (simp only: zero_fun_def)"], ["proof (state)\nthis:\n  s = (\\<lambda>_. 0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{typ \"('a, 'b) pp\"} belongs to class @{class lcs_powerprod}\\<close>"], ["", "lemma adds_pp_iff: \"(s adds t) \\<longleftrightarrow> (mapping_of s adds mapping_of t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s adds t) = (pp.mapping_of s adds pp.mapping_of t)", "unfolding adds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>k. t = s + k) =\n    (\\<exists>k. pp.mapping_of t = pp.mapping_of s + k)", "by (transfer, fact refl)"], ["", "instantiation pp :: (type, add_linorder) lcs_powerprod\nbegin"], ["", "lift_definition lcs_pp :: \"('a, 'b) pp \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> ('a, 'b) pp\" is \"lcs_powerprod_class.lcs\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lookup_lcs_pp: \"lookup_pp (lcs s t) x = max (lookup_pp s x) (lookup_pp t x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_pp (lcs s t) x = max (lookup_pp s x) (lookup_pp t x)", "by (transfer, simp add: lookup_lcs_fun lcs_fun_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, lcs_powerprod_class)", "apply (intro_classes, simp_all only: adds_pp_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t. pp.mapping_of s adds pp.mapping_of (lcs s t)\n 2. \\<And>s u t.\n       \\<lbrakk>pp.mapping_of s adds pp.mapping_of u;\n        pp.mapping_of t adds pp.mapping_of u\\<rbrakk>\n       \\<Longrightarrow> pp.mapping_of (lcs s t) adds pp.mapping_of u\n 3. \\<And>s t. lcs s t = lcs t s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp.mapping_of s_ adds pp.mapping_of (lcs s_ t_)", "by (transfer, rule adds_lcs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s u t.\n       \\<lbrakk>pp.mapping_of s adds pp.mapping_of u;\n        pp.mapping_of t adds pp.mapping_of u\\<rbrakk>\n       \\<Longrightarrow> pp.mapping_of (lcs s t) adds pp.mapping_of u\n 2. \\<And>s t. lcs s t = lcs t s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pp.mapping_of s_ adds pp.mapping_of u_;\n     pp.mapping_of t_ adds pp.mapping_of u_\\<rbrakk>\n    \\<Longrightarrow> pp.mapping_of (lcs s_ t_) adds pp.mapping_of u_", "by (transfer, elim lcs_adds)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t. lcs s t = lcs t s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs s_ t_ = lcs t_ s_", "by (transfer, rule lcs_comm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>@{typ \"('a, 'b) pp\"} belongs to class @{class ulcs_powerprod}\\<close>"], ["", "instance pp :: (type, add_linorder_min) ulcs_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, ulcs_powerprod_class)", "by intro_classes (transfer, elim plus_eq_zero)"], ["", "subsection \\<open>Dickson's lemma for power-products in finitely many indeterminates\\<close>"], ["", "lemma almost_full_on_pp_iff:\n  \"almost_full_on (adds) A \\<longleftrightarrow> almost_full_on (adds) (mapping_of ` A)\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (adds) A = almost_full_on (adds) (pp.mapping_of ` A)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_full_on (adds) A \\<Longrightarrow>\n    almost_full_on (adds) (pp.mapping_of ` A)\n 2. almost_full_on (adds) (pp.mapping_of ` A) \\<Longrightarrow>\n    almost_full_on (adds) A", "assume ?l"], ["proof (state)\nthis:\n  almost_full_on (adds) A\n\ngoal (2 subgoals):\n 1. almost_full_on (adds) A \\<Longrightarrow>\n    almost_full_on (adds) (pp.mapping_of ` A)\n 2. almost_full_on (adds) (pp.mapping_of ` A) \\<Longrightarrow>\n    almost_full_on (adds) A", "with _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  almost_full_on (adds) A", "show ?r"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  almost_full_on (adds) A\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) (pp.mapping_of ` A)", "proof (rule almost_full_on_hom)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; x adds y\\<rbrakk>\n       \\<Longrightarrow> pp.mapping_of x adds pp.mapping_of y", "fix x y :: \"('a, 'b) pp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; x adds y\\<rbrakk>\n       \\<Longrightarrow> pp.mapping_of x adds pp.mapping_of y", "assume \"x adds y\""], ["proof (state)\nthis:\n  x adds y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; x adds y\\<rbrakk>\n       \\<Longrightarrow> pp.mapping_of x adds pp.mapping_of y", "thus \"mapping_of x adds mapping_of y\""], ["proof (prove)\nusing this:\n  x adds y\n\ngoal (1 subgoal):\n 1. pp.mapping_of x adds pp.mapping_of y", "by (simp only: adds_pp_iff)"], ["proof (state)\nthis:\n  pp.mapping_of x adds pp.mapping_of y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_full_on (adds) (pp.mapping_of ` A)\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) (pp.mapping_of ` A) \\<Longrightarrow>\n    almost_full_on (adds) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_full_on (adds) (pp.mapping_of ` A) \\<Longrightarrow>\n    almost_full_on (adds) A", "assume ?r"], ["proof (state)\nthis:\n  almost_full_on (adds) (pp.mapping_of ` A)\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) (pp.mapping_of ` A) \\<Longrightarrow>\n    almost_full_on (adds) A", "hence \"almost_full_on (\\<lambda>x y. mapping_of x adds mapping_of y) A\""], ["proof (prove)\nusing this:\n  almost_full_on (adds) (pp.mapping_of ` A)\n\ngoal (1 subgoal):\n 1. almost_full_on (\\<lambda>x y. pp.mapping_of x adds pp.mapping_of y) A", "using subset_refl"], ["proof (prove)\nusing this:\n  almost_full_on (adds) (pp.mapping_of ` A)\n  ?A \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. almost_full_on (\\<lambda>x y. pp.mapping_of x adds pp.mapping_of y) A", "by (rule almost_full_on_map)"], ["proof (state)\nthis:\n  almost_full_on (\\<lambda>x y. pp.mapping_of x adds pp.mapping_of y) A\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) (pp.mapping_of ` A) \\<Longrightarrow>\n    almost_full_on (adds) A", "thus ?l"], ["proof (prove)\nusing this:\n  almost_full_on (\\<lambda>x y. pp.mapping_of x adds pp.mapping_of y) A\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) A", "by (simp only: adds_pp_iff[symmetric])"], ["proof (state)\nthis:\n  almost_full_on (adds) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition varnum_pp :: \"('a::countable, 'b::zero) pp \\<Rightarrow> nat\" is \"varnum {}\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma dickson_grading_varnum_pp:\n  \"dickson_grading (varnum_pp::('a::countable, 'b::add_wellorder) pp \\<Rightarrow> nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dickson_grading varnum_pp", "proof (rule dickson_gradingI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t. varnum_pp (s + t) = max (varnum_pp s) (varnum_pp t)\n 2. \\<And>n. almost_full_on (adds) {x. varnum_pp x \\<le> n}", "fix s t :: \"('a, 'b) pp\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t. varnum_pp (s + t) = max (varnum_pp s) (varnum_pp t)\n 2. \\<And>n. almost_full_on (adds) {x. varnum_pp x \\<le> n}", "show \"varnum_pp (s + t) = max (varnum_pp s) (varnum_pp t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. varnum_pp (s + t) = max (varnum_pp s) (varnum_pp t)", "by (transfer, rule varnum_plus)"], ["proof (state)\nthis:\n  varnum_pp (s + t) = max (varnum_pp s) (varnum_pp t)\n\ngoal (1 subgoal):\n 1. \\<And>n. almost_full_on (adds) {x. varnum_pp x \\<le> n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. almost_full_on (adds) {x. varnum_pp x \\<le> n}", "fix m::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. almost_full_on (adds) {x. varnum_pp x \\<le> n}", "show \"almost_full_on (adds) {x::('a, 'b) pp. varnum_pp x \\<le> m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. varnum_pp x \\<le> m}", "unfolding almost_full_on_pp_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (adds) (pp.mapping_of ` {x. varnum_pp x \\<le> m})", "proof (transfer, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. almost_full_on (adds) {x. varnum {} x \\<le> m}", "fix m::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. almost_full_on (adds) {x. varnum {} x \\<le> m}", "from dickson_grading_varnum_empty"], ["proof (chain)\npicking this:\n  dickson_grading (varnum {})", "show \"almost_full_on (adds) {x::'a \\<Rightarrow>\\<^sub>0 'b. varnum {} x \\<le> m}\""], ["proof (prove)\nusing this:\n  dickson_grading (varnum {})\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) {x. varnum {} x \\<le> m}", "by (rule dickson_gradingD2)"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. varnum {} x \\<le> m}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_full_on (adds) {x. varnum_pp x \\<le> m}\n\ngoal:\nNo subgoals!", "qed"], ["", "instance pp :: (countable, add_wellorder) graded_dickson_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, graded_dickson_powerprod_class)", "by (standard, rule, fact dickson_grading_varnum_pp)"], ["", "instance pp :: (finite, add_wellorder) dickson_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, dickson_powerprod_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_full_on (adds) UNIV", "have eq: \"range mapping_of = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj pp.mapping_of", "by (rule surjI, rule PP_inverse, rule UNIV_I)"], ["proof (state)\nthis:\n  surj pp.mapping_of\n\ngoal (1 subgoal):\n 1. almost_full_on (adds) UNIV", "show \"almost_full_on (adds) (UNIV::('a, 'b) pp set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (adds) UNIV", "by (simp add: almost_full_on_pp_iff eq dickson)"], ["proof (state)\nthis:\n  almost_full_on (adds) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lexicographic Term Order\\<close>"], ["", "lift_definition lex_pp :: \"('a, 'b) pp \\<Rightarrow> ('a::linorder, 'b::{zero,linorder}) pp \\<Rightarrow> bool\" is lex_pm"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition lex_pp_strict :: \"('a, 'b) pp \\<Rightarrow> ('a::linorder, 'b::{zero,linorder}) pp \\<Rightarrow> bool\" is lex_pm_strict"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lex_pp_alt: \"lex_pp s t = (s = t \\<or> (\\<exists>x. lookup_pp s x < lookup_pp t x \\<and> (\\<forall>y<x. lookup_pp s y = lookup_pp t y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp s t =\n    (s = t \\<or>\n     (\\<exists>x.\n         lookup_pp s x < lookup_pp t x \\<and>\n         (\\<forall>y<x. lookup_pp s y = lookup_pp t y)))", "by (transfer, fact lex_pm_alt)"], ["", "lemma lex_pp_refl: \"lex_pp s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp s s", "by (transfer, fact lex_pm_refl)"], ["", "lemma lex_pp_antisym: \"lex_pp s t \\<Longrightarrow> lex_pp t s \\<Longrightarrow> s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lex_pp s t; lex_pp t s\\<rbrakk> \\<Longrightarrow> s = t", "by (transfer, intro lex_pm_antisym)"], ["", "lemma lex_pp_trans: \"lex_pp s t \\<Longrightarrow> lex_pp t u \\<Longrightarrow> lex_pp s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lex_pp s t; lex_pp t u\\<rbrakk> \\<Longrightarrow> lex_pp s u", "by (transfer, rule lex_pm_trans)"], ["", "lemma lex_pp_lin: \"lex_pp s t \\<or> lex_pp t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp s t \\<or> lex_pp t s", "by (transfer, fact lex_pm_lin)"], ["", "lemma lex_pp_lin': \"\\<not> lex_pp t s \\<Longrightarrow> lex_pp s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lex_pp t s \\<Longrightarrow> lex_pp s t", "using lex_pp_lin"], ["proof (prove)\nusing this:\n  lex_pp ?s ?t \\<or> lex_pp ?t ?s\n\ngoal (1 subgoal):\n 1. \\<not> lex_pp t s \\<Longrightarrow> lex_pp s t", "by blast \\<comment>\\<open>Better suited for \\<open>auto\\<close>.\\<close>"], ["", "corollary lex_pp_strict_alt [code]:\n  \"lex_pp_strict s t = (\\<not> lex_pp t s)\" for s t::\"(_, _::ordered_comm_monoid_add) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp_strict s t = (\\<not> lex_pp t s)", "by (transfer, fact lex_pm_strict_alt)"], ["", "lemma lex_pp_zero_min: \"lex_pp 0 s\" for s::\"(_, _::add_linorder_min) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp 0 s", "by (transfer, fact lex_pm_zero_min)"], ["", "lemma lex_pp_plus_monotone: \"lex_pp s t \\<Longrightarrow> lex_pp (s + u) (t + u)\"\n  for s t::\"(_, _::{ordered_comm_monoid_add, ordered_ab_semigroup_add_imp_le}) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp s t \\<Longrightarrow> lex_pp (s + u) (t + u)", "by (transfer, intro lex_pm_plus_monotone)"], ["", "lemma lex_pp_plus_monotone': \"lex_pp s t \\<Longrightarrow> lex_pp (u + s) (u + t)\"\n  for s t::\"(_, _::{ordered_comm_monoid_add, ordered_ab_semigroup_add_imp_le}) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp s t \\<Longrightarrow> lex_pp (u + s) (u + t)", "unfolding add.commute[of u]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pp s t \\<Longrightarrow> lex_pp (s + u) (t + u)", "by (rule lex_pp_plus_monotone)"], ["", "instantiation pp :: (linorder, \"{ordered_comm_monoid_add, linorder}\") linorder\nbegin"], ["", "definition less_eq_pp :: \"('a, 'b) pp \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> bool\"\n  where \"less_eq_pp = lex_pp\""], ["", "definition less_pp :: \"('a, 'b) pp \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> bool\"\n  where \"less_pp = lex_pp_strict\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, linorder_class)", "by intro_classes (auto simp: less_eq_pp_def less_pp_def lex_pp_refl lex_pp_strict_alt intro: lex_pp_antisym lex_pp_lin' elim: lex_pp_trans)"], ["", "end"], ["", "subsection \\<open>Degree\\<close>"], ["", "lift_definition deg_pp :: \"('a, 'b::comm_monoid_add) pp \\<Rightarrow> 'b\" is deg_pm"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma deg_pp_alt: \"deg_pp s = sum (lookup_pp s) (keys_pp s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pp s = sum (lookup_pp s) (keys_pp s)", "by (transfer, transfer, simp add: deg_fun_def supp_fun_def)"], ["", "lemma deg_pp_zero [simp]: \"deg_pp 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pp 0 = (0::'a)", "by (transfer, fact deg_pm_zero)"], ["", "lemma deg_pp_eq_0_iff [simp]: \"deg_pp s = 0 \\<longleftrightarrow> s = 0\" for s::\"('a, 'b::add_linorder_min) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (deg_pp s = (0::'b)) = (s = 0)", "by (transfer, fact deg_pm_eq_0_iff)"], ["", "lemma deg_pp_plus: \"deg_pp (s + t) = deg_pp s + deg_pp (t::('a, 'b::comm_monoid_add) pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pp (s + t) = deg_pp s + deg_pp t", "by (transfer, fact deg_pm_plus)"], ["", "lemma deg_pp_single: \"deg_pp (single_pp x k) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pp (single_pp x k) = k", "by (transfer, fact deg_pm_single)"], ["", "subsection \\<open>Degree-Lexicographic Term Order\\<close>"], ["", "lift_definition dlex_pp :: \"('a::linorder, 'b::{ordered_comm_monoid_add,linorder}) pp \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> bool\"\n  is dlex_pm"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition dlex_pp_strict :: \"('a::linorder, 'b::{ordered_comm_monoid_add,linorder}) pp \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> bool\"\n  is dlex_pm_strict"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma dlex_pp_alt: \"dlex_pp s t \\<longleftrightarrow> (deg_pp s < deg_pp t \\<or> (deg_pp s = deg_pp t \\<and> lex_pp s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pp s t =\n    (deg_pp s < deg_pp t \\<or> deg_pp s = deg_pp t \\<and> lex_pp s t)", "by transfer (simp only: dlex_pm_def dord_pm_alt)"], ["", "lemma dlex_pp_refl: \"dlex_pp s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pp s s", "by (transfer) (fact dlex_pm_refl)"], ["", "lemma dlex_pp_antisym: \"dlex_pp s t \\<Longrightarrow> dlex_pp t s \\<Longrightarrow> s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dlex_pp s t; dlex_pp t s\\<rbrakk> \\<Longrightarrow> s = t", "by (transfer, elim dlex_pm_antisym)"], ["", "lemma dlex_pp_trans: \"dlex_pp s t \\<Longrightarrow> dlex_pp t u \\<Longrightarrow> dlex_pp s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dlex_pp s t; dlex_pp t u\\<rbrakk> \\<Longrightarrow> dlex_pp s u", "by (transfer, rule dlex_pm_trans)"], ["", "lemma dlex_pp_lin: \"dlex_pp s t \\<or> dlex_pp t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pp s t \\<or> dlex_pp t s", "by (transfer, fact dlex_pm_lin)"], ["", "corollary dlex_pp_strict_alt [code]: \"dlex_pp_strict s t = (\\<not> dlex_pp t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pp_strict s t = (\\<not> dlex_pp t s)", "by (transfer, fact dlex_pm_strict_alt)"], ["", "lemma dlex_pp_zero_min: \"dlex_pp 0 s\"\n  for s t::\"(_, _::add_linorder_min) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pp 0 s", "by (transfer, fact dlex_pm_zero_min)"], ["", "lemma dlex_pp_plus_monotone: \"dlex_pp s t \\<Longrightarrow> dlex_pp (s + u) (t + u)\"\n  for s t::\"(_, _::{ordered_ab_semigroup_add_imp_le, ordered_cancel_comm_monoid_add}) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlex_pp s t \\<Longrightarrow> dlex_pp (s + u) (t + u)", "by (transfer, rule dlex_pm_plus_monotone)"], ["", "subsection \\<open>Degree-Reverse-Lexicographic Term Order\\<close>"], ["", "lift_definition drlex_pp :: \"('a::linorder, 'b::{ordered_comm_monoid_add,linorder}) pp \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> bool\"\n  is drlex_pm"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition drlex_pp_strict :: \"('a::linorder, 'b::{ordered_comm_monoid_add,linorder}) pp \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> bool\"\n  is drlex_pm_strict"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma drlex_pp_alt: \"drlex_pp s t \\<longleftrightarrow> (deg_pp s < deg_pp t \\<or> (deg_pp s = deg_pp t \\<and> lex_pp t s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pp s t =\n    (deg_pp s < deg_pp t \\<or> deg_pp s = deg_pp t \\<and> lex_pp t s)", "by transfer (simp only: drlex_pm_def dord_pm_alt)"], ["", "lemma drlex_pp_refl: \"drlex_pp s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pp s s", "by (transfer, fact drlex_pm_refl)"], ["", "lemma drlex_pp_antisym: \"drlex_pp s t \\<Longrightarrow> drlex_pp t s \\<Longrightarrow> s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drlex_pp s t; drlex_pp t s\\<rbrakk> \\<Longrightarrow> s = t", "by (transfer, rule drlex_pm_antisym)"], ["", "lemma drlex_pp_trans: \"drlex_pp s t \\<Longrightarrow> drlex_pp t u \\<Longrightarrow> drlex_pp s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drlex_pp s t; drlex_pp t u\\<rbrakk>\n    \\<Longrightarrow> drlex_pp s u", "by (transfer, rule drlex_pm_trans)"], ["", "lemma drlex_pp_lin: \"drlex_pp s t \\<or> drlex_pp t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pp s t \\<or> drlex_pp t s", "by (transfer, fact drlex_pm_lin)"], ["", "corollary drlex_pp_strict_alt [code]: \"drlex_pp_strict s t = (\\<not> drlex_pp t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pp_strict s t = (\\<not> drlex_pp t s)", "by (transfer, fact drlex_pm_strict_alt)"], ["", "lemma drlex_pp_zero_min: \"drlex_pp 0 s\"\n  for s t::\"(_, _::add_linorder_min) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pp 0 s", "by (transfer, fact drlex_pm_zero_min)"], ["", "lemma drlex_pp_plus_monotone: \"drlex_pp s t \\<Longrightarrow> drlex_pp (s + u) (t + u)\"\n  for s t::\"(_, _::{ordered_ab_semigroup_add_imp_le, ordered_cancel_comm_monoid_add}) pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drlex_pp s t \\<Longrightarrow> drlex_pp (s + u) (t + u)", "by (transfer, rule drlex_pm_plus_monotone)"], ["", "end"], ["", "(* theory *)"]]}