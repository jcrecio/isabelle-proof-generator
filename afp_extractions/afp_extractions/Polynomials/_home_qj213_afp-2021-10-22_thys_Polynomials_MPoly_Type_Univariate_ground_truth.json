{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/MPoly_Type_Univariate.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma poly_to_mpoly_finite: \"finite {m::nat \\<Rightarrow>\\<^sub>0 nat. (coeff p (Poly_Mapping.lookup m v) when Poly_Mapping.keys m \\<subseteq> {v}) \\<noteq> 0}\" (is \"finite ?M\")", "lemma coeff_poly_to_mpoly: \"MPoly_Type.coeff (poly_to_mpoly v p) (Poly_Mapping.single v k) = Polynomial.coeff p k\"", "lemma coeff_mpoly_to_poly[simp]: \"Polynomial.coeff (mpoly_to_poly v p) k = MPoly_Type.coeff p (Poly_Mapping.single v k)\"", "lemma mpoly_to_poly_inverse:\nassumes \"vars p \\<subseteq> {v}\"\nshows \"poly_to_mpoly v (mpoly_to_poly v p) = p\"", "lemma poly_to_mpoly_inverse: \"mpoly_to_poly v (poly_to_mpoly v p) = p\"", "lemma poly_to_mpoly0: \"poly_to_mpoly v 0 = 0\"", "lemma mpoly_to_poly_add: \"mpoly_to_poly v (p1 + p2) = mpoly_to_poly v p1 + mpoly_to_poly v p2\"", "lemma poly_eq_insertion:\nassumes \"vars p \\<subseteq> {v}\"\nshows \"poly (mpoly_to_poly v p) x = insertion (\\<lambda>v. x) p\"", "lemma univariate_mpoly_roots_finite:\nfixes p::\"'a::idom mpoly\"\nassumes \"vars p \\<subseteq> {v}\" \"p \\<noteq> 0\"\nshows \"finite {x. insertion (\\<lambda>v. x) p = 0}\""], "translations": [["", "lemma poly_to_mpoly_finite: \"finite {m::nat \\<Rightarrow>\\<^sub>0 nat. (coeff p (Poly_Mapping.lookup m v) when Poly_Mapping.keys m \\<subseteq> {v}) \\<noteq> 0}\" (is \"finite ?M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {m. (poly.coeff p (lookup m v) when keys m \\<subseteq> {v}) \\<noteq>\n         (0::'a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {m. (poly.coeff p (lookup m v) when keys m \\<subseteq> {v}) \\<noteq>\n         (0::'a)}", "have \"?M \\<subseteq> Poly_Mapping.single v ` {x. Polynomial.coeff p x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m. (poly.coeff p (lookup m v) when keys m \\<subseteq> {v}) \\<noteq>\n        (0::'a)}\n    \\<subseteq> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. (poly.coeff p (lookup m v) when\n                    keys m \\<subseteq> {v}) \\<noteq>\n                   (0::'a)} \\<Longrightarrow>\n       x \\<in> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. (poly.coeff p (lookup m v) when\n                    keys m \\<subseteq> {v}) \\<noteq>\n                   (0::'a)} \\<Longrightarrow>\n       x \\<in> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}", "assume \"m \\<in> ?M\""], ["proof (state)\nthis:\n  m \\<in> {m. (poly.coeff p (lookup m v) when\n               keys m \\<subseteq> {v}) \\<noteq>\n              (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. (poly.coeff p (lookup m v) when\n                    keys m \\<subseteq> {v}) \\<noteq>\n                   (0::'a)} \\<Longrightarrow>\n       x \\<in> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}", "then"], ["proof (chain)\npicking this:\n  m \\<in> {m. (poly.coeff p (lookup m v) when\n               keys m \\<subseteq> {v}) \\<noteq>\n              (0::'a)}", "have \"\\<And>v'. v'\\<noteq>v \\<Longrightarrow> Poly_Mapping.lookup m v' = 0\""], ["proof (prove)\nusing this:\n  m \\<in> {m. (poly.coeff p (lookup m v) when\n               keys m \\<subseteq> {v}) \\<noteq>\n              (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>v'. v' \\<noteq> v \\<Longrightarrow> lookup m v' = 0", "by (fastforce simp add: in_keys_iff)"], ["proof (state)\nthis:\n  ?v' \\<noteq> v \\<Longrightarrow> lookup m ?v' = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. (poly.coeff p (lookup m v) when\n                    keys m \\<subseteq> {v}) \\<noteq>\n                   (0::'a)} \\<Longrightarrow>\n       x \\<in> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}", "then"], ["proof (chain)\npicking this:\n  ?v' \\<noteq> v \\<Longrightarrow> lookup m ?v' = 0", "have \"m = Poly_Mapping.single v (Poly_Mapping.lookup m v)\""], ["proof (prove)\nusing this:\n  ?v' \\<noteq> v \\<Longrightarrow> lookup m ?v' = 0\n\ngoal (1 subgoal):\n 1. m = Poly_Mapping.single v (lookup m v)", "using Poly_Mapping.poly_mapping_eqI"], ["proof (prove)\nusing this:\n  ?v' \\<noteq> v \\<Longrightarrow> lookup m ?v' = 0\n  (\\<And>k. lookup ?f k = lookup ?g k) \\<Longrightarrow> ?f = ?g\n\ngoal (1 subgoal):\n 1. m = Poly_Mapping.single v (lookup m v)", "by (metis (full_types) lookup_single_eq lookup_single_not_eq)"], ["proof (state)\nthis:\n  m = Poly_Mapping.single v (lookup m v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. (poly.coeff p (lookup m v) when\n                    keys m \\<subseteq> {v}) \\<noteq>\n                   (0::'a)} \\<Longrightarrow>\n       x \\<in> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}", "then"], ["proof (chain)\npicking this:\n  m = Poly_Mapping.single v (lookup m v)", "show \"m \\<in> (Poly_Mapping.single v) ` {x. Polynomial.coeff p x \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  m = Poly_Mapping.single v (lookup m v)\n\ngoal (1 subgoal):\n 1. m \\<in> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}", "using \\<open>m \\<in> ?M\\<close>"], ["proof (prove)\nusing this:\n  m = Poly_Mapping.single v (lookup m v)\n  m \\<in> {m. (poly.coeff p (lookup m v) when\n               keys m \\<subseteq> {v}) \\<noteq>\n              (0::'a)}\n\ngoal (1 subgoal):\n 1. m \\<in> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}", "by auto"], ["proof (state)\nthis:\n  m \\<in> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {m. (poly.coeff p (lookup m v) when keys m \\<subseteq> {v}) \\<noteq>\n      (0::'a)}\n  \\<subseteq> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. finite\n     {m. (poly.coeff p (lookup m v) when keys m \\<subseteq> {v}) \\<noteq>\n         (0::'a)}", "then"], ["proof (chain)\npicking this:\n  {m. (poly.coeff p (lookup m v) when keys m \\<subseteq> {v}) \\<noteq>\n      (0::'a)}\n  \\<subseteq> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}", "show ?thesis"], ["proof (prove)\nusing this:\n  {m. (poly.coeff p (lookup m v) when keys m \\<subseteq> {v}) \\<noteq>\n      (0::'a)}\n  \\<subseteq> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. finite\n     {m. (poly.coeff p (lookup m v) when keys m \\<subseteq> {v}) \\<noteq>\n         (0::'a)}", "using finite_surj[OF MOST_coeff_eq_0[unfolded eventually_cofinite]]"], ["proof (prove)\nusing this:\n  {m. (poly.coeff p (lookup m v) when keys m \\<subseteq> {v}) \\<noteq>\n      (0::'a)}\n  \\<subseteq> Poly_Mapping.single v ` {x. poly.coeff p x \\<noteq> (0::'a)}\n  ?B \\<subseteq> ?f `\n                 {x. poly.coeff ?p1 x \\<noteq> (0::?'a1)} \\<Longrightarrow>\n  finite ?B\n\ngoal (1 subgoal):\n 1. finite\n     {m. (poly.coeff p (lookup m v) when keys m \\<subseteq> {v}) \\<noteq>\n         (0::'a)}", "by blast"], ["proof (state)\nthis:\n  finite\n   {m. (poly.coeff p (lookup m v) when keys m \\<subseteq> {v}) \\<noteq>\n       (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_poly_to_mpoly: \"MPoly_Type.coeff (poly_to_mpoly v p) (Poly_Mapping.single v k) = Polynomial.coeff p k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (poly_to_mpoly v p) (Poly_Mapping.single v k) =\n    poly.coeff p k", "unfolding poly_to_mpoly_def coeff_def MPoly_inverse[OF Set.UNIV_I] lookup_Abs_poly_mapping[OF poly_to_mpoly_finite]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly.coeff p (lookup (Poly_Mapping.single v k) v) when\n     keys (Poly_Mapping.single v k) \\<subseteq> {v}) =\n    poly.coeff p k", "using empty_subsetI keys_single lookup_single order_refl when_simps(1)"], ["proof (prove)\nusing this:\n  {} \\<subseteq> ?A\n  keys (Poly_Mapping.single ?k ?v) = (if ?v = (0::?'b) then {} else {?k})\n  lookup (Poly_Mapping.single ?k ?v) ?k' = (?v when ?k = ?k')\n  ?x \\<le> ?x\n  (?a when True) = ?a\n\ngoal (1 subgoal):\n 1. (poly.coeff p (lookup (Poly_Mapping.single v k) v) when\n     keys (Poly_Mapping.single v k) \\<subseteq> {v}) =\n    poly.coeff p k", "by simp"], ["", "definition mpoly_to_poly::\"nat \\<Rightarrow> 'a::comm_monoid_add mpoly \\<Rightarrow> 'a poly\"\nwhere \"mpoly_to_poly v p = Abs_poly (\\<lambda>k. MPoly_Type.coeff p (Poly_Mapping.single v k))\""], ["", "lemma coeff_mpoly_to_poly[simp]: \"Polynomial.coeff (mpoly_to_poly v p) k = MPoly_Type.coeff p (Poly_Mapping.single v k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (mpoly_to_poly v p) k =\n    MPoly_Type.coeff p (Poly_Mapping.single v k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly.coeff (mpoly_to_poly v p) k =\n    MPoly_Type.coeff p (Poly_Mapping.single v k)", "have 0:\"Poly_Mapping.single v ` {x. Poly_Mapping.lookup (mapping_of p) (Poly_Mapping.single v x) \\<noteq> 0}\n          \\<subseteq> {k. Poly_Mapping.lookup (mapping_of p) k \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.single v `\n    {x. lookup (mapping_of p) (Poly_Mapping.single v x) \\<noteq> (0::'a)}\n    \\<subseteq> {k. lookup (mapping_of p) k \\<noteq> (0::'a)}", "by auto"], ["proof (state)\nthis:\n  Poly_Mapping.single v `\n  {x. lookup (mapping_of p) (Poly_Mapping.single v x) \\<noteq> (0::'a)}\n  \\<subseteq> {k. lookup (mapping_of p) k \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. poly.coeff (mpoly_to_poly v p) k =\n    MPoly_Type.coeff p (Poly_Mapping.single v k)", "have \"\\<forall>\\<^sub>\\<infinity> k. MPoly_Type.coeff p (Poly_Mapping.single v k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>k.\n       MPoly_Type.coeff p (Poly_Mapping.single v k) = (0::'a)", "unfolding coeff_def eventually_cofinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {x. lookup (mapping_of p) (Poly_Mapping.single v x) \\<noteq> (0::'a)}", "using  finite_imageD[OF finite_subset[OF 0 Poly_Mapping.finite_lookup]] inj_single"], ["proof (prove)\nusing this:\n  inj_on (Poly_Mapping.single v)\n   {x. lookup (mapping_of p) (Poly_Mapping.single v x) \\<noteq>\n       (0::'a)} \\<Longrightarrow>\n  finite\n   {x. lookup (mapping_of p) (Poly_Mapping.single v x) \\<noteq> (0::'a)}\n  inj (Poly_Mapping.single ?k)\n\ngoal (1 subgoal):\n 1. finite\n     {x. lookup (mapping_of p) (Poly_Mapping.single v x) \\<noteq> (0::'a)}", "by (metis inj_eq inj_onI)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>\\<infinity>k.\n     MPoly_Type.coeff p (Poly_Mapping.single v k) = (0::'a)\n\ngoal (1 subgoal):\n 1. poly.coeff (mpoly_to_poly v p) k =\n    MPoly_Type.coeff p (Poly_Mapping.single v k)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>\\<infinity>k.\n     MPoly_Type.coeff p (Poly_Mapping.single v k) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>\\<infinity>k.\n     MPoly_Type.coeff p (Poly_Mapping.single v k) = (0::'a)\n\ngoal (1 subgoal):\n 1. poly.coeff (mpoly_to_poly v p) k =\n    MPoly_Type.coeff p (Poly_Mapping.single v k)", "unfolding mpoly_to_poly_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>\\<infinity>k.\n     MPoly_Type.coeff p (Poly_Mapping.single v k) = (0::'a)\n\ngoal (1 subgoal):\n 1. poly.coeff\n     (Abs_poly (\\<lambda>k. MPoly_Type.coeff p (Poly_Mapping.single v k)))\n     k =\n    MPoly_Type.coeff p (Poly_Mapping.single v k)", "by (simp add: Abs_poly_inverse)"], ["proof (state)\nthis:\n  poly.coeff (mpoly_to_poly v p) k =\n  MPoly_Type.coeff p (Poly_Mapping.single v k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mpoly_to_poly_inverse:\nassumes \"vars p \\<subseteq> {v}\"\nshows \"poly_to_mpoly v (mpoly_to_poly v p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_to_mpoly v (mpoly_to_poly v p) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_to_mpoly v (mpoly_to_poly v p) = p", "define f where \"f = (\\<lambda>m. Polynomial.coeff (mpoly_to_poly v p) (Poly_Mapping.lookup m v) when Poly_Mapping.keys m \\<subseteq> {v})\""], ["proof (state)\nthis:\n  f =\n  (\\<lambda>m.\n      poly.coeff (mpoly_to_poly v p) (lookup m v) when\n      keys m \\<subseteq> {v})\n\ngoal (1 subgoal):\n 1. poly_to_mpoly v (mpoly_to_poly v p) = p", "have \"finite {m. f m \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {m. f m \\<noteq> (0::'a)}", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {m. (poly.coeff (mpoly_to_poly v p) (lookup m v) when\n          keys m \\<subseteq> {v}) \\<noteq>\n         (0::'a)}", "using poly_to_mpoly_finite"], ["proof (prove)\nusing this:\n  finite\n   {m. (poly.coeff ?p (lookup m ?v) when keys m \\<subseteq> {?v}) \\<noteq>\n       (0::?'a)}\n\ngoal (1 subgoal):\n 1. finite\n     {m. (poly.coeff (mpoly_to_poly v p) (lookup m v) when\n          keys m \\<subseteq> {v}) \\<noteq>\n         (0::'a)}", "by blast"], ["proof (state)\nthis:\n  finite {m. f m \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. poly_to_mpoly v (mpoly_to_poly v p) = p", "have \"Abs_poly_mapping f = mapping_of p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_poly_mapping f = mapping_of p", "proof (rule \"Poly_Mapping.poly_mapping_eqI\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (Abs_poly_mapping f) k = lookup (mapping_of p) k", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (Abs_poly_mapping f) k = lookup (mapping_of p) k", "show \"Poly_Mapping.lookup (Abs_poly_mapping f) m = Poly_Mapping.lookup (mapping_of p) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m", "proof (cases \"Poly_Mapping.keys m \\<subseteq> {v}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. keys m \\<subseteq> {v} \\<Longrightarrow>\n    lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m\n 2. \\<not> keys m \\<subseteq> {v} \\<Longrightarrow>\n    lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m", "assume \"Poly_Mapping.keys m \\<subseteq> {v}\""], ["proof (state)\nthis:\n  keys m \\<subseteq> {v}\n\ngoal (2 subgoals):\n 1. keys m \\<subseteq> {v} \\<Longrightarrow>\n    lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m\n 2. \\<not> keys m \\<subseteq> {v} \\<Longrightarrow>\n    lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m", "then"], ["proof (chain)\npicking this:\n  keys m \\<subseteq> {v}", "show ?thesis"], ["proof (prove)\nusing this:\n  keys m \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m", "unfolding \"Poly_Mapping.lookup_Abs_poly_mapping\"[OF \\<open>finite {m. f m \\<noteq> 0}\\<close>]"], ["proof (prove)\nusing this:\n  keys m \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. f m = lookup (mapping_of p) m", "unfolding f_def"], ["proof (prove)\nusing this:\n  keys m \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. (poly.coeff (mpoly_to_poly v p) (lookup m v) when\n     keys m \\<subseteq> {v}) =\n    lookup (mapping_of p) m", "unfolding coeff_mpoly_to_poly coeff_def"], ["proof (prove)\nusing this:\n  keys m \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. (lookup (mapping_of p) (Poly_Mapping.single v (lookup m v)) when\n     keys m \\<subseteq> {v}) =\n    lookup (mapping_of p) m", "using when_simps(1)"], ["proof (prove)\nusing this:\n  keys m \\<subseteq> {v}\n  (?a when True) = ?a\n\ngoal (1 subgoal):\n 1. (lookup (mapping_of p) (Poly_Mapping.single v (lookup m v)) when\n     keys m \\<subseteq> {v}) =\n    lookup (mapping_of p) m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys m \\<subseteq> {v} \\<Longrightarrow>\n    lookup (mapping_of p) (Poly_Mapping.single v (lookup m v)) =\n    lookup (mapping_of p) m", "using keys_single lookup_not_eq_zero_eq_in_keys lookup_single_eq\n        lookup_single_not_eq poly_mapping_eqI subset_singletonD"], ["proof (prove)\nusing this:\n  keys (Poly_Mapping.single ?k ?v) = (if ?v = (0::?'b) then {} else {?k})\n  (lookup ?f ?k \\<noteq> (0::?'a)) = (?k \\<in> keys ?f)\n  lookup (Poly_Mapping.single ?k ?v) ?k = ?v\n  ?k \\<noteq> ?k' \\<Longrightarrow>\n  lookup (Poly_Mapping.single ?k ?v) ?k' = (0::?'b)\n  (\\<And>k. lookup ?f k = lookup ?g k) \\<Longrightarrow> ?f = ?g\n  ?A \\<subseteq> {?x} \\<Longrightarrow> ?A = {} \\<or> ?A = {?x}\n\ngoal (1 subgoal):\n 1. keys m \\<subseteq> {v} \\<Longrightarrow>\n    lookup (mapping_of p) (Poly_Mapping.single v (lookup m v)) =\n    lookup (mapping_of p) m", "by (metis (no_types, lifting) aux lookup_eq_zero_in_keys_contradict)"], ["proof (state)\nthis:\n  lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m\n\ngoal (1 subgoal):\n 1. \\<not> keys m \\<subseteq> {v} \\<Longrightarrow>\n    lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> keys m \\<subseteq> {v} \\<Longrightarrow>\n    lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m", "assume \"\\<not>Poly_Mapping.keys m \\<subseteq> {v}\""], ["proof (state)\nthis:\n  \\<not> keys m \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. \\<not> keys m \\<subseteq> {v} \\<Longrightarrow>\n    lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m", "then"], ["proof (chain)\npicking this:\n  \\<not> keys m \\<subseteq> {v}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> keys m \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m", "unfolding \"Poly_Mapping.lookup_Abs_poly_mapping\"[OF \\<open>finite {m. f m \\<noteq> 0}\\<close>]"], ["proof (prove)\nusing this:\n  \\<not> keys m \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. f m = lookup (mapping_of p) m", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<not> keys m \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. (poly.coeff (mpoly_to_poly v p) (lookup m v) when\n     keys m \\<subseteq> {v}) =\n    lookup (mapping_of p) m", "using \\<open>vars p \\<subseteq> {v}\\<close>"], ["proof (prove)\nusing this:\n  \\<not> keys m \\<subseteq> {v}\n  vars p \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. (poly.coeff (mpoly_to_poly v p) (lookup m v) when\n     keys m \\<subseteq> {v}) =\n    lookup (mapping_of p) m", "unfolding vars_def"], ["proof (prove)\nusing this:\n  \\<not> keys m \\<subseteq> {v}\n  \\<Union> (keys ` keys (mapping_of p)) \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. (poly.coeff (mpoly_to_poly v p) (lookup m v) when\n     keys m \\<subseteq> {v}) =\n    lookup (mapping_of p) m", "by (metis (no_types, lifting) UN_I lookup_not_eq_zero_eq_in_keys subsetCE subsetI when_def)"], ["proof (state)\nthis:\n  lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (Abs_poly_mapping f) m = lookup (mapping_of p) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Abs_poly_mapping f = mapping_of p\n\ngoal (1 subgoal):\n 1. poly_to_mpoly v (mpoly_to_poly v p) = p", "then"], ["proof (chain)\npicking this:\n  Abs_poly_mapping f = mapping_of p", "show ?thesis"], ["proof (prove)\nusing this:\n  Abs_poly_mapping f = mapping_of p\n\ngoal (1 subgoal):\n 1. poly_to_mpoly v (mpoly_to_poly v p) = p", "unfolding poly_to_mpoly_def f_def"], ["proof (prove)\nusing this:\n  Abs_poly_mapping\n   (\\<lambda>m.\n       poly.coeff (mpoly_to_poly v p) (lookup m v) when\n       keys m \\<subseteq> {v}) =\n  mapping_of p\n\ngoal (1 subgoal):\n 1. MPoly\n     (Abs_poly_mapping\n       (\\<lambda>m.\n           poly.coeff (mpoly_to_poly v p) (lookup m v) when\n           keys m \\<subseteq> {v})) =\n    p", "by (simp add: mapping_of_inverse)"], ["proof (state)\nthis:\n  poly_to_mpoly v (mpoly_to_poly v p) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_to_mpoly_inverse: \"mpoly_to_poly v (poly_to_mpoly v p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_to_poly v (poly_to_mpoly v p) = p", "unfolding mpoly_to_poly_def coeff_poly_to_mpoly"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_poly (poly.coeff p) = p", "by (simp add: coeff_inverse)"], ["", "lemma poly_to_mpoly0: \"poly_to_mpoly v 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_to_mpoly v 0 = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_to_mpoly v 0 = 0", "have \"\\<And>m. (Polynomial.coeff 0 (Poly_Mapping.lookup m v) when Poly_Mapping.keys m \\<subseteq> {v}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       (poly.coeff 0 (lookup m v) when keys m \\<subseteq> {v}) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  (poly.coeff 0 (lookup ?m v) when keys ?m \\<subseteq> {v}) = (0::?'b1)\n\ngoal (1 subgoal):\n 1. poly_to_mpoly v 0 = 0", "have \"Abs_poly_mapping (\\<lambda>m. Polynomial.coeff 0 (Poly_Mapping.lookup m v) when Poly_Mapping.keys m \\<subseteq> {v}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_poly_mapping\n     (\\<lambda>m. poly.coeff 0 (lookup m v) when keys m \\<subseteq> {v}) =\n    0", "apply (rule Poly_Mapping.poly_mapping_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup\n        (Abs_poly_mapping\n          (\\<lambda>m.\n              poly.coeff 0 (lookup m v) when keys m \\<subseteq> {v}))\n        k =\n       lookup 0 k", "unfolding lookup_Abs_poly_mapping[OF poly_to_mpoly_finite]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       (poly.coeff 0 (lookup k v) when keys k \\<subseteq> {v}) = lookup 0 k", "by auto"], ["proof (state)\nthis:\n  Abs_poly_mapping\n   (\\<lambda>m. poly.coeff 0 (lookup m v) when keys m \\<subseteq> {v}) =\n  0\n\ngoal (1 subgoal):\n 1. poly_to_mpoly v 0 = 0", "then"], ["proof (chain)\npicking this:\n  Abs_poly_mapping\n   (\\<lambda>m. poly.coeff 0 (lookup m v) when keys m \\<subseteq> {v}) =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  Abs_poly_mapping\n   (\\<lambda>m. poly.coeff 0 (lookup m v) when keys m \\<subseteq> {v}) =\n  0\n\ngoal (1 subgoal):\n 1. poly_to_mpoly v 0 = 0", "using poly_to_mpoly_def zero_mpoly.abs_eq"], ["proof (prove)\nusing this:\n  Abs_poly_mapping\n   (\\<lambda>m. poly.coeff 0 (lookup m v) when keys m \\<subseteq> {v}) =\n  0\n  poly_to_mpoly ?v ?p =\n  MPoly\n   (Abs_poly_mapping\n     (\\<lambda>m. poly.coeff ?p (lookup m ?v) when keys m \\<subseteq> {?v}))\n  0 = MPoly 0\n\ngoal (1 subgoal):\n 1. poly_to_mpoly v 0 = 0", "by (metis (no_types))"], ["proof (state)\nthis:\n  poly_to_mpoly v 0 = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mpoly_to_poly_add: \"mpoly_to_poly v (p1 + p2) = mpoly_to_poly v p1 + mpoly_to_poly v p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_to_poly v (p1 + p2) = mpoly_to_poly v p1 + mpoly_to_poly v p2", "unfolding  Polynomial.plus_poly.abs_eq More_MPoly_Type.coeff_add coeff_mpoly_to_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_to_poly v (p1 + p2) =\n    Abs_poly\n     (\\<lambda>n. MPoly_Type.coeff (p1 + p2) (Poly_Mapping.single v n))", "using mpoly_to_poly_def"], ["proof (prove)\nusing this:\n  mpoly_to_poly ?v ?p =\n  Abs_poly (\\<lambda>k. MPoly_Type.coeff ?p (Poly_Mapping.single ?v k))\n\ngoal (1 subgoal):\n 1. mpoly_to_poly v (p1 + p2) =\n    Abs_poly\n     (\\<lambda>n. MPoly_Type.coeff (p1 + p2) (Poly_Mapping.single v n))", "by auto"], ["", "lemma poly_eq_insertion:\nassumes \"vars p \\<subseteq> {v}\"\nshows \"poly (mpoly_to_poly v p) x = insertion (\\<lambda>v. x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (mpoly_to_poly v p) x = insertion (\\<lambda>v. x) p", "using assms"], ["proof (prove)\nusing this:\n  vars p \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. poly (mpoly_to_poly v p) x = insertion (\\<lambda>v. x) p", "proof (induction p rule:mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       vars (MPoly_Type.monom m a) \\<subseteq> {v} \\<Longrightarrow>\n       poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n       insertion (\\<lambda>v. x) (MPoly_Type.monom m a)\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>vars p1 \\<subseteq> {v} \\<Longrightarrow>\n                poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1;\n        vars p2 \\<subseteq> {v} \\<Longrightarrow>\n        poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2;\n        p2 = MPoly_Type.monom m a; m \\<notin> keys (mapping_of p1);\n        vars (p1 + p2) \\<subseteq> {v}\\<rbrakk>\n       \\<Longrightarrow> poly (mpoly_to_poly v (p1 + p2)) x =\n                         insertion (\\<lambda>v. x) (p1 + p2)", "case (monom m a)"], ["proof (state)\nthis:\n  vars (MPoly_Type.monom m a) \\<subseteq> {v}\n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       vars (MPoly_Type.monom m a) \\<subseteq> {v} \\<Longrightarrow>\n       poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n       insertion (\\<lambda>v. x) (MPoly_Type.monom m a)\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>vars p1 \\<subseteq> {v} \\<Longrightarrow>\n                poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1;\n        vars p2 \\<subseteq> {v} \\<Longrightarrow>\n        poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2;\n        p2 = MPoly_Type.monom m a; m \\<notin> keys (mapping_of p1);\n        vars (p1 + p2) \\<subseteq> {v}\\<rbrakk>\n       \\<Longrightarrow> poly (mpoly_to_poly v (p1 + p2)) x =\n                         insertion (\\<lambda>v. x) (p1 + p2)", "then"], ["proof (chain)\npicking this:\n  vars (MPoly_Type.monom m a) \\<subseteq> {v}", "show ?case"], ["proof (prove)\nusing this:\n  vars (MPoly_Type.monom m a) \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n    insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "proof (cases \"a=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)\n 2. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "case True"], ["proof (state)\nthis:\n  a = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)\n 2. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "then"], ["proof (chain)\npicking this:\n  a = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n    insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "by (metis MPoly_Type.monom.abs_eq insertion_zero monom_zero poly_0 poly_to_mpoly0 poly_to_mpoly_inverse single_zero)"], ["proof (state)\nthis:\n  poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n  insertion (\\<lambda>v. x) (MPoly_Type.monom m a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)", "have \"Poly_Mapping.keys m \\<subseteq> {v}\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. keys m \\<subseteq> {v}", "using monom"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  vars (MPoly_Type.monom m a) \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. keys m \\<subseteq> {v}", "unfolding vars_def MPoly_Type.mapping_of_monom keys_single"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  \\<Union> (keys ` (if a = (0::'a) then {} else {m})) \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. keys m \\<subseteq> {v}", "by simp"], ["proof (state)\nthis:\n  keys m \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "then"], ["proof (chain)\npicking this:\n  keys m \\<subseteq> {v}", "have \"\\<And>v'. v'\\<noteq>v \\<Longrightarrow> Poly_Mapping.lookup m v' = 0\""], ["proof (prove)\nusing this:\n  keys m \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. \\<And>v'. v' \\<noteq> v \\<Longrightarrow> lookup m v' = 0", "unfolding vars_def"], ["proof (prove)\nusing this:\n  keys m \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. \\<And>v'. v' \\<noteq> v \\<Longrightarrow> lookup m v' = 0", "by (auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  ?v' \\<noteq> v \\<Longrightarrow> lookup m ?v' = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "then"], ["proof (chain)\npicking this:\n  ?v' \\<noteq> v \\<Longrightarrow> lookup m ?v' = 0", "have \"m = Poly_Mapping.single v (Poly_Mapping.lookup m v)\""], ["proof (prove)\nusing this:\n  ?v' \\<noteq> v \\<Longrightarrow> lookup m ?v' = 0\n\ngoal (1 subgoal):\n 1. m = Poly_Mapping.single v (lookup m v)", "by (metis lookup_single_eq lookup_single_not_eq poly_mapping_eqI)"], ["proof (state)\nthis:\n  m = Poly_Mapping.single v (lookup m v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "then"], ["proof (chain)\npicking this:\n  m = Poly_Mapping.single v (lookup m v)", "have 0:\"insertion (\\<lambda>v. x) (MPoly_Type.monom m a) = a * x ^ (Poly_Mapping.lookup m v)\""], ["proof (prove)\nusing this:\n  m = Poly_Mapping.single v (lookup m v)\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>v. x) (MPoly_Type.monom m a) = a * x ^ lookup m v", "using insertion_single"], ["proof (prove)\nusing this:\n  m = Poly_Mapping.single v (lookup m v)\n  insertion ?f (MPoly_Type.monom (Poly_Mapping.single ?v ?n) ?a) =\n  ?a * ?f ?v ^ ?n\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>v. x) (MPoly_Type.monom m a) = a * x ^ lookup m v", "by metis"], ["proof (state)\nthis:\n  insertion (\\<lambda>v. x) (MPoly_Type.monom m a) = a * x ^ lookup m v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "have \"\\<And>k. Poly_Mapping.single v k = m \\<longleftrightarrow> Poly_Mapping.lookup m v = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. (Poly_Mapping.single v k = m) = (lookup m v = k)", "using \\<open>m = Poly_Mapping.single v (Poly_Mapping.lookup m v)\\<close>"], ["proof (prove)\nusing this:\n  m = Poly_Mapping.single v (lookup m v)\n\ngoal (1 subgoal):\n 1. \\<And>k. (Poly_Mapping.single v k = m) = (lookup m v = k)", "by auto"], ["proof (state)\nthis:\n  (Poly_Mapping.single v ?k = m) = (lookup m v = ?k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "then"], ["proof (chain)\npicking this:\n  (Poly_Mapping.single v ?k = m) = (lookup m v = ?k)", "have \"monom a (Poly_Mapping.lookup m v) = (Abs_poly (\\<lambda>k. if Poly_Mapping.single v k = m then a else 0))\""], ["proof (prove)\nusing this:\n  (Poly_Mapping.single v ?k = m) = (lookup m v = ?k)\n\ngoal (1 subgoal):\n 1. Polynomial.monom a (lookup m v) =\n    Abs_poly\n     (\\<lambda>k. if Poly_Mapping.single v k = m then a else (0::'a))", "by (simp add: Polynomial.monom.abs_eq)"], ["proof (state)\nthis:\n  Polynomial.monom a (lookup m v) =\n  Abs_poly (\\<lambda>k. if Poly_Mapping.single v k = m then a else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vars (MPoly_Type.monom m a) \\<subseteq> {v};\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n                      insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "then"], ["proof (chain)\npicking this:\n  Polynomial.monom a (lookup m v) =\n  Abs_poly (\\<lambda>k. if Poly_Mapping.single v k = m then a else (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.monom a (lookup m v) =\n  Abs_poly (\\<lambda>k. if Poly_Mapping.single v k = m then a else (0::'a))\n\ngoal (1 subgoal):\n 1. poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n    insertion (\\<lambda>v. x) (MPoly_Type.monom m a)", "unfolding mpoly_to_poly_def More_MPoly_Type.coeff_monom 0 when_def"], ["proof (prove)\nusing this:\n  Polynomial.monom a (lookup m v) =\n  Abs_poly (\\<lambda>k. if Poly_Mapping.single v k = m then a else (0::'a))\n\ngoal (1 subgoal):\n 1. poly\n     (Abs_poly\n       (\\<lambda>k. if Poly_Mapping.single v k = m then a else (0::'a)))\n     x =\n    a * x ^ lookup m v", "by (metis poly_monom)"], ["proof (state)\nthis:\n  poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n  insertion (\\<lambda>v. x) (MPoly_Type.monom m a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (mpoly_to_poly v (MPoly_Type.monom m a)) x =\n  insertion (\\<lambda>v. x) (MPoly_Type.monom m a)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>vars p1 \\<subseteq> {v} \\<Longrightarrow>\n                poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1;\n        vars p2 \\<subseteq> {v} \\<Longrightarrow>\n        poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2;\n        p2 = MPoly_Type.monom m a; m \\<notin> keys (mapping_of p1);\n        vars (p1 + p2) \\<subseteq> {v}\\<rbrakk>\n       \\<Longrightarrow> poly (mpoly_to_poly v (p1 + p2)) x =\n                         insertion (\\<lambda>v. x) (p1 + p2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>vars p1 \\<subseteq> {v} \\<Longrightarrow>\n                poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1;\n        vars p2 \\<subseteq> {v} \\<Longrightarrow>\n        poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2;\n        p2 = MPoly_Type.monom m a; m \\<notin> keys (mapping_of p1);\n        vars (p1 + p2) \\<subseteq> {v}\\<rbrakk>\n       \\<Longrightarrow> poly (mpoly_to_poly v (p1 + p2)) x =\n                         insertion (\\<lambda>v. x) (p1 + p2)", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  vars p1 \\<subseteq> {v} \\<Longrightarrow>\n  poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1\n  vars p2 \\<subseteq> {v} \\<Longrightarrow>\n  poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2\n  p2 = MPoly_Type.monom m a\n  m \\<notin> keys (mapping_of p1)\n  vars (p1 + p2) \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>vars p1 \\<subseteq> {v} \\<Longrightarrow>\n                poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1;\n        vars p2 \\<subseteq> {v} \\<Longrightarrow>\n        poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2;\n        p2 = MPoly_Type.monom m a; m \\<notin> keys (mapping_of p1);\n        vars (p1 + p2) \\<subseteq> {v}\\<rbrakk>\n       \\<Longrightarrow> poly (mpoly_to_poly v (p1 + p2)) x =\n                         insertion (\\<lambda>v. x) (p1 + p2)", "then"], ["proof (chain)\npicking this:\n  vars p1 \\<subseteq> {v} \\<Longrightarrow>\n  poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1\n  vars p2 \\<subseteq> {v} \\<Longrightarrow>\n  poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2\n  p2 = MPoly_Type.monom m a\n  m \\<notin> keys (mapping_of p1)\n  vars (p1 + p2) \\<subseteq> {v}", "have \"poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1\"\n            \"poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2\""], ["proof (prove)\nusing this:\n  vars p1 \\<subseteq> {v} \\<Longrightarrow>\n  poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1\n  vars p2 \\<subseteq> {v} \\<Longrightarrow>\n  poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2\n  p2 = MPoly_Type.monom m a\n  m \\<notin> keys (mapping_of p1)\n  vars (p1 + p2) \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1 &&&\n    poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2", "by (simp_all add: vars_add_monom)"], ["proof (state)\nthis:\n  poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1\n  poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>vars p1 \\<subseteq> {v} \\<Longrightarrow>\n                poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1;\n        vars p2 \\<subseteq> {v} \\<Longrightarrow>\n        poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2;\n        p2 = MPoly_Type.monom m a; m \\<notin> keys (mapping_of p1);\n        vars (p1 + p2) \\<subseteq> {v}\\<rbrakk>\n       \\<Longrightarrow> poly (mpoly_to_poly v (p1 + p2)) x =\n                         insertion (\\<lambda>v. x) (p1 + p2)", "then"], ["proof (chain)\npicking this:\n  poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1\n  poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2", "show ?case"], ["proof (prove)\nusing this:\n  poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1\n  poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2\n\ngoal (1 subgoal):\n 1. poly (mpoly_to_poly v (p1 + p2)) x = insertion (\\<lambda>v. x) (p1 + p2)", "unfolding insertion_add mpoly_to_poly_add"], ["proof (prove)\nusing this:\n  poly (mpoly_to_poly v p1) x = insertion (\\<lambda>v. x) p1\n  poly (mpoly_to_poly v p2) x = insertion (\\<lambda>v. x) p2\n\ngoal (1 subgoal):\n 1. poly (mpoly_to_poly v p1 + mpoly_to_poly v p2) x =\n    insertion (\\<lambda>v. x) p1 + insertion (\\<lambda>v. x) p2", "by simp"], ["proof (state)\nthis:\n  poly (mpoly_to_poly v (p1 + p2)) x = insertion (\\<lambda>v. x) (p1 + p2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Using the new connection between MPoly and univariate polynomials, we can transfer:\\<close>"], ["", "lemma univariate_mpoly_roots_finite:\nfixes p::\"'a::idom mpoly\"\nassumes \"vars p \\<subseteq> {v}\" \"p \\<noteq> 0\"\nshows \"finite {x. insertion (\\<lambda>v. x) p = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. insertion (\\<lambda>v. x) p = (0::'a)}", "using poly_roots_finite[of \"mpoly_to_poly v p\", unfolded poly_eq_insertion[OF \\<open>vars p \\<subseteq> {v}\\<close>]]"], ["proof (prove)\nusing this:\n  mpoly_to_poly v p \\<noteq> 0 \\<Longrightarrow>\n  finite {x. insertion (\\<lambda>v. x) p = (0::'a)}\n\ngoal (1 subgoal):\n 1. finite {x. insertion (\\<lambda>v. x) p = (0::'a)}", "using assms(1) assms(2) mpoly_to_poly_inverse poly_to_mpoly0"], ["proof (prove)\nusing this:\n  mpoly_to_poly v p \\<noteq> 0 \\<Longrightarrow>\n  finite {x. insertion (\\<lambda>v. x) p = (0::'a)}\n  vars p \\<subseteq> {v}\n  p \\<noteq> 0\n  vars ?p \\<subseteq> {?v} \\<Longrightarrow>\n  poly_to_mpoly ?v (mpoly_to_poly ?v ?p) = ?p\n  poly_to_mpoly ?v 0 = 0\n\ngoal (1 subgoal):\n 1. finite {x. insertion (\\<lambda>v. x) p = (0::'a)}", "by fastforce"], ["", "end"]]}