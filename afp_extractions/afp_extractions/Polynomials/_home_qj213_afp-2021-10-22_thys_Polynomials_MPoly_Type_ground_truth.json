{"file_name": "/home/qj213/afp-2021-10-22/thys/Polynomials/MPoly_Type.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Polynomials", "problem_names": ["lemma mapping_of_monom [simp]:\n  \"mapping_of (monom m a) = Poly_Mapping.single m a\"", "lemma monom_zero [simp]:\n  \"monom 0 0 = 0\"", "lemma monom_one [simp]:\n  \"monom 0 1 = 1\"", "lemma monom_add:\n  \"monom m (a + b) = monom m a + monom m b\"", "lemma monom_uminus:\n  \"monom m (- a) = - monom m a\"", "lemma monom_diff:\n  \"monom m (a - b) = monom m a - monom m b\"", "lemma monom_numeral [simp]:\n  \"monom 0 (numeral n) = numeral n\"", "lemma monom_of_nat [simp]:\n  \"monom 0 (of_nat n) = of_nat n\"", "lemma of_nat_monom:\n  \"of_nat = monom 0 \\<circ> of_nat\"", "lemma inj_monom [iff]:\n  \"inj (monom m)\"", "lemma mult_monom: \"monom x a * monom y b = monom (x + y) (a * b)\"", "lemma monom_of_int [simp]:\n  \"monom 0 (of_int k) = of_int k\"", "lemma Const\\<^sub>0_one: \"Const\\<^sub>0 1 = 1\"", "lemma Const\\<^sub>0_numeral: \"Const\\<^sub>0 (numeral x) = numeral x\"", "lemma Const\\<^sub>0_minus: \"Const\\<^sub>0 (- x) = - Const\\<^sub>0 x\"", "lemma Const\\<^sub>0_zero: \"Const\\<^sub>0 0 = 0\"", "lemma Var\\<^sub>0_power: \"Var\\<^sub>0 v ^ n = Poly_Mapping.single (Poly_Mapping.single v n) 1\"", "lemma aux:\n  \"Poly_Mapping.lookup f = (\\<lambda>_. 0) \\<longleftrightarrow> f = 0\"", "lemma insertion_trivial [simp]:\n  \"insertion (\\<lambda>_. 0) p = coeff p 0\"", "lemma insertion_zero [simp]:\n  \"insertion f 0 = 0\"", "lemma insertion_fun_add:\n  fixes f p q\n  shows \"insertion_fun f (Poly_Mapping.lookup (p + q)) =\n    insertion_fun f (Poly_Mapping.lookup p) +\n      insertion_fun f (Poly_Mapping.lookup q)\"", "lemma insertion_add:\n  \"insertion f (p + q) = insertion f p + insertion f q\"", "lemma insertion_one [simp]:\n  \"insertion f 1 = 1\"", "lemma insertion_fun_mult:\n  fixes f p q\n  shows \"insertion_fun f (Poly_Mapping.lookup (p * q)) =\n    insertion_fun f (Poly_Mapping.lookup p) *\n      insertion_fun f (Poly_Mapping.lookup q)\"", "lemma insertion_mult:\n  \"insertion f (p * q) = insertion f p * insertion f q\"", "lemma degree_zero [simp]:\n  \"degree 0 v = 0\"", "lemma total_degree_zero [simp]:\n  \"total_degree 0 = 0\"", "lemma degree_one [simp]:\n  \"degree 1 v = 0\"", "lemma total_degree_one [simp]:\n  \"total_degree 1 = 0\"", "lemma smult_conv_mult: \"smult s p = monom 0 s * p\"", "lemma smult_monom [simp]:\n  fixes c :: \"_ :: mult_zero\"\n  shows \"smult c (monom x c') = monom x (c * c')\"", "lemma smult_0 [simp]:\n  fixes p :: \"_ :: mult_zero mpoly\"\n  shows \"smult 0 p = 0\"", "lemma mult_smult_left: \"smult s p * q = smult s (p * q)\"", "lemma pdiv_code:\n  \"p pdiv q = fst (pdivmod p q)\"", "lemma pmod_code:\n  \"p pmod q = snd (pdivmod p q)\"", "lemma div_poly_code:\n  \"p div q = fst (divmod p q)\"", "lemma mod_poly_code:\n  \"p mod q = snd (divmod p q)\"", "lemma finite_coeffs [simp]: \"finite (coeffs p)\""], "translations": [["", "lemma mapping_of_monom [simp]:\n  \"mapping_of (monom m a) = Poly_Mapping.single m a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping_of (monom m a) = Poly_Mapping.single m a", "by(fact monom.rep_eq)"], ["", "lemma monom_zero [simp]:\n  \"monom 0 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 0 (0::'a) = 0", "by transfer simp"], ["", "lemma monom_one [simp]:\n  \"monom 0 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 0 (1::'a) = 1", "by transfer simp"], ["", "lemma monom_add:\n  \"monom m (a + b) = monom m a + monom m b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom m (a + b) = monom m a + monom m b", "by transfer (simp add: single_add)"], ["", "lemma monom_uminus:\n  \"monom m (- a) = - monom m a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom m (- a) = - monom m a", "by transfer (simp add: single_uminus)"], ["", "lemma monom_diff:\n  \"monom m (a - b) = monom m a - monom m b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom m (a - b) = monom m a - monom m b", "by transfer (simp add: single_diff)"], ["", "lemma monom_numeral [simp]:\n  \"monom 0 (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 0 (numeral n) = numeral n", "by (induct n) (simp_all only: numeral.simps numeral_add monom_zero monom_one monom_add)"], ["", "lemma monom_of_nat [simp]:\n  \"monom 0 (of_nat n) = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 0 (of_nat n) = of_nat n", "by (induct n) (simp_all add: monom_add)"], ["", "lemma of_nat_monom:\n  \"of_nat = monom 0 \\<circ> of_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat = monom 0 \\<circ> of_nat", "by (simp add: fun_eq_iff)"], ["", "lemma inj_monom [iff]:\n  \"inj (monom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (monom m)", "proof (rule injI, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y m.\n       Poly_Mapping.single m x = Poly_Mapping.single m y \\<Longrightarrow>\n       x = y", "fix a b :: 'a and m :: \"nat \\<Rightarrow>\\<^sub>0 nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y m.\n       Poly_Mapping.single m x = Poly_Mapping.single m y \\<Longrightarrow>\n       x = y", "assume \"Poly_Mapping.single m a = Poly_Mapping.single m b\""], ["proof (state)\nthis:\n  Poly_Mapping.single m a = Poly_Mapping.single m b\n\ngoal (1 subgoal):\n 1. \\<And>x y m.\n       Poly_Mapping.single m x = Poly_Mapping.single m y \\<Longrightarrow>\n       x = y", "with injD [of \"Poly_Mapping.single m\" a b]"], ["proof (chain)\npicking this:\n  \\<lbrakk>inj (Poly_Mapping.single m);\n   Poly_Mapping.single m a = Poly_Mapping.single m b\\<rbrakk>\n  \\<Longrightarrow> a = b\n  Poly_Mapping.single m a = Poly_Mapping.single m b", "show \"a = b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>inj (Poly_Mapping.single m);\n   Poly_Mapping.single m a = Poly_Mapping.single m b\\<rbrakk>\n  \\<Longrightarrow> a = b\n  Poly_Mapping.single m a = Poly_Mapping.single m b\n\ngoal (1 subgoal):\n 1. a = b", "by simp"], ["proof (state)\nthis:\n  a = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_monom: \"monom x a * monom y b = monom (x + y) (a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom x a * monom y b = monom (x + y) (a * b)", "by transfer' (simp add: Poly_Mapping.mult_single)"], ["", "instance mpoly :: (semiring_char_0) semiring_char_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mpoly, semiring_char_0_class)", "by intro_classes (auto simp add: of_nat_monom inj_of_nat intro: inj_compose)"], ["", "instance mpoly :: (ring_char_0) ring_char_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mpoly, ring_char_0_class)", ".."], ["", "lemma monom_of_int [simp]:\n  \"monom 0 (of_int k) = of_int k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 0 (of_int k) = of_int k", "apply (cases k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. k = int n \\<Longrightarrow> monom 0 (of_int k) = of_int k\n 2. \\<And>n.\n       k = - int (Suc n) \\<Longrightarrow> monom 0 (of_int k) = of_int k", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       k = - 1 - int n \\<Longrightarrow>\n       monom 0 (- (1::'a) - of_nat n) = - 1 - of_nat n", "unfolding monom_diff monom_uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       k = - 1 - int n \\<Longrightarrow>\n       - monom 0 (1::'a) - monom 0 (of_nat n) = - 1 - of_nat n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Constants and Indeterminates\\<close>"], ["", "text \\<open>Embedding of indeterminates and constants in type-class polynomials,\n  can be used as constructors.\\<close>"], ["", "definition Var\\<^sub>0 :: \"'a \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::{one,zero}\" where\n  \"Var\\<^sub>0 n \\<equiv> Poly_Mapping.single (Poly_Mapping.single n 1) 1\""], ["", "definition Const\\<^sub>0 :: \"'b \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b::zero\" where \"Const\\<^sub>0 c \\<equiv> Poly_Mapping.single 0 c\""], ["", "lemma Const\\<^sub>0_one: \"Const\\<^sub>0 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const\\<^sub>0 (1::'b) = 1", "by (simp add: Const\\<^sub>0_def)"], ["", "lemma Const\\<^sub>0_numeral: \"Const\\<^sub>0 (numeral x) = numeral x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const\\<^sub>0 (numeral x) = numeral x", "by (auto intro!: poly_mapping_eqI simp: Const\\<^sub>0_def lookup_numeral)"], ["", "lemma Const\\<^sub>0_minus: \"Const\\<^sub>0 (- x) = - Const\\<^sub>0 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const\\<^sub>0 (- x) = - Const\\<^sub>0 x", "by (simp add: Const\\<^sub>0_def single_uminus)"], ["", "lemma Const\\<^sub>0_zero: \"Const\\<^sub>0 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const\\<^sub>0 (0::'b) = 0", "by (auto intro!: poly_mapping_eqI simp: Const\\<^sub>0_def)"], ["", "lemma Var\\<^sub>0_power: \"Var\\<^sub>0 v ^ n = Poly_Mapping.single (Poly_Mapping.single v n) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Var\\<^sub>0 v ^ n =\n    Poly_Mapping.single (Poly_Mapping.single v n) (1::'b)", "by (induction n) (auto simp: Var\\<^sub>0_def mult_single single_add[symmetric])"], ["", "lift_definition Var::\"nat \\<Rightarrow> 'b::{one,zero} mpoly\" is Var\\<^sub>0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition Const::\"'b::zero \\<Rightarrow> 'b mpoly\" is Const\\<^sub>0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>Integral domains\\<close>"], ["", "instance mpoly :: (ring_no_zero_divisors) ring_no_zero_divisors"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mpoly, ring_no_zero_divisors_class)", "by intro_classes (transfer, simp)"], ["", "instance mpoly :: (ring_1_no_zero_divisors) ring_1_no_zero_divisors"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mpoly, ring_1_no_zero_divisors_class)", ".."], ["", "instance mpoly :: (idom) idom"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mpoly, idom_class)", ".."], ["", "subsection \\<open>Monom coefficient lookup\\<close>"], ["", "definition coeff :: \"'a::zero mpoly \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a\"\nwhere\n  \"coeff p = Poly_Mapping.lookup (mapping_of p)\""], ["", "subsection \\<open>Insertion morphism\\<close>"], ["", "definition insertion_fun_natural :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> ((nat \\<Rightarrow> nat) \\<Rightarrow> 'a) \\<Rightarrow> 'a::comm_semiring_1\"\nwhere\n  \"insertion_fun_natural f p = (\\<Sum>m. p m * (\\<Prod>v. f v ^ m v))\""], ["", "definition insertion_fun :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> ((nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a) \\<Rightarrow> 'a::comm_semiring_1\"\nwhere\n  \"insertion_fun f p = (\\<Sum>m. p m * (\\<Prod>v. f v ^ Poly_Mapping.lookup m v))\""], ["", "text \\<open>N.b. have been unable to relate this to @{const insertion_fun_natural} using lifting!\\<close>"], ["", "lift_definition insertion_aux :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> ((nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> 'a::comm_semiring_1\"\n  is \"insertion_fun\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition insertion :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> 'a mpoly \\<Rightarrow> 'a::comm_semiring_1\"\n  is \"insertion_aux\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma aux:\n  \"Poly_Mapping.lookup f = (\\<lambda>_. 0) \\<longleftrightarrow> f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_mapping.lookup f = (\\<lambda>_. 0::'b)) = (f = 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       finite {x. f x \\<noteq> (0::'b)} \\<Longrightarrow>\n       (f = (\\<lambda>_. 0::'b)) = (f = (\\<lambda>k. 0::'b))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma insertion_trivial [simp]:\n  \"insertion (\\<lambda>_. 0) p = coeff p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>_. 0::'a) p = coeff p 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>_. 0::'a) p = coeff p 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>_. 0::'a) p = coeff p 0", "fix f :: \"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>_. 0::'a) p = coeff p 0", "have \"insertion_aux (\\<lambda>_. 0) f = Poly_Mapping.lookup f 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_aux (\\<lambda>_. 0::'a) f = poly_mapping.lookup f 0", "apply (simp add: insertion_aux_def insertion_fun_def power_Sum_any [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a. poly_mapping.lookup f a *\n              (0::'a) ^ Sum_any (poly_mapping.lookup a)) =\n    poly_mapping.lookup f 0", "apply (simp add: zero_power_eq mult_when aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  insertion_aux (\\<lambda>_. 0::'a) f = poly_mapping.lookup f 0\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>_. 0::'a) p = coeff p 0", "}"], ["proof (state)\nthis:\n  insertion_aux (\\<lambda>_. 0::'a) ?f2 = poly_mapping.lookup ?f2 0\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>_. 0::'a) p = coeff p 0", "then"], ["proof (chain)\npicking this:\n  insertion_aux (\\<lambda>_. 0::'a) ?f2 = poly_mapping.lookup ?f2 0", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion_aux (\\<lambda>_. 0::'a) ?f2 = poly_mapping.lookup ?f2 0\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>_. 0::'a) p = coeff p 0", "by (simp add: coeff_def insertion_def)"], ["proof (state)\nthis:\n  insertion (\\<lambda>_. 0::'a) p = coeff p 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_zero [simp]:\n  \"insertion f 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f 0 = (0::'a)", "by transfer (simp add: insertion_aux_def insertion_fun_def)"], ["", "lemma insertion_fun_add:\n  fixes f p q\n  shows \"insertion_fun f (Poly_Mapping.lookup (p + q)) =\n    insertion_fun f (Poly_Mapping.lookup p) +\n      insertion_fun f (Poly_Mapping.lookup q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p + q)) =\n    insertion_fun f (poly_mapping.lookup p) +\n    insertion_fun f (poly_mapping.lookup q)", "unfolding insertion_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. poly_mapping.lookup (p + q) m *\n              (\\<Prod>v. f v ^ poly_mapping.lookup m v)) =\n    (\\<Sum>m. poly_mapping.lookup p m *\n              (\\<Prod>v. f v ^ poly_mapping.lookup m v)) +\n    (\\<Sum>m. poly_mapping.lookup q m *\n              (\\<Prod>v. f v ^ poly_mapping.lookup m v))", "apply (subst Sum_any.distrib [symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     {a. poly_mapping.lookup p a *\n         (\\<Prod>v. f v ^ poly_mapping.lookup a v) \\<noteq>\n         (0::'a)}\n 2. finite\n     {a. poly_mapping.lookup q a *\n         (\\<Prod>v. f v ^ poly_mapping.lookup a v) \\<noteq>\n         (0::'a)}\n 3. (\\<Sum>m. poly_mapping.lookup (p + q) m *\n              (\\<Prod>v. f v ^ poly_mapping.lookup m v)) =\n    (\\<Sum>a. poly_mapping.lookup p a *\n              (\\<Prod>v. f v ^ poly_mapping.lookup a v) +\n              poly_mapping.lookup q a *\n              (\\<Prod>v. f v ^ poly_mapping.lookup a v))", "apply (simp_all add: plus_poly_mapping.rep_eq algebra_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     {a. poly_mapping.lookup p a *\n         (\\<Prod>v. f v ^ poly_mapping.lookup a v) \\<noteq>\n         (0::'a)}\n 2. finite\n     {a. poly_mapping.lookup q a *\n         (\\<Prod>v. f v ^ poly_mapping.lookup a v) \\<noteq>\n         (0::'a)}", "apply (rule finite_mult_not_eq_zero_rightI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {a. poly_mapping.lookup p a \\<noteq> (0::'a)}\n 2. finite\n     {a. poly_mapping.lookup q a *\n         (\\<Prod>v. f v ^ poly_mapping.lookup a v) \\<noteq>\n         (0::'a)}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {a. poly_mapping.lookup q a *\n         (\\<Prod>v. f v ^ poly_mapping.lookup a v) \\<noteq>\n         (0::'a)}", "apply (rule finite_mult_not_eq_zero_rightI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a. poly_mapping.lookup q a \\<noteq> (0::'a)}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma insertion_add:\n  \"insertion f (p + q) = insertion f p + insertion f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (p + q) = insertion f p + insertion f q", "by transfer (simp add: insertion_aux_def insertion_fun_add)"], ["", "lemma insertion_one [simp]:\n  \"insertion f 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f 1 = (1::'a)", "by transfer (simp add: insertion_aux_def insertion_fun_def one_poly_mapping.rep_eq when_mult)"], ["", "lemma insertion_fun_mult:\n  fixes f p q\n  shows \"insertion_fun f (Poly_Mapping.lookup (p * q)) =\n    insertion_fun f (Poly_Mapping.lookup p) *\n      insertion_fun f (Poly_Mapping.lookup q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "fix m :: \"nat \\<Rightarrow>\\<^sub>0 nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"finite {v. Poly_Mapping.lookup m v \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v. poly_mapping.lookup m v \\<noteq> 0}", "by simp"], ["proof (state)\nthis:\n  finite {v. poly_mapping.lookup m v \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "then"], ["proof (chain)\npicking this:\n  finite {v. poly_mapping.lookup m v \\<noteq> 0}", "have \"finite {v. f v ^ Poly_Mapping.lookup m v \\<noteq> 1}\""], ["proof (prove)\nusing this:\n  finite {v. poly_mapping.lookup m v \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. finite {v. f v ^ poly_mapping.lookup m v \\<noteq> (1::'a)}", "by (rule rev_finite_subset) (auto intro: ccontr)"], ["proof (state)\nthis:\n  finite {v. f v ^ poly_mapping.lookup m v \\<noteq> (1::'a)}\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "}"], ["proof (state)\nthis:\n  finite {v. f v ^ poly_mapping.lookup ?m2 v \\<noteq> (1::'a)}\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "moreover"], ["proof (state)\nthis:\n  finite {v. f v ^ poly_mapping.lookup ?m2 v \\<noteq> (1::'a)}\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "define g where \"g m = (\\<Prod>v. f v ^ Poly_Mapping.lookup m v)\" for m"], ["proof (state)\nthis:\n  g ?m = (\\<Prod>v. f v ^ poly_mapping.lookup ?m v)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "ultimately"], ["proof (chain)\npicking this:\n  finite {v. f v ^ poly_mapping.lookup ?m2 v \\<noteq> (1::'a)}\n  g ?m = (\\<Prod>v. f v ^ poly_mapping.lookup ?m v)", "have *: \"\\<And>a b. g (a + b) = g a * g b\""], ["proof (prove)\nusing this:\n  finite {v. f v ^ poly_mapping.lookup ?m2 v \\<noteq> (1::'a)}\n  g ?m = (\\<Prod>v. f v ^ poly_mapping.lookup ?m v)\n\ngoal (1 subgoal):\n 1. \\<And>a b. g (a + b) = g a * g b", "by (simp add: plus_poly_mapping.rep_eq power_add Prod_any.distrib)"], ["proof (state)\nthis:\n  g (?a + ?b) = g ?a * g ?b\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have bij: \"bij (\\<lambda>(l, n, m). (m, l, n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (\\<lambda>(l, n, m). (m, l, n))", "by (auto intro!: bijI injI simp add: image_def)"], ["proof (state)\nthis:\n  bij (\\<lambda>(l, n, m). (m, l, n))\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "let ?P = \"{l. Poly_Mapping.lookup p l \\<noteq> 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "let ?Q = \"{n. Poly_Mapping.lookup q n \\<noteq> 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "let ?PQ = \"{l + n | l n. l \\<in> Poly_Mapping.keys p \\<and> n \\<in> Poly_Mapping.keys q}\""], ["proof (state)\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"finite {l + n | l n. Poly_Mapping.lookup p l \\<noteq> 0 \\<and> Poly_Mapping.lookup q n \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {l + n |l n.\n      poly_mapping.lookup p l \\<noteq> (0::'a) \\<and>\n      poly_mapping.lookup q n \\<noteq> (0::'a)}", "by (rule finite_not_eq_zero_sumI) simp_all"], ["proof (state)\nthis:\n  finite\n   {l + n |l n.\n    poly_mapping.lookup p l \\<noteq> (0::'a) \\<and>\n    poly_mapping.lookup q n \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "then"], ["proof (chain)\npicking this:\n  finite\n   {l + n |l n.\n    poly_mapping.lookup p l \\<noteq> (0::'a) \\<and>\n    poly_mapping.lookup q n \\<noteq> (0::'a)}", "have fin_PQ: \"finite ?PQ\""], ["proof (prove)\nusing this:\n  finite\n   {l + n |l n.\n    poly_mapping.lookup p l \\<noteq> (0::'a) \\<and>\n    poly_mapping.lookup q n \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. finite\n     {l + n |l n.\n      l \\<in> Poly_Mapping.keys p \\<and> n \\<in> Poly_Mapping.keys q}", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  finite\n   {l + n |l n.\n    l \\<in> Poly_Mapping.keys p \\<and> n \\<in> Poly_Mapping.keys q}\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"(\\<Sum>m. Poly_Mapping.lookup (p * q) m * g m) =\n    (\\<Sum>m. (\\<Sum>l. Poly_Mapping.lookup p l * (\\<Sum>n. Poly_Mapping.lookup q n when m = l + n)) * g m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. poly_mapping.lookup (p * q) m * g m) =\n    (\\<Sum>m. (\\<Sum>l. poly_mapping.lookup p l *\n                        (\\<Sum>n. poly_mapping.lookup q n when m = l + n)) *\n              g m)", "by (simp add: times_poly_mapping.rep_eq prod_fun_def)"], ["proof (state)\nthis:\n  (\\<Sum>m. poly_mapping.lookup (p * q) m * g m) =\n  (\\<Sum>m. (\\<Sum>l. poly_mapping.lookup p l *\n                      (\\<Sum>n. poly_mapping.lookup q n when m = l + n)) *\n            g m)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m. poly_mapping.lookup (p * q) m * g m) =\n  (\\<Sum>m. (\\<Sum>l. poly_mapping.lookup p l *\n                      (\\<Sum>n. poly_mapping.lookup q n when m = l + n)) *\n            g m)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"\\<dots> = (\\<Sum>m. (\\<Sum>l. (\\<Sum>n. g m * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n) when m = l + n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. (\\<Sum>l. poly_mapping.lookup p l *\n                        (\\<Sum>n. poly_mapping.lookup q n when m = l + n)) *\n              g m) =\n    (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                                (poly_mapping.lookup p l *\n                                 poly_mapping.lookup q n) when\n                                m = l + n)", "apply (subst Sum_any_left_distrib)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       finite\n        {a. poly_mapping.lookup p a *\n            (\\<Sum>n. poly_mapping.lookup q n when m = a + n) \\<noteq>\n            (0::'a)}\n 2. (\\<Sum>m. \\<Sum>n. poly_mapping.lookup p n *\n                       (\\<Sum>na. poly_mapping.lookup q na when\n                                  m = n + na) *\n                       g m) =\n    (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                                (poly_mapping.lookup p l *\n                                 poly_mapping.lookup q n) when\n                                m = l + n)", "apply (auto intro: finite_mult_not_eq_zero_rightI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. \\<Sum>n. poly_mapping.lookup p n *\n                       (\\<Sum>na. poly_mapping.lookup q na when\n                                  m = n + na) *\n                       g m) =\n    (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                                (poly_mapping.lookup p l *\n                                 poly_mapping.lookup q n) when\n                                m = l + n)", "apply (subst Sum_any_right_distrib)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n m.\n       finite {a. (poly_mapping.lookup q a when m = n + a) \\<noteq> (0::'a)}\n 2. (\\<Sum>m. \\<Sum>n. (\\<Sum>na. poly_mapping.lookup p n *\n                                  (poly_mapping.lookup q na when\n                                   m = n + na)) *\n                       g m) =\n    (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                                (poly_mapping.lookup p l *\n                                 poly_mapping.lookup q n) when\n                                m = l + n)", "apply (auto intro: finite_mult_not_eq_zero_rightI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. \\<Sum>n. (\\<Sum>na. poly_mapping.lookup p n *\n                                  (poly_mapping.lookup q na when\n                                   m = n + na)) *\n                       g m) =\n    (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                                (poly_mapping.lookup p l *\n                                 poly_mapping.lookup q n) when\n                                m = l + n)", "apply (subst Sum_any_left_distrib)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n m.\n       finite\n        {a. poly_mapping.lookup p n *\n            (poly_mapping.lookup q a when m = n + a) \\<noteq>\n            (0::'a)}\n 2. (\\<Sum>m. \\<Sum>n. \\<Sum>na. poly_mapping.lookup p n *\n                                 (poly_mapping.lookup q na when\n                                  m = n + na) *\n                                 g m) =\n    (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                                (poly_mapping.lookup p l *\n                                 poly_mapping.lookup q n) when\n                                m = l + n)", "apply (auto intro: finite_mult_not_eq_zero_leftI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. \\<Sum>n. \\<Sum>na. poly_mapping.lookup p n *\n                                 (poly_mapping.lookup q na when\n                                  m = n + na) *\n                                 g m) =\n    (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                                (poly_mapping.lookup p l *\n                                 poly_mapping.lookup q n) when\n                                m = l + n)", "apply (simp add: ac_simps mult_when)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>m. (\\<Sum>l. poly_mapping.lookup p l *\n                      (\\<Sum>n. poly_mapping.lookup q n when m = l + n)) *\n            g m) =\n  (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                              (poly_mapping.lookup p l *\n                               poly_mapping.lookup q n) when\n                              m = l + n)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m. (\\<Sum>l. poly_mapping.lookup p l *\n                      (\\<Sum>n. poly_mapping.lookup q n when m = l + n)) *\n            g m) =\n  (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                              (poly_mapping.lookup p l *\n                               poly_mapping.lookup q n) when\n                              m = l + n)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"\\<dots> = (\\<Sum>m. (\\<Sum>(l, n). g m * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n) when m = l + n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                                (poly_mapping.lookup p l *\n                                 poly_mapping.lookup q n) when\n                                m = l + n) =\n    (\\<Sum>m. \\<Sum>(l,\n                 n). g m *\n                     (poly_mapping.lookup p l *\n                      poly_mapping.lookup q n) when\n                     m = l + n)", "apply (subst (2) Sum_any.cartesian_product [of \"?P \\<times> ?Q\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       finite\n        ({l. poly_mapping.lookup p l \\<noteq> (0::'a)} \\<times>\n         {n. poly_mapping.lookup q n \\<noteq> (0::'a)})\n 2. \\<And>m.\n       {a. \\<exists>b.\n              (g m *\n               (poly_mapping.lookup p a * poly_mapping.lookup q b) when\n               m = a + b) \\<noteq>\n              (0::'a)} \\<times>\n       {b. \\<exists>a.\n              (g m *\n               (poly_mapping.lookup p a * poly_mapping.lookup q b) when\n               m = a + b) \\<noteq>\n              (0::'a)}\n       \\<subseteq> {l. poly_mapping.lookup p l \\<noteq> (0::'a)} \\<times>\n                   {n. poly_mapping.lookup q n \\<noteq> (0::'a)}\n 3. (\\<Sum>m. \\<Sum>(a,\n                 b). g m *\n                     (poly_mapping.lookup p a *\n                      poly_mapping.lookup q b) when\n                     m = a + b) =\n    (\\<Sum>m. \\<Sum>(l,\n                 n). g m *\n                     (poly_mapping.lookup p l *\n                      poly_mapping.lookup q n) when\n                     m = l + n)", "apply (auto dest!: mult_not_zero)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                              (poly_mapping.lookup p l *\n                               poly_mapping.lookup q n) when\n                              m = l + n) =\n  (\\<Sum>m. \\<Sum>(l,\n               n). g m *\n                   (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n                   m = l + n)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m. \\<Sum>l. \\<Sum>n. g m *\n                              (poly_mapping.lookup p l *\n                               poly_mapping.lookup q n) when\n                              m = l + n) =\n  (\\<Sum>m. \\<Sum>(l,\n               n). g m *\n                   (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n                   m = l + n)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"\\<dots> = (\\<Sum>(m, l, n). g m * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n) when m = l + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. \\<Sum>(l,\n                 n). g m *\n                     (poly_mapping.lookup p l *\n                      poly_mapping.lookup q n) when\n                     m = l + n) =\n    (\\<Sum>(m, l,\n        n). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n            m = l + n)", "apply (subst Sum_any.cartesian_product [of \"?PQ \\<times> (?P \\<times> ?Q)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     ({l + n |l n.\n       l \\<in> Poly_Mapping.keys p \\<and>\n       n \\<in> Poly_Mapping.keys q} \\<times>\n      {l. poly_mapping.lookup p l \\<noteq> (0::'a)} \\<times>\n      {n. poly_mapping.lookup q n \\<noteq> (0::'a)})\n 2. {a. \\<exists>b.\n           (case b of\n            (l, n) \\<Rightarrow>\n              g a * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n              a = l + n) \\<noteq>\n           (0::'a)} \\<times>\n    {b. \\<exists>a.\n           (case b of\n            (l, n) \\<Rightarrow>\n              g a * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n              a = l + n) \\<noteq>\n           (0::'a)}\n    \\<subseteq> {l + n |l n.\n                 l \\<in> Poly_Mapping.keys p \\<and>\n                 n \\<in> Poly_Mapping.keys q} \\<times>\n                {l. poly_mapping.lookup p l \\<noteq> (0::'a)} \\<times>\n                {n. poly_mapping.lookup q n \\<noteq> (0::'a)}\n 3. (\\<Sum>(a, l,\n        n). g a * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n            a = l + n) =\n    (\\<Sum>(m, l,\n        n). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n            m = l + n)", "apply (auto dest!: mult_not_zero simp add: fin_PQ)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ab ba.\n       \\<lbrakk>g (ab + ba) \\<noteq> (0::'a);\n        poly_mapping.lookup p ab \\<noteq> (0::'a);\n        poly_mapping.lookup q ba \\<noteq> (0::'a);\n        g (aa + b) \\<noteq> (0::'a);\n        poly_mapping.lookup p aa \\<noteq> (0::'a);\n        poly_mapping.lookup q b \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l n.\n                            ab + ba = l + n \\<and>\n                            l \\<in> Poly_Mapping.keys p \\<and>\n                            n \\<in> Poly_Mapping.keys q", "apply (auto simp: in_keys_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>m. \\<Sum>(l,\n               n). g m *\n                   (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n                   m = l + n) =\n  (\\<Sum>(m, l,\n      n). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n          m = l + n)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m. \\<Sum>(l,\n               n). g m *\n                   (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n                   m = l + n) =\n  (\\<Sum>(m, l,\n      n). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n          m = l + n)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"\\<dots> = (\\<Sum>(l, n, m). g m * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n) when m = l + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(m, l,\n        n). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n            m = l + n) =\n    (\\<Sum>(l, n,\n        m). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n            m = l + n)", "using bij"], ["proof (prove)\nusing this:\n  bij (\\<lambda>(l, n, m). (m, l, n))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(m, l,\n        n). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n            m = l + n) =\n    (\\<Sum>(l, n,\n        m). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n            m = l + n)", "by (rule Sum_any.reindex_cong [of \"\\<lambda>(l, n, m). (m, l, n)\"]) (simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  (\\<Sum>(m, l,\n      n). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n          m = l + n) =\n  (\\<Sum>(l, n,\n      m). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n          m = l + n)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(m, l,\n      n). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n          m = l + n) =\n  (\\<Sum>(l, n,\n      m). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n          m = l + n)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"\\<dots> = (\\<Sum>(l, n). \\<Sum>m. g m * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n) when m = l + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(l, n,\n        m). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n            m = l + n) =\n    (\\<Sum>(l,\n        n). \\<Sum>m. g m *\n                     (poly_mapping.lookup p l *\n                      poly_mapping.lookup q n) when\n                     m = l + n)", "apply (subst Sum_any.cartesian_product2 [of \"(?P \\<times> ?Q) \\<times> ?PQ\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     (({l. poly_mapping.lookup p l \\<noteq> (0::'a)} \\<times>\n       {n. poly_mapping.lookup q n \\<noteq> (0::'a)}) \\<times>\n      {l + n |l n.\n       l \\<in> Poly_Mapping.keys p \\<and> n \\<in> Poly_Mapping.keys q})\n 2. {(a, b).\n     \\<exists>c.\n        (g c * (poly_mapping.lookup p a * poly_mapping.lookup q b) when\n         c = a + b) \\<noteq>\n        (0::'a)} \\<times>\n    {c. \\<exists>a b.\n           (g c * (poly_mapping.lookup p a * poly_mapping.lookup q b) when\n            c = a + b) \\<noteq>\n           (0::'a)}\n    \\<subseteq> ({l. poly_mapping.lookup p l \\<noteq> (0::'a)} \\<times>\n                 {n. poly_mapping.lookup q n \\<noteq> (0::'a)}) \\<times>\n                {l + n |l n.\n                 l \\<in> Poly_Mapping.keys p \\<and>\n                 n \\<in> Poly_Mapping.keys q}\n 3. (\\<Sum>(l, n,\n        m). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n            m = l + n) =\n    (\\<Sum>(a, b,\n        c). g c * (poly_mapping.lookup p a * poly_mapping.lookup q b) when\n            c = a + b)", "apply (auto dest!: mult_not_zero simp add: fin_PQ )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa bb.\n       \\<lbrakk>g (a + b) \\<noteq> (0::'a);\n        poly_mapping.lookup p a \\<noteq> (0::'a);\n        poly_mapping.lookup q b \\<noteq> (0::'a);\n        g (aa + bb) \\<noteq> (0::'a);\n        poly_mapping.lookup p aa \\<noteq> (0::'a);\n        poly_mapping.lookup q bb \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l n.\n                            aa + bb = l + n \\<and>\n                            l \\<in> Poly_Mapping.keys p \\<and>\n                            n \\<in> Poly_Mapping.keys q", "apply (auto simp: in_keys_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>(l, n,\n      m). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n          m = l + n) =\n  (\\<Sum>(l,\n      n). \\<Sum>m. g m *\n                   (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n                   m = l + n)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(l, n,\n      m). g m * (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n          m = l + n) =\n  (\\<Sum>(l,\n      n). \\<Sum>m. g m *\n                   (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n                   m = l + n)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"\\<dots> = (\\<Sum>(l, n). (g l * g n) * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(l,\n        n). \\<Sum>m. g m *\n                     (poly_mapping.lookup p l *\n                      poly_mapping.lookup q n) when\n                     m = l + n) =\n    (\\<Sum>(l,\n        n). g l * g n * (poly_mapping.lookup p l * poly_mapping.lookup q n))", "by (simp add: *)"], ["proof (state)\nthis:\n  (\\<Sum>(l,\n      n). \\<Sum>m. g m *\n                   (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n                   m = l + n) =\n  (\\<Sum>(l,\n      n). g l * g n * (poly_mapping.lookup p l * poly_mapping.lookup q n))\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(l,\n      n). \\<Sum>m. g m *\n                   (poly_mapping.lookup p l * poly_mapping.lookup q n) when\n                   m = l + n) =\n  (\\<Sum>(l,\n      n). g l * g n * (poly_mapping.lookup p l * poly_mapping.lookup q n))\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"\\<dots> = (\\<Sum>l. \\<Sum>n. (g l * g n) * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(l,\n        n). g l * g n *\n            (poly_mapping.lookup p l * poly_mapping.lookup q n)) =\n    (\\<Sum>l. \\<Sum>n. g l * g n *\n                       (poly_mapping.lookup p l * poly_mapping.lookup q n))", "apply (subst Sum_any.cartesian_product [of \"?P \\<times> ?Q\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     ({l. poly_mapping.lookup p l \\<noteq> (0::'a)} \\<times>\n      {n. poly_mapping.lookup q n \\<noteq> (0::'a)})\n 2. {a. \\<exists>b.\n           g a * g b *\n           (poly_mapping.lookup p a * poly_mapping.lookup q b) \\<noteq>\n           (0::'a)} \\<times>\n    {b. \\<exists>a.\n           g a * g b *\n           (poly_mapping.lookup p a * poly_mapping.lookup q b) \\<noteq>\n           (0::'a)}\n    \\<subseteq> {l. poly_mapping.lookup p l \\<noteq> (0::'a)} \\<times>\n                {n. poly_mapping.lookup q n \\<noteq> (0::'a)}\n 3. (\\<Sum>(l,\n        n). g l * g n *\n            (poly_mapping.lookup p l * poly_mapping.lookup q n)) =\n    (\\<Sum>(a,\n        b). g a * g b * (poly_mapping.lookup p a * poly_mapping.lookup q b))", "apply (auto dest!: mult_not_zero)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>(l,\n      n). g l * g n * (poly_mapping.lookup p l * poly_mapping.lookup q n)) =\n  (\\<Sum>l. \\<Sum>n. g l * g n *\n                     (poly_mapping.lookup p l * poly_mapping.lookup q n))\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(l,\n      n). g l * g n * (poly_mapping.lookup p l * poly_mapping.lookup q n)) =\n  (\\<Sum>l. \\<Sum>n. g l * g n *\n                     (poly_mapping.lookup p l * poly_mapping.lookup q n))\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"\\<dots> = (\\<Sum>l. \\<Sum>n. (Poly_Mapping.lookup p l * g l) * (Poly_Mapping.lookup q n * g n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. \\<Sum>n. g l * g n *\n                       (poly_mapping.lookup p l *\n                        poly_mapping.lookup q n)) =\n    (\\<Sum>l. \\<Sum>n. poly_mapping.lookup p l * g l *\n                       (poly_mapping.lookup q n * g n))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>n. g l * g n *\n                     (poly_mapping.lookup p l * poly_mapping.lookup q n)) =\n  (\\<Sum>l. \\<Sum>n. poly_mapping.lookup p l * g l *\n                     (poly_mapping.lookup q n * g n))\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>n. g l * g n *\n                     (poly_mapping.lookup p l * poly_mapping.lookup q n)) =\n  (\\<Sum>l. \\<Sum>n. poly_mapping.lookup p l * g l *\n                     (poly_mapping.lookup q n * g n))\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "have \"\\<dots> =\n    (\\<Sum>m. Poly_Mapping.lookup p m * g m) *\n    (\\<Sum>m. Poly_Mapping.lookup q m * g m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. \\<Sum>n. poly_mapping.lookup p l * g l *\n                       (poly_mapping.lookup q n * g n)) =\n    (\\<Sum>m. poly_mapping.lookup p m * g m) *\n    (\\<Sum>m. poly_mapping.lookup q m * g m)", "by (rule Sum_any_product [symmetric]) (auto intro: finite_mult_not_eq_zero_rightI)"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>n. poly_mapping.lookup p l * g l *\n                     (poly_mapping.lookup q n * g n)) =\n  (\\<Sum>m. poly_mapping.lookup p m * g m) *\n  (\\<Sum>m. poly_mapping.lookup q m * g m)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>m. poly_mapping.lookup (p * q) m * g m) =\n  (\\<Sum>m. poly_mapping.lookup p m * g m) *\n  (\\<Sum>m. poly_mapping.lookup q m * g m)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>m. poly_mapping.lookup (p * q) m * g m) =\n  (\\<Sum>m. poly_mapping.lookup p m * g m) *\n  (\\<Sum>m. poly_mapping.lookup q m * g m)\n\ngoal (1 subgoal):\n 1. insertion_fun f (poly_mapping.lookup (p * q)) =\n    insertion_fun f (poly_mapping.lookup p) *\n    insertion_fun f (poly_mapping.lookup q)", "by (simp add: insertion_fun_def g_def)"], ["proof (state)\nthis:\n  insertion_fun f (poly_mapping.lookup (p * q)) =\n  insertion_fun f (poly_mapping.lookup p) *\n  insertion_fun f (poly_mapping.lookup q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_mult:\n  \"insertion f (p * q) = insertion f p * insertion f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (p * q) = insertion f p * insertion f q", "by transfer (simp add: insertion_aux_def insertion_fun_mult)"], ["", "subsection \\<open>Degree\\<close>"], ["", "lift_definition degree :: \"'a::zero mpoly \\<Rightarrow> nat \\<Rightarrow> nat\"\nis \"\\<lambda>p v. Max (insert 0 ((\\<lambda>m. Poly_Mapping.lookup m v) ` Poly_Mapping.keys p))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition total_degree :: \"'a::zero mpoly \\<Rightarrow> nat\"\nis \"\\<lambda>p. Max (insert 0 ((\\<lambda>m. sum (Poly_Mapping.lookup m) (Poly_Mapping.keys m)) ` Poly_Mapping.keys p))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma degree_zero [simp]:\n  \"degree 0 v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree 0 v = 0", "by transfer simp"], ["", "lemma total_degree_zero [simp]:\n  \"total_degree 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total_degree 0 = 0", "by transfer simp"], ["", "(*\nvalue [code] \"total_degree (0 :: int mpoly)\" (***)\n*)"], ["", "lemma degree_one [simp]:\n  \"degree 1 v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree 1 v = 0", "by transfer simp"], ["", "lemma total_degree_one [simp]:\n  \"total_degree 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total_degree 1 = 0", "by transfer simp"], ["", "subsection \\<open>Pseudo-division of polynomials\\<close>"], ["", "lemma smult_conv_mult: \"smult s p = monom 0 s * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult s p = monom 0 s * p", "by transfer (simp add: mult_map_scale_conv_mult)"], ["", "lemma smult_monom [simp]:\n  fixes c :: \"_ :: mult_zero\"\n  shows \"smult c (monom x c') = monom x (c * c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c (monom x c') = monom x (c * c')", "by transfer simp"], ["", "lemma smult_0 [simp]:\n  fixes p :: \"_ :: mult_zero mpoly\"\n  shows \"smult 0 p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (0::'b) p = 0", "by transfer(simp add: map_eq_zero_iff)"], ["", "lemma mult_smult_left: \"smult s p * q = smult s (p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult s p * q = smult s (p * q)", "by(simp add: smult_conv_mult mult.assoc)"], ["", "lift_definition sdiv :: \"'a::euclidean_ring \\<Rightarrow> 'a mpoly \\<Rightarrow> 'a mpoly\"\n  is \"\\<lambda>a. Poly_Mapping.map (\\<lambda>b. b div a) :: ((nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> _\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>\n  \\qt{Polynomial division} is only possible on univariate polynomials \\<open>K[x]\\<close>\n  over a field \\<open>K\\<close>, all other kinds of polynomials only allow pseudo-division\n  [1]p.40/41\":\n\n  \\<open>\\<forall>x y :: 'a mpoly. y \\<noteq> 0 \\<Rightarrow> \\<exists>a q r. smult a x = q * y + r\\<close>\n\n  The introduction of pseudo-division below generalises @{file \\<open>~~/src/HOL/Computational_Algebra/Polynomial.thy\\<close>}.\n  [1] Winkler, Polynomial Algorithms, 1996.\n  The generalisation raises issues addressed by Wenda Li and commented below.\n  Florian replied to the issues conjecturing, that the abstract mpoly needs not\n  be aware of the issues, in case these are only concerned with executability.\n\\<close>"], ["", "definition pseudo_divmod_rel\n  :: \"'a::euclidean_ring => 'a mpoly => 'a mpoly => 'a mpoly => 'a mpoly => bool\"\nwhere\n  \"pseudo_divmod_rel a x y q r \\<longleftrightarrow>\n    smult a x = q * y + r \\<and> (if y = 0 then q = 0 else r = 0 \\<or> degree r < degree y)\""], ["", "(* the notion of degree resigns a main variable in multivariate polynomials;\n   also, there are infinitely many tuples (a,q,r) such that a x = q y + r *)"], ["", "definition pdiv :: \"'a::euclidean_ring mpoly \\<Rightarrow> 'a mpoly \\<Rightarrow> ('a \\<times> 'a mpoly)\" (infixl \"pdiv\" 70)\nwhere\n  \"x pdiv y = (THE (a, q). \\<exists>r. pseudo_divmod_rel a x y q r)\""], ["", "definition pmod :: \"'a::euclidean_ring mpoly \\<Rightarrow> 'a mpoly \\<Rightarrow> 'a mpoly\" (infixl \"pmod\" 70)\nwhere\n  \"x pmod y = (THE r. \\<exists>a q. pseudo_divmod_rel a x y q r)\""], ["", "definition pdivmod :: \"'a::euclidean_ring mpoly \\<Rightarrow> 'a mpoly \\<Rightarrow> ('a \\<times> 'a mpoly) \\<times> 'a mpoly\"\nwhere\n  \"pdivmod p q = (p pdiv q, p pmod q)\""], ["", "(* \"_code\" seems inappropriate, since \"THE\" in definitions pdiv and pmod is not unique,\n   see comment to definition pseudo_divmod_rel; so this cannot be executable ... *)"], ["", "lemma pdiv_code:\n  \"p pdiv q = fst (pdivmod p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p pdiv q = fst (pdivmod p q)", "by (simp add: pdivmod_def)"], ["", "lemma pmod_code:\n  \"p pmod q = snd (pdivmod p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p pmod q = snd (pdivmod p q)", "by (simp add: pdivmod_def)"], ["", "(*TODO ERROR: Ambiguous input produces n parse trees ???...*)"], ["", "definition div :: \"'a::{euclidean_ring,field} mpoly \\<Rightarrow> 'a mpoly \\<Rightarrow> 'a mpoly\" (infixl \"div\" 70)\nwhere\n  \"x div y = (THE q'. \\<exists>a q r. (pseudo_divmod_rel a x y q r) \\<and> (q' = smult (inverse a) q))\""], ["", "definition mod :: \"'a::{euclidean_ring,field} mpoly \\<Rightarrow> 'a mpoly \\<Rightarrow> 'a mpoly\" (infixl \"mod\" 70)\nwhere\n  \"x mod y = (THE r'. \\<exists>a q r. (pseudo_divmod_rel a x y q r) \\<and> (r' = smult (inverse a) r))\""], ["", "definition divmod :: \"'a::{euclidean_ring,field} mpoly \\<Rightarrow> 'a mpoly \\<Rightarrow> 'a mpoly \\<times> 'a mpoly\"\nwhere\n  \"divmod p q = (p div q, p mod q)\""], ["", "lemma div_poly_code:\n  \"p div q = fst (divmod p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p div q = fst (MPoly_Type.divmod p q)", "by (simp add: divmod_def)"], ["", "lemma mod_poly_code:\n  \"p mod q = snd (divmod p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p mod q = snd (MPoly_Type.divmod p q)", "by (simp add: divmod_def)"], ["", "subsection \\<open>Primitive poly, etc\\<close>"], ["", "lift_definition coeffs :: \"'a :: zero mpoly \\<Rightarrow> 'a set\"\nis \"Poly_Mapping.range :: ((nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> _\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma finite_coeffs [simp]: \"finite (coeffs p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (coeffs p)", "by transfer simp"], ["", "text \\<open>[1]p.82\n  A \"primitive'\" polynomial has coefficients with GCD equal to 1.\n  A polynomial is factored into \"content\" and \"primitive part\"\n  for many different purposes.\\<close>"], ["", "definition primitive :: \"'a::{euclidean_ring,semiring_Gcd} mpoly \\<Rightarrow> bool\"\nwhere\n  \"primitive p \\<longleftrightarrow> Gcd (coeffs p) = 1\""], ["", "definition content_primitive :: \"'a::{euclidean_ring,GCD.Gcd} mpoly \\<Rightarrow> 'a \\<times> 'a mpoly\"\nwhere\n  \"content_primitive p = (\n    let d = Gcd (coeffs p)\n    in (d, sdiv d p))\""], ["", "value \"let p = M [1,2,3] (4::int) + M [2,0,4] 6 + M [2,0,5] 8\n  in content_primitive p\""], ["", "end"]]}