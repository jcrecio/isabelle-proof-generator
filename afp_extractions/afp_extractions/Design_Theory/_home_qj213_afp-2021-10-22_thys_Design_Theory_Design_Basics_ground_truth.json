{"file_name": "/home/qj213/afp-2021-10-22/thys/Design_Theory/Design_Basics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Design_Theory", "problem_names": ["lemma incidence_alt_def: \n  assumes \"p \\<in> \\<V>\"\n  assumes \"b \\<in># \\<B>\"\n  shows \"incident p b \\<longleftrightarrow> p \\<in> b\"", "lemma wf_invalid_point: \"x \\<notin> \\<V> \\<Longrightarrow> b \\<in># \\<B> \\<Longrightarrow> x \\<notin> b\"", "lemma block_set_nempty_imp_block_ex: \"\\<B> \\<noteq> {#} \\<Longrightarrow> \\<exists> bl . bl \\<in># \\<B>\"", "lemma incomplete_alt_size: \"incomplete_block bl \\<Longrightarrow> card bl < \\<v>\"", "lemma incomplete_alt_in: \"incomplete_block bl \\<Longrightarrow> bl \\<in># \\<B>\"", "lemma incomplete_alt_imp[intro]: \"card bl < \\<v> \\<Longrightarrow> bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\"", "lemma finite_blocks: \"b \\<in># \\<B> \\<Longrightarrow> finite b\"", "lemma mset_points_distinct: \"distinct_mset (mset_set \\<V>)\"", "lemma mset_points_distinct_diff_one: \"distinct_mset (mset_set (\\<V> - {x}))\"", "lemma finite_design_support: \"finite (design_support)\"", "lemma block_size_lt_order: \"bl \\<in># \\<B> \\<Longrightarrow> card bl \\<le> card \\<V>\"", "lemma wf_design: \"design \\<V> \\<B>\"", "lemma wf_design_iff: \"bl \\<in># \\<B> \\<Longrightarrow> design \\<V> \\<B> \\<longleftrightarrow> (bl \\<subseteq> \\<V> \\<and> finite \\<V> \\<and> bl \\<noteq> {})\"", "lemma blocks_nempty_alt: \"\\<forall> bl \\<in># \\<B>. bl \\<noteq> {}\"", "lemma block_set_nempty_imp_points: \"\\<B> \\<noteq> {#} \\<Longrightarrow> \\<V> \\<noteq> {}\"", "lemma b_non_zero_imp_v_non_zero: \"\\<b> > 0 \\<Longrightarrow> \\<v> > 0\"", "lemma v_eq0_imp_b_eq_0: \"\\<v> = 0 \\<Longrightarrow> \\<b> = 0\"", "lemma block_size_lt_v: \"bl \\<in># \\<B> \\<Longrightarrow> card bl \\<le> \\<v>\"", "lemma block_size_gt_0: \"bl \\<in># \\<B> \\<Longrightarrow> card bl > 0\"", "lemma design_cart_product_size: \"size ((mset_set \\<V>) \\<times># \\<B>) = \\<v> * \\<b>\"", "lemma wf_design_implies: \n  assumes \"(\\<And> b . b \\<in># \\<B> \\<Longrightarrow> b \\<subseteq> V)\"\n  assumes \"\\<And> b . b \\<in># \\<B> \\<Longrightarrow> b \\<noteq> {}\"\n  assumes \"finite V\"\n  assumes \"\\<B> \\<noteq> {#}\"\n  assumes \"V \\<noteq> {}\"\n  shows \"design V \\<B>\"", "lemma (in incidence_system) finite_sysI[intro]: \"finite \\<V> \\<Longrightarrow> finite_incidence_system \\<V> \\<B>\"", "lemma (in finite_incidence_system) designI[intro]: \"(\\<And> b. b \\<in># \\<B> \\<Longrightarrow> b \\<noteq> {}) \\<Longrightarrow> \\<B> \\<noteq> {#}\n     \\<Longrightarrow> \\<V> \\<noteq> {} \\<Longrightarrow> design \\<V> \\<B>\"", "lemma max_point_rep: \"B rep x \\<le> size B\"", "lemma rep_number_g0_exists: \n  assumes \"B rep x > 0\" \n  obtains b where \"b \\<in># B\" and \"x \\<in> b\"", "lemma rep_number_on_set_def: \"finite B \\<Longrightarrow> (mset_set B) rep x = card {b \\<in> B . x \\<in> b}\"", "lemma point_rep_number_split[simp]: \"(A + B) rep x = A rep x + B rep x\"", "lemma point_rep_singleton_val [simp]: \"x \\<in> b \\<Longrightarrow> {#b#} rep x = 1\"", "lemma point_rep_singleton_inval [simp]: \"x \\<notin> b \\<Longrightarrow> {#b#} rep x = 0\"", "lemma point_rep_number_alt_def: \"\\<B> rep x = size {# b \\<in># \\<B> . x \\<in> b#}\"", "lemma rep_number_non_zero_system_point: \" \\<B> rep x > 0 \\<Longrightarrow> x \\<in> \\<V>\"", "lemma point_rep_non_existance [simp]: \"x \\<notin> \\<V> \\<Longrightarrow> \\<B> rep x = 0\"", "lemma point_rep_number_inv: \"size {# b \\<in># \\<B> . x \\<notin> b #} = \\<b> - (\\<B> rep x)\"", "lemma point_rep_num_inv_non_empty: \"(\\<B> rep x) < \\<b> \\<Longrightarrow> \\<B> \\<noteq> {#} \\<Longrightarrow> {# b \\<in># \\<B> . x \\<notin> b #} \\<noteq> {#}\"", "lemma points_index_empty [simp]: \"{#} index ps = 0\"", "lemma point_index_distrib: \"(B1 + B2) index ps =  B1 index ps + B2 index ps\"", "lemma point_index_diff: \"B1 index ps = (B1 + B2) index ps - B2 index ps\"", "lemma points_index_singleton: \"{#b#} index ps = 1 \\<longleftrightarrow> ps \\<subseteq> b\"", "lemma points_index_singleton_zero: \"\\<not> (ps \\<subseteq> b) \\<Longrightarrow> {#b#} index ps = 0\"", "lemma points_index_sum: \"(\\<Sum>\\<^sub># B ) index ps = (\\<Sum>b \\<in># B . (b index ps))\"", "lemma points_index_block_image_add_eq: \n  assumes \"x \\<notin> ps\"\n  assumes \"B index ps = l\"\n  shows \"{# insert x b . b \\<in># B#} index ps = l\"", "lemma points_index_on_set_def [simp]: \n  assumes \"finite B\"\n  shows \"(mset_set B) index ps = card {b \\<in> B. ps \\<subseteq> b}\"", "lemma points_index_single_rep_num: \"B index {x} = B rep x\"", "lemma points_index_pair_rep_num: \n  assumes \"\\<And> b. b \\<in># B \\<Longrightarrow> x \\<in> b\"\n  shows \"B index {x, y} = B rep y\"", "lemma points_index_0_left_imp: \n  assumes \"B index ps = 0\"\n  assumes \"b \\<in># B\"\n  shows \"\\<not> (ps \\<subseteq> b)\"", "lemma points_index_0_right_imp: \n  assumes \"\\<And> b . b \\<in># B \\<Longrightarrow> (\\<not> ps \\<subseteq> b)\"\n  shows \"B index ps = 0\"", "lemma points_index_0_iff: \"B index ps = 0 \\<longleftrightarrow> (\\<forall> b. b \\<in># B \\<longrightarrow> (\\<not> ps \\<subseteq> b))\"", "lemma points_index_gt0_impl_existance: \n  assumes \"B index ps > 0\"\n  shows \"(\\<exists> bl . (bl \\<in># B \\<and> ps \\<subseteq> bl))\"", "lemma points_index_one_unique: \n  assumes \"B index ps = 1\"\n  assumes \"bl \\<in># B\" and \"ps \\<subseteq> bl\" and \"bl' \\<in># B\" and \"ps \\<subseteq> bl'\"\n  shows \"bl = bl'\"", "lemma points_index_one_unique_block: \n  assumes \"B index ps = 1\"\n  shows \"\\<exists>! bl . (bl \\<in># B \\<and> ps \\<subseteq> bl)\"", "lemma points_index_one_not_unique_block: \n  assumes \"B index ps = 1\"\n  assumes \"ps \\<subseteq> bl\"\n  assumes \"bl \\<in># B\"\n  assumes \"bl' \\<in># B - {#bl#}\"\n  shows \"\\<not> ps \\<subseteq> bl'\"", "lemma (in incidence_system) points_index_alt_def: \"\\<B> index ps = size {#b \\<in># \\<B> . ps \\<subseteq> b#}\"", "lemma (in incidence_system) points_index_ps_nin: \"\\<not> (ps \\<subseteq> \\<V>) \\<Longrightarrow> \\<B> index ps = 0\"", "lemma (in incidence_system) points_index_count_bl: \n    \"multiplicity bl \\<ge> n \\<Longrightarrow> ps \\<subseteq> bl \\<Longrightarrow> count {#bl \\<in># \\<B> . ps \\<subseteq> bl#} bl \\<ge> n\"", "lemma (in finite_incidence_system) points_index_zero: \n  assumes \"card ps > card \\<V>\" \n  shows \"\\<B> index ps = 0\"", "lemma (in design) points_index_subset: \n    \"x \\<subseteq># {#bl \\<in># \\<B> . ps \\<subseteq> bl#} \\<Longrightarrow> ps \\<subseteq> \\<V> \\<Longrightarrow> (\\<B> index ps) \\<ge> (size x)\"", "lemma (in design) points_index_count_min: \"multiplicity bl \\<ge> n \\<Longrightarrow> ps \\<subseteq> bl \\<Longrightarrow> \\<B> index ps \\<ge> n\"", "lemma intersection_num_non_neg: \"b1 |\\<inter>| b2 \\<ge> 0\"", "lemma intersection_number_empty_iff: \n  assumes \"finite b1\"\n  shows \"b1 \\<inter> b2 = {} \\<longleftrightarrow> b1 |\\<inter>| b2 = 0\"", "lemma intersect_num_commute: \"b1 |\\<inter>| b2 = b2 |\\<inter>| b1\"", "lemma n_intersect_num_subset_def: \"b1 |\\<inter>|\\<^sub>n b2 = card {x . x \\<subseteq> b1 \\<inter> b2 \\<and> card x = n}\"", "lemma n_inter_num_one: \"finite b1 \\<Longrightarrow> finite b2 \\<Longrightarrow> b1 |\\<inter>|\\<^sub>1 b2 = b1 |\\<inter>| b2\"", "lemma n_inter_num_choose: \"finite b1 \\<Longrightarrow> finite b2 \\<Longrightarrow> b1 |\\<inter>|\\<^sub>n b2 = (card (b1 \\<inter> b2) choose n)\"", "lemma set_filter_single: \"x \\<in> A \\<Longrightarrow> {a \\<in> A . a = x} = {x}\"", "lemma (in design) n_inter_num_zero: \n  assumes \"b1 \\<in># \\<B>\" and \"b2 \\<in># \\<B>\"\n  shows \"b1 |\\<inter>|\\<^sub>0 b2 = 1\"", "lemma (in design) n_inter_num_choose_design: \"b1 \\<in># \\<B> \\<Longrightarrow> b2 \\<in># \\<B> \n    \\<Longrightarrow> b1 |\\<inter>|\\<^sub>n b2 = (card (b1 \\<inter> b2) choose n) \"", "lemma (in design) n_inter_num_choose_design_inter: \"b1 \\<in># \\<B> \\<Longrightarrow> b2 \\<in># \\<B> \n    \\<Longrightarrow> b1 |\\<inter>|\\<^sub>n b2 = (nat (b1 |\\<inter>| b2) choose n) \"", "lemma replication_numbers_non_empty: \n  assumes \"\\<V> \\<noteq> {}\"\n  shows \"replication_numbers \\<noteq> {}\"", "lemma obtain_point_with_rep: \"r \\<in> replication_numbers \\<Longrightarrow> \\<exists> x. x \\<in> \\<V> \\<and> \\<B> rep x = r\"", "lemma point_rep_number_in_set: \"x \\<in> \\<V> \\<Longrightarrow> (\\<B> rep x) \\<in> replication_numbers\"", "lemma (in finite_incidence_system) replication_numbers_finite: \"finite replication_numbers\"", "lemma block_sizes_non_empty_set: \n  assumes \"\\<B> \\<noteq> {#}\"\n  shows \"sys_block_sizes \\<noteq> {}\"", "lemma finite_block_sizes: \"finite (sys_block_sizes)\"", "lemma block_sizes_non_empty: \n  assumes \"\\<B> \\<noteq> {#}\"\n  shows \"card (sys_block_sizes) > 0\"", "lemma sys_block_sizes_in: \"bl \\<in># \\<B> \\<Longrightarrow> card bl \\<in> sys_block_sizes\"", "lemma sys_block_sizes_obtain_bl: \"x \\<in> sys_block_sizes  \\<Longrightarrow> (\\<exists> bl \\<in># \\<B>. int (card bl) = x)\"", "lemma obtain_blocks_intersect_num: \"n \\<in> intersection_numbers \\<Longrightarrow> \n  \\<exists> b1 b2. b1 \\<in># \\<B> \\<and> b2 \\<in># (\\<B> - {#b1#}) \\<and>  b1 |\\<inter>| b2 = n\"", "lemma intersect_num_in_set: \"b1 \\<in># \\<B> \\<Longrightarrow> b2 \\<in># (\\<B> - {#b1#}) \\<Longrightarrow> b1 |\\<inter>| b2 \\<in> intersection_numbers\"", "lemma point_indices_elem_in: \"ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = t \\<Longrightarrow> \\<B> index ps \\<in> point_indices t\"", "lemma point_indices_alt_def: \"point_indices t = { \\<B> index ps | ps. int (card ps) = t \\<and> ps \\<subseteq> \\<V>}\"", "lemma block_complement_elem_iff: \n  assumes \"ps \\<subseteq> \\<V>\"\n  shows \"ps \\<subseteq> bl\\<^sup>c \\<longleftrightarrow> (\\<forall> x \\<in> ps. x \\<notin> bl)\"", "lemma block_complement_inter_empty: \"bl1\\<^sup>c = bl2 \\<Longrightarrow> bl1 \\<inter> bl2 = {}\"", "lemma block_complement_inv: \n  assumes \"bl \\<in># \\<B>\"\n  assumes \"bl\\<^sup>c = bl2\"\n  shows \"bl2\\<^sup>c = bl\"", "lemma block_complement_subset_points: \"ps \\<subseteq> (bl\\<^sup>c) \\<Longrightarrow> ps \\<subseteq> \\<V>\"", "lemma obtain_comp_block_orig: \n  assumes \"bl1 \\<in># \\<B>\\<^sup>C\"\n  obtains bl2 where \"bl2 \\<in># \\<B>\" and \"bl1 = bl2\\<^sup>c\"", "lemma complement_same_b [simp]: \"size \\<B>\\<^sup>C = size \\<B>\"", "lemma block_comp_elem_alt_left: \"x \\<in> bl \\<Longrightarrow> ps \\<subseteq> bl\\<^sup>c \\<Longrightarrow> x \\<notin> ps\"", "lemma block_comp_elem_alt_right: \"ps \\<subseteq> \\<V> \\<Longrightarrow> (\\<And> x . x \\<in> ps \\<Longrightarrow> x \\<notin> bl) \\<Longrightarrow> ps \\<subseteq> bl\\<^sup>c\"", "lemma complement_index:\n  assumes \"ps \\<subseteq> \\<V>\"\n  shows \"\\<B>\\<^sup>C index ps = size {# b \\<in># \\<B> . (\\<forall> x \\<in> ps . x \\<notin> b) #}\"", "lemma complement_index_2:\n  assumes \"{x, y} \\<subseteq> \\<V>\"\n  shows \"\\<B>\\<^sup>C index {x, y} = size {# b \\<in># \\<B> . x \\<notin> b \\<and> y \\<notin> b #}\"", "lemma complement_rep_number: \n  assumes \"x \\<in> \\<V>\" and \"\\<B> rep x = r\" \n  shows  \"\\<B>\\<^sup>C rep x = \\<b> - r\"", "lemma complement_blocks_wf: \"bl \\<in># \\<B>\\<^sup>C \\<Longrightarrow> bl \\<subseteq> \\<V>\"", "lemma complement_wf [intro]: \"incidence_system \\<V> \\<B>\\<^sup>C\"", "lemma block_complement_size: \"b \\<subseteq> \\<V> \\<Longrightarrow> card (b\\<^sup>c) = card \\<V> - card b\"", "lemma block_comp_incomplete: \"incomplete_block bl \\<Longrightarrow> card (bl\\<^sup>c) > 0\"", "lemma  block_comp_incomplete_nempty: \"incomplete_block bl \\<Longrightarrow> bl\\<^sup>c \\<noteq> {}\"", "lemma incomplete_block_proper_subset: \"incomplete_block bl \\<Longrightarrow> bl \\<subset> \\<V>\"", "lemma complement_finite: \"finite_incidence_system \\<V> \\<B>\\<^sup>C\"", "lemma (in design) complement_design: \n  assumes \"\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\" \n  shows \"design \\<V> (\\<B>\\<^sup>C)\"", "lemma multiple_block_in_original: \"b \\<in># multiple_blocks n \\<Longrightarrow> b \\<in># \\<B>\"", "lemma multiple_block_in: \"n > 0 \\<Longrightarrow> b \\<in># \\<B> \\<Longrightarrow>  b \\<in># multiple_blocks n\"", "lemma multiple_blocks_gt: \"n > 0 \\<Longrightarrow> size (multiple_blocks n) \\<ge> size \\<B>\"", "lemma block_original_count_le: \"n > 0 \\<Longrightarrow> count \\<B> b \\<le> count (multiple_blocks n) b\"", "lemma multiple_blocks_sub: \"n > 0 \\<Longrightarrow> \\<B> \\<subseteq># (multiple_blocks n)\"", "lemma multiple_1_same: \"multiple_blocks 1 = \\<B>\"", "lemma multiple_unfold_1: \"multiple_blocks (Suc n) = (multiple_blocks n) + \\<B>\"", "lemma multiple_point_rep_num: \"(multiple_blocks n) rep x = (\\<B> rep x) * n\"", "lemma multiple_point_index: \"(multiple_blocks n) index ps = (\\<B> index ps) * n\"", "lemma repeat_mset_block_point_rel: \"\\<And>b x. b \\<in># multiple_blocks  n \\<Longrightarrow> x \\<in> b \\<Longrightarrow> x \\<in> \\<V>\"", "lemma multiple_is_wellformed: \"incidence_system \\<V> (multiple_blocks n)\"", "lemma  multiple_blocks_num [simp]: \"size (multiple_blocks n) = n*\\<b>\"", "lemma multiple_block_multiplicity [simp]: \"mult_sys.multiplicity n bl = (multiplicity bl) * n\"", "lemma multiple_block_sizes_same: \n  assumes \"n > 0\" \n  shows \"sys_block_sizes = mult_sys.sys_block_sizes n\"", "lemma multiple_is_finite: \"finite_incidence_system \\<V> (multiple_blocks n)\"", "lemma multiple_is_design: \"design \\<V> (multiple_blocks n)\"", "lemma simple_alt_def_all: \"\\<forall> bl \\<in># \\<B> . multiplicity bl = 1\"", "lemma simple_blocks_eq_sup: \"mset_set (design_support) = \\<B>\"", "lemma simple_block_size_eq_card: \"\\<b> = card (design_support)\"", "lemma points_index_simple_def: \"\\<B> index ps = card {b \\<in> design_support . ps \\<subseteq> b}\"", "lemma replication_num_simple_def: \"\\<B> rep x = card {b \\<in> design_support . x \\<in> b}\"", "lemma simple_not_multiplicity: \"b \\<in># \\<B> \\<Longrightarrow> multiplicity  b > 1 \\<Longrightarrow> \\<not> simple_incidence_system \\<V> \\<B>\"", "lemma multiple_not_simple: \n  assumes \"n > 1\"\n  assumes \"\\<B> \\<noteq> {#}\"\n  shows \"\\<not> simple_incidence_system \\<V> (multiple_blocks n)\"", "lemma is_proper: \"proper_design \\<V> \\<B>\"", "lemma v_non_zero: \"\\<v> > 0\"", "lemma b_positive: \"\\<b> > 0\"", "lemma design_points_nempty: \"\\<V> \\<noteq> {}\"", "lemma design_blocks_nempty: \"\\<B> \\<noteq> {#}\"", "lemma (in design) proper_designI[intro]: \"\\<b> \\<noteq> 0 \\<Longrightarrow> proper_design \\<V> \\<B>\"", "lemma proper_designII[intro]: \n  assumes \"design V B\" and \"B \\<noteq> {#}\" \n  shows \"proper_design V B\"", "lemma multiple_proper_design: \n  assumes \"n > 0\"\n  shows \"proper_design \\<V> (multiple_blocks n)\"", "lemma complement_proper_design: \n  assumes \"\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\"\n  shows \"proper_design \\<V> \\<B>\\<^sup>C\""], "translations": [["", "lemma incidence_alt_def: \n  assumes \"p \\<in> \\<V>\"\n  assumes \"b \\<in># \\<B>\"\n  shows \"incident p b \\<longleftrightarrow> p \\<in> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incident p b = (p \\<in> b)", "by (auto simp add: incident_def \\<I>_def assms)"], ["", "lemma wf_invalid_point: \"x \\<notin> \\<V> \\<Longrightarrow> b \\<in># \\<B> \\<Longrightarrow> x \\<notin> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<V>; b \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> b", "using wellformed"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<V>; b \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> b", "by auto"], ["", "lemma block_set_nempty_imp_block_ex: \"\\<B> \\<noteq> {#} \\<Longrightarrow> \\<exists> bl . bl \\<in># \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> \\<noteq> {#} \\<Longrightarrow> \\<exists>bl. bl \\<in># \\<B>", "by auto"], ["", "text \\<open>Abbreviations for all incidence systems\\<close>"], ["", "abbreviation multiplicity :: \"'a set \\<Rightarrow> nat\" where\n\"multiplicity b \\<equiv> count \\<B> b\""], ["", "abbreviation incomplete_block :: \"'a set \\<Rightarrow> bool\" where\n\"incomplete_block bl \\<equiv> card bl < card \\<V> \\<and> bl \\<in># \\<B>\""], ["", "lemma incomplete_alt_size: \"incomplete_block bl \\<Longrightarrow> card bl < \\<v>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incomplete_block bl \\<Longrightarrow> int (card bl) < \\<v>", "by simp"], ["", "lemma incomplete_alt_in: \"incomplete_block bl \\<Longrightarrow> bl \\<in># \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incomplete_block bl \\<Longrightarrow> bl \\<in># \\<B>", "by simp"], ["", "lemma incomplete_alt_imp[intro]: \"card bl < \\<v> \\<Longrightarrow> bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>int (card bl) < \\<v>; bl \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> incomplete_block bl", "by simp"], ["", "definition design_support :: \"'a set set\" where\n\"design_support \\<equiv> set_mset \\<B>\""], ["", "end"], ["", "subsection \\<open>Finite Incidence Systems\\<close>"], ["", "text \\<open>These simply require the point set to be finite.\nAs multisets are only defined to be finite, it is implied that the block set must be finite already\\<close>"], ["", "locale finite_incidence_system = incidence_system + \n  assumes finite_sets: \"finite \\<V>\"\nbegin"], ["", "lemma finite_blocks: \"b \\<in># \\<B> \\<Longrightarrow> finite b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in># \\<B> \\<Longrightarrow> finite b", "using wellformed finite_sets finite_subset"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n  finite \\<V>\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. b \\<in># \\<B> \\<Longrightarrow> finite b", "by blast"], ["", "lemma mset_points_distinct: \"distinct_mset (mset_set \\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset (mset_set \\<V>)", "using finite_sets"], ["proof (prove)\nusing this:\n  finite \\<V>\n\ngoal (1 subgoal):\n 1. distinct_mset (mset_set \\<V>)", "by (simp add: distinct_mset_def)"], ["", "lemma mset_points_distinct_diff_one: \"distinct_mset (mset_set (\\<V> - {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset (mset_set (\\<V> - {x}))", "by (meson count_mset_set_le_one distinct_mset_count_less_1)"], ["", "lemma finite_design_support: \"finite (design_support)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite design_support", "using design_support_def"], ["proof (prove)\nusing this:\n  design_support \\<equiv> set_mset \\<B>\n\ngoal (1 subgoal):\n 1. finite design_support", "by auto"], ["", "lemma block_size_lt_order: \"bl \\<in># \\<B> \\<Longrightarrow> card bl \\<le> card \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> card bl \\<le> card \\<V>", "using wellformed"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> card bl \\<le> card \\<V>", "by (simp add: card_mono finite_sets)"], ["", "end"], ["", "subsection \\<open>Designs\\<close>"], ["", "text \\<open>There are many varied definitions of a design in literature. However, the most\ncommonly accepted definition is a finite point set, $V$ and collection of blocks $B$, where\nno block in $B$ can be empty\\<close>"], ["", "locale design = finite_incidence_system +\n  assumes blocks_nempty: \"bl \\<in># \\<B> \\<Longrightarrow> bl \\<noteq> {}\"\nbegin"], ["", "lemma wf_design: \"design \\<V> \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design \\<V> \\<B>", "by intro_locales"], ["", "lemma wf_design_iff: \"bl \\<in># \\<B> \\<Longrightarrow> design \\<V> \\<B> \\<longleftrightarrow> (bl \\<subseteq> \\<V> \\<and> finite \\<V> \\<and> bl \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow>\n    design \\<V> \\<B> =\n    (bl \\<subseteq> \\<V> \\<and> finite \\<V> \\<and> bl \\<noteq> {})", "using blocks_nempty wellformed finite_sets"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {}\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n  finite \\<V>\n\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow>\n    design \\<V> \\<B> =\n    (bl \\<subseteq> \\<V> \\<and> finite \\<V> \\<and> bl \\<noteq> {})", "by (simp add: wf_design)"], ["", "text \\<open>Reasoning on non empty properties and non zero parameters\\<close>"], ["", "lemma blocks_nempty_alt: \"\\<forall> bl \\<in># \\<B>. bl \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#\\<B>. bl \\<noteq> {}", "using blocks_nempty"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#\\<B>. bl \\<noteq> {}", "by auto"], ["", "lemma block_set_nempty_imp_points: \"\\<B> \\<noteq> {#} \\<Longrightarrow> \\<V> \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> \\<noteq> {#} \\<Longrightarrow> \\<V> \\<noteq> {}", "using wf_design wf_design_iff"], ["proof (prove)\nusing this:\n  design \\<V> \\<B>\n  ?bl \\<in># \\<B> \\<Longrightarrow>\n  design \\<V> \\<B> =\n  (?bl \\<subseteq> \\<V> \\<and> finite \\<V> \\<and> ?bl \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<B> \\<noteq> {#} \\<Longrightarrow> \\<V> \\<noteq> {}", "by auto"], ["", "lemma b_non_zero_imp_v_non_zero: \"\\<b> > 0 \\<Longrightarrow> \\<v> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<b> \\<Longrightarrow> 0 < \\<v>", "using block_set_nempty_imp_points finite_sets"], ["proof (prove)\nusing this:\n  \\<B> \\<noteq> {#} \\<Longrightarrow> \\<V> \\<noteq> {}\n  finite \\<V>\n\ngoal (1 subgoal):\n 1. 0 < \\<b> \\<Longrightarrow> 0 < \\<v>", "by fastforce"], ["", "lemma v_eq0_imp_b_eq_0: \"\\<v> = 0 \\<Longrightarrow> \\<b> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<v> = 0 \\<Longrightarrow> \\<b> = 0", "using b_non_zero_imp_v_non_zero"], ["proof (prove)\nusing this:\n  0 < \\<b> \\<Longrightarrow> 0 < \\<v>\n\ngoal (1 subgoal):\n 1. \\<v> = 0 \\<Longrightarrow> \\<b> = 0", "by auto"], ["", "text \\<open>Size lemmas\\<close>"], ["", "lemma block_size_lt_v: \"bl \\<in># \\<B> \\<Longrightarrow> card bl \\<le> \\<v>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> int (card bl) \\<le> \\<v>", "by (simp add: card_mono finite_sets wellformed)"], ["", "lemma block_size_gt_0: \"bl \\<in># \\<B> \\<Longrightarrow> card bl > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> 0 < card bl", "using finite_sets blocks_nempty finite_blocks"], ["proof (prove)\nusing this:\n  finite \\<V>\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {}\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> 0 < card bl", "by fastforce"], ["", "lemma design_cart_product_size: \"size ((mset_set \\<V>) \\<times># \\<B>) = \\<v> * \\<b>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size (mset_set \\<V> \\<times># \\<B>)) = \\<v> * \\<b>", "by (simp add: size_cartesian_product)"], ["", "end"], ["", "text \\<open>Intro rules for design locale\\<close>"], ["", "lemma wf_design_implies: \n  assumes \"(\\<And> b . b \\<in># \\<B> \\<Longrightarrow> b \\<subseteq> V)\"\n  assumes \"\\<And> b . b \\<in># \\<B> \\<Longrightarrow> b \\<noteq> {}\"\n  assumes \"finite V\"\n  assumes \"\\<B> \\<noteq> {#}\"\n  assumes \"V \\<noteq> {}\"\n  shows \"design V \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design V \\<B>", "using assms"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> V\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<noteq> {}\n  finite V\n  \\<B> \\<noteq> {#}\n  V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. design V \\<B>", "by (unfold_locales) simp_all"], ["", "lemma (in incidence_system) finite_sysI[intro]: \"finite \\<V> \\<Longrightarrow> finite_incidence_system \\<V> \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<V> \\<Longrightarrow> finite_incidence_system \\<V> \\<B>", "by (unfold_locales) simp_all"], ["", "lemma (in finite_incidence_system) designI[intro]: \"(\\<And> b. b \\<in># \\<B> \\<Longrightarrow> b \\<noteq> {}) \\<Longrightarrow> \\<B> \\<noteq> {#}\n     \\<Longrightarrow> \\<V> \\<noteq> {} \\<Longrightarrow> design \\<V> \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>b. b \\<in># \\<B> \\<Longrightarrow> b \\<noteq> {};\n     \\<B> \\<noteq> {#}; \\<V> \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> design \\<V> \\<B>", "by (unfold_locales) simp_all"], ["", "subsection \\<open>Core Property Definitions\\<close>"], ["", "subsubsection \\<open>Replication Number\\<close>"], ["", "text \\<open>The replication number for a point is the number of blocks that point is incident with\\<close>"], ["", "definition point_replication_number :: \"'a set multiset \\<Rightarrow> 'a \\<Rightarrow> int\" (infix \"rep\" 75) where\n\"B rep x \\<equiv> size {#b \\<in># B . x \\<in> b#}\""], ["", "lemma max_point_rep: \"B rep x \\<le> size B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B rep x \\<le> int (size B)", "using size_filter_mset_lesseq"], ["proof (prove)\nusing this:\n  size (filter_mset ?f ?M) \\<le> size ?M\n\ngoal (1 subgoal):\n 1. B rep x \\<le> int (size B)", "by (simp add: point_replication_number_def)"], ["", "lemma rep_number_g0_exists: \n  assumes \"B rep x > 0\" \n  obtains b where \"b \\<in># B\" and \"x \\<in> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in># B; x \\<in> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in># B; x \\<in> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"size {#b \\<in># B . x \\<in> b#} > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < size (filter_mset ((\\<in>) x) B)", "using assms point_replication_number_def"], ["proof (prove)\nusing this:\n  0 < B rep x\n  ?B rep ?x \\<equiv> int (size (filter_mset ((\\<in>) ?x) ?B))\n\ngoal (1 subgoal):\n 1. 0 < size (filter_mset ((\\<in>) x) B)", "by (metis of_nat_0_less_iff)"], ["proof (state)\nthis:\n  0 < size (filter_mset ((\\<in>) x) B)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in># B; x \\<in> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < size (filter_mset ((\\<in>) x) B)\n\ngoal (1 subgoal):\n 1. thesis", "by (metis filter_mset_empty_conv nonempty_has_size that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rep_number_on_set_def: \"finite B \\<Longrightarrow> (mset_set B) rep x = card {b \\<in> B . x \\<in> b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B \\<Longrightarrow>\n    mset_set B rep x = int (card {b \\<in> B. x \\<in> b})", "by (simp add: point_replication_number_def)"], ["", "lemma point_rep_number_split[simp]: \"(A + B) rep x = A rep x + B rep x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A + B) rep x = A rep x + B rep x", "by (simp add: point_replication_number_def)"], ["", "lemma point_rep_singleton_val [simp]: \"x \\<in> b \\<Longrightarrow> {#b#} rep x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> b \\<Longrightarrow> {#b#} rep x = 1", "by (simp add: point_replication_number_def)"], ["", "lemma point_rep_singleton_inval [simp]: \"x \\<notin> b \\<Longrightarrow> {#b#} rep x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> b \\<Longrightarrow> {#b#} rep x = 0", "by (simp add: point_replication_number_def)"], ["", "context incidence_system\nbegin"], ["", "lemma point_rep_number_alt_def: \"\\<B> rep x = size {# b \\<in># \\<B> . x \\<in> b#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> rep x = int (size (filter_mset ((\\<in>) x) \\<B>))", "by (simp add: point_replication_number_def)"], ["", "lemma rep_number_non_zero_system_point: \" \\<B> rep x > 0 \\<Longrightarrow> x \\<in> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<B> rep x \\<Longrightarrow> x \\<in> \\<V>", "using rep_number_g0_exists wellformed"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?B rep ?x;\n   \\<And>b.\n      \\<lbrakk>b \\<in># ?B; ?x \\<in> b\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. 0 < \\<B> rep x \\<Longrightarrow> x \\<in> \\<V>", "by (metis wf_invalid_point)"], ["", "lemma point_rep_non_existance [simp]: \"x \\<notin> \\<V> \\<Longrightarrow> \\<B> rep x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> \\<V> \\<Longrightarrow> \\<B> rep x = 0", "using wf_invalid_point"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<notin> \\<V>; ?b \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> ?b\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<V> \\<Longrightarrow> \\<B> rep x = 0", "by (simp add:  point_replication_number_def filter_mset_empty_conv)"], ["", "lemma point_rep_number_inv: \"size {# b \\<in># \\<B> . x \\<notin> b #} = \\<b> - (\\<B> rep x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<notin>) x) \\<B>)) = \\<b> - \\<B> rep x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<notin>) x) \\<B>)) = \\<b> - \\<B> rep x", "have \"\\<b> = size {# b \\<in># \\<B> . x \\<notin> b #} + size {# b \\<in># \\<B> . x \\<in> b #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> =\n    int (size (filter_mset ((\\<notin>) x) \\<B>) +\n         size (filter_mset ((\\<in>) x) \\<B>))", "using multiset_partition"], ["proof (prove)\nusing this:\n  ?M = filter_mset ?P ?M + {#x \\<in># ?M. \\<not> ?P x#}\n\ngoal (1 subgoal):\n 1. \\<b> =\n    int (size (filter_mset ((\\<notin>) x) \\<B>) +\n         size (filter_mset ((\\<in>) x) \\<B>))", "by (metis add.commute size_union)"], ["proof (state)\nthis:\n  \\<b> =\n  int (size (filter_mset ((\\<notin>) x) \\<B>) +\n       size (filter_mset ((\\<in>) x) \\<B>))\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<notin>) x) \\<B>)) = \\<b> - \\<B> rep x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<b> =\n  int (size (filter_mset ((\\<notin>) x) \\<B>) +\n       size (filter_mset ((\\<in>) x) \\<B>))\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<notin>) x) \\<B>)) = \\<b> - \\<B> rep x", "by (simp add: point_replication_number_def)"], ["proof (state)\nthis:\n  int (size (filter_mset ((\\<notin>) x) \\<B>)) = \\<b> - \\<B> rep x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma point_rep_num_inv_non_empty: \"(\\<B> rep x) < \\<b> \\<Longrightarrow> \\<B> \\<noteq> {#} \\<Longrightarrow> {# b \\<in># \\<B> . x \\<notin> b #} \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<B> rep x < \\<b>; \\<B> \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> filter_mset ((\\<notin>) x) \\<B> \\<noteq> {#}", "by (metis diff_zero point_replication_number_def size_empty size_filter_neg verit_comp_simplify1(1))"], ["", "end"], ["", "subsubsection \\<open>Point Index\\<close>"], ["", "text \\<open>The point index of a subset of points in a design, is the number of times those points \noccur together in a block of the design\\<close>"], ["", "definition points_index :: \"'a set multiset \\<Rightarrow> 'a set \\<Rightarrow> nat\" (infix \"index\" 75) where\n\"B index ps \\<equiv> size {#b \\<in># B . ps \\<subseteq> b#}\""], ["", "lemma points_index_empty [simp]: \"{#} index ps = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#} index ps = 0", "by (simp add: points_index_def)"], ["", "lemma point_index_distrib: \"(B1 + B2) index ps =  B1 index ps + B2 index ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B1 + B2) index ps = B1 index ps + B2 index ps", "by (simp add: points_index_def)"], ["", "lemma point_index_diff: \"B1 index ps = (B1 + B2) index ps - B2 index ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B1 index ps = (B1 + B2) index ps - B2 index ps", "by (simp add: points_index_def)"], ["", "lemma points_index_singleton: \"{#b#} index ps = 1 \\<longleftrightarrow> ps \\<subseteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#b#} index ps = 1) = (ps \\<subseteq> b)", "by (simp add: points_index_def)"], ["", "lemma points_index_singleton_zero: \"\\<not> (ps \\<subseteq> b) \\<Longrightarrow> {#b#} index ps = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> b \\<Longrightarrow> {#b#} index ps = 0", "by (simp add: points_index_def)"], ["", "lemma points_index_sum: \"(\\<Sum>\\<^sub># B ) index ps = (\\<Sum>b \\<in># B . (b index ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># B index ps = (\\<Sum>b\\<in>#B. b index ps)", "using points_index_empty"], ["proof (prove)\nusing this:\n  {#} index ?ps = 0\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># B index ps = (\\<Sum>b\\<in>#B. b index ps)", "by (induction B) (auto simp add: point_index_distrib)"], ["", "lemma points_index_block_image_add_eq: \n  assumes \"x \\<notin> ps\"\n  assumes \"B index ps = l\"\n  shows \"{# insert x b . b \\<in># B#} index ps = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset (insert x) B index ps = l", "using points_index_def"], ["proof (prove)\nusing this:\n  ?B index ?ps \\<equiv> size (filter_mset ((\\<subseteq>) ?ps) ?B)\n\ngoal (1 subgoal):\n 1. image_mset (insert x) B index ps = l", "by (metis (no_types, lifting) assms filter_mset_cong \n      image_mset_filter_swap2 points_index_def size_image_mset subset_insert)"], ["", "lemma points_index_on_set_def [simp]: \n  assumes \"finite B\"\n  shows \"(mset_set B) index ps = card {b \\<in> B. ps \\<subseteq> b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_set B index ps = card {b \\<in> B. ps \\<subseteq> b}", "by (simp add: points_index_def assms)"], ["", "lemma points_index_single_rep_num: \"B index {x} = B rep x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (B index {x}) = B rep x", "by (simp add: points_index_def point_replication_number_def)"], ["", "lemma points_index_pair_rep_num: \n  assumes \"\\<And> b. b \\<in># B \\<Longrightarrow> x \\<in> b\"\n  shows \"B index {x, y} = B rep y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (B index {x, y}) = B rep y", "using point_replication_number_def points_index_def"], ["proof (prove)\nusing this:\n  ?B rep ?x \\<equiv> int (size (filter_mset ((\\<in>) ?x) ?B))\n  ?B index ?ps \\<equiv> size (filter_mset ((\\<subseteq>) ?ps) ?B)\n\ngoal (1 subgoal):\n 1. int (B index {x, y}) = B rep y", "by (metis assms empty_subsetI filter_mset_cong insert_subset)"], ["", "lemma points_index_0_left_imp: \n  assumes \"B index ps = 0\"\n  assumes \"b \\<in># B\"\n  shows \"\\<not> (ps \\<subseteq> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> b", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> ps \\<subseteq> b \\<Longrightarrow> False", "assume \"\\<not> \\<not> ps \\<subseteq> b\""], ["proof (state)\nthis:\n  \\<not> \\<not> ps \\<subseteq> b\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> ps \\<subseteq> b \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<not> ps \\<subseteq> b", "have a: \"ps \\<subseteq> b\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> ps \\<subseteq> b\n\ngoal (1 subgoal):\n 1. ps \\<subseteq> b", "by auto"], ["proof (state)\nthis:\n  ps \\<subseteq> b\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> ps \\<subseteq> b \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ps \\<subseteq> b", "have \"b \\<in># {#bl \\<in># B . ps \\<subseteq> bl#}\""], ["proof (prove)\nusing this:\n  ps \\<subseteq> b\n\ngoal (1 subgoal):\n 1. b \\<in># filter_mset ((\\<subseteq>) ps) B", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  b \\<in># filter_mset ((\\<subseteq>) ps) B\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> ps \\<subseteq> b \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  b \\<in># filter_mset ((\\<subseteq>) ps) B\n\ngoal (1 subgoal):\n 1. False", "by (metis assms(1) count_greater_eq_Suc_zero_iff count_size_set_repr not_less_eq_eq \n        points_index_def size_filter_mset_lesseq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma points_index_0_right_imp: \n  assumes \"\\<And> b . b \\<in># B \\<Longrightarrow> (\\<not> ps \\<subseteq> b)\"\n  shows \"B index ps = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B index ps = 0", "using assms"], ["proof (prove)\nusing this:\n  ?b \\<in># B \\<Longrightarrow> \\<not> ps \\<subseteq> ?b\n\ngoal (1 subgoal):\n 1. B index ps = 0", "by (simp add: filter_mset_empty_conv points_index_def)"], ["", "lemma points_index_0_iff: \"B index ps = 0 \\<longleftrightarrow> (\\<forall> b. b \\<in># B \\<longrightarrow> (\\<not> ps \\<subseteq> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B index ps = 0) =\n    (\\<forall>b. b \\<in># B \\<longrightarrow> \\<not> ps \\<subseteq> b)", "using points_index_0_left_imp points_index_0_right_imp"], ["proof (prove)\nusing this:\n  \\<lbrakk>?B index ?ps = 0; ?b \\<in># ?B\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?ps \\<subseteq> ?b\n  (\\<And>b.\n      b \\<in># ?B \\<Longrightarrow>\n      \\<not> ?ps \\<subseteq> b) \\<Longrightarrow>\n  ?B index ?ps = 0\n\ngoal (1 subgoal):\n 1. (B index ps = 0) =\n    (\\<forall>b. b \\<in># B \\<longrightarrow> \\<not> ps \\<subseteq> b)", "by metis"], ["", "lemma points_index_gt0_impl_existance: \n  assumes \"B index ps > 0\"\n  shows \"(\\<exists> bl . (bl \\<in># B \\<and> ps \\<subseteq> bl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>bl. bl \\<in># B \\<and> ps \\<subseteq> bl", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>bl. bl \\<in># B \\<and> ps \\<subseteq> bl", "have \"size {#bl \\<in># B . ps \\<subseteq> bl#} > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < size (filter_mset ((\\<subseteq>) ps) B)", "by (metis assms points_index_def)"], ["proof (state)\nthis:\n  0 < size (filter_mset ((\\<subseteq>) ps) B)\n\ngoal (1 subgoal):\n 1. \\<exists>bl. bl \\<in># B \\<and> ps \\<subseteq> bl", "then"], ["proof (chain)\npicking this:\n  0 < size (filter_mset ((\\<subseteq>) ps) B)", "obtain bl where \"bl \\<in># B\" and \"ps \\<subseteq> bl\""], ["proof (prove)\nusing this:\n  0 < size (filter_mset ((\\<subseteq>) ps) B)\n\ngoal (1 subgoal):\n 1. (\\<And>bl.\n        \\<lbrakk>bl \\<in># B; ps \\<subseteq> bl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis filter_mset_empty_conv nonempty_has_size)"], ["proof (state)\nthis:\n  bl \\<in># B\n  ps \\<subseteq> bl\n\ngoal (1 subgoal):\n 1. \\<exists>bl. bl \\<in># B \\<and> ps \\<subseteq> bl", "thus ?thesis"], ["proof (prove)\nusing this:\n  bl \\<in># B\n  ps \\<subseteq> bl\n\ngoal (1 subgoal):\n 1. \\<exists>bl. bl \\<in># B \\<and> ps \\<subseteq> bl", "by auto"], ["proof (state)\nthis:\n  \\<exists>bl. bl \\<in># B \\<and> ps \\<subseteq> bl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma points_index_one_unique: \n  assumes \"B index ps = 1\"\n  assumes \"bl \\<in># B\" and \"ps \\<subseteq> bl\" and \"bl' \\<in># B\" and \"ps \\<subseteq> bl'\"\n  shows \"bl = bl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl = bl'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. bl \\<noteq> bl' \\<Longrightarrow> False", "assume assm: \"bl \\<noteq> bl'\""], ["proof (state)\nthis:\n  bl \\<noteq> bl'\n\ngoal (1 subgoal):\n 1. bl \\<noteq> bl' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  bl \\<noteq> bl'", "have bl1: \"bl \\<in># {#bl \\<in># B . ps \\<subseteq> bl#}\""], ["proof (prove)\nusing this:\n  bl \\<noteq> bl'\n\ngoal (1 subgoal):\n 1. bl \\<in># filter_mset ((\\<subseteq>) ps) B", "using assms"], ["proof (prove)\nusing this:\n  bl \\<noteq> bl'\n  B index ps = 1\n  bl \\<in># B\n  ps \\<subseteq> bl\n  bl' \\<in># B\n  ps \\<subseteq> bl'\n\ngoal (1 subgoal):\n 1. bl \\<in># filter_mset ((\\<subseteq>) ps) B", "by simp"], ["proof (state)\nthis:\n  bl \\<in># filter_mset ((\\<subseteq>) ps) B\n\ngoal (1 subgoal):\n 1. bl \\<noteq> bl' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  bl \\<in># filter_mset ((\\<subseteq>) ps) B", "have bl2: \"bl'\\<in># {#bl \\<in># B . ps \\<subseteq> bl#}\""], ["proof (prove)\nusing this:\n  bl \\<in># filter_mset ((\\<subseteq>) ps) B\n\ngoal (1 subgoal):\n 1. bl' \\<in># filter_mset ((\\<subseteq>) ps) B", "using assms"], ["proof (prove)\nusing this:\n  bl \\<in># filter_mset ((\\<subseteq>) ps) B\n  B index ps = 1\n  bl \\<in># B\n  ps \\<subseteq> bl\n  bl' \\<in># B\n  ps \\<subseteq> bl'\n\ngoal (1 subgoal):\n 1. bl' \\<in># filter_mset ((\\<subseteq>) ps) B", "by simp"], ["proof (state)\nthis:\n  bl' \\<in># filter_mset ((\\<subseteq>) ps) B\n\ngoal (1 subgoal):\n 1. bl \\<noteq> bl' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  bl' \\<in># filter_mset ((\\<subseteq>) ps) B", "have \"{#bl, bl'#} \\<subseteq># {#bl \\<in># B . ps \\<subseteq> bl#}\""], ["proof (prove)\nusing this:\n  bl' \\<in># filter_mset ((\\<subseteq>) ps) B\n\ngoal (1 subgoal):\n 1. {#bl, bl'#} \\<subseteq># filter_mset ((\\<subseteq>) ps) B", "using assms"], ["proof (prove)\nusing this:\n  bl' \\<in># filter_mset ((\\<subseteq>) ps) B\n  B index ps = 1\n  bl \\<in># B\n  ps \\<subseteq> bl\n  bl' \\<in># B\n  ps \\<subseteq> bl'\n\ngoal (1 subgoal):\n 1. {#bl, bl'#} \\<subseteq># filter_mset ((\\<subseteq>) ps) B", "by (metis bl1 bl2 points_index_def\n        add_mset_subseteq_single_iff assm mset_subset_eq_single size_single subseteq_mset_size_eql)"], ["proof (state)\nthis:\n  {#bl, bl'#} \\<subseteq># filter_mset ((\\<subseteq>) ps) B\n\ngoal (1 subgoal):\n 1. bl \\<noteq> bl' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {#bl, bl'#} \\<subseteq># filter_mset ((\\<subseteq>) ps) B", "have \"size {#bl \\<in># B . ps \\<subseteq> bl#} \\<ge> 2\""], ["proof (prove)\nusing this:\n  {#bl, bl'#} \\<subseteq># filter_mset ((\\<subseteq>) ps) B\n\ngoal (1 subgoal):\n 1. 2 \\<le> size (filter_mset ((\\<subseteq>) ps) B)", "using size_mset_mono"], ["proof (prove)\nusing this:\n  {#bl, bl'#} \\<subseteq># filter_mset ((\\<subseteq>) ps) B\n  ?A \\<subseteq># ?B \\<Longrightarrow> size ?A \\<le> size ?B\n\ngoal (1 subgoal):\n 1. 2 \\<le> size (filter_mset ((\\<subseteq>) ps) B)", "by fastforce"], ["proof (state)\nthis:\n  2 \\<le> size (filter_mset ((\\<subseteq>) ps) B)\n\ngoal (1 subgoal):\n 1. bl \\<noteq> bl' \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  2 \\<le> size (filter_mset ((\\<subseteq>) ps) B)\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  2 \\<le> size (filter_mset ((\\<subseteq>) ps) B)\n  B index ps = 1\n  bl \\<in># B\n  ps \\<subseteq> bl\n  bl' \\<in># B\n  ps \\<subseteq> bl'\n\ngoal (1 subgoal):\n 1. False", "by (metis numeral_le_one_iff points_index_def semiring_norm(69))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma points_index_one_unique_block: \n  assumes \"B index ps = 1\"\n  shows \"\\<exists>! bl . (bl \\<in># B \\<and> ps \\<subseteq> bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!bl. bl \\<in># B \\<and> ps \\<subseteq> bl", "using assms points_index_gt0_impl_existance points_index_one_unique"], ["proof (prove)\nusing this:\n  B index ps = 1\n  0 < ?B index ?ps \\<Longrightarrow>\n  \\<exists>bl. bl \\<in># ?B \\<and> ?ps \\<subseteq> bl\n  \\<lbrakk>?B index ?ps = 1; ?bl \\<in># ?B; ?ps \\<subseteq> ?bl;\n   ?bl' \\<in># ?B; ?ps \\<subseteq> ?bl'\\<rbrakk>\n  \\<Longrightarrow> ?bl = ?bl'\n\ngoal (1 subgoal):\n 1. \\<exists>!bl. bl \\<in># B \\<and> ps \\<subseteq> bl", "by (metis zero_less_one)"], ["", "lemma points_index_one_not_unique_block: \n  assumes \"B index ps = 1\"\n  assumes \"ps \\<subseteq> bl\"\n  assumes \"bl \\<in># B\"\n  assumes \"bl' \\<in># B - {#bl#}\"\n  shows \"\\<not> ps \\<subseteq> bl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> bl'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> bl'", "have \"B = (B - {#bl#}) + {#bl#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = remove1_mset bl B + {#bl#}", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  B = remove1_mset bl B + {#bl#}\n\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> bl'", "then"], ["proof (chain)\npicking this:\n  B = remove1_mset bl B + {#bl#}", "have \"(B - {#bl#}) index ps = B index ps - {#bl#} index ps\""], ["proof (prove)\nusing this:\n  B = remove1_mset bl B + {#bl#}\n\ngoal (1 subgoal):\n 1. remove1_mset bl B index ps = B index ps - {#bl#} index ps", "by (metis point_index_diff)"], ["proof (state)\nthis:\n  remove1_mset bl B index ps = B index ps - {#bl#} index ps\n\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> bl'", "then"], ["proof (chain)\npicking this:\n  remove1_mset bl B index ps = B index ps - {#bl#} index ps", "have \"(B - {#bl#}) index ps = 0\""], ["proof (prove)\nusing this:\n  remove1_mset bl B index ps = B index ps - {#bl#} index ps\n\ngoal (1 subgoal):\n 1. remove1_mset bl B index ps = 0", "using assms points_index_singleton"], ["proof (prove)\nusing this:\n  remove1_mset bl B index ps = B index ps - {#bl#} index ps\n  B index ps = 1\n  ps \\<subseteq> bl\n  bl \\<in># B\n  bl' \\<in># remove1_mset bl B\n  ({#?b#} index ?ps = 1) = (?ps \\<subseteq> ?b)\n\ngoal (1 subgoal):\n 1. remove1_mset bl B index ps = 0", "by (metis diff_self_eq_0)"], ["proof (state)\nthis:\n  remove1_mset bl B index ps = 0\n\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> bl'", "thus ?thesis"], ["proof (prove)\nusing this:\n  remove1_mset bl B index ps = 0\n\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> bl'", "using assms(4) points_index_0_left_imp"], ["proof (prove)\nusing this:\n  remove1_mset bl B index ps = 0\n  bl' \\<in># remove1_mset bl B\n  \\<lbrakk>?B index ?ps = 0; ?b \\<in># ?B\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?ps \\<subseteq> ?b\n\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> bl'", "by auto"], ["proof (state)\nthis:\n  \\<not> ps \\<subseteq> bl'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in incidence_system) points_index_alt_def: \"\\<B> index ps = size {#b \\<in># \\<B> . ps \\<subseteq> b#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> index ps = size (filter_mset ((\\<subseteq>) ps) \\<B>)", "by (simp add: points_index_def)"], ["", "lemma (in incidence_system) points_index_ps_nin: \"\\<not> (ps \\<subseteq> \\<V>) \\<Longrightarrow> \\<B> index ps = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> \\<V> \\<Longrightarrow> \\<B> index ps = 0", "using points_index_alt_def filter_mset_empty_conv in_mono size_empty subsetI wf_invalid_point"], ["proof (prove)\nusing this:\n  \\<B> index ?ps = size (filter_mset ((\\<subseteq>) ?ps) \\<B>)\n  (filter_mset ?P ?M = {#}) = (\\<forall>L\\<in>#?M. \\<not> ?P L)\n  ?A \\<subseteq> ?B \\<Longrightarrow>\n  ?x \\<in> ?A \\<longrightarrow> ?x \\<in> ?B\n  size {#} = 0\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<in> ?B) \\<Longrightarrow>\n  ?A \\<subseteq> ?B\n  \\<lbrakk>?x \\<notin> \\<V>; ?b \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> ?b\n\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> \\<V> \\<Longrightarrow> \\<B> index ps = 0", "by metis"], ["", "lemma (in incidence_system) points_index_count_bl: \n    \"multiplicity bl \\<ge> n \\<Longrightarrow> ps \\<subseteq> bl \\<Longrightarrow> count {#bl \\<in># \\<B> . ps \\<subseteq> bl#} bl \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> multiplicity bl; ps \\<subseteq> bl\\<rbrakk>\n    \\<Longrightarrow> n \\<le> count (filter_mset ((\\<subseteq>) ps) \\<B>) bl", "by simp"], ["", "lemma (in finite_incidence_system) points_index_zero: \n  assumes \"card ps > card \\<V>\" \n  shows \"\\<B> index ps = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> index ps = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<B> index ps = 0", "have \"\\<And> b. b \\<in># \\<B> \\<Longrightarrow> card ps > card b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. b \\<in># \\<B> \\<Longrightarrow> card b < card ps", "using block_size_lt_order card_subset_not_gt_card finite_sets assms"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> card ?bl \\<le> card \\<V>\n  \\<lbrakk>finite ?A; card ?A < card ?ps\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?ps \\<subseteq> ?A\n  finite \\<V>\n  card \\<V> < card ps\n\ngoal (1 subgoal):\n 1. \\<And>b. b \\<in># \\<B> \\<Longrightarrow> card b < card ps", "by fastforce"], ["proof (state)\nthis:\n  ?b \\<in># \\<B> \\<Longrightarrow> card ?b < card ps\n\ngoal (1 subgoal):\n 1. \\<B> index ps = 0", "then"], ["proof (chain)\npicking this:\n  ?b \\<in># \\<B> \\<Longrightarrow> card ?b < card ps", "have \"{#b \\<in># \\<B> . ps \\<subseteq> b#} = {#}\""], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> card ?b < card ps\n\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) ps) \\<B> = {#}", "by (simp add: card_subset_not_gt_card filter_mset_empty_conv finite_blocks)"], ["proof (state)\nthis:\n  filter_mset ((\\<subseteq>) ps) \\<B> = {#}\n\ngoal (1 subgoal):\n 1. \\<B> index ps = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  filter_mset ((\\<subseteq>) ps) \\<B> = {#}\n\ngoal (1 subgoal):\n 1. \\<B> index ps = 0", "using points_index_alt_def"], ["proof (prove)\nusing this:\n  filter_mset ((\\<subseteq>) ps) \\<B> = {#}\n  \\<B> index ?ps = size (filter_mset ((\\<subseteq>) ?ps) \\<B>)\n\ngoal (1 subgoal):\n 1. \\<B> index ps = 0", "by simp"], ["proof (state)\nthis:\n  \\<B> index ps = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in design) points_index_subset: \n    \"x \\<subseteq># {#bl \\<in># \\<B> . ps \\<subseteq> bl#} \\<Longrightarrow> ps \\<subseteq> \\<V> \\<Longrightarrow> (\\<B> index ps) \\<ge> (size x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<subseteq># filter_mset ((\\<subseteq>) ps) \\<B>;\n     ps \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> size x \\<le> \\<B> index ps", "by (simp add: points_index_def size_mset_mono)"], ["", "lemma (in design) points_index_count_min: \"multiplicity bl \\<ge> n \\<Longrightarrow> ps \\<subseteq> bl \\<Longrightarrow> \\<B> index ps \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> multiplicity bl; ps \\<subseteq> bl\\<rbrakk>\n    \\<Longrightarrow> n \\<le> \\<B> index ps", "using points_index_alt_def set_count_size_min"], ["proof (prove)\nusing this:\n  \\<B> index ?ps = size (filter_mset ((\\<subseteq>) ?ps) \\<B>)\n  ?n \\<le> count ?A ?a \\<Longrightarrow> ?n \\<le> size ?A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> multiplicity bl; ps \\<subseteq> bl\\<rbrakk>\n    \\<Longrightarrow> n \\<le> \\<B> index ps", "by (metis filter_mset.rep_eq)"], ["", "subsubsection \\<open>Intersection Number\\<close>"], ["", "text \\<open>The intersection number of two blocks is the size of the intersection of those blocks. i.e. \nthe number of points which occur in both blocks\\<close>"], ["", "definition intersection_number :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> int\" (infix \"|\\<inter>|\" 70) where\n\"b1 |\\<inter>| b2 \\<equiv> card (b1 \\<inter> b2)\""], ["", "lemma intersection_num_non_neg: \"b1 |\\<inter>| b2 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b1 |\\<inter>| b2", "by (simp add: intersection_number_def)"], ["", "lemma intersection_number_empty_iff: \n  assumes \"finite b1\"\n  shows \"b1 \\<inter> b2 = {} \\<longleftrightarrow> b1 |\\<inter>| b2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b1 \\<inter> b2 = {}) = (b1 |\\<inter>| b2 = 0)", "by (simp add: intersection_number_def assms)"], ["", "lemma intersect_num_commute: \"b1 |\\<inter>| b2 = b2 |\\<inter>| b1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b1 |\\<inter>| b2 = b2 |\\<inter>| b1", "by (simp add: inf_commute intersection_number_def)"], ["", "definition n_intersect_number :: \"'a set \\<Rightarrow> nat\\<Rightarrow> 'a set \\<Rightarrow> int\" where\n\"n_intersect_number b1 n b2 \\<equiv> card { x \\<in> Pow (b1 \\<inter> b2) . card x = n}\""], ["", "notation n_intersect_number (\"(_ |\\<inter>|\\<^sub>_ _)\" [52, 51, 52] 50)"], ["", "lemma n_intersect_num_subset_def: \"b1 |\\<inter>|\\<^sub>n b2 = card {x . x \\<subseteq> b1 \\<inter> b2 \\<and> card x = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b1 |\\<inter>|\\<^sub>n b2) =\n    int (card {x. x \\<subseteq> b1 \\<inter> b2 \\<and> card x = n})", "using n_intersect_number_def"], ["proof (prove)\nusing this:\n  ?b1.0 |\\<inter>|\\<^sub>?n ?b2.0 \\<equiv>\n  int (card {x \\<in> Pow (?b1.0 \\<inter> ?b2.0). card x = ?n})\n\ngoal (1 subgoal):\n 1. (b1 |\\<inter>|\\<^sub>n b2) =\n    int (card {x. x \\<subseteq> b1 \\<inter> b2 \\<and> card x = n})", "by auto"], ["", "lemma n_inter_num_one: \"finite b1 \\<Longrightarrow> finite b2 \\<Longrightarrow> b1 |\\<inter>|\\<^sub>1 b2 = b1 |\\<inter>| b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite b1; finite b2\\<rbrakk>\n    \\<Longrightarrow> (b1 |\\<inter>|\\<^sub>1 b2) = b1 |\\<inter>| b2", "using n_intersect_number_def intersection_number_def card_Pow_filter_one"], ["proof (prove)\nusing this:\n  ?b1.0 |\\<inter>|\\<^sub>?n ?b2.0 \\<equiv>\n  int (card {x \\<in> Pow (?b1.0 \\<inter> ?b2.0). card x = ?n})\n  ?b1.0 |\\<inter>| ?b2.0 \\<equiv> int (card (?b1.0 \\<inter> ?b2.0))\n  finite ?A \\<Longrightarrow> card {x \\<in> Pow ?A. card x = 1} = card ?A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite b1; finite b2\\<rbrakk>\n    \\<Longrightarrow> (b1 |\\<inter>|\\<^sub>1 b2) = b1 |\\<inter>| b2", "by (metis (full_types) finite_Int)"], ["", "lemma n_inter_num_choose: \"finite b1 \\<Longrightarrow> finite b2 \\<Longrightarrow> b1 |\\<inter>|\\<^sub>n b2 = (card (b1 \\<inter> b2) choose n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite b1; finite b2\\<rbrakk>\n    \\<Longrightarrow> (b1 |\\<inter>|\\<^sub>n b2) =\n                      int (card (b1 \\<inter> b2) choose n)", "using n_subsets n_intersect_num_subset_def"], ["proof (prove)\nusing this:\n  finite ?A \\<Longrightarrow>\n  card {B. B \\<subseteq> ?A \\<and> card B = ?k} = card ?A choose ?k\n  (?b1.0 |\\<inter>|\\<^sub>?n ?b2.0) =\n  int (card {x. x \\<subseteq> ?b1.0 \\<inter> ?b2.0 \\<and> card x = ?n})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite b1; finite b2\\<rbrakk>\n    \\<Longrightarrow> (b1 |\\<inter>|\\<^sub>n b2) =\n                      int (card (b1 \\<inter> b2) choose n)", "by (metis (full_types) finite_Int)"], ["", "lemma set_filter_single: \"x \\<in> A \\<Longrightarrow> {a \\<in> A . a = x} = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow> {a \\<in> A. a = x} = {x}", "by auto"], ["", "lemma (in design) n_inter_num_zero: \n  assumes \"b1 \\<in># \\<B>\" and \"b2 \\<in># \\<B>\"\n  shows \"b1 |\\<inter>|\\<^sub>0 b2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b1 |\\<inter>|\\<^sub>0 b2) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (b1 |\\<inter>|\\<^sub>0 b2) = 1", "have empty: \"\\<And>x . finite x \\<Longrightarrow> card x = 0 \\<Longrightarrow> x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>finite x; card x = 0\\<rbrakk> \\<Longrightarrow> x = {}", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?x; card ?x = 0\\<rbrakk> \\<Longrightarrow> ?x = {}\n\ngoal (1 subgoal):\n 1. (b1 |\\<inter>|\\<^sub>0 b2) = 1", "have empt_in: \"{} \\<in> Pow (b1 \\<inter> b2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<in> Pow (b1 \\<inter> b2)", "by simp"], ["proof (state)\nthis:\n  {} \\<in> Pow (b1 \\<inter> b2)\n\ngoal (1 subgoal):\n 1. (b1 |\\<inter>|\\<^sub>0 b2) = 1", "have \"finite (b1 \\<inter> b2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (b1 \\<inter> b2)", "using finite_blocks assms"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n  b1 \\<in># \\<B>\n  b2 \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. finite (b1 \\<inter> b2)", "by simp"], ["proof (state)\nthis:\n  finite (b1 \\<inter> b2)\n\ngoal (1 subgoal):\n 1. (b1 |\\<inter>|\\<^sub>0 b2) = 1", "then"], ["proof (chain)\npicking this:\n  finite (b1 \\<inter> b2)", "have \"\\<And> x . x \\<in> Pow (b1 \\<inter> b2) \\<Longrightarrow> finite x\""], ["proof (prove)\nusing this:\n  finite (b1 \\<inter> b2)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow (b1 \\<inter> b2) \\<Longrightarrow> finite x", "by (meson PowD finite_subset)"], ["proof (state)\nthis:\n  ?x1 \\<in> Pow (b1 \\<inter> b2) \\<Longrightarrow> finite ?x1\n\ngoal (1 subgoal):\n 1. (b1 |\\<inter>|\\<^sub>0 b2) = 1", "then"], ["proof (chain)\npicking this:\n  ?x1 \\<in> Pow (b1 \\<inter> b2) \\<Longrightarrow> finite ?x1", "have \"{x \\<in> Pow (b1 \\<inter> b2) . card x = 0} = {x \\<in> Pow (b1 \\<inter> b2) . x = {}}\""], ["proof (prove)\nusing this:\n  ?x1 \\<in> Pow (b1 \\<inter> b2) \\<Longrightarrow> finite ?x1\n\ngoal (1 subgoal):\n 1. {x \\<in> Pow (b1 \\<inter> b2). card x = 0} =\n    {x \\<in> Pow (b1 \\<inter> b2). x = {}}", "using empty"], ["proof (prove)\nusing this:\n  ?x1 \\<in> Pow (b1 \\<inter> b2) \\<Longrightarrow> finite ?x1\n  \\<lbrakk>finite ?x; card ?x = 0\\<rbrakk> \\<Longrightarrow> ?x = {}\n\ngoal (1 subgoal):\n 1. {x \\<in> Pow (b1 \\<inter> b2). card x = 0} =\n    {x \\<in> Pow (b1 \\<inter> b2). x = {}}", "by (metis card.empty)"], ["proof (state)\nthis:\n  {x \\<in> Pow (b1 \\<inter> b2). card x = 0} =\n  {x \\<in> Pow (b1 \\<inter> b2). x = {}}\n\ngoal (1 subgoal):\n 1. (b1 |\\<inter>|\\<^sub>0 b2) = 1", "then"], ["proof (chain)\npicking this:\n  {x \\<in> Pow (b1 \\<inter> b2). card x = 0} =\n  {x \\<in> Pow (b1 \\<inter> b2). x = {}}", "have \"{x \\<in> Pow (b1 \\<inter> b2) . card x = 0} = {{}}\""], ["proof (prove)\nusing this:\n  {x \\<in> Pow (b1 \\<inter> b2). card x = 0} =\n  {x \\<in> Pow (b1 \\<inter> b2). x = {}}\n\ngoal (1 subgoal):\n 1. {x \\<in> Pow (b1 \\<inter> b2). card x = 0} = {{}}", "by (simp add: empt_in set_filter_single Collect_conv_if)"], ["proof (state)\nthis:\n  {x \\<in> Pow (b1 \\<inter> b2). card x = 0} = {{}}\n\ngoal (1 subgoal):\n 1. (b1 |\\<inter>|\\<^sub>0 b2) = 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  {x \\<in> Pow (b1 \\<inter> b2). card x = 0} = {{}}\n\ngoal (1 subgoal):\n 1. (b1 |\\<inter>|\\<^sub>0 b2) = 1", "by (simp add: n_intersect_number_def)"], ["proof (state)\nthis:\n  (b1 |\\<inter>|\\<^sub>0 b2) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in design) n_inter_num_choose_design: \"b1 \\<in># \\<B> \\<Longrightarrow> b2 \\<in># \\<B> \n    \\<Longrightarrow> b1 |\\<inter>|\\<^sub>n b2 = (card (b1 \\<inter> b2) choose n) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b1 \\<in># \\<B>; b2 \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> (b1 |\\<inter>|\\<^sub>n b2) =\n                      int (card (b1 \\<inter> b2) choose n)", "using finite_blocks"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b1 \\<in># \\<B>; b2 \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> (b1 |\\<inter>|\\<^sub>n b2) =\n                      int (card (b1 \\<inter> b2) choose n)", "by (simp add: n_inter_num_choose)"], ["", "lemma (in design) n_inter_num_choose_design_inter: \"b1 \\<in># \\<B> \\<Longrightarrow> b2 \\<in># \\<B> \n    \\<Longrightarrow> b1 |\\<inter>|\\<^sub>n b2 = (nat (b1 |\\<inter>| b2) choose n) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b1 \\<in># \\<B>; b2 \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> (b1 |\\<inter>|\\<^sub>n b2) =\n                      int (nat (b1 |\\<inter>| b2) choose n)", "using finite_blocks"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b1 \\<in># \\<B>; b2 \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> (b1 |\\<inter>|\\<^sub>n b2) =\n                      int (nat (b1 |\\<inter>| b2) choose n)", "by (simp add: n_inter_num_choose intersection_number_def)"], ["", "subsection \\<open>Incidence System Set Property Definitions\\<close>"], ["", "context incidence_system\nbegin"], ["", "text \\<open>The set of replication numbers for all points of design\\<close>"], ["", "definition replication_numbers :: \"int set\" where\n\"replication_numbers \\<equiv> {\\<B> rep x | x . x \\<in> \\<V>}\""], ["", "lemma replication_numbers_non_empty: \n  assumes \"\\<V> \\<noteq> {}\"\n  shows \"replication_numbers \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replication_numbers \\<noteq> {}", "by (simp add: assms replication_numbers_def)"], ["", "lemma obtain_point_with_rep: \"r \\<in> replication_numbers \\<Longrightarrow> \\<exists> x. x \\<in> \\<V> \\<and> \\<B> rep x = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> replication_numbers \\<Longrightarrow>\n    \\<exists>x. x \\<in> \\<V> \\<and> \\<B> rep x = r", "using replication_numbers_def"], ["proof (prove)\nusing this:\n  replication_numbers \\<equiv> {\\<B> rep x |x. x \\<in> \\<V>}\n\ngoal (1 subgoal):\n 1. r \\<in> replication_numbers \\<Longrightarrow>\n    \\<exists>x. x \\<in> \\<V> \\<and> \\<B> rep x = r", "by auto"], ["", "lemma point_rep_number_in_set: \"x \\<in> \\<V> \\<Longrightarrow> (\\<B> rep x) \\<in> replication_numbers\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<V> \\<Longrightarrow> \\<B> rep x \\<in> replication_numbers", "by (auto simp add: replication_numbers_def)"], ["", "lemma (in finite_incidence_system) replication_numbers_finite: \"finite replication_numbers\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite replication_numbers", "using finite_sets"], ["proof (prove)\nusing this:\n  finite \\<V>\n\ngoal (1 subgoal):\n 1. finite replication_numbers", "by (simp add: replication_numbers_def)"], ["", "text \\<open>The set of all block sizes in a system\\<close>"], ["", "definition sys_block_sizes :: \"int set\" where\n\"sys_block_sizes \\<equiv> { (int (card bl)) | bl. bl \\<in># \\<B>}\""], ["", "lemma block_sizes_non_empty_set: \n  assumes \"\\<B> \\<noteq> {#}\"\n  shows \"sys_block_sizes \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_block_sizes \\<noteq> {}", "by (simp add: sys_block_sizes_def assms)"], ["", "lemma finite_block_sizes: \"finite (sys_block_sizes)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite sys_block_sizes", "by (simp add: sys_block_sizes_def)"], ["", "lemma block_sizes_non_empty: \n  assumes \"\\<B> \\<noteq> {#}\"\n  shows \"card (sys_block_sizes) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card sys_block_sizes", "using finite_block_sizes block_sizes_non_empty_set"], ["proof (prove)\nusing this:\n  finite sys_block_sizes\n  \\<B> \\<noteq> {#} \\<Longrightarrow> sys_block_sizes \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < card sys_block_sizes", "by (simp add: assms card_gt_0_iff)"], ["", "lemma sys_block_sizes_in: \"bl \\<in># \\<B> \\<Longrightarrow> card bl \\<in> sys_block_sizes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> int (card bl) \\<in> sys_block_sizes", "unfolding sys_block_sizes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow>\n    int (card bl) \\<in> {int (card bl) |bl. bl \\<in># \\<B>}", "by auto"], ["", "lemma sys_block_sizes_obtain_bl: \"x \\<in> sys_block_sizes  \\<Longrightarrow> (\\<exists> bl \\<in># \\<B>. int (card bl) = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> sys_block_sizes \\<Longrightarrow>\n    \\<exists>bl\\<in>#\\<B>. int (card bl) = x", "by (auto simp add: sys_block_sizes_def)"], ["", "text \\<open>The set of all possible intersection numbers in a system.\\<close>"], ["", "definition intersection_numbers :: \"int set\" where\n\"intersection_numbers \\<equiv> { b1 |\\<inter>| b2 | b1 b2 . b1 \\<in># \\<B> \\<and> b2 \\<in># (\\<B> - {#b1#})}\""], ["", "lemma obtain_blocks_intersect_num: \"n \\<in> intersection_numbers \\<Longrightarrow> \n  \\<exists> b1 b2. b1 \\<in># \\<B> \\<and> b2 \\<in># (\\<B> - {#b1#}) \\<and>  b1 |\\<inter>| b2 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> intersection_numbers \\<Longrightarrow>\n    \\<exists>b1 b2.\n       b1 \\<in># \\<B> \\<and>\n       b2 \\<in># remove1_mset b1 \\<B> \\<and> b1 |\\<inter>| b2 = n", "by (auto simp add: intersection_numbers_def)"], ["", "lemma intersect_num_in_set: \"b1 \\<in># \\<B> \\<Longrightarrow> b2 \\<in># (\\<B> - {#b1#}) \\<Longrightarrow> b1 |\\<inter>| b2 \\<in> intersection_numbers\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b1 \\<in># \\<B>; b2 \\<in># remove1_mset b1 \\<B>\\<rbrakk>\n    \\<Longrightarrow> b1 |\\<inter>| b2 \\<in> intersection_numbers", "by (auto simp add: intersection_numbers_def)"], ["", "text \\<open>The set of all possible point indices\\<close>"], ["", "definition point_indices :: \"int \\<Rightarrow> int set\" where\n\"point_indices t \\<equiv> {\\<B> index ps | ps. int (card ps) = t \\<and> ps \\<subseteq> \\<V>}\""], ["", "lemma point_indices_elem_in: \"ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = t \\<Longrightarrow> \\<B> index ps \\<in> point_indices t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps \\<subseteq> \\<V>; card ps = t\\<rbrakk>\n    \\<Longrightarrow> int (\\<B> index ps) \\<in> point_indices (int t)", "by (auto simp add: point_indices_def)"], ["", "lemma point_indices_alt_def: \"point_indices t = { \\<B> index ps | ps. int (card ps) = t \\<and> ps \\<subseteq> \\<V>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point_indices t =\n    {int (\\<B> index ps) |ps. int (card ps) = t \\<and> ps \\<subseteq> \\<V>}", "by (simp add: point_indices_def)"], ["", "end"], ["", "subsection \\<open>Basic Constructions on designs\\<close>"], ["", "text \\<open>This section defines some of the most common universal constructions found in design theory\ninvolving only a single design\\<close>"], ["", "subsubsection \\<open>Design Complements\\<close>"], ["", "context incidence_system\nbegin"], ["", "text \\<open>The complement of a block are all the points in the design not in that block. \nThe complement of a design is therefore the original point sets, and set of all block complements\\<close>"], ["", "definition block_complement:: \"'a set \\<Rightarrow> 'a set\" (\"_\\<^sup>c\" [56] 55) where\n\"block_complement b \\<equiv> \\<V> - b\""], ["", "definition complement_blocks :: \"'a set multiset\" (\"(\\<B>\\<^sup>C)\")where\n\"complement_blocks \\<equiv> {# bl\\<^sup>c . bl \\<in># \\<B> #}\""], ["", "lemma block_complement_elem_iff: \n  assumes \"ps \\<subseteq> \\<V>\"\n  shows \"ps \\<subseteq> bl\\<^sup>c \\<longleftrightarrow> (\\<forall> x \\<in> ps. x \\<notin> bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<subseteq> bl\\<^sup>c) = (\\<forall>x\\<in>ps. x \\<notin> bl)", "using assms block_complement_def"], ["proof (prove)\nusing this:\n  ps \\<subseteq> \\<V>\n  ?b\\<^sup>c \\<equiv> \\<V> - ?b\n\ngoal (1 subgoal):\n 1. (ps \\<subseteq> bl\\<^sup>c) = (\\<forall>x\\<in>ps. x \\<notin> bl)", "by (auto)"], ["", "lemma block_complement_inter_empty: \"bl1\\<^sup>c = bl2 \\<Longrightarrow> bl1 \\<inter> bl2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl1\\<^sup>c = bl2 \\<Longrightarrow> bl1 \\<inter> bl2 = {}", "using block_complement_def"], ["proof (prove)\nusing this:\n  ?b\\<^sup>c \\<equiv> \\<V> - ?b\n\ngoal (1 subgoal):\n 1. bl1\\<^sup>c = bl2 \\<Longrightarrow> bl1 \\<inter> bl2 = {}", "by auto"], ["", "lemma block_complement_inv: \n  assumes \"bl \\<in># \\<B>\"\n  assumes \"bl\\<^sup>c = bl2\"\n  shows \"bl2\\<^sup>c = bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2\\<^sup>c = bl", "by (metis Diff_Diff_Int assms(1) assms(2) block_complement_def inf.absorb_iff2 wellformed)"], ["", "lemma block_complement_subset_points: \"ps \\<subseteq> (bl\\<^sup>c) \\<Longrightarrow> ps \\<subseteq> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<subseteq> bl\\<^sup>c \\<Longrightarrow> ps \\<subseteq> \\<V>", "using block_complement_def"], ["proof (prove)\nusing this:\n  ?b\\<^sup>c \\<equiv> \\<V> - ?b\n\ngoal (1 subgoal):\n 1. ps \\<subseteq> bl\\<^sup>c \\<Longrightarrow> ps \\<subseteq> \\<V>", "by blast"], ["", "lemma obtain_comp_block_orig: \n  assumes \"bl1 \\<in># \\<B>\\<^sup>C\"\n  obtains bl2 where \"bl2 \\<in># \\<B>\" and \"bl1 = bl2\\<^sup>c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>bl2 \\<in># \\<B>; bl1 = bl2\\<^sup>c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using wellformed assms"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n  bl1 \\<in># \\<B>\\<^sup>C\n\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>bl2 \\<in># \\<B>; bl1 = bl2\\<^sup>c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: complement_blocks_def)"], ["", "lemma complement_same_b [simp]: \"size \\<B>\\<^sup>C = size \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size \\<B>\\<^sup>C = size \\<B>", "by (simp add: complement_blocks_def)"], ["", "lemma block_comp_elem_alt_left: \"x \\<in> bl \\<Longrightarrow> ps \\<subseteq> bl\\<^sup>c \\<Longrightarrow> x \\<notin> ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> bl; ps \\<subseteq> bl\\<^sup>c\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> ps", "by (auto simp add: block_complement_def block_complement_elem_iff)"], ["", "lemma block_comp_elem_alt_right: \"ps \\<subseteq> \\<V> \\<Longrightarrow> (\\<And> x . x \\<in> ps \\<Longrightarrow> x \\<notin> bl) \\<Longrightarrow> ps \\<subseteq> bl\\<^sup>c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps \\<subseteq> \\<V>;\n     \\<And>x. x \\<in> ps \\<Longrightarrow> x \\<notin> bl\\<rbrakk>\n    \\<Longrightarrow> ps \\<subseteq> bl\\<^sup>c", "by (auto simp add: block_complement_elem_iff)"], ["", "lemma complement_index:\n  assumes \"ps \\<subseteq> \\<V>\"\n  shows \"\\<B>\\<^sup>C index ps = size {# b \\<in># \\<B> . (\\<forall> x \\<in> ps . x \\<notin> b) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index ps =\n    size {#b \\<in># \\<B>. \\<forall>x\\<in>ps. x \\<notin> b#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index ps =\n    size {#b \\<in># \\<B>. \\<forall>x\\<in>ps. x \\<notin> b#}", "have \"\\<B>\\<^sup>C index ps =  size {# b \\<in># {# bl\\<^sup>c . bl \\<in># \\<B>#}. ps \\<subseteq> b #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index ps =\n    size (filter_mset ((\\<subseteq>) ps) (image_mset block_complement \\<B>))", "by (simp add: complement_blocks_def points_index_def)"], ["proof (state)\nthis:\n  \\<B>\\<^sup>C index ps =\n  size (filter_mset ((\\<subseteq>) ps) (image_mset block_complement \\<B>))\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index ps =\n    size {#b \\<in># \\<B>. \\<forall>x\\<in>ps. x \\<notin> b#}", "then"], ["proof (chain)\npicking this:\n  \\<B>\\<^sup>C index ps =\n  size (filter_mset ((\\<subseteq>) ps) (image_mset block_complement \\<B>))", "have \"\\<B>\\<^sup>C index ps = size {# bl\\<^sup>c | bl \\<in># \\<B> . ps \\<subseteq> bl\\<^sup>c #}\""], ["proof (prove)\nusing this:\n  \\<B>\\<^sup>C index ps =\n  size (filter_mset ((\\<subseteq>) ps) (image_mset block_complement \\<B>))\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index ps =\n    size\n     (image_mset block_complement\n       {#bl \\<in># \\<B>. ps \\<subseteq> bl\\<^sup>c#})", "by (metis image_mset_filter_swap)"], ["proof (state)\nthis:\n  \\<B>\\<^sup>C index ps =\n  size\n   (image_mset block_complement\n     {#bl \\<in># \\<B>. ps \\<subseteq> bl\\<^sup>c#})\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index ps =\n    size {#b \\<in># \\<B>. \\<forall>x\\<in>ps. x \\<notin> b#}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<B>\\<^sup>C index ps =\n  size\n   (image_mset block_complement\n     {#bl \\<in># \\<B>. ps \\<subseteq> bl\\<^sup>c#})\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index ps =\n    size {#b \\<in># \\<B>. \\<forall>x\\<in>ps. x \\<notin> b#}", "using assms"], ["proof (prove)\nusing this:\n  \\<B>\\<^sup>C index ps =\n  size\n   (image_mset block_complement\n     {#bl \\<in># \\<B>. ps \\<subseteq> bl\\<^sup>c#})\n  ps \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index ps =\n    size {#b \\<in># \\<B>. \\<forall>x\\<in>ps. x \\<notin> b#}", "by (simp add: block_complement_elem_iff)"], ["proof (state)\nthis:\n  \\<B>\\<^sup>C index ps =\n  size {#b \\<in># \\<B>. \\<forall>x\\<in>ps. x \\<notin> b#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complement_index_2:\n  assumes \"{x, y} \\<subseteq> \\<V>\"\n  shows \"\\<B>\\<^sup>C index {x, y} = size {# b \\<in># \\<B> . x \\<notin> b \\<and> y \\<notin> b #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index {x, y} =\n    size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index {x, y} =\n    size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#}", "have a: \"\\<And> b. b \\<in># \\<B> \\<Longrightarrow> \\<forall> x' \\<in> {x, y} . x' \\<notin> b \\<Longrightarrow> x \\<notin> b \\<and> y \\<notin> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in># \\<B>;\n        \\<forall>x'\\<in>{x, y}. x' \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> b \\<and> y \\<notin> b", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<in># \\<B>; \\<forall>x'\\<in>{x, y}. x' \\<notin> ?b\\<rbrakk>\n  \\<Longrightarrow> x \\<notin> ?b \\<and> y \\<notin> ?b\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index {x, y} =\n    size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#}", "have \"\\<And> b. b \\<in># \\<B> \\<Longrightarrow> x \\<notin> b \\<and> y \\<notin> b \\<Longrightarrow> \\<forall> x' \\<in> {x, y} . x' \\<notin> b \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in># \\<B>; x \\<notin> b \\<and> y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x'\\<in>{x, y}. x' \\<notin> b", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<in># \\<B>; x \\<notin> ?b \\<and> y \\<notin> ?b\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x'\\<in>{x, y}. x' \\<notin> ?b\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index {x, y} =\n    size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<in># \\<B>; x \\<notin> ?b \\<and> y \\<notin> ?b\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x'\\<in>{x, y}. x' \\<notin> ?b\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index {x, y} =\n    size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#}", "using assms a complement_index"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<in># \\<B>; x \\<notin> ?b \\<and> y \\<notin> ?b\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x'\\<in>{x, y}. x' \\<notin> ?b\n  {x, y} \\<subseteq> \\<V>\n  \\<lbrakk>?b \\<in># \\<B>; \\<forall>x'\\<in>{x, y}. x' \\<notin> ?b\\<rbrakk>\n  \\<Longrightarrow> x \\<notin> ?b \\<and> y \\<notin> ?b\n  ?ps \\<subseteq> \\<V> \\<Longrightarrow>\n  \\<B>\\<^sup>C index ?ps =\n  size {#b \\<in># \\<B>. \\<forall>x\\<in>?ps. x \\<notin> b#}\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index {x, y} =\n    size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#}", "by (smt (verit) filter_mset_cong)"], ["proof (state)\nthis:\n  \\<B>\\<^sup>C index {x, y} =\n  size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complement_rep_number: \n  assumes \"x \\<in> \\<V>\" and \"\\<B> rep x = r\" \n  shows  \"\\<B>\\<^sup>C rep x = \\<b> - r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C rep x = \\<b> - r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C rep x = \\<b> - r", "have r: \"size {#b \\<in># \\<B> . x \\<in> b#} = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<in>) x) \\<B>)) = r", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> \\<V>\n  \\<B> rep x = r\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<in>) x) \\<B>)) = r", "by (simp add: point_replication_number_def)"], ["proof (state)\nthis:\n  int (size (filter_mset ((\\<in>) x) \\<B>)) = r\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C rep x = \\<b> - r", "then"], ["proof (chain)\npicking this:\n  int (size (filter_mset ((\\<in>) x) \\<B>)) = r", "have a: \"\\<And> b . b \\<in># \\<B> \\<Longrightarrow> x \\<in> b \\<Longrightarrow> x \\<notin> b\\<^sup>c\""], ["proof (prove)\nusing this:\n  int (size (filter_mset ((\\<in>) x) \\<B>)) = r\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in># \\<B>; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> b\\<^sup>c", "by (simp add: block_complement_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<in># \\<B>; x \\<in> ?b\\<rbrakk>\n  \\<Longrightarrow> x \\<notin> ?b\\<^sup>c\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C rep x = \\<b> - r", "have \"\\<And> b . b \\<in># \\<B> \\<Longrightarrow> x \\<notin> b \\<Longrightarrow> x \\<in> b\\<^sup>c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in># \\<B>; x \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b\\<^sup>c", "by (simp add: assms(1) block_complement_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<in># \\<B>; x \\<notin> ?b\\<rbrakk>\n  \\<Longrightarrow> x \\<in> ?b\\<^sup>c\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C rep x = \\<b> - r", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?b \\<in># \\<B>; x \\<notin> ?b\\<rbrakk>\n  \\<Longrightarrow> x \\<in> ?b\\<^sup>c", "have alt: \"(image_mset block_complement \\<B>) rep x = size {#b \\<in># \\<B> . x \\<notin> b#}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<in># \\<B>; x \\<notin> ?b\\<rbrakk>\n  \\<Longrightarrow> x \\<in> ?b\\<^sup>c\n\ngoal (1 subgoal):\n 1. image_mset block_complement \\<B> rep x =\n    int (size (filter_mset ((\\<notin>) x) \\<B>))", "using a filter_mset_cong image_mset_filter_swap2 point_replication_number_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<in># \\<B>; x \\<notin> ?b\\<rbrakk>\n  \\<Longrightarrow> x \\<in> ?b\\<^sup>c\n  \\<lbrakk>?b \\<in># \\<B>; x \\<in> ?b\\<rbrakk>\n  \\<Longrightarrow> x \\<notin> ?b\\<^sup>c\n  \\<lbrakk>?M = ?M';\n   \\<And>a. a \\<in># ?M \\<Longrightarrow> ?P a = ?Q a\\<rbrakk>\n  \\<Longrightarrow> filter_mset ?P ?M = filter_mset ?Q ?M\n  filter_mset ?Q (image_mset ?P ?D) =\n  image_mset ?P {#C. C \\<in># {#C \\<in># ?D. ?Q (?P C)#}#}\n  ?B rep ?x \\<equiv> int (size (filter_mset ((\\<in>) ?x) ?B))\n\ngoal (1 subgoal):\n 1. image_mset block_complement \\<B> rep x =\n    int (size (filter_mset ((\\<notin>) x) \\<B>))", "by (smt (verit, ccfv_SIG) size_image_mset)"], ["proof (state)\nthis:\n  image_mset block_complement \\<B> rep x =\n  int (size (filter_mset ((\\<notin>) x) \\<B>))\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C rep x = \\<b> - r", "have \"\\<b> = size {#b \\<in># \\<B> . x \\<in> b#} + size {#b \\<in># \\<B> . x \\<notin> b#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> =\n    int (size (filter_mset ((\\<in>) x) \\<B>) +\n         size (filter_mset ((\\<notin>) x) \\<B>))", "by (metis multiset_partition size_union)"], ["proof (state)\nthis:\n  \\<b> =\n  int (size (filter_mset ((\\<in>) x) \\<B>) +\n       size (filter_mset ((\\<notin>) x) \\<B>))\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C rep x = \\<b> - r", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<b> =\n  int (size (filter_mset ((\\<in>) x) \\<B>) +\n       size (filter_mset ((\\<notin>) x) \\<B>))\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C rep x = \\<b> - r", "using alt"], ["proof (prove)\nusing this:\n  \\<b> =\n  int (size (filter_mset ((\\<in>) x) \\<B>) +\n       size (filter_mset ((\\<notin>) x) \\<B>))\n  image_mset block_complement \\<B> rep x =\n  int (size (filter_mset ((\\<notin>) x) \\<B>))\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C rep x = \\<b> - r", "by (simp add: r complement_blocks_def)"], ["proof (state)\nthis:\n  \\<B>\\<^sup>C rep x = \\<b> - r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complement_blocks_wf: \"bl \\<in># \\<B>\\<^sup>C \\<Longrightarrow> bl \\<subseteq> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B>\\<^sup>C \\<Longrightarrow> bl \\<subseteq> \\<V>", "by (auto simp add: complement_blocks_def block_complement_def)"], ["", "lemma complement_wf [intro]: \"incidence_system \\<V> \\<B>\\<^sup>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system \\<V> \\<B>\\<^sup>C", "using complement_blocks_wf"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B>\\<^sup>C \\<Longrightarrow> ?bl \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. incidence_system \\<V> \\<B>\\<^sup>C", "by (unfold_locales)"], ["", "interpretation sys_complement: incidence_system \"\\<V>\" \"\\<B>\\<^sup>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system \\<V> \\<B>\\<^sup>C", "using complement_wf"], ["proof (prove)\nusing this:\n  incidence_system \\<V> \\<B>\\<^sup>C\n\ngoal (1 subgoal):\n 1. incidence_system \\<V> \\<B>\\<^sup>C", "by simp"], ["", "end"], ["", "context finite_incidence_system\nbegin"], ["", "lemma block_complement_size: \"b \\<subseteq> \\<V> \\<Longrightarrow> card (b\\<^sup>c) = card \\<V> - card b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<subseteq> \\<V> \\<Longrightarrow>\n    card (b\\<^sup>c) = card \\<V> - card b", "by (simp add: block_complement_def card_Diff_subset finite_subset card_mono of_nat_diff finite_sets)"], ["", "lemma block_comp_incomplete: \"incomplete_block bl \\<Longrightarrow> card (bl\\<^sup>c) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incomplete_block bl \\<Longrightarrow> 0 < card (bl\\<^sup>c)", "using block_complement_size"], ["proof (prove)\nusing this:\n  ?b \\<subseteq> \\<V> \\<Longrightarrow>\n  card (?b\\<^sup>c) = card \\<V> - card ?b\n\ngoal (1 subgoal):\n 1. incomplete_block bl \\<Longrightarrow> 0 < card (bl\\<^sup>c)", "by (simp add: wellformed)"], ["", "lemma  block_comp_incomplete_nempty: \"incomplete_block bl \\<Longrightarrow> bl\\<^sup>c \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incomplete_block bl \\<Longrightarrow> bl\\<^sup>c \\<noteq> {}", "using wellformed block_complement_def finite_blocks"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n  ?b\\<^sup>c \\<equiv> \\<V> - ?b\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n\ngoal (1 subgoal):\n 1. incomplete_block bl \\<Longrightarrow> bl\\<^sup>c \\<noteq> {}", "by (auto simp add: block_complement_size block_comp_incomplete card_subset_not_gt_card)"], ["", "lemma incomplete_block_proper_subset: \"incomplete_block bl \\<Longrightarrow> bl \\<subset> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incomplete_block bl \\<Longrightarrow> bl \\<subset> \\<V>", "using wellformed"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. incomplete_block bl \\<Longrightarrow> bl \\<subset> \\<V>", "by fastforce"], ["", "lemma complement_finite: \"finite_incidence_system \\<V> \\<B>\\<^sup>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> \\<B>\\<^sup>C", "using complement_wf finite_sets"], ["proof (prove)\nusing this:\n  incidence_system \\<V> \\<B>\\<^sup>C\n  finite \\<V>\n\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> \\<B>\\<^sup>C", "by (simp add: incidence_system.finite_sysI)"], ["", "interpretation comp_fin: finite_incidence_system \\<V> \"\\<B>\\<^sup>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> \\<B>\\<^sup>C", "using complement_finite"], ["proof (prove)\nusing this:\n  finite_incidence_system \\<V> \\<B>\\<^sup>C\n\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> \\<B>\\<^sup>C", "by simp"], ["", "end"], ["", "context design\nbegin"], ["", "lemma (in design) complement_design: \n  assumes \"\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\" \n  shows \"design \\<V> (\\<B>\\<^sup>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design \\<V> \\<B>\\<^sup>C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. design \\<V> \\<B>\\<^sup>C", "interpret fin: finite_incidence_system \\<V> \"\\<B>\\<^sup>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> \\<B>\\<^sup>C", "using complement_finite"], ["proof (prove)\nusing this:\n  finite_incidence_system \\<V> \\<B>\\<^sup>C\n\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> \\<B>\\<^sup>C", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. design \\<V> \\<B>\\<^sup>C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. design \\<V> \\<B>\\<^sup>C", "using assms block_comp_incomplete_nempty wellformed"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> incomplete_block ?bl\n  incomplete_block ?bl \\<Longrightarrow> ?bl\\<^sup>c \\<noteq> {}\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. design \\<V> \\<B>\\<^sup>C", "by (unfold_locales) (auto simp add: complement_blocks_def)"], ["proof (state)\nthis:\n  design \\<V> \\<B>\\<^sup>C\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Multiples\\<close>"], ["", "text \\<open>An easy way to construct new set systems is to simply multiply the block collection by some \nconstant\\<close>"], ["", "context incidence_system \nbegin"], ["", "abbreviation multiple_blocks :: \"nat \\<Rightarrow> 'a set multiset\" where\n\"multiple_blocks n \\<equiv> repeat_mset n \\<B>\""], ["", "lemma multiple_block_in_original: \"b \\<in># multiple_blocks n \\<Longrightarrow> b \\<in># \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in># multiple_blocks n \\<Longrightarrow> b \\<in># \\<B>", "by (simp add: elem_in_repeat_in_original)"], ["", "lemma multiple_block_in: \"n > 0 \\<Longrightarrow> b \\<in># \\<B> \\<Longrightarrow>  b \\<in># multiple_blocks n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; b \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> b \\<in># multiple_blocks n", "by (simp add: elem_in_original_in_repeat)"], ["", "lemma multiple_blocks_gt: \"n > 0 \\<Longrightarrow> size (multiple_blocks n) \\<ge> size \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> size \\<B> \\<le> size (multiple_blocks n)", "by (simp)"], ["", "lemma block_original_count_le: \"n > 0 \\<Longrightarrow> count \\<B> b \\<le> count (multiple_blocks n) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> multiplicity b \\<le> count (multiple_blocks n) b", "using count_repeat_mset"], ["proof (prove)\nusing this:\n  count (repeat_mset ?i ?A) ?a = ?i * count ?A ?a\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> multiplicity b \\<le> count (multiple_blocks n) b", "by simp"], ["", "lemma multiple_blocks_sub: \"n > 0 \\<Longrightarrow> \\<B> \\<subseteq># (multiple_blocks n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> \\<B> \\<subseteq># multiple_blocks n", "by (simp add: mset_subset_eqI block_original_count_le)"], ["", "lemma multiple_1_same: \"multiple_blocks 1 = \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiple_blocks 1 = \\<B>", "by simp"], ["", "lemma multiple_unfold_1: \"multiple_blocks (Suc n) = (multiple_blocks n) + \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiple_blocks (Suc n) = multiple_blocks n + \\<B>", "by simp"], ["", "lemma multiple_point_rep_num: \"(multiple_blocks n) rep x = (\\<B> rep x) * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiple_blocks n rep x = \\<B> rep x * int n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. multiple_blocks 0 rep x = \\<B> rep x * int 0\n 2. \\<And>n.\n       multiple_blocks n rep x = \\<B> rep x * int n \\<Longrightarrow>\n       multiple_blocks (Suc n) rep x = \\<B> rep x * int (Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. multiple_blocks 0 rep x = \\<B> rep x * int 0\n 2. \\<And>n.\n       multiple_blocks n rep x = \\<B> rep x * int n \\<Longrightarrow>\n       multiple_blocks (Suc n) rep x = \\<B> rep x * int (Suc n)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. multiple_blocks 0 rep x = \\<B> rep x * int 0", "by (simp add: point_replication_number_def)"], ["proof (state)\nthis:\n  multiple_blocks 0 rep x = \\<B> rep x * int 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       multiple_blocks n rep x = \\<B> rep x * int n \\<Longrightarrow>\n       multiple_blocks (Suc n) rep x = \\<B> rep x * int (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       multiple_blocks n rep x = \\<B> rep x * int n \\<Longrightarrow>\n       multiple_blocks (Suc n) rep x = \\<B> rep x * int (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  multiple_blocks n rep x = \\<B> rep x * int n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       multiple_blocks n rep x = \\<B> rep x * int n \\<Longrightarrow>\n       multiple_blocks (Suc n) rep x = \\<B> rep x * int (Suc n)", "then"], ["proof (chain)\npicking this:\n  multiple_blocks n rep x = \\<B> rep x * int n", "have \"multiple_blocks (Suc n) rep x = \\<B> rep x * n + (\\<B> rep x)\""], ["proof (prove)\nusing this:\n  multiple_blocks n rep x = \\<B> rep x * int n\n\ngoal (1 subgoal):\n 1. multiple_blocks (Suc n) rep x = \\<B> rep x * int n + \\<B> rep x", "using Suc.IH Suc.prems"], ["proof (prove)\nusing this:\n  multiple_blocks n rep x = \\<B> rep x * int n\n  multiple_blocks n rep x = \\<B> rep x * int n\n\ngoal (1 subgoal):\n 1. multiple_blocks (Suc n) rep x = \\<B> rep x * int n + \\<B> rep x", "by (simp add: union_commute point_replication_number_def)"], ["proof (state)\nthis:\n  multiple_blocks (Suc n) rep x = \\<B> rep x * int n + \\<B> rep x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       multiple_blocks n rep x = \\<B> rep x * int n \\<Longrightarrow>\n       multiple_blocks (Suc n) rep x = \\<B> rep x * int (Suc n)", "then"], ["proof (chain)\npicking this:\n  multiple_blocks (Suc n) rep x = \\<B> rep x * int n + \\<B> rep x", "show ?case"], ["proof (prove)\nusing this:\n  multiple_blocks (Suc n) rep x = \\<B> rep x * int n + \\<B> rep x\n\ngoal (1 subgoal):\n 1. multiple_blocks (Suc n) rep x = \\<B> rep x * int (Suc n)", "by (simp add: int_distrib(2))"], ["proof (state)\nthis:\n  multiple_blocks (Suc n) rep x = \\<B> rep x * int (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multiple_point_index: \"(multiple_blocks n) index ps = (\\<B> index ps) * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiple_blocks n index ps = \\<B> index ps * n", "by (induction n) (auto simp add: points_index_def)"], ["", "lemma repeat_mset_block_point_rel: \"\\<And>b x. b \\<in># multiple_blocks  n \\<Longrightarrow> x \\<in> b \\<Longrightarrow> x \\<in> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b x.\n       \\<lbrakk>b \\<in># multiple_blocks n; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<V>", "by (induction n) (auto, meson subset_iff wellformed)"], ["", "lemma multiple_is_wellformed: \"incidence_system \\<V> (multiple_blocks n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system \\<V> (multiple_blocks n)", "using repeat_mset_subset_in wellformed repeat_mset_block_point_rel"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>a. a \\<in># ?A \\<Longrightarrow> a \\<subseteq> ?B;\n   ?X \\<in># repeat_mset ?n ?A; ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?B\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n  \\<lbrakk>?b \\<in># multiple_blocks ?n; ?x \\<in> ?b\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. incidence_system \\<V> (multiple_blocks n)", "by (unfold_locales) (auto)"], ["", "lemma  multiple_blocks_num [simp]: \"size (multiple_blocks n) = n*\\<b>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size (multiple_blocks n)) = int n * \\<b>", "by simp"], ["", "interpretation mult_sys: incidence_system \\<V> \"(multiple_blocks n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system \\<V> (multiple_blocks n)", "by (simp add: multiple_is_wellformed)"], ["", "lemma multiple_block_multiplicity [simp]: \"mult_sys.multiplicity n bl = (multiplicity bl) * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_sys.multiplicity n bl = multiplicity bl * n", "by (simp)"], ["", "lemma multiple_block_sizes_same: \n  assumes \"n > 0\" \n  shows \"sys_block_sizes = mult_sys.sys_block_sizes n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_block_sizes = mult_sys.sys_block_sizes n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sys_block_sizes = mult_sys.sys_block_sizes n", "have def: \"mult_sys.sys_block_sizes n = {card bl | bl. bl \\<in># (multiple_blocks n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_sys.sys_block_sizes n =\n    {int (card bl) |bl. bl \\<in># multiple_blocks n}", "by (simp add: mult_sys.sys_block_sizes_def)"], ["proof (state)\nthis:\n  mult_sys.sys_block_sizes n =\n  {int (card bl) |bl. bl \\<in># multiple_blocks n}\n\ngoal (1 subgoal):\n 1. sys_block_sizes = mult_sys.sys_block_sizes n", "then"], ["proof (chain)\npicking this:\n  mult_sys.sys_block_sizes n =\n  {int (card bl) |bl. bl \\<in># multiple_blocks n}", "have eq: \"\\<And> bl. bl \\<in># (multiple_blocks n) \\<longleftrightarrow> bl \\<in># \\<B>\""], ["proof (prove)\nusing this:\n  mult_sys.sys_block_sizes n =\n  {int (card bl) |bl. bl \\<in># multiple_blocks n}\n\ngoal (1 subgoal):\n 1. \\<And>bl. (bl \\<in># multiple_blocks n) = (bl \\<in># \\<B>)", "using assms multiple_block_in multiple_block_in_original"], ["proof (prove)\nusing this:\n  mult_sys.sys_block_sizes n =\n  {int (card bl) |bl. bl \\<in># multiple_blocks n}\n  0 < n\n  \\<lbrakk>0 < ?n; ?b \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in># multiple_blocks ?n\n  ?b \\<in># multiple_blocks ?n \\<Longrightarrow> ?b \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. \\<And>bl. (bl \\<in># multiple_blocks n) = (bl \\<in># \\<B>)", "by blast"], ["proof (state)\nthis:\n  (?bl \\<in># multiple_blocks n) = (?bl \\<in># \\<B>)\n\ngoal (1 subgoal):\n 1. sys_block_sizes = mult_sys.sys_block_sizes n", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?bl \\<in># multiple_blocks n) = (?bl \\<in># \\<B>)\n\ngoal (1 subgoal):\n 1. sys_block_sizes = mult_sys.sys_block_sizes n", "using def"], ["proof (prove)\nusing this:\n  (?bl \\<in># multiple_blocks n) = (?bl \\<in># \\<B>)\n  mult_sys.sys_block_sizes n =\n  {int (card bl) |bl. bl \\<in># multiple_blocks n}\n\ngoal (1 subgoal):\n 1. sys_block_sizes = mult_sys.sys_block_sizes n", "by (simp add: sys_block_sizes_def eq)"], ["proof (state)\nthis:\n  sys_block_sizes = mult_sys.sys_block_sizes n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context finite_incidence_system\nbegin"], ["", "lemma multiple_is_finite: \"finite_incidence_system \\<V> (multiple_blocks n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> (multiple_blocks n)", "using multiple_is_wellformed finite_sets"], ["proof (prove)\nusing this:\n  incidence_system \\<V> (multiple_blocks ?n)\n  finite \\<V>\n\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> (multiple_blocks n)", "by (unfold_locales) (auto simp add: incidence_system_def)"], ["", "end"], ["", "context design\nbegin"], ["", "lemma multiple_is_design: \"design \\<V> (multiple_blocks n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design \\<V> (multiple_blocks n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. design \\<V> (multiple_blocks n)", "interpret fis: finite_incidence_system \\<V> \"multiple_blocks n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> (multiple_blocks n)", "using multiple_is_finite"], ["proof (prove)\nusing this:\n  finite_incidence_system \\<V> (multiple_blocks ?n)\n\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> (multiple_blocks n)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. design \\<V> (multiple_blocks n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. design \\<V> (multiple_blocks n)", "using blocks_nempty"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {}\n\ngoal (1 subgoal):\n 1. design \\<V> (multiple_blocks n)", "by (unfold_locales) (auto simp add: elem_in_repeat_in_original repeat_mset_not_empty)"], ["proof (state)\nthis:\n  design \\<V> (multiple_blocks n)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Simple Designs\\<close>"], ["", "text \\<open>Simple designs are those in which the multiplicity of each block is at most one. \nIn other words, the block collection is a set. This can significantly ease reasoning.\\<close>"], ["", "locale simple_incidence_system = incidence_system + \n  assumes simple [simp]: \"bl \\<in># \\<B> \\<Longrightarrow> multiplicity bl = 1\"\n\nbegin"], ["", "lemma simple_alt_def_all: \"\\<forall> bl \\<in># \\<B> . multiplicity bl = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#\\<B>. multiplicity bl = 1", "using simple"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> multiplicity ?bl = 1\n\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#\\<B>. multiplicity bl = 1", "by auto"], ["", "lemma simple_blocks_eq_sup: \"mset_set (design_support) = \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_set design_support = \\<B>", "using distinct_mset_def simple design_support_def"], ["proof (prove)\nusing this:\n  distinct_mset ?S =\n  (\\<forall>a. a \\<in># ?S \\<longrightarrow> count ?S a = 1)\n  ?bl \\<in># \\<B> \\<Longrightarrow> multiplicity ?bl = 1\n  design_support \\<equiv> set_mset \\<B>\n\ngoal (1 subgoal):\n 1. mset_set design_support = \\<B>", "by (metis distinct_mset_set_mset_ident)"], ["", "lemma simple_block_size_eq_card: \"\\<b> = card (design_support)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> = int (card design_support)", "by (metis simple_blocks_eq_sup size_mset_set)"], ["", "lemma points_index_simple_def: \"\\<B> index ps = card {b \\<in> design_support . ps \\<subseteq> b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> index ps = card {b \\<in> design_support. ps \\<subseteq> b}", "using design_support_def points_index_def card_size_filter_eq simple_blocks_eq_sup"], ["proof (prove)\nusing this:\n  design_support \\<equiv> set_mset \\<B>\n  ?B index ?ps \\<equiv> size (filter_mset ((\\<subseteq>) ?ps) ?B)\n  finite ?A \\<Longrightarrow>\n  card {a \\<in> ?A. ?P a} = size (filter_mset ?P (mset_set ?A))\n  mset_set design_support = \\<B>\n\ngoal (1 subgoal):\n 1. \\<B> index ps = card {b \\<in> design_support. ps \\<subseteq> b}", "by (metis finite_set_mset)"], ["", "lemma replication_num_simple_def: \"\\<B> rep x = card {b \\<in> design_support . x \\<in> b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> rep x = int (card {b \\<in> design_support. x \\<in> b})", "using design_support_def point_replication_number_def card_size_filter_eq simple_blocks_eq_sup"], ["proof (prove)\nusing this:\n  design_support \\<equiv> set_mset \\<B>\n  ?B rep ?x \\<equiv> int (size (filter_mset ((\\<in>) ?x) ?B))\n  finite ?A \\<Longrightarrow>\n  card {a \\<in> ?A. ?P a} = size (filter_mset ?P (mset_set ?A))\n  mset_set design_support = \\<B>\n\ngoal (1 subgoal):\n 1. \\<B> rep x = int (card {b \\<in> design_support. x \\<in> b})", "by (metis finite_set_mset)"], ["", "end"], ["", "locale simple_design = design + simple_incidence_system"], ["", "text \\<open>Additional reasoning about when something is not simple\\<close>"], ["", "context incidence_system\nbegin"], ["", "lemma simple_not_multiplicity: \"b \\<in># \\<B> \\<Longrightarrow> multiplicity  b > 1 \\<Longrightarrow> \\<not> simple_incidence_system \\<V> \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in># \\<B>; 1 < multiplicity b\\<rbrakk>\n    \\<Longrightarrow> \\<not> simple_incidence_system \\<V> \\<B>", "using simple_incidence_system_def simple_incidence_system_axioms_def"], ["proof (prove)\nusing this:\n  simple_incidence_system ?point_set ?block_collection \\<equiv>\n  incidence_system ?point_set ?block_collection \\<and>\n  simple_incidence_system_axioms ?block_collection\n  simple_incidence_system_axioms ?block_collection \\<equiv>\n  \\<forall>bl.\n     bl \\<in># ?block_collection \\<longrightarrow>\n     count ?block_collection bl = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in># \\<B>; 1 < multiplicity b\\<rbrakk>\n    \\<Longrightarrow> \\<not> simple_incidence_system \\<V> \\<B>", "by (metis nat_neq_iff)"], ["", "lemma multiple_not_simple: \n  assumes \"n > 1\"\n  assumes \"\\<B> \\<noteq> {#}\"\n  shows \"\\<not> simple_incidence_system \\<V> (multiple_blocks n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> simple_incidence_system \\<V> (multiple_blocks n)", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_incidence_system \\<V> (multiple_blocks n) \\<Longrightarrow> False", "assume \"simple_incidence_system \\<V> (multiple_blocks n)\""], ["proof (state)\nthis:\n  simple_incidence_system \\<V> (multiple_blocks n)\n\ngoal (1 subgoal):\n 1. simple_incidence_system \\<V> (multiple_blocks n) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  simple_incidence_system \\<V> (multiple_blocks n)", "have \"\\<And> bl. bl \\<in># \\<B> \\<Longrightarrow> count (multiple_blocks n) bl = 1\""], ["proof (prove)\nusing this:\n  simple_incidence_system \\<V> (multiple_blocks n)\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># \\<B> \\<Longrightarrow> count (multiple_blocks n) bl = 1", "using assms(1) elem_in_original_in_repeat"], ["proof (prove)\nusing this:\n  simple_incidence_system \\<V> (multiple_blocks n)\n  1 < n\n  \\<lbrakk>0 < ?n; ?a \\<in># ?A\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in># repeat_mset ?n ?A\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># \\<B> \\<Longrightarrow> count (multiple_blocks n) bl = 1", "by (metis not_gr_zero not_less_zero simple_incidence_system.simple)"], ["proof (state)\nthis:\n  ?bl \\<in># \\<B> \\<Longrightarrow> count (multiple_blocks n) ?bl = 1\n\ngoal (1 subgoal):\n 1. simple_incidence_system \\<V> (multiple_blocks n) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> count (multiple_blocks n) ?bl = 1\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> count (multiple_blocks n) ?bl = 1\n  1 < n\n  \\<B> \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Proper Designs\\<close>"], ["", "text \\<open>Many types of designs rely on parameter conditions that only make sense for non-empty designs. \ni.e. designs with at least one block, and therefore given well-formed condition, at least one point. \nTo this end we define the notion of a \"proper\" design\\<close>"], ["", "locale proper_design = design + \n  assumes b_non_zero: \"\\<b> \\<noteq> 0\"\nbegin"], ["", "lemma is_proper: \"proper_design \\<V> \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B>", "by intro_locales"], ["", "lemma v_non_zero: \"\\<v> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<v>", "using b_non_zero v_eq0_imp_b_eq_0"], ["proof (prove)\nusing this:\n  \\<b> \\<noteq> 0\n  \\<v> = 0 \\<Longrightarrow> \\<b> = 0\n\ngoal (1 subgoal):\n 1. 0 < \\<v>", "by auto"], ["", "lemma b_positive: \"\\<b> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<b>", "using b_non_zero"], ["proof (prove)\nusing this:\n  \\<b> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < \\<b>", "by (simp add: nonempty_has_size)"], ["", "lemma design_points_nempty: \"\\<V> \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> \\<noteq> {}", "using v_non_zero"], ["proof (prove)\nusing this:\n  0 < \\<v>\n\ngoal (1 subgoal):\n 1. \\<V> \\<noteq> {}", "by auto"], ["", "lemma design_blocks_nempty: \"\\<B> \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> \\<noteq> {#}", "using b_non_zero"], ["proof (prove)\nusing this:\n  \\<b> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<B> \\<noteq> {#}", "by auto"], ["", "end"], ["", "text \\<open>Intro rules for a proper design\\<close>"], ["", "lemma (in design) proper_designI[intro]: \"\\<b> \\<noteq> 0 \\<Longrightarrow> proper_design \\<V> \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> \\<noteq> 0 \\<Longrightarrow> proper_design \\<V> \\<B>", "by (unfold_locales) simp"], ["", "lemma proper_designII[intro]: \n  assumes \"design V B\" and \"B \\<noteq> {#}\" \n  shows \"proper_design V B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design V B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design V B", "interpret des: design V B"], ["proof (prove)\ngoal (1 subgoal):\n 1. design V B", "using assms"], ["proof (prove)\nusing this:\n  design V B\n  B \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. design V B", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design V B", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design V B", "using assms"], ["proof (prove)\nusing this:\n  design V B\n  B \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. proper_design V B", "by unfold_locales simp"], ["proof (state)\nthis:\n  proper_design V B\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Reasoning on construction closure for proper designs\\<close>"], ["", "context proper_design\nbegin"], ["", "lemma multiple_proper_design: \n  assumes \"n > 0\"\n  shows \"proper_design \\<V> (multiple_blocks n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design \\<V> (multiple_blocks n)", "using multiple_is_design assms design_blocks_nempty multiple_block_in"], ["proof (prove)\nusing this:\n  design \\<V> (multiple_blocks ?n)\n  0 < n\n  \\<B> \\<noteq> {#}\n  \\<lbrakk>0 < ?n; ?b \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in># multiple_blocks ?n\n\ngoal (1 subgoal):\n 1. proper_design \\<V> (multiple_blocks n)", "by (metis block_set_nempty_imp_block_ex empty_iff proper_designII set_mset_empty)"], ["", "lemma complement_proper_design: \n  assumes \"\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\"\n  shows \"proper_design \\<V> \\<B>\\<^sup>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B>\\<^sup>C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B>\\<^sup>C", "interpret des: design \\<V> \"\\<B>\\<^sup>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design \\<V> \\<B>\\<^sup>C", "by (simp add: assms complement_design)"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B>\\<^sup>C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B>\\<^sup>C", "using b_non_zero"], ["proof (prove)\nusing this:\n  \\<b> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B>\\<^sup>C", "by (unfold_locales) auto"], ["proof (state)\nthis:\n  proper_design \\<V> \\<B>\\<^sup>C\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}