{"file_name": "/home/qj213/afp-2021-10-22/thys/Design_Theory/Design_Operations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Design_Theory", "problem_names": ["lemma add_existing_point [simp]: \"p \\<in> \\<V> \\<Longrightarrow> add_point p = \\<V>\"", "lemma add_point_wf: \"incidence_system (add_point p) \\<B>\"", "lemma add_point_blocks_blocks_alt: \"add_point_to_blocks p bs = \n    image_mset (insert p) (filter_mset (\\<lambda> b . b \\<in> bs) \\<B>) + (filter_mset (\\<lambda> b . b \\<notin> bs) \\<B>)\"", "lemma add_point_existing_blocks: \n  assumes \"(\\<And> bl . bl \\<in> bs \\<Longrightarrow> p \\<in> bl)\" \n  shows \"add_point_to_blocks p bs = \\<B>\"", "lemma add_new_point_rep_number: \n  assumes \"p \\<notin> \\<V>\"\n  shows \"(add_point_to_blocks p bs) rep p = size {#b \\<in># \\<B> . b \\<in> bs#}\"", "lemma add_point_blocks_wf: \"incidence_system (add_point p) (add_point_to_blocks p bs)\"", "lemma del_point_block_count: \"size (del_point_blocks p) = size \\<B>\"", "lemma remove_invalid_point_block: \"p \\<notin> \\<V> \\<Longrightarrow> bl \\<in># \\<B> \\<Longrightarrow> bl - {p} = bl\"", "lemma del_invalid_point: \"p \\<notin> \\<V> \\<Longrightarrow> (del_point p) = \\<V>\"", "lemma del_invalid_point_blocks: \"p \\<notin> \\<V> \\<Longrightarrow> (del_point_blocks p) = \\<B>\"", "lemma delete_point_p_not_in_bl_blocks: \"(\\<And> bl. bl \\<in># \\<B> \\<Longrightarrow> p \\<notin> bl) \\<Longrightarrow> (del_point_blocks p) = \\<B>\"", "lemma delete_point_blocks_wf: \"b \\<in># (del_point_blocks p) \\<Longrightarrow> b \\<subseteq> \\<V> - {p}\"", "lemma delete_point_blocks_sub: \n  assumes \"b \\<in># (del_point_blocks p)\" \n  obtains bl where \"bl \\<in># \\<B> \\<and> b \\<subseteq> bl\"", "lemma delete_point_split_blocks: \"del_point_blocks p = \n  {# bl \\<in>#\\<B> . p \\<notin> bl#} + {# bl - {p} | bl \\<in># \\<B> . p \\<in> bl#}\"", "lemma delete_point_index_eq: \n  assumes \"ps \\<subseteq> (del_point p)\"\n  shows \"(del_point_blocks p) index ps = \\<B> index ps\"", "lemma delete_point_wf: \"incidence_system (del_point p) (del_point_blocks p)\"", "lemma str_del_point_blocks_alt: \"str_del_point_blocks p = \\<B> - {# bl \\<in># \\<B> . p \\<in> bl#}\"", "lemma delete_point_strong_block_in:  \"p \\<notin> bl \\<Longrightarrow> bl \\<in># \\<B>  \\<Longrightarrow> bl \\<in># str_del_point_blocks p\"", "lemma delete_point_strong_block_not_in: \"p \\<in> bl \\<Longrightarrow> bl \\<notin># (str_del_point_blocks) p\"", "lemma delete_point_strong_block_in_iff: \"bl \\<in># \\<B> \\<Longrightarrow> bl \\<in># str_del_point_blocks p \\<longleftrightarrow> p \\<notin> bl\"", "lemma delete_point_strong_block_subset: \"str_del_point_blocks p \\<subseteq># \\<B>\"", "lemma delete_point_strong_block_in_orig: \"bl \\<in># str_del_point_blocks p \\<Longrightarrow> bl \\<in># \\<B>\"", "lemma delete_invalid_pt_strong_eq: \"p \\<notin> \\<V> \\<Longrightarrow> \\<B> = str_del_point_blocks p\"", "lemma strong_del_point_index_alt: \n  assumes \"ps \\<subseteq> (del_point p)\"\n  shows \"(str_del_point_blocks p) index ps = \n    \\<B> index ps - {# bl \\<in># \\<B> . p \\<in> bl#} index ps\"", "lemma strong_del_point_incidence_wf: \"incidence_system (del_point p) (str_del_point_blocks p)\"", "lemma add_block_alt: \"add_block b = add_mset b \\<B>\"", "lemma add_block_rep_number_in: \n  assumes \"x \\<in> b\"\n  shows \"(add_block b) rep x = \\<B> rep x + 1\"", "lemma add_block_rep_number_not_in: \"x \\<notin> b \\<Longrightarrow> (add_block b) rep x = \\<B> rep x\"", "lemma add_block_index_in: \n  assumes \"ps \\<subseteq> b\"\n  shows \"(add_block b) index ps = \\<B> index ps + 1\"", "lemma add_block_index_not_in: \"\\<not> (ps \\<subseteq> b) \\<Longrightarrow> (add_block b) index ps = \\<B> index ps\"", "lemma add_block_wf: \"incidence_system (\\<V> \\<union> b) (add_block b)\"", "lemma add_block_wf_cond: \"b \\<subseteq> \\<V> \\<Longrightarrow> incidence_system \\<V> (add_block b)\"", "lemma delete_block_subset: \"(del_block b) \\<subseteq># \\<B>\"", "lemma delete_invalid_block_eq: \"b \\<notin># \\<B> \\<Longrightarrow> del_block b = \\<B>\"", "lemma delete_block_wf: \"incidence_system \\<V> (del_block b)\"", "lemma strong_del_block_alt_def: \"str_del_block b = {# bl - b . bl \\<in># removeAll_mset b \\<B> #}\"", "lemma strong_del_block_wf: \"incidence_system (\\<V> - b) (str_del_block b)\"", "lemma str_del_block_del_point: \n  assumes \"{x} \\<notin># \\<B>\"\n  shows \"str_del_block {x} = (del_point_blocks x)\"", "lemma add_point_sys_rep_numbers: \"add_point_sys.replication_numbers p = \n    replication_numbers \\<union> {\\<B> rep p}\"", "lemma add_del_block_inv: \n  assumes \"bl \\<subseteq> \\<V>\"\n  shows \"add_block_sys.del_block bl bl = \\<B>\"", "lemma del_add_block_inv: \"bl \\<in># \\<B> \\<Longrightarrow> del_block_sys.add_block bl bl = \\<B>\"", "lemma del_invalid_add_block_eq: \"bl \\<notin># \\<B> \\<Longrightarrow> del_block_sys.add_block bl bl = add_block bl\"", "lemma add_delete_point_inv: \n  assumes \"p \\<notin> \\<V>\"\n  shows \"add_point_sys.del_point p p = \\<V>\"", "lemma add_point_finite: \"finite_incidence_system (add_point p) \\<B>\"", "lemma add_point_to_blocks_finite: \"finite_incidence_system (add_point p) (add_point_to_blocks p bs)\"", "lemma delete_point_finite: \n    \"finite_incidence_system (del_point p) (del_point_blocks p)\"", "lemma del_point_order: \n  assumes \"p \\<in> \\<V>\"\n  shows \"card (del_point p) = \\<v> - 1\"", "lemma strong_del_point_finite:\"finite_incidence_system (del_point p) (str_del_point_blocks p)\"", "lemma add_block_fin: \"finite b \\<Longrightarrow> finite_incidence_system (\\<V> \\<union> b) (add_block b)\"", "lemma add_block_fin_cond: \"b \\<subseteq> \\<V> \\<Longrightarrow> finite_incidence_system \\<V> (add_block b)\"", "lemma delete_block_fin_incidence_sys: \"finite_incidence_system \\<V> (del_block b)\"", "lemma strong_del_block_fin: \"finite_incidence_system (\\<V> - b) (str_del_block b)\"", "lemma add_point_design: \"design (add_point p) \\<B>\"", "lemma delete_point_design: \n  assumes \"(\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> p \\<in> bl \\<Longrightarrow> card bl \\<ge> 2)\"\n  shows \"design (del_point p) (del_point_blocks p)\"", "lemma strong_del_point_design: \"design (del_point p) (str_del_point_blocks p)\"", "lemma add_block_design: \n  assumes \"finite bl\" \n  assumes \"bl \\<noteq> {}\" \n  shows \"design (\\<V> \\<union> bl) (add_block bl)\"", "lemma add_block_design_cond: \n  assumes \"bl \\<subseteq> \\<V>\" and \"bl \\<noteq> {}\"\n  shows \"design \\<V> (add_block bl)\"", "lemma delete_block_design: \"design \\<V> (del_block bl)\"", "lemma strong_del_block_des: \n  assumes \"\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> \\<not> (bl \\<subset> b)\"\n  shows \"design (\\<V> - b) (str_del_block b)\"", "lemma delete_point_proper: \n  assumes \"\\<And>bl. bl \\<in># \\<B> \\<Longrightarrow> p \\<in> bl \\<Longrightarrow> 2 \\<le> card bl\"\n  shows \"proper_design (del_point p) (del_point_blocks p)\"", "lemma strong_delete_point_proper: \n  assumes \"\\<And>bl. bl \\<in># \\<B> \\<Longrightarrow> p \\<in> bl \\<Longrightarrow> 2 \\<le> card bl\"\n  assumes \"\\<B> rep p < \\<b>\"\n  shows \"proper_design (del_point p) (str_del_point_blocks p)\"", "lemma combine_points_index: \"\\<B>\\<^sup>+ index ps = \\<B> index ps  + \\<B>' index ps\"", "lemma combine_rep_number: \"\\<B>\\<^sup>+ rep x = \\<B> rep x + \\<B>' rep x\"", "lemma combine_multiple1: \"\\<V> = \\<V>' \\<Longrightarrow> \\<B> = \\<B>' \\<Longrightarrow> \\<B>\\<^sup>+ = sys1.multiple_blocks 2\"", "lemma combine_multiple2: \"\\<V> = \\<V>' \\<Longrightarrow> \\<B> = \\<B>' \\<Longrightarrow> \\<B>\\<^sup>+ = sys2.multiple_blocks 2\"", "lemma combine_multiplicity: \"combine_sys.multiplicity b = sys1.multiplicity b + sys2.multiplicity b\"", "lemma combine_block_sizes: \"combine_sys.sys_block_sizes = \n    sys1.sys_block_sizes \\<union> sys2.sys_block_sizes\"", "lemma combine_order: \"card (\\<V>\\<^sup>+) \\<ge> card \\<V>\"", "lemma  combine_order_2: \"card (\\<V>\\<^sup>+) \\<ge> card \\<V>'\"", "lemma des1_is_proper: \"\\<B> \\<noteq> {#} \\<Longrightarrow> proper_design \\<V> \\<B>\"", "lemma des2_is_proper: \"\\<B>' \\<noteq> {#} \\<Longrightarrow> proper_design \\<V>' \\<B>'\"", "lemma min_one_proper_design: \"proper_design \\<V> \\<B> \\<or> proper_design \\<V>' \\<B>'\""], "translations": [["", "lemma add_existing_point [simp]: \"p \\<in> \\<V> \\<Longrightarrow> add_point p = \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> \\<V> \\<Longrightarrow> add_point p = \\<V>", "using add_point_def"], ["proof (prove)\nusing this:\n  add_point ?p \\<equiv> insert ?p \\<V>\n\ngoal (1 subgoal):\n 1. p \\<in> \\<V> \\<Longrightarrow> add_point p = \\<V>", "by fastforce"], ["", "lemma add_point_wf: \"incidence_system (add_point p) \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system (add_point p) \\<B>", "using wf_invalid_point add_point_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<notin> \\<V>; ?b \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> ?b\n  add_point ?p \\<equiv> insert ?p \\<V>\n\ngoal (1 subgoal):\n 1. incidence_system (add_point p) \\<B>", "by (unfold_locales) (auto)"], ["", "text \\<open>An extension of the basic add point operation also adds the point to a given set of blocks\\<close>"], ["", "definition add_point_to_blocks :: \"'a \\<Rightarrow> 'a set set \\<Rightarrow> 'a set multiset\" where\n\"add_point_to_blocks p bs \\<equiv> {# (insert p b) | b \\<in># \\<B> . b \\<in> bs#} + {# b \\<in># \\<B> . b \\<notin> bs#}\""], ["", "lemma add_point_blocks_blocks_alt: \"add_point_to_blocks p bs = \n    image_mset (insert p) (filter_mset (\\<lambda> b . b \\<in> bs) \\<B>) + (filter_mset (\\<lambda> b . b \\<notin> bs) \\<B>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs =\n    image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} +\n    {#b \\<in># \\<B>. b \\<notin> bs#}", "using add_point_to_blocks_def"], ["proof (prove)\nusing this:\n  add_point_to_blocks ?p ?bs \\<equiv>\n  image_mset (insert ?p) {#b \\<in># \\<B>. b \\<in> ?bs#} +\n  {#b \\<in># \\<B>. b \\<notin> ?bs#}\n\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs =\n    image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} +\n    {#b \\<in># \\<B>. b \\<notin> bs#}", "by simp"], ["", "lemma add_point_existing_blocks: \n  assumes \"(\\<And> bl . bl \\<in> bs \\<Longrightarrow> p \\<in> bl)\" \n  shows \"add_point_to_blocks p bs = \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs = \\<B>", "proof (simp add: add_point_to_blocks_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} +\n    {#b \\<in># \\<B>. b \\<notin> bs#} =\n    \\<B>", "have \"image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} = {#b \\<in># \\<B>. b \\<in> bs#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} =\n    {#b \\<in># \\<B>. b \\<in> bs#}", "using assms"], ["proof (prove)\nusing this:\n  ?bl \\<in> bs \\<Longrightarrow> p \\<in> ?bl\n\ngoal (1 subgoal):\n 1. image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} =\n    {#b \\<in># \\<B>. b \\<in> bs#}", "by (simp add: image_filter_cong insert_absorb)"], ["proof (state)\nthis:\n  image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} =\n  {#b \\<in># \\<B>. b \\<in> bs#}\n\ngoal (1 subgoal):\n 1. image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} +\n    {#b \\<in># \\<B>. b \\<notin> bs#} =\n    \\<B>", "thus \"image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} + {#b \\<in># \\<B>. b \\<notin> bs#} = \\<B>\""], ["proof (prove)\nusing this:\n  image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} =\n  {#b \\<in># \\<B>. b \\<in> bs#}\n\ngoal (1 subgoal):\n 1. image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} +\n    {#b \\<in># \\<B>. b \\<notin> bs#} =\n    \\<B>", "using multiset_partition"], ["proof (prove)\nusing this:\n  image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} =\n  {#b \\<in># \\<B>. b \\<in> bs#}\n  ?M = filter_mset ?P ?M + {#x \\<in># ?M. \\<not> ?P x#}\n\ngoal (1 subgoal):\n 1. image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} +\n    {#b \\<in># \\<B>. b \\<notin> bs#} =\n    \\<B>", "by simp"], ["proof (state)\nthis:\n  image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} +\n  {#b \\<in># \\<B>. b \\<notin> bs#} =\n  \\<B>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_new_point_rep_number: \n  assumes \"p \\<notin> \\<V>\"\n  shows \"(add_point_to_blocks p bs) rep p = size {#b \\<in># \\<B> . b \\<in> bs#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    int (size {#b \\<in># \\<B>. b \\<in> bs#})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    int (size {#b \\<in># \\<B>. b \\<in> bs#})", "have \"\\<And> b. b \\<in># \\<B> \\<Longrightarrow> b \\<notin> bs \\<Longrightarrow> p \\<notin> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in># \\<B>; b \\<notin> bs\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> b", "by (simp add: assms wf_invalid_point)"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<in># \\<B>; ?b \\<notin> bs\\<rbrakk>\n  \\<Longrightarrow> p \\<notin> ?b\n\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    int (size {#b \\<in># \\<B>. b \\<in> bs#})", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?b \\<in># \\<B>; ?b \\<notin> bs\\<rbrakk>\n  \\<Longrightarrow> p \\<notin> ?b", "have zero: \"{# b \\<in># \\<B> . b \\<notin> bs#} rep p = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<in># \\<B>; ?b \\<notin> bs\\<rbrakk>\n  \\<Longrightarrow> p \\<notin> ?b\n\ngoal (1 subgoal):\n 1. {#b \\<in># \\<B>. b \\<notin> bs#} rep p = 0", "by (simp add: filter_mset_empty_conv point_replication_number_def)"], ["proof (state)\nthis:\n  {#b \\<in># \\<B>. b \\<notin> bs#} rep p = 0\n\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    int (size {#b \\<in># \\<B>. b \\<in> bs#})", "have \"(add_point_to_blocks p bs) rep p = {# (insert p b) | b \\<in># \\<B> . b \\<in> bs#} rep p + {# b \\<in># \\<B> . b \\<notin> bs#} rep p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p +\n    {#b \\<in># \\<B>. b \\<notin> bs#} rep p", "by (simp add: add_point_to_blocks_def)"], ["proof (state)\nthis:\n  add_point_to_blocks p bs rep p =\n  image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p +\n  {#b \\<in># \\<B>. b \\<notin> bs#} rep p\n\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    int (size {#b \\<in># \\<B>. b \\<in> bs#})", "then"], ["proof (chain)\npicking this:\n  add_point_to_blocks p bs rep p =\n  image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p +\n  {#b \\<in># \\<B>. b \\<notin> bs#} rep p", "have eq: \"(add_point_to_blocks p bs) rep p = {# (insert p b) | b \\<in># \\<B> . b \\<in> bs#} rep p\""], ["proof (prove)\nusing this:\n  add_point_to_blocks p bs rep p =\n  image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p +\n  {#b \\<in># \\<B>. b \\<notin> bs#} rep p\n\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p", "using zero"], ["proof (prove)\nusing this:\n  add_point_to_blocks p bs rep p =\n  image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p +\n  {#b \\<in># \\<B>. b \\<notin> bs#} rep p\n  {#b \\<in># \\<B>. b \\<notin> bs#} rep p = 0\n\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p", "by simp"], ["proof (state)\nthis:\n  add_point_to_blocks p bs rep p =\n  image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p\n\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    int (size {#b \\<in># \\<B>. b \\<in> bs#})", "have \"\\<And> bl . bl \\<in># {# (insert p b) | b \\<in># \\<B> . b \\<in> bs#} \\<Longrightarrow> p \\<in> bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># image_mset (insert p)\n                  {#b \\<in># \\<B>. b \\<in> bs#} \\<Longrightarrow>\n       p \\<in> bl", "by auto"], ["proof (state)\nthis:\n  ?bl\n  \\<in># image_mset (insert p)\n          {#b \\<in># \\<B>. b \\<in> bs#} \\<Longrightarrow>\n  p \\<in> ?bl\n\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    int (size {#b \\<in># \\<B>. b \\<in> bs#})", "then"], ["proof (chain)\npicking this:\n  ?bl\n  \\<in># image_mset (insert p)\n          {#b \\<in># \\<B>. b \\<in> bs#} \\<Longrightarrow>\n  p \\<in> ?bl", "have \"{# (insert p b) | b \\<in># \\<B> . b \\<in> bs#} rep p = size {# (insert p b) | b \\<in># \\<B> . b \\<in> bs#}\""], ["proof (prove)\nusing this:\n  ?bl\n  \\<in># image_mset (insert p)\n          {#b \\<in># \\<B>. b \\<in> bs#} \\<Longrightarrow>\n  p \\<in> ?bl\n\ngoal (1 subgoal):\n 1. image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p =\n    int (size (image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#}))", "using point_replication_number_def"], ["proof (prove)\nusing this:\n  ?bl\n  \\<in># image_mset (insert p)\n          {#b \\<in># \\<B>. b \\<in> bs#} \\<Longrightarrow>\n  p \\<in> ?bl\n  ?B rep ?x \\<equiv> int (size (filter_mset ((\\<in>) ?x) ?B))\n\ngoal (1 subgoal):\n 1. image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p =\n    int (size (image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#}))", "by (metis filter_mset_True filter_mset_cong)"], ["proof (state)\nthis:\n  image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p =\n  int (size (image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#}))\n\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    int (size {#b \\<in># \\<B>. b \\<in> bs#})", "thus ?thesis"], ["proof (prove)\nusing this:\n  image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#} rep p =\n  int (size (image_mset (insert p) {#b \\<in># \\<B>. b \\<in> bs#}))\n\ngoal (1 subgoal):\n 1. add_point_to_blocks p bs rep p =\n    int (size {#b \\<in># \\<B>. b \\<in> bs#})", "by (simp add: eq)"], ["proof (state)\nthis:\n  add_point_to_blocks p bs rep p = int (size {#b \\<in># \\<B>. b \\<in> bs#})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_point_blocks_wf: \"incidence_system (add_point p) (add_point_to_blocks p bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system (add_point p) (add_point_to_blocks p bs)", "by (unfold_locales) (auto simp add: add_point_def wf_invalid_point add_point_to_blocks_def)"], ["", "text \\<open>Basic (weak) delete point operation removes a point from both the point set and from any \nblocks that contain it to maintain wellformed property\\<close>"], ["", "definition del_point :: \"'a \\<Rightarrow> 'a set\" where\n\"del_point p \\<equiv> \\<V> - {p}\""], ["", "definition del_point_blocks:: \"'a \\<Rightarrow> 'a set multiset\" where\n\"del_point_blocks p \\<equiv> {# (bl - {p}) . bl \\<in># \\<B> #}\""], ["", "lemma del_point_block_count: \"size (del_point_blocks p) = size \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (del_point_blocks p) = size \\<B>", "by (simp add: del_point_blocks_def)"], ["", "lemma remove_invalid_point_block: \"p \\<notin> \\<V> \\<Longrightarrow> bl \\<in># \\<B> \\<Longrightarrow> bl - {p} = bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<notin> \\<V>; bl \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> bl - {p} = bl", "using wf_invalid_point"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<notin> \\<V>; ?b \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<notin> \\<V>; bl \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> bl - {p} = bl", "by blast"], ["", "lemma del_invalid_point: \"p \\<notin> \\<V> \\<Longrightarrow> (del_point p) = \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> \\<V> \\<Longrightarrow> del_point p = \\<V>", "by (simp add: del_point_def)"], ["", "lemma del_invalid_point_blocks: \"p \\<notin> \\<V> \\<Longrightarrow> (del_point_blocks p) = \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> \\<V> \\<Longrightarrow> del_point_blocks p = \\<B>", "using del_invalid_point"], ["proof (prove)\nusing this:\n  ?p \\<notin> \\<V> \\<Longrightarrow> del_point ?p = \\<V>\n\ngoal (1 subgoal):\n 1. p \\<notin> \\<V> \\<Longrightarrow> del_point_blocks p = \\<B>", "by (auto simp add: remove_invalid_point_block del_point_blocks_def)"], ["", "lemma delete_point_p_not_in_bl_blocks: \"(\\<And> bl. bl \\<in># \\<B> \\<Longrightarrow> p \\<notin> bl) \\<Longrightarrow> (del_point_blocks p) = \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bl.\n        bl \\<in># \\<B> \\<Longrightarrow> p \\<notin> bl) \\<Longrightarrow>\n    del_point_blocks p = \\<B>", "by (simp add: del_point_blocks_def)"], ["", "lemma delete_point_blocks_wf: \"b \\<in># (del_point_blocks p) \\<Longrightarrow> b \\<subseteq> \\<V> - {p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in># del_point_blocks p \\<Longrightarrow> b \\<subseteq> \\<V> - {p}", "unfolding del_point_blocks_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in># {#bl - {p}. bl \\<in># \\<B>#} \\<Longrightarrow>\n    b \\<subseteq> \\<V> - {p}", "using wellformed"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. b \\<in># {#bl - {p}. bl \\<in># \\<B>#} \\<Longrightarrow>\n    b \\<subseteq> \\<V> - {p}", "by auto"], ["", "lemma delete_point_blocks_sub: \n  assumes \"b \\<in># (del_point_blocks p)\" \n  obtains bl where \"bl \\<in># \\<B> \\<and> b \\<subseteq> bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bl.\n        bl \\<in># \\<B> \\<and> b \\<subseteq> bl \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  b \\<in># del_point_blocks p\n\ngoal (1 subgoal):\n 1. (\\<And>bl.\n        bl \\<in># \\<B> \\<and> b \\<subseteq> bl \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: del_point_blocks_def)"], ["", "lemma delete_point_split_blocks: \"del_point_blocks p = \n  {# bl \\<in>#\\<B> . p \\<notin> bl#} + {# bl - {p} | bl \\<in># \\<B> . p \\<in> bl#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. del_point_blocks p =\n    filter_mset ((\\<notin>) p) \\<B> +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. del_point_blocks p =\n    filter_mset ((\\<notin>) p) \\<B> +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "have sm: \"\\<And> bl . p \\<notin> bl \\<Longrightarrow> bl - {p} = bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl. p \\<notin> bl \\<Longrightarrow> bl - {p} = bl", "by simp"], ["proof (state)\nthis:\n  p \\<notin> ?bl \\<Longrightarrow> ?bl - {p} = ?bl\n\ngoal (1 subgoal):\n 1. del_point_blocks p =\n    filter_mset ((\\<notin>) p) \\<B> +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "have \"del_point_blocks p = {# (bl - {p}) . bl \\<in># \\<B> #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. del_point_blocks p = {#bl - {p}. bl \\<in># \\<B>#}", "by (simp add: del_point_blocks_def)"], ["proof (state)\nthis:\n  del_point_blocks p = {#bl - {p}. bl \\<in># \\<B>#}\n\ngoal (1 subgoal):\n 1. del_point_blocks p =\n    filter_mset ((\\<notin>) p) \\<B> +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "also"], ["proof (state)\nthis:\n  del_point_blocks p = {#bl - {p}. bl \\<in># \\<B>#}\n\ngoal (1 subgoal):\n 1. del_point_blocks p =\n    filter_mset ((\\<notin>) p) \\<B> +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "have \"... = {# (bl - {p}) | bl \\<in># \\<B> . p \\<notin> bl #} + {# (bl - {p}) | bl \\<in># \\<B> . p \\<in> bl #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#bl - {p}. bl \\<in># \\<B>#} =\n    {#bl - {p}. bl \\<in># filter_mset ((\\<notin>) p) \\<B>#} +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "using multiset_partition"], ["proof (prove)\nusing this:\n  ?M = filter_mset ?P ?M + {#x \\<in># ?M. \\<not> ?P x#}\n\ngoal (1 subgoal):\n 1. {#bl - {p}. bl \\<in># \\<B>#} =\n    {#bl - {p}. bl \\<in># filter_mset ((\\<notin>) p) \\<B>#} +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "by (metis image_mset_union union_commute)"], ["proof (state)\nthis:\n  {#bl - {p}. bl \\<in># \\<B>#} =\n  {#bl - {p}. bl \\<in># filter_mset ((\\<notin>) p) \\<B>#} +\n  {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}\n\ngoal (1 subgoal):\n 1. del_point_blocks p =\n    filter_mset ((\\<notin>) p) \\<B> +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "finally"], ["proof (chain)\npicking this:\n  del_point_blocks p =\n  {#bl - {p}. bl \\<in># filter_mset ((\\<notin>) p) \\<B>#} +\n  {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "have \"del_point_blocks p = {#bl | bl \\<in># \\<B> . p \\<notin> bl#} + \n      {# (bl - {p}) | bl \\<in># \\<B> . p \\<in> bl #}\""], ["proof (prove)\nusing this:\n  del_point_blocks p =\n  {#bl - {p}. bl \\<in># filter_mset ((\\<notin>) p) \\<B>#} +\n  {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}\n\ngoal (1 subgoal):\n 1. del_point_blocks p =\n    {#bl. bl \\<in># filter_mset ((\\<notin>) p) \\<B>#} +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "using sm mem_Collect_eq"], ["proof (prove)\nusing this:\n  del_point_blocks p =\n  {#bl - {p}. bl \\<in># filter_mset ((\\<notin>) p) \\<B>#} +\n  {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}\n  p \\<notin> ?bl \\<Longrightarrow> ?bl - {p} = ?bl\n  (?a \\<in> Collect ?P) = ?P ?a\n\ngoal (1 subgoal):\n 1. del_point_blocks p =\n    {#bl. bl \\<in># filter_mset ((\\<notin>) p) \\<B>#} +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "by (metis (mono_tags, lifting) Multiset.set_mset_filter  multiset.map_cong)"], ["proof (state)\nthis:\n  del_point_blocks p =\n  {#bl. bl \\<in># filter_mset ((\\<notin>) p) \\<B>#} +\n  {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}\n\ngoal (1 subgoal):\n 1. del_point_blocks p =\n    filter_mset ((\\<notin>) p) \\<B> +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "thus ?thesis"], ["proof (prove)\nusing this:\n  del_point_blocks p =\n  {#bl. bl \\<in># filter_mset ((\\<notin>) p) \\<B>#} +\n  {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}\n\ngoal (1 subgoal):\n 1. del_point_blocks p =\n    filter_mset ((\\<notin>) p) \\<B> +\n    {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}", "by simp"], ["proof (state)\nthis:\n  del_point_blocks p =\n  filter_mset ((\\<notin>) p) \\<B> +\n  {#bl - {p}. bl \\<in># filter_mset ((\\<in>) p) \\<B>#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_point_index_eq: \n  assumes \"ps \\<subseteq> (del_point p)\"\n  shows \"(del_point_blocks p) index ps = \\<B> index ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. del_point_blocks p index ps = \\<B> index ps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. del_point_blocks p index ps = \\<B> index ps", "have eq: \"filter_mset ((\\<subseteq>) ps) {#bl - {p}. bl \\<in># \\<B>#} = \n      image_mset (\\<lambda> b . b - {p}) (filter_mset (\\<lambda> b. ps \\<subseteq> b - {p}) \\<B>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) ps) {#bl - {p}. bl \\<in># \\<B>#} =\n    {#b - {p}. b \\<in># {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#}#}", "using filter_mset_image_mset"], ["proof (prove)\nusing this:\n  filter_mset ?P (image_mset ?f ?A) =\n  image_mset ?f {#x \\<in># ?A. ?P (?f x)#}\n\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) ps) {#bl - {p}. bl \\<in># \\<B>#} =\n    {#b - {p}. b \\<in># {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#}#}", "by blast"], ["proof (state)\nthis:\n  filter_mset ((\\<subseteq>) ps) {#bl - {p}. bl \\<in># \\<B>#} =\n  {#b - {p}. b \\<in># {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#}#}\n\ngoal (1 subgoal):\n 1. del_point_blocks p index ps = \\<B> index ps", "have \"p \\<notin> ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> ps", "using assms del_point_def"], ["proof (prove)\nusing this:\n  ps \\<subseteq> del_point p\n  del_point ?p \\<equiv> \\<V> - {?p}\n\ngoal (1 subgoal):\n 1. p \\<notin> ps", "by blast"], ["proof (state)\nthis:\n  p \\<notin> ps\n\ngoal (1 subgoal):\n 1. del_point_blocks p index ps = \\<B> index ps", "then"], ["proof (chain)\npicking this:\n  p \\<notin> ps", "have \"\\<And> bl . ps \\<subseteq> bl \\<longleftrightarrow> ps \\<subseteq> bl - {p}\""], ["proof (prove)\nusing this:\n  p \\<notin> ps\n\ngoal (1 subgoal):\n 1. \\<And>bl. (ps \\<subseteq> bl) = (ps \\<subseteq> bl - {p})", "by blast"], ["proof (state)\nthis:\n  (ps \\<subseteq> ?bl) = (ps \\<subseteq> ?bl - {p})\n\ngoal (1 subgoal):\n 1. del_point_blocks p index ps = \\<B> index ps", "then"], ["proof (chain)\npicking this:\n  (ps \\<subseteq> ?bl) = (ps \\<subseteq> ?bl - {p})", "have \"((filter_mset (\\<lambda> b. ps \\<subseteq> b - {p}) \\<B>)) = (filter_mset (\\<lambda> b . ps \\<subseteq> b) \\<B>)\""], ["proof (prove)\nusing this:\n  (ps \\<subseteq> ?bl) = (ps \\<subseteq> ?bl - {p})\n\ngoal (1 subgoal):\n 1. {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#} =\n    filter_mset ((\\<subseteq>) ps) \\<B>", "by auto"], ["proof (state)\nthis:\n  {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#} =\n  filter_mset ((\\<subseteq>) ps) \\<B>\n\ngoal (1 subgoal):\n 1. del_point_blocks p index ps = \\<B> index ps", "then"], ["proof (chain)\npicking this:\n  {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#} =\n  filter_mset ((\\<subseteq>) ps) \\<B>", "have \"size (image_mset (\\<lambda> b . b - {p}) (filter_mset (\\<lambda> b. ps \\<subseteq> b - {p}) \\<B>)) \n      = \\<B> index ps\""], ["proof (prove)\nusing this:\n  {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#} =\n  filter_mset ((\\<subseteq>) ps) \\<B>\n\ngoal (1 subgoal):\n 1. size {#b - {p}. b \\<in># {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#}#} =\n    \\<B> index ps", "by (simp add: points_index_def)"], ["proof (state)\nthis:\n  size {#b - {p}. b \\<in># {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#}#} =\n  \\<B> index ps\n\ngoal (1 subgoal):\n 1. del_point_blocks p index ps = \\<B> index ps", "thus ?thesis"], ["proof (prove)\nusing this:\n  size {#b - {p}. b \\<in># {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#}#} =\n  \\<B> index ps\n\ngoal (1 subgoal):\n 1. del_point_blocks p index ps = \\<B> index ps", "using eq"], ["proof (prove)\nusing this:\n  size {#b - {p}. b \\<in># {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#}#} =\n  \\<B> index ps\n  filter_mset ((\\<subseteq>) ps) {#bl - {p}. bl \\<in># \\<B>#} =\n  {#b - {p}. b \\<in># {#b \\<in># \\<B>. ps \\<subseteq> b - {p}#}#}\n\ngoal (1 subgoal):\n 1. del_point_blocks p index ps = \\<B> index ps", "by (simp add: del_point_blocks_def points_index_def)"], ["proof (state)\nthis:\n  del_point_blocks p index ps = \\<B> index ps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_point_wf: \"incidence_system (del_point p) (del_point_blocks p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system (del_point p) (del_point_blocks p)", "using delete_point_blocks_wf del_point_def"], ["proof (prove)\nusing this:\n  ?b \\<in># del_point_blocks ?p \\<Longrightarrow> ?b \\<subseteq> \\<V> - {?p}\n  del_point ?p \\<equiv> \\<V> - {?p}\n\ngoal (1 subgoal):\n 1. incidence_system (del_point p) (del_point_blocks p)", "by (unfold_locales) auto"], ["", "text \\<open>The concept of a strong delete point comes from hypergraph theory. When a point is deleted, \nany blocks containing it are also deleted\\<close>"], ["", "definition str_del_point_blocks :: \"'a \\<Rightarrow> 'a set multiset\" where\n\"str_del_point_blocks p \\<equiv> {# bl \\<in># \\<B> . p \\<notin> bl#}\""], ["", "lemma str_del_point_blocks_alt: \"str_del_point_blocks p = \\<B> - {# bl \\<in># \\<B> . p \\<in> bl#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. str_del_point_blocks p = \\<B> - filter_mset ((\\<in>) p) \\<B>", "using add_diff_cancel_left' multiset_partition"], ["proof (prove)\nusing this:\n  ?a + ?b - ?a = ?b\n  ?M = filter_mset ?P ?M + {#x \\<in># ?M. \\<not> ?P x#}\n\ngoal (1 subgoal):\n 1. str_del_point_blocks p = \\<B> - filter_mset ((\\<in>) p) \\<B>", "by (metis str_del_point_blocks_def)"], ["", "lemma delete_point_strong_block_in:  \"p \\<notin> bl \\<Longrightarrow> bl \\<in># \\<B>  \\<Longrightarrow> bl \\<in># str_del_point_blocks p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<notin> bl; bl \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> bl \\<in># str_del_point_blocks p", "by (simp add: str_del_point_blocks_def)"], ["", "lemma delete_point_strong_block_not_in: \"p \\<in> bl \\<Longrightarrow> bl \\<notin># (str_del_point_blocks) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> bl \\<Longrightarrow> bl \\<notin># str_del_point_blocks p", "by (simp add: str_del_point_blocks_def)"], ["", "lemma delete_point_strong_block_in_iff: \"bl \\<in># \\<B> \\<Longrightarrow> bl \\<in># str_del_point_blocks p \\<longleftrightarrow> p \\<notin> bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow>\n    (bl \\<in># str_del_point_blocks p) = (p \\<notin> bl)", "using delete_point_strong_block_in delete_point_strong_block_not_in"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<notin> ?bl; ?bl \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?bl \\<in># str_del_point_blocks ?p\n  ?p \\<in> ?bl \\<Longrightarrow> ?bl \\<notin># str_del_point_blocks ?p\n\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow>\n    (bl \\<in># str_del_point_blocks p) = (p \\<notin> bl)", "by (simp add: str_del_point_blocks_def)"], ["", "lemma delete_point_strong_block_subset: \"str_del_point_blocks p \\<subseteq># \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. str_del_point_blocks p \\<subseteq># \\<B>", "by (simp add: str_del_point_blocks_def)"], ["", "lemma delete_point_strong_block_in_orig: \"bl \\<in># str_del_point_blocks p \\<Longrightarrow> bl \\<in># \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># str_del_point_blocks p \\<Longrightarrow> bl \\<in># \\<B>", "using delete_point_strong_block_subset"], ["proof (prove)\nusing this:\n  str_del_point_blocks ?p \\<subseteq># \\<B>\n\ngoal (1 subgoal):\n 1. bl \\<in># str_del_point_blocks p \\<Longrightarrow> bl \\<in># \\<B>", "by (metis mset_subset_eqD)"], ["", "lemma delete_invalid_pt_strong_eq: \"p \\<notin> \\<V> \\<Longrightarrow> \\<B> = str_del_point_blocks p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> \\<V> \\<Longrightarrow> \\<B> = str_del_point_blocks p", "unfolding str_del_point_blocks_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> \\<V> \\<Longrightarrow> \\<B> = filter_mset ((\\<notin>) p) \\<B>", "using wf_invalid_point empty_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<notin> \\<V>; ?b \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> ?b\n  (?c \\<in> {}) = False\n\ngoal (1 subgoal):\n 1. p \\<notin> \\<V> \\<Longrightarrow> \\<B> = filter_mset ((\\<notin>) p) \\<B>", "by (metis Multiset.diff_cancel filter_mset_eq_conv set_mset_empty subset_mset.order_refl)"], ["", "lemma strong_del_point_index_alt: \n  assumes \"ps \\<subseteq> (del_point p)\"\n  shows \"(str_del_point_blocks p) index ps = \n    \\<B> index ps - {# bl \\<in># \\<B> . p \\<in> bl#} index ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. str_del_point_blocks p index ps =\n    \\<B> index ps - filter_mset ((\\<in>) p) \\<B> index ps", "using str_del_point_blocks_alt points_index_def"], ["proof (prove)\nusing this:\n  str_del_point_blocks ?p = \\<B> - filter_mset ((\\<in>) ?p) \\<B>\n  ?B index ?ps \\<equiv> size (filter_mset ((\\<subseteq>) ?ps) ?B)\n\ngoal (1 subgoal):\n 1. str_del_point_blocks p index ps =\n    \\<B> index ps - filter_mset ((\\<in>) p) \\<B> index ps", "by (metis filter_diff_mset multiset_filter_mono multiset_filter_subset  size_Diff_submset)"], ["", "lemma strong_del_point_incidence_wf: \"incidence_system (del_point p) (str_del_point_blocks p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system (del_point p) (str_del_point_blocks p)", "using wellformed str_del_point_blocks_def del_point_def"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n  str_del_point_blocks ?p \\<equiv> filter_mset ((\\<notin>) ?p) \\<B>\n  del_point ?p \\<equiv> \\<V> - {?p}\n\ngoal (1 subgoal):\n 1. incidence_system (del_point p) (str_del_point_blocks p)", "by (unfold_locales) auto"], ["", "text \\<open>Add block operation\\<close>"], ["", "definition add_block :: \"'a set \\<Rightarrow> 'a set multiset\" where \n\"add_block b \\<equiv> \\<B> + {#b#}\""], ["", "lemma add_block_alt: \"add_block b = add_mset b \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_block b = add_mset b \\<B>", "by (simp add: add_block_def)"], ["", "lemma add_block_rep_number_in: \n  assumes \"x \\<in> b\"\n  shows \"(add_block b) rep x = \\<B> rep x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_block b rep x = \\<B> rep x + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. add_block b rep x = \\<B> rep x + 1", "have \"(add_block b) = {#b#} + \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_block b = {#b#} + \\<B>", "by (simp add: add_block_def)"], ["proof (state)\nthis:\n  add_block b = {#b#} + \\<B>\n\ngoal (1 subgoal):\n 1. add_block b rep x = \\<B> rep x + 1", "then"], ["proof (chain)\npicking this:\n  add_block b = {#b#} + \\<B>", "have split: \"(add_block b) rep x = {#b#} rep x + \\<B> rep x\""], ["proof (prove)\nusing this:\n  add_block b = {#b#} + \\<B>\n\ngoal (1 subgoal):\n 1. add_block b rep x = {#b#} rep x + \\<B> rep x", "by (metis point_rep_number_split)"], ["proof (state)\nthis:\n  add_block b rep x = {#b#} rep x + \\<B> rep x\n\ngoal (1 subgoal):\n 1. add_block b rep x = \\<B> rep x + 1", "have \"{#b#} rep x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#b#} rep x = 1", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> b\n\ngoal (1 subgoal):\n 1. {#b#} rep x = 1", "by simp"], ["proof (state)\nthis:\n  {#b#} rep x = 1\n\ngoal (1 subgoal):\n 1. add_block b rep x = \\<B> rep x + 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  {#b#} rep x = 1\n\ngoal (1 subgoal):\n 1. add_block b rep x = \\<B> rep x + 1", "using split"], ["proof (prove)\nusing this:\n  {#b#} rep x = 1\n  add_block b rep x = {#b#} rep x + \\<B> rep x\n\ngoal (1 subgoal):\n 1. add_block b rep x = \\<B> rep x + 1", "by auto"], ["proof (state)\nthis:\n  add_block b rep x = \\<B> rep x + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_block_rep_number_not_in: \"x \\<notin> b \\<Longrightarrow> (add_block b) rep x = \\<B> rep x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> b \\<Longrightarrow> add_block b rep x = \\<B> rep x", "using point_rep_number_split add_block_alt point_rep_singleton_inval"], ["proof (prove)\nusing this:\n  (?A + ?B) rep ?x = ?A rep ?x + ?B rep ?x\n  add_block ?b = add_mset ?b \\<B>\n  ?x \\<notin> ?b \\<Longrightarrow> {#?b#} rep ?x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> b \\<Longrightarrow> add_block b rep x = \\<B> rep x", "by (metis add.right_neutral union_mset_add_mset_right)"], ["", "lemma add_block_index_in: \n  assumes \"ps \\<subseteq> b\"\n  shows \"(add_block b) index ps = \\<B> index ps + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_block b index ps = \\<B> index ps + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. add_block b index ps = \\<B> index ps + 1", "have \"(add_block b) = {#b#} + \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_block b = {#b#} + \\<B>", "by (simp add: add_block_def)"], ["proof (state)\nthis:\n  add_block b = {#b#} + \\<B>\n\ngoal (1 subgoal):\n 1. add_block b index ps = \\<B> index ps + 1", "then"], ["proof (chain)\npicking this:\n  add_block b = {#b#} + \\<B>", "have split: \"(add_block b) index ps = {#b#} index ps + \\<B> index ps\""], ["proof (prove)\nusing this:\n  add_block b = {#b#} + \\<B>\n\ngoal (1 subgoal):\n 1. add_block b index ps = {#b#} index ps + \\<B> index ps", "by (metis point_index_distrib)"], ["proof (state)\nthis:\n  add_block b index ps = {#b#} index ps + \\<B> index ps\n\ngoal (1 subgoal):\n 1. add_block b index ps = \\<B> index ps + 1", "have \"{#b#} index ps = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#b#} index ps = 1", "using assms points_index_singleton"], ["proof (prove)\nusing this:\n  ps \\<subseteq> b\n  ({#?b#} index ?ps = 1) = (?ps \\<subseteq> ?b)\n\ngoal (1 subgoal):\n 1. {#b#} index ps = 1", "by auto"], ["proof (state)\nthis:\n  {#b#} index ps = 1\n\ngoal (1 subgoal):\n 1. add_block b index ps = \\<B> index ps + 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  {#b#} index ps = 1\n\ngoal (1 subgoal):\n 1. add_block b index ps = \\<B> index ps + 1", "using split"], ["proof (prove)\nusing this:\n  {#b#} index ps = 1\n  add_block b index ps = {#b#} index ps + \\<B> index ps\n\ngoal (1 subgoal):\n 1. add_block b index ps = \\<B> index ps + 1", "by simp"], ["proof (state)\nthis:\n  add_block b index ps = \\<B> index ps + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_block_index_not_in: \"\\<not> (ps \\<subseteq> b) \\<Longrightarrow> (add_block b) index ps = \\<B> index ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> b \\<Longrightarrow>\n    add_block b index ps = \\<B> index ps", "using point_index_distrib points_index_singleton_zero"], ["proof (prove)\nusing this:\n  (?B1.0 + ?B2.0) index ?ps = ?B1.0 index ?ps + ?B2.0 index ?ps\n  \\<not> ?ps \\<subseteq> ?b \\<Longrightarrow> {#?b#} index ?ps = 0\n\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> b \\<Longrightarrow>\n    add_block b index ps = \\<B> index ps", "by (metis add.right_neutral add_block_def)"], ["", "text \\<open>Note the add block incidence system is defined slightly differently then textbook \ndefinitions due to the modification to the point set. This ensures the operation is closed, \nwhere otherwise a condition that $b \\subseteq \\mathcal{V}$ would be required.\\<close>"], ["", "lemma add_block_wf: \"incidence_system (\\<V> \\<union> b) (add_block b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system (\\<V> \\<union> b) (add_block b)", "using wellformed add_block_def"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n  add_block ?b \\<equiv> \\<B> + {#?b#}\n\ngoal (1 subgoal):\n 1. incidence_system (\\<V> \\<union> b) (add_block b)", "by (unfold_locales) auto"], ["", "lemma add_block_wf_cond: \"b \\<subseteq> \\<V> \\<Longrightarrow> incidence_system \\<V> (add_block b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<subseteq> \\<V> \\<Longrightarrow> incidence_system \\<V> (add_block b)", "using add_block_wf"], ["proof (prove)\nusing this:\n  incidence_system (\\<V> \\<union> ?b) (add_block ?b)\n\ngoal (1 subgoal):\n 1. b \\<subseteq> \\<V> \\<Longrightarrow> incidence_system \\<V> (add_block b)", "by (metis sup.order_iff)"], ["", "text \\<open>Delete block removes a block from the block set. The point set is unchanged\\<close>"], ["", "definition del_block :: \"'a set \\<Rightarrow> 'a set multiset\" where\n\"del_block b \\<equiv> \\<B> - {#b#}\""], ["", "lemma delete_block_subset: \"(del_block b) \\<subseteq># \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. del_block b \\<subseteq># \\<B>", "by (simp add: del_block_def)"], ["", "lemma delete_invalid_block_eq: \"b \\<notin># \\<B> \\<Longrightarrow> del_block b = \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin># \\<B> \\<Longrightarrow> del_block b = \\<B>", "by (simp add: del_block_def)"], ["", "lemma delete_block_wf: \"incidence_system \\<V> (del_block b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system \\<V> (del_block b)", "by (unfold_locales) (simp add: del_block_def in_diffD wellformed)"], ["", "text \\<open>The strong delete block operation effectively deletes the block, as well as \nall points in that block\\<close>"], ["", "definition str_del_block :: \"'a set \\<Rightarrow> 'a set multiset\" where\n\"str_del_block b \\<equiv> {# bl - b | bl \\<in># \\<B> . bl \\<noteq> b #}\""], ["", "lemma strong_del_block_alt_def: \"str_del_block b = {# bl - b . bl \\<in># removeAll_mset b \\<B> #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. str_del_block b = {#bl - b. bl \\<in># removeAll_mset b \\<B>#}", "by (simp add: filter_mset_neq str_del_block_def)"], ["", "lemma strong_del_block_wf: \"incidence_system (\\<V> - b) (str_del_block b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system (\\<V> - b) (str_del_block b)", "using wf_invalid_point str_del_block_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<notin> \\<V>; ?b \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> ?b\n  str_del_block ?b \\<equiv>\n  {#bl - ?b. bl \\<in># {#bl \\<in># \\<B>. bl \\<noteq> ?b#}#}\n\ngoal (1 subgoal):\n 1. incidence_system (\\<V> - b) (str_del_block b)", "by (unfold_locales) auto"], ["", "lemma str_del_block_del_point: \n  assumes \"{x} \\<notin># \\<B>\"\n  shows \"str_del_block {x} = (del_point_blocks x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. str_del_block {x} = del_point_blocks x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. str_del_block {x} = del_point_blocks x", "have neqx: \"\\<And> bl. bl \\<in># \\<B> \\<Longrightarrow> bl \\<noteq> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl. bl \\<in># \\<B> \\<Longrightarrow> bl \\<noteq> {x}", "using assms"], ["proof (prove)\nusing this:\n  {x} \\<notin># \\<B>\n\ngoal (1 subgoal):\n 1. \\<And>bl. bl \\<in># \\<B> \\<Longrightarrow> bl \\<noteq> {x}", "by auto"], ["proof (state)\nthis:\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {x}\n\ngoal (1 subgoal):\n 1. str_del_block {x} = del_point_blocks x", "have \"str_del_block {x} = {# bl - {x} | bl \\<in># \\<B> . bl \\<noteq> {x} #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. str_del_block {x} =\n    {#bl - {x}. bl \\<in># {#bl \\<in># \\<B>. bl \\<noteq> {x}#}#}", "by (simp add: str_del_block_def)"], ["proof (state)\nthis:\n  str_del_block {x} =\n  {#bl - {x}. bl \\<in># {#bl \\<in># \\<B>. bl \\<noteq> {x}#}#}\n\ngoal (1 subgoal):\n 1. str_del_block {x} = del_point_blocks x", "then"], ["proof (chain)\npicking this:\n  str_del_block {x} =\n  {#bl - {x}. bl \\<in># {#bl \\<in># \\<B>. bl \\<noteq> {x}#}#}", "have \"str_del_block {x} = {# bl - {x} . bl \\<in># \\<B> #}\""], ["proof (prove)\nusing this:\n  str_del_block {x} =\n  {#bl - {x}. bl \\<in># {#bl \\<in># \\<B>. bl \\<noteq> {x}#}#}\n\ngoal (1 subgoal):\n 1. str_del_block {x} = {#bl - {x}. bl \\<in># \\<B>#}", "using assms neqx"], ["proof (prove)\nusing this:\n  str_del_block {x} =\n  {#bl - {x}. bl \\<in># {#bl \\<in># \\<B>. bl \\<noteq> {x}#}#}\n  {x} \\<notin># \\<B>\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {x}\n\ngoal (1 subgoal):\n 1. str_del_block {x} = {#bl - {x}. bl \\<in># \\<B>#}", "by (simp add: filter_mset_cong)"], ["proof (state)\nthis:\n  str_del_block {x} = {#bl - {x}. bl \\<in># \\<B>#}\n\ngoal (1 subgoal):\n 1. str_del_block {x} = del_point_blocks x", "thus ?thesis"], ["proof (prove)\nusing this:\n  str_del_block {x} = {#bl - {x}. bl \\<in># \\<B>#}\n\ngoal (1 subgoal):\n 1. str_del_block {x} = del_point_blocks x", "by (simp add: del_point_blocks_def)"], ["proof (state)\nthis:\n  str_del_block {x} = del_point_blocks x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Incidence System Interpretations\\<close>"], ["", "text \\<open>It is easy to interpret all operations as incidence systems in there own right. \nThese can then be used to prove local properties on the new constructions, as well \nas reason on interactions between different operation sequences\\<close>"], ["", "interpretation add_point_sys: incidence_system \"add_point p\" \"\\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system (add_point p) \\<B>", "using add_point_wf"], ["proof (prove)\nusing this:\n  incidence_system (add_point ?p) \\<B>\n\ngoal (1 subgoal):\n 1. incidence_system (add_point p) \\<B>", "by simp"], ["", "lemma add_point_sys_rep_numbers: \"add_point_sys.replication_numbers p = \n    replication_numbers \\<union> {\\<B> rep p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_point_sys.replication_numbers p =\n    replication_numbers \\<union> {\\<B> rep p}", "using add_point_sys.replication_numbers_def replication_numbers_def add_point_def"], ["proof (prove)\nusing this:\n  add_point_sys.replication_numbers ?p \\<equiv>\n  {\\<B> rep x |x. x \\<in> add_point ?p}\n  replication_numbers \\<equiv> {\\<B> rep x |x. x \\<in> \\<V>}\n  add_point ?p \\<equiv> insert ?p \\<V>\n\ngoal (1 subgoal):\n 1. add_point_sys.replication_numbers p =\n    replication_numbers \\<union> {\\<B> rep p}", "by auto"], ["", "interpretation del_point_sys: incidence_system \"del_point p\" \"del_point_blocks p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system (del_point p) (add_point_sys.del_point_blocks p)", "using delete_point_wf"], ["proof (prove)\nusing this:\n  incidence_system (del_point ?p) (add_point_sys.del_point_blocks ?p)\n\ngoal (1 subgoal):\n 1. incidence_system (del_point p) (add_point_sys.del_point_blocks p)", "by auto"], ["", "interpretation add_block_sys: incidence_system \"\\<V> \\<union> bl\" \"add_block bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system (\\<V> \\<union> bl) (add_point_sys.add_block bl)", "using add_block_wf"], ["proof (prove)\nusing this:\n  incidence_system (\\<V> \\<union> ?b) (add_point_sys.add_block ?b)\n\ngoal (1 subgoal):\n 1. incidence_system (\\<V> \\<union> bl) (add_point_sys.add_block bl)", "by simp"], ["", "interpretation del_block_sys: incidence_system \"\\<V>\" \"del_block bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system \\<V> (add_point_sys.del_block bl)", "using delete_block_wf"], ["proof (prove)\nusing this:\n  incidence_system \\<V> (add_point_sys.del_block ?b)\n\ngoal (1 subgoal):\n 1. incidence_system \\<V> (add_point_sys.del_block bl)", "by simp"], ["", "lemma add_del_block_inv: \n  assumes \"bl \\<subseteq> \\<V>\"\n  shows \"add_block_sys.del_block bl bl = \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_block_sys.del_block bl bl = \\<B>", "using add_block_sys.del_block_def add_block_def"], ["proof (prove)\nusing this:\n  add_block_sys.del_block ?bl ?b \\<equiv>\n  remove1_mset ?b (add_point_sys.add_block ?bl)\n  add_point_sys.add_block ?b \\<equiv> \\<B> + {#?b#}\n\ngoal (1 subgoal):\n 1. add_block_sys.del_block bl bl = \\<B>", "by simp"], ["", "lemma del_add_block_inv: \"bl \\<in># \\<B> \\<Longrightarrow> del_block_sys.add_block bl bl = \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> del_block_sys.add_block bl bl = \\<B>", "using del_block_sys.add_block_def del_block_def wellformed"], ["proof (prove)\nusing this:\n  del_block_sys.add_block ?bl ?b \\<equiv>\n  add_point_sys.del_block ?bl + {#?b#}\n  add_point_sys.del_block ?b \\<equiv> remove1_mset ?b \\<B>\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> del_block_sys.add_block bl bl = \\<B>", "by fastforce"], ["", "lemma del_invalid_add_block_eq: \"bl \\<notin># \\<B> \\<Longrightarrow> del_block_sys.add_block bl bl = add_block bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<notin># \\<B> \\<Longrightarrow>\n    del_block_sys.add_block bl bl = add_point_sys.add_block bl", "using del_block_sys.add_block_def"], ["proof (prove)\nusing this:\n  del_block_sys.add_block ?bl ?b \\<equiv>\n  add_point_sys.del_block ?bl + {#?b#}\n\ngoal (1 subgoal):\n 1. bl \\<notin># \\<B> \\<Longrightarrow>\n    del_block_sys.add_block bl bl = add_point_sys.add_block bl", "by (simp add: delete_invalid_block_eq)"], ["", "lemma add_delete_point_inv: \n  assumes \"p \\<notin> \\<V>\"\n  shows \"add_point_sys.del_point p p = \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_point_sys.del_point p p = \\<V>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. add_point_sys.del_point p p = \\<V>", "have \"(add_point_sys.del_point p p) = (insert p \\<V>) - {p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_point_sys.del_point p p = insert p \\<V> - {p}", "using add_point_sys.del_point_def del_block_sys.add_point_def"], ["proof (prove)\nusing this:\n  add_point_sys.del_point ?pa ?p \\<equiv> del_block_sys.add_point ?pa - {?p}\n  del_block_sys.add_point ?p \\<equiv> insert ?p \\<V>\n\ngoal (1 subgoal):\n 1. add_point_sys.del_point p p = insert p \\<V> - {p}", "by auto"], ["proof (state)\nthis:\n  add_point_sys.del_point p p = insert p \\<V> - {p}\n\ngoal (1 subgoal):\n 1. add_point_sys.del_point p p = \\<V>", "thus ?thesis"], ["proof (prove)\nusing this:\n  add_point_sys.del_point p p = insert p \\<V> - {p}\n\ngoal (1 subgoal):\n 1. add_point_sys.del_point p p = \\<V>", "by (simp add: assms)"], ["proof (state)\nthis:\n  add_point_sys.del_point p p = \\<V>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Operation Closure for Designs\\<close>"], ["", "context finite_incidence_system \nbegin"], ["", "lemma add_point_finite: \"finite_incidence_system (add_point p) \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system (add_point p) \\<B>", "using add_point_wf finite_sets add_point_def"], ["proof (prove)\nusing this:\n  incidence_system (add_point ?p) \\<B>\n  finite \\<V>\n  add_point ?p \\<equiv> insert ?p \\<V>\n\ngoal (1 subgoal):\n 1. finite_incidence_system (add_point p) \\<B>", "by (unfold_locales) (simp_all add: incidence_system_def)"], ["", "lemma add_point_to_blocks_finite: \"finite_incidence_system (add_point p) (add_point_to_blocks p bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system (add_point p) (add_point_to_blocks p bs)", "using add_point_blocks_wf add_point_finite finite_incidence_system.finite_sets \n    incidence_system.finite_sysI"], ["proof (prove)\nusing this:\n  incidence_system (add_point ?p) (add_point_to_blocks ?p ?bs)\n  finite_incidence_system (add_point ?p) \\<B>\n  finite_incidence_system ?point_set ?block_collection \\<Longrightarrow>\n  finite ?point_set\n  \\<lbrakk>incidence_system ?point_set ?block_collection;\n   finite ?point_set\\<rbrakk>\n  \\<Longrightarrow> finite_incidence_system ?point_set ?block_collection\n\ngoal (1 subgoal):\n 1. finite_incidence_system (add_point p) (add_point_to_blocks p bs)", "by blast"], ["", "lemma delete_point_finite: \n    \"finite_incidence_system (del_point p) (del_point_blocks p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system (del_point p) (del_point_blocks p)", "using finite_sets delete_point_wf"], ["proof (prove)\nusing this:\n  finite \\<V>\n  incidence_system (del_point ?p) (del_point_blocks ?p)\n\ngoal (1 subgoal):\n 1. finite_incidence_system (del_point p) (del_point_blocks p)", "by (unfold_locales) (simp_all add: incidence_system_def del_point_def)"], ["", "lemma del_point_order: \n  assumes \"p \\<in> \\<V>\"\n  shows \"card (del_point p) = \\<v> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (del_point p)) = \\<v> - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (card (del_point p)) = \\<v> - 1", "have vg0: \"card \\<V> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card \\<V>", "using assms finite_sets card_gt_0_iff"], ["proof (prove)\nusing this:\n  p \\<in> \\<V>\n  finite \\<V>\n  (0 < card ?A) = (?A \\<noteq> {} \\<and> finite ?A)\n\ngoal (1 subgoal):\n 1. 0 < card \\<V>", "by auto"], ["proof (state)\nthis:\n  0 < card \\<V>\n\ngoal (1 subgoal):\n 1. int (card (del_point p)) = \\<v> - 1", "then"], ["proof (chain)\npicking this:\n  0 < card \\<V>", "have \"card (del_point p) = card \\<V> - 1\""], ["proof (prove)\nusing this:\n  0 < card \\<V>\n\ngoal (1 subgoal):\n 1. card (del_point p) = card \\<V> - 1", "using assms del_point_def"], ["proof (prove)\nusing this:\n  0 < card \\<V>\n  p \\<in> \\<V>\n  del_point ?p \\<equiv> \\<V> - {?p}\n\ngoal (1 subgoal):\n 1. card (del_point p) = card \\<V> - 1", "by (metis card_Diff_singleton finite_sets)"], ["proof (state)\nthis:\n  card (del_point p) = card \\<V> - 1\n\ngoal (1 subgoal):\n 1. int (card (del_point p)) = \\<v> - 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  card (del_point p) = card \\<V> - 1\n\ngoal (1 subgoal):\n 1. int (card (del_point p)) = \\<v> - 1", "using vg0"], ["proof (prove)\nusing this:\n  card (del_point p) = card \\<V> - 1\n  0 < card \\<V>\n\ngoal (1 subgoal):\n 1. int (card (del_point p)) = \\<v> - 1", "by linarith"], ["proof (state)\nthis:\n  int (card (del_point p)) = \\<v> - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strong_del_point_finite:\"finite_incidence_system (del_point p) (str_del_point_blocks p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system (del_point p) (str_del_point_blocks p)", "using strong_del_point_incidence_wf del_point_def"], ["proof (prove)\nusing this:\n  incidence_system (del_point ?p) (str_del_point_blocks ?p)\n  del_point ?p \\<equiv> \\<V> - {?p}\n\ngoal (1 subgoal):\n 1. finite_incidence_system (del_point p) (str_del_point_blocks p)", "by (intro_locales) (simp_all add: finite_incidence_system_axioms_def finite_sets)"], ["", "lemma add_block_fin: \"finite b \\<Longrightarrow> finite_incidence_system (\\<V> \\<union> b) (add_block b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite b \\<Longrightarrow>\n    finite_incidence_system (\\<V> \\<union> b) (add_block b)", "using wf_invalid_point finite_sets add_block_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<notin> \\<V>; ?b \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> ?b\n  finite \\<V>\n  add_block ?b \\<equiv> \\<B> + {#?b#}\n\ngoal (1 subgoal):\n 1. finite b \\<Longrightarrow>\n    finite_incidence_system (\\<V> \\<union> b) (add_block b)", "by (unfold_locales) auto"], ["", "lemma add_block_fin_cond: \"b \\<subseteq> \\<V> \\<Longrightarrow> finite_incidence_system \\<V> (add_block b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<subseteq> \\<V> \\<Longrightarrow>\n    finite_incidence_system \\<V> (add_block b)", "using add_block_wf_cond finite_incidence_system_axioms.intro finite_sets"], ["proof (prove)\nusing this:\n  ?b \\<subseteq> \\<V> \\<Longrightarrow> incidence_system \\<V> (add_block ?b)\n  finite ?point_set \\<Longrightarrow>\n  finite_incidence_system_axioms ?point_set\n  finite \\<V>\n\ngoal (1 subgoal):\n 1. b \\<subseteq> \\<V> \\<Longrightarrow>\n    finite_incidence_system \\<V> (add_block b)", "by (intro_locales) (simp_all)"], ["", "lemma delete_block_fin_incidence_sys: \"finite_incidence_system \\<V> (del_block b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> (del_block b)", "using delete_block_wf finite_sets"], ["proof (prove)\nusing this:\n  incidence_system \\<V> (del_block ?b)\n  finite \\<V>\n\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> (del_block b)", "by (unfold_locales) (simp_all add: incidence_system_def)"], ["", "lemma strong_del_block_fin: \"finite_incidence_system (\\<V> - b) (str_del_block b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system (\\<V> - b) (str_del_block b)", "using strong_del_block_wf finite_sets finite_incidence_system_axioms_def"], ["proof (prove)\nusing this:\n  incidence_system (\\<V> - ?b) (str_del_block ?b)\n  finite \\<V>\n  finite_incidence_system_axioms ?point_set \\<equiv> finite ?point_set\n\ngoal (1 subgoal):\n 1. finite_incidence_system (\\<V> - b) (str_del_block b)", "by (intro_locales) auto"], ["", "end"], ["", "context design\nbegin"], ["", "lemma add_point_design: \"design (add_point p) \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design (add_point p) \\<B>", "using add_point_wf finite_sets blocks_nempty add_point_def"], ["proof (prove)\nusing this:\n  incidence_system (add_point ?p) \\<B>\n  finite \\<V>\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {}\n  add_point ?p \\<equiv> insert ?p \\<V>\n\ngoal (1 subgoal):\n 1. design (add_point p) \\<B>", "by (unfold_locales) (auto simp add: incidence_system_def)"], ["", "lemma delete_point_design: \n  assumes \"(\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> p \\<in> bl \\<Longrightarrow> card bl \\<ge> 2)\"\n  shows \"design (del_point p) (del_point_blocks p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design (del_point p) (del_point_blocks p)", "proof (cases \"p \\<in> \\<V>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<in> \\<V> \\<Longrightarrow> design (del_point p) (del_point_blocks p)\n 2. p \\<notin> \\<V> \\<Longrightarrow>\n    design (del_point p) (del_point_blocks p)", "case True"], ["proof (state)\nthis:\n  p \\<in> \\<V>\n\ngoal (2 subgoals):\n 1. p \\<in> \\<V> \\<Longrightarrow> design (del_point p) (del_point_blocks p)\n 2. p \\<notin> \\<V> \\<Longrightarrow>\n    design (del_point p) (del_point_blocks p)", "interpret fis: finite_incidence_system \"(del_point p)\" \"(del_point_blocks p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system (del_point p) (del_point_blocks p)", "using delete_point_finite"], ["proof (prove)\nusing this:\n  finite_incidence_system (del_point ?p) (del_point_blocks ?p)\n\ngoal (1 subgoal):\n 1. finite_incidence_system (del_point p) (del_point_blocks p)", "by simp"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<in> \\<V> \\<Longrightarrow> design (del_point p) (del_point_blocks p)\n 2. p \\<notin> \\<V> \\<Longrightarrow>\n    design (del_point p) (del_point_blocks p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. design (del_point p) (del_point_blocks p)", "proof (unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bl. bl \\<in># del_point_blocks p \\<Longrightarrow> bl \\<noteq> {}", "show \"\\<And>bl. bl \\<in># (del_point_blocks p) \\<Longrightarrow> bl \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl. bl \\<in># del_point_blocks p \\<Longrightarrow> bl \\<noteq> {}", "using assms del_point_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?bl \\<in># \\<B>; p \\<in> ?bl\\<rbrakk>\n  \\<Longrightarrow> 2 \\<le> card ?bl\n  del_point ?p \\<equiv> \\<V> - {?p}\n\ngoal (1 subgoal):\n 1. \\<And>bl. bl \\<in># del_point_blocks p \\<Longrightarrow> bl \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bl.\n       \\<lbrakk>bl \\<in># del_point_blocks p;\n        \\<And>bl.\n           \\<lbrakk>bl \\<in># \\<B>; p \\<in> bl\\<rbrakk>\n           \\<Longrightarrow> 2 \\<le> card bl;\n        \\<And>p. del_point p \\<equiv> \\<V> - {p}\\<rbrakk>\n       \\<Longrightarrow> bl \\<noteq> {}", "fix bl"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bl.\n       \\<lbrakk>bl \\<in># del_point_blocks p;\n        \\<And>bl.\n           \\<lbrakk>bl \\<in># \\<B>; p \\<in> bl\\<rbrakk>\n           \\<Longrightarrow> 2 \\<le> card bl;\n        \\<And>p. del_point p \\<equiv> \\<V> - {p}\\<rbrakk>\n       \\<Longrightarrow> bl \\<noteq> {}", "assume \"bl \\<in>#(del_point_blocks p)\""], ["proof (state)\nthis:\n  bl \\<in># del_point_blocks p\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       \\<lbrakk>bl \\<in># del_point_blocks p;\n        \\<And>bl.\n           \\<lbrakk>bl \\<in># \\<B>; p \\<in> bl\\<rbrakk>\n           \\<Longrightarrow> 2 \\<le> card bl;\n        \\<And>p. del_point p \\<equiv> \\<V> - {p}\\<rbrakk>\n       \\<Longrightarrow> bl \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  bl \\<in># del_point_blocks p", "obtain bl' where block: \"bl' \\<in># \\<B>\" and rem: \"bl = bl' - {p}\""], ["proof (prove)\nusing this:\n  bl \\<in># del_point_blocks p\n\ngoal (1 subgoal):\n 1. (\\<And>bl'.\n        \\<lbrakk>bl' \\<in># \\<B>; bl = bl' - {p}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: del_point_blocks_def)"], ["proof (state)\nthis:\n  bl' \\<in># \\<B>\n  bl = bl' - {p}\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       \\<lbrakk>bl \\<in># del_point_blocks p;\n        \\<And>bl.\n           \\<lbrakk>bl \\<in># \\<B>; p \\<in> bl\\<rbrakk>\n           \\<Longrightarrow> 2 \\<le> card bl;\n        \\<And>p. del_point p \\<equiv> \\<V> - {p}\\<rbrakk>\n       \\<Longrightarrow> bl \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  bl' \\<in># \\<B>\n  bl = bl' - {p}", "have eq: \"p \\<notin> bl' \\<Longrightarrow> bl \\<noteq> {}\""], ["proof (prove)\nusing this:\n  bl' \\<in># \\<B>\n  bl = bl' - {p}\n\ngoal (1 subgoal):\n 1. p \\<notin> bl' \\<Longrightarrow> bl \\<noteq> {}", "using block blocks_nempty"], ["proof (prove)\nusing this:\n  bl' \\<in># \\<B>\n  bl = bl' - {p}\n  bl' \\<in># \\<B>\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p \\<notin> bl' \\<Longrightarrow> bl \\<noteq> {}", "by (simp add: rem)"], ["proof (state)\nthis:\n  p \\<notin> bl' \\<Longrightarrow> bl \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       \\<lbrakk>bl \\<in># del_point_blocks p;\n        \\<And>bl.\n           \\<lbrakk>bl \\<in># \\<B>; p \\<in> bl\\<rbrakk>\n           \\<Longrightarrow> 2 \\<le> card bl;\n        \\<And>p. del_point p \\<equiv> \\<V> - {p}\\<rbrakk>\n       \\<Longrightarrow> bl \\<noteq> {}", "have \"p \\<in> bl' \\<Longrightarrow> card bl \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> bl' \\<Longrightarrow> 1 \\<le> card bl", "using rem finite_blocks block assms block"], ["proof (prove)\nusing this:\n  bl = bl' - {p}\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n  bl' \\<in># \\<B>\n  \\<lbrakk>?bl \\<in># \\<B>; p \\<in> ?bl\\<rbrakk>\n  \\<Longrightarrow> 2 \\<le> card ?bl\n  bl' \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. p \\<in> bl' \\<Longrightarrow> 1 \\<le> card bl", "by fastforce"], ["proof (state)\nthis:\n  p \\<in> bl' \\<Longrightarrow> 1 \\<le> card bl\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       \\<lbrakk>bl \\<in># del_point_blocks p;\n        \\<And>bl.\n           \\<lbrakk>bl \\<in># \\<B>; p \\<in> bl\\<rbrakk>\n           \\<Longrightarrow> 2 \\<le> card bl;\n        \\<And>p. del_point p \\<equiv> \\<V> - {p}\\<rbrakk>\n       \\<Longrightarrow> bl \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  p \\<in> bl' \\<Longrightarrow> 1 \\<le> card bl", "show \"bl \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<in> bl' \\<Longrightarrow> 1 \\<le> card bl\n\ngoal (1 subgoal):\n 1. bl \\<noteq> {}", "using  eq assms"], ["proof (prove)\nusing this:\n  p \\<in> bl' \\<Longrightarrow> 1 \\<le> card bl\n  p \\<notin> bl' \\<Longrightarrow> bl \\<noteq> {}\n  \\<lbrakk>?bl \\<in># \\<B>; p \\<in> ?bl\\<rbrakk>\n  \\<Longrightarrow> 2 \\<le> card ?bl\n\ngoal (1 subgoal):\n 1. bl \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  bl \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?bl \\<in># del_point_blocks p \\<Longrightarrow> ?bl \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  design (del_point p) (del_point_blocks p)\n\ngoal (1 subgoal):\n 1. p \\<notin> \\<V> \\<Longrightarrow>\n    design (del_point p) (del_point_blocks p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<notin> \\<V> \\<Longrightarrow>\n    design (del_point p) (del_point_blocks p)", "case False"], ["proof (state)\nthis:\n  p \\<notin> \\<V>\n\ngoal (1 subgoal):\n 1. p \\<notin> \\<V> \\<Longrightarrow>\n    design (del_point p) (del_point_blocks p)", "then"], ["proof (chain)\npicking this:\n  p \\<notin> \\<V>", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<notin> \\<V>\n\ngoal (1 subgoal):\n 1. design (del_point p) (del_point_blocks p)", "using del_invalid_point del_invalid_point_blocks"], ["proof (prove)\nusing this:\n  p \\<notin> \\<V>\n  ?p \\<notin> \\<V> \\<Longrightarrow> del_point ?p = \\<V>\n  ?p \\<notin> \\<V> \\<Longrightarrow> del_point_blocks ?p = \\<B>\n\ngoal (1 subgoal):\n 1. design (del_point p) (del_point_blocks p)", "by (simp add: wf_design)"], ["proof (state)\nthis:\n  design (del_point p) (del_point_blocks p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strong_del_point_design: \"design (del_point p) (str_del_point_blocks p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design (del_point p) (str_del_point_blocks p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. design (del_point p) (str_del_point_blocks p)", "interpret fin: finite_incidence_system \"(del_point p)\" \"(str_del_point_blocks p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system (del_point p) (str_del_point_blocks p)", "using strong_del_point_finite"], ["proof (prove)\nusing this:\n  finite_incidence_system (del_point ?p) (str_del_point_blocks ?p)\n\ngoal (1 subgoal):\n 1. finite_incidence_system (del_point p) (str_del_point_blocks p)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. design (del_point p) (str_del_point_blocks p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. design (del_point p) (str_del_point_blocks p)", "using wf_design wf_design_iff del_point_def str_del_point_blocks_def"], ["proof (prove)\nusing this:\n  design \\<V> \\<B>\n  ?bl \\<in># \\<B> \\<Longrightarrow>\n  design \\<V> \\<B> =\n  (?bl \\<subseteq> \\<V> \\<and> finite \\<V> \\<and> ?bl \\<noteq> {})\n  del_point ?p \\<equiv> \\<V> - {?p}\n  str_del_point_blocks ?p \\<equiv> filter_mset ((\\<notin>) ?p) \\<B>\n\ngoal (1 subgoal):\n 1. design (del_point p) (str_del_point_blocks p)", "by (unfold_locales) (auto)"], ["proof (state)\nthis:\n  design (del_point p) (str_del_point_blocks p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_block_design: \n  assumes \"finite bl\" \n  assumes \"bl \\<noteq> {}\" \n  shows \"design (\\<V> \\<union> bl) (add_block bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design (\\<V> \\<union> bl) (add_block bl)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. design (\\<V> \\<union> bl) (add_block bl)", "interpret fin: finite_incidence_system \"(\\<V> \\<union> bl)\" \"(add_block bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system (\\<V> \\<union> bl) (add_block bl)", "using add_block_fin assms"], ["proof (prove)\nusing this:\n  finite ?b \\<Longrightarrow>\n  finite_incidence_system (\\<V> \\<union> ?b) (add_block ?b)\n  finite bl\n  bl \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite_incidence_system (\\<V> \\<union> bl) (add_block bl)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. design (\\<V> \\<union> bl) (add_block bl)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. design (\\<V> \\<union> bl) (add_block bl)", "using blocks_nempty assms add_block_def"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {}\n  finite bl\n  bl \\<noteq> {}\n  add_block ?b \\<equiv> \\<B> + {#?b#}\n\ngoal (1 subgoal):\n 1. design (\\<V> \\<union> bl) (add_block bl)", "by (unfold_locales) auto"], ["proof (state)\nthis:\n  design (\\<V> \\<union> bl) (add_block bl)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_block_design_cond: \n  assumes \"bl \\<subseteq> \\<V>\" and \"bl \\<noteq> {}\"\n  shows \"design \\<V> (add_block bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design \\<V> (add_block bl)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. design \\<V> (add_block bl)", "interpret fin: finite_incidence_system \"\\<V>\" \"(add_block bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> (add_block bl)", "using add_block_fin_cond assms"], ["proof (prove)\nusing this:\n  ?b \\<subseteq> \\<V> \\<Longrightarrow>\n  finite_incidence_system \\<V> (add_block ?b)\n  bl \\<subseteq> \\<V>\n  bl \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> (add_block bl)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. design \\<V> (add_block bl)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. design \\<V> (add_block bl)", "using blocks_nempty assms add_block_def"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {}\n  bl \\<subseteq> \\<V>\n  bl \\<noteq> {}\n  add_block ?b \\<equiv> \\<B> + {#?b#}\n\ngoal (1 subgoal):\n 1. design \\<V> (add_block bl)", "by (unfold_locales) auto"], ["proof (state)\nthis:\n  design \\<V> (add_block bl)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_block_design: \"design \\<V> (del_block bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design \\<V> (del_block bl)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. design \\<V> (del_block bl)", "interpret fin: finite_incidence_system \\<V> \"(del_block bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> (del_block bl)", "using delete_block_fin_incidence_sys"], ["proof (prove)\nusing this:\n  finite_incidence_system \\<V> (del_block ?b)\n\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V> (del_block bl)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. design \\<V> (del_block bl)", "have \"\\<And> b . b \\<in># (del_block bl) \\<Longrightarrow> b \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. b \\<in># del_block bl \\<Longrightarrow> b \\<noteq> {}", "using blocks_nempty delete_block_subset"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {}\n  del_block ?b \\<subseteq># \\<B>\n\ngoal (1 subgoal):\n 1. \\<And>b. b \\<in># del_block bl \\<Longrightarrow> b \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  ?b \\<in># del_block bl \\<Longrightarrow> ?b \\<noteq> {}\n\ngoal (1 subgoal):\n 1. design \\<V> (del_block bl)", "then"], ["proof (chain)\npicking this:\n  ?b \\<in># del_block bl \\<Longrightarrow> ?b \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?b \\<in># del_block bl \\<Longrightarrow> ?b \\<noteq> {}\n\ngoal (1 subgoal):\n 1. design \\<V> (del_block bl)", "by (unfold_locales) (simp_all)"], ["proof (state)\nthis:\n  design \\<V> (del_block bl)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strong_del_block_des: \n  assumes \"\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> \\<not> (bl \\<subset> b)\"\n  shows \"design (\\<V> - b) (str_del_block b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design (\\<V> - b) (str_del_block b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. design (\\<V> - b) (str_del_block b)", "interpret fin: finite_incidence_system \"\\<V> - b\" \"(str_del_block b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system (\\<V> - b) (str_del_block b)", "using strong_del_block_fin"], ["proof (prove)\nusing this:\n  finite_incidence_system (\\<V> - ?b) (str_del_block ?b)\n\ngoal (1 subgoal):\n 1. finite_incidence_system (\\<V> - b) (str_del_block b)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. design (\\<V> - b) (str_del_block b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. design (\\<V> - b) (str_del_block b)", "using assms str_del_block_def"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> \\<not> ?bl \\<subset> b\n  str_del_block ?b \\<equiv>\n  {#bl - ?b. bl \\<in># {#bl \\<in># \\<B>. bl \\<noteq> ?b#}#}\n\ngoal (1 subgoal):\n 1. design (\\<V> - b) (str_del_block b)", "by (unfold_locales) auto"], ["proof (state)\nthis:\n  design (\\<V> - b) (str_del_block b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context proper_design\nbegin"], ["", "lemma delete_point_proper: \n  assumes \"\\<And>bl. bl \\<in># \\<B> \\<Longrightarrow> p \\<in> bl \\<Longrightarrow> 2 \\<le> card bl\"\n  shows \"proper_design (del_point p) (del_point_blocks p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design (del_point p) (del_point_blocks p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design (del_point p) (del_point_blocks p)", "interpret des: design \"del_point p\" \"del_point_blocks p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design (del_point p) (del_point_blocks p)", "using delete_point_design assms"], ["proof (prove)\nusing this:\n  (\\<And>bl.\n      \\<lbrakk>bl \\<in># \\<B>; ?p \\<in> bl\\<rbrakk>\n      \\<Longrightarrow> 2 \\<le> card bl) \\<Longrightarrow>\n  design (del_point ?p) (del_point_blocks ?p)\n  \\<lbrakk>?bl \\<in># \\<B>; p \\<in> ?bl\\<rbrakk>\n  \\<Longrightarrow> 2 \\<le> card ?bl\n\ngoal (1 subgoal):\n 1. design (del_point p) (del_point_blocks p)", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design (del_point p) (del_point_blocks p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design (del_point p) (del_point_blocks p)", "using design_blocks_nempty del_point_def del_point_blocks_def"], ["proof (prove)\nusing this:\n  \\<B> \\<noteq> {#}\n  del_point ?p \\<equiv> \\<V> - {?p}\n  del_point_blocks ?p \\<equiv> {#bl - {?p}. bl \\<in># \\<B>#}\n\ngoal (1 subgoal):\n 1. proper_design (del_point p) (del_point_blocks p)", "by (unfold_locales) simp"], ["proof (state)\nthis:\n  proper_design (del_point p) (del_point_blocks p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strong_delete_point_proper: \n  assumes \"\\<And>bl. bl \\<in># \\<B> \\<Longrightarrow> p \\<in> bl \\<Longrightarrow> 2 \\<le> card bl\"\n  assumes \"\\<B> rep p < \\<b>\"\n  shows \"proper_design (del_point p) (str_del_point_blocks p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design (del_point p) (str_del_point_blocks p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design (del_point p) (str_del_point_blocks p)", "interpret des: design \"del_point p\" \"str_del_point_blocks p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design (del_point p) (str_del_point_blocks p)", "using strong_del_point_design assms"], ["proof (prove)\nusing this:\n  design (del_point ?p) (str_del_point_blocks ?p)\n  \\<lbrakk>?bl \\<in># \\<B>; p \\<in> ?bl\\<rbrakk>\n  \\<Longrightarrow> 2 \\<le> card ?bl\n  \\<B> rep p < \\<b>\n\ngoal (1 subgoal):\n 1. design (del_point p) (str_del_point_blocks p)", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design (del_point p) (str_del_point_blocks p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design (del_point p) (str_del_point_blocks p)", "using assms design_blocks_nempty point_rep_num_inv_non_empty \n    str_del_point_blocks_def del_point_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?bl \\<in># \\<B>; p \\<in> ?bl\\<rbrakk>\n  \\<Longrightarrow> 2 \\<le> card ?bl\n  \\<B> rep p < \\<b>\n  \\<B> \\<noteq> {#}\n  \\<lbrakk>\\<B> rep ?x < \\<b>; \\<B> \\<noteq> {#}\\<rbrakk>\n  \\<Longrightarrow> filter_mset ((\\<notin>) ?x) \\<B> \\<noteq> {#}\n  str_del_point_blocks ?p \\<equiv> filter_mset ((\\<notin>) ?p) \\<B>\n  del_point ?p \\<equiv> \\<V> - {?p}\n\ngoal (1 subgoal):\n 1. proper_design (del_point p) (str_del_point_blocks p)", "by (unfold_locales) simp"], ["proof (state)\nthis:\n  proper_design (del_point p) (str_del_point_blocks p)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Combining Set Systems\\<close>"], ["", "text \\<open>Similar to multiple, another way to construct a new set system is to combine two existing ones.\nWe introduce a new locale enabling us to reason on two different incidence systems\\<close>"], ["", "locale two_set_systems = sys1: incidence_system \\<V> \\<B> + sys2: incidence_system \\<V>' \\<B>'\n  for \\<V> :: \"('a set)\" and \\<B> and \\<V>' :: \"('a set)\" and \\<B>'\nbegin"], ["", "abbreviation \"combine_points \\<equiv> \\<V> \\<union> \\<V>'\""], ["", "notation combine_points (\"\\<V>\\<^sup>+\")"], ["", "abbreviation \"combine_blocks \\<equiv> \\<B> + \\<B>'\""], ["", "notation combine_blocks (\"\\<B>\\<^sup>+\")"], ["", "sublocale combine_sys: incidence_system \"\\<V>\\<^sup>+\" \"\\<B>\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system \\<V>\\<^sup>+ \\<B>\\<^sup>+", "using sys1.wellformed sys2.wellformed"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n  ?b \\<in># \\<B>' \\<Longrightarrow> ?b \\<subseteq> \\<V>'\n\ngoal (1 subgoal):\n 1. incidence_system \\<V>\\<^sup>+ \\<B>\\<^sup>+", "by (unfold_locales) auto"], ["", "lemma combine_points_index: \"\\<B>\\<^sup>+ index ps = \\<B> index ps  + \\<B>' index ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>+ index ps = \\<B> index ps + \\<B>' index ps", "by (simp add: point_index_distrib)"], ["", "lemma combine_rep_number: \"\\<B>\\<^sup>+ rep x = \\<B> rep x + \\<B>' rep x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>+ rep x = \\<B> rep x + \\<B>' rep x", "by (simp add: point_replication_number_def)"], ["", "lemma combine_multiple1: \"\\<V> = \\<V>' \\<Longrightarrow> \\<B> = \\<B>' \\<Longrightarrow> \\<B>\\<^sup>+ = sys1.multiple_blocks 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<V> = \\<V>'; \\<B> = \\<B>'\\<rbrakk>\n    \\<Longrightarrow> \\<B>\\<^sup>+ = sys1.multiple_blocks 2", "by auto"], ["", "lemma combine_multiple2: \"\\<V> = \\<V>' \\<Longrightarrow> \\<B> = \\<B>' \\<Longrightarrow> \\<B>\\<^sup>+ = sys2.multiple_blocks 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<V> = \\<V>'; \\<B> = \\<B>'\\<rbrakk>\n    \\<Longrightarrow> \\<B>\\<^sup>+ = sys2.multiple_blocks 2", "by auto"], ["", "lemma combine_multiplicity: \"combine_sys.multiplicity b = sys1.multiplicity b + sys2.multiplicity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. combine_sys.multiplicity b = sys1.multiplicity b + sys2.multiplicity b", "by simp"], ["", "lemma combine_block_sizes: \"combine_sys.sys_block_sizes = \n    sys1.sys_block_sizes \\<union> sys2.sys_block_sizes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. combine_sys.sys_block_sizes =\n    sys1.sys_block_sizes \\<union> sys2.sys_block_sizes", "using sys1.sys_block_sizes_def sys2.sys_block_sizes_def combine_sys.sys_block_sizes_def"], ["proof (prove)\nusing this:\n  sys1.sys_block_sizes \\<equiv> {int (card bl) |bl. bl \\<in># \\<B>}\n  sys2.sys_block_sizes \\<equiv> {int (card bl) |bl. bl \\<in># \\<B>'}\n  combine_sys.sys_block_sizes \\<equiv>\n  {int (card bl) |bl. bl \\<in># \\<B>\\<^sup>+}\n\ngoal (1 subgoal):\n 1. combine_sys.sys_block_sizes =\n    sys1.sys_block_sizes \\<union> sys2.sys_block_sizes", "by (auto)"], ["", "end"], ["", "locale two_fin_set_systems = two_set_systems \\<V> \\<B> \\<V>' \\<B>' + sys1: finite_incidence_system \\<V> \\<B> + \n  sys2: finite_incidence_system \\<V>' \\<B>' for \\<V> \\<B> \\<V>' \\<B>'\nbegin"], ["", "sublocale combine_fin_sys: finite_incidence_system \"\\<V>\\<^sup>+\" \"\\<B>\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V>\\<^sup>+ \\<B>\\<^sup>+", "using sys1.finite_sets sys2.finite_sets"], ["proof (prove)\nusing this:\n  finite \\<V>\n  finite \\<V>'\n\ngoal (1 subgoal):\n 1. finite_incidence_system \\<V>\\<^sup>+ \\<B>\\<^sup>+", "by (unfold_locales) (simp)"], ["", "lemma combine_order: \"card (\\<V>\\<^sup>+) \\<ge> card \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card \\<V> \\<le> card \\<V>\\<^sup>+", "by (meson Un_upper1 card_mono combine_fin_sys.finite_sets)"], ["", "lemma  combine_order_2: \"card (\\<V>\\<^sup>+) \\<ge> card \\<V>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card \\<V>' \\<le> card \\<V>\\<^sup>+", "by (meson Un_upper2 card_mono combine_fin_sys.finite_sets)"], ["", "end"], ["", "locale two_designs = two_fin_set_systems \\<V> \\<B> \\<V>' \\<B>' + des1: design \\<V> \\<B> + \n  des2: design \\<V>' \\<B>' for \\<V> \\<B> \\<V>' \\<B>'\nbegin"], ["", "sublocale combine_des: design \"\\<V>\\<^sup>+\" \"\\<B>\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design \\<V>\\<^sup>+ \\<B>\\<^sup>+", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl. bl \\<in># \\<B>\\<^sup>+ \\<Longrightarrow> bl \\<noteq> {}", "using des1.blocks_nempty_alt des2.blocks_nempty_alt"], ["proof (prove)\nusing this:\n  \\<forall>bl\\<in>#\\<B>. bl \\<noteq> {}\n  \\<forall>bl\\<in>#\\<B>'. bl \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>bl. bl \\<in># \\<B>\\<^sup>+ \\<Longrightarrow> bl \\<noteq> {}", "by fastforce"], ["", "end"], ["", "locale two_designs_proper = two_designs + \n  assumes blocks_nempty: \"\\<B> \\<noteq> {#} \\<or> \\<B>' \\<noteq> {#}\"\nbegin"], ["", "lemma des1_is_proper: \"\\<B> \\<noteq> {#} \\<Longrightarrow> proper_design \\<V> \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> \\<noteq> {#} \\<Longrightarrow> proper_design \\<V> \\<B>", "by (unfold_locales) (simp)"], ["", "lemma des2_is_proper: \"\\<B>' \\<noteq> {#} \\<Longrightarrow> proper_design \\<V>' \\<B>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>' \\<noteq> {#} \\<Longrightarrow> proper_design \\<V>' \\<B>'", "by (unfold_locales) (simp)"], ["", "lemma min_one_proper_design: \"proper_design \\<V> \\<B> \\<or> proper_design \\<V>' \\<B>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B> \\<or> proper_design \\<V>' \\<B>'", "using blocks_nempty des1_is_proper des2_is_proper"], ["proof (prove)\nusing this:\n  \\<B> \\<noteq> {#} \\<or> \\<B>' \\<noteq> {#}\n  \\<B> \\<noteq> {#} \\<Longrightarrow> proper_design \\<V> \\<B>\n  \\<B>' \\<noteq> {#} \\<Longrightarrow> proper_design \\<V>' \\<B>'\n\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B> \\<or> proper_design \\<V>' \\<B>'", "by (unfold_locales, blast)"], ["", "sublocale combine_proper_des: proper_design \"\\<V>\\<^sup>+\" \"\\<B>\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design \\<V>\\<^sup>+ \\<B>\\<^sup>+", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size \\<B>\\<^sup>+) \\<noteq> 0", "by (metis blocks_nempty of_nat_0_eq_iff size_eq_0_iff_empty subset_mset.zero_eq_add_iff_both_eq_0)"], ["", "end"], ["", "end"]]}