{"file_name": "/home/qj213/afp-2021-10-22/thys/Design_Theory/BIBD.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Design_Theory", "problem_names": ["lemma min_block_size_2: \"\\<k> \\<ge> 2\"", "lemma points_index_pair: \"y \\<in> \\<V> \\<Longrightarrow> x \\<in> \\<V> \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow>  size ({# bl \\<in># \\<B> . {x, y} \\<subseteq> bl#}) = \\<Lambda>\"", "lemma index_one_empty_rm_blv [simp]:\n  assumes \"\\<Lambda> = 1\" and \" blv \\<in># \\<B>\" and \"p \\<subseteq> blv\" and \"card p = 2\" \n  shows \"{#bl \\<in># remove1_mset blv \\<B> . p \\<subseteq> bl#} = {#}\"", "lemma index_one_alt_bl_not_exist:\n  assumes \"\\<Lambda> = 1\" and \" blv \\<in># \\<B>\" and \"p \\<subseteq> blv\" and \"card p = 2\" \n  shows\" \\<And> bl. bl \\<in># remove1_mset blv \\<B> \\<Longrightarrow> \\<not> (p \\<subseteq> bl) \"", "lemma necess_cond_1_rhs: \n  assumes \"x \\<in> \\<V>\"\n  shows \"size ({# p \\<in># (mset_set (\\<V> - {x}) \\<times># {# bl \\<in># \\<B> . x \\<in> bl #}). fst p \\<in> snd p#}) = \\<Lambda> * (\\<v>- 1)\"", "lemma necess_cond_1_lhs: \n  assumes \"x \\<in> \\<V>\"\n  shows \"size ({# p \\<in># (mset_set (\\<V> - {x}) \\<times># {# bl \\<in># \\<B> . x \\<in> bl #}). fst p \\<in> snd p#}) \n      = (\\<B> rep x) * (\\<k> - 1)\" \n    (is \"size ({# p \\<in># (?M \\<times># ?B). fst p \\<in> snd p#}) = (\\<B> rep x) * (\\<k> - 1) \")", "lemma r_constant: \"x \\<in> \\<V> \\<Longrightarrow> (\\<B> rep x) * (\\<k> -1) = \\<Lambda> * (\\<v> - 1)\"", "lemma replication_number_value:\n  assumes \"x \\<in> \\<V>\"\n  shows \"(\\<B> rep x) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\"", "lemma r_constant_alt: \"\\<forall> x \\<in> \\<V>. \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\"", "lemma (in t_design) bibdI [intro]: \"\\<t> = 2 \\<Longrightarrow> bibd \\<V> \\<B> \\<k> \\<Lambda>\\<^sub>t\"", "lemma necessary_condition_one: \n  shows \"\\<r> * (\\<k> - 1) = \\<Lambda> * (\\<v> - 1)\"", "lemma bibd_point_occ_rep: \n  assumes \"x \\<in> bl\"\n  assumes \"bl \\<in># \\<B>\"\n  shows  \"(\\<B> - {#bl#}) rep x = \\<r> - 1\"", "lemma necess_cond_2_lhs: \"size {# x \\<in># (mset_set \\<V> \\<times># \\<B>) . (fst x) \\<in> (snd x)  #} = \\<v> * \\<r>\"", "lemma necess_cond_2_rhs: \"size {# x \\<in># (mset_set \\<V> \\<times># \\<B>) . (fst x) \\<in> (snd x)  #} = \\<b>*\\<k>\" \n  (is \"size {# x \\<in># (?M \\<times># ?B). (fst x) \\<in> (snd x)  #} = \\<b>*\\<k>\")", "lemma necessary_condition_two:\n  shows \"\\<v> * \\<r> = \\<b> * \\<k>\"", "theorem admissability_conditions:\n\"\\<r> * (\\<k> - 1) = \\<Lambda> * (\\<v> - 1)\"\n\"\\<v> * \\<r> = \\<b> * \\<k>\"", "lemma bibd_block_number: \"\\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k>-1))\"", "lemma symmetric_condition_1: \"\\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1) \\<Longrightarrow> \\<b> = \\<v> \\<and> \\<r> = \\<k>\"", "lemma index_lt_replication: \"\\<Lambda> < \\<r>\"", "lemma index_not_zero: \"\\<Lambda> \\<ge> 1\"", "lemma r_ge_two: \"\\<r> \\<ge> 2\"", "lemma block_num_gt_rep: \"\\<b> > \\<r>\"", "lemma bibd_subset_occ: \n  assumes \"x \\<subseteq> bl\" and \"bl \\<in># \\<B>\" and \"card x = 2\"\n  shows \"size {# blk \\<in># (\\<B> - {#bl#}). x \\<subseteq> blk #} = \\<Lambda> - 1\"", "lemma necess_cond_one_param_balance: \"\\<b> > \\<v> \\<Longrightarrow> \\<r> > \\<k>\"", "lemma comp_params_index_pair:\n  assumes \"{x, y} \\<subseteq> \\<V>\"\n  assumes \"x \\<noteq> y\"\n  shows \"\\<B>\\<^sup>C index {x, y} = \\<b> + \\<Lambda> - 2*\\<r>\"", "lemma complement_bibd_index: \n  assumes \"ps \\<subseteq> \\<V>\"\n  assumes \"card ps = 2\"\n  shows \"\\<B>\\<^sup>C index ps = \\<b> + \\<Lambda> - 2*\\<r>\"", "lemma complement_bibd: \n  assumes \"\\<k> \\<le> \\<v> - 2\" \n  shows \"bibd \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>) (\\<b> + \\<Lambda> - 2*\\<r>)\"", "lemma multiple_bibd: \"n > 0 \\<Longrightarrow> bibd \\<V> (multiple_blocks n) \\<k> (\\<Lambda> * n)\"", "lemma combine_is_bibd: \"bibd \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k> (\\<Lambda> + \\<Lambda>')\"", "lemma derive_define_flip: \"{# b \\<inter> bl . b \\<in># (\\<B> - {#bl#}) #} = \\<B>\\<^sup>D\"", "lemma derived_points_order: \"card bl = \\<k>\"", "lemma derived_block_num: \"bl \\<in># \\<B> \\<Longrightarrow> size \\<B>\\<^sup>D = \\<b> - 1\"", "lemma derived_is_wellformed:  \"b \\<in># \\<B>\\<^sup>D \\<Longrightarrow> b \\<subseteq> bl\"", "lemma derived_point_subset_orig: \"ps \\<subseteq> bl \\<Longrightarrow> ps \\<subset> \\<V>\"", "lemma derived_obtain_orig_block: \n  assumes \"b \\<in># \\<B>\\<^sup>D\"\n  obtains b2 where \"b = b2 \\<inter> bl\" and \"b2 \\<in># remove1_mset bl \\<B>\"", "lemma derived_blocks_nempty:\n  assumes \"\\<And> b .b \\<in># remove1_mset bl \\<B> \\<Longrightarrow> bl |\\<inter>| b > 0\"\n  assumes \"bld \\<in># \\<B>\\<^sup>D\"\n  shows \"bld \\<noteq> {}\"", "lemma derived_is_design:\n  assumes \"\\<And> b. b \\<in># remove1_mset bl \\<B> \\<Longrightarrow> bl |\\<inter>| b > 0\"\n  shows \"design bl \\<B>\\<^sup>D\"", "lemma derived_is_proper: \n  assumes \"\\<And> b. b \\<in># remove1_mset bl \\<B> \\<Longrightarrow> bl |\\<inter>| b > 0\"\n  shows \"proper_design bl \\<B>\\<^sup>D\"", "lemma residual_order: \"card (bl\\<^sup>c) = \\<v> - \\<k>\"", "lemma residual_block_num: \"size (\\<B>\\<^sup>R) = \\<b> - 1\"", "lemma residual_obtain_orig_block: \n  assumes \"b \\<in># \\<B>\\<^sup>R\"\n  obtains bl2 where \"b = bl2 - bl\" and \"bl2 \\<in># remove1_mset bl \\<B>\"", "lemma residual_blocks_ss: assumes \"b \\<in># \\<B>\\<^sup>R\" shows \"b \\<subseteq> \\<V>\"", "lemma residual_blocks_exclude: \"b \\<in># \\<B>\\<^sup>R \\<Longrightarrow> x \\<in> b \\<Longrightarrow> x \\<notin> bl\"", "lemma residual_is_wellformed:  \"b \\<in># \\<B>\\<^sup>R \\<Longrightarrow> b \\<subseteq> (bl\\<^sup>c)\"", "lemma residual_is_finite: \"finite (bl\\<^sup>c)\"", "lemma residual_blocks_nempty:\n  assumes \"bld \\<in># \\<B>\\<^sup>R\"\n  assumes \"multiplicity bl = 1\" \n  shows \"bld \\<noteq> {}\"", "lemma residual_is_design: \"multiplicity bl = 1 \\<Longrightarrow> design (bl\\<^sup>c) \\<B>\\<^sup>R\"", "lemma residual_is_proper: \n  assumes \"multiplicity bl = 1\" \n  shows \"proper_design (bl\\<^sup>c) \\<B>\\<^sup>R\"", "lemma rep_value_sym: \"\\<r> = \\<k>\"", "lemma symmetric_condition_2: \"\\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1)\"", "lemma sym_design_vk_gt_kl: \n  assumes \"\\<k> \\<ge> \\<Lambda> + 2\"\n  shows \"\\<v> - \\<k> > \\<k> - \\<Lambda>\"", "lemma symmetric_bibdI: \"\\<b> = \\<v> \\<Longrightarrow> symmetric_bibd \\<V> \\<B> \\<k> \\<Lambda>\"", "lemma symmetric_bibdII: \"\\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1) \\<Longrightarrow> symmetric_bibd \\<V> \\<B> \\<k> \\<Lambda>\"", "lemma symmetric_not_admissable: \"\\<Lambda> * (\\<v> - 1) \\<noteq> \\<k> * (\\<k> - 1) \\<Longrightarrow> \\<not> symmetric_bibd \\<V> \\<B> \\<k> \\<Lambda>\"", "lemma intersect_mult_set_eq_block:\n  assumes \"blv \\<in># \\<B>\"\n  shows \"p \\<in># \\<Sum>\\<^sub>#{# mset_set (bl \\<inter> blv) .bl \\<in># (\\<B> - {#blv#})#} \\<longleftrightarrow> p \\<in> blv\"", "lemma intersect_mult_set_block_subset_iff:\n  assumes \"blv \\<in># \\<B>\"\n  assumes \"p \\<in># \\<Sum>\\<^sub>#{# mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} .b2 \\<in># (\\<B> - {#blv#})#}\"\n  shows \"p \\<subseteq> blv\"", "lemma intersect_mult_set_block_subset_card:\n  assumes \"blv \\<in># \\<B>\"\n  assumes \"p \\<in># \\<Sum>\\<^sub>#{# mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} .b2 \\<in># (\\<B> - {#blv#})#}\"\n  shows \"card p = 2\"", "lemma intersect_mult_set_block_with_point_exists: \n  assumes \"blv \\<in># \\<B>\" and  \"p \\<subseteq> blv\" and \"\\<Lambda> \\<ge> 2\" and \"card p = 2\"\n  shows \"\\<exists>x\\<in>#remove1_mset blv \\<B>. p \\<in># mset_set {y. y \\<subseteq> blv \\<and> y \\<subseteq> x \\<and> card y = 2}\"", "lemma intersect_mult_set_block_subset_iff_2:\n  assumes \"blv \\<in># \\<B>\" and  \"p \\<subseteq> blv\" and \"\\<Lambda> \\<ge> 2\" and \"card p = 2\"\n  shows \"p \\<in># \\<Sum>\\<^sub>#{# mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} .b2 \\<in># (\\<B> - {#blv#})#}\"", "lemma sym_sum_mset_inter_sets_count: \n  assumes \"blv \\<in># \\<B>\"\n  assumes \"p \\<in> blv\"\n  shows \"count (\\<Sum>\\<^sub>#{# mset_set (bl \\<inter> blv) .bl \\<in># (\\<B> - {#blv#})#}) p = \\<r> - 1\" \n    (is \"count (\\<Sum>\\<^sub>#?M) p = \\<r> - 1\")", "lemma sym_sum_mset_inter_sets_size: \n  assumes \"blv \\<in># \\<B>\"\n  shows \"size (\\<Sum>\\<^sub>#{# mset_set (bl \\<inter> blv) .bl \\<in># (\\<B> - {#blv#})#}) = \\<k> * (\\<r> - 1)\" \n    (is \"size (\\<Sum>\\<^sub>#?M) = \\<k>* (\\<r> - 1)\")", "lemma sym_sum_inter_num: \n  assumes \"b1 \\<in># \\<B>\" \n  shows \"(\\<Sum>b2 \\<in>#(\\<B> - {#b1#}). b1 |\\<inter>| b2) = \\<k>* (\\<r> - 1)\"", "lemma choose_two_int: \n  assumes \" x \\<ge> 0\" \n  shows \"nat (x :: int) choose 2 = ((x ::int) * ( x - 1)) div 2 \"", "lemma sym_sum_mset_inter2_sets_count: \n  assumes \"blv \\<in># \\<B>\"\n  assumes \"p \\<subseteq> blv\"\n  assumes \"card p = 2\"\n  shows \"count (\\<Sum>\\<^sub>#{#mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}. b2 \\<in># (\\<B> - {#blv#})#}) p = \\<Lambda> - 1\" \n    (is \"count (\\<Sum>\\<^sub>#?M) p = \\<Lambda> - 1\")", "lemma sym_sum_mset_inter2_sets_size: \n  assumes \"blv \\<in># \\<B>\"\n  shows \"size (\\<Sum>\\<^sub>#{#mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}. b2 \\<in># (\\<B> - {#blv#})#}) = \n    ((nat \\<k>) choose 2) * (\\<Lambda> -1)\" \n    (is \"size (\\<Sum>\\<^sub>#?M) = ((nat \\<k>) choose 2) * (\\<Lambda> -1)\")", "lemma sum_choose_two_inter_num: \n  assumes \"b1 \\<in># \\<B>\" \n  shows \"(\\<Sum>b2 \\<in># (\\<B> - {#b1#}). (nat (b1 |\\<inter>| b2) choose 2)) = ((\\<Lambda> * (\\<Lambda> - 1) div 2)) * (\\<v> -1)\"", "lemma sym_sum_inter_num_sq: \n  assumes \"b1 \\<in># \\<B>\" \n  shows \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). (b1 |\\<inter>| bl)^2) = \\<Lambda>^2 * ( \\<v> - 1)\"", "lemma sym_sum_inter_num_to_zero: \n  assumes \"b1 \\<in># \\<B>\" \n  shows \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). ((b1 |\\<inter>| bl) - \\<Lambda>)^2) = 0\"", "theorem sym_block_intersections_index [simp]: \n  assumes \"b1 \\<in># \\<B>\"\n  assumes \"b2 \\<in># (\\<B> - {#b1#})\"\n  shows \"b1 |\\<inter>| b2 = \\<Lambda>\"", "lemma sym_block_mult_one [simp]:\n  assumes \"bl \\<in># \\<B>\"\n  shows \"multiplicity bl = 1\"", "lemma derived_block_size [simp]: \n  assumes \"b \\<in># \\<B>\\<^sup>D\"\n  shows \"card b = \\<Lambda>\"", "lemma derived_points_index [simp]: \n  assumes \"ps \\<subseteq> bl\"\n  assumes \"card ps = 2\"\n  shows \"\\<B>\\<^sup>D index  ps = \\<Lambda> - 1\"", "lemma sym_derive_design_bibd: \n  assumes \"\\<Lambda> > 1\"\n  shows \"bibd bl \\<B>\\<^sup>D \\<Lambda> (\\<Lambda> - 1)\"", "lemma residual_block_size [simp]: \n  assumes \"b \\<in># \\<B>\\<^sup>R\"\n  shows \"card b = \\<k> - \\<Lambda>\"", "lemma residual_index [simp]: \n  assumes \"ps \\<subseteq> bl\\<^sup>c\"\n  assumes \"card ps = 2\"\n  shows  \"(\\<B>\\<^sup>R) index ps = \\<Lambda>\"", "lemma sym_residual_design_bibd: \n  assumes \"\\<k> \\<ge> \\<Lambda> + 2\"\n  shows \"bibd (bl\\<^sup>c) \\<B>\\<^sup>R (\\<k> - \\<Lambda>) \\<Lambda>\"", "lemma incomplete_PBD_is_bibd: \n  assumes \"k < card V\" and \"k_\\<Lambda>_PBD V B \\<Lambda> k\" \n  shows \"bibd V B k \\<Lambda>\"", "lemma (in bibd) bibd_to_pbdI[intro]: \n  assumes \"\\<Lambda> = 1\" \n  shows \"k_PBD \\<V> \\<B> \\<k>\""], "translations": [["", "lemma min_block_size_2: \"\\<k> \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> \\<k>", "using block_size_t"], ["proof (prove)\nusing this:\n  2 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. 2 \\<le> \\<k>", "by simp"], ["", "lemma points_index_pair: \"y \\<in> \\<V> \\<Longrightarrow> x \\<in> \\<V> \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow>  size ({# bl \\<in># \\<B> . {x, y} \\<subseteq> bl#}) = \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> \\<V>; x \\<in> \\<V>; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> int (size (filter_mset ((\\<subseteq>) {x, y}) \\<B>)) =\n                      \\<Lambda>", "using balanced card_2_iff empty_subsetI insert_subset points_index_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = 2\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) = \\<Lambda>\n  (card ?S = 2) = (\\<exists>x y. ?S = {x, y} \\<and> x \\<noteq> y)\n  {} \\<subseteq> ?A\n  (insert ?x ?A \\<subseteq> ?B) = (?x \\<in> ?B \\<and> ?A \\<subseteq> ?B)\n  ?B index ?ps \\<equiv> size (filter_mset ((\\<subseteq>) ?ps) ?B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> \\<V>; x \\<in> \\<V>; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> int (size (filter_mset ((\\<subseteq>) {x, y}) \\<B>)) =\n                      \\<Lambda>", "by (metis of_nat_numeral)"], ["", "lemma index_one_empty_rm_blv [simp]:\n  assumes \"\\<Lambda> = 1\" and \" blv \\<in># \\<B>\" and \"p \\<subseteq> blv\" and \"card p = 2\" \n  shows \"{#bl \\<in># remove1_mset blv \\<B> . p \\<subseteq> bl#} = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>) = {#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>) = {#}", "have blv_in: \"blv \\<in># filter_mset ((\\<subseteq>) p) \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blv \\<in># filter_mset ((\\<subseteq>) p) \\<B>", "using assms"], ["proof (prove)\nusing this:\n  \\<Lambda> = 1\n  blv \\<in># \\<B>\n  p \\<subseteq> blv\n  card p = 2\n\ngoal (1 subgoal):\n 1. blv \\<in># filter_mset ((\\<subseteq>) p) \\<B>", "by simp"], ["proof (state)\nthis:\n  blv \\<in># filter_mset ((\\<subseteq>) p) \\<B>\n\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>) = {#}", "have \"p \\<subseteq> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<subseteq> \\<V>", "using assms wellformed"], ["proof (prove)\nusing this:\n  \\<Lambda> = 1\n  blv \\<in># \\<B>\n  p \\<subseteq> blv\n  card p = 2\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. p \\<subseteq> \\<V>", "by auto"], ["proof (state)\nthis:\n  p \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>) = {#}", "then"], ["proof (chain)\npicking this:\n  p \\<subseteq> \\<V>", "have \"size (filter_mset ((\\<subseteq>) p) \\<B>) = 1\""], ["proof (prove)\nusing this:\n  p \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. size (filter_mset ((\\<subseteq>) p) \\<B>) = 1", "using balanced assms"], ["proof (prove)\nusing this:\n  p \\<subseteq> \\<V>\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = 2\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) = \\<Lambda>\n  \\<Lambda> = 1\n  blv \\<in># \\<B>\n  p \\<subseteq> blv\n  card p = 2\n\ngoal (1 subgoal):\n 1. size (filter_mset ((\\<subseteq>) p) \\<B>) = 1", "by (simp add: points_index_def)"], ["proof (state)\nthis:\n  size (filter_mset ((\\<subseteq>) p) \\<B>) = 1\n\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>) = {#}", "then"], ["proof (chain)\npicking this:\n  size (filter_mset ((\\<subseteq>) p) \\<B>) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  size (filter_mset ((\\<subseteq>) p) \\<B>) = 1\n\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>) = {#}", "using blv_in filter_diff_mset filter_single_mset"], ["proof (prove)\nusing this:\n  size (filter_mset ((\\<subseteq>) p) \\<B>) = 1\n  blv \\<in># filter_mset ((\\<subseteq>) p) \\<B>\n  filter_mset ?P (?M - ?N) = filter_mset ?P ?M - filter_mset ?P ?N\n  filter_mset ?P {#?x#} = (if ?P ?x then {#?x#} else {#})\n\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>) = {#}", "by (metis (no_types, lifting) add_mset_eq_single assms(3) insert_DiffM size_1_singleton_mset)"], ["proof (state)\nthis:\n  filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>) = {#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_one_alt_bl_not_exist:\n  assumes \"\\<Lambda> = 1\" and \" blv \\<in># \\<B>\" and \"p \\<subseteq> blv\" and \"card p = 2\" \n  shows\" \\<And> bl. bl \\<in># remove1_mset blv \\<B> \\<Longrightarrow> \\<not> (p \\<subseteq> bl) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n       \\<not> p \\<subseteq> bl", "using index_one_empty_rm_blv"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<Lambda> = 1; ?blv \\<in># \\<B>; ?p \\<subseteq> ?blv;\n   card ?p = 2\\<rbrakk>\n  \\<Longrightarrow> filter_mset ((\\<subseteq>) ?p)\n                     (remove1_mset ?blv \\<B>) =\n                    {#}\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n       \\<not> p \\<subseteq> bl", "by (metis assms(1) assms(2) assms(3) assms(4) filter_mset_empty_conv)"], ["", "subsection \\<open>Necessary Conditions for Existence\\<close>"], ["", "text \\<open>The necessary conditions on the existence of a $(v, k, \\lambda)$-bibd are one of the \nfundamental first theorems on designs. Proofs based off MATH3301 lecture notes \\cite{HerkeLectureNotes2016}\n and Stinson \\cite{stinsonCombinatorialDesignsConstructions2004}\\<close>"], ["", "lemma necess_cond_1_rhs: \n  assumes \"x \\<in> \\<V>\"\n  shows \"size ({# p \\<in># (mset_set (\\<V> - {x}) \\<times># {# bl \\<in># \\<B> . x \\<in> bl #}). fst p \\<in> snd p#}) = \\<Lambda> * (\\<v>- 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "let ?M = \"mset_set (\\<V> - {x})\""], ["proof (state)\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "let ?B = \"{# bl \\<in># \\<B> . x \\<in> bl #}\""], ["proof (state)\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "have m_distinct: \"distinct_mset ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset (mset_set (\\<V> - {x}))", "using assms mset_points_distinct_diff_one"], ["proof (prove)\nusing this:\n  x \\<in> \\<V>\n  distinct_mset (mset_set (\\<V> - {?x}))\n\ngoal (1 subgoal):\n 1. distinct_mset (mset_set (\\<V> - {x}))", "by simp"], ["proof (state)\nthis:\n  distinct_mset (mset_set (\\<V> - {x}))\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "have y_point: \"\\<And> y . y \\<in># ?M \\<Longrightarrow> y \\<in> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> y \\<in> \\<V>", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> y \\<in> \\<V>", "by (simp add: finite_sets)"], ["proof (state)\nthis:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> ?y \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "have b_contents: \"\\<And> bl. bl \\<in># ?B \\<Longrightarrow> x \\<in> bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># filter_mset ((\\<in>) x) \\<B> \\<Longrightarrow> x \\<in> bl", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># filter_mset ((\\<in>) x) \\<B> \\<Longrightarrow> x \\<in> bl", "by auto"], ["proof (state)\nthis:\n  ?bl \\<in># filter_mset ((\\<in>) x) \\<B> \\<Longrightarrow> x \\<in> ?bl\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "have \"\\<And> y. y \\<in># ?M \\<Longrightarrow> y \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> y \\<noteq> x", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> y \\<noteq> x", "by (simp add: finite_sets)"], ["proof (state)\nthis:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> ?y \\<noteq> x\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> ?y \\<noteq> x", "have \"\\<And> y .y \\<in># ?M \\<Longrightarrow> size ({# bl \\<in># ?B . {x, y} \\<subseteq> bl#}) = nat \\<Lambda>\""], ["proof (prove)\nusing this:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> ?y \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n       size\n        (filter_mset ((\\<subseteq>) {x, y})\n          (filter_mset ((\\<in>) x) \\<B>)) =\n       nat \\<Lambda>", "using points_index_pair filter_filter_mset_ss_member y_point assms finite_sets index_ge_zero"], ["proof (prove)\nusing this:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> ?y \\<noteq> x\n  \\<lbrakk>?y \\<in> \\<V>; ?x \\<in> \\<V>; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> int (size (filter_mset ((\\<subseteq>) {?x, ?y}) \\<B>)) =\n                    \\<Lambda>\n  filter_mset ((\\<subseteq>) {?x, ?y}) ?A =\n  filter_mset ((\\<subseteq>) {?x, ?y}) (filter_mset ((\\<in>) ?x) ?A)\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> ?y \\<in> \\<V>\n  x \\<in> \\<V>\n  finite \\<V>\n  0 \\<le> \\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n       size\n        (filter_mset ((\\<subseteq>) {x, y})\n          (filter_mset ((\\<in>) x) \\<B>)) =\n       nat \\<Lambda>", "by (metis nat_0_le nat_int_comparison(1))"], ["proof (state)\nthis:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size\n   (filter_mset ((\\<subseteq>) {x, ?y}) (filter_mset ((\\<in>) x) \\<B>)) =\n  nat \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size\n   (filter_mset ((\\<subseteq>) {x, ?y}) (filter_mset ((\\<in>) x) \\<B>)) =\n  nat \\<Lambda>", "have  \"\\<And> y .y \\<in># ?M \\<Longrightarrow> size ({# bl \\<in># ?B . x \\<in> bl \\<and> y \\<in> bl#}) = nat \\<Lambda>\""], ["proof (prove)\nusing this:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size\n   (filter_mset ((\\<subseteq>) {x, ?y}) (filter_mset ((\\<in>) x) \\<B>)) =\n  nat \\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n       size\n        {#bl \\<in># filter_mset ((\\<in>) x) \\<B>.\n         x \\<in> bl \\<and> y \\<in> bl#} =\n       nat \\<Lambda>", "by auto"], ["proof (state)\nthis:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size\n   {#bl \\<in># filter_mset ((\\<in>) x) \\<B>.\n    x \\<in> bl \\<and> ?y \\<in> bl#} =\n  nat \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size\n   {#bl \\<in># filter_mset ((\\<in>) x) \\<B>.\n    x \\<in> bl \\<and> ?y \\<in> bl#} =\n  nat \\<Lambda>", "have bl_set_size: \"\\<And> y . y \\<in># ?M \\<Longrightarrow> size ({# bl \\<in># ?B .  y \\<in> bl#}) = nat \\<Lambda>\""], ["proof (prove)\nusing this:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size\n   {#bl \\<in># filter_mset ((\\<in>) x) \\<B>.\n    x \\<in> bl \\<and> ?y \\<in> bl#} =\n  nat \\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n       size (filter_mset ((\\<in>) y) (filter_mset ((\\<in>) x) \\<B>)) =\n       nat \\<Lambda>", "using b_contents"], ["proof (prove)\nusing this:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size\n   {#bl \\<in># filter_mset ((\\<in>) x) \\<B>.\n    x \\<in> bl \\<and> ?y \\<in> bl#} =\n  nat \\<Lambda>\n  ?bl \\<in># filter_mset ((\\<in>) x) \\<B> \\<Longrightarrow> x \\<in> ?bl\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n       size (filter_mset ((\\<in>) y) (filter_mset ((\\<in>) x) \\<B>)) =\n       nat \\<Lambda>", "by (metis (no_types, lifting) filter_mset_cong)"], ["proof (state)\nthis:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size (filter_mset ((\\<in>) ?y) (filter_mset ((\\<in>) x) \\<B>)) =\n  nat \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size (filter_mset ((\\<in>) ?y) (filter_mset ((\\<in>) x) \\<B>)) =\n  nat \\<Lambda>", "have final_size: \"size (\\<Sum>p\\<in>#?M . ({#p#} \\<times># {#bl \\<in># ?B. p \\<in> bl#})) = size (?M) * (nat \\<Lambda>)\""], ["proof (prove)\nusing this:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size (filter_mset ((\\<in>) ?y) (filter_mset ((\\<in>) x) \\<B>)) =\n  nat \\<Lambda>\n\ngoal (1 subgoal):\n 1. size\n     (\\<Sum>p\\<in>#mset_set\n                    (\\<V> -\n                     {x}). {#p#} \\<times>#\n                           filter_mset ((\\<in>) p)\n                            (filter_mset ((\\<in>) x) \\<B>)) =\n    size (mset_set (\\<V> - {x})) * nat \\<Lambda>", "using m_distinct size_Union_distinct_cart_prod_filter bl_set_size index_ge_zero"], ["proof (prove)\nusing this:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size (filter_mset ((\\<in>) ?y) (filter_mset ((\\<in>) x) \\<B>)) =\n  nat \\<Lambda>\n  distinct_mset (mset_set (\\<V> - {x}))\n  \\<lbrakk>distinct_mset ?M;\n   \\<And>p.\n      p \\<in># ?M \\<Longrightarrow>\n      size (filter_mset (?P p) ?B) = ?c\\<rbrakk>\n  \\<Longrightarrow> size\n                     (\\<Sum>p\\<in>#?M. {#p#} \\<times>#\n filter_mset (?P p) ?B) =\n                    size ?M * ?c\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow>\n  size (filter_mset ((\\<in>) ?y) (filter_mset ((\\<in>) x) \\<B>)) =\n  nat \\<Lambda>\n  0 \\<le> \\<Lambda>\n\ngoal (1 subgoal):\n 1. size\n     (\\<Sum>p\\<in>#mset_set\n                    (\\<V> -\n                     {x}). {#p#} \\<times>#\n                           filter_mset ((\\<in>) p)\n                            (filter_mset ((\\<in>) x) \\<B>)) =\n    size (mset_set (\\<V> - {x})) * nat \\<Lambda>", "by blast"], ["proof (state)\nthis:\n  size\n   (\\<Sum>p\\<in>#mset_set\n                  (\\<V> -\n                   {x}). {#p#} \\<times>#\n                         filter_mset ((\\<in>) p)\n                          (filter_mset ((\\<in>) x) \\<B>)) =\n  size (mset_set (\\<V> - {x})) * nat \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "have \"size ?M = \\<v> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size (mset_set (\\<V> - {x}))) = \\<v> - 1", "using v_non_zero"], ["proof (prove)\nusing this:\n  0 < \\<v>\n\ngoal (1 subgoal):\n 1. int (size (mset_set (\\<V> - {x}))) = \\<v> - 1", "by (simp add: assms(1) finite_sets)"], ["proof (state)\nthis:\n  int (size (mset_set (\\<V> - {x}))) = \\<v> - 1\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (size (mset_set (\\<V> - {x}))) = \\<v> - 1\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "using final_size"], ["proof (prove)\nusing this:\n  int (size (mset_set (\\<V> - {x}))) = \\<v> - 1\n  size\n   (\\<Sum>p\\<in>#mset_set\n                  (\\<V> -\n                   {x}). {#p#} \\<times>#\n                         filter_mset ((\\<in>) p)\n                          (filter_mset ((\\<in>) x) \\<B>)) =\n  size (mset_set (\\<V> - {x})) * nat \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<Lambda> * (\\<v> - 1)", "by (simp add: set_break_down_left index_ge_zero)"], ["proof (state)\nthis:\n  int (size\n        {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                   filter_mset ((\\<in>) x) \\<B>.\n         fst p \\<in> snd p#}) =\n  \\<Lambda> * (\\<v> - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma necess_cond_1_lhs: \n  assumes \"x \\<in> \\<V>\"\n  shows \"size ({# p \\<in># (mset_set (\\<V> - {x}) \\<times># {# bl \\<in># \\<B> . x \\<in> bl #}). fst p \\<in> snd p#}) \n      = (\\<B> rep x) * (\\<k> - 1)\" \n    (is \"size ({# p \\<in># (?M \\<times># ?B). fst p \\<in> snd p#}) = (\\<B> rep x) * (\\<k> - 1) \")"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "have \"\\<And> y. y \\<in># ?M \\<Longrightarrow> y \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> y \\<noteq> x", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> y \\<noteq> x", "by (simp add: finite_sets)"], ["proof (state)\nthis:\n  ?y \\<in># mset_set (\\<V> - {x}) \\<Longrightarrow> ?y \\<noteq> x\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "have distinct_m: \"distinct_mset ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset (mset_set (\\<V> - {x}))", "using assms mset_points_distinct_diff_one"], ["proof (prove)\nusing this:\n  x \\<in> \\<V>\n  distinct_mset (mset_set (\\<V> - {?x}))\n\ngoal (1 subgoal):\n 1. distinct_mset (mset_set (\\<V> - {x}))", "by simp"], ["proof (state)\nthis:\n  distinct_mset (mset_set (\\<V> - {x}))\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "have finite_M: \"finite (\\<V> - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<V> - {x})", "using finite_sets"], ["proof (prove)\nusing this:\n  finite \\<V>\n\ngoal (1 subgoal):\n 1. finite (\\<V> - {x})", "by auto"], ["proof (state)\nthis:\n  finite (\\<V> - {x})\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "have block_choices: \"size ?B = \\<B> rep x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<in>) x) \\<B>)) = \\<B> rep x", "by (simp add: assms(1) point_replication_number_def)"], ["proof (state)\nthis:\n  int (size (filter_mset ((\\<in>) x) \\<B>)) = \\<B> rep x\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "have bl_size: \"\\<forall> bl \\<in># ?B. card {p \\<in> \\<V> . p \\<in> bl } = \\<k> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n       int (card {p \\<in> \\<V>. p \\<in> bl}) = \\<k>", "using uniform_unfold_point_set"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow>\n  int (card {p \\<in> \\<V>. p \\<in> ?bl}) = \\<k>\n\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n       int (card {p \\<in> \\<V>. p \\<in> bl}) = \\<k>", "by simp"], ["proof (state)\nthis:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     int (card {p \\<in> \\<V>. p \\<in> bl}) = \\<k>\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "have x_in_set: \"\\<forall> bl \\<in># ?B . {x} \\<subseteq> {p \\<in> \\<V>. p \\<in> bl}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n       {x} \\<subseteq> {p \\<in> \\<V>. p \\<in> bl}", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n       {x} \\<subseteq> {p \\<in> \\<V>. p \\<in> bl}", "by auto"], ["proof (state)\nthis:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     {x} \\<subseteq> {p \\<in> \\<V>. p \\<in> bl}\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "then"], ["proof (chain)\npicking this:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     {x} \\<subseteq> {p \\<in> \\<V>. p \\<in> bl}", "have \"\\<forall> bl \\<in># ?B. card {p \\<in> (\\<V> - {x}) . p \\<in> bl } = card ({p \\<in> \\<V> . p \\<in> bl } - {x})\""], ["proof (prove)\nusing this:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     {x} \\<subseteq> {p \\<in> \\<V>. p \\<in> bl}\n\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n       card {p \\<in> \\<V> - {x}. p \\<in> bl} =\n       card ({p \\<in> \\<V>. p \\<in> bl} - {x})", "by (simp add: set_filter_diff_card)"], ["proof (state)\nthis:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     card {p \\<in> \\<V> - {x}. p \\<in> bl} =\n     card ({p \\<in> \\<V>. p \\<in> bl} - {x})\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "then"], ["proof (chain)\npicking this:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     card {p \\<in> \\<V> - {x}. p \\<in> bl} =\n     card ({p \\<in> \\<V>. p \\<in> bl} - {x})", "have \"\\<forall> bl \\<in># ?B. card {p \\<in> (\\<V> - {x}) . p \\<in> bl } = \\<k> - 1\""], ["proof (prove)\nusing this:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     card {p \\<in> \\<V> - {x}. p \\<in> bl} =\n     card ({p \\<in> \\<V>. p \\<in> bl} - {x})\n\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n       int (card {p \\<in> \\<V> - {x}. p \\<in> bl}) = \\<k> - 1", "using bl_size x_in_set card_Diff_subset finite_sets k_non_zero"], ["proof (prove)\nusing this:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     card {p \\<in> \\<V> - {x}. p \\<in> bl} =\n     card ({p \\<in> \\<V>. p \\<in> bl} - {x})\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     int (card {p \\<in> \\<V>. p \\<in> bl}) = \\<k>\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     {x} \\<subseteq> {p \\<in> \\<V>. p \\<in> bl}\n  \\<lbrakk>finite ?B; ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> card (?A - ?B) = card ?A - card ?B\n  finite \\<V>\n  1 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n       int (card {p \\<in> \\<V> - {x}. p \\<in> bl}) = \\<k> - 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     int (card {p \\<in> \\<V> - {x}. p \\<in> bl}) = \\<k> - 1\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "then"], ["proof (chain)\npicking this:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     int (card {p \\<in> \\<V> - {x}. p \\<in> bl}) = \\<k> - 1", "have \"\\<And> bl . bl \\<in># ?B \\<Longrightarrow> size {#p \\<in># ?M . p \\<in> bl#} = nat (\\<k> - 1)\""], ["proof (prove)\nusing this:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     int (card {p \\<in> \\<V> - {x}. p \\<in> bl}) = \\<k> - 1\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># filter_mset ((\\<in>) x) \\<B> \\<Longrightarrow>\n       size {#p \\<in># mset_set (\\<V> - {x}). p \\<in> bl#} = nat (\\<k> - 1)", "using assms finite_M card_size_filter_eq"], ["proof (prove)\nusing this:\n  \\<forall>bl\\<in>#filter_mset ((\\<in>) x) \\<B>.\n     int (card {p \\<in> \\<V> - {x}. p \\<in> bl}) = \\<k> - 1\n  x \\<in> \\<V>\n  finite (\\<V> - {x})\n  finite ?A \\<Longrightarrow>\n  card {a \\<in> ?A. ?P a} = size (filter_mset ?P (mset_set ?A))\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># filter_mset ((\\<in>) x) \\<B> \\<Longrightarrow>\n       size {#p \\<in># mset_set (\\<V> - {x}). p \\<in> bl#} = nat (\\<k> - 1)", "by auto"], ["proof (state)\nthis:\n  ?bl \\<in># filter_mset ((\\<in>) x) \\<B> \\<Longrightarrow>\n  size {#p \\<in># mset_set (\\<V> - {x}). p \\<in> ?bl#} = nat (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "then"], ["proof (chain)\npicking this:\n  ?bl \\<in># filter_mset ((\\<in>) x) \\<B> \\<Longrightarrow>\n  size {#p \\<in># mset_set (\\<V> - {x}). p \\<in> ?bl#} = nat (\\<k> - 1)", "have \"size (\\<Sum>bl\\<in>#?B. ( {# p \\<in># ?M . p \\<in> bl #} \\<times># {#bl#})) = size (?B) * nat (\\<k> - 1)\""], ["proof (prove)\nusing this:\n  ?bl \\<in># filter_mset ((\\<in>) x) \\<B> \\<Longrightarrow>\n  size {#p \\<in># mset_set (\\<V> - {x}). p \\<in> ?bl#} = nat (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. size\n     (\\<Sum>bl\\<in>#filter_mset ((\\<in>) x)\n                     \\<B>. {#p \\<in># mset_set (\\<V> - {x}).\n                            p \\<in> bl#} \\<times>#\n                           {#bl#}) =\n    size (filter_mset ((\\<in>) x) \\<B>) * nat (\\<k> - 1)", "using distinct_m size_Union_distinct_cart_prod_filter2"], ["proof (prove)\nusing this:\n  ?bl \\<in># filter_mset ((\\<in>) x) \\<B> \\<Longrightarrow>\n  size {#p \\<in># mset_set (\\<V> - {x}). p \\<in> ?bl#} = nat (\\<k> - 1)\n  distinct_mset (mset_set (\\<V> - {x}))\n  \\<lbrakk>distinct_mset ?V;\n   \\<And>b.\n      b \\<in># ?B \\<Longrightarrow>\n      size {#v \\<in># ?V. ?P v b#} = ?c\\<rbrakk>\n  \\<Longrightarrow> size\n                     (\\<Sum>b\\<in>#?B. {#v \\<in># ?V. ?P v b#} \\<times>#\n {#b#}) =\n                    size ?B * ?c\n\ngoal (1 subgoal):\n 1. size\n     (\\<Sum>bl\\<in>#filter_mset ((\\<in>) x)\n                     \\<B>. {#p \\<in># mset_set (\\<V> - {x}).\n                            p \\<in> bl#} \\<times>#\n                           {#bl#}) =\n    size (filter_mset ((\\<in>) x) \\<B>) * nat (\\<k> - 1)", "by blast"], ["proof (state)\nthis:\n  size\n   (\\<Sum>bl\\<in>#filter_mset ((\\<in>) x)\n                   \\<B>. {#p \\<in># mset_set (\\<V> - {x}).\n                          p \\<in> bl#} \\<times>#\n                         {#bl#}) =\n  size (filter_mset ((\\<in>) x) \\<B>) * nat (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  size\n   (\\<Sum>bl\\<in>#filter_mset ((\\<in>) x)\n                   \\<B>. {#p \\<in># mset_set (\\<V> - {x}).\n                          p \\<in> bl#} \\<times>#\n                         {#bl#}) =\n  size (filter_mset ((\\<in>) x) \\<B>) * nat (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "using block_choices k_non_zero"], ["proof (prove)\nusing this:\n  size\n   (\\<Sum>bl\\<in>#filter_mset ((\\<in>) x)\n                   \\<B>. {#p \\<in># mset_set (\\<V> - {x}).\n                          p \\<in> bl#} \\<times>#\n                         {#bl#}) =\n  size (filter_mset ((\\<in>) x) \\<B>) * nat (\\<k> - 1)\n  int (size (filter_mset ((\\<in>) x) \\<B>)) = \\<B> rep x\n  1 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. int (size\n          {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                     filter_mset ((\\<in>) x) \\<B>.\n           fst p \\<in> snd p#}) =\n    \\<B> rep x * (\\<k> - 1)", "by (simp add: set_break_down_right)"], ["proof (state)\nthis:\n  int (size\n        {#p \\<in># mset_set (\\<V> - {x}) \\<times>#\n                   filter_mset ((\\<in>) x) \\<B>.\n         fst p \\<in> snd p#}) =\n  \\<B> rep x * (\\<k> - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_constant: \"x \\<in> \\<V> \\<Longrightarrow> (\\<B> rep x) * (\\<k> -1) = \\<Lambda> * (\\<v> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<V> \\<Longrightarrow>\n    \\<B> rep x * (\\<k> - 1) = \\<Lambda> * (\\<v> - 1)", "using necess_cond_1_rhs necess_cond_1_lhs design_points_nempty"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow>\n  int (size\n        {#p \\<in># mset_set (\\<V> - {?x}) \\<times>#\n                   filter_mset ((\\<in>) ?x) \\<B>.\n         fst p \\<in> snd p#}) =\n  \\<Lambda> * (\\<v> - 1)\n  ?x \\<in> \\<V> \\<Longrightarrow>\n  int (size\n        {#p \\<in># mset_set (\\<V> - {?x}) \\<times>#\n                   filter_mset ((\\<in>) ?x) \\<B>.\n         fst p \\<in> snd p#}) =\n  \\<B> rep ?x * (\\<k> - 1)\n  \\<V> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x \\<in> \\<V> \\<Longrightarrow>\n    \\<B> rep x * (\\<k> - 1) = \\<Lambda> * (\\<v> - 1)", "by force"], ["", "lemma replication_number_value:\n  assumes \"x \\<in> \\<V>\"\n  shows \"(\\<B> rep x) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "using min_block_size_2 r_constant assms diff_gt_0_iff_gt diff_self zle_diff1_eq numeral_le_one_iff"], ["proof (prove)\nusing this:\n  2 \\<le> \\<k>\n  ?x \\<in> \\<V> \\<Longrightarrow>\n  \\<B> rep ?x * (\\<k> - 1) = \\<Lambda> * (\\<v> - 1)\n  x \\<in> \\<V>\n  ((0::?'a) < ?a - ?b) = (?b < ?a)\n  ?a - ?a = (0::?'a)\n  (?w \\<le> ?z - 1) = (?w < ?z)\n  (numeral ?n \\<le> (1::?'a)) = (?n \\<le> num.One)\n\ngoal (1 subgoal):\n 1. \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "by (metis less_int_code(1) linorder_neqE_linordered_idom nonzero_mult_div_cancel_right semiring_norm(69))"], ["", "lemma r_constant_alt: \"\\<forall> x \\<in> \\<V>. \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<V>. \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "using r_constant replication_number_value"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow>\n  \\<B> rep ?x * (\\<k> - 1) = \\<Lambda> * (\\<v> - 1)\n  ?x \\<in> \\<V> \\<Longrightarrow>\n  \\<B> rep ?x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<V>. \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "by blast"], ["", "end"], ["", "text \\<open>Using the first necessary condition, it is possible to show that a bibd has \na constant replication number\\<close>"], ["", "sublocale bibd \\<subseteq> constant_rep_design \\<V> \\<B>  \"(\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> \\<B> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "using r_constant_alt"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<V>. \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> \\<B> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by (unfold_locales) simp_all"], ["", "lemma (in t_design) bibdI [intro]: \"\\<t> = 2 \\<Longrightarrow> bibd \\<V> \\<B> \\<k> \\<Lambda>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<t> = 2 \\<Longrightarrow> bibd \\<V> \\<B> \\<k> \\<Lambda>\\<^sub>t", "using t_lt_order block_size_t"], ["proof (prove)\nusing this:\n  \\<t> \\<le> \\<v>\n  \\<t> \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. \\<t> = 2 \\<Longrightarrow> bibd \\<V> \\<B> \\<k> \\<Lambda>\\<^sub>t", "by (unfold_locales) (simp_all)"], ["", "context bibd\nbegin"], ["", "abbreviation \"\\<r> \\<equiv> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\""], ["", "lemma necessary_condition_one: \n  shows \"\\<r> * (\\<k> - 1) = \\<Lambda> * (\\<v> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n    \\<Lambda> * (\\<v> - 1)", "using necess_cond_1_rhs necess_cond_1_lhs design_points_nempty rep_number"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow>\n  int (size\n        {#p \\<in># mset_set (\\<V> - {?x}) \\<times>#\n                   filter_mset ((\\<in>) ?x) \\<B>.\n         fst p \\<in> snd p#}) =\n  \\<Lambda> * (\\<v> - 1)\n  ?x \\<in> \\<V> \\<Longrightarrow>\n  int (size\n        {#p \\<in># mset_set (\\<V> - {?x}) \\<times>#\n                   filter_mset ((\\<in>) ?x) \\<B>.\n         fst p \\<in> snd p#}) =\n  \\<B> rep ?x * (\\<k> - 1)\n  \\<V> \\<noteq> {}\n  ?x \\<in> \\<V> \\<Longrightarrow>\n  \\<B> rep ?x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n    \\<Lambda> * (\\<v> - 1)", "by auto"], ["", "lemma bibd_point_occ_rep: \n  assumes \"x \\<in> bl\"\n  assumes \"bl \\<in># \\<B>\"\n  shows  \"(\\<B> - {#bl#}) rep x = \\<r> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove1_mset bl \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. remove1_mset bl \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "have xin: \"x \\<in> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<V>", "using assms wf_invalid_point"], ["proof (prove)\nusing this:\n  x \\<in> bl\n  bl \\<in># \\<B>\n  \\<lbrakk>?x \\<notin> \\<V>; ?b \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> ?b\n\ngoal (1 subgoal):\n 1. x \\<in> \\<V>", "by blast"], ["proof (state)\nthis:\n  x \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. remove1_mset bl \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<V>", "have rep: \"size {# blk \\<in># \\<B>. x \\<in> blk #} = \\<r>\""], ["proof (prove)\nusing this:\n  x \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<in>) x) \\<B>)) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "using rep_number_unfold_set"], ["proof (prove)\nusing this:\n  x \\<in> \\<V>\n  ?x \\<in> \\<V> \\<Longrightarrow>\n  int (size (filter_mset ((\\<in>) ?x) \\<B>)) =\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<in>) x) \\<B>)) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "by simp"], ["proof (state)\nthis:\n  int (size (filter_mset ((\\<in>) x) \\<B>)) =\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. remove1_mset bl \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "have \"(\\<B> - {#bl#}) rep x = size {# blk \\<in># (\\<B> - {#bl#}). x \\<in> blk #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove1_mset bl \\<B> rep x =\n    int (size (filter_mset ((\\<in>) x) (remove1_mset bl \\<B>)))", "by (simp add: point_replication_number_def)"], ["proof (state)\nthis:\n  remove1_mset bl \\<B> rep x =\n  int (size (filter_mset ((\\<in>) x) (remove1_mset bl \\<B>)))\n\ngoal (1 subgoal):\n 1. remove1_mset bl \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "then"], ["proof (chain)\npicking this:\n  remove1_mset bl \\<B> rep x =\n  int (size (filter_mset ((\\<in>) x) (remove1_mset bl \\<B>)))", "have \"(\\<B> - {#bl#}) rep x = size {# blk \\<in># \\<B>. x \\<in> blk #} - 1\""], ["proof (prove)\nusing this:\n  remove1_mset bl \\<B> rep x =\n  int (size (filter_mset ((\\<in>) x) (remove1_mset bl \\<B>)))\n\ngoal (1 subgoal):\n 1. remove1_mset bl \\<B> rep x =\n    int (size (filter_mset ((\\<in>) x) \\<B>) - 1)", "by (simp add: assms size_Diff_singleton)"], ["proof (state)\nthis:\n  remove1_mset bl \\<B> rep x = int (size (filter_mset ((\\<in>) x) \\<B>) - 1)\n\ngoal (1 subgoal):\n 1. remove1_mset bl \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "then"], ["proof (chain)\npicking this:\n  remove1_mset bl \\<B> rep x = int (size (filter_mset ((\\<in>) x) \\<B>) - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  remove1_mset bl \\<B> rep x = int (size (filter_mset ((\\<in>) x) \\<B>) - 1)\n\ngoal (1 subgoal):\n 1. remove1_mset bl \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "using assms rep r_gzero"], ["proof (prove)\nusing this:\n  remove1_mset bl \\<B> rep x = int (size (filter_mset ((\\<in>) x) \\<B>) - 1)\n  x \\<in> bl\n  bl \\<in># \\<B>\n  int (size (filter_mset ((\\<in>) x) \\<B>)) =\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  0 < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. remove1_mset bl \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "by simp"], ["proof (state)\nthis:\n  remove1_mset bl \\<B> rep x = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma necess_cond_2_lhs: \"size {# x \\<in># (mset_set \\<V> \\<times># \\<B>) . (fst x) \\<in> (snd x)  #} = \\<v> * \\<r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "let ?M = \"mset_set \\<V>\""], ["proof (state)\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"\\<And> p . p \\<in># ?M \\<Longrightarrow> size ({# bl \\<in># \\<B> . p \\<in> bl #}) = nat (\\<r>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in># mset_set \\<V> \\<Longrightarrow>\n       size (filter_mset ((\\<in>) p) \\<B>) =\n       nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "using finite_sets rep_number_unfold_set r_gzero nat_eq_iff2"], ["proof (prove)\nusing this:\n  finite \\<V>\n  ?x \\<in> \\<V> \\<Longrightarrow>\n  int (size (filter_mset ((\\<in>) ?x) \\<B>)) =\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  0 < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  (?m = nat ?w) = (if 0 \\<le> ?w then ?w = int ?m else ?m = 0)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in># mset_set \\<V> \\<Longrightarrow>\n       size (filter_mset ((\\<in>) p) \\<B>) =\n       nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by auto"], ["proof (state)\nthis:\n  ?p \\<in># mset_set \\<V> \\<Longrightarrow>\n  size (filter_mset ((\\<in>) ?p) \\<B>) =\n  nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "then"], ["proof (chain)\npicking this:\n  ?p \\<in># mset_set \\<V> \\<Longrightarrow>\n  size (filter_mset ((\\<in>) ?p) \\<B>) =\n  nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"size (\\<Sum>p\\<in>#?M. ({#p#} \\<times># {#bl \\<in># \\<B>. p \\<in> bl#})) = size ?M * nat (\\<r>)\""], ["proof (prove)\nusing this:\n  ?p \\<in># mset_set \\<V> \\<Longrightarrow>\n  size (filter_mset ((\\<in>) ?p) \\<B>) =\n  nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. size\n     (\\<Sum>p\\<in>#mset_set\n                    \\<V>. {#p#} \\<times># filter_mset ((\\<in>) p) \\<B>) =\n    size (mset_set \\<V>) * nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "using mset_points_distinct size_Union_distinct_cart_prod_filter"], ["proof (prove)\nusing this:\n  ?p \\<in># mset_set \\<V> \\<Longrightarrow>\n  size (filter_mset ((\\<in>) ?p) \\<B>) =\n  nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n  distinct_mset (mset_set \\<V>)\n  \\<lbrakk>distinct_mset ?M;\n   \\<And>p.\n      p \\<in># ?M \\<Longrightarrow>\n      size (filter_mset (?P p) ?B) = ?c\\<rbrakk>\n  \\<Longrightarrow> size\n                     (\\<Sum>p\\<in>#?M. {#p#} \\<times>#\n filter_mset (?P p) ?B) =\n                    size ?M * ?c\n\ngoal (1 subgoal):\n 1. size\n     (\\<Sum>p\\<in>#mset_set\n                    \\<V>. {#p#} \\<times># filter_mset ((\\<in>) p) \\<B>) =\n    size (mset_set \\<V>) * nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by blast"], ["proof (state)\nthis:\n  size\n   (\\<Sum>p\\<in>#mset_set\n                  \\<V>. {#p#} \\<times># filter_mset ((\\<in>) p) \\<B>) =\n  size (mset_set \\<V>) * nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  size\n   (\\<Sum>p\\<in>#mset_set\n                  \\<V>. {#p#} \\<times># filter_mset ((\\<in>) p) \\<B>) =\n  size (mset_set \\<V>) * nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "using r_gzero"], ["proof (prove)\nusing this:\n  size\n   (\\<Sum>p\\<in>#mset_set\n                  \\<V>. {#p#} \\<times># filter_mset ((\\<in>) p) \\<B>) =\n  size (mset_set \\<V>) * nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n  0 < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by (simp add: set_break_down_left)"], ["proof (state)\nthis:\n  int (size {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma necess_cond_2_rhs: \"size {# x \\<in># (mset_set \\<V> \\<times># \\<B>) . (fst x) \\<in> (snd x)  #} = \\<b>*\\<k>\" \n  (is \"size {# x \\<in># (?M \\<times># ?B). (fst x) \\<in> (snd x)  #} = \\<b>*\\<k>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<b> * \\<k>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<b> * \\<k>", "have \"\\<And> bl . bl \\<in># ?B \\<Longrightarrow> size ({# p \\<in># ?M . p \\<in> bl #}) = nat \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># \\<B> \\<Longrightarrow>\n       size {#p \\<in># mset_set \\<V>. p \\<in> bl#} = nat \\<k>", "using uniform k_non_zero uniform_unfold_point_set_mset"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  1 \\<le> \\<k>\n  ?bl \\<in># \\<B> \\<Longrightarrow>\n  int (size {#p \\<in># mset_set \\<V>. p \\<in> ?bl#}) = \\<k>\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># \\<B> \\<Longrightarrow>\n       size {#p \\<in># mset_set \\<V>. p \\<in> bl#} = nat \\<k>", "by fastforce"], ["proof (state)\nthis:\n  ?bl \\<in># \\<B> \\<Longrightarrow>\n  size {#p \\<in># mset_set \\<V>. p \\<in> ?bl#} = nat \\<k>\n\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<b> * \\<k>", "then"], ["proof (chain)\npicking this:\n  ?bl \\<in># \\<B> \\<Longrightarrow>\n  size {#p \\<in># mset_set \\<V>. p \\<in> ?bl#} = nat \\<k>", "have \"size (\\<Sum>bl\\<in>#?B. ( {# p \\<in># ?M . p \\<in> bl #} \\<times># {#bl#})) = size (?B) * (nat \\<k>)\""], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow>\n  size {#p \\<in># mset_set \\<V>. p \\<in> ?bl#} = nat \\<k>\n\ngoal (1 subgoal):\n 1. size\n     (\\<Sum>bl\\<in>#\\<B>. {#p \\<in># mset_set \\<V>. p \\<in> bl#} \\<times>#\n                          {#bl#}) =\n    size \\<B> * nat \\<k>", "using mset_points_distinct size_Union_distinct_cart_prod_filter2"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow>\n  size {#p \\<in># mset_set \\<V>. p \\<in> ?bl#} = nat \\<k>\n  distinct_mset (mset_set \\<V>)\n  \\<lbrakk>distinct_mset ?V;\n   \\<And>b.\n      b \\<in># ?B \\<Longrightarrow>\n      size {#v \\<in># ?V. ?P v b#} = ?c\\<rbrakk>\n  \\<Longrightarrow> size\n                     (\\<Sum>b\\<in>#?B. {#v \\<in># ?V. ?P v b#} \\<times>#\n {#b#}) =\n                    size ?B * ?c\n\ngoal (1 subgoal):\n 1. size\n     (\\<Sum>bl\\<in>#\\<B>. {#p \\<in># mset_set \\<V>. p \\<in> bl#} \\<times>#\n                          {#bl#}) =\n    size \\<B> * nat \\<k>", "by blast"], ["proof (state)\nthis:\n  size\n   (\\<Sum>bl\\<in>#\\<B>. {#p \\<in># mset_set \\<V>. p \\<in> bl#} \\<times>#\n                        {#bl#}) =\n  size \\<B> * nat \\<k>\n\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<b> * \\<k>", "thus ?thesis"], ["proof (prove)\nusing this:\n  size\n   (\\<Sum>bl\\<in>#\\<B>. {#p \\<in># mset_set \\<V>. p \\<in> bl#} \\<times>#\n                        {#bl#}) =\n  size \\<B> * nat \\<k>\n\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<b> * \\<k>", "using k_non_zero"], ["proof (prove)\nusing this:\n  size\n   (\\<Sum>bl\\<in>#\\<B>. {#p \\<in># mset_set \\<V>. p \\<in> bl#} \\<times>#\n                        {#bl#}) =\n  size \\<B> * nat \\<k>\n  1 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. int (size\n          {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n    \\<b> * \\<k>", "by (simp add: set_break_down_right)"], ["proof (state)\nthis:\n  int (size {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n  \\<b> * \\<k>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma necessary_condition_two:\n  shows \"\\<v> * \\<r> = \\<b> * \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>", "using necess_cond_2_lhs necess_cond_2_rhs"], ["proof (prove)\nusing this:\n  int (size {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n  int (size {#x \\<in># mset_set \\<V> \\<times># \\<B>. fst x \\<in> snd x#}) =\n  \\<b> * \\<k>\n\ngoal (1 subgoal):\n 1. \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>", "by simp"], ["", "theorem admissability_conditions:\n\"\\<r> * (\\<k> - 1) = \\<Lambda> * (\\<v> - 1)\"\n\"\\<v> * \\<r> = \\<b> * \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n    \\<Lambda> * (\\<v> - 1) &&&\n    \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>", "using necessary_condition_one necessary_condition_two"], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n  \\<Lambda> * (\\<v> - 1)\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n    \\<Lambda> * (\\<v> - 1) &&&\n    \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>", "by auto"], ["", "subsubsection \\<open>BIBD Param Relationships\\<close>"], ["", "lemma bibd_block_number: \"\\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k>-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))", "have \"\\<b> * \\<k> = (\\<v> * \\<r>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> * \\<k> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "using necessary_condition_two"], ["proof (prove)\nusing this:\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n\ngoal (1 subgoal):\n 1. \\<b> * \\<k> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by simp"], ["proof (state)\nthis:\n  \\<b> * \\<k> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))", "then"], ["proof (chain)\npicking this:\n  \\<b> * \\<k> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have k_dvd: \"\\<k> dvd (\\<v> * \\<r>)\""], ["proof (prove)\nusing this:\n  \\<b> * \\<k> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. \\<k> dvd \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by (metis dvd_triv_right)"], ["proof (state)\nthis:\n  \\<k> dvd \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))", "then"], ["proof (chain)\npicking this:\n  \\<k> dvd \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"\\<b> = (\\<v> * \\<r>) div \\<k>\""], ["proof (prove)\nusing this:\n  \\<k> dvd \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. \\<b> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>", "using necessary_condition_two min_block_size_2"], ["proof (prove)\nusing this:\n  \\<k> dvd \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n  2 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. \\<b> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>", "by auto"], ["proof (state)\nthis:\n  \\<b> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>\n\ngoal (1 subgoal):\n 1. \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))", "then"], ["proof (chain)\npicking this:\n  \\<b> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>", "have \"\\<b> = (\\<v> * ((\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)))) div \\<k>\""], ["proof (prove)\nusing this:\n  \\<b> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>\n\ngoal (1 subgoal):\n 1. \\<b> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>", "by simp"], ["proof (state)\nthis:\n  \\<b> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>\n\ngoal (1 subgoal):\n 1. \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))", "then"], ["proof (chain)\npicking this:\n  \\<b> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>", "have \"\\<b> = (\\<v> * \\<Lambda> * (\\<v> - 1)) div ((\\<k> - 1)* \\<k>)\""], ["proof (prove)\nusing this:\n  \\<b> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>\n\ngoal (1 subgoal):\n 1. \\<b> = \\<v> * \\<Lambda> * (\\<v> - 1) div ((\\<k> - 1) * \\<k>)", "using necessary_condition_one \n      necessary_condition_two dvd_div_div_eq_mult dvd_div_eq_0_iff"], ["proof (prove)\nusing this:\n  \\<b> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n  \\<Lambda> * (\\<v> - 1)\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n  \\<lbrakk>?a \\<noteq> (0::?'a); ?c \\<noteq> (0::?'a); ?a dvd ?b;\n   ?c dvd ?d\\<rbrakk>\n  \\<Longrightarrow> (?b div ?a = ?d div ?c) = (?b * ?c = ?a * ?d)\n  ?b dvd ?a \\<Longrightarrow> (?a div ?b = (0::?'a)) = (?a = (0::?'a))\n\ngoal (1 subgoal):\n 1. \\<b> = \\<v> * \\<Lambda> * (\\<v> - 1) div ((\\<k> - 1) * \\<k>)", "by (smt (z3) dvd_triv_right mult.assoc mult.commute mult.left_commute mult_eq_0_iff )"], ["proof (state)\nthis:\n  \\<b> = \\<v> * \\<Lambda> * (\\<v> - 1) div ((\\<k> - 1) * \\<k>)\n\ngoal (1 subgoal):\n 1. \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))", "then"], ["proof (chain)\npicking this:\n  \\<b> = \\<v> * \\<Lambda> * (\\<v> - 1) div ((\\<k> - 1) * \\<k>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<b> = \\<v> * \\<Lambda> * (\\<v> - 1) div ((\\<k> - 1) * \\<k>)\n\ngoal (1 subgoal):\n 1. \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma symmetric_condition_1: \"\\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1) \\<Longrightarrow> \\<b> = \\<v> \\<and> \\<r> = \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1) \\<Longrightarrow>\n    \\<b> = \\<v> \\<and> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) = \\<k>", "using b_non_zero bibd_block_number mult_eq_0_iff necessary_condition_two necessary_condition_one"], ["proof (prove)\nusing this:\n  \\<b> \\<noteq> 0\n  \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))\n  (?a * ?b = (0::?'a)) = (?a = (0::?'a) \\<or> ?b = (0::?'a))\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n  \\<Lambda> * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1) \\<Longrightarrow>\n    \\<b> = \\<v> \\<and> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) = \\<k>", "by auto"], ["", "lemma index_lt_replication: \"\\<Lambda> < \\<r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "have 1: \"\\<r> * (\\<k> - 1) = \\<Lambda> * (\\<v> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n    \\<Lambda> * (\\<v> - 1)", "using admissability_conditions"], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n  \\<Lambda> * (\\<v> - 1)\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n    \\<Lambda> * (\\<v> - 1)", "by simp"], ["proof (state)\nthis:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n  \\<Lambda> * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "have lhsnot0: \"\\<r> * (\\<k> - 1) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) \\<noteq> 0", "using no_zero_divisors rep_not_zero zdiv_eq_0_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<noteq> (0::?'a); ?b \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?a * ?b \\<noteq> (0::?'a)\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) \\<noteq> 0\n  (?i div ?k = 0) =\n  (?k = 0 \\<or> 0 \\<le> ?i \\<and> ?i < ?k \\<or> ?i \\<le> 0 \\<and> ?k < ?i)\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "then"], ["proof (chain)\npicking this:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) \\<noteq> 0", "have rhsnot0: \"\\<Lambda> * (\\<v> - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) \\<noteq> 0", "using 1"], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) \\<noteq> 0\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n  \\<Lambda> * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  \\<Lambda> * (\\<v> - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "have \"\\<k> - 1 < \\<v> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<k> - 1 < \\<v> - 1", "using incomplete b_non_zero bibd_block_number not_less_eq"], ["proof (prove)\nusing this:\n  \\<k> < \\<v>\n  \\<b> \\<noteq> 0\n  \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))\n  (\\<not> ?m < ?n) = (?n < Suc ?m)\n\ngoal (1 subgoal):\n 1. \\<k> - 1 < \\<v> - 1", "by fastforce"], ["proof (state)\nthis:\n  \\<k> - 1 < \\<v> - 1\n\ngoal (1 subgoal):\n 1. \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<k> - 1 < \\<v> - 1\n\ngoal (1 subgoal):\n 1. \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "using 1 lhsnot0 rhsnot0"], ["proof (prove)\nusing this:\n  \\<k> - 1 < \\<v> - 1\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n  \\<Lambda> * (\\<v> - 1)\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) \\<noteq> 0\n  \\<Lambda> * (\\<v> - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "by (smt (verit, best) k_non_zero mult_le_less_imp_less r_gzero)"], ["proof (state)\nthis:\n  \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_not_zero: \"\\<Lambda> \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> \\<Lambda>", "using index_ge_zero index_lt_replication int_one_le_iff_zero_less"], ["proof (prove)\nusing this:\n  0 \\<le> \\<Lambda>\n  \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  (1 \\<le> ?z) = (0 < ?z)\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<Lambda>", "by fastforce"], ["", "lemma r_ge_two: \"\\<r> \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "using index_lt_replication index_not_zero"], ["proof (prove)\nusing this:\n  \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  1 \\<le> \\<Lambda>\n\ngoal (1 subgoal):\n 1. 2 \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "by linarith"], ["", "lemma block_num_gt_rep: \"\\<b> > \\<r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) < \\<b>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) < \\<b>", "have fact: \"\\<b> * \\<k> = \\<v> * \\<r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> * \\<k> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "using admissability_conditions"], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n  \\<Lambda> * (\\<v> - 1)\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n\ngoal (1 subgoal):\n 1. \\<b> * \\<k> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by auto"], ["proof (state)\nthis:\n  \\<b> * \\<k> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) < \\<b>", "have lhsnot0: \"\\<b> * \\<k> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> * \\<k> \\<noteq> 0", "using k_non_zero b_non_zero"], ["proof (prove)\nusing this:\n  1 \\<le> \\<k>\n  \\<b> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<b> * \\<k> \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<b> * \\<k> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) < \\<b>", "then"], ["proof (chain)\npicking this:\n  \\<b> * \\<k> \\<noteq> 0", "have rhsnot0: \"\\<v> * \\<r> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<b> * \\<k> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) \\<noteq> 0", "using fact"], ["proof (prove)\nusing this:\n  \\<b> * \\<k> \\<noteq> 0\n  \\<b> * \\<k> = \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) < \\<b>", "then"], ["proof (chain)\npicking this:\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) < \\<b>", "using incomplete lhsnot0"], ["proof (prove)\nusing this:\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) \\<noteq> 0\n  \\<k> < \\<v>\n  \\<b> * \\<k> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) < \\<b>", "using complement_rep_number constant_rep_design.r_gzero incomplete_imp_incomp_block"], ["proof (prove)\nusing this:\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) \\<noteq> 0\n  \\<k> < \\<v>\n  \\<b> * \\<k> \\<noteq> 0\n  (\\<And>bl.\n      bl \\<in># \\<B> \\<Longrightarrow>\n      incomplete_block bl) \\<Longrightarrow>\n  constant_rep_design \\<V> \\<B>\\<^sup>C\n   (\\<b> - \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n  constant_rep_design ?point_set ?block_collection\n   ?design_rep_number \\<Longrightarrow>\n  0 < ?design_rep_number\n  ?bl \\<in># \\<B> \\<Longrightarrow> incomplete_block ?bl\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) < \\<b>", "by fastforce"], ["proof (state)\nthis:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) < \\<b>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bibd_subset_occ: \n  assumes \"x \\<subseteq> bl\" and \"bl \\<in># \\<B>\" and \"card x = 2\"\n  shows \"size {# blk \\<in># (\\<B> - {#bl#}). x \\<subseteq> blk #} = \\<Lambda> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>))) =\n    \\<Lambda> - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>))) =\n    \\<Lambda> - 1", "have index: \"size {# blk \\<in># \\<B>. x \\<subseteq> blk #} = \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) x) \\<B>)) = \\<Lambda>", "using points_index_def balanced assms"], ["proof (prove)\nusing this:\n  ?B index ?ps \\<equiv> size (filter_mset ((\\<subseteq>) ?ps) ?B)\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = 2\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) = \\<Lambda>\n  x \\<subseteq> bl\n  bl \\<in># \\<B>\n  card x = 2\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) x) \\<B>)) = \\<Lambda>", "by (metis (full_types) of_nat_numeral subset_eq wf_invalid_point)"], ["proof (state)\nthis:\n  int (size (filter_mset ((\\<subseteq>) x) \\<B>)) = \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>))) =\n    \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  int (size (filter_mset ((\\<subseteq>) x) \\<B>)) = \\<Lambda>", "have \"size {# blk \\<in># (\\<B> - {#bl#}). x \\<subseteq> blk #} = size {# blk \\<in># \\<B>. x \\<subseteq> blk #} - 1\""], ["proof (prove)\nusing this:\n  int (size (filter_mset ((\\<subseteq>) x) \\<B>)) = \\<Lambda>\n\ngoal (1 subgoal):\n 1. size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>)) =\n    size (filter_mset ((\\<subseteq>) x) \\<B>) - 1", "by (simp add: assms size_Diff_singleton)"], ["proof (state)\nthis:\n  size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>)) =\n  size (filter_mset ((\\<subseteq>) x) \\<B>) - 1\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>))) =\n    \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>)) =\n  size (filter_mset ((\\<subseteq>) x) \\<B>) - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>)) =\n  size (filter_mset ((\\<subseteq>) x) \\<B>) - 1\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>))) =\n    \\<Lambda> - 1", "using assms index_not_zero index"], ["proof (prove)\nusing this:\n  size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>)) =\n  size (filter_mset ((\\<subseteq>) x) \\<B>) - 1\n  x \\<subseteq> bl\n  bl \\<in># \\<B>\n  card x = 2\n  1 \\<le> \\<Lambda>\n  int (size (filter_mset ((\\<subseteq>) x) \\<B>)) = \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>))) =\n    \\<Lambda> - 1", "by simp"], ["proof (state)\nthis:\n  int (size (filter_mset ((\\<subseteq>) x) (remove1_mset bl \\<B>))) =\n  \\<Lambda> - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma necess_cond_one_param_balance: \"\\<b> > \\<v> \\<Longrightarrow> \\<r> > \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<v> < \\<b> \\<Longrightarrow>\n    \\<k> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "using necessary_condition_two"], ["proof (prove)\nusing this:\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n\ngoal (1 subgoal):\n 1. \\<v> < \\<b> \\<Longrightarrow>\n    \\<k> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "by (smt mult_nonneg_nonneg nonzero_mult_div_cancel_right of_nat_0_le_iff r_gzero zdiv_mono2)"], ["", "subsection \\<open>Constructing New bibd's\\<close>"], ["", "text \\<open>There are many constructions on bibd's to establish new bibds (or other types of designs). \nThis section demonstrates this using both existing constructions, and by defining new constructions.\\<close>"], ["", "subsubsection \\<open>BIBD Complement, Multiple, Combine\\<close>"], ["", "lemma comp_params_index_pair:\n  assumes \"{x, y} \\<subseteq> \\<V>\"\n  assumes \"x \\<noteq> y\"\n  shows \"\\<B>\\<^sup>C index {x, y} = \\<b> + \\<Lambda> - 2*\\<r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have xin: \"x \\<in> \\<V>\" and yin: \"y \\<in> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<V> &&& y \\<in> \\<V>", "using assms"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> \\<V>\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<in> \\<V> &&& y \\<in> \\<V>", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<V>\n  y \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have ge: \"2*\\<r> \\<ge> \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> \\<le> 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "using index_lt_replication"], ["proof (prove)\nusing this:\n  \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. \\<Lambda> \\<le> 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "using r_gzero"], ["proof (prove)\nusing this:\n  \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  0 < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. \\<Lambda> \\<le> 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by linarith"], ["proof (state)\nthis:\n  \\<Lambda> \\<le> 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"size {# b \\<in># \\<B> . x \\<in> b \\<and> y \\<in> b#} =  \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#}) = \\<Lambda>", "using points_index_pair assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> \\<V>; ?x \\<in> \\<V>; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> int (size (filter_mset ((\\<subseteq>) {?x, ?y}) \\<B>)) =\n                    \\<Lambda>\n  {x, y} \\<subseteq> \\<V>\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. int (size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#}) = \\<Lambda>", "by simp"], ["proof (state)\nthis:\n  int (size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#}) = \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "then"], ["proof (chain)\npicking this:\n  int (size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#}) = \\<Lambda>", "have lambda: \"size {# b \\<in># \\<B> . x \\<in> b \\<and> y \\<in> b#} = nat \\<Lambda>\""], ["proof (prove)\nusing this:\n  int (size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#}) = \\<Lambda>\n\ngoal (1 subgoal):\n 1. size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#} = nat \\<Lambda>", "using index_ge_zero"], ["proof (prove)\nusing this:\n  int (size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#}) = \\<Lambda>\n  0 \\<le> \\<Lambda>\n\ngoal (1 subgoal):\n 1. size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#} = nat \\<Lambda>", "by auto"], ["proof (state)\nthis:\n  size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#} = nat \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"\\<B>\\<^sup>C index {x, y} = size {# b \\<in># \\<B> . x \\<notin> b \\<and> y \\<notin> b #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index {x, y} =\n    size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#}", "using complement_index_2 assms"], ["proof (prove)\nusing this:\n  {?x, ?y} \\<subseteq> \\<V> \\<Longrightarrow>\n  \\<B>\\<^sup>C index {?x, ?y} =\n  size {#b \\<in># \\<B>. ?x \\<notin> b \\<and> ?y \\<notin> b#}\n  {x, y} \\<subseteq> \\<V>\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>C index {x, y} =\n    size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#}", "by simp"], ["proof (state)\nthis:\n  \\<B>\\<^sup>C index {x, y} =\n  size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#}\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  \\<B>\\<^sup>C index {x, y} =\n  size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#}\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"\\<dots> = size \\<B> - (size {# b \\<in># \\<B> . \\<not> (x \\<notin> b \\<and> y \\<notin> b) #})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#} =\n    size \\<B> -\n    size {#b \\<in># \\<B>. \\<not> (x \\<notin> b \\<and> y \\<notin> b)#}", "using size_filter_neg"], ["proof (prove)\nusing this:\n  size (filter_mset ?P ?A) = size ?A - size {#a \\<in># ?A. \\<not> ?P a#}\n\ngoal (1 subgoal):\n 1. size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#} =\n    size \\<B> -\n    size {#b \\<in># \\<B>. \\<not> (x \\<notin> b \\<and> y \\<notin> b)#}", "by blast"], ["proof (state)\nthis:\n  size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#} =\n  size \\<B> -\n  size {#b \\<in># \\<B>. \\<not> (x \\<notin> b \\<and> y \\<notin> b)#}\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  size {#b \\<in># \\<B>. x \\<notin> b \\<and> y \\<notin> b#} =\n  size \\<B> -\n  size {#b \\<in># \\<B>. \\<not> (x \\<notin> b \\<and> y \\<notin> b)#}\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... = size \\<B> - (size {# b \\<in># \\<B> . x \\<in> b \\<or> y \\<in> b#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size \\<B> -\n    size {#b \\<in># \\<B>. \\<not> (x \\<notin> b \\<and> y \\<notin> b)#} =\n    size \\<B> - size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#}", "by auto"], ["proof (state)\nthis:\n  size \\<B> -\n  size {#b \\<in># \\<B>. \\<not> (x \\<notin> b \\<and> y \\<notin> b)#} =\n  size \\<B> - size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#}\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  size \\<B> -\n  size {#b \\<in># \\<B>. \\<not> (x \\<notin> b \\<and> y \\<notin> b)#} =\n  size \\<B> - size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#}\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... = \\<b> - (size {# b \\<in># \\<B> . x \\<in> b \\<or> y \\<in> b#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size \\<B> - size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#}) =\n    \\<b> - int (size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#})", "by (simp add: of_nat_diff)"], ["proof (state)\nthis:\n  int (size \\<B> - size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#}) =\n  \\<b> - int (size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#})\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  int (size \\<B> - size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#}) =\n  \\<b> - int (size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#})\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... = \\<b> - (size {# b \\<in># \\<B> . x \\<in> b#} +  \n    size {# b \\<in># \\<B> . y \\<in> b#} -  size {# b \\<in># \\<B> . x \\<in> b \\<and> y \\<in> b#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> - int (size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#}) =\n    \\<b> -\n    int (size (filter_mset ((\\<in>) x) \\<B>) +\n         size (filter_mset ((\\<in>) y) \\<B>) -\n         size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#})", "by (simp add: mset_size_partition_dep)"], ["proof (state)\nthis:\n  \\<b> - int (size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#}) =\n  \\<b> -\n  int (size (filter_mset ((\\<in>) x) \\<B>) +\n       size (filter_mset ((\\<in>) y) \\<B>) -\n       size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#})\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  \\<b> - int (size {#b \\<in># \\<B>. x \\<in> b \\<or> y \\<in> b#}) =\n  \\<b> -\n  int (size (filter_mset ((\\<in>) x) \\<B>) +\n       size (filter_mset ((\\<in>) y) \\<B>) -\n       size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#})\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... = \\<b> - (nat \\<r> + nat \\<r> - nat (\\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> -\n    int (size (filter_mset ((\\<in>) x) \\<B>) +\n         size (filter_mset ((\\<in>) y) \\<B>) -\n         size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#}) =\n    \\<b> -\n    int (nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) +\n         nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n         nat \\<Lambda>)", "using rep_number_unfold_set lambda xin yin"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow>\n  int (size (filter_mset ((\\<in>) ?x) \\<B>)) =\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#} = nat \\<Lambda>\n  x \\<in> \\<V>\n  y \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. \\<b> -\n    int (size (filter_mset ((\\<in>) x) \\<B>) +\n         size (filter_mset ((\\<in>) y) \\<B>) -\n         size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#}) =\n    \\<b> -\n    int (nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) +\n         nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n         nat \\<Lambda>)", "by (metis (no_types, lifting) nat_int)"], ["proof (state)\nthis:\n  \\<b> -\n  int (size (filter_mset ((\\<in>) x) \\<B>) +\n       size (filter_mset ((\\<in>) y) \\<B>) -\n       size {#b \\<in># \\<B>. x \\<in> b \\<and> y \\<in> b#}) =\n  \\<b> -\n  int (nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) +\n       nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n       nat \\<Lambda>)\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "finally"], ["proof (chain)\npicking this:\n  int (\\<B>\\<^sup>C index {x, y}) =\n  \\<b> -\n  int (nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) +\n       nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n       nat \\<Lambda>)", "have \"\\<B>\\<^sup>C index {x, y} = \\<b> - (2*\\<r> - \\<Lambda>)\""], ["proof (prove)\nusing this:\n  int (\\<B>\\<^sup>C index {x, y}) =\n  \\<b> -\n  int (nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) +\n       nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n       nat \\<Lambda>)\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> - (2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) - \\<Lambda>)", "using index_ge_zero index_lt_replication"], ["proof (prove)\nusing this:\n  int (\\<B>\\<^sup>C index {x, y}) =\n  \\<b> -\n  int (nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) +\n       nat (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n       nat \\<Lambda>)\n  0 \\<le> \\<Lambda>\n  \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> - (2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) - \\<Lambda>)", "by linarith"], ["proof (state)\nthis:\n  int (\\<B>\\<^sup>C index {x, y}) =\n  \\<b> - (2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) - \\<Lambda>)\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (\\<B>\\<^sup>C index {x, y}) =\n  \\<b> - (2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) - \\<Lambda>)\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "using ge diff_diff_right"], ["proof (prove)\nusing this:\n  int (\\<B>\\<^sup>C index {x, y}) =\n  \\<b> - (2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) - \\<Lambda>)\n  \\<Lambda> \\<le> 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n  ?k \\<le> ?j \\<Longrightarrow> ?i - (?j - ?k) = ?i + ?k - ?j\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index {x, y}) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by simp"], ["proof (state)\nthis:\n  int (\\<B>\\<^sup>C index {x, y}) =\n  \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complement_bibd_index: \n  assumes \"ps \\<subseteq> \\<V>\"\n  assumes \"card ps = 2\"\n  shows \"\\<B>\\<^sup>C index ps = \\<b> + \\<Lambda> - 2*\\<r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index ps) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index ps) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "obtain x y where set: \"ps = {x, y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. ps = {x, y} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_non_zero bibd_block_number diff_is_0_eq incomplete \n    mult_0_right nat_less_le design_points_nempty assms"], ["proof (prove)\nusing this:\n  \\<b> \\<noteq> 0\n  \\<b> = \\<Lambda> * \\<v> * (\\<v> - 1) div (\\<k> * (\\<k> - 1))\n  (?m - ?n = 0) = (?m \\<le> ?n)\n  \\<k> < \\<v>\n  ?m * 0 = 0\n  (?m < ?n) = (?m \\<le> ?n \\<and> ?m \\<noteq> ?n)\n  \\<V> \\<noteq> {}\n  ps \\<subseteq> \\<V>\n  card ps = 2\n\ngoal (1 subgoal):\n 1. (\\<And>x y. ps = {x, y} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis card_2_iff)"], ["proof (state)\nthis:\n  ps = {x, y}\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index ps) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "then"], ["proof (chain)\npicking this:\n  ps = {x, y}", "have \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  ps = {x, y}\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "using assms"], ["proof (prove)\nusing this:\n  ps = {x, y}\n  ps \\<subseteq> \\<V>\n  card ps = 2\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index ps) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index ps) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "using comp_params_index_pair assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<lbrakk>{?x, ?y} \\<subseteq> \\<V>; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> int (\\<B>\\<^sup>C index {?x, ?y}) =\n                    \\<b> + \\<Lambda> -\n                    2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n  ps \\<subseteq> \\<V>\n  card ps = 2\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>C index ps) =\n    \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by (simp add: set)"], ["proof (state)\nthis:\n  int (\\<B>\\<^sup>C index ps) =\n  \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complement_bibd: \n  assumes \"\\<k> \\<le> \\<v> - 2\" \n  shows \"bibd \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>) (\\<b> + \\<Lambda> - 2*\\<r>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bibd \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)\n     (\\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bibd \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)\n     (\\<b> + \\<Lambda> - 2 * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)))", "interpret des: incomplete_design \\<V> \"\\<B>\\<^sup>C\" \"(\\<v> - \\<k>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incomplete_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)", "using assms complement_incomplete"], ["proof (prove)\nusing this:\n  \\<k> \\<le> \\<v> - 2\n  incomplete_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)\n\ngoal (1 subgoal):\n 1. incomplete_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. bibd \\<V> \\<B>\\<^sup>C (des.\\<v> - \\<k>)\n     (\\<b> + \\<Lambda> - 2 * (\\<Lambda> * (des.\\<v> - 1) div (\\<k> - 1)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bibd \\<V> \\<B>\\<^sup>C (des.\\<v> - \\<k>)\n     (\\<b> + \\<Lambda> - 2 * (\\<Lambda> * (des.\\<v> - 1) div (\\<k> - 1)))", "proof (unfold_locales, simp_all)"], ["proof (state)\ngoal (3 subgoals):\n 1. 2 \\<le> des.\\<v>\n 2. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> \\<V>; card ps = 2\\<rbrakk>\n       \\<Longrightarrow> int (\\<B>\\<^sup>C index ps) =\n                         \\<b> + \\<Lambda> -\n                         2 * (\\<Lambda> * (des.\\<v> - 1) div (\\<k> - 1))\n 3. 2 \\<le> des.\\<v> - \\<k>", "show \"2 \\<le> des.\\<v>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> des.\\<v>", "using assms block_size_t"], ["proof (prove)\nusing this:\n  \\<k> \\<le> des.\\<v> - 2\n  2 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. 2 \\<le> des.\\<v>", "by linarith"], ["proof (state)\nthis:\n  2 \\<le> des.\\<v>\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> \\<V>; card ps = 2\\<rbrakk>\n       \\<Longrightarrow> int (\\<B>\\<^sup>C index ps) =\n                         \\<b> + \\<Lambda> -\n                         2 * (\\<Lambda> * (des.\\<v> - 1) div (\\<k> - 1))\n 2. 2 \\<le> des.\\<v> - \\<k>", "show \"\\<And>ps. ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = 2 \\<Longrightarrow> \n      \\<B>\\<^sup>C index ps = \\<b> + \\<Lambda> - 2 * (\\<Lambda> * (des.\\<v> - 1) div (\\<k> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> \\<V>; card ps = 2\\<rbrakk>\n       \\<Longrightarrow> int (\\<B>\\<^sup>C index ps) =\n                         \\<b> + \\<Lambda> -\n                         2 * (\\<Lambda> * (des.\\<v> - 1) div (\\<k> - 1))", "using complement_bibd_index"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ps \\<subseteq> \\<V>; card ?ps = 2\\<rbrakk>\n  \\<Longrightarrow> int (\\<B>\\<^sup>C index ?ps) =\n                    \\<b> + \\<Lambda> -\n                    2 * (\\<Lambda> * (des.\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> \\<V>; card ps = 2\\<rbrakk>\n       \\<Longrightarrow> int (\\<B>\\<^sup>C index ps) =\n                         \\<b> + \\<Lambda> -\n                         2 * (\\<Lambda> * (des.\\<v> - 1) div (\\<k> - 1))", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?ps \\<subseteq> \\<V>; card ?ps = 2\\<rbrakk>\n  \\<Longrightarrow> int (\\<B>\\<^sup>C index ?ps) =\n                    \\<b> + \\<Lambda> -\n                    2 * (\\<Lambda> * (des.\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. 2 \\<le> des.\\<v> - \\<k>", "show \"2 \\<le> des.\\<v> - \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> des.\\<v> - \\<k>", "using assms block_size_t"], ["proof (prove)\nusing this:\n  \\<k> \\<le> des.\\<v> - 2\n  2 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. 2 \\<le> des.\\<v> - \\<k>", "by linarith"], ["proof (state)\nthis:\n  2 \\<le> des.\\<v> - \\<k>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bibd \\<V> \\<B>\\<^sup>C (des.\\<v> - \\<k>)\n   (\\<b> + \\<Lambda> - 2 * (\\<Lambda> * (des.\\<v> - 1) div (\\<k> - 1)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multiple_bibd: \"n > 0 \\<Longrightarrow> bibd \\<V> (multiple_blocks n) \\<k> (\\<Lambda> * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    bibd \\<V> (multiple_blocks n) \\<k> (\\<Lambda> * int n)", "using multiple_t_design"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow>\n  t_design \\<V> (multiple_blocks ?n) \\<k> 2 (\\<Lambda> * int ?n)\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    bibd \\<V> (multiple_blocks n) \\<k> (\\<Lambda> * int n)", "by (simp add: bibd_def)"], ["", "end"], ["", "locale two_bibd_eq_points = two_t_designs_eq_points \\<V> \\<B> \\<k> \\<B>' 2 \\<Lambda> \\<Lambda>'\n  + des1: bibd \\<V> \\<B> \\<k> \\<Lambda> + des2: bibd \\<V> \\<B>' \\<k> \\<Lambda>' for \\<V> \\<B> \\<k> \\<B>' \\<Lambda> \\<Lambda>'\nbegin"], ["", "lemma combine_is_bibd: \"bibd \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k> (\\<Lambda> + \\<Lambda>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bibd \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k> (\\<Lambda> + \\<Lambda>')", "by (unfold_locales)"], ["", "sublocale combine_bibd: bibd \"\\<V>\\<^sup>+\" \"\\<B>\\<^sup>+\" \"\\<k>\" \"(\\<Lambda> + \\<Lambda>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bibd \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k> (\\<Lambda> + \\<Lambda>')", "by (unfold_locales)"], ["", "end"], ["", "subsubsection \\<open>Derived Designs\\<close>"], ["", "text \\<open>A derived bibd takes a block from a valid bibd as the new point sets, and the intersection \nof that block with other blocks as it's block set\\<close>"], ["", "locale bibd_block_transformations = bibd + \n  fixes block :: \"'a set\" (\"bl\")\n  assumes valid_block: \"bl \\<in># \\<B>\"\nbegin"], ["", "definition derived_blocks :: \"'a set multiset\" (\"(\\<B>\\<^sup>D)\") where \n\"\\<B>\\<^sup>D \\<equiv> {# bl \\<inter> b . b \\<in># (\\<B> - {#bl#}) #}\""], ["", "lemma derive_define_flip: \"{# b \\<inter> bl . b \\<in># (\\<B> - {#bl#}) #} = \\<B>\\<^sup>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#b \\<inter> bl. b \\<in># remove1_mset bl \\<B>#} = \\<B>\\<^sup>D", "by (simp add: derived_blocks_def inf_sup_aci(1))"], ["", "lemma derived_points_order: \"card bl = \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card bl) = \\<k>", "using uniform valid_block"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. int (card bl) = \\<k>", "by simp"], ["", "lemma derived_block_num: \"bl \\<in># \\<B> \\<Longrightarrow> size \\<B>\\<^sup>D = \\<b> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> int (size \\<B>\\<^sup>D) = \\<b> - 1", "apply (simp add: derived_blocks_def size_remove1_mset_If valid_block)"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size \\<B> - Suc 0) = \\<b> - 1", "using valid_block int_ops(6)"], ["proof (prove)\nusing this:\n  bl \\<in># \\<B>\n  int (?a - ?b) = (if int ?a < int ?b then 0 else int ?a - int ?b)\n\ngoal (1 subgoal):\n 1. int (size \\<B> - Suc 0) = \\<b> - 1", "by fastforce"], ["", "lemma derived_is_wellformed:  \"b \\<in># \\<B>\\<^sup>D \\<Longrightarrow> b \\<subseteq> bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in># \\<B>\\<^sup>D \\<Longrightarrow> b \\<subseteq> bl", "by (simp add: derived_blocks_def valid_block) (auto)"], ["", "lemma derived_point_subset_orig: \"ps \\<subseteq> bl \\<Longrightarrow> ps \\<subset> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<subseteq> bl \\<Longrightarrow> ps \\<subset> \\<V>", "by (simp add: valid_block incomplete_imp_proper_subset subset_psubset_trans)"], ["", "lemma derived_obtain_orig_block: \n  assumes \"b \\<in># \\<B>\\<^sup>D\"\n  obtains b2 where \"b = b2 \\<inter> bl\" and \"b2 \\<in># remove1_mset bl \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b2.\n        \\<lbrakk>b = b2 \\<inter> bl; b2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms derived_blocks_def"], ["proof (prove)\nusing this:\n  b \\<in># \\<B>\\<^sup>D\n  \\<B>\\<^sup>D \\<equiv> image_mset ((\\<inter>) bl) (remove1_mset bl \\<B>)\n\ngoal (1 subgoal):\n 1. (\\<And>b2.\n        \\<lbrakk>b = b2 \\<inter> bl; b2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "sublocale derived_incidence_sys: incidence_system \"bl\" \"\\<B>\\<^sup>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system bl \\<B>\\<^sup>D", "using derived_is_wellformed valid_block"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B>\\<^sup>D \\<Longrightarrow> ?b \\<subseteq> bl\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. incidence_system bl \\<B>\\<^sup>D", "by (unfold_locales) (auto)"], ["", "sublocale derived_fin_incidence_system: finite_incidence_system \"bl\" \"\\<B>\\<^sup>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system bl \\<B>\\<^sup>D", "using valid_block finite_blocks"], ["proof (prove)\nusing this:\n  bl \\<in># \\<B>\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n\ngoal (1 subgoal):\n 1. finite_incidence_system bl \\<B>\\<^sup>D", "by (unfold_locales) simp_all"], ["", "lemma derived_blocks_nempty:\n  assumes \"\\<And> b .b \\<in># remove1_mset bl \\<B> \\<Longrightarrow> bl |\\<inter>| b > 0\"\n  assumes \"bld \\<in># \\<B>\\<^sup>D\"\n  shows \"bld \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "obtain bl2 where inter: \"bld = bl2 \\<inter> bl\" and member: \"bl2 \\<in># remove1_mset bl \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>bld = bl2 \\<inter> bl;\n         bl2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms derived_obtain_orig_block"], ["proof (prove)\nusing this:\n  ?b \\<in># remove1_mset bl \\<B> \\<Longrightarrow> 0 < bl |\\<inter>| ?b\n  bld \\<in># \\<B>\\<^sup>D\n  \\<lbrakk>?b \\<in># \\<B>\\<^sup>D;\n   \\<And>b2.\n      \\<lbrakk>?b = b2 \\<inter> bl; b2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>bld = bl2 \\<inter> bl;\n         bl2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bld = bl2 \\<inter> bl\n  bl2 \\<in># remove1_mset bl \\<B>\n\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  bld = bl2 \\<inter> bl\n  bl2 \\<in># remove1_mset bl \\<B>", "have \"bl |\\<inter>| bl2 > 0\""], ["proof (prove)\nusing this:\n  bld = bl2 \\<inter> bl\n  bl2 \\<in># remove1_mset bl \\<B>\n\ngoal (1 subgoal):\n 1. 0 < bl |\\<inter>| bl2", "using assms(1)"], ["proof (prove)\nusing this:\n  bld = bl2 \\<inter> bl\n  bl2 \\<in># remove1_mset bl \\<B>\n  ?b \\<in># remove1_mset bl \\<B> \\<Longrightarrow> 0 < bl |\\<inter>| ?b\n\ngoal (1 subgoal):\n 1. 0 < bl |\\<inter>| bl2", "by blast"], ["proof (state)\nthis:\n  0 < bl |\\<inter>| bl2\n\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < bl |\\<inter>| bl2\n\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "using intersection_number_empty_iff finite_blocks valid_block"], ["proof (prove)\nusing this:\n  0 < bl |\\<inter>| bl2\n  finite ?b1.0 \\<Longrightarrow>\n  (?b1.0 \\<inter> ?b2.0 = {}) = (?b1.0 |\\<inter>| ?b2.0 = 0)\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "by (metis Int_commute dual_order.irrefl inter)"], ["proof (state)\nthis:\n  bld \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derived_is_design:\n  assumes \"\\<And> b. b \\<in># remove1_mset bl \\<B> \\<Longrightarrow> bl |\\<inter>| b > 0\"\n  shows \"design bl \\<B>\\<^sup>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design bl \\<B>\\<^sup>D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. design bl \\<B>\\<^sup>D", "interpret fin: finite_incidence_system \"bl\" \"\\<B>\\<^sup>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system bl \\<B>\\<^sup>D", "by (unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. design bl \\<B>\\<^sup>D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. design bl \\<B>\\<^sup>D", "using assms derived_blocks_nempty"], ["proof (prove)\nusing this:\n  ?b \\<in># remove1_mset bl \\<B> \\<Longrightarrow> 0 < bl |\\<inter>| ?b\n  \\<lbrakk>\\<And>b.\n              b \\<in># remove1_mset bl \\<B> \\<Longrightarrow>\n              0 < bl |\\<inter>| b;\n   ?bld \\<in># \\<B>\\<^sup>D\\<rbrakk>\n  \\<Longrightarrow> ?bld \\<noteq> {}\n\ngoal (1 subgoal):\n 1. design bl \\<B>\\<^sup>D", "by (unfold_locales) simp"], ["proof (state)\nthis:\n  design bl \\<B>\\<^sup>D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derived_is_proper: \n  assumes \"\\<And> b. b \\<in># remove1_mset bl \\<B> \\<Longrightarrow> bl |\\<inter>| b > 0\"\n  shows \"proper_design bl \\<B>\\<^sup>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design bl \\<B>\\<^sup>D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design bl \\<B>\\<^sup>D", "interpret des: design \"bl\" \"\\<B>\\<^sup>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design bl \\<B>\\<^sup>D", "using derived_is_design assms"], ["proof (prove)\nusing this:\n  (\\<And>b.\n      b \\<in># remove1_mset bl \\<B> \\<Longrightarrow>\n      0 < bl |\\<inter>| b) \\<Longrightarrow>\n  design bl \\<B>\\<^sup>D\n  ?b \\<in># remove1_mset bl \\<B> \\<Longrightarrow> 0 < bl |\\<inter>| ?b\n\ngoal (1 subgoal):\n 1. design bl \\<B>\\<^sup>D", "by fastforce"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design bl \\<B>\\<^sup>D", "have \"\\<b> - 1 > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < \\<b> - 1", "using block_num_gt_rep r_ge_two"], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) < \\<b>\n  2 \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. 1 < \\<b> - 1", "by linarith"], ["proof (state)\nthis:\n  1 < \\<b> - 1\n\ngoal (1 subgoal):\n 1. proper_design bl \\<B>\\<^sup>D", "then"], ["proof (chain)\npicking this:\n  1 < \\<b> - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < \\<b> - 1\n\ngoal (1 subgoal):\n 1. proper_design bl \\<B>\\<^sup>D", "by (unfold_locales) (simp add: derived_block_num valid_block)"], ["proof (state)\nthis:\n  proper_design bl \\<B>\\<^sup>D\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Residual Designs\\<close>"], ["", "text \\<open>Similar to derived designs, a residual design takes the complement of a block bl as it's new\npoint set, and the complement of all other blocks with respect to bl.\\<close>"], ["", "definition residual_blocks :: \"'a set multiset\" (\"(\\<B>\\<^sup>R)\") where\n\"\\<B>\\<^sup>R \\<equiv> {# b - bl . b \\<in># (\\<B> - {#bl#}) #}\""], ["", "lemma residual_order: \"card (bl\\<^sup>c) = \\<v> - \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (bl\\<^sup>c)) = \\<v> - \\<k>", "apply (simp add: valid_block wellformed block_complement_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card \\<V> - card bl) = \\<v> - \\<k>", "using block_size_lt_v derived_points_order"], ["proof (prove)\nusing this:\n  \\<k> \\<le> \\<v>\n  derived_incidence_sys.\\<v> = \\<k>\n\ngoal (1 subgoal):\n 1. int (card \\<V> - card bl) = \\<v> - \\<k>", "by auto"], ["", "lemma residual_block_num: \"size (\\<B>\\<^sup>R) = \\<b> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size \\<B>\\<^sup>R) = \\<b> - 1", "using b_positive"], ["proof (prove)\nusing this:\n  0 < \\<b>\n\ngoal (1 subgoal):\n 1. int (size \\<B>\\<^sup>R) = \\<b> - 1", "by (simp add: residual_blocks_def size_remove1_mset_If valid_block int_ops(6))"], ["", "lemma residual_obtain_orig_block: \n  assumes \"b \\<in># \\<B>\\<^sup>R\"\n  obtains bl2 where \"b = bl2 - bl\" and \"bl2 \\<in># remove1_mset bl \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>b = bl2 - bl; bl2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms residual_blocks_def"], ["proof (prove)\nusing this:\n  b \\<in># \\<B>\\<^sup>R\n  \\<B>\\<^sup>R \\<equiv> {#b - bl. b \\<in># remove1_mset bl \\<B>#}\n\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>b = bl2 - bl; bl2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma residual_blocks_ss: assumes \"b \\<in># \\<B>\\<^sup>R\" shows \"b \\<subseteq> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<subseteq> \\<V>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<subseteq> \\<V>", "have \"b \\<subseteq> (bl\\<^sup>c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<subseteq> bl\\<^sup>c", "using residual_obtain_orig_block"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<in># \\<B>\\<^sup>R;\n   \\<And>bl2.\n      \\<lbrakk>?b = bl2 - bl; bl2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. b \\<subseteq> bl\\<^sup>c", "by (metis Diff_mono assms block_complement_def in_diffD order_refl wellformed)"], ["proof (state)\nthis:\n  b \\<subseteq> bl\\<^sup>c\n\ngoal (1 subgoal):\n 1. b \\<subseteq> \\<V>", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<subseteq> bl\\<^sup>c\n\ngoal (1 subgoal):\n 1. b \\<subseteq> \\<V>", "using block_complement_subset_points"], ["proof (prove)\nusing this:\n  b \\<subseteq> bl\\<^sup>c\n  ?ps \\<subseteq> ?bl\\<^sup>c \\<Longrightarrow> ?ps \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. b \\<subseteq> \\<V>", "by auto"], ["proof (state)\nthis:\n  b \\<subseteq> \\<V>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma residual_blocks_exclude: \"b \\<in># \\<B>\\<^sup>R \\<Longrightarrow> x \\<in> b \\<Longrightarrow> x \\<notin> bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in># \\<B>\\<^sup>R; x \\<in> b\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> bl", "using residual_obtain_orig_block"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<in># \\<B>\\<^sup>R;\n   \\<And>bl2.\n      \\<lbrakk>?b = bl2 - bl; bl2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in># \\<B>\\<^sup>R; x \\<in> b\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> bl", "by auto"], ["", "lemma residual_is_wellformed:  \"b \\<in># \\<B>\\<^sup>R \\<Longrightarrow> b \\<subseteq> (bl\\<^sup>c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in># \\<B>\\<^sup>R \\<Longrightarrow> b \\<subseteq> bl\\<^sup>c", "apply (auto simp add: residual_blocks_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba x.\n       \\<lbrakk>ba \\<in># remove1_mset bl \\<B>; b = ba - bl; x \\<in> ba;\n        x \\<notin> bl\\<rbrakk>\n       \\<Longrightarrow> x \\<in> bl\\<^sup>c", "by (metis DiffI block_complement_def in_diffD wf_invalid_point)"], ["", "sublocale residual_incidence_sys: incidence_system \"bl\\<^sup>c\" \"\\<B>\\<^sup>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incidence_system (bl\\<^sup>c) \\<B>\\<^sup>R", "using residual_is_wellformed"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B>\\<^sup>R \\<Longrightarrow> ?b \\<subseteq> bl\\<^sup>c\n\ngoal (1 subgoal):\n 1. incidence_system (bl\\<^sup>c) \\<B>\\<^sup>R", "by (unfold_locales)"], ["", "lemma residual_is_finite: \"finite (bl\\<^sup>c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (bl\\<^sup>c)", "by (simp add: block_complement_def finite_sets)"], ["", "sublocale residual_fin_incidence_sys: finite_incidence_system \"bl\\<^sup>c\" \"\\<B>\\<^sup>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_incidence_system (bl\\<^sup>c) \\<B>\\<^sup>R", "using residual_is_finite"], ["proof (prove)\nusing this:\n  finite (bl\\<^sup>c)\n\ngoal (1 subgoal):\n 1. finite_incidence_system (bl\\<^sup>c) \\<B>\\<^sup>R", "by (unfold_locales)"], ["", "lemma residual_blocks_nempty:\n  assumes \"bld \\<in># \\<B>\\<^sup>R\"\n  assumes \"multiplicity bl = 1\" \n  shows \"bld \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "obtain bl2 where inter: \"bld = bl2 - bl\" and member: \"bl2 \\<in># remove1_mset bl \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>bld = bl2 - bl; bl2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms residual_blocks_def"], ["proof (prove)\nusing this:\n  bld \\<in># \\<B>\\<^sup>R\n  multiplicity bl = 1\n  \\<B>\\<^sup>R \\<equiv> {#b - bl. b \\<in># remove1_mset bl \\<B>#}\n\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>bld = bl2 - bl; bl2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bld = bl2 - bl\n  bl2 \\<in># remove1_mset bl \\<B>\n\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  bld = bl2 - bl\n  bl2 \\<in># remove1_mset bl \\<B>", "have ne: \"bl2 \\<noteq> bl\""], ["proof (prove)\nusing this:\n  bld = bl2 - bl\n  bl2 \\<in># remove1_mset bl \\<B>\n\ngoal (1 subgoal):\n 1. bl2 \\<noteq> bl", "using assms"], ["proof (prove)\nusing this:\n  bld = bl2 - bl\n  bl2 \\<in># remove1_mset bl \\<B>\n  bld \\<in># \\<B>\\<^sup>R\n  multiplicity bl = 1\n\ngoal (1 subgoal):\n 1. bl2 \\<noteq> bl", "by (metis count_eq_zero_iff in_diff_count less_one union_single_eq_member)"], ["proof (state)\nthis:\n  bl2 \\<noteq> bl\n\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "have \"card bl2 = card bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card bl2 = card bl", "using uniform valid_block member"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  bl \\<in># \\<B>\n  bl2 \\<in># remove1_mset bl \\<B>\n\ngoal (1 subgoal):\n 1. card bl2 = card bl", "by (metis in_diffD of_nat_eq_iff)"], ["proof (state)\nthis:\n  card bl2 = card bl\n\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  card bl2 = card bl", "have \"card (bl2 - bl) > 0\""], ["proof (prove)\nusing this:\n  card bl2 = card bl\n\ngoal (1 subgoal):\n 1. 0 < card (bl2 - bl)", "using finite_blocks member uniform set_card_diff_ge_zero valid_block"], ["proof (prove)\nusing this:\n  card bl2 = card bl\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n  bl2 \\<in># remove1_mset bl \\<B>\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  \\<lbrakk>finite ?A; finite ?B; ?A \\<noteq> ?B; card ?A = card ?B\\<rbrakk>\n  \\<Longrightarrow> 0 < card (?A - ?B)\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. 0 < card (bl2 - bl)", "by (metis in_diffD ne)"], ["proof (state)\nthis:\n  0 < card (bl2 - bl)\n\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < card (bl2 - bl)\n\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "using inter"], ["proof (prove)\nusing this:\n  0 < card (bl2 - bl)\n  bld = bl2 - bl\n\ngoal (1 subgoal):\n 1. bld \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  bld \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma residual_is_design: \"multiplicity bl = 1 \\<Longrightarrow> design (bl\\<^sup>c) \\<B>\\<^sup>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity bl = 1 \\<Longrightarrow> design (bl\\<^sup>c) \\<B>\\<^sup>R", "using residual_blocks_nempty"], ["proof (prove)\nusing this:\n  \\<lbrakk>?bld \\<in># \\<B>\\<^sup>R; multiplicity bl = 1\\<rbrakk>\n  \\<Longrightarrow> ?bld \\<noteq> {}\n\ngoal (1 subgoal):\n 1. multiplicity bl = 1 \\<Longrightarrow> design (bl\\<^sup>c) \\<B>\\<^sup>R", "by (unfold_locales)"], ["", "lemma residual_is_proper: \n  assumes \"multiplicity bl = 1\" \n  shows \"proper_design (bl\\<^sup>c) \\<B>\\<^sup>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design (bl\\<^sup>c) \\<B>\\<^sup>R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design (bl\\<^sup>c) \\<B>\\<^sup>R", "interpret des: design \"bl\\<^sup>c\" \"\\<B>\\<^sup>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. design (bl\\<^sup>c) \\<B>\\<^sup>R", "using residual_is_design assms"], ["proof (prove)\nusing this:\n  multiplicity bl = 1 \\<Longrightarrow> design (bl\\<^sup>c) \\<B>\\<^sup>R\n  multiplicity bl = 1\n\ngoal (1 subgoal):\n 1. design (bl\\<^sup>c) \\<B>\\<^sup>R", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_design (bl\\<^sup>c) \\<B>\\<^sup>R", "have \"\\<b> - 1 > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < \\<b> - 1", "using r_ge_two block_num_gt_rep"], ["proof (prove)\nusing this:\n  2 \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) < \\<b>\n\ngoal (1 subgoal):\n 1. 1 < \\<b> - 1", "by linarith"], ["proof (state)\nthis:\n  1 < \\<b> - 1\n\ngoal (1 subgoal):\n 1. proper_design (bl\\<^sup>c) \\<B>\\<^sup>R", "then"], ["proof (chain)\npicking this:\n  1 < \\<b> - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < \\<b> - 1\n\ngoal (1 subgoal):\n 1. proper_design (bl\\<^sup>c) \\<B>\\<^sup>R", "using residual_block_num"], ["proof (prove)\nusing this:\n  1 < \\<b> - 1\n  int (size \\<B>\\<^sup>R) = \\<b> - 1\n\ngoal (1 subgoal):\n 1. proper_design (bl\\<^sup>c) \\<B>\\<^sup>R", "by (unfold_locales) auto"], ["proof (state)\nthis:\n  proper_design (bl\\<^sup>c) \\<B>\\<^sup>R\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Symmetric BIBD's\\<close>"], ["", "text \\<open>Symmetric bibd's are those where the order of the design equals the number of blocks\\<close>"], ["", "locale symmetric_bibd = bibd + \n  assumes symmetric: \"\\<b> = \\<v>\"\nbegin"], ["", "lemma rep_value_sym: \"\\<r> = \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) = \\<k>", "using b_non_zero local.symmetric necessary_condition_two"], ["proof (prove)\nusing this:\n  \\<b> \\<noteq> 0\n  \\<b> = \\<v>\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) = \\<k>", "by auto"], ["", "lemma symmetric_condition_2: \"\\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1)", "using necessary_condition_one rep_value_sym"], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n  \\<Lambda> * (\\<v> - 1)\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) = \\<k>\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1)", "by auto"], ["", "lemma sym_design_vk_gt_kl: \n  assumes \"\\<k> \\<ge> \\<Lambda> + 2\"\n  shows \"\\<v> - \\<k> > \\<k> - \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<k> - \\<Lambda> < \\<v> - \\<k>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k> \\<Longrightarrow> False", "assume \"\\<not> (\\<v> - \\<k> > \\<k> - \\<Lambda>)\""], ["proof (state)\nthis:\n  \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k>\n\ngoal (1 subgoal):\n 1. \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k>", "have \"\\<v> \\<le> 2 * \\<k> - \\<Lambda>\""], ["proof (prove)\nusing this:\n  \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k>\n\ngoal (1 subgoal):\n 1. \\<v> \\<le> 2 * \\<k> - \\<Lambda>", "by linarith"], ["proof (state)\nthis:\n  \\<v> \\<le> 2 * \\<k> - \\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<v> \\<le> 2 * \\<k> - \\<Lambda>", "have \"\\<v> - 1 \\<le> 2 * \\<k> - \\<Lambda> - 1\""], ["proof (prove)\nusing this:\n  \\<v> \\<le> 2 * \\<k> - \\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<v> - 1 \\<le> 2 * \\<k> - \\<Lambda> - 1", "by linarith"], ["proof (state)\nthis:\n  \\<v> - 1 \\<le> 2 * \\<k> - \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<v> - 1 \\<le> 2 * \\<k> - \\<Lambda> - 1", "have \"\\<Lambda>* (\\<v> - 1) \\<le> \\<Lambda>*( 2 * \\<k> - \\<Lambda> - 1)\""], ["proof (prove)\nusing this:\n  \\<v> - 1 \\<le> 2 * \\<k> - \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) \\<le> \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1)", "using index_ge_zero mult_le_cancel_left"], ["proof (prove)\nusing this:\n  \\<v> - 1 \\<le> 2 * \\<k> - \\<Lambda> - 1\n  0 \\<le> \\<Lambda>\n  (?c * ?a \\<le> ?c * ?b) =\n  (((0::?'a) < ?c \\<longrightarrow> ?a \\<le> ?b) \\<and>\n   (?c < (0::?'a) \\<longrightarrow> ?b \\<le> ?a))\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) \\<le> \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1)", "by fastforce"], ["proof (state)\nthis:\n  \\<Lambda> * (\\<v> - 1) \\<le> \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1)\n\ngoal (1 subgoal):\n 1. \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<Lambda> * (\\<v> - 1) \\<le> \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1)", "have \"\\<k> * (\\<k> - 1) \\<le> \\<Lambda>*( 2 * \\<k> - \\<Lambda> - 1)\""], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) \\<le> \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1)\n\ngoal (1 subgoal):\n 1. \\<k> * (\\<k> - 1) \\<le> \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1)", "by (simp add: symmetric_condition_2)"], ["proof (state)\nthis:\n  \\<k> * (\\<k> - 1) \\<le> \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1)\n\ngoal (1 subgoal):\n 1. \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<k> * (\\<k> - 1) \\<le> \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1)", "have \"\\<k> * (\\<k> - 1) - \\<Lambda>*( 2 * \\<k> - \\<Lambda> - 1) \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<k> * (\\<k> - 1) \\<le> \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1)\n\ngoal (1 subgoal):\n 1. \\<k> * (\\<k> - 1) - \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1) \\<le> 0", "by linarith"], ["proof (state)\nthis:\n  \\<k> * (\\<k> - 1) - \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<k> * (\\<k> - 1) - \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1) \\<le> 0", "have \"(\\<k> - \\<Lambda>)*(\\<k> - \\<Lambda> - 1) \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<k> * (\\<k> - 1) - \\<Lambda> * (2 * \\<k> - \\<Lambda> - 1) \\<le> 0\n\ngoal (1 subgoal):\n 1. (\\<k> - \\<Lambda>) * (\\<k> - \\<Lambda> - 1) \\<le> 0", "by (simp add: mult.commute right_diff_distrib')"], ["proof (state)\nthis:\n  (\\<k> - \\<Lambda>) * (\\<k> - \\<Lambda> - 1) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (\\<k> - \\<Lambda>) * (\\<k> - \\<Lambda> - 1) \\<le> 0", "have \"\\<k> = \\<Lambda> \\<or> \\<k> = \\<Lambda> + 1\""], ["proof (prove)\nusing this:\n  (\\<k> - \\<Lambda>) * (\\<k> - \\<Lambda> - 1) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<k> = \\<Lambda> \\<or> \\<k> = \\<Lambda> + 1", "using mult_le_0_iff"], ["proof (prove)\nusing this:\n  (\\<k> - \\<Lambda>) * (\\<k> - \\<Lambda> - 1) \\<le> 0\n  (?a * ?b \\<le> (0::?'a)) =\n  ((0::?'a) \\<le> ?a \\<and> ?b \\<le> (0::?'a) \\<or>\n   ?a \\<le> (0::?'a) \\<and> (0::?'a) \\<le> ?b)\n\ngoal (1 subgoal):\n 1. \\<k> = \\<Lambda> \\<or> \\<k> = \\<Lambda> + 1", "by force"], ["proof (state)\nthis:\n  \\<k> = \\<Lambda> \\<or> \\<k> = \\<Lambda> + 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<k> - \\<Lambda> < \\<v> - \\<k> \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<k> = \\<Lambda> \\<or> \\<k> = \\<Lambda> + 1\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  \\<k> = \\<Lambda> \\<or> \\<k> = \\<Lambda> + 1\n  \\<Lambda> + 2 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context bibd\nbegin"], ["", "lemma symmetric_bibdI: \"\\<b> = \\<v> \\<Longrightarrow> symmetric_bibd \\<V> \\<B> \\<k> \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> = \\<v> \\<Longrightarrow> symmetric_bibd \\<V> \\<B> \\<k> \\<Lambda>", "by unfold_locales simp"], ["", "lemma symmetric_bibdII: \"\\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1) \\<Longrightarrow> symmetric_bibd \\<V> \\<B> \\<k> \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1) \\<Longrightarrow>\n    symmetric_bibd \\<V> \\<B> \\<k> \\<Lambda>", "using symmetric_condition_1"], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1) \\<Longrightarrow>\n  \\<b> = \\<v> \\<and> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) = \\<k>\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1) \\<Longrightarrow>\n    symmetric_bibd \\<V> \\<B> \\<k> \\<Lambda>", "by unfold_locales blast"], ["", "lemma symmetric_not_admissable: \"\\<Lambda> * (\\<v> - 1) \\<noteq> \\<k> * (\\<k> - 1) \\<Longrightarrow> \\<not> symmetric_bibd \\<V> \\<B> \\<k> \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) \\<noteq> \\<k> * (\\<k> - 1) \\<Longrightarrow>\n    \\<not> symmetric_bibd \\<V> \\<B> \\<k> \\<Lambda>", "using symmetric_bibd.symmetric_condition_2"], ["proof (prove)\nusing this:\n  symmetric_bibd ?point_set ?block_collection ?u_block_size\n   ?index \\<Longrightarrow>\n  ?index * (int (card ?point_set) - 1) = ?u_block_size * (?u_block_size - 1)\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) \\<noteq> \\<k> * (\\<k> - 1) \\<Longrightarrow>\n    \\<not> symmetric_bibd \\<V> \\<B> \\<k> \\<Lambda>", "by blast"], ["", "end"], ["", "context symmetric_bibd\nbegin"], ["", "subsubsection \\<open>Intersection Property on Symmetric BIBDs\\<close>"], ["", "text \\<open>Below is a proof of an important property on symmetric BIBD's regarding the equivalence\nof intersection numbers and the design index. This is an intuitive counting proof, and involved\nsignificantly more work in a formal environment. Based of Lecture Note \\cite{HerkeLectureNotes2016}\\<close>"], ["", "lemma intersect_mult_set_eq_block:\n  assumes \"blv \\<in># \\<B>\"\n  shows \"p \\<in># \\<Sum>\\<^sub>#{# mset_set (bl \\<inter> blv) .bl \\<in># (\\<B> - {#blv#})#} \\<longleftrightarrow> p \\<in> blv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<in># (\\<Sum>bl\\<in>#remove1_mset blv\n                              \\<B>. mset_set (bl \\<inter> blv))) =\n    (p \\<in> blv)", "proof (auto, simp add: assms finite_blocks)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> blv \\<Longrightarrow>\n    \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set (x \\<inter> blv)", "assume assm: \"p \\<in> blv\""], ["proof (state)\nthis:\n  p \\<in> blv\n\ngoal (1 subgoal):\n 1. p \\<in> blv \\<Longrightarrow>\n    \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set (x \\<inter> blv)", "then"], ["proof (chain)\npicking this:\n  p \\<in> blv", "have \"(\\<B> - {#blv#}) rep p > 0\""], ["proof (prove)\nusing this:\n  p \\<in> blv\n\ngoal (1 subgoal):\n 1. 0 < remove1_mset blv \\<B> rep p", "using bibd_point_occ_rep r_ge_two assms"], ["proof (prove)\nusing this:\n  p \\<in> blv\n  \\<lbrakk>?x \\<in> ?bl; ?bl \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> remove1_mset ?bl \\<B> rep ?x =\n                    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n  2 \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  blv \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. 0 < remove1_mset blv \\<B> rep p", "by auto"], ["proof (state)\nthis:\n  0 < remove1_mset blv \\<B> rep p\n\ngoal (1 subgoal):\n 1. p \\<in> blv \\<Longrightarrow>\n    \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set (x \\<inter> blv)", "then"], ["proof (chain)\npicking this:\n  0 < remove1_mset blv \\<B> rep p", "obtain bl where \"bl \\<in># (\\<B> - {#blv#}) \\<and> p \\<in> bl\""], ["proof (prove)\nusing this:\n  0 < remove1_mset blv \\<B> rep p\n\ngoal (1 subgoal):\n 1. (\\<And>bl.\n        bl \\<in># remove1_mset blv \\<B> \\<and> p \\<in> bl \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms rep_number_g0_exists"], ["proof (prove)\nusing this:\n  0 < remove1_mset blv \\<B> rep p\n  blv \\<in># \\<B>\n  \\<lbrakk>0 < ?B rep ?x;\n   \\<And>b.\n      \\<lbrakk>b \\<in># ?B; ?x \\<in> b\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>bl.\n        bl \\<in># remove1_mset blv \\<B> \\<and> p \\<in> bl \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  bl \\<in># remove1_mset blv \\<B> \\<and> p \\<in> bl\n\ngoal (1 subgoal):\n 1. p \\<in> blv \\<Longrightarrow>\n    \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set (x \\<inter> blv)", "then"], ["proof (chain)\npicking this:\n  bl \\<in># remove1_mset blv \\<B> \\<and> p \\<in> bl", "show \"\\<exists>x\\<in>#remove1_mset blv \\<B>. p \\<in># mset_set (x \\<inter> blv)\""], ["proof (prove)\nusing this:\n  bl \\<in># remove1_mset blv \\<B> \\<and> p \\<in> bl\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set (x \\<inter> blv)", "using assms assm finite_blocks"], ["proof (prove)\nusing this:\n  bl \\<in># remove1_mset blv \\<B> \\<and> p \\<in> bl\n  blv \\<in># \\<B>\n  p \\<in> blv\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set (x \\<inter> blv)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>#remove1_mset blv \\<B>. p \\<in># mset_set (x \\<inter> blv)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intersect_mult_set_block_subset_iff:\n  assumes \"blv \\<in># \\<B>\"\n  assumes \"p \\<in># \\<Sum>\\<^sub>#{# mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} .b2 \\<in># (\\<B> - {#blv#})#}\"\n  shows \"p \\<subseteq> blv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<subseteq> blv", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> p \\<Longrightarrow> x \\<in> blv", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> p \\<Longrightarrow> x \\<in> blv", "assume asm: \"x \\<in> p\""], ["proof (state)\nthis:\n  x \\<in> p\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> p \\<Longrightarrow> x \\<in> blv", "obtain b2 where \"p \\<in># mset_set {y . y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} \\<and> b2 \\<in>#(\\<B> - {#blv#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b2.\n        p \\<in># mset_set\n                  {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                      card y = 2} \\<and>\n        b2 \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  blv \\<in># \\<B>\n  p \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                           \\<B>. mset_set\n                                  {y. y \\<subseteq> blv \\<inter> b2 \\<and>\ncard y = 2})\n\ngoal (1 subgoal):\n 1. (\\<And>b2.\n        p \\<in># mset_set\n                  {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                      card y = 2} \\<and>\n        b2 \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in># mset_set\n            {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} \\<and>\n  b2 \\<in># remove1_mset blv \\<B>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> p \\<Longrightarrow> x \\<in> blv", "then"], ["proof (chain)\npicking this:\n  p \\<in># mset_set\n            {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} \\<and>\n  b2 \\<in># remove1_mset blv \\<B>", "have \"p \\<subseteq> blv \\<inter> b2\""], ["proof (prove)\nusing this:\n  p \\<in># mset_set\n            {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} \\<and>\n  b2 \\<in># remove1_mset blv \\<B>\n\ngoal (1 subgoal):\n 1. p \\<subseteq> blv \\<inter> b2", "by (metis (no_types, lifting) elem_mset_set equals0D infinite_set_mset_mset_set mem_Collect_eq)"], ["proof (state)\nthis:\n  p \\<subseteq> blv \\<inter> b2\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> p \\<Longrightarrow> x \\<in> blv", "thus \"x \\<in> blv\""], ["proof (prove)\nusing this:\n  p \\<subseteq> blv \\<inter> b2\n\ngoal (1 subgoal):\n 1. x \\<in> blv", "using asm"], ["proof (prove)\nusing this:\n  p \\<subseteq> blv \\<inter> b2\n  x \\<in> p\n\ngoal (1 subgoal):\n 1. x \\<in> blv", "by auto"], ["proof (state)\nthis:\n  x \\<in> blv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intersect_mult_set_block_subset_card:\n  assumes \"blv \\<in># \\<B>\"\n  assumes \"p \\<in># \\<Sum>\\<^sub>#{# mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} .b2 \\<in># (\\<B> - {#blv#})#}\"\n  shows \"card p = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card p = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card p = 2", "obtain b2 where \"p \\<in># mset_set {y . y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} \\<and> b2 \\<in>#(\\<B> - {#blv#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b2.\n        p \\<in># mset_set\n                  {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                      card y = 2} \\<and>\n        b2 \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  blv \\<in># \\<B>\n  p \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                           \\<B>. mset_set\n                                  {y. y \\<subseteq> blv \\<inter> b2 \\<and>\ncard y = 2})\n\ngoal (1 subgoal):\n 1. (\\<And>b2.\n        p \\<in># mset_set\n                  {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                      card y = 2} \\<and>\n        b2 \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in># mset_set\n            {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} \\<and>\n  b2 \\<in># remove1_mset blv \\<B>\n\ngoal (1 subgoal):\n 1. card p = 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<in># mset_set\n            {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} \\<and>\n  b2 \\<in># remove1_mset blv \\<B>\n\ngoal (1 subgoal):\n 1. card p = 2", "by (metis (mono_tags, lifting) elem_mset_set equals0D infinite_set_mset_mset_set mem_Collect_eq)"], ["proof (state)\nthis:\n  card p = 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intersect_mult_set_block_with_point_exists: \n  assumes \"blv \\<in># \\<B>\" and  \"p \\<subseteq> blv\" and \"\\<Lambda> \\<ge> 2\" and \"card p = 2\"\n  shows \"\\<exists>x\\<in>#remove1_mset blv \\<B>. p \\<in># mset_set {y. y \\<subseteq> blv \\<and> y \\<subseteq> x \\<and> card y = 2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set\n                 {y. y \\<subseteq> blv \\<and>\n                     y \\<subseteq> x \\<and> card y = 2}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set\n                 {y. y \\<subseteq> blv \\<and>\n                     y \\<subseteq> x \\<and> card y = 2}", "have \"size {#b \\<in># \\<B> . p \\<subseteq> b#} = \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) p) \\<B>)) = \\<Lambda>", "using points_index_def assms"], ["proof (prove)\nusing this:\n  ?B index ?ps \\<equiv> size (filter_mset ((\\<subseteq>) ?ps) ?B)\n  blv \\<in># \\<B>\n  p \\<subseteq> blv\n  2 \\<le> \\<Lambda>\n  card p = 2\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) p) \\<B>)) = \\<Lambda>", "by (metis balanced_alt_def_all dual_order.trans of_nat_numeral wellformed)"], ["proof (state)\nthis:\n  int (size (filter_mset ((\\<subseteq>) p) \\<B>)) = \\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set\n                 {y. y \\<subseteq> blv \\<and>\n                     y \\<subseteq> x \\<and> card y = 2}", "then"], ["proof (chain)\npicking this:\n  int (size (filter_mset ((\\<subseteq>) p) \\<B>)) = \\<Lambda>", "have \"size {#bl \\<in># (\\<B> - {#blv#}) . p \\<subseteq> bl#} \\<ge> 1\""], ["proof (prove)\nusing this:\n  int (size (filter_mset ((\\<subseteq>) p) \\<B>)) = \\<Lambda>\n\ngoal (1 subgoal):\n 1. 1 \\<le> size (filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>))", "using assms"], ["proof (prove)\nusing this:\n  int (size (filter_mset ((\\<subseteq>) p) \\<B>)) = \\<Lambda>\n  blv \\<in># \\<B>\n  p \\<subseteq> blv\n  2 \\<le> \\<Lambda>\n  card p = 2\n\ngoal (1 subgoal):\n 1. 1 \\<le> size (filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>))", "by (simp add: size_Diff_singleton)"], ["proof (state)\nthis:\n  1 \\<le> size (filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set\n                 {y. y \\<subseteq> blv \\<and>\n                     y \\<subseteq> x \\<and> card y = 2}", "then"], ["proof (chain)\npicking this:\n  1 \\<le> size (filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>))", "obtain bl where \"bl \\<in># (\\<B> - {#blv#}) \\<and> p \\<subseteq> bl\""], ["proof (prove)\nusing this:\n  1 \\<le> size (filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>))\n\ngoal (1 subgoal):\n 1. (\\<And>bl.\n        bl \\<in># remove1_mset blv \\<B> \\<and>\n        p \\<subseteq> bl \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms filter_mset_empty_conv"], ["proof (prove)\nusing this:\n  1 \\<le> size (filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>))\n  blv \\<in># \\<B>\n  p \\<subseteq> blv\n  2 \\<le> \\<Lambda>\n  card p = 2\n  (filter_mset ?P ?M = {#}) = (\\<forall>L\\<in>#?M. \\<not> ?P L)\n\ngoal (1 subgoal):\n 1. (\\<And>bl.\n        bl \\<in># remove1_mset blv \\<B> \\<and>\n        p \\<subseteq> bl \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis diff_diff_cancel diff_is_0_eq' le_numeral_extra(4) size_empty zero_neq_one)"], ["proof (state)\nthis:\n  bl \\<in># remove1_mset blv \\<B> \\<and> p \\<subseteq> bl\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set\n                 {y. y \\<subseteq> blv \\<and>\n                     y \\<subseteq> x \\<and> card y = 2}", "thus ?thesis"], ["proof (prove)\nusing this:\n  bl \\<in># remove1_mset blv \\<B> \\<and> p \\<subseteq> bl\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set\n                 {y. y \\<subseteq> blv \\<and>\n                     y \\<subseteq> x \\<and> card y = 2}", "using assms finite_blocks"], ["proof (prove)\nusing this:\n  bl \\<in># remove1_mset blv \\<B> \\<and> p \\<subseteq> bl\n  blv \\<in># \\<B>\n  p \\<subseteq> blv\n  2 \\<le> \\<Lambda>\n  card p = 2\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#remove1_mset blv \\<B>.\n       p \\<in># mset_set\n                 {y. y \\<subseteq> blv \\<and>\n                     y \\<subseteq> x \\<and> card y = 2}", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>#remove1_mset blv \\<B>.\n     p \\<in># mset_set\n               {y. y \\<subseteq> blv \\<and>\n                   y \\<subseteq> x \\<and> card y = 2}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intersect_mult_set_block_subset_iff_2:\n  assumes \"blv \\<in># \\<B>\" and  \"p \\<subseteq> blv\" and \"\\<Lambda> \\<ge> 2\" and \"card p = 2\"\n  shows \"p \\<in># \\<Sum>\\<^sub>#{# mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} .b2 \\<in># (\\<B> - {#blv#})#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                             \\<B>. mset_set\n                                    {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n  card y = 2})", "by (auto simp add: intersect_mult_set_block_with_point_exists assms)"], ["", "lemma sym_sum_mset_inter_sets_count: \n  assumes \"blv \\<in># \\<B>\"\n  assumes \"p \\<in> blv\"\n  shows \"count (\\<Sum>\\<^sub>#{# mset_set (bl \\<inter> blv) .bl \\<in># (\\<B> - {#blv#})#}) p = \\<r> - 1\" \n    (is \"count (\\<Sum>\\<^sub>#?M) p = \\<r> - 1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n          p) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n          p) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "have size_inter: \"size {# mset_set (bl \\<inter> blv) | bl  \\<in># (\\<B> - {#blv#}) . p \\<in> bl#} = \\<r> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size\n          {#mset_set (bl \\<inter> blv)\n          . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#}) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "using bibd_point_occ_rep point_replication_number_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> ?bl; ?bl \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> remove1_mset ?bl \\<B> rep ?x =\n                    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n  ?B rep ?x \\<equiv> int (size (filter_mset ((\\<in>) ?x) ?B))\n\ngoal (1 subgoal):\n 1. int (size\n          {#mset_set (bl \\<inter> blv)\n          . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#}) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "by (metis assms(1) assms(2) size_image_mset)"], ["proof (state)\nthis:\n  int (size\n        {#mset_set (bl \\<inter> blv)\n        . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#}) =\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n          p) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "have inter_finite: \"\\<forall> bl \\<in># (\\<B> - {#blv#}) . finite (bl \\<inter> blv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#remove1_mset blv \\<B>. finite (bl \\<inter> blv)", "by (simp add: assms(1) finite_blocks)"], ["proof (state)\nthis:\n  \\<forall>bl\\<in>#remove1_mset blv \\<B>. finite (bl \\<inter> blv)\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n          p) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "have \"\\<And> bl . bl \\<in># (\\<B> - {#blv#}) \\<Longrightarrow> p \\<in> bl \\<longrightarrow> count (mset_set (bl \\<inter> blv)) p = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n       p \\<in> bl \\<longrightarrow> count (mset_set (bl \\<inter> blv)) p = 1", "using assms count_mset_set(1) inter_finite"], ["proof (prove)\nusing this:\n  blv \\<in># \\<B>\n  p \\<in> blv\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> count (mset_set ?A) ?x = 1\n  \\<forall>bl\\<in>#remove1_mset blv \\<B>. finite (bl \\<inter> blv)\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n       p \\<in> bl \\<longrightarrow> count (mset_set (bl \\<inter> blv)) p = 1", "by simp"], ["proof (state)\nthis:\n  ?bl \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n  p \\<in> ?bl \\<longrightarrow> count (mset_set (?bl \\<inter> blv)) p = 1\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n          p) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "then"], ["proof (chain)\npicking this:\n  ?bl \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n  p \\<in> ?bl \\<longrightarrow> count (mset_set (?bl \\<inter> blv)) p = 1", "have \"\\<And> bl . bl \\<in># {#b1 \\<in>#(\\<B> - {#blv#}) . p \\<in> b1#} \\<Longrightarrow> count (mset_set (bl \\<inter> blv)) p = 1\""], ["proof (prove)\nusing this:\n  ?bl \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n  p \\<in> ?bl \\<longrightarrow> count (mset_set (?bl \\<inter> blv)) p = 1\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># filter_mset ((\\<in>) p)\n                  (remove1_mset blv \\<B>) \\<Longrightarrow>\n       count (mset_set (bl \\<inter> blv)) p = 1", "by (metis (full_types) count_eq_zero_iff count_filter_mset)"], ["proof (state)\nthis:\n  ?bl\n  \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>) \\<Longrightarrow>\n  count (mset_set (?bl \\<inter> blv)) p = 1\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n          p) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "then"], ["proof (chain)\npicking this:\n  ?bl\n  \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>) \\<Longrightarrow>\n  count (mset_set (?bl \\<inter> blv)) p = 1", "have pin: \"\\<And> P. P \\<in># {# mset_set (bl \\<inter> blv) | bl \\<in># (\\<B> - {#blv#}) . p \\<in> bl#} \n      \\<Longrightarrow> count P p = 1\""], ["proof (prove)\nusing this:\n  ?bl\n  \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>) \\<Longrightarrow>\n  count (mset_set (?bl \\<inter> blv)) p = 1\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       P \\<in># {#mset_set (bl \\<inter> blv)\n                . bl \\<in># filter_mset ((\\<in>) p)\n                             (remove1_mset blv \\<B>)#} \\<Longrightarrow>\n       count P p = 1", "by blast"], ["proof (state)\nthis:\n  ?P \\<in># {#mset_set (bl \\<inter> blv)\n            . bl \\<in># filter_mset ((\\<in>) p)\n                         (remove1_mset blv \\<B>)#} \\<Longrightarrow>\n  count ?P p = 1\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n          p) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "have \"?M = {# mset_set (bl \\<inter> blv) | bl \\<in># (\\<B> - {#blv#}) . p \\<in> bl#} \n      + {# mset_set (bl \\<inter> blv) | bl \\<in># (\\<B> - {#blv#}) . p \\<notin> bl#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#mset_set (bl \\<inter> blv). bl \\<in># remove1_mset blv \\<B>#} =\n    {#mset_set (bl \\<inter> blv)\n    . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#} +\n    {#mset_set (bl \\<inter> blv)\n    . bl \\<in># filter_mset ((\\<notin>) p) (remove1_mset blv \\<B>)#}", "by (metis image_mset_union multiset_partition)"], ["proof (state)\nthis:\n  {#mset_set (bl \\<inter> blv). bl \\<in># remove1_mset blv \\<B>#} =\n  {#mset_set (bl \\<inter> blv)\n  . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#} +\n  {#mset_set (bl \\<inter> blv)\n  . bl \\<in># filter_mset ((\\<notin>) p) (remove1_mset blv \\<B>)#}\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n          p) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "then"], ["proof (chain)\npicking this:\n  {#mset_set (bl \\<inter> blv). bl \\<in># remove1_mset blv \\<B>#} =\n  {#mset_set (bl \\<inter> blv)\n  . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#} +\n  {#mset_set (bl \\<inter> blv)\n  . bl \\<in># filter_mset ((\\<notin>) p) (remove1_mset blv \\<B>)#}", "have \"count (\\<Sum>\\<^sub>#?M) p = size {# mset_set (bl \\<inter> blv) | bl \\<in># (\\<B> - {#blv#}) . p \\<in> bl#} \""], ["proof (prove)\nusing this:\n  {#mset_set (bl \\<inter> blv). bl \\<in># remove1_mset blv \\<B>#} =\n  {#mset_set (bl \\<inter> blv)\n  . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#} +\n  {#mset_set (bl \\<inter> blv)\n  . bl \\<in># filter_mset ((\\<notin>) p) (remove1_mset blv \\<B>)#}\n\ngoal (1 subgoal):\n 1. count (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n     p =\n    size\n     {#mset_set (bl \\<inter> blv)\n     . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#}", "using pin"], ["proof (prove)\nusing this:\n  {#mset_set (bl \\<inter> blv). bl \\<in># remove1_mset blv \\<B>#} =\n  {#mset_set (bl \\<inter> blv)\n  . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#} +\n  {#mset_set (bl \\<inter> blv)\n  . bl \\<in># filter_mset ((\\<notin>) p) (remove1_mset blv \\<B>)#}\n  ?P \\<in># {#mset_set (bl \\<inter> blv)\n            . bl \\<in># filter_mset ((\\<in>) p)\n                         (remove1_mset blv \\<B>)#} \\<Longrightarrow>\n  count ?P p = 1\n\ngoal (1 subgoal):\n 1. count (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n     p =\n    size\n     {#mset_set (bl \\<inter> blv)\n     . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#}", "by (auto simp add: count_sum_mset)"], ["proof (state)\nthis:\n  count (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n   p =\n  size\n   {#mset_set (bl \\<inter> blv)\n   . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#}\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n          p) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "then"], ["proof (chain)\npicking this:\n  count (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n   p =\n  size\n   {#mset_set (bl \\<inter> blv)\n   . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#}", "show ?thesis"], ["proof (prove)\nusing this:\n  count (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n   p =\n  size\n   {#mset_set (bl \\<inter> blv)\n   . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#}\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n          p) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "using size_inter"], ["proof (prove)\nusing this:\n  count (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n   p =\n  size\n   {#mset_set (bl \\<inter> blv)\n   . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#}\n  int (size\n        {#mset_set (bl \\<inter> blv)\n        . bl \\<in># filter_mset ((\\<in>) p) (remove1_mset blv \\<B>)#}) =\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n          p) =\n    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "by linarith"], ["proof (state)\nthis:\n  int (count\n        (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n        p) =\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sym_sum_mset_inter_sets_size: \n  assumes \"blv \\<in># \\<B>\"\n  shows \"size (\\<Sum>\\<^sub>#{# mset_set (bl \\<inter> blv) .bl \\<in># (\\<B> - {#blv#})#}) = \\<k> * (\\<r> - 1)\" \n    (is \"size (\\<Sum>\\<^sub>#?M) = \\<k>* (\\<r> - 1)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>bl\\<in>#remove1_mset blv\n                          \\<B>. mset_set (bl \\<inter> blv))) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>bl\\<in>#remove1_mset blv\n                          \\<B>. mset_set (bl \\<inter> blv))) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "have eq: \"set_mset (\\<Sum>\\<^sub>#{# mset_set (bl \\<inter> blv) .bl \\<in># (\\<B> - {#blv#})#}) = blv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset\n     (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv)) =\n    blv", "using intersect_mult_set_eq_block assms"], ["proof (prove)\nusing this:\n  ?blv \\<in># \\<B> \\<Longrightarrow>\n  (?p \\<in># (\\<Sum>bl\\<in>#remove1_mset ?blv\n                             \\<B>. mset_set (bl \\<inter> ?blv))) =\n  (?p \\<in> ?blv)\n  blv \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. set_mset\n     (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv)) =\n    blv", "by auto"], ["proof (state)\nthis:\n  set_mset\n   (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv)) =\n  blv\n\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>bl\\<in>#remove1_mset blv\n                          \\<B>. mset_set (bl \\<inter> blv))) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "then"], ["proof (chain)\npicking this:\n  set_mset\n   (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv)) =\n  blv", "have k: \"card (set_mset (\\<Sum>\\<^sub>#?M)) = \\<k>\""], ["proof (prove)\nusing this:\n  set_mset\n   (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv)) =\n  blv\n\ngoal (1 subgoal):\n 1. int (card\n          (set_mset\n            (\\<Sum>bl\\<in>#remove1_mset blv\n                            \\<B>. mset_set (bl \\<inter> blv)))) =\n    \\<k>", "by (simp add: assms)"], ["proof (state)\nthis:\n  int (card\n        (set_mset\n          (\\<Sum>bl\\<in>#remove1_mset blv\n                          \\<B>. mset_set (bl \\<inter> blv)))) =\n  \\<k>\n\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>bl\\<in>#remove1_mset blv\n                          \\<B>. mset_set (bl \\<inter> blv))) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "have \"\\<And> p. p \\<in># (\\<Sum>\\<^sub>#?M) \\<Longrightarrow> count (\\<Sum>\\<^sub>#?M) p = \\<r> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in># (\\<Sum>bl\\<in>#remove1_mset blv\n                                \\<B>. mset_set\n (bl \\<inter> blv)) \\<Longrightarrow>\n       int (count\n             (\\<Sum>bl\\<in>#remove1_mset blv\n                             \\<B>. mset_set (bl \\<inter> blv))\n             p) =\n       \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "using sym_sum_mset_inter_sets_count assms eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?blv \\<in># \\<B>; ?p \\<in> ?blv\\<rbrakk>\n  \\<Longrightarrow> int (count\n                          (\\<Sum>bl\\<in>#remove1_mset ?blv\n    \\<B>. mset_set (bl \\<inter> ?blv))\n                          ?p) =\n                    \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n  blv \\<in># \\<B>\n  set_mset\n   (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv)) =\n  blv\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in># (\\<Sum>bl\\<in>#remove1_mset blv\n                                \\<B>. mset_set\n (bl \\<inter> blv)) \\<Longrightarrow>\n       int (count\n             (\\<Sum>bl\\<in>#remove1_mset blv\n                             \\<B>. mset_set (bl \\<inter> blv))\n             p) =\n       \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1", "by blast"], ["proof (state)\nthis:\n  ?p \\<in># (\\<Sum>bl\\<in>#remove1_mset blv\n                            \\<B>. mset_set\n                                   (bl \\<inter> blv)) \\<Longrightarrow>\n  int (count\n        (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n        ?p) =\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>bl\\<in>#remove1_mset blv\n                          \\<B>. mset_set (bl \\<inter> blv))) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?p \\<in># (\\<Sum>bl\\<in>#remove1_mset blv\n                            \\<B>. mset_set\n                                   (bl \\<inter> blv)) \\<Longrightarrow>\n  int (count\n        (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n        ?p) =\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>bl\\<in>#remove1_mset blv\n                          \\<B>. mset_set (bl \\<inter> blv))) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "using k size_multiset_int_count"], ["proof (prove)\nusing this:\n  ?p \\<in># (\\<Sum>bl\\<in>#remove1_mset blv\n                            \\<B>. mset_set\n                                   (bl \\<inter> blv)) \\<Longrightarrow>\n  int (count\n        (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))\n        ?p) =\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n  int (card\n        (set_mset\n          (\\<Sum>bl\\<in>#remove1_mset blv\n                          \\<B>. mset_set (bl \\<inter> blv)))) =\n  \\<k>\n  \\<lbrakk>int (card (set_mset ?A)) = ?ca;\n   \\<And>p. p \\<in># ?A \\<Longrightarrow> int (count ?A p) = ?ca2.0\\<rbrakk>\n  \\<Longrightarrow> int (size ?A) = ?ca * ?ca2.0\n\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>bl\\<in>#remove1_mset blv\n                          \\<B>. mset_set (bl \\<inter> blv))) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "by metis"], ["proof (state)\nthis:\n  int (size\n        (\\<Sum>bl\\<in>#remove1_mset blv \\<B>. mset_set (bl \\<inter> blv))) =\n  \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sym_sum_inter_num: \n  assumes \"b1 \\<in># \\<B>\" \n  shows \"(\\<Sum>b2 \\<in>#(\\<B> - {#b1#}). b1 |\\<inter>| b2) = \\<k>* (\\<r> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "have \"(\\<Sum>b2 \\<in>#(\\<B> - {#b1#}). b1 |\\<inter>| b2) = (\\<Sum>b2 \\<in>#(\\<B> - {#b1#}). size (mset_set (b1 \\<inter> b2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. size (mset_set (b1 \\<inter> b2)))", "by (simp add: intersection_number_def)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  int (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. size (mset_set (b1 \\<inter> b2)))\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "also"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  int (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. size (mset_set (b1 \\<inter> b2)))\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "have \"... = size (\\<Sum>\\<^sub>#{#mset_set (b1 \\<inter> bl). bl \\<in># (\\<B> - {#b1#})#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. size (mset_set (b1 \\<inter> b2))) =\n    int (size\n          (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. mset_set (b1 \\<inter> bl)))", "by (auto simp add: size_big_union_sum)"], ["proof (state)\nthis:\n  int (\\<Sum>b2\\<in>#remove1_mset b1\n                      \\<B>. size (mset_set (b1 \\<inter> b2))) =\n  int (size (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. mset_set (b1 \\<inter> bl)))\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "also"], ["proof (state)\nthis:\n  int (\\<Sum>b2\\<in>#remove1_mset b1\n                      \\<B>. size (mset_set (b1 \\<inter> b2))) =\n  int (size (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. mset_set (b1 \\<inter> bl)))\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "have \"... =  size (\\<Sum>\\<^sub>#{#mset_set (bl \\<inter> b1). bl \\<in># (\\<B> - {#b1#})#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. mset_set (b1 \\<inter> bl))) =\n    int (size\n          (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. mset_set (bl \\<inter> b1)))", "by (metis Int_commute)"], ["proof (state)\nthis:\n  int (size\n        (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. mset_set (b1 \\<inter> bl))) =\n  int (size (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. mset_set (bl \\<inter> b1)))\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "finally"], ["proof (chain)\npicking this:\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  int (size (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. mset_set (bl \\<inter> b1)))", "have \"(\\<Sum>b2 \\<in>#(\\<B> - {#b1#}). b1 |\\<inter>| b2) = \\<k> * (\\<r> - 1)\""], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  int (size (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. mset_set (bl \\<inter> b1)))\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "using sym_sum_mset_inter_sets_size assms"], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  int (size (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. mset_set (bl \\<inter> b1)))\n  ?blv \\<in># \\<B> \\<Longrightarrow>\n  int (size\n        (\\<Sum>bl\\<in>#remove1_mset ?blv\n                        \\<B>. mset_set (bl \\<inter> ?blv))) =\n  \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n  b1 \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "by auto"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "then"], ["proof (chain)\npicking this:\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)", "by simp"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma choose_two_int: \n  assumes \" x \\<ge> 0\" \n  shows \"nat (x :: int) choose 2 = ((x ::int) * ( x - 1)) div 2 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat x choose 2) = x * (x - 1) div 2", "using choose_two assms dvd_div_mult_self even_numeral int_nat_eq mult_cancel_right2 mult_eq_0_iff \n    mult_nonneg_nonneg nat_diff_distrib' nat_mult_distrib nat_one_as_int \n    numeral_Bit0_div_2 numerals(1) of_nat_numeral zdiv_int"], ["proof (prove)\nusing this:\n  ?n choose 2 = ?n * (?n - 1) div 2\n  0 \\<le> x\n  ?a dvd ?b \\<Longrightarrow> ?b div ?a * ?a = ?b\n  even (numeral (num.Bit0 ?n))\n  int (nat ?z) = (if 0 \\<le> ?z then ?z else 0)\n  (?a * ?c = ?c) = (?c = (0::?'a) \\<or> ?a = (1::?'a))\n  (?a * ?b = (0::?'a)) = (?a = (0::?'a) \\<or> ?b = (0::?'a))\n  \\<lbrakk>(0::?'a) \\<le> ?a; (0::?'a) \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) \\<le> ?a * ?b\n  \\<lbrakk>0 \\<le> ?x; 0 \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> nat (?x - ?y) = nat ?x - nat ?y\n  0 \\<le> ?z \\<Longrightarrow> nat (?z * ?z') = nat ?z * nat ?z'\n  1 = nat 1\n  numeral (num.Bit0 ?n) div (2::?'a) = numeral ?n\n  Numeral1 = 1\n  of_nat (numeral ?n) = numeral ?n\n  int (?a div ?b) = int ?a div int ?b\n\ngoal (1 subgoal):\n 1. int (nat x choose 2) = x * (x - 1) div 2", "by (smt (verit))"], ["", "(* Slow *)"], ["", "lemma sym_sum_mset_inter2_sets_count: \n  assumes \"blv \\<in># \\<B>\"\n  assumes \"p \\<subseteq> blv\"\n  assumes \"card p = 2\"\n  shows \"count (\\<Sum>\\<^sub>#{#mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}. b2 \\<in># (\\<B> - {#blv#})#}) p = \\<Lambda> - 1\" \n    (is \"count (\\<Sum>\\<^sub>#?M) p = \\<Lambda> - 1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})\n          p) =\n    \\<Lambda> - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})\n          p) =\n    \\<Lambda> - 1", "have size_inter: \"size {# mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} | b2 \\<in># (\\<B> - {#blv#}) . p \\<subseteq> b2#} \n      = \\<Lambda> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size\n          {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n          . b2 \\<in># filter_mset ((\\<subseteq>) p)\n                       (remove1_mset blv \\<B>)#}) =\n    \\<Lambda> - 1", "using bibd_subset_occ assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<subseteq> ?bl; ?bl \\<in># \\<B>; card ?x = 2\\<rbrakk>\n  \\<Longrightarrow> int (size\n                          (filter_mset ((\\<subseteq>) ?x)\n                            (remove1_mset ?bl \\<B>))) =\n                    \\<Lambda> - 1\n  blv \\<in># \\<B>\n  p \\<subseteq> blv\n  card p = 2\n\ngoal (1 subgoal):\n 1. int (size\n          {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n          . b2 \\<in># filter_mset ((\\<subseteq>) p)\n                       (remove1_mset blv \\<B>)#}) =\n    \\<Lambda> - 1", "by simp"], ["proof (state)\nthis:\n  int (size\n        {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n        . b2 \\<in># filter_mset ((\\<subseteq>) p)\n                     (remove1_mset blv \\<B>)#}) =\n  \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})\n          p) =\n    \\<Lambda> - 1", "have \"\\<forall> b2 \\<in># (\\<B> - {#blv#}) . p \\<subseteq> b2 \\<longrightarrow> count (mset_set{y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}) p = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b2\\<in>#remove1_mset blv \\<B>.\n       p \\<subseteq> b2 \\<longrightarrow>\n       count (mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2})\n        p =\n       1", "using assms(2) count_mset_set(1) assms(3)"], ["proof (prove)\nusing this:\n  p \\<subseteq> blv\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> count (mset_set ?A) ?x = 1\n  card p = 2\n\ngoal (1 subgoal):\n 1. \\<forall>b2\\<in>#remove1_mset blv \\<B>.\n       p \\<subseteq> b2 \\<longrightarrow>\n       count (mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2})\n        p =\n       1", "by (auto simp add: assms(1) finite_blocks)"], ["proof (state)\nthis:\n  \\<forall>b2\\<in>#remove1_mset blv \\<B>.\n     p \\<subseteq> b2 \\<longrightarrow>\n     count (mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2})\n      p =\n     1\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})\n          p) =\n    \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  \\<forall>b2\\<in>#remove1_mset blv \\<B>.\n     p \\<subseteq> b2 \\<longrightarrow>\n     count (mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2})\n      p =\n     1", "have \"\\<forall> bl \\<in># {#b1 \\<in>#(\\<B> - {#blv#}) . p \\<subseteq> b1#}. \n      count (mset_set {y .y \\<subseteq> blv \\<inter> bl \\<and> card y = 2}) p = 1\""], ["proof (prove)\nusing this:\n  \\<forall>b2\\<in>#remove1_mset blv \\<B>.\n     p \\<subseteq> b2 \\<longrightarrow>\n     count (mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2})\n      p =\n     1\n\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>).\n       count (mset_set {y. y \\<subseteq> blv \\<inter> bl \\<and> card y = 2})\n        p =\n       1", "using count_eq_zero_iff count_filter_mset"], ["proof (prove)\nusing this:\n  \\<forall>b2\\<in>#remove1_mset blv \\<B>.\n     p \\<subseteq> b2 \\<longrightarrow>\n     count (mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2})\n      p =\n     1\n  (count ?M ?x = 0) = (?x \\<notin># ?M)\n  count (filter_mset ?P ?M) ?a = (if ?P ?a then count ?M ?a else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>).\n       count (mset_set {y. y \\<subseteq> blv \\<inter> bl \\<and> card y = 2})\n        p =\n       1", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  \\<forall>bl\\<in>#filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>).\n     count (mset_set {y. y \\<subseteq> blv \\<inter> bl \\<and> card y = 2})\n      p =\n     1\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})\n          p) =\n    \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  \\<forall>bl\\<in>#filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>).\n     count (mset_set {y. y \\<subseteq> blv \\<inter> bl \\<and> card y = 2})\n      p =\n     1", "have pin: \"\\<forall> P \\<in># {# mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} | b2 \\<in># (\\<B> - {#blv#}) . p \\<subseteq> b2#}. \n      count P p = 1\""], ["proof (prove)\nusing this:\n  \\<forall>bl\\<in>#filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>).\n     count (mset_set {y. y \\<subseteq> blv \\<inter> bl \\<and> card y = 2})\n      p =\n     1\n\ngoal (1 subgoal):\n 1. \\<forall>P\\<in>#{#mset_set\n                       {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n                    . b2 \\<in># filter_mset ((\\<subseteq>) p)\n                                 (remove1_mset blv \\<B>)#}.\n       count P p = 1", "using count_eq_zero_iff count_filter_mset"], ["proof (prove)\nusing this:\n  \\<forall>bl\\<in>#filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>).\n     count (mset_set {y. y \\<subseteq> blv \\<inter> bl \\<and> card y = 2})\n      p =\n     1\n  (count ?M ?x = 0) = (?x \\<notin># ?M)\n  count (filter_mset ?P ?M) ?a = (if ?P ?a then count ?M ?a else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>P\\<in>#{#mset_set\n                       {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n                    . b2 \\<in># filter_mset ((\\<subseteq>) p)\n                                 (remove1_mset blv \\<B>)#}.\n       count P p = 1", "by blast"], ["proof (state)\nthis:\n  \\<forall>P\\<in>#{#mset_set\n                     {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n                  . b2 \\<in># filter_mset ((\\<subseteq>) p)\n                               (remove1_mset blv \\<B>)#}.\n     count P p = 1\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})\n          p) =\n    \\<Lambda> - 1", "have \"?M = {# mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} | b2 \\<in># (\\<B> - {#blv#}) . p \\<subseteq> b2#} + \n              {# mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} | b2 \\<in># (\\<B> - {#blv#}) . \\<not> (p \\<subseteq> b2)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n    . b2 \\<in># remove1_mset blv \\<B>#} =\n    {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n    . b2 \\<in># filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>)#} +\n    {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n    . b2 \\<in># {#b2 \\<in># remove1_mset blv \\<B>.\n                 \\<not> p \\<subseteq> b2#}#}", "by (metis image_mset_union multiset_partition)"], ["proof (state)\nthis:\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># remove1_mset blv \\<B>#} =\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>)#} +\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># {#b2 \\<in># remove1_mset blv \\<B>. \\<not> p \\<subseteq> b2#}#}\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})\n          p) =\n    \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># remove1_mset blv \\<B>#} =\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>)#} +\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># {#b2 \\<in># remove1_mset blv \\<B>. \\<not> p \\<subseteq> b2#}#}", "have \"count (\\<Sum>\\<^sub>#?M) p = \n      size {# mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} | b2 \\<in># (\\<B> - {#blv#}) . p \\<subseteq> b2#}\""], ["proof (prove)\nusing this:\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># remove1_mset blv \\<B>#} =\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>)#} +\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># {#b2 \\<in># remove1_mset blv \\<B>. \\<not> p \\<subseteq> b2#}#}\n\ngoal (1 subgoal):\n 1. count\n     (\\<Sum>b2\\<in>#remove1_mset blv\n                     \\<B>. mset_set\n                            {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                card y = 2})\n     p =\n    size\n     {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n     . b2 \\<in># filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>)#}", "using pin"], ["proof (prove)\nusing this:\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># remove1_mset blv \\<B>#} =\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>)#} +\n  {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n  . b2 \\<in># {#b2 \\<in># remove1_mset blv \\<B>. \\<not> p \\<subseteq> b2#}#}\n  \\<forall>P\\<in>#{#mset_set\n                     {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n                  . b2 \\<in># filter_mset ((\\<subseteq>) p)\n                               (remove1_mset blv \\<B>)#}.\n     count P p = 1\n\ngoal (1 subgoal):\n 1. count\n     (\\<Sum>b2\\<in>#remove1_mset blv\n                     \\<B>. mset_set\n                            {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                card y = 2})\n     p =\n    size\n     {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n     . b2 \\<in># filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>)#}", "by (auto simp add: count_sum_mset)"], ["proof (state)\nthis:\n  count\n   (\\<Sum>b2\\<in>#remove1_mset blv\n                   \\<B>. mset_set\n                          {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                              card y = 2})\n   p =\n  size\n   {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n   . b2 \\<in># filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>)#}\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})\n          p) =\n    \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  count\n   (\\<Sum>b2\\<in>#remove1_mset blv\n                   \\<B>. mset_set\n                          {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                              card y = 2})\n   p =\n  size\n   {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n   . b2 \\<in># filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>)#}", "show ?thesis"], ["proof (prove)\nusing this:\n  count\n   (\\<Sum>b2\\<in>#remove1_mset blv\n                   \\<B>. mset_set\n                          {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                              card y = 2})\n   p =\n  size\n   {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n   . b2 \\<in># filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>)#}\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})\n          p) =\n    \\<Lambda> - 1", "using size_inter"], ["proof (prove)\nusing this:\n  count\n   (\\<Sum>b2\\<in>#remove1_mset blv\n                   \\<B>. mset_set\n                          {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                              card y = 2})\n   p =\n  size\n   {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n   . b2 \\<in># filter_mset ((\\<subseteq>) p) (remove1_mset blv \\<B>)#}\n  int (size\n        {#mset_set {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}\n        . b2 \\<in># filter_mset ((\\<subseteq>) p)\n                     (remove1_mset blv \\<B>)#}) =\n  \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. int (count\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})\n          p) =\n    \\<Lambda> - 1", "by linarith"], ["proof (state)\nthis:\n  int (count\n        (\\<Sum>b2\\<in>#remove1_mset blv\n                        \\<B>. mset_set\n                               {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                   card y = 2})\n        p) =\n  \\<Lambda> - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sym_sum_mset_inter2_sets_size: \n  assumes \"blv \\<in># \\<B>\"\n  shows \"size (\\<Sum>\\<^sub>#{#mset_set {y .y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}. b2 \\<in># (\\<B> - {#blv#})#}) = \n    ((nat \\<k>) choose 2) * (\\<Lambda> -1)\" \n    (is \"size (\\<Sum>\\<^sub>#?M) = ((nat \\<k>) choose 2) * (\\<Lambda> -1)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "proof (cases \"\\<Lambda> = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Lambda> = 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)\n 2. \\<Lambda> \\<noteq> 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "case True"], ["proof (state)\nthis:\n  \\<Lambda> = 1\n\ngoal (2 subgoals):\n 1. \\<Lambda> = 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)\n 2. \\<Lambda> \\<noteq> 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "have empty: \"\\<And> b2 . b2 \\<in># remove1_mset blv \\<B> \\<Longrightarrow> {y .y \\<subseteq> blv \\<and> y \\<subseteq> b2 \\<and> card y = 2} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b2.\n       b2 \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n       {y. y \\<subseteq> blv \\<and> y \\<subseteq> b2 \\<and> card y = 2} = {}", "using index_one_alt_bl_not_exist assms True"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<Lambda> = 1; ?blv \\<in># \\<B>; ?p \\<subseteq> ?blv;\n   card ?p = 2; ?bl \\<in># remove1_mset ?blv \\<B>\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?p \\<subseteq> ?bl\n  blv \\<in># \\<B>\n  \\<Lambda> = 1\n\ngoal (1 subgoal):\n 1. \\<And>b2.\n       b2 \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n       {y. y \\<subseteq> blv \\<and> y \\<subseteq> b2 \\<and> card y = 2} = {}", "by blast"], ["proof (state)\nthis:\n  ?b2.0 \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n  {y. y \\<subseteq> blv \\<and> y \\<subseteq> ?b2.0 \\<and> card y = 2} = {}\n\ngoal (2 subgoals):\n 1. \\<Lambda> = 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)\n 2. \\<Lambda> \\<noteq> 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "then"], ["proof (chain)\npicking this:\n  ?b2.0 \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n  {y. y \\<subseteq> blv \\<and> y \\<subseteq> ?b2.0 \\<and> card y = 2} = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?b2.0 \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n  {y. y \\<subseteq> blv \\<and> y \\<subseteq> ?b2.0 \\<and> card y = 2} = {}\n\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "using sum_mset.neutral True"], ["proof (prove)\nusing this:\n  ?b2.0 \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n  {y. y \\<subseteq> blv \\<and> y \\<subseteq> ?b2.0 \\<and> card y = 2} = {}\n  \\<forall>x\\<in>#?A. x = (0::?'a) \\<Longrightarrow>\n  \\<Sum>\\<^sub># ?A = (0::?'a)\n  \\<Lambda> = 1\n\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "by (simp add: empty)"], ["proof (state)\nthis:\n  int (size\n        (\\<Sum>b2\\<in>#remove1_mset blv\n                        \\<B>. mset_set\n                               {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                   card y = 2})) =\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1)\n\ngoal (1 subgoal):\n 1. \\<Lambda> \\<noteq> 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Lambda> \\<noteq> 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "case False"], ["proof (state)\nthis:\n  \\<Lambda> \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<Lambda> \\<noteq> 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "then"], ["proof (chain)\npicking this:\n  \\<Lambda> \\<noteq> 1", "have index_min: \"\\<Lambda> \\<ge> 2\""], ["proof (prove)\nusing this:\n  \\<Lambda> \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> \\<Lambda>", "using index_not_zero"], ["proof (prove)\nusing this:\n  \\<Lambda> \\<noteq> 1\n  1 \\<le> \\<Lambda>\n\ngoal (1 subgoal):\n 1. 2 \\<le> \\<Lambda>", "by linarith"], ["proof (state)\nthis:\n  2 \\<le> \\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<Lambda> \\<noteq> 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "have subset_card: \"\\<And> x . x \\<in># (\\<Sum>\\<^sub>#?M) \\<Longrightarrow> card x = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                                \\<B>. mset_set\n {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}) \\<Longrightarrow>\n       card x = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                                \\<B>. mset_set\n {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}) \\<Longrightarrow>\n       card x = 2", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                                \\<B>. mset_set\n {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}) \\<Longrightarrow>\n       card x = 2", "assume a: \"x \\<in># (\\<Sum>\\<^sub>#?M)\""], ["proof (state)\nthis:\n  x \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                           \\<B>. mset_set\n                                  {y. y \\<subseteq> blv \\<inter> b2 \\<and>\ncard y = 2})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                                \\<B>. mset_set\n {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}) \\<Longrightarrow>\n       card x = 2", "then"], ["proof (chain)\npicking this:\n  x \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                           \\<B>. mset_set\n                                  {y. y \\<subseteq> blv \\<inter> b2 \\<and>\ncard y = 2})", "obtain b2 where \"x \\<in># mset_set {y . y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} \\<and> b2 \\<in>#(\\<B> - {#blv#})\""], ["proof (prove)\nusing this:\n  x \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                           \\<B>. mset_set\n                                  {y. y \\<subseteq> blv \\<inter> b2 \\<and>\ncard y = 2})\n\ngoal (1 subgoal):\n 1. (\\<And>b2.\n        x \\<in># mset_set\n                  {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                      card y = 2} \\<and>\n        b2 \\<in># remove1_mset blv \\<B> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in># mset_set\n            {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} \\<and>\n  b2 \\<in># remove1_mset blv \\<B>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                                \\<B>. mset_set\n {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2}) \\<Longrightarrow>\n       card x = 2", "thus \"card x = 2\""], ["proof (prove)\nusing this:\n  x \\<in># mset_set\n            {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} \\<and>\n  b2 \\<in># remove1_mset blv \\<B>\n\ngoal (1 subgoal):\n 1. card x = 2", "using mem_Collect_eq"], ["proof (prove)\nusing this:\n  x \\<in># mset_set\n            {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2} \\<and>\n  b2 \\<in># remove1_mset blv \\<B>\n  (?a \\<in> Collect ?P) = ?P ?a\n\ngoal (1 subgoal):\n 1. card x = 2", "by (metis (mono_tags, lifting) elem_mset_set equals0D infinite_set_mset_mset_set)"], ["proof (state)\nthis:\n  card x = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                            \\<B>. mset_set\n                                   {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n card y = 2}) \\<Longrightarrow>\n  card ?x = 2\n\ngoal (1 subgoal):\n 1. \\<Lambda> \\<noteq> 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "have eq: \"set_mset (\\<Sum>\\<^sub>#?M) = {bl . bl \\<subseteq> blv \\<and> card bl = 2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset\n     (\\<Sum>b2\\<in>#remove1_mset blv\n                     \\<B>. mset_set\n                            {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                card y = 2}) =\n    {bl. bl \\<subseteq> blv \\<and> card bl = 2}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. set_mset\n     (\\<Sum>b2\\<in>#remove1_mset blv\n                     \\<B>. mset_set\n                            {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                card y = 2})\n    \\<subseteq> {bl. bl \\<subseteq> blv \\<and> card bl = 2}\n 2. {bl. bl \\<subseteq> blv \\<and> card bl = 2}\n    \\<subseteq> set_mset\n                 (\\<Sum>b2\\<in>#remove1_mset blv\n                                 \\<B>. mset_set\n  {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2})", "show \"set_mset (\\<Sum>\\<^sub>#?M) \\<subseteq> {bl . bl \\<subseteq> blv \\<and> card bl = 2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset\n     (\\<Sum>b2\\<in>#remove1_mset blv\n                     \\<B>. mset_set\n                            {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                card y = 2})\n    \\<subseteq> {bl. bl \\<subseteq> blv \\<and> card bl = 2}", "using subset_card intersect_mult_set_block_subset_iff assms"], ["proof (prove)\nusing this:\n  ?x \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                            \\<B>. mset_set\n                                   {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n card y = 2}) \\<Longrightarrow>\n  card ?x = 2\n  \\<lbrakk>?blv \\<in># \\<B>;\n   ?p \\<in># (\\<Sum>b2\\<in>#remove1_mset ?blv\n                             \\<B>. mset_set\n                                    {y. y\n  \\<subseteq> ?blv \\<inter> b2 \\<and>\n  card y = 2})\\<rbrakk>\n  \\<Longrightarrow> ?p \\<subseteq> ?blv\n  blv \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. set_mset\n     (\\<Sum>b2\\<in>#remove1_mset blv\n                     \\<B>. mset_set\n                            {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                card y = 2})\n    \\<subseteq> {bl. bl \\<subseteq> blv \\<and> card bl = 2}", "by blast"], ["proof (state)\nthis:\n  set_mset\n   (\\<Sum>b2\\<in>#remove1_mset blv\n                   \\<B>. mset_set\n                          {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                              card y = 2})\n  \\<subseteq> {bl. bl \\<subseteq> blv \\<and> card bl = 2}\n\ngoal (1 subgoal):\n 1. {bl. bl \\<subseteq> blv \\<and> card bl = 2}\n    \\<subseteq> set_mset\n                 (\\<Sum>b2\\<in>#remove1_mset blv\n                                 \\<B>. mset_set\n  {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2})", "show \"{bl . bl \\<subseteq> blv \\<and> card bl = 2} \\<subseteq> set_mset (\\<Sum>\\<^sub>#?M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {bl. bl \\<subseteq> blv \\<and> card bl = 2}\n    \\<subseteq> set_mset\n                 (\\<Sum>b2\\<in>#remove1_mset blv\n                                 \\<B>. mset_set\n  {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2})", "using intersect_mult_set_block_subset_iff_2 assms index_min"], ["proof (prove)\nusing this:\n  \\<lbrakk>?blv \\<in># \\<B>; ?p \\<subseteq> ?blv; 2 \\<le> \\<Lambda>;\n   card ?p = 2\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in># (\\<Sum>b2\\<in>#remove1_mset ?blv\n        \\<B>. mset_set\n               {y. y \\<subseteq> ?blv \\<inter> b2 \\<and> card y = 2})\n  blv \\<in># \\<B>\n  2 \\<le> \\<Lambda>\n\ngoal (1 subgoal):\n 1. {bl. bl \\<subseteq> blv \\<and> card bl = 2}\n    \\<subseteq> set_mset\n                 (\\<Sum>b2\\<in>#remove1_mset blv\n                                 \\<B>. mset_set\n  {y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2})", "by blast"], ["proof (state)\nthis:\n  {bl. bl \\<subseteq> blv \\<and> card bl = 2}\n  \\<subseteq> set_mset\n               (\\<Sum>b2\\<in>#remove1_mset blv\n                               \\<B>. mset_set\n{y. y \\<subseteq> blv \\<inter> b2 \\<and> card y = 2})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_mset\n   (\\<Sum>b2\\<in>#remove1_mset blv\n                   \\<B>. mset_set\n                          {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                              card y = 2}) =\n  {bl. bl \\<subseteq> blv \\<and> card bl = 2}\n\ngoal (1 subgoal):\n 1. \\<Lambda> \\<noteq> 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "have \"card blv = (nat \\<k>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card blv = nat \\<k>", "using uniform assms"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  blv \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. card blv = nat \\<k>", "by (metis nat_int)"], ["proof (state)\nthis:\n  card blv = nat \\<k>\n\ngoal (1 subgoal):\n 1. \\<Lambda> \\<noteq> 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "then"], ["proof (chain)\npicking this:\n  card blv = nat \\<k>", "have k: \"card (set_mset (\\<Sum>\\<^sub>#?M)) = ((nat \\<k>) choose 2)\""], ["proof (prove)\nusing this:\n  card blv = nat \\<k>\n\ngoal (1 subgoal):\n 1. card\n     (set_mset\n       (\\<Sum>b2\\<in>#remove1_mset blv\n                       \\<B>. mset_set\n                              {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                  card y = 2})) =\n    nat \\<k> choose 2", "using eq n_subsets"], ["proof (prove)\nusing this:\n  card blv = nat \\<k>\n  set_mset\n   (\\<Sum>b2\\<in>#remove1_mset blv\n                   \\<B>. mset_set\n                          {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                              card y = 2}) =\n  {bl. bl \\<subseteq> blv \\<and> card bl = 2}\n  finite ?A \\<Longrightarrow>\n  card {B. B \\<subseteq> ?A \\<and> card B = ?k} = card ?A choose ?k\n\ngoal (1 subgoal):\n 1. card\n     (set_mset\n       (\\<Sum>b2\\<in>#remove1_mset blv\n                       \\<B>. mset_set\n                              {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                  card y = 2})) =\n    nat \\<k> choose 2", "by (simp add: n_subsets assms finite_blocks)"], ["proof (state)\nthis:\n  card\n   (set_mset\n     (\\<Sum>b2\\<in>#remove1_mset blv\n                     \\<B>. mset_set\n                            {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                card y = 2})) =\n  nat \\<k> choose 2\n\ngoal (1 subgoal):\n 1. \\<Lambda> \\<noteq> 1 \\<Longrightarrow>\n    int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  card\n   (set_mset\n     (\\<Sum>b2\\<in>#remove1_mset blv\n                     \\<B>. mset_set\n                            {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                card y = 2})) =\n  nat \\<k> choose 2\n\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "using k size_multiset_int_count sym_sum_mset_inter2_sets_count assms eq subset_card"], ["proof (prove)\nusing this:\n  card\n   (set_mset\n     (\\<Sum>b2\\<in>#remove1_mset blv\n                     \\<B>. mset_set\n                            {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                card y = 2})) =\n  nat \\<k> choose 2\n  card\n   (set_mset\n     (\\<Sum>b2\\<in>#remove1_mset blv\n                     \\<B>. mset_set\n                            {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                card y = 2})) =\n  nat \\<k> choose 2\n  \\<lbrakk>int (card (set_mset ?A)) = ?ca;\n   \\<And>p. p \\<in># ?A \\<Longrightarrow> int (count ?A p) = ?ca2.0\\<rbrakk>\n  \\<Longrightarrow> int (size ?A) = ?ca * ?ca2.0\n  \\<lbrakk>?blv \\<in># \\<B>; ?p \\<subseteq> ?blv; card ?p = 2\\<rbrakk>\n  \\<Longrightarrow> int (count\n                          (\\<Sum>b2\\<in>#remove1_mset ?blv\n    \\<B>. mset_set {y. y \\<subseteq> ?blv \\<inter> b2 \\<and> card y = 2})\n                          ?p) =\n                    \\<Lambda> - 1\n  blv \\<in># \\<B>\n  set_mset\n   (\\<Sum>b2\\<in>#remove1_mset blv\n                   \\<B>. mset_set\n                          {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                              card y = 2}) =\n  {bl. bl \\<subseteq> blv \\<and> card bl = 2}\n  ?x \\<in># (\\<Sum>b2\\<in>#remove1_mset blv\n                            \\<B>. mset_set\n                                   {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n card y = 2}) \\<Longrightarrow>\n  card ?x = 2\n\ngoal (1 subgoal):\n 1. int (size\n          (\\<Sum>b2\\<in>#remove1_mset blv\n                          \\<B>. mset_set\n                                 {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                     card y = 2})) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "by (metis (no_types, lifting) intersect_mult_set_block_subset_iff)"], ["proof (state)\nthis:\n  int (size\n        (\\<Sum>b2\\<in>#remove1_mset blv\n                        \\<B>. mset_set\n                               {y. y \\<subseteq> blv \\<inter> b2 \\<and>\n                                   card y = 2})) =\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_choose_two_inter_num: \n  assumes \"b1 \\<in># \\<B>\" \n  shows \"(\\<Sum>b2 \\<in># (\\<B> - {#b1#}). (nat (b1 |\\<inter>| b2) choose 2)) = ((\\<Lambda> * (\\<Lambda> - 1) div 2)) * (\\<v> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "have div_fact: \"2 dvd (\\<Lambda> * (\\<Lambda> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (\\<Lambda> * (\\<Lambda> - 1))", "by simp"], ["proof (state)\nthis:\n  even (\\<Lambda> * (\\<Lambda> - 1))\n\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "have div_fact_2: \"2 dvd (\\<Lambda> * (\\<v> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (\\<Lambda> * (\\<v> - 1))", "using symmetric_condition_2"], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. even (\\<Lambda> * (\\<v> - 1))", "by simp"], ["proof (state)\nthis:\n  even (\\<Lambda> * (\\<v> - 1))\n\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "have \"(\\<Sum>b2 \\<in># (\\<B> - {#b1#}). (nat (b1 |\\<inter>| b2) choose 2)) = (\\<Sum>b2 \\<in># (\\<B> - {#b1#}). nat (b1 |\\<inter>|\\<^sub>2 b2 ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>|\\<^sub>2 b2))", "using n_inter_num_choose_design_inter assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b1.0 \\<in># \\<B>; ?b2.0 \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> (?b1.0 |\\<inter>|\\<^sub>?n ?b2.0) =\n                    int (nat (?b1.0 |\\<inter>| ?b2.0) choose ?n)\n  b1 \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>|\\<^sub>2 b2))", "by (simp add: in_diffD)"], ["proof (state)\nthis:\n  (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n  (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>|\\<^sub>2 b2))\n\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n  (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>|\\<^sub>2 b2))", "have sum_fact: \"(\\<Sum>b2 \\<in># (\\<B> - {#b1#}).(nat (b1 |\\<inter>| b2) choose 2)) \n      = ((nat \\<k>) choose 2) * (\\<Lambda> -1)\""], ["proof (prove)\nusing this:\n  (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n  (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>|\\<^sub>2 b2))\n\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "using assms sym_sum_mset_inter2_sets_size"], ["proof (prove)\nusing this:\n  (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n  (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>|\\<^sub>2 b2))\n  b1 \\<in># \\<B>\n  ?blv \\<in># \\<B> \\<Longrightarrow>\n  int (size\n        (\\<Sum>b2\\<in>#remove1_mset ?blv\n                        \\<B>. mset_set\n                               {y. y \\<subseteq> ?blv \\<inter> b2 \\<and>\n                                   card y = 2})) =\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    int (nat \\<k> choose 2) * (\\<Lambda> - 1)", "by (auto simp add: size_big_union_sum n_intersect_num_subset_def)"], ["proof (state)\nthis:\n  int (\\<Sum>b2\\<in>#remove1_mset b1\n                      \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "have \"((nat \\<k>) choose 2) * (\\<Lambda> -1) = ((\\<Lambda> * (\\<v> - 1) div 2)) * (\\<Lambda> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n    \\<Lambda> * (\\<v> - 1) div 2 * (\\<Lambda> - 1)", "using choose_two_int symmetric_condition_2 k_non_zero"], ["proof (prove)\nusing this:\n  0 \\<le> ?x \\<Longrightarrow> int (nat ?x choose 2) = ?x * (?x - 1) div 2\n  \\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1)\n  1 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n    \\<Lambda> * (\\<v> - 1) div 2 * (\\<Lambda> - 1)", "by auto"], ["proof (state)\nthis:\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n  \\<Lambda> * (\\<v> - 1) div 2 * (\\<Lambda> - 1)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n  \\<Lambda> * (\\<v> - 1) div 2 * (\\<Lambda> - 1)", "have \"((nat \\<k>) choose 2) * (\\<Lambda> -1) = ((\\<Lambda> * (\\<Lambda> - 1) div 2)) * (\\<v> -1)\""], ["proof (prove)\nusing this:\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n  \\<Lambda> * (\\<v> - 1) div 2 * (\\<Lambda> - 1)\n\ngoal (1 subgoal):\n 1. int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "using div_fact div_fact_2"], ["proof (prove)\nusing this:\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n  \\<Lambda> * (\\<v> - 1) div 2 * (\\<Lambda> - 1)\n  even (\\<Lambda> * (\\<Lambda> - 1))\n  even (\\<Lambda> * (\\<v> - 1))\n\ngoal (1 subgoal):\n 1. int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "by (smt div_mult_swap mult.assoc mult.commute)"], ["proof (state)\nthis:\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "using sum_fact"], ["proof (prove)\nusing this:\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)\n  int (\\<Sum>b2\\<in>#remove1_mset b1\n                      \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n  int (nat \\<k> choose 2) * (\\<Lambda> - 1)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "by simp"], ["proof (state)\nthis:\n  int (\\<Sum>b2\\<in>#remove1_mset b1\n                      \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sym_sum_inter_num_sq: \n  assumes \"b1 \\<in># \\<B>\" \n  shows \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). (b1 |\\<inter>| bl)^2) = \\<Lambda>^2 * ( \\<v> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "have dvd: \"2 dvd (( \\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even ((\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1)))", "by simp"], ["proof (state)\nthis:\n  even ((\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "have a: \"(\\<Sum>b2 \\<in>#(\\<B> - {#b1#}). int (nat (b1 |\\<inter>| b2) choose 2)) = \n            (\\<Sum>bl \\<in># (remove1_mset b1 \\<B>).  ((b1 |\\<inter>| bl) *  ((b1 |\\<inter>| bl) - 1)) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b2\\<in>#remove1_mset b1\n                    \\<B>. int (nat (b1 |\\<inter>| b2) choose 2)) =\n    (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1) div 2)", "using choose_two_int"], ["proof (prove)\nusing this:\n  0 \\<le> ?x \\<Longrightarrow> int (nat ?x choose 2) = ?x * (?x - 1) div 2\n\ngoal (1 subgoal):\n 1. (\\<Sum>b2\\<in>#remove1_mset b1\n                    \\<B>. int (nat (b1 |\\<inter>| b2) choose 2)) =\n    (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1) div 2)", "by (simp add: intersection_num_non_neg)"], ["proof (state)\nthis:\n  (\\<Sum>b2\\<in>#remove1_mset b1\n                  \\<B>. int (nat (b1 |\\<inter>| b2) choose 2)) =\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1) div 2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "have b: \"(\\<Sum>b2 \\<in>#(\\<B> - {#b1#}). int (nat (b1 |\\<inter>| b2) choose 2)) = \n              (\\<Sum>b2 \\<in>#(\\<B> - {#b1#}). (nat (b1 |\\<inter>| b2) choose 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b2\\<in>#remove1_mset b1\n                    \\<B>. int (nat (b1 |\\<inter>| b2) choose 2)) =\n    int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>b2\\<in>#remove1_mset b1\n                  \\<B>. int (nat (b1 |\\<inter>| b2) choose 2)) =\n  int (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>| b2) choose 2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "have \"(\\<Sum>b2 \\<in>#(\\<B> - {#b1#}). (nat (b1 |\\<inter>| b2) choose 2)) = ((\\<Lambda> * (\\<Lambda> - 1)) div 2) * ( \\<v> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "using sum_choose_two_inter_num assms"], ["proof (prove)\nusing this:\n  ?b1.0 \\<in># \\<B> \\<Longrightarrow>\n  int (\\<Sum>b2\\<in>#remove1_mset ?b1.0\n                      \\<B>. nat (?b1.0 |\\<inter>| b2) choose 2) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)\n  b1 \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. int (\\<Sum>b2\\<in>#remove1_mset b1\n                        \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "by blast"], ["proof (state)\nthis:\n  int (\\<Sum>b2\\<in>#remove1_mset b1\n                      \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  int (\\<Sum>b2\\<in>#remove1_mset b1\n                      \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "have start: \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). ((b1 |\\<inter>| bl) *  ((b1 |\\<inter>| bl) - 1)) div 2) \n                        = ((\\<Lambda> * (\\<Lambda> - 1)) div 2) * (\\<v> - 1)\""], ["proof (prove)\nusing this:\n  int (\\<Sum>b2\\<in>#remove1_mset b1\n                      \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1) div 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "using a b"], ["proof (prove)\nusing this:\n  int (\\<Sum>b2\\<in>#remove1_mset b1\n                      \\<B>. nat (b1 |\\<inter>| b2) choose 2) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)\n  (\\<Sum>b2\\<in>#remove1_mset b1\n                  \\<B>. int (nat (b1 |\\<inter>| b2) choose 2)) =\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1) div 2)\n  (\\<Sum>b2\\<in>#remove1_mset b1\n                  \\<B>. int (nat (b1 |\\<inter>| b2) choose 2)) =\n  int (\\<Sum>b2\\<in>#remove1_mset b1 \\<B>. nat (b1 |\\<inter>| b2) choose 2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1) div 2) =\n    \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1) div 2) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "have sum_dvd: \"2 dvd (\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). (b1 |\\<inter>| bl) *  ((b1 |\\<inter>| bl) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even\n     (\\<Sum>bl\\<in>#remove1_mset b1\n                     \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1))", "by (simp add: sum_mset_dvd)"], ["proof (state)\nthis:\n  even\n   (\\<Sum>bl\\<in>#remove1_mset b1\n                   \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  even\n   (\\<Sum>bl\\<in>#remove1_mset b1\n                   \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1))", "have \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). (b1 |\\<inter>| bl) * ((b1 |\\<inter>| bl) - 1)) div 2 \n      = (\\<v> - 1) * ((\\<Lambda> * (\\<Lambda> - 1)) div 2)\""], ["proof (prove)\nusing this:\n  even\n   (\\<Sum>bl\\<in>#remove1_mset b1\n                   \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1)) div\n    2 =\n    (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1) div 2)", "using start"], ["proof (prove)\nusing this:\n  even\n   (\\<Sum>bl\\<in>#remove1_mset b1\n                   \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1))\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1) div 2) =\n  \\<Lambda> * (\\<Lambda> - 1) div 2 * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1)) div\n    2 =\n    (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1) div 2)", "by (simp add: sum_mset_distrib_div_if_dvd)"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1)) div\n  2 =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1) div 2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1)) div\n  2 =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1) div 2)", "have \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). (b1 |\\<inter>| bl)^2) \n      - (\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). (b1 |\\<inter>| bl)) = ((\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1)))\""], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1)) div\n  2 =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1) div 2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n    \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))", "using sum_dvd dvd"], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1)) div\n  2 =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1) div 2)\n  even\n   (\\<Sum>bl\\<in>#remove1_mset b1\n                   \\<B>. b1 |\\<inter>| bl * (b1 |\\<inter>| bl - 1))\n  even ((\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n    \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n    (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))", "by (simp add: dvd_div_eq_iff  div_mult_swap int_distrib(4) power2_eq_square sum_mset_add_diff)"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))", "have \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). (b1 |\\<inter>| bl)^2) - (\\<Lambda> * (\\<v> - 1)) = ((\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1)))\""], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n    \\<Lambda> * (\\<v> - 1) =\n    (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))", "using sym_sum_inter_num assms rep_value_sym symmetric_condition_2"], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))\n  ?b1.0 \\<in># \\<B> \\<Longrightarrow>\n  \\<Sum>\\<^sub>#\n   (image_mset ((|\\<inter>|) ?b1.0) (remove1_mset ?b1.0 \\<B>)) =\n  \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n  b1 \\<in># \\<B>\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) = \\<k>\n  \\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n    \\<Lambda> * (\\<v> - 1) =\n    (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n  \\<Lambda> * (\\<v> - 1) =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n  \\<Lambda> * (\\<v> - 1) =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))", "have \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). (b1 |\\<inter>| bl)^2) = (\\<Lambda> * (\\<v> - 1)) * (\\<Lambda> - 1) + (\\<Lambda> * (\\<v> - 1))\""], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n  \\<Lambda> * (\\<v> - 1) =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda> * (\\<v> - 1) * (\\<Lambda> - 1) + \\<Lambda> * (\\<v> - 1)", "using diff_eq_eq"], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) -\n  \\<Lambda> * (\\<v> - 1) =\n  (\\<v> - 1) * (\\<Lambda> * (\\<Lambda> - 1))\n  (?a - ?b = ?c) = (?a = ?c + ?b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda> * (\\<v> - 1) * (\\<Lambda> - 1) + \\<Lambda> * (\\<v> - 1)", "by fastforce"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n  \\<Lambda> * (\\<v> - 1) * (\\<Lambda> - 1) + \\<Lambda> * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n  \\<Lambda> * (\\<v> - 1) * (\\<Lambda> - 1) + \\<Lambda> * (\\<v> - 1)", "have \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). (b1 |\\<inter>| bl)^2) = (\\<Lambda> * (\\<v> - 1)) * (\\<Lambda> - 1 + 1)\""], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n  \\<Lambda> * (\\<v> - 1) * (\\<Lambda> - 1) + \\<Lambda> * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda> * (\\<v> - 1) * (\\<Lambda> - 1 + 1)", "using int_distrib(2)"], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n  \\<Lambda> * (\\<v> - 1) * (\\<Lambda> - 1) + \\<Lambda> * (\\<v> - 1)\n  ?w * (?z1.0 + ?z2.0) = ?w * ?z1.0 + ?w * ?z2.0\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda> * (\\<v> - 1) * (\\<Lambda> - 1 + 1)", "by (metis mult_numeral_1_right numeral_One)"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n  \\<Lambda> * (\\<v> - 1) * (\\<Lambda> - 1 + 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n  \\<Lambda> * (\\<v> - 1) * (\\<Lambda> - 1 + 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1)", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1 \\<B>. (b1 |\\<inter>| bl)\\<^sup>2) =\n  \\<Lambda>\\<^sup>2 * (\\<v> - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sym_sum_inter_num_to_zero: \n  assumes \"b1 \\<in># \\<B>\" \n  shows \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). ((b1 |\\<inter>| bl) - \\<Lambda>)^2) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "have rm1_size: \"size (remove1_mset b1 \\<B>) = \\<v> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size (remove1_mset b1 \\<B>)) = \\<v> - 1", "using assms b_non_zero int_ops(6)"], ["proof (prove)\nusing this:\n  b1 \\<in># \\<B>\n  \\<b> \\<noteq> 0\n  int (?a - ?b) = (if int ?a < int ?b then 0 else int ?a - int ?b)\n\ngoal (1 subgoal):\n 1. int (size (remove1_mset b1 \\<B>)) = \\<v> - 1", "by (auto simp add: symmetric size_remove1_mset_If)"], ["proof (state)\nthis:\n  int (size (remove1_mset b1 \\<B>)) = \\<v> - 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "have \"\\<And> bl . bl \\<in># (remove1_mset b1 \\<B>) \\<Longrightarrow> ((b1 |\\<inter>| bl) - \\<Lambda>)^2 = \n        (((b1 |\\<inter>| bl)^2) - (2 * \\<Lambda> * (b1 |\\<inter>| bl)) + (\\<Lambda>^2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># remove1_mset b1 \\<B> \\<Longrightarrow>\n       (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2 =\n       (b1 |\\<inter>| bl)\\<^sup>2 - 2 * \\<Lambda> * (b1 |\\<inter>| bl) +\n       \\<Lambda>\\<^sup>2", "by (simp add: power2_diff)"], ["proof (state)\nthis:\n  ?bl \\<in># remove1_mset b1 \\<B> \\<Longrightarrow>\n  (b1 |\\<inter>| ?bl - \\<Lambda>)\\<^sup>2 =\n  (b1 |\\<inter>| ?bl)\\<^sup>2 - 2 * \\<Lambda> * (b1 |\\<inter>| ?bl) +\n  \\<Lambda>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "then"], ["proof (chain)\npicking this:\n  ?bl \\<in># remove1_mset b1 \\<B> \\<Longrightarrow>\n  (b1 |\\<inter>| ?bl - \\<Lambda>)\\<^sup>2 =\n  (b1 |\\<inter>| ?bl)\\<^sup>2 - 2 * \\<Lambda> * (b1 |\\<inter>| ?bl) +\n  \\<Lambda>\\<^sup>2", "have \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). ((b1 |\\<inter>| bl) - \\<Lambda>)^2) = \n              (\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). (((b1 |\\<inter>| bl)^2) - (2 * \\<Lambda> * (b1 |\\<inter>| bl)) + (\\<Lambda>^2)))\""], ["proof (prove)\nusing this:\n  ?bl \\<in># remove1_mset b1 \\<B> \\<Longrightarrow>\n  (b1 |\\<inter>| ?bl - \\<Lambda>)\\<^sup>2 =\n  (b1 |\\<inter>| ?bl)\\<^sup>2 - 2 * \\<Lambda> * (b1 |\\<inter>| ?bl) +\n  \\<Lambda>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl)\\<^sup>2 -\n                          2 * \\<Lambda> * (b1 |\\<inter>| bl) +\n                          \\<Lambda>\\<^sup>2)", "using sum_over_fun_eq"], ["proof (prove)\nusing this:\n  ?bl \\<in># remove1_mset b1 \\<B> \\<Longrightarrow>\n  (b1 |\\<inter>| ?bl - \\<Lambda>)\\<^sup>2 =\n  (b1 |\\<inter>| ?bl)\\<^sup>2 - 2 * \\<Lambda> * (b1 |\\<inter>| ?bl) +\n  \\<Lambda>\\<^sup>2\n  (\\<And>x. x \\<in># ?A \\<Longrightarrow> ?f x = ?g x) \\<Longrightarrow>\n  \\<Sum>\\<^sub># (image_mset ?f ?A) = \\<Sum>\\<^sub># (image_mset ?g ?A)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl)\\<^sup>2 -\n                          2 * \\<Lambda> * (b1 |\\<inter>| bl) +\n                          \\<Lambda>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl)\\<^sup>2 -\n                        2 * \\<Lambda> * (b1 |\\<inter>| bl) +\n                        \\<Lambda>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "also"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl)\\<^sup>2 -\n                        2 * \\<Lambda> * (b1 |\\<inter>| bl) +\n                        \\<Lambda>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "have \"... = \\<Lambda>^2 * (\\<v> - 1) - 2 * \\<Lambda> * (\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). ((b1 |\\<inter>| bl))) \n      + (\\<v> - 1) * (\\<Lambda>^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl)\\<^sup>2 -\n                          2 * \\<Lambda> * (b1 |\\<inter>| bl) +\n                          \\<Lambda>\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1) -\n    2 * \\<Lambda> *\n    \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) +\n    (\\<v> - 1) * \\<Lambda>\\<^sup>2", "using sym_sum_inter_num_sq rm1_size"], ["proof (prove)\nusing this:\n  ?b1.0 \\<in># \\<B> \\<Longrightarrow>\n  (\\<Sum>bl\\<in>#remove1_mset ?b1.0 \\<B>. (?b1.0 |\\<inter>| bl)\\<^sup>2) =\n  \\<Lambda>\\<^sup>2 * (\\<v> - 1)\n  int (size (remove1_mset b1 \\<B>)) = \\<v> - 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl)\\<^sup>2 -\n                          2 * \\<Lambda> * (b1 |\\<inter>| bl) +\n                          \\<Lambda>\\<^sup>2) =\n    \\<Lambda>\\<^sup>2 * (\\<v> - 1) -\n    2 * \\<Lambda> *\n    \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) +\n    (\\<v> - 1) * \\<Lambda>\\<^sup>2", "by (simp add: assms sum_mset.distrib  sum_mset_add_diff sum_mset_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl)\\<^sup>2 -\n                        2 * \\<Lambda> * (b1 |\\<inter>| bl) +\n                        \\<Lambda>\\<^sup>2) =\n  \\<Lambda>\\<^sup>2 * (\\<v> - 1) -\n  2 * \\<Lambda> *\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) +\n  (\\<v> - 1) * \\<Lambda>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  \\<Lambda>\\<^sup>2 * (\\<v> - 1) -\n  2 * \\<Lambda> *\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) +\n  (\\<v> - 1) * \\<Lambda>\\<^sup>2", "have \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). ((b1 |\\<inter>| bl) - \\<Lambda>)^2) = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  \\<Lambda>\\<^sup>2 * (\\<v> - 1) -\n  2 * \\<Lambda> *\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) +\n  (\\<v> - 1) * \\<Lambda>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "using rep_value_sym symmetric_condition_2 sym_sum_inter_num assms"], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  \\<Lambda>\\<^sup>2 * (\\<v> - 1) -\n  2 * \\<Lambda> *\n  \\<Sum>\\<^sub># (image_mset ((|\\<inter>|) b1) (remove1_mset b1 \\<B>)) +\n  (\\<v> - 1) * \\<Lambda>\\<^sup>2\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) = \\<k>\n  \\<Lambda> * (\\<v> - 1) = \\<k> * (\\<k> - 1)\n  ?b1.0 \\<in># \\<B> \\<Longrightarrow>\n  \\<Sum>\\<^sub>#\n   (image_mset ((|\\<inter>|) ?b1.0) (remove1_mset ?b1.0 \\<B>)) =\n  \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n  b1 \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "by (auto simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sym_block_intersections_index [simp]: \n  assumes \"b1 \\<in># \\<B>\"\n  assumes \"b2 \\<in># (\\<B> - {#b1#})\"\n  shows \"b1 |\\<inter>| b2 = \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b1 |\\<inter>| b2 = \\<Lambda>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b1 |\\<inter>| b2 = \\<Lambda>", "have pos: \"\\<And> bl . ((b1 |\\<inter>| bl) - \\<Lambda>)^2 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bl. 0 \\<le> (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  0 \\<le> (b1 |\\<inter>| ?bl - \\<Lambda>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. b1 |\\<inter>| b2 = \\<Lambda>", "have \"(\\<Sum>bl \\<in># (remove1_mset b1 \\<B>). ((b1 |\\<inter>| bl) - \\<Lambda>)^2) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "using sym_sum_inter_num_to_zero assms"], ["proof (prove)\nusing this:\n  ?b1.0 \\<in># \\<B> \\<Longrightarrow>\n  (\\<Sum>bl\\<in>#remove1_mset ?b1.0\n                  \\<B>. (?b1.0 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  0\n  b1 \\<in># \\<B>\n  b2 \\<in># remove1_mset b1 \\<B>\n\ngoal (1 subgoal):\n 1. (\\<Sum>bl\\<in>#remove1_mset b1\n                    \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n    0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  0\n\ngoal (1 subgoal):\n 1. b1 |\\<inter>| b2 = \\<Lambda>", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  0", "have \"\\<And> bl.  bl \\<in> set_mset (remove1_mset b1 \\<B>) \\<Longrightarrow> ((b1 |\\<inter>| bl) - \\<Lambda>)^2 = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># remove1_mset b1 \\<B> \\<Longrightarrow>\n       (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2 = 0", "using sum_mset_0_iff_ge_0 pos"], ["proof (prove)\nusing this:\n  (\\<Sum>bl\\<in>#remove1_mset b1\n                  \\<B>. (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2) =\n  0\n  (\\<And>x. (0::?'a) \\<le> ?f x) \\<Longrightarrow>\n  (\\<Sum>\\<^sub># (image_mset ?f ?A) = (0::?'a)) =\n  (\\<forall>x\\<in>#?A. ?f x = (0::?'a))\n  0 \\<le> (b1 |\\<inter>| ?bl - \\<Lambda>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>bl.\n       bl \\<in># remove1_mset b1 \\<B> \\<Longrightarrow>\n       (b1 |\\<inter>| bl - \\<Lambda>)\\<^sup>2 = 0", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  ?bl \\<in># remove1_mset b1 \\<B> \\<Longrightarrow>\n  (b1 |\\<inter>| ?bl - \\<Lambda>)\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. b1 |\\<inter>| b2 = \\<Lambda>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?bl \\<in># remove1_mset b1 \\<B> \\<Longrightarrow>\n  (b1 |\\<inter>| ?bl - \\<Lambda>)\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. b1 |\\<inter>| b2 = \\<Lambda>", "using assms(2)"], ["proof (prove)\nusing this:\n  ?bl \\<in># remove1_mset b1 \\<B> \\<Longrightarrow>\n  (b1 |\\<inter>| ?bl - \\<Lambda>)\\<^sup>2 = 0\n  b2 \\<in># remove1_mset b1 \\<B>\n\ngoal (1 subgoal):\n 1. b1 |\\<inter>| b2 = \\<Lambda>", "by auto"], ["proof (state)\nthis:\n  b1 |\\<inter>| b2 = \\<Lambda>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Symmetric BIBD is Simple\\<close>"], ["", "lemma sym_block_mult_one [simp]:\n  assumes \"bl \\<in># \\<B>\"\n  shows \"multiplicity bl = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity bl = 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "assume \"\\<not> (multiplicity bl = 1)\""], ["proof (state)\nthis:\n  multiplicity bl \\<noteq> 1\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  multiplicity bl \\<noteq> 1", "have not: \"multiplicity bl \\<noteq> 1\""], ["proof (prove)\nusing this:\n  multiplicity bl \\<noteq> 1\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1", "by simp"], ["proof (state)\nthis:\n  multiplicity bl \\<noteq> 1\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "have \"multiplicity bl \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  multiplicity bl \\<noteq> 0\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  multiplicity bl \\<noteq> 0", "have m: \"multiplicity bl \\<ge> 2\""], ["proof (prove)\nusing this:\n  multiplicity bl \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> multiplicity bl", "using not"], ["proof (prove)\nusing this:\n  multiplicity bl \\<noteq> 0\n  multiplicity bl \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> multiplicity bl", "by linarith"], ["proof (state)\nthis:\n  2 \\<le> multiplicity bl\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  2 \\<le> multiplicity bl", "have blleft: \"bl \\<in># (\\<B> - {#bl#})\""], ["proof (prove)\nusing this:\n  2 \\<le> multiplicity bl\n\ngoal (1 subgoal):\n 1. bl \\<in># remove1_mset bl \\<B>", "using in_diff_count"], ["proof (prove)\nusing this:\n  2 \\<le> multiplicity bl\n  (?a \\<in># ?M - ?N) = (count ?N ?a < count ?M ?a)\n\ngoal (1 subgoal):\n 1. bl \\<in># remove1_mset bl \\<B>", "by fastforce"], ["proof (state)\nthis:\n  bl \\<in># remove1_mset bl \\<B>\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "have \"bl |\\<inter>| bl = \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl |\\<inter>| bl = \\<k>", "using k_non_zero assms"], ["proof (prove)\nusing this:\n  1 \\<le> \\<k>\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. bl |\\<inter>| bl = \\<k>", "by (simp add: intersection_number_def)"], ["proof (state)\nthis:\n  bl |\\<inter>| bl = \\<k>\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  bl |\\<inter>| bl = \\<k>", "have keql: \"\\<k> = \\<Lambda>\""], ["proof (prove)\nusing this:\n  bl |\\<inter>| bl = \\<k>\n\ngoal (1 subgoal):\n 1. \\<k> = \\<Lambda>", "using sym_block_intersections_index blleft assms"], ["proof (prove)\nusing this:\n  bl |\\<inter>| bl = \\<k>\n  \\<lbrakk>?b1.0 \\<in># \\<B>; ?b2.0 \\<in># remove1_mset ?b1.0 \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 |\\<inter>| ?b2.0 = \\<Lambda>\n  bl \\<in># remove1_mset bl \\<B>\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. \\<k> = \\<Lambda>", "by simp"], ["proof (state)\nthis:\n  \\<k> = \\<Lambda>\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<k> = \\<Lambda>", "have \"\\<v> = \\<k>\""], ["proof (prove)\nusing this:\n  \\<k> = \\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<v> = \\<k>", "using keql index_lt_replication rep_value_sym block_size_lt_v diffs0_imp_equal k_non_zero zero_diff"], ["proof (prove)\nusing this:\n  \\<k> = \\<Lambda>\n  \\<k> = \\<Lambda>\n  \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) = \\<k>\n  \\<k> \\<le> \\<v>\n  \\<lbrakk>?m - ?n = 0; ?n - ?m = 0\\<rbrakk> \\<Longrightarrow> ?m = ?n\n  1 \\<le> \\<k>\n  (0::?'a) - ?a = (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<v> = \\<k>", "by linarith"], ["proof (state)\nthis:\n  \\<v> = \\<k>\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<v> = \\<k>", "show False"], ["proof (prove)\nusing this:\n  \\<v> = \\<k>\n\ngoal (1 subgoal):\n 1. False", "using incomplete"], ["proof (prove)\nusing this:\n  \\<v> = \\<k>\n  \\<k> < \\<v>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale symmetric_bibd \\<subseteq> simple_design"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_design \\<V> \\<B>", "by unfold_locales simp"], ["", "subsubsection \\<open>Residual/Derived Sym BIBD Constructions\\<close>"], ["", "text \\<open>Using the intersect result, we can reason further on residual and derived designs. \nProofs based off lecture notes \\cite{HerkeLectureNotes2016}\\<close>"], ["", "locale symmetric_bibd_block_transformations = symmetric_bibd + bibd_block_transformations\nbegin"], ["", "lemma derived_block_size [simp]: \n  assumes \"b \\<in># \\<B>\\<^sup>D\"\n  shows \"card b = \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card b) = \\<Lambda>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (card b) = \\<Lambda>", "obtain bl2 where set: \"bl2 \\<in># remove1_mset bl \\<B>\" and inter: \"b = bl2 \\<inter> bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>bl2 \\<in># remove1_mset bl \\<B>;\n         b = bl2 \\<inter> bl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using derived_blocks_def assms"], ["proof (prove)\nusing this:\n  \\<B>\\<^sup>D \\<equiv> image_mset ((\\<inter>) bl) (remove1_mset bl \\<B>)\n  b \\<in># \\<B>\\<^sup>D\n\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>bl2 \\<in># remove1_mset bl \\<B>;\n         b = bl2 \\<inter> bl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson derived_obtain_orig_block)"], ["proof (state)\nthis:\n  bl2 \\<in># remove1_mset bl \\<B>\n  b = bl2 \\<inter> bl\n\ngoal (1 subgoal):\n 1. int (card b) = \\<Lambda>", "then"], ["proof (chain)\npicking this:\n  bl2 \\<in># remove1_mset bl \\<B>\n  b = bl2 \\<inter> bl", "have \"card b = bl2 |\\<inter>| bl\""], ["proof (prove)\nusing this:\n  bl2 \\<in># remove1_mset bl \\<B>\n  b = bl2 \\<inter> bl\n\ngoal (1 subgoal):\n 1. int (card b) = bl2 |\\<inter>| bl", "by (simp add: intersection_number_def)"], ["proof (state)\nthis:\n  int (card b) = bl2 |\\<inter>| bl\n\ngoal (1 subgoal):\n 1. int (card b) = \\<Lambda>", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (card b) = bl2 |\\<inter>| bl\n\ngoal (1 subgoal):\n 1. int (card b) = \\<Lambda>", "using sym_block_intersections_index"], ["proof (prove)\nusing this:\n  int (card b) = bl2 |\\<inter>| bl\n  \\<lbrakk>?b1.0 \\<in># \\<B>; ?b2.0 \\<in># remove1_mset ?b1.0 \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 |\\<inter>| ?b2.0 = \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (card b) = \\<Lambda>", "using set intersect_num_commute valid_block"], ["proof (prove)\nusing this:\n  int (card b) = bl2 |\\<inter>| bl\n  \\<lbrakk>?b1.0 \\<in># \\<B>; ?b2.0 \\<in># remove1_mset ?b1.0 \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 |\\<inter>| ?b2.0 = \\<Lambda>\n  bl2 \\<in># remove1_mset bl \\<B>\n  ?b1.0 |\\<inter>| ?b2.0 = ?b2.0 |\\<inter>| ?b1.0\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. int (card b) = \\<Lambda>", "by fastforce"], ["proof (state)\nthis:\n  int (card b) = \\<Lambda>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derived_points_index [simp]: \n  assumes \"ps \\<subseteq> bl\"\n  assumes \"card ps = 2\"\n  shows \"\\<B>\\<^sup>D index  ps = \\<Lambda> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1", "have b_in: \"\\<And> b . b \\<in># (remove1_mset bl \\<B>) \\<Longrightarrow> ps \\<subseteq> b \\<Longrightarrow> ps \\<subseteq> b \\<inter> bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> b\\<rbrakk>\n       \\<Longrightarrow> ps \\<subseteq> b \\<inter> bl", "using assms"], ["proof (prove)\nusing this:\n  ps \\<subseteq> bl\n  card ps = 2\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> b\\<rbrakk>\n       \\<Longrightarrow> ps \\<subseteq> b \\<inter> bl", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> ?b\\<rbrakk>\n  \\<Longrightarrow> ps \\<subseteq> ?b \\<inter> bl\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> ?b\\<rbrakk>\n  \\<Longrightarrow> ps \\<subseteq> ?b \\<inter> bl", "have orig: \"ps \\<subseteq> \\<V>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> ?b\\<rbrakk>\n  \\<Longrightarrow> ps \\<subseteq> ?b \\<inter> bl\n\ngoal (1 subgoal):\n 1. ps \\<subseteq> \\<V>", "using valid_block assms wellformed"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> ?b\\<rbrakk>\n  \\<Longrightarrow> ps \\<subseteq> ?b \\<inter> bl\n  bl \\<in># \\<B>\n  ps \\<subseteq> bl\n  card ps = 2\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. ps \\<subseteq> \\<V>", "by blast"], ["proof (state)\nthis:\n  ps \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  ps \\<subseteq> \\<V>", "have lam: \"size {# b \\<in># \\<B> . ps \\<subseteq> b #} = \\<Lambda>\""], ["proof (prove)\nusing this:\n  ps \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) ps) \\<B>)) = \\<Lambda>", "using balanced"], ["proof (prove)\nusing this:\n  ps \\<subseteq> \\<V>\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = 2\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) = \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) ps) \\<B>)) = \\<Lambda>", "by (simp add: assms(2)  points_index_def)"], ["proof (state)\nthis:\n  int (size (filter_mset ((\\<subseteq>) ps) \\<B>)) = \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  int (size (filter_mset ((\\<subseteq>) ps) \\<B>)) = \\<Lambda>", "have \"size {# b \\<in># remove1_mset bl \\<B> . ps \\<subseteq> b #} = size {# b \\<in># \\<B> . ps \\<subseteq> b #} - 1\""], ["proof (prove)\nusing this:\n  int (size (filter_mset ((\\<subseteq>) ps) \\<B>)) = \\<Lambda>\n\ngoal (1 subgoal):\n 1. size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>)) =\n    size (filter_mset ((\\<subseteq>) ps) \\<B>) - 1", "using assms valid_block"], ["proof (prove)\nusing this:\n  int (size (filter_mset ((\\<subseteq>) ps) \\<B>)) = \\<Lambda>\n  ps \\<subseteq> bl\n  card ps = 2\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>)) =\n    size (filter_mset ((\\<subseteq>) ps) \\<B>) - 1", "by (simp add: size_Diff_submset)"], ["proof (state)\nthis:\n  size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>)) =\n  size (filter_mset ((\\<subseteq>) ps) \\<B>) - 1\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>)) =\n  size (filter_mset ((\\<subseteq>) ps) \\<B>) - 1", "have \"size {# b \\<in># remove1_mset bl \\<B> . ps \\<subseteq> b #} = \\<Lambda> - 1\""], ["proof (prove)\nusing this:\n  size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>)) =\n  size (filter_mset ((\\<subseteq>) ps) \\<B>) - 1\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>))) =\n    \\<Lambda> - 1", "using lam index_not_zero"], ["proof (prove)\nusing this:\n  size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>)) =\n  size (filter_mset ((\\<subseteq>) ps) \\<B>) - 1\n  int (size (filter_mset ((\\<subseteq>) ps) \\<B>)) = \\<Lambda>\n  1 \\<le> \\<Lambda>\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>))) =\n    \\<Lambda> - 1", "by linarith"], ["proof (state)\nthis:\n  int (size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>))) =\n  \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  int (size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>))) =\n  \\<Lambda> - 1", "have \"size  {# bl \\<inter> b |  b \\<in># (remove1_mset bl \\<B>) . ps \\<subseteq> bl \\<inter> b #} = \\<Lambda> - 1\""], ["proof (prove)\nusing this:\n  int (size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>))) =\n  \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. int (size\n          (image_mset ((\\<inter>) bl)\n            {#b \\<in># remove1_mset bl \\<B>.\n             ps \\<subseteq> bl \\<inter> b#})) =\n    \\<Lambda> - 1", "using b_in"], ["proof (prove)\nusing this:\n  int (size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>))) =\n  \\<Lambda> - 1\n  \\<lbrakk>?b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> ?b\\<rbrakk>\n  \\<Longrightarrow> ps \\<subseteq> ?b \\<inter> bl\n\ngoal (1 subgoal):\n 1. int (size\n          (image_mset ((\\<inter>) bl)\n            {#b \\<in># remove1_mset bl \\<B>.\n             ps \\<subseteq> bl \\<inter> b#})) =\n    \\<Lambda> - 1", "by (metis (no_types, lifting) Int_subset_iff filter_mset_cong size_image_mset)"], ["proof (state)\nthis:\n  int (size\n        (image_mset ((\\<inter>) bl)\n          {#b \\<in># remove1_mset bl \\<B>.\n           ps \\<subseteq> bl \\<inter> b#})) =\n  \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  int (size\n        (image_mset ((\\<inter>) bl)\n          {#b \\<in># remove1_mset bl \\<B>.\n           ps \\<subseteq> bl \\<inter> b#})) =\n  \\<Lambda> - 1", "have \"size {# x \\<in># {# bl \\<inter> b . b \\<in># (remove1_mset bl \\<B>) #} . ps \\<subseteq> x #} = \\<Lambda> - 1\""], ["proof (prove)\nusing this:\n  int (size\n        (image_mset ((\\<inter>) bl)\n          {#b \\<in># remove1_mset bl \\<B>.\n           ps \\<subseteq> bl \\<inter> b#})) =\n  \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. int (size\n          (filter_mset ((\\<subseteq>) ps)\n            (image_mset ((\\<inter>) bl) (remove1_mset bl \\<B>)))) =\n    \\<Lambda> - 1", "by (metis image_mset_filter_swap)"], ["proof (state)\nthis:\n  int (size\n        (filter_mset ((\\<subseteq>) ps)\n          (image_mset ((\\<inter>) bl) (remove1_mset bl \\<B>)))) =\n  \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1", "then"], ["proof (chain)\npicking this:\n  int (size\n        (filter_mset ((\\<subseteq>) ps)\n          (image_mset ((\\<inter>) bl) (remove1_mset bl \\<B>)))) =\n  \\<Lambda> - 1", "have \"size {# x \\<in># \\<B>\\<^sup>D . ps \\<subseteq> x #} = \\<Lambda> - 1\""], ["proof (prove)\nusing this:\n  int (size\n        (filter_mset ((\\<subseteq>) ps)\n          (image_mset ((\\<inter>) bl) (remove1_mset bl \\<B>)))) =\n  \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. int (size (filter_mset ((\\<subseteq>) ps) \\<B>\\<^sup>D)) = \\<Lambda> - 1", "by (simp add: derived_blocks_def)"], ["proof (state)\nthis:\n  int (size (filter_mset ((\\<subseteq>) ps) \\<B>\\<^sup>D)) = \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (size (filter_mset ((\\<subseteq>) ps) \\<B>\\<^sup>D)) = \\<Lambda> - 1\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1", "by (simp add: points_index_def)"], ["proof (state)\nthis:\n  int (\\<B>\\<^sup>D index ps) = \\<Lambda> - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sym_derive_design_bibd: \n  assumes \"\\<Lambda> > 1\"\n  shows \"bibd bl \\<B>\\<^sup>D \\<Lambda> (\\<Lambda> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bibd bl \\<B>\\<^sup>D \\<Lambda> (\\<Lambda> - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bibd bl \\<B>\\<^sup>D \\<Lambda> (\\<Lambda> - 1)", "interpret des: proper_design bl \"\\<B>\\<^sup>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design bl \\<B>\\<^sup>D", "using derived_is_proper assms valid_block"], ["proof (prove)\nusing this:\n  (\\<And>b.\n      b \\<in># remove1_mset bl \\<B> \\<Longrightarrow>\n      0 < bl |\\<inter>| b) \\<Longrightarrow>\n  proper_design bl \\<B>\\<^sup>D\n  1 < \\<Lambda>\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. proper_design bl \\<B>\\<^sup>D", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. bibd bl \\<B>\\<^sup>D \\<Lambda> (\\<Lambda> - 1)", "have \"\\<Lambda> < \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> < \\<k>", "using index_lt_replication rep_value_sym"], ["proof (prove)\nusing this:\n  \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) = \\<k>\n\ngoal (1 subgoal):\n 1. \\<Lambda> < \\<k>", "by linarith"], ["proof (state)\nthis:\n  \\<Lambda> < \\<k>\n\ngoal (1 subgoal):\n 1. bibd bl \\<B>\\<^sup>D \\<Lambda> (\\<Lambda> - 1)", "then"], ["proof (chain)\npicking this:\n  \\<Lambda> < \\<k>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Lambda> < \\<k>\n\ngoal (1 subgoal):\n 1. bibd bl \\<B>\\<^sup>D \\<Lambda> (\\<Lambda> - 1)", "using derived_block_size assms derived_points_index derived_points_order"], ["proof (prove)\nusing this:\n  \\<Lambda> < \\<k>\n  ?b \\<in># \\<B>\\<^sup>D \\<Longrightarrow> int (card ?b) = \\<Lambda>\n  1 < \\<Lambda>\n  \\<lbrakk>?ps \\<subseteq> bl; card ?ps = 2\\<rbrakk>\n  \\<Longrightarrow> int (\\<B>\\<^sup>D index ?ps) = \\<Lambda> - 1\n  derived_incidence_sys.\\<v> = \\<k>\n\ngoal (1 subgoal):\n 1. bibd bl \\<B>\\<^sup>D \\<Lambda> (\\<Lambda> - 1)", "by (unfold_locales) (simp_all)"], ["proof (state)\nthis:\n  bibd bl \\<B>\\<^sup>D \\<Lambda> (\\<Lambda> - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma residual_block_size [simp]: \n  assumes \"b \\<in># \\<B>\\<^sup>R\"\n  shows \"card b = \\<k> - \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card b) = \\<k> - \\<Lambda>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (card b) = \\<k> - \\<Lambda>", "obtain bl2 where sub: \"b = bl2 - bl\" and mem: \"bl2 \\<in># remove1_mset bl \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>b = bl2 - bl; bl2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms residual_blocks_def"], ["proof (prove)\nusing this:\n  b \\<in># \\<B>\\<^sup>R\n  \\<B>\\<^sup>R \\<equiv> {#b - bl. b \\<in># remove1_mset bl \\<B>#}\n\ngoal (1 subgoal):\n 1. (\\<And>bl2.\n        \\<lbrakk>b = bl2 - bl; bl2 \\<in># remove1_mset bl \\<B>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b = bl2 - bl\n  bl2 \\<in># remove1_mset bl \\<B>\n\ngoal (1 subgoal):\n 1. int (card b) = \\<k> - \\<Lambda>", "then"], ["proof (chain)\npicking this:\n  b = bl2 - bl\n  bl2 \\<in># remove1_mset bl \\<B>", "have \"card b = card bl2 - card (bl2 \\<inter> bl)\""], ["proof (prove)\nusing this:\n  b = bl2 - bl\n  bl2 \\<in># remove1_mset bl \\<B>\n\ngoal (1 subgoal):\n 1. card b = card bl2 - card (bl2 \\<inter> bl)", "using card_Diff_subset_Int valid_block finite_blocks"], ["proof (prove)\nusing this:\n  b = bl2 - bl\n  bl2 \\<in># remove1_mset bl \\<B>\n  finite (?A \\<inter> ?B) \\<Longrightarrow>\n  card (?A - ?B) = card ?A - card (?A \\<inter> ?B)\n  bl \\<in># \\<B>\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n\ngoal (1 subgoal):\n 1. card b = card bl2 - card (bl2 \\<inter> bl)", "by (simp add: card_Diff_subset_Int)"], ["proof (state)\nthis:\n  card b = card bl2 - card (bl2 \\<inter> bl)\n\ngoal (1 subgoal):\n 1. int (card b) = \\<k> - \\<Lambda>", "then"], ["proof (chain)\npicking this:\n  card b = card bl2 - card (bl2 \\<inter> bl)", "have \"card b = card bl2 - bl2 |\\<inter>| bl\""], ["proof (prove)\nusing this:\n  card b = card bl2 - card (bl2 \\<inter> bl)\n\ngoal (1 subgoal):\n 1. int (card b) = int (card bl2) - bl2 |\\<inter>| bl", "using intersection_number_def finite_blocks card_inter_lt_single"], ["proof (prove)\nusing this:\n  card b = card bl2 - card (bl2 \\<inter> bl)\n  ?b1.0 |\\<inter>| ?b2.0 \\<equiv> int (card (?b1.0 \\<inter> ?b2.0))\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n  \\<lbrakk>finite ?A; finite ?B\\<rbrakk>\n  \\<Longrightarrow> card (?A \\<inter> ?B) \\<le> card ?A\n\ngoal (1 subgoal):\n 1. int (card b) = int (card bl2) - bl2 |\\<inter>| bl", "by (metis assms derived_fin_incidence_system.finite_sets finite_Diff2 of_nat_diff \n        residual_fin_incidence_sys.finite_blocks sub)"], ["proof (state)\nthis:\n  int (card b) = int (card bl2) - bl2 |\\<inter>| bl\n\ngoal (1 subgoal):\n 1. int (card b) = \\<k> - \\<Lambda>", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (card b) = int (card bl2) - bl2 |\\<inter>| bl\n\ngoal (1 subgoal):\n 1. int (card b) = \\<k> - \\<Lambda>", "using sym_block_intersections_index uniform"], ["proof (prove)\nusing this:\n  int (card b) = int (card bl2) - bl2 |\\<inter>| bl\n  \\<lbrakk>?b1.0 \\<in># \\<B>; ?b2.0 \\<in># remove1_mset ?b1.0 \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?b1.0 |\\<inter>| ?b2.0 = \\<Lambda>\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n\ngoal (1 subgoal):\n 1. int (card b) = \\<k> - \\<Lambda>", "by (metis valid_block in_diffD intersect_num_commute mem)"], ["proof (state)\nthis:\n  int (card b) = \\<k> - \\<Lambda>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma residual_index [simp]: \n  assumes \"ps \\<subseteq> bl\\<^sup>c\"\n  assumes \"card ps = 2\"\n  shows  \"(\\<B>\\<^sup>R) index ps = \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>R index ps) = \\<Lambda>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>R index ps) = \\<Lambda>", "have a: \"\\<And> b . (b \\<in># remove1_mset bl \\<B> \\<Longrightarrow> ps \\<subseteq> b \\<Longrightarrow>  ps \\<subseteq> (b - bl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> b\\<rbrakk>\n       \\<Longrightarrow> ps \\<subseteq> b - bl", "using assms"], ["proof (prove)\nusing this:\n  ps \\<subseteq> bl\\<^sup>c\n  card ps = 2\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> b\\<rbrakk>\n       \\<Longrightarrow> ps \\<subseteq> b - bl", "by (smt DiffI block_comp_elem_alt_left in_diffD subset_eq wellformed)"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> ?b\\<rbrakk>\n  \\<Longrightarrow> ps \\<subseteq> ?b - bl\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>R index ps) = \\<Lambda>", "have b: \"\\<And> b . (b \\<in># remove1_mset bl \\<B> \\<Longrightarrow>  ps \\<subseteq> (b - bl) \\<Longrightarrow>  ps \\<subseteq> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in># remove1_mset bl \\<B>;\n        ps \\<subseteq> b - bl\\<rbrakk>\n       \\<Longrightarrow> ps \\<subseteq> b", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> ?b - bl\\<rbrakk>\n  \\<Longrightarrow> ps \\<subseteq> ?b\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>R index ps) = \\<Lambda>", "have not_ss: \"\\<not> (ps \\<subseteq> bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> bl", "using set_diff_non_empty_not_subset blocks_nempty t_non_zero assms \n    block_complement_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B - ?C; ?C \\<noteq> {}; ?A \\<noteq> {};\n   ?B \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?A \\<subseteq> ?C\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {}\n  1 \\<le> 2\n  ps \\<subseteq> bl\\<^sup>c\n  card ps = 2\n  ?b\\<^sup>c \\<equiv> \\<V> - ?b\n\ngoal (1 subgoal):\n 1. \\<not> ps \\<subseteq> bl", "by fastforce"], ["proof (state)\nthis:\n  \\<not> ps \\<subseteq> bl\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>R index ps) = \\<Lambda>", "have \"\\<B>\\<^sup>R index ps = size {# x \\<in># {# b - bl . b \\<in># (remove1_mset bl \\<B>) #} . ps \\<subseteq> x #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>R index ps =\n    size\n     (filter_mset ((\\<subseteq>) ps)\n       {#b - bl. b \\<in># remove1_mset bl \\<B>#})", "using assms valid_block"], ["proof (prove)\nusing this:\n  ps \\<subseteq> bl\\<^sup>c\n  card ps = 2\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>R index ps =\n    size\n     (filter_mset ((\\<subseteq>) ps)\n       {#b - bl. b \\<in># remove1_mset bl \\<B>#})", "by (simp add: points_index_def residual_blocks_def)"], ["proof (state)\nthis:\n  \\<B>\\<^sup>R index ps =\n  size\n   (filter_mset ((\\<subseteq>) ps)\n     {#b - bl. b \\<in># remove1_mset bl \\<B>#})\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>R index ps) = \\<Lambda>", "also"], ["proof (state)\nthis:\n  \\<B>\\<^sup>R index ps =\n  size\n   (filter_mset ((\\<subseteq>) ps)\n     {#b - bl. b \\<in># remove1_mset bl \\<B>#})\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>R index ps) = \\<Lambda>", "have \"... = size  {# b - bl |  b \\<in># (remove1_mset bl \\<B>) . ps \\<subseteq> b - bl #} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. size\n     (filter_mset ((\\<subseteq>) ps)\n       {#b - bl. b \\<in># remove1_mset bl \\<B>#}) =\n    size\n     {#b - bl\n     . b \\<in># {#b \\<in># remove1_mset bl \\<B>. ps \\<subseteq> b - bl#}#}", "by (metis image_mset_filter_swap)"], ["proof (state)\nthis:\n  size\n   (filter_mset ((\\<subseteq>) ps)\n     {#b - bl. b \\<in># remove1_mset bl \\<B>#}) =\n  size\n   {#b - bl\n   . b \\<in># {#b \\<in># remove1_mset bl \\<B>. ps \\<subseteq> b - bl#}#}\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>R index ps) = \\<Lambda>", "finally"], ["proof (chain)\npicking this:\n  \\<B>\\<^sup>R index ps =\n  size\n   {#b - bl\n   . b \\<in># {#b \\<in># remove1_mset bl \\<B>. ps \\<subseteq> b - bl#}#}", "have \"\\<B>\\<^sup>R index ps = size  {#  b \\<in># (remove1_mset bl \\<B>) . ps \\<subseteq> b #} \""], ["proof (prove)\nusing this:\n  \\<B>\\<^sup>R index ps =\n  size\n   {#b - bl\n   . b \\<in># {#b \\<in># remove1_mset bl \\<B>. ps \\<subseteq> b - bl#}#}\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>R index ps =\n    size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>))", "using a b"], ["proof (prove)\nusing this:\n  \\<B>\\<^sup>R index ps =\n  size\n   {#b - bl\n   . b \\<in># {#b \\<in># remove1_mset bl \\<B>. ps \\<subseteq> b - bl#}#}\n  \\<lbrakk>?b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> ?b\\<rbrakk>\n  \\<Longrightarrow> ps \\<subseteq> ?b - bl\n  \\<lbrakk>?b \\<in># remove1_mset bl \\<B>; ps \\<subseteq> ?b - bl\\<rbrakk>\n  \\<Longrightarrow> ps \\<subseteq> ?b\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sup>R index ps =\n    size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>))", "by (metis (no_types, lifting) filter_mset_cong size_image_mset)"], ["proof (state)\nthis:\n  \\<B>\\<^sup>R index ps =\n  size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>))\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>R index ps) = \\<Lambda>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<B>\\<^sup>R index ps =\n  size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>))\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>R index ps) = \\<Lambda>", "using balanced not_ss assms points_index_alt_def block_complement_subset_points"], ["proof (prove)\nusing this:\n  \\<B>\\<^sup>R index ps =\n  size (filter_mset ((\\<subseteq>) ps) (remove1_mset bl \\<B>))\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = 2\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) = \\<Lambda>\n  \\<not> ps \\<subseteq> bl\n  ps \\<subseteq> bl\\<^sup>c\n  card ps = 2\n  \\<B> index ?ps = size (filter_mset ((\\<subseteq>) ?ps) \\<B>)\n  ?ps \\<subseteq> ?bl\\<^sup>c \\<Longrightarrow> ?ps \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. int (\\<B>\\<^sup>R index ps) = \\<Lambda>", "by auto"], ["proof (state)\nthis:\n  int (\\<B>\\<^sup>R index ps) = \\<Lambda>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sym_residual_design_bibd: \n  assumes \"\\<k> \\<ge> \\<Lambda> + 2\"\n  shows \"bibd (bl\\<^sup>c) \\<B>\\<^sup>R (\\<k> - \\<Lambda>) \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bibd (bl\\<^sup>c) \\<B>\\<^sup>R (\\<k> - \\<Lambda>) \\<Lambda>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bibd (bl\\<^sup>c) \\<B>\\<^sup>R (\\<k> - \\<Lambda>) \\<Lambda>", "interpret des: proper_design \"bl\\<^sup>c\" \"\\<B>\\<^sup>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design (bl\\<^sup>c) \\<B>\\<^sup>R", "using residual_is_proper assms(1) valid_block sym_block_mult_one"], ["proof (prove)\nusing this:\n  multiplicity bl = 1 \\<Longrightarrow>\n  proper_design (bl\\<^sup>c) \\<B>\\<^sup>R\n  \\<Lambda> + 2 \\<le> \\<k>\n  bl \\<in># \\<B>\n  ?bl \\<in># \\<B> \\<Longrightarrow> multiplicity ?bl = 1\n\ngoal (1 subgoal):\n 1. proper_design (bl\\<^sup>c) \\<B>\\<^sup>R", "by fastforce"], ["proof (state)\ngoal (1 subgoal):\n 1. bibd (bl\\<^sup>c) \\<B>\\<^sup>R (\\<k> - \\<Lambda>) \\<Lambda>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bibd (bl\\<^sup>c) \\<B>\\<^sup>R (\\<k> - \\<Lambda>) \\<Lambda>", "using residual_block_size assms sym_design_vk_gt_kl residual_order residual_index"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B>\\<^sup>R \\<Longrightarrow> int (card ?b) = \\<k> - \\<Lambda>\n  \\<Lambda> + 2 \\<le> \\<k>\n  \\<Lambda> + 2 \\<le> \\<k> \\<Longrightarrow> \\<k> - \\<Lambda> < \\<v> - \\<k>\n  int (card (bl\\<^sup>c)) = \\<v> - \\<k>\n  \\<lbrakk>?ps \\<subseteq> bl\\<^sup>c; card ?ps = 2\\<rbrakk>\n  \\<Longrightarrow> int (\\<B>\\<^sup>R index ?ps) = \\<Lambda>\n\ngoal (1 subgoal):\n 1. bibd (bl\\<^sup>c) \\<B>\\<^sup>R (\\<k> - \\<Lambda>) \\<Lambda>", "by(unfold_locales) simp_all"], ["proof (state)\nthis:\n  bibd (bl\\<^sup>c) \\<B>\\<^sup>R (\\<k> - \\<Lambda>) \\<Lambda>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>BIBD's and Other Block Designs\\<close>"], ["", "text \\<open>BIBD's are closely related to other block designs by indirect inheritance\\<close>"], ["", "sublocale bibd \\<subseteq> k_\\<Lambda>_PBD \\<V> \\<B> \\<Lambda> \\<k>"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_\\<Lambda>_PBD \\<V> \\<B> \\<Lambda> \\<k>", "using block_size_gt_t"], ["proof (prove)\nusing this:\n  ?k \\<in> {\\<k>} \\<Longrightarrow> 2 \\<le> ?k\n\ngoal (1 subgoal):\n 1. k_\\<Lambda>_PBD \\<V> \\<B> \\<Lambda> \\<k>", "by (unfold_locales) simp_all"], ["", "lemma incomplete_PBD_is_bibd: \n  assumes \"k < card V\" and \"k_\\<Lambda>_PBD V B \\<Lambda> k\" \n  shows \"bibd V B k \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bibd V B (int k) \\<Lambda>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bibd V B (int k) \\<Lambda>", "interpret inc: incomplete_design V B k"], ["proof (prove)\ngoal (1 subgoal):\n 1. incomplete_design V B (int k)", "using assms"], ["proof (prove)\nusing this:\n  k < card V\n  k_\\<Lambda>_PBD V B \\<Lambda> (int k)\n\ngoal (1 subgoal):\n 1. incomplete_design V B (int k)", "by (auto simp add: block_design.incomplete_designI k_\\<Lambda>_PBD.axioms(2))"], ["proof (state)\ngoal (1 subgoal):\n 1. bibd V B (int k) \\<Lambda>", "interpret pairwise_balance: pairwise_balance V B \\<Lambda>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise_balance V B \\<Lambda>", "using assms"], ["proof (prove)\nusing this:\n  k < card V\n  k_\\<Lambda>_PBD V B \\<Lambda> (int k)\n\ngoal (1 subgoal):\n 1. pairwise_balance V B \\<Lambda>", "by (auto simp add: k_\\<Lambda>_PBD.axioms(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. bibd V B (int k) \\<Lambda>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bibd V B (int k) \\<Lambda>", "using assms k_\\<Lambda>_PBD.block_size_t"], ["proof (prove)\nusing this:\n  k < card V\n  k_\\<Lambda>_PBD V B \\<Lambda> (int k)\n  k_\\<Lambda>_PBD ?point_set ?block_collection ?index\n   ?u_block_size \\<Longrightarrow>\n  2 \\<le> ?u_block_size\n\ngoal (1 subgoal):\n 1. bibd V B (int k) \\<Lambda>", "by (unfold_locales) (simp_all)"], ["proof (state)\nthis:\n  bibd V B (int k) \\<Lambda>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bibd) bibd_to_pbdI[intro]: \n  assumes \"\\<Lambda> = 1\" \n  shows \"k_PBD \\<V> \\<B> \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k_PBD \\<V> \\<B> \\<k>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k_PBD \\<V> \\<B> \\<k>", "interpret pbd: k_\\<Lambda>_PBD \\<V> \\<B> \\<Lambda> \\<k>"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_\\<Lambda>_PBD \\<V> \\<B> \\<Lambda> \\<k>", "by (simp add: k_\\<Lambda>_PBD_axioms)"], ["proof (state)\ngoal (1 subgoal):\n 1. k_PBD \\<V> \\<B> \\<k>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_PBD \\<V> \\<B> \\<k>", "using assms"], ["proof (prove)\nusing this:\n  \\<Lambda> = 1\n\ngoal (1 subgoal):\n 1. k_PBD \\<V> \\<B> \\<k>", "by (unfold_locales) (simp_all add: t_lt_order min_block_size_2)"], ["proof (state)\nthis:\n  k_PBD \\<V> \\<B> \\<k>\n\ngoal:\nNo subgoals!", "qed"], ["", "locale incomplete_PBD = incomplete_design + k_\\<Lambda>_PBD"], ["", "sublocale incomplete_PBD \\<subseteq> bibd"], ["proof (prove)\ngoal (1 subgoal):\n 1. bibd \\<V> \\<B> \\<k> \\<Lambda>", "using block_size_t"], ["proof (prove)\nusing this:\n  2 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. bibd \\<V> \\<B> \\<k> \\<Lambda>", "by (unfold_locales) simp"], ["", "end"]]}