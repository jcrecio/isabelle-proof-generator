{"file_name": "/home/qj213/afp-2021-10-22/thys/Design_Theory/Multisets_Extras.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Design_Theory", "problem_names": ["lemma card_Pow_filter_one: \n  assumes \"finite A\" \n  shows \"card {x \\<in> Pow A . card x = 1}  = card (A)\"", "lemma elem_exists_non_empty_set:\n  assumes \"card A > 0\"\n  obtains x where \"x \\<in> A\"", "lemma set_self_img_compr: \"{a | a . a \\<in> A} = A\"", "lemma card_subset_not_gt_card: \"finite A \\<Longrightarrow> card ps > card A \\<Longrightarrow> \\<not> (ps \\<subseteq> A)\"", "lemma card_inter_lt_single: \"finite A \\<Longrightarrow> finite B \\<Longrightarrow> card (A \\<inter> B) \\<le> card A\"", "lemma set_diff_non_empty_not_subset: \n  assumes \"A \\<subseteq> (B - C)\"\n  assumes \"C \\<noteq> {}\"\n  assumes \"A \\<noteq> {}\" \n  assumes \"B \\<noteq> {}\"\n  shows \" \\<not> (A \\<subseteq> C)\"", "lemma set_card_diff_ge_zero: \"finite A \\<Longrightarrow> finite B \\<Longrightarrow> A \\<noteq> B \\<Longrightarrow> card A = card B \\<Longrightarrow> \n    card (A - B) > 0\"", "lemma set_filter_diff: \"{a \\<in> A . P a } - {x} = {a \\<in> (A - {x}) . (P a )}\"", "lemma set_filter_diff_card: \"card ({a \\<in> A . P a } - {x}) = card {a \\<in> (A - {x}) . (P a )}\"", "lemma obtain_subset_with_card_int_n:\n  assumes \"(n ::int) \\<le> of_nat (card S)\"\n  assumes \"(n ::int) \\<ge> 0\"\n  obtains T where \"T \\<subseteq> S\" \"of_nat (card T) = (n ::int)\" \"finite T\"", "lemma transform_filter_img_empty_rm: \n  assumes \"\\<And> g . g \\<in> G \\<Longrightarrow> g \\<noteq> {}\"\n  shows \"{g - {x} | g. g \\<in> G \\<and> g \\<noteq> {x}} = {g - {x} | g. g \\<in> G } - {{}}\"", "lemma bij_betw_inter_subsets: \"bij_betw f A B \\<Longrightarrow> a1 \\<subseteq> A \\<Longrightarrow> a2 \\<subseteq> A \n    \\<Longrightarrow> f ` (a1 \\<inter> a2) = (f ` a1) \\<inter> (f ` a2)\"", "lemma partition_on_remove_pt: \n  assumes \"partition_on A G\"\n  shows \"partition_on (A - {x}) {g - {x} | g. g \\<in> G \\<and> g \\<noteq> {x}}\"", "lemma partition_on_cart_prod:\n  assumes \"card I > 0\"\n  assumes \"A \\<noteq> {}\"\n  assumes \"G \\<noteq> {}\"\n  assumes \"partition_on A G\"\n  shows \"partition_on (A \\<times> I) {g \\<times> I |g. g \\<in> G}\"", "lemma count_size_set_repr: \"size {# x \\<in># A . x = g#} = count A g\"", "lemma mset_nempty_set_nempty: \"A \\<noteq> {#} \\<longleftrightarrow> (set_mset A) \\<noteq> {}\"", "lemma mset_size_ne0_set_card: \"size A > 0 \\<Longrightarrow> card (set_mset A) > 0\"", "lemma set_count_size_min: \"count A a \\<ge> n \\<Longrightarrow> size A \\<ge> n\"", "lemma card_size_filter_eq: \"finite A \\<Longrightarrow>  card {a \\<in> A . P a} = size {#a \\<in># mset_set A . P a#}\"", "lemma size_multiset_int_count:\n  assumes \"of_nat (card (set_mset A)) = (ca :: int)\"\n  assumes \"\\<And>p. p \\<in># A \\<Longrightarrow> of_nat (count A p) = (ca2 :: int)\"\n  shows \"of_nat (size A) =  ((ca :: int) * ca2)\"", "lemma mset_union_size: \"size (A \\<union># B) = size (A) + size (B - A)\"", "lemma mset_union_size_inter: \"size (A \\<union># B) = size (A) + size B - size (A \\<inter># B)\"", "lemma repeat_mset_size [simp]: \"size (repeat_mset n A) = n * size A\"", "lemma repeat_mset_subset_in:\n  assumes \"\\<And> a . a \\<in># A \\<Longrightarrow> a \\<subseteq> B\"\n  assumes \"X \\<in># repeat_mset n A\"\n  assumes \"x \\<in> X\"\n  shows \" x \\<in> B\"", "lemma repeat_mset_not_empty: \"n > 0 \\<Longrightarrow> A \\<noteq> {#} \\<Longrightarrow> repeat_mset n A \\<noteq> {#}\"", "lemma elem_in_repeat_in_original: \"a \\<in># repeat_mset n A \\<Longrightarrow> a \\<in># A\"", "lemma elem_in_original_in_repeat: \"n > 0 \\<Longrightarrow> a \\<in># A \\<Longrightarrow> a \\<in># repeat_mset n A\"", "lemma multiset_add_filter_size: \"size {# a \\<in># (A1 + A2) . P a #} = size {# a \\<in># A1 . P a #} + \n    size {# a \\<in># A2 . P a #}\"", "lemma size_filter_neg: \"size {#a \\<in># A . P a #} = size A - size {# a \\<in># A . \\<not> P a #}\"", "lemma filter_filter_mset_cond_simp: \n  assumes \"\\<And> a . P a \\<Longrightarrow> Q a\"\n  shows \"filter_mset P A = filter_mset P (filter_mset Q A)\"", "lemma filter_filter_mset_ss_member: \"filter_mset (\\<lambda> a . {x, y} \\<subseteq> a) A = \n  filter_mset (\\<lambda> a . {x, y} \\<subseteq> a) (filter_mset (\\<lambda> a . x \\<in> a) A)\"", "lemma multiset_image_do_nothing: \"(\\<And> x .x \\<in># A \\<Longrightarrow> f x = x) \\<Longrightarrow> image_mset f A = A\"", "lemma set_mset_filter: \"set_mset {# f a . a \\<in># A #} = {f a | a. a \\<in># A}\"", "lemma mset_exists_imply: \"x \\<in># {# f a . a \\<in># A #} \\<Longrightarrow> \\<exists> y \\<in># A . x = f y\"", "lemma filter_mset_image_mset:\n  \"filter_mset P (image_mset f A) = image_mset f (filter_mset (\\<lambda>x. P (f x)) A)\"", "lemma mset_bunion_filter: \"{# a \\<in># A . P a \\<or> Q a #} = {# a \\<in># A . P a #} \\<union># {# a \\<in># A . Q a #}\"", "lemma mset_inter_filter: \"{# a \\<in># A . P a \\<and> Q a #} = {# a \\<in># A . P a #} \\<inter># {# a \\<in># A . Q a #}\"", "lemma image_image_mset: \"image_mset (\\<lambda> x . f x) (image_mset (\\<lambda> y . g y) A) = \n    image_mset (\\<lambda> x. f (g x)) A\"", "lemma mset_big_union_obtain: \n  assumes \"x \\<in># \\<Sum>\\<^sub># A\"\n  obtains a where \"a \\<in># A\" and \"x \\<in># a\"", "lemma size_big_union_sum: \"size (\\<Sum>\\<^sub># (M :: 'a multiset multiset)) = (\\<Sum>x \\<in>#M . size x)\"", "lemma size_cartesian_product_singleton [simp]: \"size ({#a#} \\<times># B) = size B\"", "lemma size_cartesian_product_singleton_right [simp]: \"size (A \\<times># {#b#}) = size A\"", "lemma size_cartesian_product_empty [simp]: \"size (A \\<times># {#}) = 0\"", "lemma size_add_elem_step_eq: \n  assumes \"size (A \\<times># B) = size A * size B\" \n  shows \"size (add_mset x A \\<times># B) = size (add_mset x A) * size B\"", "lemma size_cartesian_product: \"size (A \\<times># B) = size A * size B\"", "lemma cart_prod_distinct_mset:\n  assumes assm1: \"distinct_mset A\"\n  assumes assm2: \"distinct_mset B\"\n  shows \"distinct_mset (A \\<times># B)\"", "lemma cart_product_single_intersect: \"x1 \\<noteq> x2 \\<Longrightarrow> ({#x1#} \\<times># A) \\<inter># ({#x2#} \\<times># B) = {#}\"", "lemma size_union_distinct_cart_prod: \"x1 \\<noteq> x2 \\<Longrightarrow> size (({#x1#} \\<times># A) \\<union># ({#x2#} \\<times># B)) = \n    size ({#x1#} \\<times># A) + size ({#x2#} \\<times># B)\"", "lemma size_Union_distinct_cart_prod: \"distinct_mset M \\<Longrightarrow> \n    size (\\<Sum>p\\<in>#M. ({#p#} \\<times># B)) = size (M) * size (B)\"", "lemma size_Union_distinct_cart_prod_filter: \"distinct_mset M \\<Longrightarrow> \n    (\\<And> p . p \\<in># M \\<Longrightarrow> size ({# b \\<in># B . P p b #}) = c) \\<Longrightarrow> \n    size (\\<Sum>p\\<in>#M. ({#p#} \\<times># {# b \\<in># B . P p b #})) = size (M) * c\"", "lemma size_Union_distinct_cart_prod_filter2: \"distinct_mset V \\<Longrightarrow> \n    (\\<And> b . b \\<in># B \\<Longrightarrow> size ({# v \\<in># V . P v b #}) = c) \\<Longrightarrow> \n    size (\\<Sum>b\\<in>#B. ( {# v \\<in># V . P v b #} \\<times># {#b#})) = size (B) * c\"", "lemma cart_product_add_1: \"(add_mset a A) \\<times># B = ({#a#} \\<times># B) + (A \\<times># B)\"", "lemma cart_product_add_1_filter: \"{#m \\<in># ((add_mset a M) \\<times># N) . P m #} = \n    {#m \\<in># (M \\<times># N) . P m #} + {#m \\<in># ({#a#} \\<times>#  N) . P m #}\"", "lemma cart_product_add_1_filter2: \"{#m \\<in># (M \\<times># (add_mset b N)) . P m #} = \n    {#m \\<in># (M \\<times># N) . P m #} + {#m \\<in># (M \\<times>#  {#b#}) . P m #}\"", "lemma cart_prod_singleton_right_gen: \n  assumes \"\\<And> x . x \\<in># (A \\<times># {#b#}) \\<Longrightarrow> P x \\<longleftrightarrow> Q (fst x)\"\n  shows \"{#x \\<in># (A \\<times># {#b#}). P x#} = {# a \\<in># A . Q a#} \\<times># {#b#}\"", "lemma cart_prod_singleton_left_gen: \n  assumes \"\\<And> x . x \\<in># ({#a#} \\<times># B) \\<Longrightarrow> P x \\<longleftrightarrow> Q (snd x)\"\n  shows \"{#x \\<in># ({#a#} \\<times># B). P x#} = {#a#} \\<times># {#b \\<in># B . Q b#}\"", "lemma cart_product_singleton_left: \"{#m \\<in># ({#a#} \\<times>#  N) . fst m \\<in> snd m #} = \n  ({#a#} \\<times># {# n \\<in># N . a \\<in> n #})\" (is \"?A = ?B\")", "lemma cart_product_singleton_right: \"{#m \\<in># (N \\<times># {#b#}) . fst m \\<in> snd m #} = \n  ({# n \\<in># N . n \\<in> b #} \\<times># {# b #})\" (is \"?A = ?B\")", "lemma cart_product_add_1_filter_eq: \"{#m \\<in># ((add_mset a M) \\<times># N) . (fst m \\<in> snd m) #} = \n    {#m \\<in># (M \\<times># N) . (fst m \\<in> snd m) #} + ({#a#} \\<times># {# n \\<in># N . a \\<in> n #})\"", "lemma cart_product_add_1_filter_eq_mirror: \"{#m \\<in># M \\<times># (add_mset b N) . (fst m \\<in> snd m) #} = \n    {#m \\<in># (M \\<times># N) . (fst m \\<in> snd m) #} + ({# n \\<in># M . n \\<in> b #} \\<times># {#b#})\"", "lemma set_break_down_left:\n  shows \"{# m \\<in># (M \\<times># N) . (fst m) \\<in> (snd m)  #} = (\\<Sum>m\\<in>#M. ({#m#} \\<times># {#n \\<in># N. m \\<in> n#}))\"", "lemma set_break_down_right:\n  shows \"{# x \\<in># M \\<times># N . (fst x) \\<in> (snd x)  #} = (\\<Sum>n\\<in>#N. ({#m \\<in># M. m \\<in> n#} \\<times># {#n#}))\"", "lemma sum_over_fun_eq: \n  assumes \"\\<And> x . x \\<in># A \\<Longrightarrow> f x = g x\" \n  shows \"(\\<Sum>x \\<in># A . f(x)) = (\\<Sum> x \\<in># A . g (x))\"", "lemma sum_mset_add_diff: \"(\\<Sum> x \\<in># A. f x - g x) = (\\<Sum> x \\<in># A . f x) -  (\\<Sum> x \\<in># A . g x)\"", "lemma sum_mset_ge0:\"(\\<And> x . f x \\<ge> 0) \\<Longrightarrow> (\\<Sum> x \\<in># A. f x ) \\<ge> 0\"", "lemma sum_order_add_mset: \"(\\<And> x . f x \\<ge> 0) \\<Longrightarrow> (\\<Sum> x \\<in># A. f x ) \\<le> (\\<Sum> x \\<in># add_mset a A. f x )\"", "lemma sum_mset_0_left: \"(\\<And> x . f x \\<ge> 0) \\<Longrightarrow> (\\<Sum> x \\<in># A. f x ) = 0 \\<Longrightarrow> (\\<forall> x \\<in># A .f x = 0)\"", "lemma sum_mset_0_iff_ge_0:\n  assumes \"(\\<And> x . f x \\<ge> 0)\"\n  shows \"(\\<Sum> x \\<in># A. f x ) = 0 \\<longleftrightarrow> (\\<forall> x \\<in> set_mset A .f x = 0)\"", "lemma mset_set_size_card_count: \"(\\<Sum>x \\<in># A. x) = (\\<Sum>x \\<in> set_mset A . x * (count A x))\"", "lemma mset_size_partition_dep: \"size {# a \\<in># A . P a \\<or> Q a #} = \n    size {# a \\<in># A . P a #} +  size {# a \\<in># A . Q a #} -  size {# a \\<in># A . P a \\<and> Q a #}\"", "lemma partition_on_msetI [intro]: \"\\<Sum>\\<^sub>#P = A \\<Longrightarrow> {#} \\<notin># P \\<Longrightarrow> partition_on_mset A P\"", "lemma partition_on_msetD1: \"partition_on_mset A P \\<Longrightarrow> \\<Sum>\\<^sub>#P = A\"", "lemma partition_on_msetD2: \"partition_on_mset A P \\<Longrightarrow> {#} \\<notin>#  P\"", "lemma partition_on_mset_empty: \"partition_on_mset {#} P \\<longleftrightarrow> P = {#}\"", "lemma partition_on_mset_all: \"A \\<noteq> {#} \\<Longrightarrow> partition_on_mset A {#A #}\"", "lemma partition_on_mset_singletons: \"partition_on_mset A (image_mset (\\<lambda> x . {#x#}) A)\"", "lemma partition_on_mset_not_empty: \"A \\<noteq> {#} \\<Longrightarrow> partition_on_mset A P \\<Longrightarrow> P \\<noteq> {#}\"", "lemma partition_on_msetI2: \"\\<Sum>\\<^sub>#P = A \\<Longrightarrow> (\\<And> p . p \\<in># P \\<Longrightarrow> p \\<noteq> {#}) \\<Longrightarrow> partition_on_mset A P\"", "lemma partition_on_mset_elems: \"partition_on_mset A P \\<Longrightarrow> p1 \\<in># P \\<Longrightarrow> x \\<in># p1 \\<Longrightarrow> x \\<in># A\"", "lemma partition_on_mset_sum_size_eq: \"partition_on_mset A P \\<Longrightarrow> (\\<Sum>x \\<in># P. size x) = size A\"", "lemma partition_on_mset_card: assumes \"partition_on_mset A P\" shows \" size P \\<le> size A\"", "lemma partition_on_mset_count_eq: \"partition_on_mset A P \\<Longrightarrow> a \\<in># A \\<Longrightarrow> \n    (\\<Sum>x \\<in># P. count x a) = count A a\"", "lemma partition_on_mset_subsets: \"partition_on_mset A P \\<Longrightarrow> x \\<in># P \\<Longrightarrow> x \\<subseteq># A\"", "lemma partition_on_mset_distinct: \n  assumes \"partition_on_mset A P\"\n  assumes \"distinct_mset A\"\n  shows \"distinct_mset P\"", "lemma partition_on_mset_distinct_disjoint: \n  assumes \"partition_on_mset A P\"\n  assumes \"distinct_mset A\"\n  assumes \"p1 \\<in># P\"\n  assumes \"p2 \\<in># P - {#p1#}\"\n  shows \"p1 \\<inter># p2 = {#}\"", "lemma partition_on_mset_diff: \n  assumes \"partition_on_mset A P\"\n  assumes \"Q \\<subseteq>#P\"\n  shows \"partition_on_mset (A - \\<Sum>\\<^sub>#Q) (P - Q)\"", "lemma sigma_over_set_partition_count: \n  assumes \"finite A\"\n  assumes \"partition_on A P\"\n  assumes \"x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\"\n  shows \"count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1\"", "lemma partition_on_mset_set: \n  assumes \"finite A\"\n  assumes \"partition_on A P\"\n  shows \"partition_on_mset (mset_set A) (mset_set (image (\\<lambda> x. mset_set x) P))\"", "lemma partition_on_mset_distinct_inter: \n  assumes \"partition_on_mset A P\"\n  assumes \"distinct_mset A\"\n  assumes \"p1 \\<in># P\" and \"p2 \\<in># P\" and \"p1 \\<noteq> p2\"\n  shows \"p1 \\<inter># p2 = {#}\"", "lemma partition_on_set_mset_distinct: \n  assumes \"partition_on_mset A P\"\n  assumes \"distinct_mset A\"\n  assumes \"p \\<in># image_mset set_mset P\" \n  assumes \"p' \\<in># image_mset set_mset P\"\n  assumes \"p \\<noteq> p'\"\n  shows \"p \\<inter> p' = {}\"", "lemma partition_on_set_mset:\n  assumes \"partition_on_mset A P\"\n  assumes \"distinct_mset A\"\n  shows \"partition_on (set_mset A) (set_mset (image_mset set_mset P))\"", "lemma partition_on_mset_eq_imp_eq_carrier:\n  assumes \"partition_on_mset A P\"\n  assumes \"partition_on_mset B P\"\n  shows \"A = B\"", "lemma partition_on_mset_add_single:\n  assumes \"partition_on_mset A P\"\n  shows \"partition_on_mset (add_mset a A) (add_mset {#a#} P)\"", "lemma partition_on_mset_add_part:\n  assumes \"partition_on_mset A P\"\n  assumes \"X \\<noteq> {#}\"\n  assumes \"A + X = A'\"\n  shows \"partition_on_mset A' (add_mset X P)\"", "lemma partition_on_mset_add:\n  assumes \"partition_on_mset A P\"\n  assumes \"X \\<in># P\"\n  assumes \"add_mset a X = X'\"\n  shows \"partition_on_mset (add_mset a A) (add_mset X' (P - {#X#}))\"", "lemma partition_on_mset_elem_exists_part:\n  assumes \"partition_on_mset A P\"\n  assumes \"x \\<in># A\" \n  obtains p where \"p \\<in># P\" and \"x \\<in># p\"", "lemma partition_on_mset_combine: \n  assumes \"partition_on_mset A P\"\n  assumes \"partition_on_mset B Q\"\n  shows \"partition_on_mset (A + B) (P + Q)\"", "lemma partition_on_mset_split: \n  assumes \"partition_on_mset A (P + Q)\"\n  shows \"partition_on_mset (\\<Sum>\\<^sub>#P) P\""], "translations": [["", "lemma card_Pow_filter_one: \n  assumes \"finite A\" \n  shows \"card {x \\<in> Pow A . card x = 1}  = card (A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x \\<in> Pow A. card x = 1} = card A", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. card {x \\<in> Pow A. card x = 1} = card A", "proof (induct rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. card {x \\<in> Pow {}. card x = 1} = card {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. card {x \\<in> Pow {}. card x = 1} = card {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x \\<in> Pow {}. card x = 1} = card {}", "by auto"], ["proof (state)\nthis:\n  card {x \\<in> Pow {}. card x = 1} = card {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  card {x \\<in> Pow F. card x = 1} = card F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "have \"Pow (insert x F) = Pow F \\<union> insert x ` Pow F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow (insert x F) = Pow F \\<union> insert x ` Pow F", "by (simp add: Pow_insert)"], ["proof (state)\nthis:\n  Pow (insert x F) = Pow F \\<union> insert x ` Pow F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "then"], ["proof (chain)\npicking this:\n  Pow (insert x F) = Pow F \\<union> insert x ` Pow F", "have split: \"{y \\<in> Pow (insert x F) . card y = 1} = \n      {y \\<in> (Pow F) . card y = 1} \\<union> {y \\<in> (insert x ` Pow F) . card y = 1}\""], ["proof (prove)\nusing this:\n  Pow (insert x F) = Pow F \\<union> insert x ` Pow F\n\ngoal (1 subgoal):\n 1. {y \\<in> Pow (insert x F). card y = 1} =\n    {y \\<in> Pow F. card y = 1} \\<union>\n    {y \\<in> insert x ` Pow F. card y = 1}", "by blast"], ["proof (state)\nthis:\n  {y \\<in> Pow (insert x F). card y = 1} =\n  {y \\<in> Pow F. card y = 1} \\<union>\n  {y \\<in> insert x ` Pow F. card y = 1}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "have \"\\<And> y . y \\<in> (insert x ` Pow F) \\<Longrightarrow> finite y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> insert x ` Pow F \\<Longrightarrow> finite y", "using finite_subset insert.hyps(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  finite F\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> insert x ` Pow F \\<Longrightarrow> finite y", "by fastforce"], ["proof (state)\nthis:\n  ?y \\<in> insert x ` Pow F \\<Longrightarrow> finite ?y\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "then"], ["proof (chain)\npicking this:\n  ?y \\<in> insert x ` Pow F \\<Longrightarrow> finite ?y", "have single: \"\\<And> y . y \\<in> (insert x ` Pow F) \\<Longrightarrow> card y = 1 \\<Longrightarrow> y = {x}\""], ["proof (prove)\nusing this:\n  ?y \\<in> insert x ` Pow F \\<Longrightarrow> finite ?y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> insert x ` Pow F; card y = 1\\<rbrakk>\n       \\<Longrightarrow> y = {x}", "by (metis card_1_singletonE empty_iff image_iff insertCI insertE)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> insert x ` Pow F; card ?y = 1\\<rbrakk>\n  \\<Longrightarrow> ?y = {x}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y \\<in> insert x ` Pow F; card ?y = 1\\<rbrakk>\n  \\<Longrightarrow> ?y = {x}", "have \"card {y \\<in> (insert x ` Pow F) . card y = 1} = 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> insert x ` Pow F; card ?y = 1\\<rbrakk>\n  \\<Longrightarrow> ?y = {x}\n\ngoal (1 subgoal):\n 1. card {y \\<in> insert x ` Pow F. card y = 1} = 1", "using empty_iff imageI is_singletonI is_singletonI' is_singleton_altdef"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> insert x ` Pow F; card ?y = 1\\<rbrakk>\n  \\<Longrightarrow> ?y = {x}\n  (?c \\<in> {}) = False\n  ?x \\<in> ?A \\<Longrightarrow> ?f ?x \\<in> ?f ` ?A\n  is_singleton {?x}\n  \\<lbrakk>?A \\<noteq> {};\n   \\<And>x y.\n      \\<lbrakk>x \\<in> ?A; y \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> x = y\\<rbrakk>\n  \\<Longrightarrow> is_singleton ?A\n  is_singleton ?A = (card ?A = 1)\n\ngoal (1 subgoal):\n 1. card {y \\<in> insert x ` Pow F. card y = 1} = 1", "(* LONG *)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> insert x ` Pow F; card ?y = 1\\<rbrakk>\n  \\<Longrightarrow> ?y = {x}\n  (?c \\<in> {}) = False\n  ?x \\<in> ?A \\<Longrightarrow> ?f ?x \\<in> ?f ` ?A\n  is_singleton {?x}\n  \\<lbrakk>?A \\<noteq> {};\n   \\<And>x y.\n      \\<lbrakk>x \\<in> ?A; y \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> x = y\\<rbrakk>\n  \\<Longrightarrow> is_singleton ?A\n  is_singleton ?A = (card ?A = 1)\n\ngoal (1 subgoal):\n 1. card {y \\<in> insert x ` Pow F. card y = 1} = 1", "by (metis (full_types, lifting) Collect_empty_eq_bot Pow_bottom bot_empty_eq  mem_Collect_eq)"], ["proof (state)\nthis:\n  card {y \\<in> insert x ` Pow F. card y = 1} = 1\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "then"], ["proof (chain)\npicking this:\n  card {y \\<in> insert x ` Pow F. card y = 1} = 1", "have \" {y \\<in> (insert x ` Pow F) . card y = 1} = {{x}}\""], ["proof (prove)\nusing this:\n  card {y \\<in> insert x ` Pow F. card y = 1} = 1\n\ngoal (1 subgoal):\n 1. {y \\<in> insert x ` Pow F. card y = 1} = {{x}}", "using single card_1_singletonE card_eq_0_iff"], ["proof (prove)\nusing this:\n  card {y \\<in> insert x ` Pow F. card y = 1} = 1\n  \\<lbrakk>?y \\<in> insert x ` Pow F; card ?y = 1\\<rbrakk>\n  \\<Longrightarrow> ?y = {x}\n  \\<lbrakk>card ?A = 1; \\<And>x. ?A = {x} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  (card ?A = 0) = (?A = {} \\<or> infinite ?A)\n\ngoal (1 subgoal):\n 1. {y \\<in> insert x ` Pow F. card y = 1} = {{x}}", "by (smt empty_Collect_eq mem_Collect_eq singletonD zero_neq_one)"], ["proof (state)\nthis:\n  {y \\<in> insert x ` Pow F. card y = 1} = {{x}}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "then"], ["proof (chain)\npicking this:\n  {y \\<in> insert x ` Pow F. card y = 1} = {{x}}", "have split2:\"{y \\<in> Pow (insert x F) . card y = 1} = {y \\<in> (Pow F) . card y = 1} \\<union> {{x}}\""], ["proof (prove)\nusing this:\n  {y \\<in> insert x ` Pow F. card y = 1} = {{x}}\n\ngoal (1 subgoal):\n 1. {y \\<in> Pow (insert x F). card y = 1} =\n    {y \\<in> Pow F. card y = 1} \\<union> {{x}}", "using split"], ["proof (prove)\nusing this:\n  {y \\<in> insert x ` Pow F. card y = 1} = {{x}}\n  {y \\<in> Pow (insert x F). card y = 1} =\n  {y \\<in> Pow F. card y = 1} \\<union>\n  {y \\<in> insert x ` Pow F. card y = 1}\n\ngoal (1 subgoal):\n 1. {y \\<in> Pow (insert x F). card y = 1} =\n    {y \\<in> Pow F. card y = 1} \\<union> {{x}}", "by simp"], ["proof (state)\nthis:\n  {y \\<in> Pow (insert x F). card y = 1} =\n  {y \\<in> Pow F. card y = 1} \\<union> {{x}}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        card {x \\<in> Pow F. card x = 1} = card F\\<rbrakk>\n       \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                         card (insert x F)", "then"], ["proof (chain)\npicking this:\n  {y \\<in> Pow (insert x F). card y = 1} =\n  {y \\<in> Pow F. card y = 1} \\<union> {{x}}", "show ?case"], ["proof (prove)\nusing this:\n  {y \\<in> Pow (insert x F). card y = 1} =\n  {y \\<in> Pow F. card y = 1} \\<union> {{x}}\n\ngoal (1 subgoal):\n 1. card {xa \\<in> Pow (insert x F). card xa = 1} = card (insert x F)", "proof (cases \"x \\<in> F\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{y \\<in> Pow (insert x F). card y = 1} =\n             {y \\<in> Pow F. card y = 1} \\<union> {{x}};\n     x \\<in> F\\<rbrakk>\n    \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                      card (insert x F)\n 2. \\<lbrakk>{y \\<in> Pow (insert x F). card y = 1} =\n             {y \\<in> Pow F. card y = 1} \\<union> {{x}};\n     x \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                      card (insert x F)", "case True"], ["proof (state)\nthis:\n  x \\<in> F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{y \\<in> Pow (insert x F). card y = 1} =\n             {y \\<in> Pow F. card y = 1} \\<union> {{x}};\n     x \\<in> F\\<rbrakk>\n    \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                      card (insert x F)\n 2. \\<lbrakk>{y \\<in> Pow (insert x F). card y = 1} =\n             {y \\<in> Pow F. card y = 1} \\<union> {{x}};\n     x \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                      card (insert x F)", "then"], ["proof (chain)\npicking this:\n  x \\<in> F", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> F\n\ngoal (1 subgoal):\n 1. card {xa \\<in> Pow (insert x F). card xa = 1} = card (insert x F)", "using insert.hyps(2)"], ["proof (prove)\nusing this:\n  x \\<in> F\n  x \\<notin> F\n\ngoal (1 subgoal):\n 1. card {xa \\<in> Pow (insert x F). card xa = 1} = card (insert x F)", "by auto"], ["proof (state)\nthis:\n  card {xa \\<in> Pow (insert x F). card xa = 1} = card (insert x F)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{y \\<in> Pow (insert x F). card y = 1} =\n             {y \\<in> Pow F. card y = 1} \\<union> {{x}};\n     x \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                      card (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>{y \\<in> Pow (insert x F). card y = 1} =\n             {y \\<in> Pow F. card y = 1} \\<union> {{x}};\n     x \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                      card (insert x F)", "case False"], ["proof (state)\nthis:\n  x \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{y \\<in> Pow (insert x F). card y = 1} =\n             {y \\<in> Pow F. card y = 1} \\<union> {{x}};\n     x \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                      card (insert x F)", "then"], ["proof (chain)\npicking this:\n  x \\<notin> F", "have \"{y \\<in> (Pow F) . card y = 1} \\<inter> {{x}} = {}\""], ["proof (prove)\nusing this:\n  x \\<notin> F\n\ngoal (1 subgoal):\n 1. {y \\<in> Pow F. card y = 1} \\<inter> {{x}} = {}", "by blast"], ["proof (state)\nthis:\n  {y \\<in> Pow F. card y = 1} \\<inter> {{x}} = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{y \\<in> Pow (insert x F). card y = 1} =\n             {y \\<in> Pow F. card y = 1} \\<union> {{x}};\n     x \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                      card (insert x F)", "then"], ["proof (chain)\npicking this:\n  {y \\<in> Pow F. card y = 1} \\<inter> {{x}} = {}", "have fact:\"card {y \\<in> Pow (insert x F) . card y = 1} = \n        card {y \\<in> (Pow F) . card y = 1} + card {{x}}\""], ["proof (prove)\nusing this:\n  {y \\<in> Pow F. card y = 1} \\<inter> {{x}} = {}\n\ngoal (1 subgoal):\n 1. card {y \\<in> Pow (insert x F). card y = 1} =\n    card {y \\<in> Pow F. card y = 1} + card {{x}}", "using split2 card_Un_disjoint insert.hyps(1)"], ["proof (prove)\nusing this:\n  {y \\<in> Pow F. card y = 1} \\<inter> {{x}} = {}\n  {y \\<in> Pow (insert x F). card y = 1} =\n  {y \\<in> Pow F. card y = 1} \\<union> {{x}}\n  \\<lbrakk>finite ?A; finite ?B; ?A \\<inter> ?B = {}\\<rbrakk>\n  \\<Longrightarrow> card (?A \\<union> ?B) = card ?A + card ?B\n  finite F\n\ngoal (1 subgoal):\n 1. card {y \\<in> Pow (insert x F). card y = 1} =\n    card {y \\<in> Pow F. card y = 1} + card {{x}}", "by auto"], ["proof (state)\nthis:\n  card {y \\<in> Pow (insert x F). card y = 1} =\n  card {y \\<in> Pow F. card y = 1} + card {{x}}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{y \\<in> Pow (insert x F). card y = 1} =\n             {y \\<in> Pow F. card y = 1} \\<union> {{x}};\n     x \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                      card (insert x F)", "have \"card (insert x F) = card F + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert x F) = card F + 1", "using False card_insert_disjoint"], ["proof (prove)\nusing this:\n  x \\<notin> F\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> card (insert ?x ?A) = Suc (card ?A)\n\ngoal (1 subgoal):\n 1. card (insert x F) = card F + 1", "by (metis Suc_eq_plus1 insert.hyps(1))"], ["proof (state)\nthis:\n  card (insert x F) = card F + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{y \\<in> Pow (insert x F). card y = 1} =\n             {y \\<in> Pow F. card y = 1} \\<union> {{x}};\n     x \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> card {xa \\<in> Pow (insert x F). card xa = 1} =\n                      card (insert x F)", "then"], ["proof (chain)\npicking this:\n  card (insert x F) = card F + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  card (insert x F) = card F + 1\n\ngoal (1 subgoal):\n 1. card {xa \\<in> Pow (insert x F). card xa = 1} = card (insert x F)", "using fact insert.hyps(3)"], ["proof (prove)\nusing this:\n  card (insert x F) = card F + 1\n  card {y \\<in> Pow (insert x F). card y = 1} =\n  card {y \\<in> Pow F. card y = 1} + card {{x}}\n  card {x \\<in> Pow F. card x = 1} = card F\n\ngoal (1 subgoal):\n 1. card {xa \\<in> Pow (insert x F). card xa = 1} = card (insert x F)", "by auto"], ["proof (state)\nthis:\n  card {xa \\<in> Pow (insert x F). card xa = 1} = card (insert x F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {xa \\<in> Pow (insert x F). card xa = 1} = card (insert x F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elem_exists_non_empty_set:\n  assumes \"card A > 0\"\n  obtains x where \"x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms card_gt_0_iff"], ["proof (prove)\nusing this:\n  0 < card A\n  (0 < card ?A) = (?A \\<noteq> {} \\<and> finite ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["", "lemma set_self_img_compr: \"{a | a . a \\<in> A} = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a |a. a \\<in> A} = A", "by blast"], ["", "lemma card_subset_not_gt_card: \"finite A \\<Longrightarrow> card ps > card A \\<Longrightarrow> \\<not> (ps \\<subseteq> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; card A < card ps\\<rbrakk>\n    \\<Longrightarrow> \\<not> ps \\<subseteq> A", "using card_mono leD"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A \\<le> card ?B\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; card A < card ps\\<rbrakk>\n    \\<Longrightarrow> \\<not> ps \\<subseteq> A", "by auto"], ["", "lemma card_inter_lt_single: \"finite A \\<Longrightarrow> finite B \\<Longrightarrow> card (A \\<inter> B) \\<le> card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> card (A \\<inter> B) \\<le> card A", "by (simp add: card_mono)"], ["", "lemma set_diff_non_empty_not_subset: \n  assumes \"A \\<subseteq> (B - C)\"\n  assumes \"C \\<noteq> {}\"\n  assumes \"A \\<noteq> {}\" \n  assumes \"B \\<noteq> {}\"\n  shows \" \\<not> (A \\<subseteq> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> A \\<subseteq> C", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> A \\<subseteq> C \\<Longrightarrow> False", "assume \" \\<not> \\<not> (A \\<subseteq> C)\""], ["proof (state)\nthis:\n  \\<not> \\<not> A \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A \\<subseteq> C \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<not> A \\<subseteq> C", "have a: \"\\<And> x . x \\<in> A \\<Longrightarrow> x \\<in> C\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> A \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> C", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> ?x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A \\<subseteq> C \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> ?x \\<in> C\n\ngoal (1 subgoal):\n 1. False", "using a assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> ?x \\<in> C\n  ?x \\<in> A \\<Longrightarrow> ?x \\<in> C\n  A \\<subseteq> B - C\n  C \\<noteq> {}\n  A \\<noteq> {}\n  B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_card_diff_ge_zero: \"finite A \\<Longrightarrow> finite B \\<Longrightarrow> A \\<noteq> B \\<Longrightarrow> card A = card B \\<Longrightarrow> \n    card (A - B) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; finite B; A \\<noteq> B; card A = card B\\<rbrakk>\n    \\<Longrightarrow> 0 < card (A - B)", "by (meson Diff_eq_empty_iff card_0_eq card_subset_eq finite_Diff neq0_conv)"], ["", "lemma set_filter_diff: \"{a \\<in> A . P a } - {x} = {a \\<in> (A - {x}) . (P a )}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a \\<in> A. P a} - {x} = {a \\<in> A - {x}. P a}", "by (auto)"], ["", "lemma set_filter_diff_card: \"card ({a \\<in> A . P a } - {x}) = card {a \\<in> (A - {x}) . (P a )}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({a \\<in> A. P a} - {x}) = card {a \\<in> A - {x}. P a}", "by (simp add: set_filter_diff)"], ["", "lemma obtain_subset_with_card_int_n:\n  assumes \"(n ::int) \\<le> of_nat (card S)\"\n  assumes \"(n ::int) \\<ge> 0\"\n  obtains T where \"T \\<subseteq> S\" \"of_nat (card T) = (n ::int)\" \"finite T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>T \\<subseteq> S; int (card T) = n; finite T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using obtain_subset_with_card_n assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n \\<le> card ?S;\n   \\<And>T.\n      \\<lbrakk>T \\<subseteq> ?S; card T = ?n; finite T\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  n \\<le> int (card S)\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>T \\<subseteq> S; int (card T) = n; finite T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis nonneg_int_cases of_nat_le_iff)"], ["", "lemma transform_filter_img_empty_rm: \n  assumes \"\\<And> g . g \\<in> G \\<Longrightarrow> g \\<noteq> {}\"\n  shows \"{g - {x} | g. g \\<in> G \\<and> g \\<noteq> {x}} = {g - {x} | g. g \\<in> G } - {{}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n    {g - {x} |g. g \\<in> G} - {{}}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n    {g - {x} |g. g \\<in> G} - {{}}", "let ?f = \"\\<lambda> g . g - {x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n    {g - {x} |g. g \\<in> G} - {{}}", "have \"\\<And> g . g \\<in> G \\<Longrightarrow> g \\<noteq> {x} \\<longleftrightarrow> ?f g \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> G \\<Longrightarrow> (g \\<noteq> {x}) = (g - {x} \\<noteq> {})", "using assms"], ["proof (prove)\nusing this:\n  ?g \\<in> G \\<Longrightarrow> ?g \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> G \\<Longrightarrow> (g \\<noteq> {x}) = (g - {x} \\<noteq> {})", "by (metis Diff_cancel Diff_empty Diff_insert0 insert_Diff)"], ["proof (state)\nthis:\n  ?g \\<in> G \\<Longrightarrow> (?g \\<noteq> {x}) = (?g - {x} \\<noteq> {})\n\ngoal (1 subgoal):\n 1. {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n    {g - {x} |g. g \\<in> G} - {{}}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?g \\<in> G \\<Longrightarrow> (?g \\<noteq> {x}) = (?g - {x} \\<noteq> {})\n\ngoal (1 subgoal):\n 1. {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n    {g - {x} |g. g \\<in> G} - {{}}", "by auto"], ["proof (state)\nthis:\n  {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n  {g - {x} |g. g \\<in> G} - {{}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_inter_subsets: \"bij_betw f A B \\<Longrightarrow> a1 \\<subseteq> A \\<Longrightarrow> a2 \\<subseteq> A \n    \\<Longrightarrow> f ` (a1 \\<inter> a2) = (f ` a1) \\<inter> (f ` a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij_betw f A B; a1 \\<subseteq> A; a2 \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> f ` (a1 \\<inter> a2) = f ` a1 \\<inter> f ` a2", "by (meson bij_betw_imp_inj_on inj_on_image_Int)"], ["", "text\\<open>Partition related set theory lemmas\\<close>"], ["", "lemma partition_on_remove_pt: \n  assumes \"partition_on A G\"\n  shows \"partition_on (A - {x}) {g - {x} | g. g \\<in> G \\<and> g \\<noteq> {x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on (A - {x}) {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}}", "proof (intro partition_onI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p.\n       p \\<in> {g - {x} |g.\n                g \\<in> G \\<and> g \\<noteq> {x}} \\<Longrightarrow>\n       p \\<noteq> {}\n 2. \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}\n 3. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "show \"\\<And>p. p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} \\<Longrightarrow> p \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> {g - {x} |g.\n                g \\<in> G \\<and> g \\<noteq> {x}} \\<Longrightarrow>\n       p \\<noteq> {}", "using assms partition_onD3 subset_singletonD"], ["proof (prove)\nusing this:\n  partition_on A G\n  partition_on ?A ?P \\<Longrightarrow> {} \\<notin> ?P\n  ?A \\<subseteq> {?x} \\<Longrightarrow> ?A = {} \\<or> ?A = {?x}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> {g - {x} |g.\n                g \\<in> G \\<and> g \\<noteq> {x}} \\<Longrightarrow>\n       p \\<noteq> {}", "by force"], ["proof (state)\nthis:\n  ?p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} \\<Longrightarrow>\n  ?p \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}\n 2. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "let ?f =  \"(\\<lambda> g . g - {x})\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}\n 2. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "have un_img: \"\\<Union>({?f g | g. g \\<in> G }) = ?f (\\<Union> G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {g - {x} |g. g \\<in> G} = \\<Union> G - {x}", "by blast"], ["proof (state)\nthis:\n  \\<Union> {g - {x} |g. g \\<in> G} = \\<Union> G - {x}\n\ngoal (2 subgoals):\n 1. \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}\n 2. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "have empty: \"\\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = \\<Union>({g - {x} | g. g \\<in> G } - {{}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n    \\<Union> ({g - {x} |g. g \\<in> G} - {{}})", "by blast"], ["proof (state)\nthis:\n  \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n  \\<Union> ({g - {x} |g. g \\<in> G} - {{}})\n\ngoal (2 subgoals):\n 1. \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}\n 2. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "then"], ["proof (chain)\npicking this:\n  \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n  \\<Union> ({g - {x} |g. g \\<in> G} - {{}})", "have \"\\<Union>({g - {x} | g. g \\<in> G } - {{}}) = \\<Union>({g - {x} | g. g \\<in> G })\""], ["proof (prove)\nusing this:\n  \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n  \\<Union> ({g - {x} |g. g \\<in> G} - {{}})\n\ngoal (1 subgoal):\n 1. \\<Union> ({g - {x} |g. g \\<in> G} - {{}}) =\n    \\<Union> {g - {x} |g. g \\<in> G}", "by blast"], ["proof (state)\nthis:\n  \\<Union> ({g - {x} |g. g \\<in> G} - {{}}) =\n  \\<Union> {g - {x} |g. g \\<in> G}\n\ngoal (2 subgoals):\n 1. \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}\n 2. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "then"], ["proof (chain)\npicking this:\n  \\<Union> ({g - {x} |g. g \\<in> G} - {{}}) =\n  \\<Union> {g - {x} |g. g \\<in> G}", "show \" \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}\""], ["proof (prove)\nusing this:\n  \\<Union> ({g - {x} |g. g \\<in> G} - {{}}) =\n  \\<Union> {g - {x} |g. g \\<in> G}\n\ngoal (1 subgoal):\n 1. \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}", "using partition_onD1 assms un_img"], ["proof (prove)\nusing this:\n  \\<Union> ({g - {x} |g. g \\<in> G} - {{}}) =\n  \\<Union> {g - {x} |g. g \\<in> G}\n  partition_on ?A ?P \\<Longrightarrow> ?A = \\<Union> ?P\n  partition_on A G\n  \\<Union> {g - {x} |g. g \\<in> G} = \\<Union> G - {x}\n\ngoal (1 subgoal):\n 1. \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}", "by (metis empty)"], ["proof (state)\nthis:\n  \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}\n\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "then"], ["proof (chain)\npicking this:\n  \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}", "show \"\\<And>p p'.\n       p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} \\<Longrightarrow>\n       p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} \\<Longrightarrow> p \\<noteq> p' \\<Longrightarrow> p \\<inter> p' = {}\""], ["proof (prove)\nusing this:\n  \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} = A - {x}\n\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p';\n        \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n        A - {x}\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "fix p1 p2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p';\n        \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n        A - {x}\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "assume p1: \"p1 \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}}\" \n       and p2: \"p2 \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}}\"\n       and ne: \"p1 \\<noteq> p2\""], ["proof (state)\nthis:\n  p1 \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}}\n  p2 \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}}\n  p1 \\<noteq> p2\n\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p';\n        \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n        A - {x}\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "obtain p1' p2' where orig1: \"p1 = p1' - {x}\" and orig2: \"p2 = p2' - {x}\" \n       and origne: \"p1' \\<noteq> p2'\" and ne1: \"p1' \\<noteq> {x}\" and ne2:\"p2' \\<noteq> {x}\" and ing1: \"p1' \\<in> G\" \n       and ing2: \"p2' \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1' p2'.\n        \\<lbrakk>p1 = p1' - {x}; p2 = p2' - {x}; p1' \\<noteq> p2';\n         p1' \\<noteq> {x}; p2' \\<noteq> {x}; p1' \\<in> G;\n         p2' \\<in> G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using p1 p2"], ["proof (prove)\nusing this:\n  p1 \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}}\n  p2 \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}}\n\ngoal (1 subgoal):\n 1. (\\<And>p1' p2'.\n        \\<lbrakk>p1 = p1' - {x}; p2 = p2' - {x}; p1' \\<noteq> p2';\n         p1' \\<noteq> {x}; p2' \\<noteq> {x}; p1' \\<in> G;\n         p2' \\<in> G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mem_Collect_eq ne"], ["proof (prove)\nusing this:\n  p1 \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}}\n  p2 \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}}\n  (?a \\<in> Collect ?P) = ?P ?a\n  p1 \\<noteq> p2\n\ngoal (1 subgoal):\n 1. (\\<And>p1' p2'.\n        \\<lbrakk>p1 = p1' - {x}; p2 = p2' - {x}; p1' \\<noteq> p2';\n         p1' \\<noteq> {x}; p2' \\<noteq> {x}; p1' \\<in> G;\n         p2' \\<in> G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p1 = p1' - {x}\n  p2 = p2' - {x}\n  p1' \\<noteq> p2'\n  p1' \\<noteq> {x}\n  p2' \\<noteq> {x}\n  p1' \\<in> G\n  p2' \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p';\n        \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n        A - {x}\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "then"], ["proof (chain)\npicking this:\n  p1 = p1' - {x}\n  p2 = p2' - {x}\n  p1' \\<noteq> p2'\n  p1' \\<noteq> {x}\n  p2' \\<noteq> {x}\n  p1' \\<in> G\n  p2' \\<in> G", "have \"p1' \\<inter> p2' = {}\""], ["proof (prove)\nusing this:\n  p1 = p1' - {x}\n  p2 = p2' - {x}\n  p1' \\<noteq> p2'\n  p1' \\<noteq> {x}\n  p2' \\<noteq> {x}\n  p1' \\<in> G\n  p2' \\<in> G\n\ngoal (1 subgoal):\n 1. p1' \\<inter> p2' = {}", "using assms partition_onD2 ing1 ing2 origne disjointD"], ["proof (prove)\nusing this:\n  p1 = p1' - {x}\n  p2 = p2' - {x}\n  p1' \\<noteq> p2'\n  p1' \\<noteq> {x}\n  p2' \\<noteq> {x}\n  p1' \\<in> G\n  p2' \\<in> G\n  partition_on A G\n  partition_on ?A ?P \\<Longrightarrow> disjoint ?P\n  p1' \\<in> G\n  p2' \\<in> G\n  p1' \\<noteq> p2'\n  \\<lbrakk>disjoint ?A; ?a \\<in> ?A; ?b \\<in> ?A; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a \\<inter> ?b = {}\n\ngoal (1 subgoal):\n 1. p1' \\<inter> p2' = {}", "by blast"], ["proof (state)\nthis:\n  p1' \\<inter> p2' = {}\n\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n        p \\<noteq> p';\n        \\<Union> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}} =\n        A - {x}\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "thus \"p1 \\<inter> p2 = {}\""], ["proof (prove)\nusing this:\n  p1' \\<inter> p2' = {}\n\ngoal (1 subgoal):\n 1. p1 \\<inter> p2 = {}", "using orig1 orig2"], ["proof (prove)\nusing this:\n  p1' \\<inter> p2' = {}\n  p1 = p1' - {x}\n  p2 = p2' - {x}\n\ngoal (1 subgoal):\n 1. p1 \\<inter> p2 = {}", "by blast"], ["proof (state)\nthis:\n  p1 \\<inter> p2 = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?p \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n   ?p' \\<in> {g - {x} |g. g \\<in> G \\<and> g \\<noteq> {x}};\n   ?p \\<noteq> ?p'\\<rbrakk>\n  \\<Longrightarrow> ?p \\<inter> ?p' = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partition_on_cart_prod:\n  assumes \"card I > 0\"\n  assumes \"A \\<noteq> {}\"\n  assumes \"G \\<noteq> {}\"\n  assumes \"partition_on A G\"\n  shows \"partition_on (A \\<times> I) {g \\<times> I |g. g \\<in> G}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on (A \\<times> I) {g \\<times> I |g. g \\<in> G}", "proof (intro partition_onI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p.\n       p \\<in> {g \\<times> I |g. g \\<in> G} \\<Longrightarrow> p \\<noteq> {}\n 2. \\<Union> {g \\<times> I |g. g \\<in> G} = A \\<times> I\n 3. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g \\<times> I |g. g \\<in> G};\n        p' \\<in> {g \\<times> I |g. g \\<in> G}; p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "show \"\\<And>p. p \\<in> {g \\<times> I |g. g \\<in> G} \\<Longrightarrow> p \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> {g \\<times> I |g. g \\<in> G} \\<Longrightarrow> p \\<noteq> {}", "using assms(1) assms(4) partition_onD3"], ["proof (prove)\nusing this:\n  0 < card I\n  partition_on A G\n  partition_on ?A ?P \\<Longrightarrow> {} \\<notin> ?P\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> {g \\<times> I |g. g \\<in> G} \\<Longrightarrow> p \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  ?p \\<in> {g \\<times> I |g. g \\<in> G} \\<Longrightarrow> ?p \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<Union> {g \\<times> I |g. g \\<in> G} = A \\<times> I\n 2. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g \\<times> I |g. g \\<in> G};\n        p' \\<in> {g \\<times> I |g. g \\<in> G}; p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "show \"\\<Union> {g \\<times> I |g. g \\<in> G} = A \\<times> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {g \\<times> I |g. g \\<in> G} = A \\<times> I", "by (metis Setcompr_eq_image Sigma_Union assms(4) partition_onD1)"], ["proof (state)\nthis:\n  \\<Union> {g \\<times> I |g. g \\<in> G} = A \\<times> I\n\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g \\<times> I |g. g \\<in> G};\n        p' \\<in> {g \\<times> I |g. g \\<in> G}; p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "show \"\\<And>p p'. p \\<in> {g \\<times> I |g. g \\<in> G} \\<Longrightarrow> p' \\<in> {g \\<times> I |g. g \\<in> G} \\<Longrightarrow> p \\<noteq> p' \\<Longrightarrow> p \\<inter> p' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in> {g \\<times> I |g. g \\<in> G};\n        p' \\<in> {g \\<times> I |g. g \\<in> G}; p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "by (smt (verit, best) Sigma_Int_distrib1 Sigma_empty1 assms(4) mem_Collect_eq partition_onE)"], ["proof (state)\nthis:\n  \\<lbrakk>?p \\<in> {g \\<times> I |g. g \\<in> G};\n   ?p' \\<in> {g \\<times> I |g. g \\<in> G}; ?p \\<noteq> ?p'\\<rbrakk>\n  \\<Longrightarrow> ?p \\<inter> ?p' = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Multiset Helpers\\<close>"], ["", "text \\<open>Generic Size, count and card helpers\\<close>"], ["", "lemma count_size_set_repr: \"size {# x \\<in># A . x = g#} = count A g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#x \\<in># A. x = g#} = count A g", "by (simp add: filter_eq_replicate_mset)"], ["", "lemma mset_nempty_set_nempty: \"A \\<noteq> {#} \\<longleftrightarrow> (set_mset A) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<noteq> {#}) = (set_mset A \\<noteq> {})", "by simp"], ["", "lemma mset_size_ne0_set_card: \"size A > 0 \\<Longrightarrow> card (set_mset A) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < size A \\<Longrightarrow> 0 < card (set_mset A)", "using mset_nempty_set_nempty"], ["proof (prove)\nusing this:\n  (?A \\<noteq> {#}) = (set_mset ?A \\<noteq> {})\n\ngoal (1 subgoal):\n 1. 0 < size A \\<Longrightarrow> 0 < card (set_mset A)", "by fastforce"], ["", "lemma set_count_size_min: \"count A a \\<ge> n \\<Longrightarrow> size A \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> count A a \\<Longrightarrow> n \\<le> size A", "by (metis (full_types) count_le_replicate_mset_subset_eq size_mset_mono size_replicate_mset)"], ["", "lemma card_size_filter_eq: \"finite A \\<Longrightarrow>  card {a \\<in> A . P a} = size {#a \\<in># mset_set A . P a#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    card {a \\<in> A. P a} = size (filter_mset P (mset_set A))", "by simp"], ["", "lemma size_multiset_int_count:\n  assumes \"of_nat (card (set_mset A)) = (ca :: int)\"\n  assumes \"\\<And>p. p \\<in># A \\<Longrightarrow> of_nat (count A p) = (ca2 :: int)\"\n  shows \"of_nat (size A) =  ((ca :: int) * ca2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size A) = ca * ca2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (size A) = ca * ca2", "have \"size A = (\\<Sum> p \\<in> (set_mset A) . count A p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size A = sum (count A) (set_mset A)", "using size_multiset_overloaded_eq"], ["proof (prove)\nusing this:\n  size ?x = sum (count ?x) (set_mset ?x)\n\ngoal (1 subgoal):\n 1. size A = sum (count A) (set_mset A)", "by auto"], ["proof (state)\nthis:\n  size A = sum (count A) (set_mset A)\n\ngoal (1 subgoal):\n 1. int (size A) = ca * ca2", "then"], ["proof (chain)\npicking this:\n  size A = sum (count A) (set_mset A)", "have \"of_nat (size A) = (\\<Sum> p \\<in> (set_mset A) . ca2)\""], ["proof (prove)\nusing this:\n  size A = sum (count A) (set_mset A)\n\ngoal (1 subgoal):\n 1. int (size A) = (\\<Sum>p\\<in>set_mset A. ca2)", "using assms"], ["proof (prove)\nusing this:\n  size A = sum (count A) (set_mset A)\n  int (card (set_mset A)) = ca\n  ?p \\<in># A \\<Longrightarrow> int (count A ?p) = ca2\n\ngoal (1 subgoal):\n 1. int (size A) = (\\<Sum>p\\<in>set_mset A. ca2)", "by simp"], ["proof (state)\nthis:\n  int (size A) = (\\<Sum>p\\<in>set_mset A. ca2)\n\ngoal (1 subgoal):\n 1. int (size A) = ca * ca2", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (size A) = (\\<Sum>p\\<in>set_mset A. ca2)\n\ngoal (1 subgoal):\n 1. int (size A) = ca * ca2", "using assms(1)"], ["proof (prove)\nusing this:\n  int (size A) = (\\<Sum>p\\<in>set_mset A. ca2)\n  int (card (set_mset A)) = ca\n\ngoal (1 subgoal):\n 1. int (size A) = ca * ca2", "by auto"], ["proof (state)\nthis:\n  int (size A) = ca * ca2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_union_size: \"size (A \\<union># B) = size (A) + size (B - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (A \\<union># B) = size A + size (B - A)", "by (simp add: sup_subset_mset_def)"], ["", "lemma mset_union_size_inter: \"size (A \\<union># B) = size (A) + size B - size (A \\<inter># B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (A \\<union># B) = size A + size B - size (A \\<inter># B)", "by (metis diff_add_inverse2 size_Un_Int)"], ["", "text \\<open>Lemmas for repeat\\_mset\\<close>"], ["", "lemma repeat_mset_size [simp]: \"size (repeat_mset n A) = n * size A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (repeat_mset n A) = n * size A", "by (induction n) auto"], ["", "lemma repeat_mset_subset_in:\n  assumes \"\\<And> a . a \\<in># A \\<Longrightarrow> a \\<subseteq> B\"\n  assumes \"X \\<in># repeat_mset n A\"\n  assumes \"x \\<in> X\"\n  shows \" x \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> B", "using assms"], ["proof (prove)\nusing this:\n  ?a \\<in># A \\<Longrightarrow> ?a \\<subseteq> B\n  X \\<in># repeat_mset n A\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> B", "by (induction n) auto"], ["", "lemma repeat_mset_not_empty: \"n > 0 \\<Longrightarrow> A \\<noteq> {#} \\<Longrightarrow> repeat_mset n A \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; A \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> repeat_mset n A \\<noteq> {#}", "by (induction n) auto"], ["", "lemma elem_in_repeat_in_original: \"a \\<in># repeat_mset n A \\<Longrightarrow> a \\<in># A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in># repeat_mset n A \\<Longrightarrow> a \\<in># A", "by (metis count_inI count_repeat_mset in_countE mult.commute mult_zero_left nat.distinct(1))"], ["", "lemma elem_in_original_in_repeat: \"n > 0 \\<Longrightarrow> a \\<in># A \\<Longrightarrow> a \\<in># repeat_mset n A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; a \\<in># A\\<rbrakk>\n    \\<Longrightarrow> a \\<in># repeat_mset n A", "by (metis (full_types) Suc_pred repeat_mset.simps(2) union_iff)"], ["", "text \\<open>Lemmas on image and filter for multisets\\<close>"], ["", "lemma multiset_add_filter_size: \"size {# a \\<in># (A1 + A2) . P a #} = size {# a \\<in># A1 . P a #} + \n    size {# a \\<in># A2 . P a #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (filter_mset P (A1 + A2)) =\n    size (filter_mset P A1) + size (filter_mset P A2)", "by simp"], ["", "lemma size_filter_neg: \"size {#a \\<in># A . P a #} = size A - size {# a \\<in># A . \\<not> P a #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (filter_mset P A) = size A - size {#a \\<in># A. \\<not> P a#}", "using size_filter_mset_lesseq size_union union_filter_mset_complement"], ["proof (prove)\nusing this:\n  size (filter_mset ?f ?M) \\<le> size ?M\n  size (?M + ?N) = size ?M + size ?N\n  \\<forall>x. ?P x = (\\<not> ?Q x) \\<Longrightarrow>\n  filter_mset ?P ?M + filter_mset ?Q ?M = ?M\n\ngoal (1 subgoal):\n 1. size (filter_mset P A) = size A - size {#a \\<in># A. \\<not> P a#}", "by (metis ordered_cancel_comm_monoid_diff_class.le_imp_diff_is_add)"], ["", "lemma filter_filter_mset_cond_simp: \n  assumes \"\\<And> a . P a \\<Longrightarrow> Q a\"\n  shows \"filter_mset P A = filter_mset P (filter_mset Q A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P A = filter_mset P (filter_mset Q A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_mset P A = filter_mset P (filter_mset Q A)", "have \"filter_mset P (filter_mset Q A) = filter_mset (\\<lambda> a. Q a \\<and> P a) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P (filter_mset Q A) = {#a \\<in># A. Q a \\<and> P a#}", "by (simp add: filter_filter_mset)"], ["proof (state)\nthis:\n  filter_mset P (filter_mset Q A) = {#a \\<in># A. Q a \\<and> P a#}\n\ngoal (1 subgoal):\n 1. filter_mset P A = filter_mset P (filter_mset Q A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  filter_mset P (filter_mset Q A) = {#a \\<in># A. Q a \\<and> P a#}\n\ngoal (1 subgoal):\n 1. filter_mset P A = filter_mset P (filter_mset Q A)", "using assms"], ["proof (prove)\nusing this:\n  filter_mset P (filter_mset Q A) = {#a \\<in># A. Q a \\<and> P a#}\n  P ?a \\<Longrightarrow> Q ?a\n\ngoal (1 subgoal):\n 1. filter_mset P A = filter_mset P (filter_mset Q A)", "by (metis (mono_tags, lifting) filter_mset_cong)"], ["proof (state)\nthis:\n  filter_mset P A = filter_mset P (filter_mset Q A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_filter_mset_ss_member: \"filter_mset (\\<lambda> a . {x, y} \\<subseteq> a) A = \n  filter_mset (\\<lambda> a . {x, y} \\<subseteq> a) (filter_mset (\\<lambda> a . x \\<in> a) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) {x, y}) A =\n    filter_mset ((\\<subseteq>) {x, y}) (filter_mset ((\\<in>) x) A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) {x, y}) A =\n    filter_mset ((\\<subseteq>) {x, y}) (filter_mset ((\\<in>) x) A)", "have filter: \"filter_mset (\\<lambda> a . {x, y} \\<subseteq> a) (filter_mset (\\<lambda> a . x \\<in> a) A) = \n    filter_mset (\\<lambda> a . x \\<in> a \\<and> {x, y} \\<subseteq> a) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) {x, y}) (filter_mset ((\\<in>) x) A) =\n    {#a \\<in># A. x \\<in> a \\<and> {x, y} \\<subseteq> a#}", "by (simp add: filter_filter_mset)"], ["proof (state)\nthis:\n  filter_mset ((\\<subseteq>) {x, y}) (filter_mset ((\\<in>) x) A) =\n  {#a \\<in># A. x \\<in> a \\<and> {x, y} \\<subseteq> a#}\n\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) {x, y}) A =\n    filter_mset ((\\<subseteq>) {x, y}) (filter_mset ((\\<in>) x) A)", "have \"\\<And> a. {x, y} \\<subseteq> a \\<Longrightarrow> x \\<in> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. {x, y} \\<subseteq> a \\<Longrightarrow> x \\<in> a", "by simp"], ["proof (state)\nthis:\n  {x, y} \\<subseteq> ?a \\<Longrightarrow> x \\<in> ?a\n\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) {x, y}) A =\n    filter_mset ((\\<subseteq>) {x, y}) (filter_mset ((\\<in>) x) A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> ?a \\<Longrightarrow> x \\<in> ?a\n\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) {x, y}) A =\n    filter_mset ((\\<subseteq>) {x, y}) (filter_mset ((\\<in>) x) A)", "using filter"], ["proof (prove)\nusing this:\n  {x, y} \\<subseteq> ?a \\<Longrightarrow> x \\<in> ?a\n  filter_mset ((\\<subseteq>) {x, y}) (filter_mset ((\\<in>) x) A) =\n  {#a \\<in># A. x \\<in> a \\<and> {x, y} \\<subseteq> a#}\n\ngoal (1 subgoal):\n 1. filter_mset ((\\<subseteq>) {x, y}) A =\n    filter_mset ((\\<subseteq>) {x, y}) (filter_mset ((\\<in>) x) A)", "by auto"], ["proof (state)\nthis:\n  filter_mset ((\\<subseteq>) {x, y}) A =\n  filter_mset ((\\<subseteq>) {x, y}) (filter_mset ((\\<in>) x) A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multiset_image_do_nothing: \"(\\<And> x .x \\<in># A \\<Longrightarrow> f x = x) \\<Longrightarrow> image_mset f A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in># A \\<Longrightarrow> f x = x) \\<Longrightarrow>\n    image_mset f A = A", "by (induct A) auto"], ["", "lemma set_mset_filter: \"set_mset {# f a . a \\<in># A #} = {f a | a. a \\<in># A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (image_mset f A) = {f a |a. a \\<in># A}", "by (simp add: Setcompr_eq_image)"], ["", "lemma mset_exists_imply: \"x \\<in># {# f a . a \\<in># A #} \\<Longrightarrow> \\<exists> y \\<in># A . x = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in># image_mset f A \\<Longrightarrow> \\<exists>y\\<in>#A. x = f y", "by auto"], ["", "lemma filter_mset_image_mset:\n  \"filter_mset P (image_mset f A) = image_mset f (filter_mset (\\<lambda>x. P (f x)) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P (image_mset f A) = image_mset f {#x \\<in># A. P (f x)#}", "by (induction A) auto"], ["", "lemma mset_bunion_filter: \"{# a \\<in># A . P a \\<or> Q a #} = {# a \\<in># A . P a #} \\<union># {# a \\<in># A . Q a #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#a \\<in># A. P a \\<or> Q a#} =\n    filter_mset P A \\<union># filter_mset Q A", "by (rule multiset_eqI) simp"], ["", "lemma mset_inter_filter: \"{# a \\<in># A . P a \\<and> Q a #} = {# a \\<in># A . P a #} \\<inter># {# a \\<in># A . Q a #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#a \\<in># A. P a \\<and> Q a#} =\n    filter_mset P A \\<inter># filter_mset Q A", "by (rule multiset_eqI) simp"], ["", "lemma image_image_mset: \"image_mset (\\<lambda> x . f x) (image_mset (\\<lambda> y . g y) A) = \n    image_mset (\\<lambda> x. f (g x)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset f (image_mset g A) = {#f (g x). x \\<in># A#}", "by simp"], ["", "text \\<open>Big Union over multiset helpers\\<close>"], ["", "lemma mset_big_union_obtain: \n  assumes \"x \\<in># \\<Sum>\\<^sub># A\"\n  obtains a where \"a \\<in># A\" and \"x \\<in># a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in># A; x \\<in># a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in># \\<Sum>\\<^sub># A\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in># A; x \\<in># a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma size_big_union_sum: \"size (\\<Sum>\\<^sub># (M :: 'a multiset multiset)) = (\\<Sum>x \\<in>#M . size x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (\\<Sum>\\<^sub># M) = \\<Sum>\\<^sub># (image_mset size M)", "by (induct M) auto"], ["", "text \\<open>Cartesian Product on Multisets\\<close>"], ["", "lemma size_cartesian_product_singleton [simp]: \"size ({#a#} \\<times># B) = size B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size ({#a#} \\<times># B) = size B", "by (simp add: Times_mset_single_left)"], ["", "lemma size_cartesian_product_singleton_right [simp]: \"size (A \\<times># {#b#}) = size A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (A \\<times># {#b#}) = size A", "by (simp add: Times_mset_single_right)"], ["", "lemma size_cartesian_product_empty [simp]: \"size (A \\<times># {#}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (A \\<times># {#}) = 0", "by simp"], ["", "lemma size_add_elem_step_eq: \n  assumes \"size (A \\<times># B) = size A * size B\" \n  shows \"size (add_mset x A \\<times># B) = size (add_mset x A) * size B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (add_mset x A \\<times># B) = size (add_mset x A) * size B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. size (add_mset x A \\<times># B) = size (add_mset x A) * size B", "have \"(add_mset x A \\<times># B) = A \\<times># B + {#x#} \\<times># B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset x A \\<times># B = A \\<times># B + {#x#} \\<times># B", "by (metis Sigma_mset_plus_distrib1 add_mset_add_single)"], ["proof (state)\nthis:\n  add_mset x A \\<times># B = A \\<times># B + {#x#} \\<times># B\n\ngoal (1 subgoal):\n 1. size (add_mset x A \\<times># B) = size (add_mset x A) * size B", "then"], ["proof (chain)\npicking this:\n  add_mset x A \\<times># B = A \\<times># B + {#x#} \\<times># B", "have \"size (add_mset x A \\<times># B) = size (A \\<times># B) + size B\""], ["proof (prove)\nusing this:\n  add_mset x A \\<times># B = A \\<times># B + {#x#} \\<times># B\n\ngoal (1 subgoal):\n 1. size (add_mset x A \\<times># B) = size (A \\<times># B) + size B", "by auto"], ["proof (state)\nthis:\n  size (add_mset x A \\<times># B) = size (A \\<times># B) + size B\n\ngoal (1 subgoal):\n 1. size (add_mset x A \\<times># B) = size (add_mset x A) * size B", "also"], ["proof (state)\nthis:\n  size (add_mset x A \\<times># B) = size (A \\<times># B) + size B\n\ngoal (1 subgoal):\n 1. size (add_mset x A \\<times># B) = size (add_mset x A) * size B", "have \"... = size A * size B + size B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (A \\<times># B) + size B = size A * size B + size B", "by (simp add: assms)"], ["proof (state)\nthis:\n  size (A \\<times># B) + size B = size A * size B + size B\n\ngoal (1 subgoal):\n 1. size (add_mset x A \\<times># B) = size (add_mset x A) * size B", "finally"], ["proof (chain)\npicking this:\n  size (add_mset x A \\<times># B) = size A * size B + size B", "have \"size (add_mset x A \\<times># B) = (size A + 1) * size B\""], ["proof (prove)\nusing this:\n  size (add_mset x A \\<times># B) = size A * size B + size B\n\ngoal (1 subgoal):\n 1. size (add_mset x A \\<times># B) = (size A + 1) * size B", "by auto"], ["proof (state)\nthis:\n  size (add_mset x A \\<times># B) = (size A + 1) * size B\n\ngoal (1 subgoal):\n 1. size (add_mset x A \\<times># B) = size (add_mset x A) * size B", "thus ?thesis"], ["proof (prove)\nusing this:\n  size (add_mset x A \\<times># B) = (size A + 1) * size B\n\ngoal (1 subgoal):\n 1. size (add_mset x A \\<times># B) = size (add_mset x A) * size B", "by simp"], ["proof (state)\nthis:\n  size (add_mset x A \\<times># B) = size (add_mset x A) * size B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma size_cartesian_product: \"size (A \\<times># B) = size A * size B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (A \\<times># B) = size A * size B", "by (induct A) (simp_all add: size_add_elem_step_eq)"], ["", "lemma cart_prod_distinct_mset:\n  assumes assm1: \"distinct_mset A\"\n  assumes assm2: \"distinct_mset B\"\n  shows \"distinct_mset (A \\<times># B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset (A \\<times># B)", "unfolding distinct_mset_count_less_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. count (A \\<times># B) a \\<le> 1", "proof (rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. count (A \\<times># B) a \\<le> 1", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. count (A \\<times># B) a \\<le> 1", "have count_mult: \"count (A \\<times># B) x = count A (fst x) * count B (snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (A \\<times># B) x = count A (fst x) * count B (snd x)", "using count_Sigma_mset"], ["proof (prove)\nusing this:\n  count (Sigma_mset ?A ?B) (?a, ?b) = count ?A ?a * count (?B ?a) ?b\n\ngoal (1 subgoal):\n 1. count (A \\<times># B) x = count A (fst x) * count B (snd x)", "by (metis prod.exhaust_sel)"], ["proof (state)\nthis:\n  count (A \\<times># B) x = count A (fst x) * count B (snd x)\n\ngoal (1 subgoal):\n 1. \\<And>a. count (A \\<times># B) a \\<le> 1", "then"], ["proof (chain)\npicking this:\n  count (A \\<times># B) x = count A (fst x) * count B (snd x)", "have \"count A (fst x) * count B (snd x) \\<le> 1\""], ["proof (prove)\nusing this:\n  count (A \\<times># B) x = count A (fst x) * count B (snd x)\n\ngoal (1 subgoal):\n 1. count A (fst x) * count B (snd x) \\<le> 1", "using assm1 assm2"], ["proof (prove)\nusing this:\n  count (A \\<times># B) x = count A (fst x) * count B (snd x)\n  distinct_mset A\n  distinct_mset B\n\ngoal (1 subgoal):\n 1. count A (fst x) * count B (snd x) \\<le> 1", "unfolding distinct_mset_count_less_1"], ["proof (prove)\nusing this:\n  count (A \\<times># B) x = count A (fst x) * count B (snd x)\n  \\<forall>a. count A a \\<le> 1\n  \\<forall>a. count B a \\<le> 1\n\ngoal (1 subgoal):\n 1. count A (fst x) * count B (snd x) \\<le> 1", "using mult_le_one"], ["proof (prove)\nusing this:\n  count (A \\<times># B) x = count A (fst x) * count B (snd x)\n  \\<forall>a. count A a \\<le> 1\n  \\<forall>a. count B a \\<le> 1\n  \\<lbrakk>?a \\<le> (1::?'a); (0::?'a) \\<le> ?b; ?b \\<le> (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?a * ?b \\<le> (1::?'a)\n\ngoal (1 subgoal):\n 1. count A (fst x) * count B (snd x) \\<le> 1", "by blast"], ["proof (state)\nthis:\n  count A (fst x) * count B (snd x) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>a. count (A \\<times># B) a \\<le> 1", "thus \"count (A \\<times># B) x \\<le> 1\""], ["proof (prove)\nusing this:\n  count A (fst x) * count B (snd x) \\<le> 1\n\ngoal (1 subgoal):\n 1. count (A \\<times># B) x \\<le> 1", "using count_mult"], ["proof (prove)\nusing this:\n  count A (fst x) * count B (snd x) \\<le> 1\n  count (A \\<times># B) x = count A (fst x) * count B (snd x)\n\ngoal (1 subgoal):\n 1. count (A \\<times># B) x \\<le> 1", "by simp"], ["proof (state)\nthis:\n  count (A \\<times># B) x \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart_product_single_intersect: \"x1 \\<noteq> x2 \\<Longrightarrow> ({#x1#} \\<times># A) \\<inter># ({#x2#} \\<times># B) = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq> x2 \\<Longrightarrow>\n    {#x1#} \\<times># A \\<inter># {#x2#} \\<times># B = {#}", "using multiset_inter_single"], ["proof (prove)\nusing this:\n  ?a \\<noteq> ?b \\<Longrightarrow> {#?a#} \\<inter># {#?b#} = {#}\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> x2 \\<Longrightarrow>\n    {#x1#} \\<times># A \\<inter># {#x2#} \\<times># B = {#}", "by fastforce"], ["", "lemma size_union_distinct_cart_prod: \"x1 \\<noteq> x2 \\<Longrightarrow> size (({#x1#} \\<times># A) \\<union># ({#x2#} \\<times># B)) = \n    size ({#x1#} \\<times># A) + size ({#x2#} \\<times># B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq> x2 \\<Longrightarrow>\n    size ({#x1#} \\<times># A \\<union># {#x2#} \\<times># B) =\n    size ({#x1#} \\<times># A) + size ({#x2#} \\<times># B)", "by (simp add: cart_product_single_intersect size_Un_disjoint)"], ["", "lemma size_Union_distinct_cart_prod: \"distinct_mset M \\<Longrightarrow> \n    size (\\<Sum>p\\<in>#M. ({#p#} \\<times># B)) = size (M) * size (B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset M \\<Longrightarrow>\n    size (\\<Sum>p\\<in>#M. {#p#} \\<times># B) = size M * size B", "by (induction M) auto"], ["", "lemma size_Union_distinct_cart_prod_filter: \"distinct_mset M \\<Longrightarrow> \n    (\\<And> p . p \\<in># M \\<Longrightarrow> size ({# b \\<in># B . P p b #}) = c) \\<Longrightarrow> \n    size (\\<Sum>p\\<in>#M. ({#p#} \\<times># {# b \\<in># B . P p b #})) = size (M) * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct_mset M;\n     \\<And>p.\n        p \\<in># M \\<Longrightarrow> size (filter_mset (P p) B) = c\\<rbrakk>\n    \\<Longrightarrow> size\n                       (\\<Sum>p\\<in>#M. {#p#} \\<times>#\n  filter_mset (P p) B) =\n                      size M * c", "by (induction M) auto"], ["", "lemma size_Union_distinct_cart_prod_filter2: \"distinct_mset V \\<Longrightarrow> \n    (\\<And> b . b \\<in># B \\<Longrightarrow> size ({# v \\<in># V . P v b #}) = c) \\<Longrightarrow> \n    size (\\<Sum>b\\<in>#B. ( {# v \\<in># V . P v b #} \\<times># {#b#})) = size (B) * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct_mset V;\n     \\<And>b.\n        b \\<in># B \\<Longrightarrow> size {#v \\<in># V. P v b#} = c\\<rbrakk>\n    \\<Longrightarrow> size\n                       (\\<Sum>b\\<in>#B. {#v \\<in># V. P v b#} \\<times>#\n  {#b#}) =\n                      size B * c", "by (induction B) auto"], ["", "lemma cart_product_add_1: \"(add_mset a A) \\<times># B = ({#a#} \\<times># B) + (A \\<times># B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset a A \\<times># B = {#a#} \\<times># B + A \\<times># B", "by (metis Sigma_mset_plus_distrib1 add_mset_add_single union_commute)"], ["", "lemma cart_product_add_1_filter: \"{#m \\<in># ((add_mset a M) \\<times># N) . P m #} = \n    {#m \\<in># (M \\<times># N) . P m #} + {#m \\<in># ({#a#} \\<times>#  N) . P m #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P (add_mset a M \\<times># N) =\n    filter_mset P (M \\<times># N) + filter_mset P ({#a#} \\<times># N)", "unfolding add_mset_add_single [of a M] Sigma_mset_plus_distrib1"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P (M \\<times># N + {#a#} \\<times># N) =\n    filter_mset P (M \\<times># N) + filter_mset P ({#a#} \\<times># N)", "by (simp add: Times_mset_single_left)"], ["", "lemma cart_product_add_1_filter2: \"{#m \\<in># (M \\<times># (add_mset b N)) . P m #} = \n    {#m \\<in># (M \\<times># N) . P m #} + {#m \\<in># (M \\<times>#  {#b#}) . P m #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P (M \\<times># add_mset b N) =\n    filter_mset P (M \\<times># N) + filter_mset P (M \\<times># {#b#})", "unfolding add_mset_add_single [of b N] Sigma_mset_plus_distrib1"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P (M \\<times># (N + {#b#})) =\n    filter_mset P (M \\<times># N) + filter_mset P (M \\<times># {#b#})", "by (metis Times_insert_left Times_mset_single_right add_mset_add_single filter_union_mset)"], ["", "lemma cart_prod_singleton_right_gen: \n  assumes \"\\<And> x . x \\<in># (A \\<times># {#b#}) \\<Longrightarrow> P x \\<longleftrightarrow> Q (fst x)\"\n  shows \"{#x \\<in># (A \\<times># {#b#}). P x#} = {# a \\<in># A . Q a#} \\<times># {#b#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P (A \\<times># {#b#}) = filter_mset Q A \\<times># {#b#}", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in># A \\<times># {#b#} \\<Longrightarrow> P ?x = Q (fst ?x)\n\ngoal (1 subgoal):\n 1. filter_mset P (A \\<times># {#b#}) = filter_mset Q A \\<times># {#b#}", "proof (induction A)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in># {#} \\<times># {#b#} \\<Longrightarrow>\n        P x = Q (fst x)) \\<Longrightarrow>\n    filter_mset P ({#} \\<times># {#b#}) = filter_mset Q {#} \\<times># {#b#}\n 2. \\<And>x A.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># A \\<times># {#b#} \\<Longrightarrow>\n                    P x = Q (fst x)) \\<Longrightarrow>\n                filter_mset P (A \\<times># {#b#}) =\n                filter_mset Q A \\<times># {#b#};\n        \\<And>xa.\n           xa \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow>\n           P xa = Q (fst xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P (add_mset x A \\<times># {#b#}) =\n                         filter_mset Q (add_mset x A) \\<times># {#b#}", "case empty"], ["proof (state)\nthis:\n  ?x \\<in># {#} \\<times># {#b#} \\<Longrightarrow> P ?x = Q (fst ?x)\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in># {#} \\<times># {#b#} \\<Longrightarrow>\n        P x = Q (fst x)) \\<Longrightarrow>\n    filter_mset P ({#} \\<times># {#b#}) = filter_mset Q {#} \\<times># {#b#}\n 2. \\<And>x A.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># A \\<times># {#b#} \\<Longrightarrow>\n                    P x = Q (fst x)) \\<Longrightarrow>\n                filter_mset P (A \\<times># {#b#}) =\n                filter_mset Q A \\<times># {#b#};\n        \\<And>xa.\n           xa \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow>\n           P xa = Q (fst xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P (add_mset x A \\<times># {#b#}) =\n                         filter_mset Q (add_mset x A) \\<times># {#b#}", "then"], ["proof (chain)\npicking this:\n  ?x \\<in># {#} \\<times># {#b#} \\<Longrightarrow> P ?x = Q (fst ?x)", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in># {#} \\<times># {#b#} \\<Longrightarrow> P ?x = Q (fst ?x)\n\ngoal (1 subgoal):\n 1. filter_mset P ({#} \\<times># {#b#}) = filter_mset Q {#} \\<times># {#b#}", "by simp"], ["proof (state)\nthis:\n  filter_mset P ({#} \\<times># {#b#}) = filter_mset Q {#} \\<times># {#b#}\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># A \\<times># {#b#} \\<Longrightarrow>\n                    P x = Q (fst x)) \\<Longrightarrow>\n                filter_mset P (A \\<times># {#b#}) =\n                filter_mset Q A \\<times># {#b#};\n        \\<And>xa.\n           xa \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow>\n           P xa = Q (fst xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P (add_mset x A \\<times># {#b#}) =\n                         filter_mset Q (add_mset x A) \\<times># {#b#}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># A \\<times># {#b#} \\<Longrightarrow>\n                    P x = Q (fst x)) \\<Longrightarrow>\n                filter_mset P (A \\<times># {#b#}) =\n                filter_mset Q A \\<times># {#b#};\n        \\<And>xa.\n           xa \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow>\n           P xa = Q (fst xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P (add_mset x A \\<times># {#b#}) =\n                         filter_mset Q (add_mset x A) \\<times># {#b#}", "case (add x A)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in># A \\<times># {#b#} \\<Longrightarrow>\n      P x = Q (fst x)) \\<Longrightarrow>\n  filter_mset P (A \\<times># {#b#}) = filter_mset Q A \\<times># {#b#}\n  ?x \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow> P ?x = Q (fst ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># A \\<times># {#b#} \\<Longrightarrow>\n                    P x = Q (fst x)) \\<Longrightarrow>\n                filter_mset P (A \\<times># {#b#}) =\n                filter_mset Q A \\<times># {#b#};\n        \\<And>xa.\n           xa \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow>\n           P xa = Q (fst xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P (add_mset x A \\<times># {#b#}) =\n                         filter_mset Q (add_mset x A) \\<times># {#b#}", "have \"add_mset x A \\<times># {#b#} = add_mset (x, b) (A \\<times># {#b#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset x A \\<times># {#b#} = add_mset (x, b) (A \\<times># {#b#})", "by (simp add: Times_mset_single_right)"], ["proof (state)\nthis:\n  add_mset x A \\<times># {#b#} = add_mset (x, b) (A \\<times># {#b#})\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># A \\<times># {#b#} \\<Longrightarrow>\n                    P x = Q (fst x)) \\<Longrightarrow>\n                filter_mset P (A \\<times># {#b#}) =\n                filter_mset Q A \\<times># {#b#};\n        \\<And>xa.\n           xa \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow>\n           P xa = Q (fst xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P (add_mset x A \\<times># {#b#}) =\n                         filter_mset Q (add_mset x A) \\<times># {#b#}", "then"], ["proof (chain)\npicking this:\n  add_mset x A \\<times># {#b#} = add_mset (x, b) (A \\<times># {#b#})", "have lhs: \"filter_mset P (add_mset x A \\<times># {#b#}) = filter_mset P (A \\<times># {#b#}) + \n    filter_mset P {#(x, b)#}\""], ["proof (prove)\nusing this:\n  add_mset x A \\<times># {#b#} = add_mset (x, b) (A \\<times># {#b#})\n\ngoal (1 subgoal):\n 1. filter_mset P (add_mset x A \\<times># {#b#}) =\n    filter_mset P (A \\<times># {#b#}) + filter_mset P {#(x, b)#}", "by simp"], ["proof (state)\nthis:\n  filter_mset P (add_mset x A \\<times># {#b#}) =\n  filter_mset P (A \\<times># {#b#}) + filter_mset P {#(x, b)#}\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># A \\<times># {#b#} \\<Longrightarrow>\n                    P x = Q (fst x)) \\<Longrightarrow>\n                filter_mset P (A \\<times># {#b#}) =\n                filter_mset Q A \\<times># {#b#};\n        \\<And>xa.\n           xa \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow>\n           P xa = Q (fst xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P (add_mset x A \\<times># {#b#}) =\n                         filter_mset Q (add_mset x A) \\<times># {#b#}", "have rhs: \"filter_mset Q (add_mset x A) \\<times># {#b#} = filter_mset Q A \\<times># {#b#} + \n    filter_mset Q {#x#} \\<times># {#b#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset Q (add_mset x A) \\<times># {#b#} =\n    filter_mset Q A \\<times># {#b#} + filter_mset Q {#x#} \\<times># {#b#}", "by (metis Sigma_mset_plus_distrib1 add_mset_add_single filter_union_mset)"], ["proof (state)\nthis:\n  filter_mset Q (add_mset x A) \\<times># {#b#} =\n  filter_mset Q A \\<times># {#b#} + filter_mset Q {#x#} \\<times># {#b#}\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># A \\<times># {#b#} \\<Longrightarrow>\n                    P x = Q (fst x)) \\<Longrightarrow>\n                filter_mset P (A \\<times># {#b#}) =\n                filter_mset Q A \\<times># {#b#};\n        \\<And>xa.\n           xa \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow>\n           P xa = Q (fst xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P (add_mset x A \\<times># {#b#}) =\n                         filter_mset Q (add_mset x A) \\<times># {#b#}", "have \"filter_mset P {#(x, b)#} = filter_mset Q {#x#} \\<times># {#b#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P {#(x, b)#} = filter_mset Q {#x#} \\<times># {#b#}", "using add.prems"], ["proof (prove)\nusing this:\n  ?x \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow> P ?x = Q (fst ?x)\n\ngoal (1 subgoal):\n 1. filter_mset P {#(x, b)#} = filter_mset Q {#x#} \\<times># {#b#}", "by fastforce"], ["proof (state)\nthis:\n  filter_mset P {#(x, b)#} = filter_mset Q {#x#} \\<times># {#b#}\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># A \\<times># {#b#} \\<Longrightarrow>\n                    P x = Q (fst x)) \\<Longrightarrow>\n                filter_mset P (A \\<times># {#b#}) =\n                filter_mset Q A \\<times># {#b#};\n        \\<And>xa.\n           xa \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow>\n           P xa = Q (fst xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P (add_mset x A \\<times># {#b#}) =\n                         filter_mset Q (add_mset x A) \\<times># {#b#}", "then"], ["proof (chain)\npicking this:\n  filter_mset P {#(x, b)#} = filter_mset Q {#x#} \\<times># {#b#}", "show ?case"], ["proof (prove)\nusing this:\n  filter_mset P {#(x, b)#} = filter_mset Q {#x#} \\<times># {#b#}\n\ngoal (1 subgoal):\n 1. filter_mset P (add_mset x A \\<times># {#b#}) =\n    filter_mset Q (add_mset x A) \\<times># {#b#}", "using lhs rhs add.IH add.prems"], ["proof (prove)\nusing this:\n  filter_mset P {#(x, b)#} = filter_mset Q {#x#} \\<times># {#b#}\n  filter_mset P (add_mset x A \\<times># {#b#}) =\n  filter_mset P (A \\<times># {#b#}) + filter_mset P {#(x, b)#}\n  filter_mset Q (add_mset x A) \\<times># {#b#} =\n  filter_mset Q A \\<times># {#b#} + filter_mset Q {#x#} \\<times># {#b#}\n  (\\<And>x.\n      x \\<in># A \\<times># {#b#} \\<Longrightarrow>\n      P x = Q (fst x)) \\<Longrightarrow>\n  filter_mset P (A \\<times># {#b#}) = filter_mset Q A \\<times># {#b#}\n  ?x \\<in># add_mset x A \\<times># {#b#} \\<Longrightarrow> P ?x = Q (fst ?x)\n\ngoal (1 subgoal):\n 1. filter_mset P (add_mset x A \\<times># {#b#}) =\n    filter_mset Q (add_mset x A) \\<times># {#b#}", "by force"], ["proof (state)\nthis:\n  filter_mset P (add_mset x A \\<times># {#b#}) =\n  filter_mset Q (add_mset x A) \\<times># {#b#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart_prod_singleton_left_gen: \n  assumes \"\\<And> x . x \\<in># ({#a#} \\<times># B) \\<Longrightarrow> P x \\<longleftrightarrow> Q (snd x)\"\n  shows \"{#x \\<in># ({#a#} \\<times># B). P x#} = {#a#} \\<times># {#b \\<in># B . Q b#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P ({#a#} \\<times># B) = {#a#} \\<times># filter_mset Q B", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in># {#a#} \\<times># B \\<Longrightarrow> P ?x = Q (snd ?x)\n\ngoal (1 subgoal):\n 1. filter_mset P ({#a#} \\<times># B) = {#a#} \\<times># filter_mset Q B", "proof (induction B)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in># {#a#} \\<times># {#} \\<Longrightarrow>\n        P x = Q (snd x)) \\<Longrightarrow>\n    filter_mset P ({#a#} \\<times># {#}) = {#a#} \\<times># filter_mset Q {#}\n 2. \\<And>x B.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># {#a#} \\<times># B \\<Longrightarrow>\n                    P x = Q (snd x)) \\<Longrightarrow>\n                filter_mset P ({#a#} \\<times># B) =\n                {#a#} \\<times># filter_mset Q B;\n        \\<And>xa.\n           xa \\<in># {#a#} \\<times># add_mset x B \\<Longrightarrow>\n           P xa = Q (snd xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P ({#a#} \\<times># add_mset x B) =\n                         {#a#} \\<times># filter_mset Q (add_mset x B)", "case empty"], ["proof (state)\nthis:\n  ?x \\<in># {#a#} \\<times># {#} \\<Longrightarrow> P ?x = Q (snd ?x)\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in># {#a#} \\<times># {#} \\<Longrightarrow>\n        P x = Q (snd x)) \\<Longrightarrow>\n    filter_mset P ({#a#} \\<times># {#}) = {#a#} \\<times># filter_mset Q {#}\n 2. \\<And>x B.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># {#a#} \\<times># B \\<Longrightarrow>\n                    P x = Q (snd x)) \\<Longrightarrow>\n                filter_mset P ({#a#} \\<times># B) =\n                {#a#} \\<times># filter_mset Q B;\n        \\<And>xa.\n           xa \\<in># {#a#} \\<times># add_mset x B \\<Longrightarrow>\n           P xa = Q (snd xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P ({#a#} \\<times># add_mset x B) =\n                         {#a#} \\<times># filter_mset Q (add_mset x B)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in># {#a#} \\<times># {#} \\<Longrightarrow> P ?x = Q (snd ?x)", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in># {#a#} \\<times># {#} \\<Longrightarrow> P ?x = Q (snd ?x)\n\ngoal (1 subgoal):\n 1. filter_mset P ({#a#} \\<times># {#}) = {#a#} \\<times># filter_mset Q {#}", "by simp"], ["proof (state)\nthis:\n  filter_mset P ({#a#} \\<times># {#}) = {#a#} \\<times># filter_mset Q {#}\n\ngoal (1 subgoal):\n 1. \\<And>x B.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># {#a#} \\<times># B \\<Longrightarrow>\n                    P x = Q (snd x)) \\<Longrightarrow>\n                filter_mset P ({#a#} \\<times># B) =\n                {#a#} \\<times># filter_mset Q B;\n        \\<And>xa.\n           xa \\<in># {#a#} \\<times># add_mset x B \\<Longrightarrow>\n           P xa = Q (snd xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P ({#a#} \\<times># add_mset x B) =\n                         {#a#} \\<times># filter_mset Q (add_mset x B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x B.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># {#a#} \\<times># B \\<Longrightarrow>\n                    P x = Q (snd x)) \\<Longrightarrow>\n                filter_mset P ({#a#} \\<times># B) =\n                {#a#} \\<times># filter_mset Q B;\n        \\<And>xa.\n           xa \\<in># {#a#} \\<times># add_mset x B \\<Longrightarrow>\n           P xa = Q (snd xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P ({#a#} \\<times># add_mset x B) =\n                         {#a#} \\<times># filter_mset Q (add_mset x B)", "case (add x B)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in># {#a#} \\<times># B \\<Longrightarrow>\n      P x = Q (snd x)) \\<Longrightarrow>\n  filter_mset P ({#a#} \\<times># B) = {#a#} \\<times># filter_mset Q B\n  ?x \\<in># {#a#} \\<times># add_mset x B \\<Longrightarrow> P ?x = Q (snd ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x B.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># {#a#} \\<times># B \\<Longrightarrow>\n                    P x = Q (snd x)) \\<Longrightarrow>\n                filter_mset P ({#a#} \\<times># B) =\n                {#a#} \\<times># filter_mset Q B;\n        \\<And>xa.\n           xa \\<in># {#a#} \\<times># add_mset x B \\<Longrightarrow>\n           P xa = Q (snd xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P ({#a#} \\<times># add_mset x B) =\n                         {#a#} \\<times># filter_mset Q (add_mset x B)", "have lhs: \"filter_mset P ({#a#} \\<times># add_mset x B) = filter_mset P ({#a#} \\<times># B) + \n    filter_mset P {#(a, x)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P ({#a#} \\<times># add_mset x B) =\n    filter_mset P ({#a#} \\<times># B) + filter_mset P {#(a, x)#}", "by (simp add: cart_product_add_1_filter2)"], ["proof (state)\nthis:\n  filter_mset P ({#a#} \\<times># add_mset x B) =\n  filter_mset P ({#a#} \\<times># B) + filter_mset P {#(a, x)#}\n\ngoal (1 subgoal):\n 1. \\<And>x B.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># {#a#} \\<times># B \\<Longrightarrow>\n                    P x = Q (snd x)) \\<Longrightarrow>\n                filter_mset P ({#a#} \\<times># B) =\n                {#a#} \\<times># filter_mset Q B;\n        \\<And>xa.\n           xa \\<in># {#a#} \\<times># add_mset x B \\<Longrightarrow>\n           P xa = Q (snd xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P ({#a#} \\<times># add_mset x B) =\n                         {#a#} \\<times># filter_mset Q (add_mset x B)", "have rhs: \"{#a#} \\<times># filter_mset Q (add_mset x B) = {#a#} \\<times># filter_mset Q B + \n    {#a#} \\<times># filter_mset Q {#x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#a#} \\<times># filter_mset Q (add_mset x B) =\n    {#a#} \\<times># filter_mset Q B + {#a#} \\<times># filter_mset Q {#x#}", "using add_mset_add_single filter_union_mset"], ["proof (prove)\nusing this:\n  add_mset ?a ?A = ?A + {#?a#}\n  filter_mset ?P (?M + ?N) = filter_mset ?P ?M + filter_mset ?P ?N\n\ngoal (1 subgoal):\n 1. {#a#} \\<times># filter_mset Q (add_mset x B) =\n    {#a#} \\<times># filter_mset Q B + {#a#} \\<times># filter_mset Q {#x#}", "by (metis Times_mset_single_left image_mset_union)"], ["proof (state)\nthis:\n  {#a#} \\<times># filter_mset Q (add_mset x B) =\n  {#a#} \\<times># filter_mset Q B + {#a#} \\<times># filter_mset Q {#x#}\n\ngoal (1 subgoal):\n 1. \\<And>x B.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># {#a#} \\<times># B \\<Longrightarrow>\n                    P x = Q (snd x)) \\<Longrightarrow>\n                filter_mset P ({#a#} \\<times># B) =\n                {#a#} \\<times># filter_mset Q B;\n        \\<And>xa.\n           xa \\<in># {#a#} \\<times># add_mset x B \\<Longrightarrow>\n           P xa = Q (snd xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P ({#a#} \\<times># add_mset x B) =\n                         {#a#} \\<times># filter_mset Q (add_mset x B)", "have \"filter_mset P {#(a, x)#} = {#a#} \\<times># filter_mset Q {#x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P {#(a, x)#} = {#a#} \\<times># filter_mset Q {#x#}", "using add.prems"], ["proof (prove)\nusing this:\n  ?x \\<in># {#a#} \\<times># add_mset x B \\<Longrightarrow> P ?x = Q (snd ?x)\n\ngoal (1 subgoal):\n 1. filter_mset P {#(a, x)#} = {#a#} \\<times># filter_mset Q {#x#}", "by fastforce"], ["proof (state)\nthis:\n  filter_mset P {#(a, x)#} = {#a#} \\<times># filter_mset Q {#x#}\n\ngoal (1 subgoal):\n 1. \\<And>x B.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in># {#a#} \\<times># B \\<Longrightarrow>\n                    P x = Q (snd x)) \\<Longrightarrow>\n                filter_mset P ({#a#} \\<times># B) =\n                {#a#} \\<times># filter_mset Q B;\n        \\<And>xa.\n           xa \\<in># {#a#} \\<times># add_mset x B \\<Longrightarrow>\n           P xa = Q (snd xa)\\<rbrakk>\n       \\<Longrightarrow> filter_mset P ({#a#} \\<times># add_mset x B) =\n                         {#a#} \\<times># filter_mset Q (add_mset x B)", "then"], ["proof (chain)\npicking this:\n  filter_mset P {#(a, x)#} = {#a#} \\<times># filter_mset Q {#x#}", "show ?case"], ["proof (prove)\nusing this:\n  filter_mset P {#(a, x)#} = {#a#} \\<times># filter_mset Q {#x#}\n\ngoal (1 subgoal):\n 1. filter_mset P ({#a#} \\<times># add_mset x B) =\n    {#a#} \\<times># filter_mset Q (add_mset x B)", "using lhs rhs add.IH add.prems"], ["proof (prove)\nusing this:\n  filter_mset P {#(a, x)#} = {#a#} \\<times># filter_mset Q {#x#}\n  filter_mset P ({#a#} \\<times># add_mset x B) =\n  filter_mset P ({#a#} \\<times># B) + filter_mset P {#(a, x)#}\n  {#a#} \\<times># filter_mset Q (add_mset x B) =\n  {#a#} \\<times># filter_mset Q B + {#a#} \\<times># filter_mset Q {#x#}\n  (\\<And>x.\n      x \\<in># {#a#} \\<times># B \\<Longrightarrow>\n      P x = Q (snd x)) \\<Longrightarrow>\n  filter_mset P ({#a#} \\<times># B) = {#a#} \\<times># filter_mset Q B\n  ?x \\<in># {#a#} \\<times># add_mset x B \\<Longrightarrow> P ?x = Q (snd ?x)\n\ngoal (1 subgoal):\n 1. filter_mset P ({#a#} \\<times># add_mset x B) =\n    {#a#} \\<times># filter_mset Q (add_mset x B)", "by force"], ["proof (state)\nthis:\n  filter_mset P ({#a#} \\<times># add_mset x B) =\n  {#a#} \\<times># filter_mset Q (add_mset x B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart_product_singleton_left: \"{#m \\<in># ({#a#} \\<times>#  N) . fst m \\<in> snd m #} = \n  ({#a#} \\<times># {# n \\<in># N . a \\<in> n #})\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#m \\<in># {#a#} \\<times># N. fst m \\<in> snd m#} =\n    {#a#} \\<times># filter_mset ((\\<in>) a) N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {#m \\<in># {#a#} \\<times># N. fst m \\<in> snd m#} =\n    {#a#} \\<times># filter_mset ((\\<in>) a) N", "have stmt: \"\\<And>m. m \\<in># ({#a#} \\<times># N) \\<Longrightarrow> fst m \\<in> snd m \\<longleftrightarrow> a \\<in> snd m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in># {#a#} \\<times># N \\<Longrightarrow>\n       (fst m \\<in> snd m) = (a \\<in> snd m)", "by (simp add: mem_Times_mset_iff)"], ["proof (state)\nthis:\n  ?m \\<in># {#a#} \\<times># N \\<Longrightarrow>\n  (fst ?m \\<in> snd ?m) = (a \\<in> snd ?m)\n\ngoal (1 subgoal):\n 1. {#m \\<in># {#a#} \\<times># N. fst m \\<in> snd m#} =\n    {#a#} \\<times># filter_mset ((\\<in>) a) N", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?m \\<in># {#a#} \\<times># N \\<Longrightarrow>\n  (fst ?m \\<in> snd ?m) = (a \\<in> snd ?m)\n\ngoal (1 subgoal):\n 1. {#m \\<in># {#a#} \\<times># N. fst m \\<in> snd m#} =\n    {#a#} \\<times># filter_mset ((\\<in>) a) N", "by (metis (no_types, lifting) Sigma_mset_cong stmt cart_prod_singleton_left_gen)"], ["proof (state)\nthis:\n  {#m \\<in># {#a#} \\<times># N. fst m \\<in> snd m#} =\n  {#a#} \\<times># filter_mset ((\\<in>) a) N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart_product_singleton_right: \"{#m \\<in># (N \\<times># {#b#}) . fst m \\<in> snd m #} = \n  ({# n \\<in># N . n \\<in> b #} \\<times># {# b #})\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#m \\<in># N \\<times># {#b#}. fst m \\<in> snd m#} =\n    {#n \\<in># N. n \\<in> b#} \\<times># {#b#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {#m \\<in># N \\<times># {#b#}. fst m \\<in> snd m#} =\n    {#n \\<in># N. n \\<in> b#} \\<times># {#b#}", "have stmt: \"\\<And>m. m \\<in># (N \\<times># {#b#}) \\<Longrightarrow> fst m \\<in> snd m \\<longleftrightarrow> fst m \\<in>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in># N \\<times># {#b#} \\<Longrightarrow>\n       (fst m \\<in> snd m) = (fst m \\<in> b)", "by (simp add: mem_Times_mset_iff)"], ["proof (state)\nthis:\n  ?m \\<in># N \\<times># {#b#} \\<Longrightarrow>\n  (fst ?m \\<in> snd ?m) = (fst ?m \\<in> b)\n\ngoal (1 subgoal):\n 1. {#m \\<in># N \\<times># {#b#}. fst m \\<in> snd m#} =\n    {#n \\<in># N. n \\<in> b#} \\<times># {#b#}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?m \\<in># N \\<times># {#b#} \\<Longrightarrow>\n  (fst ?m \\<in> snd ?m) = (fst ?m \\<in> b)\n\ngoal (1 subgoal):\n 1. {#m \\<in># N \\<times># {#b#}. fst m \\<in> snd m#} =\n    {#n \\<in># N. n \\<in> b#} \\<times># {#b#}", "by (metis (no_types, lifting) Sigma_mset_cong stmt cart_prod_singleton_right_gen)"], ["proof (state)\nthis:\n  {#m \\<in># N \\<times># {#b#}. fst m \\<in> snd m#} =\n  {#n \\<in># N. n \\<in> b#} \\<times># {#b#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart_product_add_1_filter_eq: \"{#m \\<in># ((add_mset a M) \\<times># N) . (fst m \\<in> snd m) #} = \n    {#m \\<in># (M \\<times># N) . (fst m \\<in> snd m) #} + ({#a#} \\<times># {# n \\<in># N . a \\<in> n #})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#m \\<in># add_mset a M \\<times># N. fst m \\<in> snd m#} =\n    {#m \\<in># M \\<times># N. fst m \\<in> snd m#} +\n    {#a#} \\<times># filter_mset ((\\<in>) a) N", "unfolding add_mset_add_single [of a M] Sigma_mset_plus_distrib1"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#m \\<in># M \\<times># N + {#a#} \\<times># N. fst m \\<in> snd m#} =\n    {#m \\<in># M \\<times># N. fst m \\<in> snd m#} +\n    {#a#} \\<times># filter_mset ((\\<in>) a) N", "using cart_product_singleton_left cart_product_add_1_filter"], ["proof (prove)\nusing this:\n  {#m \\<in># {#?a#} \\<times># ?N. fst m \\<in> snd m#} =\n  {#?a#} \\<times># filter_mset ((\\<in>) ?a) ?N\n  filter_mset ?P (add_mset ?a ?M \\<times># ?N) =\n  filter_mset ?P (?M \\<times># ?N) + filter_mset ?P ({#?a#} \\<times># ?N)\n\ngoal (1 subgoal):\n 1. {#m \\<in># M \\<times># N + {#a#} \\<times># N. fst m \\<in> snd m#} =\n    {#m \\<in># M \\<times># N. fst m \\<in> snd m#} +\n    {#a#} \\<times># filter_mset ((\\<in>) a) N", "by fastforce"], ["", "lemma cart_product_add_1_filter_eq_mirror: \"{#m \\<in># M \\<times># (add_mset b N) . (fst m \\<in> snd m) #} = \n    {#m \\<in># (M \\<times># N) . (fst m \\<in> snd m) #} + ({# n \\<in># M . n \\<in> b #} \\<times># {#b#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#m \\<in># M \\<times># add_mset b N. fst m \\<in> snd m#} =\n    {#m \\<in># M \\<times># N. fst m \\<in> snd m#} +\n    {#n \\<in># M. n \\<in> b#} \\<times># {#b#}", "unfolding add_mset_add_single [of b N] Sigma_mset_plus_distrib1"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#m \\<in># M \\<times># (N + {#b#}). fst m \\<in> snd m#} =\n    {#m \\<in># M \\<times># N. fst m \\<in> snd m#} +\n    {#n \\<in># M. n \\<in> b#} \\<times># {#b#}", "(* longish *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#m \\<in># M \\<times># (N + {#b#}). fst m \\<in> snd m#} =\n    {#m \\<in># M \\<times># N. fst m \\<in> snd m#} +\n    {#n \\<in># M. n \\<in> b#} \\<times># {#b#}", "by (metis (no_types) add_mset_add_single cart_product_add_1_filter2 cart_product_singleton_right)"], ["", "lemma set_break_down_left:\n  shows \"{# m \\<in># (M \\<times># N) . (fst m) \\<in> (snd m)  #} = (\\<Sum>m\\<in>#M. ({#m#} \\<times># {#n \\<in># N. m \\<in> n#}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#m \\<in># M \\<times># N. fst m \\<in> snd m#} =\n    (\\<Sum>m\\<in>#M. {#m#} \\<times># filter_mset ((\\<in>) m) N)", "by (induction M) (auto simp add: cart_product_add_1_filter_eq)"], ["", "lemma set_break_down_right:\n  shows \"{# x \\<in># M \\<times># N . (fst x) \\<in> (snd x)  #} = (\\<Sum>n\\<in>#N. ({#m \\<in># M. m \\<in> n#} \\<times># {#n#}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#x \\<in># M \\<times># N. fst x \\<in> snd x#} =\n    (\\<Sum>n\\<in>#N. {#m \\<in># M. m \\<in> n#} \\<times># {#n#})", "by (induction N) (auto simp add: cart_product_add_1_filter_eq_mirror)"], ["", "text \\<open>Reasoning on sums of elements over multisets\\<close>"], ["", "lemma sum_over_fun_eq: \n  assumes \"\\<And> x . x \\<in># A \\<Longrightarrow> f x = g x\" \n  shows \"(\\<Sum>x \\<in># A . f(x)) = (\\<Sum> x \\<in># A . g (x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f A) = \\<Sum>\\<^sub># (image_mset g A)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in># A \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f A) = \\<Sum>\\<^sub># (image_mset g A)", "by auto"], ["", "context ring_1\nbegin"], ["", "lemma sum_mset_add_diff: \"(\\<Sum> x \\<in># A. f x - g x) = (\\<Sum> x \\<in># A . f x) -  (\\<Sum> x \\<in># A . g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#A. f x - g x) =\n    \\<Sum>\\<^sub># (image_mset f A) - \\<Sum>\\<^sub># (image_mset g A)", "by (induction A) (auto simp add: algebra_simps)"], ["", "end"], ["", "context ordered_ring\nbegin"], ["", "lemma sum_mset_ge0:\"(\\<And> x . f x \\<ge> 0) \\<Longrightarrow> (\\<Sum> x \\<in># A. f x ) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n    (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A)", "proof (induction A)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n    (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f {#})\n 2. \\<And>x A.\n       \\<lbrakk>(\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n                (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A);\n        \\<And>x. (0::'a) \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> (0::'a)\n                         \\<le> \\<Sum>\\<^sub># (image_mset f (add_mset x A))", "case empty"], ["proof (state)\nthis:\n  (0::'a) \\<le> f ?x1\n\ngoal (2 subgoals):\n 1. (\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n    (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f {#})\n 2. \\<And>x A.\n       \\<lbrakk>(\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n                (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A);\n        \\<And>x. (0::'a) \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> (0::'a)\n                         \\<le> \\<Sum>\\<^sub># (image_mset f (add_mset x A))", "then"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> f ?x1", "show ?case"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> f ?x1\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f {#})", "by simp"], ["proof (state)\nthis:\n  (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f {#})\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n                (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A);\n        \\<And>x. (0::'a) \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> (0::'a)\n                         \\<le> \\<Sum>\\<^sub># (image_mset f (add_mset x A))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n                (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A);\n        \\<And>x. (0::'a) \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> (0::'a)\n                         \\<le> \\<Sum>\\<^sub># (image_mset f (add_mset x A))", "case (add x A)"], ["proof (state)\nthis:\n  (\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n  (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A)\n  (0::'a) \\<le> f ?x1\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n                (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A);\n        \\<And>x. (0::'a) \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> (0::'a)\n                         \\<le> \\<Sum>\\<^sub># (image_mset f (add_mset x A))", "then"], ["proof (chain)\npicking this:\n  (\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n  (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A)\n  (0::'a) \\<le> f ?x1", "have hyp2: \"0 \\<le> sum_mset (image_mset f A)\""], ["proof (prove)\nusing this:\n  (\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n  (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A)\n  (0::'a) \\<le> f ?x1\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A)", "by blast"], ["proof (state)\nthis:\n  (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A)\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n                (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A);\n        \\<And>x. (0::'a) \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> (0::'a)\n                         \\<le> \\<Sum>\\<^sub># (image_mset f (add_mset x A))", "then"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A)", "have \" sum_mset (image_mset f (add_mset x A)) =  sum_mset (image_mset f  A) + f x\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A)\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f (add_mset x A)) =\n    \\<Sum>\\<^sub># (image_mset f A) + f x", "by (simp add: add_commute)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset f (add_mset x A)) =\n  \\<Sum>\\<^sub># (image_mset f A) + f x\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>(\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n                (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f A);\n        \\<And>x. (0::'a) \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> (0::'a)\n                         \\<le> \\<Sum>\\<^sub># (image_mset f (add_mset x A))", "then"], ["proof (chain)\npicking this:\n  \\<Sum>\\<^sub># (image_mset f (add_mset x A)) =\n  \\<Sum>\\<^sub># (image_mset f A) + f x", "show ?case"], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (image_mset f (add_mset x A)) =\n  \\<Sum>\\<^sub># (image_mset f A) + f x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f (add_mset x A))", "by (simp add: add.IH add.prems)"], ["proof (state)\nthis:\n  (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset f (add_mset x A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_order_add_mset: \"(\\<And> x . f x \\<ge> 0) \\<Longrightarrow> (\\<Sum> x \\<in># A. f x ) \\<le> (\\<Sum> x \\<in># add_mset a A. f x )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. (0::'a) \\<le> f x) \\<Longrightarrow>\n    \\<Sum>\\<^sub># (image_mset f A)\n    \\<le> \\<Sum>\\<^sub># (image_mset f (add_mset a A))", "by simp"], ["", "lemma sum_mset_0_left: \"(\\<And> x . f x \\<ge> 0) \\<Longrightarrow> (\\<Sum> x \\<in># A. f x ) = 0 \\<Longrightarrow> (\\<forall> x \\<in># A .f x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. (0::'a) \\<le> f x;\n     \\<Sum>\\<^sub># (image_mset f A) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>#A. f x = (0::'a)", "apply (induction A)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. (0::'a) \\<le> f x;\n     \\<Sum>\\<^sub># (image_mset f {#}) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>#{#}. f x = (0::'a)\n 2. \\<And>x A.\n       \\<lbrakk>\\<lbrakk>\\<And>x. (0::'a) \\<le> f x;\n                 \\<Sum>\\<^sub># (image_mset f A) = (0::'a)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>#A. f x = (0::'a);\n        \\<And>x. (0::'a) \\<le> f x;\n        \\<Sum>\\<^sub># (image_mset f (add_mset x A)) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>#add_mset x A. f x = (0::'a)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>\\<Sum>\\<^sub># (image_mset f A) = (0::'a) \\<Longrightarrow>\n                \\<forall>x\\<in>#A. f x = (0::'a);\n        \\<And>x. (0::'a) \\<le> f x;\n        f x + \\<Sum>\\<^sub># (image_mset f A) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> f x = (0::'a)\n 2. \\<And>x A xa.\n       \\<lbrakk>\\<Sum>\\<^sub># (image_mset f A) = (0::'a) \\<Longrightarrow>\n                \\<forall>x\\<in>#A. f x = (0::'a);\n        \\<And>x. (0::'a) \\<le> f x;\n        f x + \\<Sum>\\<^sub># (image_mset f A) = (0::'a);\n        xa \\<in># A\\<rbrakk>\n       \\<Longrightarrow> f xa = (0::'a)", "using local.add_nonneg_eq_0_iff sum_mset_ge0"], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::'a) \\<le> ?x; (0::'a) \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> (?x + ?y = (0::'a)) = (?x = (0::'a) \\<and> ?y = (0::'a))\n  (\\<And>x. (0::'a) \\<le> ?f x) \\<Longrightarrow>\n  (0::'a) \\<le> \\<Sum>\\<^sub># (image_mset ?f ?A)\n\ngoal (2 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>\\<Sum>\\<^sub># (image_mset f A) = (0::'a) \\<Longrightarrow>\n                \\<forall>x\\<in>#A. f x = (0::'a);\n        \\<And>x. (0::'a) \\<le> f x;\n        f x + \\<Sum>\\<^sub># (image_mset f A) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> f x = (0::'a)\n 2. \\<And>x A xa.\n       \\<lbrakk>\\<Sum>\\<^sub># (image_mset f A) = (0::'a) \\<Longrightarrow>\n                \\<forall>x\\<in>#A. f x = (0::'a);\n        \\<And>x. (0::'a) \\<le> f x;\n        f x + \\<Sum>\\<^sub># (image_mset f A) = (0::'a);\n        xa \\<in># A\\<rbrakk>\n       \\<Longrightarrow> f xa = (0::'a)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A xa.\n       \\<lbrakk>\\<Sum>\\<^sub># (image_mset f A) = (0::'a) \\<Longrightarrow>\n                \\<forall>x\\<in>#A. f x = (0::'a);\n        \\<And>x. (0::'a) \\<le> f x;\n        f x + \\<Sum>\\<^sub># (image_mset f A) = (0::'a);\n        xa \\<in># A\\<rbrakk>\n       \\<Longrightarrow> f xa = (0::'a)", "by (metis local.antisym local.sum_mset.insert sum_mset_ge0 sum_order_add_mset)"], ["", "lemma sum_mset_0_iff_ge_0:\n  assumes \"(\\<And> x . f x \\<ge> 0)\"\n  shows \"(\\<Sum> x \\<in># A. f x ) = 0 \\<longleftrightarrow> (\\<forall> x \\<in> set_mset A .f x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub># (image_mset f A) = (0::'a)) =\n    (\\<forall>x\\<in>#A. f x = (0::'a))", "using sum_mset_0_left assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. (0::'a) \\<le> ?f x;\n   \\<Sum>\\<^sub># (image_mset ?f ?A) = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>#?A. ?f x = (0::'a)\n  (0::'a) \\<le> f ?x1\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub># (image_mset f A) = (0::'a)) =\n    (\\<forall>x\\<in>#A. f x = (0::'a))", "by auto"], ["", "end"], ["", "lemma mset_set_size_card_count: \"(\\<Sum>x \\<in># A. x) = (\\<Sum>x \\<in> set_mset A . x * (count A x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#A. x) = (\\<Sum>x\\<in>set_mset A. x * count A x)", "proof (induction A)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>x\\<in>#{#}. x) = (\\<Sum>x\\<in>set_mset {#}. x * count {#} x)\n 2. \\<And>x A.\n       (\\<Sum>x\\<in>#A. x) =\n       (\\<Sum>x\\<in>set_mset A. x * count A x) \\<Longrightarrow>\n       (\\<Sum>x\\<in>#add_mset x A. x) =\n       (\\<Sum>xa\\<in>set_mset (add_mset x A). xa * count (add_mset x A) xa)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<Sum>x\\<in>#{#}. x) = (\\<Sum>x\\<in>set_mset {#}. x * count {#} x)\n 2. \\<And>x A.\n       (\\<Sum>x\\<in>#A. x) =\n       (\\<Sum>x\\<in>set_mset A. x * count A x) \\<Longrightarrow>\n       (\\<Sum>x\\<in>#add_mset x A. x) =\n       (\\<Sum>xa\\<in>set_mset (add_mset x A). xa * count (add_mset x A) xa)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#{#}. x) = (\\<Sum>x\\<in>set_mset {#}. x * count {#} x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>#{#}. x) = (\\<Sum>x\\<in>set_mset {#}. x * count {#} x)\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       (\\<Sum>x\\<in>#A. x) =\n       (\\<Sum>x\\<in>set_mset A. x * count A x) \\<Longrightarrow>\n       (\\<Sum>x\\<in>#add_mset x A. x) =\n       (\\<Sum>xa\\<in>set_mset (add_mset x A). xa * count (add_mset x A) xa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A.\n       (\\<Sum>x\\<in>#A. x) =\n       (\\<Sum>x\\<in>set_mset A. x * count A x) \\<Longrightarrow>\n       (\\<Sum>x\\<in>#add_mset x A. x) =\n       (\\<Sum>xa\\<in>set_mset (add_mset x A). xa * count (add_mset x A) xa)", "case (add y A)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>#A. x) = (\\<Sum>x\\<in>set_mset A. x * count A x)\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       (\\<Sum>x\\<in>#A. x) =\n       (\\<Sum>x\\<in>set_mset A. x * count A x) \\<Longrightarrow>\n       (\\<Sum>x\\<in>#add_mset x A. x) =\n       (\\<Sum>xa\\<in>set_mset (add_mset x A). xa * count (add_mset x A) xa)", "have lhs: \"(\\<Sum>x\\<in>#add_mset y A. x) = (\\<Sum>x\\<in># A. x) + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#add_mset y A. x) = (\\<Sum>x\\<in>#A. x) + y", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>#add_mset y A. x) = (\\<Sum>x\\<in>#A. x) + y\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       (\\<Sum>x\\<in>#A. x) =\n       (\\<Sum>x\\<in>set_mset A. x * count A x) \\<Longrightarrow>\n       (\\<Sum>x\\<in>#add_mset x A. x) =\n       (\\<Sum>xa\\<in>set_mset (add_mset x A). xa * count (add_mset x A) xa)", "have rhs: \"(\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) = \n      (\\<Sum>x\\<in>(insert y (set_mset A)) . x * count (add_mset y A) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n    (\\<Sum>x\\<in>insert y (set_mset A). x * count (add_mset y A) x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  (\\<Sum>x\\<in>insert y (set_mset A). x * count (add_mset y A) x)\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       (\\<Sum>x\\<in>#A. x) =\n       (\\<Sum>x\\<in>set_mset A. x * count A x) \\<Longrightarrow>\n       (\\<Sum>x\\<in>#add_mset x A. x) =\n       (\\<Sum>xa\\<in>set_mset (add_mset x A). xa * count (add_mset x A) xa)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  (\\<Sum>x\\<in>insert y (set_mset A). x * count (add_mset y A) x)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  (\\<Sum>x\\<in>insert y (set_mset A). x * count (add_mset y A) x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#add_mset y A. x) =\n    (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x)", "proof (cases \"y \\<in># A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<in># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)\n 2. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "case True"], ["proof (state)\nthis:\n  y \\<in># A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<in># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)\n 2. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "have x_val: \"\\<And> x . x \\<in> (insert y (set_mset A)) \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> \n        x* count (add_mset y A) x = x * (count A x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> insert y (set_mset A); x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> x * count (add_mset y A) x = x * count A x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> insert y (set_mset A); ?x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> ?x * count (add_mset y A) ?x = ?x * count A ?x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<in># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)\n 2. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "have y_count: \"count (add_mset y A) y = 1 + count A y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (add_mset y A) y = 1 + count A y", "using True count_inI"], ["proof (prove)\nusing this:\n  y \\<in># A\n  (count ?M ?x = 0 \\<Longrightarrow> False) \\<Longrightarrow> ?x \\<in># ?M\n\ngoal (1 subgoal):\n 1. count (add_mset y A) y = 1 + count A y", "by fastforce"], ["proof (state)\nthis:\n  count (add_mset y A) y = 1 + count A y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<in># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)\n 2. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "then"], ["proof (chain)\npicking this:\n  count (add_mset y A) y = 1 + count A y", "have \"(\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) = \n        (y * (count (add_mset y A) y)) + (\\<Sum>x\\<in>(set_mset A) - {y}. x * count A x)\""], ["proof (prove)\nusing this:\n  count (add_mset y A) y = 1 + count A y\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n    y * count (add_mset y A) y +\n    (\\<Sum>x\\<in>set_mset A - {y}. x * count A x)", "using x_val finite_set_mset sum.cong sum.insert rhs"], ["proof (prove)\nusing this:\n  count (add_mset y A) y = 1 + count A y\n  \\<lbrakk>?x \\<in> insert y (set_mset A); ?x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> ?x * count (add_mset y A) ?x = ?x * count A ?x\n  finite (set_mset ?M)\n  \\<lbrakk>?A = ?B;\n   \\<And>x. x \\<in> ?B \\<Longrightarrow> ?g x = ?h x\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?h ?B\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> sum ?g (insert ?x ?A) = ?g ?x + sum ?g ?A\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  (\\<Sum>x\\<in>insert y (set_mset A). x * count (add_mset y A) x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n    y * count (add_mset y A) y +\n    (\\<Sum>x\\<in>set_mset A - {y}. x * count A x)", "by (smt DiffD1 Diff_insert_absorb insert_absorb mk_disjoint_insert sum.insert_remove)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y * count (add_mset y A) y + (\\<Sum>x\\<in>set_mset A - {y}. x * count A x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<in># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)\n 2. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y * count (add_mset y A) y + (\\<Sum>x\\<in>set_mset A - {y}. x * count A x)", "have s1: \"(\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) = \n        y + y * (count A y) + (\\<Sum>x\\<in>(set_mset A) - {y}. x * count A x)\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y * count (add_mset y A) y + (\\<Sum>x\\<in>set_mset A - {y}. x * count A x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n    y + y * count A y + (\\<Sum>x\\<in>set_mset A - {y}. x * count A x)", "using y_count"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y * count (add_mset y A) y + (\\<Sum>x\\<in>set_mset A - {y}. x * count A x)\n  count (add_mset y A) y = 1 + count A y\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n    y + y * count A y + (\\<Sum>x\\<in>set_mset A - {y}. x * count A x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + y * count A y + (\\<Sum>x\\<in>set_mset A - {y}. x * count A x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<in># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)\n 2. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + y * count A y + (\\<Sum>x\\<in>set_mset A - {y}. x * count A x)", "have \"(\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) = \n        y + (\\<Sum>x\\<in>insert y ((set_mset A) - {y} ) . x * count A x)\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + y * count A y + (\\<Sum>x\\<in>set_mset A - {y}. x * count A x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n    y + (\\<Sum>x\\<in>insert y (set_mset A - {y}). x * count A x)", "by (simp add: sum.insert_remove)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + (\\<Sum>x\\<in>insert y (set_mset A - {y}). x * count A x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<in># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)\n 2. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + (\\<Sum>x\\<in>insert y (set_mset A - {y}). x * count A x)", "have \"(\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) = \n        y + (\\<Sum>x\\<in>(set_mset A) . x * count A x)\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + (\\<Sum>x\\<in>insert y (set_mset A - {y}). x * count A x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n    y + (\\<Sum>x\\<in>set_mset A. x * count A x)", "by (simp add:  True insert_absorb)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + (\\<Sum>x\\<in>set_mset A. x * count A x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<in># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)\n 2. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + (\\<Sum>x\\<in>set_mset A. x * count A x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + (\\<Sum>x\\<in>set_mset A. x * count A x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#add_mset y A. x) =\n    (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x)", "using lhs add.IH"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + (\\<Sum>x\\<in>set_mset A. x * count A x)\n  (\\<Sum>x\\<in>#add_mset y A. x) = (\\<Sum>x\\<in>#A. x) + y\n  (\\<Sum>x\\<in>#A. x) = (\\<Sum>x\\<in>set_mset A. x * count A x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#add_mset y A. x) =\n    (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x)", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>#add_mset y A. x) =\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "case False"], ["proof (state)\nthis:\n  y \\<notin># A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "have x_val: \"\\<And> x . x \\<in> set_mset A \\<Longrightarrow> x* count (add_mset y A) x = x * (count A x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># A \\<Longrightarrow>\n       x * count (add_mset y A) x = x * count A x", "using False"], ["proof (prove)\nusing this:\n  y \\<notin># A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># A \\<Longrightarrow>\n       x * count (add_mset y A) x = x * count A x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in># A \\<Longrightarrow>\n  ?x * count (add_mset y A) ?x = ?x * count A ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "have y_count: \"count (add_mset y A) y = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (add_mset y A) y = 1", "using False count_inI"], ["proof (prove)\nusing this:\n  y \\<notin># A\n  (count ?M ?x = 0 \\<Longrightarrow> False) \\<Longrightarrow> ?x \\<in># ?M\n\ngoal (1 subgoal):\n 1. count (add_mset y A) y = 1", "by fastforce"], ["proof (state)\nthis:\n  count (add_mset y A) y = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "have lhs: \"(\\<Sum>x\\<in>#add_mset y A. x) = (\\<Sum>x\\<in># A. x) + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#add_mset y A. x) = (\\<Sum>x\\<in>#A. x) + y", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>#add_mset y A. x) = (\\<Sum>x\\<in>#A. x) + y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "have \"(\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) = \n        (y * count (add_mset y A) y) + (\\<Sum>x\\<in>set_mset A. x * count A x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n    y * count (add_mset y A) y + (\\<Sum>x\\<in>set_mset A. x * count A x)", "using x_val rhs"], ["proof (prove)\nusing this:\n  ?x \\<in># A \\<Longrightarrow>\n  ?x * count (add_mset y A) ?x = ?x * count A ?x\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  (\\<Sum>x\\<in>insert y (set_mset A). x * count (add_mset y A) x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n    y * count (add_mset y A) y + (\\<Sum>x\\<in>set_mset A. x * count A x)", "by (metis (no_types, lifting) False finite_set_mset sum.cong sum.insert)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y * count (add_mset y A) y + (\\<Sum>x\\<in>set_mset A. x * count A x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y * count (add_mset y A) y + (\\<Sum>x\\<in>set_mset A. x * count A x)", "have \"(\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) = \n        y + (\\<Sum>x\\<in>set_mset A. x * count A x)\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y * count (add_mset y A) y + (\\<Sum>x\\<in>set_mset A. x * count A x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n    y + (\\<Sum>x\\<in>set_mset A. x * count A x)", "using y_count"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y * count (add_mset y A) y + (\\<Sum>x\\<in>set_mset A. x * count A x)\n  count (add_mset y A) y = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n    y + (\\<Sum>x\\<in>set_mset A. x * count A x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + (\\<Sum>x\\<in>set_mset A. x * count A x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>x\\<in>set_mset (add_mset y A).\n                x * count (add_mset y A) x) =\n             (\\<Sum>x\\<in>insert y (set_mset A).\n                x * count (add_mset y A) x);\n     y \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#add_mset y A. x) =\n                      (\\<Sum>x\\<in>set_mset (add_mset y A).\n                         x * count (add_mset y A) x)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + (\\<Sum>x\\<in>set_mset A. x * count A x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + (\\<Sum>x\\<in>set_mset A. x * count A x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#add_mset y A. x) =\n    (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x)", "using lhs add.IH"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x) =\n  y + (\\<Sum>x\\<in>set_mset A. x * count A x)\n  (\\<Sum>x\\<in>#add_mset y A. x) = (\\<Sum>x\\<in>#A. x) + y\n  (\\<Sum>x\\<in>#A. x) = (\\<Sum>x\\<in>set_mset A. x * count A x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#add_mset y A. x) =\n    (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x)", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>#add_mset y A. x) =\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>#add_mset y A. x) =\n  (\\<Sum>x\\<in>set_mset (add_mset y A). x * count (add_mset y A) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Partitions on Multisets\\<close>"], ["", "text \\<open>A partition on a multiset A is a multiset of multisets, where the sum over P equals A and the \nempty multiset is not in the partition. Based off set partition definition. \nWe note that unlike set partitions, there is no requirement for elements in the multisets to be \ndistinct due to the definition of union on multisets \\cite{benderPartitionsMultisets1974}\\<close>"], ["", "lemma mset_size_partition_dep: \"size {# a \\<in># A . P a \\<or> Q a #} = \n    size {# a \\<in># A . P a #} +  size {# a \\<in># A . Q a #} -  size {# a \\<in># A . P a \\<and> Q a #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#a \\<in># A. P a \\<or> Q a#} =\n    size (filter_mset P A) + size (filter_mset Q A) -\n    size {#a \\<in># A. P a \\<and> Q a#}", "by (simp add: mset_bunion_filter mset_inter_filter mset_union_size_inter)"], ["", "definition partition_on_mset :: \"'a multiset \\<Rightarrow> 'a multiset multiset \\<Rightarrow> bool\" where\n\"partition_on_mset A P \\<longleftrightarrow> \\<Sum>\\<^sub>#P = A \\<and> {#} \\<notin># P\""], ["", "lemma partition_on_msetI [intro]: \"\\<Sum>\\<^sub>#P = A \\<Longrightarrow> {#} \\<notin># P \\<Longrightarrow> partition_on_mset A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Sum>\\<^sub># P = A; {#} \\<notin># P\\<rbrakk>\n    \\<Longrightarrow> partition_on_mset A P", "by (simp add: partition_on_mset_def)"], ["", "lemma partition_on_msetD1: \"partition_on_mset A P \\<Longrightarrow> \\<Sum>\\<^sub>#P = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset A P \\<Longrightarrow> \\<Sum>\\<^sub># P = A", "by (simp add: partition_on_mset_def)"], ["", "lemma partition_on_msetD2: \"partition_on_mset A P \\<Longrightarrow> {#} \\<notin>#  P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset A P \\<Longrightarrow> {#} \\<notin># P", "by (simp add: partition_on_mset_def)"], ["", "lemma partition_on_mset_empty: \"partition_on_mset {#} P \\<longleftrightarrow> P = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset {#} P = (P = {#})", "unfolding partition_on_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub># P = {#} \\<and> {#} \\<notin># P) = (P = {#})", "using multiset_nonemptyE"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<noteq> {#};\n   \\<And>x. x \\<in># ?A \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub># P = {#} \\<and> {#} \\<notin># P) = (P = {#})", "by fastforce"], ["", "lemma partition_on_mset_all: \"A \\<noteq> {#} \\<Longrightarrow> partition_on_mset A {#A #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {#} \\<Longrightarrow> partition_on_mset A {#A#}", "by (simp add: partition_on_mset_def)"], ["", "lemma partition_on_mset_singletons: \"partition_on_mset A (image_mset (\\<lambda> x . {#x#}) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset A {#{#x#}. x \\<in># A#}", "by (auto simp: partition_on_mset_def)"], ["", "lemma partition_on_mset_not_empty: \"A \\<noteq> {#} \\<Longrightarrow> partition_on_mset A P \\<Longrightarrow> P \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {#}; partition_on_mset A P\\<rbrakk>\n    \\<Longrightarrow> P \\<noteq> {#}", "by (auto simp: partition_on_mset_def)"], ["", "lemma partition_on_msetI2: \"\\<Sum>\\<^sub>#P = A \\<Longrightarrow> (\\<And> p . p \\<in># P \\<Longrightarrow> p \\<noteq> {#}) \\<Longrightarrow> partition_on_mset A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Sum>\\<^sub># P = A;\n     \\<And>p. p \\<in># P \\<Longrightarrow> p \\<noteq> {#}\\<rbrakk>\n    \\<Longrightarrow> partition_on_mset A P", "by (auto simp: partition_on_mset_def)"], ["", "lemma partition_on_mset_elems: \"partition_on_mset A P \\<Longrightarrow> p1 \\<in># P \\<Longrightarrow> x \\<in># p1 \\<Longrightarrow> x \\<in># A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>partition_on_mset A P; p1 \\<in># P; x \\<in># p1\\<rbrakk>\n    \\<Longrightarrow> x \\<in># A", "by (auto simp: partition_on_mset_def)"], ["", "lemma partition_on_mset_sum_size_eq: \"partition_on_mset A P \\<Longrightarrow> (\\<Sum>x \\<in># P. size x) = size A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset A P \\<Longrightarrow>\n    \\<Sum>\\<^sub># (image_mset size P) = size A", "by (metis partition_on_msetD1 size_big_union_sum)"], ["", "lemma partition_on_mset_card: assumes \"partition_on_mset A P\" shows \" size P \\<le> size A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size P \\<le> size A", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> size P \\<le> size A \\<Longrightarrow> False", "assume \"\\<not> size P \\<le> size A\""], ["proof (state)\nthis:\n  \\<not> size P \\<le> size A\n\ngoal (1 subgoal):\n 1. \\<not> size P \\<le> size A \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> size P \\<le> size A", "have a: \"size P > size A\""], ["proof (prove)\nusing this:\n  \\<not> size P \\<le> size A\n\ngoal (1 subgoal):\n 1. size A < size P", "by simp"], ["proof (state)\nthis:\n  size A < size P\n\ngoal (1 subgoal):\n 1. \\<not> size P \\<le> size A \\<Longrightarrow> False", "have \"\\<And> x . x \\<in># P \\<Longrightarrow> size x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in># P \\<Longrightarrow> 0 < size x", "using partition_on_msetD2"], ["proof (prove)\nusing this:\n  partition_on_mset ?A ?P \\<Longrightarrow> {#} \\<notin># ?P\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in># P \\<Longrightarrow> 0 < size x", "using assms nonempty_has_size"], ["proof (prove)\nusing this:\n  partition_on_mset ?A ?P \\<Longrightarrow> {#} \\<notin># ?P\n  partition_on_mset A P\n  (?S \\<noteq> {#}) = (0 < size ?S)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in># P \\<Longrightarrow> 0 < size x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in># P \\<Longrightarrow> 0 < size ?x\n\ngoal (1 subgoal):\n 1. \\<not> size P \\<le> size A \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?x \\<in># P \\<Longrightarrow> 0 < size ?x", "have \" (\\<Sum>x \\<in># P. size x) \\<ge> size P\""], ["proof (prove)\nusing this:\n  ?x \\<in># P \\<Longrightarrow> 0 < size ?x\n\ngoal (1 subgoal):\n 1. size P \\<le> \\<Sum>\\<^sub># (image_mset size P)", "by (metis leI less_one not_less_zero size_eq_sum_mset sum_mset_mono)"], ["proof (state)\nthis:\n  size P \\<le> \\<Sum>\\<^sub># (image_mset size P)\n\ngoal (1 subgoal):\n 1. \\<not> size P \\<le> size A \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  size P \\<le> \\<Sum>\\<^sub># (image_mset size P)\n\ngoal (1 subgoal):\n 1. False", "using a partition_on_mset_sum_size_eq"], ["proof (prove)\nusing this:\n  size P \\<le> \\<Sum>\\<^sub># (image_mset size P)\n  size A < size P\n  partition_on_mset ?A ?P \\<Longrightarrow>\n  \\<Sum>\\<^sub># (image_mset size ?P) = size ?A\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  size P \\<le> \\<Sum>\\<^sub># (image_mset size P)\n  size A < size P\n  partition_on_mset ?A ?P \\<Longrightarrow>\n  \\<Sum>\\<^sub># (image_mset size ?P) = size ?A\n  partition_on_mset A P\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partition_on_mset_count_eq: \"partition_on_mset A P \\<Longrightarrow> a \\<in># A \\<Longrightarrow> \n    (\\<Sum>x \\<in># P. count x a) = count A a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>partition_on_mset A P; a \\<in># A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>#P. count x a) = count A a", "by (metis count_sum_mset partition_on_msetD1)"], ["", "lemma partition_on_mset_subsets: \"partition_on_mset A P \\<Longrightarrow> x \\<in># P \\<Longrightarrow> x \\<subseteq># A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>partition_on_mset A P; x \\<in># P\\<rbrakk>\n    \\<Longrightarrow> x \\<subseteq># A", "by (auto simp add: partition_on_mset_def)"], ["", "lemma partition_on_mset_distinct: \n  assumes \"partition_on_mset A P\"\n  assumes \"distinct_mset A\"\n  shows \"distinct_mset P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset P", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct_mset P \\<Longrightarrow> False", "assume \"\\<not> distinct_mset P\""], ["proof (state)\nthis:\n  \\<not> distinct_mset P\n\ngoal (1 subgoal):\n 1. \\<not> distinct_mset P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct_mset P", "obtain p1 where count: \"count P p1 \\<ge> 2\""], ["proof (prove)\nusing this:\n  \\<not> distinct_mset P\n\ngoal (1 subgoal):\n 1. (\\<And>p1.\n        2 \\<le> count P p1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_1 distinct_mset_count_less_1 less_Suc_eq_le not_less_eq)"], ["proof (state)\nthis:\n  2 \\<le> count P p1\n\ngoal (1 subgoal):\n 1. \\<not> distinct_mset P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  2 \\<le> count P p1", "have cge: \"\\<And> x . x \\<in># p1 \\<Longrightarrow> (\\<Sum>p \\<in># P. count p x ) \\<ge> 2\""], ["proof (prove)\nusing this:\n  2 \\<le> count P p1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># p1 \\<Longrightarrow> 2 \\<le> (\\<Sum>p\\<in>#P. count p x)", "by (smt count_greater_eq_one_iff count_sum_mset_if_1_0 dual_order.trans sum_mset_mono zero_le)"], ["proof (state)\nthis:\n  ?x \\<in># p1 \\<Longrightarrow> 2 \\<le> (\\<Sum>p\\<in>#P. count p ?x)\n\ngoal (1 subgoal):\n 1. \\<not> distinct_mset P \\<Longrightarrow> False", "have elem_in: \"\\<And> x . x \\<in># p1 \\<Longrightarrow> x \\<in># A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in># p1 \\<Longrightarrow> x \\<in># A", "using partition_on_mset_elems"], ["proof (prove)\nusing this:\n  \\<lbrakk>partition_on_mset ?A ?P; ?p1.0 \\<in># ?P;\n   ?x \\<in># ?p1.0\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in># ?A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in># p1 \\<Longrightarrow> x \\<in># A", "by (metis count assms(1) count_eq_zero_iff not_numeral_le_zero)"], ["proof (state)\nthis:\n  ?x \\<in># p1 \\<Longrightarrow> ?x \\<in># A\n\ngoal (1 subgoal):\n 1. \\<not> distinct_mset P \\<Longrightarrow> False", "have \"\\<And> x . x \\<in># A \\<Longrightarrow> count A x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in># A \\<Longrightarrow> count A x = 1", "using assms"], ["proof (prove)\nusing this:\n  partition_on_mset A P\n  distinct_mset A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in># A \\<Longrightarrow> count A x = 1", "by (simp add: distinct_mset_def)"], ["proof (state)\nthis:\n  ?x \\<in># A \\<Longrightarrow> count A ?x = 1\n\ngoal (1 subgoal):\n 1. \\<not> distinct_mset P \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  ?x \\<in># A \\<Longrightarrow> count A ?x = 1\n\ngoal (1 subgoal):\n 1. False", "using assms partition_on_mset_count_eq cge elem_in count_inI local.count multiset_nonemptyE"], ["proof (prove)\nusing this:\n  ?x \\<in># A \\<Longrightarrow> count A ?x = 1\n  partition_on_mset A P\n  distinct_mset A\n  \\<lbrakk>partition_on_mset ?A ?P; ?a \\<in># ?A\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>#?P. count x ?a) = count ?A ?a\n  ?x \\<in># p1 \\<Longrightarrow> 2 \\<le> (\\<Sum>p\\<in>#P. count p ?x)\n  ?x \\<in># p1 \\<Longrightarrow> ?x \\<in># A\n  (count ?M ?x = 0 \\<Longrightarrow> False) \\<Longrightarrow> ?x \\<in># ?M\n  2 \\<le> count P p1\n  \\<lbrakk>?A \\<noteq> {#};\n   \\<And>x. x \\<in># ?A \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "by (metis (mono_tags) not_numeral_le_zero numeral_One numeral_le_iff partition_on_mset_def semiring_norm(69))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partition_on_mset_distinct_disjoint: \n  assumes \"partition_on_mset A P\"\n  assumes \"distinct_mset A\"\n  assumes \"p1 \\<in># P\"\n  assumes \"p2 \\<in># P - {#p1#}\"\n  shows \"p1 \\<inter># p2 = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<inter># p2 = {#}", "using Diff_eq_empty_iff_mset assms diff_add_zero distinct_mset_add multiset_inter_assoc sum_mset.remove"], ["proof (prove)\nusing this:\n  (?A - ?B = {#}) = (?A \\<subseteq># ?B)\n  partition_on_mset A P\n  distinct_mset A\n  p1 \\<in># P\n  p2 \\<in># remove1_mset p1 P\n  ?a - (?a + ?b) = (0::?'a)\n  distinct_mset (?L + ?L') =\n  (distinct_mset ?L \\<and> distinct_mset ?L' \\<and> ?L \\<inter># ?L' = {#})\n  ?A \\<inter># (?B \\<inter># ?C) = ?A \\<inter># ?B \\<inter># ?C\n  ?x \\<in># ?A \\<Longrightarrow>\n  \\<Sum>\\<^sub># ?A = ?x + \\<Sum>\\<^sub># (remove1_mset ?x ?A)\n\ngoal (1 subgoal):\n 1. p1 \\<inter># p2 = {#}", "by (smt partition_on_msetD1 subset_mset.inf.absorb_iff2 subset_mset.le_add_same_cancel1 subset_mset.le_iff_inf)"], ["", "lemma partition_on_mset_diff: \n  assumes \"partition_on_mset A P\"\n  assumes \"Q \\<subseteq>#P\"\n  shows \"partition_on_mset (A - \\<Sum>\\<^sub>#Q) (P - Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset (A - \\<Sum>\\<^sub># Q) (P - Q)", "using assms partition_on_mset_def"], ["proof (prove)\nusing this:\n  partition_on_mset A P\n  Q \\<subseteq># P\n  partition_on_mset ?A ?P = (\\<Sum>\\<^sub># ?P = ?A \\<and> {#} \\<notin># ?P)\n\ngoal (1 subgoal):\n 1. partition_on_mset (A - \\<Sum>\\<^sub># Q) (P - Q)", "by (smt diff_union_cancelL subset_mset.add_diff_inverse sum_mset.union union_iff)"], ["", "lemma sigma_over_set_partition_count: \n  assumes \"finite A\"\n  assumes \"partition_on A P\"\n  assumes \"x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\"\n  shows \"count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "have disj: \"disjoint P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjoint P", "using assms partition_onD2"], ["proof (prove)\nusing this:\n  finite A\n  partition_on A P\n  x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\n  partition_on ?A ?P \\<Longrightarrow> disjoint ?P\n\ngoal (1 subgoal):\n 1. disjoint P", "by auto"], ["proof (state)\nthis:\n  disjoint P\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "then"], ["proof (chain)\npicking this:\n  disjoint P", "obtain p where  pin: \"p \\<in># mset_set (mset_set ` P)\" and xin: \"x \\<in># p\""], ["proof (prove)\nusing this:\n  disjoint P\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in># mset_set (mset_set ` P); x \\<in># p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  disjoint P\n  finite A\n  partition_on A P\n  x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in># mset_set (mset_set ` P); x \\<in># p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in># mset_set (mset_set ` P)\n  x \\<in># p\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "then"], ["proof (chain)\npicking this:\n  p \\<in># mset_set (mset_set ` P)\n  x \\<in># p", "have \"count (mset_set (mset_set ` P)) p = 1\""], ["proof (prove)\nusing this:\n  p \\<in># mset_set (mset_set ` P)\n  x \\<in># p\n\ngoal (1 subgoal):\n 1. count (mset_set (mset_set ` P)) p = 1", "by (meson count_eq_zero_iff count_mset_set')"], ["proof (state)\nthis:\n  count (mset_set (mset_set ` P)) p = 1\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "then"], ["proof (chain)\npicking this:\n  count (mset_set (mset_set ` P)) p = 1", "have filter: \"\\<And> p' . p' \\<in># ((mset_set (mset_set` P)) - {#p#}) \\<Longrightarrow> p \\<noteq> p'\""], ["proof (prove)\nusing this:\n  count (mset_set (mset_set ` P)) p = 1\n\ngoal (1 subgoal):\n 1. \\<And>p'.\n       p' \\<in># remove1_mset p (mset_set (mset_set ` P)) \\<Longrightarrow>\n       p \\<noteq> p'", "using count_eq_zero_iff count_single"], ["proof (prove)\nusing this:\n  count (mset_set (mset_set ` P)) p = 1\n  (count ?M ?x = 0) = (?x \\<notin># ?M)\n  count {#?b#} ?a = (if ?b = ?a then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>p'.\n       p' \\<in># remove1_mset p (mset_set (mset_set ` P)) \\<Longrightarrow>\n       p \\<noteq> p'", "by fastforce"], ["proof (state)\nthis:\n  ?p' \\<in># remove1_mset p (mset_set (mset_set ` P)) \\<Longrightarrow>\n  p \\<noteq> ?p'\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "have zero: \"\\<And> p'. p' \\<in># mset_set (mset_set ` P) \\<Longrightarrow> p' \\<noteq> p \\<Longrightarrow> count p' x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p'.\n       \\<lbrakk>p' \\<in># mset_set (mset_set ` P); p' \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> count p' x = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p'.\n       \\<lbrakk>p' \\<in># mset_set (mset_set ` P); p' \\<noteq> p;\n        count p' x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p'.\n       \\<lbrakk>p' \\<in># mset_set (mset_set ` P); p' \\<noteq> p;\n        count p' x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume assm: \"p' \\<in># mset_set (mset_set ` P)\" and ne: \"p' \\<noteq> p\"  and n0: \"count p' x \\<noteq> 0\""], ["proof (state)\nthis:\n  p' \\<in># mset_set (mset_set ` P)\n  p' \\<noteq> p\n  count p' x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p'.\n       \\<lbrakk>p' \\<in># mset_set (mset_set ` P); p' \\<noteq> p;\n        count p' x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p' \\<in># mset_set (mset_set ` P)\n  p' \\<noteq> p\n  count p' x \\<noteq> 0", "have xin2: \"x \\<in># p'\""], ["proof (prove)\nusing this:\n  p' \\<in># mset_set (mset_set ` P)\n  p' \\<noteq> p\n  count p' x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in># p'", "by auto"], ["proof (state)\nthis:\n  x \\<in># p'\n\ngoal (1 subgoal):\n 1. \\<And>p'.\n       \\<lbrakk>p' \\<in># mset_set (mset_set ` P); p' \\<noteq> p;\n        count p' x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> False", "obtain p1 p2 where p1in: \"p1 \\<in> P\" and p2in: \"p2 \\<in> P\" and  p1eq: \"mset_set p1 = p\" \n        and p2eq: \"mset_set p2 = p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p1 \\<in> P; p2 \\<in> P; mset_set p1 = p;\n         mset_set p2 = p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assm assms(1) assms(2) pin"], ["proof (prove)\nusing this:\n  p' \\<in># mset_set (mset_set ` P)\n  finite A\n  partition_on A P\n  p \\<in># mset_set (mset_set ` P)\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p1 \\<in> P; p2 \\<in> P; mset_set p1 = p;\n         mset_set p2 = p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) elem_mset_set finite_elements finite_imageI image_iff)"], ["proof (state)\nthis:\n  p1 \\<in> P\n  p2 \\<in> P\n  mset_set p1 = p\n  mset_set p2 = p'\n\ngoal (1 subgoal):\n 1. \\<And>p'.\n       \\<lbrakk>p' \\<in># mset_set (mset_set ` P); p' \\<noteq> p;\n        count p' x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> False", "have origne: \"p1 \\<noteq> p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<noteq> p2", "using ne p1eq p2eq"], ["proof (prove)\nusing this:\n  p' \\<noteq> p\n  mset_set p1 = p\n  mset_set p2 = p'\n\ngoal (1 subgoal):\n 1. p1 \\<noteq> p2", "by auto"], ["proof (state)\nthis:\n  p1 \\<noteq> p2\n\ngoal (1 subgoal):\n 1. \\<And>p'.\n       \\<lbrakk>p' \\<in># mset_set (mset_set ` P); p' \\<noteq> p;\n        count p' x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> False", "have \"p1 = p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 = p2", "using partition_onD4 xin xin2"], ["proof (prove)\nusing this:\n  \\<lbrakk>partition_on ?A ?P; ?p \\<in> ?P; ?q \\<in> ?P; ?x \\<in> ?p;\n   ?x \\<in> ?q\\<rbrakk>\n  \\<Longrightarrow> ?p = ?q\n  x \\<in># p\n  x \\<in># p'\n\ngoal (1 subgoal):\n 1. p1 = p2", "by (metis assms(2) count_eq_zero_iff count_mset_set' p1eq p1in p2eq p2in)"], ["proof (state)\nthis:\n  p1 = p2\n\ngoal (1 subgoal):\n 1. \\<And>p'.\n       \\<lbrakk>p' \\<in># mset_set (mset_set ` P); p' \\<noteq> p;\n        count p' x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p1 = p2", "show False"], ["proof (prove)\nusing this:\n  p1 = p2\n\ngoal (1 subgoal):\n 1. False", "using origne"], ["proof (prove)\nusing this:\n  p1 = p2\n  p1 \\<noteq> p2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?p' \\<in># mset_set (mset_set ` P); ?p' \\<noteq> p\\<rbrakk>\n  \\<Longrightarrow> count ?p' x = 0\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "have one: \"count p x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count p x = 1", "using pin xin assms count_eq_zero_iff count_greater_eq_one_iff"], ["proof (prove)\nusing this:\n  p \\<in># mset_set (mset_set ` P)\n  x \\<in># p\n  finite A\n  partition_on A P\n  x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\n  (count ?M ?x = 0) = (?x \\<notin># ?M)\n  (1 \\<le> count ?M ?x) = (?x \\<in># ?M)\n\ngoal (1 subgoal):\n 1. count p x = 1", "by (metis count_mset_set(3) count_mset_set_le_one image_iff le_antisym)"], ["proof (state)\nthis:\n  count p x = 1\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "then"], ["proof (chain)\npicking this:\n  count p x = 1", "have \"count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = \n      (\\<Sum>p' \\<in># (mset_set (mset_set ` P)) . count p' x)\""], ["proof (prove)\nusing this:\n  count p x = 1\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n    (\\<Sum>p'\\<in>#mset_set (mset_set ` P). count p' x)", "using count_sum_mset"], ["proof (prove)\nusing this:\n  count p x = 1\n  count (\\<Sum>\\<^sub># ?M) ?b = (\\<Sum>P\\<in>#?M. count P ?b)\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n    (\\<Sum>p'\\<in>#mset_set (mset_set ` P). count p' x)", "by auto"], ["proof (state)\nthis:\n  count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n  (\\<Sum>p'\\<in>#mset_set (mset_set ` P). count p' x)\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "also"], ["proof (state)\nthis:\n  count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n  (\\<Sum>p'\\<in>#mset_set (mset_set ` P). count p' x)\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "have \"... = (count p x) + (\\<Sum>p' \\<in># ((mset_set (mset_set ` P)) - {#p#}) . count p' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p'\\<in>#mset_set (mset_set ` P). count p' x) =\n    count p x +\n    (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x)", "by (metis (mono_tags, lifting) insert_DiffM pin sum_mset.insert)"], ["proof (state)\nthis:\n  (\\<Sum>p'\\<in>#mset_set (mset_set ` P). count p' x) =\n  count p x +\n  (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x)\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>p'\\<in>#mset_set (mset_set ` P). count p' x) =\n  count p x +\n  (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x)\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "have \"... = 1 + (\\<Sum>p' \\<in># ((mset_set (mset_set ` P)) - {#p#}) . count p' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count p x +\n    (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x) =\n    1 + (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x)", "using one"], ["proof (prove)\nusing this:\n  count p x = 1\n\ngoal (1 subgoal):\n 1. count p x +\n    (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x) =\n    1 + (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x)", "by presburger"], ["proof (state)\nthis:\n  count p x +\n  (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x) =\n  1 + (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x)\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "finally"], ["proof (chain)\npicking this:\n  count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n  1 + (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x)", "have \"count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = \n      1 + (\\<Sum>p' \\<in># ((mset_set (mset_set ` P)) - {#p#}) . 0)\""], ["proof (prove)\nusing this:\n  count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n  1 + (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x)\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n    1 + (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). 0)", "using zero filter"], ["proof (prove)\nusing this:\n  count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n  1 + (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). count p' x)\n  \\<lbrakk>?p' \\<in># mset_set (mset_set ` P); ?p' \\<noteq> p\\<rbrakk>\n  \\<Longrightarrow> count ?p' x = 0\n  ?p' \\<in># remove1_mset p (mset_set (mset_set ` P)) \\<Longrightarrow>\n  p \\<noteq> ?p'\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n    1 + (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). 0)", "by (metis (mono_tags, lifting) in_diffD sum_over_fun_eq)"], ["proof (state)\nthis:\n  count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n  1 + (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). 0)\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "then"], ["proof (chain)\npicking this:\n  count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n  1 + (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). 0)", "show \"count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1\""], ["proof (prove)\nusing this:\n  count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x =\n  1 + (\\<Sum>p'\\<in>#remove1_mset p (mset_set (mset_set ` P)). 0)\n\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1", "by simp"], ["proof (state)\nthis:\n  count (\\<Sum>\\<^sub># (mset_set (mset_set ` P))) x = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partition_on_mset_set: \n  assumes \"finite A\"\n  assumes \"partition_on A P\"\n  shows \"partition_on_mset (mset_set A) (mset_set (image (\\<lambda> x. mset_set x) P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset (mset_set A) (mset_set (mset_set ` P))", "proof (intro partition_on_msetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Sum>\\<^sub># (mset_set (mset_set ` P)) = mset_set A\n 2. {#} \\<notin># mset_set (mset_set ` P)", "have partd1: \"\\<Union>P = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> P = A", "using assms partition_onD1"], ["proof (prove)\nusing this:\n  finite A\n  partition_on A P\n  partition_on ?A ?P \\<Longrightarrow> ?A = \\<Union> ?P\n\ngoal (1 subgoal):\n 1. \\<Union> P = A", "by auto"], ["proof (state)\nthis:\n  \\<Union> P = A\n\ngoal (2 subgoals):\n 1. \\<Sum>\\<^sub># (mset_set (mset_set ` P)) = mset_set A\n 2. {#} \\<notin># mset_set (mset_set ` P)", "have imp: \"\\<And>x. x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P)) \\<Longrightarrow> x \\<in># mset_set A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P)) \\<Longrightarrow>\n       x \\<in># mset_set A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P)) \\<Longrightarrow>\n       x \\<in># mset_set A", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P)) \\<Longrightarrow>\n       x \\<in># mset_set A", "assume \"x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\""], ["proof (state)\nthis:\n  x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P)) \\<Longrightarrow>\n       x \\<in># mset_set A", "then"], ["proof (chain)\npicking this:\n  x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))", "obtain p where \"p \\<in> (mset_set ` P)\" and xin: \"x \\<in># p\""], ["proof (prove)\nusing this:\n  x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> mset_set ` P; x \\<in># p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis elem_mset_set equals0D infinite_set_mset_mset_set mset_big_union_obtain)"], ["proof (state)\nthis:\n  p \\<in> mset_set ` P\n  x \\<in># p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P)) \\<Longrightarrow>\n       x \\<in># mset_set A", "then"], ["proof (chain)\npicking this:\n  p \\<in> mset_set ` P\n  x \\<in># p", "have \"set_mset p \\<in> P\""], ["proof (prove)\nusing this:\n  p \\<in> mset_set ` P\n  x \\<in># p\n\ngoal (1 subgoal):\n 1. set_mset p \\<in> P", "by (metis empty_iff finite_set_mset_mset_set image_iff infinite_set_mset_mset_set)"], ["proof (state)\nthis:\n  set_mset p \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P)) \\<Longrightarrow>\n       x \\<in># mset_set A", "then"], ["proof (chain)\npicking this:\n  set_mset p \\<in> P", "show \"x \\<in># mset_set A\""], ["proof (prove)\nusing this:\n  set_mset p \\<in> P\n\ngoal (1 subgoal):\n 1. x \\<in># mset_set A", "using partd1 xin assms(1)"], ["proof (prove)\nusing this:\n  set_mset p \\<in> P\n  \\<Union> P = A\n  x \\<in># p\n  finite A\n\ngoal (1 subgoal):\n 1. x \\<in># mset_set A", "by auto"], ["proof (state)\nthis:\n  x \\<in># mset_set A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P)) \\<Longrightarrow>\n  ?x \\<in># mset_set A\n\ngoal (2 subgoals):\n 1. \\<Sum>\\<^sub># (mset_set (mset_set ` P)) = mset_set A\n 2. {#} \\<notin># mset_set (mset_set ` P)", "have imp2: \"\\<And>x . x \\<in># mset_set A \\<Longrightarrow> x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_set A \\<Longrightarrow>\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_set A \\<Longrightarrow>\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_set A \\<Longrightarrow>\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))", "assume \"x \\<in># mset_set A\""], ["proof (state)\nthis:\n  x \\<in># mset_set A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_set A \\<Longrightarrow>\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))", "then"], ["proof (chain)\npicking this:\n  x \\<in># mset_set A", "have \"x \\<in> A\""], ["proof (prove)\nusing this:\n  x \\<in># mset_set A\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_set A \\<Longrightarrow>\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))", "then"], ["proof (chain)\npicking this:\n  x \\<in> A", "obtain p where \"p \\<in> P\" and \"x \\<in> p\""], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> P; x \\<in> p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  x \\<in> A\n  partition_on A P\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> P; x \\<in> p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using partd1"], ["proof (prove)\nusing this:\n  x \\<in> A\n  partition_on A P\n  \\<Union> P = A\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> P; x \\<in> p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in> P\n  x \\<in> p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_set A \\<Longrightarrow>\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))", "then"], ["proof (chain)\npicking this:\n  p \\<in> P\n  x \\<in> p", "obtain p' where \"p' \\<in> (mset_set ` P)\" and \"p' = mset_set p\""], ["proof (prove)\nusing this:\n  p \\<in> P\n  x \\<in> p\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p' \\<in> mset_set ` P; p' = mset_set p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p' \\<in> mset_set ` P\n  p' = mset_set p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_set A \\<Longrightarrow>\n       x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))", "thus \"x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\""], ["proof (prove)\nusing this:\n  p' \\<in> mset_set ` P\n  p' = mset_set p\n\ngoal (1 subgoal):\n 1. x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))", "using assms \\<open>p \\<in> P\\<close> \\<open>x \\<in> p\\<close> finite_elements partd1"], ["proof (prove)\nusing this:\n  p' \\<in> mset_set ` P\n  p' = mset_set p\n  finite A\n  partition_on A P\n  p \\<in> P\n  x \\<in> p\n  \\<lbrakk>finite ?A; partition_on ?A ?P\\<rbrakk>\n  \\<Longrightarrow> finite ?P\n  \\<Union> P = A\n\ngoal (1 subgoal):\n 1. x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))", "by (metis Sup_upper finite_imageI finite_set_mset_mset_set in_Union_mset_iff rev_finite_subset)"], ["proof (state)\nthis:\n  x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in># mset_set A \\<Longrightarrow>\n  ?x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\n\ngoal (2 subgoals):\n 1. \\<Sum>\\<^sub># (mset_set (mset_set ` P)) = mset_set A\n 2. {#} \\<notin># mset_set (mset_set ` P)", "have a1: \"\\<And> x . x \\<in># mset_set A \\<Longrightarrow> count (mset_set A) x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in># mset_set A \\<Longrightarrow> count (mset_set A) x = 1", "using assms(1)"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in># mset_set A \\<Longrightarrow> count (mset_set A) x = 1", "by fastforce"], ["proof (state)\nthis:\n  ?x \\<in># mset_set A \\<Longrightarrow> count (mset_set A) ?x = 1\n\ngoal (2 subgoals):\n 1. \\<Sum>\\<^sub># (mset_set (mset_set ` P)) = mset_set A\n 2. {#} \\<notin># mset_set (mset_set ` P)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in># mset_set A \\<Longrightarrow> count (mset_set A) ?x = 1", "show \"\\<Sum>\\<^sub># (mset_set (mset_set ` P)) = mset_set A\""], ["proof (prove)\nusing this:\n  ?x \\<in># mset_set A \\<Longrightarrow> count (mset_set A) ?x = 1\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset_set (mset_set ` P)) = mset_set A", "using imp imp2 a1"], ["proof (prove)\nusing this:\n  ?x \\<in># mset_set A \\<Longrightarrow> count (mset_set A) ?x = 1\n  ?x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P)) \\<Longrightarrow>\n  ?x \\<in># mset_set A\n  ?x \\<in># mset_set A \\<Longrightarrow>\n  ?x \\<in># \\<Sum>\\<^sub># (mset_set (mset_set ` P))\n  ?x \\<in># mset_set A \\<Longrightarrow> count (mset_set A) ?x = 1\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset_set (mset_set ` P)) = mset_set A", "by (metis assms(1) assms(2) count_eq_zero_iff multiset_eqI sigma_over_set_partition_count)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (mset_set (mset_set ` P)) = mset_set A\n\ngoal (1 subgoal):\n 1. {#} \\<notin># mset_set (mset_set ` P)", "have \"\\<And> p. p \\<in> P \\<Longrightarrow>  p \\<noteq> {} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> p \\<noteq> {}", "using assms partition_onD3"], ["proof (prove)\nusing this:\n  finite A\n  partition_on A P\n  partition_on ?A ?P \\<Longrightarrow> {} \\<notin> ?P\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> p \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  ?p \\<in> P \\<Longrightarrow> ?p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {#} \\<notin># mset_set (mset_set ` P)", "then"], ["proof (chain)\npicking this:\n  ?p \\<in> P \\<Longrightarrow> ?p \\<noteq> {}", "have \"\\<And> p. p \\<in> P \\<Longrightarrow>  mset_set p \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  ?p \\<in> P \\<Longrightarrow> ?p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> mset_set p \\<noteq> {#}", "using mset_set_empty_iff"], ["proof (prove)\nusing this:\n  ?p \\<in> P \\<Longrightarrow> ?p \\<noteq> {}\n  (mset_set ?A = {#}) = (?A = {} \\<or> infinite ?A)\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> mset_set p \\<noteq> {#}", "by (metis Union_upper assms(1) partd1 rev_finite_subset)"], ["proof (state)\nthis:\n  ?p \\<in> P \\<Longrightarrow> mset_set ?p \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. {#} \\<notin># mset_set (mset_set ` P)", "then"], ["proof (chain)\npicking this:\n  ?p \\<in> P \\<Longrightarrow> mset_set ?p \\<noteq> {#}", "show \"{#} \\<notin># mset_set (mset_set ` P)\""], ["proof (prove)\nusing this:\n  ?p \\<in> P \\<Longrightarrow> mset_set ?p \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. {#} \\<notin># mset_set (mset_set ` P)", "by (metis elem_mset_set equals0D image_iff infinite_set_mset_mset_set)"], ["proof (state)\nthis:\n  {#} \\<notin># mset_set (mset_set ` P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partition_on_mset_distinct_inter: \n  assumes \"partition_on_mset A P\"\n  assumes \"distinct_mset A\"\n  assumes \"p1 \\<in># P\" and \"p2 \\<in># P\" and \"p1 \\<noteq> p2\"\n  shows \"p1 \\<inter># p2 = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<inter># p2 = {#}", "by (metis assms in_remove1_mset_neq partition_on_mset_distinct_disjoint)"], ["", "lemma partition_on_set_mset_distinct: \n  assumes \"partition_on_mset A P\"\n  assumes \"distinct_mset A\"\n  assumes \"p \\<in># image_mset set_mset P\" \n  assumes \"p' \\<in># image_mset set_mset P\"\n  assumes \"p \\<noteq> p'\"\n  shows \"p \\<inter> p' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<inter> p' = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<inter> p' = {}", "obtain p1 where p1in: \"p1 \\<in># P\" and p1eq: \"set_mset p1 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1.\n        \\<lbrakk>p1 \\<in># P; set_mset p1 = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  p \\<in># image_mset set_mset P\n\ngoal (1 subgoal):\n 1. (\\<And>p1.\n        \\<lbrakk>p1 \\<in># P; set_mset p1 = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p1 \\<in># P\n  set_mset p1 = p\n\ngoal (1 subgoal):\n 1. p \\<inter> p' = {}", "obtain p2 where p2in: \"p2 \\<in># P\" and p2eq: \"set_mset p2 = p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2.\n        \\<lbrakk>p2 \\<in># P; set_mset p2 = p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(4)"], ["proof (prove)\nusing this:\n  p' \\<in># image_mset set_mset P\n\ngoal (1 subgoal):\n 1. (\\<And>p2.\n        \\<lbrakk>p2 \\<in># P; set_mset p2 = p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p2 \\<in># P\n  set_mset p2 = p'\n\ngoal (1 subgoal):\n 1. p \\<inter> p' = {}", "have \"distinct_mset P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset P", "using assms partition_on_mset_distinct"], ["proof (prove)\nusing this:\n  partition_on_mset A P\n  distinct_mset A\n  p \\<in># image_mset set_mset P\n  p' \\<in># image_mset set_mset P\n  p \\<noteq> p'\n  \\<lbrakk>partition_on_mset ?A ?P; distinct_mset ?A\\<rbrakk>\n  \\<Longrightarrow> distinct_mset ?P\n\ngoal (1 subgoal):\n 1. distinct_mset P", "by blast"], ["proof (state)\nthis:\n  distinct_mset P\n\ngoal (1 subgoal):\n 1. p \\<inter> p' = {}", "then"], ["proof (chain)\npicking this:\n  distinct_mset P", "have \"p1 \\<noteq> p2\""], ["proof (prove)\nusing this:\n  distinct_mset P\n\ngoal (1 subgoal):\n 1. p1 \\<noteq> p2", "using assms"], ["proof (prove)\nusing this:\n  distinct_mset P\n  partition_on_mset A P\n  distinct_mset A\n  p \\<in># image_mset set_mset P\n  p' \\<in># image_mset set_mset P\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. p1 \\<noteq> p2", "using p1eq p2eq"], ["proof (prove)\nusing this:\n  distinct_mset P\n  partition_on_mset A P\n  distinct_mset A\n  p \\<in># image_mset set_mset P\n  p' \\<in># image_mset set_mset P\n  p \\<noteq> p'\n  set_mset p1 = p\n  set_mset p2 = p'\n\ngoal (1 subgoal):\n 1. p1 \\<noteq> p2", "by fastforce"], ["proof (state)\nthis:\n  p1 \\<noteq> p2\n\ngoal (1 subgoal):\n 1. p \\<inter> p' = {}", "then"], ["proof (chain)\npicking this:\n  p1 \\<noteq> p2", "have \"p1 \\<inter># p2 = {#}\""], ["proof (prove)\nusing this:\n  p1 \\<noteq> p2\n\ngoal (1 subgoal):\n 1. p1 \\<inter># p2 = {#}", "using partition_on_mset_distinct_inter"], ["proof (prove)\nusing this:\n  p1 \\<noteq> p2\n  \\<lbrakk>partition_on_mset ?A ?P; distinct_mset ?A; ?p1.0 \\<in># ?P;\n   ?p2.0 \\<in># ?P; ?p1.0 \\<noteq> ?p2.0\\<rbrakk>\n  \\<Longrightarrow> ?p1.0 \\<inter># ?p2.0 = {#}\n\ngoal (1 subgoal):\n 1. p1 \\<inter># p2 = {#}", "using assms(1) assms(2) p1in p2in"], ["proof (prove)\nusing this:\n  p1 \\<noteq> p2\n  \\<lbrakk>partition_on_mset ?A ?P; distinct_mset ?A; ?p1.0 \\<in># ?P;\n   ?p2.0 \\<in># ?P; ?p1.0 \\<noteq> ?p2.0\\<rbrakk>\n  \\<Longrightarrow> ?p1.0 \\<inter># ?p2.0 = {#}\n  partition_on_mset A P\n  distinct_mset A\n  p1 \\<in># P\n  p2 \\<in># P\n\ngoal (1 subgoal):\n 1. p1 \\<inter># p2 = {#}", "by auto"], ["proof (state)\nthis:\n  p1 \\<inter># p2 = {#}\n\ngoal (1 subgoal):\n 1. p \\<inter> p' = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  p1 \\<inter># p2 = {#}\n\ngoal (1 subgoal):\n 1. p \\<inter> p' = {}", "using p1eq p2eq"], ["proof (prove)\nusing this:\n  p1 \\<inter># p2 = {#}\n  set_mset p1 = p\n  set_mset p2 = p'\n\ngoal (1 subgoal):\n 1. p \\<inter> p' = {}", "by (metis set_mset_empty set_mset_inter)"], ["proof (state)\nthis:\n  p \\<inter> p' = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partition_on_set_mset:\n  assumes \"partition_on_mset A P\"\n  assumes \"distinct_mset A\"\n  shows \"partition_on (set_mset A) (set_mset (image_mset set_mset P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on (set_mset A) (set_mset (image_mset set_mset P))", "proof (intro partition_onI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p. p \\<in># image_mset set_mset P \\<Longrightarrow> p \\<noteq> {}\n 2. \\<Union> (set_mset (image_mset set_mset P)) = set_mset A\n 3. \\<And>p p'.\n       \\<lbrakk>p \\<in># image_mset set_mset P;\n        p' \\<in># image_mset set_mset P; p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "show \"\\<And>p. p \\<in># image_mset set_mset P \\<Longrightarrow> p \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in># image_mset set_mset P \\<Longrightarrow> p \\<noteq> {}", "using assms(1) partition_on_msetD2"], ["proof (prove)\nusing this:\n  partition_on_mset A P\n  partition_on_mset ?A ?P \\<Longrightarrow> {#} \\<notin># ?P\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in># image_mset set_mset P \\<Longrightarrow> p \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  ?p \\<in># image_mset set_mset P \\<Longrightarrow> ?p \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<Union> (set_mset (image_mset set_mset P)) = set_mset A\n 2. \\<And>p p'.\n       \\<lbrakk>p \\<in># image_mset set_mset P;\n        p' \\<in># image_mset set_mset P; p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Union> (set_mset (image_mset set_mset P)) = set_mset A\n 2. \\<And>p p'.\n       \\<lbrakk>p \\<in># image_mset set_mset P;\n        p' \\<in># image_mset set_mset P; p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "have \"\\<And> x . x \\<in> set_mset A \\<Longrightarrow> x \\<in> \\<Union> (set_mset (image_mset set_mset P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># A \\<Longrightarrow>\n       x \\<in> \\<Union> (set_mset (image_mset set_mset P))", "by (metis Union_iff assms(1) image_eqI mset_big_union_obtain partition_on_msetD1 set_image_mset)"], ["proof (state)\nthis:\n  ?x \\<in># A \\<Longrightarrow>\n  ?x \\<in> \\<Union> (set_mset (image_mset set_mset P))\n\ngoal (2 subgoals):\n 1. \\<Union> (set_mset (image_mset set_mset P)) = set_mset A\n 2. \\<And>p p'.\n       \\<lbrakk>p \\<in># image_mset set_mset P;\n        p' \\<in># image_mset set_mset P; p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "then"], ["proof (chain)\npicking this:\n  ?x \\<in># A \\<Longrightarrow>\n  ?x \\<in> \\<Union> (set_mset (image_mset set_mset P))", "show \"\\<Union> (set_mset (image_mset set_mset P)) = set_mset A\""], ["proof (prove)\nusing this:\n  ?x \\<in># A \\<Longrightarrow>\n  ?x \\<in> \\<Union> (set_mset (image_mset set_mset P))\n\ngoal (1 subgoal):\n 1. \\<Union> (set_mset (image_mset set_mset P)) = set_mset A", "using set_eqI' partition_on_mset_elems assms"], ["proof (prove)\nusing this:\n  ?x \\<in># A \\<Longrightarrow>\n  ?x \\<in> \\<Union> (set_mset (image_mset set_mset P))\n  \\<lbrakk>\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<in> ?B;\n   \\<And>x. x \\<in> ?B \\<Longrightarrow> x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?A = ?B\n  \\<lbrakk>partition_on_mset ?A ?P; ?p1.0 \\<in># ?P;\n   ?x \\<in># ?p1.0\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in># ?A\n  partition_on_mset A P\n  distinct_mset A\n\ngoal (1 subgoal):\n 1. \\<Union> (set_mset (image_mset set_mset P)) = set_mset A", "by auto"], ["proof (state)\nthis:\n  \\<Union> (set_mset (image_mset set_mset P)) = set_mset A\n\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in># image_mset set_mset P;\n        p' \\<in># image_mset set_mset P; p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "show \"\\<And>p p'. p \\<in># image_mset set_mset P \\<Longrightarrow> p' \\<in># image_mset set_mset P \\<Longrightarrow> \n      p \\<noteq> p' \\<Longrightarrow> p \\<inter> p' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in># image_mset set_mset P;\n        p' \\<in># image_mset set_mset P; p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "using partition_on_set_mset_distinct assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>partition_on_mset ?A ?P; distinct_mset ?A;\n   ?p \\<in># image_mset set_mset ?P; ?p' \\<in># image_mset set_mset ?P;\n   ?p \\<noteq> ?p'\\<rbrakk>\n  \\<Longrightarrow> ?p \\<inter> ?p' = {}\n  partition_on_mset A P\n  distinct_mset A\n\ngoal (1 subgoal):\n 1. \\<And>p p'.\n       \\<lbrakk>p \\<in># image_mset set_mset P;\n        p' \\<in># image_mset set_mset P; p \\<noteq> p'\\<rbrakk>\n       \\<Longrightarrow> p \\<inter> p' = {}", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?p \\<in># image_mset set_mset P;\n   ?p' \\<in># image_mset set_mset P; ?p \\<noteq> ?p'\\<rbrakk>\n  \\<Longrightarrow> ?p \\<inter> ?p' = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partition_on_mset_eq_imp_eq_carrier:\n  assumes \"partition_on_mset A P\"\n  assumes \"partition_on_mset B P\"\n  shows \"A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "using assms partition_on_msetD1"], ["proof (prove)\nusing this:\n  partition_on_mset A P\n  partition_on_mset B P\n  partition_on_mset ?A ?P \\<Longrightarrow> \\<Sum>\\<^sub># ?P = ?A\n\ngoal (1 subgoal):\n 1. A = B", "by auto"], ["", "lemma partition_on_mset_add_single:\n  assumes \"partition_on_mset A P\"\n  shows \"partition_on_mset (add_mset a A) (add_mset {#a#} P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset (add_mset a A) (add_mset {#a#} P)", "using assms"], ["proof (prove)\nusing this:\n  partition_on_mset A P\n\ngoal (1 subgoal):\n 1. partition_on_mset (add_mset a A) (add_mset {#a#} P)", "by (auto simp: partition_on_mset_def)"], ["", "lemma partition_on_mset_add_part:\n  assumes \"partition_on_mset A P\"\n  assumes \"X \\<noteq> {#}\"\n  assumes \"A + X = A'\"\n  shows \"partition_on_mset A' (add_mset X P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset A' (add_mset X P)", "using assms"], ["proof (prove)\nusing this:\n  partition_on_mset A P\n  X \\<noteq> {#}\n  A + X = A'\n\ngoal (1 subgoal):\n 1. partition_on_mset A' (add_mset X P)", "by (auto simp: partition_on_mset_def)"], ["", "lemma partition_on_mset_add:\n  assumes \"partition_on_mset A P\"\n  assumes \"X \\<in># P\"\n  assumes \"add_mset a X = X'\"\n  shows \"partition_on_mset (add_mset a A) (add_mset X' (P - {#X#}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset (add_mset a A) (add_mset X' (remove1_mset X P))", "using add_mset_add_single assms empty_not_add_mset mset_subset_eq_single partition_on_mset_all"], ["proof (prove)\nusing this:\n  add_mset ?a ?A = ?A + {#?a#}\n  partition_on_mset A P\n  X \\<in># P\n  add_mset a X = X'\n  {#} \\<noteq> add_mset ?a ?A\n  ?a \\<in># ?B \\<Longrightarrow> {#?a#} \\<subseteq># ?B\n  ?A \\<noteq> {#} \\<Longrightarrow> partition_on_mset ?A {#?A#}\n\ngoal (1 subgoal):\n 1. partition_on_mset (add_mset a A) (add_mset X' (remove1_mset X P))", "by (smt partition_on_mset_def subset_mset.add_diff_inverse sum_mset.add_mset sum_mset.remove union_iff union_mset_add_mset_left)"], ["", "lemma partition_on_mset_elem_exists_part:\n  assumes \"partition_on_mset A P\"\n  assumes \"x \\<in># A\" \n  obtains p where \"p \\<in># P\" and \"x \\<in># p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in># P; x \\<in># p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms in_Union_mset_iff partition_on_msetD2 partition_on_msetI"], ["proof (prove)\nusing this:\n  partition_on_mset A P\n  x \\<in># A\n  (?x \\<in># \\<Sum>\\<^sub># ?MM) =\n  (\\<exists>M. M \\<in># ?MM \\<and> ?x \\<in># M)\n  partition_on_mset ?A ?P \\<Longrightarrow> {#} \\<notin># ?P\n  \\<lbrakk>\\<Sum>\\<^sub># ?P = ?A; {#} \\<notin># ?P\\<rbrakk>\n  \\<Longrightarrow> partition_on_mset ?A ?P\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in># P; x \\<in># p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis partition_on_mset_eq_imp_eq_carrier)"], ["", "lemma partition_on_mset_combine: \n  assumes \"partition_on_mset A P\"\n  assumes \"partition_on_mset B Q\"\n  shows \"partition_on_mset (A + B) (P + Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset (A + B) (P + Q)", "unfolding partition_on_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (P + Q) = A + B \\<and> {#} \\<notin># P + Q", "using assms partition_on_msetD1 partition_on_msetD2"], ["proof (prove)\nusing this:\n  partition_on_mset A P\n  partition_on_mset B Q\n  partition_on_mset ?A ?P \\<Longrightarrow> \\<Sum>\\<^sub># ?P = ?A\n  partition_on_mset ?A ?P \\<Longrightarrow> {#} \\<notin># ?P\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (P + Q) = A + B \\<and> {#} \\<notin># P + Q", "by auto"], ["", "lemma partition_on_mset_split: \n  assumes \"partition_on_mset A (P + Q)\"\n  shows \"partition_on_mset (\\<Sum>\\<^sub>#P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset (\\<Sum>\\<^sub># P) P", "using  partition_on_mset_def partition_on_msetD2 assms"], ["proof (prove)\nusing this:\n  partition_on_mset ?A ?P = (\\<Sum>\\<^sub># ?P = ?A \\<and> {#} \\<notin># ?P)\n  partition_on_mset ?A ?P \\<Longrightarrow> {#} \\<notin># ?P\n  partition_on_mset A (P + Q)\n\ngoal (1 subgoal):\n 1. partition_on_mset (\\<Sum>\\<^sub># P) P", "by fastforce"], ["", "end"]]}