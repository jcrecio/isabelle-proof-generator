{"file_name": "/home/qj213/afp-2021-10-22/thys/Design_Theory/Resolvable_Designs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Design_Theory", "problem_names": ["lemma resolution_classI [intro]: \"partition_on \\<V>  S \\<Longrightarrow> (\\<And> bl . bl \\<in> S \\<Longrightarrow> bl \\<in># \\<B>) \n    \\<Longrightarrow> resolution_class S\"", "lemma resolution_classD1: \"resolution_class S \\<Longrightarrow> partition_on \\<V> S\"", "lemma resolution_classD2: \"resolution_class S \\<Longrightarrow>  bl \\<in> S \\<Longrightarrow> bl \\<in># \\<B>\"", "lemma resolution_class_empty_iff: \"resolution_class {} \\<longleftrightarrow> \\<V>  = {}\"", "lemma resolution_class_complete: \"\\<V>  \\<noteq> {} \\<Longrightarrow> \\<V>  \\<in># \\<B> \\<Longrightarrow> resolution_class {\\<V>}\"", "lemma resolution_class_union: \"resolution_class S \\<Longrightarrow> \\<Union>S = \\<V> \"", "lemma (in finite_incidence_system) resolution_class_finite: \"resolution_class S \\<Longrightarrow> finite S\"", "lemma (in design) resolution_class_sum_card: \"resolution_class S \\<Longrightarrow> (\\<Sum>bl \\<in> S . card bl) = \\<v>\"", "lemma resolutionI : \"partition_on_mset \\<B> P \\<Longrightarrow> (\\<And> S . S \\<in>#P \\<Longrightarrow> distinct_mset S) \\<Longrightarrow> \n    (\\<And> S . S\\<in># P \\<Longrightarrow> resolution_class (set_mset S)) \\<Longrightarrow> resolution P\"", "lemma (in proper_design) resolution_blocks: \"distinct_mset \\<B> \\<Longrightarrow> disjoint (set_mset \\<B>) \\<Longrightarrow> \n    \\<Union>(set_mset \\<B>) = \\<V> \\<Longrightarrow> resolution {#\\<B>#}\"", "lemma resolutionD1: \"partition_on_mset \\<B> \\<P>\"", "lemma resolutionD2: \"S \\<in>#\\<P> \\<Longrightarrow> distinct_mset S\"", "lemma resolutionD3: \" S\\<in># \\<P> \\<Longrightarrow> resolution_class (set_mset S)\"", "lemma resolution_class_blocks_disjoint: \"S \\<in># \\<P> \\<Longrightarrow> disjoint (set_mset S)\"", "lemma resolution_not_empty: \"\\<B> \\<noteq> {#} \\<Longrightarrow> \\<P> \\<noteq> {#}\"", "lemma resolution_blocks_subset: \"S \\<in># \\<P> \\<Longrightarrow> S \\<subseteq># \\<B>\"", "lemma (in incidence_system) resolvable_designI [intro]: \"resolution \\<P> \\<Longrightarrow> design \\<V> \\<B> \\<Longrightarrow> \n    resolvable_design \\<V> \\<B> \\<P>\"", "lemma resolution_class_blocks_constant_size: \"S \\<in># \\<P> \\<Longrightarrow> bl \\<in># S \\<Longrightarrow> card bl = \\<k>\"", "lemma resolution_class_size1: \n  assumes \"S \\<in># \\<P>\"\n  shows \"\\<v> = \\<k> * size S\"", "lemma resolution_class_size2: \n  assumes \"S \\<in># \\<P>\"\n  shows \"size S = \\<v> div \\<k>\"", "lemma resolvable_necessary_cond_v: \"\\<k> dvd \\<v>\"", "lemma resolvable_design_num_res_classes: \"size \\<P> = \\<r>\"", "lemma resolvable_necessary_cond_b: \"\\<r> dvd \\<b>\"", "theorem bose_inequality_alternate: \"\\<b> \\<ge> \\<v> + \\<r> - 1 \\<longleftrightarrow> \\<r> \\<ge> \\<k> + \\<Lambda>\""], "translations": [["", "lemma resolution_classI [intro]: \"partition_on \\<V>  S \\<Longrightarrow> (\\<And> bl . bl \\<in> S \\<Longrightarrow> bl \\<in># \\<B>) \n    \\<Longrightarrow> resolution_class S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>partition_on \\<V> S;\n     \\<And>bl. bl \\<in> S \\<Longrightarrow> bl \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> resolution_class S", "by (simp add: resolution_class_def)"], ["", "lemma resolution_classD1: \"resolution_class S \\<Longrightarrow> partition_on \\<V> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_class S \\<Longrightarrow> partition_on \\<V> S", "by (simp add: resolution_class_def)"], ["", "lemma resolution_classD2: \"resolution_class S \\<Longrightarrow>  bl \\<in> S \\<Longrightarrow> bl \\<in># \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>resolution_class S; bl \\<in> S\\<rbrakk>\n    \\<Longrightarrow> bl \\<in># \\<B>", "by (simp add: resolution_class_def)"], ["", "lemma resolution_class_empty_iff: \"resolution_class {} \\<longleftrightarrow> \\<V>  = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_class {} = (\\<V> = {})", "by (auto simp add: resolution_class_def partition_on_def)"], ["", "lemma resolution_class_complete: \"\\<V>  \\<noteq> {} \\<Longrightarrow> \\<V>  \\<in># \\<B> \\<Longrightarrow> resolution_class {\\<V>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<V> \\<noteq> {}; \\<V> \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> resolution_class {\\<V>}", "by (auto simp add: resolution_class_def partition_on_space)"], ["", "lemma resolution_class_union: \"resolution_class S \\<Longrightarrow> \\<Union>S = \\<V> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_class S \\<Longrightarrow> \\<Union> S = \\<V>", "by (simp add: resolution_class_def partition_on_def)"], ["", "lemma (in finite_incidence_system) resolution_class_finite: \"resolution_class S \\<Longrightarrow> finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_class S \\<Longrightarrow> finite S", "using finite_elements finite_sets"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; partition_on ?A ?P\\<rbrakk>\n  \\<Longrightarrow> finite ?P\n  finite \\<V>\n\ngoal (1 subgoal):\n 1. resolution_class S \\<Longrightarrow> finite S", "by (auto simp add: resolution_class_def)"], ["", "lemma (in design) resolution_class_sum_card: \"resolution_class S \\<Longrightarrow> (\\<Sum>bl \\<in> S . card bl) = \\<v>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_class S \\<Longrightarrow> int (sum card S) = \\<v>", "using resolution_class_union finite_blocks"], ["proof (prove)\nusing this:\n  resolution_class ?S \\<Longrightarrow> \\<Union> ?S = \\<V>\n  ?b \\<in># \\<B> \\<Longrightarrow> finite ?b\n\ngoal (1 subgoal):\n 1. resolution_class S \\<Longrightarrow> int (sum card S) = \\<v>", "by (auto simp add: resolution_class_def partition_on_def card_Union_disjoint)"], ["", "definition resolution:: \"'a set multiset multiset \\<Rightarrow> bool\" where\n\"resolution P \\<longleftrightarrow> partition_on_mset \\<B> P \\<and> (\\<forall> S \\<in># P . distinct_mset S \\<and> resolution_class (set_mset S))\""], ["", "lemma resolutionI : \"partition_on_mset \\<B> P \\<Longrightarrow> (\\<And> S . S \\<in>#P \\<Longrightarrow> distinct_mset S) \\<Longrightarrow> \n    (\\<And> S . S\\<in># P \\<Longrightarrow> resolution_class (set_mset S)) \\<Longrightarrow> resolution P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>partition_on_mset \\<B> P;\n     \\<And>S. S \\<in># P \\<Longrightarrow> distinct_mset S;\n     \\<And>S.\n        S \\<in># P \\<Longrightarrow> resolution_class (set_mset S)\\<rbrakk>\n    \\<Longrightarrow> resolution P", "by (simp add: resolution_def)"], ["", "lemma (in proper_design) resolution_blocks: \"distinct_mset \\<B> \\<Longrightarrow> disjoint (set_mset \\<B>) \\<Longrightarrow> \n    \\<Union>(set_mset \\<B>) = \\<V> \\<Longrightarrow> resolution {#\\<B>#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct_mset \\<B>; disjoint (set_mset \\<B>);\n     \\<Union> (set_mset \\<B>) = \\<V>\\<rbrakk>\n    \\<Longrightarrow> resolution {#\\<B>#}", "unfolding resolution_def resolution_class_def partition_on_mset_def partition_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct_mset \\<B>; disjoint (set_mset \\<B>);\n     \\<Union> (set_mset \\<B>) = \\<V>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sub># {#\\<B>#} = \\<B> \\<and>\n                       {#} \\<notin># {#\\<B>#}) \\<and>\n                      (\\<forall>S\\<in>#{#\\<B>#}.\n                          distinct_mset S \\<and>\n                          (\\<Union> (set_mset S) = \\<V> \\<and>\n                           disjoint (set_mset S) \\<and>\n                           {} \\<notin># S) \\<and>\n                          (\\<forall>bl\\<in>#S. bl \\<in># \\<B>))", "using design_blocks_nempty blocks_nempty"], ["proof (prove)\nusing this:\n  \\<B> \\<noteq> {#}\n  ?bl \\<in># \\<B> \\<Longrightarrow> ?bl \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct_mset \\<B>; disjoint (set_mset \\<B>);\n     \\<Union> (set_mset \\<B>) = \\<V>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^sub># {#\\<B>#} = \\<B> \\<and>\n                       {#} \\<notin># {#\\<B>#}) \\<and>\n                      (\\<forall>S\\<in>#{#\\<B>#}.\n                          distinct_mset S \\<and>\n                          (\\<Union> (set_mset S) = \\<V> \\<and>\n                           disjoint (set_mset S) \\<and>\n                           {} \\<notin># S) \\<and>\n                          (\\<forall>bl\\<in>#S. bl \\<in># \\<B>))", "by auto"], ["", "end"], ["", "subsection \\<open>Resolvable Design Locale\\<close>"], ["", "text \\<open>A resolvable design is one with a resolution P\\<close>"], ["", "locale resolvable_design = design + \n  fixes partition :: \"'a set multiset multiset\" (\"\\<P>\")\n  assumes resolvable: \"resolution \\<P>\"\nbegin"], ["", "lemma resolutionD1: \"partition_on_mset \\<B> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on_mset \\<B> \\<P>", "using resolvable"], ["proof (prove)\nusing this:\n  resolution \\<P>\n\ngoal (1 subgoal):\n 1. partition_on_mset \\<B> \\<P>", "by (simp add: resolution_def)"], ["", "lemma resolutionD2: \"S \\<in>#\\<P> \\<Longrightarrow> distinct_mset S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in># \\<P> \\<Longrightarrow> distinct_mset S", "using resolvable"], ["proof (prove)\nusing this:\n  resolution \\<P>\n\ngoal (1 subgoal):\n 1. S \\<in># \\<P> \\<Longrightarrow> distinct_mset S", "by (simp  add: resolution_def)"], ["", "lemma resolutionD3: \" S\\<in># \\<P> \\<Longrightarrow> resolution_class (set_mset S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in># \\<P> \\<Longrightarrow> resolution_class (set_mset S)", "using resolvable"], ["proof (prove)\nusing this:\n  resolution \\<P>\n\ngoal (1 subgoal):\n 1. S \\<in># \\<P> \\<Longrightarrow> resolution_class (set_mset S)", "by (simp add: resolution_def)"], ["", "lemma resolution_class_blocks_disjoint: \"S \\<in># \\<P> \\<Longrightarrow> disjoint (set_mset S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in># \\<P> \\<Longrightarrow> disjoint (set_mset S)", "using resolutionD3"], ["proof (prove)\nusing this:\n  ?S \\<in># \\<P> \\<Longrightarrow> resolution_class (set_mset ?S)\n\ngoal (1 subgoal):\n 1. S \\<in># \\<P> \\<Longrightarrow> disjoint (set_mset S)", "by (simp add: partition_on_def resolution_class_def)"], ["", "lemma resolution_not_empty: \"\\<B> \\<noteq> {#} \\<Longrightarrow> \\<P> \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> \\<noteq> {#} \\<Longrightarrow> \\<P> \\<noteq> {#}", "using partition_on_mset_not_empty resolutionD1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<noteq> {#}; partition_on_mset ?A ?P\\<rbrakk>\n  \\<Longrightarrow> ?P \\<noteq> {#}\n  partition_on_mset \\<B> \\<P>\n\ngoal (1 subgoal):\n 1. \\<B> \\<noteq> {#} \\<Longrightarrow> \\<P> \\<noteq> {#}", "by auto"], ["", "lemma resolution_blocks_subset: \"S \\<in># \\<P> \\<Longrightarrow> S \\<subseteq># \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in># \\<P> \\<Longrightarrow> S \\<subseteq># \\<B>", "using partition_on_mset_subsets resolutionD1"], ["proof (prove)\nusing this:\n  \\<lbrakk>partition_on_mset ?A ?P; ?x \\<in># ?P\\<rbrakk>\n  \\<Longrightarrow> ?x \\<subseteq># ?A\n  partition_on_mset \\<B> \\<P>\n\ngoal (1 subgoal):\n 1. S \\<in># \\<P> \\<Longrightarrow> S \\<subseteq># \\<B>", "by auto"], ["", "end"], ["", "lemma (in incidence_system) resolvable_designI [intro]: \"resolution \\<P> \\<Longrightarrow> design \\<V> \\<B> \\<Longrightarrow> \n    resolvable_design \\<V> \\<B> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>resolution \\<P>; design \\<V> \\<B>\\<rbrakk>\n    \\<Longrightarrow> resolvable_design \\<V> \\<B> \\<P>", "by (simp add: resolvable_design.intro resolvable_design_axioms.intro)"], ["", "subsection \\<open>Resolvable Block Designs\\<close>"], ["", "text \\<open>An RBIBD is a resolvable BIBD - a common subclass of interest for block designs\\<close>"], ["", "locale r_block_design = resolvable_design + block_design\nbegin"], ["", "lemma resolution_class_blocks_constant_size: \"S \\<in># \\<P> \\<Longrightarrow> bl \\<in># S \\<Longrightarrow> card bl = \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<in># \\<P>; bl \\<in># S\\<rbrakk>\n    \\<Longrightarrow> int (card bl) = \\<k>", "by (metis resolutionD3 resolution_classD2 uniform_alt_def_all)"], ["", "lemma resolution_class_size1: \n  assumes \"S \\<in># \\<P>\"\n  shows \"\\<v> = \\<k> * size S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<v> = \\<k> * int (size S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<v> = \\<k> * int (size S)", "have \"(\\<Sum>bl \\<in># S . card bl) = (\\<Sum>bl \\<in> (set_mset S) . card bl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset card S) = sum card (set_mset S)", "using resolutionD2 assms"], ["proof (prove)\nusing this:\n  ?S \\<in># \\<P> \\<Longrightarrow> distinct_mset ?S\n  S \\<in># \\<P>\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset card S) = sum card (set_mset S)", "by (simp add:  sum_unfold_sum_mset)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset card S) = sum card (set_mset S)\n\ngoal (1 subgoal):\n 1. \\<v> = \\<k> * int (size S)", "then"], ["proof (chain)\npicking this:\n  \\<Sum>\\<^sub># (image_mset card S) = sum card (set_mset S)", "have eqv: \"(\\<Sum>bl \\<in># S . card bl) = \\<v>\""], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (image_mset card S) = sum card (set_mset S)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>\\<^sub># (image_mset card S)) = \\<v>", "using resolutionD3 assms resolution_class_sum_card"], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (image_mset card S) = sum card (set_mset S)\n  ?S \\<in># \\<P> \\<Longrightarrow> resolution_class (set_mset ?S)\n  S \\<in># \\<P>\n  resolution_class ?S \\<Longrightarrow> int (sum card ?S) = \\<v>\n\ngoal (1 subgoal):\n 1. int (\\<Sum>\\<^sub># (image_mset card S)) = \\<v>", "by presburger"], ["proof (state)\nthis:\n  int (\\<Sum>\\<^sub># (image_mset card S)) = \\<v>\n\ngoal (1 subgoal):\n 1. \\<v> = \\<k> * int (size S)", "have \"(\\<Sum>bl \\<in># S . card bl) = (\\<Sum>bl \\<in># S . \\<k>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<Sum>\\<^sub># (image_mset card S)) = (\\<Sum>bl\\<in>#S. \\<k>)", "using resolution_class_blocks_constant_size assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<in># \\<P>; ?bl \\<in># ?S\\<rbrakk>\n  \\<Longrightarrow> int (card ?bl) = \\<k>\n  S \\<in># \\<P>\n\ngoal (1 subgoal):\n 1. int (\\<Sum>\\<^sub># (image_mset card S)) = (\\<Sum>bl\\<in>#S. \\<k>)", "by auto"], ["proof (state)\nthis:\n  int (\\<Sum>\\<^sub># (image_mset card S)) = (\\<Sum>bl\\<in>#S. \\<k>)\n\ngoal (1 subgoal):\n 1. \\<v> = \\<k> * int (size S)", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (\\<Sum>\\<^sub># (image_mset card S)) = (\\<Sum>bl\\<in>#S. \\<k>)\n\ngoal (1 subgoal):\n 1. \\<v> = \\<k> * int (size S)", "using eqv"], ["proof (prove)\nusing this:\n  int (\\<Sum>\\<^sub># (image_mset card S)) = (\\<Sum>bl\\<in>#S. \\<k>)\n  int (\\<Sum>\\<^sub># (image_mset card S)) = \\<v>\n\ngoal (1 subgoal):\n 1. \\<v> = \\<k> * int (size S)", "by (metis mult.commute sum_mset_constant)"], ["proof (state)\nthis:\n  \\<v> = \\<k> * int (size S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resolution_class_size2: \n  assumes \"S \\<in># \\<P>\"\n  shows \"size S = \\<v> div \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size S) = \\<v> div \\<k>", "using resolution_class_size1 assms"], ["proof (prove)\nusing this:\n  ?S \\<in># \\<P> \\<Longrightarrow> \\<v> = \\<k> * int (size ?S)\n  S \\<in># \\<P>\n\ngoal (1 subgoal):\n 1. int (size S) = \\<v> div \\<k>", "by (metis nonzero_mult_div_cancel_left not_one_le_zero k_non_zero)"], ["", "lemma resolvable_necessary_cond_v: \"\\<k> dvd \\<v>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<k> dvd \\<v>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<k> dvd \\<v>", "obtain S where s_in: \"S \\<in>#\\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S. S \\<in># \\<P> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using resolution_not_empty design_blocks_nempty"], ["proof (prove)\nusing this:\n  \\<B> \\<noteq> {#} \\<Longrightarrow> \\<P> \\<noteq> {#}\n  \\<B> \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (\\<And>S. S \\<in># \\<P> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S \\<in># \\<P>\n\ngoal (1 subgoal):\n 1. \\<k> dvd \\<v>", "then"], ["proof (chain)\npicking this:\n  S \\<in># \\<P>", "have \"\\<k> * size S = \\<v>\""], ["proof (prove)\nusing this:\n  S \\<in># \\<P>\n\ngoal (1 subgoal):\n 1. \\<k> * int (size S) = \\<v>", "using resolution_class_size1"], ["proof (prove)\nusing this:\n  S \\<in># \\<P>\n  ?S \\<in># \\<P> \\<Longrightarrow> \\<v> = \\<k> * int (size ?S)\n\ngoal (1 subgoal):\n 1. \\<k> * int (size S) = \\<v>", "by simp"], ["proof (state)\nthis:\n  \\<k> * int (size S) = \\<v>\n\ngoal (1 subgoal):\n 1. \\<k> dvd \\<v>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<k> * int (size S) = \\<v>\n\ngoal (1 subgoal):\n 1. \\<k> dvd \\<v>", "by (metis dvd_triv_left)"], ["proof (state)\nthis:\n  \\<k> dvd \\<v>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale rbibd = r_block_design + bibd\n \nbegin"], ["", "lemma resolvable_design_num_res_classes: \"size \\<P> = \\<r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "have k_ne0: \"\\<k> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<k> \\<noteq> 0", "using k_non_zero"], ["proof (prove)\nusing this:\n  1 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. \\<k> \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<k> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "have f1: \"\\<b> = (\\<Sum>S \\<in># \\<P> . size S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))", "by (metis partition_on_msetD1 resolutionD1 size_big_union_sum)"], ["proof (state)\nthis:\n  \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "then"], ["proof (chain)\npicking this:\n  \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))", "have \"\\<b> = (\\<Sum>S \\<in># \\<P> . \\<v> div \\<k>)\""], ["proof (prove)\nusing this:\n  \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))\n\ngoal (1 subgoal):\n 1. \\<b> = (\\<Sum>S\\<in>#\\<P>. \\<v> div \\<k>)", "using resolution_class_size2 f1"], ["proof (prove)\nusing this:\n  \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))\n  ?S \\<in># \\<P> \\<Longrightarrow> int (size ?S) = \\<v> div \\<k>\n  \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))\n\ngoal (1 subgoal):\n 1. \\<b> = (\\<Sum>S\\<in>#\\<P>. \\<v> div \\<k>)", "by auto"], ["proof (state)\nthis:\n  \\<b> = (\\<Sum>S\\<in>#\\<P>. \\<v> div \\<k>)\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "then"], ["proof (chain)\npicking this:\n  \\<b> = (\\<Sum>S\\<in>#\\<P>. \\<v> div \\<k>)", "have f2: \"\\<b> = (size \\<P>) * (\\<v> div \\<k>)\""], ["proof (prove)\nusing this:\n  \\<b> = (\\<Sum>S\\<in>#\\<P>. \\<v> div \\<k>)\n\ngoal (1 subgoal):\n 1. \\<b> = int (size \\<P>) * (\\<v> div \\<k>)", "by simp"], ["proof (state)\nthis:\n  \\<b> = int (size \\<P>) * (\\<v> div \\<k>)\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "then"], ["proof (chain)\npicking this:\n  \\<b> = int (size \\<P>) * (\\<v> div \\<k>)", "have \"size \\<P> = \\<b> div (\\<v> div \\<k>)\""], ["proof (prove)\nusing this:\n  \\<b> = int (size \\<P>) * (\\<v> div \\<k>)\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<b> div (\\<v> div \\<k>)", "using b_non_zero"], ["proof (prove)\nusing this:\n  \\<b> = int (size \\<P>) * (\\<v> div \\<k>)\n  \\<b> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<b> div (\\<v> div \\<k>)", "by auto"], ["proof (state)\nthis:\n  int (size \\<P>) = \\<b> div (\\<v> div \\<k>)\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "then"], ["proof (chain)\npicking this:\n  int (size \\<P>) = \\<b> div (\\<v> div \\<k>)", "have \"size \\<P> = (\\<b> * \\<k>) div \\<v>\""], ["proof (prove)\nusing this:\n  int (size \\<P>) = \\<b> div (\\<v> div \\<k>)\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<b> * \\<k> div \\<v>", "using f2 resolvable_necessary_cond_v"], ["proof (prove)\nusing this:\n  int (size \\<P>) = \\<b> div (\\<v> div \\<k>)\n  \\<b> = int (size \\<P>) * (\\<v> div \\<k>)\n  \\<k> dvd \\<v>\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<b> * \\<k> div \\<v>", "by (metis div_div_div_same div_dvd_div dvd_triv_right k_ne0 nonzero_mult_div_cancel_right)"], ["proof (state)\nthis:\n  int (size \\<P>) = \\<b> * \\<k> div \\<v>\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (size \\<P>) = \\<b> * \\<k> div \\<v>\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "using necessary_condition_two"], ["proof (prove)\nusing this:\n  int (size \\<P>) = \\<b> * \\<k> div \\<v>\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n\ngoal (1 subgoal):\n 1. int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)", "by (metis nonzero_mult_div_cancel_left not_one_less_zero t_design_min_v)"], ["proof (state)\nthis:\n  int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resolvable_necessary_cond_b: \"\\<r> dvd \\<b>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) dvd \\<b>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) dvd \\<b>", "have f1: \"\\<b> = (\\<Sum>S \\<in># \\<P> . size S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))", "by (metis partition_on_msetD1 resolutionD1 size_big_union_sum)"], ["proof (state)\nthis:\n  \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) dvd \\<b>", "then"], ["proof (chain)\npicking this:\n  \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))", "have \"\\<b> = (\\<Sum>S \\<in># \\<P> . \\<v> div \\<k>)\""], ["proof (prove)\nusing this:\n  \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))\n\ngoal (1 subgoal):\n 1. \\<b> = (\\<Sum>S\\<in>#\\<P>. \\<v> div \\<k>)", "using resolution_class_size2 f1"], ["proof (prove)\nusing this:\n  \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))\n  ?S \\<in># \\<P> \\<Longrightarrow> int (size ?S) = \\<v> div \\<k>\n  \\<b> = int (\\<Sum>\\<^sub># (image_mset size \\<P>))\n\ngoal (1 subgoal):\n 1. \\<b> = (\\<Sum>S\\<in>#\\<P>. \\<v> div \\<k>)", "by auto"], ["proof (state)\nthis:\n  \\<b> = (\\<Sum>S\\<in>#\\<P>. \\<v> div \\<k>)\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) dvd \\<b>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<b> = (\\<Sum>S\\<in>#\\<P>. \\<v> div \\<k>)\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) dvd \\<b>", "using resolvable_design_num_res_classes"], ["proof (prove)\nusing this:\n  \\<b> = (\\<Sum>S\\<in>#\\<P>. \\<v> div \\<k>)\n  int (size \\<P>) = \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) dvd \\<b>", "by simp"], ["proof (state)\nthis:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) dvd \\<b>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Bose's Inequality\\<close>"], ["", "text \\<open>Boses inequality is an important theorem on RBIBD's. This is a proof \nof an alternate statement of the thm, which does not require a linear algebraic approach, \ntaken directly from Stinson \\cite{stinsonCombinatorialDesignsConstructions2004}\\<close>"], ["", "theorem bose_inequality_alternate: \"\\<b> \\<ge> \\<v> + \\<r> - 1 \\<longleftrightarrow> \\<r> \\<ge> \\<k> + \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have kdvd: \"\\<k> dvd (\\<v> * (\\<r> - \\<k>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<k> dvd \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>)", "using necessary_condition_two"], ["proof (prove)\nusing this:\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n\ngoal (1 subgoal):\n 1. \\<k> dvd \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>)", "by (simp add: right_diff_distrib')"], ["proof (state)\nthis:\n  \\<k> dvd \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>)\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have v_eq: \"\\<v> = (\\<r> * (\\<k> - 1) + \\<Lambda> ) div \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<v> =\n    (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>) div\n    \\<Lambda>", "using necessary_condition_one index_not_zero"], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n  \\<Lambda> * (\\<v> - 1)\n  1 \\<le> \\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<v> =\n    (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>) div\n    \\<Lambda>", "by auto"], ["proof (state)\nthis:\n  \\<v> =\n  (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>) div\n  \\<Lambda>\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have ldvd: \" \\<And> x. \\<Lambda> dvd (x * (\\<r> * (\\<k> - 1) + \\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<Lambda> dvd\n       x * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>)", "using necessary_condition_one"], ["proof (prove)\nusing this:\n  \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) =\n  \\<Lambda> * (\\<v> - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<Lambda> dvd\n       x * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>)", "by auto"], ["proof (state)\nthis:\n  \\<Lambda> dvd\n  ?x * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>)\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"(\\<b> \\<ge> \\<v> + \\<r> - 1) \\<longleftrightarrow> ((\\<v> * \\<r>) div \\<k> \\<ge> \\<v> + \\<r> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n     \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>)", "using necessary_condition_two k_non_zero"], ["proof (prove)\nusing this:\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n  1 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n     \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>)", "by auto"], ["proof (state)\nthis:\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n   \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>)\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n   \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>)\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have  \"... \\<longleftrightarrow> (((\\<v> * \\<r>) - (\\<v> * \\<k>)) div \\<k> \\<ge> \\<r> - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n     \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>) =\n    (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n     \\<le> (\\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n            \\<v> * \\<k>) div\n           \\<k>)", "using  k_non_zero div_mult_self3 k_non_zero necessary_condition_two"], ["proof (prove)\nusing this:\n  1 \\<le> \\<k>\n  ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  (?c * ?b + ?a) div ?b = ?c + ?a div ?b\n  1 \\<le> \\<k>\n  \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) = \\<b> * \\<k>\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n     \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>) =\n    (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n     \\<le> (\\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n            \\<v> * \\<k>) div\n           \\<k>)", "by auto"], ["proof (state)\nthis:\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n   \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>) =\n  (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n   \\<le> (\\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) - \\<v> * \\<k>) div\n         \\<k>)\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n   \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) div \\<k>) =\n  (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n   \\<le> (\\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) - \\<v> * \\<k>) div\n         \\<k>)\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have f2: \" ... \\<longleftrightarrow> ((\\<v> * ( \\<r> - \\<k>)) \\<ge> \\<k> * ( \\<r> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n     \\<le> (\\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n            \\<v> * \\<k>) div\n           \\<k>) =\n    (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>))", "using k_non_zero kdvd"], ["proof (prove)\nusing this:\n  1 \\<le> \\<k>\n  \\<k> dvd \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>)\n\ngoal (1 subgoal):\n 1. (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n     \\<le> (\\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n            \\<v> * \\<k>) div\n           \\<k>) =\n    (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>))", "by (auto simp add: int_distrib(3) mult_of_nat_commute)"], ["proof (state)\nthis:\n  (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n   \\<le> (\\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) - \\<v> * \\<k>) div\n         \\<k>) =\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1\n   \\<le> (\\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) - \\<v> * \\<k>) div\n         \\<k>) =\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... \\<longleftrightarrow> ((((\\<r> * (\\<k> - 1) + \\<Lambda> ) div \\<Lambda>) * (\\<r> - \\<k>)) \\<ge> \\<k> * (\\<r> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>)) =\n    (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n            \\<Lambda>) div\n           \\<Lambda> *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>))", "using v_eq"], ["proof (prove)\nusing this:\n  \\<v> =\n  (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>) div\n  \\<Lambda>\n\ngoal (1 subgoal):\n 1. (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>)) =\n    (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n            \\<Lambda>) div\n           \\<Lambda> *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>))", "by presburger"], ["proof (state)\nthis:\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>)) =\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n          \\<Lambda>) div\n         \\<Lambda> *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> \\<v> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>)) =\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n          \\<Lambda>) div\n         \\<Lambda> *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... \\<longleftrightarrow> ( (\\<r> - \\<k>) * ((\\<r> * (\\<k> - 1) + \\<Lambda> ) div \\<Lambda>) \\<ge> (\\<k> * (\\<r> - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n            \\<Lambda>) div\n           \\<Lambda> *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>)) =\n    (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           ((\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n             \\<Lambda>) div\n            \\<Lambda>))", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n          \\<Lambda>) div\n         \\<Lambda> *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>)) =\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         ((\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n           \\<Lambda>) div\n          \\<Lambda>))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n          \\<Lambda>) div\n         \\<Lambda> *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>)) =\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         ((\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n           \\<Lambda>) div\n          \\<Lambda>))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \" ... \\<longleftrightarrow> ( ((\\<r> - \\<k>) * (\\<r> * (\\<k> - 1) + \\<Lambda> )) div \\<Lambda> \\<ge> (\\<k> * (\\<r> - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           ((\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n             \\<Lambda>) div\n            \\<Lambda>)) =\n    (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n            \\<Lambda>) div\n           \\<Lambda>)", "by (metis div_mult_swap dvd_add_triv_right_iff dvd_triv_left necessary_condition_one)"], ["proof (state)\nthis:\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         ((\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n           \\<Lambda>) div\n          \\<Lambda>)) =\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n          \\<Lambda>) div\n         \\<Lambda>)\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         ((\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n           \\<Lambda>) div\n          \\<Lambda>)) =\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n          \\<Lambda>) div\n         \\<Lambda>)\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \" ... \\<longleftrightarrow> (((\\<r> - \\<k>) * (\\<r> * (\\<k> - 1) + \\<Lambda> ))  \\<ge>  \\<Lambda> * (\\<k> * (\\<r> - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n            \\<Lambda>) div\n           \\<Lambda>) =\n    (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>))", "using ldvd"], ["proof (prove)\nusing this:\n  \\<Lambda> dvd\n  ?x * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>)\n\ngoal (1 subgoal):\n 1. (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n            \\<Lambda>) div\n           \\<Lambda>) =\n    (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>))", "by (smt dvd_mult_div_cancel index_not_zero mult_strict_left_mono)"], ["proof (state)\nthis:\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n          \\<Lambda>) div\n         \\<Lambda>) =\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n          \\<Lambda>) div\n         \\<Lambda>) =\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... \\<longleftrightarrow> (((\\<r> - \\<k>) * (\\<r> * (\\<k> - 1))) + ((\\<r> - \\<k>) * \\<Lambda> )  \\<ge>  \\<Lambda> * (\\<k> * (\\<r> - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) +\n            \\<Lambda>)) =\n    (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1)) +\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>)", "by (simp add: distrib_left)"], ["proof (state)\nthis:\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>)) =\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1)) +\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>)\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1) + \\<Lambda>)) =\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1)) +\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>)\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... \\<longleftrightarrow> (((\\<r> - \\<k>) * \\<r> * (\\<k> - 1)) \\<ge> \\<Lambda> * \\<k> * (\\<r> - 1) - ((\\<r> - \\<k>) * \\<Lambda> ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1)) +\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>) =\n    (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1) -\n     (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1))", "using mult.assoc"], ["proof (prove)\nusing this:\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1)) +\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>) =\n    (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1) -\n     (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1))", "by linarith"], ["proof (state)\nthis:\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1)) +\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>) =\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1) -\n   (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * (\\<k> - 1)) +\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>) =\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1) -\n   (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... \\<longleftrightarrow> (((\\<r> - \\<k>) * \\<r> * (\\<k> - 1)) \\<ge> (\\<Lambda> * \\<k> * \\<r>) - (\\<Lambda> * \\<k>) - ((\\<r> * \\<Lambda>) -(\\<k> * \\<Lambda> )))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1) -\n     (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1)) =\n    (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n     \\<Lambda> * \\<k> -\n     (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<Lambda> - \\<k> * \\<Lambda>)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1))", "using distrib_right"], ["proof (prove)\nusing this:\n  (?a + ?b) * ?c = ?a * ?c + ?b * ?c\n\ngoal (1 subgoal):\n 1. (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1) -\n     (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1)) =\n    (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n     \\<Lambda> * \\<k> -\n     (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<Lambda> - \\<k> * \\<Lambda>)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1))", "by (simp add: distrib_left right_diff_distrib' left_diff_distrib')"], ["proof (state)\nthis:\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1) -\n   (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1)) =\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n   \\<Lambda> * \\<k> -\n   (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<Lambda> - \\<k> * \\<Lambda>)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1) -\n   (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) * \\<Lambda>\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1)) =\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n   \\<Lambda> * \\<k> -\n   (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<Lambda> - \\<k> * \\<Lambda>)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... \\<longleftrightarrow> (((\\<r> - \\<k>) * \\<r> * (\\<k> - 1)) \\<ge> (\\<Lambda> * \\<k> * \\<r>)  - ( \\<Lambda> * \\<r>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n     \\<Lambda> * \\<k> -\n     (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<Lambda> - \\<k> * \\<Lambda>)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1)) =\n    (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n     \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1))", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n   \\<Lambda> * \\<k> -\n   (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<Lambda> - \\<k> * \\<Lambda>)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1)) =\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n   \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n   \\<Lambda> * \\<k> -\n   (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<Lambda> - \\<k> * \\<Lambda>)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1)) =\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n   \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... \\<longleftrightarrow> (((\\<r> - \\<k>) * \\<r> * (\\<k> - 1)) \\<ge> (\\<Lambda>  * (\\<k> * \\<r>))  - ( \\<Lambda> * \\<r>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n     \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1)) =\n    (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))) -\n     \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1))", "by linarith"], ["proof (state)\nthis:\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n   \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1)) =\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))) -\n   \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<Lambda> * \\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) -\n   \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1)) =\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))) -\n   \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... \\<longleftrightarrow> (((\\<r> - \\<k>) * \\<r> * (\\<k> - 1)) \\<ge> (\\<Lambda>  * (\\<r> * \\<k>))  - ( \\<Lambda> * \\<r>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))) -\n     \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1)) =\n    (\\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<k>) -\n     \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1))", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))) -\n   \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1)) =\n  (\\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<k>) -\n   \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "also"], ["proof (state)\nthis:\n  (\\<Lambda> * (\\<k> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))) -\n   \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1)) =\n  (\\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<k>) -\n   \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "have \"... \\<longleftrightarrow> (((\\<r> - \\<k>) * \\<r> * (\\<k> - 1)) \\<ge> \\<Lambda> * \\<r> * ( \\<k> - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<k>) -\n     \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1)) =\n    (\\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) * (\\<k> - 1)\n     \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n           (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n           (\\<k> - 1))", "by (simp add:  mult.assoc int_distrib(4))"], ["proof (state)\nthis:\n  (\\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) * \\<k>) -\n   \\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1)) =\n  (\\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) * (\\<k> - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "finally"], ["proof (chain)\npicking this:\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n  (\\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) * (\\<k> - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))", "have \"(\\<b> \\<ge> \\<v> + \\<r> - 1) \\<longleftrightarrow> (\\<r> \\<ge> \\<k> + \\<Lambda>)\""], ["proof (prove)\nusing this:\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n  (\\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) * (\\<k> - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "using index_lt_replication mult_right_le_imp_le r_gzero"], ["proof (prove)\nusing this:\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n  (\\<Lambda> * (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) * (\\<k> - 1)\n   \\<le> (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - \\<k>) *\n         (\\<Lambda> * (\\<v> - 1) div (\\<k> - 1)) *\n         (\\<k> - 1))\n  \\<Lambda> < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n  \\<lbrakk>?a * ?c \\<le> ?b * ?c; (0::?'a) < ?c\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b\n  0 < \\<Lambda> * (\\<v> - 1) div (\\<k> - 1)\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by (smt mult_cancel_right k_non_zero)"], ["proof (state)\nthis:\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n  (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n  (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal (1 subgoal):\n 1. (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n    (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))", "by simp"], ["proof (state)\nthis:\n  (\\<v> + \\<Lambda> * (\\<v> - 1) div (\\<k> - 1) - 1 \\<le> \\<b>) =\n  (\\<k> + \\<Lambda> \\<le> \\<Lambda> * (\\<v> - 1) div (\\<k> - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}