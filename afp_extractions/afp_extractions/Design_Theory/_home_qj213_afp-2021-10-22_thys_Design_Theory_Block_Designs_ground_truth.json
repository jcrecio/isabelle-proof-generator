{"file_name": "/home/qj213/afp-2021-10-22/thys/Design_Theory/Block_Designs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Design_Theory", "problem_names": ["lemma sys_block_size_subset: \"sys_block_sizes \\<subseteq> \\<K>\"", "lemma k_non_zero: \"\\<k> \\<ge> 1\"", "lemma uniform_alt_def_all: \"\\<forall> bl \\<in># \\<B> .card bl = \\<k>\"", "lemma uniform_unfold_point_set: \"bl \\<in># \\<B> \\<Longrightarrow> card {p \\<in> \\<V>. p \\<in> bl} = \\<k>\"", "lemma uniform_unfold_point_set_mset: \"bl \\<in># \\<B> \\<Longrightarrow> size {#p \\<in># mset_set \\<V>. p \\<in> bl #} = \\<k>\"", "lemma sys_block_sizes_uniform [simp]:  \"sys_block_sizes  = {\\<k>}\"", "lemma sys_block_sizes_uniform_single: \"is_singleton (sys_block_sizes)\"", "lemma uniform_size_incomp: \"\\<k> \\<le> \\<v> - 1 \\<Longrightarrow> bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\"", "lemma uniform_complement_block_size:\n  assumes \"bl \\<in># \\<B>\\<^sup>C\"\n  shows \"card bl = \\<v> - \\<k>\"", "lemma uniform_complement[intro]: \n  assumes \"\\<k> \\<le> \\<v> - 1\"\n  shows \"block_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)\"", "lemma block_size_lt_v: \"\\<k> \\<le> \\<v>\"", "lemma (in proper_design) block_designI[intro]: \"(\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> card bl = k) \n  \\<Longrightarrow> block_design \\<V> \\<B> k\"", "lemma block_design_multiple: \"n > 0 \\<Longrightarrow> block_design \\<V> (multiple_blocks n) \\<k>\"", "lemma incomplete_imp_incomp_block: \"bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\"", "lemma incomplete_imp_proper_subset: \"bl \\<in># \\<B> \\<Longrightarrow> bl \\<subset> \\<V>\"", "lemma (in block_design) incomplete_designI[intro]: \"\\<k> < \\<v> \\<Longrightarrow> incomplete_design \\<V> \\<B> \\<k>\"", "lemma multiple_incomplete: \"n > 0 \\<Longrightarrow> incomplete_design \\<V> (multiple_blocks n) \\<k>\"", "lemma complement_incomplete: \"incomplete_design \\<V> (\\<B>\\<^sup>C) (\\<v> - \\<k>)\"", "lemma balanced_alt_def_all: \"\\<forall> ps \\<subseteq> \\<V> . card ps = \\<t> \\<longrightarrow> \\<B> index ps = \\<Lambda>\\<^sub>t\"", "lemma (in proper_design) t_wise_balanceI[intro]: \"\\<t> \\<le> \\<v> \\<Longrightarrow> \\<t> \\<ge> 1 \\<Longrightarrow> \n  (\\<And> ps . ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = \\<t>  \\<Longrightarrow> \\<B> index ps = \\<Lambda>\\<^sub>t) \\<Longrightarrow> t_wise_balance \\<V> \\<B> \\<t> \\<Lambda>\\<^sub>t\"", "lemma obtain_t_subset_points:\n  obtains T where \"T \\<subseteq> \\<V>\" \"card T = \\<t>\" \"finite T\"", "lemma multiple_t_wise_balance_index [simp]:\n  assumes \"ps \\<subseteq> \\<V>\"\n  assumes \"card ps = \\<t>\"\n  shows \"(multiple_blocks n) index ps = \\<Lambda>\\<^sub>t * n\"", "lemma multiple_t_wise_balance: \n  assumes \"n > 0\" \n  shows \"t_wise_balance \\<V> (multiple_blocks n) \\<t> (\\<Lambda>\\<^sub>t * n)\"", "lemma twise_set_pair_index: \"ps \\<subseteq> \\<V> \\<Longrightarrow> ps2 \\<subseteq> \\<V> \\<Longrightarrow> ps \\<noteq> ps2 \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> card ps2 = \\<t> \n  \\<Longrightarrow> \\<B> index ps = \\<B> index ps2\"", "lemma t_wise_balance_alt: \"ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> \\<B> index ps = l2 \n  \\<Longrightarrow> (\\<And> ps . ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> \\<B> index ps = l2)\"", "lemma index_ge_zero: \"\\<Lambda>\\<^sub>t \\<ge> 0\"", "lemma index_1_imp_mult_1 [simp]: \n  assumes \"\\<Lambda>\\<^sub>t = 1\"\n  assumes \"bl \\<in># \\<B>\"\n  assumes \"card bl \\<ge> \\<t>\"\n  shows \"multiplicity bl = 1\"", "lemma multiplicity_is_1:\n  assumes \"bl \\<in># \\<B>\"\n  shows \"multiplicity bl = 1\"", "lemma covering_alt_def_all: \"\\<forall> ps \\<subseteq> \\<V> . card ps = \\<t> \\<longrightarrow> \\<B> index ps \\<ge> \\<Lambda>\\<^sub>t\"", "lemma (in block_design) t_covering_designI [intro]: \"t \\<le> \\<k> \\<Longrightarrow> t \\<ge> 1 \\<Longrightarrow> \n  (\\<And> ps. ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = t \\<Longrightarrow> \\<B> index ps \\<ge> \\<Lambda>\\<^sub>t) \\<Longrightarrow> t_covering_design \\<V> \\<B> \\<k> t \\<Lambda>\\<^sub>t\"", "lemma packing_alt_def_all: \"\\<forall> ps \\<subseteq> \\<V> . card ps = \\<t> \\<longrightarrow> \\<B> index ps \\<le> \\<Lambda>\\<^sub>t\"", "lemma (in block_design) t_packing_designI [intro]: \"t \\<le> \\<k> \\<Longrightarrow> t \\<ge> 1 \\<Longrightarrow> \n  (\\<And> ps . ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = t \\<Longrightarrow> \\<B> index ps \\<le> \\<Lambda>\\<^sub>t) \\<Longrightarrow> t_packing_design \\<V> \\<B> \\<k> t \\<Lambda>\\<^sub>t\"", "lemma packing_covering_imp_balance: \n  assumes \"t_packing_design V B k t \\<Lambda>\\<^sub>t\" \n  assumes \"t_covering_design V B k t \\<Lambda>\\<^sub>t\" \n  shows \"t_wise_balance V B t \\<Lambda>\\<^sub>t\"", "lemma rep_number_alt_def_all: \"\\<forall> x \\<in> \\<V>. \\<B> rep x = \\<r>\"", "lemma rep_number_unfold_set: \"x \\<in> \\<V> \\<Longrightarrow> size {#bl \\<in># \\<B> . x \\<in> bl#} = \\<r>\"", "lemma rep_numbers_constant [simp]: \"replication_numbers  = {\\<r>}\"", "lemma replication_number_single: \"is_singleton (replication_numbers)\"", "lemma constant_rep_point_pair: \"x1 \\<in> \\<V> \\<Longrightarrow> x2 \\<in> \\<V> \\<Longrightarrow> x1 \\<noteq> x2 \\<Longrightarrow> \\<B> rep x1 = \\<B> rep x2\"", "lemma constant_rep_alt: \"x1 \\<in> \\<V> \\<Longrightarrow> \\<B> rep x1 = r2 \\<Longrightarrow> (\\<And> x . x \\<in> \\<V> \\<Longrightarrow> \\<B> rep x = r2)\"", "lemma constant_rep_point_not_0:\n  assumes \"x \\<in> \\<V>\" \n  shows \"\\<B> rep x \\<noteq> 0\"", "lemma rep_not_zero: \"\\<r> \\<noteq> 0\"", "lemma r_gzero: \"\\<r> > 0\"", "lemma r_lt_eq_b: \"\\<r> \\<le> \\<b>\"", "lemma complement_rep_number: \n  assumes \"\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\"\n  shows \"constant_rep_design \\<V> \\<B>\\<^sup>C (\\<b> - \\<r>)\"", "lemma multiple_rep_number: \n  assumes \"n > 0\"\n  shows \"constant_rep_design \\<V> (multiple_blocks n) (\\<r> * n)\"", "lemma (in proper_design) constant_rep_designI [intro]: \"(\\<And> x . x \\<in> \\<V> \\<Longrightarrow> \\<B> rep x = \\<r>) \n    \\<Longrightarrow> constant_rep_design \\<V> \\<B> \\<r>\"", "lemma point_indices_balanced: \"point_indices \\<t> = {\\<Lambda>\\<^sub>t}\"", "lemma point_indices_singleton: \"is_singleton (point_indices \\<t>)\"", "lemma t_designI [intro]: \n  assumes \"incomplete_design V B k\"\n  assumes \"t_wise_balance V B t \\<Lambda>\\<^sub>t\"\n  assumes \"t \\<le> k\"\n  shows \"t_design V B k t \\<Lambda>\\<^sub>t\"", "lemma t_design_pack_cov [intro]: \n  assumes \"k < card V\"\n  assumes \"t_covering_design V B k t \\<Lambda>\\<^sub>t\"\n  assumes \"t_packing_design V B k t \\<Lambda>\\<^sub>t\"\n  shows \"t_design V B k t \\<Lambda>\\<^sub>t\"", "lemma multiple_t_design: \"n > 0 \\<Longrightarrow> t_design \\<V> (multiple_blocks n) \\<k> \\<t> (\\<Lambda>\\<^sub>t * n)\"", "lemma t_design_min_v: \"\\<v> > 1\"", "lemma block_multiplicity [simp]: \n  assumes \"bl \\<in># \\<B>\"\n  shows \"multiplicity bl = 1\"", "lemma (in t_design) steiner_systemI[intro]: \"\\<Lambda>\\<^sub>t = 1 \\<Longrightarrow> steiner_system \\<V> \\<B> \\<k> \\<t>\"", "lemma combine_t_wise_balance_index: \"ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> \\<B>\\<^sup>+ index ps = (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')\"", "lemma combine_t_wise_balance: \"t_wise_balance \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<t> (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')\"", "lemma block_design_combine: \"block_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>\"", "lemma combine_rep_number: \"constant_rep_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ (\\<r> + \\<r>')\"", "lemma combine_is_incomplete: \"incomplete_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>\"", "lemma combine_is_t_des: \"t_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k> \\<t> (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')\""], "translations": [["", "lemma sys_block_size_subset: \"sys_block_sizes \\<subseteq> \\<K>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_block_sizes \\<subseteq> \\<K>", "using block_sizes sys_block_sizes_obtain_bl"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) \\<in> \\<K>\n  ?x \\<in> sys_block_sizes \\<Longrightarrow>\n  \\<exists>bl\\<in>#\\<B>. int (card bl) = ?x\n\ngoal (1 subgoal):\n 1. sys_block_sizes \\<subseteq> \\<K>", "by blast"], ["", "end"], ["", "subsubsection\\<open>Uniform Block Design\\<close>"], ["", "text \\<open>The typical uniform block design is defined below\\<close>"], ["", "locale block_design = proper_design + \n  fixes u_block_size :: int (\"\\<k>\")\n  assumes uniform [simp]: \"bl \\<in># \\<B> \\<Longrightarrow> card bl = \\<k>\"\nbegin"], ["", "lemma k_non_zero: \"\\<k> \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> \\<k>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> \\<k>", "obtain bl where bl_in: \"bl \\<in># \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bl. bl \\<in># \\<B> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using design_blocks_nempty"], ["proof (prove)\nusing this:\n  \\<B> \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (\\<And>bl. bl \\<in># \\<B> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<k>", "then"], ["proof (chain)\npicking this:\n  bl \\<in># \\<B>", "have \"int (card bl) \\<ge> 1\""], ["proof (prove)\nusing this:\n  bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. 1 \\<le> int (card bl)", "using block_size_gt_0"], ["proof (prove)\nusing this:\n  bl \\<in># \\<B>\n  ?bl \\<in># \\<B> \\<Longrightarrow> 0 < card ?bl\n\ngoal (1 subgoal):\n 1. 1 \\<le> int (card bl)", "by (metis less_not_refl less_one not_le_imp_less of_nat_1 of_nat_less_iff)"], ["proof (state)\nthis:\n  1 \\<le> int (card bl)\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<k>", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> int (card bl)\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<k>", "by (simp add: bl_in)"], ["proof (state)\nthis:\n  1 \\<le> \\<k>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uniform_alt_def_all: \"\\<forall> bl \\<in># \\<B> .card bl = \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#\\<B>. int (card bl) = \\<k>", "using uniform"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n\ngoal (1 subgoal):\n 1. \\<forall>bl\\<in>#\\<B>. int (card bl) = \\<k>", "by auto"], ["", "lemma uniform_unfold_point_set: \"bl \\<in># \\<B> \\<Longrightarrow> card {p \\<in> \\<V>. p \\<in> bl} = \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow>\n    int (card {p \\<in> \\<V>. p \\<in> bl}) = \\<k>", "using uniform wellformed"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow>\n    int (card {p \\<in> \\<V>. p \\<in> bl}) = \\<k>", "by (simp add: Collect_conj_eq inf.absorb_iff2)"], ["", "lemma uniform_unfold_point_set_mset: \"bl \\<in># \\<B> \\<Longrightarrow> size {#p \\<in># mset_set \\<V>. p \\<in> bl #} = \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow>\n    int (size {#p \\<in># mset_set \\<V>. p \\<in> bl#}) = \\<k>", "using uniform_unfold_point_set"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow>\n  int (card {p \\<in> \\<V>. p \\<in> ?bl}) = \\<k>\n\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow>\n    int (size {#p \\<in># mset_set \\<V>. p \\<in> bl#}) = \\<k>", "by (simp add: finite_sets)"], ["", "lemma sys_block_sizes_uniform [simp]:  \"sys_block_sizes  = {\\<k>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_block_sizes = {\\<k>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sys_block_sizes = {\\<k>}", "have \"sys_block_sizes = {bs . \\<exists> bl . bs = card bl \\<and> bl\\<in># \\<B>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_block_sizes = {int (card bl) |bl. bl \\<in># \\<B>}", "by (simp add: sys_block_sizes_def)"], ["proof (state)\nthis:\n  sys_block_sizes = {int (card bl) |bl. bl \\<in># \\<B>}\n\ngoal (1 subgoal):\n 1. sys_block_sizes = {\\<k>}", "then"], ["proof (chain)\npicking this:\n  sys_block_sizes = {int (card bl) |bl. bl \\<in># \\<B>}", "have \"sys_block_sizes  = {bs . bs = \\<k>}\""], ["proof (prove)\nusing this:\n  sys_block_sizes = {int (card bl) |bl. bl \\<in># \\<B>}\n\ngoal (1 subgoal):\n 1. sys_block_sizes = {bs. bs = \\<k>}", "using uniform uniform_unfold_point_set \n      b_positive block_set_nempty_imp_block_ex"], ["proof (prove)\nusing this:\n  sys_block_sizes = {int (card bl) |bl. bl \\<in># \\<B>}\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  ?bl \\<in># \\<B> \\<Longrightarrow>\n  int (card {p \\<in> \\<V>. p \\<in> ?bl}) = \\<k>\n  0 < \\<b>\n  \\<B> \\<noteq> {#} \\<Longrightarrow> \\<exists>bl. bl \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. sys_block_sizes = {bs. bs = \\<k>}", "by (smt (verit, best) Collect_cong design_blocks_nempty)"], ["proof (state)\nthis:\n  sys_block_sizes = {bs. bs = \\<k>}\n\ngoal (1 subgoal):\n 1. sys_block_sizes = {\\<k>}", "thus ?thesis"], ["proof (prove)\nusing this:\n  sys_block_sizes = {bs. bs = \\<k>}\n\ngoal (1 subgoal):\n 1. sys_block_sizes = {\\<k>}", "by auto"], ["proof (state)\nthis:\n  sys_block_sizes = {\\<k>}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sys_block_sizes_uniform_single: \"is_singleton (sys_block_sizes)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_singleton sys_block_sizes", "by simp"], ["", "lemma uniform_size_incomp: \"\\<k> \\<le> \\<v> - 1 \\<Longrightarrow> bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<k> \\<le> \\<v> - 1; bl \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> incomplete_block bl", "using uniform k_non_zero of_nat_less_iff zle_diff1_eq"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  1 \\<le> \\<k>\n  (of_nat ?m < of_nat ?n) = (?m < ?n)\n  (?w \\<le> ?z - 1) = (?w < ?z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<k> \\<le> \\<v> - 1; bl \\<in># \\<B>\\<rbrakk>\n    \\<Longrightarrow> incomplete_block bl", "by metis"], ["", "lemma uniform_complement_block_size:\n  assumes \"bl \\<in># \\<B>\\<^sup>C\"\n  shows \"card bl = \\<v> - \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card bl) = \\<v> - \\<k>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (card bl) = \\<v> - \\<k>", "obtain bl' where bl_assm: \"bl = bl'\\<^sup>c \\<and> bl' \\<in># \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bl'.\n        bl = bl'\\<^sup>c \\<and> bl' \\<in># \\<B> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using wellformed assms"], ["proof (prove)\nusing this:\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n  bl \\<in># \\<B>\\<^sup>C\n\ngoal (1 subgoal):\n 1. (\\<And>bl'.\n        bl = bl'\\<^sup>c \\<and> bl' \\<in># \\<B> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: complement_blocks_def)"], ["proof (state)\nthis:\n  bl = bl'\\<^sup>c \\<and> bl' \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. int (card bl) = \\<v> - \\<k>", "then"], ["proof (chain)\npicking this:\n  bl = bl'\\<^sup>c \\<and> bl' \\<in># \\<B>", "have \"int (card bl') = \\<k>\""], ["proof (prove)\nusing this:\n  bl = bl'\\<^sup>c \\<and> bl' \\<in># \\<B>\n\ngoal (1 subgoal):\n 1. int (card bl') = \\<k>", "by simp"], ["proof (state)\nthis:\n  int (card bl') = \\<k>\n\ngoal (1 subgoal):\n 1. int (card bl) = \\<v> - \\<k>", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (card bl') = \\<k>\n\ngoal (1 subgoal):\n 1. int (card bl) = \\<v> - \\<k>", "using bl_assm block_complement_size wellformed"], ["proof (prove)\nusing this:\n  int (card bl') = \\<k>\n  bl = bl'\\<^sup>c \\<and> bl' \\<in># \\<B>\n  ?b \\<subseteq> \\<V> \\<Longrightarrow>\n  card (?b\\<^sup>c) = card \\<V> - card ?b\n  ?b \\<in># \\<B> \\<Longrightarrow> ?b \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. int (card bl) = \\<v> - \\<k>", "by (simp add: block_size_lt_order of_nat_diff)"], ["proof (state)\nthis:\n  int (card bl) = \\<v> - \\<k>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uniform_complement[intro]: \n  assumes \"\\<k> \\<le> \\<v> - 1\"\n  shows \"block_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. block_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. block_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)", "interpret des: proper_design \\<V> \"\\<B>\\<^sup>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B>\\<^sup>C", "using  uniform_size_incomp assms complement_proper_design"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<k> \\<le> \\<v> - 1; ?bl \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> incomplete_block ?bl\n  \\<k> \\<le> \\<v> - 1\n  (\\<And>bl.\n      bl \\<in># \\<B> \\<Longrightarrow>\n      incomplete_block bl) \\<Longrightarrow>\n  proper_design \\<V> \\<B>\\<^sup>C\n\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B>\\<^sup>C", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. block_design \\<V> \\<B>\\<^sup>C (des.\\<v> - \\<k>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. block_design \\<V> \\<B>\\<^sup>C (des.\\<v> - \\<k>)", "using assms uniform_complement_block_size"], ["proof (prove)\nusing this:\n  \\<k> \\<le> des.\\<v> - 1\n  ?bl \\<in># \\<B>\\<^sup>C \\<Longrightarrow> int (card ?bl) = des.\\<v> - \\<k>\n\ngoal (1 subgoal):\n 1. block_design \\<V> \\<B>\\<^sup>C (des.\\<v> - \\<k>)", "by (unfold_locales) (simp)"], ["proof (state)\nthis:\n  block_design \\<V> \\<B>\\<^sup>C (des.\\<v> - \\<k>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma block_size_lt_v: \"\\<k> \\<le> \\<v>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<k> \\<le> \\<v>", "using v_non_zero block_size_lt_v design_blocks_nempty uniform"], ["proof (prove)\nusing this:\n  0 < \\<v>\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) \\<le> \\<v>\n  \\<B> \\<noteq> {#}\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n\ngoal (1 subgoal):\n 1. \\<k> \\<le> \\<v>", "by auto"], ["", "end"], ["", "lemma (in proper_design) block_designI[intro]: \"(\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> card bl = k) \n  \\<Longrightarrow> block_design \\<V> \\<B> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bl.\n        bl \\<in># \\<B> \\<Longrightarrow> card bl = k) \\<Longrightarrow>\n    block_design \\<V> \\<B> (int k)", "by (unfold_locales) (auto)"], ["", "context block_design \nbegin"], ["", "lemma block_design_multiple: \"n > 0 \\<Longrightarrow> block_design \\<V> (multiple_blocks n) \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> block_design \\<V> (multiple_blocks n) \\<k>", "using elem_in_repeat_in_original multiple_proper_design proper_design.block_designI"], ["proof (prove)\nusing this:\n  ?a \\<in># repeat_mset ?n ?A \\<Longrightarrow> ?a \\<in># ?A\n  0 < ?n \\<Longrightarrow> proper_design \\<V> (multiple_blocks ?n)\n  \\<lbrakk>proper_design ?point_set ?block_collection;\n   \\<And>bl.\n      bl \\<in># ?block_collection \\<Longrightarrow> card bl = ?k\\<rbrakk>\n  \\<Longrightarrow> block_design ?point_set ?block_collection (int ?k)\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> block_design \\<V> (multiple_blocks n) \\<k>", "by (metis block_set_nempty_imp_block_ex design_blocks_nempty int_int_eq uniform_alt_def_all)"], ["", "end"], ["", "text \\<open>A uniform block design is clearly a type of $K$\\_block\\_design with a singleton $K$ set\\<close>"], ["", "sublocale block_design \\<subseteq> K_block_design \\<V> \\<B> \"{\\<k>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K_block_design \\<V> \\<B> {\\<k>}", "using k_non_zero uniform"], ["proof (prove)\nusing this:\n  1 \\<le> \\<k>\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n\ngoal (1 subgoal):\n 1. K_block_design \\<V> \\<B> {\\<k>}", "by unfold_locales simp_all"], ["", "subsubsection \\<open>Incomplete Designs\\<close>"], ["", "text \\<open>An incomplete design is a design where $k < v$, i.e. no block is equal to the point set\\<close>"], ["", "locale incomplete_design = block_design + \n  assumes incomplete: \"\\<k> < \\<v>\"\n\nbegin"], ["", "lemma incomplete_imp_incomp_block: \"bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl", "using incomplete uniform uniform_size_incomp"], ["proof (prove)\nusing this:\n  \\<k> < \\<v>\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  \\<lbrakk>\\<k> \\<le> \\<v> - 1; ?bl \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> incomplete_block ?bl\n\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl", "by fastforce"], ["", "lemma incomplete_imp_proper_subset: \"bl \\<in># \\<B> \\<Longrightarrow> bl \\<subset> \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl \\<in># \\<B> \\<Longrightarrow> bl \\<subset> \\<V>", "by (simp add: incomplete_block_proper_subset incomplete_imp_incomp_block wellformed)"], ["", "end"], ["", "lemma (in block_design) incomplete_designI[intro]: \"\\<k> < \\<v> \\<Longrightarrow> incomplete_design \\<V> \\<B> \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<k> < \\<v> \\<Longrightarrow> incomplete_design \\<V> \\<B> \\<k>", "by unfold_locales auto"], ["", "context incomplete_design\nbegin"], ["", "lemma multiple_incomplete: \"n > 0 \\<Longrightarrow> incomplete_design \\<V> (multiple_blocks n) \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> incomplete_design \\<V> (multiple_blocks n) \\<k>", "using block_design_multiple incomplete"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> block_design \\<V> (multiple_blocks ?n) \\<k>\n  \\<k> < \\<v>\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> incomplete_design \\<V> (multiple_blocks n) \\<k>", "by (simp add: block_design.incomplete_designI)"], ["", "lemma complement_incomplete: \"incomplete_design \\<V> (\\<B>\\<^sup>C) (\\<v> - \\<k>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incomplete_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. incomplete_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)", "have \"\\<v> - \\<k> < \\<v>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<v> - \\<k> < \\<v>", "using v_non_zero k_non_zero"], ["proof (prove)\nusing this:\n  0 < \\<v>\n  1 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. \\<v> - \\<k> < \\<v>", "by linarith"], ["proof (state)\nthis:\n  \\<v> - \\<k> < \\<v>\n\ngoal (1 subgoal):\n 1. incomplete_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<v> - \\<k> < \\<v>\n\ngoal (1 subgoal):\n 1. incomplete_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)", "using uniform_complement incomplete incomplete_designI"], ["proof (prove)\nusing this:\n  \\<v> - \\<k> < \\<v>\n  \\<k> \\<le> \\<v> - 1 \\<Longrightarrow>\n  block_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)\n  \\<k> < \\<v>\n  \\<k> < \\<v> \\<Longrightarrow> incomplete_design \\<V> \\<B> \\<k>\n\ngoal (1 subgoal):\n 1. incomplete_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)", "by (simp add: block_design.incomplete_designI)"], ["proof (state)\nthis:\n  incomplete_design \\<V> \\<B>\\<^sup>C (\\<v> - \\<k>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Balanced Designs\\<close>"], ["", "text \\<open>t-wise balance is a design with the property that all point subsets of size $t$ occur in \n$\\lambda_t$ blocks\\<close>"], ["", "locale t_wise_balance = proper_design + \n  fixes grouping :: int (\"\\<t>\") and index :: int (\"\\<Lambda>\\<^sub>t\")\n  assumes t_non_zero: \"\\<t> \\<ge> 1\"\n  assumes t_lt_order: \"\\<t> \\<le> \\<v>\"\n  assumes balanced [simp]: \"ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> \\<B> index ps = \\<Lambda>\\<^sub>t\"\nbegin"], ["", "lemma balanced_alt_def_all: \"\\<forall> ps \\<subseteq> \\<V> . card ps = \\<t> \\<longrightarrow> \\<B> index ps = \\<Lambda>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps\\<subseteq>\\<V>.\n       int (card ps) = \\<t> \\<longrightarrow>\n       int (\\<B> index ps) = \\<Lambda>\\<^sub>t", "using balanced"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) = \\<Lambda>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<forall>ps\\<subseteq>\\<V>.\n       int (card ps) = \\<t> \\<longrightarrow>\n       int (\\<B> index ps) = \\<Lambda>\\<^sub>t", "by auto"], ["", "end"], ["", "lemma (in proper_design) t_wise_balanceI[intro]: \"\\<t> \\<le> \\<v> \\<Longrightarrow> \\<t> \\<ge> 1 \\<Longrightarrow> \n  (\\<And> ps . ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = \\<t>  \\<Longrightarrow> \\<B> index ps = \\<Lambda>\\<^sub>t) \\<Longrightarrow> t_wise_balance \\<V> \\<B> \\<t> \\<Lambda>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>int \\<t> \\<le> \\<v>; 1 \\<le> \\<t>;\n     \\<And>ps.\n        \\<lbrakk>ps \\<subseteq> \\<V>; card ps = \\<t>\\<rbrakk>\n        \\<Longrightarrow> \\<B> index ps = \\<Lambda>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> t_wise_balance \\<V> \\<B> (int \\<t>)\n                       (int \\<Lambda>\\<^sub>t)", "by (unfold_locales) auto"], ["", "context t_wise_balance\nbegin"], ["", "lemma obtain_t_subset_points:\n  obtains T where \"T \\<subseteq> \\<V>\" \"card T = \\<t>\" \"finite T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>T \\<subseteq> \\<V>; int (card T) = \\<t>; finite T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using obtain_subset_with_card_int_n design_points_nempty t_lt_order t_non_zero finite_sets"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n \\<le> int (card ?S); 0 \\<le> ?n;\n   \\<And>T.\n      \\<lbrakk>T \\<subseteq> ?S; int (card T) = ?n; finite T\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<V> \\<noteq> {}\n  \\<t> \\<le> \\<v>\n  1 \\<le> \\<t>\n  finite \\<V>\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>T \\<subseteq> \\<V>; int (card T) = \\<t>; finite T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, hide_lams) dual_order.strict_trans2 not_le_imp_less of_nat_1 of_nat_less_0_iff)"], ["", "lemma multiple_t_wise_balance_index [simp]:\n  assumes \"ps \\<subseteq> \\<V>\"\n  assumes \"card ps = \\<t>\"\n  shows \"(multiple_blocks n) index ps = \\<Lambda>\\<^sub>t * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (multiple_blocks n index ps) = \\<Lambda>\\<^sub>t * int n", "using multiple_point_index balanced assms"], ["proof (prove)\nusing this:\n  multiple_blocks ?n index ?ps = \\<B> index ?ps * ?n\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) = \\<Lambda>\\<^sub>t\n  ps \\<subseteq> \\<V>\n  int (card ps) = \\<t>\n\ngoal (1 subgoal):\n 1. int (multiple_blocks n index ps) = \\<Lambda>\\<^sub>t * int n", "by fastforce"], ["", "lemma multiple_t_wise_balance: \n  assumes \"n > 0\" \n  shows \"t_wise_balance \\<V> (multiple_blocks n) \\<t> (\\<Lambda>\\<^sub>t * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_wise_balance \\<V> (multiple_blocks n) \\<t> (\\<Lambda>\\<^sub>t * int n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t_wise_balance \\<V> (multiple_blocks n) \\<t> (\\<Lambda>\\<^sub>t * int n)", "interpret des: proper_design \\<V> \"(multiple_blocks n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design \\<V> (multiple_blocks n)", "by (simp add: assms multiple_proper_design)"], ["proof (state)\ngoal (1 subgoal):\n 1. t_wise_balance \\<V> (multiple_blocks n) \\<t> (\\<Lambda>\\<^sub>t * int n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_wise_balance \\<V> (multiple_blocks n) \\<t> (\\<Lambda>\\<^sub>t * int n)", "using t_non_zero t_lt_order multiple_t_wise_balance_index"], ["proof (prove)\nusing this:\n  1 \\<le> \\<t>\n  \\<t> \\<le> des.\\<v>\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> int (multiple_blocks ?n index ?ps) =\n                    \\<Lambda>\\<^sub>t * int ?n\n\ngoal (1 subgoal):\n 1. t_wise_balance \\<V> (multiple_blocks n) \\<t> (\\<Lambda>\\<^sub>t * int n)", "by (unfold_locales) (simp_all)"], ["proof (state)\nthis:\n  t_wise_balance \\<V> (multiple_blocks n) \\<t> (\\<Lambda>\\<^sub>t * int n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma twise_set_pair_index: \"ps \\<subseteq> \\<V> \\<Longrightarrow> ps2 \\<subseteq> \\<V> \\<Longrightarrow> ps \\<noteq> ps2 \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> card ps2 = \\<t> \n  \\<Longrightarrow> \\<B> index ps = \\<B> index ps2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps \\<subseteq> \\<V>; ps2 \\<subseteq> \\<V>; ps \\<noteq> ps2;\n     int (card ps) = \\<t>; int (card ps2) = \\<t>\\<rbrakk>\n    \\<Longrightarrow> \\<B> index ps = \\<B> index ps2", "using balanced"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) = \\<Lambda>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ps \\<subseteq> \\<V>; ps2 \\<subseteq> \\<V>; ps \\<noteq> ps2;\n     int (card ps) = \\<t>; int (card ps2) = \\<t>\\<rbrakk>\n    \\<Longrightarrow> \\<B> index ps = \\<B> index ps2", "by (metis of_nat_eq_iff)"], ["", "lemma t_wise_balance_alt: \"ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> \\<B> index ps = l2 \n  \\<Longrightarrow> (\\<And> ps . ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> \\<B> index ps = l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps \\<subseteq> \\<V>; int (card ps) = \\<t>;\n     \\<B> index ps = l2\\<rbrakk>\n    \\<Longrightarrow> (\\<And>ps.\n                          \\<lbrakk>ps \\<subseteq> \\<V>;\n                           int (card ps) = \\<t>\\<rbrakk>\n                          \\<Longrightarrow> \\<B> index ps = l2)", "using twise_set_pair_index"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ps \\<subseteq> \\<V>; ?ps2.0 \\<subseteq> \\<V>;\n   ?ps \\<noteq> ?ps2.0; int (card ?ps) = \\<t>;\n   int (card ?ps2.0) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> \\<B> index ?ps = \\<B> index ?ps2.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ps \\<subseteq> \\<V>; int (card ps) = \\<t>;\n     \\<B> index ps = l2\\<rbrakk>\n    \\<Longrightarrow> (\\<And>ps.\n                          \\<lbrakk>ps \\<subseteq> \\<V>;\n                           int (card ps) = \\<t>\\<rbrakk>\n                          \\<Longrightarrow> \\<B> index ps = l2)", "by blast"], ["", "lemma index_ge_zero: \"\\<Lambda>\\<^sub>t \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Lambda>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Lambda>\\<^sub>t", "obtain ps where \"ps \\<subseteq> \\<V> \\<and> card ps = \\<t>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        ps \\<subseteq> \\<V> \\<and> int (card ps) = \\<t> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using t_non_zero t_lt_order obtain_subset_with_card_n"], ["proof (prove)\nusing this:\n  1 \\<le> \\<t>\n  \\<t> \\<le> \\<v>\n  \\<lbrakk>?n \\<le> card ?S;\n   \\<And>T.\n      \\<lbrakk>T \\<subseteq> ?S; card T = ?n; finite T\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        ps \\<subseteq> \\<V> \\<and> int (card ps) = \\<t> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis dual_order.trans of_nat_le_iff zero_le_imp_eq_int zero_le_one)"], ["proof (state)\nthis:\n  ps \\<subseteq> \\<V> \\<and> int (card ps) = \\<t>\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Lambda>\\<^sub>t", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps \\<subseteq> \\<V> \\<and> int (card ps) = \\<t>\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Lambda>\\<^sub>t", "using balanced_alt_def_all of_nat_0_le_iff"], ["proof (prove)\nusing this:\n  ps \\<subseteq> \\<V> \\<and> int (card ps) = \\<t>\n  \\<forall>ps\\<subseteq>\\<V>.\n     int (card ps) = \\<t> \\<longrightarrow>\n     int (\\<B> index ps) = \\<Lambda>\\<^sub>t\n  (0::?'a) \\<le> of_nat ?n\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Lambda>\\<^sub>t", "by blast"], ["proof (state)\nthis:\n  0 \\<le> \\<Lambda>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_1_imp_mult_1 [simp]: \n  assumes \"\\<Lambda>\\<^sub>t = 1\"\n  assumes \"bl \\<in># \\<B>\"\n  assumes \"card bl \\<ge> \\<t>\"\n  shows \"multiplicity bl = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity bl = 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "assume \"\\<not> (multiplicity bl = 1)\""], ["proof (state)\nthis:\n  multiplicity bl \\<noteq> 1\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  multiplicity bl \\<noteq> 1", "have not: \"multiplicity bl \\<noteq> 1\""], ["proof (prove)\nusing this:\n  multiplicity bl \\<noteq> 1\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1", "by simp"], ["proof (state)\nthis:\n  multiplicity bl \\<noteq> 1\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "have \"multiplicity bl \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  \\<Lambda>\\<^sub>t = 1\n  bl \\<in># \\<B>\n  \\<t> \\<le> int (card bl)\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  multiplicity bl \\<noteq> 0\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  multiplicity bl \\<noteq> 0", "have m: \"multiplicity bl \\<ge> 2\""], ["proof (prove)\nusing this:\n  multiplicity bl \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> multiplicity bl", "using not"], ["proof (prove)\nusing this:\n  multiplicity bl \\<noteq> 0\n  multiplicity bl \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> multiplicity bl", "by linarith"], ["proof (state)\nthis:\n  2 \\<le> multiplicity bl\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "obtain ps where ps: \"ps \\<subseteq> bl \\<and> card ps = \\<t>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        ps \\<subseteq> bl \\<and> int (card ps) = \\<t> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms obtain_t_subset_points"], ["proof (prove)\nusing this:\n  \\<Lambda>\\<^sub>t = 1\n  bl \\<in># \\<B>\n  \\<t> \\<le> int (card bl)\n  (\\<And>T.\n      \\<lbrakk>T \\<subseteq> \\<V>; int (card T) = \\<t>; finite T\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        ps \\<subseteq> bl \\<and> int (card ps) = \\<t> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_subset_with_card_int_n of_nat_0_le_iff)"], ["proof (state)\nthis:\n  ps \\<subseteq> bl \\<and> int (card ps) = \\<t>\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ps \\<subseteq> bl \\<and> int (card ps) = \\<t>", "have \"\\<B> index ps \\<ge> 2\""], ["proof (prove)\nusing this:\n  ps \\<subseteq> bl \\<and> int (card ps) = \\<t>\n\ngoal (1 subgoal):\n 1. 2 \\<le> \\<B> index ps", "using m points_index_count_min ps"], ["proof (prove)\nusing this:\n  ps \\<subseteq> bl \\<and> int (card ps) = \\<t>\n  2 \\<le> multiplicity bl\n  \\<lbrakk>?n \\<le> multiplicity ?bl; ?ps \\<subseteq> ?bl\\<rbrakk>\n  \\<Longrightarrow> ?n \\<le> \\<B> index ?ps\n  ps \\<subseteq> bl \\<and> int (card ps) = \\<t>\n\ngoal (1 subgoal):\n 1. 2 \\<le> \\<B> index ps", "by blast"], ["proof (state)\nthis:\n  2 \\<le> \\<B> index ps\n\ngoal (1 subgoal):\n 1. multiplicity bl \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  2 \\<le> \\<B> index ps", "show False"], ["proof (prove)\nusing this:\n  2 \\<le> \\<B> index ps\n\ngoal (1 subgoal):\n 1. False", "using balanced ps antisym_conv2 not_numeral_less_zero numeral_le_one_iff \n      points_index_ps_nin semiring_norm(69) zero_neq_numeral"], ["proof (prove)\nusing this:\n  2 \\<le> \\<B> index ps\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) = \\<Lambda>\\<^sub>t\n  ps \\<subseteq> bl \\<and> int (card ps) = \\<t>\n  ?x \\<le> ?y \\<Longrightarrow> (\\<not> ?x < ?y) = (?x = ?y)\n  \\<not> numeral ?n < (0::?'a)\n  (numeral ?n \\<le> (1::?'a)) = (?n \\<le> num.One)\n  \\<not> ?ps \\<subseteq> \\<V> \\<Longrightarrow> \\<B> index ?ps = 0\n  (num.Bit0 ?m \\<le> num.One) = False\n  (0::?'a) \\<noteq> numeral ?n\n\ngoal (1 subgoal):\n 1. False", "by (metis assms(1) int_int_eq int_ops(2))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Sub-types of t-wise balance\\<close>"], ["", "text \\<open>Pairwise balance is when $t = 2$. These are commonly of interest\\<close>"], ["", "locale pairwise_balance = t_wise_balance \\<V> \\<B> 2 \\<Lambda> \n  for point_set (\"\\<V>\") and block_collection (\"\\<B>\") and index (\"\\<Lambda>\")"], ["", "text \\<open>We can combine the balance properties with $K$\\_block design to define tBD's \n(t-wise balanced designs), and PBD's (pairwise balanced designs)\\<close>"], ["", "locale tBD = t_wise_balance + K_block_design +\n  assumes block_size_gt_t: \"k \\<in> \\<K> \\<Longrightarrow> k \\<ge> \\<t>\""], ["", "locale \\<Lambda>_PBD = pairwise_balance + K_block_design + \n  assumes block_size_gt_t: \"k \\<in> \\<K> \\<Longrightarrow> k \\<ge> 2\""], ["", "sublocale \\<Lambda>_PBD \\<subseteq> tBD \\<V> \\<B> 2 \\<Lambda> \\<K>"], ["proof (prove)\ngoal (1 subgoal):\n 1. tBD \\<V> \\<B> 2 \\<Lambda> \\<K>", "using t_lt_order block_size_gt_t"], ["proof (prove)\nusing this:\n  2 \\<le> \\<v>\n  ?k \\<in> \\<K> \\<Longrightarrow> 2 \\<le> ?k\n\ngoal (1 subgoal):\n 1. tBD \\<V> \\<B> 2 \\<Lambda> \\<K>", "by (unfold_locales) (simp_all)"], ["", "locale PBD = \\<Lambda>_PBD \\<V> \\<B> 1 \\<K> for point_set (\"\\<V>\") and block_collection (\"\\<B>\") and sizes (\"\\<K>\")\nbegin"], ["", "lemma multiplicity_is_1:\n  assumes \"bl \\<in># \\<B>\"\n  shows \"multiplicity bl = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity bl = 1", "using block_size_gt_t index_1_imp_mult_1"], ["proof (prove)\nusing this:\n  ?k \\<in> \\<K> \\<Longrightarrow> 2 \\<le> ?k\n  \\<lbrakk>1 = 1; ?bl \\<in># \\<B>; 2 \\<le> int (card ?bl)\\<rbrakk>\n  \\<Longrightarrow> multiplicity ?bl = 1\n\ngoal (1 subgoal):\n 1. multiplicity bl = 1", "by (simp add: assms block_sizes)"], ["", "end"], ["", "sublocale PBD \\<subseteq> simple_design"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_design \\<V> \\<B>", "using multiplicity_is_1"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> multiplicity ?bl = 1\n\ngoal (1 subgoal):\n 1. simple_design \\<V> \\<B>", "by (unfold_locales)"], ["", "text \\<open>PBD's are often only used in the case where $k$ is uniform, defined here.\\<close>"], ["", "locale k_\\<Lambda>_PBD = pairwise_balance + block_design + \n  assumes block_size_t: \"2 \\<le> \\<k>\""], ["", "sublocale k_\\<Lambda>_PBD \\<subseteq> \\<Lambda>_PBD \\<V> \\<B> \\<Lambda> \"{\\<k>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>_PBD \\<V> \\<B> \\<Lambda> {\\<k>}", "using k_non_zero uniform block_size_t"], ["proof (prove)\nusing this:\n  1 \\<le> \\<k>\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  2 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. \\<Lambda>_PBD \\<V> \\<B> \\<Lambda> {\\<k>}", "by(unfold_locales) (simp_all)"], ["", "locale k_PBD = k_\\<Lambda>_PBD \\<V> \\<B> 1 \\<k> for point_set (\"\\<V>\") and block_collection (\"\\<B>\") and u_block_size (\"\\<k>\")"], ["", "sublocale k_PBD \\<subseteq> PBD \\<V> \\<B> \"{\\<k>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PBD \\<V> \\<B> {\\<k>}", "using  block_size_t"], ["proof (prove)\nusing this:\n  2 \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. PBD \\<V> \\<B> {\\<k>}", "by (unfold_locales, simp_all)"], ["", "subsubsection \\<open>Covering and Packing Designs\\<close>"], ["", "text \\<open>Covering and packing designs involve a looser balance restriction. Upper/lower bounds\nare placed on the points index, instead of a strict equality\\<close>"], ["", "text \\<open>A t-covering design is a relaxed version of a tBD, where, for all point subsets of size t, \na lower bound is put on the points index\\<close>"], ["", "locale t_covering_design = block_design +\n  fixes grouping :: int (\"\\<t>\")\n  fixes min_index :: int (\"\\<Lambda>\\<^sub>t\")\n  assumes covering: \"ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> \\<B> index ps \\<ge> \\<Lambda>\\<^sub>t\" \n  assumes block_size_t: \"\\<t> \\<le> \\<k>\"\n  assumes t_non_zero: \"\\<t> \\<ge> 1\"\nbegin"], ["", "lemma covering_alt_def_all: \"\\<forall> ps \\<subseteq> \\<V> . card ps = \\<t> \\<longrightarrow> \\<B> index ps \\<ge> \\<Lambda>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps\\<subseteq>\\<V>.\n       int (card ps) = \\<t> \\<longrightarrow>\n       \\<Lambda>\\<^sub>t \\<le> int (\\<B> index ps)", "using covering"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> \\<Lambda>\\<^sub>t \\<le> int (\\<B> index ?ps)\n\ngoal (1 subgoal):\n 1. \\<forall>ps\\<subseteq>\\<V>.\n       int (card ps) = \\<t> \\<longrightarrow>\n       \\<Lambda>\\<^sub>t \\<le> int (\\<B> index ps)", "by auto"], ["", "end"], ["", "lemma (in block_design) t_covering_designI [intro]: \"t \\<le> \\<k> \\<Longrightarrow> t \\<ge> 1 \\<Longrightarrow> \n  (\\<And> ps. ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = t \\<Longrightarrow> \\<B> index ps \\<ge> \\<Lambda>\\<^sub>t) \\<Longrightarrow> t_covering_design \\<V> \\<B> \\<k> t \\<Lambda>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>int t \\<le> \\<k>; 1 \\<le> t;\n     \\<And>ps.\n        \\<lbrakk>ps \\<subseteq> \\<V>; card ps = t\\<rbrakk>\n        \\<Longrightarrow> \\<Lambda>\\<^sub>t \\<le> \\<B> index ps\\<rbrakk>\n    \\<Longrightarrow> t_covering_design \\<V> \\<B> \\<k> (int t)\n                       (int \\<Lambda>\\<^sub>t)", "by (unfold_locales) simp_all"], ["", "text \\<open>A t-packing design is a relaxed version of a tBD, where, for all point subsets of size t, \nan upper bound is put on the points index\\<close>"], ["", "locale t_packing_design = block_design + \n  fixes grouping :: int (\"\\<t>\")\n  fixes min_index :: int (\"\\<Lambda>\\<^sub>t\")\n  assumes packing: \"ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> \\<B> index ps \\<le> \\<Lambda>\\<^sub>t\"\n  assumes block_size_t: \"\\<t> \\<le> \\<k>\"\n  assumes t_non_zero: \"\\<t> \\<ge> 1\"\nbegin"], ["", "lemma packing_alt_def_all: \"\\<forall> ps \\<subseteq> \\<V> . card ps = \\<t> \\<longrightarrow> \\<B> index ps \\<le> \\<Lambda>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps\\<subseteq>\\<V>.\n       int (card ps) = \\<t> \\<longrightarrow>\n       int (\\<B> index ps) \\<le> \\<Lambda>\\<^sub>t", "using packing"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) \\<le> \\<Lambda>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<forall>ps\\<subseteq>\\<V>.\n       int (card ps) = \\<t> \\<longrightarrow>\n       int (\\<B> index ps) \\<le> \\<Lambda>\\<^sub>t", "by auto"], ["", "end"], ["", "lemma (in block_design) t_packing_designI [intro]: \"t \\<le> \\<k> \\<Longrightarrow> t \\<ge> 1 \\<Longrightarrow> \n  (\\<And> ps . ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = t \\<Longrightarrow> \\<B> index ps \\<le> \\<Lambda>\\<^sub>t) \\<Longrightarrow> t_packing_design \\<V> \\<B> \\<k> t \\<Lambda>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>int t \\<le> \\<k>; 1 \\<le> t;\n     \\<And>ps.\n        \\<lbrakk>ps \\<subseteq> \\<V>; card ps = t\\<rbrakk>\n        \\<Longrightarrow> \\<B> index ps \\<le> \\<Lambda>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> t_packing_design \\<V> \\<B> \\<k> (int t)\n                       (int \\<Lambda>\\<^sub>t)", "by (unfold_locales) simp_all"], ["", "lemma packing_covering_imp_balance: \n  assumes \"t_packing_design V B k t \\<Lambda>\\<^sub>t\" \n  assumes \"t_covering_design V B k t \\<Lambda>\\<^sub>t\" \n  shows \"t_wise_balance V B t \\<Lambda>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_wise_balance V B t \\<Lambda>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t_wise_balance V B t \\<Lambda>\\<^sub>t", "from assms"], ["proof (chain)\npicking this:\n  t_packing_design V B k t \\<Lambda>\\<^sub>t\n  t_covering_design V B k t \\<Lambda>\\<^sub>t", "interpret des: proper_design V B"], ["proof (prove)\nusing this:\n  t_packing_design V B k t \\<Lambda>\\<^sub>t\n  t_covering_design V B k t \\<Lambda>\\<^sub>t\n\ngoal (1 subgoal):\n 1. proper_design V B", "using block_design.axioms(1) t_covering_design.axioms(1)"], ["proof (prove)\nusing this:\n  t_packing_design V B k t \\<Lambda>\\<^sub>t\n  t_covering_design V B k t \\<Lambda>\\<^sub>t\n  block_design ?point_set ?block_collection ?u_block_size \\<Longrightarrow>\n  proper_design ?point_set ?block_collection\n  t_covering_design ?point_set ?block_collection ?u_block_size ?grouping\n   ?min_index \\<Longrightarrow>\n  block_design ?point_set ?block_collection ?u_block_size\n\ngoal (1 subgoal):\n 1. proper_design V B", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. t_wise_balance V B t \\<Lambda>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_wise_balance V B t \\<Lambda>\\<^sub>t", "proof (unfold_locales)"], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> t\n 2. t \\<le> des.\\<v>\n 3. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> V; int (card ps) = t\\<rbrakk>\n       \\<Longrightarrow> int (B index ps) = \\<Lambda>\\<^sub>t", "show \"1 \\<le> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> t", "using assms"], ["proof (prove)\nusing this:\n  t_packing_design V B k t \\<Lambda>\\<^sub>t\n  t_covering_design V B k t \\<Lambda>\\<^sub>t\n\ngoal (1 subgoal):\n 1. 1 \\<le> t", "by (simp add: t_packing_design.t_non_zero)"], ["proof (state)\nthis:\n  1 \\<le> t\n\ngoal (2 subgoals):\n 1. t \\<le> des.\\<v>\n 2. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> V; int (card ps) = t\\<rbrakk>\n       \\<Longrightarrow> int (B index ps) = \\<Lambda>\\<^sub>t", "show \"t \\<le> des.\\<v>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> des.\\<v>", "using block_design.block_size_lt_v t_packing_design.axioms(1)"], ["proof (prove)\nusing this:\n  block_design ?point_set ?block_collection ?u_block_size \\<Longrightarrow>\n  ?u_block_size \\<le> int (card ?point_set)\n  t_packing_design ?point_set ?block_collection ?u_block_size ?grouping\n   ?min_index \\<Longrightarrow>\n  block_design ?point_set ?block_collection ?u_block_size\n\ngoal (1 subgoal):\n 1. t \\<le> des.\\<v>", "by (metis assms(1) dual_order.trans t_packing_design.block_size_t)"], ["proof (state)\nthis:\n  t \\<le> des.\\<v>\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> V; int (card ps) = t\\<rbrakk>\n       \\<Longrightarrow> int (B index ps) = \\<Lambda>\\<^sub>t", "show \"\\<And>ps. ps \\<subseteq> V \\<Longrightarrow> card ps = t \\<Longrightarrow> B index ps = \\<Lambda>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> V; int (card ps) = t\\<rbrakk>\n       \\<Longrightarrow> int (B index ps) = \\<Lambda>\\<^sub>t", "using t_packing_design.packing t_covering_design.covering"], ["proof (prove)\nusing this:\n  \\<lbrakk>t_packing_design ?point_set ?block_collection ?u_block_size\n            ?grouping ?min_index;\n   ?ps \\<subseteq> ?point_set; int (card ?ps) = ?grouping\\<rbrakk>\n  \\<Longrightarrow> int (?block_collection index ?ps) \\<le> ?min_index\n  \\<lbrakk>t_covering_design ?point_set ?block_collection ?u_block_size\n            ?grouping ?min_index;\n   ?ps \\<subseteq> ?point_set; int (card ?ps) = ?grouping\\<rbrakk>\n  \\<Longrightarrow> ?min_index \\<le> int (?block_collection index ?ps)\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> V; int (card ps) = t\\<rbrakk>\n       \\<Longrightarrow> int (B index ps) = \\<Lambda>\\<^sub>t", "by (metis assms dual_order.antisym)"], ["proof (state)\nthis:\n  \\<lbrakk>?ps \\<subseteq> V; int (card ?ps) = t\\<rbrakk>\n  \\<Longrightarrow> int (B index ?ps) = \\<Lambda>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t_wise_balance V B t \\<Lambda>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Constant Replication Design\\<close>"], ["", "text \\<open>When the replication number for all points in a design is constant, it is the \ndesign replication number.\\<close>"], ["", "locale constant_rep_design = proper_design +\n  fixes design_rep_number :: int (\"\\<r>\")\n  assumes rep_number [simp]: \"x \\<in> \\<V> \\<Longrightarrow>  \\<B> rep x = \\<r>\" \n\nbegin"], ["", "lemma rep_number_alt_def_all: \"\\<forall> x \\<in> \\<V>. \\<B> rep x = \\<r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<V>. \\<B> rep x = \\<r>", "by (simp)"], ["", "lemma rep_number_unfold_set: \"x \\<in> \\<V> \\<Longrightarrow> size {#bl \\<in># \\<B> . x \\<in> bl#} = \\<r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<V> \\<Longrightarrow>\n    int (size (filter_mset ((\\<in>) x) \\<B>)) = \\<r>", "using rep_number"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = \\<r>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<V> \\<Longrightarrow>\n    int (size (filter_mset ((\\<in>) x) \\<B>)) = \\<r>", "by (simp add: point_replication_number_def)"], ["", "lemma rep_numbers_constant [simp]: \"replication_numbers  = {\\<r>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replication_numbers = {\\<r>}", "unfolding replication_numbers_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<B> rep x |x. x \\<in> \\<V>} = {\\<r>}", "using rep_number design_points_nempty Collect_cong finite.cases \n    finite_sets insertCI singleton_conv"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = \\<r>\n  \\<V> \\<noteq> {}\n  (\\<And>x. ?P x = ?Q x) \\<Longrightarrow> {x. ?P x} = {x. ?Q x}\n  \\<lbrakk>finite ?a; ?a = {} \\<Longrightarrow> ?P;\n   \\<And>A a.\n      \\<lbrakk>?a = insert a A; finite A\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  finite \\<V>\n  (?a \\<notin> ?B \\<Longrightarrow> ?a = ?b) \\<Longrightarrow>\n  ?a \\<in> insert ?b ?B\n  {x. x = ?a} = {?a}\n\ngoal (1 subgoal):\n 1. {\\<B> rep x |x. x \\<in> \\<V>} = {\\<r>}", "by (smt (verit, ccfv_threshold) fst_conv snd_conv)"], ["", "lemma replication_number_single: \"is_singleton (replication_numbers)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_singleton replication_numbers", "using is_singleton_the_elem"], ["proof (prove)\nusing this:\n  is_singleton ?A = (?A = {the_elem ?A})\n\ngoal (1 subgoal):\n 1. is_singleton replication_numbers", "by simp"], ["", "lemma constant_rep_point_pair: \"x1 \\<in> \\<V> \\<Longrightarrow> x2 \\<in> \\<V> \\<Longrightarrow> x1 \\<noteq> x2 \\<Longrightarrow> \\<B> rep x1 = \\<B> rep x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x1 \\<in> \\<V>; x2 \\<in> \\<V>; x1 \\<noteq> x2\\<rbrakk>\n    \\<Longrightarrow> \\<B> rep x1 = \\<B> rep x2", "using rep_number"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = \\<r>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x1 \\<in> \\<V>; x2 \\<in> \\<V>; x1 \\<noteq> x2\\<rbrakk>\n    \\<Longrightarrow> \\<B> rep x1 = \\<B> rep x2", "by auto"], ["", "lemma constant_rep_alt: \"x1 \\<in> \\<V> \\<Longrightarrow> \\<B> rep x1 = r2 \\<Longrightarrow> (\\<And> x . x \\<in> \\<V> \\<Longrightarrow> \\<B> rep x = r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x1 \\<in> \\<V>; \\<B> rep x1 = r2\\<rbrakk>\n    \\<Longrightarrow> (\\<And>x.\n                          x \\<in> \\<V> \\<Longrightarrow> \\<B> rep x = r2)", "by (simp)"], ["", "lemma constant_rep_point_not_0:\n  assumes \"x \\<in> \\<V>\" \n  shows \"\\<B> rep x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B> rep x \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<B> rep x \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> \\<B> rep x \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> \\<B> rep x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> \\<B> rep x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<B> rep x \\<noteq> 0", "have \"\\<And> x . x \\<in> \\<V> \\<Longrightarrow> \\<B> rep x = 0\""], ["proof (prove)\nusing this:\n  \\<not> \\<B> rep x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<V> \\<Longrightarrow> \\<B> rep x = 0", "using rep_number assms"], ["proof (prove)\nusing this:\n  \\<not> \\<B> rep x \\<noteq> 0\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = \\<r>\n  x \\<in> \\<V>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<V> \\<Longrightarrow> \\<B> rep x = 0", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = 0\n\ngoal (1 subgoal):\n 1. \\<not> \\<B> rep x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = 0", "have \"\\<And> x . x \\<in> \\<V> \\<Longrightarrow>  size {#bl \\<in># \\<B> . x \\<in> bl#} = 0\""], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<V> \\<Longrightarrow>\n       size (filter_mset ((\\<in>) x) \\<B>) = 0", "by (simp add: point_replication_number_def)"], ["proof (state)\nthis:\n  ?x \\<in> \\<V> \\<Longrightarrow> size (filter_mset ((\\<in>) ?x) \\<B>) = 0\n\ngoal (1 subgoal):\n 1. \\<not> \\<B> rep x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> \\<V> \\<Longrightarrow> size (filter_mset ((\\<in>) ?x) \\<B>) = 0", "show False"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow> size (filter_mset ((\\<in>) ?x) \\<B>) = 0\n\ngoal (1 subgoal):\n 1. False", "using design_blocks_nempty wf_design wf_design_iff wf_invalid_point"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow> size (filter_mset ((\\<in>) ?x) \\<B>) = 0\n  \\<B> \\<noteq> {#}\n  design \\<V> \\<B>\n  ?bl \\<in># \\<B> \\<Longrightarrow>\n  design \\<V> \\<B> =\n  (?bl \\<subseteq> \\<V> \\<and> finite \\<V> \\<and> ?bl \\<noteq> {})\n  \\<lbrakk>?x \\<notin> \\<V>; ?b \\<in># \\<B>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> ?b\n\ngoal (1 subgoal):\n 1. False", "by (metis ex_in_conv filter_mset_empty_conv multiset_nonemptyE size_eq_0_iff_empty)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rep_not_zero: \"\\<r> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r> \\<noteq> 0", "using rep_number constant_rep_point_not_0 design_points_nempty"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = \\<r>\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x \\<noteq> 0\n  \\<V> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<r> \\<noteq> 0", "by auto"], ["", "lemma r_gzero: \"\\<r> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<r>", "using point_replication_number_def rep_number constant_rep_design.rep_not_zero"], ["proof (prove)\nusing this:\n  ?B rep ?x \\<equiv> int (size (filter_mset ((\\<in>) ?x) ?B))\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = \\<r>\n  constant_rep_design ?point_set ?block_collection\n   ?design_rep_number \\<Longrightarrow>\n  ?design_rep_number \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < \\<r>", "by (metis constant_rep_design.intro constant_rep_design_axioms.intro leI of_nat_less_0_iff \n      proper_design_axioms verit_la_disequality)"], ["", "lemma r_lt_eq_b: \"\\<r> \\<le> \\<b>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r> \\<le> \\<b>", "using rep_number max_point_rep"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = \\<r>\n  ?B rep ?x \\<le> int (size ?B)\n\ngoal (1 subgoal):\n 1. \\<r> \\<le> \\<b>", "by (metis all_not_in_conv design_points_nempty)"], ["", "lemma complement_rep_number: \n  assumes \"\\<And> bl . bl \\<in># \\<B> \\<Longrightarrow> incomplete_block bl\"\n  shows \"constant_rep_design \\<V> \\<B>\\<^sup>C (\\<b> - \\<r>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> \\<B>\\<^sup>C (\\<b> - \\<r>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> \\<B>\\<^sup>C (\\<b> - \\<r>)", "interpret d: proper_design \\<V> \"(\\<B>\\<^sup>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B>\\<^sup>C", "using complement_proper_design"], ["proof (prove)\nusing this:\n  (\\<And>bl.\n      bl \\<in># \\<B> \\<Longrightarrow>\n      incomplete_block bl) \\<Longrightarrow>\n  proper_design \\<V> \\<B>\\<^sup>C\n\ngoal (1 subgoal):\n 1. proper_design \\<V> \\<B>\\<^sup>C", "by (simp add: assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> \\<B>\\<^sup>C (\\<b> - \\<r>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> \\<B>\\<^sup>C (\\<b> - \\<r>)", "using complement_rep_number rep_number"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> \\<V>; \\<B> rep ?x = ?r\\<rbrakk>\n  \\<Longrightarrow> \\<B>\\<^sup>C rep ?x = \\<b> - ?r\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = \\<r>\n\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> \\<B>\\<^sup>C (\\<b> - \\<r>)", "by (unfold_locales) simp"], ["proof (state)\nthis:\n  constant_rep_design \\<V> \\<B>\\<^sup>C (\\<b> - \\<r>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multiple_rep_number: \n  assumes \"n > 0\"\n  shows \"constant_rep_design \\<V> (multiple_blocks n) (\\<r> * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> (multiple_blocks n) (\\<r> * int n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> (multiple_blocks n) (\\<r> * int n)", "interpret d: proper_design \\<V> \"(multiple_blocks n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_design \\<V> (multiple_blocks n)", "using multiple_proper_design"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> proper_design \\<V> (multiple_blocks ?n)\n\ngoal (1 subgoal):\n 1. proper_design \\<V> (multiple_blocks n)", "by (simp add: assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> (multiple_blocks n) (\\<r> * int n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> (multiple_blocks n) (\\<r> * int n)", "using multiple_point_rep_num"], ["proof (prove)\nusing this:\n  multiple_blocks ?n rep ?x = \\<B> rep ?x * int ?n\n\ngoal (1 subgoal):\n 1. constant_rep_design \\<V> (multiple_blocks n) (\\<r> * int n)", "by (unfold_locales) (simp_all)"], ["proof (state)\nthis:\n  constant_rep_design \\<V> (multiple_blocks n) (\\<r> * int n)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma (in proper_design) constant_rep_designI [intro]: \"(\\<And> x . x \\<in> \\<V> \\<Longrightarrow> \\<B> rep x = \\<r>) \n    \\<Longrightarrow> constant_rep_design \\<V> \\<B> \\<r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> \\<V> \\<Longrightarrow> \\<B> rep x = \\<r>) \\<Longrightarrow>\n    constant_rep_design \\<V> \\<B> \\<r>", "by unfold_locales auto"], ["", "subsection \\<open>T-designs\\<close>"], ["", "text \\<open>All the before mentioned designs build up to the concept of a t-design, which has uniform \nblock size and is t-wise balanced. We limit $t$ to be less than $k$, so the balance condition has \nrelevance\\<close>"], ["", "locale t_design = incomplete_design + t_wise_balance + \n  assumes block_size_t: \"\\<t> \\<le> \\<k>\"\nbegin"], ["", "lemma point_indices_balanced: \"point_indices \\<t> = {\\<Lambda>\\<^sub>t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point_indices \\<t> = {\\<Lambda>\\<^sub>t}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. point_indices \\<t> = {\\<Lambda>\\<^sub>t}", "have \"point_indices \\<t> = {i . \\<exists> ps . i = \\<B> index ps \\<and> int (card ps) = \\<t> \\<and> ps \\<subseteq> \\<V>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point_indices \\<t> =\n    {int (\\<B> index ps) |ps.\n     int (card ps) = \\<t> \\<and> ps \\<subseteq> \\<V>}", "by (simp add: point_indices_def)"], ["proof (state)\nthis:\n  point_indices \\<t> =\n  {int (\\<B> index ps) |ps. int (card ps) = \\<t> \\<and> ps \\<subseteq> \\<V>}\n\ngoal (1 subgoal):\n 1. point_indices \\<t> = {\\<Lambda>\\<^sub>t}", "then"], ["proof (chain)\npicking this:\n  point_indices \\<t> =\n  {int (\\<B> index ps) |ps. int (card ps) = \\<t> \\<and> ps \\<subseteq> \\<V>}", "have \"point_indices  \\<t> = {i . i = \\<Lambda>\\<^sub>t}\""], ["proof (prove)\nusing this:\n  point_indices \\<t> =\n  {int (\\<B> index ps) |ps. int (card ps) = \\<t> \\<and> ps \\<subseteq> \\<V>}\n\ngoal (1 subgoal):\n 1. point_indices \\<t> = {i. i = \\<Lambda>\\<^sub>t}", "using balanced Collect_cong obtain_t_subset_points"], ["proof (prove)\nusing this:\n  point_indices \\<t> =\n  {int (\\<B> index ps) |ps. int (card ps) = \\<t> \\<and> ps \\<subseteq> \\<V>}\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) = \\<Lambda>\\<^sub>t\n  (\\<And>x. ?P x = ?Q x) \\<Longrightarrow> {x. ?P x} = {x. ?Q x}\n  (\\<And>T.\n      \\<lbrakk>T \\<subseteq> \\<V>; int (card T) = \\<t>; finite T\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. point_indices \\<t> = {i. i = \\<Lambda>\\<^sub>t}", "by smt"], ["proof (state)\nthis:\n  point_indices \\<t> = {i. i = \\<Lambda>\\<^sub>t}\n\ngoal (1 subgoal):\n 1. point_indices \\<t> = {\\<Lambda>\\<^sub>t}", "thus ?thesis"], ["proof (prove)\nusing this:\n  point_indices \\<t> = {i. i = \\<Lambda>\\<^sub>t}\n\ngoal (1 subgoal):\n 1. point_indices \\<t> = {\\<Lambda>\\<^sub>t}", "by auto"], ["proof (state)\nthis:\n  point_indices \\<t> = {\\<Lambda>\\<^sub>t}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma point_indices_singleton: \"is_singleton (point_indices \\<t>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_singleton (point_indices \\<t>)", "using point_indices_balanced is_singleton_the_elem"], ["proof (prove)\nusing this:\n  point_indices \\<t> = {\\<Lambda>\\<^sub>t}\n  is_singleton ?A = (?A = {the_elem ?A})\n\ngoal (1 subgoal):\n 1. is_singleton (point_indices \\<t>)", "by simp"], ["", "end"], ["", "lemma t_designI [intro]: \n  assumes \"incomplete_design V B k\"\n  assumes \"t_wise_balance V B t \\<Lambda>\\<^sub>t\"\n  assumes \"t \\<le> k\"\n  shows \"t_design V B k t \\<Lambda>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_design V B k t \\<Lambda>\\<^sub>t", "by (simp add: assms(1) assms(2) assms(3) t_design.intro t_design_axioms.intro)"], ["", "sublocale t_design \\<subseteq> t_covering_design \\<V> \\<B> \\<k> \\<t> \\<Lambda>\\<^sub>t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_covering_design \\<V> \\<B> \\<k> \\<t> \\<Lambda>\\<^sub>t", "using t_non_zero"], ["proof (prove)\nusing this:\n  1 \\<le> \\<t>\n\ngoal (1 subgoal):\n 1. t_covering_design \\<V> \\<B> \\<k> \\<t> \\<Lambda>\\<^sub>t", "by (unfold_locales) (auto simp add: block_size_t)"], ["", "sublocale t_design \\<subseteq> t_packing_design \\<V> \\<B> \\<k> \\<t> \\<Lambda>\\<^sub>t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_packing_design \\<V> \\<B> \\<k> \\<t> \\<Lambda>\\<^sub>t", "using t_non_zero"], ["proof (prove)\nusing this:\n  1 \\<le> \\<t>\n\ngoal (1 subgoal):\n 1. t_packing_design \\<V> \\<B> \\<k> \\<t> \\<Lambda>\\<^sub>t", "by (unfold_locales) (auto simp add: block_size_t)"], ["", "lemma t_design_pack_cov [intro]: \n  assumes \"k < card V\"\n  assumes \"t_covering_design V B k t \\<Lambda>\\<^sub>t\"\n  assumes \"t_packing_design V B k t \\<Lambda>\\<^sub>t\"\n  shows \"t_design V B k t \\<Lambda>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_design V B (int k) t \\<Lambda>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t_design V B (int k) t \\<Lambda>\\<^sub>t", "from assms"], ["proof (chain)\npicking this:\n  k < card V\n  t_covering_design V B (int k) t \\<Lambda>\\<^sub>t\n  t_packing_design V B (int k) t \\<Lambda>\\<^sub>t", "interpret id: incomplete_design V B k"], ["proof (prove)\nusing this:\n  k < card V\n  t_covering_design V B (int k) t \\<Lambda>\\<^sub>t\n  t_packing_design V B (int k) t \\<Lambda>\\<^sub>t\n\ngoal (1 subgoal):\n 1. incomplete_design V B (int k)", "using block_design.incomplete_designI t_packing_design.axioms(1)"], ["proof (prove)\nusing this:\n  k < card V\n  t_covering_design V B (int k) t \\<Lambda>\\<^sub>t\n  t_packing_design V B (int k) t \\<Lambda>\\<^sub>t\n  \\<lbrakk>block_design ?point_set ?block_collection ?u_block_size;\n   ?u_block_size < int (card ?point_set)\\<rbrakk>\n  \\<Longrightarrow> incomplete_design ?point_set ?block_collection\n                     ?u_block_size\n  t_packing_design ?point_set ?block_collection ?u_block_size ?grouping\n   ?min_index \\<Longrightarrow>\n  block_design ?point_set ?block_collection ?u_block_size\n\ngoal (1 subgoal):\n 1. incomplete_design V B (int k)", "by (metis of_nat_less_iff)"], ["proof (state)\ngoal (1 subgoal):\n 1. t_design V B (int k) t \\<Lambda>\\<^sub>t", "from assms"], ["proof (chain)\npicking this:\n  k < card V\n  t_covering_design V B (int k) t \\<Lambda>\\<^sub>t\n  t_packing_design V B (int k) t \\<Lambda>\\<^sub>t", "interpret balance: t_wise_balance V B t \\<Lambda>\\<^sub>t"], ["proof (prove)\nusing this:\n  k < card V\n  t_covering_design V B (int k) t \\<Lambda>\\<^sub>t\n  t_packing_design V B (int k) t \\<Lambda>\\<^sub>t\n\ngoal (1 subgoal):\n 1. t_wise_balance V B t \\<Lambda>\\<^sub>t", "using packing_covering_imp_balance"], ["proof (prove)\nusing this:\n  k < card V\n  t_covering_design V B (int k) t \\<Lambda>\\<^sub>t\n  t_packing_design V B (int k) t \\<Lambda>\\<^sub>t\n  \\<lbrakk>t_packing_design ?V ?B ?k ?t ?\\<Lambda>\\<^sub>t;\n   t_covering_design ?V ?B ?k ?t ?\\<Lambda>\\<^sub>t\\<rbrakk>\n  \\<Longrightarrow> t_wise_balance ?V ?B ?t ?\\<Lambda>\\<^sub>t\n\ngoal (1 subgoal):\n 1. t_wise_balance V B t \\<Lambda>\\<^sub>t", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. t_design V B (int k) t \\<Lambda>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_design V B (int k) t \\<Lambda>\\<^sub>t", "using assms(3)"], ["proof (prove)\nusing this:\n  t_packing_design V B (int k) t \\<Lambda>\\<^sub>t\n\ngoal (1 subgoal):\n 1. t_design V B (int k) t \\<Lambda>\\<^sub>t", "by (unfold_locales) (simp_all add: t_packing_design.block_size_t)"], ["proof (state)\nthis:\n  t_design V B (int k) t \\<Lambda>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale t_design \\<subseteq> tBD \\<V> \\<B> \\<t> \\<Lambda>\\<^sub>t \"{\\<k>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tBD \\<V> \\<B> \\<t> \\<Lambda>\\<^sub>t {\\<k>}", "using uniform k_non_zero block_size_t"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  1 \\<le> \\<k>\n  \\<t> \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. tBD \\<V> \\<B> \\<t> \\<Lambda>\\<^sub>t {\\<k>}", "by (unfold_locales) simp_all"], ["", "context t_design \nbegin"], ["", "lemma multiple_t_design: \"n > 0 \\<Longrightarrow> t_design \\<V> (multiple_blocks n) \\<k> \\<t> (\\<Lambda>\\<^sub>t * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    t_design \\<V> (multiple_blocks n) \\<k> \\<t> (\\<Lambda>\\<^sub>t * int n)", "using multiple_t_wise_balance multiple_incomplete block_size_t"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow>\n  t_wise_balance \\<V> (multiple_blocks ?n) \\<t> (\\<Lambda>\\<^sub>t * int ?n)\n  0 < ?n \\<Longrightarrow> incomplete_design \\<V> (multiple_blocks ?n) \\<k>\n  \\<t> \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    t_design \\<V> (multiple_blocks n) \\<k> \\<t> (\\<Lambda>\\<^sub>t * int n)", "by (simp add: t_designI)"], ["", "lemma t_design_min_v: \"\\<v> > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < \\<v>", "using k_non_zero incomplete"], ["proof (prove)\nusing this:\n  1 \\<le> \\<k>\n  \\<k> < \\<v>\n\ngoal (1 subgoal):\n 1. 1 < \\<v>", "by simp"], ["", "end"], ["", "subsection \\<open>Steiner Systems\\<close>"], ["", "text \\<open>Steiner systems are a special type of t-design where $\\Lambda_t = 1$\\<close>"], ["", "locale steiner_system = t_design \\<V> \\<B> \\<k> \\<t> 1 \n  for point_set (\"\\<V>\") and block_collection (\"\\<B>\") and u_block_size (\"\\<k>\") and grouping (\"\\<t>\")\n\nbegin"], ["", "lemma block_multiplicity [simp]: \n  assumes \"bl \\<in># \\<B>\"\n  shows \"multiplicity bl = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity bl = 1", "by (simp add: assms block_size_t)"], ["", "end"], ["", "sublocale steiner_system \\<subseteq> simple_design"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_design \\<V> \\<B>", "by unfold_locales (simp)"], ["", "lemma (in t_design) steiner_systemI[intro]: \"\\<Lambda>\\<^sub>t = 1 \\<Longrightarrow> steiner_system \\<V> \\<B> \\<k> \\<t>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>\\<^sub>t = 1 \\<Longrightarrow>\n    steiner_system \\<V> \\<B> \\<k> \\<t>", "using t_non_zero t_lt_order block_size_t"], ["proof (prove)\nusing this:\n  1 \\<le> \\<t>\n  \\<t> \\<le> \\<v>\n  \\<t> \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. \\<Lambda>\\<^sub>t = 1 \\<Longrightarrow>\n    steiner_system \\<V> \\<B> \\<k> \\<t>", "by unfold_locales auto"], ["", "subsection \\<open>Combining block designs\\<close>"], ["", "text \\<open>We define some closure properties for various block designs under the combine operator.\nThis is done using locales to reason on multiple instances of the same type of design, building \non what was presented in the design operations theory\\<close>"], ["", "locale two_t_wise_eq_points = two_designs_proper \\<V> \\<B> \\<V> \\<B>' + des1: t_wise_balance \\<V> \\<B> \\<t> \\<Lambda>\\<^sub>t + \n  des2: t_wise_balance \\<V> \\<B>' \\<t> \\<Lambda>\\<^sub>t' for \\<V> \\<B> \\<t> \\<Lambda>\\<^sub>t \\<B>' \\<Lambda>\\<^sub>t'\nbegin"], ["", "lemma combine_t_wise_balance_index: \"ps \\<subseteq> \\<V> \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> \\<B>\\<^sup>+ index ps = (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps \\<subseteq> \\<V>; int (card ps) = \\<t>\\<rbrakk>\n    \\<Longrightarrow> int (\\<B>\\<^sup>+ index ps) =\n                      \\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t'", "using des1.balanced des2.balanced"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> int (\\<B> index ?ps) = \\<Lambda>\\<^sub>t\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> int (\\<B>' index ?ps) = \\<Lambda>\\<^sub>t'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ps \\<subseteq> \\<V>; int (card ps) = \\<t>\\<rbrakk>\n    \\<Longrightarrow> int (\\<B>\\<^sup>+ index ps) =\n                      \\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t'", "by (simp add: combine_points_index)"], ["", "lemma combine_t_wise_balance: \"t_wise_balance \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<t> (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_wise_balance \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<t>\n     (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')", "proof (unfold_locales, simp add: des1.t_non_zero)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<t> \\<le> int (card \\<V>\\<^sup>+)\n 2. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> \\<V>\\<^sup>+; int (card ps) = \\<t>\\<rbrakk>\n       \\<Longrightarrow> int (\\<B>\\<^sup>+ index ps) =\n                         \\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t'", "have \"card \\<V>\\<^sup>+  \\<ge> card \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card \\<V> \\<le> card \\<V>\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  card \\<V> \\<le> card \\<V>\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<t> \\<le> int (card \\<V>\\<^sup>+)\n 2. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> \\<V>\\<^sup>+; int (card ps) = \\<t>\\<rbrakk>\n       \\<Longrightarrow> int (\\<B>\\<^sup>+ index ps) =\n                         \\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t'", "then"], ["proof (chain)\npicking this:\n  card \\<V> \\<le> card \\<V>\\<^sup>+", "show \"\\<t> \\<le> card (\\<V>\\<^sup>+)\""], ["proof (prove)\nusing this:\n  card \\<V> \\<le> card \\<V>\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<t> \\<le> int (card \\<V>\\<^sup>+)", "using des1.t_lt_order"], ["proof (prove)\nusing this:\n  card \\<V> \\<le> card \\<V>\\<^sup>+\n  \\<t> \\<le> sys2.\\<v>\n\ngoal (1 subgoal):\n 1. \\<t> \\<le> int (card \\<V>\\<^sup>+)", "by linarith"], ["proof (state)\nthis:\n  \\<t> \\<le> int (card \\<V>\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> \\<V>\\<^sup>+; int (card ps) = \\<t>\\<rbrakk>\n       \\<Longrightarrow> int (\\<B>\\<^sup>+ index ps) =\n                         \\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t'", "show \"\\<And>ps. ps \\<subseteq> \\<V>\\<^sup>+ \\<Longrightarrow> card ps = \\<t> \\<Longrightarrow> (\\<B>\\<^sup>+ index ps) = \\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> \\<V>\\<^sup>+; int (card ps) = \\<t>\\<rbrakk>\n       \\<Longrightarrow> int (\\<B>\\<^sup>+ index ps) =\n                         \\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t'", "using combine_t_wise_balance_index"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ps \\<subseteq> \\<V>; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> int (\\<B>\\<^sup>+ index ?ps) =\n                    \\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t'\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<subseteq> \\<V>\\<^sup>+; int (card ps) = \\<t>\\<rbrakk>\n       \\<Longrightarrow> int (\\<B>\\<^sup>+ index ps) =\n                         \\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t'", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?ps \\<subseteq> \\<V>\\<^sup>+; int (card ?ps) = \\<t>\\<rbrakk>\n  \\<Longrightarrow> int (\\<B>\\<^sup>+ index ?ps) =\n                    \\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t'\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale combine_t_wise_des: t_wise_balance \"\\<V>\\<^sup>+\" \"\\<B>\\<^sup>+\" \"\\<t>\" \"(\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_wise_balance \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<t>\n     (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')", "using combine_t_wise_balance"], ["proof (prove)\nusing this:\n  t_wise_balance \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<t>\n   (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')\n\ngoal (1 subgoal):\n 1. t_wise_balance \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<t>\n     (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')", "by auto"], ["", "end"], ["", "locale two_k_block_designs = two_designs_proper \\<V> \\<B> \\<V>' \\<B>' + des1: block_design \\<V> \\<B> \\<k> + \n  des2: block_design \\<V>' \\<B>' \\<k> for \\<V> \\<B> \\<k> \\<V>' \\<B>'\nbegin"], ["", "lemma block_design_combine: \"block_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. block_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>", "using des1.uniform des2.uniform"], ["proof (prove)\nusing this:\n  ?bl \\<in># \\<B> \\<Longrightarrow> int (card ?bl) = \\<k>\n  ?bl \\<in># \\<B>' \\<Longrightarrow> int (card ?bl) = \\<k>\n\ngoal (1 subgoal):\n 1. block_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>", "by (unfold_locales) (auto)"], ["", "sublocale combine_block_des: block_design \"\\<V>\\<^sup>+\" \"\\<B>\\<^sup>+\" \"\\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. block_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>", "using block_design_combine"], ["proof (prove)\nusing this:\n  block_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>\n\ngoal (1 subgoal):\n 1. block_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>", "by simp"], ["", "end"], ["", "locale two_rep_designs_eq_points = two_designs_proper \\<V> \\<B> \\<V> \\<B>' + des1: constant_rep_design \\<V> \\<B> \\<r> + \n  des2: constant_rep_design \\<V> \\<B>' \\<r>' for \\<V> \\<B> \\<r> \\<B>' \\<r>' \nbegin"], ["", "lemma combine_rep_number: \"constant_rep_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ (\\<r> + \\<r>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_rep_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ (\\<r> + \\<r>')", "using combine_rep_number des1.rep_number des2.rep_number"], ["proof (prove)\nusing this:\n  \\<B>\\<^sup>+ rep ?x = \\<B> rep ?x + \\<B>' rep ?x\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B> rep ?x = \\<r>\n  ?x \\<in> \\<V> \\<Longrightarrow> \\<B>' rep ?x = \\<r>'\n\ngoal (1 subgoal):\n 1. constant_rep_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ (\\<r> + \\<r>')", "by (unfold_locales) (simp)"], ["", "sublocale combine_const_rep: constant_rep_design \"\\<V>\\<^sup>+\" \"\\<B>\\<^sup>+\" \"(\\<r> + \\<r>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_rep_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ (\\<r> + \\<r>')", "using combine_rep_number"], ["proof (prove)\nusing this:\n  constant_rep_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ (\\<r> + \\<r>')\n\ngoal (1 subgoal):\n 1. constant_rep_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ (\\<r> + \\<r>')", "by simp"], ["", "end"], ["", "locale two_incomplete_designs = two_k_block_designs \\<V> \\<B> \\<k> \\<V>' \\<B>' + des1: incomplete_design \\<V> \\<B> \\<k> + \n  des2: incomplete_design \\<V>' \\<B>' \\<k> for \\<V> \\<B> \\<k> \\<V>' \\<B>'\nbegin"], ["", "lemma combine_is_incomplete: \"incomplete_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incomplete_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>", "using combine_order des1.incomplete des2.incomplete"], ["proof (prove)\nusing this:\n  card \\<V> \\<le> card \\<V>\\<^sup>+\n  \\<k> < sys1.\\<v>\n  \\<k> < sys2.\\<v>\n\ngoal (1 subgoal):\n 1. incomplete_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>", "by (unfold_locales) (simp)"], ["", "sublocale combine_incomplete: incomplete_design \"\\<V>\\<^sup>+\" \"\\<B>\\<^sup>+\" \"\\<k>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incomplete_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>", "using combine_is_incomplete"], ["proof (prove)\nusing this:\n  incomplete_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>\n\ngoal (1 subgoal):\n 1. incomplete_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k>", "by simp"], ["", "end"], ["", "locale two_t_designs_eq_points = two_incomplete_designs \\<V> \\<B> \\<k> \\<V> \\<B>' \n  + two_t_wise_eq_points \\<V> \\<B> \\<t> \\<Lambda>\\<^sub>t \\<B>' \\<Lambda>\\<^sub>t' + des1: t_design \\<V> \\<B> \\<k> \\<t> \\<Lambda>\\<^sub>t + \n  des2: t_design \\<V> \\<B>' \\<k> \\<t> \\<Lambda>\\<^sub>t' for \\<V> \\<B> \\<k> \\<B>' \\<t> \\<Lambda>\\<^sub>t \\<Lambda>\\<^sub>t'\nbegin"], ["", "lemma combine_is_t_des: \"t_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k> \\<t> (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k> \\<t>\n     (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')", "using des1.block_size_t des2.block_size_t"], ["proof (prove)\nusing this:\n  \\<t> \\<le> \\<k>\n  \\<t> \\<le> \\<k>\n\ngoal (1 subgoal):\n 1. t_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k> \\<t>\n     (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')", "by (unfold_locales)"], ["", "sublocale combine_t_des: t_design \"\\<V>\\<^sup>+\" \"\\<B>\\<^sup>+\" \"\\<k>\" \"\\<t>\" \"(\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k> \\<t>\n     (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')", "using combine_is_t_des"], ["proof (prove)\nusing this:\n  t_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k> \\<t>\n   (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')\n\ngoal (1 subgoal):\n 1. t_design \\<V>\\<^sup>+ \\<B>\\<^sup>+ \\<k> \\<t>\n     (\\<Lambda>\\<^sub>t + \\<Lambda>\\<^sub>t')", "by blast"], ["", "end"], ["", "end"]]}