{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Examples/Array_Blit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma blit_rule[sep_heap_rules]:\n    assumes LEN: \"si+len \\<le> length lsrc\" \"di+len \\<le> length ldst\"\n    shows\n    \"< src \\<mapsto>\\<^sub>a lsrc \n      * dst \\<mapsto>\\<^sub>a ldst >\n    blit src si dst di len\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a lsrc \n      * dst \\<mapsto>\\<^sub>a (take di ldst @ take len (drop si lsrc) @ drop (di+len) ldst)\n    >\"", "lemma [code]:\n    \"blit src si dst di len \n      = blit' src (integer_of_nat si) dst (integer_of_nat di) \n          (integer_of_nat len)\"", "lemma [code]: \n    \"nth_oo v a == nth_oo' v a o integer_of_nat\"\n    \"upd_oo f == upd_oo' f o integer_of_nat\"", "lemmas [code] = nth_oo'_def[unfolded nth_oo_def[abs_def]]", "lemmas [code] = upd_oo'_def[unfolded upd_oo_def[abs_def]]", "lemma array_shrink_rule[sep_heap_rules]:\n    assumes \"s\\<le>length la\"\n    shows \"< a\\<mapsto>\\<^sub>ala > array_shrink a s <\\<lambda>a'. a'\\<mapsto>\\<^sub>atake s la >\\<^sub>t\"", "lemma array_grow_rule[sep_heap_rules]:\n    assumes \"s\\<ge>length la\"\n    shows \"\n      < a\\<mapsto>\\<^sub>ala > \n        array_grow a s x \n      <\\<lambda>a'. a'\\<mapsto>\\<^sub>a (la @ replicate (s-length la) x)>\\<^sub>t\"", "lemma array_copy_rule[sep_heap_rules]:\n    \"\n      < a\\<mapsto>\\<^sub>al> \n        array_copy a \n      <\\<lambda>a'. a\\<mapsto>\\<^sub>al * a'\\<mapsto>\\<^sub>a l>\""], "translations": [["", "lemma blit_rule[sep_heap_rules]:\n    assumes LEN: \"si+len \\<le> length lsrc\" \"di+len \\<le> length ldst\"\n    shows\n    \"< src \\<mapsto>\\<^sub>a lsrc \n      * dst \\<mapsto>\\<^sub>a ldst >\n    blit src si dst di len\n    <\\<lambda>_. src \\<mapsto>\\<^sub>a lsrc \n      * dst \\<mapsto>\\<^sub>a (take di ldst @ take len (drop si lsrc) @ drop (di+len) ldst)\n    >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n    blit src si dst di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a lsrc *\n        dst \\<mapsto>\\<^sub>a\n        (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>", "using LEN"], ["proof (prove)\nusing this:\n  si + len \\<le> length lsrc\n  di + len \\<le> length ldst\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n    blit src si dst di len\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a lsrc *\n        dst \\<mapsto>\\<^sub>a\n        (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>", "proof (induction len arbitrary: si di ldst)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>si di ldst.\n       \\<lbrakk>si + 0 \\<le> length lsrc; di + 0 \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         blit src si dst di 0\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take 0 (drop si lsrc) @ drop (di + 0) ldst)>\n 2. \\<And>len si di ldst.\n       \\<lbrakk>\\<And>si di ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     blit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         blit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "case 0"], ["proof (state)\nthis:\n  si + 0 \\<le> length lsrc\n  di + 0 \\<le> length ldst\n\ngoal (2 subgoals):\n 1. \\<And>si di ldst.\n       \\<lbrakk>si + 0 \\<le> length lsrc; di + 0 \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         blit src si dst di 0\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take 0 (drop si lsrc) @ drop (di + 0) ldst)>\n 2. \\<And>len si di ldst.\n       \\<lbrakk>\\<And>si di ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     blit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         blit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "thus ?case"], ["proof (prove)\nusing this:\n  si + 0 \\<le> length lsrc\n  di + 0 \\<le> length ldst\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n    blit src si dst di 0\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a lsrc *\n        dst \\<mapsto>\\<^sub>a\n        (take di ldst @ take 0 (drop si lsrc) @ drop (di + 0) ldst)>", "by sep_auto"], ["proof (state)\nthis:\n  <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n  blit src si dst di 0\n  <\\<lambda>_.\n      src \\<mapsto>\\<^sub>a lsrc *\n      dst \\<mapsto>\\<^sub>a\n      (take di ldst @ take 0 (drop si lsrc) @ drop (di + 0) ldst)>\n\ngoal (1 subgoal):\n 1. \\<And>len si di ldst.\n       \\<lbrakk>\\<And>si di ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     blit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         blit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>len si di ldst.\n       \\<lbrakk>\\<And>si di ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     blit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         blit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "case (Suc len)"], ["proof (state)\nthis:\n  \\<lbrakk>?si + len \\<le> length lsrc;\n   ?di + len \\<le> length ?ldst\\<rbrakk>\n  \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                     dst \\<mapsto>\\<^sub>a ?ldst>\n                    blit src ?si dst ?di len\n                    <\\<lambda>_.\n                        src \\<mapsto>\\<^sub>a lsrc *\n                        dst \\<mapsto>\\<^sub>a\n                        (take ?di ?ldst @\n                         take len (drop ?si lsrc) @ drop (?di + len) ?ldst)>\n  si + Suc len \\<le> length lsrc\n  di + Suc len \\<le> length ldst\n\ngoal (1 subgoal):\n 1. \\<And>len si di ldst.\n       \\<lbrakk>\\<And>si di ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     blit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         blit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "note [sep_heap_rules] = Suc.IH"], ["proof (state)\nthis:\n  \\<lbrakk>?si + len \\<le> length lsrc;\n   ?di + len \\<le> length ?ldst\\<rbrakk>\n  \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                     dst \\<mapsto>\\<^sub>a ?ldst>\n                    blit src ?si dst ?di len\n                    <\\<lambda>_.\n                        src \\<mapsto>\\<^sub>a lsrc *\n                        dst \\<mapsto>\\<^sub>a\n                        (take ?di ?ldst @\n                         take len (drop ?si lsrc) @ drop (?di + len) ?ldst)>\n\ngoal (1 subgoal):\n 1. \\<And>len si di ldst.\n       \\<lbrakk>\\<And>si di ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     blit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         blit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "have [simp]: \"\\<And>x. lsrc ! si # take len (drop (Suc si) lsrc) @ x\n      = take (Suc len) (drop si lsrc) @ x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       lsrc ! si # take len (drop (Suc si) lsrc) @ x =\n       take (Suc len) (drop si lsrc) @ x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. lsrc ! si # take len (drop (Suc si) lsrc) =\n    take (Suc len) (drop si lsrc)", "by (metis Suc.prems(1) add_Suc_right Cons_nth_drop_Suc\n        less_Suc_eq_le add.commute not_less_eq take_Suc_Cons \n        Nat.trans_le_add2)"], ["proof (state)\nthis:\n  lsrc ! si # take len (drop (Suc si) lsrc) @ ?x =\n  take (Suc len) (drop si lsrc) @ ?x\n\ngoal (1 subgoal):\n 1. \\<And>len si di ldst.\n       \\<lbrakk>\\<And>si di ldst.\n                   \\<lbrakk>si + len \\<le> length lsrc;\n                    di + len \\<le> length ldst\\<rbrakk>\n                   \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\ndst \\<mapsto>\\<^sub>a ldst>\n                                     blit src si dst di len\n                                     <\\<lambda>_.\n   src \\<mapsto>\\<^sub>a lsrc *\n   dst \\<mapsto>\\<^sub>a\n   (take di ldst @ take len (drop si lsrc) @ drop (di + len) ldst)>;\n        si + Suc len \\<le> length lsrc;\n        di + Suc len \\<le> length ldst\\<rbrakk>\n       \\<Longrightarrow> <src \\<mapsto>\\<^sub>a lsrc *\n                          dst \\<mapsto>\\<^sub>a ldst>\n                         blit src si dst di (Suc len)\n                         <\\<lambda>_.\n                             src \\<mapsto>\\<^sub>a lsrc *\n                             dst \\<mapsto>\\<^sub>a\n                             (take di ldst @\n                              take (Suc len) (drop si lsrc) @\n                              drop (di + Suc len) ldst)>", "from Suc.prems"], ["proof (chain)\npicking this:\n  si + Suc len \\<le> length lsrc\n  di + Suc len \\<le> length ldst", "show ?case"], ["proof (prove)\nusing this:\n  si + Suc len \\<le> length lsrc\n  di + Suc len \\<le> length ldst\n\ngoal (1 subgoal):\n 1. <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n    blit src si dst di (Suc len)\n    <\\<lambda>_.\n        src \\<mapsto>\\<^sub>a lsrc *\n        dst \\<mapsto>\\<^sub>a\n        (take di ldst @\n         take (Suc len) (drop si lsrc) @ drop (di + Suc len) ldst)>", "by (sep_auto simp: take_update_last drop_upd_irrelevant)"], ["proof (state)\nthis:\n  <src \\<mapsto>\\<^sub>a lsrc * dst \\<mapsto>\\<^sub>a ldst>\n  blit src si dst di (Suc len)\n  <\\<lambda>_.\n      src \\<mapsto>\\<^sub>a lsrc *\n      dst \\<mapsto>\\<^sub>a\n      (take di ldst @\n       take (Suc len) (drop si lsrc) @ drop (di + Suc len) ldst)>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition nth_oo where \"nth_oo v a i \\<equiv> do {\n    l\\<leftarrow>Array.len a;\n    if i<l then\n      Array.nth a i\n    else \n      return v\n  }\""], ["", "definition upd_oo where \"upd_oo f i x a \\<equiv> do {\n    l\\<leftarrow>Array.len a;\n    if i<l then\n      Array.upd i x a\n    else\n      f\n  }\""], ["", "ML_val Array.update"], ["", "subsection \"Code Generator Setup\""], ["", "code_printing code_module \"array_blit\" \\<rightharpoonup> (SML)\n    \\<open>\n   fun array_blit src si dst di len = (\n      src=dst andalso raise Fail (\"array_blit: Same arrays\");\n      ArraySlice.copy {\n        di = IntInf.toInt di,\n        src = ArraySlice.slice (src,IntInf.toInt si,SOME (IntInf.toInt len)),\n        dst = dst})\n\n    fun array_nth_oo v a i () = Array.sub(a,IntInf.toInt i) handle Subscript => v | Overflow => v\n    fun array_upd_oo f i x a () = \n      (Array.update(a,IntInf.toInt i,x); a) handle Subscript => f () | Overflow => f ()\n\n\\<close>"], ["", "definition blit' where\n    [code del]: \"blit' src si dst di len \n      = blit src (nat_of_integer si) dst (nat_of_integer di) \n          (nat_of_integer len)\""], ["", "lemma [code]:\n    \"blit src si dst di len \n      = blit' src (integer_of_nat si) dst (integer_of_nat di) \n          (integer_of_nat len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blit src si dst di len =\n    blit' src (integer_of_nat si) dst (integer_of_nat di)\n     (integer_of_nat len)", "by (simp add: blit'_def)"], ["", "(* TODO: Export to other languages: OCaml, Haskell *)"], ["", "code_printing constant blit' \\<rightharpoonup>\n    (SML) \"(fn/ ()/ => /array'_blit _ _ _ _ _)\"\n    and (Scala) \"{ ('_: Unit)/=>/\n      def safecopy(src: Array['_], srci: Int, dst: Array['_], dsti: Int, len: Int) = {\n        if (src eq dst)\n          sys.error(\\\"array'_blit: Same arrays\\\")\n        else\n          System.arraycopy(src, srci, dst, dsti, len)\n      }\n      safecopy(_.array,_.toInt,_.array,_.toInt,_.toInt)\n    }\""], ["", "definition [code del]: \"nth_oo' v a == nth_oo v a o nat_of_integer\""], ["", "definition [code del]: \"upd_oo' f == upd_oo f o nat_of_integer\""], ["", "lemma [code]: \n    \"nth_oo v a == nth_oo' v a o integer_of_nat\"\n    \"upd_oo f == upd_oo' f o integer_of_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nth_oo v a \\<equiv> nth_oo' v a \\<circ> integer_of_nat) &&&\n    upd_oo f \\<equiv> upd_oo' f \\<circ> integer_of_nat", "by (simp_all add: nth_oo'_def upd_oo'_def o_def)"], ["", "text \\<open>Fallbacks\\<close>"], ["", "lemmas [code] = nth_oo'_def[unfolded nth_oo_def[abs_def]]"], ["", "lemmas [code] = upd_oo'_def[unfolded upd_oo_def[abs_def]]"], ["", "code_printing constant nth_oo' \\<rightharpoonup> (SML) \"array'_nth'_oo _ _ _\"\n    | constant upd_oo' \\<rightharpoonup> (SML) \"array'_upd'_oo _ _ _ _\""], ["", "subsection \\<open>Derived Functions\\<close>"], ["", "definition \"array_shrink a s \\<equiv> do {\n    \\<comment> \\<open>Avoiding the need for default value\\<close>\n    l\\<leftarrow>Array.len a;\n    if l=s then \n      return a\n    else if l=0 then \n      Array.of_list []\n    else do {\n      x\\<leftarrow>Array.nth a 0;\n      a'\\<leftarrow>Array.new s x;\n      blit a 0 a' 0 s;\n      return a'\n    }\n  }\""], ["", "lemma array_shrink_rule[sep_heap_rules]:\n    assumes \"s\\<le>length la\"\n    shows \"< a\\<mapsto>\\<^sub>ala > array_shrink a s <\\<lambda>a'. a'\\<mapsto>\\<^sub>atake s la >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a\n     la> array_shrink a\n          s <\\<lambda>r. r \\<mapsto>\\<^sub>a take s la>\\<^sub>t", "using assms"], ["proof (prove)\nusing this:\n  s \\<le> length la\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a\n     la> array_shrink a\n          s <\\<lambda>r. r \\<mapsto>\\<^sub>a take s la>\\<^sub>t", "unfolding array_shrink_def"], ["proof (prove)\nusing this:\n  s \\<le> length la\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a\n     la> Array.len a \\<bind>\n         (\\<lambda>l.\n             if l = s then return a\n             else if l = 0 then Array.of_list []\n                  else Array.nth a 0 \\<bind>\n                       (\\<lambda>x.\n                           Array.new s x \\<bind>\n                           (\\<lambda>a'.\n                               blit a 0 a' 0 s \\<bind>\n                               (\\<lambda>_.\n                                   return\n                                    a')))) <\\<lambda>r.\n         r \\<mapsto>\\<^sub>a take s la>\\<^sub>t", "by sep_auto"], ["", "definition \"array_grow a s x \\<equiv> do {\n    l\\<leftarrow>Array.len a;\n    if l=s then \n      return a\n    else do {\n      a'\\<leftarrow>Array.new s x;\n      blit a 0 a' 0 l;\n      return a'\n    }\n  }\""], ["", "lemma array_grow_rule[sep_heap_rules]:\n    assumes \"s\\<ge>length la\"\n    shows \"\n      < a\\<mapsto>\\<^sub>ala > \n        array_grow a s x \n      <\\<lambda>a'. a'\\<mapsto>\\<^sub>a (la @ replicate (s-length la) x)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a\n     la> array_grow a s\n          x <\\<lambda>r.\n                r \\<mapsto>\\<^sub>a\n                (la @ replicate (s - length la) x)>\\<^sub>t", "using assms"], ["proof (prove)\nusing this:\n  length la \\<le> s\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a\n     la> array_grow a s\n          x <\\<lambda>r.\n                r \\<mapsto>\\<^sub>a\n                (la @ replicate (s - length la) x)>\\<^sub>t", "unfolding array_grow_def"], ["proof (prove)\nusing this:\n  length la \\<le> s\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a\n     la> Array.len a \\<bind>\n         (\\<lambda>l.\n             if l = s then return a\n             else Array.new s x \\<bind>\n                  (\\<lambda>a'.\n                      blit a 0 a' 0 l \\<bind>\n                      (\\<lambda>_.\n                          return\n                           a'))) <\\<lambda>r.\n                                     r \\<mapsto>\\<^sub>a\n                                     (la @\nreplicate (s - length la) x)>\\<^sub>t", "by sep_auto"], ["", "export_code array_grow checking SML Scala"], ["", "(* TODO: Are there system-calls for array-copy? *)"], ["", "definition \"array_copy a \\<equiv> do {\n    l\\<leftarrow>Array.len a;\n    if l=0 then \n      Array.of_list []\n    else do {\n      s \\<leftarrow> Array.nth a 0;\n      a'\\<leftarrow>Array.new l s;\n      blit a 0 a' 0 l;\n      return a'\n    }\n  }\""], ["", "lemma array_copy_rule[sep_heap_rules]:\n    \"\n      < a\\<mapsto>\\<^sub>al> \n        array_copy a \n      <\\<lambda>a'. a\\<mapsto>\\<^sub>al * a'\\<mapsto>\\<^sub>a l>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a l> array_copy a\n    <\\<lambda>a'. a \\<mapsto>\\<^sub>a l * a' \\<mapsto>\\<^sub>a l>", "unfolding array_copy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a l>\n    Array.len a \\<bind>\n    (\\<lambda>l.\n        if l = 0 then Array.of_list []\n        else Array.nth a 0 \\<bind>\n             (\\<lambda>s.\n                 Array.new l s \\<bind>\n                 (\\<lambda>a'.\n                     blit a 0 a' 0 l \\<bind> (\\<lambda>_. return a'))))\n    <\\<lambda>a'. a \\<mapsto>\\<^sub>a l * a' \\<mapsto>\\<^sub>a l>", "by sep_auto"], ["", "export_code array_copy checking SML Scala"], ["", "end"]]}