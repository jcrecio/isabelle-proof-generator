{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Examples/Array_Map_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma [code]: \"iam_lookup k a \\<equiv> nth_oo None a k\"", "lemma [code]: \"iam_delete k a \\<equiv> upd_oo (return a) k None a\"", "lemma [code]: \"iam_update k v a = upd_oo \n    (do {\n      l\\<leftarrow>Array.len a;\n      let newsz = max (k+1) (2 * l + 3);\n      a\\<leftarrow>array_grow a newsz None;\n      Array.upd k (Some v) a\n    })\n    k (Some v) a\"", "lemma precise_iam: \"precise is_iam\"", "lemma iam_new_abs: \"iam_of_list (replicate n None) = Map.empty\"", "lemma iam_new_sz_rule: \"<emp> iam_new_sz n < is_iam Map.empty >\"", "lemma iam_new_rule: \"<emp> iam_new < is_iam Map.empty >\"", "lemma iam_lookup_abs1: \"k<length l \\<Longrightarrow> iam_of_list l k = l!k\"", "lemma iam_lookup_abs2: \"\\<not>k<length l \\<Longrightarrow> iam_of_list l k = None\"", "lemma iam_lookup_rule: \"< is_iam m p > \n    iam_lookup k p \n    <\\<lambda>r. is_iam m p * \\<up>(r=m k) >\"", "lemma iam_delete_abs1: \"k<length l \n    \\<Longrightarrow> iam_of_list (l[k := None]) = iam_of_list l |` (- {k})\"", "lemma iam_delete_abs2: \"\\<not>k<length l \n    \\<Longrightarrow> iam_of_list l |` (- {k}) = iam_of_list l\"", "lemma iam_delete_rule: \"< is_iam m p >\n    iam_delete k p\n    <\\<lambda>r. is_iam (m|`(-{k})) r>\"", "lemma iam_update_abs1: \"iam_of_list (l@replicate n None) = iam_of_list l\"", "lemma iam_update_abs2: \"\\<not> length l \\<le> k \n    \\<Longrightarrow> iam_of_list (l[k := Some v]) = iam_of_list l(k \\<mapsto> v)\"", "lemma iam_update_rule:\n    \"< is_iam m p > iam_update k v p <\\<lambda>r. is_iam (m(k\\<mapsto>v)) r>\\<^sub>t\""], "translations": [["", "lemma [code]: \"iam_lookup k a \\<equiv> nth_oo None a k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_lookup k a \\<equiv> nth_oo None a k", "unfolding nth_oo_def iam_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.len a \\<bind>\n    (\\<lambda>l. if k < l then Array.nth a k else return None) \\<equiv>\n    Array.len a \\<bind>\n    (\\<lambda>l. if k < l then Array.nth a k else return None)", "."], ["", "definition iam_delete\n    :: \"nat \\<Rightarrow> ('v::heap) array_map \\<Rightarrow> ('v::heap) array_map Heap\"\n  where \"iam_delete k a = do {\n      l\\<leftarrow>Array.len a;\n      if k < l then Array.upd k None a else return a\n    }\""], ["", "lemma [code]: \"iam_delete k a \\<equiv> upd_oo (return a) k None a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_delete k a \\<equiv> upd_oo (return a) k None a", "unfolding upd_oo_def iam_delete_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.len a \\<bind>\n    (\\<lambda>l. if k < l then Array.upd k None a else return a) \\<equiv>\n    Array.len a \\<bind>\n    (\\<lambda>l. if k < l then Array.upd k None a else return a)", "."], ["", "definition iam_update\n    :: \"nat \\<Rightarrow> 'v::heap \\<Rightarrow> 'v array_map \\<Rightarrow> 'v array_map Heap\"\n    where \"iam_update k v a = do {\n      l\\<leftarrow>Array.len a;\n      a\\<leftarrow>if k>=l then do {\n          let newsz = max (k+1) (2 * l + 3);\n          array_grow a newsz None\n        } else return a;\n\n      Array.upd k (Some v) a\n    }\""], ["", "lemma [code]: \"iam_update k v a = upd_oo \n    (do {\n      l\\<leftarrow>Array.len a;\n      let newsz = max (k+1) (2 * l + 3);\n      a\\<leftarrow>array_grow a newsz None;\n      Array.upd k (Some v) a\n    })\n    k (Some v) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_update k v a =\n    upd_oo\n     (Array.len a \\<bind>\n      (\\<lambda>l.\n          let newsz = max (k + 1) (2 * l + 3)\n          in array_grow a newsz None \\<bind> Array.upd k (Some v)))\n     k (Some v) a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. iam_update k v a =\n    upd_oo\n     (Array.len a \\<bind>\n      (\\<lambda>l.\n          let newsz = max (k + 1) (2 * l + 3)\n          in array_grow a newsz None \\<bind> Array.upd k (Some v)))\n     k (Some v) a", "have [simp]: \n      \"\\<And>x t e. do {\n        l\\<leftarrow>Array.len a;\n        if x l then \n          t l \n        else do {\n          l'\\<leftarrow>Array.len a;\n          e l l'\n        } \n      }\n      =\n      do {\n        l\\<leftarrow>Array.len a;\n        if x l then t l else e l l\n      }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t e.\n       Array.len a \\<bind>\n       (\\<lambda>l. if x l then t l else Array.len a \\<bind> e l) =\n       Array.len a \\<bind> (\\<lambda>l. if x l then t l else e l l)", "apply (auto \n        simp: bind_def execute_len \n        split: option.split\n        intro!: ext\n      )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Array.len a \\<bind>\n  (\\<lambda>l. if ?x l then ?t l else Array.len a \\<bind> ?e l) =\n  Array.len a \\<bind> (\\<lambda>l. if ?x l then ?t l else ?e l l)\n\ngoal (1 subgoal):\n 1. iam_update k v a =\n    upd_oo\n     (Array.len a \\<bind>\n      (\\<lambda>l.\n          let newsz = max (k + 1) (2 * l + 3)\n          in array_grow a newsz None \\<bind> Array.upd k (Some v)))\n     k (Some v) a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_update k v a =\n    upd_oo\n     (Array.len a \\<bind>\n      (\\<lambda>l.\n          let newsz = max (k + 1) (2 * l + 3)\n          in array_grow a newsz None \\<bind> Array.upd k (Some v)))\n     k (Some v) a", "unfolding upd_oo_def iam_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.len a \\<bind>\n    (\\<lambda>l.\n        (if l \\<le> k\n         then let newsz = max (k + 1) (2 * l + 3) in array_grow a newsz None\n         else return a) \\<bind>\n        Array.upd k (Some v)) =\n    Array.len a \\<bind>\n    (\\<lambda>l.\n        if k < l then Array.upd k (Some v) a\n        else Array.len a \\<bind>\n             (\\<lambda>l.\n                 let newsz = max (k + 1) (2 * l + 3)\n                 in array_grow a newsz None \\<bind> Array.upd k (Some v)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.len a \\<bind>\n    (\\<lambda>l.\n        (if l \\<le> k\n         then let newsz = max (k + 1) (2 * l + 3) in array_grow a newsz None\n         else return a) \\<bind>\n        Array.upd k (Some v)) =\n    Array.len a \\<bind>\n    (\\<lambda>l.\n        if k < l then Array.upd k (Some v) a\n        else let newsz = max (k + 1) (2 * l + 3)\n             in array_grow a newsz None \\<bind> Array.upd k (Some v))", "apply (rule cong[OF arg_cong, where f1=bind])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Array.len a = Array.len a\n 2. (\\<lambda>l.\n        (if l \\<le> k\n         then let newsz = max (k + 1) (2 * l + 3) in array_grow a newsz None\n         else return a) \\<bind>\n        Array.upd k (Some v)) =\n    (\\<lambda>l.\n        if k < l then Array.upd k (Some v) a\n        else let newsz = max (k + 1) (2 * l + 3)\n             in array_grow a newsz None \\<bind> Array.upd k (Some v))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l.\n        (if l \\<le> k\n         then let newsz = max (k + 1) (2 * l + 3) in array_grow a newsz None\n         else return a) \\<bind>\n        Array.upd k (Some v)) =\n    (\\<lambda>l.\n        if k < l then Array.upd k (Some v) a\n        else let newsz = max (k + 1) (2 * l + 3)\n             in array_grow a newsz None \\<bind> Array.upd k (Some v))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (if l \\<le> k\n        then let newsz = max (k + 1) (2 * l + 3) in array_grow a newsz None\n        else return a) \\<bind>\n       Array.upd k (Some v) =\n       (if k < l then Array.upd k (Some v) a\n        else let newsz = max (k + 1) (2 * l + 3)\n             in array_grow a newsz None \\<bind> Array.upd k (Some v))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  iam_update k v a =\n  upd_oo\n   (Array.len a \\<bind>\n    (\\<lambda>l.\n        let newsz = max (k + 1) (2 * l + 3)\n        in array_grow a newsz None \\<bind> Array.upd k (Some v)))\n   k (Some v) a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma precise_iam: \"precise is_iam\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_iam", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_iam a p * F \\<and>\\<^sub>A is_iam a' p * F' \\<Longrightarrow>\n       a = a'", "by (auto simp add: is_iam_def dest: preciseD[OF snga_prec])"], ["", "lemma iam_new_abs: \"iam_of_list (replicate n None) = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_of_list (replicate n None) = Map.empty", "unfolding iam_of_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        if i < length (replicate n None) then replicate n None ! i\n        else None) =\n    Map.empty", "by auto"], ["", "lemma iam_new_sz_rule: \"<emp> iam_new_sz n < is_iam Map.empty >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> iam_new_sz n <is_iam Map.empty>", "unfolding iam_new_sz_def is_iam_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> Array.new n None\n    <\\<lambda>a.\n        \\<exists>\\<^sub>Al.\n           a \\<mapsto>\\<^sub>a l * \\<up> (Map.empty = iam_of_list l)>", "by (sep_auto simp: iam_new_abs)"], ["", "lemma iam_new_rule: \"<emp> iam_new < is_iam Map.empty >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> iam_new <is_iam Map.empty>", "unfolding iam_new_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> iam_new_sz iam_initial_size <is_iam Map.empty>", "by (sep_auto heap: iam_new_sz_rule)"], ["", "lemma iam_lookup_abs1: \"k<length l \\<Longrightarrow> iam_of_list l k = l!k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length l \\<Longrightarrow> iam_of_list l k = l ! k", "by (simp add: iam_of_list_def)"], ["", "lemma iam_lookup_abs2: \"\\<not>k<length l \\<Longrightarrow> iam_of_list l k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> k < length l \\<Longrightarrow> iam_of_list l k = None", "by (simp add: iam_of_list_def)"], ["", "lemma iam_lookup_rule: \"< is_iam m p > \n    iam_lookup k p \n    <\\<lambda>r. is_iam m p * \\<up>(r=m k) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_iam m p> iam_lookup k p <\\<lambda>r. is_iam m p * \\<up> (r = m k)>", "unfolding iam_lookup_def is_iam_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al. p \\<mapsto>\\<^sub>a l * \\<up> (m = iam_of_list l)>\n    Array.len p \\<bind>\n    (\\<lambda>l. if k < l then Array.nth p k else return None)\n    <\\<lambda>r.\n        (\\<exists>\\<^sub>Al.\n            p \\<mapsto>\\<^sub>a l * \\<up> (m = iam_of_list l)) *\n        \\<up> (r = m k)>", "by (sep_auto simp: iam_lookup_abs1 iam_lookup_abs2)"], ["", "lemma iam_delete_abs1: \"k<length l \n    \\<Longrightarrow> iam_of_list (l[k := None]) = iam_of_list l |` (- {k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length l \\<Longrightarrow>\n    iam_of_list (l[k := None]) = iam_of_list l |` (- {k})", "unfolding iam_of_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length l \\<Longrightarrow>\n    (\\<lambda>i.\n        if i < length (l[k := None]) then l[k := None] ! i else None) =\n    (\\<lambda>i. if i < length l then l ! i else None) |` (- {k})", "by (auto intro!: ext simp: restrict_map_def)"], ["", "lemma iam_delete_abs2: \"\\<not>k<length l \n    \\<Longrightarrow> iam_of_list l |` (- {k}) = iam_of_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> k < length l \\<Longrightarrow>\n    iam_of_list l |` (- {k}) = iam_of_list l", "unfolding iam_of_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> k < length l \\<Longrightarrow>\n    (\\<lambda>i. if i < length l then l ! i else None) |` (- {k}) =\n    (\\<lambda>i. if i < length l then l ! i else None)", "by (auto intro!: ext simp: restrict_map_def)"], ["", "lemma iam_delete_rule: \"< is_iam m p >\n    iam_delete k p\n    <\\<lambda>r. is_iam (m|`(-{k})) r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_iam m p> iam_delete k p <is_iam (m |` (- {k}))>", "unfolding is_iam_def iam_delete_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al. p \\<mapsto>\\<^sub>a l * \\<up> (m = iam_of_list l)>\n    Array.len p \\<bind>\n    (\\<lambda>l. if k < l then Array.upd k None p else return p)\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           r \\<mapsto>\\<^sub>a l * \\<up> (m |` (- {k}) = iam_of_list l)>", "by (sep_auto simp: iam_delete_abs1 iam_delete_abs2)"], ["", "lemma iam_update_abs1: \"iam_of_list (l@replicate n None) = iam_of_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_of_list (l @ replicate n None) = iam_of_list l", "unfolding iam_of_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        if i < length (l @ replicate n None) then (l @ replicate n None) ! i\n        else None) =\n    (\\<lambda>i. if i < length l then l ! i else None)", "by (auto intro!: ext simp: nth_append)"], ["", "lemma iam_update_abs2: \"\\<not> length l \\<le> k \n    \\<Longrightarrow> iam_of_list (l[k := Some v]) = iam_of_list l(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length l \\<le> k \\<Longrightarrow>\n    iam_of_list (l[k := Some v]) = iam_of_list l(k \\<mapsto> v)", "unfolding iam_of_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length l \\<le> k \\<Longrightarrow>\n    (\\<lambda>i.\n        if i < length (l[k := Some v]) then l[k := Some v] ! i else None) =\n    (\\<lambda>i. if i < length l then l ! i else None)(k \\<mapsto> v)", "by auto"], ["", "lemma iam_update_rule:\n    \"< is_iam m p > iam_update k v p <\\<lambda>r. is_iam (m(k\\<mapsto>v)) r>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_iam m p> iam_update k v p <is_iam (m(k \\<mapsto> v))>\\<^sub>t", "unfolding is_iam_def iam_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al.\n        p \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (m =\n          iam_of_list\n           l)> Array.len p \\<bind>\n               (\\<lambda>l.\n                   (if l \\<le> k\n                    then let newsz = max (k + 1) (2 * l + 3)\n                         in array_grow p newsz None\n                    else return p) \\<bind>\n                   Array.upd k\n                    (Some\n                      v)) <\\<lambda>r.\n                              \\<exists>\\<^sub>Al.\n                                 r \\<mapsto>\\<^sub>a l *\n                                 \\<up>\n                                  (m(k \\<mapsto> v) =\n                                   iam_of_list l)>\\<^sub>t", "by (sep_auto \n      decon: decon_if_split \n      simp: iam_update_abs1 iam_update_abs2)"], ["", "interpretation iam: imp_map is_iam"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map is_iam", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_iam", "by (rule precise_iam)"], ["", "interpretation iam: imp_map_empty is_iam iam_new"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_empty is_iam iam_new", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> iam_new <is_iam Map.empty>\\<^sub>t", "by (sep_auto heap: iam_new_rule)"], ["", "interpretation iam_sz: imp_map_empty is_iam \"iam_new_sz sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_empty is_iam (iam_new_sz sz)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> iam_new_sz sz <is_iam Map.empty>\\<^sub>t", "by (sep_auto heap: iam_new_sz_rule)"], ["", "interpretation iam: imp_map_lookup is_iam iam_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_lookup is_iam iam_lookup", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m p k.\n       <is_iam m\n         p> iam_lookup k\n             p <\\<lambda>r. is_iam m p * \\<up> (r = m k)>\\<^sub>t", "by (sep_auto heap: iam_lookup_rule)"], ["", "interpretation iam: imp_map_delete is_iam iam_delete"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_delete is_iam iam_delete", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m p k. <is_iam m p> iam_delete k p <is_iam (m |` (- {k}))>\\<^sub>t", "by (sep_auto heap: iam_delete_rule)"], ["", "interpretation iam: imp_map_update is_iam iam_update"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_update is_iam iam_update", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m p k v.\n       <is_iam m p> iam_update k v p <is_iam (m(k \\<mapsto> v))>\\<^sub>t", "by (sep_auto heap: iam_update_rule)"], ["", "end"]]}