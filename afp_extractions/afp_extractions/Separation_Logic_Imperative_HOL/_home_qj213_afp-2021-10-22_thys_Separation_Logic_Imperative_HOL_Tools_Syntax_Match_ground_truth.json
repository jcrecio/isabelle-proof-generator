{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Tools/Syntax_Match.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma [cong]: \"syntax_fo_nomatch x y = syntax_fo_nomatch x y\"", "lemma [cong]: \"syntax_nomatch x y = syntax_nomatch x y\"", "lemmas left_assoc = right_assoc[symmetric]", "lemma left_commute: \"f a (f b c) = f b (f a c)\"", "lemmas right_ac = right_assoc left_commute commute", "lemma right_commute: \"f (f a b) c = f (f a c) b\"", "lemma safe_commute: \"syntax_fo_nomatch (f x y) a \\<Longrightarrow> f a b = f b a\"", "lemmas left_ac = left_assoc right_commute safe_commute"], "translations": [["", "lemma [cong]: \"syntax_fo_nomatch x y = syntax_fo_nomatch x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. syntax_fo_nomatch x y = syntax_fo_nomatch x y", "by simp"], ["", "lemma [cong]: \"syntax_nomatch x y = syntax_nomatch x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. syntax_nomatch x y = syntax_nomatch x y", "by simp"], ["", "ML \\<open>\nstructure Syntax_Match = struct\n  val nomatch_thm = @{thm syntax_nomatch_def};\n  val fo_nomatch_thm = @{thm syntax_fo_nomatch_def};\n\n  fun fo_nomatch_simproc ctxt credex = let\n    (*val ctxt = Simplifier.the_context ss;*)\n    val thy = Proof_Context.theory_of ctxt;\n\n    val redex = Thm.term_of credex;\n    val (_,[pat,obj]) = strip_comb redex;\n\n    fun fo_matches po = (Pattern.first_order_match \n      thy po (Vartab.empty, Vartab.empty); true) handle Pattern.MATCH => false;\n  in\n    if fo_matches (pat,obj) then NONE else SOME fo_nomatch_thm\n  end\n\n  fun nomatch_simproc ctxt credex = let\n    (*val ctxt = Simplifier.the_context ss;*)\n    val thy = Proof_Context.theory_of ctxt;\n\n    val redex = Thm.term_of credex;\n    val (_,[pat,obj]) = strip_comb redex;\n  in\n    if Pattern.matches thy (pat,obj) then NONE else SOME nomatch_thm\n  end\nend\n\\<close>"], ["", "simproc_setup nomatch (\"syntax_nomatch pat obj\") \n  = \\<open>K Syntax_Match.nomatch_simproc\\<close>"], ["", "simproc_setup fo_nomatch (\"syntax_fo_nomatch pat obj\") \n  = \\<open>K Syntax_Match.fo_nomatch_simproc\\<close>"], ["", "subsection \\<open>Examples\\<close>"], ["", "subsubsection \\<open>Ordering AC-structures\\<close>"], ["", "text \\<open>\n  Currently, the simplifier rules for ac-rewriting only work when\n  associativity groups to the right. Here, we define rules that work for\n  associativity grouping to the left. They are useful for operators where \n  syntax is parsed (and pretty-printed) left-associative.\n\\<close>"], ["", "locale ac_operator =\n  fixes f\n  assumes right_assoc: \"f (f a b) c = f a (f b c)\"\n  assumes commute: \"f a b = f b a\"\nbegin"], ["", "lemmas left_assoc = right_assoc[symmetric]"], ["", "lemma left_commute: \"f a (f b c) = f b (f a c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a (f b c) = f b (f a c)", "apply (simp add: left_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (f a b) c = f (f b a) c", "apply (simp add: commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas right_ac = right_assoc left_commute commute"], ["", "lemma right_commute: \"f (f a b) c = f (f a c) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (f a b) c = f (f a c) b", "by (simp add: right_ac)"], ["", "lemma safe_commute: \"syntax_fo_nomatch (f x y) a \\<Longrightarrow> f a b = f b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. syntax_fo_nomatch (f x y) a \\<Longrightarrow> f a b = f b a", "by (simp add: right_ac)"], ["", "lemmas left_ac = left_assoc right_commute safe_commute"], ["", "end"], ["", "interpretation mult: ac_operator \"(*) ::'a::ab_semigroup_mult \\<Rightarrow> _ \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ac_operator (*)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a", "apply (simp_all add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation add: ac_operator \"(+) ::'a::ab_semigroup_add \\<Rightarrow> _ \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ac_operator (+)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a", "apply (simp_all add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Attention: \\<open>conj_assoc\\<close> is in standard simpset, it has to be \n  removed when using \\<open>conj.left_ac\\<close> !\\<close>"], ["", "interpretation conj: ac_operator \"(\\<and>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ac_operator (\\<and>)", "by unfold_locales auto"], ["", "interpretation disj: ac_operator \"(\\<or>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ac_operator (\\<or>)", "by unfold_locales auto"], ["", "end"]]}