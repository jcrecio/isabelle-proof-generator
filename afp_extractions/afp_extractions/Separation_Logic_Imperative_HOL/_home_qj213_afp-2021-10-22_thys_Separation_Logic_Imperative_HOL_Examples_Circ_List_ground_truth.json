{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Examples/Circ_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma [simp]: \"cs_list l None = \\<up>(l=[])\"", "lemma [simp]: \n  \"cs_list l (Some p) \n  = (\\<exists>\\<^sub>Ax ls. \\<up>(l=x#ls) * lseg (x#ls) (Some p) (Some p))\"", "lemma cs_prec: \n  \"precise cs_list\"", "lemma cs_imp_list_impl: \"imp_list cs_list\"", "lemma cs_empty_rule: \"<emp> cs_empty <cs_list []>\"", "lemma cs_empty_impl: \"imp_list_empty cs_list cs_empty\"", "lemma cs_prepend_rule: \n  \"<cs_list l p> cs_prepend x p <cs_list (x#l)>\"", "lemma cs_prepend_impl: \"imp_list_prepend cs_list cs_prepend\"", "lemma cs_append_rule: \n  \"<cs_list l p> cs_append x p <cs_list (l@[x])>\"", "lemma cs_append_impl: \"imp_list_append cs_list cs_append\"", "lemma cs_pop_rule: \n  \"<cs_list (x#l) p> cs_pop p <\\<lambda>(y,p'). cs_list l p' * true * \\<up>(y=x)>\"", "lemma cs_pop_impl: \"imp_list_pop cs_list cs_pop\"", "lemma cs_rotate_rule: \n  \"<cs_list l p> cs_rotate p <cs_list (rotate1 l)>\"", "lemma cs_rotate_impl: \"imp_list_rotate cs_list cs_rotate\"", "lemma \"<emp> test <\\<lambda>r. \\<up>(r=test_result) * true>\""], "translations": [["", "lemma [simp]: \"cs_list l None = \\<up>(l=[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs_list l None = \\<up> (l = [])", "by (cases l) auto"], ["", "lemma [simp]: \n  \"cs_list l (Some p) \n  = (\\<exists>\\<^sub>Ax ls. \\<up>(l=x#ls) * lseg (x#ls) (Some p) (Some p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs_list l (Some p) =\n    (\\<exists>\\<^sub>Ax ls.\n        \\<up> (l = x # ls) * lseg (x # ls) (Some p) (Some p))", "apply (rule ent_iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cs_list l (Some p) \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Ax ls.\n       \\<up> (l = x # ls) * lseg (x # ls) (Some p) (Some p)\n 2. \\<exists>\\<^sub>Ax ls.\n       \\<up> (l = x # ls) *\n       lseg (x # ls) (Some p) (Some p) \\<Longrightarrow>\\<^sub>A\n    cs_list l (Some p)", "apply (cases l)"], ["proof (prove)\ngoal (3 subgoals):\n 1. l = [] \\<Longrightarrow>\n    cs_list l (Some p) \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Ax ls.\n       \\<up> (l = x # ls) * lseg (x # ls) (Some p) (Some p)\n 2. \\<And>a list.\n       l = a # list \\<Longrightarrow>\n       cs_list l (Some p) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ax ls.\n          \\<up> (l = x # ls) * lseg (x # ls) (Some p) (Some p)\n 3. \\<exists>\\<^sub>Ax ls.\n       \\<up> (l = x # ls) *\n       lseg (x # ls) (Some p) (Some p) \\<Longrightarrow>\\<^sub>A\n    cs_list l (Some p)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       l = a # list \\<Longrightarrow>\n       cs_list l (Some p) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ax ls.\n          \\<up> (l = x # ls) * lseg (x # ls) (Some p) (Some p)\n 2. \\<exists>\\<^sub>Ax ls.\n       \\<up> (l = x # ls) *\n       lseg (x # ls) (Some p) (Some p) \\<Longrightarrow>\\<^sub>A\n    cs_list l (Some p)", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>Ax ls.\n       \\<up> (l = x # ls) *\n       lseg (x # ls) (Some p) (Some p) \\<Longrightarrow>\\<^sub>A\n    cs_list l (Some p)", "apply (cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    \\<exists>\\<^sub>Ax ls.\n       \\<up> (l = x # ls) *\n       lseg (x # ls) (Some p) (Some p) \\<Longrightarrow>\\<^sub>A\n    cs_list l (Some p)\n 2. \\<And>a list.\n       l = a # list \\<Longrightarrow>\n       \\<exists>\\<^sub>Ax ls.\n          \\<up> (l = x # ls) *\n          lseg (x # ls) (Some p) (Some p) \\<Longrightarrow>\\<^sub>A\n       cs_list l (Some p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l = a # list \\<Longrightarrow>\n       \\<exists>\\<^sub>Ax ls.\n          \\<up> (l = x # ls) *\n          lseg (x # ls) (Some p) (Some p) \\<Longrightarrow>\\<^sub>A\n       cs_list l (Some p)", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Precision\\<close>"], ["", "lemma cs_prec: \n  \"precise cs_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise cs_list", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       cs_list a p * F \\<and>\\<^sub>A cs_list a' p * F' \\<Longrightarrow>\n       a = a'", "apply (case_tac p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' h p F F'.\n       \\<lbrakk>h \\<Turnstile>\n                cs_list a p * F \\<and>\\<^sub>A cs_list a' p * F';\n        p = None\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a a' h p F F' aa.\n       \\<lbrakk>h \\<Turnstile>\n                cs_list a p * F \\<and>\\<^sub>A cs_list a' p * F';\n        p = Some aa\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F' aa.\n       \\<lbrakk>h \\<Turnstile>\n                cs_list a p * F \\<and>\\<^sub>A cs_list a' p * F';\n        p = Some aa\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b F F' aaa x ls n xa lsa na.\n       (aa, b) \\<Turnstile>\n       aaa \\<mapsto>\\<^sub>r Node xa na * lseg lsa na (Some aaa) *\n       F \\<and>\\<^sub>A\n       aaa \\<mapsto>\\<^sub>r Node x n * lseg ls n (Some aaa) *\n       F' \\<Longrightarrow>\n       xa = x \\<and> lsa = ls", "apply (subgoal_tac \"x=xa \\<and> n=na\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b F F' aaa x ls n xa lsa.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                aaa \\<mapsto>\\<^sub>r Node xa n * lseg lsa n (Some aaa) *\n                F \\<and>\\<^sub>A\n                aaa \\<mapsto>\\<^sub>r Node xa n * lseg ls n (Some aaa) * F';\n        x = xa\\<rbrakk>\n       \\<Longrightarrow> lsa = ls\n 2. \\<And>aa b F F' aaa x ls n xa lsa na.\n       (aa, b) \\<Turnstile>\n       aaa \\<mapsto>\\<^sub>r Node xa na * lseg lsa na (Some aaa) *\n       F \\<and>\\<^sub>A\n       aaa \\<mapsto>\\<^sub>r Node x n * lseg ls n (Some aaa) *\n       F' \\<Longrightarrow>\n       x = xa \\<and> n = na", "apply (erule prec_frame_expl[OF lseg_prec1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b F F' aaa x ls n xa lsa.\n       x = xa \\<Longrightarrow>\n       aaa \\<mapsto>\\<^sub>r Node xa n * lseg lsa n (Some aaa) *\n       F \\<Longrightarrow>\\<^sub>A\n       lseg lsa (?p18 aa b F F' aaa x ls n xa lsa)\n        (Some (?q20 aa b F F' aaa x ls n xa lsa)) *\n       ?q20 aa b F F' aaa x ls n xa lsa \\<mapsto>\\<^sub>r\n       ?x21 aa b F F' aaa x ls n xa lsa *\n       ?F1.16 aa b F F' aaa x ls n xa lsa\n 2. \\<And>aa b F F' aaa x ls n xa lsa.\n       x = xa \\<Longrightarrow>\n       aaa \\<mapsto>\\<^sub>r Node xa n * lseg ls n (Some aaa) *\n       F' \\<Longrightarrow>\\<^sub>A\n       lseg ls (?p18 aa b F F' aaa x ls n xa lsa)\n        (Some (?q20 aa b F F' aaa x ls n xa lsa)) *\n       ?q20 aa b F F' aaa x ls n xa lsa \\<mapsto>\\<^sub>r\n       ?x21 aa b F F' aaa x ls n xa lsa *\n       ?F2.16 aa b F F' aaa x ls n xa lsa\n 3. \\<And>aa b F F' aaa x ls n xa lsa na.\n       (aa, b) \\<Turnstile>\n       aaa \\<mapsto>\\<^sub>r Node xa na * lseg lsa na (Some aaa) *\n       F \\<and>\\<^sub>A\n       aaa \\<mapsto>\\<^sub>r Node x n * lseg ls n (Some aaa) *\n       F' \\<Longrightarrow>\n       x = xa \\<and> n = na", "apply frame_inference"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b F F' aaa x ls n xa lsa.\n       x = xa \\<Longrightarrow>\n       aaa \\<mapsto>\\<^sub>r Node xa n * lseg ls n (Some aaa) *\n       F' \\<Longrightarrow>\\<^sub>A\n       lseg ls n (Some aaa) * aaa \\<mapsto>\\<^sub>r Node xa n *\n       ?F2.16 aa b F F' aaa x ls n xa lsa\n 2. \\<And>aa b F F' aaa x ls n xa lsa na.\n       (aa, b) \\<Turnstile>\n       aaa \\<mapsto>\\<^sub>r Node xa na * lseg lsa na (Some aaa) *\n       F \\<and>\\<^sub>A\n       aaa \\<mapsto>\\<^sub>r Node x n * lseg ls n (Some aaa) *\n       F' \\<Longrightarrow>\n       x = xa \\<and> n = na", "apply frame_inference"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b F F' aaa x ls n xa lsa na.\n       (aa, b) \\<Turnstile>\n       aaa \\<mapsto>\\<^sub>r Node xa na * lseg lsa na (Some aaa) *\n       F \\<and>\\<^sub>A\n       aaa \\<mapsto>\\<^sub>r Node x n * lseg ls n (Some aaa) *\n       F' \\<Longrightarrow>\n       x = xa \\<and> n = na", "apply (drule prec_frame[OF sngr_prec])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b F F' aaa x ls n xa lsa na.\n       aaa \\<mapsto>\\<^sub>r Node xa na * lseg lsa na (Some aaa) *\n       F \\<Longrightarrow>\\<^sub>A\n       ?p60 aa b F F' aaa x ls n xa lsa na \\<mapsto>\\<^sub>r\n       ?x60 aa b F F' aaa x ls n xa lsa na *\n       ?F1.60 aa b F F' aaa x ls n xa lsa na\n 2. \\<And>aa b F F' aaa x ls n xa lsa na.\n       aaa \\<mapsto>\\<^sub>r Node x n * lseg ls n (Some aaa) *\n       F' \\<Longrightarrow>\\<^sub>A\n       ?p60 aa b F F' aaa x ls n xa lsa na \\<mapsto>\\<^sub>r\n       ?y60 aa b F F' aaa x ls n xa lsa na *\n       ?F2.60 aa b F F' aaa x ls n xa lsa na\n 3. \\<And>aa b F F' aaa x ls n xa lsa na.\n       ?x60 aa b F F' aaa x ls n xa lsa na =\n       ?y60 aa b F F' aaa x ls n xa lsa na \\<Longrightarrow>\n       x = xa \\<and> n = na", "apply frame_inference"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b F F' aaa x ls n xa lsa na.\n       aaa \\<mapsto>\\<^sub>r Node x n * lseg ls n (Some aaa) *\n       F' \\<Longrightarrow>\\<^sub>A\n       aaa \\<mapsto>\\<^sub>r ?y60 aa b F F' aaa x ls n xa lsa na *\n       ?F2.60 aa b F F' aaa x ls n xa lsa na\n 2. \\<And>aa b F F' aaa x ls n xa lsa na.\n       Node xa na = ?y60 aa b F F' aaa x ls n xa lsa na \\<Longrightarrow>\n       x = xa \\<and> n = na", "apply frame_inference"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b F F' aaa x ls n xa lsa na.\n       Node xa na = Node x n \\<Longrightarrow> x = xa \\<and> n = na", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cs_imp_list_impl: \"imp_list cs_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list cs_list", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise cs_list", "apply (rule cs_prec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation cs: imp_list cs_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list cs_list", "by (rule cs_imp_list_impl)"], ["", "subsection \\<open>Operations\\<close>"], ["", "subsubsection \\<open>Allocate Empty List\\<close>"], ["", "definition cs_empty :: \"'a::heap cs_list Heap\" where\n  \"cs_empty \\<equiv> return None\""], ["", "lemma cs_empty_rule: \"<emp> cs_empty <cs_list []>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> cs_empty <cs_list []>", "unfolding cs_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> return None <cs_list []>", "by sep_auto"], ["", "lemma cs_empty_impl: \"imp_list_empty cs_list cs_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_empty cs_list cs_empty", "by unfold_locales (sep_auto heap: cs_empty_rule)"], ["", "interpretation cs: imp_list_empty cs_list cs_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_empty cs_list cs_empty", "by (rule cs_empty_impl)"], ["", "subsubsection \\<open>Prepend Element\\<close>"], ["", "fun cs_prepend :: \"'a \\<Rightarrow> 'a::heap cs_list \\<Rightarrow> 'a cs_list Heap\" where\n  \"cs_prepend x None = do {\n    p \\<leftarrow> ref (Node x None); \n    p:=Node x (Some p); \n    return (Some p)\n  }\"\n| \"cs_prepend x (Some p) = do {\n    n \\<leftarrow> !p;\n    q \\<leftarrow> ref (Node (val n) (next n));\n    p := Node x (Some q);\n    return (Some p)\n  }\""], ["", "declare cs_prepend.simps [simp del]"], ["", "lemma cs_prepend_rule: \n  \"<cs_list l p> cs_prepend x p <cs_list (x#l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <cs_list l p> cs_prepend x p <cs_list (x # l)>", "apply (cases p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = None \\<Longrightarrow>\n    <cs_list l p> cs_prepend x p <cs_list (x # l)>\n 2. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <cs_list l p> cs_prepend x p <cs_list (x # l)>", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = None \\<Longrightarrow>\n    l = [] \\<longrightarrow> <emp> cs_prepend x None <cs_list [x]>\n 2. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <\\<exists>\\<^sub>Ax ls pp n.\n           pp \\<mapsto>\\<^sub>r Node x n * lseg ls n (Some a) *\n           \\<up> (l = x # ls \\<and> a = pp)>\n       cs_prepend x (Some a) <cs_list (x # l)>", "apply (sep_auto simp: cs_prepend.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <\\<exists>\\<^sub>Ax ls pp n.\n           pp \\<mapsto>\\<^sub>r Node x n * lseg ls n (Some a) *\n           \\<up> (l = x # ls \\<and> a = pp)>\n       cs_prepend x (Some a) <cs_list (x # l)>", "apply (sep_auto simp: cs_prepend.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cs_prepend_impl: \"imp_list_prepend cs_list cs_prepend\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_prepend cs_list cs_prepend", "by unfold_locales (sep_auto heap: cs_prepend_rule)"], ["", "interpretation cs: imp_list_prepend cs_list cs_prepend"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_prepend cs_list cs_prepend", "by (rule cs_prepend_impl)"], ["", "subsubsection \\<open>Append Element\\<close>"], ["", "fun cs_append :: \"'a \\<Rightarrow> 'a::heap cs_list \\<Rightarrow> 'a cs_list Heap\" where\n  \"cs_append x None = do { \n    p \\<leftarrow> ref (Node x None); \n    p:=Node x (Some p); \n    return (Some p) }\"\n| \"cs_append x (Some p) = do {\n    n \\<leftarrow> !p;\n    q \\<leftarrow> ref (Node (val n) (next n));\n    p := Node x (Some q);\n    return (Some q)\n  }\""], ["", "declare cs_append.simps [simp del]"], ["", "lemma cs_append_rule: \n  \"<cs_list l p> cs_append x p <cs_list (l@[x])>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <cs_list l p> cs_append x p <cs_list (l @ [x])>", "apply (cases p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = None \\<Longrightarrow>\n    <cs_list l p> cs_append x p <cs_list (l @ [x])>\n 2. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <cs_list l p> cs_append x p <cs_list (l @ [x])>", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = None \\<Longrightarrow>\n    l = [] \\<longrightarrow> <emp> cs_append x None <cs_list [x]>\n 2. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <\\<exists>\\<^sub>Ax ls pp n.\n           pp \\<mapsto>\\<^sub>r Node x n * lseg ls n (Some a) *\n           \\<up> (l = x # ls \\<and> a = pp)>\n       cs_append x (Some a) <cs_list (l @ [x])>", "apply (sep_auto simp: cs_append.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <\\<exists>\\<^sub>Ax ls pp n.\n           pp \\<mapsto>\\<^sub>r Node x n * lseg ls n (Some a) *\n           \\<up> (l = x # ls \\<and> a = pp)>\n       cs_append x (Some a) <cs_list (l @ [x])>", "apply (sep_auto simp: cs_append.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> a \\<mapsto>\\<^sub>r Node x (Some xb) *\n                         xb \\<mapsto>\\<^sub>r Node xa n *\n                         lseg ls n (Some a) \\<Longrightarrow>\\<^sub>A\n                         xb \\<mapsto>\\<^sub>r Node xa (?n115 a xa ls n xb) *\n                         lseg (ls @ [x]) (?n115 a xa ls n xb) (Some xb)", "apply (rule ent_frame_fwd)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a x ls n xb.\n       \\<lbrakk>p = Some a; l = x # ls\\<rbrakk>\n       \\<Longrightarrow> ?P122 a x ls n xb \\<Longrightarrow>\\<^sub>A\n                         ?R122 a x ls n xb\n 2. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> a \\<mapsto>\\<^sub>r Node x (Some xb) *\n                         xb \\<mapsto>\\<^sub>r Node xa n *\n                         lseg ls n (Some a) \\<Longrightarrow>\\<^sub>A\n                         ?P122 a xa ls n xb * ?F122 a xa ls n xb\n 3. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> ?R122 a xa ls n xb *\n                         ?F122 a xa ls n xb \\<Longrightarrow>\\<^sub>A\n                         xb \\<mapsto>\\<^sub>r Node xa (?n115 a xa ls n xb) *\n                         lseg (ls @ [x]) (?n115 a xa ls n xb) (Some xb)", "apply (rule_tac s=a in lseg_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> a \\<mapsto>\\<^sub>r Node x (Some xb) *\n                         xb \\<mapsto>\\<^sub>r Node xa n *\n                         lseg ls n (Some a) \\<Longrightarrow>\\<^sub>A\n                         lseg (?l126 a xa ls n xb) (?p126 a xa ls n xb)\n                          (Some a) *\n                         a \\<mapsto>\\<^sub>r\n                         Node (?x126 a xa ls n xb) (?q126 a xa ls n xb) *\n                         ?F122 a xa ls n xb\n 2. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> lseg (?l126 a xa ls n xb @ [?x126 a xa ls n xb])\n                          (?p126 a xa ls n xb) (?q126 a xa ls n xb) *\n                         ?F122 a xa ls n xb \\<Longrightarrow>\\<^sub>A\n                         xb \\<mapsto>\\<^sub>r Node xa (?n115 a xa ls n xb) *\n                         lseg (ls @ [x]) (?n115 a xa ls n xb) (Some xb)", "(* frame_inference does no backtracking\n    on instantiating schematics, hence we have to give it some help here. *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> a \\<mapsto>\\<^sub>r Node x (Some xb) *\n                         xb \\<mapsto>\\<^sub>r Node xa n *\n                         lseg ls n (Some a) \\<Longrightarrow>\\<^sub>A\n                         lseg (?l126 a xa ls n xb) (?p126 a xa ls n xb)\n                          (Some a) *\n                         a \\<mapsto>\\<^sub>r\n                         Node (?x126 a xa ls n xb) (?q126 a xa ls n xb) *\n                         ?F122 a xa ls n xb\n 2. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> lseg (?l126 a xa ls n xb @ [?x126 a xa ls n xb])\n                          (?p126 a xa ls n xb) (?q126 a xa ls n xb) *\n                         ?F122 a xa ls n xb \\<Longrightarrow>\\<^sub>A\n                         xb \\<mapsto>\\<^sub>r Node xa (?n115 a xa ls n xb) *\n                         lseg (ls @ [x]) (?n115 a xa ls n xb) (Some xb)", "apply frame_inference"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> lseg (ls @ [x]) n (Some xb) *\n                         xb \\<mapsto>\\<^sub>r\n                         Node xa n \\<Longrightarrow>\\<^sub>A\n                         xb \\<mapsto>\\<^sub>r Node xa (?n115 a xa ls n xb) *\n                         lseg (ls @ [x]) (?n115 a xa ls n xb) (Some xb)", "apply (sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cs_append_impl: \"imp_list_append cs_list cs_append\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_append cs_list cs_append", "by unfold_locales (sep_auto heap: cs_append_rule)"], ["", "interpretation cs: imp_list_append cs_list cs_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_append cs_list cs_append", "by (rule cs_append_impl)"], ["", "subsubsection \\<open>Pop First Element\\<close>"], ["", "fun cs_pop :: \"'a::heap cs_list \\<Rightarrow> ('a\\<times>'a cs_list) Heap\" where\n  \"cs_pop None = raise STR ''Pop from empty list''\"\n| \"cs_pop (Some p) = do {\n    n1 \\<leftarrow> !p;\n    if next n1 = Some p then\n      return (val n1,None) \\<comment> \\<open>Singleton list becomes empty list\\<close>\n    else do {\n      let p2 = the (next n1);\n      n2 \\<leftarrow> !p2;\n      p := Node (val n2) (next n2);\n      return (val n1,Some p)\n    }\n  }\""], ["", "declare cs_pop.simps[simp del]"], ["", "lemma cs_pop_rule: \n  \"<cs_list (x#l) p> cs_pop p <\\<lambda>(y,p'). cs_list l p' * true * \\<up>(y=x)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <cs_list (x # l) p> cs_pop p\n    <\\<lambda>(y, p'). cs_list l p' * true * \\<up> (y = x)>", "apply (cases p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = None \\<Longrightarrow>\n    <cs_list (x # l) p> cs_pop p\n    <\\<lambda>(y, p'). cs_list l p' * true * \\<up> (y = x)>\n 2. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <cs_list (x # l) p> cs_pop p\n       <\\<lambda>(y, p'). cs_list l p' * true * \\<up> (y = x)>", "apply (sep_auto simp: cs_pop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <cs_list (x # l) p> cs_pop p\n       <\\<lambda>(y, p'). cs_list l p' * true * \\<up> (y = x)>", "apply (cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>p = Some a; l = []\\<rbrakk>\n       \\<Longrightarrow> <cs_list (x # l) p> cs_pop p\n                         <\\<lambda>(y, p').\n                             cs_list l p' * true * \\<up> (y = x)>\n 2. \\<And>a aa list.\n       \\<lbrakk>p = Some a; l = aa # list\\<rbrakk>\n       \\<Longrightarrow> <cs_list (x # l) p> cs_pop p\n                         <\\<lambda>(y, p').\n                             cs_list l p' * true * \\<up> (y = x)>", "apply (sep_auto simp: cs_pop.simps dflt_simps: option.sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list.\n       \\<lbrakk>p = Some a; l = aa # list\\<rbrakk>\n       \\<Longrightarrow> <cs_list (x # l) p> cs_pop p\n                         <\\<lambda>(y, p').\n                             cs_list l p' * true * \\<up> (y = x)>", "apply (sep_auto \n    simp: cs_pop.simps \n    dflt_simps: option.sel \n    eintros del: exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list pp na.\n       \\<lbrakk>p = Some a; l = aa # list; pp \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n nb nc.\n                            ((\\<exists>ab b.\n                                 (ab, b) \\<Turnstile>\n                                 a \\<mapsto>\\<^sub>r Node aa na *\n                                 pp \\<mapsto>\\<^sub>r Node aa na *\n                                 lseg list na (Some a)) \\<longrightarrow>\n                             aa = n \\<and> list = nb \\<and> a = nc) \\<and>\n                            (\\<exists>nd.\n                                a \\<mapsto>\\<^sub>r Node aa na *\n                                pp \\<mapsto>\\<^sub>r Node aa na *\n                                lseg list na\n                                 (Some a) \\<Longrightarrow>\\<^sub>A\n                                nc \\<mapsto>\\<^sub>r Node n nd *\n                                lseg nb nd (Some a) *\n                                true)", "(* Some unfortunate quantifier fiddling :( *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list pp na.\n       \\<lbrakk>p = Some a; l = aa # list; pp \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n nb nc.\n                            ((\\<exists>ab b.\n                                 (ab, b) \\<Turnstile>\n                                 a \\<mapsto>\\<^sub>r Node aa na *\n                                 pp \\<mapsto>\\<^sub>r Node aa na *\n                                 lseg list na (Some a)) \\<longrightarrow>\n                             aa = n \\<and> list = nb \\<and> a = nc) \\<and>\n                            (\\<exists>nd.\n                                a \\<mapsto>\\<^sub>r Node aa na *\n                                pp \\<mapsto>\\<^sub>r Node aa na *\n                                lseg list na\n                                 (Some a) \\<Longrightarrow>\\<^sub>A\n                                nc \\<mapsto>\\<^sub>r Node n nd *\n                                lseg nb nd (Some a) *\n                                true)", "apply (rule_tac x=aa in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list pp na.\n       \\<lbrakk>p = Some a; l = aa # list; pp \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n nb.\n                            ((\\<exists>ab b.\n                                 (ab, b) \\<Turnstile>\n                                 a \\<mapsto>\\<^sub>r Node aa na *\n                                 pp \\<mapsto>\\<^sub>r Node aa na *\n                                 lseg list na (Some a)) \\<longrightarrow>\n                             aa = aa \\<and> list = n \\<and> a = nb) \\<and>\n                            (\\<exists>nc.\n                                a \\<mapsto>\\<^sub>r Node aa na *\n                                pp \\<mapsto>\\<^sub>r Node aa na *\n                                lseg list na\n                                 (Some a) \\<Longrightarrow>\\<^sub>A\n                                nb \\<mapsto>\\<^sub>r Node aa nc *\n                                lseg n nc (Some a) *\n                                true)", "apply (rule_tac x=list in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list pp na.\n       \\<lbrakk>p = Some a; l = aa # list; pp \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            ((\\<exists>ab b.\n                                 (ab, b) \\<Turnstile>\n                                 a \\<mapsto>\\<^sub>r Node aa na *\n                                 pp \\<mapsto>\\<^sub>r Node aa na *\n                                 lseg list na (Some a)) \\<longrightarrow>\n                             aa = aa \\<and> list = list \\<and> a = n) \\<and>\n                            (\\<exists>nb.\n                                a \\<mapsto>\\<^sub>r Node aa na *\n                                pp \\<mapsto>\\<^sub>r Node aa na *\n                                lseg list na\n                                 (Some a) \\<Longrightarrow>\\<^sub>A\n                                n \\<mapsto>\\<^sub>r Node aa nb *\n                                lseg list nb (Some a) *\n                                true)", "apply (rule_tac x=a in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list pp na.\n       \\<lbrakk>p = Some a; l = aa # list; pp \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>ab b.\n                              (ab, b) \\<Turnstile>\n                              a \\<mapsto>\\<^sub>r Node aa na *\n                              pp \\<mapsto>\\<^sub>r Node aa na *\n                              lseg list na (Some a)) \\<longrightarrow>\n                          aa = aa \\<and> list = list \\<and> a = a) \\<and>\n                         (\\<exists>n.\n                             a \\<mapsto>\\<^sub>r Node aa na *\n                             pp \\<mapsto>\\<^sub>r Node aa na *\n                             lseg list na (Some a) \\<Longrightarrow>\\<^sub>A\n                             a \\<mapsto>\\<^sub>r Node aa n *\n                             lseg list n (Some a) *\n                             true)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list pp na.\n       \\<lbrakk>p = Some a; l = aa # list; pp \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            a \\<mapsto>\\<^sub>r Node aa na *\n                            pp \\<mapsto>\\<^sub>r Node aa na *\n                            lseg list na (Some a) \\<Longrightarrow>\\<^sub>A\n                            a \\<mapsto>\\<^sub>r Node aa n *\n                            lseg list n (Some a) *\n                            true", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list pp na.\n       \\<lbrakk>p = Some a; l = aa # list; pp \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> a \\<mapsto>\\<^sub>r Node aa na *\n                         pp \\<mapsto>\\<^sub>r Node aa na *\n                         lseg list na (Some a) \\<Longrightarrow>\\<^sub>A\n                         a \\<mapsto>\\<^sub>r\n                         Node aa (?n117 a aa list pp na) *\n                         lseg list (?n117 a aa list pp na) (Some a) *\n                         true", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cs_pop_impl: \"imp_list_pop cs_list cs_pop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_pop cs_list cs_pop", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l p.\n       l \\<noteq> [] \\<Longrightarrow>\n       <cs_list l\n         p> cs_pop\n             p <\\<lambda>r.\n                   case r of\n                   (r, p') \\<Rightarrow>\n                     cs_list (tl l) p' * \\<up> (r = hd l)>\\<^sub>t", "apply (sep_auto heap: cs_pop_rule elim!: neq_NilE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation cs: imp_list_pop cs_list cs_pop"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_pop cs_list cs_pop", "by (rule cs_pop_impl)"], ["", "subsubsection \\<open>Rotate\\<close>"], ["", "fun cs_rotate :: \"'a::heap cs_list \\<Rightarrow> 'a cs_list Heap\" where\n  \"cs_rotate None = return None\"\n| \"cs_rotate (Some p) = do {\n    n \\<leftarrow> !p;\n    return (next n)\n  }\""], ["", "declare cs_rotate.simps [simp del]"], ["", "lemma cs_rotate_rule: \n  \"<cs_list l p> cs_rotate p <cs_list (rotate1 l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <cs_list l p> cs_rotate p <cs_list (rotate1 l)>", "apply (cases p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = None \\<Longrightarrow>\n    <cs_list l p> cs_rotate p <cs_list (rotate1 l)>\n 2. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <cs_list l p> cs_rotate p <cs_list (rotate1 l)>", "apply (sep_auto simp: cs_rotate.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <cs_list l p> cs_rotate p <cs_list (rotate1 l)>", "apply (cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>p = Some a; l = []\\<rbrakk>\n       \\<Longrightarrow> <cs_list l p> cs_rotate p <cs_list (rotate1 l)>\n 2. \\<And>a aa list.\n       \\<lbrakk>p = Some a; l = aa # list\\<rbrakk>\n       \\<Longrightarrow> <cs_list l p> cs_rotate p <cs_list (rotate1 l)>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list.\n       \\<lbrakk>p = Some a; l = aa # list\\<rbrakk>\n       \\<Longrightarrow> <cs_list l p> cs_rotate p <cs_list (rotate1 l)>", "apply (case_tac list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa list.\n       \\<lbrakk>p = Some a; l = aa # list; list = []\\<rbrakk>\n       \\<Longrightarrow> <cs_list l p> cs_rotate p <cs_list (rotate1 l)>\n 2. \\<And>a aa list ab lista.\n       \\<lbrakk>p = Some a; l = aa # list; list = ab # lista\\<rbrakk>\n       \\<Longrightarrow> <cs_list l p> cs_rotate p <cs_list (rotate1 l)>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa list.\n       \\<lbrakk>p = Some a; l = [aa]; list = []\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Ax ls pp n.\n                             pp \\<mapsto>\\<^sub>r Node x n *\n                             lseg ls n (Some a) *\n                             \\<up> (aa = x \\<and> [] = ls \\<and> a = pp)>\n                         cs_rotate (Some a) <cs_list [aa]>\n 2. \\<And>a aa list ab lista.\n       \\<lbrakk>p = Some a; l = aa # list; list = ab # lista\\<rbrakk>\n       \\<Longrightarrow> <cs_list l p> cs_rotate p <cs_list (rotate1 l)>", "apply (sep_auto simp: cs_rotate.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list ab lista.\n       \\<lbrakk>p = Some a; l = aa # list; list = ab # lista\\<rbrakk>\n       \\<Longrightarrow> <cs_list l p> cs_rotate p <cs_list (rotate1 l)>", "apply (sep_auto simp: cs_rotate.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ab lista x pp na.\n       \\<lbrakk>p = Some a; l = x # ab # lista\\<rbrakk>\n       \\<Longrightarrow> a \\<mapsto>\\<^sub>r Node x (Some pp) *\n                         pp \\<mapsto>\\<^sub>r Node ab na *\n                         lseg lista na (Some a) \\<Longrightarrow>\\<^sub>A\n                         pp \\<mapsto>\\<^sub>r\n                         Node ab (?n142 a ab lista x pp na) *\n                         lseg (lista @ [x]) (?n142 a ab lista x pp na)\n                          (Some pp)", "apply (rule ent_frame_fwd)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ab lista x pp na.\n       \\<lbrakk>p = Some a; l = x # ab # lista\\<rbrakk>\n       \\<Longrightarrow> ?P149 a ab lista x pp na \\<Longrightarrow>\\<^sub>A\n                         ?R149 a ab lista x pp na\n 2. \\<And>a ab lista x pp na.\n       \\<lbrakk>p = Some a; l = x # ab # lista\\<rbrakk>\n       \\<Longrightarrow> a \\<mapsto>\\<^sub>r Node x (Some pp) *\n                         pp \\<mapsto>\\<^sub>r Node ab na *\n                         lseg lista na (Some a) \\<Longrightarrow>\\<^sub>A\n                         ?P149 a ab lista x pp na * ?F149 a ab lista x pp na\n 3. \\<And>a ab lista x pp na.\n       \\<lbrakk>p = Some a; l = x # ab # lista\\<rbrakk>\n       \\<Longrightarrow> ?R149 a ab lista x pp na *\n                         ?F149 a ab lista x pp na \\<Longrightarrow>\\<^sub>A\n                         pp \\<mapsto>\\<^sub>r\n                         Node ab (?n142 a ab lista x pp na) *\n                         lseg (lista @ [x]) (?n142 a ab lista x pp na)\n                          (Some pp)", "apply (rule_tac s=\"a\" in lseg_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ab lista x pp na.\n       \\<lbrakk>p = Some a; l = x # ab # lista\\<rbrakk>\n       \\<Longrightarrow> a \\<mapsto>\\<^sub>r Node x (Some pp) *\n                         pp \\<mapsto>\\<^sub>r Node ab na *\n                         lseg lista na (Some a) \\<Longrightarrow>\\<^sub>A\n                         lseg (?l153 a ab lista x pp na)\n                          (?p153 a ab lista x pp na) (Some a) *\n                         a \\<mapsto>\\<^sub>r\n                         Node (?x153 a ab lista x pp na)\n                          (?q153 a ab lista x pp na) *\n                         ?F149 a ab lista x pp na\n 2. \\<And>a ab lista x pp na.\n       \\<lbrakk>p = Some a; l = x # ab # lista\\<rbrakk>\n       \\<Longrightarrow> lseg\n                          (?l153 a ab lista x pp na @\n                           [?x153 a ab lista x pp na])\n                          (?p153 a ab lista x pp na)\n                          (?q153 a ab lista x pp na) *\n                         ?F149 a ab lista x pp na \\<Longrightarrow>\\<^sub>A\n                         pp \\<mapsto>\\<^sub>r\n                         Node ab (?n142 a ab lista x pp na) *\n                         lseg (lista @ [x]) (?n142 a ab lista x pp na)\n                          (Some pp)", "apply frame_inference"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ab lista x pp na.\n       \\<lbrakk>p = Some a; l = x # ab # lista\\<rbrakk>\n       \\<Longrightarrow> lseg (lista @ [x]) na (Some pp) *\n                         pp \\<mapsto>\\<^sub>r\n                         Node ab na \\<Longrightarrow>\\<^sub>A\n                         pp \\<mapsto>\\<^sub>r\n                         Node ab (?n142 a ab lista x pp na) *\n                         lseg (lista @ [x]) (?n142 a ab lista x pp na)\n                          (Some pp)", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cs_rotate_impl: \"imp_list_rotate cs_list cs_rotate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_rotate cs_list cs_rotate", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l p. <cs_list l p> cs_rotate p <cs_list (rotate1 l)>\\<^sub>t", "apply (sep_auto heap: cs_rotate_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation cs: imp_list_rotate cs_list cs_rotate"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_rotate cs_list cs_rotate", "by (rule cs_rotate_impl)"], ["", "subsection \\<open>Test\\<close>"], ["", "definition \"test \\<equiv> do {\n  l \\<leftarrow> cs_empty;\n  l \\<leftarrow> cs_append ''a'' l;\n  l \\<leftarrow> cs_append ''b'' l;\n  l \\<leftarrow> cs_append ''c'' l;\n  l \\<leftarrow> cs_prepend ''0'' l;\n  l \\<leftarrow> cs_rotate l;\n  (v1,l)\\<leftarrow>cs_pop l;\n  (v2,l)\\<leftarrow>cs_pop l;\n  (v3,l)\\<leftarrow>cs_pop l;\n  (v4,l)\\<leftarrow>cs_pop l;\n  return [v1,v2,v3,v4]\n}\""], ["", "definition \"test_result \\<equiv> [''a'', ''b'', ''c'', ''0'']\""], ["", "lemma \"<emp> test <\\<lambda>r. \\<up>(r=test_result) * true>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> test <\\<lambda>r. \\<up> (r = test_result)>\\<^sub>t", "unfolding test_def test_result_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> cs_empty \\<bind>\n          (\\<lambda>l.\n              cs_append ''a'' l \\<bind>\n              (\\<lambda>l.\n                  cs_append ''b'' l \\<bind>\n                  (\\<lambda>l.\n                      cs_append ''c'' l \\<bind>\n                      (\\<lambda>l.\n                          cs_prepend ''0'' l \\<bind>\n                          (\\<lambda>l.\n                              cs_rotate l \\<bind>\n                              (\\<lambda>l.\n                                  cs_pop l \\<bind>\n                                  (\\<lambda>(v1, l).\ncs_pop l \\<bind>\n(\\<lambda>(v2, l).\n    cs_pop l \\<bind>\n    (\\<lambda>(v3, l).\n        cs_pop l \\<bind>\n        (\\<lambda>(v4, l).\n            return\n             [v1, v2, v3,\n              v4])))))))))) <\\<lambda>r.\n                                \\<up>\n                                 (r = [''a'', ''b'', ''c'', ''0''])>\\<^sub>t", "apply (sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "export_code test checking SML_imp"], ["", "ML_val \\<open>\n  val res = @{code test} ();\n  if res = @{code test_result} then () else raise Match;\n\\<close>"], ["", "hide_const (open) test test_result"], ["", "end"]]}