{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Hoare_Triple.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma new_addr_refl[simp]: \"new_addrs h as h = as\"", "lemma\n  assumes \"<P> c <Q>\"\n  assumes \"(h,as)\\<Turnstile>P\"\n  shows hoare_triple_success: \"success c h\" \n    and hoare_triple_effect: \"\\<exists>h' r. effect c h h' r \\<and> (h',new_addrs h as h')\\<Turnstile>Q r\"", "lemma hoare_tripleD:\n  fixes h h' as as' \\<sigma> r\n  assumes \"<P> c <Q>\"\n  assumes \"(h,as)\\<Turnstile>P\"\n  assumes \"run c (Some h) \\<sigma> r\"\n  defines \"h'\\<equiv>the_state \\<sigma>\" and \"as'\\<equiv>new_addrs h as h'\"\n  shows \"\\<not>is_exn \\<sigma>\" \n  and \"(h',as')\\<Turnstile>Q r\"\n  and \"relH ({a . a<lim h \\<and> a\\<notin>as}) h h'\"\n  and \"lim h \\<le> lim h'\"", "lemma hoare_triple_preI: \n  assumes \"\\<And>h. h\\<Turnstile>P \\<Longrightarrow> <P> c <Q>\"\n  shows \"<P> c <Q>\"", "lemma frame_rule: \n  assumes A: \"<P> c <Q>\"\n  shows \"<P*R> c <\\<lambda>x. Q x * R>\"", "lemma false_rule[simp, intro!]: \"<false> c <Q>\"", "lemma cons_rule:\n  assumes CPRE: \"P \\<Longrightarrow>\\<^sub>A P'\"\n  assumes CPOST: \"\\<And>x. Q x \\<Longrightarrow>\\<^sub>A Q' x\"\n  assumes R: \"<P'> c <Q>\"\n  shows \"<P> c <Q'>\"", "lemmas cons_pre_rule = cons_rule[OF _ ent_refl]", "lemmas cons_post_rule = cons_rule[OF ent_refl, rotated]", "lemma cons_rulet: \"\\<lbrakk>P\\<Longrightarrow>\\<^sub>tP'; \\<And>x. Q x \\<Longrightarrow>\\<^sub>t Q' x; <P'> c <Q>\\<^sub>t \\<rbrakk> \\<Longrightarrow> <P> c <Q'>\\<^sub>t\"", "lemmas cons_pre_rulet = cons_rulet[OF _ entt_refl]", "lemmas cons_post_rulet = cons_rulet[OF entt_refl, rotated]", "lemma norm_pre_ex_rule:\n  assumes A: \"\\<And>x. <P x> f <Q>\"\n  shows \"<\\<exists>\\<^sub>Ax. P x> f <Q>\"", "lemma norm_pre_pure_iff[simp]:\n  \"<P*\\<up>b> f <Q> \\<longleftrightarrow> (b \\<longrightarrow> <P> f <Q>)\"", "lemma norm_pre_pure_iff_sng[simp]:\n  \"<\\<up>b> f <Q> \\<longleftrightarrow> (b \\<longrightarrow> <emp> f <Q>)\"", "lemma norm_pre_pure_rule1: \n  \"\\<lbrakk>b \\<Longrightarrow> <P> f <Q>\\<rbrakk> \\<Longrightarrow> <P*\\<up>b> f <Q>\"", "lemma norm_pre_pure_rule2:\n  \"\\<lbrakk> b \\<Longrightarrow> <emp> f <Q> \\<rbrakk> \\<Longrightarrow> <\\<up>b> f <Q>\"", "lemmas norm_pre_pure_rule = norm_pre_pure_rule1 norm_pre_pure_rule2", "lemma post_exI_rule: \"<P> c <\\<lambda>r. Q r x> \\<Longrightarrow> <P> c <\\<lambda>r. \\<exists>\\<^sub>Ax. Q r x>\"", "lemma ref_rule:\n  \"<emp> ref x <\\<lambda>r. r \\<mapsto>\\<^sub>r x>\"", "lemma lookup_rule:\n  \"<p \\<mapsto>\\<^sub>r x> !p <\\<lambda>r. p \\<mapsto>\\<^sub>r x * \\<up>(r = x)>\"", "lemma update_rule:\n  \"<p \\<mapsto>\\<^sub>r y> p := x <\\<lambda>r. p \\<mapsto>\\<^sub>r x>\"", "lemma update_wp_rule:\n  \"<r \\<mapsto>\\<^sub>r y * ((r \\<mapsto>\\<^sub>r x) -* (Q ()))> r := x <Q>\"", "lemma new_rule:\n  \"<emp> Array.new n x <\\<lambda>r. r \\<mapsto>\\<^sub>a replicate n x>\"", "lemma make_rule: \"<emp> Array.make n f <\\<lambda>r. r \\<mapsto>\\<^sub>a (map f [0 ..< n])>\"", "lemma of_list_rule: \"<emp> Array.of_list xs <\\<lambda>r. r \\<mapsto>\\<^sub>a xs>\"", "lemma length_rule:\n  \"<a \\<mapsto>\\<^sub>a xs> Array.len a <\\<lambda>r. a \\<mapsto>\\<^sub>a xs * \\<up>(r = length xs)>\"", "lemma nth_rule:\n  \"\\<lbrakk>i < length xs\\<rbrakk> \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs> Array.nth a i <\\<lambda>r. a \\<mapsto>\\<^sub>a xs * \\<up>(r = xs ! i)>\"", "lemma upd_rule:\n  \"\\<lbrakk>i < length xs\\<rbrakk> \\<Longrightarrow> \n  <a \\<mapsto>\\<^sub>a xs> \n  Array.upd i x a \n  <\\<lambda>r. (a \\<mapsto>\\<^sub>a (list_update xs i x)) * \\<up>(r = a)>\"", "lemma freeze_rule:\n  \"<a \\<mapsto>\\<^sub>a xs> Array.freeze a <\\<lambda>r. a \\<mapsto>\\<^sub>a xs * \\<up>(r = xs)>\"", "lemma return_wp_rule:\n  \"<Q x> return x <Q>\"", "lemma return_sp_rule:\n  \"<P> return x <\\<lambda>r. P * \\<up>(r = x)>\"", "lemma raise_iff: \n  \"<P> raise s <Q> \\<longleftrightarrow> P = false\"", "lemma raise_rule: \"<false> raise s <Q>\"", "lemma bind_rule: \n  assumes T1: \"<P> f <R>\"\n  assumes T2: \"\\<And>x. <R x> g x <Q>\"\n  shows \"<P> bind f g <Q>\"", "lemma if_rule:\n  assumes  \"b \\<Longrightarrow> <P> f <Q>\"\n  assumes  \"\\<not>b \\<Longrightarrow> <P> g <Q>\"\n  shows \"<P> if b then f else g <Q>\"", "lemma if_rule_split:\n  assumes  B: \"b \\<Longrightarrow> <P> f <Q1>\"\n  assumes  NB: \"\\<not>b \\<Longrightarrow> <P> g <Q2>\"\n  assumes M: \"\\<And>x. (Q1 x * \\<up>b) \\<or>\\<^sub>A (Q2 x * \\<up>(\\<not>b)) \\<Longrightarrow>\\<^sub>A Q x\"\n  shows \"<P> if b then f else g <Q>\"", "lemma split_rule: \n  assumes P: \"<P> c <R>\"\n  assumes Q: \"<Q> c <R>\"\n  shows \"<P \\<or>\\<^sub>A Q> c <R>\"", "lemmas decon_if_split = if_rule_split split_rule\n  \\<comment> \\<open>Use with care: Complete splitting of if statements\\<close>", "lemma case_prod_rule: \n  \"(\\<And>a b. x = (a, b) \\<Longrightarrow> <P> f a b <Q>) \\<Longrightarrow> <P> case x of (a, b) \\<Rightarrow> f a b <Q>\"", "lemma case_list_rule:\n  \"\\<lbrakk> l=[] \\<Longrightarrow> <P> fn <Q>; \\<And>x xs. l=x#xs \\<Longrightarrow> <P> fc x xs <Q> \\<rbrakk> \\<Longrightarrow> \n  <P> case_list fn fc l <Q>\"", "lemma case_option_rule:\n  \"\\<lbrakk> v=None \\<Longrightarrow> <P> fn <Q>; \\<And>x. v=Some x \\<Longrightarrow> <P> fs x <Q> \\<rbrakk> \n  \\<Longrightarrow> <P> case_option fn fs v <Q>\"", "lemma case_sum_rule:\n  \"\\<lbrakk> \\<And>x. v=Inl x \\<Longrightarrow> <P> fl x <Q>; \n     \\<And>x. v=Inr x \\<Longrightarrow> <P> fr x <Q> \\<rbrakk> \n  \\<Longrightarrow> <P> case_sum fl fr v <Q>\"", "lemma let_rule: \"(\\<And>x. x = t \\<Longrightarrow> <P> f x <Q>) \\<Longrightarrow> <P> Let t f <Q>\""], "translations": [["", "lemma new_addr_refl[simp]: \"new_addrs h as h = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_addrs h as h = as", "unfolding new_addrs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<union> {a. lim h \\<le> a \\<and> a < lim h} = as", "by auto"], ["", "text \\<open>\n  Apart from correctness of the program wrt. the pre- and post condition,\n  a Hoare-triple also encodes some well-formedness conditions of the command:\n  The command must not change addresses outside the address range of the \n  precondition, and it must not decrease the heap limit. \n\n  Note that we do not require that the command only reads from heap locations\n  inside the precondition's address range, as this condition would be quite\n  complicated to express with the heap model of Imperative/HOL, and is not \n  necessary in our formalization of partial heaps, that always contain the \n  information for all addresses.\n\\<close>"], ["", "definition hoare_triple \n  :: \"assn \\<Rightarrow> 'a Heap \\<Rightarrow> ('a \\<Rightarrow> assn) \\<Rightarrow> bool\" (\"<_>/ _/ <_>\")\n  where\n  \"<P> c <Q> \\<equiv> \\<forall>h as \\<sigma> r. (h,as)\\<Turnstile>P \\<and> run c (Some h) \\<sigma> r \n  \\<longrightarrow> (let h'=the_state \\<sigma>; as'=new_addrs h as h' in  \n    \\<not>is_exn \\<sigma> \\<and> (h',as')\\<Turnstile>Q r \\<and> relH ({a . a<lim h \\<and> a\\<notin>as}) h h' \n    \\<and> lim h \\<le> lim h')\""], ["", "text \\<open>Sanity checking theorems for Hoare-Triples\\<close>"], ["", "lemma\n  assumes \"<P> c <Q>\"\n  assumes \"(h,as)\\<Turnstile>P\"\n  shows hoare_triple_success: \"success c h\" \n    and hoare_triple_effect: \"\\<exists>h' r. effect c h h' r \\<and> (h',new_addrs h as h')\\<Turnstile>Q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success c h &&&\n    \\<exists>h' r.\n       effect c h h' r \\<and> (h', new_addrs h as h') \\<Turnstile> Q r", "using assms"], ["proof (prove)\nusing this:\n  <P> c <Q>\n  (h, as) \\<Turnstile> P\n\ngoal (1 subgoal):\n 1. success c h &&&\n    \\<exists>h' r.\n       effect c h h' r \\<and> (h', new_addrs h as h') \\<Turnstile> Q r", "unfolding hoare_triple_def success_def effect_def"], ["proof (prove)\nusing this:\n  \\<forall>h as \\<sigma> r.\n     (h, as) \\<Turnstile> P \\<and>\n     run c (Some h) \\<sigma> r \\<longrightarrow>\n     (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n      in \\<not> is_exn \\<sigma> \\<and>\n         (h', as') \\<Turnstile> Q r \\<and>\n         relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n         lim h \\<le> lim h')\n  (h, as) \\<Turnstile> P\n\ngoal (1 subgoal):\n 1. execute c h \\<noteq> None &&&\n    \\<exists>h' r.\n       execute c h = Some (r, h') \\<and>\n       (h', new_addrs h as h') \\<Turnstile> Q r", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>h as \\<sigma> r.\n                (h, as) \\<Turnstile> P \\<and>\n                run c (Some h) \\<sigma> r \\<longrightarrow>\n                (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n                 in \\<not> is_exn \\<sigma> \\<and>\n                    (h', as') \\<Turnstile> Q r \\<and>\n                    relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n                    lim h \\<le> lim h');\n     (h, as) \\<Turnstile> P\\<rbrakk>\n    \\<Longrightarrow> execute c h \\<noteq> None\n 2. \\<lbrakk>\\<forall>h as \\<sigma> r.\n                (h, as) \\<Turnstile> P \\<and>\n                run c (Some h) \\<sigma> r \\<longrightarrow>\n                (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n                 in \\<not> is_exn \\<sigma> \\<and>\n                    (h', as') \\<Turnstile> Q r \\<and>\n                    relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n                    lim h \\<le> lim h');\n     (h, as) \\<Turnstile> P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>h' r.\n                         execute c h = Some (r, h') \\<and>\n                         (h', new_addrs h as h') \\<Turnstile> Q r", "apply (auto simp: Let_def run.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>h as \\<sigma> r.\n                (h, as) \\<Turnstile> P \\<and>\n                (\\<sigma> = None \\<and> execute c h = None \\<or>\n                 (\\<exists>h'.\n                     \\<sigma> = Some h' \\<and>\n                     execute c h = Some (r, h'))) \\<longrightarrow>\n                \\<not> is_exn \\<sigma> \\<and>\n                (the_state \\<sigma>,\n                 new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                Q r \\<and>\n                relH {a. a < lim h \\<and> a \\<notin> as} h\n                 (the_state \\<sigma>) \\<and>\n                lim h \\<le> lim (the_state \\<sigma>);\n     (h, as) \\<Turnstile> P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b. execute c h = Some (a, b)\n 2. \\<lbrakk>\\<forall>h as \\<sigma> r.\n                (h, as) \\<Turnstile> P \\<and>\n                (\\<sigma> = None \\<and> execute c h = None \\<or>\n                 (\\<exists>h'.\n                     \\<sigma> = Some h' \\<and>\n                     execute c h = Some (r, h'))) \\<longrightarrow>\n                \\<not> is_exn \\<sigma> \\<and>\n                (the_state \\<sigma>,\n                 new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                Q r \\<and>\n                relH {a. a < lim h \\<and> a \\<notin> as} h\n                 (the_state \\<sigma>) \\<and>\n                lim h \\<le> lim (the_state \\<sigma>);\n     (h, as) \\<Turnstile> P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>h' r.\n                         execute c h = Some (r, h') \\<and>\n                         (h', new_addrs h as h') \\<Turnstile> Q r", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>h as \\<sigma> r.\n                (h, as) \\<Turnstile> P \\<and>\n                (\\<sigma> = None \\<and> execute c h = None \\<or>\n                 (\\<exists>h'.\n                     \\<sigma> = Some h' \\<and>\n                     execute c h = Some (r, h'))) \\<longrightarrow>\n                \\<not> is_exn \\<sigma> \\<and>\n                (the_state \\<sigma>,\n                 new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                Q r \\<and>\n                relH {a. a < lim h \\<and> a \\<notin> as} h\n                 (the_state \\<sigma>) \\<and>\n                lim h \\<le> lim (the_state \\<sigma>);\n     (h, as) \\<Turnstile> P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>h' r.\n                         execute c h = Some (r, h') \\<and>\n                         (h', new_addrs h as h') \\<Turnstile> Q r", "by (metis is_exn.simps(2) not_Some_eq2 the_state.simps)"], ["", "lemma hoare_tripleD:\n  fixes h h' as as' \\<sigma> r\n  assumes \"<P> c <Q>\"\n  assumes \"(h,as)\\<Turnstile>P\"\n  assumes \"run c (Some h) \\<sigma> r\"\n  defines \"h'\\<equiv>the_state \\<sigma>\" and \"as'\\<equiv>new_addrs h as h'\"\n  shows \"\\<not>is_exn \\<sigma>\" \n  and \"(h',as')\\<Turnstile>Q r\"\n  and \"relH ({a . a<lim h \\<and> a\\<notin>as}) h h'\"\n  and \"lim h \\<le> lim h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_exn \\<sigma> &&& (h', as') \\<Turnstile> Q r) &&&\n    relH {a. a < lim h \\<and> a \\<notin> as} h h' &&& lim h \\<le> lim h'", "using assms"], ["proof (prove)\nusing this:\n  <P> c <Q>\n  (h, as) \\<Turnstile> P\n  run c (Some h) \\<sigma> r\n  h' \\<equiv> the_state \\<sigma>\n  as' \\<equiv> new_addrs h as h'\n\ngoal (1 subgoal):\n 1. (\\<not> is_exn \\<sigma> &&& (h', as') \\<Turnstile> Q r) &&&\n    relH {a. a < lim h \\<and> a \\<notin> as} h h' &&& lim h \\<le> lim h'", "unfolding hoare_triple_def h'_def as'_def"], ["proof (prove)\nusing this:\n  \\<forall>h as \\<sigma> r.\n     (h, as) \\<Turnstile> P \\<and>\n     run c (Some h) \\<sigma> r \\<longrightarrow>\n     (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n      in \\<not> is_exn \\<sigma> \\<and>\n         (h', as') \\<Turnstile> Q r \\<and>\n         relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n         lim h \\<le> lim h')\n  (h, as) \\<Turnstile> P\n  run c (Some h) \\<sigma> r\n  the_state \\<sigma> \\<equiv> the_state \\<sigma>\n  new_addrs h as (the_state \\<sigma>) \\<equiv>\n  new_addrs h as (the_state \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<not> is_exn \\<sigma> &&&\n     (the_state \\<sigma>, new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n     Q r) &&&\n    relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>) &&&\n    lim h \\<le> lim (the_state \\<sigma>)", "by (auto simp: Let_def)"], ["", "text \\<open>For garbage-collected languages, specifications usually allow for some\n  arbitrary heap parts in the postcondition. The following abbreviation defines\n  a handy shortcut notation for such specifications.\\<close>"], ["", "abbreviation hoare_triple' \n  :: \"assn \\<Rightarrow> 'r Heap \\<Rightarrow> ('r \\<Rightarrow> assn) \\<Rightarrow> bool\" (\"<_> _ <_>\\<^sub>t\") \n  where \"<P> c <Q>\\<^sub>t \\<equiv> <P> c <\\<lambda>r. Q r * true>\""], ["", "subsection \\<open>Rules\\<close>"], ["", "text \\<open>\n  In this section, we provide a set of rules to prove Hoare-Triples correct.\n\\<close>"], ["", "subsubsection \\<open>Basic Rules\\<close>"], ["", "lemma hoare_triple_preI: \n  assumes \"\\<And>h. h\\<Turnstile>P \\<Longrightarrow> <P> c <Q>\"\n  shows \"<P> c <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> c <Q>", "using assms"], ["proof (prove)\nusing this:\n  ?h \\<Turnstile> P \\<Longrightarrow> <P> c <Q>\n\ngoal (1 subgoal):\n 1. <P> c <Q>", "unfolding hoare_triple_def"], ["proof (prove)\nusing this:\n  ?h \\<Turnstile> P \\<Longrightarrow>\n  \\<forall>h as \\<sigma> r.\n     (h, as) \\<Turnstile> P \\<and>\n     run c (Some h) \\<sigma> r \\<longrightarrow>\n     (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n      in \\<not> is_exn \\<sigma> \\<and>\n         (h', as') \\<Turnstile> Q r \\<and>\n         relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n         lim h \\<le> lim h')\n\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile> Q r \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "by auto"], ["", "lemma frame_rule: \n  assumes A: \"<P> c <Q>\"\n  shows \"<P*R> c <\\<lambda>x. Q x * R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P * R> c <\\<lambda>x. Q x * R>", "unfolding hoare_triple_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P * R \\<and>\n       run c (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r * R \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P * R \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r * R \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma> \\<and>\n                         (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R \\<and>\n                         relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>) \\<and>\n                         lim h \\<le> lim (the_state \\<sigma>)", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 3. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 3. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "fix h as"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 3. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "assume \"(h,as) \\<Turnstile> P * R\""], ["proof (state)\nthis:\n  (h, as) \\<Turnstile> P * R\n\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 3. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  (h, as) \\<Turnstile> P * R", "obtain as1 as2 where [simp]: \"as=as1\\<union>as2\" and DJ: \"as1\\<inter>as2={}\"\n    and M1: \"(h,as1)\\<Turnstile>P\" and M2: \"(h,as2)\\<Turnstile>R\""], ["proof (prove)\nusing this:\n  (h, as) \\<Turnstile> P * R\n\ngoal (1 subgoal):\n 1. (\\<And>as1 as2.\n        \\<lbrakk>as = as1 \\<union> as2; as1 \\<inter> as2 = {};\n         (h, as1) \\<Turnstile> P; (h, as2) \\<Turnstile> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding times_assn_def"], ["proof (prove)\nusing this:\n  (h, as) \\<Turnstile> Abs_assn (times_assn_raw (Rep_assn P) (Rep_assn R))\n\ngoal (1 subgoal):\n 1. (\\<And>as1 as2.\n        \\<lbrakk>as = as1 \\<union> as2; as1 \\<inter> as2 = {};\n         (h, as1) \\<Turnstile> P; (h, as2) \\<Turnstile> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Abs_assn_inverse)"], ["proof (state)\nthis:\n  as = as1 \\<union> as2\n  as1 \\<inter> as2 = {}\n  (h, as1) \\<Turnstile> P\n  (h, as2) \\<Turnstile> R\n\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 3. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "fix \\<sigma> r"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 3. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "assume RUN: \"run c (Some h) \\<sigma> r\""], ["proof (state)\nthis:\n  run c (Some h) \\<sigma> r\n\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 3. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "from hoare_tripleD(1)[OF A M1 RUN]"], ["proof (chain)\npicking this:\n  \\<not> is_exn \\<sigma>", "show \"\\<not> is_exn \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<not> is_exn \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> is_exn \\<sigma>", "."], ["proof (state)\nthis:\n  \\<not> is_exn \\<sigma>\n\ngoal (3 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 3. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "from hoare_tripleD(4)[OF A M1 RUN]"], ["proof (chain)\npicking this:\n  lim h \\<le> lim (the_state \\<sigma>)", "show \"lim h \\<le> lim (the_state \\<sigma>)\""], ["proof (prove)\nusing this:\n  lim h \\<le> lim (the_state \\<sigma>)\n\ngoal (1 subgoal):\n 1. lim h \\<le> lim (the_state \\<sigma>)", "."], ["proof (state)\nthis:\n  lim h \\<le> lim (the_state \\<sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)", "from hoare_tripleD(3)[OF A M1 RUN]"], ["proof (chain)\npicking this:\n  relH {a. a < lim h \\<and> a \\<notin> as1} h (the_state \\<sigma>)", "have \n    RH1: \"relH {a. a < lim h \\<and> a \\<notin> as1} h (the_state \\<sigma>)\""], ["proof (prove)\nusing this:\n  relH {a. a < lim h \\<and> a \\<notin> as1} h (the_state \\<sigma>)\n\ngoal (1 subgoal):\n 1. relH {a. a < lim h \\<and> a \\<notin> as1} h (the_state \\<sigma>)", "."], ["proof (state)\nthis:\n  relH {a. a < lim h \\<and> a \\<notin> as1} h (the_state \\<sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)", "moreover"], ["proof (state)\nthis:\n  relH {a. a < lim h \\<and> a \\<notin> as1} h (the_state \\<sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)", "have \"{a. a < lim h \\<and> a \\<notin> as} \\<subseteq> {a. a < lim h \\<and> a \\<notin> as1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. a < lim h \\<and> a \\<notin> as}\n    \\<subseteq> {a. a < lim h \\<and> a \\<notin> as1}", "by auto"], ["proof (state)\nthis:\n  {a. a < lim h \\<and> a \\<notin> as}\n  \\<subseteq> {a. a < lim h \\<and> a \\<notin> as1}\n\ngoal (2 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)", "ultimately"], ["proof (chain)\npicking this:\n  relH {a. a < lim h \\<and> a \\<notin> as1} h (the_state \\<sigma>)\n  {a. a < lim h \\<and> a \\<notin> as}\n  \\<subseteq> {a. a < lim h \\<and> a \\<notin> as1}", "show \"relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>)\""], ["proof (prove)\nusing this:\n  relH {a. a < lim h \\<and> a \\<notin> as1} h (the_state \\<sigma>)\n  {a. a < lim h \\<and> a \\<notin> as}\n  \\<subseteq> {a. a < lim h \\<and> a \\<notin> as1}\n\ngoal (1 subgoal):\n 1. relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>)", "by (blast intro: relH_subset)"], ["proof (state)\nthis:\n  relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R", "from hoare_tripleD(2)[OF A M1 RUN]"], ["proof (chain)\npicking this:\n  (the_state \\<sigma>, new_addrs h as1 (the_state \\<sigma>)) \\<Turnstile>\n  Q r", "have \n    \"(the_state \\<sigma>, new_addrs h as1 (the_state \\<sigma>)) \\<Turnstile> Q r\""], ["proof (prove)\nusing this:\n  (the_state \\<sigma>, new_addrs h as1 (the_state \\<sigma>)) \\<Turnstile>\n  Q r\n\ngoal (1 subgoal):\n 1. (the_state \\<sigma>, new_addrs h as1 (the_state \\<sigma>)) \\<Turnstile>\n    Q r", "."], ["proof (state)\nthis:\n  (the_state \\<sigma>, new_addrs h as1 (the_state \\<sigma>)) \\<Turnstile>\n  Q r\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R", "moreover"], ["proof (state)\nthis:\n  (the_state \\<sigma>, new_addrs h as1 (the_state \\<sigma>)) \\<Turnstile>\n  Q r\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R", "have DJN: \"new_addrs h as1 (the_state \\<sigma>) \\<inter> as2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_addrs h as1 (the_state \\<sigma>) \\<inter> as2 = {}", "using DJ models_in_range[OF M2]"], ["proof (prove)\nusing this:\n  as1 \\<inter> as2 = {}\n  in_range (h, as2)\n\ngoal (1 subgoal):\n 1. new_addrs h as1 (the_state \\<sigma>) \\<inter> as2 = {}", "by (auto simp: in_range.simps new_addrs_def)"], ["proof (state)\nthis:\n  new_addrs h as1 (the_state \\<sigma>) \\<inter> as2 = {}\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R", "moreover"], ["proof (state)\nthis:\n  new_addrs h as1 (the_state \\<sigma>) \\<inter> as2 = {}\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R", "have \"as2 \\<subseteq> {a. a < lim h \\<and> a \\<notin> as1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as2 \\<subseteq> {a. a < lim h \\<and> a \\<notin> as1}", "using DJ models_in_range[OF M2]"], ["proof (prove)\nusing this:\n  as1 \\<inter> as2 = {}\n  in_range (h, as2)\n\ngoal (1 subgoal):\n 1. as2 \\<subseteq> {a. a < lim h \\<and> a \\<notin> as1}", "by (auto simp: in_range.simps)"], ["proof (state)\nthis:\n  as2 \\<subseteq> {a. a < lim h \\<and> a \\<notin> as1}\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R", "hence \"relH as2 h (the_state \\<sigma>)\""], ["proof (prove)\nusing this:\n  as2 \\<subseteq> {a. a < lim h \\<and> a \\<notin> as1}\n\ngoal (1 subgoal):\n 1. relH as2 h (the_state \\<sigma>)", "using RH1"], ["proof (prove)\nusing this:\n  as2 \\<subseteq> {a. a < lim h \\<and> a \\<notin> as1}\n  relH {a. a < lim h \\<and> a \\<notin> as1} h (the_state \\<sigma>)\n\ngoal (1 subgoal):\n 1. relH as2 h (the_state \\<sigma>)", "by (blast intro: relH_subset)"], ["proof (state)\nthis:\n  relH as2 h (the_state \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R", "with M2"], ["proof (chain)\npicking this:\n  (h, as2) \\<Turnstile> R\n  relH as2 h (the_state \\<sigma>)", "have \"(the_state \\<sigma>, as2)\\<Turnstile>R\""], ["proof (prove)\nusing this:\n  (h, as2) \\<Turnstile> R\n  relH as2 h (the_state \\<sigma>)\n\ngoal (1 subgoal):\n 1. (the_state \\<sigma>, as2) \\<Turnstile> R", "by (metis mem_Collect_eq Rep_assn  \n      proper_iff relH_in_rangeI(2))"], ["proof (state)\nthis:\n  (the_state \\<sigma>, as2) \\<Turnstile> R\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R", "moreover"], ["proof (state)\nthis:\n  (the_state \\<sigma>, as2) \\<Turnstile> R\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R", "have \"new_addrs h as (the_state \\<sigma>) \n    = new_addrs h as1 (the_state \\<sigma>) \\<union> as2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_addrs h as (the_state \\<sigma>) =\n    new_addrs h as1 (the_state \\<sigma>) \\<union> as2", "by (auto simp: new_addrs_def)"], ["proof (state)\nthis:\n  new_addrs h as (the_state \\<sigma>) =\n  new_addrs h as1 (the_state \\<sigma>) \\<union> as2\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P * R;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r * R", "ultimately"], ["proof (chain)\npicking this:\n  (the_state \\<sigma>, new_addrs h as1 (the_state \\<sigma>)) \\<Turnstile>\n  Q r\n  new_addrs h as1 (the_state \\<sigma>) \\<inter> as2 = {}\n  (the_state \\<sigma>, as2) \\<Turnstile> R\n  new_addrs h as (the_state \\<sigma>) =\n  new_addrs h as1 (the_state \\<sigma>) \\<union> as2", "show \n    \"(the_state \\<sigma>, new_addrs h as (the_state \\<sigma>)) \\<Turnstile> Q r * R\""], ["proof (prove)\nusing this:\n  (the_state \\<sigma>, new_addrs h as1 (the_state \\<sigma>)) \\<Turnstile>\n  Q r\n  new_addrs h as1 (the_state \\<sigma>) \\<inter> as2 = {}\n  (the_state \\<sigma>, as2) \\<Turnstile> R\n  new_addrs h as (the_state \\<sigma>) =\n  new_addrs h as1 (the_state \\<sigma>) \\<union> as2\n\ngoal (1 subgoal):\n 1. (the_state \\<sigma>, new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n    Q r * R", "unfolding times_assn_def"], ["proof (prove)\nusing this:\n  (the_state \\<sigma>, new_addrs h as1 (the_state \\<sigma>)) \\<Turnstile>\n  Q r\n  new_addrs h as1 (the_state \\<sigma>) \\<inter> as2 = {}\n  (the_state \\<sigma>, as2) \\<Turnstile> R\n  new_addrs h as (the_state \\<sigma>) =\n  new_addrs h as1 (the_state \\<sigma>) \\<union> as2\n\ngoal (1 subgoal):\n 1. (the_state \\<sigma>, new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n    Abs_assn (times_assn_raw (Rep_assn (Q r)) (Rep_assn R))", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(the_state \\<sigma>,\n              new_addrs h as1 (the_state \\<sigma>)) \\<Turnstile>\n             Q r;\n     new_addrs h as1 (the_state \\<sigma>) \\<inter> as2 = {};\n     (the_state \\<sigma>, as2) \\<Turnstile> R;\n     new_addrs h (as1 \\<union> as2) (the_state \\<sigma>) =\n     new_addrs h as1 (the_state \\<sigma>) \\<union> as2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1a as2a.\n                         new_addrs h as1 (the_state \\<sigma>) \\<union> as2 =\n                         as1a \\<union> as2a \\<and>\n                         as1a \\<inter> as2a = {} \\<and>\n                         (the_state \\<sigma>, as1a) \\<Turnstile> Q r \\<and>\n                         (the_state \\<sigma>, as2a) \\<Turnstile> R", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (the_state \\<sigma>, new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n  Q r * R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma false_rule[simp, intro!]: \"<false> c <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <false> c <Q>", "unfolding hoare_triple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> false \\<and>\n       run c (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile> Q r \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "by simp"], ["", "lemma cons_rule:\n  assumes CPRE: \"P \\<Longrightarrow>\\<^sub>A P'\"\n  assumes CPOST: \"\\<And>x. Q x \\<Longrightarrow>\\<^sub>A Q' x\"\n  assumes R: \"<P'> c <Q>\"\n  shows \"<P> c <Q'>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> c <Q'>", "unfolding hoare_triple_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q' r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "using hoare_tripleD[OF R entailsD[OF CPRE]] entailsD[OF CPOST]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_exn ?\\<sigma>\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> (the_state ?\\<sigma>,\n                     new_addrs ?h ?as (the_state ?\\<sigma>)) \\<Turnstile>\n                    Q ?r\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> relH {a. a < lim ?h \\<and> a \\<notin> ?as} ?h\n                     (the_state ?\\<sigma>)\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> lim ?h \\<le> lim (the_state ?\\<sigma>)\n  ?h \\<Turnstile> Q ?x1 \\<Longrightarrow> ?h \\<Turnstile> Q' ?x1\n\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q' r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "by blast"], ["", "lemmas cons_pre_rule = cons_rule[OF _ ent_refl]"], ["", "lemmas cons_post_rule = cons_rule[OF ent_refl, rotated]"], ["", "lemma cons_rulet: \"\\<lbrakk>P\\<Longrightarrow>\\<^sub>tP'; \\<And>x. Q x \\<Longrightarrow>\\<^sub>t Q' x; <P'> c <Q>\\<^sub>t \\<rbrakk> \\<Longrightarrow> <P> c <Q'>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Longrightarrow>\\<^sub>t P';\n     \\<And>x. Q x \\<Longrightarrow>\\<^sub>t Q' x;\n     <P'> c <Q>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> <P> c <Q'>\\<^sub>t", "unfolding entailst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Longrightarrow>\\<^sub>A P' * true;\n     \\<And>x. Q x \\<Longrightarrow>\\<^sub>A Q' x * true;\n     <P'> c <Q>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> <P> c <Q'>\\<^sub>t", "apply (rule cons_pre_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<Longrightarrow>\\<^sub>A P' * true;\n     \\<And>x. Q x \\<Longrightarrow>\\<^sub>A Q' x * true;\n     <P'> c <Q>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>A ?P'\n 2. \\<lbrakk>P \\<Longrightarrow>\\<^sub>A P' * true;\n     \\<And>x. Q x \\<Longrightarrow>\\<^sub>A Q' x * true;\n     <P'> c <Q>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> <?P'> c <Q'>\\<^sub>t", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Longrightarrow>\\<^sub>A P' * true;\n     \\<And>x. Q x \\<Longrightarrow>\\<^sub>A Q' x * true;\n     <P'> c <Q>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> <P' * true> c <Q'>\\<^sub>t", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<Longrightarrow>\\<^sub>A P' * true;\n     \\<And>x. Q x \\<Longrightarrow>\\<^sub>A Q' x * true;\n     <P'> c <Q>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> <P' * true> c <?Q3>\n 2. \\<And>x.\n       \\<lbrakk>P \\<Longrightarrow>\\<^sub>A P' * true;\n        \\<And>x. Q x \\<Longrightarrow>\\<^sub>A Q' x * true;\n        <P'> c <Q>\\<^sub>t\\<rbrakk>\n       \\<Longrightarrow> ?Q3 x \\<Longrightarrow>\\<^sub>A Q' x * true", "apply (erule frame_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P \\<Longrightarrow>\\<^sub>A P' * true;\n        \\<And>x. Q x \\<Longrightarrow>\\<^sub>A Q' x * true;\n        <P'> c <Q>\\<^sub>t\\<rbrakk>\n       \\<Longrightarrow> Q x * true * true \\<Longrightarrow>\\<^sub>A\n                         Q' x * true", "by (simp add: enttD enttI)"], ["", "lemmas cons_pre_rulet = cons_rulet[OF _ entt_refl]"], ["", "lemmas cons_post_rulet = cons_rulet[OF entt_refl, rotated]"], ["", "lemma norm_pre_ex_rule:\n  assumes A: \"\\<And>x. <P x> f <Q>\"\n  shows \"<\\<exists>\\<^sub>Ax. P x> f <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Ax. P x> f <Q>", "unfolding hoare_triple_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> ex_assn P \\<and>\n       run f (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (intro allI impI, elim conjE mod_exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r x.\n       \\<lbrakk>run f (Some h) \\<sigma> r; (h, as) \\<Turnstile> P x\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma> \\<and>\n                         (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r \\<and>\n                         relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>) \\<and>\n                         lim h \\<le> lim (the_state \\<sigma>)", "using hoare_tripleD[OF A]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P ?x1;\n   run f (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_exn ?\\<sigma>\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P ?x1;\n   run f (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> (the_state ?\\<sigma>,\n                     new_addrs ?h ?as (the_state ?\\<sigma>)) \\<Turnstile>\n                    Q ?r\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P ?x1;\n   run f (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> relH {a. a < lim ?h \\<and> a \\<notin> ?as} ?h\n                     (the_state ?\\<sigma>)\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P ?x1;\n   run f (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> lim ?h \\<le> lim (the_state ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r x.\n       \\<lbrakk>run f (Some h) \\<sigma> r; (h, as) \\<Turnstile> P x\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma> \\<and>\n                         (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r \\<and>\n                         relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>) \\<and>\n                         lim h \\<le> lim (the_state \\<sigma>)", "by blast"], ["", "lemma norm_pre_pure_iff[simp]:\n  \"<P*\\<up>b> f <Q> \\<longleftrightarrow> (b \\<longrightarrow> <P> f <Q>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P * \\<up> b> f <Q> = (b \\<longrightarrow> <P> f <Q>)", "unfolding hoare_triple_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>h as \\<sigma> r.\n        (h, as) \\<Turnstile> P * \\<up> b \\<and>\n        run f (Some h) \\<sigma> r \\<longrightarrow>\n        \\<not> is_exn \\<sigma> \\<and>\n        (the_state \\<sigma>,\n         new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n        Q r \\<and>\n        relH {a. a < lim h \\<and> a \\<notin> as} h\n         (the_state \\<sigma>) \\<and>\n        lim h \\<le> lim (the_state \\<sigma>)) =\n    (b \\<longrightarrow>\n     (\\<forall>h as \\<sigma> r.\n         (h, as) \\<Turnstile> P \\<and>\n         run f (Some h) \\<sigma> r \\<longrightarrow>\n         \\<not> is_exn \\<sigma> \\<and>\n         (the_state \\<sigma>,\n          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n         Q r \\<and>\n         relH {a. a < lim h \\<and> a \\<notin> as} h\n          (the_state \\<sigma>) \\<and>\n         lim h \\<le> lim (the_state \\<sigma>)))", "by auto"], ["", "lemma norm_pre_pure_iff_sng[simp]:\n  \"<\\<up>b> f <Q> \\<longleftrightarrow> (b \\<longrightarrow> <emp> f <Q>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<up> b> f <Q> = (b \\<longrightarrow> <emp> f <Q>)", "using norm_pre_pure_iff[where P=emp]"], ["proof (prove)\nusing this:\n  <emp * \\<up> ?b> ?f <?Q> = (?b \\<longrightarrow> <emp> ?f <?Q>)\n\ngoal (1 subgoal):\n 1. <\\<up> b> f <Q> = (b \\<longrightarrow> <emp> f <Q>)", "by simp"], ["", "lemma norm_pre_pure_rule1: \n  \"\\<lbrakk>b \\<Longrightarrow> <P> f <Q>\\<rbrakk> \\<Longrightarrow> <P*\\<up>b> f <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<Longrightarrow> <P> f <Q>) \\<Longrightarrow> <P * \\<up> b> f <Q>", "by simp"], ["", "lemma norm_pre_pure_rule2:\n  \"\\<lbrakk> b \\<Longrightarrow> <emp> f <Q> \\<rbrakk> \\<Longrightarrow> <\\<up>b> f <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<Longrightarrow> <emp> f <Q>) \\<Longrightarrow> <\\<up> b> f <Q>", "by simp"], ["", "lemmas norm_pre_pure_rule = norm_pre_pure_rule1 norm_pre_pure_rule2"], ["", "lemma post_exI_rule: \"<P> c <\\<lambda>r. Q r x> \\<Longrightarrow> <P> c <\\<lambda>r. \\<exists>\\<^sub>Ax. Q r x>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. Q r x> \\<Longrightarrow>\n    <P> c <\\<lambda>r. \\<exists>\\<^sub>Ax. Q r x>", "by (blast intro: cons_post_rule ent_ex_postI ent_refl)"], ["", "subsubsection \\<open>Rules for Atomic Commands\\<close>"], ["", "lemma ref_rule:\n  \"<emp> ref x <\\<lambda>r. r \\<mapsto>\\<^sub>r x>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> ref x <\\<lambda>r. r \\<mapsto>\\<^sub>r x>", "unfolding one_assn_def sngr_assn_def hoare_triple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> Abs_assn one_assn_raw \\<and>\n       run (ref x) (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile> Abs_assn (sngr_assn_raw r x) \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "apply (simp add: Let_def Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h \\<sigma> r.\n       run (ref x) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       Ref.get (the_state \\<sigma>) r = x \\<and>\n       new_addrs h {} (the_state \\<sigma>) = {addr_of_ref r} \\<and>\n       addr_of_ref r < lim (the_state \\<sigma>) \\<and>\n       relH {a. a < lim h} h (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h \\<sigma> r.\n       run (ref x) (Some h) \\<sigma> r \\<Longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       Ref.get (the_state \\<sigma>) r = x \\<and>\n       new_addrs h {} (the_state \\<sigma>) = {addr_of_ref r} \\<and>\n       addr_of_ref r < lim (the_state \\<sigma>) \\<and>\n       relH {a. a < lim h} h (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (elim conjE run_elims)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h \\<sigma> r. \\<not> is_exn (Some h)\n 2. \\<And>h \\<sigma> r.\n       \\<lbrakk>\\<sigma> = Some (snd (Ref.alloc x (the_state (Some h))));\n        r = fst (Ref.alloc x (the_state (Some h)));\n        Ref.get (the_state \\<sigma>) r = x\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma> \\<and>\n                         Ref.get (the_state \\<sigma>) r = x \\<and>\n                         new_addrs h {} (the_state \\<sigma>) =\n                         {addr_of_ref r} \\<and>\n                         addr_of_ref r < lim (the_state \\<sigma>) \\<and>\n                         relH {a. a < lim h} h (the_state \\<sigma>) \\<and>\n                         lim h \\<le> lim (the_state \\<sigma>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h \\<sigma> r.\n       \\<lbrakk>\\<sigma> = Some (snd (Ref.alloc x (the_state (Some h))));\n        r = fst (Ref.alloc x (the_state (Some h)));\n        Ref.get (the_state \\<sigma>) r = x\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma> \\<and>\n                         Ref.get (the_state \\<sigma>) r = x \\<and>\n                         new_addrs h {} (the_state \\<sigma>) =\n                         {addr_of_ref r} \\<and>\n                         addr_of_ref r < lim (the_state \\<sigma>) \\<and>\n                         relH {a. a < lim h} h (the_state \\<sigma>) \\<and>\n                         lim h \\<le> lim (the_state \\<sigma>)", "apply (auto \n    simp: new_addrs_def Ref.alloc_def Let_def\n    Ref.set_def Ref.get_def relH_def in_range.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lookup_rule:\n  \"<p \\<mapsto>\\<^sub>r x> !p <\\<lambda>r. p \\<mapsto>\\<^sub>r x * \\<up>(r = x)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <p \\<mapsto>\\<^sub>r x> !p\n    <\\<lambda>r. p \\<mapsto>\\<^sub>r x * \\<up> (r = x)>", "unfolding hoare_triple_def sngr_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> Abs_assn (sngr_assn_raw p x) \\<and>\n       run (!p) (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile>\n           Abs_assn (sngr_assn_raw p x) * \\<up> (r = x) \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "apply (simp add: Let_def Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h \\<sigma> r.\n       Ref.get h p = x \\<and>\n       addr_of_ref p < lim h \\<and>\n       run (!p) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       Ref.get (the_state \\<sigma>) p = x \\<and>\n       new_addrs h {addr_of_ref p} (the_state \\<sigma>) =\n       {addr_of_ref p} \\<and>\n       addr_of_ref p < lim (the_state \\<sigma>) \\<and>\n       r = x \\<and>\n       relH {a. a < lim h \\<and> a \\<noteq> addr_of_ref p} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto elim: run_elims simp add: relH_refl in_range.simps new_addrs_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma update_rule:\n  \"<p \\<mapsto>\\<^sub>r y> p := x <\\<lambda>r. p \\<mapsto>\\<^sub>r x>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <p \\<mapsto>\\<^sub>r y> p := x <\\<lambda>r. p \\<mapsto>\\<^sub>r x>", "unfolding hoare_triple_def sngr_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> Abs_assn (sngr_assn_raw p y) \\<and>\n       run (p := x) (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile> Abs_assn (sngr_assn_raw p x) \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "apply (auto elim!: run_update \n    simp: Let_def Abs_assn_inverse new_addrs_def in_range.simps \n    intro!: relH_set_ref)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma update_wp_rule:\n  \"<r \\<mapsto>\\<^sub>r y * ((r \\<mapsto>\\<^sub>r x) -* (Q ()))> r := x <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <r \\<mapsto>\\<^sub>r y * (r \\<mapsto>\\<^sub>r x -* Q ())> r := x <Q>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. <r \\<mapsto>\\<^sub>r y * (r \\<mapsto>\\<^sub>r x -* Q ())> r := x <?Q>\n 2. \\<And>x. ?Q x \\<Longrightarrow>\\<^sub>A Q x", "apply (rule frame_rule[OF update_rule[where p=r and x=x], \n    where R=\"((r \\<mapsto>\\<^sub>r x) -* (Q ()))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       r \\<mapsto>\\<^sub>r x *\n       (r \\<mapsto>\\<^sub>r x -* Q ()) \\<Longrightarrow>\\<^sub>A\n       Q xa", "apply (rule ent_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       r \\<mapsto>\\<^sub>r x *\n       (r \\<mapsto>\\<^sub>r x -* Q ()) \\<Longrightarrow>\\<^sub>A\n       ?Q5 xa\n 2. \\<And>x. ?Q5 x \\<Longrightarrow>\\<^sub>A Q x", "apply (rule ent_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. Q () \\<Longrightarrow>\\<^sub>A Q x", "by simp"], ["", "lemma new_rule:\n  \"<emp> Array.new n x <\\<lambda>r. r \\<mapsto>\\<^sub>a replicate n x>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> Array.new n x <\\<lambda>r. r \\<mapsto>\\<^sub>a replicate n x>", "unfolding hoare_triple_def snga_assn_def one_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> Abs_assn one_assn_raw \\<and>\n       run (Array.new n x) (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile>\n           Abs_assn (snga_assn_raw r (replicate n x)) \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "apply (simp add: Let_def Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h \\<sigma> r.\n       run (Array.new n x) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       Array.get (the_state \\<sigma>) r = replicate n x \\<and>\n       new_addrs h {} (the_state \\<sigma>) = {addr_of_array r} \\<and>\n       addr_of_array r < lim (the_state \\<sigma>) \\<and>\n       relH {a. a < lim h} h (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto \n    elim!: run_elims\n    simp: Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def\n      relH_def in_range.simps\n  )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma make_rule: \"<emp> Array.make n f <\\<lambda>r. r \\<mapsto>\\<^sub>a (map f [0 ..< n])>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> Array.make n f <\\<lambda>r. r \\<mapsto>\\<^sub>a map f [0..<n]>", "unfolding hoare_triple_def snga_assn_def one_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> Abs_assn one_assn_raw \\<and>\n       run (Array.make n f) (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile>\n           Abs_assn (snga_assn_raw r (map f [0..<n])) \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "apply (simp add: Let_def Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h \\<sigma> r.\n       run (Array.make n f) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       Array.get (the_state \\<sigma>) r = map f [0..<n] \\<and>\n       new_addrs h {} (the_state \\<sigma>) = {addr_of_array r} \\<and>\n       addr_of_array r < lim (the_state \\<sigma>) \\<and>\n       relH {a. a < lim h} h (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto \n    elim!: run_elims\n    simp: Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def\n      relH_def in_range.simps\n  )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma of_list_rule: \"<emp> Array.of_list xs <\\<lambda>r. r \\<mapsto>\\<^sub>a xs>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> Array.of_list xs <\\<lambda>r. r \\<mapsto>\\<^sub>a xs>", "unfolding hoare_triple_def snga_assn_def one_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> Abs_assn one_assn_raw \\<and>\n       run (Array.of_list xs) (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile> Abs_assn (snga_assn_raw r xs) \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "apply (simp add: Let_def Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h \\<sigma> r.\n       run (Array.of_list xs) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       Array.get (the_state \\<sigma>) r = xs \\<and>\n       new_addrs h {} (the_state \\<sigma>) = {addr_of_array r} \\<and>\n       addr_of_array r < lim (the_state \\<sigma>) \\<and>\n       relH {a. a < lim h} h (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto \n    elim!: run_elims\n    simp: Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def\n      relH_def in_range.simps\n  )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_rule:\n  \"<a \\<mapsto>\\<^sub>a xs> Array.len a <\\<lambda>r. a \\<mapsto>\\<^sub>a xs * \\<up>(r = length xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs> Array.len a\n    <\\<lambda>r. a \\<mapsto>\\<^sub>a xs * \\<up> (r = length xs)>", "unfolding hoare_triple_def snga_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> Abs_assn (snga_assn_raw a xs) \\<and>\n       run (Array.len a) (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile>\n           Abs_assn (snga_assn_raw a xs) * \\<up> (r = length xs) \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "apply (simp add: Let_def Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h \\<sigma> r.\n       Array.get h a = xs \\<and>\n       addr_of_array a < lim h \\<and>\n       run (Array.len a) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       Array.get (the_state \\<sigma>) a = xs \\<and>\n       new_addrs h {addr_of_array a} (the_state \\<sigma>) =\n       {addr_of_array a} \\<and>\n       addr_of_array a < lim (the_state \\<sigma>) \\<and>\n       r = length xs \\<and>\n       relH {aa. aa < lim h \\<and> aa \\<noteq> addr_of_array a} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto \n    elim!: run_elims\n    simp: Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def\n      relH_def in_range.simps Array.length_def\n  )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Note that the Boolean expression is placed at meta level and not \n  inside the precondition. This makes frame inference simpler.\\<close>"], ["", "lemma nth_rule:\n  \"\\<lbrakk>i < length xs\\<rbrakk> \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs> Array.nth a i <\\<lambda>r. a \\<mapsto>\\<^sub>a xs * \\<up>(r = xs ! i)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    <a \\<mapsto>\\<^sub>a xs> Array.nth a i\n    <\\<lambda>r. a \\<mapsto>\\<^sub>a xs * \\<up> (r = xs ! i)>", "unfolding hoare_triple_def snga_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> Abs_assn (snga_assn_raw a xs) \\<and>\n       run (Array.nth a i) (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile>\n           Abs_assn (snga_assn_raw a xs) * \\<up> (r = xs ! i) \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "apply (simp add: Let_def Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    \\<forall>h \\<sigma> r.\n       Array.get h a = xs \\<and>\n       addr_of_array a < lim h \\<and>\n       run (Array.nth a i) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       Array.get (the_state \\<sigma>) a = xs \\<and>\n       new_addrs h {addr_of_array a} (the_state \\<sigma>) =\n       {addr_of_array a} \\<and>\n       addr_of_array a < lim (the_state \\<sigma>) \\<and>\n       r = xs ! i \\<and>\n       relH {aa. aa < lim h \\<and> aa \\<noteq> addr_of_array a} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto \n    elim!: run_elims\n    simp: Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def\n      relH_def in_range.simps Array.length_def\n  )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma upd_rule:\n  \"\\<lbrakk>i < length xs\\<rbrakk> \\<Longrightarrow> \n  <a \\<mapsto>\\<^sub>a xs> \n  Array.upd i x a \n  <\\<lambda>r. (a \\<mapsto>\\<^sub>a (list_update xs i x)) * \\<up>(r = a)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    <a \\<mapsto>\\<^sub>a xs> Array.upd i x a\n    <\\<lambda>r. a \\<mapsto>\\<^sub>a xs[i := x] * \\<up> (r = a)>", "unfolding hoare_triple_def snga_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> Abs_assn (snga_assn_raw a xs) \\<and>\n       run (Array.upd i x a) (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile>\n           Abs_assn (snga_assn_raw a (xs[i := x])) * \\<up> (r = a) \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "apply (simp add: Let_def Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    \\<forall>h \\<sigma> r.\n       Array.get h a = xs \\<and>\n       addr_of_array a < lim h \\<and>\n       run (Array.upd i x a) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       Array.get (the_state \\<sigma>) a = xs[i := x] \\<and>\n       new_addrs h {addr_of_array a} (the_state \\<sigma>) =\n       {addr_of_array a} \\<and>\n       addr_of_array a < lim (the_state \\<sigma>) \\<and>\n       r = a \\<and>\n       relH {aa. aa < lim h \\<and> aa \\<noteq> addr_of_array a} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto \n    elim!: run_elims\n    simp: Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def\n      relH_def in_range.simps Array.length_def Array.update_def comp_def\n  )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma freeze_rule:\n  \"<a \\<mapsto>\\<^sub>a xs> Array.freeze a <\\<lambda>r. a \\<mapsto>\\<^sub>a xs * \\<up>(r = xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs> Array.freeze a\n    <\\<lambda>r. a \\<mapsto>\\<^sub>a xs * \\<up> (r = xs)>", "unfolding hoare_triple_def snga_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> Abs_assn (snga_assn_raw a xs) \\<and>\n       run (Array.freeze a) (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile>\n           Abs_assn (snga_assn_raw a xs) * \\<up> (r = xs) \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "apply (simp add: Let_def Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h \\<sigma> r.\n       Array.get h a = xs \\<and>\n       addr_of_array a < lim h \\<and>\n       run (Array.freeze a) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       Array.get (the_state \\<sigma>) a = xs \\<and>\n       new_addrs h {addr_of_array a} (the_state \\<sigma>) =\n       {addr_of_array a} \\<and>\n       addr_of_array a < lim (the_state \\<sigma>) \\<and>\n       r = xs \\<and>\n       relH {aa. aa < lim h \\<and> aa \\<noteq> addr_of_array a} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto \n    elim!: run_elims\n    simp: Let_def new_addrs_def Array.get_def Array.set_def Array.alloc_def\n      relH_def in_range.simps Array.length_def Array.update_def\n  )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma return_wp_rule:\n  \"<Q x> return x <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <Q x> return x <Q>", "unfolding hoare_triple_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> Q x \\<and>\n       run (return x) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto elim!: run_elims)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as.\n       (h, as) \\<Turnstile> Q x \\<Longrightarrow>\n       relH {a. a < lim h \\<and> a \\<notin> as} h h", "apply (rule relH_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as.\n       (h, as) \\<Turnstile> Q x \\<Longrightarrow>\n       in_range (h, {a. a < lim h \\<and> a \\<notin> as})", "apply (simp add: in_range.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma return_sp_rule:\n  \"<P> return x <\\<lambda>r. P * \\<up>(r = x)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> return x <\\<lambda>r. P * \\<up> (r = x)>", "unfolding hoare_triple_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run (return x) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       P * \\<up> (r = x) \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run (return x) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       P \\<and>\n       r = x \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto elim!: run_elims intro!: relH_refl intro: models_in_range)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as.\n       (h, as) \\<Turnstile> P \\<Longrightarrow>\n       in_range (h, {a. a < lim h \\<and> a \\<notin> as})", "apply (simp add: in_range.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma raise_iff: \n  \"<P> raise s <Q> \\<longleftrightarrow> P = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> raise s <Q> = (P = false)", "unfolding hoare_triple_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>h as \\<sigma> r.\n        (h, as) \\<Turnstile> P \\<and>\n        run (raise s) (Some h) \\<sigma> r \\<longrightarrow>\n        \\<not> is_exn \\<sigma> \\<and>\n        (the_state \\<sigma>,\n         new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n        Q r \\<and>\n        relH {a. a < lim h \\<and> a \\<notin> as} h\n         (the_state \\<sigma>) \\<and>\n        lim h \\<le> lim (the_state \\<sigma>)) =\n    (P = false)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run (raise s) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>) \\<Longrightarrow>\n    P = false\n 2. P = false \\<Longrightarrow>\n    \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run (raise s) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (unfold bot_assn_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run (raise s) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>) \\<Longrightarrow>\n    P = Abs_assn (\\<lambda>_. False)\n 2. P = false \\<Longrightarrow>\n    \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run (raise s) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<forall>h as \\<sigma> r.\n          (h, as) \\<Turnstile> P \\<and>\n          run (raise s) (Some h) \\<sigma> r \\<longrightarrow>\n          \\<not> is_exn \\<sigma> \\<and>\n          (the_state \\<sigma>,\n           new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n          Q r \\<and>\n          relH {a. a < lim h \\<and> a \\<notin> as} h\n           (the_state \\<sigma>) \\<and>\n          lim h \\<le> lim (the_state \\<sigma>) \\<Longrightarrow>\n       False = (h \\<Turnstile> P)\n 2. P = false \\<Longrightarrow>\n    \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run (raise s) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto simp add: run_raise_iff) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = false \\<Longrightarrow>\n    \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run (raise s) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (auto simp add: run_raise_iff) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma raise_rule: \"<false> raise s <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <false> raise s <Q>", "by (simp add: raise_iff)"], ["", "subsubsection \\<open>Rules for Composed Commands\\<close>"], ["", "lemma bind_rule: \n  assumes T1: \"<P> f <R>\"\n  assumes T2: \"\\<And>x. <R x> g x <Q>\"\n  shows \"<P> bind f g <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> f \\<bind> g <Q>", "unfolding hoare_triple_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run (f \\<bind> g) (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run (f \\<bind> g) (Some h) \\<sigma> r \\<Longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       Q r \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (elim conjE run_elims)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma> \\<and>\n                         (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r \\<and>\n                         relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>) \\<and>\n                         lim h \\<le> lim (the_state \\<sigma>)", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r\n 3. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r\n 3. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "fix h as \\<sigma>'' r'' \\<sigma>' r'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r\n 3. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "assume M: \"(h,as) \\<Turnstile> P\" \n    and R1: \"run f (Some h) \\<sigma>' r'\" \n    and R2: \"run (g r') \\<sigma>' \\<sigma>'' r''\""], ["proof (state)\nthis:\n  (h, as) \\<Turnstile> P\n  run f (Some h) \\<sigma>' r'\n  run (g r') \\<sigma>' \\<sigma>'' r''\n\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r\n 3. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "from hoare_tripleD[OF T1 M R1]"], ["proof (chain)\npicking this:\n  \\<not> is_exn \\<sigma>'\n  (the_state \\<sigma>', new_addrs h as (the_state \\<sigma>')) \\<Turnstile>\n  R r'\n  relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>')\n  lim h \\<le> lim (the_state \\<sigma>')", "have NO_E: \"\\<not> is_exn \\<sigma>'\" \n    and M': \"(the_state \\<sigma>', new_addrs h as (the_state \\<sigma>')) \\<Turnstile> R r'\"\n    and RH': \"relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>')\"\n    and LIM: \"lim h \\<le> lim (the_state \\<sigma>')\""], ["proof (prove)\nusing this:\n  \\<not> is_exn \\<sigma>'\n  (the_state \\<sigma>', new_addrs h as (the_state \\<sigma>')) \\<Turnstile>\n  R r'\n  relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>')\n  lim h \\<le> lim (the_state \\<sigma>')\n\ngoal (1 subgoal):\n 1. (\\<not> is_exn \\<sigma>' &&&\n     (the_state \\<sigma>',\n      new_addrs h as (the_state \\<sigma>')) \\<Turnstile>\n     R r') &&&\n    relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>') &&&\n    lim h \\<le> lim (the_state \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  \\<not> is_exn \\<sigma>'\n  (the_state \\<sigma>', new_addrs h as (the_state \\<sigma>')) \\<Turnstile>\n  R r'\n  relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>')\n  lim h \\<le> lim (the_state \\<sigma>')\n\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r\n 3. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "from NO_E"], ["proof (chain)\npicking this:\n  \\<not> is_exn \\<sigma>'", "have [simp]: \"Some (the_state \\<sigma>') = \\<sigma>'\""], ["proof (prove)\nusing this:\n  \\<not> is_exn \\<sigma>'\n\ngoal (1 subgoal):\n 1. Some (the_state \\<sigma>') = \\<sigma>'", "by (cases \\<sigma>') auto"], ["proof (state)\nthis:\n  Some (the_state \\<sigma>') = \\<sigma>'\n\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r\n 3. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "from hoare_tripleD[OF T2 M', simplified, OF R2]"], ["proof (chain)\npicking this:\n  \\<not> is_exn \\<sigma>''\n  (the_state \\<sigma>'',\n   new_addrs (the_state \\<sigma>') (new_addrs h as (the_state \\<sigma>'))\n    (the_state \\<sigma>'')) \\<Turnstile>\n  Q r''\n  relH\n   {a. a < lim (the_state \\<sigma>') \\<and>\n       a \\<notin> new_addrs h as (the_state \\<sigma>')}\n   (the_state \\<sigma>') (the_state \\<sigma>'')\n  lim (the_state \\<sigma>') \\<le> lim (the_state \\<sigma>'')", "have \n    NO_E'': \"\\<not> is_exn \\<sigma>''\"\n    and M'': \"(the_state \\<sigma>'',\n      new_addrs (the_state \\<sigma>') \n        (new_addrs h as (the_state \\<sigma>')) (the_state \\<sigma>'')) \n      \\<Turnstile> Q r''\"\n    and RH'': \n    \"relH \n      {a. a < lim (the_state \\<sigma>') \n        \\<and> a \\<notin> new_addrs h as (the_state \\<sigma>')\n      }\n      (the_state \\<sigma>') (the_state \\<sigma>'')\"\n    and LIM': \"lim (the_state \\<sigma>') \\<le> lim (the_state \\<sigma>'')\""], ["proof (prove)\nusing this:\n  \\<not> is_exn \\<sigma>''\n  (the_state \\<sigma>'',\n   new_addrs (the_state \\<sigma>') (new_addrs h as (the_state \\<sigma>'))\n    (the_state \\<sigma>'')) \\<Turnstile>\n  Q r''\n  relH\n   {a. a < lim (the_state \\<sigma>') \\<and>\n       a \\<notin> new_addrs h as (the_state \\<sigma>')}\n   (the_state \\<sigma>') (the_state \\<sigma>'')\n  lim (the_state \\<sigma>') \\<le> lim (the_state \\<sigma>'')\n\ngoal (1 subgoal):\n 1. (\\<not> is_exn \\<sigma>'' &&&\n     (the_state \\<sigma>'',\n      new_addrs (the_state \\<sigma>') (new_addrs h as (the_state \\<sigma>'))\n       (the_state \\<sigma>'')) \\<Turnstile>\n     Q r'') &&&\n    relH\n     {a. a < lim (the_state \\<sigma>') \\<and>\n         a \\<notin> new_addrs h as (the_state \\<sigma>')}\n     (the_state \\<sigma>') (the_state \\<sigma>'') &&&\n    lim (the_state \\<sigma>') \\<le> lim (the_state \\<sigma>'')", "by auto"], ["proof (state)\nthis:\n  \\<not> is_exn \\<sigma>''\n  (the_state \\<sigma>'',\n   new_addrs (the_state \\<sigma>') (new_addrs h as (the_state \\<sigma>'))\n    (the_state \\<sigma>'')) \\<Turnstile>\n  Q r''\n  relH\n   {a. a < lim (the_state \\<sigma>') \\<and>\n       a \\<notin> new_addrs h as (the_state \\<sigma>')}\n   (the_state \\<sigma>') (the_state \\<sigma>'')\n  lim (the_state \\<sigma>') \\<le> lim (the_state \\<sigma>'')\n\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r\n 3. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "show \"\\<not> is_exn \\<sigma>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_exn \\<sigma>''", "by fact"], ["proof (state)\nthis:\n  \\<not> is_exn \\<sigma>''\n\ngoal (3 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 3. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "have  \n    \"new_addrs \n      (the_state \\<sigma>') \n      (new_addrs h as (the_state \\<sigma>')) \n      (the_state \\<sigma>'') \n    = new_addrs h as (the_state \\<sigma>'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_addrs (the_state \\<sigma>') (new_addrs h as (the_state \\<sigma>'))\n     (the_state \\<sigma>'') =\n    new_addrs h as (the_state \\<sigma>'')", "using LIM LIM'"], ["proof (prove)\nusing this:\n  lim h \\<le> lim (the_state \\<sigma>')\n  lim (the_state \\<sigma>') \\<le> lim (the_state \\<sigma>'')\n\ngoal (1 subgoal):\n 1. new_addrs (the_state \\<sigma>') (new_addrs h as (the_state \\<sigma>'))\n     (the_state \\<sigma>'') =\n    new_addrs h as (the_state \\<sigma>'')", "by (auto simp add: new_addrs_def)"], ["proof (state)\nthis:\n  new_addrs (the_state \\<sigma>') (new_addrs h as (the_state \\<sigma>'))\n   (the_state \\<sigma>'') =\n  new_addrs h as (the_state \\<sigma>'')\n\ngoal (3 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>,\n                          new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n                         Q r\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 3. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "with M''"], ["proof (chain)\npicking this:\n  (the_state \\<sigma>'',\n   new_addrs (the_state \\<sigma>') (new_addrs h as (the_state \\<sigma>'))\n    (the_state \\<sigma>'')) \\<Turnstile>\n  Q r''\n  new_addrs (the_state \\<sigma>') (new_addrs h as (the_state \\<sigma>'))\n   (the_state \\<sigma>'') =\n  new_addrs h as (the_state \\<sigma>'')", "show \n    \"(the_state \\<sigma>'', new_addrs h as (the_state \\<sigma>'')) \\<Turnstile> Q r''\""], ["proof (prove)\nusing this:\n  (the_state \\<sigma>'',\n   new_addrs (the_state \\<sigma>') (new_addrs h as (the_state \\<sigma>'))\n    (the_state \\<sigma>'')) \\<Turnstile>\n  Q r''\n  new_addrs (the_state \\<sigma>') (new_addrs h as (the_state \\<sigma>'))\n   (the_state \\<sigma>'') =\n  new_addrs h as (the_state \\<sigma>'')\n\ngoal (1 subgoal):\n 1. (the_state \\<sigma>'',\n     new_addrs h as (the_state \\<sigma>'')) \\<Turnstile>\n    Q r''", "by simp"], ["proof (state)\nthis:\n  (the_state \\<sigma>'', new_addrs h as (the_state \\<sigma>'')) \\<Turnstile>\n  Q r''\n\ngoal (2 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "note RH'"], ["proof (state)\nthis:\n  relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>')\n\ngoal (2 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "also"], ["proof (state)\nthis:\n  relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>')\n\ngoal (2 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "have \"relH {a. a < lim h \\<and> a \\<notin> as} (the_state \\<sigma>') (the_state \\<sigma>'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relH {a. a < lim h \\<and> a \\<notin> as} (the_state \\<sigma>')\n     (the_state \\<sigma>'')", "apply (rule relH_subset[OF RH''])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. a < lim h \\<and> a \\<notin> as}\n    \\<subseteq> {a. a < lim (the_state \\<sigma>') \\<and>\n                    a \\<notin> new_addrs h as (the_state \\<sigma>')}", "using LIM LIM'"], ["proof (prove)\nusing this:\n  lim h \\<le> lim (the_state \\<sigma>')\n  lim (the_state \\<sigma>') \\<le> lim (the_state \\<sigma>'')\n\ngoal (1 subgoal):\n 1. {a. a < lim h \\<and> a \\<notin> as}\n    \\<subseteq> {a. a < lim (the_state \\<sigma>') \\<and>\n                    a \\<notin> new_addrs h as (the_state \\<sigma>')}", "by (auto simp: new_addrs_def)"], ["proof (state)\nthis:\n  relH {a. a < lim h \\<and> a \\<notin> as} (the_state \\<sigma>')\n   (the_state \\<sigma>'')\n\ngoal (2 subgoals):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> relH {a. a < lim h \\<and> a \\<notin> as} h\n                          (the_state \\<sigma>)\n 2. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "finally"], ["proof (chain)\npicking this:\n  relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>'')", "show \"relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>'')\""], ["proof (prove)\nusing this:\n  relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>'')\n\ngoal (1 subgoal):\n 1. relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>'')", "."], ["proof (state)\nthis:\n  relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>'')\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "note LIM"], ["proof (state)\nthis:\n  lim h \\<le> lim (the_state \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "also"], ["proof (state)\nthis:\n  lim h \\<le> lim (the_state \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "note LIM'"], ["proof (state)\nthis:\n  lim (the_state \\<sigma>') \\<le> lim (the_state \\<sigma>'')\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r \\<sigma>' r'.\n       \\<lbrakk>(h, as) \\<Turnstile> P; run f (Some h) \\<sigma>' r';\n        run (g r') \\<sigma>' \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> lim h \\<le> lim (the_state \\<sigma>)", "finally"], ["proof (chain)\npicking this:\n  lim h \\<le> lim (the_state \\<sigma>'')", "show \"lim h \\<le> lim (the_state \\<sigma>'')\""], ["proof (prove)\nusing this:\n  lim h \\<le> lim (the_state \\<sigma>'')\n\ngoal (1 subgoal):\n 1. lim h \\<le> lim (the_state \\<sigma>'')", "."], ["proof (state)\nthis:\n  lim h \\<le> lim (the_state \\<sigma>'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma if_rule:\n  assumes  \"b \\<Longrightarrow> <P> f <Q>\"\n  assumes  \"\\<not>b \\<Longrightarrow> <P> g <Q>\"\n  shows \"<P> if b then f else g <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> if b then f else g <Q>", "using assms"], ["proof (prove)\nusing this:\n  b \\<Longrightarrow> <P> f <Q>\n  \\<not> b \\<Longrightarrow> <P> g <Q>\n\ngoal (1 subgoal):\n 1. <P> if b then f else g <Q>", "by auto"], ["", "lemma if_rule_split:\n  assumes  B: \"b \\<Longrightarrow> <P> f <Q1>\"\n  assumes  NB: \"\\<not>b \\<Longrightarrow> <P> g <Q2>\"\n  assumes M: \"\\<And>x. (Q1 x * \\<up>b) \\<or>\\<^sub>A (Q2 x * \\<up>(\\<not>b)) \\<Longrightarrow>\\<^sub>A Q x\"\n  shows \"<P> if b then f else g <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> if b then f else g <Q>", "apply (cases b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> <P> if b then f else g <Q>\n 2. \\<not> b \\<Longrightarrow> <P> if b then f else g <Q>", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> <P> f <Q>\n 2. \\<not> b \\<Longrightarrow> <P> g <Q>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. b \\<Longrightarrow> <P> f <?Q3>\n 2. \\<And>x. b \\<Longrightarrow> ?Q3 x \\<Longrightarrow>\\<^sub>A Q x\n 3. \\<not> b \\<Longrightarrow> <P> g <Q>", "apply (erule B)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. b \\<Longrightarrow> Q1 x \\<Longrightarrow>\\<^sub>A Q x\n 2. \\<not> b \\<Longrightarrow> <P> g <Q>", "apply (rule ent_trans[OF _ ent_disjI1[OF M]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       b \\<Longrightarrow> Q1 x \\<Longrightarrow>\\<^sub>A Q1 x * \\<up> b\n 2. \\<not> b \\<Longrightarrow> <P> g <Q>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow> <P> g <Q>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> b \\<Longrightarrow> <P> g <?Q11>\n 2. \\<And>x. \\<not> b \\<Longrightarrow> ?Q11 x \\<Longrightarrow>\\<^sub>A Q x", "apply (erule NB)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> b \\<Longrightarrow> Q2 x \\<Longrightarrow>\\<^sub>A Q x", "apply (rule ent_trans[OF _ ent_disjI2[OF M]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> b \\<Longrightarrow>\n       Q2 x \\<Longrightarrow>\\<^sub>A Q2 x * \\<up> (\\<not> b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma split_rule: \n  assumes P: \"<P> c <R>\"\n  assumes Q: \"<Q> c <R>\"\n  shows \"<P \\<or>\\<^sub>A Q> c <R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P \\<or>\\<^sub>A Q> c <R>", "unfolding hoare_triple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<or>\\<^sub>A Q \\<and>\n       run c (Some h) \\<sigma> r \\<longrightarrow>\n       (let h' = the_state \\<sigma>; as' = new_addrs h as h'\n        in \\<not> is_exn \\<sigma> \\<and>\n           (h', as') \\<Turnstile> R r \\<and>\n           relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n           lim h \\<le> lim h')", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<or>\\<^sub>A Q \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       let h' = the_state \\<sigma>; as' = new_addrs h as h'\n       in \\<not> is_exn \\<sigma> \\<and>\n          (h', as') \\<Turnstile> R r \\<and>\n          relH {a. a < lim h \\<and> a \\<notin> as} h h' \\<and>\n          lim h \\<le> lim h'", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P \\<or>\\<^sub>A Q;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> let h' = the_state \\<sigma>;\n                             as' = new_addrs h as h'\n                         in \\<not> is_exn \\<sigma> \\<and>\n                            (h', as') \\<Turnstile> R r \\<and>\n                            relH {a. a < lim h \\<and> a \\<notin> as} h\n                             h' \\<and>\n                            lim h \\<le> lim h'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>(h, as) \\<Turnstile> P \\<or> (h, as) \\<Turnstile> Q;\n        run c (Some h) \\<sigma> r\\<rbrakk>\n       \\<Longrightarrow> let h' = the_state \\<sigma>\n                         in \\<not> is_exn \\<sigma> \\<and>\n                            (h', new_addrs h as h') \\<Turnstile> R r \\<and>\n                            relH {a. a < lim h \\<and> a \\<notin> as} h\n                             h' \\<and>\n                            lim h \\<le> lim h'", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>run c (Some h) \\<sigma> r; (h, as) \\<Turnstile> P\\<rbrakk>\n       \\<Longrightarrow> let h' = the_state \\<sigma>\n                         in \\<not> is_exn \\<sigma> \\<and>\n                            (h', new_addrs h as h') \\<Turnstile> R r \\<and>\n                            relH {a. a < lim h \\<and> a \\<notin> as} h\n                             h' \\<and>\n                            lim h \\<le> lim h'\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>run c (Some h) \\<sigma> r; (h, as) \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> let h' = the_state \\<sigma>\n                         in \\<not> is_exn \\<sigma> \\<and>\n                            (h', new_addrs h as h') \\<Turnstile> R r \\<and>\n                            relH {a. a < lim h \\<and> a \\<notin> as} h\n                             h' \\<and>\n                            lim h \\<le> lim h'", "using hoare_tripleD[OF P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_exn ?\\<sigma>\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> (the_state ?\\<sigma>,\n                     new_addrs ?h ?as (the_state ?\\<sigma>)) \\<Turnstile>\n                    R ?r\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> relH {a. a < lim ?h \\<and> a \\<notin> ?as} ?h\n                     (the_state ?\\<sigma>)\n  \\<lbrakk>(?h, ?as) \\<Turnstile> P; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> lim ?h \\<le> lim (the_state ?\\<sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>run c (Some h) \\<sigma> r; (h, as) \\<Turnstile> P\\<rbrakk>\n       \\<Longrightarrow> let h' = the_state \\<sigma>\n                         in \\<not> is_exn \\<sigma> \\<and>\n                            (h', new_addrs h as h') \\<Turnstile> R r \\<and>\n                            relH {a. a < lim h \\<and> a \\<notin> as} h\n                             h' \\<and>\n                            lim h \\<le> lim h'\n 2. \\<And>h as \\<sigma> r.\n       \\<lbrakk>run c (Some h) \\<sigma> r; (h, as) \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> let h' = the_state \\<sigma>\n                         in \\<not> is_exn \\<sigma> \\<and>\n                            (h', new_addrs h as h') \\<Turnstile> R r \\<and>\n                            relH {a. a < lim h \\<and> a \\<notin> as} h\n                             h' \\<and>\n                            lim h \\<le> lim h'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>run c (Some h) \\<sigma> r; (h, as) \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> let h' = the_state \\<sigma>\n                         in \\<not> is_exn \\<sigma> \\<and>\n                            (h', new_addrs h as h') \\<Turnstile> R r \\<and>\n                            relH {a. a < lim h \\<and> a \\<notin> as} h\n                             h' \\<and>\n                            lim h \\<le> lim h'", "using hoare_tripleD[OF Q]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?h, ?as) \\<Turnstile> Q; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_exn ?\\<sigma>\n  \\<lbrakk>(?h, ?as) \\<Turnstile> Q; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> (the_state ?\\<sigma>,\n                     new_addrs ?h ?as (the_state ?\\<sigma>)) \\<Turnstile>\n                    R ?r\n  \\<lbrakk>(?h, ?as) \\<Turnstile> Q; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> relH {a. a < lim ?h \\<and> a \\<notin> ?as} ?h\n                     (the_state ?\\<sigma>)\n  \\<lbrakk>(?h, ?as) \\<Turnstile> Q; run c (Some ?h) ?\\<sigma> ?r\\<rbrakk>\n  \\<Longrightarrow> lim ?h \\<le> lim (the_state ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       \\<lbrakk>run c (Some h) \\<sigma> r; (h, as) \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> let h' = the_state \\<sigma>\n                         in \\<not> is_exn \\<sigma> \\<and>\n                            (h', new_addrs h as h') \\<Turnstile> R r \\<and>\n                            relH {a. a < lim h \\<and> a \\<notin> as} h\n                             h' \\<and>\n                            lim h \\<le> lim h'", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas decon_if_split = if_rule_split split_rule\n  \\<comment> \\<open>Use with care: Complete splitting of if statements\\<close>"], ["", "lemma case_prod_rule: \n  \"(\\<And>a b. x = (a, b) \\<Longrightarrow> <P> f a b <Q>) \\<Longrightarrow> <P> case x of (a, b) \\<Rightarrow> f a b <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        x = (a, b) \\<Longrightarrow> <P> f a b <Q>) \\<Longrightarrow>\n    <P> case x of (a, b) \\<Rightarrow> f a b <Q>", "by (auto split: prod.split)"], ["", "lemma case_list_rule:\n  \"\\<lbrakk> l=[] \\<Longrightarrow> <P> fn <Q>; \\<And>x xs. l=x#xs \\<Longrightarrow> <P> fc x xs <Q> \\<rbrakk> \\<Longrightarrow> \n  <P> case_list fn fc l <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l = [] \\<Longrightarrow> <P> fn <Q>;\n     \\<And>x xs. l = x # xs \\<Longrightarrow> <P> fc x xs <Q>\\<rbrakk>\n    \\<Longrightarrow> <P>\n                      case l of [] \\<Rightarrow> fn\n                      | x # xa \\<Rightarrow> fc x xa\n                      <Q>", "by (auto split: list.split)"], ["", "lemma case_option_rule:\n  \"\\<lbrakk> v=None \\<Longrightarrow> <P> fn <Q>; \\<And>x. v=Some x \\<Longrightarrow> <P> fs x <Q> \\<rbrakk> \n  \\<Longrightarrow> <P> case_option fn fs v <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = None \\<Longrightarrow> <P> fn <Q>;\n     \\<And>x. v = Some x \\<Longrightarrow> <P> fs x <Q>\\<rbrakk>\n    \\<Longrightarrow> <P>\n                      case v of None \\<Rightarrow> fn\n                      | Some x \\<Rightarrow> fs x\n                      <Q>", "by (auto split: option.split)"], ["", "lemma case_sum_rule:\n  \"\\<lbrakk> \\<And>x. v=Inl x \\<Longrightarrow> <P> fl x <Q>; \n     \\<And>x. v=Inr x \\<Longrightarrow> <P> fr x <Q> \\<rbrakk> \n  \\<Longrightarrow> <P> case_sum fl fr v <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. v = Inl x \\<Longrightarrow> <P> fl x <Q>;\n     \\<And>x. v = Inr x \\<Longrightarrow> <P> fr x <Q>\\<rbrakk>\n    \\<Longrightarrow> <P>\n                      case v of Inl x \\<Rightarrow> fl x\n                      | Inr x \\<Rightarrow> fr x\n                      <Q>", "by (auto split: sum.split)"], ["", "lemma let_rule: \"(\\<And>x. x = t \\<Longrightarrow> <P> f x <Q>) \\<Longrightarrow> <P> Let t f <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x = t \\<Longrightarrow> <P> f x <Q>) \\<Longrightarrow>\n    <P> Let t f <Q>", "by (auto)"], ["", "end"]]}