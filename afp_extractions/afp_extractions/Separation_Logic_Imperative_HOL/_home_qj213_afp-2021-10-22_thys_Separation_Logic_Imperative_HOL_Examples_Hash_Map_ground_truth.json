{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Examples/Hash_Map.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma map_of_ls_update: \n  \"map_of (fst (ls_update k v l)) = (map_of l)(k \\<mapsto> v)\"", "lemma map_of_concat:\n  \"k \\<in> dom (map_of(concat l)) \n  \\<Longrightarrow> \\<exists>i. k \\<in> dom (map_of(l!i)) \\<and> i < length l\"", "lemma map_of_concat':\n  \"k \\<in> dom (map_of(l!i)) \\<and> i < length l \\<Longrightarrow> k \\<in> dom (map_of(concat l))\"", "lemma map_of_concat''':\n  assumes \"\\<exists>i. k \\<in> dom (map_of(l!i)) \\<and> i < length l\"\n  shows \"k \\<in> dom (map_of(concat l))\"", "lemma map_of_concat'':\n  \"(k \\<in> dom (map_of(concat l))) \n  \\<longleftrightarrow> (\\<exists>i. k \\<in> dom (map_of(l!i)) \\<and> i < length l)\"", "lemma abs_update_length: \"length (abs_update k v l) = length l\"", "lemma ls_update_map_of_eq:\n  \"map_of (fst (ls_update k v ls)) k = Some v\"", "lemma ls_update_map_of_neq:\n  \"x \\<noteq> k \\<Longrightarrow> map_of (fst (ls_update k v ls)) x = map_of ls x\"", "lemma is_hashmap'_prec:\n  \"\\<forall>s s'. h\\<Turnstile>(is_hashmap' m l ht * F1) \\<and>\\<^sub>A (is_hashmap' m' l' ht * F2)\n  \\<longrightarrow> l=l' \\<and> m=m'\"", "lemma is_hashmap_prec: \"precise is_hashmap\"", "lemma hm_new_rule': \n  \"<emp> \n  hm_new::('k::{heap,hashable}, 'v::heap) hashtable Heap \n  <is_hashmap' Map.empty (replicate (def_hashmap_size TYPE('k)) [])>\"", "lemma hm_new_rule: \n  \"<emp> hm_new <is_hashmap Map.empty>\"", "lemma ht_hash_distinct:\n  \"ht_hash l \n  \\<Longrightarrow> \\<forall>i j . i\\<noteq>j \\<and> i < length l \\<and> j < length l \n    \\<longrightarrow> set (l!i) \\<inter> set (l!j) = {}\"", "lemma ht_hash_in_dom_in_dom_bounded_hashcode_nat:\n  assumes \"ht_hash l\"\n  assumes \"k \\<in> dom (map_of(concat l))\"\n  shows \"k \\<in> dom (map_of(l!bounded_hashcode_nat (length l) k))\"", "lemma ht_hash_in_dom_bounded_hashcode_nat_in_dom:\n  assumes \"ht_hash l\"\n  assumes \"1 < length l\"\n  assumes \"k \\<in> dom (map_of(l!bounded_hashcode_nat (length l) k))\"\n  shows \"k \\<in> dom (map_of(concat l))\"", "lemma ht_hash_in_dom_in_dom_bounded_hashcode_nat_eq:\n  assumes \"ht_hash l\"\n  assumes \"1 < length l\"\n  shows \"(k \\<in> dom (map_of(concat l))) \n  = (k \\<in> dom (map_of(l!bounded_hashcode_nat (length l) k)))\"", "lemma ht_hash_in_dom_i_bounded_hashcode_nat_i:\n  assumes \"ht_hash l\"\n  assumes \"1 < length l\"\n  assumes \"i < length l\"\n  assumes \"k \\<in> dom (map_of (l!i))\" \n  shows \"i = bounded_hashcode_nat (length l) k\"", "lemma ht_hash_in_bounded_hashcode_nat_not_i_not_in_dom_i:\n  assumes \"ht_hash l\"\n  assumes \"1 < length l\"\n  assumes \"i < length l\"\n  assumes \"i \\<noteq> bounded_hashcode_nat (length l) k\"\n  shows \"k \\<notin> dom (map_of (l!i))\"", "lemma ht_hash_ht_distinct_in_dom_unique_value:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  assumes \"k \\<in> dom (map_of (concat l))\"\n  shows \"\\<exists>!v. (k,v) \\<in> set (concat l)\"", "lemma ht_hash_ht_distinct_map_of:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat l) k \n  = map_of(l!bounded_hashcode_nat (length l) k) k\"", "lemma ls_lookup_map_of_pre:\n  \"distinct (map fst l) \\<Longrightarrow> ls_lookup k l = map_of l k\"", "lemma ls_lookup_map_of:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\" \n  assumes \"1 < length l\" \n  shows \"ls_lookup k (l ! bounded_hashcode_nat (length l) k) \n  = map_of (concat l) k\"", "lemma hm_lookup_rule':\n  \"<is_hashmap' m l ht> hm_lookup k ht \n    <\\<lambda>r. is_hashmap' m l ht * \n      \\<up>(r = m k)>\"", "lemma hm_lookup_rule:\n  \"<is_hashmap m ht> hm_lookup k ht \n    <\\<lambda>r. is_hashmap m ht * \n      \\<up>(r = m k)>\"", "lemma abs_update_map_of'':\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (abs_update k v l)) k = Some v\"", "lemma abs_update_map_of_hceq:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  assumes \"x \\<noteq> k\"\n  assumes \"bounded_hashcode_nat (length l) x \n    = bounded_hashcode_nat (length l) k\"\n  shows \"map_of (concat (abs_update k v l)) x = map_of (concat l) x\"", "lemma abs_update_map_of_hcneq:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  assumes \"x \\<noteq> k\"\n  assumes \"bounded_hashcode_nat (length l) x \n    \\<noteq> bounded_hashcode_nat (length l) k\"\n  shows \"map_of (concat (abs_update k v l)) x = map_of (concat l) x\"", "lemma abs_update_map_of''':\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  assumes \"x \\<noteq> k\"\n  shows \"map_of (concat (abs_update k v l)) x = map_of (concat l) x\"", "lemma abs_update_map_of':  \n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (abs_update k v l)) x \n    = (map_of (concat l)(k \\<mapsto> v)) x\"", "lemma abs_update_map_of:  \n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (abs_update k v l)) \n    = map_of (concat l)(k \\<mapsto> v) \"", "lemma ls_insls_map_of:\n  assumes \"ht_hash ld\"\n  assumes \"ht_distinct ld\"\n  assumes \"1 < length ld\"\n  assumes \"distinct (map fst xs)\"\n  shows \"map_of (concat (ls_insls xs ld)) = map_of (concat ld) ++ map_of xs\"", "lemma ls_insls_map_of':\n  assumes \"ht_hash ls\"\n  assumes \"ht_distinct ls\"\n  assumes \"ht_hash ld\"\n  assumes \"ht_distinct ld\"\n  assumes \"1 < length ld\"\n  assumes \"n < length ls\"\n  shows \"map_of (concat (ls_insls (ls ! n) ld)) \n      ++ map_of (concat (take n ls))\n    = map_of (concat ld) ++ map_of (concat (take (Suc n) ls))\"", "lemma ls_copy_map_of:\n  assumes \"ht_hash ls\"\n  assumes \"ht_distinct ls\"\n  assumes \"ht_hash ld\"\n  assumes \"ht_distinct ld\"\n  assumes \"1 < length ld\"\n  assumes \"n \\<le> length ls\"\n  shows \"map_of (concat (ls_copy n ls ld)) = map_of (concat ld) ++ map_of (concat (take n ls))\"", "lemma ls_rehash_map_of:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (ls_rehash l)) = map_of (concat l)\"", "lemma abs_update_rehash_map_of:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (abs_update k v (ls_rehash l))) \n  = map_of (concat l)(k \\<mapsto> v)\"", "lemma hm_update_rule':\n  \"<is_hashmap' m l ht> \n    hm_update k v ht \n  <\\<lambda>r. is_hashmap (m(k \\<mapsto> v)) r * true>\"", "lemma hm_update_rule:\n  \"<is_hashmap m ht> \n    hm_update k v ht \n  <\\<lambda>r. is_hashmap (m(k \\<mapsto> v)) r * true>\"", "lemma ls_delete_map_of:\n  assumes \"distinct (map fst l)\"\n  shows \"map_of (fst (ls_delete k l)) x = ((map_of l) |` (- {k})) x\"", "lemma update_ls_delete_map_of: \n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"ht_hash (l[bounded_hashcode_nat (length l) k \n  := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\"\n  assumes \"ht_distinct (l[bounded_hashcode_nat (length l) k \n  := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (l[bounded_hashcode_nat (length l) k \n    := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])) x\n  = ((map_of (concat l)) |` (- {k})) x\"", "lemma hm_delete_rule': \n  \"<is_hashmap' m l ht> hm_delete k ht <is_hashmap (m |` (-{k}))>\"", "lemma hm_delete_rule: \n  \"<is_hashmap m ht> hm_delete k ht <is_hashmap (m |` (-{k}))>\"", "lemma hm_isEmpty_rule': \n  \"<is_hashmap' m l ht> \n  hm_isEmpty ht \n  <\\<lambda>r. is_hashmap' m l ht * \\<up>(r \\<longleftrightarrow> m=Map.empty)>\"", "lemma hm_isEmpty_rule: \n  \"<is_hashmap m ht> hm_isEmpty ht <\\<lambda>r. is_hashmap m ht * \\<up>(r \\<longleftrightarrow> m=Map.empty)>\"", "lemma length_card_dom_map_of:\n  assumes \"distinct (map fst l)\"\n  shows \"length l = card (dom (map_of l))\"", "lemma ht_hash_dom_map_of_disj:\n  assumes \"ht_hash l\"\n  assumes \"i < length l\"\n  assumes \"j < length l\"\n  assumes \"i \\<noteq> j\"\n  shows \"dom (map_of (l!i)) \\<inter> dom (map_of(l!j)) = {}\"", "lemma ht_hash_dom_map_of_disj_drop:\n  assumes \"ht_hash l\"\n  assumes \"i < length l\"\n  shows \"dom (map_of (l!i)) \\<inter> dom (map_of (concat (drop (Suc i) l))) = {}\"", "lemma sum_list_length_card_dom_map_of_concat:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  shows \"sum_list (map length l) = card (dom (map_of (concat l)))\"", "lemma hm_size_rule': \n  \"<is_hashmap' m l ht> \n  hm_size ht \n  <\\<lambda>r. is_hashmap' m l ht * \\<up>(r = card (dom m))>\"", "lemma hm_size_rule: \n  \"<is_hashmap m ht> \n    hm_size ht \n  <\\<lambda>r. is_hashmap m ht * \\<up>(r = card (dom m))>\"", "lemma concat_take_Suc_empty: \"\\<lbrakk> n < length l; l!n=[] \\<rbrakk> \n  \\<Longrightarrow> concat (take (Suc n) l) = concat (take n l)\"", "lemma nth_concat_splitE:\n  assumes \"i<length (concat ls)\"\n  obtains j k where\n  \"j < length ls\" \n  and \"k < length (ls!j)\" \n  and \"concat ls ! i = ls!j!k\"\n  and \"i = length (concat (take j ls)) + k\"", "lemma is_hashmap'_distinct: \n  \"is_hashtable l ht \n    \\<Longrightarrow>\\<^sub>A is_hashtable l ht * \\<up>(distinct (map fst (concat l)))\"", "lemma take_set: \"set (take n l) = { l!i | i. i<n \\<and> i<length l }\"", "lemma skip_empty_aux:\n  assumes A: \"concat (take (Suc n) l) = concat (take (Suc x) l)\"\n  assumes L[simp]: \"Suc n \\<le> length l\" \"x \\<le> n\"\n  shows \"\\<forall>i. x<i \\<and> i\\<le>n \\<longrightarrow> l!i=[]\"", "lemma take_Suc0: \n  \"l\\<noteq>[] \\<Longrightarrow> take (Suc 0) l = [l!0]\" \n  \"0 < length l \\<Longrightarrow> take (Suc 0) l = [l!0]\" \n  \"Suc n \\<le> length l \\<Longrightarrow> take (Suc 0) l = [l!0]\"", "lemma concat_take_Suc_app_nth:\n  assumes \"x < length l\"\n  shows \"concat (take (Suc x) l) = concat (take x l) @ l ! x\"", "lemma hm_hashcode_eq:\n  assumes \"j < length (l!i)\"\n  assumes \"i < length l\"\n  assumes \"h \\<Turnstile> is_hashtable l ht\"\n  shows \"bounded_hashcode_nat (length l) (fst (l!i!j)) = i\"", "lemma distinct_imp_distinct_take: \n  \"distinct (map fst (concat l))\n  \\<Longrightarrow> distinct (map fst (concat (take x l)))\"", "lemma hm_it_adjust_rule:\n  \"i<length l \\<Longrightarrow> <is_hashtable l ht> \n    hm_it_adjust i ht \n   <\\<lambda>j. is_hashtable l ht * \\<up>(\n      j\\<le>i \\<and> \n      (concat (take (Suc i) l) = concat (take (Suc j) l)) \\<and>\n      (j=0 \\<or> l!j \\<noteq> [])\n    )    \n   >\"", "lemma hm_it_next_rule': \"l'\\<noteq>[] \\<Longrightarrow> \n    <hm_is_it' l ht l' it> \n      hm_it_next it \n    <\\<lambda>((k,v),it'). \n      hm_is_it' l ht (butlast l') it' \n    * \\<up>(last l' = (k,v) \\<and> distinct (map fst l') )>\"", "lemma hm_it_next_rule: \"m'\\<noteq>Map.empty \\<Longrightarrow> \n    <hm_is_it m ht m' it> \n      hm_it_next it \n    <\\<lambda>((k,v),it'). hm_is_it m ht (m' |` (-{k})) it' * \\<up>(m' k = Some v)>\"", "lemma hm_it_init_rule:\n  fixes ht :: \"('k::{heap,hashable},'v::heap) hashtable\"\n  shows \"<is_hashmap m ht> hm_it_init ht <hm_is_it m ht m>\\<^sub>t\"", "lemma hm_it_has_next_rule:\n  \"<hm_is_it m ht m' it> hm_it_has_next it \n    <\\<lambda>r. hm_is_it m ht m' it * \\<up>(r\\<longleftrightarrow>m'\\<noteq>Map.empty)>\"", "lemma hm_it_finish: \"hm_is_it m p m' it \\<Longrightarrow>\\<^sub>A is_hashmap m p\""], "translations": [["", "lemma map_of_ls_update: \n  \"map_of (fst (ls_update k v l)) = (map_of l)(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (fst (ls_update k v l)) = map_of l(k \\<mapsto> v)", "apply (induct l rule: ls_update.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k v. map_of (fst (ls_update k v [])) = map_of [](k \\<mapsto> v)\n 2. \\<And>k v l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        map_of (fst (ls_update k v ls)) = map_of ls(k \\<mapsto>\n        v)) \\<Longrightarrow>\n       map_of (fst (ls_update k v ((l, w) # ls))) = map_of ((l, w) # ls)(k \n       \\<mapsto> v)", "by (auto simp add: ext Let_def)"], ["", "lemma map_of_concat:\n  \"k \\<in> dom (map_of(concat l)) \n  \\<Longrightarrow> \\<exists>i. k \\<in> dom (map_of(l!i)) \\<and> i < length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    \\<exists>i. k \\<in> dom (map_of (l ! i)) \\<and> i < length l", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k \\<in> dom (map_of (concat [])) \\<Longrightarrow>\n    \\<exists>i. k \\<in> dom (map_of ([] ! i)) \\<and> i < length []\n 2. \\<And>a l.\n       \\<lbrakk>k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n                \\<exists>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and> i < length l;\n        k \\<in> dom (map_of (concat (a # l)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            k \\<in> dom (map_of ((a # l) ! i)) \\<and>\n                            i < length (a # l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n                \\<exists>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and> i < length l;\n        k \\<in> dom (map_of (concat (a # l)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            k \\<in> dom (map_of ((a # l) ! i)) \\<and>\n                            i < length (a # l)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l y.\n       \\<lbrakk>k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n                \\<exists>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and> i < length l;\n        map_of a k = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            k \\<in> dom (map_of ((a # l) ! i)) \\<and>\n                            i < Suc (length l)\n 2. \\<And>a l y.\n       \\<lbrakk>k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n                \\<exists>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and> i < length l;\n        map_of (concat l) k = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            k \\<in> dom (map_of ((a # l) ! i)) \\<and>\n                            i < Suc (length l)", "apply (rule_tac x = 0 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l y.\n       \\<lbrakk>k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n                \\<exists>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and> i < length l;\n        map_of a k = Some y\\<rbrakk>\n       \\<Longrightarrow> k \\<in> dom (map_of ((a # l) ! 0)) \\<and>\n                         0 < Suc (length l)\n 2. \\<And>a l y.\n       \\<lbrakk>k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n                \\<exists>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and> i < length l;\n        map_of (concat l) k = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            k \\<in> dom (map_of ((a # l) ! i)) \\<and>\n                            i < Suc (length l)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l y.\n       \\<lbrakk>k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n                \\<exists>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and> i < length l;\n        map_of (concat l) k = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            k \\<in> dom (map_of ((a # l) ! i)) \\<and>\n                            i < Suc (length l)", "by (metis Suc_mono domI nth_Cons_Suc)"], ["", "lemma map_of_concat':\n  \"k \\<in> dom (map_of(l!i)) \\<and> i < length l \\<Longrightarrow> k \\<in> dom (map_of(concat l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! i)) \\<and> i < length l \\<Longrightarrow>\n    k \\<in> dom (map_of (concat l))", "apply (induct l arbitrary: i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       k \\<in> dom (map_of ([] ! i)) \\<and> i < length [] \\<Longrightarrow>\n       k \\<in> dom (map_of (concat []))\n 2. \\<And>a l i.\n       \\<lbrakk>\\<And>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and>\n                   i < length l \\<Longrightarrow>\n                   k \\<in> dom (map_of (concat l));\n        k \\<in> dom (map_of ((a # l) ! i)) \\<and>\n        i < length (a # l)\\<rbrakk>\n       \\<Longrightarrow> k \\<in> dom (map_of (concat (a # l)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l i.\n       \\<lbrakk>\\<And>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and>\n                   i < length l \\<Longrightarrow>\n                   k \\<in> dom (map_of (concat l));\n        k \\<in> dom (map_of ((a # l) ! i)) \\<and>\n        i < length (a # l)\\<rbrakk>\n       \\<Longrightarrow> k \\<in> dom (map_of (concat (a # l)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l i y.\n       \\<lbrakk>\\<And>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and>\n                   i < length l \\<Longrightarrow>\n                   k \\<in> dom (map_of (concat l));\n        i < Suc (length l); map_of ((a # l) ! i) k = Some y;\n        map_of (concat l) k = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. map_of a k = Some y", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l i y.\n       \\<lbrakk>\\<And>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and>\n                   i < length l \\<Longrightarrow>\n                   k \\<in> dom (map_of (concat l));\n        i < Suc (length l); map_of ((a # l) ! i) k = Some y;\n        map_of (concat l) k = None; i = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. map_of a k = Some y\n 2. \\<And>a l i y nat.\n       \\<lbrakk>\\<And>i.\n                   k \\<in> dom (map_of (l ! i)) \\<and>\n                   i < length l \\<Longrightarrow>\n                   k \\<in> dom (map_of (concat l));\n        i < Suc (length l); map_of ((a # l) ! i) k = Some y;\n        map_of (concat l) k = None; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. map_of a k = Some y", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_concat''':\n  assumes \"\\<exists>i. k \\<in> dom (map_of(l!i)) \\<and> i < length l\"\n  shows \"k \\<in> dom (map_of(concat l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l))", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>i. k \\<in> dom (map_of (l ! i)) \\<and> i < length l", "obtain i where \"k \\<in> dom (map_of (l ! i)) \\<and> i < length l\""], ["proof (prove)\nusing this:\n  \\<exists>i. k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        k \\<in> dom (map_of (l ! i)) \\<and> i < length l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l))", "from map_of_concat'[OF this]"], ["proof (chain)\npicking this:\n  k \\<in> dom (map_of (concat l))", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<in> dom (map_of (concat l))\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l))", "."], ["proof (state)\nthis:\n  k \\<in> dom (map_of (concat l))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_concat'':\n  \"(k \\<in> dom (map_of(concat l))) \n  \\<longleftrightarrow> (\\<exists>i. k \\<in> dom (map_of(l!i)) \\<and> i < length l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> dom (map_of (concat l))) =\n    (\\<exists>i. k \\<in> dom (map_of (l ! i)) \\<and> i < length l)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    \\<exists>i. k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n 2. \\<exists>i.\n       k \\<in> dom (map_of (l ! i)) \\<and> i < length l \\<Longrightarrow>\n    k \\<in> dom (map_of (concat l))", "using map_of_concat[of k l]"], ["proof (prove)\nusing this:\n  k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n  \\<exists>i. k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n\ngoal (2 subgoals):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    \\<exists>i. k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n 2. \\<exists>i.\n       k \\<in> dom (map_of (l ! i)) \\<and> i < length l \\<Longrightarrow>\n    k \\<in> dom (map_of (concat l))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       k \\<in> dom (map_of (l ! i)) \\<and> i < length l \\<Longrightarrow>\n    k \\<in> dom (map_of (concat l))", "using map_of_concat'[of k l]"], ["proof (prove)\nusing this:\n  k \\<in> dom (map_of (l ! ?i)) \\<and> ?i < length l \\<Longrightarrow>\n  k \\<in> dom (map_of (concat l))\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       k \\<in> dom (map_of (l ! i)) \\<and> i < length l \\<Longrightarrow>\n    k \\<in> dom (map_of (concat l))", "by blast"], ["", "lemma abs_update_length: \"length (abs_update k v l) = length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (abs_update k v l) = length l", "by (simp add: abs_update_def)"], ["", "lemma ls_update_map_of_eq:\n  \"map_of (fst (ls_update k v ls)) k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (fst (ls_update k v ls)) k = Some v", "apply (induct ls rule: ls_update.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k v. map_of (fst (ls_update k v [])) k = Some v\n 2. \\<And>k v l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        map_of (fst (ls_update k v ls)) k = Some v) \\<Longrightarrow>\n       map_of (fst (ls_update k v ((l, w) # ls))) k = Some v", "by (simp_all add: Let_def)"], ["", "lemma ls_update_map_of_neq:\n  \"x \\<noteq> k \\<Longrightarrow> map_of (fst (ls_update k v ls)) x = map_of ls x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> k \\<Longrightarrow>\n    map_of (fst (ls_update k v ls)) x = map_of ls x", "apply (induct ls rule: ls_update.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ka v.\n       ka \\<noteq> k \\<Longrightarrow>\n       map_of (fst (ls_update k v [])) ka = map_of [] ka\n 2. \\<And>ka v l w ls.\n       \\<lbrakk>\\<lbrakk>ka \\<noteq> l; ka \\<noteq> k\\<rbrakk>\n                \\<Longrightarrow> map_of (fst (ls_update k v ls)) ka =\n                                  map_of ls ka;\n        ka \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> map_of (fst (ls_update k v ((l, w) # ls))) ka =\n                         map_of ((l, w) # ls) ka", "by (auto simp add: Let_def)"], ["", "subsection \\<open>Main Definitions and Lemmas\\<close>"], ["", "definition is_hashmap' \n  :: \"('k, 'v) map \n    \\<Rightarrow> ('k \\<times> 'v) list list \n    \\<Rightarrow> ('k::{heap,hashable}, 'v::heap) hashtable\n    \\<Rightarrow> assn\" \n  where\n  \"is_hashmap' m l ht = is_hashtable l ht * \\<up> (map_of (concat l) = m)\""], ["", "definition is_hashmap \n  :: \"('k, 'v) map \\<Rightarrow> ('k::{heap,hashable}, 'v::heap) hashtable \\<Rightarrow> assn\" \n  where\n  \"is_hashmap m ht = (\\<exists>\\<^sub>Al. is_hashmap' m l ht)\""], ["", "lemma is_hashmap'_prec:\n  \"\\<forall>s s'. h\\<Turnstile>(is_hashmap' m l ht * F1) \\<and>\\<^sub>A (is_hashmap' m' l' ht * F2)\n  \\<longrightarrow> l=l' \\<and> m=m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       h \\<Turnstile>\n       is_hashmap' m l ht * F1 \\<and>\\<^sub>A\n       is_hashmap' m' l' ht * F2 \\<longrightarrow>\n       l = l' \\<and> m = m'", "unfolding is_hashmap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       h \\<Turnstile>\n       is_hashtable l ht * \\<up> (map_of (concat l) = m) * F1 \\<and>\\<^sub>A\n       is_hashtable l' ht * \\<up> (map_of (concat l') = m') *\n       F2 \\<longrightarrow>\n       l = l' \\<and> m = m'", "apply (auto simp add: preciseD[OF is_hashtable_prec])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<Turnstile>\n             is_hashtable l ht * F1 \\<and>\\<^sub>A is_hashtable l' ht * F2;\n     m = map_of (concat l); m' = map_of (concat l')\\<rbrakk>\n    \\<Longrightarrow> map_of (concat l) = map_of (concat l')", "apply (subgoal_tac \"l = l'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<Turnstile>\n             is_hashtable l ht * F1 \\<and>\\<^sub>A is_hashtable l' ht * F2;\n     m = map_of (concat l); m' = map_of (concat l'); l = l'\\<rbrakk>\n    \\<Longrightarrow> map_of (concat l) = map_of (concat l')\n 2. \\<lbrakk>h \\<Turnstile>\n             is_hashtable l ht * F1 \\<and>\\<^sub>A is_hashtable l' ht * F2;\n     m = map_of (concat l); m' = map_of (concat l')\\<rbrakk>\n    \\<Longrightarrow> l = l'", "by (auto simp add: preciseD[OF is_hashtable_prec])"], ["", "lemma is_hashmap_prec: \"precise is_hashmap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_hashmap", "unfolding is_hashmap_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (\\<lambda>m ht. \\<exists>\\<^sub>Al. is_hashmap' m l ht)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       (\\<exists>\\<^sub>Al. is_hashmap' a l p) * F \\<and>\\<^sub>A\n       (\\<exists>\\<^sub>Al. is_hashmap' a' l p) * F' \\<Longrightarrow>\n       a = a'", "by (auto simp add: is_hashmap'_prec)"], ["", "abbreviation \"hm_new \\<equiv> ht_new\""], ["", "lemma hm_new_rule': \n  \"<emp> \n  hm_new::('k::{heap,hashable}, 'v::heap) hashtable Heap \n  <is_hashmap' Map.empty (replicate (def_hashmap_size TYPE('k)) [])>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> hm_new\n    <is_hashmap' Map.empty (replicate (def_hashmap_size TYPE('k)) [])>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. <emp> hm_new <?Q>\n 2. \\<And>x.\n       ?Q x \\<Longrightarrow>\\<^sub>A\n       is_hashmap' Map.empty (replicate (def_hashmap_size TYPE('k)) []) x", "using complete_ht_new"], ["proof (prove)\nusing this:\n  <emp> hm_new <is_hashtable (replicate (def_hashmap_size TYPE(?'k)) [])>\n\ngoal (2 subgoals):\n 1. <emp> hm_new <?Q>\n 2. \\<And>x.\n       ?Q x \\<Longrightarrow>\\<^sub>A\n       is_hashmap' Map.empty (replicate (def_hashmap_size TYPE('k)) []) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       is_hashtable (replicate (def_hashmap_size TYPE('k)) [])\n        x \\<Longrightarrow>\\<^sub>A\n       is_hashmap' Map.empty (replicate (def_hashmap_size TYPE('k)) []) x", "apply (simp add: is_hashmap'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_new_rule: \n  \"<emp> hm_new <is_hashmap Map.empty>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> hm_new <is_hashmap Map.empty>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. <emp> hm_new <?Q>\n 2. \\<And>x. ?Q x \\<Longrightarrow>\\<^sub>A is_hashmap Map.empty x", "using complete_ht_new"], ["proof (prove)\nusing this:\n  <emp> hm_new <is_hashtable (replicate (def_hashmap_size TYPE(?'k)) [])>\n\ngoal (2 subgoals):\n 1. <emp> hm_new <?Q>\n 2. \\<And>x. ?Q x \\<Longrightarrow>\\<^sub>A is_hashmap Map.empty x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       is_hashtable (replicate (def_hashmap_size TYPE('a)) [])\n        x \\<Longrightarrow>\\<^sub>A\n       is_hashmap Map.empty x", "apply (simp add: is_hashmap_def is_hashmap'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       is_hashtable (replicate (def_hashmap_size TYPE('a)) [])\n        x \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Al.\n          is_hashtable l x * \\<up> (\\<forall>xs\\<in>set l. xs = [])", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ht_hash_distinct:\n  \"ht_hash l \n  \\<Longrightarrow> \\<forall>i j . i\\<noteq>j \\<and> i < length l \\<and> j < length l \n    \\<longrightarrow> set (l!i) \\<inter> set (l!j) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_hash l \\<Longrightarrow>\n    \\<forall>i j.\n       i \\<noteq> j \\<and>\n       i < length l \\<and> j < length l \\<longrightarrow>\n       set (l ! i) \\<inter> set (l ! j) = {}", "apply (auto simp add: ht_hash_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j a b.\n       \\<lbrakk>\\<forall>i<length l.\n                   \\<forall>x\\<in>set (l ! i).\n                      bounded_hashcode_nat (length l) (fst x) = i;\n        i \\<noteq> j; i < length l; j < length l; (a, b) \\<in> set (l ! i);\n        (a, b) \\<in> set (l ! j)\\<rbrakk>\n       \\<Longrightarrow> False", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ht_hash_in_dom_in_dom_bounded_hashcode_nat:\n  assumes \"ht_hash l\"\n  assumes \"k \\<in> dom (map_of(concat l))\"\n  shows \"k \\<in> dom (map_of(l!bounded_hashcode_nat (length l) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "from map_of_concat[OF assms(2)]"], ["proof (chain)\npicking this:\n  \\<exists>i. k \\<in> dom (map_of (l ! i)) \\<and> i < length l", "obtain i \n    where i: \"k \\<in> dom (map_of (l ! i)) \\<and> i < length l\""], ["proof (prove)\nusing this:\n  \\<exists>i. k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        k \\<in> dom (map_of (l ! i)) \\<and> i < length l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "thm ht_hash_def"], ["proof (state)\nthis:\n  k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "hence \"\\<exists>v. (k,v)\\<in>set(l!i)\""], ["proof (prove)\nusing this:\n  k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n\ngoal (1 subgoal):\n 1. \\<exists>v. (k, v) \\<in> set (l ! i)", "by (auto dest: map_of_SomeD)"], ["proof (state)\nthis:\n  \\<exists>v. (k, v) \\<in> set (l ! i)\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "from this"], ["proof (chain)\npicking this:\n  \\<exists>v. (k, v) \\<in> set (l ! i)", "obtain v where v: \"(k,v)\\<in>set(l!i)\""], ["proof (prove)\nusing this:\n  \\<exists>v. (k, v) \\<in> set (l ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (k, v) \\<in> set (l ! i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (k, v) \\<in> set (l ! i)\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "from assms(1)[unfolded ht_hash_def] i v bounded_hashcode_nat_bounds"], ["proof (chain)\npicking this:\n  \\<forall>i<length l.\n     \\<forall>x\\<in>set (l ! i). bounded_hashcode_nat (length l) (fst x) = i\n  k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n  (k, v) \\<in> set (l ! i)\n  1 < ?n \\<Longrightarrow> bounded_hashcode_nat ?n ?a < ?n", "have \"bounded_hashcode_nat (length l) k = i\""], ["proof (prove)\nusing this:\n  \\<forall>i<length l.\n     \\<forall>x\\<in>set (l ! i). bounded_hashcode_nat (length l) (fst x) = i\n  k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n  (k, v) \\<in> set (l ! i)\n  1 < ?n \\<Longrightarrow> bounded_hashcode_nat ?n ?a < ?n\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length l) k = i", "by (metis fst_conv)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length l) k = i\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "with i"], ["proof (chain)\npicking this:\n  k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n  bounded_hashcode_nat (length l) k = i", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<in> dom (map_of (l ! i)) \\<and> i < length l\n  bounded_hashcode_nat (length l) k = i\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "by simp"], ["proof (state)\nthis:\n  k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ht_hash_in_dom_bounded_hashcode_nat_in_dom:\n  assumes \"ht_hash l\"\n  assumes \"1 < length l\"\n  assumes \"k \\<in> dom (map_of(l!bounded_hashcode_nat (length l) k))\"\n  shows \"k \\<in> dom (map_of(concat l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l))", "using map_of_concat'[of k l \"bounded_hashcode_nat (length l) k\"] \n    assms(2,3) bounded_hashcode_nat_bounds[of \"length l\" k]"], ["proof (prove)\nusing this:\n  k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k)) \\<and>\n  bounded_hashcode_nat (length l) k < length l \\<Longrightarrow>\n  k \\<in> dom (map_of (concat l))\n  1 < length l\n  k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))\n  1 < length l \\<Longrightarrow>\n  bounded_hashcode_nat (length l) k < length l\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l))", "by simp"], ["", "lemma ht_hash_in_dom_in_dom_bounded_hashcode_nat_eq:\n  assumes \"ht_hash l\"\n  assumes \"1 < length l\"\n  shows \"(k \\<in> dom (map_of(concat l))) \n  = (k \\<in> dom (map_of(l!bounded_hashcode_nat (length l) k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> dom (map_of (concat l))) =\n    (k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k)))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))\n 2. k \\<in> dom (map_of\n                  (l ! bounded_hashcode_nat (length l) k)) \\<Longrightarrow>\n    k \\<in> dom (map_of (concat l))", "using ht_hash_in_dom_in_dom_bounded_hashcode_nat[OF assms(1)] \n    ht_hash_in_dom_bounded_hashcode_nat_in_dom[OF assms]"], ["proof (prove)\nusing this:\n  ?k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n  ?k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) ?k))\n  ?k \\<in> dom (map_of\n                 (l ! bounded_hashcode_nat (length l) ?k)) \\<Longrightarrow>\n  ?k \\<in> dom (map_of (concat l))\n\ngoal (2 subgoals):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))\n 2. k \\<in> dom (map_of\n                  (l ! bounded_hashcode_nat (length l) k)) \\<Longrightarrow>\n    k \\<in> dom (map_of (concat l))", "by simp_all"], ["", "lemma ht_hash_in_dom_i_bounded_hashcode_nat_i:\n  assumes \"ht_hash l\"\n  assumes \"1 < length l\"\n  assumes \"i < length l\"\n  assumes \"k \\<in> dom (map_of (l!i))\" \n  shows \"i = bounded_hashcode_nat (length l) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = bounded_hashcode_nat (length l) k", "using assms"], ["proof (prove)\nusing this:\n  ht_hash l\n  1 < length l\n  i < length l\n  k \\<in> dom (map_of (l ! i))\n\ngoal (1 subgoal):\n 1. i = bounded_hashcode_nat (length l) k", "using bounded_hashcode_nat_bounds"], ["proof (prove)\nusing this:\n  ht_hash l\n  1 < length l\n  i < length l\n  k \\<in> dom (map_of (l ! i))\n  1 < ?n \\<Longrightarrow> bounded_hashcode_nat ?n ?a < ?n\n\ngoal (1 subgoal):\n 1. i = bounded_hashcode_nat (length l) k", "by (auto simp add: ht_hash_def ht_distinct_def dom_map_of_conv_image_fst)"], ["", "lemma ht_hash_in_bounded_hashcode_nat_not_i_not_in_dom_i:\n  assumes \"ht_hash l\"\n  assumes \"1 < length l\"\n  assumes \"i < length l\"\n  assumes \"i \\<noteq> bounded_hashcode_nat (length l) k\"\n  shows \"k \\<notin> dom (map_of (l!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of (l ! i))", "using assms"], ["proof (prove)\nusing this:\n  ht_hash l\n  1 < length l\n  i < length l\n  i \\<noteq> bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of (l ! i))", "using bounded_hashcode_nat_bounds"], ["proof (prove)\nusing this:\n  ht_hash l\n  1 < length l\n  i < length l\n  i \\<noteq> bounded_hashcode_nat (length l) k\n  1 < ?n \\<Longrightarrow> bounded_hashcode_nat ?n ?a < ?n\n\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of (l ! i))", "by (auto simp add: ht_hash_def ht_distinct_def dom_map_of_conv_image_fst)"], ["", "lemma ht_hash_ht_distinct_in_dom_unique_value:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  assumes \"k \\<in> dom (map_of (concat l))\"\n  shows \"\\<exists>!v. (k,v) \\<in> set (concat l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!v. (k, v) \\<in> set (concat l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!v. (k, v) \\<in> set (concat l)", "from assms(4)"], ["proof (chain)\npicking this:\n  k \\<in> dom (map_of (concat l))", "have ex: \"\\<exists>v. (k,v) \\<in> set (concat l)\""], ["proof (prove)\nusing this:\n  k \\<in> dom (map_of (concat l))\n\ngoal (1 subgoal):\n 1. \\<exists>v. (k, v) \\<in> set (concat l)", "by (auto dest!: map_of_SomeD)"], ["proof (state)\nthis:\n  \\<exists>v. (k, v) \\<in> set (concat l)\n\ngoal (1 subgoal):\n 1. \\<exists>!v. (k, v) \\<in> set (concat l)", "have \"v = w\" if kv: \"(k,v) \\<in> set (concat l)\" and kw: \"(k,w) \\<in> set (concat l)\" for v w"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "from ht_hash_in_dom_in_dom_bounded_hashcode_nat[OF assms(1,4)]"], ["proof (chain)\npicking this:\n  k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "have a: \"k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))\""], ["proof (prove)\nusing this:\n  k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "."], ["proof (state)\nthis:\n  k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))\n\ngoal (1 subgoal):\n 1. v = w", "have \"k \\<notin> dom(map_of(l!i))\"\n      if \"i < length l\" and \"i \\<noteq> bounded_hashcode_nat (length l) k\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of (l ! i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of (l ! i))", "from ht_hash_in_bounded_hashcode_nat_not_i_not_in_dom_i[OF assms(1,3) that]"], ["proof (chain)\npicking this:\n  k \\<notin> dom (map_of (l ! i))", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<notin> dom (map_of (l ! i))\n\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of (l ! i))", "."], ["proof (state)\nthis:\n  k \\<notin> dom (map_of (l ! i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length l;\n   ?i \\<noteq> bounded_hashcode_nat (length l) k\\<rbrakk>\n  \\<Longrightarrow> k \\<notin> dom (map_of (l ! ?i))\n\ngoal (1 subgoal):\n 1. v = w", "have v: \"(k,v) \\<in> set (l ! bounded_hashcode_nat (length l) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "from kv"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set (concat l)", "have \"\\<exists>i. i < length l \\<and> (k, v) \\<in> set (l!i)\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set (concat l)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length l. (k, v) \\<in> set (l ! i)", "by auto (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>i<length l. (k, v) \\<in> set (l ! i)\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>i<length l. (k, v) \\<in> set (l ! i)", "obtain i where i: \"i < length l \\<and> (k, v) \\<in> set (l!i)\""], ["proof (prove)\nusing this:\n  \\<exists>i<length l. (k, v) \\<in> set (l ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length l \\<and> (k, v) \\<in> set (l ! i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < length l \\<and> (k, v) \\<in> set (l ! i)\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "hence \"k \\<in> dom (map_of (l!i))\""], ["proof (prove)\nusing this:\n  i < length l \\<and> (k, v) \\<in> set (l ! i)\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! i))", "by (metis (no_types) prod.exhaust a assms(1) fst_conv ht_hash_def)"], ["proof (state)\nthis:\n  k \\<in> dom (map_of (l ! i))\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "from i ht_hash_in_dom_i_bounded_hashcode_nat_i[OF assms(1,3) _ this]"], ["proof (chain)\npicking this:\n  i < length l \\<and> (k, v) \\<in> set (l ! i)\n  i < length l \\<Longrightarrow> i = bounded_hashcode_nat (length l) k", "have \"i = bounded_hashcode_nat (length l) k\""], ["proof (prove)\nusing this:\n  i < length l \\<and> (k, v) \\<in> set (l ! i)\n  i < length l \\<Longrightarrow> i = bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. i = bounded_hashcode_nat (length l) k", "by simp"], ["proof (state)\nthis:\n  i = bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "with i"], ["proof (chain)\npicking this:\n  i < length l \\<and> (k, v) \\<in> set (l ! i)\n  i = bounded_hashcode_nat (length l) k", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length l \\<and> (k, v) \\<in> set (l ! i)\n  i = bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "by simp"], ["proof (state)\nthis:\n  (k, v) \\<in> set (l ! bounded_hashcode_nat (length l) k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (k, v) \\<in> set (l ! bounded_hashcode_nat (length l) k)\n\ngoal (1 subgoal):\n 1. v = w", "have w: \"(k,w) \\<in> set (l ! bounded_hashcode_nat (length l) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, w) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (k, w) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "from kw"], ["proof (chain)\npicking this:\n  (k, w) \\<in> set (concat l)", "have \"\\<exists>i. i < length l \\<and> (k, w) \\<in> set (l!i)\""], ["proof (prove)\nusing this:\n  (k, w) \\<in> set (concat l)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length l. (k, w) \\<in> set (l ! i)", "by auto (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>i<length l. (k, w) \\<in> set (l ! i)\n\ngoal (1 subgoal):\n 1. (k, w) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>i<length l. (k, w) \\<in> set (l ! i)", "obtain i where i: \"i < length l \\<and> (k, w) \\<in> set (l!i)\""], ["proof (prove)\nusing this:\n  \\<exists>i<length l. (k, w) \\<in> set (l ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length l \\<and> (k, w) \\<in> set (l ! i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < length l \\<and> (k, w) \\<in> set (l ! i)\n\ngoal (1 subgoal):\n 1. (k, w) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "hence \"k \\<in> dom (map_of (l!i))\""], ["proof (prove)\nusing this:\n  i < length l \\<and> (k, w) \\<in> set (l ! i)\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! i))", "by (metis (no_types) prod.exhaust a assms(1) fst_conv ht_hash_def)"], ["proof (state)\nthis:\n  k \\<in> dom (map_of (l ! i))\n\ngoal (1 subgoal):\n 1. (k, w) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "from i ht_hash_in_dom_i_bounded_hashcode_nat_i[OF assms(1,3) _ this]"], ["proof (chain)\npicking this:\n  i < length l \\<and> (k, w) \\<in> set (l ! i)\n  i < length l \\<Longrightarrow> i = bounded_hashcode_nat (length l) k", "have \"i = bounded_hashcode_nat (length l) k\""], ["proof (prove)\nusing this:\n  i < length l \\<and> (k, w) \\<in> set (l ! i)\n  i < length l \\<Longrightarrow> i = bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. i = bounded_hashcode_nat (length l) k", "by simp"], ["proof (state)\nthis:\n  i = bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. (k, w) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "with i"], ["proof (chain)\npicking this:\n  i < length l \\<and> (k, w) \\<in> set (l ! i)\n  i = bounded_hashcode_nat (length l) k", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length l \\<and> (k, w) \\<in> set (l ! i)\n  i = bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. (k, w) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "by simp"], ["proof (state)\nthis:\n  (k, w) \\<in> set (l ! bounded_hashcode_nat (length l) k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (k, w) \\<in> set (l ! bounded_hashcode_nat (length l) k)\n\ngoal (1 subgoal):\n 1. v = w", "from assms(2,3)"], ["proof (chain)\npicking this:\n  ht_distinct l\n  1 < length l", "have \n      \"distinct (map fst (l ! bounded_hashcode_nat (length l) k))\""], ["proof (prove)\nusing this:\n  ht_distinct l\n  1 < length l\n\ngoal (1 subgoal):\n 1. distinct (map fst (l ! bounded_hashcode_nat (length l) k))", "by (simp add: ht_distinct_def bounded_hashcode_nat_bounds)"], ["proof (state)\nthis:\n  distinct (map fst (l ! bounded_hashcode_nat (length l) k))\n\ngoal (1 subgoal):\n 1. v = w", "from Map.map_of_is_SomeI[OF this v] Map.map_of_is_SomeI[OF this w]"], ["proof (chain)\npicking this:\n  map_of (l ! bounded_hashcode_nat (length l) k) k = Some v\n  map_of (l ! bounded_hashcode_nat (length l) k) k = Some w", "show \"v = w\""], ["proof (prove)\nusing this:\n  map_of (l ! bounded_hashcode_nat (length l) k) k = Some v\n  map_of (l ! bounded_hashcode_nat (length l) k) k = Some w\n\ngoal (1 subgoal):\n 1. v = w", "by simp"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(k, ?v) \\<in> set (concat l);\n   (k, ?w) \\<in> set (concat l)\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n\ngoal (1 subgoal):\n 1. \\<exists>!v. (k, v) \\<in> set (concat l)", "with ex"], ["proof (chain)\npicking this:\n  \\<exists>v. (k, v) \\<in> set (concat l)\n  \\<lbrakk>(k, ?v) \\<in> set (concat l);\n   (k, ?w) \\<in> set (concat l)\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v. (k, v) \\<in> set (concat l)\n  \\<lbrakk>(k, ?v) \\<in> set (concat l);\n   (k, ?w) \\<in> set (concat l)\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n\ngoal (1 subgoal):\n 1. \\<exists>!v. (k, v) \\<in> set (concat l)", "by blast"], ["proof (state)\nthis:\n  \\<exists>!v. (k, v) \\<in> set (concat l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ht_hash_ht_distinct_map_of:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat l) k \n  = map_of(l!bounded_hashcode_nat (length l) k) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "proof (cases \"k \\<in> dom (map_of(concat l))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k\n 2. k \\<notin> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "case False"], ["proof (state)\nthis:\n  k \\<notin> dom (map_of (concat l))\n\ngoal (2 subgoals):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k\n 2. k \\<notin> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "hence a: \"map_of (concat l) k = None\""], ["proof (prove)\nusing this:\n  k \\<notin> dom (map_of (concat l))\n\ngoal (1 subgoal):\n 1. map_of (concat l) k = None", "by auto"], ["proof (state)\nthis:\n  map_of (concat l) k = None\n\ngoal (2 subgoals):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k\n 2. k \\<notin> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "from ht_hash_in_dom_in_dom_bounded_hashcode_nat_eq[OF assms(1,3)] False"], ["proof (chain)\npicking this:\n  (?k \\<in> dom (map_of (concat l))) =\n  (?k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) ?k)))\n  k \\<notin> dom (map_of (concat l))", "have \"k \\<notin> dom (map_of (l ! bounded_hashcode_nat (length l) k))\""], ["proof (prove)\nusing this:\n  (?k \\<in> dom (map_of (concat l))) =\n  (?k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) ?k)))\n  k \\<notin> dom (map_of (concat l))\n\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "by simp"], ["proof (state)\nthis:\n  k \\<notin> dom (map_of (l ! bounded_hashcode_nat (length l) k))\n\ngoal (2 subgoals):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k\n 2. k \\<notin> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "hence \"map_of(l!bounded_hashcode_nat (length l) k) k = None\""], ["proof (prove)\nusing this:\n  k \\<notin> dom (map_of (l ! bounded_hashcode_nat (length l) k))\n\ngoal (1 subgoal):\n 1. map_of (l ! bounded_hashcode_nat (length l) k) k = None", "by auto"], ["proof (state)\nthis:\n  map_of (l ! bounded_hashcode_nat (length l) k) k = None\n\ngoal (2 subgoals):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k\n 2. k \\<notin> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "with a"], ["proof (chain)\npicking this:\n  map_of (concat l) k = None\n  map_of (l ! bounded_hashcode_nat (length l) k) k = None", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (concat l) k = None\n  map_of (l ! bounded_hashcode_nat (length l) k) k = None\n\ngoal (1 subgoal):\n 1. map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "by simp"], ["proof (state)\nthis:\n  map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "case True"], ["proof (state)\nthis:\n  k \\<in> dom (map_of (concat l))\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "from True"], ["proof (chain)\npicking this:\n  k \\<in> dom (map_of (concat l))", "obtain y where y: \"map_of (concat l) k = Some y\""], ["proof (prove)\nusing this:\n  k \\<in> dom (map_of (concat l))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        map_of (concat l) k = Some y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  map_of (concat l) k = Some y\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "hence a: \"(k,y) \\<in> set (concat l)\""], ["proof (prove)\nusing this:\n  map_of (concat l) k = Some y\n\ngoal (1 subgoal):\n 1. (k, y) \\<in> set (concat l)", "by (metis map_of_SomeD)"], ["proof (state)\nthis:\n  (k, y) \\<in> set (concat l)\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "from ht_hash_in_dom_in_dom_bounded_hashcode_nat_eq[OF assms(1,3)] True"], ["proof (chain)\npicking this:\n  (?k \\<in> dom (map_of (concat l))) =\n  (?k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) ?k)))\n  k \\<in> dom (map_of (concat l))", "have \"k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))\""], ["proof (prove)\nusing this:\n  (?k \\<in> dom (map_of (concat l))) =\n  (?k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) ?k)))\n  k \\<in> dom (map_of (concat l))\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "by simp"], ["proof (state)\nthis:\n  k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "from this"], ["proof (chain)\npicking this:\n  k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))", "obtain z where \n    z: \"map_of(l!bounded_hashcode_nat (length l) k) k = Some z\""], ["proof (prove)\nusing this:\n  k \\<in> dom (map_of (l ! bounded_hashcode_nat (length l) k))\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        map_of (l ! bounded_hashcode_nat (length l) k) k =\n        Some z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  map_of (l ! bounded_hashcode_nat (length l) k) k = Some z\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "hence \"(k,z) \\<in> set (l ! bounded_hashcode_nat (length l) k)\""], ["proof (prove)\nusing this:\n  map_of (l ! bounded_hashcode_nat (length l) k) k = Some z\n\ngoal (1 subgoal):\n 1. (k, z) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "by (metis map_of_SomeD)"], ["proof (state)\nthis:\n  (k, z) \\<in> set (l ! bounded_hashcode_nat (length l) k)\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "with bounded_hashcode_nat_bounds[OF assms(3), of k]"], ["proof (chain)\npicking this:\n  bounded_hashcode_nat (length l) k < length l\n  (k, z) \\<in> set (l ! bounded_hashcode_nat (length l) k)", "have b: \"(k,z) \\<in> set (concat l)\""], ["proof (prove)\nusing this:\n  bounded_hashcode_nat (length l) k < length l\n  (k, z) \\<in> set (l ! bounded_hashcode_nat (length l) k)\n\ngoal (1 subgoal):\n 1. (k, z) \\<in> set (concat l)", "by auto"], ["proof (state)\nthis:\n  (k, z) \\<in> set (concat l)\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "from ht_hash_ht_distinct_in_dom_unique_value[OF assms True] a b"], ["proof (chain)\npicking this:\n  \\<exists>!v. (k, v) \\<in> set (concat l)\n  (k, y) \\<in> set (concat l)\n  (k, z) \\<in> set (concat l)", "have \"y = z\""], ["proof (prove)\nusing this:\n  \\<exists>!v. (k, v) \\<in> set (concat l)\n  (k, y) \\<in> set (concat l)\n  (k, z) \\<in> set (concat l)\n\ngoal (1 subgoal):\n 1. y = z", "by auto"], ["proof (state)\nthis:\n  y = z\n\ngoal (1 subgoal):\n 1. k \\<in> dom (map_of (concat l)) \\<Longrightarrow>\n    map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "with y z"], ["proof (chain)\npicking this:\n  map_of (concat l) k = Some y\n  map_of (l ! bounded_hashcode_nat (length l) k) k = Some z\n  y = z", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (concat l) k = Some y\n  map_of (l ! bounded_hashcode_nat (length l) k) k = Some z\n  y = z\n\ngoal (1 subgoal):\n 1. map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k", "by simp"], ["proof (state)\nthis:\n  map_of (concat l) k = map_of (l ! bounded_hashcode_nat (length l) k) k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ls_lookup_map_of_pre:\n  \"distinct (map fst l) \\<Longrightarrow> ls_lookup k l = map_of l k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow> ls_lookup k l = map_of l k", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow> ls_lookup k [] = map_of [] k\n 2. \\<And>a l.\n       \\<lbrakk>distinct (map fst l) \\<Longrightarrow>\n                ls_lookup k l = map_of l k;\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> ls_lookup k (a # l) = map_of (a # l) k", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>distinct (map fst l) \\<Longrightarrow>\n                ls_lookup k l = map_of l k;\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> ls_lookup k (a # l) = map_of (a # l) k", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l aa b.\n       \\<lbrakk>distinct (map fst l) \\<Longrightarrow>\n                ls_lookup k l = map_of l k;\n        distinct (map fst (a # l)); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> ls_lookup k (a # l) = map_of (a # l) k", "by simp"], ["", "lemma ls_lookup_map_of:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\" \n  assumes \"1 < length l\" \n  shows \"ls_lookup k (l ! bounded_hashcode_nat (length l) k) \n  = map_of (concat l) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls_lookup k (l ! bounded_hashcode_nat (length l) k) =\n    map_of (concat l) k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ls_lookup k (l ! bounded_hashcode_nat (length l) k) =\n    map_of (concat l) k", "from assms(2,3)"], ["proof (chain)\npicking this:\n  ht_distinct l\n  1 < length l", "have \"distinct (map fst (l ! bounded_hashcode_nat (length l) k))\""], ["proof (prove)\nusing this:\n  ht_distinct l\n  1 < length l\n\ngoal (1 subgoal):\n 1. distinct (map fst (l ! bounded_hashcode_nat (length l) k))", "by (simp add: ht_distinct_def bounded_hashcode_nat_bounds)"], ["proof (state)\nthis:\n  distinct (map fst (l ! bounded_hashcode_nat (length l) k))\n\ngoal (1 subgoal):\n 1. ls_lookup k (l ! bounded_hashcode_nat (length l) k) =\n    map_of (concat l) k", "from ls_lookup_map_of_pre[OF this]"], ["proof (chain)\npicking this:\n  ls_lookup ?k (l ! bounded_hashcode_nat (length l) k) =\n  map_of (l ! bounded_hashcode_nat (length l) k) ?k", "have \"ls_lookup k (l ! bounded_hashcode_nat (length l) k) \n    = map_of (l ! bounded_hashcode_nat (length l) k) k\""], ["proof (prove)\nusing this:\n  ls_lookup ?k (l ! bounded_hashcode_nat (length l) k) =\n  map_of (l ! bounded_hashcode_nat (length l) k) ?k\n\ngoal (1 subgoal):\n 1. ls_lookup k (l ! bounded_hashcode_nat (length l) k) =\n    map_of (l ! bounded_hashcode_nat (length l) k) k", "."], ["proof (state)\nthis:\n  ls_lookup k (l ! bounded_hashcode_nat (length l) k) =\n  map_of (l ! bounded_hashcode_nat (length l) k) k\n\ngoal (1 subgoal):\n 1. ls_lookup k (l ! bounded_hashcode_nat (length l) k) =\n    map_of (concat l) k", "also"], ["proof (state)\nthis:\n  ls_lookup k (l ! bounded_hashcode_nat (length l) k) =\n  map_of (l ! bounded_hashcode_nat (length l) k) k\n\ngoal (1 subgoal):\n 1. ls_lookup k (l ! bounded_hashcode_nat (length l) k) =\n    map_of (concat l) k", "from ht_hash_ht_distinct_map_of[OF assms]"], ["proof (chain)\npicking this:\n  map_of (concat l) ?k = map_of (l ! bounded_hashcode_nat (length l) ?k) ?k", "have \"map_of (l ! bounded_hashcode_nat (length l) k) k \n    = map_of (concat l) k\""], ["proof (prove)\nusing this:\n  map_of (concat l) ?k = map_of (l ! bounded_hashcode_nat (length l) ?k) ?k\n\ngoal (1 subgoal):\n 1. map_of (l ! bounded_hashcode_nat (length l) k) k = map_of (concat l) k", "by simp"], ["proof (state)\nthis:\n  map_of (l ! bounded_hashcode_nat (length l) k) k = map_of (concat l) k\n\ngoal (1 subgoal):\n 1. ls_lookup k (l ! bounded_hashcode_nat (length l) k) =\n    map_of (concat l) k", "finally"], ["proof (chain)\npicking this:\n  ls_lookup k (l ! bounded_hashcode_nat (length l) k) = map_of (concat l) k", "show ?thesis"], ["proof (prove)\nusing this:\n  ls_lookup k (l ! bounded_hashcode_nat (length l) k) = map_of (concat l) k\n\ngoal (1 subgoal):\n 1. ls_lookup k (l ! bounded_hashcode_nat (length l) k) =\n    map_of (concat l) k", "."], ["proof (state)\nthis:\n  ls_lookup k (l ! bounded_hashcode_nat (length l) k) = map_of (concat l) k\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"hm_lookup \\<equiv> ht_lookup\""], ["", "lemma hm_lookup_rule':\n  \"<is_hashmap' m l ht> hm_lookup k ht \n    <\\<lambda>r. is_hashmap' m l ht * \n      \\<up>(r = m k)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap' m l ht> hm_lookup k ht\n    <\\<lambda>r. is_hashmap' m l ht * \\<up> (r = m k)>", "unfolding is_hashmap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht * \\<up> (map_of (concat l) = m)> hm_lookup k ht\n    <\\<lambda>r.\n        is_hashtable l ht * \\<up> (map_of (concat l) = m) * \\<up> (r = m k)>", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. m = map_of (concat l) \\<Longrightarrow>\n    <is_hashtable l ht> hm_lookup k ht\n    <\\<lambda>r. is_hashtable l ht * \\<up> (r = map_of (concat l) k)>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = map_of (concat l) \\<Longrightarrow>\n    <is_hashtable l ht> hm_lookup k ht <?Q7>\n 2. \\<And>x.\n       m = map_of (concat l) \\<Longrightarrow>\n       ?Q7 x \\<Longrightarrow>\\<^sub>A\n       is_hashtable l ht * \\<up> (x = map_of (concat l) k)", "using complete_ht_lookup[of l ht k]"], ["proof (prove)\nusing this:\n  <is_hashtable l ht> hm_lookup k ht\n  <\\<lambda>r.\n      is_hashtable l ht *\n      \\<up> (r = ls_lookup k (l ! bounded_hashcode_nat (length l) k))>\n\ngoal (2 subgoals):\n 1. m = map_of (concat l) \\<Longrightarrow>\n    <is_hashtable l ht> hm_lookup k ht <?Q7>\n 2. \\<And>x.\n       m = map_of (concat l) \\<Longrightarrow>\n       ?Q7 x \\<Longrightarrow>\\<^sub>A\n       is_hashtable l ht * \\<up> (x = map_of (concat l) k)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = map_of (concat l) \\<Longrightarrow>\n       is_hashtable l ht *\n       \\<up>\n        (x =\n         ls_lookup k\n          (l ! bounded_hashcode_nat (length l) k)) \\<Longrightarrow>\\<^sub>A\n       is_hashtable l ht * \\<up> (x = map_of (concat l) k)", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>m = map_of (concat l);\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> ls_lookup k\n                          (l ! bounded_hashcode_nat (length l) k) =\n                         map_of (concat l) k", "by (simp add: ls_lookup_map_of is_hashtable_def)"], ["", "lemma hm_lookup_rule:\n  \"<is_hashmap m ht> hm_lookup k ht \n    <\\<lambda>r. is_hashmap m ht * \n      \\<up>(r = m k)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap m ht> hm_lookup k ht\n    <\\<lambda>r. is_hashmap m ht * \\<up> (r = m k)>", "unfolding is_hashmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al. is_hashmap' m l ht> hm_lookup k ht\n    <\\<lambda>r. (\\<exists>\\<^sub>Al. is_hashmap' m l ht) * \\<up> (r = m k)>", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       <is_hashmap' m l ht> hm_lookup k ht\n       <\\<lambda>r.\n           \\<exists>\\<^sub>Al. is_hashmap' m l ht * \\<up> (r = m k)>", "apply (rule cons_post_rule[OF hm_lookup_rule'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x.\n       is_hashmap' m l ht * \\<up> (x = m k) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Al. is_hashmap' m l ht * \\<up> (x = m k)", "by sep_auto"], ["", "lemma abs_update_map_of'':\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (abs_update k v l)) k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) k = Some v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) k = Some v", "from ht_hash_ht_distinct_map_of[\n    OF ht_hash_update[OF assms(1)] \n       ht_distinct_update[OF assms(2)] \n       length_update[OF assms(3)], \n    of k v k]"], ["proof (chain)\npicking this:\n  map_of (concat (abs_update k v l)) k =\n  map_of\n   (abs_update k v l ! bounded_hashcode_nat (length (abs_update k v l)) k) k", "have \"map_of (concat (abs_update k v l)) k \n    = map_of ((abs_update k v l) ! bounded_hashcode_nat (length l) k) k\""], ["proof (prove)\nusing this:\n  map_of (concat (abs_update k v l)) k =\n  map_of\n   (abs_update k v l ! bounded_hashcode_nat (length (abs_update k v l)) k) k\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) k =\n    map_of (abs_update k v l ! bounded_hashcode_nat (length l) k) k", "by (simp add: abs_update_length)"], ["proof (state)\nthis:\n  map_of (concat (abs_update k v l)) k =\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) k) k\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) k = Some v", "also"], ["proof (state)\nthis:\n  map_of (concat (abs_update k v l)) k =\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) k) k\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) k = Some v", "have \n    \"\\<dots> = map_of (fst (ls_update k v \n                        (l ! bounded_hashcode_nat (length l) k))) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (abs_update k v l ! bounded_hashcode_nat (length l) k) k =\n    map_of (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))) k", "by (simp add: abs_update_def bounded_hashcode_nat_bounds[OF assms(3)])"], ["proof (state)\nthis:\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) k) k =\n  map_of (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))) k\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) k = Some v", "also"], ["proof (state)\nthis:\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) k) k =\n  map_of (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))) k\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) k = Some v", "have \"... = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))) k =\n    Some v", "by (simp add: ls_update_map_of_eq)"], ["proof (state)\nthis:\n  map_of (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))) k =\n  Some v\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) k = Some v", "finally"], ["proof (chain)\npicking this:\n  map_of (concat (abs_update k v l)) k = Some v", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (concat (abs_update k v l)) k = Some v\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) k = Some v", "."], ["proof (state)\nthis:\n  map_of (concat (abs_update k v l)) k = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_update_map_of_hceq:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  assumes \"x \\<noteq> k\"\n  assumes \"bounded_hashcode_nat (length l) x \n    = bounded_hashcode_nat (length l) k\"\n  shows \"map_of (concat (abs_update k v l)) x = map_of (concat l) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "from ht_hash_ht_distinct_map_of[\n    OF ht_hash_update[OF assms(1)] \n       ht_distinct_update[OF assms(2)] \n       length_update[OF assms(3)], \n    of k v x]"], ["proof (chain)\npicking this:\n  map_of (concat (abs_update k v l)) x =\n  map_of\n   (abs_update k v l ! bounded_hashcode_nat (length (abs_update k v l)) x) x", "have \"map_of (concat (abs_update k v l)) x \n    = map_of ((abs_update k v l) ! bounded_hashcode_nat (length l) x) x\""], ["proof (prove)\nusing this:\n  map_of (concat (abs_update k v l)) x =\n  map_of\n   (abs_update k v l ! bounded_hashcode_nat (length (abs_update k v l)) x) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x =\n    map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x", "by (simp add: abs_update_length)"], ["proof (state)\nthis:\n  map_of (concat (abs_update k v l)) x =\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "also"], ["proof (state)\nthis:\n  map_of (concat (abs_update k v l)) x =\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "from assms(5)"], ["proof (chain)\npicking this:\n  bounded_hashcode_nat (length l) x = bounded_hashcode_nat (length l) k", "have \n    \"\\<dots> = map_of (fst (ls_update k v \n                        (l ! bounded_hashcode_nat (length l) k))) x\""], ["proof (prove)\nusing this:\n  bounded_hashcode_nat (length l) x = bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x =\n    map_of (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))) x", "by (simp add: abs_update_def bounded_hashcode_nat_bounds[OF assms(3)])"], ["proof (state)\nthis:\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x =\n  map_of (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "also"], ["proof (state)\nthis:\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x =\n  map_of (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "have \n    \"\\<dots> = map_of (l ! bounded_hashcode_nat (length l) x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))) x =\n    map_of (l ! bounded_hashcode_nat (length l) x) x", "by (simp add: ls_update_map_of_neq[OF assms(4)] assms(5))"], ["proof (state)\nthis:\n  map_of (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))) x =\n  map_of (l ! bounded_hashcode_nat (length l) x) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "also"], ["proof (state)\nthis:\n  map_of (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))) x =\n  map_of (l ! bounded_hashcode_nat (length l) x) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "from ht_hash_ht_distinct_map_of[OF assms(1-3)]"], ["proof (chain)\npicking this:\n  map_of (concat l) ?k = map_of (l ! bounded_hashcode_nat (length l) ?k) ?k", "have \n    \"\\<dots> = map_of (concat l) x\""], ["proof (prove)\nusing this:\n  map_of (concat l) ?k = map_of (l ! bounded_hashcode_nat (length l) ?k) ?k\n\ngoal (1 subgoal):\n 1. map_of (l ! bounded_hashcode_nat (length l) x) x = map_of (concat l) x", "by simp"], ["proof (state)\nthis:\n  map_of (l ! bounded_hashcode_nat (length l) x) x = map_of (concat l) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "finally"], ["proof (chain)\npicking this:\n  map_of (concat (abs_update k v l)) x = map_of (concat l) x", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (concat (abs_update k v l)) x = map_of (concat l) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "."], ["proof (state)\nthis:\n  map_of (concat (abs_update k v l)) x = map_of (concat l) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_update_map_of_hcneq:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  assumes \"x \\<noteq> k\"\n  assumes \"bounded_hashcode_nat (length l) x \n    \\<noteq> bounded_hashcode_nat (length l) k\"\n  shows \"map_of (concat (abs_update k v l)) x = map_of (concat l) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "from ht_hash_ht_distinct_map_of[\n    OF ht_hash_update[OF assms(1)] \n        ht_distinct_update[OF assms(2)] \n        length_update[OF assms(3)], \n    of k v x]"], ["proof (chain)\npicking this:\n  map_of (concat (abs_update k v l)) x =\n  map_of\n   (abs_update k v l ! bounded_hashcode_nat (length (abs_update k v l)) x) x", "have \"map_of (concat (abs_update k v l)) x \n    = map_of ((abs_update k v l) ! bounded_hashcode_nat (length l) x) x\""], ["proof (prove)\nusing this:\n  map_of (concat (abs_update k v l)) x =\n  map_of\n   (abs_update k v l ! bounded_hashcode_nat (length (abs_update k v l)) x) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x =\n    map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x", "by (simp add: abs_update_length)"], ["proof (state)\nthis:\n  map_of (concat (abs_update k v l)) x =\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "also"], ["proof (state)\nthis:\n  map_of (concat (abs_update k v l)) x =\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "from assms(5)"], ["proof (chain)\npicking this:\n  bounded_hashcode_nat (length l) x \\<noteq>\n  bounded_hashcode_nat (length l) k", "have \"\\<dots> = map_of (l ! bounded_hashcode_nat (length l) x) x\""], ["proof (prove)\nusing this:\n  bounded_hashcode_nat (length l) x \\<noteq>\n  bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x =\n    map_of (l ! bounded_hashcode_nat (length l) x) x", "by (simp add: abs_update_def bounded_hashcode_nat_bounds[OF assms(3)])"], ["proof (state)\nthis:\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x =\n  map_of (l ! bounded_hashcode_nat (length l) x) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "also"], ["proof (state)\nthis:\n  map_of (abs_update k v l ! bounded_hashcode_nat (length l) x) x =\n  map_of (l ! bounded_hashcode_nat (length l) x) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "from ht_hash_ht_distinct_map_of[OF assms(1-3)]"], ["proof (chain)\npicking this:\n  map_of (concat l) ?k = map_of (l ! bounded_hashcode_nat (length l) ?k) ?k", "have \"\\<dots> = map_of (concat l) x\""], ["proof (prove)\nusing this:\n  map_of (concat l) ?k = map_of (l ! bounded_hashcode_nat (length l) ?k) ?k\n\ngoal (1 subgoal):\n 1. map_of (l ! bounded_hashcode_nat (length l) x) x = map_of (concat l) x", "by simp"], ["proof (state)\nthis:\n  map_of (l ! bounded_hashcode_nat (length l) x) x = map_of (concat l) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "finally"], ["proof (chain)\npicking this:\n  map_of (concat (abs_update k v l)) x = map_of (concat l) x", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (concat (abs_update k v l)) x = map_of (concat l) x\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "."], ["proof (state)\nthis:\n  map_of (concat (abs_update k v l)) x = map_of (concat l) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_update_map_of''':\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  assumes \"x \\<noteq> k\"\n  shows \"map_of (concat (abs_update k v l)) x = map_of (concat l) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x = map_of (concat l) x", "apply (cases \n    \"bounded_hashcode_nat (length l) x = bounded_hashcode_nat (length l) k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. bounded_hashcode_nat (length l) x =\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of (concat (abs_update k v l)) x = map_of (concat l) x\n 2. bounded_hashcode_nat (length l) x \\<noteq>\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of (concat (abs_update k v l)) x = map_of (concat l) x", "by (auto simp add: abs_update_map_of_hceq[OF assms] \n    abs_update_map_of_hcneq[OF assms])"], ["", "lemma abs_update_map_of':  \n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (abs_update k v l)) x \n    = (map_of (concat l)(k \\<mapsto> v)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) x =\n    (map_of (concat l)(k \\<mapsto> v)) x", "apply (cases \"x = k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = k \\<Longrightarrow>\n    map_of (concat (abs_update k v l)) x =\n    (map_of (concat l)(k \\<mapsto> v)) x\n 2. x \\<noteq> k \\<Longrightarrow>\n    map_of (concat (abs_update k v l)) x =\n    (map_of (concat l)(k \\<mapsto> v)) x", "apply (simp add: abs_update_map_of''[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> k \\<Longrightarrow>\n    map_of (concat (abs_update k v l)) x =\n    (map_of (concat l)(k \\<mapsto> v)) x", "by (simp add: abs_update_map_of'''[OF assms])"], ["", "lemma abs_update_map_of:  \n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (abs_update k v l)) \n    = map_of (concat l)(k \\<mapsto> v) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v l)) = map_of (concat l)(k \\<mapsto> v)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_of (concat (abs_update k v l)) x =\n       (map_of (concat l)(k \\<mapsto> v)) x", "by (simp add: abs_update_map_of'[OF assms])"], ["", "lemma ls_insls_map_of:\n  assumes \"ht_hash ld\"\n  assumes \"ht_distinct ld\"\n  assumes \"1 < length ld\"\n  assumes \"distinct (map fst xs)\"\n  shows \"map_of (concat (ls_insls xs ld)) = map_of (concat ld) ++ map_of xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (ls_insls xs ld)) = map_of (concat ld) ++ map_of xs", "using assms"], ["proof (prove)\nusing this:\n  ht_hash ld\n  ht_distinct ld\n  1 < length ld\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. map_of (concat (ls_insls xs ld)) = map_of (concat ld) ++ map_of xs", "apply (induct xs arbitrary: ld)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ld.\n       \\<lbrakk>ht_hash ld; ht_distinct ld; 1 < length ld;\n        distinct (map fst [])\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (ls_insls [] ld)) =\n                         map_of (concat ld) ++ map_of []\n 2. \\<And>a xs ld.\n       \\<lbrakk>\\<And>ld.\n                   \\<lbrakk>ht_hash ld; ht_distinct ld; 1 < length ld;\n                    distinct (map fst xs)\\<rbrakk>\n                   \\<Longrightarrow> map_of (concat (ls_insls xs ld)) =\n                                     map_of (concat ld) ++ map_of xs;\n        ht_hash ld; ht_distinct ld; 1 < length ld;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (ls_insls (a # xs) ld)) =\n                         map_of (concat ld) ++ map_of (a # xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ld.\n       \\<lbrakk>\\<And>ld.\n                   \\<lbrakk>ht_hash ld; ht_distinct ld; 1 < length ld;\n                    distinct (map fst xs)\\<rbrakk>\n                   \\<Longrightarrow> map_of (concat (ls_insls xs ld)) =\n                                     map_of (concat ld) ++ map_of xs;\n        ht_hash ld; ht_distinct ld; 1 < length ld;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (ls_insls (a # xs) ld)) =\n                         map_of (concat ld) ++ map_of (a # xs)", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ld aa b.\n       \\<lbrakk>\\<And>ld.\n                   \\<lbrakk>ht_hash ld; ht_distinct ld; 1 < length ld;\n                    distinct (map fst xs)\\<rbrakk>\n                   \\<Longrightarrow> map_of (concat (ls_insls xs ld)) =\n                                     map_of (concat ld) ++ map_of xs;\n        ht_hash ld; ht_distinct ld; 1 < length ld;\n        distinct (map fst (a # xs)); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (ls_insls (a # xs) ld)) =\n                         map_of (concat ld) ++ map_of (a # xs)", "apply (simp only: ls_insls.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ld aa b.\n       \\<lbrakk>\\<And>ld.\n                   \\<lbrakk>ht_hash ld; ht_distinct ld; 1 < length ld;\n                    distinct (map fst xs)\\<rbrakk>\n                   \\<Longrightarrow> map_of (concat (ls_insls xs ld)) =\n                                     map_of (concat ld) ++ map_of xs;\n        ht_hash ld; ht_distinct ld; 1 < length ld;\n        distinct (map fst ((aa, b) # xs)); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (concat (ls_insls xs (abs_update aa b ld))) =\n                         map_of (concat ld) ++ map_of ((aa, b) # xs)", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (ls_insls xs_ (abs_update aa_ b_ ld_))) =\n    map_of (concat ld_) ++ map_of ((aa_, b_) # xs_)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (concat (ls_insls xs_ (abs_update aa_ b_ ld_))) =\n    map_of (concat ld_) ++ map_of ((aa_, b_) # xs_)", "from prems(5) prems(1)[OF ht_hash_update[OF prems(2)] \n      ht_distinct_update[OF prems(3)] \n      length_update[OF prems(4)]] \n      abs_update_map_of[OF prems(2-4)]"], ["proof (chain)\npicking this:\n  distinct (map fst ((aa_, b_) # xs_))\n  distinct (map fst xs_) \\<Longrightarrow>\n  map_of (concat (ls_insls xs_ (abs_update ?k1 ?v1 ld_))) =\n  map_of (concat (abs_update ?k1 ?v1 ld_)) ++ map_of xs_\n  map_of (concat (abs_update ?k ?v ld_)) = map_of (concat ld_)(?k \\<mapsto>\n  ?v)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (map fst ((aa_, b_) # xs_))\n  distinct (map fst xs_) \\<Longrightarrow>\n  map_of (concat (ls_insls xs_ (abs_update ?k1 ?v1 ld_))) =\n  map_of (concat (abs_update ?k1 ?v1 ld_)) ++ map_of xs_\n  map_of (concat (abs_update ?k ?v ld_)) = map_of (concat ld_)(?k \\<mapsto>\n  ?v)\n\ngoal (1 subgoal):\n 1. map_of (concat (ls_insls xs_ (abs_update aa_ b_ ld_))) =\n    map_of (concat ld_) ++ map_of ((aa_, b_) # xs_)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aa_ \\<notin> fst ` set xs_ \\<and> distinct (map fst xs_);\n     \\<And>k v.\n        map_of (concat (ls_insls xs_ (abs_update k v ld_))) =\n        map_of (concat ld_)(k \\<mapsto> v) ++ map_of xs_;\n     \\<And>k v.\n        map_of (concat (abs_update k v ld_)) = map_of (concat ld_)(k \n        \\<mapsto> v)\\<rbrakk>\n    \\<Longrightarrow> map_of (concat ld_)(aa_ \\<mapsto> b_) ++ map_of xs_ =\n                      (map_of (concat ld_) ++ map_of xs_)(aa_ \\<mapsto> b_)", "apply (rule map_add_upd_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aa_ \\<notin> fst ` set xs_ \\<and> distinct (map fst xs_);\n     \\<And>k v.\n        map_of (concat (ls_insls xs_ (abs_update k v ld_))) =\n        map_of (concat ld_)(k \\<mapsto> v) ++ map_of xs_;\n     \\<And>k v.\n        map_of (concat (abs_update k v ld_)) = map_of (concat ld_)(k \n        \\<mapsto> v)\\<rbrakk>\n    \\<Longrightarrow> aa_ \\<notin> dom (map_of xs_)", "apply (metis dom_map_of_conv_image_fst)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_of (concat (ls_insls xs_ (abs_update aa_ b_ ld_))) =\n  map_of (concat ld_) ++ map_of ((aa_, b_) # xs_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ls_insls_map_of':\n  assumes \"ht_hash ls\"\n  assumes \"ht_distinct ls\"\n  assumes \"ht_hash ld\"\n  assumes \"ht_distinct ld\"\n  assumes \"1 < length ld\"\n  assumes \"n < length ls\"\n  shows \"map_of (concat (ls_insls (ls ! n) ld)) \n      ++ map_of (concat (take n ls))\n    = map_of (concat ld) ++ map_of (concat (take (Suc n) ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (ls_insls (ls ! n) ld)) ++ map_of (concat (take n ls)) =\n    map_of (concat ld) ++ map_of (concat (take (Suc n) ls))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (concat (ls_insls (ls ! n) ld)) ++ map_of (concat (take n ls)) =\n    map_of (concat ld) ++ map_of (concat (take (Suc n) ls))", "from assms(2,6)"], ["proof (chain)\npicking this:\n  ht_distinct ls\n  n < length ls", "have \"distinct (map fst (ls ! n))\""], ["proof (prove)\nusing this:\n  ht_distinct ls\n  n < length ls\n\ngoal (1 subgoal):\n 1. distinct (map fst (ls ! n))", "by (simp add: ht_distinct_def)"], ["proof (state)\nthis:\n  distinct (map fst (ls ! n))\n\ngoal (1 subgoal):\n 1. map_of (concat (ls_insls (ls ! n) ld)) ++ map_of (concat (take n ls)) =\n    map_of (concat ld) ++ map_of (concat (take (Suc n) ls))", "from ls_insls_map_of[OF assms(3-5) this] assms(6)"], ["proof (chain)\npicking this:\n  map_of (concat (ls_insls (ls ! n) ld)) =\n  map_of (concat ld) ++ map_of (ls ! n)\n  n < length ls", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (concat (ls_insls (ls ! n) ld)) =\n  map_of (concat ld) ++ map_of (ls ! n)\n  n < length ls\n\ngoal (1 subgoal):\n 1. map_of (concat (ls_insls (ls ! n) ld)) ++ map_of (concat (take n ls)) =\n    map_of (concat ld) ++ map_of (concat (take (Suc n) ls))", "by (simp add: List.take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  map_of (concat (ls_insls (ls ! n) ld)) ++ map_of (concat (take n ls)) =\n  map_of (concat ld) ++ map_of (concat (take (Suc n) ls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ls_copy_map_of:\n  assumes \"ht_hash ls\"\n  assumes \"ht_distinct ls\"\n  assumes \"ht_hash ld\"\n  assumes \"ht_distinct ld\"\n  assumes \"1 < length ld\"\n  assumes \"n \\<le> length ls\"\n  shows \"map_of (concat (ls_copy n ls ld)) = map_of (concat ld) ++ map_of (concat (take n ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (ls_copy n ls ld)) =\n    map_of (concat ld) ++ map_of (concat (take n ls))", "using assms"], ["proof (prove)\nusing this:\n  ht_hash ls\n  ht_distinct ls\n  ht_hash ld\n  ht_distinct ld\n  1 < length ld\n  n \\<le> length ls\n\ngoal (1 subgoal):\n 1. map_of (concat (ls_copy n ls ld)) =\n    map_of (concat ld) ++ map_of (concat (take n ls))", "apply (induct n arbitrary: ld)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ld.\n       \\<lbrakk>ht_hash ls; ht_distinct ls; ht_hash ld; ht_distinct ld;\n        1 < length ld; 0 \\<le> length ls\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (ls_copy 0 ls ld)) =\n                         map_of (concat ld) ++ map_of (concat (take 0 ls))\n 2. \\<And>n ld.\n       \\<lbrakk>\\<And>ld.\n                   \\<lbrakk>ht_hash ls; ht_distinct ls; ht_hash ld;\n                    ht_distinct ld; 1 < length ld;\n                    n \\<le> length ls\\<rbrakk>\n                   \\<Longrightarrow> map_of (concat (ls_copy n ls ld)) =\n                                     map_of (concat ld) ++\n                                     map_of (concat (take n ls));\n        ht_hash ls; ht_distinct ls; ht_hash ld; ht_distinct ld;\n        1 < length ld; Suc n \\<le> length ls\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (ls_copy (Suc n) ls ld)) =\n                         map_of (concat ld) ++\n                         map_of (concat (take (Suc n) ls))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n ld.\n       \\<lbrakk>\\<And>ld.\n                   \\<lbrakk>ht_hash ls; ht_distinct ls; ht_hash ld;\n                    ht_distinct ld; 1 < length ld;\n                    n \\<le> length ls\\<rbrakk>\n                   \\<Longrightarrow> map_of (concat (ls_copy n ls ld)) =\n                                     map_of (concat ld) ++\n                                     map_of (concat (take n ls));\n        ht_hash ls; ht_distinct ls; ht_hash ld; ht_distinct ld;\n        1 < length ld; Suc n \\<le> length ls\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (ls_copy (Suc n) ls ld)) =\n                         map_of (concat ld) ++\n                         map_of (concat (take (Suc n) ls))", "subgoal premises prems for n ld"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (ls_copy (Suc n) ls ld)) =\n    map_of (concat ld) ++ map_of (concat (take (Suc n) ls))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (concat (ls_copy (Suc n) ls ld)) =\n    map_of (concat ld) ++ map_of (concat (take (Suc n) ls))", "note a = ht_hash_ls_insls[OF prems(4), of \"ls ! n\"]"], ["proof (state)\nthis:\n  ht_hash (ls_insls (ls ! n) ld)\n\ngoal (1 subgoal):\n 1. map_of (concat (ls_copy (Suc n) ls ld)) =\n    map_of (concat ld) ++ map_of (concat (take (Suc n) ls))", "note b = ht_distinct_ls_insls[OF prems(5), of \"ls ! n\"]"], ["proof (state)\nthis:\n  ht_distinct (ls_insls (ls ! n) ld)\n\ngoal (1 subgoal):\n 1. map_of (concat (ls_copy (Suc n) ls ld)) =\n    map_of (concat ld) ++ map_of (concat (take (Suc n) ls))", "note c = length_ls_insls[OF prems(6), of \"ls ! n\"]"], ["proof (state)\nthis:\n  1 < length (ls_insls (ls ! n) ld)\n\ngoal (1 subgoal):\n 1. map_of (concat (ls_copy (Suc n) ls ld)) =\n    map_of (concat ld) ++ map_of (concat (take (Suc n) ls))", "from prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>ht_hash ls; ht_distinct ls; ht_hash ?ld; ht_distinct ?ld;\n   1 < length ?ld; n \\<le> length ls\\<rbrakk>\n  \\<Longrightarrow> map_of (concat (ls_copy n ls ?ld)) =\n                    map_of (concat ?ld) ++ map_of (concat (take n ls))\n  ht_hash ls\n  ht_distinct ls\n  ht_hash ld\n  ht_distinct ld\n  1 < length ld\n  Suc n \\<le> length ls", "have \"n < length ls\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ht_hash ls; ht_distinct ls; ht_hash ?ld; ht_distinct ?ld;\n   1 < length ?ld; n \\<le> length ls\\<rbrakk>\n  \\<Longrightarrow> map_of (concat (ls_copy n ls ?ld)) =\n                    map_of (concat ?ld) ++ map_of (concat (take n ls))\n  ht_hash ls\n  ht_distinct ls\n  ht_hash ld\n  ht_distinct ld\n  1 < length ld\n  Suc n \\<le> length ls\n\ngoal (1 subgoal):\n 1. n < length ls", "by simp"], ["proof (state)\nthis:\n  n < length ls\n\ngoal (1 subgoal):\n 1. map_of (concat (ls_copy (Suc n) ls ld)) =\n    map_of (concat ld) ++ map_of (concat (take (Suc n) ls))", "with \n      ls_insls_map_of'[OF prems(2-6) this] \n      prems(1)[OF assms(1,2) a b c]"], ["proof (chain)\npicking this:\n  map_of (concat (ls_insls (ls ! n) ld)) ++ map_of (concat (take n ls)) =\n  map_of (concat ld) ++ map_of (concat (take (Suc n) ls))\n  n \\<le> length ls \\<Longrightarrow>\n  map_of (concat (ls_copy n ls (ls_insls (ls ! n) ld))) =\n  map_of (concat (ls_insls (ls ! n) ld)) ++ map_of (concat (take n ls))\n  n < length ls", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (concat (ls_insls (ls ! n) ld)) ++ map_of (concat (take n ls)) =\n  map_of (concat ld) ++ map_of (concat (take (Suc n) ls))\n  n \\<le> length ls \\<Longrightarrow>\n  map_of (concat (ls_copy n ls (ls_insls (ls ! n) ld))) =\n  map_of (concat (ls_insls (ls ! n) ld)) ++ map_of (concat (take n ls))\n  n < length ls\n\ngoal (1 subgoal):\n 1. map_of (concat (ls_copy (Suc n) ls ld)) =\n    map_of (concat ld) ++ map_of (concat (take (Suc n) ls))", "by simp"], ["proof (state)\nthis:\n  map_of (concat (ls_copy (Suc n) ls ld)) =\n  map_of (concat ld) ++ map_of (concat (take (Suc n) ls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ls_rehash_map_of:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (ls_rehash l)) = map_of (concat l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (ls_rehash l)) = map_of (concat l)", "using assms(3) ls_copy_map_of[OF assms(1,2) \n    ht_hash_replicate ht_distinct_replicate]"], ["proof (prove)\nusing this:\n  1 < length l\n  \\<lbrakk>1 < length (replicate ?n1 []); ?n \\<le> length l\\<rbrakk>\n  \\<Longrightarrow> map_of (concat (ls_copy ?n l (replicate ?n1 []))) =\n                    map_of (concat (replicate ?n1 [])) ++\n                    map_of (concat (take ?n l))\n\ngoal (1 subgoal):\n 1. map_of (concat (ls_rehash l)) = map_of (concat l)", "by (simp add: ls_rehash_def)"], ["", "lemma abs_update_rehash_map_of:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (abs_update k v (ls_rehash l))) \n  = map_of (concat l)(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v (ls_rehash l))) = map_of (concat l)(k \n    \\<mapsto> v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v (ls_rehash l))) = map_of (concat l)(k \n    \\<mapsto> v)", "note a = ht_hash_ls_rehash[of l]"], ["proof (state)\nthis:\n  ht_hash (ls_rehash l)\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v (ls_rehash l))) = map_of (concat l)(k \n    \\<mapsto> v)", "note b = ht_distinct_ls_rehash[of l]"], ["proof (state)\nthis:\n  ht_distinct (ls_rehash l)\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v (ls_rehash l))) = map_of (concat l)(k \n    \\<mapsto> v)", "note c = length_ls_rehash[OF assms(3)]"], ["proof (state)\nthis:\n  1 < length (ls_rehash l)\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v (ls_rehash l))) = map_of (concat l)(k \n    \\<mapsto> v)", "from abs_update_map_of[OF a b c] ls_rehash_map_of[OF assms]"], ["proof (chain)\npicking this:\n  map_of (concat (abs_update ?k ?v (ls_rehash l))) =\n  map_of (concat (ls_rehash l))(?k \\<mapsto> ?v)\n  map_of (concat (ls_rehash l)) = map_of (concat l)", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (concat (abs_update ?k ?v (ls_rehash l))) =\n  map_of (concat (ls_rehash l))(?k \\<mapsto> ?v)\n  map_of (concat (ls_rehash l)) = map_of (concat l)\n\ngoal (1 subgoal):\n 1. map_of (concat (abs_update k v (ls_rehash l))) = map_of (concat l)(k \n    \\<mapsto> v)", "by simp"], ["proof (state)\nthis:\n  map_of (concat (abs_update k v (ls_rehash l))) = map_of (concat l)(k \n  \\<mapsto> v)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"hm_update \\<equiv> ht_update\""], ["", "lemma hm_update_rule':\n  \"<is_hashmap' m l ht> \n    hm_update k v ht \n  <\\<lambda>r. is_hashmap (m(k \\<mapsto> v)) r * true>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap' m l\n      ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "proof (cases \"length l * load_factor \\<le> the_size ht * 100\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length l * load_factor \\<le> the_size ht * 100 \\<Longrightarrow>\n    <is_hashmap' m l\n      ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t\n 2. \\<not> length l * load_factor \\<le> the_size ht * 100 \\<Longrightarrow>\n    <is_hashmap' m l\n      ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "case True"], ["proof (state)\nthis:\n  length l * load_factor \\<le> the_size ht * 100\n\ngoal (2 subgoals):\n 1. length l * load_factor \\<le> the_size ht * 100 \\<Longrightarrow>\n    <is_hashmap' m l\n      ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t\n 2. \\<not> length l * load_factor \\<le> the_size ht * 100 \\<Longrightarrow>\n    <is_hashmap' m l\n      ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap' m l\n      ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "unfolding is_hashmap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht *\n     \\<up>\n      (map_of (concat l) =\n       m)> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. m = map_of (concat l) \\<Longrightarrow>\n    <is_hashtable l\n      ht> hm_update k v\n           ht <is_hashmap (map_of (concat l)(k \\<mapsto> v))>\\<^sub>t", "apply (rule cons_post_rule[OF complete_ht_update_rehash[OF True]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = map_of (concat l) \\<Longrightarrow>\n       is_hashtable l ht *\n       is_hashtable (abs_update k v (ls_rehash l))\n        x \\<Longrightarrow>\\<^sub>A\n       is_hashmap (map_of (concat l)(k \\<mapsto> v)) x * true", "unfolding is_hashmap_def is_hashmap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       m = map_of (concat l) \\<Longrightarrow>\n       is_hashtable l ht *\n       is_hashtable (abs_update k v (ls_rehash l))\n        x \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Ala.\n           is_hashtable la x *\n           \\<up> (map_of (concat la) = map_of (concat l)(k \\<mapsto> v))) *\n       true", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>m = map_of (concat l);\n        (a, b) \\<Turnstile>\n        is_hashtable l ht *\n        is_hashtable (abs_update k v (ls_rehash l)) x\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (abs_update k v (ls_rehash l))) =\n                         map_of (concat l)(k \\<mapsto> v)", "apply (simp add: abs_update_rehash_map_of is_hashtable_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <is_hashmap' m l\n    ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<not> length l * load_factor \\<le> the_size ht * 100 \\<Longrightarrow>\n    <is_hashmap' m l\n      ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length l * load_factor \\<le> the_size ht * 100 \\<Longrightarrow>\n    <is_hashmap' m l\n      ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "case False"], ["proof (state)\nthis:\n  \\<not> length l * load_factor \\<le> the_size ht * 100\n\ngoal (1 subgoal):\n 1. \\<not> length l * load_factor \\<le> the_size ht * 100 \\<Longrightarrow>\n    <is_hashmap' m l\n      ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap' m l\n      ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "unfolding is_hashmap'_def is_hashtable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n     \\<up>\n      (map_of (concat l) =\n       m)> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n     ht_distinct l; Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a\n                       l> hm_update k v\n                           ht <is_hashmap\n                                (map_of (concat l)(k \\<mapsto> v))>\\<^sub>t", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n     ht_distinct l; Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l> hm_update k v ht\n                      <?Q11>\n 2. \\<And>x.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l\\<rbrakk>\n       \\<Longrightarrow> ?Q11 x \\<Longrightarrow>\\<^sub>A\n                         is_hashmap (map_of (concat l)(k \\<mapsto> v)) x *\n                         true", "using complete_ht_update_normal[OF False, simplified is_hashtable_def, \n      simplified, of k v]"], ["proof (prove)\nusing this:\n  ht_size l (the_size ht) \\<and>\n  ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l \\<longrightarrow>\n  <the_array ht \\<mapsto>\\<^sub>a l> hm_update k v ht\n  <is_hashtable (abs_update k v l)>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n     ht_distinct l; Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l> hm_update k v ht\n                      <?Q11>\n 2. \\<And>x.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l\\<rbrakk>\n       \\<Longrightarrow> ?Q11 x \\<Longrightarrow>\\<^sub>A\n                         is_hashmap (map_of (concat l)(k \\<mapsto> v)) x *\n                         true", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l;\n        <the_array ht \\<mapsto>\\<^sub>a l> hm_update k v ht\n        <is_hashtable (abs_update k v l)>\\<rbrakk>\n       \\<Longrightarrow> is_hashtable (abs_update k v l)\n                          x \\<Longrightarrow>\\<^sub>A\n                         is_hashmap (map_of (concat l)(k \\<mapsto> v)) x *\n                         true", "unfolding is_hashmap_def is_hashmap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l;\n        <the_array ht \\<mapsto>\\<^sub>a l> hm_update k v ht\n        <is_hashtable (abs_update k v l)>\\<rbrakk>\n       \\<Longrightarrow> is_hashtable (abs_update k v l)\n                          x \\<Longrightarrow>\\<^sub>A\n                         (\\<exists>\\<^sub>Ala.\n                             is_hashtable la x *\n                             \\<up>\n                              (map_of (concat la) = map_of (concat l)(k \n                               \\<mapsto> v))) *\n                         true", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l;\n        <the_array ht \\<mapsto>\\<^sub>a l> hm_update k v ht\n        <is_hashtable (abs_update k v l)>;\n        (a, b) \\<Turnstile> is_hashtable (abs_update k v l) x\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (abs_update k v l)) =\n                         map_of (concat l)(k \\<mapsto> v)", "by (simp add: abs_update_map_of is_hashtable_def)"], ["proof (state)\nthis:\n  <is_hashmap' m l\n    ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hm_update_rule:\n  \"<is_hashmap m ht> \n    hm_update k v ht \n  <\\<lambda>r. is_hashmap (m(k \\<mapsto> v)) r * true>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap m\n      ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "unfolding is_hashmap_def[of m]"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al.\n        is_hashmap' m l\n         ht> hm_update k v ht <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "by (sep_auto heap add: hm_update_rule')"], ["", "lemma ls_delete_map_of:\n  assumes \"distinct (map fst l)\"\n  shows \"map_of (fst (ls_delete k l)) x = ((map_of l) |` (- {k})) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (fst (ls_delete k l)) x = (map_of l |` (- {k})) x", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst l)\n\ngoal (1 subgoal):\n 1. map_of (fst (ls_delete k l)) x = (map_of l |` (- {k})) x", "apply (induct l rule: ls_delete.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       distinct (map fst []) \\<Longrightarrow>\n       map_of (fst (ls_delete k [])) ka = (map_of [] |` (- {k})) ka\n 2. \\<And>ka l w ls.\n       \\<lbrakk>\\<lbrakk>ka \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> map_of (fst (ls_delete k ls)) ka =\n                                  (map_of ls |` (- {k})) ka;\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> map_of (fst (ls_delete k ((l, w) # ls))) ka =\n                         (map_of ((l, w) # ls) |` (- {k})) ka", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka l w ls.\n       \\<lbrakk>\\<lbrakk>ka \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> map_of (fst (ls_delete k ls)) ka =\n                                  (map_of ls |` (- {k})) ka;\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> map_of (fst (ls_delete k ((l, w) # ls))) ka =\n                         (map_of ((l, w) # ls) |` (- {k})) ka", "apply (auto simp add: map_of_eq_None_iff Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka l ls.\n       \\<lbrakk>map_of (fst (ls_delete k ls)) ka =\n                (map_of ls |` (- {k})) ka;\n        l \\<notin> fst ` set ls; distinct (map fst ls); ka \\<noteq> l;\n        l \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> (map_of ls |` (- {k})) ka =\n                         (map_of ls |` (- {k} - {l})) ka", "by (metis ComplD ComplI Compl_insert option.set(2) \n    insertE insertI2 map_upd_eq_restrict restrict_map_def)"], ["", "lemma update_ls_delete_map_of: \n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  assumes \"ht_hash (l[bounded_hashcode_nat (length l) k \n  := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\"\n  assumes \"ht_distinct (l[bounded_hashcode_nat (length l) k \n  := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\"\n  assumes \"1 < length l\"\n  shows \"map_of (concat (l[bounded_hashcode_nat (length l) k \n    := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])) x\n  = ((map_of (concat l)) |` (- {k})) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "from assms(2) bounded_hashcode_nat_bounds[OF assms(5)]"], ["proof (chain)\npicking this:\n  ht_distinct l\n  bounded_hashcode_nat (length l) ?a < length l", "have \n    distinct: \"distinct (map fst (l ! bounded_hashcode_nat (length l) k))\""], ["proof (prove)\nusing this:\n  ht_distinct l\n  bounded_hashcode_nat (length l) ?a < length l\n\ngoal (1 subgoal):\n 1. distinct (map fst (l ! bounded_hashcode_nat (length l) k))", "by (auto simp add: ht_distinct_def)"], ["proof (state)\nthis:\n  distinct (map fst (l ! bounded_hashcode_nat (length l) k))\n\ngoal (1 subgoal):\n 1. map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "note id1 = ht_hash_ht_distinct_map_of[OF assms(3,4), simplified, \n    OF assms(5)[simplified], of x]"], ["proof (state)\nthis:\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  map_of\n   (l[bounded_hashcode_nat (length l) k :=\n        fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n    bounded_hashcode_nat (length l) x)\n   x\n\ngoal (1 subgoal):\n 1. map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "note id2 = ht_hash_ht_distinct_map_of[OF assms(1,2,5), of x]"], ["proof (state)\nthis:\n  map_of (concat l) x = map_of (l ! bounded_hashcode_nat (length l) x) x\n\ngoal (1 subgoal):\n 1. map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "proof (cases \n      \"bounded_hashcode_nat (length l) x = bounded_hashcode_nat (length l) k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bounded_hashcode_nat (length l) x =\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x\n 2. bounded_hashcode_nat (length l) x \\<noteq>\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "case True"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length l) x = bounded_hashcode_nat (length l) k\n\ngoal (2 subgoals):\n 1. bounded_hashcode_nat (length l) x =\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x\n 2. bounded_hashcode_nat (length l) x \\<noteq>\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "with id1"], ["proof (chain)\npicking this:\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  map_of\n   (l[bounded_hashcode_nat (length l) k :=\n        fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n    bounded_hashcode_nat (length l) x)\n   x\n  bounded_hashcode_nat (length l) x = bounded_hashcode_nat (length l) k", "have \"map_of (concat (l[bounded_hashcode_nat (length l) k \n      := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])) x \n      =\n      map_of (l[bounded_hashcode_nat (length l) k \n        := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] \n      ! bounded_hashcode_nat (length l) k) x\""], ["proof (prove)\nusing this:\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  map_of\n   (l[bounded_hashcode_nat (length l) k :=\n        fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n    bounded_hashcode_nat (length l) x)\n   x\n  bounded_hashcode_nat (length l) x = bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    map_of\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n      bounded_hashcode_nat (length l) k)\n     x", "by simp"], ["proof (state)\nthis:\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  map_of\n   (l[bounded_hashcode_nat (length l) k :=\n        fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n    bounded_hashcode_nat (length l) k)\n   x\n\ngoal (2 subgoals):\n 1. bounded_hashcode_nat (length l) x =\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x\n 2. bounded_hashcode_nat (length l) x \\<noteq>\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "also"], ["proof (state)\nthis:\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  map_of\n   (l[bounded_hashcode_nat (length l) k :=\n        fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n    bounded_hashcode_nat (length l) k)\n   x\n\ngoal (2 subgoals):\n 1. bounded_hashcode_nat (length l) x =\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x\n 2. bounded_hashcode_nat (length l) x \\<noteq>\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "have \n      \"\\<dots> = map_of (fst (ls_delete k \n                          (l ! bounded_hashcode_nat (length l) k))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n      bounded_hashcode_nat (length l) k)\n     x =\n    map_of (fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))) x", "by (simp add: bounded_hashcode_nat_bounds[OF assms(5)])"], ["proof (state)\nthis:\n  map_of\n   (l[bounded_hashcode_nat (length l) k :=\n        fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n    bounded_hashcode_nat (length l) k)\n   x =\n  map_of (fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))) x\n\ngoal (2 subgoals):\n 1. bounded_hashcode_nat (length l) x =\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x\n 2. bounded_hashcode_nat (length l) x \\<noteq>\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "also"], ["proof (state)\nthis:\n  map_of\n   (l[bounded_hashcode_nat (length l) k :=\n        fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n    bounded_hashcode_nat (length l) k)\n   x =\n  map_of (fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))) x\n\ngoal (2 subgoals):\n 1. bounded_hashcode_nat (length l) x =\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x\n 2. bounded_hashcode_nat (length l) x \\<noteq>\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "from ls_delete_map_of[OF distinct]"], ["proof (chain)\npicking this:\n  map_of (fst (ls_delete ?k (l ! bounded_hashcode_nat (length l) k))) ?x =\n  (map_of (l ! bounded_hashcode_nat (length l) k) |` (- {?k})) ?x", "have \n      \"\\<dots> = (map_of (l ! bounded_hashcode_nat (length l) k) |` (- {k})) x\""], ["proof (prove)\nusing this:\n  map_of (fst (ls_delete ?k (l ! bounded_hashcode_nat (length l) k))) ?x =\n  (map_of (l ! bounded_hashcode_nat (length l) k) |` (- {?k})) ?x\n\ngoal (1 subgoal):\n 1. map_of (fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))) x =\n    (map_of (l ! bounded_hashcode_nat (length l) k) |` (- {k})) x", "by simp"], ["proof (state)\nthis:\n  map_of (fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))) x =\n  (map_of (l ! bounded_hashcode_nat (length l) k) |` (- {k})) x\n\ngoal (2 subgoals):\n 1. bounded_hashcode_nat (length l) x =\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x\n 2. bounded_hashcode_nat (length l) x \\<noteq>\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "finally"], ["proof (chain)\npicking this:\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  (map_of (l ! bounded_hashcode_nat (length l) k) |` (- {k})) x", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  (map_of (l ! bounded_hashcode_nat (length l) k) |` (- {k})) x\n\ngoal (1 subgoal):\n 1. map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "by (cases \"x = k\") (simp_all add: id2 True)"], ["proof (state)\nthis:\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  (map_of (concat l) |` (- {k})) x\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length l) x \\<noteq>\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length l) x \\<noteq>\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "case False"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length l) x \\<noteq>\n  bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length l) x \\<noteq>\n    bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "with bounded_hashcode_nat_bounds[OF assms(5)] id1 id2[symmetric]"], ["proof (chain)\npicking this:\n  bounded_hashcode_nat (length l) ?a < length l\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  map_of\n   (l[bounded_hashcode_nat (length l) k :=\n        fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n    bounded_hashcode_nat (length l) x)\n   x\n  map_of (l ! bounded_hashcode_nat (length l) x) x = map_of (concat l) x\n  bounded_hashcode_nat (length l) x \\<noteq>\n  bounded_hashcode_nat (length l) k", "show ?thesis"], ["proof (prove)\nusing this:\n  bounded_hashcode_nat (length l) ?a < length l\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  map_of\n   (l[bounded_hashcode_nat (length l) k :=\n        fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n    bounded_hashcode_nat (length l) x)\n   x\n  map_of (l ! bounded_hashcode_nat (length l) x) x = map_of (concat l) x\n  bounded_hashcode_nat (length l) x \\<noteq>\n  bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. map_of\n     (concat\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n     x =\n    (map_of (concat l) |` (- {k})) x", "by (cases \"x = k\") simp_all"], ["proof (state)\nthis:\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  (map_of (concat l) |` (- {k})) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of\n   (concat\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))\n   x =\n  (map_of (concat l) |` (- {k})) x\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"hm_delete \\<equiv> ht_delete\""], ["", "lemma hm_delete_rule': \n  \"<is_hashmap' m l ht> hm_delete k ht <is_hashmap (m |` (-{k}))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap' m l ht> hm_delete k ht <is_hashmap (m |` (- {k}))>", "apply (simp only: is_hashmap'_def[of m] is_hashtable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n     \\<up> (map_of (concat l) = m)>\n    hm_delete k ht <is_hashmap (m |` (- {k}))>", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n     ht_distinct l; Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l> hm_delete k ht\n                      <is_hashmap (map_of (concat l) |` (- {k}))>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n     ht_distinct l; Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l> hm_delete k ht\n                      <?Q11>\n 2. \\<And>x.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l\\<rbrakk>\n       \\<Longrightarrow> ?Q11 x \\<Longrightarrow>\\<^sub>A\n                         is_hashmap (map_of (concat l) |` (- {k})) x", "using complete_ht_delete[simplified is_hashtable_def]"], ["proof (prove)\nusing this:\n  <the_array ?ht \\<mapsto>\\<^sub>a ?l *\n   \\<up>\n    (ht_size ?l (the_size ?ht) \\<and>\n     ht_hash ?l \\<and> ht_distinct ?l \\<and> 1 < length ?l)>\n  hm_delete ?k ?ht\n  <is_hashtable\n    (?l[bounded_hashcode_nat (length ?l) ?k :=\n          fst (ls_delete ?k (?l ! bounded_hashcode_nat (length ?l) ?k))])>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n     ht_distinct l; Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l> hm_delete k ht\n                      <?Q11>\n 2. \\<And>x.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l\\<rbrakk>\n       \\<Longrightarrow> ?Q11 x \\<Longrightarrow>\\<^sub>A\n                         is_hashmap (map_of (concat l) |` (- {k})) x", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l\\<rbrakk>\n       \\<Longrightarrow> is_hashtable\n                          (l[bounded_hashcode_nat (length l) k :=\n                               fst (ls_delete k\n                                     (l !\nbounded_hashcode_nat (length l) k))])\n                          x \\<Longrightarrow>\\<^sub>A\n                         is_hashmap (map_of (concat l) |` (- {k})) x", "apply (simp add: is_hashmap_def is_hashmap'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l\\<rbrakk>\n       \\<Longrightarrow> is_hashtable\n                          (l[bounded_hashcode_nat (length l) k :=\n                               fst (ls_delete k\n                                     (l !\nbounded_hashcode_nat (length l) k))])\n                          x \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Ala.\n                            is_hashtable la x *\n                            \\<up>\n                             (map_of (concat la) =\n                              map_of (concat l) |` (- {k}))", "apply (sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l;\n        (a, b) \\<Turnstile>\n        is_hashtable\n         (l[bounded_hashcode_nat (length l) k :=\n              fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n         x\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (concat\n                            (l[bounded_hashcode_nat (length l) k :=\n                                 fst (ls_delete k\n (l ! bounded_hashcode_nat (length l) k))])) =\n                         map_of (concat l) |` (- {k})", "apply (simp add: is_hashtable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l;\n        (a, b) \\<Turnstile>\n        the_array x \\<mapsto>\\<^sub>a l\n        [bounded_hashcode_nat (length l) k :=\n           fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] \\<and>\n        ht_size\n         (l[bounded_hashcode_nat (length l) k :=\n              fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n         (the_size x) \\<and>\n        ht_hash\n         (l[bounded_hashcode_nat (length l) k :=\n              fst (ls_delete k\n                    (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n        ht_distinct\n         (l[bounded_hashcode_nat (length l) k :=\n              fst (ls_delete k\n                    (l ! bounded_hashcode_nat (length l) k))])\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (concat\n                            (l[bounded_hashcode_nat (length l) k :=\n                                 fst (ls_delete k\n (l ! bounded_hashcode_nat (length l) k))])) =\n                         map_of (concat l) |` (- {k})", "apply (sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l;\n        (a, b) \\<Turnstile>\n        the_array x \\<mapsto>\\<^sub>a l\n        [bounded_hashcode_nat (length l) k :=\n           fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))];\n        ht_size\n         (l[bounded_hashcode_nat (length l) k :=\n              fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n         (the_size x);\n        ht_hash\n         (l[bounded_hashcode_nat (length l) k :=\n              fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]);\n        ht_distinct\n         (l[bounded_hashcode_nat (length l) k :=\n              fst (ls_delete k\n                    (l ! bounded_hashcode_nat (length l) k))])\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (concat\n                            (l[bounded_hashcode_nat (length l) k :=\n                                 fst (ls_delete k\n (l ! bounded_hashcode_nat (length l) k))])) =\n                         map_of (concat l) |` (- {k})", "by (auto simp add: update_ls_delete_map_of)"], ["", "lemma hm_delete_rule: \n  \"<is_hashmap m ht> hm_delete k ht <is_hashmap (m |` (-{k}))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap m ht> hm_delete k ht <is_hashmap (m |` (- {k}))>", "unfolding is_hashmap_def[of m]"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al. is_hashmap' m l ht> hm_delete k ht\n    <is_hashmap (m |` (- {k}))>", "by (sep_auto heap add: hm_delete_rule')"], ["", "definition hm_isEmpty :: \"('k, 'v) hashtable \\<Rightarrow> bool Heap\" where\n  \"hm_isEmpty ht \\<equiv> return (the_size ht = 0)\""], ["", "lemma hm_isEmpty_rule': \n  \"<is_hashmap' m l ht> \n  hm_isEmpty ht \n  <\\<lambda>r. is_hashmap' m l ht * \\<up>(r \\<longleftrightarrow> m=Map.empty)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap' m l ht> hm_isEmpty ht\n    <\\<lambda>r. is_hashmap' m l ht * \\<up> (r = (m = Map.empty))>", "unfolding hm_isEmpty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap' m l ht> return (the_size ht = 0)\n    <\\<lambda>r. is_hashmap' m l ht * \\<up> (r = (m = Map.empty))>", "unfolding is_hashmap_def is_hashmap'_def is_hashtable_def ht_size_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (the_size ht = sum_list (map length l) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n     \\<up> (map_of (concat l) = m)>\n    return (the_size ht = 0)\n    <\\<lambda>r.\n        the_array ht \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (the_size ht = sum_list (map length l) \\<and>\n          ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n        \\<up> (map_of (concat l) = m) *\n        \\<up> (r = (m = Map.empty))>", "apply (cases ht, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       ht = HashTable x1 x2 \\<Longrightarrow>\n       map_of (concat l) = m \\<longrightarrow>\n       x2 = sum_list (map length l) \\<and>\n       ht_hash l \\<and>\n       ht_distinct l \\<and> Suc 0 < length l \\<longrightarrow>\n       <x1 \\<mapsto>\\<^sub>a l> return (\\<forall>n\\<in>set l. n = [])\n       <\\<lambda>r. x1 \\<mapsto>\\<^sub>a l * \\<up> (r = (m = Map.empty))>", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_isEmpty_rule: \n  \"<is_hashmap m ht> hm_isEmpty ht <\\<lambda>r. is_hashmap m ht * \\<up>(r \\<longleftrightarrow> m=Map.empty)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap m ht> hm_isEmpty ht\n    <\\<lambda>r. is_hashmap m ht * \\<up> (r = (m = Map.empty))>", "unfolding is_hashmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al. is_hashmap' m l ht> hm_isEmpty ht\n    <\\<lambda>r.\n        (\\<exists>\\<^sub>Al. is_hashmap' m l ht) *\n        \\<up> (r = (m = Map.empty))>", "apply (sep_auto heap: hm_isEmpty_rule')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition hm_size :: \"('k, 'v) hashtable \\<Rightarrow> nat Heap\" where\n  \"hm_size ht \\<equiv> return (the_size ht)\""], ["", "lemma length_card_dom_map_of:\n  assumes \"distinct (map fst l)\"\n  shows \"length l = card (dom (map_of l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = card (dom (map_of l))", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst l)\n\ngoal (1 subgoal):\n 1. length l = card (dom (map_of l))", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    length [] = card (dom (map_of []))\n 2. \\<And>a l.\n       \\<lbrakk>distinct (map fst l) \\<Longrightarrow>\n                length l = card (dom (map_of l));\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> length (a # l) = card (dom (map_of (a # l)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>distinct (map fst l) \\<Longrightarrow>\n                length l = card (dom (map_of l));\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> length (a # l) = card (dom (map_of (a # l)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>length l = card (dom (map_of l));\n        fst a \\<notin> fst ` set l \\<and> distinct (map fst l)\\<rbrakk>\n       \\<Longrightarrow> Suc (card (dom (map_of l))) =\n                         card (insert (fst a) (dom (map_of l)))", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l aa b.\n       \\<lbrakk>length l = card (dom (map_of l));\n        fst a \\<notin> fst ` set l \\<and> distinct (map fst l);\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> Suc (card (dom (map_of l))) =\n                         card (insert (fst a) (dom (map_of l)))", "apply (auto intro!: fst_conv map_of_SomeD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l aa.\n       \\<lbrakk>length l = card (dom (map_of l)); aa \\<notin> fst ` set l;\n        distinct (map fst l)\\<rbrakk>\n       \\<Longrightarrow> Suc (card (dom (map_of l))) =\n                         card (insert aa (dom (map_of l)))", "apply (subgoal_tac \"aa \\<notin> dom (map_of l)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l aa.\n       \\<lbrakk>length l = card (dom (map_of l)); aa \\<notin> fst ` set l;\n        distinct (map fst l); aa \\<notin> dom (map_of l)\\<rbrakk>\n       \\<Longrightarrow> Suc (card (dom (map_of l))) =\n                         card (insert aa (dom (map_of l)))\n 2. \\<And>l aa.\n       \\<lbrakk>length l = card (dom (map_of l)); aa \\<notin> fst ` set l;\n        distinct (map fst l)\\<rbrakk>\n       \\<Longrightarrow> aa \\<notin> dom (map_of l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l aa.\n       \\<lbrakk>length l = card (dom (map_of l)); aa \\<notin> fst ` set l;\n        distinct (map fst l)\\<rbrakk>\n       \\<Longrightarrow> aa \\<notin> dom (map_of l)", "by (metis dom_map_of_conv_image_fst)"], ["", "lemma ht_hash_dom_map_of_disj:\n  assumes \"ht_hash l\"\n  assumes \"i < length l\"\n  assumes \"j < length l\"\n  assumes \"i \\<noteq> j\"\n  shows \"dom (map_of (l!i)) \\<inter> dom (map_of(l!j)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of (l ! i)) \\<inter> dom (map_of (l ! j)) = {}", "using assms"], ["proof (prove)\nusing this:\n  ht_hash l\n  i < length l\n  j < length l\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. dom (map_of (l ! i)) \\<inter> dom (map_of (l ! j)) = {}", "unfolding ht_hash_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length l.\n     \\<forall>x\\<in>set (l ! i). bounded_hashcode_nat (length l) (fst x) = i\n  i < length l\n  j < length l\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. dom (map_of (l ! i)) \\<inter> dom (map_of (l ! j)) = {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ya.\n       \\<lbrakk>\\<forall>i<length l.\n                   \\<forall>x\\<in>set (l ! i).\n                      bounded_hashcode_nat (length l) (fst x) = i;\n        i < length l; j < length l; i \\<noteq> j; map_of (l ! i) x = Some y;\n        map_of (l ! j) x = Some ya\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis fst_conv map_of_SomeD)"], ["", "lemma ht_hash_dom_map_of_disj_drop:\n  assumes \"ht_hash l\"\n  assumes \"i < length l\"\n  shows \"dom (map_of (l!i)) \\<inter> dom (map_of (concat (drop (Suc i) l))) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of (l ! i)) \\<inter> dom (map_of (concat (drop (Suc i) l))) =\n    {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ya.\n       \\<lbrakk>map_of (l ! i) x = Some y;\n        map_of (concat (drop (Suc i) l)) x = Some ya\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal premises prems for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from prems(2)"], ["proof (chain)\npicking this:\n  map_of (concat (drop (Suc i) l)) x = Some z", "have \"x \\<in> dom (map_of (concat (drop (Suc i) l)))\""], ["proof (prove)\nusing this:\n  map_of (concat (drop (Suc i) l)) x = Some z\n\ngoal (1 subgoal):\n 1. x \\<in> dom (map_of (concat (drop (Suc i) l)))", "by auto"], ["proof (state)\nthis:\n  x \\<in> dom (map_of (concat (drop (Suc i) l)))\n\ngoal (1 subgoal):\n 1. False", "hence \"\\<exists>j. j < length (drop (Suc i) l) \n      \\<and> x \\<in> dom (map_of ((drop (Suc i) l)!j))\""], ["proof (prove)\nusing this:\n  x \\<in> dom (map_of (concat (drop (Suc i) l)))\n\ngoal (1 subgoal):\n 1. \\<exists>j<length (drop (Suc i) l).\n       x \\<in> dom (map_of (drop (Suc i) l ! j))", "by (metis Hash_Map.map_of_concat \n        \\<open>x \\<in> dom (map_of (concat (drop (Suc i) l)))\\<close> length_drop)"], ["proof (state)\nthis:\n  \\<exists>j<length (drop (Suc i) l).\n     x \\<in> dom (map_of (drop (Suc i) l ! j))\n\ngoal (1 subgoal):\n 1. False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>j<length (drop (Suc i) l).\n     x \\<in> dom (map_of (drop (Suc i) l ! j))", "obtain j where \n      j: \"j < length (drop (Suc i) l) \n        \\<and> x \\<in> dom (map_of ((drop (Suc i) l)!j))\""], ["proof (prove)\nusing this:\n  \\<exists>j<length (drop (Suc i) l).\n     x \\<in> dom (map_of (drop (Suc i) l ! j))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j < length (drop (Suc i) l) \\<and>\n        x \\<in> dom (map_of (drop (Suc i) l ! j)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j < length (drop (Suc i) l) \\<and>\n  x \\<in> dom (map_of (drop (Suc i) l ! j))\n\ngoal (1 subgoal):\n 1. False", "hence length: \"(Suc i + j) < length l\""], ["proof (prove)\nusing this:\n  j < length (drop (Suc i) l) \\<and>\n  x \\<in> dom (map_of (drop (Suc i) l ! j))\n\ngoal (1 subgoal):\n 1. Suc i + j < length l", "by auto"], ["proof (state)\nthis:\n  Suc i + j < length l\n\ngoal (1 subgoal):\n 1. False", "from j"], ["proof (chain)\npicking this:\n  j < length (drop (Suc i) l) \\<and>\n  x \\<in> dom (map_of (drop (Suc i) l ! j))", "have neq: \"i \\<noteq> (Suc i + j)\""], ["proof (prove)\nusing this:\n  j < length (drop (Suc i) l) \\<and>\n  x \\<in> dom (map_of (drop (Suc i) l ! j))\n\ngoal (1 subgoal):\n 1. i \\<noteq> Suc i + j", "by simp"], ["proof (state)\nthis:\n  i \\<noteq> Suc i + j\n\ngoal (1 subgoal):\n 1. False", "from j"], ["proof (chain)\npicking this:\n  j < length (drop (Suc i) l) \\<and>\n  x \\<in> dom (map_of (drop (Suc i) l ! j))", "have in_dom: \"x \\<in> dom (map_of (l!(Suc i + j)))\""], ["proof (prove)\nusing this:\n  j < length (drop (Suc i) l) \\<and>\n  x \\<in> dom (map_of (drop (Suc i) l ! j))\n\ngoal (1 subgoal):\n 1. x \\<in> dom (map_of (l ! (Suc i + j)))", "by auto"], ["proof (state)\nthis:\n  x \\<in> dom (map_of (l ! (Suc i + j)))\n\ngoal (1 subgoal):\n 1. False", "from prems(1)"], ["proof (chain)\npicking this:\n  map_of (l ! i) x = Some y", "have in_dom2: \"x \\<in> dom (map_of (l ! i))\""], ["proof (prove)\nusing this:\n  map_of (l ! i) x = Some y\n\ngoal (1 subgoal):\n 1. x \\<in> dom (map_of (l ! i))", "by auto"], ["proof (state)\nthis:\n  x \\<in> dom (map_of (l ! i))\n\ngoal (1 subgoal):\n 1. False", "from ht_hash_dom_map_of_disj[OF assms length neq] in_dom in_dom2"], ["proof (chain)\npicking this:\n  dom (map_of (l ! i)) \\<inter> dom (map_of (l ! (Suc i + j))) = {}\n  x \\<in> dom (map_of (l ! (Suc i + j)))\n  x \\<in> dom (map_of (l ! i))", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (map_of (l ! i)) \\<inter> dom (map_of (l ! (Suc i + j))) = {}\n  x \\<in> dom (map_of (l ! (Suc i + j)))\n  x \\<in> dom (map_of (l ! i))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sum_list_length_card_dom_map_of_concat:\n  assumes \"ht_hash l\"\n  assumes \"ht_distinct l\"\n  shows \"sum_list (map length l) = card (dom (map_of (concat l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map length l) = card (dom (map_of (concat l)))", "using assms"], ["proof (prove)\nusing this:\n  ht_hash l\n  ht_distinct l\n\ngoal (1 subgoal):\n 1. sum_list (map length l) = card (dom (map_of (concat l)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ht_hash l; ht_distinct l\\<rbrakk>\n    \\<Longrightarrow> sum_list (map length l) =\n                      card (dom (map_of (concat l)))", "from ht_hash_dom_map_of_disj_drop[OF assms(1)]"], ["proof (chain)\npicking this:\n  ?i < length l \\<Longrightarrow>\n  dom (map_of (l ! ?i)) \\<inter> dom (map_of (concat (drop (Suc ?i) l))) =\n  {}", "have \"\\<forall>i. i < length l \n    \\<longrightarrow> dom (map_of (l ! i)) \\<inter> dom (map_of (concat (drop (Suc i) l)))\n        = {}\""], ["proof (prove)\nusing this:\n  ?i < length l \\<Longrightarrow>\n  dom (map_of (l ! ?i)) \\<inter> dom (map_of (concat (drop (Suc ?i) l))) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<forall>i<length l.\n       dom (map_of (l ! i)) \\<inter>\n       dom (map_of (concat (drop (Suc i) l))) =\n       {}", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length l.\n     dom (map_of (l ! i)) \\<inter> dom (map_of (concat (drop (Suc i) l))) =\n     {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ht_hash l; ht_distinct l\\<rbrakk>\n    \\<Longrightarrow> sum_list (map length l) =\n                      card (dom (map_of (concat l)))", "with assms(2)"], ["proof (chain)\npicking this:\n  ht_distinct l\n  \\<forall>i<length l.\n     dom (map_of (l ! i)) \\<inter> dom (map_of (concat (drop (Suc i) l))) =\n     {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ht_distinct l\n  \\<forall>i<length l.\n     dom (map_of (l ! i)) \\<inter> dom (map_of (concat (drop (Suc i) l))) =\n     {}\n\ngoal (1 subgoal):\n 1. sum_list (map length l) = card (dom (map_of (concat l)))", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ht_distinct [];\n     \\<forall>i<length [].\n        dom (map_of ([] ! i)) \\<inter>\n        dom (map_of (concat (drop (Suc i) []))) =\n        {}\\<rbrakk>\n    \\<Longrightarrow> sum_list (map length []) =\n                      card (dom (map_of (concat [])))\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>ht_distinct l;\n                 \\<forall>i<length l.\n                    dom (map_of (l ! i)) \\<inter>\n                    dom (map_of (concat (drop (Suc i) l))) =\n                    {}\\<rbrakk>\n                \\<Longrightarrow> sum_list (map length l) =\n                                  card (dom (map_of (concat l)));\n        ht_distinct (a # l);\n        \\<forall>i<length (a # l).\n           dom (map_of ((a # l) ! i)) \\<inter>\n           dom (map_of (concat (drop (Suc i) (a # l)))) =\n           {}\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length (a # l)) =\n                         card (dom (map_of (concat (a # l))))", "case Nil"], ["proof (state)\nthis:\n  ht_distinct []\n  \\<forall>i<length [].\n     dom (map_of ([] ! i)) \\<inter>\n     dom (map_of (concat (drop (Suc i) []))) =\n     {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ht_distinct [];\n     \\<forall>i<length [].\n        dom (map_of ([] ! i)) \\<inter>\n        dom (map_of (concat (drop (Suc i) []))) =\n        {}\\<rbrakk>\n    \\<Longrightarrow> sum_list (map length []) =\n                      card (dom (map_of (concat [])))\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>ht_distinct l;\n                 \\<forall>i<length l.\n                    dom (map_of (l ! i)) \\<inter>\n                    dom (map_of (concat (drop (Suc i) l))) =\n                    {}\\<rbrakk>\n                \\<Longrightarrow> sum_list (map length l) =\n                                  card (dom (map_of (concat l)));\n        ht_distinct (a # l);\n        \\<forall>i<length (a # l).\n           dom (map_of ((a # l) ! i)) \\<inter>\n           dom (map_of (concat (drop (Suc i) (a # l)))) =\n           {}\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length (a # l)) =\n                         card (dom (map_of (concat (a # l))))", "thus ?case"], ["proof (prove)\nusing this:\n  ht_distinct []\n  \\<forall>i<length [].\n     dom (map_of ([] ! i)) \\<inter>\n     dom (map_of (concat (drop (Suc i) []))) =\n     {}\n\ngoal (1 subgoal):\n 1. sum_list (map length []) = card (dom (map_of (concat [])))", "by simp"], ["proof (state)\nthis:\n  sum_list (map length []) = card (dom (map_of (concat [])))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>ht_distinct l;\n                 \\<forall>i<length l.\n                    dom (map_of (l ! i)) \\<inter>\n                    dom (map_of (concat (drop (Suc i) l))) =\n                    {}\\<rbrakk>\n                \\<Longrightarrow> sum_list (map length l) =\n                                  card (dom (map_of (concat l)));\n        ht_distinct (a # l);\n        \\<forall>i<length (a # l).\n           dom (map_of ((a # l) ! i)) \\<inter>\n           dom (map_of (concat (drop (Suc i) (a # l)))) =\n           {}\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length (a # l)) =\n                         card (dom (map_of (concat (a # l))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>ht_distinct l;\n                 \\<forall>i<length l.\n                    dom (map_of (l ! i)) \\<inter>\n                    dom (map_of (concat (drop (Suc i) l))) =\n                    {}\\<rbrakk>\n                \\<Longrightarrow> sum_list (map length l) =\n                                  card (dom (map_of (concat l)));\n        ht_distinct (a # l);\n        \\<forall>i<length (a # l).\n           dom (map_of ((a # l) ! i)) \\<inter>\n           dom (map_of (concat (drop (Suc i) (a # l)))) =\n           {}\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length (a # l)) =\n                         card (dom (map_of (concat (a # l))))", "case (Cons l ls)"], ["proof (state)\nthis:\n  \\<lbrakk>ht_distinct ls;\n   \\<forall>i<length ls.\n      dom (map_of (ls ! i)) \\<inter>\n      dom (map_of (concat (drop (Suc i) ls))) =\n      {}\\<rbrakk>\n  \\<Longrightarrow> sum_list (map length ls) =\n                    card (dom (map_of (concat ls)))\n  ht_distinct (l # ls)\n  \\<forall>i<length (l # ls).\n     dom (map_of ((l # ls) ! i)) \\<inter>\n     dom (map_of (concat (drop (Suc i) (l # ls)))) =\n     {}\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>ht_distinct l;\n                 \\<forall>i<length l.\n                    dom (map_of (l ! i)) \\<inter>\n                    dom (map_of (concat (drop (Suc i) l))) =\n                    {}\\<rbrakk>\n                \\<Longrightarrow> sum_list (map length l) =\n                                  card (dom (map_of (concat l)));\n        ht_distinct (a # l);\n        \\<forall>i<length (a # l).\n           dom (map_of ((a # l) ! i)) \\<inter>\n           dom (map_of (concat (drop (Suc i) (a # l)))) =\n           {}\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length (a # l)) =\n                         card (dom (map_of (concat (a # l))))", "from Cons(2)"], ["proof (chain)\npicking this:\n  ht_distinct (l # ls)", "have a: \"ht_distinct ls\""], ["proof (prove)\nusing this:\n  ht_distinct (l # ls)\n\ngoal (1 subgoal):\n 1. ht_distinct ls", "by (auto simp add: ht_distinct_def)"], ["proof (state)\nthis:\n  ht_distinct ls\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>ht_distinct l;\n                 \\<forall>i<length l.\n                    dom (map_of (l ! i)) \\<inter>\n                    dom (map_of (concat (drop (Suc i) l))) =\n                    {}\\<rbrakk>\n                \\<Longrightarrow> sum_list (map length l) =\n                                  card (dom (map_of (concat l)));\n        ht_distinct (a # l);\n        \\<forall>i<length (a # l).\n           dom (map_of ((a # l) ! i)) \\<inter>\n           dom (map_of (concat (drop (Suc i) (a # l)))) =\n           {}\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length (a # l)) =\n                         card (dom (map_of (concat (a # l))))", "from Cons(3)"], ["proof (chain)\npicking this:\n  \\<forall>i<length (l # ls).\n     dom (map_of ((l # ls) ! i)) \\<inter>\n     dom (map_of (concat (drop (Suc i) (l # ls)))) =\n     {}", "have b: \"\\<forall>i < length ls. dom (map_of (ls ! i)) \n      \\<inter> dom (map_of (concat (drop (Suc i) ls))) = {}\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (l # ls).\n     dom (map_of ((l # ls) ! i)) \\<inter>\n     dom (map_of (concat (drop (Suc i) (l # ls)))) =\n     {}\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ls.\n       dom (map_of (ls ! i)) \\<inter>\n       dom (map_of (concat (drop (Suc i) ls))) =\n       {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<Suc (length ls).\n       dom (map_of ((l # ls) ! i)) \\<inter>\n       dom (map_of (concat (drop i ls))) =\n       {} \\<Longrightarrow>\n    \\<forall>i<length ls.\n       dom (map_of (ls ! i)) \\<inter>\n       dom (map_of (concat (drop (Suc i) ls))) =\n       {}", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<forall>i<Suc (length ls).\n          dom (map_of ((l # ls) ! i)) \\<inter>\n          dom (map_of (concat (drop i ls))) =\n          {} \\<Longrightarrow>\n       i < length ls \\<longrightarrow>\n       dom (map_of (ls ! i)) \\<inter>\n       dom (map_of (concat (drop (Suc i) ls))) =\n       {}", "apply (rule_tac x=\"Suc i\" and P=\"(\\<lambda>i. i<Suc (length ls) \\<longrightarrow>\n             dom (map_of ((l # ls) ! i)) \\<inter> dom (map_of (concat (drop i ls))) =\n             {})\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<forall>i<Suc (length ls).\n          dom (map_of ((l # ls) ! i)) \\<inter>\n          dom (map_of (concat (drop i ls))) =\n          {} \\<Longrightarrow>\n       \\<forall>x<Suc (length ls).\n          dom (map_of ((l # ls) ! x)) \\<inter>\n          dom (map_of (concat (drop x ls))) =\n          {}\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>i<Suc (length ls).\n                   dom (map_of ((l # ls) ! i)) \\<inter>\n                   dom (map_of (concat (drop i ls))) =\n                   {};\n        Suc i < Suc (length ls) \\<longrightarrow>\n        dom (map_of ((l # ls) ! Suc i)) \\<inter>\n        dom (map_of (concat (drop (Suc i) ls))) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> i < length ls \\<longrightarrow>\n                         dom (map_of (ls ! i)) \\<inter>\n                         dom (map_of (concat (drop (Suc i) ls))) =\n                         {}", "by simp_all"], ["proof (state)\nthis:\n  \\<forall>i<length ls.\n     dom (map_of (ls ! i)) \\<inter>\n     dom (map_of (concat (drop (Suc i) ls))) =\n     {}\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>ht_distinct l;\n                 \\<forall>i<length l.\n                    dom (map_of (l ! i)) \\<inter>\n                    dom (map_of (concat (drop (Suc i) l))) =\n                    {}\\<rbrakk>\n                \\<Longrightarrow> sum_list (map length l) =\n                                  card (dom (map_of (concat l)));\n        ht_distinct (a # l);\n        \\<forall>i<length (a # l).\n           dom (map_of ((a # l) ! i)) \\<inter>\n           dom (map_of (concat (drop (Suc i) (a # l)))) =\n           {}\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length (a # l)) =\n                         card (dom (map_of (concat (a # l))))", "from Cons(2)"], ["proof (chain)\npicking this:\n  ht_distinct (l # ls)", "have \"distinct (map fst l)\""], ["proof (prove)\nusing this:\n  ht_distinct (l # ls)\n\ngoal (1 subgoal):\n 1. distinct (map fst l)", "by (auto simp add: ht_distinct_def)"], ["proof (state)\nthis:\n  distinct (map fst l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>ht_distinct l;\n                 \\<forall>i<length l.\n                    dom (map_of (l ! i)) \\<inter>\n                    dom (map_of (concat (drop (Suc i) l))) =\n                    {}\\<rbrakk>\n                \\<Longrightarrow> sum_list (map length l) =\n                                  card (dom (map_of (concat l)));\n        ht_distinct (a # l);\n        \\<forall>i<length (a # l).\n           dom (map_of ((a # l) ! i)) \\<inter>\n           dom (map_of (concat (drop (Suc i) (a # l)))) =\n           {}\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length (a # l)) =\n                         card (dom (map_of (concat (a # l))))", "note l = length_card_dom_map_of[OF this]"], ["proof (state)\nthis:\n  length l = card (dom (map_of l))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>ht_distinct l;\n                 \\<forall>i<length l.\n                    dom (map_of (l ! i)) \\<inter>\n                    dom (map_of (concat (drop (Suc i) l))) =\n                    {}\\<rbrakk>\n                \\<Longrightarrow> sum_list (map length l) =\n                                  card (dom (map_of (concat l)));\n        ht_distinct (a # l);\n        \\<forall>i<length (a # l).\n           dom (map_of ((a # l) ! i)) \\<inter>\n           dom (map_of (concat (drop (Suc i) (a # l)))) =\n           {}\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length (a # l)) =\n                         card (dom (map_of (concat (a # l))))", "from Cons(3)"], ["proof (chain)\npicking this:\n  \\<forall>i<length (l # ls).\n     dom (map_of ((l # ls) ! i)) \\<inter>\n     dom (map_of (concat (drop (Suc i) (l # ls)))) =\n     {}", "have c: \"dom (map_of l) \\<inter> dom (map_of (concat ls)) = {}\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (l # ls).\n     dom (map_of ((l # ls) ! i)) \\<inter>\n     dom (map_of (concat (drop (Suc i) (l # ls)))) =\n     {}\n\ngoal (1 subgoal):\n 1. dom (map_of l) \\<inter> dom (map_of (concat ls)) = {}", "apply (rule_tac x=\"0\" and P=\"(\\<lambda>i. i<Suc (length ls) \\<longrightarrow>\n             dom (map_of ((l # ls) ! i)) \n               \\<inter> dom (map_of (concat (drop i ls))) \n             = {})\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i<length (l # ls).\n       dom (map_of ((l # ls) ! i)) \\<inter>\n       dom (map_of (concat (drop (Suc i) (l # ls)))) =\n       {} \\<Longrightarrow>\n    \\<forall>x<Suc (length ls).\n       dom (map_of ((l # ls) ! x)) \\<inter>\n       dom (map_of (concat (drop x ls))) =\n       {}\n 2. \\<lbrakk>\\<forall>i<length (l # ls).\n                dom (map_of ((l # ls) ! i)) \\<inter>\n                dom (map_of (concat (drop (Suc i) (l # ls)))) =\n                {};\n     0 < Suc (length ls) \\<longrightarrow>\n     dom (map_of ((l # ls) ! 0)) \\<inter>\n     dom (map_of (concat (drop 0 ls))) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> dom (map_of l) \\<inter> dom (map_of (concat ls)) = {}", "by simp_all"], ["proof (state)\nthis:\n  dom (map_of l) \\<inter> dom (map_of (concat ls)) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>ht_distinct l;\n                 \\<forall>i<length l.\n                    dom (map_of (l ! i)) \\<inter>\n                    dom (map_of (concat (drop (Suc i) l))) =\n                    {}\\<rbrakk>\n                \\<Longrightarrow> sum_list (map length l) =\n                                  card (dom (map_of (concat l)));\n        ht_distinct (a # l);\n        \\<forall>i<length (a # l).\n           dom (map_of ((a # l) ! i)) \\<inter>\n           dom (map_of (concat (drop (Suc i) (a # l)))) =\n           {}\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length (a # l)) =\n                         card (dom (map_of (concat (a # l))))", "from Cons(1)[OF a b] l c"], ["proof (chain)\npicking this:\n  sum_list (map length ls) = card (dom (map_of (concat ls)))\n  length l = card (dom (map_of l))\n  dom (map_of l) \\<inter> dom (map_of (concat ls)) = {}", "show ?case"], ["proof (prove)\nusing this:\n  sum_list (map length ls) = card (dom (map_of (concat ls)))\n  length l = card (dom (map_of l))\n  dom (map_of l) \\<inter> dom (map_of (concat ls)) = {}\n\ngoal (1 subgoal):\n 1. sum_list (map length (l # ls)) = card (dom (map_of (concat (l # ls))))", "by (simp add: card_Un_disjoint)"], ["proof (state)\nthis:\n  sum_list (map length (l # ls)) = card (dom (map_of (concat (l # ls))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (map length l) = card (dom (map_of (concat l)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hm_size_rule': \n  \"<is_hashmap' m l ht> \n  hm_size ht \n  <\\<lambda>r. is_hashmap' m l ht * \\<up>(r = card (dom m))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap' m l ht> hm_size ht\n    <\\<lambda>r. is_hashmap' m l ht * \\<up> (r = card (dom m))>", "unfolding hm_size_def is_hashmap_def is_hashmap'_def is_hashtable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n     \\<up> (map_of (concat l) = m)>\n    return (the_size ht)\n    <\\<lambda>r.\n        the_array ht \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (ht_size l (the_size ht) \\<and>\n          ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n        \\<up> (map_of (concat l) = m) *\n        \\<up> (r = card (dom m))>", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l;\n        (a, b) \\<Turnstile> the_array ht \\<mapsto>\\<^sub>a l\\<rbrakk>\n       \\<Longrightarrow> the_size ht = card (dom (map_of (concat l)))", "apply (cases ht)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x1 x2.\n       \\<lbrakk>m = map_of (concat l); ht_size l (the_size ht); ht_hash l;\n        ht_distinct l; Suc 0 < length l;\n        (a, b) \\<Turnstile> the_array ht \\<mapsto>\\<^sub>a l;\n        ht = HashTable x1 x2\\<rbrakk>\n       \\<Longrightarrow> the_size ht = card (dom (map_of (concat l)))", "apply (simp add: ht_size_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x1 x2.\n       \\<lbrakk>m = map_of (concat l); x2 = sum_list (map length l);\n        ht_hash l; ht_distinct l; Suc 0 < length l;\n        (a, b) \\<Turnstile> x1 \\<mapsto>\\<^sub>a l;\n        ht = HashTable x1 (sum_list (map length l))\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length l) =\n                         card (dom (map_of (concat l)))", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x1.\n       \\<lbrakk>m = map_of (concat l); ht_hash l; ht_distinct l;\n        Suc 0 < length l; (a, b) \\<Turnstile> x1 \\<mapsto>\\<^sub>a l;\n        ht = HashTable x1 (sum_list (map length l))\\<rbrakk>\n       \\<Longrightarrow> sum_list (map length l) =\n                         card (dom (map_of (concat l)))", "by (simp add: sum_list_length_card_dom_map_of_concat)"], ["", "lemma hm_size_rule: \n  \"<is_hashmap m ht> \n    hm_size ht \n  <\\<lambda>r. is_hashmap m ht * \\<up>(r = card (dom m))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap m ht> hm_size ht\n    <\\<lambda>r. is_hashmap m ht * \\<up> (r = card (dom m))>", "unfolding is_hashmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al. is_hashmap' m l ht> hm_size ht\n    <\\<lambda>r.\n        (\\<exists>\\<^sub>Al. is_hashmap' m l ht) * \\<up> (r = card (dom m))>", "by (sep_auto heap: hm_size_rule')"], ["", "subsection \\<open>Iterators\\<close>"], ["", "subsubsection \\<open>Definitions\\<close>"], ["", "type_synonym ('k,'v) hm_it = \"(nat \\<times> ('k\\<times>'v) list \\<times> ('k,'v) hashtable)\""], ["", "fun hm_it_adjust \n  :: \"nat \\<Rightarrow> ('k::{heap,hashable},'v::heap) hashtable \\<Rightarrow> nat Heap\"\n  where\n  \"hm_it_adjust 0 ht = return 0\"\n| \"hm_it_adjust n ht = do {\n    l \\<leftarrow> Array.nth (the_array ht) n;\n    case l of \n      [] \\<Rightarrow> hm_it_adjust (n - 1) ht\n    | _ \\<Rightarrow>  return n\n  }\""], ["", "definition hm_it_init \n  :: \"('k::{heap,hashable},'v::heap) hashtable \\<Rightarrow> ('k,'v) hm_it Heap\"\n  where \n  \"hm_it_init ht \\<equiv> do {\n  n\\<leftarrow>Array.len (the_array ht);\n  if n = 0 then return (0,[],ht)\n  else do {\n    i\\<leftarrow>hm_it_adjust (n - 1) ht;\n    l\\<leftarrow>Array.nth (the_array ht) i;\n    return (i,l,ht)\n  }\n}\""], ["", "definition hm_it_has_next \n  :: \"('k::{heap,hashable},'v::heap) hm_it \\<Rightarrow> bool Heap\"\n  where \"hm_it_has_next it \n  \\<equiv> return (case it of (0,[],_) \\<Rightarrow> False | _ \\<Rightarrow> True)\""], ["", "definition hm_it_next :: \n  \"('k::{heap,hashable},'v::heap) hm_it \n    \\<Rightarrow> (('k\\<times>'v)\\<times>('k,'v) hm_it) Heap\"\n  where \"hm_it_next it \\<equiv> case it of \n    (i,a#b#l,ht) \\<Rightarrow> return (a,(i,b#l,ht))\n  | (0,[a],ht) \\<Rightarrow> return (a,(0,[],ht))\n  | (Suc i,[a],ht) \\<Rightarrow> do {\n    i \\<leftarrow> hm_it_adjust i ht;\n    l \\<leftarrow> Array.nth (the_array ht) i;\n    return (a,(i,rev l,ht))\n  }\n  \""], ["", "definition \"hm_is_it' l ht l' it \\<equiv>  \n  is_hashtable l ht * \n  \\<up>(let (i,r,ht')=it in \n       ht = ht' \n     \\<and> l' = (concat (take i l) @ rev r)\n     \\<and> distinct (map fst (l'))\n     \\<and> i \\<le> length l \\<and> (r=[] \\<longrightarrow> i=0)\n   )\""], ["", "definition \"hm_is_it m ht m' it \\<equiv> \\<exists>\\<^sub>Al l'. \n  hm_is_it' l ht l' it \n  * \\<up>(map_of (concat l) = m \\<and> map_of l' = m') \n  \""], ["", "subsubsection \\<open>Auxiliary Lemmas\\<close>"], ["", "lemma concat_take_Suc_empty: \"\\<lbrakk> n < length l; l!n=[] \\<rbrakk> \n  \\<Longrightarrow> concat (take (Suc n) l) = concat (take n l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length l; l ! n = []\\<rbrakk>\n    \\<Longrightarrow> concat (take (Suc n) l) = concat (take n l)", "apply (induct n arbitrary: l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>0 < length l; l ! 0 = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc 0) l) = concat (take 0 l)\n 2. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>n < length l; l ! n = []\\<rbrakk>\n                   \\<Longrightarrow> concat (take (Suc n) l) =\n                                     concat (take n l);\n        Suc n < length l; l ! Suc n = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc (Suc n)) l) =\n                         concat (take (Suc n) l)", "apply (case_tac l)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>0 < length l; l ! 0 = []; l = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc 0) l) = concat (take 0 l)\n 2. \\<And>l a list.\n       \\<lbrakk>0 < length l; l ! 0 = []; l = a # list\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc 0) l) = concat (take 0 l)\n 3. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>n < length l; l ! n = []\\<rbrakk>\n                   \\<Longrightarrow> concat (take (Suc n) l) =\n                                     concat (take n l);\n        Suc n < length l; l ! Suc n = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc (Suc n)) l) =\n                         concat (take (Suc n) l)", "apply auto [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>n < length l; l ! n = []\\<rbrakk>\n                   \\<Longrightarrow> concat (take (Suc n) l) =\n                                     concat (take n l);\n        Suc n < length l; l ! Suc n = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc (Suc n)) l) =\n                         concat (take (Suc n) l)", "apply (case_tac l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>n < length l; l ! n = []\\<rbrakk>\n                   \\<Longrightarrow> concat (take (Suc n) l) =\n                                     concat (take n l);\n        Suc n < length l; l ! Suc n = []; l = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc (Suc n)) l) =\n                         concat (take (Suc n) l)\n 2. \\<And>n l a list.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>n < length l; l ! n = []\\<rbrakk>\n                   \\<Longrightarrow> concat (take (Suc n) l) =\n                                     concat (take n l);\n        Suc n < length l; l ! Suc n = []; l = a # list\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc (Suc n)) l) =\n                         concat (take (Suc n) l)", "apply auto [2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_concat_splitE:\n  assumes \"i<length (concat ls)\"\n  obtains j k where\n  \"j < length ls\" \n  and \"k < length (ls!j)\" \n  and \"concat ls ! i = ls!j!k\"\n  and \"i = length (concat (take j ls)) + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        \\<lbrakk>j < length ls; k < length (ls ! j);\n         concat ls ! i = ls ! j ! k;\n         i = length (concat (take j ls)) + k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  i < length (concat ls)\n\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        \\<lbrakk>j < length ls; k < length (ls ! j);\n         concat ls ! i = ls ! j ! k;\n         i = length (concat (take j ls)) + k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct ls arbitrary: i thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i thesis.\n       \\<lbrakk>\\<And>j k.\n                   \\<lbrakk>j < length []; k < length ([] ! j);\n                    concat [] ! i = [] ! j ! k;\n                    i = length (concat (take j [])) + k\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        i < length (concat [])\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ls i thesis.\n       \\<lbrakk>\\<And>i thesis.\n                   \\<lbrakk>\\<And>j k.\n                               \\<lbrakk>j < length ls; k < length (ls ! j);\n                                concat ls ! i = ls ! j ! k;\n                                i = length (concat (take j ls)) + k\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    i < length (concat ls)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>j k.\n           \\<lbrakk>j < length (a # ls); k < length ((a # ls) ! j);\n            concat (a # ls) ! i = (a # ls) ! j ! k;\n            i = length (concat (take j (a # ls))) + k\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        i < length (concat (a # ls))\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?j < length []; ?k < length ([] ! ?j);\n   concat [] ! i = [] ! ?j ! ?k;\n   i = length (concat (take ?j [])) + ?k\\<rbrakk>\n  \\<Longrightarrow> thesis\n  i < length (concat [])\n\ngoal (2 subgoals):\n 1. \\<And>i thesis.\n       \\<lbrakk>\\<And>j k.\n                   \\<lbrakk>j < length []; k < length ([] ! j);\n                    concat [] ! i = [] ! j ! k;\n                    i = length (concat (take j [])) + k\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        i < length (concat [])\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ls i thesis.\n       \\<lbrakk>\\<And>i thesis.\n                   \\<lbrakk>\\<And>j k.\n                               \\<lbrakk>j < length ls; k < length (ls ! j);\n                                concat ls ! i = ls ! j ! k;\n                                i = length (concat (take j ls)) + k\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    i < length (concat ls)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>j k.\n           \\<lbrakk>j < length (a # ls); k < length ((a # ls) ! j);\n            concat (a # ls) ! i = (a # ls) ! j ! k;\n            i = length (concat (take j (a # ls))) + k\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        i < length (concat (a # ls))\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j < length []; ?k < length ([] ! ?j);\n   concat [] ! i = [] ! ?j ! ?k;\n   i = length (concat (take ?j [])) + ?k\\<rbrakk>\n  \\<Longrightarrow> thesis\n  i < length (concat [])\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a ls i thesis.\n       \\<lbrakk>\\<And>i thesis.\n                   \\<lbrakk>\\<And>j k.\n                               \\<lbrakk>j < length ls; k < length (ls ! j);\n                                concat ls ! i = ls ! j ! k;\n                                i = length (concat (take j ls)) + k\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    i < length (concat ls)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>j k.\n           \\<lbrakk>j < length (a # ls); k < length ((a # ls) ! j);\n            concat (a # ls) ! i = (a # ls) ! j ! k;\n            i = length (concat (take j (a # ls))) + k\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        i < length (concat (a # ls))\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls i thesis.\n       \\<lbrakk>\\<And>i thesis.\n                   \\<lbrakk>\\<And>j k.\n                               \\<lbrakk>j < length ls; k < length (ls ! j);\n                                concat ls ! i = ls ! j ! k;\n                                i = length (concat (take j ls)) + k\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    i < length (concat ls)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>j k.\n           \\<lbrakk>j < length (a # ls); k < length ((a # ls) ! j);\n            concat (a # ls) ! i = (a # ls) ! j ! k;\n            i = length (concat (take j (a # ls))) + k\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        i < length (concat (a # ls))\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons l ls)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>j k.\n              \\<lbrakk>j < length ls; k < length (ls ! j);\n               concat ls ! ?i = ls ! j ! k;\n               ?i = length (concat (take j ls)) + k\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   ?i < length (concat ls)\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>?j < length (l # ls); ?k < length ((l # ls) ! ?j);\n   concat (l # ls) ! i = (l # ls) ! ?j ! ?k;\n   i = length (concat (take ?j (l # ls))) + ?k\\<rbrakk>\n  \\<Longrightarrow> thesis\n  i < length (concat (l # ls))\n\ngoal (1 subgoal):\n 1. \\<And>a ls i thesis.\n       \\<lbrakk>\\<And>i thesis.\n                   \\<lbrakk>\\<And>j k.\n                               \\<lbrakk>j < length ls; k < length (ls ! j);\n                                concat ls ! i = ls ! j ! k;\n                                i = length (concat (take j ls)) + k\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    i < length (concat ls)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>j k.\n           \\<lbrakk>j < length (a # ls); k < length ((a # ls) ! j);\n            concat (a # ls) ! i = (a # ls) ! j ! k;\n            i = length (concat (take j (a # ls))) + k\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        i < length (concat (a # ls))\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> thesis\n 2. \\<not> ?P \\<Longrightarrow> thesis", "assume L: \"i < length l\""], ["proof (state)\nthis:\n  i < length l\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> thesis\n 2. \\<not> ?P \\<Longrightarrow> thesis", "hence \"concat (l#ls) ! i = (l#ls)!0!i\""], ["proof (prove)\nusing this:\n  i < length l\n\ngoal (1 subgoal):\n 1. concat (l # ls) ! i = (l # ls) ! 0 ! i", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  concat (l # ls) ! i = (l # ls) ! 0 ! i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> thesis\n 2. \\<not> ?P \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  concat (l # ls) ! i = (l # ls) ! 0 ! i\n\ngoal (1 subgoal):\n 1. thesis", "apply (rule_tac Cons.prems(1)[of 0 i])"], ["proof (prove)\ngoal (4 subgoals):\n 1. concat (l # ls) ! i = (l # ls) ! 0 ! i \\<Longrightarrow>\n    0 < length (l # ls)\n 2. concat (l # ls) ! i = (l # ls) ! 0 ! i \\<Longrightarrow>\n    i < length ((l # ls) ! 0)\n 3. concat (l # ls) ! i = (l # ls) ! 0 ! i \\<Longrightarrow>\n    concat (l # ls) ! i = (l # ls) ! 0 ! i\n 4. concat (l # ls) ! i = (l # ls) ! 0 ! i \\<Longrightarrow>\n    i = length (concat (take 0 (l # ls))) + i", "apply (simp_all add: L)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<not> i < length l \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length l \\<Longrightarrow> thesis", "assume L: \"\\<not>(i < length l)\""], ["proof (state)\nthis:\n  \\<not> i < length l\n\ngoal (1 subgoal):\n 1. \\<not> i < length l \\<Longrightarrow> thesis", "hence 1: \"concat (l#ls)!i = concat ls ! (i - length l)\""], ["proof (prove)\nusing this:\n  \\<not> i < length l\n\ngoal (1 subgoal):\n 1. concat (l # ls) ! i = concat ls ! (i - length l)", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  concat (l # ls) ! i = concat ls ! (i - length l)\n\ngoal (1 subgoal):\n 1. \\<not> i < length l \\<Longrightarrow> thesis", "obtain j k where\n      \"j < length ls\" and \"k < length (ls!j)\" \n      and \"concat ls ! (i - length l) = ls!j!k\"\n      and \"i - length l = length (concat (take j ls)) + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        \\<lbrakk>j < length ls; k < length (ls ! j);\n         concat ls ! (i - length l) = ls ! j ! k;\n         i - length l = length (concat (take j ls)) + k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule Cons.hyps[of \"i - length l\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j k.\n       \\<lbrakk>\\<And>j k.\n                   \\<lbrakk>j < length ls; k < length (ls ! j);\n                    concat ls ! (i - length l) = ls ! j ! k;\n                    i - length l = length (concat (take j ls)) + k\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        j < length ls; k < length (ls ! j);\n        concat ls ! (i - length l) = ls ! j ! k;\n        i - length l = length (concat (take j ls)) + k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. (\\<And>j k.\n        \\<lbrakk>j < length ls; k < length (ls ! j);\n         concat ls ! (i - length l) = ls ! j ! k;\n         i - length l = length (concat (take j ls)) + k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    i - length l < length (concat ls)", "using Cons.prems L"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j < length (l # ls); ?k < length ((l # ls) ! ?j);\n   concat (l # ls) ! i = (l # ls) ! ?j ! ?k;\n   i = length (concat (take ?j (l # ls))) + ?k\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  i < length (concat (l # ls))\n  \\<not> i < length l\n\ngoal (2 subgoals):\n 1. \\<And>j k.\n       \\<lbrakk>\\<And>j k.\n                   \\<lbrakk>j < length ls; k < length (ls ! j);\n                    concat ls ! (i - length l) = ls ! j ! k;\n                    i - length l = length (concat (take j ls)) + k\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        j < length ls; k < length (ls ! j);\n        concat ls ! (i - length l) = ls ! j ! k;\n        i - length l = length (concat (take j ls)) + k\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. (\\<And>j k.\n        \\<lbrakk>j < length ls; k < length (ls ! j);\n         concat ls ! (i - length l) = ls ! j ! k;\n         i - length l = length (concat (take j ls)) + k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    i - length l < length (concat ls)", "by auto"], ["proof (state)\nthis:\n  j < length ls\n  k < length (ls ! j)\n  concat ls ! (i - length l) = ls ! j ! k\n  i - length l = length (concat (take j ls)) + k\n\ngoal (1 subgoal):\n 1. \\<not> i < length l \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  j < length ls\n  k < length (ls ! j)\n  concat ls ! (i - length l) = ls ! j ! k\n  i - length l = length (concat (take j ls)) + k\n\ngoal (1 subgoal):\n 1. thesis", "using L"], ["proof (prove)\nusing this:\n  j < length ls\n  k < length (ls ! j)\n  concat ls ! (i - length l) = ls ! j ! k\n  i - length l = length (concat (take j ls)) + k\n  \\<not> i < length l\n\ngoal (1 subgoal):\n 1. thesis", "apply (rule_tac Cons.prems(1)[of \"Suc j\" k])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>j < length ls; k < length (ls ! j);\n     concat ls ! (i - length l) = ls ! j ! k;\n     i - length l = length (concat (take j ls)) + k;\n     \\<not> i < length l\\<rbrakk>\n    \\<Longrightarrow> Suc j < length (l # ls)\n 2. \\<lbrakk>j < length ls; k < length (ls ! j);\n     concat ls ! (i - length l) = ls ! j ! k;\n     i - length l = length (concat (take j ls)) + k;\n     \\<not> i < length l\\<rbrakk>\n    \\<Longrightarrow> k < length ((l # ls) ! Suc j)\n 3. \\<lbrakk>j < length ls; k < length (ls ! j);\n     concat ls ! (i - length l) = ls ! j ! k;\n     i - length l = length (concat (take j ls)) + k;\n     \\<not> i < length l\\<rbrakk>\n    \\<Longrightarrow> concat (l # ls) ! i = (l # ls) ! Suc j ! k\n 4. \\<lbrakk>j < length ls; k < length (ls ! j);\n     concat ls ! (i - length l) = ls ! j ! k;\n     i - length l = length (concat (take j ls)) + k;\n     \\<not> i < length l\\<rbrakk>\n    \\<Longrightarrow> i = length (concat (take (Suc j) (l # ls))) + k", "apply (auto simp: nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_hashmap'_distinct: \n  \"is_hashtable l ht \n    \\<Longrightarrow>\\<^sub>A is_hashtable l ht * \\<up>(distinct (map fst (concat l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_hashtable l ht \\<Longrightarrow>\\<^sub>A\n    is_hashtable l ht * \\<up> (distinct (map fst (concat l)))", "apply (simp add: distinct_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht) \\<longrightarrow>\n    (\\<forall>i<length (concat l).\n        \\<forall>j<length (concat l).\n           i \\<noteq> j \\<longrightarrow>\n           fst (concat l ! i) \\<noteq> fst (concat l ! j))", "proof (intro allI impI, elim exE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j a b.\n       \\<lbrakk>i < length (concat l); j < length (concat l); i \\<noteq> j;\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)", "fix i j a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j a b.\n       \\<lbrakk>i < length (concat l); j < length (concat l); i \\<noteq> j;\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)", "assume 1: \"i < length (concat l)\""], ["proof (state)\nthis:\n  i < length (concat l)\n\ngoal (1 subgoal):\n 1. \\<And>i j a b.\n       \\<lbrakk>i < length (concat l); j < length (concat l); i \\<noteq> j;\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)", "assume 2: \"j < length (concat l)\""], ["proof (state)\nthis:\n  j < length (concat l)\n\ngoal (1 subgoal):\n 1. \\<And>i j a b.\n       \\<lbrakk>i < length (concat l); j < length (concat l); i \\<noteq> j;\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)", "assume 3: \"i\\<noteq>j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j a b.\n       \\<lbrakk>i < length (concat l); j < length (concat l); i \\<noteq> j;\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)", "assume HM: \"(a,b) \\<Turnstile> is_hashtable l ht\""], ["proof (state)\nthis:\n  (a, b) \\<Turnstile> is_hashtable l ht\n\ngoal (1 subgoal):\n 1. \\<And>i j a b.\n       \\<lbrakk>i < length (concat l); j < length (concat l); i \\<noteq> j;\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)", "from 1"], ["proof (chain)\npicking this:\n  i < length (concat l)", "obtain ji ki where\n    IFMT: \"i = length (concat (take ji l)) + ki\" \n    and JI_LEN: \"ji < length l\"\n    and KI_LEN: \"ki < length (l!ji)\"\n    and [simp]: \"concat l ! i = l!ji!ki\""], ["proof (prove)\nusing this:\n  i < length (concat l)\n\ngoal (1 subgoal):\n 1. (\\<And>ji ki.\n        \\<lbrakk>i = length (concat (take ji l)) + ki; ji < length l;\n         ki < length (l ! ji); concat l ! i = l ! ji ! ki\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim: nth_concat_splitE)"], ["proof (state)\nthis:\n  i = length (concat (take ji l)) + ki\n  ji < length l\n  ki < length (l ! ji)\n  concat l ! i = l ! ji ! ki\n\ngoal (1 subgoal):\n 1. \\<And>i j a b.\n       \\<lbrakk>i < length (concat l); j < length (concat l); i \\<noteq> j;\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)", "from 2"], ["proof (chain)\npicking this:\n  j < length (concat l)", "obtain jj kj where\n    JFMT: \"j = length (concat (take jj l)) + kj\" \n    and JJ_LEN: \"jj < length l\"\n    and KJ_LEN: \"kj < length (l!jj)\"\n    and [simp]: \"concat l ! j = l!jj!kj\""], ["proof (prove)\nusing this:\n  j < length (concat l)\n\ngoal (1 subgoal):\n 1. (\\<And>jj kj.\n        \\<lbrakk>j = length (concat (take jj l)) + kj; jj < length l;\n         kj < length (l ! jj); concat l ! j = l ! jj ! kj\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim: nth_concat_splitE)"], ["proof (state)\nthis:\n  j = length (concat (take jj l)) + kj\n  jj < length l\n  kj < length (l ! jj)\n  concat l ! j = l ! jj ! kj\n\ngoal (1 subgoal):\n 1. \\<And>i j a b.\n       \\<lbrakk>i < length (concat l); j < length (concat l); i \\<noteq> j;\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)", "show \"fst (concat l ! i) \\<noteq> fst (concat l ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (concat l ! i) \\<noteq> fst (concat l ! j)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)\n 2. \\<not> ?P \\<Longrightarrow>\n    fst (concat l ! i) \\<noteq> fst (concat l ! j)", "assume [simp]: \"ji=jj\""], ["proof (state)\nthis:\n  ji = jj\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)\n 2. \\<not> ?P \\<Longrightarrow>\n    fst (concat l ! i) \\<noteq> fst (concat l ! j)", "with IFMT JFMT \\<open>i\\<noteq>j\\<close>"], ["proof (chain)\npicking this:\n  i = length (concat (take ji l)) + ki\n  j = length (concat (take jj l)) + kj\n  i \\<noteq> j\n  ji = jj", "have \"ki\\<noteq>kj\""], ["proof (prove)\nusing this:\n  i = length (concat (take ji l)) + ki\n  j = length (concat (take jj l)) + kj\n  i \\<noteq> j\n  ji = jj\n\ngoal (1 subgoal):\n 1. ki \\<noteq> kj", "by auto"], ["proof (state)\nthis:\n  ki \\<noteq> kj\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)\n 2. \\<not> ?P \\<Longrightarrow>\n    fst (concat l ! i) \\<noteq> fst (concat l ! j)", "moreover"], ["proof (state)\nthis:\n  ki \\<noteq> kj\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)\n 2. \\<not> ?P \\<Longrightarrow>\n    fst (concat l ! i) \\<noteq> fst (concat l ! j)", "from HM JJ_LEN"], ["proof (chain)\npicking this:\n  (a, b) \\<Turnstile> is_hashtable l ht\n  jj < length l", "have \"distinct (map fst (l!jj))\""], ["proof (prove)\nusing this:\n  (a, b) \\<Turnstile> is_hashtable l ht\n  jj < length l\n\ngoal (1 subgoal):\n 1. distinct (map fst (l ! jj))", "unfolding is_hashmap'_def is_hashtable_def ht_distinct_def"], ["proof (prove)\nusing this:\n  (a, b) \\<Turnstile>\n  the_array ht \\<mapsto>\\<^sub>a l *\n  \\<up>\n   (ht_size l (the_size ht) \\<and>\n    ht_hash l \\<and>\n    (\\<forall>i<length l. distinct (map fst (l ! i))) \\<and> 1 < length l)\n  jj < length l\n\ngoal (1 subgoal):\n 1. distinct (map fst (l ! jj))", "by auto"], ["proof (state)\nthis:\n  distinct (map fst (l ! jj))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> fst (concat l ! i) \\<noteq> fst (concat l ! j)\n 2. \\<not> ?P \\<Longrightarrow>\n    fst (concat l ! i) \\<noteq> fst (concat l ! j)", "ultimately"], ["proof (chain)\npicking this:\n  ki \\<noteq> kj\n  distinct (map fst (l ! jj))", "show ?thesis"], ["proof (prove)\nusing this:\n  ki \\<noteq> kj\n  distinct (map fst (l ! jj))\n\ngoal (1 subgoal):\n 1. fst (concat l ! i) \\<noteq> fst (concat l ! j)", "using KI_LEN KJ_LEN"], ["proof (prove)\nusing this:\n  ki \\<noteq> kj\n  distinct (map fst (l ! jj))\n  ki < length (l ! ji)\n  kj < length (l ! jj)\n\ngoal (1 subgoal):\n 1. fst (concat l ! i) \\<noteq> fst (concat l ! j)", "by (simp add: distinct_conv_nth)"], ["proof (state)\nthis:\n  fst (concat l ! i) \\<noteq> fst (concat l ! j)\n\ngoal (1 subgoal):\n 1. ji \\<noteq> jj \\<Longrightarrow>\n    fst (concat l ! i) \\<noteq> fst (concat l ! j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ji \\<noteq> jj \\<Longrightarrow>\n    fst (concat l ! i) \\<noteq> fst (concat l ! j)", "assume NE: \"ji\\<noteq>jj\""], ["proof (state)\nthis:\n  ji \\<noteq> jj\n\ngoal (1 subgoal):\n 1. ji \\<noteq> jj \\<Longrightarrow>\n    fst (concat l ! i) \\<noteq> fst (concat l ! j)", "from HM"], ["proof (chain)\npicking this:\n  (a, b) \\<Turnstile> is_hashtable l ht", "have \n      \"\\<forall>x\\<in>set (l!ji). bounded_hashcode_nat (length l) (fst x) = ji\"\n      \"\\<forall>x\\<in>set (l!jj). bounded_hashcode_nat (length l) (fst x) = jj\""], ["proof (prove)\nusing this:\n  (a, b) \\<Turnstile> is_hashtable l ht\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (l ! ji).\n       bounded_hashcode_nat (length l) (fst x) = ji &&&\n    \\<forall>x\\<in>set (l ! jj).\n       bounded_hashcode_nat (length l) (fst x) = jj", "unfolding is_hashmap'_def is_hashtable_def ht_hash_def"], ["proof (prove)\nusing this:\n  (a, b) \\<Turnstile>\n  the_array ht \\<mapsto>\\<^sub>a l *\n  \\<up>\n   (ht_size l (the_size ht) \\<and>\n    (\\<forall>i<length l.\n        \\<forall>x\\<in>set (l ! i).\n           bounded_hashcode_nat (length l) (fst x) = i) \\<and>\n    ht_distinct l \\<and> 1 < length l)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (l ! ji).\n       bounded_hashcode_nat (length l) (fst x) = ji &&&\n    \\<forall>x\\<in>set (l ! jj).\n       bounded_hashcode_nat (length l) (fst x) = jj", "using JI_LEN JJ_LEN"], ["proof (prove)\nusing this:\n  (a, b) \\<Turnstile>\n  the_array ht \\<mapsto>\\<^sub>a l *\n  \\<up>\n   (ht_size l (the_size ht) \\<and>\n    (\\<forall>i<length l.\n        \\<forall>x\\<in>set (l ! i).\n           bounded_hashcode_nat (length l) (fst x) = i) \\<and>\n    ht_distinct l \\<and> 1 < length l)\n  ji < length l\n  jj < length l\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (l ! ji).\n       bounded_hashcode_nat (length l) (fst x) = ji &&&\n    \\<forall>x\\<in>set (l ! jj).\n       bounded_hashcode_nat (length l) (fst x) = jj", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (l ! ji). bounded_hashcode_nat (length l) (fst x) = ji\n  \\<forall>x\\<in>set (l ! jj). bounded_hashcode_nat (length l) (fst x) = jj\n\ngoal (1 subgoal):\n 1. ji \\<noteq> jj \\<Longrightarrow>\n    fst (concat l ! i) \\<noteq> fst (concat l ! j)", "with KI_LEN KJ_LEN NE"], ["proof (chain)\npicking this:\n  ki < length (l ! ji)\n  kj < length (l ! jj)\n  ji \\<noteq> jj\n  \\<forall>x\\<in>set (l ! ji). bounded_hashcode_nat (length l) (fst x) = ji\n  \\<forall>x\\<in>set (l ! jj). bounded_hashcode_nat (length l) (fst x) = jj", "show ?thesis"], ["proof (prove)\nusing this:\n  ki < length (l ! ji)\n  kj < length (l ! jj)\n  ji \\<noteq> jj\n  \\<forall>x\\<in>set (l ! ji). bounded_hashcode_nat (length l) (fst x) = ji\n  \\<forall>x\\<in>set (l ! jj). bounded_hashcode_nat (length l) (fst x) = jj\n\ngoal (1 subgoal):\n 1. fst (concat l ! i) \\<noteq> fst (concat l ! j)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ki < length (l ! ji); kj < length (l ! jj); ji \\<noteq> jj;\n     \\<forall>x\\<in>set (l ! ji).\n        bounded_hashcode_nat (length l) (fst x) = ji;\n     \\<forall>x\\<in>set (l ! jj).\n        bounded_hashcode_nat (length l) (fst x) = jj;\n     fst (l ! ji ! ki) = fst (l ! jj ! kj)\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis nth_mem)"], ["proof (state)\nthis:\n  fst (concat l ! i) \\<noteq> fst (concat l ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (concat l ! i) \\<noteq> fst (concat l ! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma take_set: \"set (take n l) = { l!i | i. i<n \\<and> i<length l }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take n l) = {l ! i |i. i < n \\<and> i < length l}", "apply (auto simp add: set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < n; i < length l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            l ! i = take n l ! ia \\<and>\n                            ia < length l \\<and> ia < n", "apply (rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < n; i < length l\\<rbrakk>\n       \\<Longrightarrow> l ! i = take n l ! i \\<and>\n                         i < length l \\<and> i < n", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma skip_empty_aux:\n  assumes A: \"concat (take (Suc n) l) = concat (take (Suc x) l)\"\n  assumes L[simp]: \"Suc n \\<le> length l\" \"x \\<le> n\"\n  shows \"\\<forall>i. x<i \\<and> i\\<le>n \\<longrightarrow> l!i=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. x < i \\<and> i \\<le> n \\<longrightarrow> l ! i = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i. x < i \\<and> i \\<le> n \\<longrightarrow> l ! i = []", "have \"take (Suc n) l = take (Suc x + (n - x)) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc n) l = take (Suc x + (n - x)) l", "by simp"], ["proof (state)\nthis:\n  take (Suc n) l = take (Suc x + (n - x)) l\n\ngoal (1 subgoal):\n 1. \\<forall>i. x < i \\<and> i \\<le> n \\<longrightarrow> l ! i = []", "also"], ["proof (state)\nthis:\n  take (Suc n) l = take (Suc x + (n - x)) l\n\ngoal (1 subgoal):\n 1. \\<forall>i. x < i \\<and> i \\<le> n \\<longrightarrow> l ! i = []", "have \"\\<dots> = take (Suc x) l @ take (n - x) (drop (Suc x) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc x + (n - x)) l =\n    take (Suc x) l @ take (n - x) (drop (Suc x) l)", "by (simp only: take_add)"], ["proof (state)\nthis:\n  take (Suc x + (n - x)) l = take (Suc x) l @ take (n - x) (drop (Suc x) l)\n\ngoal (1 subgoal):\n 1. \\<forall>i. x < i \\<and> i \\<le> n \\<longrightarrow> l ! i = []", "finally"], ["proof (chain)\npicking this:\n  take (Suc n) l = take (Suc x) l @ take (n - x) (drop (Suc x) l)", "have \n    \"concat (take (Suc x) l) = \n      concat (take (Suc x) l) @ concat (take (n - x) (drop (Suc x) l))\""], ["proof (prove)\nusing this:\n  take (Suc n) l = take (Suc x) l @ take (n - x) (drop (Suc x) l)\n\ngoal (1 subgoal):\n 1. concat (take (Suc x) l) =\n    concat (take (Suc x) l) @ concat (take (n - x) (drop (Suc x) l))", "using A"], ["proof (prove)\nusing this:\n  take (Suc n) l = take (Suc x) l @ take (n - x) (drop (Suc x) l)\n  concat (take (Suc n) l) = concat (take (Suc x) l)\n\ngoal (1 subgoal):\n 1. concat (take (Suc x) l) =\n    concat (take (Suc x) l) @ concat (take (n - x) (drop (Suc x) l))", "by simp"], ["proof (state)\nthis:\n  concat (take (Suc x) l) =\n  concat (take (Suc x) l) @ concat (take (n - x) (drop (Suc x) l))\n\ngoal (1 subgoal):\n 1. \\<forall>i. x < i \\<and> i \\<le> n \\<longrightarrow> l ! i = []", "hence 1: \"\\<forall>l\\<in>set (take (n - x) (drop (Suc x) l)). l=[]\""], ["proof (prove)\nusing this:\n  concat (take (Suc x) l) =\n  concat (take (Suc x) l) @ concat (take (n - x) (drop (Suc x) l))\n\ngoal (1 subgoal):\n 1. \\<forall>l\\<in>set (take (n - x) (drop (Suc x) l)). l = []", "by simp"], ["proof (state)\nthis:\n  \\<forall>l\\<in>set (take (n - x) (drop (Suc x) l)). l = []\n\ngoal (1 subgoal):\n 1. \\<forall>i. x < i \\<and> i \\<le> n \\<longrightarrow> l ! i = []", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. x < i \\<and> i \\<le> n \\<longrightarrow> l ! i = []", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>x < i; i \\<le> n\\<rbrakk> \\<Longrightarrow> l ! i = []", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>x < i; i \\<le> n\\<rbrakk> \\<Longrightarrow> l ! i = []", "assume \"x<i\" and \"i\\<le>n\""], ["proof (state)\nthis:\n  x < i\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>x < i; i \\<le> n\\<rbrakk> \\<Longrightarrow> l ! i = []", "hence \"l!i \\<in> set (take (n - x) (drop (Suc x) l))\""], ["proof (prove)\nusing this:\n  x < i\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. l ! i \\<in> set (take (n - x) (drop (Suc x) l))", "using L[simp del]"], ["proof (prove)\nusing this:\n  x < i\n  i \\<le> n\n  Suc n \\<le> length l\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. l ! i \\<in> set (take (n - x) (drop (Suc x) l))", "apply (auto simp: take_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < i; i \\<le> n; Suc n \\<le> length l\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ia.\n                         l ! i = l ! Suc (x + ia) \\<and>\n                         ia < n - x \\<and> ia < length l - Suc x", "apply (rule_tac x=\"i - Suc x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < i; i \\<le> n; Suc n \\<le> length l\\<rbrakk>\n    \\<Longrightarrow> l ! i = l ! Suc (x + (i - Suc x)) \\<and>\n                      i - Suc x < n - x \\<and> i - Suc x < length l - Suc x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  l ! i \\<in> set (take (n - x) (drop (Suc x) l))\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>x < i; i \\<le> n\\<rbrakk> \\<Longrightarrow> l ! i = []", "with 1"], ["proof (chain)\npicking this:\n  \\<forall>l\\<in>set (take (n - x) (drop (Suc x) l)). l = []\n  l ! i \\<in> set (take (n - x) (drop (Suc x) l))", "show \"l!i=[]\""], ["proof (prove)\nusing this:\n  \\<forall>l\\<in>set (take (n - x) (drop (Suc x) l)). l = []\n  l ! i \\<in> set (take (n - x) (drop (Suc x) l))\n\ngoal (1 subgoal):\n 1. l ! i = []", "by blast"], ["proof (state)\nthis:\n  l ! i = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. x < i \\<and> i \\<le> n \\<longrightarrow> l ! i = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma take_Suc0: \n  \"l\\<noteq>[] \\<Longrightarrow> take (Suc 0) l = [l!0]\" \n  \"0 < length l \\<Longrightarrow> take (Suc 0) l = [l!0]\" \n  \"Suc n \\<le> length l \\<Longrightarrow> take (Suc 0) l = [l!0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l \\<noteq> [] \\<Longrightarrow> take (Suc 0) l = [l ! 0]) &&&\n    (0 < length l \\<Longrightarrow> take (Suc 0) l = [l ! 0]) &&&\n    (Suc n \\<le> length l \\<Longrightarrow> take (Suc 0) l = [l ! 0])", "by (cases l, auto)+"], ["", "lemma concat_take_Suc_app_nth:\n  assumes \"x < length l\"\n  shows \"concat (take (Suc x) l) = concat (take x l) @ l ! x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (take (Suc x) l) = concat (take x l) @ l ! x", "using assms"], ["proof (prove)\nusing this:\n  x < length l\n\ngoal (1 subgoal):\n 1. concat (take (Suc x) l) = concat (take x l) @ l ! x", "by (auto simp: take_Suc_conv_app_nth)"], ["", "lemma hm_hashcode_eq:\n  assumes \"j < length (l!i)\"\n  assumes \"i < length l\"\n  assumes \"h \\<Turnstile> is_hashtable l ht\"\n  shows \"bounded_hashcode_nat (length l) (fst (l!i!j)) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length l) (fst (l ! i ! j)) = i", "using assms"], ["proof (prove)\nusing this:\n  j < length (l ! i)\n  i < length l\n  h \\<Turnstile> is_hashtable l ht\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length l) (fst (l ! i ! j)) = i", "unfolding is_hashtable_def ht_hash_def"], ["proof (prove)\nusing this:\n  j < length (l ! i)\n  i < length l\n  h \\<Turnstile>\n  the_array ht \\<mapsto>\\<^sub>a l *\n  \\<up>\n   (ht_size l (the_size ht) \\<and>\n    (\\<forall>i<length l.\n        \\<forall>x\\<in>set (l ! i).\n           bounded_hashcode_nat (length l) (fst x) = i) \\<and>\n    ht_distinct l \\<and> 1 < length l)\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length l) (fst (l ! i ! j)) = i", "apply (cases \"l!i!j\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>j < length (l ! i); i < length l;\n        h \\<Turnstile>\n        the_array ht \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (ht_size l (the_size ht) \\<and>\n          (\\<forall>i<length l.\n              \\<forall>x\\<in>set (l ! i).\n                 bounded_hashcode_nat (length l) (fst x) = i) \\<and>\n          ht_distinct l \\<and> 1 < length l);\n        l ! i ! j = (a, b)\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat (length l) (fst (l ! i ! j)) =\n                         i", "apply (force simp: set_conv_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_imp_distinct_take: \n  \"distinct (map fst (concat l))\n  \\<Longrightarrow> distinct (map fst (concat (take x l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (concat l)) \\<Longrightarrow>\n    distinct (map fst (concat (take x l)))", "apply (subst (asm) append_take_drop_id[of x l,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (concat (take x l @ drop x l))) \\<Longrightarrow>\n    distinct (map fst (concat (take x l)))", "apply (simp del: append_take_drop_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_it_adjust_rule:\n  \"i<length l \\<Longrightarrow> <is_hashtable l ht> \n    hm_it_adjust i ht \n   <\\<lambda>j. is_hashtable l ht * \\<up>(\n      j\\<le>i \\<and> \n      (concat (take (Suc i) l) = concat (take (Suc j) l)) \\<and>\n      (j=0 \\<or> l!j \\<noteq> [])\n    )    \n   >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow>\n    <is_hashtable l ht> hm_it_adjust i ht\n    <\\<lambda>j.\n        is_hashtable l ht *\n        \\<up>\n         (j \\<le> i \\<and>\n          concat (take (Suc i) l) = concat (take (Suc j) l) \\<and>\n          (j = 0 \\<or> l ! j \\<noteq> []))>", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length l \\<Longrightarrow>\n    <is_hashtable l ht> hm_it_adjust 0 ht\n    <\\<lambda>j.\n        is_hashtable l ht *\n        \\<up>\n         (j \\<le> 0 \\<and>\n          concat (take (Suc 0) l) = concat (take (Suc j) l) \\<and>\n          (j = 0 \\<or> l ! j \\<noteq> []))>\n 2. \\<And>i.\n       \\<lbrakk>i < length l \\<Longrightarrow>\n                <is_hashtable l ht> hm_it_adjust i ht\n                <\\<lambda>j.\n                    is_hashtable l ht *\n                    \\<up>\n                     (j \\<le> i \\<and>\n                      concat (take (Suc i) l) =\n                      concat (take (Suc j) l) \\<and>\n                      (j = 0 \\<or> l ! j \\<noteq> []))>;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht> hm_it_adjust (Suc i) ht\n                         <\\<lambda>j.\n                             is_hashtable l ht *\n                             \\<up>\n                              (j \\<le> Suc i \\<and>\n                               concat (take (Suc (Suc i)) l) =\n                               concat (take (Suc j) l) \\<and>\n                               (j = 0 \\<or> l ! j \\<noteq> []))>", "case 0"], ["proof (state)\nthis:\n  0 < length l\n\ngoal (2 subgoals):\n 1. 0 < length l \\<Longrightarrow>\n    <is_hashtable l ht> hm_it_adjust 0 ht\n    <\\<lambda>j.\n        is_hashtable l ht *\n        \\<up>\n         (j \\<le> 0 \\<and>\n          concat (take (Suc 0) l) = concat (take (Suc j) l) \\<and>\n          (j = 0 \\<or> l ! j \\<noteq> []))>\n 2. \\<And>i.\n       \\<lbrakk>i < length l \\<Longrightarrow>\n                <is_hashtable l ht> hm_it_adjust i ht\n                <\\<lambda>j.\n                    is_hashtable l ht *\n                    \\<up>\n                     (j \\<le> i \\<and>\n                      concat (take (Suc i) l) =\n                      concat (take (Suc j) l) \\<and>\n                      (j = 0 \\<or> l ! j \\<noteq> []))>;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht> hm_it_adjust (Suc i) ht\n                         <\\<lambda>j.\n                             is_hashtable l ht *\n                             \\<up>\n                              (j \\<le> Suc i \\<and>\n                               concat (take (Suc (Suc i)) l) =\n                               concat (take (Suc j) l) \\<and>\n                               (j = 0 \\<or> l ! j \\<noteq> []))>", "thus ?case"], ["proof (prove)\nusing this:\n  0 < length l\n\ngoal (1 subgoal):\n 1. <is_hashtable l ht> hm_it_adjust 0 ht\n    <\\<lambda>j.\n        is_hashtable l ht *\n        \\<up>\n         (j \\<le> 0 \\<and>\n          concat (take (Suc 0) l) = concat (take (Suc j) l) \\<and>\n          (j = 0 \\<or> l ! j \\<noteq> []))>", "by sep_auto"], ["proof (state)\nthis:\n  <is_hashtable l ht> hm_it_adjust 0 ht\n  <\\<lambda>j.\n      is_hashtable l ht *\n      \\<up>\n       (j \\<le> 0 \\<and>\n        concat (take (Suc 0) l) = concat (take (Suc j) l) \\<and>\n        (j = 0 \\<or> l ! j \\<noteq> []))>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length l \\<Longrightarrow>\n                <is_hashtable l ht> hm_it_adjust i ht\n                <\\<lambda>j.\n                    is_hashtable l ht *\n                    \\<up>\n                     (j \\<le> i \\<and>\n                      concat (take (Suc i) l) =\n                      concat (take (Suc j) l) \\<and>\n                      (j = 0 \\<or> l ! j \\<noteq> []))>;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht> hm_it_adjust (Suc i) ht\n                         <\\<lambda>j.\n                             is_hashtable l ht *\n                             \\<up>\n                              (j \\<le> Suc i \\<and>\n                               concat (take (Suc (Suc i)) l) =\n                               concat (take (Suc j) l) \\<and>\n                               (j = 0 \\<or> l ! j \\<noteq> []))>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length l \\<Longrightarrow>\n                <is_hashtable l ht> hm_it_adjust i ht\n                <\\<lambda>j.\n                    is_hashtable l ht *\n                    \\<up>\n                     (j \\<le> i \\<and>\n                      concat (take (Suc i) l) =\n                      concat (take (Suc j) l) \\<and>\n                      (j = 0 \\<or> l ! j \\<noteq> []))>;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht> hm_it_adjust (Suc i) ht\n                         <\\<lambda>j.\n                             is_hashtable l ht *\n                             \\<up>\n                              (j \\<le> Suc i \\<and>\n                               concat (take (Suc (Suc i)) l) =\n                               concat (take (Suc j) l) \\<and>\n                               (j = 0 \\<or> l ! j \\<noteq> []))>", "case (Suc n)"], ["proof (state)\nthis:\n  n < length l \\<Longrightarrow>\n  <is_hashtable l ht> hm_it_adjust n ht\n  <\\<lambda>j.\n      is_hashtable l ht *\n      \\<up>\n       (j \\<le> n \\<and>\n        concat (take (Suc n) l) = concat (take (Suc j) l) \\<and>\n        (j = 0 \\<or> l ! j \\<noteq> []))>\n  Suc n < length l\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length l \\<Longrightarrow>\n                <is_hashtable l ht> hm_it_adjust i ht\n                <\\<lambda>j.\n                    is_hashtable l ht *\n                    \\<up>\n                     (j \\<le> i \\<and>\n                      concat (take (Suc i) l) =\n                      concat (take (Suc j) l) \\<and>\n                      (j = 0 \\<or> l ! j \\<noteq> []))>;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht> hm_it_adjust (Suc i) ht\n                         <\\<lambda>j.\n                             is_hashtable l ht *\n                             \\<up>\n                              (j \\<le> Suc i \\<and>\n                               concat (take (Suc (Suc i)) l) =\n                               concat (take (Suc j) l) \\<and>\n                               (j = 0 \\<or> l ! j \\<noteq> []))>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> hm_it_adjust (Suc n) ht\n    <\\<lambda>j.\n        is_hashtable l ht *\n        \\<up>\n         (j \\<le> Suc n \\<and>\n          concat (take (Suc (Suc n)) l) = concat (take (Suc j) l) \\<and>\n          (j = 0 \\<or> l ! j \\<noteq> []))>", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc n < length l\n\ngoal (1 subgoal):\n 1. <is_hashtable l ht> hm_it_adjust (Suc n) ht\n    <\\<lambda>j.\n        is_hashtable l ht *\n        \\<up>\n         (j \\<le> Suc n \\<and>\n          concat (take (Suc (Suc n)) l) = concat (take (Suc j) l) \\<and>\n          (j = 0 \\<or> l ! j \\<noteq> []))>", "by (sep_auto \n      heap add: Suc.hyps\n      simp: concat_take_Suc_empty\n      split: list.split)"], ["proof (state)\nthis:\n  <is_hashtable l ht> hm_it_adjust (Suc n) ht\n  <\\<lambda>j.\n      is_hashtable l ht *\n      \\<up>\n       (j \\<le> Suc n \\<and>\n        concat (take (Suc (Suc n)) l) = concat (take (Suc j) l) \\<and>\n        (j = 0 \\<or> l ! j \\<noteq> []))>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hm_it_next_rule': \"l'\\<noteq>[] \\<Longrightarrow> \n    <hm_is_it' l ht l' it> \n      hm_it_next it \n    <\\<lambda>((k,v),it'). \n      hm_is_it' l ht (butlast l') it' \n    * \\<up>(last l' = (k,v) \\<and> distinct (map fst l') )>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' \\<noteq> [] \\<Longrightarrow>\n    <hm_is_it' l ht l' it> hm_it_next it\n    <\\<lambda>((k, v), it').\n        hm_is_it' l ht (butlast l') it' *\n        \\<up> (last l' = (k, v) \\<and> distinct (map fst l'))>", "unfolding hm_it_next_def hm_is_it'_def is_hashmap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l' \\<noteq> [] \\<Longrightarrow>\n    <is_hashtable l ht *\n     \\<up>\n      (let (i, r, ht') = it\n       in ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0))>\n    case it of (0, [a], ht) \\<Rightarrow> return (a, 0, [], ht)\n    | (0, a # b # l, ht) \\<Rightarrow> return (a, 0, b # l, ht)\n    | (Suc nat, [a], ht) \\<Rightarrow>\n        hm_it_adjust nat ht \\<bind>\n        (\\<lambda>i.\n            Array.nth (the_array ht) i \\<bind>\n            (\\<lambda>l. return (a, i, rev l, ht)))\n    | (Suc nat, a # b # l, ht) \\<Rightarrow> return (a, Suc nat, b # l, ht)\n    <\\<lambda>((k, v), it').\n        is_hashtable l ht *\n        \\<up>\n         (let (i, r, ht') = it'\n          in ht = ht' \\<and>\n             butlast l' = concat (take i l) @ rev r \\<and>\n             distinct (map fst (butlast l')) \\<and>\n             i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n        \\<up> (last l' = (k, v) \\<and> distinct (map fst l'))>", "using [[hypsubst_thin = true]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. l' \\<noteq> [] \\<Longrightarrow>\n    <is_hashtable l ht *\n     \\<up>\n      (let (i, r, ht') = it\n       in ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0))>\n    case it of (0, [a], ht) \\<Rightarrow> return (a, 0, [], ht)\n    | (0, a # b # l, ht) \\<Rightarrow> return (a, 0, b # l, ht)\n    | (Suc nat, [a], ht) \\<Rightarrow>\n        hm_it_adjust nat ht \\<bind>\n        (\\<lambda>i.\n            Array.nth (the_array ht) i \\<bind>\n            (\\<lambda>l. return (a, i, rev l, ht)))\n    | (Suc nat, a # b # l, ht) \\<Rightarrow> return (a, Suc nat, b # l, ht)\n    <\\<lambda>((k, v), it').\n        is_hashtable l ht *\n        \\<up>\n         (let (i, r, ht') = it'\n          in ht = ht' \\<and>\n             butlast l' = concat (take i l) @ rev r \\<and>\n             distinct (map fst (butlast l')) \\<and>\n             i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n        \\<up> (last l' = (k, v) \\<and> distinct (map fst l'))>", "apply (sep_auto (plain)\n    split: nat.split list.split \n    heap: hm_it_adjust_rule\n    simp: take_Suc0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i aa.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         case i of\n                         0 \\<Rightarrow>\n                           case aa of\n                           ([a], ht) \\<Rightarrow> return (a, 0, [], ht)\n                           | (a # b # l, ht) \\<Rightarrow>\n                               return (a, 0, b # l, ht)\n                         | Suc nat \\<Rightarrow>\n                             case aa of\n                             ([a], ht) \\<Rightarrow>\n                               hm_it_adjust nat ht \\<bind>\n                               (\\<lambda>i.\n                                   Array.nth (the_array ht) i \\<bind>\n                                   (\\<lambda>l. return (a, i, rev l, ht)))\n                             | (a # b # l, ht) \\<Rightarrow>\n                                 return (a, Suc nat, b # l, ht)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>", "apply (simp split: prod.split nat.split list.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i aa.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x1 x2.\n                            (x1 = [] \\<longrightarrow>\n                             (i = 0 \\<longrightarrow>\n                              aa = ([], x2) \\<longrightarrow>\n                              <is_hashtable l ht> undefined\n                              <\\<lambda>((k, v), it').\n                                  is_hashtable l ht *\n                                  \\<up>\n                                   (case it' of\n                                    (i, r, ht') \\<Rightarrow>\nht = ht' \\<and>\nbutlast l' = concat (take i l) @ rev r \\<and>\ndistinct (map fst (butlast l')) \\<and>\ni \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n                                  \\<up>\n                                   (last l' = (k, v) \\<and>\n                                    distinct (map fst l'))>) \\<and>\n                             ((\\<exists>x2. i = Suc x2) \\<longrightarrow>\n                              aa = ([], x2) \\<longrightarrow>\n                              <is_hashtable l ht> undefined\n                              <\\<lambda>((k, v), it').\n                                  is_hashtable l ht *\n                                  \\<up>\n                                   (case it' of\n                                    (i, r, ht') \\<Rightarrow>\nht = ht' \\<and>\nbutlast l' = concat (take i l) @ rev r \\<and>\ndistinct (map fst (butlast l')) \\<and>\ni \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n                                  \\<up>\n                                   (last l' = (k, v) \\<and>\n                                    distinct (map fst l'))>)) \\<and>\n                            (\\<forall>a b x22.\n                                (x22 = [] \\<longrightarrow>\n                                 x1 = [(a, b)] \\<longrightarrow>\n                                 (i = 0 \\<longrightarrow>\n                                  aa = ([(a, b)], x2) \\<longrightarrow>\n                                  <is_hashtable l ht>\n                                  return ((a, b), 0, [], x2)\n                                  <\\<lambda>((k, v), it').\nis_hashtable l ht *\n\\<up>\n (case it' of\n  (i, r, ht') \\<Rightarrow>\n    ht = ht' \\<and>\n    butlast l' = concat (take i l) @ rev r \\<and>\n    distinct (map fst (butlast l')) \\<and>\n    i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n\\<up> (last l' = (k, v) \\<and> distinct (map fst l'))>) \\<and>\n                                 (\\<forall>x2a.\n                                     i = Suc x2a \\<longrightarrow>\n                                     aa = ([(a, b)], x2) \\<longrightarrow>\n                                     <is_hashtable l ht>\n                                     hm_it_adjust x2a x2 \\<bind>\n                                     (\\<lambda>i.\n   Array.nth (the_array x2) i \\<bind>\n   (\\<lambda>l. return ((a, b), i, rev l, x2)))\n                                     <\\<lambda>((k, v), it').\n   is_hashtable l ht *\n   \\<up>\n    (case it' of\n     (i, r, ht') \\<Rightarrow>\n       ht = ht' \\<and>\n       butlast l' = concat (take i l) @ rev r \\<and>\n       distinct (map fst (butlast l')) \\<and>\n       i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n   \\<up> (last l' = (k, v) \\<and> distinct (map fst l'))>)) \\<and>\n                                (\\<forall>aaa ba x22a.\n                                    x22 = (aaa, ba) # x22a \\<longrightarrow>\n                                    x1 =\n                                    (a, b) #\n                                    (aaa, ba) # x22a \\<longrightarrow>\n                                    (i = 0 \\<longrightarrow>\n                                     aa =\n                                     ((a, b) # (aaa, ba) # x22a,\nx2) \\<longrightarrow>\n                                     <is_hashtable l ht>\n                                     return\n((a, b), 0, (aaa, ba) # x22a, x2)\n                                     <\\<lambda>((k, v), it').\n   is_hashtable l ht *\n   \\<up>\n    (case it' of\n     (i, r, ht') \\<Rightarrow>\n       ht = ht' \\<and>\n       butlast l' = concat (take i l) @ rev r \\<and>\n       distinct (map fst (butlast l')) \\<and>\n       i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n   \\<up> (last l' = (k, v) \\<and> distinct (map fst l'))>) \\<and>\n                                    (\\<forall>x2a.\n  i = Suc x2a \\<longrightarrow>\n  aa = ((a, b) # (aaa, ba) # x22a, x2) \\<longrightarrow> <is_hashtable l ht>\n  return ((a, b), Suc x2a, (aaa, ba) # x22a, x2)\n  <\\<lambda>((k, v), it').\n      is_hashtable l ht *\n      \\<up>\n       (case it' of\n        (i, r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          butlast l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst (butlast l')) \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n      \\<up> (last l' = (k, v) \\<and> distinct (map fst l'))>)))", "apply (intro allI impI conjI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>i aa x1 x2.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x1 = []; i = 0; aa = ([], x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht> undefined\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 2. \\<And>i aa x1 x2.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x1 = []; \\<exists>x2. i = Suc x2;\n        aa = ([], x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht> undefined\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 3. \\<And>i aa x1 x2 a b x22.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = []; x1 = [(a, b)]; i = 0;\n        aa = ([(a, b)], x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht> return ((a, b), 0, [], x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 4. \\<And>i aa x1 x2 a b x22 x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = []; x1 = [(a, b)]; i = Suc x2a;\n        aa = ([(a, b)], x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         hm_it_adjust x2a x2 \\<bind>\n                         (\\<lambda>i.\n                             Array.nth (the_array x2) i \\<bind>\n                             (\\<lambda>l. return ((a, b), i, rev l, x2)))\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 5. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 6. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>", "apply auto []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>i aa x1 x2.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x1 = []; \\<exists>x2. i = Suc x2;\n        aa = ([], x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht> undefined\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 2. \\<And>i aa x1 x2 a b x22.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = []; x1 = [(a, b)]; i = 0;\n        aa = ([(a, b)], x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht> return ((a, b), 0, [], x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 3. \\<And>i aa x1 x2 a b x22 x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = []; x1 = [(a, b)]; i = Suc x2a;\n        aa = ([(a, b)], x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         hm_it_adjust x2a x2 \\<bind>\n                         (\\<lambda>i.\n                             Array.nth (the_array x2) i \\<bind>\n                             (\\<lambda>l. return ((a, b), i, rev l, x2)))\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 4. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 5. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>", "apply auto []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i aa x1 x2 a b x22.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = []; x1 = [(a, b)]; i = 0;\n        aa = ([(a, b)], x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht> return ((a, b), 0, [], x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 2. \\<And>i aa x1 x2 a b x22 x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = []; x1 = [(a, b)]; i = Suc x2a;\n        aa = ([(a, b)], x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         hm_it_adjust x2a x2 \\<bind>\n                         (\\<lambda>i.\n                             Array.nth (the_array x2) i \\<bind>\n                             (\\<lambda>l. return ((a, b), i, rev l, x2)))\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 3. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 4. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>", "apply sep_auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i aa x1 x2 a b x22 x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = []; x1 = [(a, b)]; i = Suc x2a;\n        aa = ([(a, b)], x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         hm_it_adjust x2a x2 \\<bind>\n                         (\\<lambda>i.\n                             Array.nth (the_array x2) i \\<bind>\n                             (\\<lambda>l. return ((a, b), i, rev l, x2)))\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 2. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 3. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>", "apply (sep_auto (plain)\n    heap: hm_it_adjust_rule)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i aa x1 a b x22 x2a.\n       \\<lbrakk>concat (take (Suc x2a) l) @ rev [(a, b)] \\<noteq> [];\n        l' = concat (take (Suc x2a) l) @ rev [(a, b)] \\<and>\n        distinct (map fst l') \\<and>\n        Suc x2a \\<le> length l \\<and>\n        ([(a, b)] = [] \\<longrightarrow> Suc x2a = 0);\n        it = (Suc x2a, [(a, b)], ht); x22 = []; x1 = [(a, b)]; i = Suc x2a;\n        aa = ([(a, b)], ht)\\<rbrakk>\n       \\<Longrightarrow> x2a < length l\n 2. \\<And>i aa x1 a b x22 x2a x.\n       \\<lbrakk>concat (take (Suc x2a) l) @ rev [(a, b)] \\<noteq> [];\n        l' = concat (take (Suc x2a) l) @ rev [(a, b)] \\<and>\n        distinct (map fst l') \\<and>\n        Suc x2a \\<le> length l \\<and>\n        ([(a, b)] = [] \\<longrightarrow> Suc x2a = 0);\n        it = (Suc x2a, [(a, b)], ht); x22 = []; x1 = [(a, b)]; i = Suc x2a;\n        aa = ([(a, b)], ht)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht *\n                          \\<up>\n                           (x \\<le> x2a \\<and>\n                            concat (take i l) =\n                            concat (take (Suc x) l) \\<and>\n                            (x = 0 \\<or> l ! x \\<noteq> x22))>\n                         Array.nth (the_array ht) x \\<bind>\n                         (\\<lambda>l. return ((a, b), x, rev l, ht))\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast\n                                  (concat (take (Suc x2a) l) @\n                                   rev [(a, b)]) =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct\n                                  (map fst\n                                    (butlast\n(concat (take (Suc x2a) l) @ rev [(a, b)]))) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last\n                                (concat (take (Suc x2a) l) @ rev [(a, b)]) =\n                               (k, v) \\<and>\n                               distinct\n                                (map fst\n                                  (concat (take (Suc x2a) l) @\n                                   rev [(a, b)])))>\n 3. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 4. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i aa x1 a b x22 x2a x.\n       \\<lbrakk>concat (take (Suc x2a) l) @ rev [(a, b)] \\<noteq> [];\n        l' = concat (take (Suc x2a) l) @ rev [(a, b)] \\<and>\n        distinct (map fst l') \\<and>\n        Suc x2a \\<le> length l \\<and>\n        ([(a, b)] = [] \\<longrightarrow> Suc x2a = 0);\n        it = (Suc x2a, [(a, b)], ht); x22 = []; x1 = [(a, b)]; i = Suc x2a;\n        aa = ([(a, b)], ht)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht *\n                          \\<up>\n                           (x \\<le> x2a \\<and>\n                            concat (take i l) =\n                            concat (take (Suc x) l) \\<and>\n                            (x = 0 \\<or> l ! x \\<noteq> x22))>\n                         Array.nth (the_array ht) x \\<bind>\n                         (\\<lambda>l. return ((a, b), x, rev l, ht))\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast\n                                  (concat (take (Suc x2a) l) @\n                                   rev [(a, b)]) =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct\n                                  (map fst\n                                    (butlast\n(concat (take (Suc x2a) l) @ rev [(a, b)]))) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last\n                                (concat (take (Suc x2a) l) @ rev [(a, b)]) =\n                               (k, v) \\<and>\n                               distinct\n                                (map fst\n                                  (concat (take (Suc x2a) l) @\n                                   rev [(a, b)])))>\n 2. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 3. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>", "apply sep_auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x2a a b ab ba xa.\n       \\<lbrakk>Suc x2a \\<le> length l;\n        concat (take (Suc x2a) l) = concat (take (Suc 0) l);\n        distinct (map fst (concat (take (Suc 0) l)));\n        ab \\<notin> fst ` \\<Union> (set ` set (take (Suc 0) l));\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        xa \\<in> set (take (Suc x2a) l); (ab, ba) \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x2a x a b ab ba xa.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        concat (take (Suc x2a) l) = concat (take (Suc x) l);\n        distinct (map fst (concat (take (Suc x) l)));\n        ab \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        xa \\<in> set (take (Suc x2a) l); (ab, ba) \\<in> set xa;\n        l ! x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        concat (take (Suc x2a) l) = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x\n 4. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        concat (take (Suc x2a) l) = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        l ! x = []\\<rbrakk>\n       \\<Longrightarrow> x = 0\n 5. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 6. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>", "apply (cases l, auto) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x2a x a b ab ba xa.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        concat (take (Suc x2a) l) = concat (take (Suc x) l);\n        distinct (map fst (concat (take (Suc x) l)));\n        ab \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        xa \\<in> set (take (Suc x2a) l); (ab, ba) \\<in> set xa;\n        l ! x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        concat (take (Suc x2a) l) = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x\n 3. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        concat (take (Suc x2a) l) = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        l ! x = []\\<rbrakk>\n       \\<Longrightarrow> x = 0\n 4. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 5. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>", "apply (metis SUP_upper fst_image_mp image_mono set_concat)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        concat (take (Suc x2a) l) = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x\n 2. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        concat (take (Suc x2a) l) = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        l ! x = []\\<rbrakk>\n       \\<Longrightarrow> x = 0\n 3. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 4. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>", "apply (drule skip_empty_aux, simp_all) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        \\<forall>i.\n           x < i \\<and> i \\<le> x2a \\<longrightarrow> l ! i = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x\n 2. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        concat (take (Suc x2a) l) = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        l ! x = []\\<rbrakk>\n       \\<Longrightarrow> x = 0\n 3. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 4. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>", "defer"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        concat (take (Suc x2a) l) = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        l ! x = []\\<rbrakk>\n       \\<Longrightarrow> x = 0\n 2. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 3. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 4. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        \\<forall>i.\n           x < i \\<and> i \\<le> x2a \\<longrightarrow> l ! i = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x", "apply (auto simp: concat_take_Suc_app_nth) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i aa x1 x2 a b x22 ab ba x22a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = 0; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), 0, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 2. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 3. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        \\<forall>i.\n           x < i \\<and> i \\<le> x2a \\<longrightarrow> l ! i = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba ab baa x22a.\n       \\<lbrakk>distinct (map fst (rev x22a)); ab \\<noteq> aa;\n        ab \\<notin> fst ` set x22a; aa \\<notin> fst ` set x22a\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((aa, ba), 0, (ab, baa) # x22a, ht)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast\n                                  (rev x22a @ [(ab, baa), (aa, ba)]) =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct\n                                  (map fst\n                                    (butlast\n(rev x22a @ [(ab, baa), (aa, ba)]))) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up> (aa = k \\<and> ba = v)>\n 2. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 3. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        \\<forall>i.\n           x < i \\<and> i \\<le> x2a \\<longrightarrow> l ! i = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x", "apply sep_auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa ba ab baa x22a ae bc.\n       \\<lbrakk>distinct (map fst (rev x22a)); ab \\<noteq> aa;\n        ab \\<notin> fst ` set x22a; aa \\<notin> fst ` set x22a;\n        (ae, bc) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> butlast (rev x22a @ [(ab, baa), (aa, ba)]) =\n                         rev x22a @ [(ab, baa)]\n 2. \\<And>aa ba ab baa x22a ae bc.\n       \\<lbrakk>distinct (map fst (rev x22a)); ab \\<noteq> aa;\n        ab \\<notin> fst ` set x22a; aa \\<notin> fst ` set x22a;\n        (ae, bc) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (butlast (rev x22a @ [(ab, baa), (aa, ba)])))\n 3. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 4. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        \\<forall>i.\n           x < i \\<and> i \\<le> x2a \\<longrightarrow> l ! i = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x", "apply (auto simp: butlast_append) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba ab baa x22a ae bc.\n       \\<lbrakk>distinct (map fst (rev x22a)); ab \\<noteq> aa;\n        ab \\<notin> fst ` set x22a; aa \\<notin> fst ` set x22a;\n        (ae, bc) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (butlast (rev x22a @ [(ab, baa), (aa, ba)])))\n 2. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 3. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        \\<forall>i.\n           x < i \\<and> i \\<le> x2a \\<longrightarrow> l ! i = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x", "apply (auto simp: butlast_append) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i aa x1 x2 a b x22 ab ba x22a x2a.\n       \\<lbrakk>l' \\<noteq> [];\n        case aa of\n        (r, ht') \\<Rightarrow>\n          ht = ht' \\<and>\n          l' = concat (take i l) @ rev r \\<and>\n          distinct (map fst l') \\<and>\n          i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0);\n        it = (i, aa); x22 = (ab, ba) # x22a; x1 = (a, b) # (ab, ba) # x22a;\n        i = Suc x2a; aa = ((a, b) # (ab, ba) # x22a, x2)\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht>\n                         return ((a, b), Suc x2a, (ab, ba) # x22a, x2)\n                         <\\<lambda>((k, v), it').\n                             is_hashtable l ht *\n                             \\<up>\n                              (case it' of\n                               (i, r, ht') \\<Rightarrow>\n                                 ht = ht' \\<and>\n                                 butlast l' =\n                                 concat (take i l) @ rev r \\<and>\n                                 distinct (map fst (butlast l')) \\<and>\n                                 i \\<le> length l \\<and>\n                                 (r = [] \\<longrightarrow> i = 0)) *\n                             \\<up>\n                              (last l' = (k, v) \\<and>\n                               distinct (map fst l'))>\n 2. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        \\<forall>i.\n           x < i \\<and> i \\<le> x2a \\<longrightarrow> l ! i = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x", "apply sep_auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba ab baa x22a x2a ae bc.\n       \\<lbrakk>Suc x2a \\<le> length l;\n        distinct (map fst (concat (take (Suc x2a) l)));\n        distinct (map fst (rev x22a)); ab \\<noteq> aa;\n        ab \\<notin> fst ` set x22a; aa \\<notin> fst ` set x22a;\n        ab \\<notin> fst ` \\<Union> (set ` set (take (Suc x2a) l));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x2a) l));\n        fst ` \\<Union> (set ` set (take (Suc x2a) l)) \\<inter>\n        fst ` set x22a =\n        {};\n        (ae, bc) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> butlast\n                          (concat (take (Suc x2a) l) @\n                           rev x22a @ [(ab, baa), (aa, ba)]) =\n                         concat (take (Suc x2a) l) @ rev x22a @ [(ab, baa)]\n 2. \\<And>aa ba ab baa x22a x2a ae bc.\n       \\<lbrakk>Suc x2a \\<le> length l;\n        distinct (map fst (concat (take (Suc x2a) l)));\n        distinct (map fst (rev x22a)); ab \\<noteq> aa;\n        ab \\<notin> fst ` set x22a; aa \\<notin> fst ` set x22a;\n        ab \\<notin> fst ` \\<Union> (set ` set (take (Suc x2a) l));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x2a) l));\n        fst ` \\<Union> (set ` set (take (Suc x2a) l)) \\<inter>\n        fst ` set x22a =\n        {};\n        (ae, bc) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (butlast\n                              (concat (take (Suc x2a) l) @\n                               rev x22a @ [(ab, baa), (aa, ba)])))\n 3. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        \\<forall>i.\n           x < i \\<and> i \\<le> x2a \\<longrightarrow> l ! i = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x", "apply (auto simp: butlast_append) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba ab baa x22a x2a ae bc.\n       \\<lbrakk>Suc x2a \\<le> length l;\n        distinct (map fst (concat (take (Suc x2a) l)));\n        distinct (map fst (rev x22a)); ab \\<noteq> aa;\n        ab \\<notin> fst ` set x22a; aa \\<notin> fst ` set x22a;\n        ab \\<notin> fst ` \\<Union> (set ` set (take (Suc x2a) l));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x2a) l));\n        fst ` \\<Union> (set ` set (take (Suc x2a) l)) \\<inter>\n        fst ` set x22a =\n        {};\n        (ae, bc) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (butlast\n                              (concat (take (Suc x2a) l) @\n                               rev x22a @ [(ab, baa), (aa, ba)])))\n 2. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        \\<forall>i.\n           x < i \\<and> i \\<le> x2a \\<longrightarrow> l ! i = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x", "apply (auto simp: butlast_append) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa x2a x.\n       \\<lbrakk>Suc x2a \\<le> length l; x \\<le> x2a;\n        x = 0 \\<or> l ! x \\<noteq> [];\n        distinct (map fst (concat (take (Suc x) l)));\n        aa \\<notin> fst ` \\<Union> (set ` set (take (Suc x) l));\n        \\<exists>a b. (a, b) \\<Turnstile> is_hashtable l ht;\n        \\<forall>i.\n           x < i \\<and> i \\<le> x2a \\<longrightarrow> l ! i = []\\<rbrakk>\n       \\<Longrightarrow> concat (take (Suc x) l) = concat (take x l) @ l ! x", "by (metis Ex_list_of_length Suc_leD concat_take_Suc_app_nth le_neq_implies_less le_trans nat.inject not_less_eq_eq)"], ["", "subsubsection \\<open>Main Lemmas\\<close>"], ["", "lemma hm_it_next_rule: \"m'\\<noteq>Map.empty \\<Longrightarrow> \n    <hm_is_it m ht m' it> \n      hm_it_next it \n    <\\<lambda>((k,v),it'). hm_is_it m ht (m' |` (-{k})) it' * \\<up>(m' k = Some v)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<noteq> Map.empty \\<Longrightarrow>\n    <hm_is_it m ht m' it> hm_it_next it\n    <\\<lambda>((k, v), it').\n        hm_is_it m ht (m' |` (- {k})) it' * \\<up> (m' k = Some v)>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m' \\<noteq> Map.empty \\<Longrightarrow>\n    <hm_is_it m ht m' it> hm_it_next it\n    <\\<lambda>((k, v), it').\n        hm_is_it m ht (m' |` (- {k})) it' * \\<up> (m' k = Some v)>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. m' \\<noteq> Map.empty \\<Longrightarrow>\n    <hm_is_it m ht m' it> hm_it_next it\n    <\\<lambda>((k, v), it').\n        hm_is_it m ht (m' |` (- {k})) it' * \\<up> (m' k = Some v)>", "fix ys a"], ["proof (state)\ngoal (1 subgoal):\n 1. m' \\<noteq> Map.empty \\<Longrightarrow>\n    <hm_is_it m ht m' it> hm_it_next it\n    <\\<lambda>((k, v), it').\n        hm_is_it m ht (m' |` (- {k})) it' * \\<up> (m' k = Some v)>", "have aux3: \" \n      \\<lbrakk>distinct (map fst ys); a \\<notin> fst ` set ys\\<rbrakk> \\<Longrightarrow> map_of ys a = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst ys); a \\<notin> fst ` set ys\\<rbrakk>\n    \\<Longrightarrow> map_of ys a = None", "by (induct ys) auto"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst ys); a \\<notin> fst ` set ys\\<rbrakk>\n  \\<Longrightarrow> map_of ys a = None\n\ngoal (1 subgoal):\n 1. m' \\<noteq> Map.empty \\<Longrightarrow>\n    <hm_is_it m ht m' it> hm_it_next it\n    <\\<lambda>((k, v), it').\n        hm_is_it m ht (m' |` (- {k})) it' * \\<up> (m' k = Some v)>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst ?ys2); ?a2 \\<notin> fst ` set ?ys2\\<rbrakk>\n  \\<Longrightarrow> map_of ?ys2 ?a2 = None\n\ngoal (1 subgoal):\n 1. m' \\<noteq> Map.empty \\<Longrightarrow>\n    <hm_is_it m ht m' it> hm_it_next it\n    <\\<lambda>((k, v), it').\n        hm_is_it m ht (m' |` (- {k})) it' * \\<up> (m' k = Some v)>", "note aux3 = this"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst ?ys2); ?a2 \\<notin> fst ` set ?ys2\\<rbrakk>\n  \\<Longrightarrow> map_of ?ys2 ?a2 = None\n\ngoal (1 subgoal):\n 1. m' \\<noteq> Map.empty \\<Longrightarrow>\n    <hm_is_it m ht m' it> hm_it_next it\n    <\\<lambda>((k, v), it').\n        hm_is_it m ht (m' |` (- {k})) it' * \\<up> (m' k = Some v)>", "assume \"m'\\<noteq>Map.empty\""], ["proof (state)\nthis:\n  m' \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. m' \\<noteq> Map.empty \\<Longrightarrow>\n    <hm_is_it m ht m' it> hm_it_next it\n    <\\<lambda>((k, v), it').\n        hm_is_it m ht (m' |` (- {k})) it' * \\<up> (m' k = Some v)>", "thus ?thesis"], ["proof (prove)\nusing this:\n  m' \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. <hm_is_it m ht m' it> hm_it_next it\n    <\\<lambda>((k, v), it').\n        hm_is_it m ht (m' |` (- {k})) it' * \\<up> (m' k = Some v)>", "unfolding hm_is_it_def"], ["proof (prove)\nusing this:\n  m' \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al l'.\n        hm_is_it' l ht l' it *\n        \\<up> (map_of (concat l) = m \\<and> map_of l' = m')>\n    hm_it_next it\n    <\\<lambda>((k, v), it').\n        (\\<exists>\\<^sub>Al l'.\n            hm_is_it' l ht l' it' *\n            \\<up>\n             (map_of (concat l) = m \\<and> map_of l' = m' |` (- {k}))) *\n        \\<up> (m' k = Some v)>", "apply (sep_auto heap: hm_it_next_rule')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l l' a b aa ab ba ac bb.\n       \\<lbrakk>l' \\<noteq> []; m = map_of (concat l); m' = map_of l';\n        last l' = (a, b); distinct (map fst l');\n        (ac, bb) \\<Turnstile>\n        hm_is_it' l ht (butlast l') (aa, ab, ba)\\<rbrakk>\n       \\<Longrightarrow> map_of (butlast l') = map_of l' |` (- {a})\n 2. \\<And>l l' a b aa ab ba.\n       \\<lbrakk>l' \\<noteq> []; m = map_of (concat l); m' = map_of l';\n        last l' = (a, b); distinct (map fst l');\n        \\<exists>h.\n           h \\<Turnstile> hm_is_it' l ht (butlast l') (aa, ab, ba)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> set l'", "apply (case_tac l' rule: rev_cases, \n      auto simp: restrict_map_def aux3 intro!: ext) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l l' a b aa ab ba.\n       \\<lbrakk>l' \\<noteq> []; m = map_of (concat l); m' = map_of l';\n        last l' = (a, b); distinct (map fst l');\n        \\<exists>h.\n           h \\<Turnstile> hm_is_it' l ht (butlast l') (aa, ab, ba)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> set l'", "apply (case_tac l' rule: rev_cases, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <hm_is_it m ht m' it> hm_it_next it\n  <\\<lambda>((k, v), it').\n      hm_is_it m ht (m' |` (- {k})) it' * \\<up> (m' k = Some v)>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hm_it_init_rule:\n  fixes ht :: \"('k::{heap,hashable},'v::heap) hashtable\"\n  shows \"<is_hashmap m ht> hm_it_init ht <hm_is_it m ht m>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashmap m ht> hm_it_init ht <hm_is_it m ht m>\\<^sub>t", "unfolding hm_it_init_def is_hashmap_def is_hashmap'_def \n    hm_is_it_def hm_is_it'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al.\n        is_hashtable l ht *\n        \\<up>\n         (map_of (concat l) =\n          m)> Array.len (the_array ht) \\<bind>\n              (\\<lambda>n.\n                  if n = 0 then return (0, [], ht)\n                  else hm_it_adjust (n - 1) ht \\<bind>\n                       (\\<lambda>i.\n                           Array.nth (the_array ht) i \\<bind>\n                           (\\<lambda>l.\n                               return\n                                (i, l,\n                                 ht)))) <\\<lambda>r.\n      \\<exists>\\<^sub>Al l'.\n         is_hashtable l ht *\n         \\<up>\n          (let (i, r, ht') = r\n           in ht = ht' \\<and>\n              l' = concat (take i l) @ rev r \\<and>\n              distinct (map fst l') \\<and>\n              i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n         \\<up> (map_of (concat l) = m \\<and> map_of l' = m)>\\<^sub>t", "apply (sep_auto simp del: map_of_append heap add: hm_it_adjust_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        l ! x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> x < length l\n 2. \\<And>l x xa.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht * \\<up> (xa = l ! x)>\n                         return (x, xa, ht)\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ala l'.\n                                is_hashtable la ht * true *\n                                \\<up>\n                                 ((case r of\n                                   (i, r, ht') \\<Rightarrow>\n                                     ht = ht' \\<and>\n                                     l' = concat (take i la) @ rev r \\<and>\n                                     distinct (map fst l') \\<and>\n                                     i \\<le> length la \\<and>\n                                     (r = [] \\<longrightarrow>\ni = 0)) \\<and>\n                                  map_of (concat la) =\n                                  map_of (concat (take (Suc x) l)) \\<and>\n                                  map_of l' =\n                                  map_of (concat (take (Suc x) l)))>", "apply (case_tac l, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x xa.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable l ht * \\<up> (xa = l ! x)>\n                         return (x, xa, ht)\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ala l'.\n                                is_hashtable la ht * true *\n                                \\<up>\n                                 ((case r of\n                                   (i, r, ht') \\<Rightarrow>\n                                     ht = ht' \\<and>\n                                     l' = concat (take i la) @ rev r \\<and>\n                                     distinct (map fst l') \\<and>\n                                     i \\<le> length la \\<and>\n                                     (r = [] \\<longrightarrow>\ni = 0)) \\<and>\n                                  map_of (concat la) =\n                                  map_of (concat (take (Suc x) l)) \\<and>\n                                  map_of l' =\n                                  map_of (concat (take (Suc x) l)))>", "apply (sep_auto simp del: concat_eq_Nil_conv map_of_append)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        (a, b) \\<Turnstile> is_hashtable l ht; l ! x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (concat (take x l)))\n 2. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (rev (l ! x)))\n 3. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst ` \\<Union> (set ` set (take x l)) \\<inter>\n                         fst ` set (l ! x) =\n                         {}\n 4. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> length l\n 5. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (take x l) @ rev (l ! x)) =\n                         map_of (concat (take (Suc x) l))", "apply (auto simp: distinct_imp_distinct_take \n    dest: ent_fwd[OF _ is_hashmap'_distinct]) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (rev (l ! x)))\n 2. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst ` \\<Union> (set ` set (take x l)) \\<inter>\n                         fst ` set (l ! x) =\n                         {}\n 3. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> length l\n 4. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (take x l) @ rev (l ! x)) =\n                         map_of (concat (take (Suc x) l))", "apply (drule sym)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; x \\<le> length l - Suc 0;\n        concat l = concat (take (Suc x) l); x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        map_of (concat (take (Suc x) l)) = m\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (rev (l ! x)))\n 2. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst ` \\<Union> (set ` set (take x l)) \\<inter>\n                         fst ` set (l ! x) =\n                         {}\n 3. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> length l\n 4. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (take x l) @ rev (l ! x)) =\n                         map_of (concat (take (Suc x) l))", "apply (auto \n    simp: is_hashtable_def ht_distinct_def rev_map[symmetric]) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> fst ` \\<Union> (set ` set (take x l)) \\<inter>\n                         fst ` set (l ! x) =\n                         {}\n 2. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> length l\n 3. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (take x l) @ rev (l ! x)) =\n                         map_of (concat (take (Suc x) l))", "apply (auto simp: set_conv_nth) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l x a b aa ba ab bb i ia ib.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        fst (l ! i ! ia) = fst (l ! x ! ib); i < x; (aa, ba) = l ! i ! ia;\n        ia < length (l ! i); (ab, bb) = l ! x ! ib;\n        ib < length (l ! x)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> length l\n 3. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (take x l) @ rev (l ! x)) =\n                         map_of (concat (take (Suc x) l))", "apply (hypsubst_thin)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l x a b aa ba ab bb i ia ib.\n       \\<lbrakk>l \\<noteq> []; x \\<le> length l - Suc 0;\n        concat l = concat (take (Suc x) l);\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        fst (l ! i ! ia) = fst (l ! x ! ib); i < x; (aa, ba) = l ! i ! ia;\n        ia < length (l ! i); (ab, bb) = l ! x ! ib;\n        ib < length (l ! x)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> length l\n 3. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (take x l) @ rev (l ! x)) =\n                         map_of (concat (take (Suc x) l))", "apply (drule_tac j=ia in hm_hashcode_eq, simp_all) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l x a b aa ba ab bb i ia ib.\n       \\<lbrakk>l \\<noteq> []; x \\<le> length l - Suc 0;\n        concat l = concat (take (Suc x) l);\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        fst (l ! i ! ia) = fst (l ! x ! ib); i < x; (aa, ba) = l ! i ! ia;\n        (ab, bb) = l ! x ! ib; ib < length (l ! x);\n        bounded_hashcode_nat (length l) (fst (l ! x ! ib)) = i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> length l\n 3. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (take x l) @ rev (l ! x)) =\n                         map_of (concat (take (Suc x) l))", "apply (drule_tac j=ib in hm_hashcode_eq, simp_all) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> length l\n 2. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (take x l) @ rev (l ! x)) =\n                         map_of (concat (take (Suc x) l))", "apply (auto \n    simp: is_hashmap'_def is_hashtable_def ht_distinct_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        Ex (Rep_assn (is_hashtable l ht))\\<rbrakk>\n       \\<Longrightarrow> map_of (concat (take x l) @ rev (l ! x)) =\n                         map_of (concat (take (Suc x) l))", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (l ! x)) ++\n                         map_of (concat (take x l)) =\n                         map_of (concat (take (Suc x) l))", "apply (drule ent_fwd[OF _ is_hashmap'_distinct])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile>\n        is_hashtable l ht * \\<up> (distinct (map fst (concat l)))\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (l ! x)) ++\n                         map_of (concat (take x l)) =\n                         map_of (concat (take (Suc x) l))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        distinct (map fst (concat (take (Suc x) l)))\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (l ! x)) ++\n                         map_of (concat (take x l)) =\n                         map_of (concat (take (Suc x) l))", "apply (subst concat_take_Suc_app_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        distinct (map fst (concat (take (Suc x) l)))\\<rbrakk>\n       \\<Longrightarrow> x < length l\n 2. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        distinct (map fst (concat (take (Suc x) l)))\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (l ! x)) ++\n                         map_of (concat (take x l)) =\n                         map_of (concat (take x l) @ l ! x)", "apply (case_tac l,auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        distinct (map fst (concat (take (Suc x) l)))\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (l ! x)) ++\n                         map_of (concat (take x l)) =\n                         map_of (concat (take x l) @ l ! x)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; m = map_of (concat (take (Suc x) l));\n        x \\<le> length l - Suc 0; concat l = concat (take (Suc x) l);\n        x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        distinct (map fst (concat (take (Suc x) l)))\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (l ! x)) ++\n                         map_of (concat (take x l)) =\n                         map_of (l ! x) ++ map_of (concat (take x l))", "apply (hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; x \\<le> length l - Suc 0;\n        concat l = concat (take (Suc x) l); x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        distinct (map fst (concat (take (Suc x) l)))\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (l ! x)) ++\n                         map_of (concat (take x l)) =\n                         map_of (l ! x) ++ map_of (concat (take x l))", "apply (subst (asm) (2) concat_take_Suc_app_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; x \\<le> length l - Suc 0;\n        concat l = concat (take (Suc x) l); x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht\\<rbrakk>\n       \\<Longrightarrow> x < length l\n 2. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; x \\<le> length l - Suc 0;\n        concat l = concat (take (Suc x) l); x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        distinct (map fst (concat (take x l) @ l ! x))\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (l ! x)) ++\n                         map_of (concat (take x l)) =\n                         map_of (l ! x) ++ map_of (concat (take x l))", "apply (case_tac l,auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; x \\<le> length l - Suc 0;\n        concat l = concat (take (Suc x) l); x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        distinct (map fst (concat (take x l) @ l ! x))\\<rbrakk>\n       \\<Longrightarrow> map_of (rev (l ! x)) ++\n                         map_of (concat (take x l)) =\n                         map_of (l ! x) ++ map_of (concat (take x l))", "apply (subst map_of_rev_distinct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; x \\<le> length l - Suc 0;\n        concat l = concat (take (Suc x) l); x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        distinct (map fst (concat (take x l) @ l ! x))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (l ! x))\n 2. \\<And>l x a b.\n       \\<lbrakk>l \\<noteq> []; x \\<le> length l - Suc 0;\n        concat l = concat (take (Suc x) l); x = 0 \\<or> l ! x \\<noteq> [];\n        (a, b) \\<Turnstile> is_hashtable l ht;\n        distinct (map fst (concat (take x l) @ l ! x))\\<rbrakk>\n       \\<Longrightarrow> map_of (l ! x) ++ map_of (concat (take x l)) =\n                         map_of (l ! x) ++ map_of (concat (take x l))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_it_has_next_rule:\n  \"<hm_is_it m ht m' it> hm_it_has_next it \n    <\\<lambda>r. hm_is_it m ht m' it * \\<up>(r\\<longleftrightarrow>m'\\<noteq>Map.empty)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <hm_is_it m ht m' it> hm_it_has_next it\n    <\\<lambda>r. hm_is_it m ht m' it * \\<up> (r = (m' \\<noteq> Map.empty))>", "unfolding is_hashmap'_def hm_is_it_def hm_is_it'_def hm_it_has_next_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al l'.\n        is_hashtable l ht *\n        \\<up>\n         (let (i, r, ht') = it\n          in ht = ht' \\<and>\n             l' = concat (take i l) @ rev r \\<and>\n             distinct (map fst l') \\<and>\n             i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n        \\<up> (map_of (concat l) = m \\<and> map_of l' = m')>\n    return\n     (case it of (0, [], x) \\<Rightarrow> False\n      | (0, aa # list, x) \\<Rightarrow> True\n      | (Suc nat, b) \\<Rightarrow> True)\n    <\\<lambda>r.\n        (\\<exists>\\<^sub>Al l'.\n            is_hashtable l ht *\n            \\<up>\n             (let (i, r, ht') = it\n              in ht = ht' \\<and>\n                 l' = concat (take i l) @ rev r \\<and>\n                 distinct (map fst l') \\<and>\n                 i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n            \\<up> (map_of (concat l) = m \\<and> map_of l' = m')) *\n        \\<up> (r = (m' \\<noteq> Map.empty))>", "by (sep_auto split: nat.split list.split)"], ["", "lemma hm_it_finish: \"hm_is_it m p m' it \\<Longrightarrow>\\<^sub>A is_hashmap m p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_is_it m p m' it \\<Longrightarrow>\\<^sub>A is_hashmap m p", "unfolding hm_is_it_def hm_is_it'_def is_hashmap_def is_hashmap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>Al l'.\n       is_hashtable l p *\n       \\<up>\n        (let (i, r, ht') = it\n         in p = ht' \\<and>\n            l' = concat (take i l) @ rev r \\<and>\n            distinct (map fst l') \\<and>\n            i \\<le> length l \\<and> (r = [] \\<longrightarrow> i = 0)) *\n       \\<up>\n        (map_of (concat l) = m \\<and>\n         map_of l' = m') \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Al. is_hashtable l p * \\<up> (map_of (concat l) = m)", "by sep_auto"], ["", "end"]]}