{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Examples/Hash_Set_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma ne_some_unit_eq: \"x\\<noteq>Some () \\<longleftrightarrow> x=None\"", "lemma map_of_set_simps[simp]:\n  \"dom (map_of_set s) = s\"\n  \"map_of_set (dom m) = m\"\n  \"map_of_set {} = Map.empty\"\n  \"map_of_set s x = None \\<longleftrightarrow> x\\<notin>s\"\n  \"map_of_set s x = Some u \\<longleftrightarrow> x\\<in>s\"\n  \"map_of_set s (x\\<mapsto>()) = map_of_set (insert x s)\"\n  \"(map_of_set s) |` (-{x}) = map_of_set (s -{x})\"", "lemma map_of_set_eq':\n  \"map_of_set a = map_of_set b \\<longleftrightarrow> a=b\"", "lemma map_of_set_eq[simp]:\n  \"map_of_set s = m \\<longleftrightarrow> dom m=s\"", "lemma hs_set_impl: \"imp_set is_hashset\"", "lemma hs_new_impl: \"imp_set_empty is_hashset hs_new\"", "lemma hs_memb_impl: \"imp_set_memb is_hashset hs_memb\"", "lemma hs_ins_impl: \"imp_set_ins is_hashset hs_ins\"", "lemma hs_delete_impl: \"imp_set_delete is_hashset hs_delete\"", "lemma hs_is_empty_impl: \"imp_set_is_empty is_hashset hs_isEmpty\"", "lemma hs_size_impl: \"imp_set_size is_hashset hs_size\"", "lemma hs_iterate_impl: \"imp_set_iterate \n  is_hashset hs_is_it hs_it_init hs_it_has_next hs_it_next\""], "translations": [["", "lemma ne_some_unit_eq: \"x\\<noteq>Some () \\<longleftrightarrow> x=None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<noteq> Some ()) = (x = None)", "by (cases x) auto"], ["", "lemma map_of_set_simps[simp]:\n  \"dom (map_of_set s) = s\"\n  \"map_of_set (dom m) = m\"\n  \"map_of_set {} = Map.empty\"\n  \"map_of_set s x = None \\<longleftrightarrow> x\\<notin>s\"\n  \"map_of_set s x = Some u \\<longleftrightarrow> x\\<in>s\"\n  \"map_of_set s (x\\<mapsto>()) = map_of_set (insert x s)\"\n  \"(map_of_set s) |` (-{x}) = map_of_set (s -{x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dom (map_of_set s) = s &&&\n     map_of_set (dom m) = m &&& map_of_set {} = Map.empty) &&&\n    ((map_of_set s x = None) = (x \\<notin> s) &&&\n     (map_of_set s x = Some u) = (x \\<in> s)) &&&\n    map_of_set s(x \\<mapsto> ()) = map_of_set (insert x s) &&&\n    map_of_set s |` (- {x}) = map_of_set (s - {x})", "apply (auto simp: map_of_set_def \n    dom_def ne_some_unit_eq restrict_map_def \n    intro!: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_set_eq':\n  \"map_of_set a = map_of_set b \\<longleftrightarrow> a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of_set a = map_of_set b) = (a = b)", "apply (auto simp: map_of_set_def[abs_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(\\<lambda>x. if x \\<in> a then Some () else None) =\n                (\\<lambda>x. if x \\<in> b then Some () else None);\n        x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b\n 2. \\<And>x.\n       \\<lbrakk>(\\<lambda>x. if x \\<in> a then Some () else None) =\n                (\\<lambda>x. if x \\<in> b then Some () else None);\n        x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> a", "apply (metis option.simps(3))+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_set_eq[simp]:\n  \"map_of_set s = m \\<longleftrightarrow> dom m=s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of_set s = m) = (dom m = s)", "apply (auto \n    simp: dom_def map_of_set_def[abs_def] ne_some_unit_eq \n    intro!: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m = (\\<lambda>x. if x \\<in> s then Some () else None);\n        (if x \\<in> s then Some () else None) = Some ()\\<rbrakk>\n       \\<Longrightarrow> x \\<in> s", "apply (metis option.simps(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Main Definitions\\<close>"], ["", "type_synonym 'a hashset = \"('a,unit) hashtable\""], ["", "definition \"is_hashset s ht \\<equiv> is_hashmap (map_of_set s) ht\""], ["", "lemma hs_set_impl: \"imp_set is_hashset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set is_hashset", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_hashset", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_hashset a p * F \\<and>\\<^sub>A\n       is_hashset a' p * F' \\<Longrightarrow>\n       a = a'", "unfolding is_hashset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_hashmap (map_of_set a) p * F \\<and>\\<^sub>A\n       is_hashmap (map_of_set a') p * F' \\<Longrightarrow>\n       a = a'", "apply (subst map_of_set_eq'[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_hashmap (map_of_set a) p * F \\<and>\\<^sub>A\n       is_hashmap (map_of_set a') p * F' \\<Longrightarrow>\n       map_of_set a = map_of_set a'", "by (metis preciseD[OF is_hashmap_prec])"], ["", "interpretation hs: imp_set is_hashset"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set is_hashset", "by (rule hs_set_impl)"], ["", "definition hs_new :: \"'a::{heap,hashable} hashset Heap\" \n  where \"hs_new = hm_new\""], ["", "lemma hs_new_impl: \"imp_set_empty is_hashset hs_new\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_empty is_hashset hs_new", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> hs_new <is_hashset {}>\\<^sub>t", "apply (sep_auto heap: hm_new_rule simp: is_hashset_def hs_new_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hs: imp_set_empty is_hashset hs_new"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_empty is_hashset hs_new", "by (rule hs_new_impl)"], ["", "definition hs_memb:: \"'a::{heap,hashable} \\<Rightarrow> 'a hashset \\<Rightarrow> bool Heap\" \n  where \"hs_memb x s \\<equiv> do { \n  r\\<leftarrow>hm_lookup x s; \n  return (case r of Some _ \\<Rightarrow> True | None \\<Rightarrow> False)  \n}\""], ["", "lemma hs_memb_impl: \"imp_set_memb is_hashset hs_memb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_memb is_hashset hs_memb", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p a.\n       <is_hashset s\n         p> hs_memb a\n             p <\\<lambda>r.\n                   is_hashset s p * \\<up> (r = (a \\<in> s))>\\<^sub>t", "unfolding hs_memb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p a.\n       <is_hashset s\n         p> hm_lookup a p \\<bind>\n            (\\<lambda>r.\n                return\n                 (case r of None \\<Rightarrow> False\n                  | Some x \\<Rightarrow>\n                      True)) <\\<lambda>r.\n                                 is_hashset s p *\n                                 \\<up> (r = (a \\<in> s))>\\<^sub>t", "apply (sep_auto \n    heap: hm_lookup_rule \n    simp: is_hashset_def split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hs: imp_set_memb is_hashset hs_memb"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_memb is_hashset hs_memb", "by (rule hs_memb_impl)"], ["", "definition hs_ins:: \"'a::{heap,hashable} \\<Rightarrow> 'a hashset \\<Rightarrow> 'a hashset Heap\"\n  where \"hs_ins x ht \\<equiv> hm_update x () ht\""], ["", "lemma hs_ins_impl: \"imp_set_ins is_hashset hs_ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_ins is_hashset hs_ins", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p a.\n       <is_hashset s p> hs_ins a p <is_hashset (insert a s)>\\<^sub>t", "apply (sep_auto heap: hm_update_rule simp: hs_ins_def is_hashset_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hs: imp_set_ins is_hashset hs_ins"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_ins is_hashset hs_ins", "by (rule hs_ins_impl)"], ["", "definition hs_delete\n  :: \"'a::{heap,hashable} \\<Rightarrow> 'a hashset \\<Rightarrow> 'a hashset Heap\"\n  where \"hs_delete x ht \\<equiv> hm_delete x ht\""], ["", "lemma hs_delete_impl: \"imp_set_delete is_hashset hs_delete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_delete is_hashset hs_delete", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p a.\n       <is_hashset s p> hs_delete a p <is_hashset (s - {a})>\\<^sub>t", "apply (sep_auto heap: hm_delete_rule simp: is_hashset_def hs_delete_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hs: imp_set_delete is_hashset hs_delete"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_delete is_hashset hs_delete", "by (rule hs_delete_impl)"], ["", "definition \"hs_isEmpty == hm_isEmpty\""], ["", "lemma hs_is_empty_impl: \"imp_set_is_empty is_hashset hs_isEmpty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_is_empty is_hashset hs_isEmpty", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p.\n       <is_hashset s\n         p> hs_isEmpty\n             p <\\<lambda>r. is_hashset s p * \\<up> (r = (s = {}))>\\<^sub>t", "apply (sep_auto heap: hm_isEmpty_rule simp: is_hashset_def hs_isEmpty_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hs: imp_set_is_empty is_hashset hs_isEmpty"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_is_empty is_hashset hs_isEmpty", "by (rule hs_is_empty_impl)"], ["", "definition \"hs_size == hm_size\""], ["", "lemma hs_size_impl: \"imp_set_size is_hashset hs_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_size is_hashset hs_size", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p.\n       <is_hashset s\n         p> hs_size\n             p <\\<lambda>r. is_hashset s p * \\<up> (r = card s)>\\<^sub>t", "apply (sep_auto heap: hm_size_rule simp: is_hashset_def hs_size_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hs: imp_set_size is_hashset hs_size"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_size is_hashset hs_size", "by (rule hs_size_impl)"], ["", "type_synonym ('a) hs_it = \"('a,unit) hm_it\""], ["", "definition \"hs_is_it s hs its it \n  \\<equiv> hm_is_it (map_of_set s) hs (map_of_set its) it\""], ["", "definition hs_it_init :: \"('a::{heap,hashable}) hashset \\<Rightarrow> 'a hs_it Heap\"\n  where \"hs_it_init \\<equiv> hm_it_init\""], ["", "definition hs_it_has_next :: \"('a::{heap,hashable}) hs_it \\<Rightarrow> bool Heap\"\n  where \"hs_it_has_next \\<equiv> hm_it_has_next\""], ["", "definition hs_it_next \n  :: \"('a::{heap,hashable}) hs_it \\<Rightarrow> ('a\\<times>'a hs_it) Heap\"\n  where \n  \"hs_it_next it \\<equiv> do {\n    ((x,_),it) \\<leftarrow> hm_it_next it;\n    return (x,it)\n  }\""], ["", "lemma hs_iterate_impl: \"imp_set_iterate \n  is_hashset hs_is_it hs_it_init hs_it_has_next hs_it_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_iterate is_hashset hs_is_it hs_it_init hs_it_has_next hs_it_next", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s p. <is_hashset s p> hs_it_init p <hs_is_it s p s>\\<^sub>t\n 2. \\<And>s' s p it.\n       s' \\<noteq> {} \\<Longrightarrow>\n       <hs_is_it s p s' it> hs_it_next it\n       <\\<lambda>(a, it'). hs_is_it s p (s' - {a}) it' * \\<up> (a \\<in> s')>\n 3. \\<And>s p s' it.\n       <hs_is_it s p s' it> hs_it_has_next it\n       <\\<lambda>r. hs_is_it s p s' it * \\<up> (r = (s' \\<noteq> {}))>\n 4. \\<And>s p s' it.\n       hs_is_it s p s' it \\<Longrightarrow>\\<^sub>A is_hashset s p * true", "unfolding hs_it_init_def hs_it_next_def hs_it_has_next_def \n    hs_is_it_def is_hashset_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s p.\n       <is_hashmap (map_of_set s)\n         p> hm_it_init p <hm_is_it (map_of_set s) p (map_of_set s)>\\<^sub>t\n 2. \\<And>s' s p it.\n       s' \\<noteq> {} \\<Longrightarrow>\n       <hm_is_it (map_of_set s) p (map_of_set s') it>\n       hm_it_next it \\<bind> (\\<lambda>((x, uu_), it). return (x, it))\n       <\\<lambda>(a, it').\n           hm_is_it (map_of_set s) p (map_of_set (s' - {a})) it' *\n           \\<up> (a \\<in> s')>\n 3. \\<And>s p s' it.\n       <hm_is_it (map_of_set s) p (map_of_set s') it> hm_it_has_next it\n       <\\<lambda>r.\n           hm_is_it (map_of_set s) p (map_of_set s') it *\n           \\<up> (r = (s' \\<noteq> {}))>\n 4. \\<And>s p s' it.\n       hm_is_it (map_of_set s) p (map_of_set s')\n        it \\<Longrightarrow>\\<^sub>A\n       is_hashmap (map_of_set s) p * true", "apply sep_auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s' s p it.\n       s' \\<noteq> {} \\<Longrightarrow>\n       <hm_is_it (map_of_set s) p (map_of_set s') it>\n       hm_it_next it \\<bind> (\\<lambda>((x, uu_), it). return (x, it))\n       <\\<lambda>(a, it').\n           hm_is_it (map_of_set s) p (map_of_set (s' - {a})) it' *\n           \\<up> (a \\<in> s')>\n 2. \\<And>s p s' it.\n       <hm_is_it (map_of_set s) p (map_of_set s') it> hm_it_has_next it\n       <\\<lambda>r.\n           hm_is_it (map_of_set s) p (map_of_set s') it *\n           \\<up> (r = (s' \\<noteq> {}))>\n 3. \\<And>s p s' it.\n       hm_is_it (map_of_set s) p (map_of_set s')\n        it \\<Longrightarrow>\\<^sub>A\n       is_hashmap (map_of_set s) p * true", "apply sep_auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s p s' it.\n       <hm_is_it (map_of_set s) p (map_of_set s') it> hm_it_has_next it\n       <\\<lambda>r.\n           hm_is_it (map_of_set s) p (map_of_set s') it *\n           \\<up> (r = (s' \\<noteq> {}))>\n 2. \\<And>s p s' it.\n       hm_is_it (map_of_set s) p (map_of_set s')\n        it \\<Longrightarrow>\\<^sub>A\n       is_hashmap (map_of_set s) p * true", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p s' it.\n       hm_is_it (map_of_set s) p (map_of_set s')\n        it \\<Longrightarrow>\\<^sub>A\n       is_hashmap (map_of_set s) p * true", "apply (sep_auto eintros: hm.quit_iteration)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hs: imp_set_iterate \n  is_hashset hs_is_it hs_it_init hs_it_has_next hs_it_next"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_iterate is_hashset hs_is_it hs_it_init hs_it_has_next hs_it_next", "by (rule hs_iterate_impl)"], ["", "export_code hs_new hs_memb hs_ins hs_delete hs_isEmpty hs_size \n  hs_it_init hs_it_has_next hs_it_next\n  checking SML_imp"], ["", "end"]]}