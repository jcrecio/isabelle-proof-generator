{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Examples/To_List_GA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma to_list_ga_rec_rule:\n    assumes \"imp_set_iterate is_set is_it it_init it_has_next it_next\"\n    assumes \"imp_list_prepend is_list l_prepend\"\n    assumes FIN: \"finite it\"\n    shows \"\n    < is_it s si it iti * is_list l li > \n      to_list_ga_rec it_has_next it_next l_prepend iti li\n    < \\<lambda>r. \\<exists>\\<^sub>Al'. is_set s si \n      * is_list l' r\n      * \\<up>(set l' = set l \\<union> it) >\\<^sub>t\"", "lemma to_list_ga_rule:\n    assumes IT: \"imp_set_iterate is_set is_it it_init it_has_next it_next\"\n    assumes EM: \"imp_list_empty is_list l_empty\"\n    assumes PREP: \"imp_list_prepend is_list l_prepend\"\n    assumes FIN: \"finite s\"\n    shows \"\n    <is_set s si>\n    to_list_ga it_init it_has_next it_next\n      l_empty l_prepend si\n    <\\<lambda>r. \\<exists>\\<^sub>Al. is_set s si * is_list l r * true * \\<up>(set l = s)>\"", "lemmas hs_to_ol_rule[sep_heap_rules] =\n    to_list_ga_rule[OF hs_iterate_impl os_empty_impl os_prepend_impl,\n    folded hs_to_ol_def]"], "translations": [["", "lemma to_list_ga_rec_rule:\n    assumes \"imp_set_iterate is_set is_it it_init it_has_next it_next\"\n    assumes \"imp_list_prepend is_list l_prepend\"\n    assumes FIN: \"finite it\"\n    shows \"\n    < is_it s si it iti * is_list l li > \n      to_list_ga_rec it_has_next it_next l_prepend iti li\n    < \\<lambda>r. \\<exists>\\<^sub>Al'. is_set s si \n      * is_list l' r\n      * \\<up>(set l' = set l \\<union> it) >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> to_list_ga_rec it_has_next it_next l_prepend iti\n           li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set s si * is_list l' r *\n                     \\<up> (set l' = set l \\<union> it)>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> to_list_ga_rec it_has_next it_next l_prepend iti\n           li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set s si * is_list l' r *\n                     \\<up> (set l' = set l \\<union> it)>\\<^sub>t", "interpret imp_set_iterate is_set is_it it_init it_has_next it_next\n      + imp_list_prepend is_list l_prepend"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_iterate is_set is_it it_init it_has_next it_next &&&\n    imp_list_prepend is_list l_prepend", "by fact+"], ["proof (state)\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> to_list_ga_rec it_has_next it_next l_prepend iti\n           li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set s si * is_list l' r *\n                     \\<up> (set l' = set l \\<union> it)>\\<^sub>t", "from FIN"], ["proof (chain)\npicking this:\n  finite it", "show ?thesis"], ["proof (prove)\nusing this:\n  finite it\n\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> to_list_ga_rec it_has_next it_next l_prepend iti\n           li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set s si * is_list l' r *\n                     \\<up> (set l' = set l \\<union> it)>\\<^sub>t", "proof (induction arbitrary: l li iti rule: finite_psubset_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A l li iti.\n       \\<lbrakk>finite A;\n        \\<And>B l li iti.\n           B \\<subset> A \\<Longrightarrow>\n           <is_it s si B iti *\n            is_list l\n             li> to_list_ga_rec it_has_next it_next l_prepend iti\n                  li <\\<lambda>r.\n                         \\<exists>\\<^sub>Al'.\n                            is_set s si * is_list l' r *\n                            \\<up>\n                             (set l' = set l \\<union> B)>\\<^sub>t\\<rbrakk>\n       \\<Longrightarrow> <is_it s si A iti *\n                          is_list l\n                           li> to_list_ga_rec it_has_next it_next l_prepend\n                                iti\n                                li <\\<lambda>r.\n \\<exists>\\<^sub>Al'.\n    is_set s si * is_list l' r * \\<up> (set l' = set l \\<union> A)>\\<^sub>t", "case (psubset it)"], ["proof (state)\nthis:\n  finite it\n  ?B \\<subset> it \\<Longrightarrow>\n  <is_it s si ?B ?iti *\n   is_list ?l\n    ?li> to_list_ga_rec it_has_next it_next l_prepend ?iti\n          ?li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set s si * is_list l' r *\n                     \\<up> (set l' = set ?l \\<union> ?B)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>A l li iti.\n       \\<lbrakk>finite A;\n        \\<And>B l li iti.\n           B \\<subset> A \\<Longrightarrow>\n           <is_it s si B iti *\n            is_list l\n             li> to_list_ga_rec it_has_next it_next l_prepend iti\n                  li <\\<lambda>r.\n                         \\<exists>\\<^sub>Al'.\n                            is_set s si * is_list l' r *\n                            \\<up>\n                             (set l' = set l \\<union> B)>\\<^sub>t\\<rbrakk>\n       \\<Longrightarrow> <is_it s si A iti *\n                          is_list l\n                           li> to_list_ga_rec it_has_next it_next l_prepend\n                                iti\n                                li <\\<lambda>r.\n \\<exists>\\<^sub>Al'.\n    is_set s si * is_list l' r * \\<up> (set l' = set l \\<union> A)>\\<^sub>t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> to_list_ga_rec it_has_next it_next l_prepend iti\n           li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set s si * is_list l' r *\n                     \\<up> (set l' = set l \\<union> it)>\\<^sub>t", "apply (subst to_list_ga_rec.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> it_has_next iti \\<bind>\n          (\\<lambda>b.\n              if b\n              then it_next iti \\<bind>\n                   (\\<lambda>(x, it).\n                       l_prepend x li \\<bind>\n                       to_list_ga_rec it_has_next it_next l_prepend it)\n              else return\n                    li) <\\<lambda>r.\n                            \\<exists>\\<^sub>Al'.\n                               is_set s si * is_list l' r *\n                               \\<up> (set l' = set l \\<union> it)>\\<^sub>t", "apply (sep_auto heap: psubset.IH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. it = {} \\<Longrightarrow>\n    is_it s si {} iti * is_list l li \\<Longrightarrow>\\<^sub>A\n    is_set s si * is_list l li * true", "apply (rule ent_frame_fwd[OF quit_iteration])"], ["proof (prove)\ngoal (2 subgoals):\n 1. it = {} \\<Longrightarrow>\n    is_it s si {} iti * is_list l li \\<Longrightarrow>\\<^sub>A\n    is_it ?s155 ?p155 ?s'155 ?it155 * ?F154\n 2. it = {} \\<Longrightarrow>\n    is_set ?s155 ?p155 * true * ?F154 \\<Longrightarrow>\\<^sub>A\n    is_set s si * is_list l li * true", "apply frame_inference"], ["proof (prove)\ngoal (1 subgoal):\n 1. it = {} \\<Longrightarrow>\n    is_set s si * true * is_list l li \\<Longrightarrow>\\<^sub>A\n    is_set s si * is_list l li * true", "apply solve_entails"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <is_it s si it iti *\n   is_list l\n    li> to_list_ga_rec it_has_next it_next l_prepend iti\n         li <\\<lambda>r.\n                \\<exists>\\<^sub>Al'.\n                   is_set s si * is_list l' r *\n                   \\<up> (set l' = set l \\<union> it)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <is_it s si it iti *\n   is_list l\n    li> to_list_ga_rec it_has_next it_next l_prepend iti\n         li <\\<lambda>r.\n                \\<exists>\\<^sub>Al'.\n                   is_set s si * is_list l' r *\n                   \\<up> (set l' = set l \\<union> it)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"to_list_ga \n    it_init it_has_next it_next\n    l_empty l_prepend s \n    \\<equiv> do {\n      it \\<leftarrow> it_init s;\n      l \\<leftarrow> l_empty;\n      l \\<leftarrow> to_list_ga_rec it_has_next it_next l_prepend it l;\n      return l\n    }\""], ["", "lemma to_list_ga_rule:\n    assumes IT: \"imp_set_iterate is_set is_it it_init it_has_next it_next\"\n    assumes EM: \"imp_list_empty is_list l_empty\"\n    assumes PREP: \"imp_list_prepend is_list l_prepend\"\n    assumes FIN: \"finite s\"\n    shows \"\n    <is_set s si>\n    to_list_ga it_init it_has_next it_next\n      l_empty l_prepend si\n    <\\<lambda>r. \\<exists>\\<^sub>Al. is_set s si * is_list l r * true * \\<up>(set l = s)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_set s si>\n    to_list_ga it_init it_has_next it_next l_empty l_prepend si\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true * \\<up> (set l = s)>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <is_set s si>\n    to_list_ga it_init it_has_next it_next l_empty l_prepend si\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true * \\<up> (set l = s)>", "interpret imp_list_empty is_list l_empty +\n      imp_set_iterate is_set is_it it_init it_has_next it_next"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_empty is_list l_empty &&&\n    imp_set_iterate is_set is_it it_init it_has_next it_next", "by fact+"], ["proof (state)\ngoal (1 subgoal):\n 1. <is_set s si>\n    to_list_ga it_init it_has_next it_next l_empty l_prepend si\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true * \\<up> (set l = s)>", "note [sep_heap_rules] = to_list_ga_rec_rule[OF IT PREP]"], ["proof (state)\nthis:\n  finite ?it \\<Longrightarrow>\n  <is_it ?s ?si ?it ?iti *\n   is_list ?l\n    ?li> to_list_ga_rec it_has_next it_next l_prepend ?iti\n          ?li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set ?s ?si * is_list l' r *\n                     \\<up> (set l' = set ?l \\<union> ?it)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. <is_set s si>\n    to_list_ga it_init it_has_next it_next l_empty l_prepend si\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true * \\<up> (set l = s)>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_set s si>\n    to_list_ga it_init it_has_next it_next l_empty l_prepend si\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true * \\<up> (set l = s)>", "unfolding to_list_ga_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_set s si>\n    it_init si \\<bind>\n    (\\<lambda>it.\n        l_empty \\<bind>\n        (\\<lambda>l.\n            to_list_ga_rec it_has_next it_next l_prepend it l \\<bind>\n            return))\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true * \\<up> (set l = s)>", "by (sep_auto simp: FIN)"], ["proof (state)\nthis:\n  <is_set s si> to_list_ga it_init it_has_next it_next l_empty l_prepend si\n  <\\<lambda>r.\n      \\<exists>\\<^sub>Al.\n         is_set s si * is_list l r * true * \\<up> (set l = s)>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Sample Instantiation for hash set and open list\\<close>"], ["", "definition \"hs_to_ol \n    \\<equiv> to_list_ga hs_it_init hs_it_has_next hs_it_next\n        os_empty os_prepend\""], ["", "lemmas hs_to_ol_rule[sep_heap_rules] =\n    to_list_ga_rule[OF hs_iterate_impl os_empty_impl os_prepend_impl,\n    folded hs_to_ol_def]"], ["", "export_code hs_to_ol checking SML_imp"], ["", "end"]]}