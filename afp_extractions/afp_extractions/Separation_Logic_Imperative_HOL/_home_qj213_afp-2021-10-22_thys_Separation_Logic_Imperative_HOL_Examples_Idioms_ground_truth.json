{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Examples/Idioms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma \"<emp> \n    test \n    <\\<lambda>(l1,l2). cs_list [''a'',''b''] l1 \n      * cs_list [''c'',''e'',''d''] l2>\\<^sub>t\"", "lemma complete_ht_rehash: \n    \"<is_hashtable l ht> ht_rehash ht \n    <\\<lambda>r. is_hashtable l ht * is_hashtable (ls_rehash l) r>\"", "lemma\n    \"<os_list xs n> os_prepend x n <os_list (x # xs)>\"", "lemma\n    \"<os_list xs n> os_prepend x n <os_list (x # xs)>\"", "lemma cs_append_rule: \n    \"<cs_list l p> cs_append x p <cs_list (l@[x])>\"", "lemma ins_from_list_correct:\n    \"<is_hashset s hs> ins_from_list l hs <is_hashset (s\\<union>set l)>\\<^sub>t\"", "lemma os_sum'_rule: \n    \"<os_is_it l p l' it> \n    os_sum' it s \n    <\\<lambda>r. os_list l p * \\<up>(r = s + sum_list l')>\\<^sub>t\"", "lemma lseg_prec3: \n    \"\\<forall>q q'. h \\<Turnstile> (lseg l p q * F1) \\<and>\\<^sub>A (lseg l p q' * F2) \\<longrightarrow> q=q'\""], "translations": [["", "lemma \"<emp> \n    test \n    <\\<lambda>(l1,l2). cs_list [''a'',''b''] l1 \n      * cs_list [''c'',''e'',''d''] l2>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> test <\\<lambda>r.\n                   case r of\n                   (l1, l2) \\<Rightarrow>\n                     cs_list [''a'', ''b''] l1 *\n                     cs_list [''c'', ''e'', ''d''] l2>\\<^sub>t", "unfolding test_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> cs_empty \\<bind>\n          (\\<lambda>l1.\n              cs_empty \\<bind>\n              (\\<lambda>l2.\n                  cs_append ''a'' l1 \\<bind>\n                  (\\<lambda>l1.\n                      cs_append ''c'' l2 \\<bind>\n                      (\\<lambda>l2.\n                          cs_append ''b'' l1 \\<bind>\n                          (\\<lambda>l1.\n                              cs_append ''e'' l2 \\<bind>\n                              (\\<lambda>l2.\n                                  cs_prepend ''d'' l2 \\<bind>\n                                  (\\<lambda>l2.\ncs_rotate l2 \\<bind>\n(\\<lambda>l2.\n    return\n     (l1,\n      l2))))))))) <\\<lambda>r.\n                      case r of\n                      (l1, l2) \\<Rightarrow>\n                        cs_list [''a'', ''b''] l1 *\n                        cs_list [''c'', ''e'', ''d''] l2>\\<^sub>t", "apply (sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\\<open>sep_auto\\<close> accepts all the section-options of the classical\n    reasoner and simplifier, e.g., \\<open>simp add/del:\\<close>, \\<open>intro:\\<close>.\n    Moreover, it has some more section options, the most useful being \n    \\<open>heap add/del:\\<close> to add or remove Hoare-rules that are applied\n    with frame-inference. A complete documentation of the accepted options can\n    be found in Section~\\ref{sec:auto:overview}.\n\\<close>"], ["", "text \\<open>As a typical example, consider the following proof:\\<close>"], ["", "lemma complete_ht_rehash: \n    \"<is_hashtable l ht> ht_rehash ht \n    <\\<lambda>r. is_hashtable l ht * is_hashtable (ls_rehash l) r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_rehash ht\n    <\\<lambda>r. is_hashtable l ht * is_hashtable (ls_rehash l) r>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_rehash ht\n    <\\<lambda>r. is_hashtable l ht * is_hashtable (ls_rehash l) r>", "have LEN: \" l \\<noteq> [] \\<Longrightarrow> Suc 0 < 2 * length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow> Suc 0 < 2 * length l", "by (cases l) auto"], ["proof (state)\nthis:\n  l \\<noteq> [] \\<Longrightarrow> Suc 0 < 2 * length l\n\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_rehash ht\n    <\\<lambda>r. is_hashtable l ht * is_hashtable (ls_rehash l) r>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_rehash ht\n    <\\<lambda>r. is_hashtable l ht * is_hashtable (ls_rehash l) r>", "apply (rule cons_pre_rule[OF ht_imp_len])"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht * \\<up> (0 < length l)> ht_rehash ht\n    <\\<lambda>x. is_hashtable l ht * is_hashtable (ls_rehash l) x>", "unfolding ht_rehash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht * \\<up> (0 < length l)>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>n. ht_new_sz (2 * n) \\<bind> ht_copy n ht)\n    <\\<lambda>x. is_hashtable l ht * is_hashtable (ls_rehash l) x>", "apply (sep_auto \n        heap: complete_ht_new_sz complete_ht_copy\n        simp: ls_rehash_def LEN\n      ) \\<comment> \\<open>Here we add a heap-rule, and some simp-rules\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <is_hashtable l ht> ht_rehash ht\n  <\\<lambda>r. is_hashtable l ht * is_hashtable (ls_rehash l) r>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Applying Single Rules\\<close>"], ["", "text \\<open>\\paragraph{Hoare Triples} In this example, we show how to do\n    a proof step-by-step.\\<close>"], ["", "lemma\n    \"<os_list xs n> os_prepend x n <os_list (x # xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs n> os_prepend x n <os_list (x # xs)>", "unfolding os_prepend_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs n> ref (Node x n) \\<bind> (\\<lambda>p. return (Some p))\n    <os_list (x # xs)>", "txt \\<open>The rules to deconstruct compound statements are contained in the\n      \\<open>sep_decon_rules\\<close> collection\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs n> ref (Node x n) \\<bind> (\\<lambda>p. return (Some p))\n    <os_list (x # xs)>", "thm sep_decon_rules"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs n> ref (Node x n) \\<bind> (\\<lambda>p. return (Some p))\n    <os_list (x # xs)>", "apply (rule sep_decon_rules)"], ["proof (prove)\ngoal (2 subgoals):\n 1. <os_list xs n> ref (Node x n) <?R>\n 2. \\<And>xa. <?R xa> return (Some xa) <os_list (x # xs)>", "txt \\<open>The rules for statement that deend on the heap are\n      contained in the \\<open>sep_heap_rules\\<close> collection. The\n      \\<open>fi_rule\\<close>-lemma prepares frame inference for them\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. <os_list xs n> ref (Node x n) <?R>\n 2. \\<And>xa. <?R xa> return (Some xa) <os_list (x # xs)>", "apply (rule sep_heap_rules[THEN fi_rule])"], ["proof (prove)\ngoal (2 subgoals):\n 1. os_list xs n \\<Longrightarrow>\\<^sub>A emp * ?F3\n 2. \\<And>xa.\n       <xa \\<mapsto>\\<^sub>r Node x n * ?F3> return (Some xa)\n       <os_list (x # xs)>", "apply frame_inference \\<comment> \\<open>This method does the frame-inference\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       <xa \\<mapsto>\\<^sub>r Node x n * os_list xs n> return (Some xa)\n       <os_list (x # xs)>", "txt \\<open>The consequence rule comes in three versions, \n      \\<open>const_rule\\<close>, \\<open>cons_pre_rule\\<close>, \n      and \\<open>cons_post_rule\\<close>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       <xa \\<mapsto>\\<^sub>r Node x n * os_list xs n> return (Some xa)\n       <os_list (x # xs)>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       <xa \\<mapsto>\\<^sub>r Node x n * os_list xs n> return (Some xa)\n       <?Q10 xa>\n 2. \\<And>xa xaa. ?Q10 xa xaa \\<Longrightarrow>\\<^sub>A os_list (x # xs) xaa", "apply (rule sep_decon_rules)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       xa \\<mapsto>\\<^sub>r Node x n * os_list xs n *\n       \\<up> (xaa = Some xa) \\<Longrightarrow>\\<^sub>A\n       os_list (x # xs) xaa", "txt \\<open>A simplification unfolds \\<open>os_list\\<close> and extract the\n      pure part of the assumption\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       xa \\<mapsto>\\<^sub>r Node x n * os_list xs n *\n       \\<up> (xaa = Some xa) \\<Longrightarrow>\\<^sub>A\n       os_list (x # xs) xaa", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<mapsto>\\<^sub>r Node x n *\n       os_list xs n \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>App n.\n          pp \\<mapsto>\\<^sub>r Node x n * os_list xs n * \\<up> (xa = pp)", "txt \\<open>We can use \\<open>ent_ex_postI\\<close> to manually introduce \n      existentials in entailsments\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<mapsto>\\<^sub>r Node x n *\n       os_list xs n \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>App n.\n          pp \\<mapsto>\\<^sub>r Node x n * os_list xs n * \\<up> (xa = pp)", "apply (rule_tac x=xa in ent_ex_postI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<mapsto>\\<^sub>r Node x n *\n       os_list xs n \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>An.\n          xa \\<mapsto>\\<^sub>r Node x n * os_list xs n * \\<up> (xa = xa)", "apply (rule_tac x=n in ent_ex_postI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<mapsto>\\<^sub>r Node x n *\n       os_list xs n \\<Longrightarrow>\\<^sub>A\n       xa \\<mapsto>\\<^sub>r Node x n * os_list xs n * \\<up> (xa = xa)", "txt \\<open>The simplifier has a setup for assertions, so it will do the rest\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<mapsto>\\<^sub>r Node x n *\n       os_list xs n \\<Longrightarrow>\\<^sub>A\n       xa \\<mapsto>\\<^sub>r Node x n * os_list xs n * \\<up> (xa = xa)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Note that the proof above can be done with \\<open>sep_auto\\<close>,\n    the \"Swiss army knife\" of our framework\\<close>"], ["", "lemma\n    \"<os_list xs n> os_prepend x n <os_list (x # xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs n> os_prepend x n <os_list (x # xs)>", "unfolding os_prepend_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs n> ref (Node x n) \\<bind> (\\<lambda>p. return (Some p))\n    <os_list (x # xs)>", "by sep_auto"], ["", "text \\<open>\\paragraph{Entailment} This example presents an actual proof\n    from the circular list theory, where we have to manually apply a\n    rule and give some hints to frame inference\\<close>"], ["", "lemma cs_append_rule: \n    \"<cs_list l p> cs_append x p <cs_list (l@[x])>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <cs_list l p> cs_append x p <cs_list (l @ [x])>", "apply (cases p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = None \\<Longrightarrow>\n    <cs_list l p> cs_append x p <cs_list (l @ [x])>\n 2. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <cs_list l p> cs_append x p <cs_list (l @ [x])>", "apply (sep_auto simp: cs_append.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <cs_list l p> cs_append x p <cs_list (l @ [x])>", "apply (sep_auto simp: cs_append.simps heap: lseg_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> a \\<mapsto>\\<^sub>r Node x (Some xb) *\n                         xb \\<mapsto>\\<^sub>r Node xa n *\n                         lseg ls n (Some a) \\<Longrightarrow>\\<^sub>A\n                         xb \\<mapsto>\\<^sub>r Node xa (?n114 a xa ls n xb) *\n                         lseg (ls @ [x]) (?n114 a xa ls n xb) (Some xb)", "txt \\<open>At this point, we are left with an entailment subgoal that sep-auto\n      cannot solve. A closer look reveals that we could use the rule\n      \\<open>lseg_append\\<close>. \n      \n      With the \\<open>ent_frame_fwd\\<close>-rule, we can manually apply a rule to\n      solve an entailment, involving frame inference. In this case, we have\n      the additional problem that frame-inference guesses\n      a wrong instantiation, and is not able to infer the frame.\n      So we have to pre-instantiate the rule, as done below.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> a \\<mapsto>\\<^sub>r Node x (Some xb) *\n                         xb \\<mapsto>\\<^sub>r Node xa n *\n                         lseg ls n (Some a) \\<Longrightarrow>\\<^sub>A\n                         xb \\<mapsto>\\<^sub>r Node xa (?n114 a xa ls n xb) *\n                         lseg (ls @ [x]) (?n114 a xa ls n xb) (Some xb)", "apply (rule_tac s1=a in ent_frame_fwd[OF lseg_append])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> a \\<mapsto>\\<^sub>r Node x (Some xb) *\n                         xb \\<mapsto>\\<^sub>r Node xa n *\n                         lseg ls n (Some a) \\<Longrightarrow>\\<^sub>A\n                         lseg (?l122 a xa ls n xb) (?p122 a xa ls n xb)\n                          (Some a) *\n                         a \\<mapsto>\\<^sub>r\n                         Node (?x122 a xa ls n xb) (?q122 a xa ls n xb) *\n                         ?F121 a xa ls n xb\n 2. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> lseg (?l122 a xa ls n xb @ [?x122 a xa ls n xb])\n                          (?p122 a xa ls n xb) (?q122 a xa ls n xb) *\n                         ?F121 a xa ls n xb \\<Longrightarrow>\\<^sub>A\n                         xb \\<mapsto>\\<^sub>r Node xa (?n114 a xa ls n xb) *\n                         lseg (ls @ [x]) (?n114 a xa ls n xb) (Some xb)", "apply frame_inference \\<comment> \\<open>Now frame-inference is able to infer the frame\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> lseg (ls @ [x]) n (Some xb) *\n                         xb \\<mapsto>\\<^sub>r\n                         Node xa n \\<Longrightarrow>\\<^sub>A\n                         xb \\<mapsto>\\<^sub>r Node xa (?n114 a xa ls n xb) *\n                         lseg (ls @ [x]) (?n114 a xa ls n xb) (Some xb)", "txt \\<open>Now we are left with a trivial entailment, modulo commutativity of\n      star. This can be handled by the entailment solver:\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xa ls n xb.\n       \\<lbrakk>p = Some a; l = xa # ls\\<rbrakk>\n       \\<Longrightarrow> lseg (ls @ [x]) n (Some xb) *\n                         xb \\<mapsto>\\<^sub>r\n                         Node xa n \\<Longrightarrow>\\<^sub>A\n                         xb \\<mapsto>\\<^sub>r Node xa (?n114 a xa ls n xb) *\n                         lseg (ls @ [x]) (?n114 a xa ls n xb) (Some xb)", "apply solve_entails"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Functions with Explicit Recursion\\<close>"], ["", "text \\<open>If the termination argument of a function depends on one of\n    its parameters, we can use the function package. For example, \n    the following function inserts elements from a list into a hash-set:\\<close>"], ["", "fun ins_from_list \n    :: \"('x::{heap,hashable}) list \\<Rightarrow> 'x hashset \\<Rightarrow> 'x hashset Heap\" \n    where\n    \"ins_from_list [] hs = return hs\" |\n    \"ins_from_list (x # l) hs = do { hs \\<leftarrow> hs_ins x hs; ins_from_list l hs }\""], ["", "text \\<open>Proofs over such functions are usually done by structural\n    induction on the explicit parameter, in this case, on the list\\<close>"], ["", "lemma ins_from_list_correct:\n    \"<is_hashset s hs> ins_from_list l hs <is_hashset (s\\<union>set l)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashset s\n      hs> ins_from_list l hs <is_hashset (s \\<union> set l)>\\<^sub>t", "proof (induction l arbitrary: hs s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>hs s.\n       <is_hashset s\n         hs> ins_from_list [] hs <is_hashset (s \\<union> set [])>\\<^sub>t\n 2. \\<And>a l hs s.\n       (\\<And>hs s.\n           <is_hashset s\n             hs> ins_from_list l\n                  hs <is_hashset\n                       (s \\<union> set l)>\\<^sub>t) \\<Longrightarrow>\n       <is_hashset s\n         hs> ins_from_list (a # l)\n              hs <is_hashset (s \\<union> set (a # l))>\\<^sub>t", "case (Cons x l)"], ["proof (state)\nthis:\n  <is_hashset ?s\n    ?hs> ins_from_list l ?hs <is_hashset (?s \\<union> set l)>\\<^sub>t\n\ngoal (2 subgoals):\n 1. \\<And>hs s.\n       <is_hashset s\n         hs> ins_from_list [] hs <is_hashset (s \\<union> set [])>\\<^sub>t\n 2. \\<And>a l hs s.\n       (\\<And>hs s.\n           <is_hashset s\n             hs> ins_from_list l\n                  hs <is_hashset\n                       (s \\<union> set l)>\\<^sub>t) \\<Longrightarrow>\n       <is_hashset s\n         hs> ins_from_list (a # l)\n              hs <is_hashset (s \\<union> set (a # l))>\\<^sub>t", "txt \\<open>In the induction step, the induction hypothesis has to be \n      declared as a heap-rule, as \\<open>sep_auto\\<close> currently does not\n      look for potential heap-rules among the premises of the subgoal\\<close>"], ["proof (state)\nthis:\n  <is_hashset ?s\n    ?hs> ins_from_list l ?hs <is_hashset (?s \\<union> set l)>\\<^sub>t\n\ngoal (2 subgoals):\n 1. \\<And>hs s.\n       <is_hashset s\n         hs> ins_from_list [] hs <is_hashset (s \\<union> set [])>\\<^sub>t\n 2. \\<And>a l hs s.\n       (\\<And>hs s.\n           <is_hashset s\n             hs> ins_from_list l\n                  hs <is_hashset\n                       (s \\<union> set l)>\\<^sub>t) \\<Longrightarrow>\n       <is_hashset s\n         hs> ins_from_list (a # l)\n              hs <is_hashset (s \\<union> set (a # l))>\\<^sub>t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashset s\n      hs> ins_from_list (x # l)\n           hs <is_hashset (s \\<union> set (x # l))>\\<^sub>t", "by (sep_auto heap: Cons.IH)"], ["proof (state)\nthis:\n  <is_hashset s\n    hs> ins_from_list (x # l)\n         hs <is_hashset (s \\<union> set (x # l))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>hs s.\n       <is_hashset s\n         hs> ins_from_list [] hs <is_hashset (s \\<union> set [])>\\<^sub>t", "qed sep_auto"], ["", "subsection \\<open>\n    Functions with Recursion Involving the Heap\n\\<close>"], ["", "text \\<open>If the termination argument of a function depends on data stored on\n    the heap, \\<open>partial_function\\<close> is a useful tool.\n\n    Note that, despite the name, proving a Hoare-Triple \\<open><\\<dots>> \\<dots> <\\<dots>>\\<close>\n    for something defined with \\<open>partial_function\\<close> implies total \n    correctness.\n\\<close>"], ["", "text \\<open>In the following example, we compute the sum of a list, using an\n    iterator. Note that the partial-function package does not provide a\n    code generator setup by default, so we have to add a \\<open>[code]\\<close>\n    attribute manually\\<close>"], ["", "partial_function (heap) os_sum' :: \"int os_list_it \\<Rightarrow> int \\<Rightarrow> int Heap\" \n    where [code]:\n    \"os_sum' it s = do {\n      b \\<leftarrow> os_it_has_next it;\n      if b then do {\n        (x,it') \\<leftarrow> os_it_next it;\n        os_sum' it' (s+x)\n      } else return s\n    }\""], ["", "text \\<open>The proof that the function is correct can be done by induction\n    over the representation of the list that we still have to iterate over.\n    Note that for iterators over sets, we need induction on finite sets,\n    cf. also \\<open>To_List_Ga.thy\\<close>\\<close>"], ["", "lemma os_sum'_rule: \n    \"<os_is_it l p l' it> \n    os_sum' it s \n    <\\<lambda>r. os_list l p * \\<up>(r = s + sum_list l')>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p l'\n      it> Idioms.os_sum' it\n           s <\\<lambda>r. os_list l p * \\<up> (r = s + sum_list l')>\\<^sub>t", "proof (induct l' arbitrary: it s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>it s.\n       <os_is_it l p []\n         it> Idioms.os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list [])>\\<^sub>t\n 2. \\<And>a l' it s.\n       (\\<And>it s.\n           <os_is_it l p l'\n             it> Idioms.os_sum' it\n                  s <\\<lambda>r.\n                        os_list l p *\n                        \\<up>\n                         (r = s + sum_list l')>\\<^sub>t) \\<Longrightarrow>\n       <os_is_it l p (a # l')\n         it> Idioms.os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list (a # l'))>\\<^sub>t", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>it s.\n       <os_is_it l p []\n         it> Idioms.os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list [])>\\<^sub>t\n 2. \\<And>a l' it s.\n       (\\<And>it s.\n           <os_is_it l p l'\n             it> Idioms.os_sum' it\n                  s <\\<lambda>r.\n                        os_list l p *\n                        \\<up>\n                         (r = s + sum_list l')>\\<^sub>t) \\<Longrightarrow>\n       <os_is_it l p (a # l')\n         it> Idioms.os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list (a # l'))>\\<^sub>t", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p []\n      it> Idioms.os_sum' it\n           s <\\<lambda>r. os_list l p * \\<up> (r = s + sum_list [])>\\<^sub>t", "txt \\<open>To unfold the definition of a partial function, we have to use \n        \\<open>subst\\<close>. Note that \\<open>simp\\<close> would loop, unfolding the\n        function arbitrarily deep\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p []\n      it> Idioms.os_sum' it\n           s <\\<lambda>r. os_list l p * \\<up> (r = s + sum_list [])>\\<^sub>t", "apply (subst os_sum'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p []\n      it> os_it_has_next it \\<bind>\n          (\\<lambda>b.\n              if b\n              then os_it_next it \\<bind>\n                   (\\<lambda>(x, it'). Idioms.os_sum' it' (s + x))\n              else return\n                    s) <\\<lambda>r.\n                           os_list l p *\n                           \\<up> (r = s + sum_list [])>\\<^sub>t", "txt \\<open>\\<open>sep_auto\\<close> accepts all the section parameters that \n        \\<open>auto\\<close> does, eg. \\<open>intro:\\<close>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p []\n      it> os_it_has_next it \\<bind>\n          (\\<lambda>b.\n              if b\n              then os_it_next it \\<bind>\n                   (\\<lambda>(x, it'). Idioms.os_sum' it' (s + x))\n              else return\n                    s) <\\<lambda>r.\n                           os_list l p *\n                           \\<up> (r = s + sum_list [])>\\<^sub>t", "apply (sep_auto intro: os.quit_iteration)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <os_is_it l p []\n    it> Idioms.os_sum' it\n         s <\\<lambda>r. os_list l p * \\<up> (r = s + sum_list [])>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>a l' it s.\n       (\\<And>it s.\n           <os_is_it l p l'\n             it> Idioms.os_sum' it\n                  s <\\<lambda>r.\n                        os_list l p *\n                        \\<up>\n                         (r = s + sum_list l')>\\<^sub>t) \\<Longrightarrow>\n       <os_is_it l p (a # l')\n         it> Idioms.os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list (a # l'))>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l' it s.\n       (\\<And>it s.\n           <os_is_it l p l'\n             it> Idioms.os_sum' it\n                  s <\\<lambda>r.\n                        os_list l p *\n                        \\<up>\n                         (r = s + sum_list l')>\\<^sub>t) \\<Longrightarrow>\n       <os_is_it l p (a # l')\n         it> Idioms.os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list (a # l'))>\\<^sub>t", "case (Cons x l')"], ["proof (state)\nthis:\n  <os_is_it l p l'\n    ?it> Idioms.os_sum' ?it\n          ?s <\\<lambda>r.\n                 os_list l p * \\<up> (r = ?s + sum_list l')>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>a l' it s.\n       (\\<And>it s.\n           <os_is_it l p l'\n             it> Idioms.os_sum' it\n                  s <\\<lambda>r.\n                        os_list l p *\n                        \\<up>\n                         (r = s + sum_list l')>\\<^sub>t) \\<Longrightarrow>\n       <os_is_it l p (a # l')\n         it> Idioms.os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list (a # l'))>\\<^sub>t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p (x # l')\n      it> Idioms.os_sum' it\n           s <\\<lambda>r.\n                 os_list l p * \\<up> (r = s + sum_list (x # l'))>\\<^sub>t", "apply (subst os_sum'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p (x # l')\n      it> os_it_has_next it \\<bind>\n          (\\<lambda>b.\n              if b\n              then os_it_next it \\<bind>\n                   (\\<lambda>(x, it'). Idioms.os_sum' it' (s + x))\n              else return\n                    s) <\\<lambda>r.\n                           os_list l p *\n                           \\<up> (r = s + sum_list (x # l'))>\\<^sub>t", "txt \\<open>Additionally, \\<open>sep_auto\\<close> accepts some more section \n        parameters. The most common one, \\<open>heap:\\<close>, declares rules \n        to be used with frame inference. See Section~\\ref{sec:auto:overview}\n        for a complete overview.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p (x # l')\n      it> os_it_has_next it \\<bind>\n          (\\<lambda>b.\n              if b\n              then os_it_next it \\<bind>\n                   (\\<lambda>(x, it'). Idioms.os_sum' it' (s + x))\n              else return\n                    s) <\\<lambda>r.\n                           os_list l p *\n                           \\<up> (r = s + sum_list (x # l'))>\\<^sub>t", "apply (sep_auto heap: Cons.hyps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <os_is_it l p (x # l')\n    it> Idioms.os_sum' it\n         s <\\<lambda>r.\n               os_list l p * \\<up> (r = s + sum_list (x # l'))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Precision Proofs\\<close>"], ["", "text \\<open>\n    Precision lemmas show that an assertion uniquely determines some of its\n    parameters. Our example shows that two list segments from the same start \n    pointer and with the same list, also have to end at the same end pointer.\n\\<close>"], ["", "lemma lseg_prec3: \n    \"\\<forall>q q'. h \\<Turnstile> (lseg l p q * F1) \\<and>\\<^sub>A (lseg l p q' * F2) \\<longrightarrow> q=q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q q'.\n       h \\<Turnstile>\n       lseg l p q * F1 \\<and>\\<^sub>A lseg l p q' * F2 \\<longrightarrow>\n       q = q'", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q q'.\n       h \\<Turnstile>\n       lseg l p q * F1 \\<and>\\<^sub>A lseg l p q' * F2 \\<longrightarrow>\n       q = q'", "proof (induct l arbitrary: p F1 F2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q q' p F1 F2.\n       h \\<Turnstile>\n       lseg [] p q * F1 \\<and>\\<^sub>A lseg [] p q' * F2 \\<longrightarrow>\n       q = q'\n 2. \\<And>a l q q' p F1 F2.\n       (\\<And>q q' p F1 F2.\n           h \\<Turnstile>\n           lseg l p q * F1 \\<and>\\<^sub>A lseg l p q' * F2 \\<longrightarrow>\n           q = q') \\<Longrightarrow>\n       h \\<Turnstile>\n       lseg (a # l) p q * F1 \\<and>\\<^sub>A\n       lseg (a # l) p q' * F2 \\<longrightarrow>\n       q = q'", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>q q' p F1 F2.\n       h \\<Turnstile>\n       lseg [] p q * F1 \\<and>\\<^sub>A lseg [] p q' * F2 \\<longrightarrow>\n       q = q'\n 2. \\<And>a l q q' p F1 F2.\n       (\\<And>q q' p F1 F2.\n           h \\<Turnstile>\n           lseg l p q * F1 \\<and>\\<^sub>A lseg l p q' * F2 \\<longrightarrow>\n           q = q') \\<Longrightarrow>\n       h \\<Turnstile>\n       lseg (a # l) p q * F1 \\<and>\\<^sub>A\n       lseg (a # l) p q' * F2 \\<longrightarrow>\n       q = q'", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile>\n    lseg [] p q * F1 \\<and>\\<^sub>A lseg [] p q' * F2 \\<longrightarrow>\n    q = q'", "apply simp \\<comment> \\<open>A precision solver for references and arrays is included\n        in the standard simplifier setup. Building a general precision solver\n        remains future work.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> F1 \\<and>\\<^sub>A F2 \\<and>\n    p = q \\<and> p = q' \\<longrightarrow>\n    q = q'", "by metis \\<comment> \\<open>Unfortunately, the simplifier cannot cope with arbitrarily  \n        directed equations, so we have to use some more powerful tool\\<close>"], ["proof (state)\nthis:\n  h \\<Turnstile>\n  lseg [] p q * F1 \\<and>\\<^sub>A lseg [] p q' * F2 \\<longrightarrow>\n  q = q'\n\ngoal (1 subgoal):\n 1. \\<And>a l q q' p F1 F2.\n       (\\<And>q q' p F1 F2.\n           h \\<Turnstile>\n           lseg l p q * F1 \\<and>\\<^sub>A lseg l p q' * F2 \\<longrightarrow>\n           q = q') \\<Longrightarrow>\n       h \\<Turnstile>\n       lseg (a # l) p q * F1 \\<and>\\<^sub>A\n       lseg (a # l) p q' * F2 \\<longrightarrow>\n       q = q'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l q q' p F1 F2.\n       (\\<And>q q' p F1 F2.\n           h \\<Turnstile>\n           lseg l p q * F1 \\<and>\\<^sub>A lseg l p q' * F2 \\<longrightarrow>\n           q = q') \\<Longrightarrow>\n       h \\<Turnstile>\n       lseg (a # l) p q * F1 \\<and>\\<^sub>A\n       lseg (a # l) p q' * F2 \\<longrightarrow>\n       q = q'", "case (Cons x l)"], ["proof (state)\nthis:\n  h \\<Turnstile>\n  lseg l ?p ?q * ?F1.0 \\<and>\\<^sub>A\n  lseg l ?p ?q' * ?F2.0 \\<longrightarrow>\n  ?q = ?q'\n\ngoal (1 subgoal):\n 1. \\<And>a l q q' p F1 F2.\n       (\\<And>q q' p F1 F2.\n           h \\<Turnstile>\n           lseg l p q * F1 \\<and>\\<^sub>A lseg l p q' * F2 \\<longrightarrow>\n           q = q') \\<Longrightarrow>\n       h \\<Turnstile>\n       lseg (a # l) p q * F1 \\<and>\\<^sub>A\n       lseg (a # l) p q' * F2 \\<longrightarrow>\n       q = q'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile>\n    lseg (x # l) p q * F1 \\<and>\\<^sub>A\n    lseg (x # l) p q' * F2 \\<longrightarrow>\n    q = q'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pp n na.\n       \\<lbrakk>h \\<Turnstile>\n                pp \\<mapsto>\\<^sub>r Node x na * lseg l na q *\n                F1 \\<and>\\<^sub>A\n                pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' * F2;\n        p = Some pp\\<rbrakk>\n       \\<Longrightarrow> q = q'", "apply (subgoal_tac \"na=n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>pp n na.\n       \\<lbrakk>h \\<Turnstile>\n                pp \\<mapsto>\\<^sub>r Node x na * lseg l na q *\n                F1 \\<and>\\<^sub>A\n                pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' * F2;\n        p = Some pp; na = n\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 2. \\<And>pp n na.\n       \\<lbrakk>h \\<Turnstile>\n                pp \\<mapsto>\\<^sub>r Node x na * lseg l na q *\n                F1 \\<and>\\<^sub>A\n                pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' * F2;\n        p = Some pp\\<rbrakk>\n       \\<Longrightarrow> na = n", "txt \\<open>The \\<open>prec_frame\\<close> and \\<open>prec_frame'\\<close> rules are \n        useful to do precision proofs\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>pp n na.\n       \\<lbrakk>h \\<Turnstile>\n                pp \\<mapsto>\\<^sub>r Node x na * lseg l na q *\n                F1 \\<and>\\<^sub>A\n                pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' * F2;\n        p = Some pp; na = n\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 2. \\<And>pp n na.\n       \\<lbrakk>h \\<Turnstile>\n                pp \\<mapsto>\\<^sub>r Node x na * lseg l na q *\n                F1 \\<and>\\<^sub>A\n                pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' * F2;\n        p = Some pp\\<rbrakk>\n       \\<Longrightarrow> na = n", "apply (erule prec_frame'[OF Cons.hyps])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>pp n na.\n       \\<lbrakk>p = Some pp; na = n\\<rbrakk>\n       \\<Longrightarrow> pp \\<mapsto>\\<^sub>r Node x na * lseg l na q *\n                         F1 \\<Longrightarrow>\\<^sub>A\n                         lseg l (?p18 pp n na q) q * ?F1.15 pp n na\n 2. \\<And>pp n na.\n       \\<lbrakk>p = Some pp; na = n\\<rbrakk>\n       \\<Longrightarrow> pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' *\n                         F2 \\<Longrightarrow>\\<^sub>A\n                         lseg l (?p18 pp n na q') q' * ?F2.15 pp n na\n 3. \\<And>pp n na.\n       \\<lbrakk>h \\<Turnstile>\n                pp \\<mapsto>\\<^sub>r Node x na * lseg l na q *\n                F1 \\<and>\\<^sub>A\n                pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' * F2;\n        p = Some pp\\<rbrakk>\n       \\<Longrightarrow> na = n\nflex-flex pairs:\n  \\<lambda>pp n na. ?p18 pp n na q' \\<equiv>\\<^sup>?\n    \\<lambda>pp n na. ?p18 pp n na q", "apply frame_inference"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>pp n na.\n       \\<lbrakk>p = Some pp; na = n\\<rbrakk>\n       \\<Longrightarrow> pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' *\n                         F2 \\<Longrightarrow>\\<^sub>A\n                         lseg l na q' * ?F2.15 pp n na\n 2. \\<And>pp n na.\n       \\<lbrakk>h \\<Turnstile>\n                pp \\<mapsto>\\<^sub>r Node x na * lseg l na q *\n                F1 \\<and>\\<^sub>A\n                pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' * F2;\n        p = Some pp\\<rbrakk>\n       \\<Longrightarrow> na = n", "apply frame_inference"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pp n na.\n       \\<lbrakk>h \\<Turnstile>\n                pp \\<mapsto>\\<^sub>r Node x na * lseg l na q *\n                F1 \\<and>\\<^sub>A\n                pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' * F2;\n        p = Some pp\\<rbrakk>\n       \\<Longrightarrow> na = n", "apply (drule prec_frame[OF sngr_prec])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>pp n na.\n       p = Some pp \\<Longrightarrow>\n       pp \\<mapsto>\\<^sub>r Node x na * lseg l na q *\n       F1 \\<Longrightarrow>\\<^sub>A\n       ?p41 pp n na \\<mapsto>\\<^sub>r ?x41 pp n na * ?F1.41 pp n na\n 2. \\<And>pp n na.\n       p = Some pp \\<Longrightarrow>\n       pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' *\n       F2 \\<Longrightarrow>\\<^sub>A\n       ?p41 pp n na \\<mapsto>\\<^sub>r ?y41 pp n na * ?F2.41 pp n na\n 3. \\<And>pp n na.\n       \\<lbrakk>p = Some pp; ?x41 pp n na = ?y41 pp n na\\<rbrakk>\n       \\<Longrightarrow> na = n", "apply frame_inference"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>pp n na.\n       p = Some pp \\<Longrightarrow>\n       pp \\<mapsto>\\<^sub>r Node x n * lseg l n q' *\n       F2 \\<Longrightarrow>\\<^sub>A\n       pp \\<mapsto>\\<^sub>r ?y41 pp n na * ?F2.41 pp n na\n 2. \\<And>pp n na.\n       \\<lbrakk>p = Some pp; Node x na = ?y41 pp n na\\<rbrakk>\n       \\<Longrightarrow> na = n", "apply frame_inference"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pp n na.\n       \\<lbrakk>p = Some pp; Node x na = Node x n\\<rbrakk>\n       \\<Longrightarrow> na = n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  h \\<Turnstile>\n  lseg (x # l) p q * F1 \\<and>\\<^sub>A\n  lseg (x # l) p q' * F2 \\<longrightarrow>\n  q = q'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}