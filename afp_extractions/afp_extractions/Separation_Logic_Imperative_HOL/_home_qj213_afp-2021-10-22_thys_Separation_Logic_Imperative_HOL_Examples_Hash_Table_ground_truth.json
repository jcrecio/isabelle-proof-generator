{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Examples/Hash_Table.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma is_hashtable_prec: \"precise is_hashtable\"", "lemma ht_array_nth_rule[sep_heap_rules]:\n    \"i<length l \\<Longrightarrow> <is_hashtable l ht>\n      Array.nth (the_array ht) i\n      <\\<lambda>r. is_hashtable l ht * \\<up>(r = l!i)>\"", "lemma ht_array_length_rule[sep_heap_rules]:\n    \"<is_hashtable l ht>\n      Array.len (the_array ht)\n      <\\<lambda>r. is_hashtable l ht * \\<up>(r = length l)>\"", "lemma ht_hash_replicate[simp, intro!]: \"ht_hash (replicate n [])\"", "lemma ht_distinct_replicate[simp, intro!]: \"ht_distinct (replicate n [])\"", "lemma ht_size_replicate[simp, intro!]: \"ht_size (replicate n []) 0\"", "lemma complete_ht_new_sz: \"1 < n \\<Longrightarrow> <emp> ht_new_sz n <is_hashtable (replicate n [])>\"", "lemma complete_ht_new:\n  \"<emp>\n     ht_new::('k::{heap,hashable}, 'v::heap) hashtable Heap\n   <is_hashtable (replicate (def_hashmap_size TYPE('k)) [])>\"", "lemma complete_ht_lookup:\n  \"<is_hashtable l ht> ht_lookup x ht\n     <\\<lambda>r. is_hashtable l ht *\n        \\<up>(r = ls_lookup x (l!(bounded_hashcode_nat (length l) x))) >\"", "lemma complete_ht_lookup_alt_proof:\n  \"<is_hashtable l ht> ht_lookup x ht\n    <\\<lambda>r. is_hashtable l ht *\n      \\<up>(r = ls_lookup x (l!(bounded_hashcode_nat (length l) x)))>\"", "lemma ls_update_snd_set: \"snd (ls_update k v l) \\<longleftrightarrow> k \\<in> set (map fst l)\"", "lemma ls_update_fst_set: \"set (fst (ls_update k v l)) \\<subseteq> insert (k, v) (set l)\"", "lemma ls_update_fst_map_set: \"set (map fst (fst (ls_update k v l))) = insert k (set (map fst l))\"", "lemma ls_update_distinct: \"distinct (map fst l) \\<Longrightarrow> distinct (map fst (fst (ls_update k v l)))\"", "lemma ls_update_length: \"length (fst (ls_update k v l))\n  = (if (k \\<in> set (map fst l)) then length l else Suc (length l))\"", "lemma ls_update_length_snd_True:\n  \"snd (ls_update k v l) \\<Longrightarrow> length (fst (ls_update k v l)) = length l\"", "lemma ls_update_length_snd_False:\n  \"\\<not> snd (ls_update k v l) \\<Longrightarrow> length (fst (ls_update k v l)) = Suc (length l)\"", "lemma ht_hash_update:\n  assumes \"ht_hash ls\"\n  shows \"ht_hash (abs_update k v ls)\"", "lemma ht_distinct_update:\n  assumes \"ht_distinct l\"\n  shows \"ht_distinct (abs_update k v l)\"", "lemma length_update:\n  assumes \"1 < length l\"\n  shows \"1 < length (abs_update k v l)\"", "lemma ht_size_update1:\n  assumes size: \"ht_size l n\"\n  assumes i: \"i < length l\"\n  assumes snd: \"snd (ls_update k v (l ! i))\"\n  shows \"ht_size (l[i := fst (ls_update k v (l!i))]) n\"", "lemma ht_size_update2:\n  assumes size: \"ht_size l n\"\n  assumes i: \"i < length l\"\n  assumes snd: \"\\<not> snd (ls_update k v (l ! i))\"\n  shows \"ht_size (l[i := fst (ls_update k v (l!i))]) (Suc n)\"", "lemma complete_ht_upd: \"<is_hashtable l ht> ht_upd k v ht\n  <is_hashtable (abs_update k v l)>\"", "lemma complete_ht_upd_alt_proof:\n  \"<is_hashtable l ht> ht_upd k v ht <is_hashtable (abs_update k v l)>\"", "lemma ls_delete_snd_set: \"snd (ls_delete k l) \\<longleftrightarrow> k \\<in> set (map fst l)\"", "lemma ls_delete_fst_set: \"set (fst (ls_delete k l)) \\<subseteq> set l\"", "lemma ls_delete_fst_map_set:\n  \"distinct (map fst l) \\<Longrightarrow>\n  set (map fst (fst (ls_delete k l))) = (set (map fst l)) - {k}\"", "lemma ls_delete_distinct: \"distinct (map fst l) \\<Longrightarrow> distinct (map fst (fst (ls_delete k l)))\"", "lemma ls_delete_length:\n  \"length (fst (ls_delete k l)) = (\n    if (k \\<in> set (map fst l)) then\n      (length l - 1)\n    else\n      length l)\"", "lemma ls_delete_length_snd_True:\n  \"snd (ls_delete k l) \\<Longrightarrow> length (fst (ls_delete k l)) = length l - 1\"", "lemma ls_delete_length_snd_False:\n  \"\\<not> snd (ls_delete k l) \\<Longrightarrow> length (fst (ls_delete k l)) = length l\"", "lemma ht_hash_delete:\n  assumes \"ht_hash ls\"\n  shows \"ht_hash (\n    ls[bounded_hashcode_nat (length ls) k\n      := fst (ls_delete k\n               (ls ! bounded_hashcode_nat (length ls) k)\n             )\n      ]\n  )\"", "lemma ht_distinct_delete:\n  assumes \"ht_distinct l\"\n  shows \"ht_distinct (\n    l[bounded_hashcode_nat (length l) k\n      := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\"", "lemma ht_size_delete1:\n  assumes size: \"ht_size l n\"\n  assumes i: \"i < length l\"\n  assumes snd: \"snd (ls_delete k (l ! i))\"\n  shows \"ht_size (l[i := fst (ls_delete k (l!i))]) (n - 1)\"", "lemma ht_size_delete2:\n  assumes size: \"ht_size l n\"\n  assumes i: \"i < length l\"\n  assumes snd: \"\\<not> snd (ls_delete k (l ! i))\"\n  shows \"ht_size (l[i := fst (ls_delete k (l!i))]) n\"", "lemma complete_ht_delete: \"<is_hashtable l ht> ht_delete k ht\n  <is_hashtable (l[bounded_hashcode_nat (length l) k\n    := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])>\"", "lemma \"<is_hashtable l ht> ht_delete k ht\n  <is_hashtable (l[bounded_hashcode_nat (length l)\n    k := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])>\"", "lemma ht_hash_ls_insls:\n  assumes \"ht_hash l\"\n  shows \"ht_hash (ls_insls ls l)\"", "lemma ht_distinct_ls_insls:\n  assumes \"ht_distinct l\"\n  shows \"ht_distinct (ls_insls ls l)\"", "lemma length_ls_insls:\n  assumes \"1 < length l\"\n  shows \"1 < length (ls_insls ls l)\"", "lemma complete_ht_insls:\n  \"<is_hashtable ls ht> ht_insls xs ht <is_hashtable (ls_insls xs ls)>\"", "lemma ht_hash_ls_copy:\n  assumes \"ht_hash l\"\n  shows \"ht_hash (ls_copy n ss l)\"", "lemma ht_distinct_ls_copy:\n  assumes \"ht_distinct l\"\n  shows \"ht_distinct (ls_copy n ss l)\"", "lemma length_ls_copy:\n  assumes \"1 < length l\"\n  shows \"1 < length (ls_copy n ss l)\"", "lemma complete_ht_copy: \"n \\<le> List.length ss \\<Longrightarrow>\n  <is_hashtable ss src * is_hashtable ds dst>\n  ht_copy n src dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ds) r>\"", "lemma complete_ht_copy_alt_proof: \"n \\<le> List.length ss \\<Longrightarrow>\n  <is_hashtable ss src * is_hashtable ds dst>\n  ht_copy n src dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ds) r>\"", "lemma ht_hash_ls_rehash: \"ht_hash (ls_rehash l)\"", "lemma ht_distinct_ls_rehash: \"ht_distinct (ls_rehash l)\"", "lemma length_ls_rehash:\n  assumes \"1 < length l\"\n  shows \"1 < length (ls_rehash l)\"", "lemma ht_imp_len: \"is_hashtable l ht \\<Longrightarrow>\\<^sub>A is_hashtable l ht * \\<up>(length l > 0)\"", "lemma complete_ht_rehash:\n  \"<is_hashtable l ht> ht_rehash ht\n  <\\<lambda>r. is_hashtable l ht * is_hashtable (ls_rehash l) r>\"", "lemma complete_ht_update_normal:\n  \"\\<not> length l * load_factor \\<le> (the_size ht)* 100 \\<Longrightarrow>\n  <is_hashtable l ht>\n  ht_update k v ht\n  <is_hashtable (abs_update k v l)>\"", "lemma complete_ht_update_rehash:\n  \"length l * load_factor \\<le> (the_size ht)* 100 \\<Longrightarrow>\n  <is_hashtable l ht>\n  ht_update k v ht\n  <\\<lambda>r. is_hashtable l ht\n    * is_hashtable (abs_update k v (ls_rehash l)) r>\"", "lemma complete_ht_to_list: \"<is_hashtable l ht> ht_to_list ht\n  <\\<lambda>r. is_hashtable l ht * \\<up>(r = concat l)>\""], "translations": [["", "lemma is_hashtable_prec: \"precise is_hashtable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_hashtable", "apply (rule preciseI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_hashtable a p * F \\<and>\\<^sub>A\n       is_hashtable a' p * F' \\<Longrightarrow>\n       a = a'", "unfolding is_hashtable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       the_array p \\<mapsto>\\<^sub>a a *\n       \\<up>\n        (ht_size a (the_size p) \\<and>\n         ht_hash a \\<and> ht_distinct a \\<and> 1 < length a) *\n       F \\<and>\\<^sub>A\n       the_array p \\<mapsto>\\<^sub>a a' *\n       \\<up>\n        (ht_size a' (the_size p) \\<and>\n         ht_hash a' \\<and> ht_distinct a' \\<and> 1 < length a') *\n       F' \\<Longrightarrow>\n       a = a'", "apply (auto simp add: preciseD[OF snga_prec])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>These rules are quite useful for automated methods, to avoid unfolding\n  of definitions, that might be used folded in other lemmas,\n  like induction hypothesis. However, they show in some sense a possibility for\n  modularization improvement, as it should be enough to show an implication\n  and know that the \\<open>nth\\<close> and \\<open>len\\<close> operations do not change\n  the heap.\\<close>"], ["", "lemma ht_array_nth_rule[sep_heap_rules]:\n    \"i<length l \\<Longrightarrow> <is_hashtable l ht>\n      Array.nth (the_array ht) i\n      <\\<lambda>r. is_hashtable l ht * \\<up>(r = l!i)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow>\n    <is_hashtable l ht> Array.nth (the_array ht) i\n    <\\<lambda>r. is_hashtable l ht * \\<up> (r = l ! i)>", "unfolding is_hashtable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow>\n    <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l)>\n    Array.nth (the_array ht) i\n    <\\<lambda>r.\n        the_array ht \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (ht_size l (the_size ht) \\<and>\n          ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n        \\<up> (r = l ! i)>", "by sep_auto"], ["", "lemma ht_array_length_rule[sep_heap_rules]:\n    \"<is_hashtable l ht>\n      Array.len (the_array ht)\n      <\\<lambda>r. is_hashtable l ht * \\<up>(r = length l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> Array.len (the_array ht)\n    <\\<lambda>r. is_hashtable l ht * \\<up> (r = length l)>", "unfolding is_hashtable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l)>\n    Array.len (the_array ht)\n    <\\<lambda>r.\n        the_array ht \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (ht_size l (the_size ht) \\<and>\n          ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n        \\<up> (r = length l)>", "by sep_auto"], ["", "subsection \\<open>New\\<close>"], ["", "subsubsection \\<open>Definition\\<close>"], ["", "definition ht_new_sz :: \"nat \\<Rightarrow> ('k::{heap,hashable}, 'v::heap) hashtable Heap\"\nwhere\n  \"ht_new_sz n \\<equiv> do { let l = replicate n [];\n  a \\<leftarrow> Array.of_list l;\n  return (HashTable a 0) }\""], ["", "definition ht_new :: \"('k::{heap,hashable}, 'v::heap) hashtable Heap\"\n  where \"ht_new \\<equiv> ht_new_sz (def_hashmap_size TYPE('k))\""], ["", "subsubsection \\<open>Complete Correctness\\<close>"], ["", "lemma ht_hash_replicate[simp, intro!]: \"ht_hash (replicate n [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_hash (replicate n [])", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ht_hash (replicate 0 [])\n 2. \\<And>n.\n       ht_hash (replicate n []) \\<Longrightarrow>\n       ht_hash (replicate (Suc n) [])", "apply (auto simp add: ht_hash_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n i a b.\n       \\<lbrakk>i < Suc n;\n        (a, b) \\<in> set (([] # replicate n []) ! i)\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat (Suc n) a = i", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n i a b.\n       \\<lbrakk>i < Suc n; (a, b) \\<in> set (([] # replicate n []) ! i);\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat (Suc n) a = i\n 2. \\<And>n i a b nat.\n       \\<lbrakk>i < Suc n; (a, b) \\<in> set (([] # replicate n []) ! i);\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat (Suc n) a = i", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ht_distinct_replicate[simp, intro!]: \"ht_distinct (replicate n [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_distinct (replicate n [])", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ht_distinct (replicate 0 [])\n 2. \\<And>n.\n       ht_distinct (replicate n []) \\<Longrightarrow>\n       ht_distinct (replicate (Suc n) [])", "apply (auto simp add: ht_distinct_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n i.\n       i < Suc n \\<Longrightarrow>\n       distinct (map fst (([] # replicate n []) ! i))", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n i.\n       \\<lbrakk>i < Suc n; i = 0\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (([] # replicate n []) ! i))\n 2. \\<And>n i nat.\n       \\<lbrakk>i < Suc n; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (([] # replicate n []) ! i))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ht_size_replicate[simp, intro!]: \"ht_size (replicate n []) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_size (replicate n []) 0", "by (simp add: ht_size_def)\n\n \\<comment> \\<open>We can't create hash tables with a size of zero\\<close>"], ["", "lemma complete_ht_new_sz: \"1 < n \\<Longrightarrow> <emp> ht_new_sz n <is_hashtable (replicate n [])>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow>\n    <emp> ht_new_sz n <is_hashtable (replicate n [])>", "apply (unfold ht_new_sz_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow>\n    <emp>\n    let l = replicate n []\n    in Array.of_list l \\<bind> (\\<lambda>a. return (HashTable a 0))\n    <is_hashtable (replicate n [])>", "apply (simp del: replicate.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < n \\<Longrightarrow>\n    <emp>\n    Array.of_list (replicate n []) \\<bind>\n    (\\<lambda>a. return (HashTable a 0))\n    <is_hashtable (replicate n [])>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc 0 < n \\<Longrightarrow> <emp> Array.of_list (replicate n []) <?R1>\n 2. \\<And>x.\n       Suc 0 < n \\<Longrightarrow>\n       <?R1 x> return (HashTable x 0) <is_hashtable (replicate n [])>", "apply (rule of_list_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Suc 0 < n \\<Longrightarrow>\n       <x \\<mapsto>\\<^sub>a replicate n []> return (HashTable x 0)\n       <is_hashtable (replicate n [])>", "apply (rule return_cons_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Suc 0 < n \\<Longrightarrow>\n       x \\<mapsto>\\<^sub>a replicate n [] \\<Longrightarrow>\\<^sub>A\n       is_hashtable (replicate n []) (HashTable x 0)", "apply (simp add: is_hashtable_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma complete_ht_new:\n  \"<emp>\n     ht_new::('k::{heap,hashable}, 'v::heap) hashtable Heap\n   <is_hashtable (replicate (def_hashmap_size TYPE('k)) [])>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> ht_new <is_hashtable (replicate (def_hashmap_size TYPE('k)) [])>", "unfolding ht_new_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> ht_new_sz (def_hashmap_size TYPE('k))\n    <is_hashtable (replicate (def_hashmap_size TYPE('k)) [])>", "by (simp add: complete_ht_new_sz[OF def_hashmap_size])"], ["", "subsection \\<open>Lookup\\<close>"], ["", "subsubsection \\<open>Definition\\<close>"], ["", "fun ls_lookup :: \"'k \\<Rightarrow> ('k \\<times> 'v) list \\<Rightarrow> 'v option\"\nwhere\n  \"ls_lookup x [] = None\" |\n  \"ls_lookup x ((k, v) # l) = (if x = k then Some v else ls_lookup x l)\""], ["", "definition ht_lookup :: \"'k \\<Rightarrow> ('k::{heap,hashable}, 'v::heap) hashtable \\<Rightarrow> 'v option Heap\"\nwhere\n  \"ht_lookup x ht = do {\n    m \\<leftarrow> Array.len (the_array ht);\n    let i = bounded_hashcode_nat m x;\n    l \\<leftarrow> Array.nth (the_array ht) i;\n    return (ls_lookup x l)\n  }\""], ["", "subsubsection \\<open>Complete Correctness\\<close>"], ["", "lemma complete_ht_lookup:\n  \"<is_hashtable l ht> ht_lookup x ht\n     <\\<lambda>r. is_hashtable l ht *\n        \\<up>(r = ls_lookup x (l!(bounded_hashcode_nat (length l) x))) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_lookup x ht\n    <\\<lambda>r.\n        is_hashtable l ht *\n        \\<up> (r = ls_lookup x (l ! bounded_hashcode_nat (length l) x))>", "apply (cases ht)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       ht = HashTable x1 x2 \\<Longrightarrow>\n       <is_hashtable l ht> ht_lookup x ht\n       <\\<lambda>r.\n           is_hashtable l ht *\n           \\<up> (r = ls_lookup x (l ! bounded_hashcode_nat (length l) x))>", "apply (clarsimp simp: is_hashtable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l\\<rbrakk>\n       \\<Longrightarrow> <x1 \\<mapsto>\\<^sub>a l>\n                         ht_lookup x (HashTable x1 x2)\n                         <\\<lambda>r.\n                             x1 \\<mapsto>\\<^sub>a l *\n                             \\<up>\n                              (r =\n                               ls_lookup x\n                                (l ! bounded_hashcode_nat (length l) x))>", "apply (simp add: ht_lookup_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l\\<rbrakk>\n       \\<Longrightarrow> <x1 \\<mapsto>\\<^sub>a l>\n                         Array.len x1 \\<bind>\n                         (\\<lambda>m.\n                             Array.nth x1 (bounded_hashcode_nat m x) \\<bind>\n                             (\\<lambda>l. return (ls_lookup x l)))\n                         <\\<lambda>r.\n                             x1 \\<mapsto>\\<^sub>a l *\n                             \\<up>\n                              (r =\n                               ls_lookup x\n                                (l ! bounded_hashcode_nat (length l) x))>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l\\<rbrakk>\n       \\<Longrightarrow> <x1 \\<mapsto>\\<^sub>a l> Array.len x1 <?R9 x1 x2>\n 2. \\<And>x1 x2 xa.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l\\<rbrakk>\n       \\<Longrightarrow> <?R9 x1 x2 xa>\n                         Array.nth x1 (bounded_hashcode_nat xa x) \\<bind>\n                         (\\<lambda>l. return (ls_lookup x l))\n                         <\\<lambda>r.\n                             x1 \\<mapsto>\\<^sub>a l *\n                             \\<up>\n                              (r =\n                               ls_lookup x\n                                (l ! bounded_hashcode_nat (length l) x))>", "apply (rule length_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xa.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l\\<rbrakk>\n       \\<Longrightarrow> <x1 \\<mapsto>\\<^sub>a l * \\<up> (xa = length l)>\n                         Array.nth x1 (bounded_hashcode_nat xa x) \\<bind>\n                         (\\<lambda>l. return (ls_lookup x l))\n                         <\\<lambda>r.\n                             x1 \\<mapsto>\\<^sub>a l *\n                             \\<up>\n                              (r =\n                               ls_lookup x\n                                (l ! bounded_hashcode_nat (length l) x))>", "apply (rule norm_pre_pure_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xa.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l; xa = length l\\<rbrakk>\n       \\<Longrightarrow> <x1 \\<mapsto>\\<^sub>a l>\n                         Array.nth x1 (bounded_hashcode_nat xa x) \\<bind>\n                         (\\<lambda>l. return (ls_lookup x l))\n                         <\\<lambda>r.\n                             x1 \\<mapsto>\\<^sub>a l *\n                             \\<up>\n                              (r =\n                               ls_lookup x\n                                (l ! bounded_hashcode_nat (length l) x))>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 xa.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l; xa = length l\\<rbrakk>\n       \\<Longrightarrow> <x1 \\<mapsto>\\<^sub>a l>\n                         Array.nth x1 (bounded_hashcode_nat xa x)\n                         <?R15 x1 x2 xa>\n 2. \\<And>x1 x2 xa xaa.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l; xa = length l\\<rbrakk>\n       \\<Longrightarrow> <?R15 x1 x2 xa xaa> return (ls_lookup x xaa)\n                         <\\<lambda>r.\n                             x1 \\<mapsto>\\<^sub>a l *\n                             \\<up>\n                              (r =\n                               ls_lookup x\n                                (l ! bounded_hashcode_nat (length l) x))>", "apply (rule nth_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 xa.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l; xa = length l\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat xa x < length l\n 2. \\<And>x1 x2 xa xaa.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l; xa = length l\\<rbrakk>\n       \\<Longrightarrow> <x1 \\<mapsto>\\<^sub>a l *\n                          \\<up> (xaa = l ! bounded_hashcode_nat xa x)>\n                         return (ls_lookup x xaa)\n                         <\\<lambda>r.\n                             x1 \\<mapsto>\\<^sub>a l *\n                             \\<up>\n                              (r =\n                               ls_lookup x\n                                (l ! bounded_hashcode_nat (length l) x))>", "apply (simp add: bounded_hashcode_nat_bounds)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xa xaa.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l; xa = length l\\<rbrakk>\n       \\<Longrightarrow> <x1 \\<mapsto>\\<^sub>a l *\n                          \\<up> (xaa = l ! bounded_hashcode_nat xa x)>\n                         return (ls_lookup x xaa)\n                         <\\<lambda>r.\n                             x1 \\<mapsto>\\<^sub>a l *\n                             \\<up>\n                              (r =\n                               ls_lookup x\n                                (l ! bounded_hashcode_nat (length l) x))>", "apply (rule norm_pre_pure_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xa xaa.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l; xa = length l;\n        xaa = l ! bounded_hashcode_nat xa x\\<rbrakk>\n       \\<Longrightarrow> <x1 \\<mapsto>\\<^sub>a l> return (ls_lookup x xaa)\n                         <\\<lambda>r.\n                             x1 \\<mapsto>\\<^sub>a l *\n                             \\<up>\n                              (r =\n                               ls_lookup x\n                                (l ! bounded_hashcode_nat (length l) x))>", "apply (rule return_cons_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xa xaa.\n       \\<lbrakk>ht = HashTable x1 x2; ht_size l x2; ht_hash l;\n        ht_distinct l; Suc 0 < length l; xa = length l;\n        xaa = l ! bounded_hashcode_nat xa x\\<rbrakk>\n       \\<Longrightarrow> x1 \\<mapsto>\\<^sub>a l \\<Longrightarrow>\\<^sub>A\n                         x1 \\<mapsto>\\<^sub>a l *\n                         \\<up>\n                          (ls_lookup x xaa =\n                           ls_lookup x\n                            (l ! bounded_hashcode_nat (length l) x))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Alternative, more automatic proof\\<close>"], ["", "lemma complete_ht_lookup_alt_proof:\n  \"<is_hashtable l ht> ht_lookup x ht\n    <\\<lambda>r. is_hashtable l ht *\n      \\<up>(r = ls_lookup x (l!(bounded_hashcode_nat (length l) x)))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_lookup x ht\n    <\\<lambda>r.\n        is_hashtable l ht *\n        \\<up> (r = ls_lookup x (l ! bounded_hashcode_nat (length l) x))>", "unfolding is_hashtable_def ht_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l)>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>m.\n        let i = bounded_hashcode_nat m x\n        in Array.nth (the_array ht) i \\<bind>\n           (\\<lambda>l. return (ls_lookup x l)))\n    <\\<lambda>r.\n        the_array ht \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (ht_size l (the_size ht) \\<and>\n          ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n        \\<up> (r = ls_lookup x (l ! bounded_hashcode_nat (length l) x))>", "apply (cases ht)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       ht = HashTable x1 x2 \\<Longrightarrow>\n       <the_array ht \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (ht_size l (the_size ht) \\<and>\n          ht_hash l \\<and> ht_distinct l \\<and> 1 < length l)>\n       Array.len (the_array ht) \\<bind>\n       (\\<lambda>m.\n           let i = bounded_hashcode_nat m x\n           in Array.nth (the_array ht) i \\<bind>\n              (\\<lambda>l. return (ls_lookup x l)))\n       <\\<lambda>r.\n           the_array ht \\<mapsto>\\<^sub>a l *\n           \\<up>\n            (ht_size l (the_size ht) \\<and>\n             ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n           \\<up> (r = ls_lookup x (l ! bounded_hashcode_nat (length l) x))>", "apply (sep_auto simp: bounded_hashcode_nat_bounds)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Update\\<close>"], ["", "subsubsection \\<open>Definition\\<close>"], ["", "fun ls_update :: \"'k \\<Rightarrow> 'v \\<Rightarrow> ('k \\<times> 'v) list \\<Rightarrow> (('k \\<times> 'v) list \\<times> bool)\"\nwhere\n  \"ls_update k v [] = ([(k, v)], False)\" |\n  \"ls_update k v ((l, w) # ls) = (\n    if k = l then\n      ((k, v) # ls, True)\n    else\n      (let r = ls_update k v ls in ((l, w) # fst r, snd r))\n  )\""], ["", "definition abs_update\n  :: \"'k::hashable \\<Rightarrow> 'v \\<Rightarrow> ('k \\<times> 'v) list list \\<Rightarrow> ('k \\<times> 'v) list list\"\n  where\n  \"abs_update k v l =\n    l[bounded_hashcode_nat (length l) k\n      := fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))]\""], ["", "lemma ls_update_snd_set: \"snd (ls_update k v l) \\<longleftrightarrow> k \\<in> set (map fst l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (ls_update k v l) = (k \\<in> set (map fst l))", "by (induct l rule: ls_update.induct) simp_all"], ["", "lemma ls_update_fst_set: \"set (fst (ls_update k v l)) \\<subseteq> insert (k, v) (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (ls_update k v l)) \\<subseteq> insert (k, v) (set l)", "apply (induct l rule: ls_update.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k v.\n       set (fst (ls_update k v [])) \\<subseteq> insert (k, v) (set [])\n 2. \\<And>k v l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        set (fst (ls_update k v ls))\n        \\<subseteq> insert (k, v) (set ls)) \\<Longrightarrow>\n       set (fst (ls_update k v ((l, w) # ls)))\n       \\<subseteq> insert (k, v) (set ((l, w) # ls))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        set (fst (ls_update k v ls))\n        \\<subseteq> insert (k, v) (set ls)) \\<Longrightarrow>\n       set (fst (ls_update k v ((l, w) # ls)))\n       \\<subseteq> insert (k, v) (set ((l, w) # ls))", "apply (auto simp add: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ls_update_fst_map_set: \"set (map fst (fst (ls_update k v l))) = insert k (set (map fst l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (fst (ls_update k v l))) = insert k (set (map fst l))", "apply (induct l rule: ls_update.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k v.\n       set (map fst (fst (ls_update k v []))) = insert k (set (map fst []))\n 2. \\<And>k v l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        set (map fst (fst (ls_update k v ls))) =\n        insert k (set (map fst ls))) \\<Longrightarrow>\n       set (map fst (fst (ls_update k v ((l, w) # ls)))) =\n       insert k (set (map fst ((l, w) # ls)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        set (map fst (fst (ls_update k v ls))) =\n        insert k (set (map fst ls))) \\<Longrightarrow>\n       set (map fst (fst (ls_update k v ((l, w) # ls)))) =\n       insert k (set (map fst ((l, w) # ls)))", "apply (auto simp add: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ls_update_distinct: \"distinct (map fst l) \\<Longrightarrow> distinct (map fst (fst (ls_update k v l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow>\n    distinct (map fst (fst (ls_update k v l)))", "proof (induct l rule: ls_update.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v.\n       distinct (map fst []) \\<Longrightarrow>\n       distinct (map fst (fst (ls_update k v [])))\n 2. \\<And>k v l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (fst (ls_update k v ls)));\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (fst (ls_update k v ((l, w) # ls))))", "case 1"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. \\<And>k v.\n       distinct (map fst []) \\<Longrightarrow>\n       distinct (map fst (fst (ls_update k v [])))\n 2. \\<And>k v l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (fst (ls_update k v ls)));\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (fst (ls_update k v ((l, w) # ls))))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. distinct (map fst (fst (ls_update k_ v_ [])))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (fst (ls_update k_ v_ [])))\n\ngoal (1 subgoal):\n 1. \\<And>k v l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (fst (ls_update k v ls)));\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (fst (ls_update k v ((l, w) # ls))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (fst (ls_update k v ls)));\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (fst (ls_update k v ((l, w) # ls))))", "case (2 k v l w ls)"], ["proof (state)\nthis:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_update k v ls)))\n  distinct (map fst ((l, w) # ls))\n\ngoal (1 subgoal):\n 1. \\<And>k v l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (fst (ls_update k v ls)));\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (fst (ls_update k v ((l, w) # ls))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (fst (ls_update k v ((l, w) # ls))))", "proof (cases \"k = l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = l \\<Longrightarrow>\n    distinct (map fst (fst (ls_update k v ((l, w) # ls))))\n 2. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_update k v ((l, w) # ls))))", "case True"], ["proof (state)\nthis:\n  k = l\n\ngoal (2 subgoals):\n 1. k = l \\<Longrightarrow>\n    distinct (map fst (fst (ls_update k v ((l, w) # ls))))\n 2. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_update k v ((l, w) # ls))))", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_update k v ls)))\n  distinct (map fst ((l, w) # ls))\n  k = l", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_update k v ls)))\n  distinct (map fst ((l, w) # ls))\n  k = l\n\ngoal (1 subgoal):\n 1. distinct (map fst (fst (ls_update k v ((l, w) # ls))))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (fst (ls_update k v ((l, w) # ls))))\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_update k v ((l, w) # ls))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_update k v ((l, w) # ls))))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_update k v ((l, w) # ls))))", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_update k v ls)))\n  distinct (map fst ((l, w) # ls))\n  k \\<noteq> l", "have d: \"distinct (map fst (fst (ls_update k v ls)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_update k v ls)))\n  distinct (map fst ((l, w) # ls))\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. distinct (map fst (fst (ls_update k v ls)))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (fst (ls_update k v ls)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_update k v ((l, w) # ls))))", "from 2(2)"], ["proof (chain)\npicking this:\n  distinct (map fst ((l, w) # ls))", "have \"l \\<notin> set (map fst ls)\""], ["proof (prove)\nusing this:\n  distinct (map fst ((l, w) # ls))\n\ngoal (1 subgoal):\n 1. l \\<notin> set (map fst ls)", "by simp"], ["proof (state)\nthis:\n  l \\<notin> set (map fst ls)\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_update k v ((l, w) # ls))))", "with False"], ["proof (chain)\npicking this:\n  k \\<noteq> l\n  l \\<notin> set (map fst ls)", "have \"l \\<notin> set (map fst (fst (ls_update k v ls)))\""], ["proof (prove)\nusing this:\n  k \\<noteq> l\n  l \\<notin> set (map fst ls)\n\ngoal (1 subgoal):\n 1. l \\<notin> set (map fst (fst (ls_update k v ls)))", "by (simp only: ls_update_fst_map_set) simp"], ["proof (state)\nthis:\n  l \\<notin> set (map fst (fst (ls_update k v ls)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_update k v ((l, w) # ls))))", "with d False"], ["proof (chain)\npicking this:\n  distinct (map fst (fst (ls_update k v ls)))\n  k \\<noteq> l\n  l \\<notin> set (map fst (fst (ls_update k v ls)))", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (map fst (fst (ls_update k v ls)))\n  k \\<noteq> l\n  l \\<notin> set (map fst (fst (ls_update k v ls)))\n\ngoal (1 subgoal):\n 1. distinct (map fst (fst (ls_update k v ((l, w) # ls))))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  distinct (map fst (fst (ls_update k v ((l, w) # ls))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map fst (fst (ls_update k v ((l, w) # ls))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ls_update_length: \"length (fst (ls_update k v l))\n  = (if (k \\<in> set (map fst l)) then length l else Suc (length l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (ls_update k v l)) =\n    (if k \\<in> set (map fst l) then length l else Suc (length l))", "by (induct l rule: ls_update.induct) (auto simp add: Let_def)"], ["", "lemma ls_update_length_snd_True:\n  \"snd (ls_update k v l) \\<Longrightarrow> length (fst (ls_update k v l)) = length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (ls_update k v l) \\<Longrightarrow>\n    length (fst (ls_update k v l)) = length l", "by (simp add: ls_update_length ls_update_snd_set)"], ["", "lemma ls_update_length_snd_False:\n  \"\\<not> snd (ls_update k v l) \\<Longrightarrow> length (fst (ls_update k v l)) = Suc (length l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> snd (ls_update k v l) \\<Longrightarrow>\n    length (fst (ls_update k v l)) = Suc (length l)", "by (simp add: ls_update_length ls_update_snd_set)"], ["", "definition ht_upd\n  :: \"'k \\<Rightarrow> 'v\n    \\<Rightarrow> ('k::{heap,hashable}, 'v::heap) hashtable\n    \\<Rightarrow> ('k, 'v) hashtable Heap\"\n  where\n  \"ht_upd k v ht = do {\n      m \\<leftarrow> Array.len (the_array ht);\n      let i = bounded_hashcode_nat m k;\n      l \\<leftarrow> Array.nth (the_array ht) i;\n      let l = ls_update k v l;\n      Array.upd i (fst l) (the_array ht);\n      let n = (if (snd l) then the_size ht else Suc (the_size ht));\n      return (HashTable (the_array ht) n)\n    }\""], ["", "subsubsection \\<open>Complete Correctness\\<close>"], ["", "lemma ht_hash_update:\n  assumes \"ht_hash ls\"\n  shows \"ht_hash (abs_update k v ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_hash (abs_update k v ls)", "unfolding ht_hash_def abs_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (ls[bounded_hashcode_nat (length ls) k :=\n                      fst (ls_update k v\n                            (ls ! bounded_hashcode_nat (length ls) k))]).\n       \\<forall>x\\<in>set (ls[bounded_hashcode_nat (length ls) k :=\n                                fst (ls_update k v\n(ls ! bounded_hashcode_nat (length ls) k))] !\n                           i).\n          bounded_hashcode_nat\n           (length\n             (ls[bounded_hashcode_nat (length ls) k :=\n                   fst (ls_update k v\n                         (ls ! bounded_hashcode_nat (length ls) k))]))\n           (fst x) =\n          i", "apply (intro allI ballI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length\n                     (ls[bounded_hashcode_nat (length ls) k :=\n                           fst (ls_update k v\n                                 (ls !\n                                  bounded_hashcode_nat (length ls) k))]);\n        x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                          fst (ls_update k v\n                                (ls !\n                                 bounded_hashcode_nat (length ls) k))] !\n                     i)\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat\n                          (length\n                            (ls[bounded_hashcode_nat (length ls) k :=\n                                  fst (ls_update k v\n  (ls ! bounded_hashcode_nat (length ls) k))]))\n                          (fst x) =\n                         i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length ls;\n        x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                          fst (ls_update k v\n                                (ls !\n                                 bounded_hashcode_nat (length ls) k))] !\n                     i)\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat (length ls) (fst x) = i", "subgoal premises prems for i x"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length ls) (fst x) = i", "proof (cases \"i = bounded_hashcode_nat (length ls) k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i\n 2. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "case True"], ["proof (state)\nthis:\n  i = bounded_hashcode_nat (length ls) k\n\ngoal (2 subgoals):\n 1. i = bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i\n 2. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "note i = True"], ["proof (state)\nthis:\n  i = bounded_hashcode_nat (length ls) k\n\ngoal (2 subgoals):\n 1. i = bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i\n 2. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length ls) (fst x) = i", "proof (cases \"fst x = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow> bounded_hashcode_nat (length ls) (fst x) = i\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "case True"], ["proof (state)\nthis:\n  fst x = k\n\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow> bounded_hashcode_nat (length ls) (fst x) = i\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with i"], ["proof (chain)\npicking this:\n  i = bounded_hashcode_nat (length ls) k\n  fst x = k", "show ?thesis"], ["proof (prove)\nusing this:\n  i = bounded_hashcode_nat (length ls) k\n  fst x = k\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length ls) (fst x) = i", "by simp"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length ls) (fst x) = i\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "case False"], ["proof (state)\nthis:\n  fst x \\<noteq> k\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with prems i"], ["proof (chain)\npicking this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_update k v\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  i = bounded_hashcode_nat (length ls) k\n  fst x \\<noteq> k", "have\n        \"x \\<in> set (fst (ls_update k v\n                         (ls ! bounded_hashcode_nat (length ls) k)))\""], ["proof (prove)\nusing this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_update k v\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  i = bounded_hashcode_nat (length ls) k\n  fst x \\<noteq> k\n\ngoal (1 subgoal):\n 1. x \\<in> set (fst (ls_update k v\n                       (ls ! bounded_hashcode_nat (length ls) k)))", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (fst (ls_update k v\n                     (ls ! bounded_hashcode_nat (length ls) k)))\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with\n        ls_update_fst_set[\n          of k v \"ls ! bounded_hashcode_nat (length ls) k\"]\n        False"], ["proof (chain)\npicking this:\n  set (fst (ls_update k v (ls ! bounded_hashcode_nat (length ls) k)))\n  \\<subseteq> insert (k, v) (set (ls ! bounded_hashcode_nat (length ls) k))\n  fst x \\<noteq> k\n  x \\<in> set (fst (ls_update k v\n                     (ls ! bounded_hashcode_nat (length ls) k)))", "have \"x \\<in> insert (k, v)\n                  (set (ls ! bounded_hashcode_nat (length ls) k))\""], ["proof (prove)\nusing this:\n  set (fst (ls_update k v (ls ! bounded_hashcode_nat (length ls) k)))\n  \\<subseteq> insert (k, v) (set (ls ! bounded_hashcode_nat (length ls) k))\n  fst x \\<noteq> k\n  x \\<in> set (fst (ls_update k v\n                     (ls ! bounded_hashcode_nat (length ls) k)))\n\ngoal (1 subgoal):\n 1. x \\<in> insert (k, v) (set (ls ! bounded_hashcode_nat (length ls) k))", "by auto"], ["proof (state)\nthis:\n  x \\<in> insert (k, v) (set (ls ! bounded_hashcode_nat (length ls) k))\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with False"], ["proof (chain)\npicking this:\n  fst x \\<noteq> k\n  x \\<in> insert (k, v) (set (ls ! bounded_hashcode_nat (length ls) k))", "have \"x \\<in> set (ls ! bounded_hashcode_nat (length ls) k)\""], ["proof (prove)\nusing this:\n  fst x \\<noteq> k\n  x \\<in> insert (k, v) (set (ls ! bounded_hashcode_nat (length ls) k))\n\ngoal (1 subgoal):\n 1. x \\<in> set (ls ! bounded_hashcode_nat (length ls) k)", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (ls ! bounded_hashcode_nat (length ls) k)\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with i prems assms[unfolded ht_hash_def]"], ["proof (chain)\npicking this:\n  i = bounded_hashcode_nat (length ls) k\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_update k v\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  \\<forall>i<length ls.\n     \\<forall>x\\<in>set (ls ! i).\n        bounded_hashcode_nat (length ls) (fst x) = i\n  x \\<in> set (ls ! bounded_hashcode_nat (length ls) k)", "show ?thesis"], ["proof (prove)\nusing this:\n  i = bounded_hashcode_nat (length ls) k\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_update k v\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  \\<forall>i<length ls.\n     \\<forall>x\\<in>set (ls ! i).\n        bounded_hashcode_nat (length ls) (fst x) = i\n  x \\<in> set (ls ! bounded_hashcode_nat (length ls) k)\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length ls) (fst x) = i", "by simp"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length ls) (fst x) = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length ls) (fst x) = i\n\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "case False"], ["proof (state)\nthis:\n  i \\<noteq> bounded_hashcode_nat (length ls) k\n\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with prems"], ["proof (chain)\npicking this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_update k v\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  i \\<noteq> bounded_hashcode_nat (length ls) k", "have \"x \\<in> set (ls ! i)\""], ["proof (prove)\nusing this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_update k v\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  i \\<noteq> bounded_hashcode_nat (length ls) k\n\ngoal (1 subgoal):\n 1. x \\<in> set (ls ! i)", "by simp"], ["proof (state)\nthis:\n  x \\<in> set (ls ! i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with prems assms[unfolded ht_hash_def]"], ["proof (chain)\npicking this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_update k v\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  \\<forall>i<length ls.\n     \\<forall>x\\<in>set (ls ! i).\n        bounded_hashcode_nat (length ls) (fst x) = i\n  x \\<in> set (ls ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_update k v\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  \\<forall>i<length ls.\n     \\<forall>x\\<in>set (ls ! i).\n        bounded_hashcode_nat (length ls) (fst x) = i\n  x \\<in> set (ls ! i)\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length ls) (fst x) = i", "by simp"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length ls) (fst x) = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ht_distinct_update:\n  assumes \"ht_distinct l\"\n  shows \"ht_distinct (abs_update k v l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_distinct (abs_update k v l)", "unfolding ht_distinct_def abs_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (l[bounded_hashcode_nat (length l) k :=\n                     fst (ls_update k v\n                           (l ! bounded_hashcode_nat (length l) k))]).\n       distinct\n        (map fst\n          (l[bounded_hashcode_nat (length l) k :=\n               fst (ls_update k v\n                     (l ! bounded_hashcode_nat (length l) k))] !\n           i))", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (l[bounded_hashcode_nat (length l) k :=\n                 fst (ls_update k v\n                       (l !\n                        bounded_hashcode_nat (length l)\n                         k))]) \\<Longrightarrow>\n       distinct\n        (map fst\n          (l[bounded_hashcode_nat (length l) k :=\n               fst (ls_update k v\n                     (l ! bounded_hashcode_nat (length l) k))] !\n           i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length l \\<Longrightarrow>\n       distinct\n        (map fst\n          (l[bounded_hashcode_nat (length l) k :=\n               fst (ls_update k v\n                     (l ! bounded_hashcode_nat (length l) k))] !\n           i))", "subgoal premises prems for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "proof (cases \"i = bounded_hashcode_nat (length l) k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))\n 2. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "case True"], ["proof (state)\nthis:\n  i = bounded_hashcode_nat (length l) k\n\ngoal (2 subgoals):\n 1. i = bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))\n 2. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "with prems assms[unfolded ht_distinct_def]"], ["proof (chain)\npicking this:\n  i < length l\n  \\<forall>i<length l. distinct (map fst (l ! i))\n  i = bounded_hashcode_nat (length l) k", "have \"distinct (map fst (l ! bounded_hashcode_nat (length l) k))\""], ["proof (prove)\nusing this:\n  i < length l\n  \\<forall>i<length l. distinct (map fst (l ! i))\n  i = bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. distinct (map fst (l ! bounded_hashcode_nat (length l) k))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (l ! bounded_hashcode_nat (length l) k))\n\ngoal (2 subgoals):\n 1. i = bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))\n 2. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "from ls_update_distinct[OF this, of k v] True prems"], ["proof (chain)\npicking this:\n  distinct\n   (map fst (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))))\n  i = bounded_hashcode_nat (length l) k\n  i < length l", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct\n   (map fst (fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))))\n  i = bounded_hashcode_nat (length l) k\n  i < length l\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "by simp"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n      i))\n\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "with prems assms[unfolded ht_distinct_def]"], ["proof (chain)\npicking this:\n  i < length l\n  \\<forall>i<length l. distinct (map fst (l ! i))\n  i \\<noteq> bounded_hashcode_nat (length l) k", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length l\n  \\<forall>i<length l. distinct (map fst (l ! i))\n  i \\<noteq> bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "by simp"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_update k v (l ! bounded_hashcode_nat (length l) k))] !\n      i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_update:\n  assumes \"1 < length l\"\n  shows \"1 < length (abs_update k v l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (abs_update k v l)", "using assms"], ["proof (prove)\nusing this:\n  1 < length l\n\ngoal (1 subgoal):\n 1. 1 < length (abs_update k v l)", "by (simp add: abs_update_def)"], ["", "lemma ht_size_update1:\n  assumes size: \"ht_size l n\"\n  assumes i: \"i < length l\"\n  assumes snd: \"snd (ls_update k v (l ! i))\"\n  shows \"ht_size (l[i := fst (ls_update k v (l!i))]) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) n", "have \"(map length (l[i := fst (ls_update k v (l ! i))]))\n    = (map length l)[i := length (fst (ls_update k v (l ! i)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map length (l[i := fst (ls_update k v (l ! i))]) = (map length l)\n    [i := length (fst (ls_update k v (l ! i)))]", "by (simp add: map_update)"], ["proof (state)\nthis:\n  map length (l[i := fst (ls_update k v (l ! i))]) = (map length l)\n  [i := length (fst (ls_update k v (l ! i)))]\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) n", "also"], ["proof (state)\nthis:\n  map length (l[i := fst (ls_update k v (l ! i))]) = (map length l)\n  [i := length (fst (ls_update k v (l ! i)))]\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) n", "from sum_list_update[of i \"map length l\", simplified, OF i,\n    of \"length (fst (ls_update k v (l ! i)))\"]\n    ls_update_length_snd_True[OF snd]"], ["proof (chain)\npicking this:\n  sum_list ((map length l)[i := length (fst (ls_update k v (l ! i)))]) =\n  sum_list (map length l) + length (fst (ls_update k v (l ! i))) -\n  length (l ! i)\n  length (fst (ls_update k v (l ! i))) = length (l ! i)", "have\n    \"sum_list ((map length l)[i := length (fst (ls_update k v (l ! i)))])\n    = sum_list (map length l)\""], ["proof (prove)\nusing this:\n  sum_list ((map length l)[i := length (fst (ls_update k v (l ! i)))]) =\n  sum_list (map length l) + length (fst (ls_update k v (l ! i))) -\n  length (l ! i)\n  length (fst (ls_update k v (l ! i))) = length (l ! i)\n\ngoal (1 subgoal):\n 1. sum_list ((map length l)[i := length (fst (ls_update k v (l ! i)))]) =\n    sum_list (map length l)", "by simp"], ["proof (state)\nthis:\n  sum_list ((map length l)[i := length (fst (ls_update k v (l ! i)))]) =\n  sum_list (map length l)\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) n", "finally"], ["proof (chain)\npicking this:\n  sum_list (map length (l[i := fst (ls_update k v (l ! i))])) =\n  sum_list (map length l)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map length (l[i := fst (ls_update k v (l ! i))])) =\n  sum_list (map length l)\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) n", "using assms"], ["proof (prove)\nusing this:\n  sum_list (map length (l[i := fst (ls_update k v (l ! i))])) =\n  sum_list (map length l)\n  ht_size l n\n  i < length l\n  snd (ls_update k v (l ! i))\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) n", "by (simp add: ht_size_def assms)"], ["proof (state)\nthis:\n  ht_size (l[i := fst (ls_update k v (l ! i))]) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ht_size_update2:\n  assumes size: \"ht_size l n\"\n  assumes i: \"i < length l\"\n  assumes snd: \"\\<not> snd (ls_update k v (l ! i))\"\n  shows \"ht_size (l[i := fst (ls_update k v (l!i))]) (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) (Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) (Suc n)", "have \"(map length (l[i := fst (ls_update k v (l ! i))]))\n    = (map length l)[i := length (fst (ls_update k v (l ! i)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map length (l[i := fst (ls_update k v (l ! i))]) = (map length l)\n    [i := length (fst (ls_update k v (l ! i)))]", "by (simp add: map_update)"], ["proof (state)\nthis:\n  map length (l[i := fst (ls_update k v (l ! i))]) = (map length l)\n  [i := length (fst (ls_update k v (l ! i)))]\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) (Suc n)", "also"], ["proof (state)\nthis:\n  map length (l[i := fst (ls_update k v (l ! i))]) = (map length l)\n  [i := length (fst (ls_update k v (l ! i)))]\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) (Suc n)", "from sum_list_update[of i \"map length l\", simplified, OF i,\n    of \"length (fst (ls_update k v (l ! i)))\"]\n    ls_update_length_snd_False[OF snd]"], ["proof (chain)\npicking this:\n  sum_list ((map length l)[i := length (fst (ls_update k v (l ! i)))]) =\n  sum_list (map length l) + length (fst (ls_update k v (l ! i))) -\n  length (l ! i)\n  length (fst (ls_update k v (l ! i))) = Suc (length (l ! i))", "have\n    \"sum_list ((map length l)[i := length (fst (ls_update k v (l ! i)))])\n    = Suc (sum_list (map length l))\""], ["proof (prove)\nusing this:\n  sum_list ((map length l)[i := length (fst (ls_update k v (l ! i)))]) =\n  sum_list (map length l) + length (fst (ls_update k v (l ! i))) -\n  length (l ! i)\n  length (fst (ls_update k v (l ! i))) = Suc (length (l ! i))\n\ngoal (1 subgoal):\n 1. sum_list ((map length l)[i := length (fst (ls_update k v (l ! i)))]) =\n    Suc (sum_list (map length l))", "by simp"], ["proof (state)\nthis:\n  sum_list ((map length l)[i := length (fst (ls_update k v (l ! i)))]) =\n  Suc (sum_list (map length l))\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) (Suc n)", "finally"], ["proof (chain)\npicking this:\n  sum_list (map length (l[i := fst (ls_update k v (l ! i))])) =\n  Suc (sum_list (map length l))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map length (l[i := fst (ls_update k v (l ! i))])) =\n  Suc (sum_list (map length l))\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) (Suc n)", "using assms"], ["proof (prove)\nusing this:\n  sum_list (map length (l[i := fst (ls_update k v (l ! i))])) =\n  Suc (sum_list (map length l))\n  ht_size l n\n  i < length l\n  \\<not> snd (ls_update k v (l ! i))\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_update k v (l ! i))]) (Suc n)", "by (simp add: ht_size_def assms)"], ["proof (state)\nthis:\n  ht_size (l[i := fst (ls_update k v (l ! i))]) (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complete_ht_upd: \"<is_hashtable l ht> ht_upd k v ht\n  <is_hashtable (abs_update k v l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_upd k v ht <is_hashtable (abs_update k v l)>", "unfolding ht_upd_def is_hashtable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l)>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>m.\n        let i = bounded_hashcode_nat m k\n        in Array.nth (the_array ht) i \\<bind>\n           (\\<lambda>l.\n               let l = ls_update k v l\n               in Array.upd i (fst l) (the_array ht) \\<bind>\n                  (\\<lambda>_.\n                      let n = if snd l then the_size ht\n                              else Suc (the_size ht)\n                      in return (HashTable (the_array ht) n))))\n    <\\<lambda>ht.\n        the_array ht \\<mapsto>\\<^sub>a abs_update k v l *\n        \\<up>\n         (ht_size (abs_update k v l) (the_size ht) \\<and>\n          ht_hash (abs_update k v l) \\<and>\n          ht_distinct (abs_update k v l) \\<and>\n          1 < length (abs_update k v l))>", "apply (rule norm_pre_pure_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_size l (the_size ht) \\<and>\n    ht_hash l \\<and> ht_distinct l \\<and> 1 < length l \\<Longrightarrow>\n    <the_array ht \\<mapsto>\\<^sub>a l>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>m.\n        let i = bounded_hashcode_nat m k\n        in Array.nth (the_array ht) i \\<bind>\n           (\\<lambda>l.\n               let l = ls_update k v l\n               in Array.upd i (fst l) (the_array ht) \\<bind>\n                  (\\<lambda>_.\n                      let n = if snd l then the_size ht\n                              else Suc (the_size ht)\n                      in return (HashTable (the_array ht) n))))\n    <\\<lambda>ht.\n        the_array ht \\<mapsto>\\<^sub>a abs_update k v l *\n        \\<up>\n         (ht_size (abs_update k v l) (the_size ht) \\<and>\n          ht_hash (abs_update k v l) \\<and>\n          ht_distinct (abs_update k v l) \\<and>\n          1 < length (abs_update k v l))>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ht_size l (the_size ht) \\<and>\n    ht_hash l \\<and> ht_distinct l \\<and> 1 < length l \\<Longrightarrow>\n    <the_array ht \\<mapsto>\\<^sub>a l> Array.len (the_array ht) <?R2>\n 2. \\<And>x.\n       ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l \\<Longrightarrow>\n       <?R2 x>\n       let i = bounded_hashcode_nat x k\n       in Array.nth (the_array ht) i \\<bind>\n          (\\<lambda>l.\n              let l = ls_update k v l\n              in Array.upd i (fst l) (the_array ht) \\<bind>\n                 (\\<lambda>_.\n                     let n = if snd l then the_size ht\n                             else Suc (the_size ht)\n                     in return (HashTable (the_array ht) n)))\n       <\\<lambda>ht.\n           the_array ht \\<mapsto>\\<^sub>a abs_update k v l *\n           \\<up>\n            (ht_size (abs_update k v l) (the_size ht) \\<and>\n             ht_hash (abs_update k v l) \\<and>\n             ht_distinct (abs_update k v l) \\<and>\n             1 < length (abs_update k v l))>", "apply (rule length_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l \\<Longrightarrow>\n       <the_array ht \\<mapsto>\\<^sub>a l * \\<up> (x = length l)>\n       let i = bounded_hashcode_nat x k\n       in Array.nth (the_array ht) i \\<bind>\n          (\\<lambda>l.\n              let l = ls_update k v l\n              in Array.upd i (fst l) (the_array ht) \\<bind>\n                 (\\<lambda>_.\n                     let n = if snd l then the_size ht\n                             else Suc (the_size ht)\n                     in return (HashTable (the_array ht) n)))\n       <\\<lambda>ht.\n           the_array ht \\<mapsto>\\<^sub>a abs_update k v l *\n           \\<up>\n            (ht_size (abs_update k v l) (the_size ht) \\<and>\n             ht_hash (abs_update k v l) \\<and>\n             ht_distinct (abs_update k v l) \\<and>\n             1 < length (abs_update k v l))>", "apply (rule norm_pre_pure_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> 1 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l>\n                         let i = bounded_hashcode_nat x k\n                         in Array.nth (the_array ht) i \\<bind>\n                            (\\<lambda>l.\n                                let l = ls_update k v l\n                                in Array.upd i (fst l)\n                                    (the_array ht) \\<bind>\n                                   (\\<lambda>_.\n let n = if snd l then the_size ht else Suc (the_size ht)\n in return (HashTable (the_array ht) n)))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a\n                             abs_update k v l *\n                             \\<up>\n                              (ht_size (abs_update k v l)\n                                (the_size ht) \\<and>\n                               ht_hash (abs_update k v l) \\<and>\n                               ht_distinct (abs_update k v l) \\<and>\n                               1 < length (abs_update k v l))>", "apply (simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l>\n                         Array.nth (the_array ht)\n                          (bounded_hashcode_nat (length l) k) \\<bind>\n                         (\\<lambda>la.\n                             Array.upd (bounded_hashcode_nat (length l) k)\n                              (fst (ls_update k v la))\n                              (the_array ht) \\<bind>\n                             (\\<lambda>_.\n                                 return\n                                  (HashTable (the_array ht)\n                                    (if snd (ls_update k v la)\n                                     then the_size ht\n                                     else Suc (the_size ht)))))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a\n                             abs_update k v l *\n                             \\<up>\n                              (ht_size (abs_update k v l)\n                                (the_size ht) \\<and>\n                               ht_hash (abs_update k v l) \\<and>\n                               ht_distinct (abs_update k v l) \\<and>\n                               Suc 0 < length (abs_update k v l))>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l>\n                         Array.nth (the_array ht)\n                          (bounded_hashcode_nat (length l) k)\n                         <?R8 x>\n 2. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <?R8 x xa>\n                         Array.upd (bounded_hashcode_nat (length l) k)\n                          (fst (ls_update k v xa)) (the_array ht) \\<bind>\n                         (\\<lambda>_.\n                             return\n                              (HashTable (the_array ht)\n                                (if snd (ls_update k v xa) then the_size ht\n                                 else Suc (the_size ht))))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a\n                             abs_update k v l *\n                             \\<up>\n                              (ht_size (abs_update k v l)\n                                (the_size ht) \\<and>\n                               ht_hash (abs_update k v l) \\<and>\n                               ht_distinct (abs_update k v l) \\<and>\n                               Suc 0 < length (abs_update k v l))>", "apply (rule nth_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat (length l) k < length l\n 2. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l *\n                          \\<up>\n                           (xa = l ! bounded_hashcode_nat (length l) k)>\n                         Array.upd (bounded_hashcode_nat (length l) k)\n                          (fst (ls_update k v xa)) (the_array ht) \\<bind>\n                         (\\<lambda>_.\n                             return\n                              (HashTable (the_array ht)\n                                (if snd (ls_update k v xa) then the_size ht\n                                 else Suc (the_size ht))))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a\n                             abs_update k v l *\n                             \\<up>\n                              (ht_size (abs_update k v l)\n                                (the_size ht) \\<and>\n                               ht_hash (abs_update k v l) \\<and>\n                               ht_distinct (abs_update k v l) \\<and>\n                               Suc 0 < length (abs_update k v l))>", "apply (simp add: bounded_hashcode_nat_bounds)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l *\n                          \\<up>\n                           (xa = l ! bounded_hashcode_nat (length l) k)>\n                         Array.upd (bounded_hashcode_nat (length l) k)\n                          (fst (ls_update k v xa)) (the_array ht) \\<bind>\n                         (\\<lambda>_.\n                             return\n                              (HashTable (the_array ht)\n                                (if snd (ls_update k v xa) then the_size ht\n                                 else Suc (the_size ht))))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a\n                             abs_update k v l *\n                             \\<up>\n                              (ht_size (abs_update k v l)\n                                (the_size ht) \\<and>\n                               ht_hash (abs_update k v l) \\<and>\n                               ht_distinct (abs_update k v l) \\<and>\n                               Suc 0 < length (abs_update k v l))>", "apply (rule norm_pre_pure_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l>\n                         Array.upd (bounded_hashcode_nat (length l) k)\n                          (fst (ls_update k v xa)) (the_array ht) \\<bind>\n                         (\\<lambda>_.\n                             return\n                              (HashTable (the_array ht)\n                                (if snd (ls_update k v xa) then the_size ht\n                                 else Suc (the_size ht))))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a\n                             abs_update k v l *\n                             \\<up>\n                              (ht_size (abs_update k v l)\n                                (the_size ht) \\<and>\n                               ht_hash (abs_update k v l) \\<and>\n                               ht_distinct (abs_update k v l) \\<and>\n                               Suc 0 < length (abs_update k v l))>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l>\n                         Array.upd (bounded_hashcode_nat (length l) k)\n                          (fst (ls_update k v xa)) (the_array ht)\n                         <?R15 x xa>\n 2. \\<And>x xa xb.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> <?R15 x xa xb>\n                         return\n                          (HashTable (the_array ht)\n                            (if snd (ls_update k v xa) then the_size ht\n                             else Suc (the_size ht)))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a\n                             abs_update k v l *\n                             \\<up>\n                              (ht_size (abs_update k v l)\n                                (the_size ht) \\<and>\n                               ht_hash (abs_update k v l) \\<and>\n                               ht_distinct (abs_update k v l) \\<and>\n                               Suc 0 < length (abs_update k v l))>", "apply (rule upd_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat (length l) k < length l\n 2. \\<And>x xa xb.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l\n                          [bounded_hashcode_nat (length l) k :=\n                             fst (ls_update k v xa)] *\n                          \\<up> (xb = the_array ht)>\n                         return\n                          (HashTable (the_array ht)\n                            (if snd (ls_update k v xa) then the_size ht\n                             else Suc (the_size ht)))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a\n                             abs_update k v l *\n                             \\<up>\n                              (ht_size (abs_update k v l)\n                                (the_size ht) \\<and>\n                               ht_hash (abs_update k v l) \\<and>\n                               ht_distinct (abs_update k v l) \\<and>\n                               Suc 0 < length (abs_update k v l))>", "apply (simp add: bounded_hashcode_nat_bounds)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l\n                          [bounded_hashcode_nat (length l) k :=\n                             fst (ls_update k v xa)] *\n                          \\<up> (xb = the_array ht)>\n                         return\n                          (HashTable (the_array ht)\n                            (if snd (ls_update k v xa) then the_size ht\n                             else Suc (the_size ht)))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a\n                             abs_update k v l *\n                             \\<up>\n                              (ht_size (abs_update k v l)\n                                (the_size ht) \\<and>\n                               ht_hash (abs_update k v l) \\<and>\n                               ht_distinct (abs_update k v l) \\<and>\n                               Suc 0 < length (abs_update k v l))>", "apply (rule return_cons_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> the_array ht \\<mapsto>\\<^sub>a l\n                         [bounded_hashcode_nat (length l) k :=\n                            fst (ls_update k v xa)] *\n                         \\<up> (xb = the_array ht) \\<Longrightarrow>\\<^sub>A\n                         the_array\n                          (HashTable (the_array ht)\n                            (if snd (ls_update k v xa) then the_size ht\n                             else Suc (the_size ht))) \\<mapsto>\\<^sub>a\n                         abs_update k v l *\n                         \\<up>\n                          (ht_size (abs_update k v l)\n                            (the_size\n                              (HashTable (the_array ht)\n                                (if snd (ls_update k v xa) then the_size ht\n                                 else Suc (the_size ht)))) \\<and>\n                           ht_hash (abs_update k v l) \\<and>\n                           ht_distinct (abs_update k v l) \\<and>\n                           Suc 0 < length (abs_update k v l))", "apply (auto\n    simp add: ht_size_update1 ht_size_update2 bounded_hashcode_nat_bounds\n              is_hashtable_def ht_hash_update[unfolded abs_update_def]\n              ht_distinct_update[unfolded abs_update_def] abs_update_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Alternative, more automatic proof\\<close>"], ["", "lemma complete_ht_upd_alt_proof:\n  \"<is_hashtable l ht> ht_upd k v ht <is_hashtable (abs_update k v l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_upd k v ht <is_hashtable (abs_update k v l)>", "unfolding ht_upd_def is_hashtable_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l)>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>m.\n        Array.nth (the_array ht) (bounded_hashcode_nat m k) \\<bind>\n        (\\<lambda>l.\n            Array.upd (bounded_hashcode_nat m k) (fst (ls_update k v l))\n             (the_array ht) \\<bind>\n            (\\<lambda>_.\n                return\n                 (HashTable (the_array ht)\n                   (if snd (ls_update k v l) then the_size ht\n                    else Suc (the_size ht))))))\n    <\\<lambda>ht.\n        the_array ht \\<mapsto>\\<^sub>a abs_update k v l *\n        \\<up>\n         (ht_size (abs_update k v l) (the_size ht) \\<and>\n          ht_hash (abs_update k v l) \\<and>\n          ht_distinct (abs_update k v l) \\<and>\n          1 < length (abs_update k v l))>", "(* TODO: Is this huge simp-step really necessary? *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l)>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>m.\n        Array.nth (the_array ht) (bounded_hashcode_nat m k) \\<bind>\n        (\\<lambda>l.\n            Array.upd (bounded_hashcode_nat m k) (fst (ls_update k v l))\n             (the_array ht) \\<bind>\n            (\\<lambda>_.\n                return\n                 (HashTable (the_array ht)\n                   (if snd (ls_update k v l) then the_size ht\n                    else Suc (the_size ht))))))\n    <\\<lambda>ht.\n        the_array ht \\<mapsto>\\<^sub>a abs_update k v l *\n        \\<up>\n         (ht_size (abs_update k v l) (the_size ht) \\<and>\n          ht_hash (abs_update k v l) \\<and>\n          ht_distinct (abs_update k v l) \\<and>\n          1 < length (abs_update k v l))>", "apply (sep_auto\n    simp: ht_size_update1 ht_size_update2 bounded_hashcode_nat_bounds\n              is_hashtable_def ht_hash_update[unfolded abs_update_def]\n              ht_distinct_update[unfolded abs_update_def] abs_update_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Delete\\<close>"], ["", "subsubsection \\<open>Definition\\<close>"], ["", "fun ls_delete :: \"'k \\<Rightarrow> ('k \\<times> 'v) list \\<Rightarrow> (('k \\<times> 'v) list \\<times> bool)\" where\n  \"ls_delete k [] = ([], False)\" |\n  \"ls_delete k ((l, w) # ls) = (\n    if k = l then\n      (ls, True)\n    else\n      (let r = ls_delete k ls in ((l, w) # fst r, snd r)))\""], ["", "lemma ls_delete_snd_set: \"snd (ls_delete k l) \\<longleftrightarrow> k \\<in> set (map fst l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (ls_delete k l) = (k \\<in> set (map fst l))", "by (induct l rule: ls_delete.induct) simp_all"], ["", "lemma ls_delete_fst_set: \"set (fst (ls_delete k l)) \\<subseteq> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (ls_delete k l)) \\<subseteq> set l", "apply (induct l rule: ls_delete.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k. set (fst (ls_delete k [])) \\<subseteq> set []\n 2. \\<And>k l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        set (fst (ls_delete k ls)) \\<subseteq> set ls) \\<Longrightarrow>\n       set (fst (ls_delete k ((l, w) # ls))) \\<subseteq> set ((l, w) # ls)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        set (fst (ls_delete k ls)) \\<subseteq> set ls) \\<Longrightarrow>\n       set (fst (ls_delete k ((l, w) # ls))) \\<subseteq> set ((l, w) # ls)", "apply (auto simp add: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ls_delete_fst_map_set:\n  \"distinct (map fst l) \\<Longrightarrow>\n  set (map fst (fst (ls_delete k l))) = (set (map fst l)) - {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow>\n    set (map fst (fst (ls_delete k l))) = set (map fst l) - {k}", "apply (induct l rule: ls_delete.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       distinct (map fst []) \\<Longrightarrow>\n       set (map fst (fst (ls_delete k []))) = set (map fst []) - {k}\n 2. \\<And>k l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> set (map fst (fst (ls_delete k ls))) =\n                                  set (map fst ls) - {k};\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> set (map fst (fst (ls_delete k ((l, w) # ls)))) =\n                         set (map fst ((l, w) # ls)) - {k}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> set (map fst (fst (ls_delete k ls))) =\n                                  set (map fst ls) - {k};\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> set (map fst (fst (ls_delete k ((l, w) # ls)))) =\n                         set (map fst ((l, w) # ls)) - {k}", "apply (auto simp add: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ls_delete_distinct: \"distinct (map fst l) \\<Longrightarrow> distinct (map fst (fst (ls_delete k l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k l)))", "proof (induct l rule: ls_delete.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       distinct (map fst []) \\<Longrightarrow>\n       distinct (map fst (fst (ls_delete k [])))\n 2. \\<And>k l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)));\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (fst (ls_delete k ((l, w) # ls))))", "case 1"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       distinct (map fst []) \\<Longrightarrow>\n       distinct (map fst (fst (ls_delete k [])))\n 2. \\<And>k l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)));\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (fst (ls_delete k ((l, w) # ls))))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. distinct (map fst (fst (ls_delete k_ [])))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (fst (ls_delete k_ [])))\n\ngoal (1 subgoal):\n 1. \\<And>k l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)));\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (fst (ls_delete k ((l, w) # ls))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)));\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (fst (ls_delete k ((l, w) # ls))))", "case (2 k l w ls)"], ["proof (state)\nthis:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)))\n  distinct (map fst ((l, w) # ls))\n\ngoal (1 subgoal):\n 1. \\<And>k l w ls.\n       \\<lbrakk>\\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n                \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)));\n        distinct (map fst ((l, w) # ls))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (fst (ls_delete k ((l, w) # ls))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "proof (cases \"k = l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = l \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k ((l, w) # ls))))\n 2. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "case True"], ["proof (state)\nthis:\n  k = l\n\ngoal (2 subgoals):\n 1. k = l \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k ((l, w) # ls))))\n 2. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)))\n  distinct (map fst ((l, w) # ls))\n  k = l", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)))\n  distinct (map fst ((l, w) # ls))\n  k = l\n\ngoal (1 subgoal):\n 1. distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (fst (ls_delete k ((l, w) # ls))))\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)))\n  distinct (map fst ((l, w) # ls))\n  k \\<noteq> l", "have d: \"distinct (map fst (fst (ls_delete k ls)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)))\n  distinct (map fst ((l, w) # ls))\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. distinct (map fst (fst (ls_delete k ls)))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (fst (ls_delete k ls)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)))\n  distinct (map fst ((l, w) # ls))", "have d2: \"distinct (map fst ls)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)))\n  distinct (map fst ((l, w) # ls))\n\ngoal (1 subgoal):\n 1. distinct (map fst ls)", "by simp"], ["proof (state)\nthis:\n  distinct (map fst ls)\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "from 2(2)"], ["proof (chain)\npicking this:\n  distinct (map fst ((l, w) # ls))", "have \"l \\<notin> set (map fst ls)\""], ["proof (prove)\nusing this:\n  distinct (map fst ((l, w) # ls))\n\ngoal (1 subgoal):\n 1. l \\<notin> set (map fst ls)", "by simp"], ["proof (state)\nthis:\n  l \\<notin> set (map fst ls)\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "with False 2 ls_delete_fst_map_set[OF d2, of k]"], ["proof (chain)\npicking this:\n  k \\<noteq> l\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)))\n  distinct (map fst ((l, w) # ls))\n  set (map fst (fst (ls_delete k ls))) = set (map fst ls) - {k}\n  l \\<notin> set (map fst ls)", "have \"l \\<notin> set (map fst (fst (ls_delete k ls)))\""], ["proof (prove)\nusing this:\n  k \\<noteq> l\n  \\<lbrakk>k \\<noteq> l; distinct (map fst ls)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (fst (ls_delete k ls)))\n  distinct (map fst ((l, w) # ls))\n  set (map fst (fst (ls_delete k ls))) = set (map fst ls) - {k}\n  l \\<notin> set (map fst ls)\n\ngoal (1 subgoal):\n 1. l \\<notin> set (map fst (fst (ls_delete k ls)))", "by simp"], ["proof (state)\nthis:\n  l \\<notin> set (map fst (fst (ls_delete k ls)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "with d False"], ["proof (chain)\npicking this:\n  distinct (map fst (fst (ls_delete k ls)))\n  k \\<noteq> l\n  l \\<notin> set (map fst (fst (ls_delete k ls)))", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (map fst (fst (ls_delete k ls)))\n  k \\<noteq> l\n  l \\<notin> set (map fst (fst (ls_delete k ls)))\n\ngoal (1 subgoal):\n 1. distinct (map fst (fst (ls_delete k ((l, w) # ls))))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  distinct (map fst (fst (ls_delete k ((l, w) # ls))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map fst (fst (ls_delete k ((l, w) # ls))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ls_delete_length:\n  \"length (fst (ls_delete k l)) = (\n    if (k \\<in> set (map fst l)) then\n      (length l - 1)\n    else\n      length l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (ls_delete k l)) =\n    (if k \\<in> set (map fst l) then length l - 1 else length l)", "proof (induct l rule: ls_delete.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       length (fst (ls_delete k [])) =\n       (if k \\<in> set (map fst []) then length [] - 1 else length [])\n 2. \\<And>k l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        length (fst (ls_delete k ls)) =\n        (if k \\<in> set (map fst ls) then length ls - 1\n         else length ls)) \\<Longrightarrow>\n       length (fst (ls_delete k ((l, w) # ls))) =\n       (if k \\<in> set (map fst ((l, w) # ls)) then length ((l, w) # ls) - 1\n        else length ((l, w) # ls))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>k.\n       length (fst (ls_delete k [])) =\n       (if k \\<in> set (map fst []) then length [] - 1 else length [])\n 2. \\<And>k l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        length (fst (ls_delete k ls)) =\n        (if k \\<in> set (map fst ls) then length ls - 1\n         else length ls)) \\<Longrightarrow>\n       length (fst (ls_delete k ((l, w) # ls))) =\n       (if k \\<in> set (map fst ((l, w) # ls)) then length ((l, w) # ls) - 1\n        else length ((l, w) # ls))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (ls_delete k_ [])) =\n    (if k_ \\<in> set (map fst []) then length [] - 1 else length [])", "by simp"], ["proof (state)\nthis:\n  length (fst (ls_delete k_ [])) =\n  (if k_ \\<in> set (map fst []) then length [] - 1 else length [])\n\ngoal (1 subgoal):\n 1. \\<And>k l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        length (fst (ls_delete k ls)) =\n        (if k \\<in> set (map fst ls) then length ls - 1\n         else length ls)) \\<Longrightarrow>\n       length (fst (ls_delete k ((l, w) # ls))) =\n       (if k \\<in> set (map fst ((l, w) # ls)) then length ((l, w) # ls) - 1\n        else length ((l, w) # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        length (fst (ls_delete k ls)) =\n        (if k \\<in> set (map fst ls) then length ls - 1\n         else length ls)) \\<Longrightarrow>\n       length (fst (ls_delete k ((l, w) # ls))) =\n       (if k \\<in> set (map fst ((l, w) # ls)) then length ((l, w) # ls) - 1\n        else length ((l, w) # ls))", "case (2 k l w ls)"], ["proof (state)\nthis:\n  k \\<noteq> l \\<Longrightarrow>\n  length (fst (ls_delete k ls)) =\n  (if k \\<in> set (map fst ls) then length ls - 1 else length ls)\n\ngoal (1 subgoal):\n 1. \\<And>k l w ls.\n       (k \\<noteq> l \\<Longrightarrow>\n        length (fst (ls_delete k ls)) =\n        (if k \\<in> set (map fst ls) then length ls - 1\n         else length ls)) \\<Longrightarrow>\n       length (fst (ls_delete k ((l, w) # ls))) =\n       (if k \\<in> set (map fst ((l, w) # ls)) then length ((l, w) # ls) - 1\n        else length ((l, w) # ls))", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> l \\<Longrightarrow>\n  length (fst (ls_delete k ls)) =\n  (if k \\<in> set (map fst ls) then length ls - 1 else length ls)", "show ?case"], ["proof (prove)\nusing this:\n  k \\<noteq> l \\<Longrightarrow>\n  length (fst (ls_delete k ls)) =\n  (if k \\<in> set (map fst ls) then length ls - 1 else length ls)\n\ngoal (1 subgoal):\n 1. length (fst (ls_delete k ((l, w) # ls))) =\n    (if k \\<in> set (map fst ((l, w) # ls)) then length ((l, w) # ls) - 1\n     else length ((l, w) # ls))", "by (cases ls) (auto simp add: Let_def)"], ["proof (state)\nthis:\n  length (fst (ls_delete k ((l, w) # ls))) =\n  (if k \\<in> set (map fst ((l, w) # ls)) then length ((l, w) # ls) - 1\n   else length ((l, w) # ls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ls_delete_length_snd_True:\n  \"snd (ls_delete k l) \\<Longrightarrow> length (fst (ls_delete k l)) = length l - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (ls_delete k l) \\<Longrightarrow>\n    length (fst (ls_delete k l)) = length l - 1", "by (simp add: ls_delete_length ls_delete_snd_set)"], ["", "lemma ls_delete_length_snd_False:\n  \"\\<not> snd (ls_delete k l) \\<Longrightarrow> length (fst (ls_delete k l)) = length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> snd (ls_delete k l) \\<Longrightarrow>\n    length (fst (ls_delete k l)) = length l", "by (simp add: ls_delete_length ls_delete_snd_set)"], ["", "definition ht_delete\n  :: \"'k\n    \\<Rightarrow> ('k::{heap,hashable}, 'v::heap) hashtable\n    \\<Rightarrow> ('k, 'v) hashtable Heap\"\n  where\n  \"ht_delete k ht = do {\n      m \\<leftarrow> Array.len (the_array ht);\n      let i = bounded_hashcode_nat m k;\n      l \\<leftarrow> Array.nth (the_array ht) i;\n      let l = ls_delete k l;\n      Array.upd i (fst l) (the_array ht);\n      let n = (if (snd l) then (the_size ht - 1) else the_size ht);\n      return (HashTable (the_array ht) n)\n    }\""], ["", "subsubsection \\<open>Complete Correctness\\<close>"], ["", "lemma ht_hash_delete:\n  assumes \"ht_hash ls\"\n  shows \"ht_hash (\n    ls[bounded_hashcode_nat (length ls) k\n      := fst (ls_delete k\n               (ls ! bounded_hashcode_nat (length ls) k)\n             )\n      ]\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_hash\n     (ls[bounded_hashcode_nat (length ls) k :=\n           fst (ls_delete k (ls ! bounded_hashcode_nat (length ls) k))])", "unfolding ht_hash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (ls[bounded_hashcode_nat (length ls) k :=\n                      fst (ls_delete k\n                            (ls ! bounded_hashcode_nat (length ls) k))]).\n       \\<forall>x\\<in>set (ls[bounded_hashcode_nat (length ls) k :=\n                                fst (ls_delete k\n(ls ! bounded_hashcode_nat (length ls) k))] !\n                           i).\n          bounded_hashcode_nat\n           (length\n             (ls[bounded_hashcode_nat (length ls) k :=\n                   fst (ls_delete k\n                         (ls ! bounded_hashcode_nat (length ls) k))]))\n           (fst x) =\n          i", "apply (intro allI ballI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length\n                     (ls[bounded_hashcode_nat (length ls) k :=\n                           fst (ls_delete k\n                                 (ls !\n                                  bounded_hashcode_nat (length ls) k))]);\n        x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                          fst (ls_delete k\n                                (ls !\n                                 bounded_hashcode_nat (length ls) k))] !\n                     i)\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat\n                          (length\n                            (ls[bounded_hashcode_nat (length ls) k :=\n                                  fst (ls_delete k\n  (ls ! bounded_hashcode_nat (length ls) k))]))\n                          (fst x) =\n                         i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length ls;\n        x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                          fst (ls_delete k\n                                (ls !\n                                 bounded_hashcode_nat (length ls) k))] !\n                     i)\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat (length ls) (fst x) = i", "subgoal premises prems for i x"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length ls) (fst x) = i", "proof (cases \"i = bounded_hashcode_nat (length ls) k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i\n 2. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "case i: True"], ["proof (state)\nthis:\n  i = bounded_hashcode_nat (length ls) k\n\ngoal (2 subgoals):\n 1. i = bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i\n 2. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length ls) (fst x) = i", "proof (cases \"fst x = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow> bounded_hashcode_nat (length ls) (fst x) = i\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "case True"], ["proof (state)\nthis:\n  fst x = k\n\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow> bounded_hashcode_nat (length ls) (fst x) = i\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with i"], ["proof (chain)\npicking this:\n  i = bounded_hashcode_nat (length ls) k\n  fst x = k", "show ?thesis"], ["proof (prove)\nusing this:\n  i = bounded_hashcode_nat (length ls) k\n  fst x = k\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length ls) (fst x) = i", "by simp"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length ls) (fst x) = i\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "case False"], ["proof (state)\nthis:\n  fst x \\<noteq> k\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with prems i"], ["proof (chain)\npicking this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_delete k\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  i = bounded_hashcode_nat (length ls) k\n  fst x \\<noteq> k", "have\n        \"x \\<in> set (fst (ls_delete k\n                        (ls ! bounded_hashcode_nat (length ls) k)))\""], ["proof (prove)\nusing this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_delete k\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  i = bounded_hashcode_nat (length ls) k\n  fst x \\<noteq> k\n\ngoal (1 subgoal):\n 1. x \\<in> set (fst (ls_delete k\n                       (ls ! bounded_hashcode_nat (length ls) k)))", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (fst (ls_delete k (ls ! bounded_hashcode_nat (length ls) k)))\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with\n        ls_delete_fst_set[\n          of k \"ls ! bounded_hashcode_nat (length ls) k\"]\n        False"], ["proof (chain)\npicking this:\n  set (fst (ls_delete k (ls ! bounded_hashcode_nat (length ls) k)))\n  \\<subseteq> set (ls ! bounded_hashcode_nat (length ls) k)\n  fst x \\<noteq> k\n  x \\<in> set (fst (ls_delete k (ls ! bounded_hashcode_nat (length ls) k)))", "have \"x \\<in> (set (ls ! bounded_hashcode_nat (length ls) k))\""], ["proof (prove)\nusing this:\n  set (fst (ls_delete k (ls ! bounded_hashcode_nat (length ls) k)))\n  \\<subseteq> set (ls ! bounded_hashcode_nat (length ls) k)\n  fst x \\<noteq> k\n  x \\<in> set (fst (ls_delete k (ls ! bounded_hashcode_nat (length ls) k)))\n\ngoal (1 subgoal):\n 1. x \\<in> set (ls ! bounded_hashcode_nat (length ls) k)", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (ls ! bounded_hashcode_nat (length ls) k)\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with i prems assms[unfolded ht_hash_def]"], ["proof (chain)\npicking this:\n  i = bounded_hashcode_nat (length ls) k\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_delete k\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  \\<forall>i<length ls.\n     \\<forall>x\\<in>set (ls ! i).\n        bounded_hashcode_nat (length ls) (fst x) = i\n  x \\<in> set (ls ! bounded_hashcode_nat (length ls) k)", "show ?thesis"], ["proof (prove)\nusing this:\n  i = bounded_hashcode_nat (length ls) k\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_delete k\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  \\<forall>i<length ls.\n     \\<forall>x\\<in>set (ls ! i).\n        bounded_hashcode_nat (length ls) (fst x) = i\n  x \\<in> set (ls ! bounded_hashcode_nat (length ls) k)\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length ls) (fst x) = i", "by simp"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length ls) (fst x) = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length ls) (fst x) = i\n\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "case False"], ["proof (state)\nthis:\n  i \\<noteq> bounded_hashcode_nat (length ls) k\n\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with prems"], ["proof (chain)\npicking this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_delete k\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  i \\<noteq> bounded_hashcode_nat (length ls) k", "have \"x \\<in> set (ls ! i)\""], ["proof (prove)\nusing this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_delete k\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  i \\<noteq> bounded_hashcode_nat (length ls) k\n\ngoal (1 subgoal):\n 1. x \\<in> set (ls ! i)", "by simp"], ["proof (state)\nthis:\n  x \\<in> set (ls ! i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length ls) k \\<Longrightarrow>\n    bounded_hashcode_nat (length ls) (fst x) = i", "with prems assms[unfolded ht_hash_def]"], ["proof (chain)\npicking this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_delete k\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  \\<forall>i<length ls.\n     \\<forall>x\\<in>set (ls ! i).\n        bounded_hashcode_nat (length ls) (fst x) = i\n  x \\<in> set (ls ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length ls\n  x \\<in> set (ls[bounded_hashcode_nat (length ls) k :=\n                    fst (ls_delete k\n                          (ls ! bounded_hashcode_nat (length ls) k))] !\n               i)\n  \\<forall>i<length ls.\n     \\<forall>x\\<in>set (ls ! i).\n        bounded_hashcode_nat (length ls) (fst x) = i\n  x \\<in> set (ls ! i)\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length ls) (fst x) = i", "by simp"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length ls) (fst x) = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ht_distinct_delete:\n  assumes \"ht_distinct l\"\n  shows \"ht_distinct (\n    l[bounded_hashcode_nat (length l) k\n      := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_distinct\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])", "unfolding ht_distinct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (l[bounded_hashcode_nat (length l) k :=\n                     fst (ls_delete k\n                           (l ! bounded_hashcode_nat (length l) k))]).\n       distinct\n        (map fst\n          (l[bounded_hashcode_nat (length l) k :=\n               fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n           i))", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (l[bounded_hashcode_nat (length l) k :=\n                 fst (ls_delete k\n                       (l !\n                        bounded_hashcode_nat (length l)\n                         k))]) \\<Longrightarrow>\n       distinct\n        (map fst\n          (l[bounded_hashcode_nat (length l) k :=\n               fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n           i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length l \\<Longrightarrow>\n       distinct\n        (map fst\n          (l[bounded_hashcode_nat (length l) k :=\n               fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n           i))", "subgoal premises prems for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "proof (cases \"i = bounded_hashcode_nat (length l) k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))\n 2. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "case True"], ["proof (state)\nthis:\n  i = bounded_hashcode_nat (length l) k\n\ngoal (2 subgoals):\n 1. i = bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))\n 2. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "with prems assms[unfolded ht_distinct_def]"], ["proof (chain)\npicking this:\n  i < length l\n  \\<forall>i<length l. distinct (map fst (l ! i))\n  i = bounded_hashcode_nat (length l) k", "have \"distinct (map fst (l ! bounded_hashcode_nat (length l) k))\""], ["proof (prove)\nusing this:\n  i < length l\n  \\<forall>i<length l. distinct (map fst (l ! i))\n  i = bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. distinct (map fst (l ! bounded_hashcode_nat (length l) k))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (l ! bounded_hashcode_nat (length l) k))\n\ngoal (2 subgoals):\n 1. i = bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))\n 2. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "from ls_delete_distinct[OF this, of k] True prems"], ["proof (chain)\npicking this:\n  distinct\n   (map fst (fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))))\n  i = bounded_hashcode_nat (length l) k\n  i < length l", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct\n   (map fst (fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))))\n  i = bounded_hashcode_nat (length l) k\n  i < length l\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "by simp"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n      i))\n\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. i \\<noteq> bounded_hashcode_nat (length l) k \\<Longrightarrow>\n    distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "with prems assms[unfolded ht_distinct_def]"], ["proof (chain)\npicking this:\n  i < length l\n  \\<forall>i<length l. distinct (map fst (l ! i))\n  i \\<noteq> bounded_hashcode_nat (length l) k", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length l\n  \\<forall>i<length l. distinct (map fst (l ! i))\n  i \\<noteq> bounded_hashcode_nat (length l) k\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (l[bounded_hashcode_nat (length l) k :=\n            fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n        i))", "by simp"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (l[bounded_hashcode_nat (length l) k :=\n          fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] !\n      i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ht_size_delete1:\n  assumes size: \"ht_size l n\"\n  assumes i: \"i < length l\"\n  assumes snd: \"snd (ls_delete k (l ! i))\"\n  shows \"ht_size (l[i := fst (ls_delete k (l!i))]) (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) (n - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) (n - 1)", "have \"(map length (l[i := fst (ls_delete k (l ! i))]))\n    = (map length l)[i := length (fst (ls_delete k (l ! i)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map length (l[i := fst (ls_delete k (l ! i))]) = (map length l)\n    [i := length (fst (ls_delete k (l ! i)))]", "by (simp add: map_update)"], ["proof (state)\nthis:\n  map length (l[i := fst (ls_delete k (l ! i))]) = (map length l)\n  [i := length (fst (ls_delete k (l ! i)))]\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) (n - 1)", "also"], ["proof (state)\nthis:\n  map length (l[i := fst (ls_delete k (l ! i))]) = (map length l)\n  [i := length (fst (ls_delete k (l ! i)))]\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) (n - 1)", "from sum_list_update[of i \"map length l\", simplified, OF i,\n    of \"length (fst (ls_delete k (l ! i)))\"]\n    ls_delete_length_snd_True[OF snd] snd"], ["proof (chain)\npicking this:\n  sum_list ((map length l)[i := length (fst (ls_delete k (l ! i)))]) =\n  sum_list (map length l) + length (fst (ls_delete k (l ! i))) -\n  length (l ! i)\n  length (fst (ls_delete k (l ! i))) = length (l ! i) - 1\n  snd (ls_delete k (l ! i))", "have \"sum_list ((map length l)[i := length (fst (ls_delete k (l ! i)))])\n    = sum_list (map length l) - 1\""], ["proof (prove)\nusing this:\n  sum_list ((map length l)[i := length (fst (ls_delete k (l ! i)))]) =\n  sum_list (map length l) + length (fst (ls_delete k (l ! i))) -\n  length (l ! i)\n  length (fst (ls_delete k (l ! i))) = length (l ! i) - 1\n  snd (ls_delete k (l ! i))\n\ngoal (1 subgoal):\n 1. sum_list ((map length l)[i := length (fst (ls_delete k (l ! i)))]) =\n    sum_list (map length l) - 1", "by (cases \"length (l ! i)\") (simp_all add: ls_delete_snd_set)"], ["proof (state)\nthis:\n  sum_list ((map length l)[i := length (fst (ls_delete k (l ! i)))]) =\n  sum_list (map length l) - 1\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) (n - 1)", "finally"], ["proof (chain)\npicking this:\n  sum_list (map length (l[i := fst (ls_delete k (l ! i))])) =\n  sum_list (map length l) - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map length (l[i := fst (ls_delete k (l ! i))])) =\n  sum_list (map length l) - 1\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) (n - 1)", "using assms"], ["proof (prove)\nusing this:\n  sum_list (map length (l[i := fst (ls_delete k (l ! i))])) =\n  sum_list (map length l) - 1\n  ht_size l n\n  i < length l\n  snd (ls_delete k (l ! i))\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) (n - 1)", "by (simp add: ht_size_def assms)"], ["proof (state)\nthis:\n  ht_size (l[i := fst (ls_delete k (l ! i))]) (n - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ht_size_delete2:\n  assumes size: \"ht_size l n\"\n  assumes i: \"i < length l\"\n  assumes snd: \"\\<not> snd (ls_delete k (l ! i))\"\n  shows \"ht_size (l[i := fst (ls_delete k (l!i))]) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) n", "have \"(map length (l[i := fst (ls_delete k (l ! i))]))\n    = (map length l)[i := length (fst (ls_delete k (l ! i)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map length (l[i := fst (ls_delete k (l ! i))]) = (map length l)\n    [i := length (fst (ls_delete k (l ! i)))]", "by (simp add: map_update)"], ["proof (state)\nthis:\n  map length (l[i := fst (ls_delete k (l ! i))]) = (map length l)\n  [i := length (fst (ls_delete k (l ! i)))]\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) n", "also"], ["proof (state)\nthis:\n  map length (l[i := fst (ls_delete k (l ! i))]) = (map length l)\n  [i := length (fst (ls_delete k (l ! i)))]\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) n", "from sum_list_update[of i \"map length l\", simplified, OF i,\n    of \"length (fst (ls_delete k (l ! i)))\"]\n    ls_delete_length_snd_False[OF snd]"], ["proof (chain)\npicking this:\n  sum_list ((map length l)[i := length (fst (ls_delete k (l ! i)))]) =\n  sum_list (map length l) + length (fst (ls_delete k (l ! i))) -\n  length (l ! i)\n  length (fst (ls_delete k (l ! i))) = length (l ! i)", "have \"sum_list ((map length l)[i := length (fst (ls_delete k (l ! i)))])\n    = sum_list (map length l)\""], ["proof (prove)\nusing this:\n  sum_list ((map length l)[i := length (fst (ls_delete k (l ! i)))]) =\n  sum_list (map length l) + length (fst (ls_delete k (l ! i))) -\n  length (l ! i)\n  length (fst (ls_delete k (l ! i))) = length (l ! i)\n\ngoal (1 subgoal):\n 1. sum_list ((map length l)[i := length (fst (ls_delete k (l ! i)))]) =\n    sum_list (map length l)", "by simp"], ["proof (state)\nthis:\n  sum_list ((map length l)[i := length (fst (ls_delete k (l ! i)))]) =\n  sum_list (map length l)\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) n", "finally"], ["proof (chain)\npicking this:\n  sum_list (map length (l[i := fst (ls_delete k (l ! i))])) =\n  sum_list (map length l)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map length (l[i := fst (ls_delete k (l ! i))])) =\n  sum_list (map length l)\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) n", "using assms"], ["proof (prove)\nusing this:\n  sum_list (map length (l[i := fst (ls_delete k (l ! i))])) =\n  sum_list (map length l)\n  ht_size l n\n  i < length l\n  \\<not> snd (ls_delete k (l ! i))\n\ngoal (1 subgoal):\n 1. ht_size (l[i := fst (ls_delete k (l ! i))]) n", "by (simp add: ht_size_def assms)"], ["proof (state)\nthis:\n  ht_size (l[i := fst (ls_delete k (l ! i))]) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complete_ht_delete: \"<is_hashtable l ht> ht_delete k ht\n  <is_hashtable (l[bounded_hashcode_nat (length l) k\n    := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_delete k ht\n    <is_hashtable\n      (l[bounded_hashcode_nat (length l) k :=\n           fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])>", "unfolding ht_delete_def is_hashtable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l)>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>m.\n        let i = bounded_hashcode_nat m k\n        in Array.nth (the_array ht) i \\<bind>\n           (\\<lambda>l.\n               let l = ls_delete k l\n               in Array.upd i (fst l) (the_array ht) \\<bind>\n                  (\\<lambda>_.\n                      let n = if snd l then the_size ht - 1 else the_size ht\n                      in return (HashTable (the_array ht) n))))\n    <\\<lambda>ht.\n        the_array ht \\<mapsto>\\<^sub>a l\n        [bounded_hashcode_nat (length l) k :=\n           fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] *\n        \\<up>\n         (ht_size\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n           (the_size ht) \\<and>\n          ht_hash\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k\n                      (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n          ht_distinct\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k\n                      (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n          1 < length\n               (l[bounded_hashcode_nat (length l) k :=\n                    fst (ls_delete k\n                          (l ! bounded_hashcode_nat (length l) k))]))>", "apply (rule norm_pre_pure_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_size l (the_size ht) \\<and>\n    ht_hash l \\<and> ht_distinct l \\<and> 1 < length l \\<Longrightarrow>\n    <the_array ht \\<mapsto>\\<^sub>a l>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>m.\n        let i = bounded_hashcode_nat m k\n        in Array.nth (the_array ht) i \\<bind>\n           (\\<lambda>l.\n               let l = ls_delete k l\n               in Array.upd i (fst l) (the_array ht) \\<bind>\n                  (\\<lambda>_.\n                      let n = if snd l then the_size ht - 1 else the_size ht\n                      in return (HashTable (the_array ht) n))))\n    <\\<lambda>ht.\n        the_array ht \\<mapsto>\\<^sub>a l\n        [bounded_hashcode_nat (length l) k :=\n           fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] *\n        \\<up>\n         (ht_size\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n           (the_size ht) \\<and>\n          ht_hash\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k\n                      (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n          ht_distinct\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k\n                      (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n          1 < length\n               (l[bounded_hashcode_nat (length l) k :=\n                    fst (ls_delete k\n                          (l ! bounded_hashcode_nat (length l) k))]))>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ht_size l (the_size ht) \\<and>\n    ht_hash l \\<and> ht_distinct l \\<and> 1 < length l \\<Longrightarrow>\n    <the_array ht \\<mapsto>\\<^sub>a l> Array.len (the_array ht) <?R2>\n 2. \\<And>x.\n       ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l \\<Longrightarrow>\n       <?R2 x>\n       let i = bounded_hashcode_nat x k\n       in Array.nth (the_array ht) i \\<bind>\n          (\\<lambda>l.\n              let l = ls_delete k l\n              in Array.upd i (fst l) (the_array ht) \\<bind>\n                 (\\<lambda>_.\n                     let n = if snd l then the_size ht - 1 else the_size ht\n                     in return (HashTable (the_array ht) n)))\n       <\\<lambda>ht.\n           the_array ht \\<mapsto>\\<^sub>a l\n           [bounded_hashcode_nat (length l) k :=\n              fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] *\n           \\<up>\n            (ht_size\n              (l[bounded_hashcode_nat (length l) k :=\n                   fst (ls_delete k\n                         (l ! bounded_hashcode_nat (length l) k))])\n              (the_size ht) \\<and>\n             ht_hash\n              (l[bounded_hashcode_nat (length l) k :=\n                   fst (ls_delete k\n                         (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n             ht_distinct\n              (l[bounded_hashcode_nat (length l) k :=\n                   fst (ls_delete k\n                         (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n             1 < length\n                  (l[bounded_hashcode_nat (length l) k :=\n                       fst (ls_delete k\n                             (l ! bounded_hashcode_nat (length l) k))]))>", "apply (rule length_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l \\<Longrightarrow>\n       <the_array ht \\<mapsto>\\<^sub>a l * \\<up> (x = length l)>\n       let i = bounded_hashcode_nat x k\n       in Array.nth (the_array ht) i \\<bind>\n          (\\<lambda>l.\n              let l = ls_delete k l\n              in Array.upd i (fst l) (the_array ht) \\<bind>\n                 (\\<lambda>_.\n                     let n = if snd l then the_size ht - 1 else the_size ht\n                     in return (HashTable (the_array ht) n)))\n       <\\<lambda>ht.\n           the_array ht \\<mapsto>\\<^sub>a l\n           [bounded_hashcode_nat (length l) k :=\n              fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] *\n           \\<up>\n            (ht_size\n              (l[bounded_hashcode_nat (length l) k :=\n                   fst (ls_delete k\n                         (l ! bounded_hashcode_nat (length l) k))])\n              (the_size ht) \\<and>\n             ht_hash\n              (l[bounded_hashcode_nat (length l) k :=\n                   fst (ls_delete k\n                         (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n             ht_distinct\n              (l[bounded_hashcode_nat (length l) k :=\n                   fst (ls_delete k\n                         (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n             1 < length\n                  (l[bounded_hashcode_nat (length l) k :=\n                       fst (ls_delete k\n                             (l ! bounded_hashcode_nat (length l) k))]))>", "apply (rule norm_pre_pure_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> 1 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l>\n                         let i = bounded_hashcode_nat x k\n                         in Array.nth (the_array ht) i \\<bind>\n                            (\\<lambda>l.\n                                let l = ls_delete k l\n                                in Array.upd i (fst l)\n                                    (the_array ht) \\<bind>\n                                   (\\<lambda>_.\n let n = if snd l then the_size ht - 1 else the_size ht\n in return (HashTable (the_array ht) n)))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a l\n                             [bounded_hashcode_nat (length l) k :=\n                                fst (ls_delete k\n(l ! bounded_hashcode_nat (length l) k))] *\n                             \\<up>\n                              (ht_size\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n                                (the_size ht) \\<and>\n                               ht_hash\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n                               ht_distinct\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n                               1 < length\n                                    (l[bounded_hashcode_nat (length l) k :=\n   fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))]))>", "apply (simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l>\n                         Array.nth (the_array ht)\n                          (bounded_hashcode_nat (length l) k) \\<bind>\n                         (\\<lambda>la.\n                             Array.upd (bounded_hashcode_nat (length l) k)\n                              (fst (ls_delete k la)) (the_array ht) \\<bind>\n                             (\\<lambda>_.\n                                 return\n                                  (HashTable (the_array ht)\n                                    (if snd (ls_delete k la)\n                                     then the_size ht - 1\n                                     else the_size ht))))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a l\n                             [bounded_hashcode_nat (length l) k :=\n                                fst (ls_delete k\n(l ! bounded_hashcode_nat (length l) k))] *\n                             \\<up>\n                              (ht_size\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n                                (the_size ht) \\<and>\n                               ht_hash\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n                               ht_distinct\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]))>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l>\n                         Array.nth (the_array ht)\n                          (bounded_hashcode_nat (length l) k)\n                         <?R8 x>\n 2. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <?R8 x xa>\n                         Array.upd (bounded_hashcode_nat (length l) k)\n                          (fst (ls_delete k xa)) (the_array ht) \\<bind>\n                         (\\<lambda>_.\n                             return\n                              (HashTable (the_array ht)\n                                (if snd (ls_delete k xa)\n                                 then the_size ht - 1 else the_size ht)))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a l\n                             [bounded_hashcode_nat (length l) k :=\n                                fst (ls_delete k\n(l ! bounded_hashcode_nat (length l) k))] *\n                             \\<up>\n                              (ht_size\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n                                (the_size ht) \\<and>\n                               ht_hash\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n                               ht_distinct\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]))>", "apply (rule nth_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat (length l) k < length l\n 2. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l *\n                          \\<up>\n                           (xa = l ! bounded_hashcode_nat (length l) k)>\n                         Array.upd (bounded_hashcode_nat (length l) k)\n                          (fst (ls_delete k xa)) (the_array ht) \\<bind>\n                         (\\<lambda>_.\n                             return\n                              (HashTable (the_array ht)\n                                (if snd (ls_delete k xa)\n                                 then the_size ht - 1 else the_size ht)))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a l\n                             [bounded_hashcode_nat (length l) k :=\n                                fst (ls_delete k\n(l ! bounded_hashcode_nat (length l) k))] *\n                             \\<up>\n                              (ht_size\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n                                (the_size ht) \\<and>\n                               ht_hash\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n                               ht_distinct\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]))>", "apply (simp add: bounded_hashcode_nat_bounds)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l *\n                          \\<up>\n                           (xa = l ! bounded_hashcode_nat (length l) k)>\n                         Array.upd (bounded_hashcode_nat (length l) k)\n                          (fst (ls_delete k xa)) (the_array ht) \\<bind>\n                         (\\<lambda>_.\n                             return\n                              (HashTable (the_array ht)\n                                (if snd (ls_delete k xa)\n                                 then the_size ht - 1 else the_size ht)))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a l\n                             [bounded_hashcode_nat (length l) k :=\n                                fst (ls_delete k\n(l ! bounded_hashcode_nat (length l) k))] *\n                             \\<up>\n                              (ht_size\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n                                (the_size ht) \\<and>\n                               ht_hash\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n                               ht_distinct\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]))>", "apply (rule norm_pre_pure_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l>\n                         Array.upd (bounded_hashcode_nat (length l) k)\n                          (fst (ls_delete k xa)) (the_array ht) \\<bind>\n                         (\\<lambda>_.\n                             return\n                              (HashTable (the_array ht)\n                                (if snd (ls_delete k xa)\n                                 then the_size ht - 1 else the_size ht)))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a l\n                             [bounded_hashcode_nat (length l) k :=\n                                fst (ls_delete k\n(l ! bounded_hashcode_nat (length l) k))] *\n                             \\<up>\n                              (ht_size\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n                                (the_size ht) \\<and>\n                               ht_hash\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n                               ht_distinct\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]))>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l>\n                         Array.upd (bounded_hashcode_nat (length l) k)\n                          (fst (ls_delete k xa)) (the_array ht)\n                         <?R15 x xa>\n 2. \\<And>x xa xb.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> <?R15 x xa xb>\n                         return\n                          (HashTable (the_array ht)\n                            (if snd (ls_delete k xa) then the_size ht - 1\n                             else the_size ht))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a l\n                             [bounded_hashcode_nat (length l) k :=\n                                fst (ls_delete k\n(l ! bounded_hashcode_nat (length l) k))] *\n                             \\<up>\n                              (ht_size\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n                                (the_size ht) \\<and>\n                               ht_hash\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n                               ht_distinct\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]))>", "apply (rule upd_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> bounded_hashcode_nat (length l) k < length l\n 2. \\<And>x xa xb.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l\n                          [bounded_hashcode_nat (length l) k :=\n                             fst (ls_delete k xa)] *\n                          \\<up> (xb = the_array ht)>\n                         return\n                          (HashTable (the_array ht)\n                            (if snd (ls_delete k xa) then the_size ht - 1\n                             else the_size ht))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a l\n                             [bounded_hashcode_nat (length l) k :=\n                                fst (ls_delete k\n(l ! bounded_hashcode_nat (length l) k))] *\n                             \\<up>\n                              (ht_size\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n                                (the_size ht) \\<and>\n                               ht_hash\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n                               ht_distinct\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]))>", "apply (simp add: bounded_hashcode_nat_bounds)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l\n                          [bounded_hashcode_nat (length l) k :=\n                             fst (ls_delete k xa)] *\n                          \\<up> (xb = the_array ht)>\n                         return\n                          (HashTable (the_array ht)\n                            (if snd (ls_delete k xa) then the_size ht - 1\n                             else the_size ht))\n                         <\\<lambda>ht.\n                             the_array ht \\<mapsto>\\<^sub>a l\n                             [bounded_hashcode_nat (length l) k :=\n                                fst (ls_delete k\n(l ! bounded_hashcode_nat (length l) k))] *\n                             \\<up>\n                              (ht_size\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n                                (the_size ht) \\<and>\n                               ht_hash\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n                               ht_distinct\n                                (l[bounded_hashcode_nat (length l) k :=\n                                     fst\n(ls_delete k (l ! bounded_hashcode_nat (length l) k))]))>", "apply (rule return_cons_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>ht_size l (the_size ht) \\<and>\n                ht_hash l \\<and> ht_distinct l \\<and> Suc 0 < length l;\n        x = length l; xa = l ! bounded_hashcode_nat (length l) k\\<rbrakk>\n       \\<Longrightarrow> the_array ht \\<mapsto>\\<^sub>a l\n                         [bounded_hashcode_nat (length l) k :=\n                            fst (ls_delete k xa)] *\n                         \\<up> (xb = the_array ht) \\<Longrightarrow>\\<^sub>A\n                         the_array\n                          (HashTable (the_array ht)\n                            (if snd (ls_delete k xa) then the_size ht - 1\n                             else the_size ht)) \\<mapsto>\\<^sub>a\n                         l[bounded_hashcode_nat (length l) k :=\n                             fst (ls_delete k\n                                   (l !\n                                    bounded_hashcode_nat (length l) k))] *\n                         \\<up>\n                          (ht_size\n                            (l[bounded_hashcode_nat (length l) k :=\n                                 fst (ls_delete k\n (l ! bounded_hashcode_nat (length l) k))])\n                            (the_size\n                              (HashTable (the_array ht)\n                                (if snd (ls_delete k xa)\n                                 then the_size ht - 1\n                                 else the_size ht))) \\<and>\n                           ht_hash\n                            (l[bounded_hashcode_nat (length l) k :=\n                                 fst (ls_delete k\n (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n                           ht_distinct\n                            (l[bounded_hashcode_nat (length l) k :=\n                                 fst (ls_delete k\n (l ! bounded_hashcode_nat (length l) k))]))", "apply (auto\n    simp add: ht_size_delete1 ht_size_delete2 bounded_hashcode_nat_bounds\n              is_hashtable_def ht_hash_delete ht_distinct_delete)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ht_size l (the_size ht); ht_hash l; ht_distinct l;\n        Suc 0 < length l;\n        snd (ls_delete k (l ! bounded_hashcode_nat (length l) k));\n        (a, b) \\<Turnstile>\n        the_array ht \\<mapsto>\\<^sub>a l\n        [bounded_hashcode_nat (length l) k :=\n           fst (ls_delete k\n                 (l ! bounded_hashcode_nat (length l) k))]\\<rbrakk>\n       \\<Longrightarrow> ht_size\n                          (l[bounded_hashcode_nat (length l) k :=\n                               fst (ls_delete k\n                                     (l !\nbounded_hashcode_nat (length l) k))])\n                          (the_size ht - Suc 0)", "using ht_size_delete1[OF _ bounded_hashcode_nat_bounds[of \"length l\" k], of \"the_size ht\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>ht_size l (the_size ht); 1 < length l;\n   snd (ls_delete ?k (l ! bounded_hashcode_nat (length l) k))\\<rbrakk>\n  \\<Longrightarrow> ht_size\n                     (l[bounded_hashcode_nat (length l) k :=\n                          fst (ls_delete ?k\n                                (l ! bounded_hashcode_nat (length l) k))])\n                     (the_size ht - 1)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ht_size l (the_size ht); ht_hash l; ht_distinct l;\n        Suc 0 < length l;\n        snd (ls_delete k (l ! bounded_hashcode_nat (length l) k));\n        (a, b) \\<Turnstile>\n        the_array ht \\<mapsto>\\<^sub>a l\n        [bounded_hashcode_nat (length l) k :=\n           fst (ls_delete k\n                 (l ! bounded_hashcode_nat (length l) k))]\\<rbrakk>\n       \\<Longrightarrow> ht_size\n                          (l[bounded_hashcode_nat (length l) k :=\n                               fst (ls_delete k\n                                     (l !\nbounded_hashcode_nat (length l) k))])\n                          (the_size ht - Suc 0)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Alternative, more automatic proof\\<close>"], ["", "lemma \"<is_hashtable l ht> ht_delete k ht\n  <is_hashtable (l[bounded_hashcode_nat (length l)\n    k := fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_delete k ht\n    <is_hashtable\n      (l[bounded_hashcode_nat (length l) k :=\n           fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])>", "unfolding ht_delete_def is_hashtable_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l)>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>m.\n        Array.nth (the_array ht) (bounded_hashcode_nat m k) \\<bind>\n        (\\<lambda>l.\n            Array.upd (bounded_hashcode_nat m k) (fst (ls_delete k l))\n             (the_array ht) \\<bind>\n            (\\<lambda>_.\n                return\n                 (HashTable (the_array ht)\n                   (if snd (ls_delete k l) then the_size ht - 1\n                    else the_size ht)))))\n    <\\<lambda>ht.\n        the_array ht \\<mapsto>\\<^sub>a l\n        [bounded_hashcode_nat (length l) k :=\n           fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] *\n        \\<up>\n         (ht_size\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n           (the_size ht) \\<and>\n          ht_hash\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k\n                      (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n          ht_distinct\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k\n                      (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n          1 < length\n               (l[bounded_hashcode_nat (length l) k :=\n                    fst (ls_delete k\n                          (l ! bounded_hashcode_nat (length l) k))]))>", "using ht_size_delete1[OF _ bounded_hashcode_nat_bounds[of \"length l\" k],\n    of \"the_size ht\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>ht_size l (the_size ht); 1 < length l;\n   snd (ls_delete ?k (l ! bounded_hashcode_nat (length l) k))\\<rbrakk>\n  \\<Longrightarrow> ht_size\n                     (l[bounded_hashcode_nat (length l) k :=\n                          fst (ls_delete ?k\n                                (l ! bounded_hashcode_nat (length l) k))])\n                     (the_size ht - 1)\n\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l)>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>m.\n        Array.nth (the_array ht) (bounded_hashcode_nat m k) \\<bind>\n        (\\<lambda>l.\n            Array.upd (bounded_hashcode_nat m k) (fst (ls_delete k l))\n             (the_array ht) \\<bind>\n            (\\<lambda>_.\n                return\n                 (HashTable (the_array ht)\n                   (if snd (ls_delete k l) then the_size ht - 1\n                    else the_size ht)))))\n    <\\<lambda>ht.\n        the_array ht \\<mapsto>\\<^sub>a l\n        [bounded_hashcode_nat (length l) k :=\n           fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))] *\n        \\<up>\n         (ht_size\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k (l ! bounded_hashcode_nat (length l) k))])\n           (the_size ht) \\<and>\n          ht_hash\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k\n                      (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n          ht_distinct\n           (l[bounded_hashcode_nat (length l) k :=\n                fst (ls_delete k\n                      (l ! bounded_hashcode_nat (length l) k))]) \\<and>\n          1 < length\n               (l[bounded_hashcode_nat (length l) k :=\n                    fst (ls_delete k\n                          (l ! bounded_hashcode_nat (length l) k))]))>", "apply (sep_auto simp:\n    ht_size_delete1 ht_size_delete2 bounded_hashcode_nat_bounds\n    is_hashtable_def ht_hash_delete ht_distinct_delete)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Re-Hashing\\<close>"], ["", "subsubsection \\<open>Auxiliary Functions\\<close>"], ["", "text \\<open>\\paragraph{Insert List}\\<close>"], ["", "fun ht_insls\n  :: \"('k \\<times> 'v) list\n    \\<Rightarrow> ('k::{heap,hashable}, 'v::heap) hashtable\n    \\<Rightarrow> ('k, 'v::heap) hashtable Heap\"\n  where\n  \"ht_insls [] ht = return ht\" |\n  \"ht_insls ((k, v) # l) ht = do { h \\<leftarrow> ht_upd k v ht; ht_insls l h }\""], ["", "text \"Abstract version\""], ["", "fun ls_insls :: \"('k::hashable \\<times> 'v) list\n  \\<Rightarrow> ('k \\<times> 'v) list list \\<Rightarrow> ('k \\<times> 'v) list list\"\nwhere\n  \"ls_insls [] l = l\" |\n  \"ls_insls ((k, v) # ls) l =\n    ls_insls ls (abs_update k v l)\""], ["", "lemma ht_hash_ls_insls:\n  assumes \"ht_hash l\"\n  shows \"ht_hash (ls_insls ls l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_hash (ls_insls ls l)", "using assms"], ["proof (prove)\nusing this:\n  ht_hash l\n\ngoal (1 subgoal):\n 1. ht_hash (ls_insls ls l)", "apply (induct l rule: ls_insls.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l. ht_hash l \\<Longrightarrow> ht_hash (ls_insls [] l)\n 2. \\<And>k v ls l.\n       \\<lbrakk>ht_hash (abs_update k v l) \\<Longrightarrow>\n                ht_hash (ls_insls ls (abs_update k v l));\n        ht_hash l\\<rbrakk>\n       \\<Longrightarrow> ht_hash (ls_insls ((k, v) # ls) l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v ls l.\n       \\<lbrakk>ht_hash (abs_update k v l) \\<Longrightarrow>\n                ht_hash (ls_insls ls (abs_update k v l));\n        ht_hash l\\<rbrakk>\n       \\<Longrightarrow> ht_hash (ls_insls ((k, v) # ls) l)", "apply (simp add: ht_hash_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ht_distinct_ls_insls:\n  assumes \"ht_distinct l\"\n  shows \"ht_distinct (ls_insls ls l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_distinct (ls_insls ls l)", "using assms"], ["proof (prove)\nusing this:\n  ht_distinct l\n\ngoal (1 subgoal):\n 1. ht_distinct (ls_insls ls l)", "apply (induct l rule: ls_insls.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l. ht_distinct l \\<Longrightarrow> ht_distinct (ls_insls [] l)\n 2. \\<And>k v ls l.\n       \\<lbrakk>ht_distinct (abs_update k v l) \\<Longrightarrow>\n                ht_distinct (ls_insls ls (abs_update k v l));\n        ht_distinct l\\<rbrakk>\n       \\<Longrightarrow> ht_distinct (ls_insls ((k, v) # ls) l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v ls l.\n       \\<lbrakk>ht_distinct (abs_update k v l) \\<Longrightarrow>\n                ht_distinct (ls_insls ls (abs_update k v l));\n        ht_distinct l\\<rbrakk>\n       \\<Longrightarrow> ht_distinct (ls_insls ((k, v) # ls) l)", "apply (simp add: ht_distinct_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_ls_insls:\n  assumes \"1 < length l\"\n  shows \"1 < length (ls_insls ls l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (ls_insls ls l)", "using assms"], ["proof (prove)\nusing this:\n  1 < length l\n\ngoal (1 subgoal):\n 1. 1 < length (ls_insls ls l)", "proof (induct l rule: ls_insls.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l. 1 < length l \\<Longrightarrow> 1 < length (ls_insls [] l)\n 2. \\<And>k v ls l.\n       \\<lbrakk>1 < length (abs_update k v l) \\<Longrightarrow>\n                1 < length (ls_insls ls (abs_update k v l));\n        1 < length l\\<rbrakk>\n       \\<Longrightarrow> 1 < length (ls_insls ((k, v) # ls) l)", "case 1"], ["proof (state)\nthis:\n  1 < length l_\n\ngoal (2 subgoals):\n 1. \\<And>l. 1 < length l \\<Longrightarrow> 1 < length (ls_insls [] l)\n 2. \\<And>k v ls l.\n       \\<lbrakk>1 < length (abs_update k v l) \\<Longrightarrow>\n                1 < length (ls_insls ls (abs_update k v l));\n        1 < length l\\<rbrakk>\n       \\<Longrightarrow> 1 < length (ls_insls ((k, v) # ls) l)", "then"], ["proof (chain)\npicking this:\n  1 < length l_", "show ?case"], ["proof (prove)\nusing this:\n  1 < length l_\n\ngoal (1 subgoal):\n 1. 1 < length (ls_insls [] l_)", "by simp"], ["proof (state)\nthis:\n  1 < length (ls_insls [] l_)\n\ngoal (1 subgoal):\n 1. \\<And>k v ls l.\n       \\<lbrakk>1 < length (abs_update k v l) \\<Longrightarrow>\n                1 < length (ls_insls ls (abs_update k v l));\n        1 < length l\\<rbrakk>\n       \\<Longrightarrow> 1 < length (ls_insls ((k, v) # ls) l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v ls l.\n       \\<lbrakk>1 < length (abs_update k v l) \\<Longrightarrow>\n                1 < length (ls_insls ls (abs_update k v l));\n        1 < length l\\<rbrakk>\n       \\<Longrightarrow> 1 < length (ls_insls ((k, v) # ls) l)", "case (2 k v ls l)"], ["proof (state)\nthis:\n  1 < length (abs_update k v l) \\<Longrightarrow>\n  1 < length (ls_insls ls (abs_update k v l))\n  1 < length l\n\ngoal (1 subgoal):\n 1. \\<And>k v ls l.\n       \\<lbrakk>1 < length (abs_update k v l) \\<Longrightarrow>\n                1 < length (ls_insls ls (abs_update k v l));\n        1 < length l\\<rbrakk>\n       \\<Longrightarrow> 1 < length (ls_insls ((k, v) # ls) l)", "from 2(1)[OF length_update[OF 2(2), of k v]]"], ["proof (chain)\npicking this:\n  1 < length (ls_insls ls (abs_update k v l))", "show ?case"], ["proof (prove)\nusing this:\n  1 < length (ls_insls ls (abs_update k v l))\n\ngoal (1 subgoal):\n 1. 1 < length (ls_insls ((k, v) # ls) l)", "by simp"], ["proof (state)\nthis:\n  1 < length (ls_insls ((k, v) # ls) l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complete_ht_insls:\n  \"<is_hashtable ls ht> ht_insls xs ht <is_hashtable (ls_insls xs ls)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable ls ht> ht_insls xs ht <is_hashtable (ls_insls xs ls)>", "proof (induct xs arbitrary: ls ht)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ls ht.\n       <is_hashtable ls ht> ht_insls [] ht <is_hashtable (ls_insls [] ls)>\n 2. \\<And>a xs ls ht.\n       (\\<And>ls ht.\n           <is_hashtable ls ht> ht_insls xs ht\n           <is_hashtable (ls_insls xs ls)>) \\<Longrightarrow>\n       <is_hashtable ls ht> ht_insls (a # xs) ht\n       <is_hashtable (ls_insls (a # xs) ls)>", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ls ht.\n       <is_hashtable ls ht> ht_insls [] ht <is_hashtable (ls_insls [] ls)>\n 2. \\<And>a xs ls ht.\n       (\\<And>ls ht.\n           <is_hashtable ls ht> ht_insls xs ht\n           <is_hashtable (ls_insls xs ls)>) \\<Longrightarrow>\n       <is_hashtable ls ht> ht_insls (a # xs) ht\n       <is_hashtable (ls_insls (a # xs) ls)>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable ls ht> ht_insls [] ht <is_hashtable (ls_insls [] ls)>", "by (auto intro: return_cons_rule)"], ["proof (state)\nthis:\n  <is_hashtable ls ht> ht_insls [] ht <is_hashtable (ls_insls [] ls)>\n\ngoal (1 subgoal):\n 1. \\<And>a xs ls ht.\n       (\\<And>ls ht.\n           <is_hashtable ls ht> ht_insls xs ht\n           <is_hashtable (ls_insls xs ls)>) \\<Longrightarrow>\n       <is_hashtable ls ht> ht_insls (a # xs) ht\n       <is_hashtable (ls_insls (a # xs) ls)>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ls ht.\n       (\\<And>ls ht.\n           <is_hashtable ls ht> ht_insls xs ht\n           <is_hashtable (ls_insls xs ls)>) \\<Longrightarrow>\n       <is_hashtable ls ht> ht_insls (a # xs) ht\n       <is_hashtable (ls_insls (a # xs) ls)>", "case (Cons x xs)"], ["proof (state)\nthis:\n  <is_hashtable ?ls ?ht> ht_insls xs ?ht <is_hashtable (ls_insls xs ?ls)>\n\ngoal (1 subgoal):\n 1. \\<And>a xs ls ht.\n       (\\<And>ls ht.\n           <is_hashtable ls ht> ht_insls xs ht\n           <is_hashtable (ls_insls xs ls)>) \\<Longrightarrow>\n       <is_hashtable ls ht> ht_insls (a # xs) ht\n       <is_hashtable (ls_insls (a # xs) ls)>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable ls ht> ht_insls (x # xs) ht\n    <is_hashtable (ls_insls (x # xs) ls)>", "proof (cases x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       x = (a, b) \\<Longrightarrow>\n       <is_hashtable ls ht> ht_insls (x # xs) ht\n       <is_hashtable (ls_insls (x # xs) ls)>", "case (Pair k v)"], ["proof (state)\nthis:\n  x = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       x = (a, b) \\<Longrightarrow>\n       <is_hashtable ls ht> ht_insls (x # xs) ht\n       <is_hashtable (ls_insls (x # xs) ls)>", "then"], ["proof (chain)\npicking this:\n  x = (k, v)", "show ?thesis"], ["proof (prove)\nusing this:\n  x = (k, v)\n\ngoal (1 subgoal):\n 1. <is_hashtable ls ht> ht_insls (x # xs) ht\n    <is_hashtable (ls_insls (x # xs) ls)>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (k, v) \\<Longrightarrow>\n    <is_hashtable ls ht> ht_upd k v ht \\<bind> ht_insls xs\n    <is_hashtable (ls_insls xs (abs_update k v ls))>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = (k, v) \\<Longrightarrow> <is_hashtable ls ht> ht_upd k v ht <?R1>\n 2. \\<And>xa.\n       x = (k, v) \\<Longrightarrow>\n       <?R1 xa> ht_insls xs xa\n       <is_hashtable (ls_insls xs (abs_update k v ls))>", "apply (rule complete_ht_upd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = (k, v) \\<Longrightarrow>\n       <is_hashtable (abs_update k v ls) xa> ht_insls xs xa\n       <is_hashtable (ls_insls xs (abs_update k v ls))>", "apply (simp add: Cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <is_hashtable ls ht> ht_insls (x # xs) ht\n  <is_hashtable (ls_insls (x # xs) ls)>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <is_hashtable ls ht> ht_insls (x # xs) ht\n  <is_hashtable (ls_insls (x # xs) ls)>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\\paragraph{Copy}\\<close>"], ["", "fun ht_copy :: \"nat \\<Rightarrow> ('k::{heap,hashable}, 'v::heap) hashtable\n  \\<Rightarrow> ('k, 'v) hashtable \\<Rightarrow> ('k, 'v) hashtable Heap\"\n  where\n  \"ht_copy 0 src dst = return dst\" |\n  \"ht_copy (Suc n) src dst = do {\n    l \\<leftarrow> Array.nth (the_array src) n;\n    ht \\<leftarrow> ht_insls l dst;\n    ht_copy n src ht\n  }\""], ["", "text \"Abstract version\""], ["", "fun ls_copy :: \"nat \\<Rightarrow> ('k::hashable \\<times> 'v) list list\n  \\<Rightarrow> ('k \\<times> 'v) list list \\<Rightarrow> ('k \\<times> 'v) list list\"\n  where\n  \"ls_copy 0 ss ds = ds\" |\n  \"ls_copy (Suc n) ss ds = ls_copy n ss (ls_insls (ss ! n) ds)\""], ["", "lemma ht_hash_ls_copy:\n  assumes \"ht_hash l\"\n  shows \"ht_hash (ls_copy n ss l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_hash (ls_copy n ss l)", "using assms"], ["proof (prove)\nusing this:\n  ht_hash l\n\ngoal (1 subgoal):\n 1. ht_hash (ls_copy n ss l)", "apply (induct n arbitrary: l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l. ht_hash l \\<Longrightarrow> ht_hash (ls_copy 0 ss l)\n 2. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   ht_hash l \\<Longrightarrow> ht_hash (ls_copy n ss l);\n        ht_hash l\\<rbrakk>\n       \\<Longrightarrow> ht_hash (ls_copy (Suc n) ss l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   ht_hash l \\<Longrightarrow> ht_hash (ls_copy n ss l);\n        ht_hash l\\<rbrakk>\n       \\<Longrightarrow> ht_hash (ls_copy (Suc n) ss l)", "apply (simp add: ht_hash_ls_insls)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ht_distinct_ls_copy:\n  assumes \"ht_distinct l\"\n  shows \"ht_distinct (ls_copy n ss l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_distinct (ls_copy n ss l)", "using assms"], ["proof (prove)\nusing this:\n  ht_distinct l\n\ngoal (1 subgoal):\n 1. ht_distinct (ls_copy n ss l)", "apply (induct n arbitrary: l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l. ht_distinct l \\<Longrightarrow> ht_distinct (ls_copy 0 ss l)\n 2. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   ht_distinct l \\<Longrightarrow>\n                   ht_distinct (ls_copy n ss l);\n        ht_distinct l\\<rbrakk>\n       \\<Longrightarrow> ht_distinct (ls_copy (Suc n) ss l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   ht_distinct l \\<Longrightarrow>\n                   ht_distinct (ls_copy n ss l);\n        ht_distinct l\\<rbrakk>\n       \\<Longrightarrow> ht_distinct (ls_copy (Suc n) ss l)", "apply (simp add: ht_distinct_ls_insls)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_ls_copy:\n  assumes \"1 < length l\"\n  shows \"1 < length (ls_copy n ss l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (ls_copy n ss l)", "using assms"], ["proof (prove)\nusing this:\n  1 < length l\n\ngoal (1 subgoal):\n 1. 1 < length (ls_copy n ss l)", "proof (induct n arbitrary: l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l. 1 < length l \\<Longrightarrow> 1 < length (ls_copy 0 ss l)\n 2. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   1 < length l \\<Longrightarrow>\n                   1 < length (ls_copy n ss l);\n        1 < length l\\<rbrakk>\n       \\<Longrightarrow> 1 < length (ls_copy (Suc n) ss l)", "case 0"], ["proof (state)\nthis:\n  1 < length l\n\ngoal (2 subgoals):\n 1. \\<And>l. 1 < length l \\<Longrightarrow> 1 < length (ls_copy 0 ss l)\n 2. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   1 < length l \\<Longrightarrow>\n                   1 < length (ls_copy n ss l);\n        1 < length l\\<rbrakk>\n       \\<Longrightarrow> 1 < length (ls_copy (Suc n) ss l)", "then"], ["proof (chain)\npicking this:\n  1 < length l", "show ?case"], ["proof (prove)\nusing this:\n  1 < length l\n\ngoal (1 subgoal):\n 1. 1 < length (ls_copy 0 ss l)", "by simp"], ["proof (state)\nthis:\n  1 < length (ls_copy 0 ss l)\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   1 < length l \\<Longrightarrow>\n                   1 < length (ls_copy n ss l);\n        1 < length l\\<rbrakk>\n       \\<Longrightarrow> 1 < length (ls_copy (Suc n) ss l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   1 < length l \\<Longrightarrow>\n                   1 < length (ls_copy n ss l);\n        1 < length l\\<rbrakk>\n       \\<Longrightarrow> 1 < length (ls_copy (Suc n) ss l)", "case (Suc n)"], ["proof (state)\nthis:\n  1 < length ?l \\<Longrightarrow> 1 < length (ls_copy n ss ?l)\n  1 < length l\n\ngoal (1 subgoal):\n 1. \\<And>n l.\n       \\<lbrakk>\\<And>l.\n                   1 < length l \\<Longrightarrow>\n                   1 < length (ls_copy n ss l);\n        1 < length l\\<rbrakk>\n       \\<Longrightarrow> 1 < length (ls_copy (Suc n) ss l)", "from Suc(1)[OF length_ls_insls[OF Suc(2)]]"], ["proof (chain)\npicking this:\n  1 < length (ls_copy n ss (ls_insls ?ls1 l))", "show ?case"], ["proof (prove)\nusing this:\n  1 < length (ls_copy n ss (ls_insls ?ls1 l))\n\ngoal (1 subgoal):\n 1. 1 < length (ls_copy (Suc n) ss l)", "by simp"], ["proof (state)\nthis:\n  1 < length (ls_copy (Suc n) ss l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complete_ht_copy: \"n \\<le> List.length ss \\<Longrightarrow>\n  <is_hashtable ss src * is_hashtable ds dst>\n  ht_copy n src dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ds) r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length ss \\<Longrightarrow>\n    <is_hashtable ss src * is_hashtable ds dst> ht_copy n src dst\n    <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ds) r>", "proof (induct n arbitrary: ds dst)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds dst.\n       0 \\<le> length ss \\<Longrightarrow>\n       <is_hashtable ss src * is_hashtable ds dst> ht_copy 0 src dst\n       <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy 0 ss ds) r>\n 2. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "case 0"], ["proof (state)\nthis:\n  0 \\<le> length ss\n\ngoal (2 subgoals):\n 1. \\<And>ds dst.\n       0 \\<le> length ss \\<Longrightarrow>\n       <is_hashtable ss src * is_hashtable ds dst> ht_copy 0 src dst\n       <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy 0 ss ds) r>\n 2. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable ss src * is_hashtable ds dst> ht_copy 0 src dst\n    <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy 0 ss ds) r>", "by (auto intro!: return_cons_rule)"], ["proof (state)\nthis:\n  <is_hashtable ss src * is_hashtable ds dst> ht_copy 0 src dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy 0 ss ds) r>\n\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> length ss \\<Longrightarrow>\n  <is_hashtable ss src * is_hashtable ?ds ?dst> ht_copy n src ?dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ?ds) r>\n  Suc n \\<le> length ss\n\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "then"], ["proof (chain)\npicking this:\n  n \\<le> length ss \\<Longrightarrow>\n  <is_hashtable ss src * is_hashtable ?ds ?dst> ht_copy n src ?dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ?ds) r>\n  Suc n \\<le> length ss", "have n: \"n < length ss\""], ["proof (prove)\nusing this:\n  n \\<le> length ss \\<Longrightarrow>\n  <is_hashtable ss src * is_hashtable ?ds ?dst> ht_copy n src ?dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ?ds) r>\n  Suc n \\<le> length ss\n\ngoal (1 subgoal):\n 1. n < length ss", "by simp"], ["proof (state)\nthis:\n  n < length ss\n\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "then"], ["proof (chain)\npicking this:\n  n < length ss", "have \"n \\<le> length ss\""], ["proof (prove)\nusing this:\n  n < length ss\n\ngoal (1 subgoal):\n 1. n \\<le> length ss", "by simp"], ["proof (state)\nthis:\n  n \\<le> length ss\n\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "note IH = Suc(1)[OF this]"], ["proof (state)\nthis:\n  <is_hashtable ss src * is_hashtable ?ds ?dst> ht_copy n src ?dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ?ds) r>\n\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable ss src * is_hashtable ds dst> ht_copy (Suc n) src dst\n    <\\<lambda>r.\n        is_hashtable ss src * is_hashtable (ls_copy (Suc n) ss ds) r>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable ss src * is_hashtable ds dst>\n    Array.nth (the_array src) n \\<bind>\n    (\\<lambda>l. ht_insls l dst \\<bind> ht_copy n src)\n    <\\<lambda>r.\n        is_hashtable ss src *\n        is_hashtable (ls_copy n ss (ls_insls (ss ! n) ds)) r>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. <is_hashtable ss src * is_hashtable ds dst> Array.nth (the_array src) n\n    <?R>\n 2. \\<And>x.\n       <?R x> ht_insls x dst \\<bind> ht_copy n src\n       <\\<lambda>r.\n           is_hashtable ss src *\n           is_hashtable (ls_copy n ss (ls_insls (ss ! n) ds)) r>", "apply (rule frame_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. <is_hashtable ss src> Array.nth (the_array src) n <?Q3>\n 2. \\<And>x.\n       <?Q3 x * is_hashtable ds dst> ht_insls x dst \\<bind> ht_copy n src\n       <\\<lambda>r.\n           is_hashtable ss src *\n           is_hashtable (ls_copy n ss (ls_insls (ss ! n) ds)) r>", "apply (subgoal_tac \"<is_hashtable ss src>\n      Array.nth (the_array src) n\n      <\\<lambda>r. is_hashtable ss src * \\<up>(r = ss ! n)>\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. <is_hashtable ss src> Array.nth (the_array src) n\n    <\\<lambda>r. is_hashtable ss src * \\<up> (r = ss ! n)> \\<Longrightarrow>\n    <is_hashtable ss src> Array.nth (the_array src) n <?Q3>\n 2. <is_hashtable ss src> Array.nth (the_array src) n\n    <\\<lambda>r. is_hashtable ss src * \\<up> (r = ss ! n)>\n 3. \\<And>x.\n       <?Q3 x * is_hashtable ds dst> ht_insls x dst \\<bind> ht_copy n src\n       <\\<lambda>r.\n           is_hashtable ss src *\n           is_hashtable (ls_copy n ss (ls_insls (ss ! n) ds)) r>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. <is_hashtable ss src> Array.nth (the_array src) n\n    <\\<lambda>r. is_hashtable ss src * \\<up> (r = ss ! n)>\n 2. \\<And>x.\n       <is_hashtable ss src * \\<up> (x = ss ! n) * is_hashtable ds dst>\n       ht_insls x dst \\<bind> ht_copy n src\n       <\\<lambda>r.\n           is_hashtable ss src *\n           is_hashtable (ls_copy n ss (ls_insls (ss ! n) ds)) r>", "apply (simp add: is_hashtable_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ht_size ss (the_size src) \\<and>\n    ht_hash ss \\<and>\n    ht_distinct ss \\<and> Suc 0 < length ss \\<longrightarrow>\n    <the_array src \\<mapsto>\\<^sub>a ss> Array.nth (the_array src) n\n    <\\<lambda>r. the_array src \\<mapsto>\\<^sub>a ss * \\<up> (r = ss ! n)>\n 2. \\<And>x.\n       <is_hashtable ss src * \\<up> (x = ss ! n) * is_hashtable ds dst>\n       ht_insls x dst \\<bind> ht_copy n src\n       <\\<lambda>r.\n           is_hashtable ss src *\n           is_hashtable (ls_copy n ss (ls_insls (ss ! n) ds)) r>", "apply (auto intro!: nth_rule simp add: n)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       <is_hashtable ss src * \\<up> (x = ss ! n) * is_hashtable ds dst>\n       ht_insls x dst \\<bind> ht_copy n src\n       <\\<lambda>r.\n           is_hashtable ss src *\n           is_hashtable (ls_copy n ss (ls_insls (ss ! n) ds)) r>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable ss src * is_hashtable ds dst>\n    ht_insls (ss ! n) dst \\<bind> ht_copy n src\n    <\\<lambda>r.\n        is_hashtable ss src *\n        is_hashtable (ls_copy n ss (ls_insls (ss ! n) ds)) r>", "apply (rule bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. <is_hashtable ss src * is_hashtable ds dst> ht_insls (ss ! n) dst <?R15>\n 2. \\<And>x.\n       <?R15 x> ht_copy n src x\n       <\\<lambda>r.\n           is_hashtable ss src *\n           is_hashtable (ls_copy n ss (ls_insls (ss ! n) ds)) r>", "apply (rule frame_rule_left)"], ["proof (prove)\ngoal (2 subgoals):\n 1. <is_hashtable ds dst> ht_insls (ss ! n) dst <?Q18>\n 2. \\<And>x.\n       <is_hashtable ss src * ?Q18 x> ht_copy n src x\n       <\\<lambda>r.\n           is_hashtable ss src *\n           is_hashtable (ls_copy n ss (ls_insls (ss ! n) ds)) r>", "apply (rule complete_ht_insls)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       <is_hashtable ss src * is_hashtable (ls_insls (ss ! n) ds) x>\n       ht_copy n src x\n       <\\<lambda>r.\n           is_hashtable ss src *\n           is_hashtable (ls_copy n ss (ls_insls (ss ! n) ds)) r>", "apply (simp add: IH)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <is_hashtable ss src * is_hashtable ds dst> ht_copy (Suc n) src dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy (Suc n) ss ds) r>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Alternative, more automatic proof\\<close>"], ["", "lemma complete_ht_copy_alt_proof: \"n \\<le> List.length ss \\<Longrightarrow>\n  <is_hashtable ss src * is_hashtable ds dst>\n  ht_copy n src dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ds) r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length ss \\<Longrightarrow>\n    <is_hashtable ss src * is_hashtable ds dst> ht_copy n src dst\n    <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ds) r>", "proof (induct n arbitrary: ds dst)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds dst.\n       0 \\<le> length ss \\<Longrightarrow>\n       <is_hashtable ss src * is_hashtable ds dst> ht_copy 0 src dst\n       <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy 0 ss ds) r>\n 2. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "case 0"], ["proof (state)\nthis:\n  0 \\<le> length ss\n\ngoal (2 subgoals):\n 1. \\<And>ds dst.\n       0 \\<le> length ss \\<Longrightarrow>\n       <is_hashtable ss src * is_hashtable ds dst> ht_copy 0 src dst\n       <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy 0 ss ds) r>\n 2. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable ss src * is_hashtable ds dst> ht_copy 0 src dst\n    <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy 0 ss ds) r>", "by (sep_auto)"], ["proof (state)\nthis:\n  <is_hashtable ss src * is_hashtable ds dst> ht_copy 0 src dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy 0 ss ds) r>\n\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> length ss \\<Longrightarrow>\n  <is_hashtable ss src * is_hashtable ?ds ?dst> ht_copy n src ?dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ?ds) r>\n  Suc n \\<le> length ss\n\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "then"], ["proof (chain)\npicking this:\n  n \\<le> length ss \\<Longrightarrow>\n  <is_hashtable ss src * is_hashtable ?ds ?dst> ht_copy n src ?dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ?ds) r>\n  Suc n \\<le> length ss", "have N_LESS: \"n < length ss\""], ["proof (prove)\nusing this:\n  n \\<le> length ss \\<Longrightarrow>\n  <is_hashtable ss src * is_hashtable ?ds ?dst> ht_copy n src ?dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ?ds) r>\n  Suc n \\<le> length ss\n\ngoal (1 subgoal):\n 1. n < length ss", "by simp"], ["proof (state)\nthis:\n  n < length ss\n\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "then"], ["proof (chain)\npicking this:\n  n < length ss", "have N_LE: \"n \\<le> length ss\""], ["proof (prove)\nusing this:\n  n < length ss\n\ngoal (1 subgoal):\n 1. n \\<le> length ss", "by simp"], ["proof (state)\nthis:\n  n \\<le> length ss\n\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "note IH = Suc(1)[OF this]"], ["proof (state)\nthis:\n  <is_hashtable ss src * is_hashtable ?ds ?dst> ht_copy n src ?dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy n ss ?ds) r>\n\ngoal (1 subgoal):\n 1. \\<And>n ds dst.\n       \\<lbrakk>\\<And>ds dst.\n                   n \\<le> length ss \\<Longrightarrow>\n                   <is_hashtable ss src * is_hashtable ds dst>\n                   ht_copy n src dst\n                   <\\<lambda>r.\n                       is_hashtable ss src *\n                       is_hashtable (ls_copy n ss ds) r>;\n        Suc n \\<le> length ss\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable ss src * is_hashtable ds dst>\n                         ht_copy (Suc n) src dst\n                         <\\<lambda>r.\n                             is_hashtable ss src *\n                             is_hashtable (ls_copy (Suc n) ss ds) r>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable ss src * is_hashtable ds dst> ht_copy (Suc n) src dst\n    <\\<lambda>r.\n        is_hashtable ss src * is_hashtable (ls_copy (Suc n) ss ds) r>", "by (sep_auto simp: N_LESS N_LE heap: complete_ht_insls IH)"], ["proof (state)\nthis:\n  <is_hashtable ss src * is_hashtable ds dst> ht_copy (Suc n) src dst\n  <\\<lambda>r. is_hashtable ss src * is_hashtable (ls_copy (Suc n) ss ds) r>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition ht_rehash\n  :: \"('k::{heap,hashable}, 'v::heap) hashtable \\<Rightarrow> ('k, 'v) hashtable Heap\"\n  where\n  \"ht_rehash ht = do {\n    n \\<leftarrow> Array.len (the_array ht);\n    h \\<leftarrow> ht_new_sz (2 * n);\n    ht_copy n ht h\n  }\""], ["", "text \"Operation on Abstraction\""], ["", "definition ls_rehash :: \"('k::hashable \\<times> 'v) list list \\<Rightarrow> ('k \\<times> 'v) list list\"\n  where \"ls_rehash l = ls_copy (List.length l) l (replicate (2 * length l) [])\""], ["", "lemma ht_hash_ls_rehash: \"ht_hash (ls_rehash l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_hash (ls_rehash l)", "by (simp add: ht_hash_ls_copy ls_rehash_def)"], ["", "lemma ht_distinct_ls_rehash: \"ht_distinct (ls_rehash l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ht_distinct (ls_rehash l)", "by (simp add: ht_distinct_ls_copy ls_rehash_def)"], ["", "lemma length_ls_rehash:\n  assumes \"1 < length l\"\n  shows \"1 < length (ls_rehash l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (ls_rehash l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < length (ls_rehash l)", "from assms"], ["proof (chain)\npicking this:\n  1 < length l", "have \"1 < length (replicate (2 * length l) [])\""], ["proof (prove)\nusing this:\n  1 < length l\n\ngoal (1 subgoal):\n 1. 1 < length (replicate (2 * length l) [])", "by simp"], ["proof (state)\nthis:\n  1 < length (replicate (2 * length l) [])\n\ngoal (1 subgoal):\n 1. 1 < length (ls_rehash l)", "from length_ls_copy[OF this, of \"length l\" l]"], ["proof (chain)\npicking this:\n  1 < length (ls_copy (length l) l (replicate (2 * length l) []))", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < length (ls_copy (length l) l (replicate (2 * length l) []))\n\ngoal (1 subgoal):\n 1. 1 < length (ls_rehash l)", "by (simp add: ls_rehash_def)"], ["proof (state)\nthis:\n  1 < length (ls_rehash l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ht_imp_len: \"is_hashtable l ht \\<Longrightarrow>\\<^sub>A is_hashtable l ht * \\<up>(length l > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_hashtable l ht \\<Longrightarrow>\\<^sub>A\n    is_hashtable l ht * \\<up> (0 < length l)", "unfolding is_hashtable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_array ht \\<mapsto>\\<^sub>a l *\n    \\<up>\n     (ht_size l (the_size ht) \\<and>\n      ht_hash l \\<and>\n      ht_distinct l \\<and> 1 < length l) \\<Longrightarrow>\\<^sub>A\n    the_array ht \\<mapsto>\\<^sub>a l *\n    \\<up>\n     (ht_size l (the_size ht) \\<and>\n      ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n    \\<up> (0 < length l)", "by sep_auto"], ["", "lemma complete_ht_rehash:\n  \"<is_hashtable l ht> ht_rehash ht\n  <\\<lambda>r. is_hashtable l ht * is_hashtable (ls_rehash l) r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_rehash ht\n    <\\<lambda>r. is_hashtable l ht * is_hashtable (ls_rehash l) r>", "apply (rule cons_pre_rule[OF ht_imp_len])"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht * \\<up> (0 < length l)> ht_rehash ht\n    <\\<lambda>x. is_hashtable l ht * is_hashtable (ls_rehash l) x>", "unfolding ht_rehash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht * \\<up> (0 < length l)>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>n. ht_new_sz (2 * n) \\<bind> ht_copy n ht)\n    <\\<lambda>x. is_hashtable l ht * is_hashtable (ls_rehash l) x>", "apply (sep_auto heap: complete_ht_new_sz)"], ["proof (prove)\ngoal (2 subgoals):\n 1. l \\<noteq> [] \\<Longrightarrow> Suc 0 < 2 * length l\n 2. \\<And>x xa.\n       \\<lbrakk>l \\<noteq> []; x = length l\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable (replicate (2 * x) []) xa *\n                          is_hashtable l ht>\n                         ht_copy (length l) ht xa\n                         <\\<lambda>x.\n                             is_hashtable l ht *\n                             is_hashtable (ls_rehash l) x>", "apply (cases l; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>l \\<noteq> []; x = length l\\<rbrakk>\n       \\<Longrightarrow> <is_hashtable (replicate (2 * x) []) xa *\n                          is_hashtable l ht>\n                         ht_copy (length l) ht xa\n                         <\\<lambda>x.\n                             is_hashtable l ht *\n                             is_hashtable (ls_rehash l) x>", "apply (sep_auto heap: complete_ht_copy simp: ls_rehash_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition load_factor :: nat \\<comment> \\<open>in percent\\<close>\n  where \"load_factor = 75\""], ["", "definition ht_update\n  :: \"'k::{heap,hashable} \\<Rightarrow> 'v::heap \\<Rightarrow> ('k, 'v) hashtable\n  \\<Rightarrow> ('k, 'v) hashtable Heap\"\n  where\n  \"ht_update k v ht = do {\n    m \\<leftarrow> Array.len (the_array ht);\n    ht \\<leftarrow> (if m * load_factor \\<le> (the_size ht) * 100 then\n        ht_rehash ht\n      else return ht);\n    ht_upd k v ht\n  }\""], ["", "lemma complete_ht_update_normal:\n  \"\\<not> length l * load_factor \\<le> (the_size ht)* 100 \\<Longrightarrow>\n  <is_hashtable l ht>\n  ht_update k v ht\n  <is_hashtable (abs_update k v l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length l * load_factor \\<le> the_size ht * 100 \\<Longrightarrow>\n    <is_hashtable l ht> ht_update k v ht <is_hashtable (abs_update k v l)>", "unfolding ht_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length l * load_factor \\<le> the_size ht * 100 \\<Longrightarrow>\n    <is_hashtable l ht>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>m.\n        (if m * load_factor \\<le> the_size ht * 100 then ht_rehash ht\n         else return ht) \\<bind>\n        ht_upd k v)\n    <is_hashtable (abs_update k v l)>", "apply (sep_auto simp: is_hashtable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length l * load_factor \\<le> the_size ht * 100;\n     ht_size l (the_size ht); ht_hash l; ht_distinct l;\n     Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> <the_array ht \\<mapsto>\\<^sub>a l> ht_upd k v ht\n                      <is_hashtable (abs_update k v l)>", "apply (rule cons_pre_rule[where P' = \"is_hashtable l ht\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> length l * load_factor \\<le> the_size ht * 100;\n     ht_size l (the_size ht); ht_hash l; ht_distinct l;\n     Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> the_array ht \\<mapsto>\\<^sub>a\n                      l \\<Longrightarrow>\\<^sub>A\n                      is_hashtable l ht\n 2. \\<lbrakk>\\<not> length l * load_factor \\<le> the_size ht * 100;\n     ht_size l (the_size ht); ht_hash l; ht_distinct l;\n     Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> <is_hashtable l ht> ht_upd k v ht\n                      <is_hashtable (abs_update k v l)>", "apply (simp add: is_hashtable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length l * load_factor \\<le> the_size ht * 100;\n     ht_size l (the_size ht); ht_hash l; ht_distinct l;\n     Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> <is_hashtable l ht> ht_upd k v ht\n                      <is_hashtable (abs_update k v l)>", "apply (simp add: complete_ht_upd)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma complete_ht_update_rehash:\n  \"length l * load_factor \\<le> (the_size ht)* 100 \\<Longrightarrow>\n  <is_hashtable l ht>\n  ht_update k v ht\n  <\\<lambda>r. is_hashtable l ht\n    * is_hashtable (abs_update k v (ls_rehash l)) r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l * load_factor \\<le> the_size ht * 100 \\<Longrightarrow>\n    <is_hashtable l ht> ht_update k v ht\n    <\\<lambda>r.\n        is_hashtable l ht * is_hashtable (abs_update k v (ls_rehash l)) r>", "unfolding ht_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length l * load_factor \\<le> the_size ht * 100 \\<Longrightarrow>\n    <is_hashtable l ht>\n    Array.len (the_array ht) \\<bind>\n    (\\<lambda>m.\n        (if m * load_factor \\<le> the_size ht * 100 then ht_rehash ht\n         else return ht) \\<bind>\n        ht_upd k v)\n    <\\<lambda>r.\n        is_hashtable l ht * is_hashtable (abs_update k v (ls_rehash l)) r>", "by (sep_auto heap: complete_ht_rehash complete_ht_upd)"], ["", "subsection \\<open>Conversion to List\\<close>"], ["", "definition ht_to_list ::\n  \"('k::heap, 'v::heap) hashtable \\<Rightarrow> ('k \\<times> 'v) list Heap\" where\n  \"ht_to_list ht = do {\n    l \\<leftarrow> (Array.freeze (the_array ht));\n    return (concat l)\n  }\""], ["", "lemma complete_ht_to_list: \"<is_hashtable l ht> ht_to_list ht\n  <\\<lambda>r. is_hashtable l ht * \\<up>(r = concat l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_hashtable l ht> ht_to_list ht\n    <\\<lambda>r. is_hashtable l ht * \\<up> (r = concat l)>", "unfolding ht_to_list_def is_hashtable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <the_array ht \\<mapsto>\\<^sub>a l *\n     \\<up>\n      (ht_size l (the_size ht) \\<and>\n       ht_hash l \\<and> ht_distinct l \\<and> 1 < length l)>\n    Array.freeze (the_array ht) \\<bind> (\\<lambda>l. return (concat l))\n    <\\<lambda>r.\n        the_array ht \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (ht_size l (the_size ht) \\<and>\n          ht_hash l \\<and> ht_distinct l \\<and> 1 < length l) *\n        \\<up> (r = concat l)>", "by sep_auto"], ["", "end"]]}