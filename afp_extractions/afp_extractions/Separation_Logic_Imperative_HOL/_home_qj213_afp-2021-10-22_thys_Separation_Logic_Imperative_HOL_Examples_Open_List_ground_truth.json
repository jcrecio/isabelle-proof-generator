{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Examples/Open_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma os_prec: \n  \"precise os_list\"", "lemma os_imp_list_impl: \"imp_list os_list\"", "lemma os_empty_rule: \"<emp> os_empty <os_list []>\"", "lemma os_empty_impl: \"imp_list_empty os_list os_empty\"", "lemma os_is_empty_rule: \n  \"<os_list xs b> os_is_empty b <\\<lambda>r. os_list xs b * \\<up>(r \\<longleftrightarrow> xs = [])>\"", "lemma os_is_empty_impl: \"imp_list_is_empty os_list os_is_empty\"", "lemma os_prepend_rule:\n  \"<os_list xs n> os_prepend x n <os_list (x # xs)>\"", "lemma os_prepend_impl: \"imp_list_prepend os_list os_prepend\"", "lemma os_pop_rule:\n  \"xs \\<noteq> [] \\<Longrightarrow> <os_list xs r> \n  os_pop r \n  <\\<lambda>(x,r'). os_list (tl xs) r' * (the r) \\<mapsto>\\<^sub>r (Node x r') * \\<up>(x = hd xs)>\"", "lemma os_pop_impl: \"imp_list_pop os_list os_pop\"", "lemma [simp, sep_dflt_simps]:\n  \"os_reverse_aux q None = return q\"\n  \"os_reverse_aux q (Some r) = do {\n      v \\<leftarrow> !r;\n      r := Node (val v) q;\n      os_reverse_aux (Some r) (next v) }\"", "lemma os_reverse_aux_rule: \n  \"<os_list xs p * os_list ys q> \n    os_reverse_aux q p \n  <os_list ((rev xs) @ ys) >\"", "lemma os_reverse_rule: \"<os_list xs p> os_reverse p <os_list (rev xs)>\"", "lemma os_reverse_impl: \"imp_list_reverse os_list os_reverse\"", "lemma [simp, sep_dflt_simps]: \n  \"os_rem x None = return None\"\n  \"os_rem x (Some p) = do { \n       n \\<leftarrow> !p;\n       q \\<leftarrow> os_rem x (next n);\n       (if (val n = x) \n         then return q\n         else do { \n           p := Node (val n) q; \n           return (Some p) }) }\"", "lemma os_rem_rule[sep_heap_rules]: \n  \"<os_list xs b> os_rem x b <\\<lambda>r. os_list (removeAll x xs) r * true>\"", "lemma os_rem_rule_alt_proof: \n  \"<os_list xs b> os_rem x b <\\<lambda>r. os_list (removeAll x xs) r * true>\"", "lemma os_iterate_impl: \n  \"imp_list_iterate os_list os_is_it os_it_init os_it_has_next os_it_next\"", "lemma os_sum'_rule[sep_heap_rules]: \n  \"<os_is_it l p l' it> \n    os_sum' it s \n  <\\<lambda>r. os_list l p * \\<up>(r = s + sum_list l')>\\<^sub>t\"", "lemma os_sum_rule[sep_heap_rules]: \n  \"<os_list l p> os_sum p <\\<lambda>r. os_list l p * \\<up>(r=sum_list l)>\\<^sub>t\""], "translations": [["", "lemma os_prec: \n  \"precise os_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise os_list", "by rule (simp add: lseg_prec2)"], ["", "lemma os_imp_list_impl: \"imp_list os_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list os_list", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise os_list", "apply (rule os_prec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation os: imp_list os_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list os_list", "by (rule os_imp_list_impl)"], ["", "subsection \\<open>Operations\\<close>"], ["", "subsubsection \\<open>Allocate Empty List\\<close>"], ["", "definition os_empty :: \"'a::heap os_list Heap\" where\n  \"os_empty \\<equiv> return None\""], ["", "lemma os_empty_rule: \"<emp> os_empty <os_list []>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> os_empty <os_list []>", "unfolding os_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> return None <os_list []>", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma os_empty_impl: \"imp_list_empty os_list os_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_empty os_list os_empty", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> os_empty <os_list []>\\<^sub>t", "apply (sep_auto heap add: os_empty_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation os: imp_list_empty os_list os_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_empty os_list os_empty", "by (rule os_empty_impl)"], ["", "subsubsection \\<open>Emptiness check\\<close>"], ["", "text \\<open>A linked list is empty, iff it is the null pointer.\\<close>"], ["", "definition os_is_empty :: \"'a::heap os_list \\<Rightarrow> bool Heap\" where\n  \"os_is_empty b \\<equiv> return (b = None)\""], ["", "lemma os_is_empty_rule: \n  \"<os_list xs b> os_is_empty b <\\<lambda>r. os_list xs b * \\<up>(r \\<longleftrightarrow> xs = [])>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs b> os_is_empty b\n    <\\<lambda>r. os_list xs b * \\<up> (r = (xs = []))>", "unfolding os_is_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs b> return (b = None)\n    <\\<lambda>r. os_list xs b * \\<up> (r = (xs = []))>", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma os_is_empty_impl: \"imp_list_is_empty os_list os_is_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_is_empty os_list os_is_empty", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l p.\n       <os_list l\n         p> os_is_empty\n             p <\\<lambda>r. os_list l p * \\<up> (r = (l = []))>\\<^sub>t", "apply (sep_auto heap add: os_is_empty_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation os: imp_list_is_empty os_list os_is_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_is_empty os_list os_is_empty", "by (rule os_is_empty_impl)"], ["", "subsubsection \\<open>Prepend\\<close>"], ["", "text \\<open>To push an element to the front of a list we allocate a new node which\n  stores the element and the old list as successor. The new list is the new \n  allocated reference.\\<close>"], ["", "definition os_prepend :: \"'a \\<Rightarrow> 'a::heap os_list \\<Rightarrow> 'a os_list Heap\" where\n  \"os_prepend a n = do { p \\<leftarrow> ref (Node a n); return (Some p) }\""], ["", "lemma os_prepend_rule:\n  \"<os_list xs n> os_prepend x n <os_list (x # xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs n> os_prepend x n <os_list (x # xs)>", "unfolding os_prepend_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs n> ref (Node x n) \\<bind> (\\<lambda>p. return (Some p))\n    <os_list (x # xs)>", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma os_prepend_impl: \"imp_list_prepend os_list os_prepend\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_prepend os_list os_prepend", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l p a. <os_list l p> os_prepend a p <os_list (a # l)>\\<^sub>t", "apply (sep_auto heap add: os_prepend_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation os: imp_list_prepend os_list os_prepend"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_prepend os_list os_prepend", "by (rule os_prepend_impl)"], ["", "subsubsection\\<open>Pop\\<close>"], ["", "text \\<open>To pop the first element out of the list we look up the value and the\n  reference of the node and return the pair of those.\\<close>"], ["", "fun os_pop :: \"'a::heap os_list \\<Rightarrow> ('a \\<times> 'a os_list) Heap\" where\n  \"os_pop None   = raise STR ''Empty Os_list''\" |\n  \"os_pop (Some p) = do {m \\<leftarrow> !p; return (val m, next m)}\""], ["", "declare os_pop.simps[simp del]"], ["", "lemma os_pop_rule:\n  \"xs \\<noteq> [] \\<Longrightarrow> <os_list xs r> \n  os_pop r \n  <\\<lambda>(x,r'). os_list (tl xs) r' * (the r) \\<mapsto>\\<^sub>r (Node x r') * \\<up>(x = hd xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    <os_list xs r> os_pop r\n    <\\<lambda>(x, r').\n        os_list (tl xs) r' * the r \\<mapsto>\\<^sub>r Node x r' *\n        \\<up> (x = hd xs)>", "apply (cases r, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>xs \\<noteq> []; r = Some a\\<rbrakk>\n       \\<Longrightarrow> <os_list xs (Some a)> os_pop (Some a)\n                         <\\<lambda>(x, r').\n                             os_list (tl xs) r' *\n                             a \\<mapsto>\\<^sub>r Node x r' *\n                             \\<up> (x = hd xs)>", "apply (cases xs, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list.\n       \\<lbrakk>r = Some a; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>App n.\n                             pp \\<mapsto>\\<^sub>r Node aa n *\n                             os_list list n *\n                             \\<up> (a = pp)>\n                         os_pop (Some a)\n                         <\\<lambda>(x, r').\n                             os_list list r' *\n                             a \\<mapsto>\\<^sub>r Node x r' *\n                             \\<up> (x = aa)>", "apply (sep_auto simp: os_pop.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma os_pop_impl: \"imp_list_pop os_list os_pop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_pop os_list os_pop", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l p.\n       l \\<noteq> [] \\<Longrightarrow>\n       <os_list l\n         p> os_pop\n             p <\\<lambda>r.\n                   case r of\n                   (r, p') \\<Rightarrow>\n                     os_list (tl l) p' * \\<up> (r = hd l)>\\<^sub>t", "apply (sep_auto heap add: os_pop_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation os: imp_list_pop os_list os_pop"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_pop os_list os_pop", "by (rule os_pop_impl)"], ["", "subsubsection \\<open>Reverse\\<close>"], ["", "text \\<open>The following reversal function is equivalent to the one from \n  Imperative HOL. And gives a more difficult example.\\<close>"], ["", "partial_function (heap) os_reverse_aux \n  :: \"'a::heap os_list \\<Rightarrow> 'a os_list \\<Rightarrow> 'a os_list Heap\" \n  where [code]:\n  \"os_reverse_aux q p = (case p of \n    None \\<Rightarrow> return q |\n    Some r \\<Rightarrow> do {\n      v \\<leftarrow> !r;\n      r := Node (val v) q;\n      os_reverse_aux p (next v) })\""], ["", "lemma [simp, sep_dflt_simps]:\n  \"os_reverse_aux q None = return q\"\n  \"os_reverse_aux q (Some r) = do {\n      v \\<leftarrow> !r;\n      r := Node (val v) q;\n      os_reverse_aux (Some r) (next v) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. os_reverse_aux q None = return q &&&\n    os_reverse_aux q (Some r) =\n    !r \\<bind>\n    (\\<lambda>v.\n        r := Node (val v) q \\<bind>\n        (\\<lambda>_. os_reverse_aux (Some r) (next v)))", "apply (subst os_reverse_aux.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (case None of None \\<Rightarrow> return q\n     | Some r \\<Rightarrow>\n         !r \\<bind>\n         (\\<lambda>v.\n             r := Node (val v) q \\<bind>\n             (\\<lambda>_. os_reverse_aux None (next v)))) =\n    return q\n 2. os_reverse_aux q (Some r) =\n    !r \\<bind>\n    (\\<lambda>v.\n        r := Node (val v) q \\<bind>\n        (\\<lambda>_. os_reverse_aux (Some r) (next v)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. os_reverse_aux q (Some r) =\n    !r \\<bind>\n    (\\<lambda>v.\n        r := Node (val v) q \\<bind>\n        (\\<lambda>_. os_reverse_aux (Some r) (next v)))", "apply (subst os_reverse_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case Some r of None \\<Rightarrow> return q\n     | Some ra \\<Rightarrow>\n         !ra \\<bind>\n         (\\<lambda>v.\n             ra := Node (val v) q \\<bind>\n             (\\<lambda>_. os_reverse_aux (Some r) (next v)))) =\n    !r \\<bind>\n    (\\<lambda>v.\n        r := Node (val v) q \\<bind>\n        (\\<lambda>_. os_reverse_aux (Some r) (next v)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"os_reverse p = os_reverse_aux None p\""], ["", "lemma os_reverse_aux_rule: \n  \"<os_list xs p * os_list ys q> \n    os_reverse_aux q p \n  <os_list ((rev xs) @ ys) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs p * os_list ys q> os_reverse_aux q p <os_list (rev xs @ ys)>", "proof (induct xs arbitrary: p q ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q ys.\n       <os_list [] p * os_list ys q> os_reverse_aux q p\n       <os_list (rev [] @ ys)>\n 2. \\<And>a xs p q ys.\n       (\\<And>p q ys.\n           <os_list xs p * os_list ys q> os_reverse_aux q p\n           <os_list (rev xs @ ys)>) \\<Longrightarrow>\n       <os_list (a # xs) p * os_list ys q> os_reverse_aux q p\n       <os_list (rev (a # xs) @ ys)>", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>p q ys.\n       <os_list [] p * os_list ys q> os_reverse_aux q p\n       <os_list (rev [] @ ys)>\n 2. \\<And>a xs p q ys.\n       (\\<And>p q ys.\n           <os_list xs p * os_list ys q> os_reverse_aux q p\n           <os_list (rev xs @ ys)>) \\<Longrightarrow>\n       <os_list (a # xs) p * os_list ys q> os_reverse_aux q p\n       <os_list (rev (a # xs) @ ys)>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list [] p * os_list ys q> os_reverse_aux q p <os_list (rev [] @ ys)>", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <os_list [] p * os_list ys q> os_reverse_aux q p <os_list (rev [] @ ys)>\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q ys.\n       (\\<And>p q ys.\n           <os_list xs p * os_list ys q> os_reverse_aux q p\n           <os_list (rev xs @ ys)>) \\<Longrightarrow>\n       <os_list (a # xs) p * os_list ys q> os_reverse_aux q p\n       <os_list (rev (a # xs) @ ys)>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs p q ys.\n       (\\<And>p q ys.\n           <os_list xs p * os_list ys q> os_reverse_aux q p\n           <os_list (rev xs @ ys)>) \\<Longrightarrow>\n       <os_list (a # xs) p * os_list ys q> os_reverse_aux q p\n       <os_list (rev (a # xs) @ ys)>", "case (Cons x xs)"], ["proof (state)\nthis:\n  <os_list xs ?p * os_list ?ys ?q> os_reverse_aux ?q ?p\n  <os_list (rev xs @ ?ys)>\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q ys.\n       (\\<And>p q ys.\n           <os_list xs p * os_list ys q> os_reverse_aux q p\n           <os_list (rev xs @ ys)>) \\<Longrightarrow>\n       <os_list (a # xs) p * os_list ys q> os_reverse_aux q p\n       <os_list (rev (a # xs) @ ys)>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list (x # xs) p * os_list ys q> os_reverse_aux q p\n    <os_list (rev (x # xs) @ ys)>", "apply (cases p, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       p = Some a \\<Longrightarrow>\n       <\\<exists>\\<^sub>App n.\n           pp \\<mapsto>\\<^sub>r Node x n * os_list xs n * os_list ys q *\n           \\<up> (a = pp)>\n       !a \\<bind>\n       (\\<lambda>v.\n           a := Node (val v) q \\<bind>\n           (\\<lambda>_. os_reverse_aux (Some a) (next v)))\n       <os_list (rev xs @ x # ys)>", "apply (sep_auto heap add: cons_pre_rule[OF _ Cons.hyps])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <os_list (x # xs) p * os_list ys q> os_reverse_aux q p\n  <os_list (rev (x # xs) @ ys)>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma os_reverse_rule: \"<os_list xs p> os_reverse p <os_list (rev xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs p> os_reverse p <os_list (rev xs)>", "unfolding os_reverse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs p> os_reverse_aux None p <os_list (rev xs)>", "apply (auto simp: os_reverse_aux_rule[where ys=\"[]\", simplified, rule_format])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma os_reverse_impl: \"imp_list_reverse os_list os_reverse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_reverse os_list os_reverse", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l p. <os_list l p> os_reverse p <os_list (rev l)>\\<^sub>t", "apply (sep_auto heap add: os_reverse_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation os: imp_list_reverse os_list os_reverse"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_reverse os_list os_reverse", "by (rule os_reverse_impl)"], ["", "subsubsection \\<open>Remove\\<close>"], ["", "text \\<open>Remove all appearances of an element from a linked list.\\<close>"], ["", "partial_function (heap) os_rem \n  :: \"'a::heap \\<Rightarrow> 'a node ref option \\<Rightarrow> 'a node ref option Heap\" \n  where [code]:\n  \"os_rem x b = (case b of \n     None \\<Rightarrow> return None |\n     Some p \\<Rightarrow> do { \n       n \\<leftarrow> !p;\n       q \\<leftarrow> os_rem x (next n);\n       (if (val n = x) \n         then return q\n         else do { \n           p := Node (val n) q; \n           return (Some p) }) })\""], ["", "lemma [simp, sep_dflt_simps]: \n  \"os_rem x None = return None\"\n  \"os_rem x (Some p) = do { \n       n \\<leftarrow> !p;\n       q \\<leftarrow> os_rem x (next n);\n       (if (val n = x) \n         then return q\n         else do { \n           p := Node (val n) q; \n           return (Some p) }) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. os_rem x None = return None &&&\n    os_rem x (Some p) =\n    !p \\<bind>\n    (\\<lambda>n.\n        os_rem x (next n) \\<bind>\n        (\\<lambda>q.\n            if val n = x then return q\n            else p := Node (val n) q \\<bind> (\\<lambda>_. return (Some p))))", "apply (subst os_rem.simps, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma os_rem_rule[sep_heap_rules]: \n  \"<os_list xs b> os_rem x b <\\<lambda>r. os_list (removeAll x xs) r * true>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs b> os_rem x b <os_list (removeAll x xs)>\\<^sub>t", "proof (induct xs arbitrary: b x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b x. <os_list [] b> os_rem x b <os_list (removeAll x [])>\\<^sub>t\n 2. \\<And>a xs b x.\n       (\\<And>b x.\n           <os_list xs\n             b> os_rem x\n                 b <os_list (removeAll x xs)>\\<^sub>t) \\<Longrightarrow>\n       <os_list (a # xs)\n         b> os_rem x b <os_list (removeAll x (a # xs))>\\<^sub>t", "(* Have to generalize over x, as \n    sep_auto preprocessor introduces a new variable. Alternative: \n    No preprocessing. (See alternative proof below) *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b x. <os_list [] b> os_rem x b <os_list (removeAll x [])>\\<^sub>t\n 2. \\<And>a xs b x.\n       (\\<And>b x.\n           <os_list xs\n             b> os_rem x\n                 b <os_list (removeAll x xs)>\\<^sub>t) \\<Longrightarrow>\n       <os_list (a # xs)\n         b> os_rem x b <os_list (removeAll x (a # xs))>\\<^sub>t", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>b x. <os_list [] b> os_rem x b <os_list (removeAll x [])>\\<^sub>t\n 2. \\<And>a xs b x.\n       (\\<And>b x.\n           <os_list xs\n             b> os_rem x\n                 b <os_list (removeAll x xs)>\\<^sub>t) \\<Longrightarrow>\n       <os_list (a # xs)\n         b> os_rem x b <os_list (removeAll x (a # xs))>\\<^sub>t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list [] b> os_rem x b <os_list (removeAll x [])>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <os_list [] b> os_rem x b <os_list (removeAll x [])>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>a xs b x.\n       (\\<And>b x.\n           <os_list xs\n             b> os_rem x\n                 b <os_list (removeAll x xs)>\\<^sub>t) \\<Longrightarrow>\n       <os_list (a # xs)\n         b> os_rem x b <os_list (removeAll x (a # xs))>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs b x.\n       (\\<And>b x.\n           <os_list xs\n             b> os_rem x\n                 b <os_list (removeAll x xs)>\\<^sub>t) \\<Longrightarrow>\n       <os_list (a # xs)\n         b> os_rem x b <os_list (removeAll x (a # xs))>\\<^sub>t", "case (Cons y xs)"], ["proof (state)\nthis:\n  <os_list xs ?b> os_rem ?x ?b <os_list (removeAll ?x xs)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>a xs b x.\n       (\\<And>b x.\n           <os_list xs\n             b> os_rem x\n                 b <os_list (removeAll x xs)>\\<^sub>t) \\<Longrightarrow>\n       <os_list (a # xs)\n         b> os_rem x b <os_list (removeAll x (a # xs))>\\<^sub>t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list (y # xs) b> os_rem x b <os_list (removeAll x (y # xs))>\\<^sub>t", "by (sep_auto heap add: Cons.hyps)"], ["proof (state)\nthis:\n  <os_list (y # xs) b> os_rem x b <os_list (removeAll x (y # xs))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma os_rem_rule_alt_proof: \n  \"<os_list xs b> os_rem x b <\\<lambda>r. os_list (removeAll x xs) r * true>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list xs b> os_rem x b <os_list (removeAll x xs)>\\<^sub>t", "proof (induct xs arbitrary: b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b. <os_list [] b> os_rem x b <os_list (removeAll x [])>\\<^sub>t\n 2. \\<And>a xs b.\n       (\\<And>b.\n           <os_list xs\n             b> os_rem x\n                 b <os_list (removeAll x xs)>\\<^sub>t) \\<Longrightarrow>\n       <os_list (a # xs)\n         b> os_rem x b <os_list (removeAll x (a # xs))>\\<^sub>t", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>b. <os_list [] b> os_rem x b <os_list (removeAll x [])>\\<^sub>t\n 2. \\<And>a xs b.\n       (\\<And>b.\n           <os_list xs\n             b> os_rem x\n                 b <os_list (removeAll x xs)>\\<^sub>t) \\<Longrightarrow>\n       <os_list (a # xs)\n         b> os_rem x b <os_list (removeAll x (a # xs))>\\<^sub>t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list [] b> os_rem x b <os_list (removeAll x [])>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <os_list [] b> os_rem x b <os_list (removeAll x [])>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>a xs b.\n       (\\<And>b.\n           <os_list xs\n             b> os_rem x\n                 b <os_list (removeAll x xs)>\\<^sub>t) \\<Longrightarrow>\n       <os_list (a # xs)\n         b> os_rem x b <os_list (removeAll x (a # xs))>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs b.\n       (\\<And>b.\n           <os_list xs\n             b> os_rem x\n                 b <os_list (removeAll x xs)>\\<^sub>t) \\<Longrightarrow>\n       <os_list (a # xs)\n         b> os_rem x b <os_list (removeAll x (a # xs))>\\<^sub>t", "case (Cons y xs)"], ["proof (state)\nthis:\n  <os_list xs ?b> os_rem x ?b <os_list (removeAll x xs)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>a xs b.\n       (\\<And>b.\n           <os_list xs\n             b> os_rem x\n                 b <os_list (removeAll x xs)>\\<^sub>t) \\<Longrightarrow>\n       <os_list (a # xs)\n         b> os_rem x b <os_list (removeAll x (a # xs))>\\<^sub>t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list (y # xs) b> os_rem x b <os_list (removeAll x (y # xs))>\\<^sub>t", "by (sep_auto (nopre) heap add: Cons.hyps)"], ["proof (state)\nthis:\n  <os_list (y # xs) b> os_rem x b <os_list (removeAll x (y # xs))>\\<^sub>t\n\ngoal:\nNo subgoals!", "(* Switching off preprocessor *)"], ["proof (state)\nthis:\n  <os_list (y # xs) b> os_rem x b <os_list (removeAll x (y # xs))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Iterator\\<close>"], ["", "type_synonym 'a os_list_it = \"'a os_list\""], ["", "definition \"os_is_it l p l2 it \n  \\<equiv> \\<exists>\\<^sub>Al1. \\<up>(l=l1@l2) * lseg l1 p it * os_list l2 it\""], ["", "definition os_it_init :: \"'a os_list \\<Rightarrow> ('a os_list_it) Heap\" \n  where \"os_it_init l = return l\""], ["", "fun os_it_next where \n  \"os_it_next (Some p) = do {\n    n \\<leftarrow> !p;\n    return (val n,next n)\n  }\""], ["", "definition os_it_has_next :: \"'a os_list_it \\<Rightarrow> bool Heap\" where\n  \"os_it_has_next it \\<equiv> return (it\\<noteq>None)\""], ["", "lemma os_iterate_impl: \n  \"imp_list_iterate os_list os_is_it os_it_init os_it_has_next os_it_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_iterate os_list os_is_it os_it_init os_it_has_next os_it_next", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l p. <os_list l p> os_it_init p <os_is_it l p l>\\<^sub>t\n 2. \\<And>l' l p it.\n       l' \\<noteq> [] \\<Longrightarrow>\n       <os_is_it l p l' it> os_it_next it\n       <\\<lambda>(a, it'). os_is_it l p (tl l') it' * \\<up> (a = hd l')>\n 3. \\<And>l p l' it.\n       <os_is_it l p l' it> os_it_has_next it\n       <\\<lambda>r. os_is_it l p l' it * \\<up> (r = (l' \\<noteq> []))>\n 4. \\<And>l p l' it.\n       os_is_it l p l' it \\<Longrightarrow>\\<^sub>A os_list l p * true", "unfolding os_it_init_def os_is_it_def[abs_def]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l p.\n       <os_list l\n         p> return\n             p <\\<lambda>r.\n                   \\<exists>\\<^sub>Al1.\n                      \\<up> (l = l1 @ l) * lseg l1 p r *\n                      os_list l r>\\<^sub>t\n 2. \\<And>l' l p it.\n       l' \\<noteq> [] \\<Longrightarrow>\n       <\\<exists>\\<^sub>Al1.\n           \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it>\n       os_it_next it\n       <\\<lambda>(a, it').\n           (\\<exists>\\<^sub>Al1.\n               \\<up> (l = l1 @ tl l') * lseg l1 p it' *\n               os_list (tl l') it') *\n           \\<up> (a = hd l')>\n 3. \\<And>l p l' it.\n       <\\<exists>\\<^sub>Al1.\n           \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it>\n       os_it_has_next it\n       <\\<lambda>r.\n           (\\<exists>\\<^sub>Al1.\n               \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it) *\n           \\<up> (r = (l' \\<noteq> []))>\n 4. \\<And>l p l' it.\n       \\<exists>\\<^sub>Al1.\n          \\<up> (l = l1 @ l') * lseg l1 p it *\n          os_list l' it \\<Longrightarrow>\\<^sub>A\n       os_list l p * true", "apply sep_auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l' l p it.\n       l' \\<noteq> [] \\<Longrightarrow>\n       <\\<exists>\\<^sub>Al1.\n           \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it>\n       os_it_next it\n       <\\<lambda>(a, it').\n           (\\<exists>\\<^sub>Al1.\n               \\<up> (l = l1 @ tl l') * lseg l1 p it' *\n               os_list (tl l') it') *\n           \\<up> (a = hd l')>\n 2. \\<And>l p l' it.\n       <\\<exists>\\<^sub>Al1.\n           \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it>\n       os_it_has_next it\n       <\\<lambda>r.\n           (\\<exists>\\<^sub>Al1.\n               \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it) *\n           \\<up> (r = (l' \\<noteq> []))>\n 3. \\<And>l p l' it.\n       \\<exists>\\<^sub>Al1.\n          \\<up> (l = l1 @ l') * lseg l1 p it *\n          os_list l' it \\<Longrightarrow>\\<^sub>A\n       os_list l p * true", "apply (case_tac it, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l' l p it a.\n       \\<lbrakk>l' \\<noteq> []; it = Some a\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Al1.\n                             \\<up> (l = l1 @ l') * lseg l1 p it *\n                             os_list l' it>\n                         os_it_next it\n                         <\\<lambda>(a, it').\n                             (\\<exists>\\<^sub>Al1.\n                                 \\<up> (l = l1 @ tl l') * lseg l1 p it' *\n                                 os_list (tl l') it') *\n                             \\<up> (a = hd l')>\n 2. \\<And>l p l' it.\n       <\\<exists>\\<^sub>Al1.\n           \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it>\n       os_it_has_next it\n       <\\<lambda>r.\n           (\\<exists>\\<^sub>Al1.\n               \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it) *\n           \\<up> (r = (l' \\<noteq> []))>\n 3. \\<And>l p l' it.\n       \\<exists>\\<^sub>Al1.\n          \\<up> (l = l1 @ l') * lseg l1 p it *\n          os_list l' it \\<Longrightarrow>\\<^sub>A\n       os_list l p * true", "apply (case_tac l', simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l' l p it a aa list.\n       \\<lbrakk>l' \\<noteq> []; it = Some a; l' = aa # list\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Al1.\n                             \\<up> (l = l1 @ l') * lseg l1 p it *\n                             os_list l' it>\n                         os_it_next it\n                         <\\<lambda>(a, it').\n                             (\\<exists>\\<^sub>Al1.\n                                 \\<up> (l = l1 @ tl l') * lseg l1 p it' *\n                                 os_list (tl l') it') *\n                             \\<up> (a = hd l')>\n 2. \\<And>l p l' it.\n       <\\<exists>\\<^sub>Al1.\n           \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it>\n       os_it_has_next it\n       <\\<lambda>r.\n           (\\<exists>\\<^sub>Al1.\n               \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it) *\n           \\<up> (r = (l' \\<noteq> []))>\n 3. \\<And>l p l' it.\n       \\<exists>\\<^sub>Al1.\n          \\<up> (l = l1 @ l') * lseg l1 p it *\n          os_list l' it \\<Longrightarrow>\\<^sub>A\n       os_list l p * true", "apply sep_auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p a aa list l1 n.\n       a \\<mapsto>\\<^sub>r Node aa n * lseg l1 p (Some a) *\n       os_list list n \\<Longrightarrow>\\<^sub>A\n       lseg (l1 @ [aa]) p n * os_list list n\n 2. \\<And>l p l' it.\n       <\\<exists>\\<^sub>Al1.\n           \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it>\n       os_it_has_next it\n       <\\<lambda>r.\n           (\\<exists>\\<^sub>Al1.\n               \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it) *\n           \\<up> (r = (l' \\<noteq> []))>\n 3. \\<And>l p l' it.\n       \\<exists>\\<^sub>Al1.\n          \\<up> (l = l1 @ l') * lseg l1 p it *\n          os_list l' it \\<Longrightarrow>\\<^sub>A\n       os_list l p * true", "apply (rule ent_frame_fwd[OF lseg_append])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>p a aa list l1 n.\n       a \\<mapsto>\\<^sub>r Node aa n * lseg l1 p (Some a) *\n       os_list list n \\<Longrightarrow>\\<^sub>A\n       lseg (?l88 p a aa list l1 n) (?p88 p a aa list l1 n)\n        (Some (?s88 p a aa list l1 n)) *\n       ?s88 p a aa list l1 n \\<mapsto>\\<^sub>r\n       Node (?x88 p a aa list l1 n) (?q88 p a aa list l1 n) *\n       ?F87 p a aa list l1 n\n 2. \\<And>p a aa list l1 n.\n       lseg (?l88 p a aa list l1 n @ [?x88 p a aa list l1 n])\n        (?p88 p a aa list l1 n) (?q88 p a aa list l1 n) *\n       ?F87 p a aa list l1 n \\<Longrightarrow>\\<^sub>A\n       lseg (l1 @ [aa]) p n * os_list list n\n 3. \\<And>l p l' it.\n       <\\<exists>\\<^sub>Al1.\n           \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it>\n       os_it_has_next it\n       <\\<lambda>r.\n           (\\<exists>\\<^sub>Al1.\n               \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it) *\n           \\<up> (r = (l' \\<noteq> []))>\n 4. \\<And>l p l' it.\n       \\<exists>\\<^sub>Al1.\n          \\<up> (l = l1 @ l') * lseg l1 p it *\n          os_list l' it \\<Longrightarrow>\\<^sub>A\n       os_list l p * true", "apply frame_inference"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p a aa list l1 n.\n       lseg (l1 @ [aa]) p n * os_list list n \\<Longrightarrow>\\<^sub>A\n       lseg (l1 @ [aa]) p n * os_list list n\n 2. \\<And>l p l' it.\n       <\\<exists>\\<^sub>Al1.\n           \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it>\n       os_it_has_next it\n       <\\<lambda>r.\n           (\\<exists>\\<^sub>Al1.\n               \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it) *\n           \\<up> (r = (l' \\<noteq> []))>\n 3. \\<And>l p l' it.\n       \\<exists>\\<^sub>Al1.\n          \\<up> (l = l1 @ l') * lseg l1 p it *\n          os_list l' it \\<Longrightarrow>\\<^sub>A\n       os_list l p * true", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l p l' it.\n       <\\<exists>\\<^sub>Al1.\n           \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it>\n       os_it_has_next it\n       <\\<lambda>r.\n           (\\<exists>\\<^sub>Al1.\n               \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it) *\n           \\<up> (r = (l' \\<noteq> []))>\n 2. \\<And>l p l' it.\n       \\<exists>\\<^sub>Al1.\n          \\<up> (l = l1 @ l') * lseg l1 p it *\n          os_list l' it \\<Longrightarrow>\\<^sub>A\n       os_list l p * true", "unfolding os_it_has_next_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l p l' it.\n       <\\<exists>\\<^sub>Al1.\n           \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it>\n       return (it \\<noteq> None)\n       <\\<lambda>r.\n           (\\<exists>\\<^sub>Al1.\n               \\<up> (l = l1 @ l') * lseg l1 p it * os_list l' it) *\n           \\<up> (r = (l' \\<noteq> []))>\n 2. \\<And>l p l' it.\n       \\<exists>\\<^sub>Al1.\n          \\<up> (l = l1 @ l') * lseg l1 p it *\n          os_list l' it \\<Longrightarrow>\\<^sub>A\n       os_list l p * true", "apply (sep_auto elim!: neq_NilE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l p l' it.\n       \\<exists>\\<^sub>Al1.\n          \\<up> (l = l1 @ l') * lseg l1 p it *\n          os_list l' it \\<Longrightarrow>\\<^sub>A\n       os_list l p * true", "apply solve_entails"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l p l' it l1.\n       l = l1 @ l' \\<Longrightarrow>\n       lseg l1 p it * os_list l' it \\<Longrightarrow>\\<^sub>A\n       os_list (l1 @ l') p * true", "apply (rule ent_frame_fwd[OF lseg_conc])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l p l' it l1.\n       l = l1 @ l' \\<Longrightarrow>\n       lseg l1 p it * os_list l' it \\<Longrightarrow>\\<^sub>A\n       lseg (?l1.147 l p l' it l1) (?p147 l p l' it l1)\n        (?q147 l p l' it l1) *\n       lseg (?l2.147 l p l' it l1) (?q147 l p l' it l1)\n        (?r147 l p l' it l1) *\n       ?F146 l p l' it l1\n 2. \\<And>l p l' it l1.\n       l = l1 @ l' \\<Longrightarrow>\n       lseg (?l1.147 l p l' it l1 @ ?l2.147 l p l' it l1)\n        (?p147 l p l' it l1) (?r147 l p l' it l1) *\n       ?F146 l p l' it l1 \\<Longrightarrow>\\<^sub>A\n       os_list (l1 @ l') p * true", "apply frame_inference"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l p l' it l1.\n       l = l1 @ l' \\<Longrightarrow>\n       os_list (l1 @ l') p * emp \\<Longrightarrow>\\<^sub>A\n       os_list (l1 @ l') p * true", "apply solve_entails"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation os: \n  imp_list_iterate os_list os_is_it os_it_init os_it_has_next os_it_next"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_iterate os_list os_is_it os_it_init os_it_has_next os_it_next", "by (rule os_iterate_impl)"], ["", "subsubsection \\<open>List-Sum\\<close>"], ["", "partial_function (heap) os_sum' :: \"int os_list_it \\<Rightarrow> int \\<Rightarrow> int Heap\" \n  where [code]:\n  \"os_sum' it s = do {\n    b \\<leftarrow> os_it_has_next it;\n    if b then do {\n      (x,it') \\<leftarrow> os_it_next it;\n      os_sum' it' (s+x)\n    } else return s\n  }\""], ["", "lemma os_sum'_rule[sep_heap_rules]: \n  \"<os_is_it l p l' it> \n    os_sum' it s \n  <\\<lambda>r. os_list l p * \\<up>(r = s + sum_list l')>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p l'\n      it> os_sum' it\n           s <\\<lambda>r. os_list l p * \\<up> (r = s + sum_list l')>\\<^sub>t", "proof (induct l' arbitrary: it s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>it s.\n       <os_is_it l p []\n         it> os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list [])>\\<^sub>t\n 2. \\<And>a l' it s.\n       (\\<And>it s.\n           <os_is_it l p l'\n             it> os_sum' it\n                  s <\\<lambda>r.\n                        os_list l p *\n                        \\<up>\n                         (r = s + sum_list l')>\\<^sub>t) \\<Longrightarrow>\n       <os_is_it l p (a # l')\n         it> os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list (a # l'))>\\<^sub>t", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>it s.\n       <os_is_it l p []\n         it> os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list [])>\\<^sub>t\n 2. \\<And>a l' it s.\n       (\\<And>it s.\n           <os_is_it l p l'\n             it> os_sum' it\n                  s <\\<lambda>r.\n                        os_list l p *\n                        \\<up>\n                         (r = s + sum_list l')>\\<^sub>t) \\<Longrightarrow>\n       <os_is_it l p (a # l')\n         it> os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list (a # l'))>\\<^sub>t", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p []\n      it> os_sum' it\n           s <\\<lambda>r. os_list l p * \\<up> (r = s + sum_list [])>\\<^sub>t", "apply (subst os_sum'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p []\n      it> os_it_has_next it \\<bind>\n          (\\<lambda>b.\n              if b\n              then os_it_next it \\<bind>\n                   (\\<lambda>(x, it'). os_sum' it' (s + x))\n              else return\n                    s) <\\<lambda>r.\n                           os_list l p *\n                           \\<up> (r = s + sum_list [])>\\<^sub>t", "apply (sep_auto intro: os.quit_iteration)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <os_is_it l p []\n    it> os_sum' it\n         s <\\<lambda>r. os_list l p * \\<up> (r = s + sum_list [])>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>a l' it s.\n       (\\<And>it s.\n           <os_is_it l p l'\n             it> os_sum' it\n                  s <\\<lambda>r.\n                        os_list l p *\n                        \\<up>\n                         (r = s + sum_list l')>\\<^sub>t) \\<Longrightarrow>\n       <os_is_it l p (a # l')\n         it> os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list (a # l'))>\\<^sub>t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l' it s.\n       (\\<And>it s.\n           <os_is_it l p l'\n             it> os_sum' it\n                  s <\\<lambda>r.\n                        os_list l p *\n                        \\<up>\n                         (r = s + sum_list l')>\\<^sub>t) \\<Longrightarrow>\n       <os_is_it l p (a # l')\n         it> os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list (a # l'))>\\<^sub>t", "case (Cons x l')"], ["proof (state)\nthis:\n  <os_is_it l p l'\n    ?it> os_sum' ?it\n          ?s <\\<lambda>r.\n                 os_list l p * \\<up> (r = ?s + sum_list l')>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>a l' it s.\n       (\\<And>it s.\n           <os_is_it l p l'\n             it> os_sum' it\n                  s <\\<lambda>r.\n                        os_list l p *\n                        \\<up>\n                         (r = s + sum_list l')>\\<^sub>t) \\<Longrightarrow>\n       <os_is_it l p (a # l')\n         it> os_sum' it\n              s <\\<lambda>r.\n                    os_list l p * \\<up> (r = s + sum_list (a # l'))>\\<^sub>t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p (x # l')\n      it> os_sum' it\n           s <\\<lambda>r.\n                 os_list l p * \\<up> (r = s + sum_list (x # l'))>\\<^sub>t", "apply (subst os_sum'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_is_it l p (x # l')\n      it> os_it_has_next it \\<bind>\n          (\\<lambda>b.\n              if b\n              then os_it_next it \\<bind>\n                   (\\<lambda>(x, it'). os_sum' it' (s + x))\n              else return\n                    s) <\\<lambda>r.\n                           os_list l p *\n                           \\<up> (r = s + sum_list (x # l'))>\\<^sub>t", "apply (sep_auto heap: Cons.hyps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <os_is_it l p (x # l')\n    it> os_sum' it\n         s <\\<lambda>r.\n               os_list l p * \\<up> (r = s + sum_list (x # l'))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"os_sum p \\<equiv> do { \n  it \\<leftarrow> os_it_init p;\n  os_sum' it 0}\""], ["", "lemma os_sum_rule[sep_heap_rules]: \n  \"<os_list l p> os_sum p <\\<lambda>r. os_list l p * \\<up>(r=sum_list l)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list l\n      p> os_sum p <\\<lambda>r. os_list l p * \\<up> (r = sum_list l)>\\<^sub>t", "unfolding os_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <os_list l\n      p> os_it_init p \\<bind>\n         (\\<lambda>it.\n             os_sum' it\n              0) <\\<lambda>r. os_list l p * \\<up> (r = sum_list l)>\\<^sub>t", "by sep_auto"], ["", "end"]]}