{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Examples/Hash_Map_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma hm_map_impl: \"imp_map is_hashmap\"", "lemma hm_empty_impl: \"imp_map_empty is_hashmap hm_new\"", "lemma hm_lookup_impl: \"imp_map_lookup is_hashmap hm_lookup\"", "lemma hm_update_impl: \"imp_map_update is_hashmap hm_update\"", "lemma hm_delete_impl: \"imp_map_delete is_hashmap hm_delete\"", "lemma hm_is_empty_impl: \"imp_map_is_empty is_hashmap hm_isEmpty\"", "lemma hm_size_impl: \"imp_map_size is_hashmap hm_size\"", "lemma hm_iterate_impl: \n  \"imp_map_iterate is_hashmap hm_is_it hm_it_init hm_it_has_next hm_it_next\""], "translations": [["", "lemma hm_map_impl: \"imp_map is_hashmap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map is_hashmap", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_hashmap", "apply (rule is_hashmap_prec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hm: imp_map is_hashmap"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map is_hashmap", "by (rule hm_map_impl)"], ["", "lemma hm_empty_impl: \"imp_map_empty is_hashmap hm_new\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_empty is_hashmap hm_new", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> hm_new <is_hashmap Map.empty>\\<^sub>t", "apply (sep_auto heap: hm_new_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hm: imp_map_empty is_hashmap hm_new"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_empty is_hashmap hm_new", "by (rule hm_empty_impl)"], ["", "lemma hm_lookup_impl: \"imp_map_lookup is_hashmap hm_lookup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_lookup is_hashmap hm_lookup", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m p k.\n       <is_hashmap m\n         p> hm_lookup k\n             p <\\<lambda>r. is_hashmap m p * \\<up> (r = m k)>\\<^sub>t", "apply (sep_auto heap: hm_lookup_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hm: imp_map_lookup is_hashmap hm_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_lookup is_hashmap hm_lookup", "by (rule hm_lookup_impl)"], ["", "lemma hm_update_impl: \"imp_map_update is_hashmap hm_update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_update is_hashmap hm_update", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m p k v.\n       <is_hashmap m\n         p> hm_update k v p <is_hashmap (m(k \\<mapsto> v))>\\<^sub>t", "apply (sep_auto heap: hm_update_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hm: imp_map_update is_hashmap hm_update"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_update is_hashmap hm_update", "by (rule hm_update_impl)"], ["", "lemma hm_delete_impl: \"imp_map_delete is_hashmap hm_delete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_delete is_hashmap hm_delete", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m p k.\n       <is_hashmap m p> hm_delete k p <is_hashmap (m |` (- {k}))>\\<^sub>t", "apply (sep_auto heap: hm_delete_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hm: imp_map_delete is_hashmap hm_delete"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_delete is_hashmap hm_delete", "by (rule hm_delete_impl)"], ["", "lemma hm_is_empty_impl: \"imp_map_is_empty is_hashmap hm_isEmpty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_is_empty is_hashmap hm_isEmpty", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m p.\n       <is_hashmap m\n         p> hm_isEmpty\n             p <\\<lambda>r.\n                   is_hashmap m p * \\<up> (r = (m = Map.empty))>\\<^sub>t", "apply (sep_auto heap: hm_isEmpty_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hm: imp_map_is_empty is_hashmap hm_isEmpty"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_is_empty is_hashmap hm_isEmpty", "by (rule hm_is_empty_impl)"], ["", "lemma hm_size_impl: \"imp_map_size is_hashmap hm_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_size is_hashmap hm_size", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m p.\n       <is_hashmap m\n         p> hm_size\n             p <\\<lambda>r.\n                   is_hashmap m p * \\<up> (r = card (dom m))>\\<^sub>t", "apply (sep_auto heap: hm_size_rule)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hm: imp_map_size is_hashmap hm_size"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_size is_hashmap hm_size", "by (rule hm_size_impl)"], ["", "lemma hm_iterate_impl: \n  \"imp_map_iterate is_hashmap hm_is_it hm_it_init hm_it_has_next hm_it_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_iterate is_hashmap hm_is_it hm_it_init hm_it_has_next hm_it_next", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s p. <is_hashmap s p> hm_it_init p <hm_is_it s p s>\\<^sub>t\n 2. \\<And>m' m p it.\n       m' \\<noteq> Map.empty \\<Longrightarrow>\n       <hm_is_it m p m' it> hm_it_next it\n       <\\<lambda>((k, v), it').\n           hm_is_it m p (m' |` (- {k})) it' * \\<up> (m' k = Some v)>\n 3. \\<And>m p m' it.\n       <hm_is_it m p m' it> hm_it_has_next it\n       <\\<lambda>r.\n           hm_is_it m p m' it * \\<up> (r = (m' \\<noteq> Map.empty))>\n 4. \\<And>m p m' it.\n       hm_is_it m p m' it \\<Longrightarrow>\\<^sub>A is_hashmap m p * true", "apply (rule hm_it_init_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m' m p it.\n       m' \\<noteq> Map.empty \\<Longrightarrow>\n       <hm_is_it m p m' it> hm_it_next it\n       <\\<lambda>((k, v), it').\n           hm_is_it m p (m' |` (- {k})) it' * \\<up> (m' k = Some v)>\n 2. \\<And>m p m' it.\n       <hm_is_it m p m' it> hm_it_has_next it\n       <\\<lambda>r.\n           hm_is_it m p m' it * \\<up> (r = (m' \\<noteq> Map.empty))>\n 3. \\<And>m p m' it.\n       hm_is_it m p m' it \\<Longrightarrow>\\<^sub>A is_hashmap m p * true", "apply (erule hm_it_next_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m p m' it.\n       <hm_is_it m p m' it> hm_it_has_next it\n       <\\<lambda>r.\n           hm_is_it m p m' it * \\<up> (r = (m' \\<noteq> Map.empty))>\n 2. \\<And>m p m' it.\n       hm_is_it m p m' it \\<Longrightarrow>\\<^sub>A is_hashmap m p * true", "apply (rule hm_it_has_next_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m p m' it.\n       hm_is_it m p m' it \\<Longrightarrow>\\<^sub>A is_hashmap m p * true", "apply (rule ent_frame_fwd[OF hm_it_finish])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m p m' it.\n       hm_is_it m p m' it \\<Longrightarrow>\\<^sub>A\n       hm_is_it (?m7 m p m' it) (?p7 m p m' it) (?m'7 m p m' it)\n        (?it7 m p m' it) *\n       ?F6 m p m' it\n 2. \\<And>m p m' it.\n       is_hashmap (?m7 m p m' it) (?p7 m p m' it) *\n       ?F6 m p m' it \\<Longrightarrow>\\<^sub>A\n       is_hashmap m p * true", "apply (frame_inference)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m p m' it.\n       is_hashmap m p * emp \\<Longrightarrow>\\<^sub>A is_hashmap m p * true", "apply solve_entails"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation hm: \n  imp_map_iterate is_hashmap hm_is_it hm_it_init hm_it_has_next hm_it_next"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_map_iterate is_hashmap hm_is_it hm_it_init hm_it_has_next hm_it_next", "by (rule hm_iterate_impl)"], ["", "(*\ndefinition \"hm_is_it'' m ht l' it \\<equiv> \n  \\<exists>\\<^sub>Al. hm_is_it' l ht l' it * \\<up>(map_of (concat l) = m)\"\n\nlemma hm_iterate'_impl: \n  \"imp_map_iterate' is_hashmap hm_is_it'' hm_it_init hm_it_has_next hm_it_next\"\n  apply unfold_locales\n  apply (rule hm_it_init_rule)\n  apply (erule hm_it_next_rule)\n  apply (rule hm_it_has_next_rule)\n  apply (rule ent_frame_fwd[OF hm_it_finish])\n  apply (frame_inference)\n  apply solve_entails\n  done\n\n*)"], ["", "export_code hm_new hm_lookup hm_update hm_delete hm_isEmpty hm_size \n  hm_it_init hm_it_has_next hm_it_next\n  checking SML_imp"], ["", "end"]]}