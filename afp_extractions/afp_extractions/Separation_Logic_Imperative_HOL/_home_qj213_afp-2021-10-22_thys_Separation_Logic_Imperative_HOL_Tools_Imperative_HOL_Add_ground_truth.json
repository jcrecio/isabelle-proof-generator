{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Tools/Imperative_HOL_Add.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma effect_ref[effect_elims]:\n  assumes \"effect (ref (x::('a::heap))) h h' r\"\n  obtains \"r = fst (Ref.alloc x h)\" and \"h' = snd (Ref.alloc x h)\"", "lemma lim_Ref_alloc[simp]: \"lim (snd (Ref.alloc x h)) = Suc (lim h)\"", "lemma lim_Array_alloc[simp]: \"lim (snd (Array.alloc x h)) = Suc (lim h)\"", "lemma lim_Array_set[simp]: \"lim (Array.set a xs h) = lim h\"", "lemma lim_Array_update[simp]: \"lim (Array.update a i x h) = lim h\"", "lemma addr_of_ref_alloc[simp]:\n  \"addr_of_ref (fst (Ref.alloc x h)) = lim h\"", "lemma addr_of_array_alloc[simp]:\n  \"addr_of_array (fst (Array.alloc x h)) = lim h\""], "translations": [["", "lemma effect_ref[effect_elims]:\n  assumes \"effect (ref (x::('a::heap))) h h' r\"\n  obtains \"r = fst (Ref.alloc x h)\" and \"h' = snd (Ref.alloc x h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>r = fst (Ref.alloc x h); h' = snd (Ref.alloc x h)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lbrakk>r = fst (Ref.alloc x h); h' = snd (Ref.alloc x h)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  effect (ref x) h h' r", "have \"execute (ref x) h = Some (r, h')\""], ["proof (prove)\nusing this:\n  effect (ref x) h h' r\n\ngoal (1 subgoal):\n 1. execute (ref x) h = Some (r, h')", "by (unfold effect_def)"], ["proof (state)\nthis:\n  execute (ref x) h = Some (r, h')\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>r = fst (Ref.alloc x h); h' = snd (Ref.alloc x h)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  execute (ref x) h = Some (r, h')", "have \"r = fst (Ref.alloc x h)\" \"h' = snd (Ref.alloc x h)\""], ["proof (prove)\nusing this:\n  execute (ref x) h = Some (r, h')\n\ngoal (1 subgoal):\n 1. r = fst (Ref.alloc x h) &&& h' = snd (Ref.alloc x h)", "by (auto simp add: execute_simps)"], ["proof (state)\nthis:\n  r = fst (Ref.alloc x h)\n  h' = snd (Ref.alloc x h)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>r = fst (Ref.alloc x h); h' = snd (Ref.alloc x h)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  r = fst (Ref.alloc x h)\n  h' = snd (Ref.alloc x h)", "show thesis"], ["proof (prove)\nusing this:\n  r = fst (Ref.alloc x h)\n  h' = snd (Ref.alloc x h)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Some lemmas about the evaluation of the limit for modifications on \n  a heap\\<close>"], ["", "lemma lim_Ref_alloc[simp]: \"lim (snd (Ref.alloc x h)) = Suc (lim h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lim (snd (Ref.alloc x h)) = Suc (lim h)", "unfolding Ref.alloc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lim (snd (let l = lim h; r = Ref l\n              in (r, Ref.set r x (h\\<lparr>lim := l + 1\\<rparr>)))) =\n    Suc (lim h)", "by (simp add: Let_def)"], ["", "lemma lim_Array_alloc[simp]: \"lim (snd (Array.alloc x h)) = Suc (lim h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lim (snd (Array.alloc x h)) = Suc (lim h)", "unfolding Array.alloc_def Array.set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lim (snd (let l = lim h; r = Array l\n              in Let (arrays_update\n                       (\\<lambda>h. h\n                           (TYPEREP('a) := (h TYPEREP('a))\n                              (addr_of_array r := map to_nat x)))\n                       (h\\<lparr>lim := l + 1\\<rparr>))\n                  (Pair r))) =\n    Suc (lim h)", "by (simp add: Let_def)"], ["", "lemma lim_Array_set[simp]: \"lim (Array.set a xs h) = lim h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lim (Array.set a xs h) = lim h", "unfolding Array.set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lim (arrays_update\n          (\\<lambda>h. h\n              (TYPEREP('a) := (h TYPEREP('a))\n                 (addr_of_array a := map to_nat xs)))\n          h) =\n    lim h", "by (simp add: Let_def)"], ["", "thm Array.update_def"], ["", "lemma lim_Array_update[simp]: \"lim (Array.update a i x h) = lim h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lim (Array.update a i x h) = lim h", "unfolding Array.update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lim (Array.set a ((Array.get h a)[i := x]) h) = lim h", "by (simp add: Let_def)"], ["", "text \\<open>Simplification rules for the addresses of new allocated arrays and\n  references\\<close>"], ["", "lemma addr_of_ref_alloc[simp]:\n  \"addr_of_ref (fst (Ref.alloc x h)) = lim h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_of_ref (fst (Ref.alloc x h)) = lim h", "unfolding Ref.alloc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_of_ref\n     (fst (let l = lim h; r = Ref l\n           in (r, Ref.set r x (h\\<lparr>lim := l + 1\\<rparr>)))) =\n    lim h", "by (simp add: Let_def)"], ["", "lemma addr_of_array_alloc[simp]:\n  \"addr_of_array (fst (Array.alloc x h)) = lim h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_of_array (fst (Array.alloc x h)) = lim h", "unfolding Array.alloc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. addr_of_array\n     (fst (let l = lim h; r = Array l\n           in Let (Array.set r x (h\\<lparr>lim := l + 1\\<rparr>))\n               (Pair r))) =\n    lim h", "by (simp add: Let_def)"], ["", "end"]]}