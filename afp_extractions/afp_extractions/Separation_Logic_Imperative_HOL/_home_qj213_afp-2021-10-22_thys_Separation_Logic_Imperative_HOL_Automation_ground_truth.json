{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Automation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemmas assn_aci =   \n  inf_aci[where 'a=assn] \n  sup_aci[where 'a=assn] \n  mult.left_ac[where 'a=assn]", "lemmas star_assoc = mult.assoc[where 'a=assn]", "lemmas assn_assoc = \n  mult.left_assoc inf_assoc[where 'a=assn] sup_assoc[where 'a=assn]", "lemma merge_true_star_ctx: \"true * (true * P) = true * P\"", "lemmas star_aci = \n  mult.assoc[where 'a=assn] mult.commute[where 'a=assn] mult.left_commute[where 'a=assn]\n  assn_one_left mult_1_right[where 'a=assn]\n  merge_true_star merge_true_star_ctx", "lemma ex_assn_move_out[simp]:\n  \"\\<And>Q R. (\\<exists>\\<^sub>Ax. Q x) * R = (\\<exists>\\<^sub>Ax. (Q x * R))\"\n  \"\\<And>Q R. R * (\\<exists>\\<^sub>Ax. Q x) = (\\<exists>\\<^sub>Ax. (R * Q x))\"\n\n  \"\\<And>P Q. (\\<exists>\\<^sub>Ax. Q x) \\<and>\\<^sub>A P = (\\<exists>\\<^sub>Ax. (Q x \\<and>\\<^sub>A P)) \"\n  \"\\<And>P Q. Q \\<and>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) = (\\<exists>\\<^sub>Ax. (Q \\<and>\\<^sub>A P x))\"\n\n  \"\\<And>P Q. (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P = (\\<exists>\\<^sub>Ax. (Q x \\<or>\\<^sub>A P))\"\n  \"\\<And>P Q. Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) = (\\<exists>\\<^sub>Ax. (Q \\<or>\\<^sub>A P x))\"", "lemma and_extract_pure_left_iff[simp]: \"\\<up>b \\<and>\\<^sub>A Q = (emp\\<and>\\<^sub>AQ)*\\<up>b\"", "lemma and_extract_pure_left_ctx_iff[simp]: \"P*\\<up>b \\<and>\\<^sub>A Q = (P\\<and>\\<^sub>AQ)*\\<up>b\"", "lemma and_extract_pure_right_iff[simp]: \"P \\<and>\\<^sub>A \\<up>b = (emp\\<and>\\<^sub>AP)*\\<up>b\"", "lemma and_extract_pure_right_ctx_iff[simp]: \"P \\<and>\\<^sub>A Q*\\<up>b = (P\\<and>\\<^sub>AQ)*\\<up>b\"", "lemmas and_extract_pure_iff = \n  and_extract_pure_left_iff and_extract_pure_left_ctx_iff\n  and_extract_pure_right_iff and_extract_pure_right_ctx_iff", "lemmas norm_assertion_simps =\n  (* Neutral elements *)\n  mult_1[where 'a=assn] mult_1_right[where 'a=assn]\n  inf_top_left[where 'a=assn] inf_top_right[where 'a=assn]\n  sup_bot_left[where 'a=assn] sup_bot_right[where 'a=assn]\n\n  (* Zero elements *)\n  star_false_left star_false_right\n  inf_bot_left[where 'a=assn] inf_bot_right[where 'a=assn]\n  sup_top_left[where 'a=assn] sup_top_right[where 'a=assn]\n\n  (* Associativity *)\n  mult.left_assoc[where 'a=assn]\n  inf_assoc[where 'a=assn]\n  sup_assoc[where 'a=assn]\n\n  (* Existential Quantifiers *)\n  ex_assn_move_out ex_assn_const\n\n  (* Extract pure assertions from conjunctions *)\n  and_extract_pure_iff\n\n  (* Merging *)\n  merge_pure_star merge_pure_and merge_pure_or\n  merge_true_star \n  inf_idem[where 'a=assn] sup_idem[where 'a=assn]\n\n  (* Duplicated References *)\n  sngr_same_false snga_same_false", "lemma not_same_noteqr[simp]: \"\\<not> a=!=a\"", "lemma not_same_noteqa[simp]: \"\\<not> a=!!=a\"", "lemma enorm_exI': (* Incomplete, as chosen x may depend on heap! *)\n  \"(\\<And>x. Z x \\<longrightarrow> (P \\<Longrightarrow>\\<^sub>A Q x)) \\<Longrightarrow> (\\<exists>x. Z x) \\<longrightarrow> (P \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Ax. Q x))\"", "lemmas ent_triv = ent_true ent_false", "lemma is_hoare_triple: \"<P> c <Q> \\<Longrightarrow> <P> c <Q>\"", "lemma is_entails: \"P\\<Longrightarrow>\\<^sub>AQ \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>AQ\"", "lemma SLN_left: \"SLN * P = P\"", "lemma SLN_right: \"P * SLN = P\"", "lemmas SLN_normalize = SLN_right mult.left_assoc[where 'a=assn]", "lemmas SLN_strip = SLN_right SLN_left mult.left_assoc[where 'a=assn]", "lemma FI_init: \n  assumes \"FI [] (SLN*P) (SLN*Q) SLN SLN F\"\n  shows \"FI_QUERY P Q F\"", "lemma FI_finalize:\n  assumes \"FI_RESULT m (p*up) (q*uq) f\"\n  shows \"FI m p q up uq f\"", "lemma fi_match_entails:\n  assumes \"fi_m_match m\"\n  shows \"fi_m_fst m \\<Longrightarrow>\\<^sub>A fi_m_snd m\"", "lemma FI_match:\n  assumes \"p \\<Longrightarrow>\\<^sub>A q\"\n  assumes \"FI ((p,q)#m) (ps*up) (qs*uq) SLN SLN f\"\n  shows \"FI m (ps*p) (qs*q) up uq f\"", "lemma FI_p_nomatch:\n  assumes \"FI m ps (qs*q) (p*up) uq f\"\n  shows \"FI m (ps*p) (qs*q) up uq f\"", "lemma FI_q_nomatch:\n  assumes \"FI m (SLN*up) qs SLN (q*uq) f\"\n  shows \"FI m SLN (qs*q) up uq f\"", "lemma frame_inference_init:\n  assumes \"FI_QUERY P Q F\"\n  shows \"P \\<Longrightarrow>\\<^sub>A Q * F\"", "lemma frame_inference_finalize:\n  shows \"FI_RESULT M F emp F\"", "lemma entails_solve_init:\n  \"FI_QUERY P Q true \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>A Q * true\"\n  \"FI_QUERY P Q emp \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>A Q\"", "lemma entails_solve_finalize:\n  \"FI_RESULT M P emp true\"\n  \"FI_RESULT M emp emp emp\"", "lemmas solve_ent_preprocess_simps = \n  ent_pure_post_iff ent_pure_post_iff_sng ent_pure_pre_iff ent_pure_pre_iff_sng", "lemmas normalize_rules = norm_pre_ex_rule norm_pre_pure_rule", "lemmas return_cons_rule = cons_pre_rule[OF _ return_wp_rule]", "lemma frame_rule_left:\n  \"<P> c <Q> \\<Longrightarrow> <R * P> c <\\<lambda>x. R * Q x>\"", "lemmas deconstruct_rules = \n  bind_rule if_rule false_rule return_sp_rule let_rule \n  case_prod_rule case_list_rule case_option_rule case_sum_rule", "lemmas heap_rules = \n  ref_rule\n  lookup_rule\n  update_rule\n  new_rule\n  make_rule\n  of_list_rule\n  length_rule\n  nth_rule\n  upd_rule\n  freeze_rule", "lemma fi_rule:\n  assumes CMD: \"<P> c <Q>\"\n  assumes FRAME: \"Ps \\<Longrightarrow>\\<^sub>A P * F\"\n  shows \"<Ps> c <\\<lambda>x. Q x * F>\"", "lemmas [sep_dflt_simps] = split", "lemmas [sep_eintros] = impI conjI exI", "lemma ent_frame_fwd:\n  assumes R: \"P \\<Longrightarrow>\\<^sub>A R\"\n  assumes F: \"Ps \\<Longrightarrow>\\<^sub>A P*F\"\n  assumes I: \"R*F \\<Longrightarrow>\\<^sub>A Q\"\n  shows \"Ps \\<Longrightarrow>\\<^sub>A Q\"", "lemma mod_frame_fwd:\n  assumes M: \"h\\<Turnstile>Ps\"\n  assumes R: \"P\\<Longrightarrow>\\<^sub>AR\"\n  assumes F: \"Ps \\<Longrightarrow>\\<^sub>A P*F\"\n  shows \"h\\<Turnstile>R*F\"", "lemma prec_frame:\n  assumes PREC: \"precise P\"\n  assumes M1: \"h\\<Turnstile>(R1 \\<and>\\<^sub>A R2)\"\n  assumes F1: \"R1 \\<Longrightarrow>\\<^sub>A P x p * F1\"\n  assumes F2: \"R2 \\<Longrightarrow>\\<^sub>A P y p * F2\"\n  shows \"x=y\"", "lemma prec_frame_expl:\n  assumes PREC: \"\\<forall>x y. (h\\<Turnstile>(P x * F1) \\<and>\\<^sub>A (P y * F2)) \\<longrightarrow> x=y\"\n  assumes M1: \"h\\<Turnstile>(R1 \\<and>\\<^sub>A R2)\"\n  assumes F1: \"R1 \\<Longrightarrow>\\<^sub>A P x * F1\"\n  assumes F2: \"R2 \\<Longrightarrow>\\<^sub>A P y * F2\"\n  shows \"x=y\"", "lemma prec_frame':\n  assumes PREC: \"(h\\<Turnstile>(P x * F1) \\<and>\\<^sub>A (P y * F2)) \\<longrightarrow> x=y\"\n  assumes M1: \"h\\<Turnstile>(R1 \\<and>\\<^sub>A R2)\"\n  assumes F1: \"R1 \\<Longrightarrow>\\<^sub>A P x * F1\"\n  assumes F2: \"R2 \\<Longrightarrow>\\<^sub>A P y * F2\"\n  shows \"x=y\"", "lemma ent_wand_frameI:\n  assumes \"(Q -* R) * F \\<Longrightarrow>\\<^sub>A S\"\n  assumes \"P \\<Longrightarrow>\\<^sub>A F * X\"\n  assumes \"Q*X \\<Longrightarrow>\\<^sub>A R\"\n  shows \"P \\<Longrightarrow>\\<^sub>A S\"", "lemma ent_true_drop: \n  \"P\\<Longrightarrow>\\<^sub>AQ*true \\<Longrightarrow> P*R\\<Longrightarrow>\\<^sub>AQ*true\"\n  \"P\\<Longrightarrow>\\<^sub>AQ \\<Longrightarrow> P\\<Longrightarrow>\\<^sub>AQ*true\"", "lemma fr_refl: \"A\\<Longrightarrow>\\<^sub>AB \\<Longrightarrow> A*C \\<Longrightarrow>\\<^sub>AB*C\"", "lemma fr_rot: \"(A*B \\<Longrightarrow>\\<^sub>A C) \\<Longrightarrow> (B*A \\<Longrightarrow>\\<^sub>A C)\"", "lemma fr_rot_rhs: \"(A \\<Longrightarrow>\\<^sub>A B*C) \\<Longrightarrow> (A \\<Longrightarrow>\\<^sub>A C*B)\"", "lemma ent_star_mono_true: \n  assumes \"A \\<Longrightarrow>\\<^sub>A A' * true\"\n  assumes \"B \\<Longrightarrow>\\<^sub>A B' * true\"\n  shows \"A*B*true \\<Longrightarrow>\\<^sub>A A'*B'*true\"", "lemma ent_refl_true: \"A \\<Longrightarrow>\\<^sub>A A * true\"", "lemma entt_fr_refl: \"F\\<Longrightarrow>\\<^sub>tF' \\<Longrightarrow> F*A \\<Longrightarrow>\\<^sub>t F'*A\"", "lemma entt_fr_drop: \"F\\<Longrightarrow>\\<^sub>tF' \\<Longrightarrow> F*A \\<Longrightarrow>\\<^sub>t F'\"", "lemma \"\\<And>x. A x * true * Q x \\<Longrightarrow>\\<^sub>A true * A x * Q x\"", "lemma \"A * (true * B) \\<Longrightarrow>\\<^sub>A true * A * B\"", "lemma \"h\\<Turnstile>true*P*true \\<longleftrightarrow> h\\<Turnstile>P*true\"", "lemma \"A * true * \\<up>(b \\<and> c) * true * B \\<Longrightarrow>\\<^sub>A \\<up>b * \\<up>c * true *A * B\"", "lemma \"\\<exists>y c. \\<exists>\\<^sub>Ax. P x * (R x * Q y) * \\<up> (b \\<and> c) \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Ax. \\<up>b * (P x * (R x * Q y) * \\<up>c))\"", "lemma \"A * B * (\\<up>c * B * C * D * \\<up>a * true * \\<up>d) * (\\<exists>\\<^sub>Ax. E x * F * \\<up>b) * true \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Ax. \\<up> (c \\<and> a \\<and> d \\<and> b) *\n          true * A * B * (true * B * C * D) * (E x * F))\"", "lemma \"<P> c <\\<lambda>r. Q r * true * \\<up>(b r) * true * \\<up>a> \n  \\<longleftrightarrow> <P> c <\\<lambda>r. Q r * true * \\<up>(b r \\<and> a)>\"", "lemma \"(h\\<Turnstile>((A*B*\\<up>b*true*\\<up>c*true) \\<and>\\<^sub>A (\\<up>(p=q)*P*Q)))\n  \\<longleftrightarrow> h \\<Turnstile> A * B * true \\<and>\\<^sub>A P * Q \\<and> b \\<and> c \\<and> p = q\"", "lemma assumes \"FI_RESULT [(B, B), (A, A)] C D F\" \n  shows \"FI_QUERY (A*B*C) (D*B*A) F\"", "lemma \n  assumes \"FI_RESULT [(B,B), (A,A)] C emp F\"\n  shows \"FI_QUERY (A*B*C) (B*A) F\"", "lemma \n  assumes \"FI_RESULT [(B, B), (A, A)] emp emp F\"\n  shows \"FI_QUERY (A*B) (B*A) F\"", "lemma \n  assumes \"FI_RESULT [(A, A)] emp emp F\"\n  shows \"FI_QUERY (A) (A) F\"", "lemma \n  assumes \"FI_RESULT [(A, A)] (B * C * D) emp F\"\n  shows \"FI_QUERY (B*C*D*A) (A) F\"", "lemma \"\\<lbrakk>A; B; C; b 17\\<rbrakk> \\<Longrightarrow> \n  Q 1 5 3 \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Ax y z. \\<exists>\\<^sub>Aa. Q x y z * \\<up>(b a) * \\<up>(y=5))\"", "lemma \"<P * x\\<mapsto>\\<^sub>a[1,2,3]> \n  do { v\\<leftarrow>Array.nth x 1; return v } \n  <\\<lambda>r. P * x\\<mapsto>\\<^sub>a[1,2,3] * \\<up>(r=2)>\""], "translations": [["", "lemmas assn_aci =   \n  inf_aci[where 'a=assn] \n  sup_aci[where 'a=assn] \n  mult.left_ac[where 'a=assn]"], ["", "lemmas star_assoc = mult.assoc[where 'a=assn]"], ["", "lemmas assn_assoc = \n  mult.left_assoc inf_assoc[where 'a=assn] sup_assoc[where 'a=assn]"], ["", "lemma merge_true_star_ctx: \"true * (true * P) = true * P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true * (true * P) = true * P", "by (simp add: mult.left_ac)"], ["", "lemmas star_aci = \n  mult.assoc[where 'a=assn] mult.commute[where 'a=assn] mult.left_commute[where 'a=assn]\n  assn_one_left mult_1_right[where 'a=assn]\n  merge_true_star merge_true_star_ctx"], ["", "text \\<open>Move existential quantifiers to the front of assertions\\<close>"], ["", "lemma ex_assn_move_out[simp]:\n  \"\\<And>Q R. (\\<exists>\\<^sub>Ax. Q x) * R = (\\<exists>\\<^sub>Ax. (Q x * R))\"\n  \"\\<And>Q R. R * (\\<exists>\\<^sub>Ax. Q x) = (\\<exists>\\<^sub>Ax. (R * Q x))\"\n\n  \"\\<And>P Q. (\\<exists>\\<^sub>Ax. Q x) \\<and>\\<^sub>A P = (\\<exists>\\<^sub>Ax. (Q x \\<and>\\<^sub>A P)) \"\n  \"\\<And>P Q. Q \\<and>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) = (\\<exists>\\<^sub>Ax. (Q \\<and>\\<^sub>A P x))\"\n\n  \"\\<And>P Q. (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P = (\\<exists>\\<^sub>Ax. (Q x \\<or>\\<^sub>A P))\"\n  \"\\<And>P Q. Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) = (\\<exists>\\<^sub>Ax. (Q \\<or>\\<^sub>A P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>Q R.\n         (\\<exists>\\<^sub>Ax. Q x) * R = (\\<exists>\\<^sub>Ax. Q x * R)) &&&\n     (\\<And>Q R.\n         R * (\\<exists>\\<^sub>Ax. Q x) = (\\<exists>\\<^sub>Ax. R * Q x)) &&&\n     (\\<And>P Q.\n         (\\<exists>\\<^sub>Ax. Q x) \\<and>\\<^sub>A P =\n         (\\<exists>\\<^sub>Ax. Q x \\<and>\\<^sub>A P))) &&&\n    (\\<And>P Q.\n        Q \\<and>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n        (\\<exists>\\<^sub>Ax. Q \\<and>\\<^sub>A P x)) &&&\n    (\\<And>P Q.\n        (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P =\n        (\\<exists>\\<^sub>Ax. Q x \\<or>\\<^sub>A P)) &&&\n    (\\<And>P Q.\n        Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n        (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x))", "apply -"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>Q R. (\\<exists>\\<^sub>Ax. Q x) * R = (\\<exists>\\<^sub>Ax. Q x * R)\n 2. \\<And>Q R. R * (\\<exists>\\<^sub>Ax. Q x) = (\\<exists>\\<^sub>Ax. R * Q x)\n 3. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<and>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<and>\\<^sub>A P)\n 4. \\<And>P Q.\n       Q \\<and>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<and>\\<^sub>A P x)\n 5. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<or>\\<^sub>A P)\n 6. \\<And>P Q.\n       Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x)", "apply (simp add: ex_distrib_star)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Q R. R * (\\<exists>\\<^sub>Ax. Q x) = (\\<exists>\\<^sub>Ax. R * Q x)\n 2. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<and>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<and>\\<^sub>A P)\n 3. \\<And>P Q.\n       Q \\<and>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<and>\\<^sub>A P x)\n 4. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<or>\\<^sub>A P)\n 5. \\<And>P Q.\n       Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x)", "apply (subst mult.commute)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Q R. (\\<exists>\\<^sub>Ax. Q x) * R = (\\<exists>\\<^sub>Ax. R * Q x)\n 2. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<and>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<and>\\<^sub>A P)\n 3. \\<And>P Q.\n       Q \\<and>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<and>\\<^sub>A P x)\n 4. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<or>\\<^sub>A P)\n 5. \\<And>P Q.\n       Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x)", "apply (subst (2) mult.commute)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Q R. (\\<exists>\\<^sub>Ax. Q x) * R = (\\<exists>\\<^sub>Ax. Q x * R)\n 2. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<and>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<and>\\<^sub>A P)\n 3. \\<And>P Q.\n       Q \\<and>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<and>\\<^sub>A P x)\n 4. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<or>\\<^sub>A P)\n 5. \\<And>P Q.\n       Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x)", "apply (simp add: ex_distrib_star)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<and>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<and>\\<^sub>A P)\n 2. \\<And>P Q.\n       Q \\<and>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<and>\\<^sub>A P x)\n 3. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<or>\\<^sub>A P)\n 4. \\<And>P Q.\n       Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x)", "apply (simp add: ex_distrib_and)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>P Q.\n       Q \\<and>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<and>\\<^sub>A P x)\n 2. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<or>\\<^sub>A P)\n 3. \\<And>P Q.\n       Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x)", "apply (subst inf_commute)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. P x) \\<and>\\<^sub>A Q =\n       (\\<exists>\\<^sub>Ax. Q \\<and>\\<^sub>A P x)\n 2. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<or>\\<^sub>A P)\n 3. \\<And>P Q.\n       Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x)", "apply (subst (2) inf_commute)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. P x) \\<and>\\<^sub>A Q =\n       (\\<exists>\\<^sub>Ax. P x \\<and>\\<^sub>A Q)\n 2. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<or>\\<^sub>A P)\n 3. \\<And>P Q.\n       Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x)", "apply (simp add: ex_distrib_and)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. Q x) \\<or>\\<^sub>A P =\n       (\\<exists>\\<^sub>Ax. Q x \\<or>\\<^sub>A P)\n 2. \\<And>P Q.\n       Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x)", "apply (simp add: ex_distrib_or)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       Q \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. P x) =\n       (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x)", "apply (subst sup_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. P x) \\<or>\\<^sub>A Q =\n       (\\<exists>\\<^sub>Ax. Q \\<or>\\<^sub>A P x)", "apply (subst (2) sup_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       (\\<exists>\\<^sub>Ax. P x) \\<or>\\<^sub>A Q =\n       (\\<exists>\\<^sub>Ax. P x \\<or>\\<^sub>A Q)", "apply (simp add: ex_distrib_or)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Extract pure assertions from and-clauses\\<close>"], ["", "lemma and_extract_pure_left_iff[simp]: \"\\<up>b \\<and>\\<^sub>A Q = (emp\\<and>\\<^sub>AQ)*\\<up>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> b \\<and>\\<^sub>A Q = (emp \\<and>\\<^sub>A Q) * \\<up> b", "by (cases b) auto"], ["", "lemma and_extract_pure_left_ctx_iff[simp]: \"P*\\<up>b \\<and>\\<^sub>A Q = (P\\<and>\\<^sub>AQ)*\\<up>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * \\<up> b \\<and>\\<^sub>A Q = (P \\<and>\\<^sub>A Q) * \\<up> b", "by (cases b) auto"], ["", "lemma and_extract_pure_right_iff[simp]: \"P \\<and>\\<^sub>A \\<up>b = (emp\\<and>\\<^sub>AP)*\\<up>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<and>\\<^sub>A \\<up> b = (emp \\<and>\\<^sub>A P) * \\<up> b", "by (cases b) (auto simp: assn_aci)"], ["", "lemma and_extract_pure_right_ctx_iff[simp]: \"P \\<and>\\<^sub>A Q*\\<up>b = (P\\<and>\\<^sub>AQ)*\\<up>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<and>\\<^sub>A Q * \\<up> b = (P \\<and>\\<^sub>A Q) * \\<up> b", "by (cases b) auto"], ["", "lemmas and_extract_pure_iff = \n  and_extract_pure_left_iff and_extract_pure_left_ctx_iff\n  and_extract_pure_right_iff and_extract_pure_right_ctx_iff"], ["", "lemmas norm_assertion_simps =\n  (* Neutral elements *)\n  mult_1[where 'a=assn] mult_1_right[where 'a=assn]\n  inf_top_left[where 'a=assn] inf_top_right[where 'a=assn]\n  sup_bot_left[where 'a=assn] sup_bot_right[where 'a=assn]\n\n  (* Zero elements *)\n  star_false_left star_false_right\n  inf_bot_left[where 'a=assn] inf_bot_right[where 'a=assn]\n  sup_top_left[where 'a=assn] sup_top_right[where 'a=assn]\n\n  (* Associativity *)\n  mult.left_assoc[where 'a=assn]\n  inf_assoc[where 'a=assn]\n  sup_assoc[where 'a=assn]\n\n  (* Existential Quantifiers *)\n  ex_assn_move_out ex_assn_const\n\n  (* Extract pure assertions from conjunctions *)\n  and_extract_pure_iff\n\n  (* Merging *)\n  merge_pure_star merge_pure_and merge_pure_or\n  merge_true_star \n  inf_idem[where 'a=assn] sup_idem[where 'a=assn]\n\n  (* Duplicated References *)\n  sngr_same_false snga_same_false"], ["", "subsubsection \\<open>Simplifier Setup Fine-Tuning\\<close>"], ["", "text \\<open>Imperative HOL likes to simplify pointer inequations to this strange\n  operator. We do some additional simplifier setup here\\<close>"], ["", "lemma not_same_noteqr[simp]: \"\\<not> a=!=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> a =!= a", "by (metis Ref.unequal)"], ["", "declare Ref.noteq_irrefl[dest!]"], ["", "lemma not_same_noteqa[simp]: \"\\<not> a=!!=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> a =!!= a", "by (metis Array.unequal)"], ["", "declare Array.noteq_irrefl[dest!]"], ["", "text \\<open>However, it is safest to disable this rewriting, as there is\n  a working standard simplifier setup for \\<open>(\\<noteq>)\\<close>\n\\<close>"], ["", "declare Ref.unequal[simp del]"], ["", "declare Array.unequal[simp del]"], ["", "subsection \\<open>Normalization of Entailments\\<close>"], ["", "text \\<open>Used by existential quantifier extraction tactic\\<close>"], ["", "lemma enorm_exI': (* Incomplete, as chosen x may depend on heap! *)\n  \"(\\<And>x. Z x \\<longrightarrow> (P \\<Longrightarrow>\\<^sub>A Q x)) \\<Longrightarrow> (\\<exists>x. Z x) \\<longrightarrow> (P \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Ax. Q x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        Z x \\<longrightarrow>\n        (P \\<Longrightarrow>\\<^sub>A Q x)) \\<Longrightarrow>\n    (\\<exists>x. Z x) \\<longrightarrow>\n    (P \\<Longrightarrow>\\<^sub>A \\<exists>\\<^sub>Ax. Q x)", "by (metis ent_ex_postI)"], ["", "text \\<open>Example of how to build an extraction lemma.\\<close>"], ["", "thm enorm_exI'[OF enorm_exI'[OF imp_refl]]"], ["", "lemmas ent_triv = ent_true ent_false"], ["", "text \\<open>Dummy rule to detect Hoare triple goal\\<close>"], ["", "lemma is_hoare_triple: \"<P> c <Q> \\<Longrightarrow> <P> c <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> c <Q> \\<Longrightarrow> <P> c <Q>", "."], ["", "text \\<open>Dummy rule to detect entailment goal\\<close>"], ["", "lemma is_entails: \"P\\<Longrightarrow>\\<^sub>AQ \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>AQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A Q \\<Longrightarrow>\n    P \\<Longrightarrow>\\<^sub>A Q", "."], ["", "subsection \\<open>Frame Matcher\\<close>"], ["", "text \\<open>Given star-lists P,Q and a frame F, this method tries to match \n  all elements of Q with corresponding elements of P. The result is a \n  partial match, that contains matching pairs and the unmatched content.\\<close>"], ["", "text \\<open>The frame-matcher internally uses syntactic lists separated by\n  star, and delimited by the special symbol \\<open>SLN\\<close>, which is defined\n  to be \\<open>emp\\<close>.\\<close>"], ["", "definition [simp]: \"SLN \\<equiv> emp\""], ["", "lemma SLN_left: \"SLN * P = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SLN * P = P", "by simp"], ["", "lemma SLN_right: \"P * SLN = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * SLN = P", "by simp"], ["", "lemmas SLN_normalize = SLN_right mult.left_assoc[where 'a=assn]"], ["", "lemmas SLN_strip = SLN_right SLN_left mult.left_assoc[where 'a=assn]"], ["", "text \\<open>A query to the frame matcher. Contains the assertions\n  P and Q that shall be matched, as well as a frame F, that is not \n  touched.\\<close>"], ["", "definition [simp]: \"FI_QUERY P Q F \\<equiv> P \\<Longrightarrow>\\<^sub>A Q*F\""], ["", "abbreviation \"fi_m_fst M \\<equiv> foldr (*) (map fst M) emp\""], ["", "abbreviation \"fi_m_snd M \\<equiv> foldr (*) (map snd M) emp\""], ["", "abbreviation \"fi_m_match M \\<equiv> (\\<forall>(p,q)\\<in>set M. p \\<Longrightarrow>\\<^sub>A q)\""], ["", "text \\<open>A result of the frame matcher. Contains a list of matching pairs,\n  as well as the unmatched parts of P and Q, and the frame F.\n\\<close>"], ["", "definition [simp]: \"FI_RESULT M UP UQ F \\<equiv> \n  fi_m_match M \\<longrightarrow> (fi_m_fst M * UP \\<Longrightarrow>\\<^sub>A fi_m_snd M * UQ * F)\""], ["", "text \\<open>Internal structure used by the frame matcher: \n  m contains the matched pairs; p,q the assertions that still needs to be \n  matched; up,uq the assertions that could not be matched; and f the frame.\n  p and q are SLN-delimited syntactic lists. \n\\<close>"], ["", "definition [simp]: \"FI m p q up uq f \\<equiv> \n  fi_m_match m \\<longrightarrow> (fi_m_fst m * p * up \\<Longrightarrow>\\<^sub>A fi_m_snd m * q * uq * f)\""], ["", "text \\<open>Initialize processing of query\\<close>"], ["", "lemma FI_init: \n  assumes \"FI [] (SLN*P) (SLN*Q) SLN SLN F\"\n  shows \"FI_QUERY P Q F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_QUERY P Q F", "using assms"], ["proof (prove)\nusing this:\n  FI [] (SLN * P) (SLN * Q) SLN SLN F\n\ngoal (1 subgoal):\n 1. FI_QUERY P Q F", "by simp"], ["", "text \\<open>Construct result from internal representation\\<close>"], ["", "lemma FI_finalize:\n  assumes \"FI_RESULT m (p*up) (q*uq) f\"\n  shows \"FI m p q up uq f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI m p q up uq f", "using assms"], ["proof (prove)\nusing this:\n  FI_RESULT m (p * up) (q * uq) f\n\ngoal (1 subgoal):\n 1. FI m p q up uq f", "by (simp add: assn_aci)"], ["", "text \\<open>Auxiliary lemma to show that all matching pairs together form\n  an entailment. This is required for most applications.\\<close>"], ["", "lemma fi_match_entails:\n  assumes \"fi_m_match m\"\n  shows \"fi_m_fst m \\<Longrightarrow>\\<^sub>A fi_m_snd m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fi_m_fst m \\<Longrightarrow>\\<^sub>A fi_m_snd m", "using assms"], ["proof (prove)\nusing this:\n  fi_m_match m\n\ngoal (1 subgoal):\n 1. fi_m_fst m \\<Longrightarrow>\\<^sub>A fi_m_snd m", "apply (induct m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fi_m_match [] \\<Longrightarrow>\n    fi_m_fst [] \\<Longrightarrow>\\<^sub>A fi_m_snd []\n 2. \\<And>a m.\n       \\<lbrakk>fi_m_match m \\<Longrightarrow>\n                fi_m_fst m \\<Longrightarrow>\\<^sub>A fi_m_snd m;\n        fi_m_match (a # m)\\<rbrakk>\n       \\<Longrightarrow> fi_m_fst (a # m) \\<Longrightarrow>\\<^sub>A\n                         fi_m_snd (a # m)", "apply (simp_all split: prod.split_asm add: ent_star_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Internally, the frame matcher tries to match the first assertion\n  of q with the first assertion of p. If no match is found, the first\n  assertion of p is discarded. If no match for any assertion in p can be\n  found, the first assertion of q is discarded.\\<close>"], ["", "text \\<open>Match\\<close>"], ["", "lemma FI_match:\n  assumes \"p \\<Longrightarrow>\\<^sub>A q\"\n  assumes \"FI ((p,q)#m) (ps*up) (qs*uq) SLN SLN f\"\n  shows \"FI m (ps*p) (qs*q) up uq f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI m (ps * p) (qs * q) up uq f", "using assms"], ["proof (prove)\nusing this:\n  p \\<Longrightarrow>\\<^sub>A q\n  FI ((p, q) # m) (ps * up) (qs * uq) SLN SLN f\n\ngoal (1 subgoal):\n 1. FI m (ps * p) (qs * q) up uq f", "unfolding FI_def"], ["proof (prove)\nusing this:\n  p \\<Longrightarrow>\\<^sub>A q\n  fi_m_match ((p, q) # m) \\<longrightarrow>\n  (fi_m_fst ((p, q) # m) * (ps * up) * SLN \\<Longrightarrow>\\<^sub>A\n   fi_m_snd ((p, q) # m) * (qs * uq) * SLN * f)\n\ngoal (1 subgoal):\n 1. fi_m_match m \\<longrightarrow>\n    (fi_m_fst m * (ps * p) * up \\<Longrightarrow>\\<^sub>A\n     fi_m_snd m * (qs * q) * uq * f)", "by (simp add: assn_aci)"], ["", "text \\<open>No match\\<close>"], ["", "lemma FI_p_nomatch:\n  assumes \"FI m ps (qs*q) (p*up) uq f\"\n  shows \"FI m (ps*p) (qs*q) up uq f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI m (ps * p) (qs * q) up uq f", "using assms"], ["proof (prove)\nusing this:\n  FI m ps (qs * q) (p * up) uq f\n\ngoal (1 subgoal):\n 1. FI m (ps * p) (qs * q) up uq f", "unfolding FI_def"], ["proof (prove)\nusing this:\n  fi_m_match m \\<longrightarrow>\n  (fi_m_fst m * ps * (p * up) \\<Longrightarrow>\\<^sub>A\n   fi_m_snd m * (qs * q) * uq * f)\n\ngoal (1 subgoal):\n 1. fi_m_match m \\<longrightarrow>\n    (fi_m_fst m * (ps * p) * up \\<Longrightarrow>\\<^sub>A\n     fi_m_snd m * (qs * q) * uq * f)", "by (simp add: assn_aci)"], ["", "text \\<open>Head of q could not be matched\\<close>"], ["", "lemma FI_q_nomatch:\n  assumes \"FI m (SLN*up) qs SLN (q*uq) f\"\n  shows \"FI m SLN (qs*q) up uq f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI m SLN (qs * q) up uq f", "using assms"], ["proof (prove)\nusing this:\n  FI m (SLN * up) qs SLN (q * uq) f\n\ngoal (1 subgoal):\n 1. FI m SLN (qs * q) up uq f", "unfolding FI_def"], ["proof (prove)\nusing this:\n  fi_m_match m \\<longrightarrow>\n  (fi_m_fst m * (SLN * up) * SLN \\<Longrightarrow>\\<^sub>A\n   fi_m_snd m * qs * (q * uq) * f)\n\ngoal (1 subgoal):\n 1. fi_m_match m \\<longrightarrow>\n    (fi_m_fst m * SLN * up \\<Longrightarrow>\\<^sub>A\n     fi_m_snd m * (qs * q) * uq * f)", "by (simp add: assn_aci)"], ["", "subsection \\<open>Frame Inference\\<close>"], ["", "lemma frame_inference_init:\n  assumes \"FI_QUERY P Q F\"\n  shows \"P \\<Longrightarrow>\\<^sub>A Q * F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A Q * F", "using assms"], ["proof (prove)\nusing this:\n  FI_QUERY P Q F\n\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A Q * F", "by simp"], ["", "lemma frame_inference_finalize:\n  shows \"FI_RESULT M F emp F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_RESULT M F emp F", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fi_m_match M \\<longrightarrow>\n    (fi_m_fst M * F \\<Longrightarrow>\\<^sub>A fi_m_snd M * F)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. fi_m_match M \\<Longrightarrow>\n    fi_m_fst M * F \\<Longrightarrow>\\<^sub>A fi_m_snd M * F", "apply (drule fi_match_entails)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fi_m_fst M \\<Longrightarrow>\\<^sub>A fi_m_snd M \\<Longrightarrow>\n    fi_m_fst M * F \\<Longrightarrow>\\<^sub>A fi_m_snd M * F", "apply (rule ent_star_mono[OF _ ent_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fi_m_fst M \\<Longrightarrow>\\<^sub>A fi_m_snd M \\<Longrightarrow>\n    fi_m_fst M \\<Longrightarrow>\\<^sub>A fi_m_snd M", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Entailment Solver\\<close>"], ["", "lemma entails_solve_init:\n  \"FI_QUERY P Q true \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>A Q * true\"\n  \"FI_QUERY P Q emp \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FI_QUERY P Q true \\<Longrightarrow>\n     P \\<Longrightarrow>\\<^sub>A Q * true) &&&\n    (FI_QUERY P Q emp \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>A Q)", "by (simp_all add: assn_aci)"], ["", "lemma entails_solve_finalize:\n  \"FI_RESULT M P emp true\"\n  \"FI_RESULT M emp emp emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_RESULT M P emp true &&& FI_RESULT M emp emp emp", "by (auto simp add: fi_match_entails intro: ent_star_mono)"], ["", "lemmas solve_ent_preprocess_simps = \n  ent_pure_post_iff ent_pure_post_iff_sng ent_pure_pre_iff ent_pure_pre_iff_sng"], ["", "subsection \\<open>Verification Condition Generator\\<close>"], ["", "lemmas normalize_rules = norm_pre_ex_rule norm_pre_pure_rule"], ["", "(* Originally we introduced backwards-reasoning here, via\n  cons_pre_rule[OF _ return_wp_rule] (old name: complete_return_cons). \n  This only works, if the postcondition is not schematic! However, for \n  forward reasoning, one usually assumes a schematic postcondition!\n  *)"], ["", "text \\<open>May be useful in simple, manual proofs, where the postcondition\n  is no schematic variable.\\<close>"], ["", "lemmas return_cons_rule = cons_pre_rule[OF _ return_wp_rule]"], ["", "text \\<open>Useful frame-rule variant for manual proof:\\<close>"], ["", "lemma frame_rule_left:\n  \"<P> c <Q> \\<Longrightarrow> <R * P> c <\\<lambda>x. R * Q x>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> c <Q> \\<Longrightarrow> <R * P> c <\\<lambda>x. R * Q x>", "using frame_rule"], ["proof (prove)\nusing this:\n  <?P> ?c <?Q> \\<Longrightarrow> <?P * ?R> ?c <\\<lambda>x. ?Q x * ?R>\n\ngoal (1 subgoal):\n 1. <P> c <Q> \\<Longrightarrow> <R * P> c <\\<lambda>x. R * Q x>", "by (simp add: assn_aci)"], ["", "lemmas deconstruct_rules = \n  bind_rule if_rule false_rule return_sp_rule let_rule \n  case_prod_rule case_list_rule case_option_rule case_sum_rule"], ["", "lemmas heap_rules = \n  ref_rule\n  lookup_rule\n  update_rule\n  new_rule\n  make_rule\n  of_list_rule\n  length_rule\n  nth_rule\n  upd_rule\n  freeze_rule"], ["", "lemma fi_rule:\n  assumes CMD: \"<P> c <Q>\"\n  assumes FRAME: \"Ps \\<Longrightarrow>\\<^sub>A P * F\"\n  shows \"<Ps> c <\\<lambda>x. Q x * F>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <Ps> c <\\<lambda>x. Q x * F>", "apply (rule cons_pre_rule[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. <?P'> c <\\<lambda>x. Q x * F>\n 2. Ps \\<Longrightarrow>\\<^sub>A ?P'", "apply (rule frame_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. <?P3> c <Q>\n 2. Ps \\<Longrightarrow>\\<^sub>A ?P3 * F", "apply (rule CMD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ps \\<Longrightarrow>\\<^sub>A P * F", "apply (rule FRAME)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>ML-setup\\<close>"], ["", "named_theorems sep_dflt_simps \"Seplogic: Default simplification rules for automated solvers\""], ["", "named_theorems sep_eintros \"Seplogic: Intro rules for entailment solver\""], ["", "named_theorems sep_heap_rules \"Seplogic: VCG heap rules\""], ["", "named_theorems sep_decon_rules \"Seplogic: VCG deconstruct rules\""], ["", "ML \\<open>\ninfix 1 THEN_IGNORE_NEWGOALS\n\nstructure Seplogic_Auto =\nstruct\n\n  (***********************************)\n  (*             Tools               *)\n  (***********************************)\n\n  (* Repeat tac on subgoal. Determinize each step. \n     Stop if tac fails or subgoal is solved. *)\n  fun REPEAT_DETERM' tac i st = let\n    val n = Thm.nprems_of st \n  in\n    REPEAT_DETERM (COND (has_fewer_prems n) no_tac (tac i)) st\n  end\n\n\n  (***********************************)\n  (*             Debugging           *)\n  (***********************************)\n  fun tr_term t = Pretty.string_of (Syntax.pretty_term @{context} t);\n\n\n  (***********************************)\n  (*        Custom Tacticals         *)\n  (***********************************)\n\n  (* Apply tac1, and then tac2 with an offset such that anything left \n     over by tac1 is skipped.\n\n     The typical usage of this tactic is, if a theorem is instantiated\n     with another theorem that produces additional goals that should \n     be ignored first. Here, it is used in the vcg to ensure that \n     frame inference is done before additional premises (that may \n     depend on the frame) are discharged.\n  *)\n  fun (tac1 THEN_IGNORE_NEWGOALS tac2) i st = let\n    val np = Thm.nprems_of st\n  in\n    (tac1 i THEN (fn st' => let val np' = Thm.nprems_of st' in\n      if np'<np then tac2 i st'\n      else tac2 (i+(np'-np)+1) st'\n    end)) st\n  end;\n\n\n  (***********************************)\n  (*     Assertion Normalization     *)\n  (***********************************)\n  (* Find two terms in a list whose key is equal *)\n  fun find_similar (key_of:term -> term) (ts:term list) = let\n    fun frec _ [] = NONE\n    | frec tab (t::ts) = let val k=key_of t in\n      if Termtab.defined tab k then\n        SOME (the (Termtab.lookup tab k),t)\n      else frec (Termtab.update (k,t) tab) ts\n    end\n  in\n    frec Termtab.empty ts\n  end;\n\n  (* Perform DFS over term with binary operator opN, threading through\n    a state. Atomic terms are transformed by tr. Supports omission of\n    terms from the result structure by transforming them to NONE. *)\n  fun dfs_opr opN (tr:'state -> term -> ('state*term option)) \n    d (t as ((op_t as Const (fN,_))$t1$t2)) =\n    if fN = opN then let\n        val (d1,t1') = dfs_opr opN tr d t1;\n        val (d2,t2') = dfs_opr opN tr d1 t2;\n      in\n        case (t1',t2') of\n          (NONE,NONE) => (d2,NONE)\n        | (SOME t1',NONE) => (d2,SOME t1')\n        | (NONE,SOME t2') => (d2,SOME t2')\n        | (SOME t1',SOME t2') => (d2,SOME (op_t$t1'$t2'))\n      end\n    else tr d t\n  | dfs_opr _ tr d t = tr d t;\n    \n  (* Replace single occurrence of (atomic) ot in t by nt. \n    Returns new term or NONE if nothing was removed. *)\n  fun dfs_replace_atomic opN ot nt t = let\n    fun tr d t = if not d andalso t=ot then (true,SOME nt) else (d,SOME t);\n    val (success,SOME t') = dfs_opr opN tr false t; \n  in\n    if success then SOME t' else NONE\n  end;\n\n  fun assn_simproc_fun ctxt credex = let\n    val ([redex],ctxt') = Variable.import_terms true [Thm.term_of credex] ctxt;\n    (*val _ = tracing (tr_term redex);*)\n    val export = singleton (Variable.export ctxt' ctxt)\n\n    fun mk_star t1 t2 = @{term \"(*)::assn \\<Rightarrow> _ \\<Rightarrow> _\"}$t2$t1;\n\n    fun mk_star' NONE NONE = NONE\n    | mk_star' (SOME t1) NONE  = SOME t1\n    | mk_star' NONE (SOME t2) = SOME t2\n    | mk_star' (SOME t1) (SOME t2) = SOME (mk_star t1 t2);\n\n    fun ptrs_key (_$k$_) = k;\n\n    fun remove_term pt t = case\n      dfs_replace_atomic @{const_name \"Groups.times_class.times\"} pt \n        @{term emp} t \n    of\n      SOME t' => t';  \n\n    fun normalize t = let\n\n      fun ep_tr (has_true,ps,ptrs) t = case t of \n        Const (@{const_name \"Assertions.pure_assn\"},_)$_ \n        => ((has_true,t::ps,ptrs),NONE)\n      | Const (@{const_name \"Assertions.sngr_assn\"},_)$_$_ \n        => ((has_true,ps,t::ptrs),SOME t)\n      | Const (@{const_name \"Assertions.snga_assn\"},_)$_$_\n        => ((has_true,ps,t::ptrs),SOME t)\n      | Const (@{const_name \"Orderings.top_class.top\"},_)\n        => ((true,ps,ptrs),NONE)\n      | (inf_op as Const (@{const_name \"Lattices.inf_class.inf\"},_))$t1$t2\n        => ((has_true,ps,ptrs),SOME (inf_op$normalize t1$normalize t2))\n      | _ => ((has_true,ps,ptrs),SOME t);\n\n      fun normalizer t = case dfs_opr @{const_name \"Groups.times_class.times\"}\n        ep_tr (false,[],[]) t \n      of \n        ((has_true,ps,ptrs),rt) => ((has_true,rev ps,ptrs),rt);\n\n      fun normalize_core t = let \n        val ((has_true,pures,ptrs),rt) = normalizer t;\n        val similar = find_similar ptrs_key ptrs;\n        val true_t = if has_true then SOME @{term \"Assertions.top_assn\"} \n          else NONE;\n        val pures' = case pures of \n            [] => NONE\n          | p::ps => SOME (fold mk_star ps p);\n      in\n        case similar of NONE => the (mk_star' pures' (mk_star' true_t rt))\n        | SOME (t1,t2) => let\n            val t_stripped = remove_term t1 (remove_term t2 t);\n          in mk_star t_stripped (mk_star t1 t2) end\n      end;\n\n      fun skip_ex ((exq as Const (@{const_name \"ex_assn\"},_))$(Abs (n,ty,t))) =\n        exq$Abs (n,ty,skip_ex t)\n      | skip_ex t = normalize_core t;\n\n      val (bs,t') = strip_abs t;\n      val ty = fastype_of1 (map #2 bs,t');\n    in\n      if ty = @{typ assn} then\n        Logic.rlist_abs (bs,skip_ex t')\n      else t\n    end;\n\n    (*val _ = tracing (tr_term redex);*)\n    val (f,terms) = strip_comb redex;\n    val nterms = map (fn t => let\n        (*val _ = tracing (tr_term t); *)\n        val t'=normalize t; \n        (*val _ = tracing (tr_term t');*)\n      in t' end) terms;\n    val new_form = list_comb (f,nterms);\n\n    val res_ss = (put_simpset HOL_basic_ss ctxt addsimps @{thms star_aci});\n    val result = Option.map (export o mk_meta_eq) (Arith_Data.prove_conv_nohyps\n      [simp_tac res_ss 1] ctxt' (redex,new_form)\n    );\n\n  in \n    result\n  end handle exc =>\n    if Exn.is_interrupt exc then Exn.reraise exc\n    else\n      (tracing (\"assn_simproc failed with exception\\n:\" ^ Runtime.exn_message exc);\n        NONE) (* Fail silently *);\n  \n  val assn_simproc =\n    Simplifier.make_simproc @{context} \"assn_simproc\"\n     {lhss =\n      [@{term \"h \\<Turnstile> P\"},\n       @{term \"P \\<Longrightarrow>\\<^sub>A Q\"},\n       @{term \"P \\<Longrightarrow>\\<^sub>t Q\"},\n       @{term \"Hoare_Triple.hoare_triple P c Q\"},\n       @{term \"(P::assn) = Q\"}],\n      proc = K assn_simproc_fun};\n\n\n\n  (***********************************)\n  (*     Default Simplifications     *)\n  (***********************************)\n\n  (* Default simplification. MUST contain assertion normalization!\n    Tactic must not fail! *)\n  fun dflt_tac ctxt = asm_full_simp_tac\n    (put_simpset HOL_ss ctxt\n      addsimprocs [assn_simproc] \n      addsimps @{thms norm_assertion_simps}\n      addsimps (Named_Theorems.get ctxt @{named_theorems sep_dflt_simps})\n      |> fold Splitter.del_split @{thms if_split}\n    );\n\n  (***********************************)\n  (*         Frame Matcher           *)\n  (***********************************)\n\n  (* Do frame matching\n    imp_solve_tac - tactic used to discharge first assumption of match-rule\n      cf. lemma FI_match.\n  *)\n  fun match_frame_tac imp_solve_tac ctxt = let\n    (* Normalize star-lists *)\n    val norm_tac = simp_tac (\n      put_simpset HOL_basic_ss ctxt addsimps @{thms SLN_normalize});\n\n    (* Strip star-lists *)\n    val strip_tac = \n      simp_tac (put_simpset HOL_basic_ss ctxt addsimps @{thms SLN_strip}) THEN'\n      simp_tac (put_simpset HOL_basic_ss ctxt addsimps @{thms SLN_def});\n\n    (* Do a match step *)\n    val match_tac = resolve_tac ctxt @{thms FI_match} (* Separate p,q*)\n      THEN' SOLVED' imp_solve_tac (* Solve implication *)\n      THEN' norm_tac;\n\n    (* Do a no-match step *)\n    val nomatch_tac = resolve_tac ctxt @{thms FI_p_nomatch} ORELSE' \n      (resolve_tac ctxt @{thms FI_q_nomatch} THEN' norm_tac);\n  in\n    resolve_tac ctxt @{thms FI_init} THEN' norm_tac \n    THEN' REPEAT_DETERM' (FIRST' [\n      CHANGED o dflt_tac ctxt,\n      (match_tac ORELSE' nomatch_tac)])\n    THEN' resolve_tac ctxt @{thms FI_finalize} THEN' strip_tac\n  end;\n\n\n  (***********************************)\n  (*         Frame Inference         *)\n  (***********************************)\n\n  fun frame_inference_tac ctxt =\n    resolve_tac ctxt @{thms frame_inference_init} \n    THEN' match_frame_tac (resolve_tac ctxt @{thms ent_refl}) ctxt\n    THEN' resolve_tac ctxt @{thms frame_inference_finalize};\n\n\n  (***********************************)\n  (*       Entailment Solver         *)\n  (***********************************)\n\n  (* Extract existential quantifiers from entailment goal *)\n  fun extract_ex_tac ctxt i st = let\n    fun count_ex (Const (@{const_name Assertions.entails},_)$_$c) = \n      count_ex c RS @{thm HOL.mp}\n    | count_ex (Const (@{const_name Assertions.ex_assn},_)$Abs (_,_,t))\n      = count_ex t RS @{thm enorm_exI'}\n    | count_ex _ = @{thm imp_refl};\n\n    val concl = Logic.concl_of_goal (Thm.prop_of st) i |> HOLogic.dest_Trueprop;\n    val thm = count_ex concl;\n  in\n    (TRY o REPEAT_ALL_NEW (match_tac ctxt @{thms ent_ex_preI}) THEN'\n     resolve_tac ctxt [thm]) i st\n  end;\n\n\n  (* Solve Entailment *)\n  fun solve_entails_tac ctxt = let\n    val preprocess_entails_tac = \n      dflt_tac ctxt \n      THEN' extract_ex_tac ctxt\n      THEN' simp_tac \n        (put_simpset HOL_ss ctxt addsimps @{thms solve_ent_preprocess_simps});\n\n    val match_entails_tac =\n      resolve_tac ctxt @{thms entails_solve_init} \n      THEN' match_frame_tac (resolve_tac ctxt @{thms ent_refl}) ctxt\n      THEN' resolve_tac ctxt @{thms entails_solve_finalize};\n  in\n    preprocess_entails_tac\n    THEN' (TRY o\n      REPEAT_ALL_NEW (match_tac ctxt (rev (Named_Theorems.get ctxt @{named_theorems sep_eintros}))))\n    THEN_ALL_NEW (dflt_tac ctxt THEN' \n      TRY o (match_tac ctxt @{thms ent_triv} \n        ORELSE' resolve_tac ctxt @{thms ent_refl}\n        ORELSE' match_entails_tac))\n  end;\n\n\n  (***********************************)\n  (* Verification Condition Generator*)\n  (***********************************)\n\n  fun heap_rule_tac ctxt h_thms = \n    resolve_tac ctxt h_thms ORELSE' (\n    resolve_tac ctxt @{thms fi_rule} THEN' (resolve_tac ctxt h_thms THEN_IGNORE_NEWGOALS\n    frame_inference_tac ctxt));\n\n  fun vcg_step_tac ctxt = let\n    val h_thms = rev (Named_Theorems.get ctxt @{named_theorems sep_heap_rules});\n    val d_thms = rev (Named_Theorems.get ctxt @{named_theorems sep_decon_rules});\n    val heap_rule_tac = heap_rule_tac ctxt h_thms\n\n    (* Apply consequence rule if postcondition is not a schematic var *)\n    fun app_post_cons_tac i st = \n      case Logic.concl_of_goal (Thm.prop_of st) i |> HOLogic.dest_Trueprop of\n        Const (@{const_name Hoare_Triple.hoare_triple},_)$_$_$qt =>\n          if is_Var (head_of qt) then no_tac st\n          else resolve_tac ctxt @{thms cons_post_rule} i st\n      | _ => no_tac st;\n\n  in\n    CSUBGOAL (snd #> (FIRST' [\n      CHANGED o dflt_tac ctxt,\n      REPEAT_ALL_NEW (resolve_tac ctxt @{thms normalize_rules}),\n      CHANGED o (FIRST' [resolve_tac ctxt d_thms, heap_rule_tac]\n        ORELSE' (app_post_cons_tac THEN' \n          FIRST' [resolve_tac ctxt d_thms, heap_rule_tac])) \n    ]))\n  end;\n\n  fun vcg_tac ctxt = REPEAT_DETERM' (vcg_step_tac ctxt)\n\n  (***********************************)\n  (*        Automatic Solver         *)\n  (***********************************)\n\n  fun sep_autosolve_tac do_pre do_post ctxt = let\n    val pre_tacs = [\n      CHANGED o clarsimp_tac ctxt,\n      CHANGED o REPEAT_ALL_NEW (match_tac ctxt @{thms ballI allI impI conjI})\n    ];\n    val main_tacs = [\n      match_tac ctxt @{thms is_hoare_triple} THEN' CHANGED o vcg_tac ctxt,\n      match_tac ctxt @{thms is_entails} THEN' CHANGED o solve_entails_tac ctxt\n    ];\n    val post_tacs = [SELECT_GOAL (auto_tac ctxt)];\n    val tacs = (if do_pre then pre_tacs else [])\n      @ main_tacs \n      @ (if do_post then post_tacs else []);\n  in\n    REPEAT_DETERM' (CHANGED o FIRST' tacs)\n  end;\n\n\n  (***********************************)\n  (*          Method Setup           *)\n  (***********************************)\n\n  val dflt_simps_modifiers = [\n    Args.$$$ \"dflt_simps\" -- Scan.option Args.add -- Args.colon \n      >> K (Method.modifier (Named_Theorems.add @{named_theorems sep_dflt_simps}) \\<^here>),\n    Args.$$$ \"dflt_simps\" -- Scan.option Args.del -- Args.colon \n      >> K (Method.modifier (Named_Theorems.del @{named_theorems sep_dflt_simps}) \\<^here>)\n  ];\n  val heap_modifiers = [\n    Args.$$$ \"heap\" -- Scan.option Args.add -- Args.colon \n      >> K (Method.modifier (Named_Theorems.add @{named_theorems sep_heap_rules}) \\<^here>),\n    Args.$$$ \"heap\" -- Scan.option Args.del -- Args.colon \n      >> K (Method.modifier (Named_Theorems.del @{named_theorems sep_heap_rules}) \\<^here>)\n  ];\n  val decon_modifiers = [\n    Args.$$$ \"decon\" -- Scan.option Args.add -- Args.colon \n      >> K (Method.modifier (Named_Theorems.add @{named_theorems sep_decon_rules}) \\<^here>),\n    Args.$$$ \"decon\" -- Scan.option Args.del -- Args.colon \n      >> K (Method.modifier (Named_Theorems.del @{named_theorems sep_decon_rules}) \\<^here>)\n  ];\n\n  val eintros_modifiers = [\n    Args.$$$ \"eintros\" -- Scan.option Args.add -- Args.colon \n      >> K (Method.modifier (Named_Theorems.add @{named_theorems sep_eintros}) \\<^here>),\n    Args.$$$ \"eintros\" -- Scan.option Args.del -- Args.colon \n      >> K (Method.modifier (Named_Theorems.del @{named_theorems sep_eintros}) \\<^here>)\n  ];\n\n\n  val solve_entails_modifiers = dflt_simps_modifiers @ eintros_modifiers;\n\n  val vcg_modifiers = \n    heap_modifiers @ decon_modifiers @ dflt_simps_modifiers;\n\n  val sep_auto_modifiers = \n    clasimp_modifiers @ vcg_modifiers @ eintros_modifiers;\n\nend;\n\\<close>"], ["", "simproc_setup assn_simproc \n  (\"h\\<Turnstile>P\" | \"P\\<Longrightarrow>\\<^sub>AQ\" | \"P\\<Longrightarrow>\\<^sub>tQ\" | \"<P> c <R>\" | \"(P::assn) = Q\") \n  = \\<open>K Seplogic_Auto.assn_simproc_fun\\<close>"], ["", "method_setup assn_simp =\\<open>Scan.succeed (fn ctxt => (SIMPLE_METHOD' (\n  CHANGED o Seplogic_Auto.dflt_tac ctxt\n)))\\<close> \"Seplogic: Simplification of assertions\""], ["", "method_setup frame_inference = \\<open>Scan.succeed (fn ctxt => (SIMPLE_METHOD' (\n  CHANGED o Seplogic_Auto.frame_inference_tac ctxt\n)))\\<close> \"Seplogic: Frame inference\""], ["", "method_setup solve_entails = \\<open>\n  Method.sections Seplogic_Auto.solve_entails_modifiers >>\n  (fn _ => fn ctxt => SIMPLE_METHOD' (\n  CHANGED o Seplogic_Auto.solve_entails_tac ctxt\n))\\<close> \"Seplogic: Entailment Solver\""], ["", "method_setup heap_rule = \\<open>\n  Attrib.thms >>\n  (fn thms => fn ctxt => SIMPLE_METHOD' ( \n    let\n      val thms = case thms of [] => rev (Named_Theorems.get ctxt @{named_theorems sep_heap_rules})\n        | _ => thms\n    in\n      CHANGED o Seplogic_Auto.heap_rule_tac ctxt thms\n    end\n))\\<close> \"Seplogic: Apply rule with frame inference\""], ["", "method_setup vcg = \\<open>\n  Scan.lift (Args.mode \"ss\") --\n  Method.sections Seplogic_Auto.vcg_modifiers >>\n  (fn (ss,_) => fn ctxt => SIMPLE_METHOD' (\n  CHANGED o (\n    if ss then Seplogic_Auto.vcg_step_tac ctxt \n    else Seplogic_Auto.vcg_tac ctxt\n  )\n))\\<close> \"Seplogic: Verification Condition Generator\""], ["", "method_setup sep_auto = \n  \\<open>Scan.lift (Args.mode \"nopre\" -- Args.mode \"nopost\" -- Args.mode \"plain\") \n      --| Method.sections Seplogic_Auto.sep_auto_modifiers >>\n  (fn ((nopre,nopost),plain) => fn ctxt => SIMPLE_METHOD' (\n    CHANGED o Seplogic_Auto.sep_autosolve_tac \n      ((not nopre) andalso (not plain)) \n      ((not nopost) andalso (not plain)) ctxt\n  ))\\<close> \"Seplogic: Automatic solver\""], ["", "lemmas [sep_dflt_simps] = split"], ["", "declare deconstruct_rules[sep_decon_rules]"], ["", "declare heap_rules[sep_heap_rules]"], ["", "lemmas [sep_eintros] = impI conjI exI"], ["", "subsection \\<open>Semi-Automatic Reasoning\\<close>"], ["", "text \\<open>In this section, we provide some lemmas for semi-automatic reasoning\\<close>"], ["", "text \\<open>Forward reasoning with frame. Use \\<open>frame_inference\\<close>-method \n  to discharge second assumption.\\<close>"], ["", "lemma ent_frame_fwd:\n  assumes R: \"P \\<Longrightarrow>\\<^sub>A R\"\n  assumes F: \"Ps \\<Longrightarrow>\\<^sub>A P*F\"\n  assumes I: \"R*F \\<Longrightarrow>\\<^sub>A Q\"\n  shows \"Ps \\<Longrightarrow>\\<^sub>A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ps \\<Longrightarrow>\\<^sub>A Q", "using assms"], ["proof (prove)\nusing this:\n  P \\<Longrightarrow>\\<^sub>A R\n  Ps \\<Longrightarrow>\\<^sub>A P * F\n  R * F \\<Longrightarrow>\\<^sub>A Q\n\ngoal (1 subgoal):\n 1. Ps \\<Longrightarrow>\\<^sub>A Q", "by (metis ent_refl ent_star_mono ent_trans)"], ["", "lemma mod_frame_fwd:\n  assumes M: \"h\\<Turnstile>Ps\"\n  assumes R: \"P\\<Longrightarrow>\\<^sub>AR\"\n  assumes F: \"Ps \\<Longrightarrow>\\<^sub>A P*F\"\n  shows \"h\\<Turnstile>R*F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> R * F", "using assms"], ["proof (prove)\nusing this:\n  h \\<Turnstile> Ps\n  P \\<Longrightarrow>\\<^sub>A R\n  Ps \\<Longrightarrow>\\<^sub>A P * F\n\ngoal (1 subgoal):\n 1. h \\<Turnstile> R * F", "by (metis ent_star_mono entails_def)"], ["", "text \\<open>Apply precision rule with frame inference.\\<close>"], ["", "lemma prec_frame:\n  assumes PREC: \"precise P\"\n  assumes M1: \"h\\<Turnstile>(R1 \\<and>\\<^sub>A R2)\"\n  assumes F1: \"R1 \\<Longrightarrow>\\<^sub>A P x p * F1\"\n  assumes F2: \"R2 \\<Longrightarrow>\\<^sub>A P y p * F2\"\n  shows \"x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using preciseD[OF PREC] M1 F1 F2"], ["proof (prove)\nusing this:\n  ?h \\<Turnstile>\n  P ?a ?p * ?F \\<and>\\<^sub>A P ?a' ?p * ?F' \\<Longrightarrow>\n  ?a = ?a'\n  h \\<Turnstile> R1 \\<and>\\<^sub>A R2\n  R1 \\<Longrightarrow>\\<^sub>A P x p * F1\n  R2 \\<Longrightarrow>\\<^sub>A P y p * F2\n\ngoal (1 subgoal):\n 1. x = y", "by (metis entailsD mod_and_dist)"], ["", "lemma prec_frame_expl:\n  assumes PREC: \"\\<forall>x y. (h\\<Turnstile>(P x * F1) \\<and>\\<^sub>A (P y * F2)) \\<longrightarrow> x=y\"\n  assumes M1: \"h\\<Turnstile>(R1 \\<and>\\<^sub>A R2)\"\n  assumes F1: \"R1 \\<Longrightarrow>\\<^sub>A P x * F1\"\n  assumes F2: \"R2 \\<Longrightarrow>\\<^sub>A P y * F2\"\n  shows \"x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     h \\<Turnstile> P x * F1 \\<and>\\<^sub>A P y * F2 \\<longrightarrow> x = y\n  h \\<Turnstile> R1 \\<and>\\<^sub>A R2\n  R1 \\<Longrightarrow>\\<^sub>A P x * F1\n  R2 \\<Longrightarrow>\\<^sub>A P y * F2\n\ngoal (1 subgoal):\n 1. x = y", "by (metis entailsD mod_and_dist)"], ["", "text \\<open>Variant that is useful within induction proofs, where induction\n  goes over \\<open>x\\<close> or \\<open>y\\<close>\\<close>"], ["", "lemma prec_frame':\n  assumes PREC: \"(h\\<Turnstile>(P x * F1) \\<and>\\<^sub>A (P y * F2)) \\<longrightarrow> x=y\"\n  assumes M1: \"h\\<Turnstile>(R1 \\<and>\\<^sub>A R2)\"\n  assumes F1: \"R1 \\<Longrightarrow>\\<^sub>A P x * F1\"\n  assumes F2: \"R2 \\<Longrightarrow>\\<^sub>A P y * F2\"\n  shows \"x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using assms"], ["proof (prove)\nusing this:\n  h \\<Turnstile> P x * F1 \\<and>\\<^sub>A P y * F2 \\<longrightarrow> x = y\n  h \\<Turnstile> R1 \\<and>\\<^sub>A R2\n  R1 \\<Longrightarrow>\\<^sub>A P x * F1\n  R2 \\<Longrightarrow>\\<^sub>A P y * F2\n\ngoal (1 subgoal):\n 1. x = y", "by (metis entailsD mod_and_dist)"], ["", "lemma ent_wand_frameI:\n  assumes \"(Q -* R) * F \\<Longrightarrow>\\<^sub>A S\"\n  assumes \"P \\<Longrightarrow>\\<^sub>A F * X\"\n  assumes \"Q*X \\<Longrightarrow>\\<^sub>A R\"\n  shows \"P \\<Longrightarrow>\\<^sub>A S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A S", "using assms"], ["proof (prove)\nusing this:\n  (Q -* R) * F \\<Longrightarrow>\\<^sub>A S\n  P \\<Longrightarrow>\\<^sub>A F * X\n  Q * X \\<Longrightarrow>\\<^sub>A R\n\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A S", "by (metis ent_frame_fwd ent_wandI mult.commute)"], ["", "subsubsection \\<open>Manual Frame Inference\\<close>"], ["", "lemma ent_true_drop: \n  \"P\\<Longrightarrow>\\<^sub>AQ*true \\<Longrightarrow> P*R\\<Longrightarrow>\\<^sub>AQ*true\"\n  \"P\\<Longrightarrow>\\<^sub>AQ \\<Longrightarrow> P\\<Longrightarrow>\\<^sub>AQ*true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow>\\<^sub>A Q * true \\<Longrightarrow>\n     P * R \\<Longrightarrow>\\<^sub>A Q * true) &&&\n    (P \\<Longrightarrow>\\<^sub>A Q \\<Longrightarrow>\n     P \\<Longrightarrow>\\<^sub>A Q * true)", "apply (metis assn_times_comm ent_star_mono ent_true merge_true_star_ctx)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A Q \\<Longrightarrow>\n    P \\<Longrightarrow>\\<^sub>A Q * true", "apply (metis assn_one_left ent_star_mono ent_true star_aci(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fr_refl: \"A\\<Longrightarrow>\\<^sub>AB \\<Longrightarrow> A*C \\<Longrightarrow>\\<^sub>AB*C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A B \\<Longrightarrow>\n    A * C \\<Longrightarrow>\\<^sub>A B * C", "by (blast intro: ent_star_mono ent_refl)"], ["", "lemma fr_rot: \"(A*B \\<Longrightarrow>\\<^sub>A C) \\<Longrightarrow> (B*A \\<Longrightarrow>\\<^sub>A C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B \\<Longrightarrow>\\<^sub>A C \\<Longrightarrow>\n    B * A \\<Longrightarrow>\\<^sub>A C", "by (simp add: assn_aci)"], ["", "lemma fr_rot_rhs: \"(A \\<Longrightarrow>\\<^sub>A B*C) \\<Longrightarrow> (A \\<Longrightarrow>\\<^sub>A C*B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A B * C \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>A C * B", "by (simp add: assn_aci)"], ["", "lemma ent_star_mono_true: \n  assumes \"A \\<Longrightarrow>\\<^sub>A A' * true\"\n  assumes \"B \\<Longrightarrow>\\<^sub>A B' * true\"\n  shows \"A*B*true \\<Longrightarrow>\\<^sub>A A'*B'*true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B * true \\<Longrightarrow>\\<^sub>A A' * B' * true", "using ent_star_mono[OF assms]"], ["proof (prove)\nusing this:\n  A * B \\<Longrightarrow>\\<^sub>A A' * true * (B' * true)\n\ngoal (1 subgoal):\n 1. A * B * true \\<Longrightarrow>\\<^sub>A A' * B' * true", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B \\<Longrightarrow>\\<^sub>A A' * B' * true \\<Longrightarrow>\n    A * B * true \\<Longrightarrow>\\<^sub>A A' * B' * true", "using ent_true_drop(1)"], ["proof (prove)\nusing this:\n  ?P \\<Longrightarrow>\\<^sub>A ?Q * true \\<Longrightarrow>\n  ?P * ?R \\<Longrightarrow>\\<^sub>A ?Q * true\n\ngoal (1 subgoal):\n 1. A * B \\<Longrightarrow>\\<^sub>A A' * B' * true \\<Longrightarrow>\n    A * B * true \\<Longrightarrow>\\<^sub>A A' * B' * true", "by blast"], ["", "lemma ent_refl_true: \"A \\<Longrightarrow>\\<^sub>A A * true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A A * true", "by (simp add: ent_true_drop(2))"], ["", "lemma entt_fr_refl: \"F\\<Longrightarrow>\\<^sub>tF' \\<Longrightarrow> F*A \\<Longrightarrow>\\<^sub>t F'*A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow>\n    F * A \\<Longrightarrow>\\<^sub>t F' * A", "by (rule entt_star_mono) auto"], ["", "lemma entt_fr_drop: \"F\\<Longrightarrow>\\<^sub>tF' \\<Longrightarrow> F*A \\<Longrightarrow>\\<^sub>t F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow>\n    F * A \\<Longrightarrow>\\<^sub>t F'", "using ent_true_drop(1) enttD enttI"], ["proof (prove)\nusing this:\n  ?P \\<Longrightarrow>\\<^sub>A ?Q * true \\<Longrightarrow>\n  ?P * ?R \\<Longrightarrow>\\<^sub>A ?Q * true\n  ?A \\<Longrightarrow>\\<^sub>t ?B \\<Longrightarrow>\n  ?A \\<Longrightarrow>\\<^sub>A ?B * true\n  ?A \\<Longrightarrow>\\<^sub>A ?B * true \\<Longrightarrow>\n  ?A \\<Longrightarrow>\\<^sub>t ?B\n\ngoal (1 subgoal):\n 1. F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow>\n    F * A \\<Longrightarrow>\\<^sub>t F'", "by blast"], ["", "method_setup fr_rot = \\<open>\n  let\n    fun rot_tac ctxt = \n      resolve_tac ctxt @{thms fr_rot} THEN'\n      simp_tac (put_simpset HOL_basic_ss ctxt \n        addsimps @{thms star_assoc[symmetric]})\n\n  in\n    Scan.lift Parse.nat >> \n      (fn n => fn ctxt => SIMPLE_METHOD' (\n        fn i => REPEAT_DETERM_N n (rot_tac ctxt i)))\n\n  end\n\\<close>"], ["", "method_setup fr_rot_rhs = \\<open>\n  let\n    fun rot_tac ctxt = \n      resolve_tac ctxt @{thms fr_rot_rhs} THEN'\n      simp_tac (put_simpset HOL_basic_ss ctxt \n        addsimps @{thms star_assoc[symmetric]})\n\n  in\n    Scan.lift Parse.nat >> \n      (fn n => fn ctxt => SIMPLE_METHOD' (\n        fn i => REPEAT_DETERM_N n (rot_tac ctxt i)))\n\n  end\n\\<close>"], ["", "(*<*)"], ["", "subsection \\<open>Test Cases\\<close>"], ["", "lemma \"\\<And>x. A x * true * Q x \\<Longrightarrow>\\<^sub>A true * A x * Q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. A x * true * Q x \\<Longrightarrow>\\<^sub>A true * A x * Q x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"A * (true * B) \\<Longrightarrow>\\<^sub>A true * A * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * (true * B) \\<Longrightarrow>\\<^sub>A true * A * B", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"h\\<Turnstile>true*P*true \\<longleftrightarrow> h\\<Turnstile>P*true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> true * P * true) = (h \\<Turnstile> P * true)", "by simp"], ["", "lemma \"A * true * \\<up>(b \\<and> c) * true * B \\<Longrightarrow>\\<^sub>A \\<up>b * \\<up>c * true *A * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * true * \\<up> (b \\<and> c) * true * B \\<Longrightarrow>\\<^sub>A\n    \\<up> b * \\<up> c * true * A * B", "by simp"], ["", "lemma \"\\<exists>y c. \\<exists>\\<^sub>Ax. P x * (R x * Q y) * \\<up> (b \\<and> c) \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Ax. \\<up>b * (P x * (R x * Q y) * \\<up>c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y c.\n       \\<exists>\\<^sub>Ax.\n          P x * (R x * Q y) * \\<up> (b \\<and> c) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ax. \\<up> b * (P x * (R x * Q y) * \\<up> c)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"A * B * (\\<up>c * B * C * D * \\<up>a * true * \\<up>d) * (\\<exists>\\<^sub>Ax. E x * F * \\<up>b) * true \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Ax. \\<up> (c \\<and> a \\<and> d \\<and> b) *\n          true * A * B * (true * B * C * D) * (E x * F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B * (\\<up> c * B * C * D * \\<up> a * true * \\<up> d) *\n    (\\<exists>\\<^sub>Ax. E x * F * \\<up> b) *\n    true \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Ax.\n       \\<up> (c \\<and> a \\<and> d \\<and> b) * true * A * B *\n       (true * B * C * D) *\n       (E x * F)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"<P> c <\\<lambda>r. Q r * true * \\<up>(b r) * true * \\<up>a> \n  \\<longleftrightarrow> <P> c <\\<lambda>r. Q r * true * \\<up>(b r \\<and> a)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. Q r * true * \\<up> (b r) * true * \\<up> a> = <P> c\n    <\\<lambda>r. Q r * true * \\<up> (b r \\<and> a)>", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"(h\\<Turnstile>((A*B*\\<up>b*true*\\<up>c*true) \\<and>\\<^sub>A (\\<up>(p=q)*P*Q)))\n  \\<longleftrightarrow> h \\<Turnstile> A * B * true \\<and>\\<^sub>A P * Q \\<and> b \\<and> c \\<and> p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile>\n     A * B * \\<up> b * true * \\<up> c * true \\<and>\\<^sub>A\n     \\<up> (p = q) * P * Q) =\n    (h \\<Turnstile> A * B * true \\<and>\\<^sub>A P * Q \\<and>\n     b \\<and> c \\<and> p = q)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assumes \"FI_RESULT [(B, B), (A, A)] C D F\" \n  shows \"FI_QUERY (A*B*C) (D*B*A) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_QUERY (A * B * C) (D * B * A) F", "apply (tactic \\<open>Seplogic_Auto.match_frame_tac \n    (resolve_tac @{context} @{thms ent_refl}) @{context} 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_RESULT [(B, B), (A, A)] C D F", "by (rule assms)"], ["", "lemma \n  assumes \"FI_RESULT [(B,B), (A,A)] C emp F\"\n  shows \"FI_QUERY (A*B*C) (B*A) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_QUERY (A * B * C) (B * A) F", "apply (tactic \\<open>Seplogic_Auto.match_frame_tac \n    (resolve_tac @{context} @{thms ent_refl}) @{context} 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_RESULT [(B, B), (A, A)] C emp F", "by (rule assms)"], ["", "lemma \n  assumes \"FI_RESULT [(B, B), (A, A)] emp emp F\"\n  shows \"FI_QUERY (A*B) (B*A) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_QUERY (A * B) (B * A) F", "apply (tactic \\<open>Seplogic_Auto.match_frame_tac \n    (resolve_tac @{context} @{thms ent_refl}) @{context} 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_RESULT [(B, B), (A, A)] emp emp F", "by (rule assms)"], ["", "lemma \n  assumes \"FI_RESULT [(A, A)] emp emp F\"\n  shows \"FI_QUERY (A) (A) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_QUERY A A F", "apply (tactic \\<open>Seplogic_Auto.match_frame_tac \n    (resolve_tac @{context} @{thms ent_refl}) @{context} 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_RESULT [(A, A)] emp emp F", "by (rule assms)"], ["", "lemma \n  assumes \"FI_RESULT [(A, A)] (B * C * D) emp F\"\n  shows \"FI_QUERY (B*C*D*A) (A) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_QUERY (B * C * D * A) A F", "apply (tactic \\<open>Seplogic_Auto.match_frame_tac \n    (resolve_tac @{context} @{thms ent_refl}) @{context} 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FI_RESULT [(A, A)] (B * C * D) emp F", "by (rule assms)"], ["", "schematic_goal \n  \"P1 * P2 * P3 * P4 \\<Longrightarrow>\\<^sub>A P3 * ?R1\"\n  \"P1 * (P2 * (P3 * P4)) \\<Longrightarrow>\\<^sub>A P1 * ?R2\"\n  \"P4 * (P2 * (P1 * P3)) \\<Longrightarrow>\\<^sub>A P1 * ?R2'\"\n  \"P1 * P2 * P3 * P4 \\<Longrightarrow>\\<^sub>A P4 * ?R3\"\n  \"P1 * P2 \\<Longrightarrow>\\<^sub>A P1 * ?R4\"\n  \"P1 * P2 \\<Longrightarrow>\\<^sub>A P2 * ?R5\"\n  \"P1 \\<Longrightarrow>\\<^sub>A P1 * ?R6\"\n  \"P1 * P2 \\<Longrightarrow>\\<^sub>A emp * ?R7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P1 * P2 * P3 * P4 \\<Longrightarrow>\\<^sub>A P3 * ?R1 &&&\n      P1 * (P2 * (P3 * P4)) \\<Longrightarrow>\\<^sub>A P1 * ?R2) &&&\n     P4 * (P2 * (P1 * P3)) \\<Longrightarrow>\\<^sub>A P1 * ?R2' &&&\n     P1 * P2 * P3 * P4 \\<Longrightarrow>\\<^sub>A P4 * ?R3) &&&\n    (P1 * P2 \\<Longrightarrow>\\<^sub>A P1 * ?R4 &&&\n     P1 * P2 \\<Longrightarrow>\\<^sub>A P2 * ?R5) &&&\n    P1 \\<Longrightarrow>\\<^sub>A P1 * ?R6 &&&\n    P1 * P2 \\<Longrightarrow>\\<^sub>A emp * ?R7", "by frame_inference+"], ["", "lemma \"\\<lbrakk>A; B; C; b 17\\<rbrakk> \\<Longrightarrow> \n  Q 1 5 3 \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Ax y z. \\<exists>\\<^sub>Aa. Q x y z * \\<up>(b a) * \\<up>(y=5))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A; B; C; b (17::'a)\\<rbrakk>\n    \\<Longrightarrow> Q (1::'b) (5::'c) (3::'d) \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Ax y z a.\n                         Q x y z * \\<up> (b a) * \\<up> (y = (5::'c))", "by solve_entails"], ["", "thm nth_rule"], ["", "lemma \"<P * x\\<mapsto>\\<^sub>a[1,2,3]> \n  do { v\\<leftarrow>Array.nth x 1; return v } \n  <\\<lambda>r. P * x\\<mapsto>\\<^sub>a[1,2,3] * \\<up>(r=2)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P * x \\<mapsto>\\<^sub>a [1::'a, 2::'a, 3::'a]>\n    Array.nth x 1 \\<bind> return\n    <\\<lambda>r.\n        P * x \\<mapsto>\\<^sub>a [1::'a, 2::'a, 3::'a] * \\<up> (r = (2::'a))>", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection \\<open>Quick Overview of Proof Methods\\<close>"], ["", "text_raw \\<open>\\label{sec:auto:overview}\\<close>"], ["", "text \\<open>\n  In this section, we give a quick overview of the available proof methods \n  and options. The most versatile proof method that we provide is\n  \\<open>sep_auto\\<close>. It tries to solve the first subgoal, invoking appropriate\n  proof methods as required. If it cannot solve the subgoal completely, it\n  stops at the intermediate state that it could not handle any more. \n\n  \\<open>sep_auto\\<close> can be configured by \n  section-arguments for the simplifier, the classical reasoner, and all\n  section-arguments for the verification condition generator and \n  entailment solver. Moreover, it takes an optional mode argument (mode), where\n  valid modes are:\n  \\begin{description}\n    \\item[(nopre)] No preprocessing of goal. The preprocessor tries to clarify\n      and simplify the goal before the main method is invoked.\n    \\item[(nopost)] No postprocessing of goal. The postprocessor tries to \n      solve or simplify goals left over by verification condition generation or\n      entailment solving.\n    \\item[(plain)] Neither pre- nor postprocessing. Just applies vcg and \n      entailment solver.  \n  \\end{description}\n\n  \\paragraph{Entailment Solver.} The entailment solver processes goals of the\n  form \\<open>P \\<Longrightarrow>\\<^sub>A Q\\<close>. It is invoked by the method \\<open>solve_entails\\<close>.\n  It first tries to pull out pure parts of\n  \\<open>P\\<close> and \\<open>Q\\<close>. This may introduce quantifiers, conjunction,\n  and implication into the goal, that are eliminated by resolving with rules\n  declared as \\<open>sep_eintros\\<close> (method argument: eintros[add/del]:).\n  Moreover, it simplifies with rules declared as \\<open>sep_dflt_simps\\<close> \n  (section argument: \\<open>dflt_simps[add/del]:\\<close>).\n\n  Now, \\<open>P\\<close> and \\<open>Q\\<close> should have the form \\<open>X\\<^sub>1*\\<dots>*X\\<^sub>n\\<close>.\n  Then, the frame-matcher is used to match all items of \\<open>P\\<close> with items\n  of \\<open>Q\\<close>, and thus solve the implication. Matching is currently done \n  syntactically, but can instantiate schematic variables.\n\n  Note that, by default, existential introduction is declared as \n  \\<open>sep_eintros\\<close>-rule. This introduces schematic variables, that can\n  later be matched against. However, in some cases, the matching may instantiate\n  the schematic variables in an undesired way. In this case, the argument \n  \\<open>eintros del: exI\\<close> should be passed to the entailment solver, and\n  the existential quantifier should be instantiated manually.\n\n  \\paragraph{Frame Inference}\n  The method \\<open>frame_inference\\<close> tries to solve a goal of the \n  form \\<open>P\\<Longrightarrow>Q*?F\\<close>, by matching \\<open>Q\\<close> against the parts of \n  \\<open>P\\<close>, and instantiating \\<open>?F\\<close> accordingly. \n  Matching is done syntactically, possibly \n  instantiating schematic variables. \\<open>P\\<close> and \\<open>Q\\<close> should be \n  assertions separated by \\<open>*\\<close>. Note that frame inference does no \n  simplification or other kinds of normalization.\n\n  The method \\<open>heap_rule\\<close> applies the specified heap rules, using\n  frame inference if necessary. If no rules are specified, the default \n  heap rules are used.\n\n  \\paragraph{Verification Condition Generator}\n  The verification condition generator processes goals of the form \n  \\<open><P>c<Q>\\<close>. It is invoked by the method \\<open>vcg\\<close>.\n  First, it tries to pull out pure parts and simplifies with\n  the default simplification rules. Then, it tries to resolve the goal with\n  deconstruct rules (attribute: \\<open>sep_decon_rules\\<close>, \n  section argument: \\<open>decon[add/del]:\\<close>), and if this does not succeed, \n  it tries\n  to resolve the goal with heap rules (attribute: \\<open>sep_heap_rules\\<close>, \n  section argument: \\<open>heap[add/del]:\\<close>), using the frame rule and \n  frame inference.\n  If resolving is not possible, it also tries to apply the consequence rule to\n  make the postcondition a schematic variable.\n\\<close>"], ["", "(*<*)"], ["", "subsection \\<open>Hiding of internal stuff\\<close>"], ["", "hide_const (open) FI SLN"], ["", "(*>*)"], ["", "end"]]}