{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Assertions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma in_range_empty[simp, intro!]: \"in_range (h,{})\"", "lemma in_range_dist_union[simp]: \n  \"in_range (h,as \\<union> as') \\<longleftrightarrow> in_range (h,as) \\<and> in_range (h,as')\"", "lemma in_range_subset: \n  \"\\<lbrakk>as \\<subseteq> as'; in_range (h,as')\\<rbrakk> \\<Longrightarrow> in_range (h,as)\"", "lemma relH_in_rangeI:\n  assumes \"relH as h h'\"\n  shows \"in_range (h,as)\" and \"in_range (h',as)\"", "lemma relH_refl: \"in_range (h,as) \\<Longrightarrow> relH as h h\"", "lemma relH_sym: \"relH as h h' \\<Longrightarrow> relH as h' h\"", "lemma relH_trans[trans]: \"\\<lbrakk>relH as h1 h2; relH as h2 h3\\<rbrakk> \\<Longrightarrow> relH as h1 h3\"", "lemma relH_dist_union[simp]: \n  \"relH (as\\<union>as') h h' \\<longleftrightarrow> relH as h h' \\<and> relH as' h h'\"", "lemma relH_subset:\n  assumes \"relH bs h h'\"\n  assumes \"as \\<subseteq> bs\"\n  shows \"relH as h h'\"", "lemma relH_ref:\n  assumes \"relH as h h'\"\n  assumes \"addr_of_ref r \\<in> as\"\n  shows \"Ref.get h r = Ref.get h' r\"", "lemma relH_array:\n  assumes \"relH as h h'\"\n  assumes \"addr_of_array r \\<in> as\"\n  shows \"Array.get h r = Array.get h' r\"", "lemma relH_set_ref: \"\\<lbrakk> addr_of_ref r \\<notin> as; in_range (h,as)\\<rbrakk> \n  \\<Longrightarrow> relH as h (Ref.set r x h)\"", "lemma relH_set_array: \"\\<lbrakk>addr_of_array r \\<notin> as; in_range (h,as)\\<rbrakk> \n  \\<Longrightarrow> relH as h (Array.set r x h)\"", "lemma properI[intro?]: \n  assumes \"\\<And>as h. P (h,as) \\<Longrightarrow> in_range (h,as)\"\n  assumes \"\\<And>as h h'. \n    \\<lbrakk>P (h,as); relH as h h'; in_range (h',as)\\<rbrakk> \\<Longrightarrow> P (h',as)\"\n  shows \"proper P\"", "lemma properD1:\n  assumes \"proper P\"\n  assumes \"P (h,as)\"\n  shows \"in_range (h,as)\"", "lemma properD2:\n  assumes \"proper P\"\n  assumes \"P (h,as)\"\n  assumes \"relH as h h'\"\n  assumes \"in_range (h',as)\"\n  shows \"P (h',as)\"", "lemmas properD = properD1 properD2", "lemma proper_iff:\n  assumes \"proper P\"\n  assumes \"relH as h h'\"\n  assumes \"in_range (h',as)\"\n  shows \"P (h,as) \\<longleftrightarrow> P (h',as)\"", "lemmas [simp] = Rep_assn_inverse Rep_assn_inject", "lemmas [simp, intro!] = Rep_assn[unfolded mem_Collect_eq]", "lemma Abs_assn_eqI[intro?]: \n  \"(\\<And>h. P h = Rep_assn Pr h) \\<Longrightarrow> Abs_assn P = Pr\"\n  \"(\\<And>h. P h = Rep_assn Pr h) \\<Longrightarrow> Pr = Abs_assn P\"", "lemma models_in_range: \"h\\<Turnstile>P \\<Longrightarrow> in_range h\"", "lemma mod_h_bot_indep: \"(h,{})\\<Turnstile>P \\<longleftrightarrow> (h',{})\\<Turnstile>P\"", "lemma mod_h_bot_normalize[simp]: \n  \"syntax_fo_nomatch undefined h \\<Longrightarrow> (h,{})\\<Turnstile>P \\<longleftrightarrow> h\\<^sub>\\<bottom> \\<Turnstile> P\"", "lemma mod_relH: \"relH as h h' \\<Longrightarrow> (h,as)\\<Turnstile>P \\<longleftrightarrow> (h',as)\\<Turnstile>P\"", "lemma one_assn_proper[intro!,simp]: \"proper one_assn_raw\"", "lemma times_assn_proper[intro!,simp]: \n    \"proper P \\<Longrightarrow> proper Q \\<Longrightarrow> proper (times_assn_raw P Q)\"", "lemma mod_star_conv: \"h\\<Turnstile>A*B \n  \\<longleftrightarrow> (\\<exists>hr as1 as2. h=(hr,as1\\<union>as2) \\<and> as1\\<inter>as2={} \\<and> (hr,as1)\\<Turnstile>A \\<and> (hr,as2)\\<Turnstile>B)\"", "lemma mod_starD: \"h\\<Turnstile>A*B \\<Longrightarrow> \\<exists>h1 h2. h1\\<Turnstile>A \\<and> h2\\<Turnstile>B\"", "lemma star_assnI:\n  assumes \"(h,as)\\<Turnstile>P\" and \"(h,as')\\<Turnstile>Q\" and \"as\\<inter>as'={}\"\n  shows \"(h,as\\<union>as')\\<Turnstile>P*Q\"", "lemma assn_one_left: \"1*P = (P::assn)\"", "lemma assn_times_comm: \"P*Q = Q*(P::assn)\"", "lemma assn_times_assoc: \"(P*Q)*R = P*(Q*(R::assn))\"", "lemma wand_proper[simp, intro!]: \"proper (wand_raw P Q)\"", "lemma wand_assnI: \n  assumes \"in_range (h,as)\"\n  assumes \"\\<And>h' as'. \\<lbrakk>\n    as \\<inter> as' = {}; \n    relH as h h'; \n    in_range (h',as); \n    (h',as')\\<Turnstile>Q \n  \\<rbrakk> \\<Longrightarrow> (h',as\\<union>as') \\<Turnstile> R\"\n  shows \"(h,as) \\<Turnstile> Q -* R\"", "lemma bool_assn_proper[simp, intro!]:\n    \"proper in_range\"\n    \"proper (\\<lambda>_. False)\"\n    \"proper P \\<Longrightarrow> proper Q \\<Longrightarrow> proper (\\<lambda>h. P h \\<or> Q h)\"\n    \"proper P \\<Longrightarrow> proper Q \\<Longrightarrow> proper (\\<lambda>h. P h \\<and> Q h)\"\n    \"proper P \\<Longrightarrow> proper (\\<lambda>h. in_range h \\<and> \\<not>P h)\"", "lemma star_false_left[simp]: \"false * P = false\"", "lemma star_false_right[simp]: \"P * false = false\"", "lemmas star_false = star_false_left star_false_right", "lemma assn_basic_inequalities[simp, intro!]:\n  \"true \\<noteq> emp\" \"emp \\<noteq> true\"\n  \"false \\<noteq> emp\" \"emp \\<noteq> false\"\n  \"true \\<noteq> false\" \"false \\<noteq> true\"", "lemma ex_assn_proper[simp, intro!]: \n  \"(\\<And>x. proper (P x)) \\<Longrightarrow> proper (\\<lambda>h. \\<exists>x. P x h)\"", "lemma ex_assn_const[simp]: \"(\\<exists>\\<^sub>Ax. c) = c\"", "lemma ex_one_point_gen: \n  \"\\<lbrakk>\\<And>h x. h\\<Turnstile>P x \\<Longrightarrow> x=v\\<rbrakk> \\<Longrightarrow> (\\<exists>\\<^sub>Ax. P x) = (P v)\"", "lemma ex_distrib_star: \"(\\<exists>\\<^sub>Ax. P x * Q) = (\\<exists>\\<^sub>Ax. P x) * Q\"", "lemma ex_distrib_and: \"(\\<exists>\\<^sub>Ax. P x \\<and>\\<^sub>A Q) = (\\<exists>\\<^sub>Ax. P x) \\<and>\\<^sub>A Q\"", "lemma ex_distrib_or: \"(\\<exists>\\<^sub>Ax. P x \\<or>\\<^sub>A Q) = (\\<exists>\\<^sub>Ax. P x) \\<or>\\<^sub>A Q\"", "lemma ex_join_or: \"(\\<exists>\\<^sub>Ax. P x \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. Q x)) = (\\<exists>\\<^sub>Ax. P x \\<or>\\<^sub>A Q x)\"", "lemma pure_assn_proper[simp, intro!]: \"proper (pure_assn_raw b)\"", "lemma pure_true[simp]: \"\\<up>True = emp\"", "lemma pure_false[simp]: \"\\<up>False = false\"", "lemma pure_assn_eq_false_iff[simp]: \"\\<up>P = false \\<longleftrightarrow> \\<not>P\"", "lemma pure_assn_eq_emp_iff[simp]: \"\\<up>P = emp \\<longleftrightarrow> P\"", "lemma merge_pure_star[simp]: \n  \"\\<up>a * \\<up>b = \\<up>(a\\<and>b)\"", "lemma merge_true_star[simp]: \"true*true = true\"", "lemma merge_pure_and[simp]:\n  \"\\<up>a \\<and>\\<^sub>A \\<up>b = \\<up>(a\\<and>b)\"", "lemma merge_pure_or[simp]:\n  \"\\<up>a \\<or>\\<^sub>A \\<up>b = \\<up>(a\\<or>b)\"", "lemma pure_assn_eq_conv[simp]: \"\\<up>P = \\<up>Q \\<longleftrightarrow> P=Q\"", "lemma is_pure_assnE: assumes \"is_pure_assn a\" obtains P where \"a=\\<up>P\"", "lemma is_pure_assn_pure[simp, intro!]: \"is_pure_assn (\\<up>P)\"", "lemma is_pure_assn_basic_simps[simp]:\n  \"is_pure_assn false\"\n  \"is_pure_assn emp\"", "lemma is_pure_assn_starI[simp,intro!]: \n  \"\\<lbrakk>is_pure_assn a; is_pure_assn b\\<rbrakk> \\<Longrightarrow> is_pure_assn (a*b)\"", "lemma sngr_assn_proper[simp, intro!]: \"proper (sngr_assn_raw r x)\"", "lemma snga_assn_proper[simp, intro!]: \"proper (snga_assn_raw r x)\"", "lemma sngr_same_false[simp]: \n  \"p \\<mapsto>\\<^sub>r x * p \\<mapsto>\\<^sub>r y = false\"", "lemma snga_same_false[simp]: \n  \"p \\<mapsto>\\<^sub>a x * p \\<mapsto>\\<^sub>a y = false\"", "lemma mod_true[simp]: \"h\\<Turnstile>true \\<longleftrightarrow> in_range h\"", "lemma mod_false[simp]: \"\\<not> h\\<Turnstile>false\"", "lemma mod_emp: \"h\\<Turnstile>emp \\<longleftrightarrow> snd h = {}\"", "lemma mod_emp_simp[simp]: \"(h,{})\\<Turnstile>emp\"", "lemma mod_pure[simp]: \"h\\<Turnstile>\\<up>b \\<longleftrightarrow> snd h = {} \\<and> b\"", "lemma mod_ex_dist[simp]: \"h\\<Turnstile>(\\<exists>\\<^sub>Ax. P x) \\<longleftrightarrow> (\\<exists>x. h\\<Turnstile>P x)\"", "lemma mod_exI: \"\\<exists>x. h\\<Turnstile>P x \\<Longrightarrow> h\\<Turnstile>(\\<exists>\\<^sub>Ax. P x)\"", "lemma mod_exE: assumes \"h\\<Turnstile>(\\<exists>\\<^sub>Ax. P x)\" obtains x where \"h\\<Turnstile>P x\"", "lemma mod_and_dist: \"h\\<Turnstile>P\\<and>\\<^sub>AQ \\<longleftrightarrow> h\\<Turnstile>P \\<and> h\\<Turnstile>Q\"", "lemma mod_or_dist[simp]: \"h\\<Turnstile>P\\<or>\\<^sub>AQ \\<longleftrightarrow> h\\<Turnstile>P \\<or> h\\<Turnstile>Q\"", "lemma mod_not_dist[simp]: \"h\\<Turnstile>(\\<not>\\<^sub>AP) \\<longleftrightarrow> in_range h \\<and> \\<not> h\\<Turnstile>P\"", "lemma mod_pure_star_dist[simp]: \"h\\<Turnstile>P*\\<up>b \\<longleftrightarrow> h\\<Turnstile>P \\<and> b\"", "lemmas mod_dist = mod_pure mod_pure_star_dist mod_ex_dist mod_and_dist\n  mod_or_dist mod_not_dist", "lemma mod_star_trueI: \"h\\<Turnstile>P \\<Longrightarrow> h\\<Turnstile>P*true\"", "lemma mod_star_trueE': assumes \"h\\<Turnstile>P*true\" obtains h' where \n  \"fst h' = fst h\" and \"snd h' \\<subseteq> snd h\" and \"h'\\<Turnstile>P\"", "lemma mod_star_trueE: assumes \"h\\<Turnstile>P*true\" obtains h' where \"h'\\<Turnstile>P\"", "lemma mod_h_bot_iff[simp]:\n  \"(h,{}) \\<Turnstile> \\<up>b \\<longleftrightarrow> b\"\n  \"(h,{}) \\<Turnstile> true\"\n  \"(h,{}) \\<Turnstile> p\\<mapsto>\\<^sub>rx \\<longleftrightarrow> False\"\n  \"(h,{}) \\<Turnstile> q\\<mapsto>\\<^sub>ay \\<longleftrightarrow> False\"\n  \"(h,{}) \\<Turnstile> P*Q \\<longleftrightarrow> ((h,{}) \\<Turnstile> P) \\<and> ((h,{}) \\<Turnstile> Q)\"\n  \"(h,{}) \\<Turnstile> P\\<and>\\<^sub>AQ \\<longleftrightarrow> ((h,{}) \\<Turnstile> P) \\<and> ((h,{}) \\<Turnstile> Q)\"\n  \"(h,{}) \\<Turnstile> P\\<or>\\<^sub>AQ \\<longleftrightarrow> ((h,{}) \\<Turnstile> P) \\<or> ((h,{}) \\<Turnstile> Q)\"\n  \"(h,{}) \\<Turnstile> (\\<exists>\\<^sub>Ax. R x) \\<longleftrightarrow> (\\<exists>x. (h,{}) \\<Turnstile> R x)\"", "lemma entailsI: \n  assumes \"\\<And>h. h\\<Turnstile>P \\<Longrightarrow> h\\<Turnstile>Q\"\n  shows \"P \\<Longrightarrow>\\<^sub>A Q\"", "lemma entailsD: \n  assumes \"P \\<Longrightarrow>\\<^sub>A Q\"\n  assumes \"h\\<Turnstile>P\"\n  shows \"h\\<Turnstile>Q\"", "lemma ent_fwd: \n  assumes \"h\\<Turnstile>P\"\n  assumes \"P \\<Longrightarrow>\\<^sub>A Q\"\n  shows \"h\\<Turnstile>Q\"", "lemma ent_refl[simp]: \"P \\<Longrightarrow>\\<^sub>A P\"", "lemma ent_trans[trans]: \"\\<lbrakk> P \\<Longrightarrow>\\<^sub>A Q; Q \\<Longrightarrow>\\<^sub>AR \\<rbrakk> \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>A R\"", "lemma ent_iffI:\n  assumes \"A\\<Longrightarrow>\\<^sub>AB\"\n  assumes \"B\\<Longrightarrow>\\<^sub>AA\"\n  shows \"A=B\"", "lemma ent_false[simp]: \"false \\<Longrightarrow>\\<^sub>A P\"", "lemma ent_true[simp]: \"P \\<Longrightarrow>\\<^sub>A true\"", "lemma ent_false_iff[simp]: \"(P \\<Longrightarrow>\\<^sub>A false) \\<longleftrightarrow> (\\<forall>h. \\<not>h\\<Turnstile>P)\"", "lemma ent_pure_pre_iff[simp]: \"(P*\\<up>b \\<Longrightarrow>\\<^sub>A Q) \\<longleftrightarrow> (b \\<longrightarrow> (P \\<Longrightarrow>\\<^sub>A Q))\"", "lemma ent_pure_pre_iff_sng[simp]: \n  \"(\\<up>b \\<Longrightarrow>\\<^sub>A Q) \\<longleftrightarrow> (b \\<longrightarrow> (emp \\<Longrightarrow>\\<^sub>A Q))\"", "lemma ent_pure_post_iff[simp]: \n  \"(P \\<Longrightarrow>\\<^sub>A Q*\\<up>b) \\<longleftrightarrow> ((\\<forall>h. h\\<Turnstile>P \\<longrightarrow> b) \\<and> (P \\<Longrightarrow>\\<^sub>A Q))\"", "lemma ent_pure_post_iff_sng[simp]: \n  \"(P \\<Longrightarrow>\\<^sub>A \\<up>b) \\<longleftrightarrow> ((\\<forall>h. h\\<Turnstile>P \\<longrightarrow> b) \\<and> (P \\<Longrightarrow>\\<^sub>A emp))\"", "lemma ent_ex_preI: \"(\\<And>x. P x \\<Longrightarrow>\\<^sub>A Q) \\<Longrightarrow> \\<exists>\\<^sub>Ax. P x \\<Longrightarrow>\\<^sub>A Q\"", "lemma ent_ex_postI: \"(P \\<Longrightarrow>\\<^sub>A Q x) \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>A \\<exists>\\<^sub>Ax. Q x\"", "lemma ent_mp: \"(P * (P -* Q)) \\<Longrightarrow>\\<^sub>A Q\"", "lemma ent_star_mono: \"\\<lbrakk> P \\<Longrightarrow>\\<^sub>A P'; Q \\<Longrightarrow>\\<^sub>A Q'\\<rbrakk> \\<Longrightarrow> P*Q \\<Longrightarrow>\\<^sub>A P'*Q'\"", "lemma ent_wandI:\n  assumes IMP: \"Q*P \\<Longrightarrow>\\<^sub>A R\"\n  shows \"P \\<Longrightarrow>\\<^sub>A (Q -* R)\"", "lemma ent_disjI1:\n  assumes \"P \\<or>\\<^sub>A Q \\<Longrightarrow>\\<^sub>A R\" \n  shows \"P \\<Longrightarrow>\\<^sub>A R\"", "lemma ent_disjI2:\n  assumes \"P \\<or>\\<^sub>A Q \\<Longrightarrow>\\<^sub>A R\" \n  shows \"Q \\<Longrightarrow>\\<^sub>A R\"", "lemma ent_disjI1_direct[simp]: \"A \\<Longrightarrow>\\<^sub>A A \\<or>\\<^sub>A B\"", "lemma ent_disjI2_direct[simp]: \"B \\<Longrightarrow>\\<^sub>A A \\<or>\\<^sub>A B\"", "lemma ent_disjE: \"\\<lbrakk> A\\<Longrightarrow>\\<^sub>AC; B\\<Longrightarrow>\\<^sub>AC \\<rbrakk> \\<Longrightarrow> A\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>AC\"", "lemma ent_conjI: \"\\<lbrakk> A\\<Longrightarrow>\\<^sub>AB; A\\<Longrightarrow>\\<^sub>AC \\<rbrakk> \\<Longrightarrow> A \\<Longrightarrow>\\<^sub>A B \\<and>\\<^sub>A C\"", "lemma ent_conjE1: \"\\<lbrakk>A\\<Longrightarrow>\\<^sub>AC\\<rbrakk> \\<Longrightarrow> A\\<and>\\<^sub>AB\\<Longrightarrow>\\<^sub>AC\"", "lemma ent_conjE2: \"\\<lbrakk>B\\<Longrightarrow>\\<^sub>AC\\<rbrakk> \\<Longrightarrow> A\\<and>\\<^sub>AB\\<Longrightarrow>\\<^sub>AC\"", "lemma star_or_dist1: \n  \"(A \\<or>\\<^sub>A B)*C = (A*C \\<or>\\<^sub>A B*C)\"", "lemma star_or_dist2: \n  \"C*(A \\<or>\\<^sub>A B) = (C*A \\<or>\\<^sub>A C*B)\"", "lemmas star_or_dist = star_or_dist1 star_or_dist2", "lemma ent_disjI1': \"A\\<Longrightarrow>\\<^sub>AB \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>AB\\<or>\\<^sub>AC\"", "lemma ent_disjI2': \"A\\<Longrightarrow>\\<^sub>AC \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>AB\\<or>\\<^sub>AC\"", "lemma triv_exI[simp, intro!]: \"Q x \\<Longrightarrow>\\<^sub>A \\<exists>\\<^sub>Ax. Q x\"", "lemma enttI: \"A\\<Longrightarrow>\\<^sub>AB*true \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>tB\"", "lemma enttD: \"A\\<Longrightarrow>\\<^sub>tB \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>AB*true\"", "lemma entt_trans:\n  \"entailst A B \\<Longrightarrow> entailst B C \\<Longrightarrow> entailst A C\"", "lemma entt_refl[simp, intro!]: \"entailst A A\"", "lemma entt_true[simp, intro!]:\n  \"entailst A true\"", "lemma entt_emp[simp, intro!]:\n  \"entailst A emp\"", "lemma entt_star_true_simp[simp]:\n  \"entailst A (B*true) \\<longleftrightarrow> entailst A B\"\n  \"entailst (A*true) B \\<longleftrightarrow> entailst A B\"", "lemma entt_star_mono: \"\\<lbrakk>entailst A B; entailst C D\\<rbrakk> \\<Longrightarrow> entailst (A*C) (B*D)\"", "lemma entt_frame_fwd:\n  assumes \"entailst P Q\"\n  assumes \"entailst A (P*F)\"\n  assumes \"entailst (Q*F) B\"\n  shows \"entailst A B\"", "lemma enttI_true: \"P*true \\<Longrightarrow>\\<^sub>A Q*true \\<Longrightarrow> P\\<Longrightarrow>\\<^sub>tQ\"", "lemma entt_def_true: \"(P\\<Longrightarrow>\\<^sub>tQ) \\<equiv> (P*true \\<Longrightarrow>\\<^sub>A Q*true)\"", "lemma ent_imp_entt: \"P\\<Longrightarrow>\\<^sub>AQ \\<Longrightarrow> P\\<Longrightarrow>\\<^sub>tQ\"", "lemma entt_disjI1_direct[simp]: \"A \\<Longrightarrow>\\<^sub>t A \\<or>\\<^sub>A B\"", "lemma entt_disjI2_direct[simp]: \"B \\<Longrightarrow>\\<^sub>t A \\<or>\\<^sub>A B\"", "lemma entt_disjI1': \"A\\<Longrightarrow>\\<^sub>tB \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>tB\\<or>\\<^sub>AC\"", "lemma entt_disjI2': \"A\\<Longrightarrow>\\<^sub>tC \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>tB\\<or>\\<^sub>AC\"", "lemma entt_disjE: \"\\<lbrakk> A\\<Longrightarrow>\\<^sub>tM; B\\<Longrightarrow>\\<^sub>tM \\<rbrakk> \\<Longrightarrow> A\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>t M\"", "lemma entt_disjD1: \"A\\<or>\\<^sub>AB\\<Longrightarrow>\\<^sub>tC \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>tC\"", "lemma entt_disjD2: \"A\\<or>\\<^sub>AB\\<Longrightarrow>\\<^sub>tC \\<Longrightarrow> B\\<Longrightarrow>\\<^sub>tC\"", "lemma preciseI[intro?]: \n  assumes \"\\<And>a a' h p F F'. h \\<Turnstile> R a p * F \\<and>\\<^sub>A R a' p * F' \\<Longrightarrow> a = a'\"\n  shows \"precise R\"", "lemma preciseD:\n  assumes \"precise R\"\n  assumes \"h \\<Turnstile> R a p * F \\<and>\\<^sub>A R a' p * F'\"\n  shows \"a=a'\"", "lemma preciseD':\n  assumes \"precise R\"\n  assumes \"h \\<Turnstile> R a p * F\" \n  assumes \"h \\<Turnstile> R a' p * F'\"\n  shows \"a=a'\"", "lemma precise_extr_pure[simp]: \n  \"precise (\\<lambda>x y. \\<up>P * R x y) \\<longleftrightarrow> (P \\<longrightarrow> precise R)\"\n  \"precise (\\<lambda>x y. R x y * \\<up>P) \\<longleftrightarrow> (P \\<longrightarrow> precise R)\"", "lemma sngr_prec: \"precise (\\<lambda>x p. p\\<mapsto>\\<^sub>rx)\"", "lemma snga_prec: \"precise (\\<lambda>x p. p\\<mapsto>\\<^sub>ax)\""], "translations": [["", "lemma in_range_empty[simp, intro!]: \"in_range (h,{})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_range (h, {})", "by (auto simp: in_range.simps)"], ["", "lemma in_range_dist_union[simp]: \n  \"in_range (h,as \\<union> as') \\<longleftrightarrow> in_range (h,as) \\<and> in_range (h,as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_range (h, as \\<union> as') =\n    (in_range (h, as) \\<and> in_range (h, as'))", "by (auto simp: in_range.simps)"], ["", "lemma in_range_subset: \n  \"\\<lbrakk>as \\<subseteq> as'; in_range (h,as')\\<rbrakk> \\<Longrightarrow> in_range (h,as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<subseteq> as'; in_range (h, as')\\<rbrakk>\n    \\<Longrightarrow> in_range (h, as)", "by (auto simp: in_range.simps)"], ["", "text \\<open>Relation that holds if two heaps are identical on a given \n  address range\\<close>"], ["", "definition relH :: \"addr set \\<Rightarrow> heap \\<Rightarrow> heap \\<Rightarrow> bool\" \n  where \"relH as h h' \\<equiv> \n  in_range (h,as) \n  \\<and> in_range (h',as) \n  \\<and> (\\<forall>t. \\<forall>a \\<in> as. \n        refs h t a = refs h' t a \n      \\<and> arrays h t a = arrays h' t a\n    )\""], ["", "lemma relH_in_rangeI:\n  assumes \"relH as h h'\"\n  shows \"in_range (h,as)\" and \"in_range (h',as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_range (h, as) &&& in_range (h', as)", "using assms"], ["proof (prove)\nusing this:\n  relH as h h'\n\ngoal (1 subgoal):\n 1. in_range (h, as) &&& in_range (h', as)", "unfolding relH_def"], ["proof (prove)\nusing this:\n  in_range (h, as) \\<and>\n  in_range (h', as) \\<and>\n  (\\<forall>t.\n      \\<forall>a\\<in>as.\n         refs h t a = refs h' t a \\<and> arrays h t a = arrays h' t a)\n\ngoal (1 subgoal):\n 1. in_range (h, as) &&& in_range (h', as)", "by auto"], ["", "text \"Reflexivity\""], ["", "lemma relH_refl: \"in_range (h,as) \\<Longrightarrow> relH as h h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_range (h, as) \\<Longrightarrow> relH as h h", "unfolding relH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_range (h, as) \\<Longrightarrow>\n    in_range (h, as) \\<and>\n    in_range (h, as) \\<and>\n    (\\<forall>t.\n        \\<forall>a\\<in>as.\n           refs h t a = refs h t a \\<and> arrays h t a = arrays h t a)", "by simp"], ["", "text \"Symmetry\""], ["", "lemma relH_sym: \"relH as h h' \\<Longrightarrow> relH as h' h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relH as h h' \\<Longrightarrow> relH as h' h", "unfolding relH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_range (h, as) \\<and>\n    in_range (h', as) \\<and>\n    (\\<forall>t.\n        \\<forall>a\\<in>as.\n           refs h t a = refs h' t a \\<and>\n           arrays h t a = arrays h' t a) \\<Longrightarrow>\n    in_range (h', as) \\<and>\n    in_range (h, as) \\<and>\n    (\\<forall>t.\n        \\<forall>a\\<in>as.\n           refs h' t a = refs h t a \\<and> arrays h' t a = arrays h t a)", "by auto"], ["", "text \"Transitivity\""], ["", "lemma relH_trans[trans]: \"\\<lbrakk>relH as h1 h2; relH as h2 h3\\<rbrakk> \\<Longrightarrow> relH as h1 h3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>relH as h1 h2; relH as h2 h3\\<rbrakk>\n    \\<Longrightarrow> relH as h1 h3", "unfolding relH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_range (h1, as) \\<and>\n             in_range (h2, as) \\<and>\n             (\\<forall>t.\n                 \\<forall>a\\<in>as.\n                    refs h1 t a = refs h2 t a \\<and>\n                    arrays h1 t a = arrays h2 t a);\n     in_range (h2, as) \\<and>\n     in_range (h3, as) \\<and>\n     (\\<forall>t.\n         \\<forall>a\\<in>as.\n            refs h2 t a = refs h3 t a \\<and>\n            arrays h2 t a = arrays h3 t a)\\<rbrakk>\n    \\<Longrightarrow> in_range (h1, as) \\<and>\n                      in_range (h3, as) \\<and>\n                      (\\<forall>t.\n                          \\<forall>a\\<in>as.\n                             refs h1 t a = refs h3 t a \\<and>\n                             arrays h1 t a = arrays h3 t a)", "by auto"], ["", "lemma relH_dist_union[simp]: \n  \"relH (as\\<union>as') h h' \\<longleftrightarrow> relH as h h' \\<and> relH as' h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relH (as \\<union> as') h h' = (relH as h h' \\<and> relH as' h h')", "unfolding relH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (in_range (h, as \\<union> as') \\<and>\n     in_range (h', as \\<union> as') \\<and>\n     (\\<forall>t.\n         \\<forall>a\\<in>as \\<union> as'.\n            refs h t a = refs h' t a \\<and> arrays h t a = arrays h' t a)) =\n    ((in_range (h, as) \\<and>\n      in_range (h', as) \\<and>\n      (\\<forall>t.\n          \\<forall>a\\<in>as.\n             refs h t a = refs h' t a \\<and>\n             arrays h t a = arrays h' t a)) \\<and>\n     in_range (h, as') \\<and>\n     in_range (h', as') \\<and>\n     (\\<forall>t.\n         \\<forall>a\\<in>as'.\n            refs h t a = refs h' t a \\<and> arrays h t a = arrays h' t a))", "by auto"], ["", "lemma relH_subset:\n  assumes \"relH bs h h'\"\n  assumes \"as \\<subseteq> bs\"\n  shows \"relH as h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relH as h h'", "using assms"], ["proof (prove)\nusing this:\n  relH bs h h'\n  as \\<subseteq> bs\n\ngoal (1 subgoal):\n 1. relH as h h'", "unfolding relH_def"], ["proof (prove)\nusing this:\n  in_range (h, bs) \\<and>\n  in_range (h', bs) \\<and>\n  (\\<forall>t.\n      \\<forall>a\\<in>bs.\n         refs h t a = refs h' t a \\<and> arrays h t a = arrays h' t a)\n  as \\<subseteq> bs\n\ngoal (1 subgoal):\n 1. in_range (h, as) \\<and>\n    in_range (h', as) \\<and>\n    (\\<forall>t.\n        \\<forall>a\\<in>as.\n           refs h t a = refs h' t a \\<and> arrays h t a = arrays h' t a)", "by (auto intro: in_range_subset)"], ["", "lemma relH_ref:\n  assumes \"relH as h h'\"\n  assumes \"addr_of_ref r \\<in> as\"\n  shows \"Ref.get h r = Ref.get h' r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.get h r = Ref.get h' r", "using assms"], ["proof (prove)\nusing this:\n  relH as h h'\n  addr_of_ref r \\<in> as\n\ngoal (1 subgoal):\n 1. Ref.get h r = Ref.get h' r", "unfolding relH_def Ref.get_def"], ["proof (prove)\nusing this:\n  in_range (h, as) \\<and>\n  in_range (h', as) \\<and>\n  (\\<forall>t.\n      \\<forall>a\\<in>as.\n         refs h t a = refs h' t a \\<and> arrays h t a = arrays h' t a)\n  addr_of_ref r \\<in> as\n\ngoal (1 subgoal):\n 1. ((from_nat \\<circ>\\<circ>\\<circ> refs) h TYPEREP('a) \\<circ>\n     addr_of_ref)\n     r =\n    ((from_nat \\<circ>\\<circ>\\<circ> refs) h' TYPEREP('a) \\<circ>\n     addr_of_ref)\n     r", "by auto"], ["", "lemma relH_array:\n  assumes \"relH as h h'\"\n  assumes \"addr_of_array r \\<in> as\"\n  shows \"Array.get h r = Array.get h' r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.get h r = Array.get h' r", "using assms"], ["proof (prove)\nusing this:\n  relH as h h'\n  addr_of_array r \\<in> as\n\ngoal (1 subgoal):\n 1. Array.get h r = Array.get h' r", "unfolding relH_def Array.get_def"], ["proof (prove)\nusing this:\n  in_range (h, as) \\<and>\n  in_range (h', as) \\<and>\n  (\\<forall>t.\n      \\<forall>a\\<in>as.\n         refs h t a = refs h' t a \\<and> arrays h t a = arrays h' t a)\n  addr_of_array r \\<in> as\n\ngoal (1 subgoal):\n 1. map from_nat (arrays h TYPEREP('a) (addr_of_array r)) =\n    map from_nat (arrays h' TYPEREP('a) (addr_of_array r))", "by auto"], ["", "lemma relH_set_ref: \"\\<lbrakk> addr_of_ref r \\<notin> as; in_range (h,as)\\<rbrakk> \n  \\<Longrightarrow> relH as h (Ref.set r x h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>addr_of_ref r \\<notin> as; in_range (h, as)\\<rbrakk>\n    \\<Longrightarrow> relH as h (Ref.set r x h)", "unfolding relH_def Ref.set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>addr_of_ref r \\<notin> as; in_range (h, as)\\<rbrakk>\n    \\<Longrightarrow> in_range (h, as) \\<and>\n                      in_range\n                       (refs_update\n                         (\\<lambda>h. h\n                             (TYPEREP('a) := (h TYPEREP('a))\n                                (addr_of_ref r := to_nat x)))\n                         h,\n                        as) \\<and>\n                      (\\<forall>t.\n                          \\<forall>a\\<in>as.\n                             refs h t a =\n                             refs\n                              (refs_update\n                                (\\<lambda>h. h\n                                    (TYPEREP('a) := (h TYPEREP('a))\n (addr_of_ref r := to_nat x)))\n                                h)\n                              t a \\<and>\n                             arrays h t a =\n                             arrays\n                              (refs_update\n                                (\\<lambda>h. h\n                                    (TYPEREP('a) := (h TYPEREP('a))\n (addr_of_ref r := to_nat x)))\n                                h)\n                              t a)", "by (auto simp: in_range.simps)"], ["", "lemma relH_set_array: \"\\<lbrakk>addr_of_array r \\<notin> as; in_range (h,as)\\<rbrakk> \n  \\<Longrightarrow> relH as h (Array.set r x h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>addr_of_array r \\<notin> as; in_range (h, as)\\<rbrakk>\n    \\<Longrightarrow> relH as h (Array.set r x h)", "unfolding relH_def Array.set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>addr_of_array r \\<notin> as; in_range (h, as)\\<rbrakk>\n    \\<Longrightarrow> in_range (h, as) \\<and>\n                      in_range\n                       (arrays_update\n                         (\\<lambda>h. h\n                             (TYPEREP('a) := (h TYPEREP('a))\n                                (addr_of_array r := map to_nat x)))\n                         h,\n                        as) \\<and>\n                      (\\<forall>t.\n                          \\<forall>a\\<in>as.\n                             refs h t a =\n                             refs\n                              (arrays_update\n                                (\\<lambda>h. h\n                                    (TYPEREP('a) := (h TYPEREP('a))\n (addr_of_array r := map to_nat x)))\n                                h)\n                              t a \\<and>\n                             arrays h t a =\n                             arrays\n                              (arrays_update\n                                (\\<lambda>h. h\n                                    (TYPEREP('a) := (h TYPEREP('a))\n (addr_of_array r := map to_nat x)))\n                                h)\n                              t a)", "by (auto simp: in_range.simps)"], ["", "subsection \\<open>Assertions\\<close>"], ["", "text \\<open>\n  Assertions are predicates on partial heaps, that fulfill a well-formedness \n  condition called properness: They only depend on the part of the heap\n  by the address set, and must be false for partial heaps that are not in range.\n\\<close>"], ["", "type_synonym assn_raw = \"pheap \\<Rightarrow> bool\""], ["", "definition proper :: \"assn_raw \\<Rightarrow> bool\" where\n  \"proper P \\<equiv> \\<forall>h h' as. (P (h,as) \\<longrightarrow> in_range (h,as)) \n    \\<and> (P (h,as) \\<and> relH as h h' \\<and> in_range (h',as) \\<longrightarrow> P (h',as))\""], ["", "lemma properI[intro?]: \n  assumes \"\\<And>as h. P (h,as) \\<Longrightarrow> in_range (h,as)\"\n  assumes \"\\<And>as h h'. \n    \\<lbrakk>P (h,as); relH as h h'; in_range (h',as)\\<rbrakk> \\<Longrightarrow> P (h',as)\"\n  shows \"proper P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper P", "unfolding proper_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h h' as.\n       (P (h, as) \\<longrightarrow> in_range (h, as)) \\<and>\n       (P (h, as) \\<and>\n        relH as h h' \\<and> in_range (h', as) \\<longrightarrow>\n        P (h', as))", "using assms"], ["proof (prove)\nusing this:\n  P (?h, ?as) \\<Longrightarrow> in_range (?h, ?as)\n  \\<lbrakk>P (?h, ?as); relH ?as ?h ?h'; in_range (?h', ?as)\\<rbrakk>\n  \\<Longrightarrow> P (?h', ?as)\n\ngoal (1 subgoal):\n 1. \\<forall>h h' as.\n       (P (h, as) \\<longrightarrow> in_range (h, as)) \\<and>\n       (P (h, as) \\<and>\n        relH as h h' \\<and> in_range (h', as) \\<longrightarrow>\n        P (h', as))", "by blast"], ["", "lemma properD1:\n  assumes \"proper P\"\n  assumes \"P (h,as)\"\n  shows \"in_range (h,as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_range (h, as)", "using assms"], ["proof (prove)\nusing this:\n  proper P\n  P (h, as)\n\ngoal (1 subgoal):\n 1. in_range (h, as)", "unfolding proper_def"], ["proof (prove)\nusing this:\n  \\<forall>h h' as.\n     (P (h, as) \\<longrightarrow> in_range (h, as)) \\<and>\n     (P (h, as) \\<and>\n      relH as h h' \\<and> in_range (h', as) \\<longrightarrow>\n      P (h', as))\n  P (h, as)\n\ngoal (1 subgoal):\n 1. in_range (h, as)", "by blast"], ["", "lemma properD2:\n  assumes \"proper P\"\n  assumes \"P (h,as)\"\n  assumes \"relH as h h'\"\n  assumes \"in_range (h',as)\"\n  shows \"P (h',as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (h', as)", "using assms"], ["proof (prove)\nusing this:\n  proper P\n  P (h, as)\n  relH as h h'\n  in_range (h', as)\n\ngoal (1 subgoal):\n 1. P (h', as)", "unfolding proper_def"], ["proof (prove)\nusing this:\n  \\<forall>h h' as.\n     (P (h, as) \\<longrightarrow> in_range (h, as)) \\<and>\n     (P (h, as) \\<and>\n      relH as h h' \\<and> in_range (h', as) \\<longrightarrow>\n      P (h', as))\n  P (h, as)\n  relH as h h'\n  in_range (h', as)\n\ngoal (1 subgoal):\n 1. P (h', as)", "by blast"], ["", "lemmas properD = properD1 properD2"], ["", "lemma proper_iff:\n  assumes \"proper P\"\n  assumes \"relH as h h'\"\n  assumes \"in_range (h',as)\"\n  shows \"P (h,as) \\<longleftrightarrow> P (h',as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (h, as) = P (h', as)", "using assms"], ["proof (prove)\nusing this:\n  proper P\n  relH as h h'\n  in_range (h', as)\n\ngoal (1 subgoal):\n 1. P (h, as) = P (h', as)", "by (metis properD2 relH_in_rangeI(1) relH_sym)"], ["", "text \\<open>We encapsulate assertions in their own type\\<close>"], ["", "typedef assn = \"Collect proper\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Collect proper", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. proper x", "unfolding proper_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>h h' as.\n          (x (h, as) \\<longrightarrow> in_range (h, as)) \\<and>\n          (x (h, as) \\<and>\n           relH as h h' \\<and> in_range (h', as) \\<longrightarrow>\n           x (h', as))", "by fastforce"], ["", "lemmas [simp] = Rep_assn_inverse Rep_assn_inject"], ["", "lemmas [simp, intro!] = Rep_assn[unfolded mem_Collect_eq]"], ["", "lemma Abs_assn_eqI[intro?]: \n  \"(\\<And>h. P h = Rep_assn Pr h) \\<Longrightarrow> Abs_assn P = Pr\"\n  \"(\\<And>h. P h = Rep_assn Pr h) \\<Longrightarrow> Pr = Abs_assn P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>h. P h = Rep_assn Pr h) \\<Longrightarrow> Abs_assn P = Pr) &&&\n    ((\\<And>h. P h = Rep_assn Pr h) \\<Longrightarrow> Pr = Abs_assn P)", "by (metis Rep_assn_inverse predicate1I xt1(5))+"], ["", "abbreviation models :: \"pheap \\<Rightarrow> assn \\<Rightarrow> bool\" (infix \"\\<Turnstile>\" 50) \n  where \"h\\<Turnstile>P \\<equiv> Rep_assn P h\""], ["", "lemma models_in_range: \"h\\<Turnstile>P \\<Longrightarrow> in_range h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> P \\<Longrightarrow> in_range h", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>h \\<Turnstile> P; h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> in_range h", "by (metis mem_Collect_eq Rep_assn properD1)"], ["", "subsubsection \\<open>Empty Partial Heap\\<close>"], ["", "text \\<open>The empty partial heap satisfies some special properties.\n  We set up a simplification that tries to rewrite it to the standard\n  empty partial heap \\<open>h\\<^sub>\\<bottom>\\<close>\\<close>"], ["", "abbreviation h_bot (\"h\\<^sub>\\<bottom>\") where \"h\\<^sub>\\<bottom> \\<equiv> (undefined,{})\""], ["", "lemma mod_h_bot_indep: \"(h,{})\\<Turnstile>P \\<longleftrightarrow> (h',{})\\<Turnstile>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((h, {}) \\<Turnstile> P) = ((h', {}) \\<Turnstile> P)", "by (metis mem_Collect_eq Rep_assn emptyE in_range_empty \n    proper_iff relH_def)"], ["", "lemma mod_h_bot_normalize[simp]: \n  \"syntax_fo_nomatch undefined h \\<Longrightarrow> (h,{})\\<Turnstile>P \\<longleftrightarrow> h\\<^sub>\\<bottom> \\<Turnstile> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. syntax_fo_nomatch undefined h \\<Longrightarrow>\n    ((h, {}) \\<Turnstile> P) = (h\\<^sub>\\<bottom> \\<Turnstile> P)", "using mod_h_bot_indep[where h'=undefined]"], ["proof (prove)\nusing this:\n  ((?h, {}) \\<Turnstile> ?P) = (h\\<^sub>\\<bottom> \\<Turnstile> ?P)\n\ngoal (1 subgoal):\n 1. syntax_fo_nomatch undefined h \\<Longrightarrow>\n    ((h, {}) \\<Turnstile> P) = (h\\<^sub>\\<bottom> \\<Turnstile> P)", "by simp"], ["", "text \\<open>Properness, lifted to the assertion type.\\<close>"], ["", "lemma mod_relH: \"relH as h h' \\<Longrightarrow> (h,as)\\<Turnstile>P \\<longleftrightarrow> (h',as)\\<Turnstile>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relH as h h' \\<Longrightarrow>\n    ((h, as) \\<Turnstile> P) = ((h', as) \\<Turnstile> P)", "by (metis mem_Collect_eq Rep_assn proper_iff relH_in_rangeI(2))"], ["", "subsection \\<open>Connectives\\<close>"], ["", "text \\<open>\n  We define several operations on assertions, and instantiate some type classes.\n\\<close>"], ["", "subsubsection \\<open>Empty Heap and Separation Conjunction\\<close>"], ["", "text \\<open>The assertion that describes the empty heap, and the separation\n  conjunction form a commutative monoid:\\<close>"], ["", "instantiation assn :: one begin"], ["", "fun one_assn_raw :: \"pheap \\<Rightarrow> bool\" \n    where \"one_assn_raw (h,as) \\<longleftrightarrow> as={}\""], ["", "lemma one_assn_proper[intro!,simp]: \"proper one_assn_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper one_assn_raw", "by (auto intro!: properI)"], ["", "definition one_assn :: assn where \"1 \\<equiv> Abs_assn one_assn_raw\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(assn, one_class)", ".."], ["", "end"], ["", "abbreviation one_assn::assn (\"emp\") where \"one_assn \\<equiv> 1\""], ["", "instantiation assn :: times begin"], ["", "fun times_assn_raw :: \"assn_raw \\<Rightarrow> assn_raw \\<Rightarrow> assn_raw\" where\n    \"times_assn_raw P Q (h,as) \n    = (\\<exists>as1 as2. as=as1\\<union>as2 \\<and> as1\\<inter>as2={} \n        \\<and> P (h,as1) \\<and> Q (h,as2))\""], ["", "lemma times_assn_proper[intro!,simp]: \n    \"proper P \\<Longrightarrow> proper Q \\<Longrightarrow> proper (times_assn_raw P Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proper P; proper Q\\<rbrakk>\n    \\<Longrightarrow> proper (times_assn_raw P Q)", "apply (rule properI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as h.\n       \\<lbrakk>proper P; proper Q; times_assn_raw P Q (h, as)\\<rbrakk>\n       \\<Longrightarrow> in_range (h, as)\n 2. \\<And>as h h'.\n       \\<lbrakk>proper P; proper Q; times_assn_raw P Q (h, as);\n        relH as h h'; in_range (h', as)\\<rbrakk>\n       \\<Longrightarrow> times_assn_raw P Q (h', as)", "apply (auto dest: properD1) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as h h'.\n       \\<lbrakk>proper P; proper Q; times_assn_raw P Q (h, as);\n        relH as h h'; in_range (h', as)\\<rbrakk>\n       \\<Longrightarrow> times_assn_raw P Q (h', as)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' as1 as2.\n       \\<lbrakk>proper P; proper Q; as1 \\<inter> as2 = {}; P (h, as1);\n        Q (h, as2); relH as1 h h'; relH as2 h h'; in_range (h', as1);\n        in_range (h', as2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as1a as2a.\n                            as1 \\<union> as2 = as1a \\<union> as2a \\<and>\n                            as1a \\<inter> as2a = {} \\<and>\n                            P (h', as1a) \\<and> Q (h', as2a)", "apply (drule (3) properD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' as1 as2.\n       \\<lbrakk>proper Q; as1 \\<inter> as2 = {}; P (h, as1); Q (h, as2);\n        relH as1 h h'; relH as2 h h'; in_range (h', as1);\n        in_range (h', as2); P (h', as1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as1a as2a.\n                            as1 \\<union> as2 = as1a \\<union> as2a \\<and>\n                            as1a \\<inter> as2a = {} \\<and>\n                            P (h', as1a) \\<and> Q (h', as2a)", "apply (drule (3) properD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' as1 as2.\n       \\<lbrakk>as1 \\<inter> as2 = {}; P (h, as1); Q (h, as2);\n        relH as1 h h'; relH as2 h h'; in_range (h', as1);\n        in_range (h', as2); P (h', as1); Q (h', as2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as1a as2a.\n                            as1 \\<union> as2 = as1a \\<union> as2a \\<and>\n                            as1a \\<inter> as2a = {} \\<and>\n                            P (h', as1a) \\<and> Q (h', as2a)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition times_assn where \"P*Q \\<equiv> \n    Abs_assn (times_assn_raw (Rep_assn P) (Rep_assn Q))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(assn, times_class)", ".."], ["", "end"], ["", "lemma mod_star_conv: \"h\\<Turnstile>A*B \n  \\<longleftrightarrow> (\\<exists>hr as1 as2. h=(hr,as1\\<union>as2) \\<and> as1\\<inter>as2={} \\<and> (hr,as1)\\<Turnstile>A \\<and> (hr,as2)\\<Turnstile>B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> A * B) =\n    (\\<exists>hr as1 as2.\n        h = (hr, as1 \\<union> as2) \\<and>\n        as1 \\<inter> as2 = {} \\<and>\n        (hr, as1) \\<Turnstile> A \\<and> (hr, as2) \\<Turnstile> B)", "unfolding times_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> Abs_assn (times_assn_raw (Rep_assn A) (Rep_assn B))) =\n    (\\<exists>hr as1 as2.\n        h = (hr, as1 \\<union> as2) \\<and>\n        as1 \\<inter> as2 = {} \\<and>\n        (hr, as1) \\<Turnstile> A \\<and> (hr, as2) \\<Turnstile> B)", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       h = (a, b) \\<Longrightarrow>\n       (h \\<Turnstile>\n        Abs_assn (times_assn_raw (Rep_assn A) (Rep_assn B))) =\n       (\\<exists>hr as1 as2.\n           h = (hr, as1 \\<union> as2) \\<and>\n           as1 \\<inter> as2 = {} \\<and>\n           (hr, as1) \\<Turnstile> A \\<and> (hr, as2) \\<Turnstile> B)", "by (auto simp: Abs_assn_inverse)"], ["", "lemma mod_starD: \"h\\<Turnstile>A*B \\<Longrightarrow> \\<exists>h1 h2. h1\\<Turnstile>A \\<and> h2\\<Turnstile>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> A * B \\<Longrightarrow>\n    \\<exists>h1 h2. h1 \\<Turnstile> A \\<and> h2 \\<Turnstile> B", "by (auto simp: mod_star_conv)"], ["", "lemma star_assnI:\n  assumes \"(h,as)\\<Turnstile>P\" and \"(h,as')\\<Turnstile>Q\" and \"as\\<inter>as'={}\"\n  shows \"(h,as\\<union>as')\\<Turnstile>P*Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h, as \\<union> as') \\<Turnstile> P * Q", "using assms"], ["proof (prove)\nusing this:\n  (h, as) \\<Turnstile> P\n  (h, as') \\<Turnstile> Q\n  as \\<inter> as' = {}\n\ngoal (1 subgoal):\n 1. (h, as \\<union> as') \\<Turnstile> P * Q", "unfolding times_assn_def"], ["proof (prove)\nusing this:\n  (h, as) \\<Turnstile> P\n  (h, as') \\<Turnstile> Q\n  as \\<inter> as' = {}\n\ngoal (1 subgoal):\n 1. (h, as \\<union> as') \\<Turnstile>\n    Abs_assn (times_assn_raw (Rep_assn P) (Rep_assn Q))", "by (auto simp: Abs_assn_inverse)"], ["", "instantiation assn :: comm_monoid_mult begin"], ["", "lemma assn_one_left: \"1*P = (P::assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emp * P = P", "unfolding one_assn_def times_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (times_assn_raw (Rep_assn (Abs_assn one_assn_raw)) (Rep_assn P)) =\n    P", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       times_assn_raw (Rep_assn (Abs_assn one_assn_raw)) (Rep_assn P) h =\n       (h \\<Turnstile> P)", "apply (auto simp: Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assn_times_comm: \"P*Q = Q*(P::assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * Q = Q * P", "unfolding times_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn (times_assn_raw (Rep_assn P) (Rep_assn Q)) =\n    Abs_assn (times_assn_raw (Rep_assn Q) (Rep_assn P))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       times_assn_raw (Rep_assn Q) (Rep_assn P) h =\n       (h \\<Turnstile> Abs_assn (times_assn_raw (Rep_assn P) (Rep_assn Q)))", "apply (fastforce simp add: Abs_assn_inverse Un_ac)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assn_times_assoc: \"(P*Q)*R = P*(Q*(R::assn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * Q * R = P * (Q * R)", "unfolding times_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (times_assn_raw\n       (Rep_assn (Abs_assn (times_assn_raw (Rep_assn P) (Rep_assn Q))))\n       (Rep_assn R)) =\n    Abs_assn\n     (times_assn_raw (Rep_assn P)\n       (Rep_assn (Abs_assn (times_assn_raw (Rep_assn Q) (Rep_assn R)))))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       times_assn_raw (Rep_assn P)\n        (Rep_assn (Abs_assn (times_assn_raw (Rep_assn Q) (Rep_assn R)))) h =\n       (h \\<Turnstile>\n        Abs_assn\n         (times_assn_raw\n           (Rep_assn (Abs_assn (times_assn_raw (Rep_assn P) (Rep_assn Q))))\n           (Rep_assn R)))", "apply (auto simp: Abs_assn_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as1 as1a as2a.\n       \\<lbrakk>as1 \\<inter> (as1a \\<union> as2a) = {};\n        (a, as1) \\<Turnstile> P; as1a \\<inter> as2a = {};\n        (a, as1a) \\<Turnstile> Q; (a, as2a) \\<Turnstile> R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as1b as2.\n                            as1 \\<union> (as1a \\<union> as2a) =\n                            as1b \\<union> as2 \\<and>\n                            as1b \\<inter> as2 = {} \\<and>\n                            (\\<exists>as1 as2.\n                                as1b = as1 \\<union> as2 \\<and>\n                                as1 \\<inter> as2 = {} \\<and>\n                                (a, as1) \\<Turnstile> P \\<and>\n                                (a, as2) \\<Turnstile> Q) \\<and>\n                            (a, as2) \\<Turnstile> R\n 2. \\<And>a as2 as1a as2a.\n       \\<lbrakk>(as1a \\<union> as2a) \\<inter> as2 = {};\n        (a, as2) \\<Turnstile> R; as1a \\<inter> as2a = {};\n        (a, as1a) \\<Turnstile> P; (a, as2a) \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as1 as2b.\n                            as1a \\<union> as2a \\<union> as2 =\n                            as1 \\<union> as2b \\<and>\n                            as1 \\<inter> as2b = {} \\<and>\n                            (a, as1) \\<Turnstile> P \\<and>\n                            (\\<exists>as1 as2.\n                                as2b = as1 \\<union> as2 \\<and>\n                                as1 \\<inter> as2 = {} \\<and>\n                                (a, as1) \\<Turnstile> Q \\<and>\n                                (a, as2) \\<Turnstile> R)", "apply (rule_tac x=\"as1\\<union>as1a\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as1 as1a as2a.\n       \\<lbrakk>as1 \\<inter> (as1a \\<union> as2a) = {};\n        (a, as1) \\<Turnstile> P; as1a \\<inter> as2a = {};\n        (a, as1a) \\<Turnstile> Q; (a, as2a) \\<Turnstile> R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as2.\n                            as1 \\<union> (as1a \\<union> as2a) =\n                            as1 \\<union> as1a \\<union> as2 \\<and>\n                            (as1 \\<union> as1a) \\<inter> as2 = {} \\<and>\n                            (\\<exists>as1b as2.\n                                as1 \\<union> as1a = as1b \\<union> as2 \\<and>\n                                as1b \\<inter> as2 = {} \\<and>\n                                (a, as1b) \\<Turnstile> P \\<and>\n                                (a, as2) \\<Turnstile> Q) \\<and>\n                            (a, as2) \\<Turnstile> R\n 2. \\<And>a as2 as1a as2a.\n       \\<lbrakk>(as1a \\<union> as2a) \\<inter> as2 = {};\n        (a, as2) \\<Turnstile> R; as1a \\<inter> as2a = {};\n        (a, as1a) \\<Turnstile> P; (a, as2a) \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as1 as2b.\n                            as1a \\<union> as2a \\<union> as2 =\n                            as1 \\<union> as2b \\<and>\n                            as1 \\<inter> as2b = {} \\<and>\n                            (a, as1) \\<Turnstile> P \\<and>\n                            (\\<exists>as1 as2.\n                                as2b = as1 \\<union> as2 \\<and>\n                                as1 \\<inter> as2 = {} \\<and>\n                                (a, as1) \\<Turnstile> Q \\<and>\n                                (a, as2) \\<Turnstile> R)", "apply (rule_tac x=\"as2a\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as1 as1a as2a.\n       \\<lbrakk>as1 \\<inter> (as1a \\<union> as2a) = {};\n        (a, as1) \\<Turnstile> P; as1a \\<inter> as2a = {};\n        (a, as1a) \\<Turnstile> Q; (a, as2a) \\<Turnstile> R\\<rbrakk>\n       \\<Longrightarrow> as1 \\<union> (as1a \\<union> as2a) =\n                         as1 \\<union> as1a \\<union> as2a \\<and>\n                         (as1 \\<union> as1a) \\<inter> as2a = {} \\<and>\n                         (\\<exists>as1b as2.\n                             as1 \\<union> as1a = as1b \\<union> as2 \\<and>\n                             as1b \\<inter> as2 = {} \\<and>\n                             (a, as1b) \\<Turnstile> P \\<and>\n                             (a, as2) \\<Turnstile> Q) \\<and>\n                         (a, as2a) \\<Turnstile> R\n 2. \\<And>a as2 as1a as2a.\n       \\<lbrakk>(as1a \\<union> as2a) \\<inter> as2 = {};\n        (a, as2) \\<Turnstile> R; as1a \\<inter> as2a = {};\n        (a, as1a) \\<Turnstile> P; (a, as2a) \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as1 as2b.\n                            as1a \\<union> as2a \\<union> as2 =\n                            as1 \\<union> as2b \\<and>\n                            as1 \\<inter> as2b = {} \\<and>\n                            (a, as1) \\<Turnstile> P \\<and>\n                            (\\<exists>as1 as2.\n                                as2b = as1 \\<union> as2 \\<and>\n                                as1 \\<inter> as2 = {} \\<and>\n                                (a, as1) \\<Turnstile> Q \\<and>\n                                (a, as2) \\<Turnstile> R)", "apply (auto simp add: Un_ac) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as2 as1a as2a.\n       \\<lbrakk>(as1a \\<union> as2a) \\<inter> as2 = {};\n        (a, as2) \\<Turnstile> R; as1a \\<inter> as2a = {};\n        (a, as1a) \\<Turnstile> P; (a, as2a) \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as1 as2b.\n                            as1a \\<union> as2a \\<union> as2 =\n                            as1 \\<union> as2b \\<and>\n                            as1 \\<inter> as2b = {} \\<and>\n                            (a, as1) \\<Turnstile> P \\<and>\n                            (\\<exists>as1 as2.\n                                as2b = as1 \\<union> as2 \\<and>\n                                as1 \\<inter> as2 = {} \\<and>\n                                (a, as1) \\<Turnstile> Q \\<and>\n                                (a, as2) \\<Turnstile> R)", "apply (rule_tac x=\"as1a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as2 as1a as2a.\n       \\<lbrakk>(as1a \\<union> as2a) \\<inter> as2 = {};\n        (a, as2) \\<Turnstile> R; as1a \\<inter> as2a = {};\n        (a, as1a) \\<Turnstile> P; (a, as2a) \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as2b.\n                            as1a \\<union> as2a \\<union> as2 =\n                            as1a \\<union> as2b \\<and>\n                            as1a \\<inter> as2b = {} \\<and>\n                            (a, as1a) \\<Turnstile> P \\<and>\n                            (\\<exists>as1 as2.\n                                as2b = as1 \\<union> as2 \\<and>\n                                as1 \\<inter> as2 = {} \\<and>\n                                (a, as1) \\<Turnstile> Q \\<and>\n                                (a, as2) \\<Turnstile> R)", "apply (rule_tac x=\"as2a\\<union>as2\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as2 as1a as2a.\n       \\<lbrakk>(as1a \\<union> as2a) \\<inter> as2 = {};\n        (a, as2) \\<Turnstile> R; as1a \\<inter> as2a = {};\n        (a, as1a) \\<Turnstile> P; (a, as2a) \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> as1a \\<union> as2a \\<union> as2 =\n                         as1a \\<union> (as2a \\<union> as2) \\<and>\n                         as1a \\<inter> (as2a \\<union> as2) = {} \\<and>\n                         (a, as1a) \\<Turnstile> P \\<and>\n                         (\\<exists>as1 as2b.\n                             as2a \\<union> as2 = as1 \\<union> as2b \\<and>\n                             as1 \\<inter> as2b = {} \\<and>\n                             (a, as1) \\<Turnstile> Q \\<and>\n                             (a, as2b) \\<Turnstile> R)", "apply (fastforce simp add: Un_ac) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(assn, comm_monoid_mult_class)", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. emp * a = a", "apply (rule assn_times_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a. emp * a = a", "apply (rule assn_times_comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. emp * a = a", "apply (rule assn_one_left)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \\<open>Magic Wand\\<close>"], ["", "fun wand_raw :: \"assn_raw \\<Rightarrow> assn_raw \\<Rightarrow> assn_raw\" where\n  \"wand_raw P Q (h,as) \\<longleftrightarrow> in_range (h,as) \n  \\<and> (\\<forall>h' as'. as\\<inter>as'={} \\<and> relH as h h' \\<and> in_range (h',as)\n    \\<and> P (h',as')\n    \\<longrightarrow> Q (h',as\\<union>as'))\""], ["", "lemma wand_proper[simp, intro!]: \"proper (wand_raw P Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper (wand_raw P Q)", "apply (rule properI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as h. wand_raw P Q (h, as) \\<Longrightarrow> in_range (h, as)\n 2. \\<And>as h h'.\n       \\<lbrakk>wand_raw P Q (h, as); relH as h h';\n        in_range (h', as)\\<rbrakk>\n       \\<Longrightarrow> wand_raw P Q (h', as)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as h h'.\n       \\<lbrakk>wand_raw P Q (h, as); relH as h h';\n        in_range (h', as)\\<rbrakk>\n       \\<Longrightarrow> wand_raw P Q (h', as)", "apply (auto dest: relH_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \n  wand_assn :: \"assn \\<Rightarrow> assn \\<Rightarrow> assn\" (infixl \"-*\" 56)\n  where \"P-*Q \\<equiv> Abs_assn (wand_raw (Rep_assn P) (Rep_assn Q))\""], ["", "lemma wand_assnI: \n  assumes \"in_range (h,as)\"\n  assumes \"\\<And>h' as'. \\<lbrakk>\n    as \\<inter> as' = {}; \n    relH as h h'; \n    in_range (h',as); \n    (h',as')\\<Turnstile>Q \n  \\<rbrakk> \\<Longrightarrow> (h',as\\<union>as') \\<Turnstile> R\"\n  shows \"(h,as) \\<Turnstile> Q -* R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h, as) \\<Turnstile> Q -* R", "using assms"], ["proof (prove)\nusing this:\n  in_range (h, as)\n  \\<lbrakk>as \\<inter> ?as' = {}; relH as h ?h'; in_range (?h', as);\n   (?h', ?as') \\<Turnstile> Q\\<rbrakk>\n  \\<Longrightarrow> (?h', as \\<union> ?as') \\<Turnstile> R\n\ngoal (1 subgoal):\n 1. (h, as) \\<Turnstile> Q -* R", "unfolding wand_assn_def"], ["proof (prove)\nusing this:\n  in_range (h, as)\n  \\<lbrakk>as \\<inter> ?as' = {}; relH as h ?h'; in_range (?h', as);\n   (?h', ?as') \\<Turnstile> Q\\<rbrakk>\n  \\<Longrightarrow> (?h', as \\<union> ?as') \\<Turnstile> R\n\ngoal (1 subgoal):\n 1. (h, as) \\<Turnstile> Abs_assn (wand_raw (Rep_assn Q) (Rep_assn R))", "apply (auto simp: Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Boolean Algebra on Assertions\\<close>"], ["", "instantiation assn :: boolean_algebra begin"], ["", "definition top_assn where \"top \\<equiv> Abs_assn in_range\""], ["", "definition bot_assn where \"bot \\<equiv> Abs_assn (\\<lambda>_. False)\""], ["", "definition sup_assn where \"sup P Q \\<equiv> Abs_assn (\\<lambda>h. h\\<Turnstile>P \\<or> h\\<Turnstile>Q)\""], ["", "definition inf_assn where \"inf P Q \\<equiv> Abs_assn (\\<lambda>h. h\\<Turnstile>P \\<and> h\\<Turnstile>Q)\""], ["", "definition uminus_assn where \n    \"-P \\<equiv> Abs_assn (\\<lambda>h. in_range h \\<and> \\<not>h\\<Turnstile>P)\""], ["", "lemma bool_assn_proper[simp, intro!]:\n    \"proper in_range\"\n    \"proper (\\<lambda>_. False)\"\n    \"proper P \\<Longrightarrow> proper Q \\<Longrightarrow> proper (\\<lambda>h. P h \\<or> Q h)\"\n    \"proper P \\<Longrightarrow> proper Q \\<Longrightarrow> proper (\\<lambda>h. P h \\<and> Q h)\"\n    \"proper P \\<Longrightarrow> proper (\\<lambda>h. in_range h \\<and> \\<not>P h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (proper in_range &&& proper (\\<lambda>_. False)) &&&\n    (\\<lbrakk>proper P; proper Q\\<rbrakk>\n     \\<Longrightarrow> proper (\\<lambda>h. P h \\<or> Q h)) &&&\n    (\\<lbrakk>proper P; proper Q\\<rbrakk>\n     \\<Longrightarrow> proper (\\<lambda>h. P h \\<and> Q h)) &&&\n    (proper P \\<Longrightarrow>\n     proper (\\<lambda>h. in_range h \\<and> \\<not> P h))", "apply (auto \n      intro!: properI \n      intro: relH_in_rangeI \n      dest: properD1 \n      simp: proper_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>(And, Or, True, False, Not) are a Boolean algebra. \n    Due to idiosyncrasies of the Isabelle/HOL class setup, we have to\n    also define a difference and an ordering:\\<close>"], ["", "definition less_eq_assn where\n  [simp]: \"(a::assn) \\<le> b \\<equiv> a = inf a b\""], ["", "definition less_assn where\n  [simp]: \"(a::assn) < b \\<equiv> a \\<le> b \\<and> a\\<noteq>b\""], ["", "definition minus_assn where\n  [simp]: \"(a::assn) - b \\<equiv> inf a (-b)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(assn, boolean_algebra_class)", "apply standard"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. inf x y \\<le> x\n 6. \\<And>x y. inf x y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 8. \\<And>x y. x \\<le> sup x y\n 9. \\<And>y x. y \\<le> sup x y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> sup y z \\<le> x\nA total of 16 subgoals...", "unfolding \n      top_assn_def bot_assn_def sup_assn_def inf_assn_def uminus_assn_def\n      less_eq_assn_def less_assn_def minus_assn_def"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y.\n       (x =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y) \\<and>\n        x \\<noteq> y) =\n       (x =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y) \\<and>\n        y \\<noteq>\n        Abs_assn (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> x))\n 2. \\<And>x.\n       x = Abs_assn (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> x)\n 3. \\<And>x y z.\n       \\<lbrakk>x =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y);\n        y =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> x \\<and> h \\<Turnstile> z)\n 4. \\<And>x y.\n       \\<lbrakk>x =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y);\n        y =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> x)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y.\n       Abs_assn (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y) =\n       Abs_assn\n        (\\<lambda>h.\n            h \\<Turnstile>\n            Abs_assn\n             (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y) \\<and>\n            h \\<Turnstile> x)\n 6. \\<And>x y.\n       Abs_assn (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y) =\n       Abs_assn\n        (\\<lambda>h.\n            h \\<Turnstile>\n            Abs_assn\n             (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y) \\<and>\n            h \\<Turnstile> y)\n 7. \\<And>x y z.\n       \\<lbrakk>x =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y);\n        x =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> x \\<and>\n                              h \\<Turnstile>\n                              Abs_assn\n                               (\\<lambda>h.\n                                   h \\<Turnstile> y \\<and>\n                                   h \\<Turnstile> z))\n 8. \\<And>x y.\n       x =\n       Abs_assn\n        (\\<lambda>h.\n            h \\<Turnstile> x \\<and>\n            h \\<Turnstile>\n            Abs_assn (\\<lambda>h. h \\<Turnstile> x \\<or> h \\<Turnstile> y))\n 9. \\<And>y x.\n       y =\n       Abs_assn\n        (\\<lambda>h.\n            h \\<Turnstile> y \\<and>\n            h \\<Turnstile>\n            Abs_assn (\\<lambda>h. h \\<Turnstile> x \\<or> h \\<Turnstile> y))\n 10. \\<And>y x z.\n        \\<lbrakk>y =\n                 Abs_assn\n                  (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> x);\n         z =\n         Abs_assn\n          (\\<lambda>h. h \\<Turnstile> z \\<and> h \\<Turnstile> x)\\<rbrakk>\n        \\<Longrightarrow> Abs_assn\n                           (\\<lambda>h.\n                               h \\<Turnstile> y \\<or> h \\<Turnstile> z) =\n                          Abs_assn\n                           (\\<lambda>h.\n                               h \\<Turnstile>\n                               Abs_assn\n                                (\\<lambda>h.\n                                    h \\<Turnstile> y \\<or>\n                                    h \\<Turnstile> z) \\<and>\n                               h \\<Turnstile> x)\nA total of 16 subgoals...", "apply (auto \n      simp: Abs_assn_inverse conj_commute conj_ac \n      intro: Abs_assn_eqI models_in_range)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y);\n        y =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> x \\<and> h \\<Turnstile> z)\n 2. \\<And>x y z.\n       \\<lbrakk>x =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y);\n        x =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> x \\<and>\n                              h \\<Turnstile> y \\<and> h \\<Turnstile> z)\n 3. \\<And>y x z.\n       \\<lbrakk>y =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> x);\n        z =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> y \\<or> h \\<Turnstile> z) =\n                         Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> x \\<and>\n                              (h \\<Turnstile> y \\<or> h \\<Turnstile> z))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z h.\n       \\<lbrakk>x =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y);\n        y =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> (h \\<Turnstile> x \\<and> h \\<Turnstile> z) =\n                         (h \\<Turnstile> x)\n 2. \\<And>x y z.\n       \\<lbrakk>x =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y);\n        x =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> x \\<and>\n                              h \\<Turnstile> y \\<and> h \\<Turnstile> z)\n 3. \\<And>y x z.\n       \\<lbrakk>y =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> x);\n        z =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> y \\<or> h \\<Turnstile> z) =\n                         Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> x \\<and>\n                              (h \\<Turnstile> y \\<or> h \\<Turnstile> z))", "apply (metis (mono_tags) Abs_assn_inverse[unfolded mem_Collect_eq]\n      Rep_assn[unfolded mem_Collect_eq] bool_assn_proper(4))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y);\n        x =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> x \\<and>\n                              h \\<Turnstile> y \\<and> h \\<Turnstile> z)\n 2. \\<And>y x z.\n       \\<lbrakk>y =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> x);\n        z =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> y \\<or> h \\<Turnstile> z) =\n                         Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> x \\<and>\n                              (h \\<Turnstile> y \\<or> h \\<Turnstile> z))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z h.\n       \\<lbrakk>x =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> y);\n        x =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> (h \\<Turnstile> x \\<and>\n                          h \\<Turnstile> y \\<and> h \\<Turnstile> z) =\n                         (h \\<Turnstile> x)\n 2. \\<And>y x z.\n       \\<lbrakk>y =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> x);\n        z =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> y \\<or> h \\<Turnstile> z) =\n                         Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> x \\<and>\n                              (h \\<Turnstile> y \\<or> h \\<Turnstile> z))", "apply (metis (mono_tags)\n      Abs_assn_inverse[unfolded mem_Collect_eq]\n      Rep_assn[unfolded mem_Collect_eq] bool_assn_proper(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>y =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> x);\n        z =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> y \\<or> h \\<Turnstile> z) =\n                         Abs_assn\n                          (\\<lambda>h.\n                              h \\<Turnstile> x \\<and>\n                              (h \\<Turnstile> y \\<or> h \\<Turnstile> z))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x z h.\n       \\<lbrakk>y =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> x);\n        z =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> (h \\<Turnstile> x \\<and>\n                          (h \\<Turnstile> y \\<or> h \\<Turnstile> z)) =\n                         (h \\<Turnstile>\n                          Abs_assn\n                           (\\<lambda>h.\n                               h \\<Turnstile> y \\<or> h \\<Turnstile> z))", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x z h.\n       \\<lbrakk>y =\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> y \\<and> h \\<Turnstile> x);\n        z =\n        Abs_assn\n         (\\<lambda>h. h \\<Turnstile> x \\<and> h \\<Turnstile> z)\\<rbrakk>\n       \\<Longrightarrow> (h \\<Turnstile> x \\<and>\n                          (h \\<Turnstile> y \\<or> h \\<Turnstile> z)) =\n                         (h \\<Turnstile> y \\<or> h \\<Turnstile> z)", "apply (metis (mono_tags) \n      Abs_assn_inverse[unfolded mem_Collect_eq] \n      Rep_assn[unfolded mem_Collect_eq] bool_assn_proper(4))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>We give the operations some more standard names\\<close>"], ["", "abbreviation top_assn::assn (\"true\") where \"top_assn \\<equiv> top\""], ["", "abbreviation bot_assn::assn (\"false\") where \"bot_assn \\<equiv> bot\""], ["", "abbreviation sup_assn::\"assn\\<Rightarrow>assn\\<Rightarrow>assn\" (infixr \"\\<or>\\<^sub>A\" 61) \n  where \"sup_assn \\<equiv> sup\""], ["", "abbreviation inf_assn::\"assn\\<Rightarrow>assn\\<Rightarrow>assn\" (infixr \"\\<and>\\<^sub>A\" 62) \n  where \"inf_assn \\<equiv> inf\""], ["", "abbreviation uminus_assn::\"assn \\<Rightarrow> assn\" (\"\\<not>\\<^sub>A _\" [81] 80) \n  where \"uminus_assn \\<equiv> uminus\""], ["", "text \\<open>Now we prove some relations between the Boolean algebra operations\n  and the (empty heap,separation conjunction) monoid\\<close>"], ["", "lemma star_false_left[simp]: \"false * P = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. false * P = false", "unfolding times_assn_def bot_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (times_assn_raw (Rep_assn (Abs_assn (\\<lambda>_. False)))\n       (Rep_assn P)) =\n    Abs_assn (\\<lambda>_. False)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       False =\n       (h \\<Turnstile>\n        Abs_assn\n         (times_assn_raw (Rep_assn (Abs_assn (\\<lambda>_. False)))\n           (Rep_assn P)))", "apply (auto simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma star_false_right[simp]: \"P * false = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * false = false", "using star_false_left"], ["proof (prove)\nusing this:\n  false * ?P = false\n\ngoal (1 subgoal):\n 1. P * false = false", "by (simp add: assn_times_comm)"], ["", "lemmas star_false = star_false_left star_false_right"], ["", "lemma assn_basic_inequalities[simp, intro!]:\n  \"true \\<noteq> emp\" \"emp \\<noteq> true\"\n  \"false \\<noteq> emp\" \"emp \\<noteq> false\"\n  \"true \\<noteq> false\" \"false \\<noteq> true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true \\<noteq> emp &&& emp \\<noteq> true &&& false \\<noteq> emp) &&&\n    emp \\<noteq> false &&& true \\<noteq> false &&& false \\<noteq> true", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. true \\<noteq> emp", "unfolding one_assn_def top_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn in_range \\<noteq> Abs_assn one_assn_raw", "proof (subst Abs_assn_inject; simp?)"], ["proof (state)\ngoal (1 subgoal):\n 1. in_range \\<noteq> one_assn_raw", "have \"in_range (\\<lparr>arrays = (\\<lambda>_ _. []), refs = (\\<lambda>_ _. 0), lim = 1\\<rparr>,{0})\" (is \"in_range ?h\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_range\n     (\\<lparr>arrays = \\<lambda>_ _. [], refs = \\<lambda>_ _. 0,\n         lim = 1\\<rparr>,\n      {0})", "by (auto simp: in_range.simps)"], ["proof (state)\nthis:\n  in_range\n   (\\<lparr>arrays = \\<lambda>_ _. [], refs = \\<lambda>_ _. 0,\n       lim = 1\\<rparr>,\n    {0})\n\ngoal (1 subgoal):\n 1. in_range \\<noteq> one_assn_raw", "moreover"], ["proof (state)\nthis:\n  in_range\n   (\\<lparr>arrays = \\<lambda>_ _. [], refs = \\<lambda>_ _. 0,\n       lim = 1\\<rparr>,\n    {0})\n\ngoal (1 subgoal):\n 1. in_range \\<noteq> one_assn_raw", "have \"\\<not>one_assn_raw ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> one_assn_raw\n            (\\<lparr>arrays = \\<lambda>_ _. [], refs = \\<lambda>_ _. 0,\n                lim = 1\\<rparr>,\n             {0})", "by auto"], ["proof (state)\nthis:\n  \\<not> one_assn_raw\n          (\\<lparr>arrays = \\<lambda>_ _. [], refs = \\<lambda>_ _. 0,\n              lim = 1\\<rparr>,\n           {0})\n\ngoal (1 subgoal):\n 1. in_range \\<noteq> one_assn_raw", "ultimately"], ["proof (chain)\npicking this:\n  in_range\n   (\\<lparr>arrays = \\<lambda>_ _. [], refs = \\<lambda>_ _. 0,\n       lim = 1\\<rparr>,\n    {0})\n  \\<not> one_assn_raw\n          (\\<lparr>arrays = \\<lambda>_ _. [], refs = \\<lambda>_ _. 0,\n              lim = 1\\<rparr>,\n           {0})", "show \"in_range \\<noteq> one_assn_raw\""], ["proof (prove)\nusing this:\n  in_range\n   (\\<lparr>arrays = \\<lambda>_ _. [], refs = \\<lambda>_ _. 0,\n       lim = 1\\<rparr>,\n    {0})\n  \\<not> one_assn_raw\n          (\\<lparr>arrays = \\<lambda>_ _. [], refs = \\<lambda>_ _. 0,\n              lim = 1\\<rparr>,\n           {0})\n\ngoal (1 subgoal):\n 1. in_range \\<noteq> one_assn_raw", "by auto"], ["proof (state)\nthis:\n  in_range \\<noteq> one_assn_raw\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (5 subgoals):\n 1. emp \\<noteq> true\n 2. false \\<noteq> emp\n 3. emp \\<noteq> false\n 4. true \\<noteq> false\n 5. false \\<noteq> true", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. emp \\<noteq> true", "by (simp add: \\<open>true \\<noteq> emp\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. false \\<noteq> emp\n 2. emp \\<noteq> false\n 3. true \\<noteq> false\n 4. false \\<noteq> true", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. false \\<noteq> emp", "using star_false_left \\<open>true \\<noteq> emp\\<close>"], ["proof (prove)\nusing this:\n  false * ?P = false\n  true \\<noteq> emp\n\ngoal (1 subgoal):\n 1. false \\<noteq> emp", "by force"], ["proof (prove)\ngoal (3 subgoals):\n 1. emp \\<noteq> false\n 2. true \\<noteq> false\n 3. false \\<noteq> true", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. emp \\<noteq> false", "by (simp add: \\<open>false \\<noteq> emp\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. true \\<noteq> false\n 2. false \\<noteq> true", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. true \\<noteq> false", "by (metis inf_bot_right inf_top.right_neutral \\<open>true \\<noteq> emp\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. false \\<noteq> true", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. false \\<noteq> true", "using \\<open>true \\<noteq> false\\<close>"], ["proof (prove)\nusing this:\n  true \\<noteq> false\n\ngoal (1 subgoal):\n 1. false \\<noteq> true", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Existential Quantification\\<close>"], ["", "definition ex_assn :: \"('a \\<Rightarrow> assn) \\<Rightarrow> assn\" (binder \"\\<exists>\\<^sub>A\" 11)\n  where \"(\\<exists>\\<^sub>Ax. P x) \\<equiv> Abs_assn (\\<lambda>h. \\<exists>x. h\\<Turnstile>P x)\""], ["", "lemma ex_assn_proper[simp, intro!]: \n  \"(\\<And>x. proper (P x)) \\<Longrightarrow> proper (\\<lambda>h. \\<exists>x. P x h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. proper (P x)) \\<Longrightarrow>\n    proper (\\<lambda>h. \\<exists>x. P x h)", "by (auto intro!: properI dest: properD1 simp: proper_iff)"], ["", "lemma ex_assn_const[simp]: \"(\\<exists>\\<^sub>Ax. c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>Ax. c) = c", "unfolding ex_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn (\\<lambda>h. \\<exists>x. h \\<Turnstile> c) = c", "by auto"], ["", "lemma ex_one_point_gen: \n  \"\\<lbrakk>\\<And>h x. h\\<Turnstile>P x \\<Longrightarrow> x=v\\<rbrakk> \\<Longrightarrow> (\\<exists>\\<^sub>Ax. P x) = (P v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h x.\n        h \\<Turnstile> P x \\<Longrightarrow> x = v) \\<Longrightarrow>\n    (\\<exists>\\<^sub>Ax. P x) = P v", "unfolding ex_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h x.\n        h \\<Turnstile> P x \\<Longrightarrow> x = v) \\<Longrightarrow>\n    Abs_assn (\\<lambda>h. \\<exists>x. h \\<Turnstile> P x) = P v", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (\\<And>h x.\n           h \\<Turnstile> P x \\<Longrightarrow> x = v) \\<Longrightarrow>\n       (\\<exists>x. h \\<Turnstile> P x) = (h \\<Turnstile> P v)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ex_distrib_star: \"(\\<exists>\\<^sub>Ax. P x * Q) = (\\<exists>\\<^sub>Ax. P x) * Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>Ax. P x * Q) = (\\<exists>\\<^sub>Ax. P x) * Q", "unfolding ex_assn_def times_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (\\<lambda>h.\n         \\<exists>x.\n            h \\<Turnstile>\n            Abs_assn (times_assn_raw (Rep_assn (P x)) (Rep_assn Q))) =\n    Abs_assn\n     (times_assn_raw\n       (Rep_assn (Abs_assn (\\<lambda>h. \\<exists>x. h \\<Turnstile> P x)))\n       (Rep_assn Q))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       times_assn_raw\n        (Rep_assn (Abs_assn (\\<lambda>h. \\<exists>x. h \\<Turnstile> P x)))\n        (Rep_assn Q) h =\n       (h \\<Turnstile>\n        Abs_assn\n         (\\<lambda>h.\n             \\<exists>x.\n                h \\<Turnstile>\n                Abs_assn (times_assn_raw (Rep_assn (P x)) (Rep_assn Q))))", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       times_assn_raw (\\<lambda>h. \\<exists>x. h \\<Turnstile> P x)\n        (Rep_assn Q) h =\n       (\\<exists>x. times_assn_raw (Rep_assn (P x)) (Rep_assn Q) h)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ex_distrib_and: \"(\\<exists>\\<^sub>Ax. P x \\<and>\\<^sub>A Q) = (\\<exists>\\<^sub>Ax. P x) \\<and>\\<^sub>A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>Ax. P x \\<and>\\<^sub>A Q) =\n    (\\<exists>\\<^sub>Ax. P x) \\<and>\\<^sub>A Q", "unfolding ex_assn_def inf_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (\\<lambda>h.\n         \\<exists>x.\n            h \\<Turnstile>\n            Abs_assn\n             (\\<lambda>h. h \\<Turnstile> P x \\<and> h \\<Turnstile> Q)) =\n    Abs_assn\n     (\\<lambda>h.\n         h \\<Turnstile>\n         Abs_assn (\\<lambda>h. \\<exists>x. h \\<Turnstile> P x) \\<and>\n         h \\<Turnstile> Q)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (h \\<Turnstile>\n        Abs_assn (\\<lambda>h. \\<exists>x. h \\<Turnstile> P x) \\<and>\n        h \\<Turnstile> Q) =\n       (h \\<Turnstile>\n        Abs_assn\n         (\\<lambda>h.\n             \\<exists>x.\n                h \\<Turnstile>\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> P x \\<and> h \\<Turnstile> Q)))", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ex_distrib_or: \"(\\<exists>\\<^sub>Ax. P x \\<or>\\<^sub>A Q) = (\\<exists>\\<^sub>Ax. P x) \\<or>\\<^sub>A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>Ax. P x \\<or>\\<^sub>A Q) =\n    (\\<exists>\\<^sub>Ax. P x) \\<or>\\<^sub>A Q", "unfolding ex_assn_def sup_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (\\<lambda>h.\n         \\<exists>x.\n            h \\<Turnstile>\n            Abs_assn\n             (\\<lambda>h. h \\<Turnstile> P x \\<or> h \\<Turnstile> Q)) =\n    Abs_assn\n     (\\<lambda>h.\n         h \\<Turnstile>\n         Abs_assn (\\<lambda>h. \\<exists>x. h \\<Turnstile> P x) \\<or>\n         h \\<Turnstile> Q)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (h \\<Turnstile>\n        Abs_assn (\\<lambda>h. \\<exists>x. h \\<Turnstile> P x) \\<or>\n        h \\<Turnstile> Q) =\n       (h \\<Turnstile>\n        Abs_assn\n         (\\<lambda>h.\n             \\<exists>x.\n                h \\<Turnstile>\n                Abs_assn\n                 (\\<lambda>h. h \\<Turnstile> P x \\<or> h \\<Turnstile> Q)))", "apply (auto simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ex_join_or: \"(\\<exists>\\<^sub>Ax. P x \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. Q x)) = (\\<exists>\\<^sub>Ax. P x \\<or>\\<^sub>A Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>Ax. P x \\<or>\\<^sub>A (\\<exists>\\<^sub>Ax. Q x)) =\n    (\\<exists>\\<^sub>Ax. P x \\<or>\\<^sub>A Q x)", "unfolding ex_assn_def sup_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (\\<lambda>h.\n         \\<exists>x.\n            h \\<Turnstile>\n            Abs_assn\n             (\\<lambda>h.\n                 h \\<Turnstile> P x \\<or>\n                 h \\<Turnstile>\n                 Abs_assn (\\<lambda>h. \\<exists>x. h \\<Turnstile> Q x))) =\n    Abs_assn\n     (\\<lambda>h.\n         \\<exists>x.\n            h \\<Turnstile>\n            Abs_assn\n             (\\<lambda>h. h \\<Turnstile> P x \\<or> h \\<Turnstile> Q x))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (\\<exists>x.\n           h \\<Turnstile>\n           Abs_assn\n            (\\<lambda>h. h \\<Turnstile> P x \\<or> h \\<Turnstile> Q x)) =\n       (h \\<Turnstile>\n        Abs_assn\n         (\\<lambda>h.\n             \\<exists>x.\n                h \\<Turnstile>\n                Abs_assn\n                 (\\<lambda>h.\n                     h \\<Turnstile> P x \\<or>\n                     h \\<Turnstile>\n                     Abs_assn\n                      (\\<lambda>h. \\<exists>x. h \\<Turnstile> Q x))))", "apply (auto simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Pure Assertions\\<close>"], ["", "text \\<open>Pure assertions do not depend on any heap content.\\<close>"], ["", "fun pure_assn_raw where \"pure_assn_raw b (h,as) \\<longleftrightarrow> as={} \\<and> b\""], ["", "definition pure_assn :: \"bool \\<Rightarrow> assn\" (\"\\<up>\") where\n  \"\\<up>b \\<equiv> Abs_assn (pure_assn_raw b)\""], ["", "lemma pure_assn_proper[simp, intro!]: \"proper (pure_assn_raw b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper (pure_assn_raw b)", "by (auto intro!: properI intro: relH_in_rangeI)"], ["", "lemma pure_true[simp]: \"\\<up>True = emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> True = emp", "unfolding pure_assn_def one_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn (pure_assn_raw True) = Abs_assn one_assn_raw", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. one_assn_raw h = (h \\<Turnstile> Abs_assn (pure_assn_raw True))", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. one_assn_raw h = pure_assn_raw True h", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pure_false[simp]: \"\\<up>False = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> False = false", "unfolding pure_assn_def bot_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn (pure_assn_raw False) = Abs_assn (\\<lambda>_. False)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. False = (h \\<Turnstile> Abs_assn (pure_assn_raw False))", "apply (auto simp: Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pure_assn_eq_false_iff[simp]: \"\\<up>P = false \\<longleftrightarrow> \\<not>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<up> P = false) = (\\<not> P)", "by auto"], ["", "lemma pure_assn_eq_emp_iff[simp]: \"\\<up>P = emp \\<longleftrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<up> P = emp) = P", "by (cases P) auto"], ["", "lemma merge_pure_star[simp]: \n  \"\\<up>a * \\<up>b = \\<up>(a\\<and>b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> a * \\<up> b = \\<up> (a \\<and> b)", "unfolding times_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn (times_assn_raw (Rep_assn (\\<up> a)) (Rep_assn (\\<up> b))) =\n    \\<up> (a \\<and> b)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       times_assn_raw (Rep_assn (\\<up> a)) (Rep_assn (\\<up> b)) h =\n       (h \\<Turnstile> \\<up> (a \\<and> b))", "unfolding pure_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       times_assn_raw (Rep_assn (Abs_assn (pure_assn_raw a)))\n        (Rep_assn (Abs_assn (pure_assn_raw b))) h =\n       (h \\<Turnstile> Abs_assn (pure_assn_raw (a \\<and> b)))", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       times_assn_raw (pure_assn_raw a) (pure_assn_raw b) h =\n       pure_assn_raw (a \\<and> b) h", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma merge_true_star[simp]: \"true*true = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true * true = true", "unfolding times_assn_def top_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (times_assn_raw (Rep_assn (Abs_assn in_range))\n       (Rep_assn (Abs_assn in_range))) =\n    Abs_assn in_range", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       in_range h =\n       (h \\<Turnstile>\n        Abs_assn\n         (times_assn_raw (Rep_assn (Abs_assn in_range))\n           (Rep_assn (Abs_assn in_range))))", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. in_range h = times_assn_raw in_range in_range h", "apply (fastforce simp: in_range.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma merge_pure_and[simp]:\n  \"\\<up>a \\<and>\\<^sub>A \\<up>b = \\<up>(a\\<and>b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> a \\<and>\\<^sub>A \\<up> b = \\<up> (a \\<and> b)", "unfolding inf_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (\\<lambda>h. h \\<Turnstile> \\<up> a \\<and> h \\<Turnstile> \\<up> b) =\n    \\<up> (a \\<and> b)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (h \\<Turnstile> \\<up> a \\<and> h \\<Turnstile> \\<up> b) =\n       (h \\<Turnstile> \\<up> (a \\<and> b))", "unfolding pure_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (h \\<Turnstile> Abs_assn (pure_assn_raw a) \\<and>\n        h \\<Turnstile> Abs_assn (pure_assn_raw b)) =\n       (h \\<Turnstile> Abs_assn (pure_assn_raw (a \\<and> b)))", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (pure_assn_raw a h \\<and> pure_assn_raw b h) =\n       pure_assn_raw (a \\<and> b) h", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma merge_pure_or[simp]:\n  \"\\<up>a \\<or>\\<^sub>A \\<up>b = \\<up>(a\\<or>b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> a \\<or>\\<^sub>A \\<up> b = \\<up> (a \\<or> b)", "unfolding sup_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (\\<lambda>h. h \\<Turnstile> \\<up> a \\<or> h \\<Turnstile> \\<up> b) =\n    \\<up> (a \\<or> b)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (h \\<Turnstile> \\<up> a \\<or> h \\<Turnstile> \\<up> b) =\n       (h \\<Turnstile> \\<up> (a \\<or> b))", "unfolding pure_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (h \\<Turnstile> Abs_assn (pure_assn_raw a) \\<or>\n        h \\<Turnstile> Abs_assn (pure_assn_raw b)) =\n       (h \\<Turnstile> Abs_assn (pure_assn_raw (a \\<or> b)))", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (pure_assn_raw a h \\<or> pure_assn_raw b h) =\n       pure_assn_raw (a \\<or> b) h", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pure_assn_eq_conv[simp]: \"\\<up>P = \\<up>Q \\<longleftrightarrow> P=Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<up> P = \\<up> Q) = (P = Q)", "by auto"], ["", "definition \"is_pure_assn a \\<equiv> \\<exists>P. a=\\<up>P\""], ["", "lemma is_pure_assnE: assumes \"is_pure_assn a\" obtains P where \"a=\\<up>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P. a = \\<up> P \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  is_pure_assn a\n\ngoal (1 subgoal):\n 1. (\\<And>P. a = \\<up> P \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: is_pure_assn_def)"], ["", "lemma is_pure_assn_pure[simp, intro!]: \"is_pure_assn (\\<up>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure_assn (\\<up> P)", "by (auto simp add: is_pure_assn_def)"], ["", "lemma is_pure_assn_basic_simps[simp]:\n  \"is_pure_assn false\"\n  \"is_pure_assn emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure_assn false &&& is_pure_assn emp", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. is_pure_assn false\n 2. is_pure_assn emp", "have \"is_pure_assn (\\<up>False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure_assn (\\<up> False)", "by rule"], ["proof (state)\nthis:\n  is_pure_assn (\\<up> False)\n\ngoal (2 subgoals):\n 1. is_pure_assn false\n 2. is_pure_assn emp", "thus \"is_pure_assn false\""], ["proof (prove)\nusing this:\n  is_pure_assn (\\<up> False)\n\ngoal (1 subgoal):\n 1. is_pure_assn false", "by simp"], ["proof (state)\nthis:\n  is_pure_assn false\n\ngoal (1 subgoal):\n 1. is_pure_assn emp", "have \"is_pure_assn (\\<up>True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure_assn (\\<up> True)", "by rule"], ["proof (state)\nthis:\n  is_pure_assn (\\<up> True)\n\ngoal (1 subgoal):\n 1. is_pure_assn emp", "thus \"is_pure_assn emp\""], ["proof (prove)\nusing this:\n  is_pure_assn (\\<up> True)\n\ngoal (1 subgoal):\n 1. is_pure_assn emp", "by simp"], ["proof (state)\nthis:\n  is_pure_assn emp\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_pure_assn_starI[simp,intro!]: \n  \"\\<lbrakk>is_pure_assn a; is_pure_assn b\\<rbrakk> \\<Longrightarrow> is_pure_assn (a*b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_pure_assn a; is_pure_assn b\\<rbrakk>\n    \\<Longrightarrow> is_pure_assn (a * b)", "by (auto elim!: is_pure_assnE)"], ["", "subsubsection \\<open>Pointers\\<close>"], ["", "text \\<open>In Imperative HOL, we have to distinguish between pointers to single\n  values and pointers to arrays. For both, we define assertions that \n  describe the part of the heap that a pointer points to.\\<close>"], ["", "fun sngr_assn_raw :: \"'a::heap ref \\<Rightarrow> 'a \\<Rightarrow> assn_raw\" where\n  \"sngr_assn_raw r x (h,as) \\<longleftrightarrow> Ref.get h r = x \\<and> as = {addr_of_ref r} \\<and> \n  addr_of_ref r < lim h\""], ["", "lemma sngr_assn_proper[simp, intro!]: \"proper (sngr_assn_raw r x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper (sngr_assn_raw r x)", "apply (auto intro!: properI simp: relH_ref)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>addr_of_ref r < lim h; x = Ref.get h r\\<rbrakk>\n       \\<Longrightarrow> in_range (h, {addr_of_ref r})\n 2. \\<And>h h'.\n       \\<lbrakk>relH {addr_of_ref r} h h'; in_range (h', {addr_of_ref r});\n        addr_of_ref r < lim h; x = Ref.get h' r\\<rbrakk>\n       \\<Longrightarrow> addr_of_ref r < lim h'", "apply (simp add: in_range.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>relH {addr_of_ref r} h h'; in_range (h', {addr_of_ref r});\n        addr_of_ref r < lim h; x = Ref.get h' r\\<rbrakk>\n       \\<Longrightarrow> addr_of_ref r < lim h'", "apply (auto simp add: in_range.simps dest: relH_in_rangeI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition sngr_assn :: \"'a::heap ref \\<Rightarrow> 'a \\<Rightarrow> assn\" (infix \"\\<mapsto>\\<^sub>r\" 82) \n  where \"r\\<mapsto>\\<^sub>rx \\<equiv> Abs_assn (sngr_assn_raw r x)\""], ["", "fun snga_assn_raw :: \"'a::heap array \\<Rightarrow> 'a list \\<Rightarrow> assn_raw\" \n  where \"snga_assn_raw r x (h,as) \n  \\<longleftrightarrow> Array.get h r = x \\<and> as = {addr_of_array r} \n      \\<and> addr_of_array r < lim h\""], ["", "lemma snga_assn_proper[simp, intro!]: \"proper (snga_assn_raw r x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper (snga_assn_raw r x)", "apply (auto intro!: properI simp: relH_array)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>addr_of_array r < lim h; x = Array.get h r\\<rbrakk>\n       \\<Longrightarrow> in_range (h, {addr_of_array r})\n 2. \\<And>h h'.\n       \\<lbrakk>relH {addr_of_array r} h h';\n        in_range (h', {addr_of_array r}); addr_of_array r < lim h;\n        x = Array.get h' r\\<rbrakk>\n       \\<Longrightarrow> addr_of_array r < lim h'", "apply (simp add: in_range.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>relH {addr_of_array r} h h';\n        in_range (h', {addr_of_array r}); addr_of_array r < lim h;\n        x = Array.get h' r\\<rbrakk>\n       \\<Longrightarrow> addr_of_array r < lim h'", "apply (auto simp add: in_range.simps dest: relH_in_rangeI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \n  snga_assn :: \"'a::heap array \\<Rightarrow> 'a list \\<Rightarrow> assn\" (infix \"\\<mapsto>\\<^sub>a\" 82)\n  where \"r\\<mapsto>\\<^sub>aa \\<equiv> Abs_assn (snga_assn_raw r a)\""], ["", "text \\<open>Two disjoint parts of the heap cannot be pointed to by the \n  same pointer\\<close>"], ["", "lemma sngr_same_false[simp]: \n  \"p \\<mapsto>\\<^sub>r x * p \\<mapsto>\\<^sub>r y = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<mapsto>\\<^sub>r x * p \\<mapsto>\\<^sub>r y = false", "unfolding times_assn_def bot_assn_def sngr_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (times_assn_raw (Rep_assn (Abs_assn (sngr_assn_raw p x)))\n       (Rep_assn (Abs_assn (sngr_assn_raw p y)))) =\n    Abs_assn (\\<lambda>_. False)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       False =\n       (h \\<Turnstile>\n        Abs_assn\n         (times_assn_raw (Rep_assn (Abs_assn (sngr_assn_raw p x)))\n           (Rep_assn (Abs_assn (sngr_assn_raw p y)))))", "apply (auto simp: Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma snga_same_false[simp]: \n  \"p \\<mapsto>\\<^sub>a x * p \\<mapsto>\\<^sub>a y = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<mapsto>\\<^sub>a x * p \\<mapsto>\\<^sub>a y = false", "unfolding times_assn_def bot_assn_def snga_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_assn\n     (times_assn_raw (Rep_assn (Abs_assn (snga_assn_raw p x)))\n       (Rep_assn (Abs_assn (snga_assn_raw p y)))) =\n    Abs_assn (\\<lambda>_. False)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       False =\n       (h \\<Turnstile>\n        Abs_assn\n         (times_assn_raw (Rep_assn (Abs_assn (snga_assn_raw p x)))\n           (Rep_assn (Abs_assn (snga_assn_raw p y)))))", "apply (auto simp: Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Properties of the Models-Predicate\\<close>"], ["", "lemma mod_true[simp]: \"h\\<Turnstile>true \\<longleftrightarrow> in_range h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> true) = in_range h", "unfolding top_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> Abs_assn in_range) = in_range h", "by (simp add: Abs_assn_inverse)"], ["", "lemma mod_false[simp]: \"\\<not> h\\<Turnstile>false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> h \\<Turnstile> false", "unfolding bot_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> h \\<Turnstile> Abs_assn (\\<lambda>_. False)", "by (simp add: Abs_assn_inverse)"], ["", "lemma mod_emp: \"h\\<Turnstile>emp \\<longleftrightarrow> snd h = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> emp) = (snd h = {})", "unfolding one_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> Abs_assn one_assn_raw) = (snd h = {})", "by (cases h) (simp add: Abs_assn_inverse)"], ["", "lemma mod_emp_simp[simp]: \"(h,{})\\<Turnstile>emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h, {}) \\<Turnstile> emp", "by (simp add: mod_emp)"], ["", "lemma mod_pure[simp]: \"h\\<Turnstile>\\<up>b \\<longleftrightarrow> snd h = {} \\<and> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> \\<up> b) = (snd h = {} \\<and> b)", "unfolding pure_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> Abs_assn (pure_assn_raw b)) = (snd h = {} \\<and> b)", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba.\n       h = (a, ba) \\<Longrightarrow>\n       (h \\<Turnstile> Abs_assn (pure_assn_raw b)) = (snd h = {} \\<and> b)", "apply (auto simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mod_ex_dist[simp]: \"h\\<Turnstile>(\\<exists>\\<^sub>Ax. P x) \\<longleftrightarrow> (\\<exists>x. h\\<Turnstile>P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> (\\<exists>\\<^sub>Ax. P x)) =\n    (\\<exists>x. h \\<Turnstile> P x)", "unfolding ex_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> Abs_assn (\\<lambda>h. \\<exists>x. h \\<Turnstile> P x)) =\n    (\\<exists>x. h \\<Turnstile> P x)", "by (auto simp: Abs_assn_inverse)"], ["", "lemma mod_exI: \"\\<exists>x. h\\<Turnstile>P x \\<Longrightarrow> h\\<Turnstile>(\\<exists>\\<^sub>Ax. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. h \\<Turnstile> P x \\<Longrightarrow>\n    h \\<Turnstile> (\\<exists>\\<^sub>Ax. P x)", "by (auto simp: mod_ex_dist)"], ["", "lemma mod_exE: assumes \"h\\<Turnstile>(\\<exists>\\<^sub>Ax. P x)\" obtains x where \"h\\<Turnstile>P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. h \\<Turnstile> P x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<Turnstile> (\\<exists>\\<^sub>Ax. P x)\n\ngoal (1 subgoal):\n 1. (\\<And>x. h \\<Turnstile> P x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: mod_ex_dist)"], ["", "(* Not declared as simp, to not interfere with precision.\n  TODO: Perhaps define own connector for precision claims?\n*)"], ["", "lemma mod_and_dist: \"h\\<Turnstile>P\\<and>\\<^sub>AQ \\<longleftrightarrow> h\\<Turnstile>P \\<and> h\\<Turnstile>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> P \\<and>\\<^sub>A Q) =\n    (h \\<Turnstile> P \\<and> h \\<Turnstile> Q)", "unfolding inf_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile>\n     Abs_assn (\\<lambda>h. h \\<Turnstile> P \\<and> h \\<Turnstile> Q)) =\n    (h \\<Turnstile> P \\<and> h \\<Turnstile> Q)", "by (simp add: Abs_assn_inverse)"], ["", "lemma mod_or_dist[simp]: \"h\\<Turnstile>P\\<or>\\<^sub>AQ \\<longleftrightarrow> h\\<Turnstile>P \\<or> h\\<Turnstile>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> P \\<or>\\<^sub>A Q) =\n    (h \\<Turnstile> P \\<or> h \\<Turnstile> Q)", "unfolding sup_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile>\n     Abs_assn (\\<lambda>h. h \\<Turnstile> P \\<or> h \\<Turnstile> Q)) =\n    (h \\<Turnstile> P \\<or> h \\<Turnstile> Q)", "by (simp add: Abs_assn_inverse)"], ["", "lemma mod_not_dist[simp]: \"h\\<Turnstile>(\\<not>\\<^sub>AP) \\<longleftrightarrow> in_range h \\<and> \\<not> h\\<Turnstile>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> \\<not>\\<^sub>A P) =\n    (in_range h \\<and> \\<not> h \\<Turnstile> P)", "unfolding uminus_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile>\n     Abs_assn (\\<lambda>h. in_range h \\<and> \\<not> h \\<Turnstile> P)) =\n    (in_range h \\<and> \\<not> h \\<Turnstile> P)", "by (simp add: Abs_assn_inverse)"], ["", "lemma mod_pure_star_dist[simp]: \"h\\<Turnstile>P*\\<up>b \\<longleftrightarrow> h\\<Turnstile>P \\<and> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<Turnstile> P * \\<up> b) = (h \\<Turnstile> P \\<and> b)", "by (metis (full_types) mod_false mult_1_right pure_false \n    pure_true star_false_right)"], ["", "lemmas mod_dist = mod_pure mod_pure_star_dist mod_ex_dist mod_and_dist\n  mod_or_dist mod_not_dist"], ["", "lemma mod_star_trueI: \"h\\<Turnstile>P \\<Longrightarrow> h\\<Turnstile>P*true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> P \\<Longrightarrow> h \\<Turnstile> P * true", "unfolding times_assn_def top_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> P \\<Longrightarrow>\n    h \\<Turnstile>\n    Abs_assn (times_assn_raw (Rep_assn P) (Rep_assn (Abs_assn in_range)))", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> P \\<Longrightarrow>\n    times_assn_raw (Rep_assn P) in_range h", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>h \\<Turnstile> P; h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> times_assn_raw (Rep_assn P) in_range h", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mod_star_trueE': assumes \"h\\<Turnstile>P*true\" obtains h' where \n  \"fst h' = fst h\" and \"snd h' \\<subseteq> snd h\" and \"h'\\<Turnstile>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h'.\n        \\<lbrakk>fst h' = fst h; snd h' \\<subseteq> snd h;\n         h' \\<Turnstile> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<Turnstile> P * true\n\ngoal (1 subgoal):\n 1. (\\<And>h'.\n        \\<lbrakk>fst h' = fst h; snd h' \\<subseteq> snd h;\n         h' \\<Turnstile> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding times_assn_def top_assn_def"], ["proof (prove)\nusing this:\n  h \\<Turnstile>\n  Abs_assn (times_assn_raw (Rep_assn P) (Rep_assn (Abs_assn in_range)))\n\ngoal (1 subgoal):\n 1. (\\<And>h'.\n        \\<lbrakk>fst h' = fst h; snd h' \\<subseteq> snd h;\n         h' \\<Turnstile> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>h'.\n                   \\<lbrakk>fst h' = fst h; snd h' \\<subseteq> snd h;\n                    h' \\<Turnstile> P\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        h \\<Turnstile>\n        Abs_assn\n         (times_assn_raw (Rep_assn P) (Rep_assn (Abs_assn in_range)));\n        h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (fastforce simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mod_star_trueE: assumes \"h\\<Turnstile>P*true\" obtains h' where \"h'\\<Turnstile>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h'. h' \\<Turnstile> P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<Turnstile> P * true\n\ngoal (1 subgoal):\n 1. (\\<And>h'. h' \\<Turnstile> P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim: mod_star_trueE')"], ["", "lemma mod_h_bot_iff[simp]:\n  \"(h,{}) \\<Turnstile> \\<up>b \\<longleftrightarrow> b\"\n  \"(h,{}) \\<Turnstile> true\"\n  \"(h,{}) \\<Turnstile> p\\<mapsto>\\<^sub>rx \\<longleftrightarrow> False\"\n  \"(h,{}) \\<Turnstile> q\\<mapsto>\\<^sub>ay \\<longleftrightarrow> False\"\n  \"(h,{}) \\<Turnstile> P*Q \\<longleftrightarrow> ((h,{}) \\<Turnstile> P) \\<and> ((h,{}) \\<Turnstile> Q)\"\n  \"(h,{}) \\<Turnstile> P\\<and>\\<^sub>AQ \\<longleftrightarrow> ((h,{}) \\<Turnstile> P) \\<and> ((h,{}) \\<Turnstile> Q)\"\n  \"(h,{}) \\<Turnstile> P\\<or>\\<^sub>AQ \\<longleftrightarrow> ((h,{}) \\<Turnstile> P) \\<or> ((h,{}) \\<Turnstile> Q)\"\n  \"(h,{}) \\<Turnstile> (\\<exists>\\<^sub>Ax. R x) \\<longleftrightarrow> (\\<exists>x. (h,{}) \\<Turnstile> R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((h, {}) \\<Turnstile> \\<up> b) = b &&& (h, {}) \\<Turnstile> true) &&&\n     ((h, {}) \\<Turnstile> p \\<mapsto>\\<^sub>r x) = False &&&\n     ((h, {}) \\<Turnstile> q \\<mapsto>\\<^sub>a y) = False) &&&\n    (((h, {}) \\<Turnstile> P * Q) =\n     ((h, {}) \\<Turnstile> P \\<and> (h, {}) \\<Turnstile> Q) &&&\n     ((h, {}) \\<Turnstile> P \\<and>\\<^sub>A Q) =\n     ((h, {}) \\<Turnstile> P \\<and> (h, {}) \\<Turnstile> Q)) &&&\n    ((h, {}) \\<Turnstile> P \\<or>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<or> (h, {}) \\<Turnstile> Q) &&&\n    ((h, {}) \\<Turnstile> (\\<exists>\\<^sub>Ax. R x)) =\n    (\\<exists>x. (h, {}) \\<Turnstile> R x)", "apply (simp add: pure_assn_def Abs_assn_inverse)"], ["proof (prove)\ngoal (7 subgoals):\n 1. (h, {}) \\<Turnstile> true\n 2. ((h, {}) \\<Turnstile> p \\<mapsto>\\<^sub>r x) = False\n 3. ((h, {}) \\<Turnstile> q \\<mapsto>\\<^sub>a y) = False\n 4. ((h, {}) \\<Turnstile> P * Q) =\n    ((h, {}) \\<Turnstile> P \\<and> (h, {}) \\<Turnstile> Q)\n 5. ((h, {}) \\<Turnstile> P \\<and>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<and> (h, {}) \\<Turnstile> Q)\n 6. ((h, {}) \\<Turnstile> P \\<or>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<or> (h, {}) \\<Turnstile> Q)\n 7. ((h, {}) \\<Turnstile> (\\<exists>\\<^sub>Ax. R x)) =\n    (\\<exists>x. (h, {}) \\<Turnstile> R x)", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. ((h, {}) \\<Turnstile> p \\<mapsto>\\<^sub>r x) = False\n 2. ((h, {}) \\<Turnstile> q \\<mapsto>\\<^sub>a y) = False\n 3. ((h, {}) \\<Turnstile> P * Q) =\n    ((h, {}) \\<Turnstile> P \\<and> (h, {}) \\<Turnstile> Q)\n 4. ((h, {}) \\<Turnstile> P \\<and>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<and> (h, {}) \\<Turnstile> Q)\n 5. ((h, {}) \\<Turnstile> P \\<or>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<or> (h, {}) \\<Turnstile> Q)\n 6. ((h, {}) \\<Turnstile> (\\<exists>\\<^sub>Ax. R x)) =\n    (\\<exists>x. (h, {}) \\<Turnstile> R x)", "apply (simp add: sngr_assn_def Abs_assn_inverse)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ((h, {}) \\<Turnstile> q \\<mapsto>\\<^sub>a y) = False\n 2. ((h, {}) \\<Turnstile> P * Q) =\n    ((h, {}) \\<Turnstile> P \\<and> (h, {}) \\<Turnstile> Q)\n 3. ((h, {}) \\<Turnstile> P \\<and>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<and> (h, {}) \\<Turnstile> Q)\n 4. ((h, {}) \\<Turnstile> P \\<or>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<or> (h, {}) \\<Turnstile> Q)\n 5. ((h, {}) \\<Turnstile> (\\<exists>\\<^sub>Ax. R x)) =\n    (\\<exists>x. (h, {}) \\<Turnstile> R x)", "apply (simp add: snga_assn_def Abs_assn_inverse)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ((h, {}) \\<Turnstile> P * Q) =\n    ((h, {}) \\<Turnstile> P \\<and> (h, {}) \\<Turnstile> Q)\n 2. ((h, {}) \\<Turnstile> P \\<and>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<and> (h, {}) \\<Turnstile> Q)\n 3. ((h, {}) \\<Turnstile> P \\<or>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<or> (h, {}) \\<Turnstile> Q)\n 4. ((h, {}) \\<Turnstile> (\\<exists>\\<^sub>Ax. R x)) =\n    (\\<exists>x. (h, {}) \\<Turnstile> R x)", "apply (simp add: times_assn_def Abs_assn_inverse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((h, {}) \\<Turnstile> P \\<and>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<and> (h, {}) \\<Turnstile> Q)\n 2. ((h, {}) \\<Turnstile> P \\<or>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<or> (h, {}) \\<Turnstile> Q)\n 3. ((h, {}) \\<Turnstile> (\\<exists>\\<^sub>Ax. R x)) =\n    (\\<exists>x. (h, {}) \\<Turnstile> R x)", "apply (simp add: inf_assn_def Abs_assn_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((h, {}) \\<Turnstile> P \\<or>\\<^sub>A Q) =\n    ((h, {}) \\<Turnstile> P \\<or> (h, {}) \\<Turnstile> Q)\n 2. ((h, {}) \\<Turnstile> (\\<exists>\\<^sub>Ax. R x)) =\n    (\\<exists>x. (h, {}) \\<Turnstile> R x)", "apply (simp add: sup_assn_def Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((h, {}) \\<Turnstile> (\\<exists>\\<^sub>Ax. R x)) =\n    (\\<exists>x. (h, {}) \\<Turnstile> R x)", "apply (simp add: ex_assn_def Abs_assn_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Entailment\\<close>"], ["", "definition entails :: \"assn \\<Rightarrow> assn \\<Rightarrow> bool\" (infix \"\\<Longrightarrow>\\<^sub>A\" 10)\n  where \"P \\<Longrightarrow>\\<^sub>A Q \\<equiv> \\<forall>h. h\\<Turnstile>P \\<longrightarrow> h\\<Turnstile>Q\""], ["", "lemma entailsI: \n  assumes \"\\<And>h. h\\<Turnstile>P \\<Longrightarrow> h\\<Turnstile>Q\"\n  shows \"P \\<Longrightarrow>\\<^sub>A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A Q", "using assms"], ["proof (prove)\nusing this:\n  ?h \\<Turnstile> P \\<Longrightarrow> ?h \\<Turnstile> Q\n\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A Q", "unfolding entails_def"], ["proof (prove)\nusing this:\n  ?h \\<Turnstile> P \\<Longrightarrow> ?h \\<Turnstile> Q\n\ngoal (1 subgoal):\n 1. \\<forall>h. h \\<Turnstile> P \\<longrightarrow> h \\<Turnstile> Q", "by auto"], ["", "lemma entailsD: \n  assumes \"P \\<Longrightarrow>\\<^sub>A Q\"\n  assumes \"h\\<Turnstile>P\"\n  shows \"h\\<Turnstile>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> Q", "using assms"], ["proof (prove)\nusing this:\n  P \\<Longrightarrow>\\<^sub>A Q\n  h \\<Turnstile> P\n\ngoal (1 subgoal):\n 1. h \\<Turnstile> Q", "unfolding entails_def"], ["proof (prove)\nusing this:\n  \\<forall>h. h \\<Turnstile> P \\<longrightarrow> h \\<Turnstile> Q\n  h \\<Turnstile> P\n\ngoal (1 subgoal):\n 1. h \\<Turnstile> Q", "by blast"], ["", "subsubsection \\<open>Properties\\<close>"], ["", "lemma ent_fwd: \n  assumes \"h\\<Turnstile>P\"\n  assumes \"P \\<Longrightarrow>\\<^sub>A Q\"\n  shows \"h\\<Turnstile>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> Q", "using assms(2,1)"], ["proof (prove)\nusing this:\n  P \\<Longrightarrow>\\<^sub>A Q\n  h \\<Turnstile> P\n\ngoal (1 subgoal):\n 1. h \\<Turnstile> Q", "by (rule entailsD)"], ["", "lemma ent_refl[simp]: \"P \\<Longrightarrow>\\<^sub>A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A P", "by (auto simp: entailsI)"], ["", "lemma ent_trans[trans]: \"\\<lbrakk> P \\<Longrightarrow>\\<^sub>A Q; Q \\<Longrightarrow>\\<^sub>AR \\<rbrakk> \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>A R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Longrightarrow>\\<^sub>A Q;\n     Q \\<Longrightarrow>\\<^sub>A R\\<rbrakk>\n    \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>A R", "by (auto intro: entailsI dest: entailsD)"], ["", "lemma ent_iffI:\n  assumes \"A\\<Longrightarrow>\\<^sub>AB\"\n  assumes \"B\\<Longrightarrow>\\<^sub>AA\"\n  shows \"A=B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "apply (subst Rep_assn_inject[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_assn A = Rep_assn B", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<Turnstile> A) = (x \\<Turnstile> B)", "using assms"], ["proof (prove)\nusing this:\n  A \\<Longrightarrow>\\<^sub>A B\n  B \\<Longrightarrow>\\<^sub>A A\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<Turnstile> A) = (x \\<Turnstile> B)", "unfolding entails_def"], ["proof (prove)\nusing this:\n  \\<forall>h. h \\<Turnstile> A \\<longrightarrow> h \\<Turnstile> B\n  \\<forall>h. h \\<Turnstile> B \\<longrightarrow> h \\<Turnstile> A\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<Turnstile> A) = (x \\<Turnstile> B)", "by blast"], ["", "lemma ent_false[simp]: \"false \\<Longrightarrow>\\<^sub>A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. false \\<Longrightarrow>\\<^sub>A P", "by (auto intro: entailsI)"], ["", "lemma ent_true[simp]: \"P \\<Longrightarrow>\\<^sub>A true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A true", "by (auto intro!: entailsI simp: models_in_range)"], ["", "lemma ent_false_iff[simp]: \"(P \\<Longrightarrow>\\<^sub>A false) \\<longleftrightarrow> (\\<forall>h. \\<not>h\\<Turnstile>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow>\\<^sub>A false) =\n    (\\<forall>h. \\<not> h \\<Turnstile> P)", "unfolding entails_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>h. h \\<Turnstile> P \\<longrightarrow> h \\<Turnstile> false) =\n    (\\<forall>h. \\<not> h \\<Turnstile> P)", "by auto"], ["", "lemma ent_pure_pre_iff[simp]: \"(P*\\<up>b \\<Longrightarrow>\\<^sub>A Q) \\<longleftrightarrow> (b \\<longrightarrow> (P \\<Longrightarrow>\\<^sub>A Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P * \\<up> b \\<Longrightarrow>\\<^sub>A Q) =\n    (b \\<longrightarrow> (P \\<Longrightarrow>\\<^sub>A Q))", "unfolding entails_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>h.\n        h \\<Turnstile> P * \\<up> b \\<longrightarrow> h \\<Turnstile> Q) =\n    (b \\<longrightarrow>\n     (\\<forall>h. h \\<Turnstile> P \\<longrightarrow> h \\<Turnstile> Q))", "by (auto simp add: mod_dist)"], ["", "lemma ent_pure_pre_iff_sng[simp]: \n  \"(\\<up>b \\<Longrightarrow>\\<^sub>A Q) \\<longleftrightarrow> (b \\<longrightarrow> (emp \\<Longrightarrow>\\<^sub>A Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<up> b \\<Longrightarrow>\\<^sub>A Q) =\n    (b \\<longrightarrow> (emp \\<Longrightarrow>\\<^sub>A Q))", "using ent_pure_pre_iff[where P=emp]"], ["proof (prove)\nusing this:\n  (emp * \\<up> ?b \\<Longrightarrow>\\<^sub>A ?Q) =\n  (?b \\<longrightarrow> (emp \\<Longrightarrow>\\<^sub>A ?Q))\n\ngoal (1 subgoal):\n 1. (\\<up> b \\<Longrightarrow>\\<^sub>A Q) =\n    (b \\<longrightarrow> (emp \\<Longrightarrow>\\<^sub>A Q))", "by simp"], ["", "lemma ent_pure_post_iff[simp]: \n  \"(P \\<Longrightarrow>\\<^sub>A Q*\\<up>b) \\<longleftrightarrow> ((\\<forall>h. h\\<Turnstile>P \\<longrightarrow> b) \\<and> (P \\<Longrightarrow>\\<^sub>A Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow>\\<^sub>A Q * \\<up> b) =\n    ((\\<forall>h. h \\<Turnstile> P \\<longrightarrow> b) \\<and>\n     (P \\<Longrightarrow>\\<^sub>A Q))", "unfolding entails_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>h.\n        h \\<Turnstile> P \\<longrightarrow> h \\<Turnstile> Q * \\<up> b) =\n    ((\\<forall>h. h \\<Turnstile> P \\<longrightarrow> b) \\<and>\n     (\\<forall>h. h \\<Turnstile> P \\<longrightarrow> h \\<Turnstile> Q))", "by (auto simp add: mod_dist)"], ["", "lemma ent_pure_post_iff_sng[simp]: \n  \"(P \\<Longrightarrow>\\<^sub>A \\<up>b) \\<longleftrightarrow> ((\\<forall>h. h\\<Turnstile>P \\<longrightarrow> b) \\<and> (P \\<Longrightarrow>\\<^sub>A emp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow>\\<^sub>A \\<up> b) =\n    ((\\<forall>h. h \\<Turnstile> P \\<longrightarrow> b) \\<and>\n     (P \\<Longrightarrow>\\<^sub>A emp))", "using ent_pure_post_iff[where Q=emp]"], ["proof (prove)\nusing this:\n  (?P \\<Longrightarrow>\\<^sub>A emp * \\<up> ?b) =\n  ((\\<forall>h. h \\<Turnstile> ?P \\<longrightarrow> ?b) \\<and>\n   (?P \\<Longrightarrow>\\<^sub>A emp))\n\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow>\\<^sub>A \\<up> b) =\n    ((\\<forall>h. h \\<Turnstile> P \\<longrightarrow> b) \\<and>\n     (P \\<Longrightarrow>\\<^sub>A emp))", "by simp"], ["", "lemma ent_ex_preI: \"(\\<And>x. P x \\<Longrightarrow>\\<^sub>A Q) \\<Longrightarrow> \\<exists>\\<^sub>Ax. P x \\<Longrightarrow>\\<^sub>A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. P x \\<Longrightarrow>\\<^sub>A Q) \\<Longrightarrow>\n    \\<exists>\\<^sub>Ax. P x \\<Longrightarrow>\\<^sub>A Q", "unfolding entails_def ex_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<forall>h.\n           h \\<Turnstile> P x \\<longrightarrow>\n           h \\<Turnstile> Q) \\<Longrightarrow>\n    \\<forall>h.\n       h \\<Turnstile>\n       Abs_assn\n        (\\<lambda>h. \\<exists>x. h \\<Turnstile> P x) \\<longrightarrow>\n       h \\<Turnstile> Q", "by (auto simp: Abs_assn_inverse)"], ["", "lemma ent_ex_postI: \"(P \\<Longrightarrow>\\<^sub>A Q x) \\<Longrightarrow> P \\<Longrightarrow>\\<^sub>A \\<exists>\\<^sub>Ax. Q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A Q x \\<Longrightarrow>\n    P \\<Longrightarrow>\\<^sub>A \\<exists>\\<^sub>Ax. Q x", "unfolding entails_def ex_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h \\<Turnstile> P \\<longrightarrow>\n       h \\<Turnstile> Q x \\<Longrightarrow>\n    \\<forall>h.\n       h \\<Turnstile> P \\<longrightarrow>\n       h \\<Turnstile> Abs_assn (\\<lambda>h. \\<exists>x. h \\<Turnstile> Q x)", "by (auto simp: Abs_assn_inverse)"], ["", "lemma ent_mp: \"(P * (P -* Q)) \\<Longrightarrow>\\<^sub>A Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * (P -* Q) \\<Longrightarrow>\\<^sub>A Q", "apply (rule entailsI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. h \\<Turnstile> P * (P -* Q) \\<Longrightarrow> h \\<Turnstile> Q", "unfolding times_assn_def wand_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile>\n       Abs_assn\n        (times_assn_raw (Rep_assn P)\n          (Rep_assn\n            (Abs_assn\n              (wand_raw (Rep_assn P) (Rep_assn Q))))) \\<Longrightarrow>\n       h \\<Turnstile> Q", "apply (clarsimp simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as1 as2.\n       \\<lbrakk>as1 \\<inter> as2 = {}; (a, as1) \\<Turnstile> P;\n        in_range (a, as2);\n        \\<forall>h' as'.\n           as2 \\<inter> as' = {} \\<and>\n           relH as2 a h' \\<and>\n           in_range (h', as2) \\<and>\n           (h', as') \\<Turnstile> P \\<longrightarrow>\n           (h', as2 \\<union> as') \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> (a, as1 \\<union> as2) \\<Turnstile> Q", "apply (drule_tac x=\"a\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as1 as2.\n       \\<lbrakk>as1 \\<inter> as2 = {}; (a, as1) \\<Turnstile> P;\n        in_range (a, as2);\n        \\<forall>as'.\n           as2 \\<inter> as' = {} \\<and>\n           relH as2 a a \\<and>\n           in_range (a, as2) \\<and>\n           (a, as') \\<Turnstile> P \\<longrightarrow>\n           (a, as2 \\<union> as') \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> (a, as1 \\<union> as2) \\<Turnstile> Q", "apply (drule_tac x=\"as1\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as1 as2.\n       \\<lbrakk>as1 \\<inter> as2 = {}; (a, as1) \\<Turnstile> P;\n        in_range (a, as2);\n        as2 \\<inter> as1 = {} \\<and>\n        relH as2 a a \\<and>\n        in_range (a, as2) \\<and> (a, as1) \\<Turnstile> P \\<longrightarrow>\n        (a, as2 \\<union> as1) \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> (a, as1 \\<union> as2) \\<Turnstile> Q", "apply (auto simp: Un_ac relH_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ent_star_mono: \"\\<lbrakk> P \\<Longrightarrow>\\<^sub>A P'; Q \\<Longrightarrow>\\<^sub>A Q'\\<rbrakk> \\<Longrightarrow> P*Q \\<Longrightarrow>\\<^sub>A P'*Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Longrightarrow>\\<^sub>A P';\n     Q \\<Longrightarrow>\\<^sub>A Q'\\<rbrakk>\n    \\<Longrightarrow> P * Q \\<Longrightarrow>\\<^sub>A P' * Q'", "unfolding entails_def times_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>h.\n                h \\<Turnstile> P \\<longrightarrow> h \\<Turnstile> P';\n     \\<forall>h.\n        h \\<Turnstile> Q \\<longrightarrow> h \\<Turnstile> Q'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>h.\n                         h \\<Turnstile>\n                         Abs_assn\n                          (times_assn_raw (Rep_assn P)\n                            (Rep_assn Q)) \\<longrightarrow>\n                         h \\<Turnstile>\n                         Abs_assn\n                          (times_assn_raw (Rep_assn P') (Rep_assn Q'))", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                (a, b) \\<Turnstile> P \\<longrightarrow>\n                (a, b) \\<Turnstile> P';\n     \\<forall>a b.\n        (a, b) \\<Turnstile> Q \\<longrightarrow>\n        (a, b) \\<Turnstile> Q'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b.\n                         (\\<exists>as1 as2.\n                             b = as1 \\<union> as2 \\<and>\n                             as1 \\<inter> as2 = {} \\<and>\n                             (a, as1) \\<Turnstile> P \\<and>\n                             (a, as2) \\<Turnstile> Q) \\<longrightarrow>\n                         (\\<exists>as1 as2.\n                             b = as1 \\<union> as2 \\<and>\n                             as1 \\<inter> as2 = {} \\<and>\n                             (a, as1) \\<Turnstile> P' \\<and>\n                             (a, as2) \\<Turnstile> Q')", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ent_wandI:\n  assumes IMP: \"Q*P \\<Longrightarrow>\\<^sub>A R\"\n  shows \"P \\<Longrightarrow>\\<^sub>A (Q -* R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A Q -* R", "unfolding entails_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h. h \\<Turnstile> P \\<longrightarrow> h \\<Turnstile> Q -* R", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<Turnstile> P \\<Longrightarrow> (a, b) \\<Turnstile> Q -* R", "apply (rule wand_assnI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b. (a, b) \\<Turnstile> P \\<Longrightarrow> in_range (a, b)\n 2. \\<And>a b h' as'.\n       \\<lbrakk>(a, b) \\<Turnstile> P; b \\<inter> as' = {}; relH b a h';\n        in_range (h', b); (h', as') \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> (h', b \\<union> as') \\<Turnstile> R", "apply (blast intro: models_in_range)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b h' as'.\n       \\<lbrakk>(a, b) \\<Turnstile> P; b \\<inter> as' = {}; relH b a h';\n        in_range (h', b); (h', as') \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> (h', b \\<union> as') \\<Turnstile> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b h' as'.\n       \\<lbrakk>(a, b) \\<Turnstile> P; b \\<inter> as' = {}; relH b a h';\n        in_range (h', b); (h', as') \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> (h', b \\<union> as') \\<Turnstile> R", "fix h as h' as'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b h' as'.\n       \\<lbrakk>(a, b) \\<Turnstile> P; b \\<inter> as' = {}; relH b a h';\n        in_range (h', b); (h', as') \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> (h', b \\<union> as') \\<Turnstile> R", "assume \"(h,as)\\<Turnstile>P\" \n    and \"as\\<inter>as'={}\" \n    and \"relH as h h'\" \n    and \"in_range (h',as)\" \n    and \"(h',as') \\<Turnstile> Q\""], ["proof (state)\nthis:\n  (h, as) \\<Turnstile> P\n  as \\<inter> as' = {}\n  relH as h h'\n  in_range (h', as)\n  (h', as') \\<Turnstile> Q\n\ngoal (1 subgoal):\n 1. \\<And>a b h' as'.\n       \\<lbrakk>(a, b) \\<Turnstile> P; b \\<inter> as' = {}; relH b a h';\n        in_range (h', b); (h', as') \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> (h', b \\<union> as') \\<Turnstile> R", "from \\<open>(h,as)\\<Turnstile>P\\<close> and \\<open>relH as h h'\\<close>"], ["proof (chain)\npicking this:\n  (h, as) \\<Turnstile> P\n  relH as h h'", "have \"(h',as)\\<Turnstile>P\""], ["proof (prove)\nusing this:\n  (h, as) \\<Turnstile> P\n  relH as h h'\n\ngoal (1 subgoal):\n 1. (h', as) \\<Turnstile> P", "by (simp add: mod_relH)"], ["proof (state)\nthis:\n  (h', as) \\<Turnstile> P\n\ngoal (1 subgoal):\n 1. \\<And>a b h' as'.\n       \\<lbrakk>(a, b) \\<Turnstile> P; b \\<inter> as' = {}; relH b a h';\n        in_range (h', b); (h', as') \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> (h', b \\<union> as') \\<Turnstile> R", "with \\<open>(h',as') \\<Turnstile> Q\\<close> and \\<open>as\\<inter>as'={}\\<close>"], ["proof (chain)\npicking this:\n  (h', as') \\<Turnstile> Q\n  as \\<inter> as' = {}\n  (h', as) \\<Turnstile> P", "have \"(h',as\\<union>as')\\<Turnstile>Q*P\""], ["proof (prove)\nusing this:\n  (h', as') \\<Turnstile> Q\n  as \\<inter> as' = {}\n  (h', as) \\<Turnstile> P\n\ngoal (1 subgoal):\n 1. (h', as \\<union> as') \\<Turnstile> Q * P", "by (metis star_assnI Int_commute Un_commute)"], ["proof (state)\nthis:\n  (h', as \\<union> as') \\<Turnstile> Q * P\n\ngoal (1 subgoal):\n 1. \\<And>a b h' as'.\n       \\<lbrakk>(a, b) \\<Turnstile> P; b \\<inter> as' = {}; relH b a h';\n        in_range (h', b); (h', as') \\<Turnstile> Q\\<rbrakk>\n       \\<Longrightarrow> (h', b \\<union> as') \\<Turnstile> R", "with IMP"], ["proof (chain)\npicking this:\n  Q * P \\<Longrightarrow>\\<^sub>A R\n  (h', as \\<union> as') \\<Turnstile> Q * P", "show \"(h',as\\<union>as') \\<Turnstile> R\""], ["proof (prove)\nusing this:\n  Q * P \\<Longrightarrow>\\<^sub>A R\n  (h', as \\<union> as') \\<Turnstile> Q * P\n\ngoal (1 subgoal):\n 1. (h', as \\<union> as') \\<Turnstile> R", "by (blast dest: ent_fwd)"], ["proof (state)\nthis:\n  (h', as \\<union> as') \\<Turnstile> R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ent_disjI1:\n  assumes \"P \\<or>\\<^sub>A Q \\<Longrightarrow>\\<^sub>A R\" \n  shows \"P \\<Longrightarrow>\\<^sub>A R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A R", "using assms"], ["proof (prove)\nusing this:\n  P \\<or>\\<^sub>A Q \\<Longrightarrow>\\<^sub>A R\n\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A R", "unfolding entails_def"], ["proof (prove)\nusing this:\n  \\<forall>h.\n     h \\<Turnstile> P \\<or>\\<^sub>A Q \\<longrightarrow> h \\<Turnstile> R\n\ngoal (1 subgoal):\n 1. \\<forall>h. h \\<Turnstile> P \\<longrightarrow> h \\<Turnstile> R", "by simp"], ["", "lemma ent_disjI2:\n  assumes \"P \\<or>\\<^sub>A Q \\<Longrightarrow>\\<^sub>A R\" \n  shows \"Q \\<Longrightarrow>\\<^sub>A R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<Longrightarrow>\\<^sub>A R", "using assms"], ["proof (prove)\nusing this:\n  P \\<or>\\<^sub>A Q \\<Longrightarrow>\\<^sub>A R\n\ngoal (1 subgoal):\n 1. Q \\<Longrightarrow>\\<^sub>A R", "unfolding entails_def"], ["proof (prove)\nusing this:\n  \\<forall>h.\n     h \\<Turnstile> P \\<or>\\<^sub>A Q \\<longrightarrow> h \\<Turnstile> R\n\ngoal (1 subgoal):\n 1. \\<forall>h. h \\<Turnstile> Q \\<longrightarrow> h \\<Turnstile> R", "by simp"], ["", "lemma ent_disjI1_direct[simp]: \"A \\<Longrightarrow>\\<^sub>A A \\<or>\\<^sub>A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A A \\<or>\\<^sub>A B", "by (simp add: entails_def)"], ["", "lemma ent_disjI2_direct[simp]: \"B \\<Longrightarrow>\\<^sub>A A \\<or>\\<^sub>A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<Longrightarrow>\\<^sub>A A \\<or>\\<^sub>A B", "by (simp add: entails_def)"], ["", "lemma ent_disjE: \"\\<lbrakk> A\\<Longrightarrow>\\<^sub>AC; B\\<Longrightarrow>\\<^sub>AC \\<rbrakk> \\<Longrightarrow> A\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>AC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>A C;\n     B \\<Longrightarrow>\\<^sub>A C\\<rbrakk>\n    \\<Longrightarrow> A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>A C", "unfolding entails_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>h.\n                h \\<Turnstile> A \\<longrightarrow> h \\<Turnstile> C;\n     \\<forall>h.\n        h \\<Turnstile> B \\<longrightarrow> h \\<Turnstile> C\\<rbrakk>\n    \\<Longrightarrow> \\<forall>h.\n                         h \\<Turnstile> A \\<or>\\<^sub>A B \\<longrightarrow>\n                         h \\<Turnstile> C", "by auto"], ["", "lemma ent_conjI: \"\\<lbrakk> A\\<Longrightarrow>\\<^sub>AB; A\\<Longrightarrow>\\<^sub>AC \\<rbrakk> \\<Longrightarrow> A \\<Longrightarrow>\\<^sub>A B \\<and>\\<^sub>A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>A B;\n     A \\<Longrightarrow>\\<^sub>A C\\<rbrakk>\n    \\<Longrightarrow> A \\<Longrightarrow>\\<^sub>A B \\<and>\\<^sub>A C", "unfolding entails_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>h.\n                h \\<Turnstile> A \\<longrightarrow> h \\<Turnstile> B;\n     \\<forall>h.\n        h \\<Turnstile> A \\<longrightarrow> h \\<Turnstile> C\\<rbrakk>\n    \\<Longrightarrow> \\<forall>h.\n                         h \\<Turnstile> A \\<longrightarrow>\n                         h \\<Turnstile> B \\<and>\\<^sub>A C", "by (auto simp: mod_and_dist)"], ["", "lemma ent_conjE1: \"\\<lbrakk>A\\<Longrightarrow>\\<^sub>AC\\<rbrakk> \\<Longrightarrow> A\\<and>\\<^sub>AB\\<Longrightarrow>\\<^sub>AC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A C \\<Longrightarrow>\n    A \\<and>\\<^sub>A B \\<Longrightarrow>\\<^sub>A C", "unfolding entails_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h \\<Turnstile> A \\<longrightarrow> h \\<Turnstile> C \\<Longrightarrow>\n    \\<forall>h.\n       h \\<Turnstile> A \\<and>\\<^sub>A B \\<longrightarrow> h \\<Turnstile> C", "by (auto simp: mod_and_dist)"], ["", "lemma ent_conjE2: \"\\<lbrakk>B\\<Longrightarrow>\\<^sub>AC\\<rbrakk> \\<Longrightarrow> A\\<and>\\<^sub>AB\\<Longrightarrow>\\<^sub>AC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<Longrightarrow>\\<^sub>A C \\<Longrightarrow>\n    A \\<and>\\<^sub>A B \\<Longrightarrow>\\<^sub>A C", "unfolding entails_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h \\<Turnstile> B \\<longrightarrow> h \\<Turnstile> C \\<Longrightarrow>\n    \\<forall>h.\n       h \\<Turnstile> A \\<and>\\<^sub>A B \\<longrightarrow> h \\<Turnstile> C", "by (auto simp: mod_and_dist)"], ["", "lemma star_or_dist1: \n  \"(A \\<or>\\<^sub>A B)*C = (A*C \\<or>\\<^sub>A B*C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<or>\\<^sub>A B) * C = A * C \\<or>\\<^sub>A B * C", "apply (rule ent_iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (A \\<or>\\<^sub>A B) * C \\<Longrightarrow>\\<^sub>A\n    A * C \\<or>\\<^sub>A B * C\n 2. A * C \\<or>\\<^sub>A B * C \\<Longrightarrow>\\<^sub>A\n    (A \\<or>\\<^sub>A B) * C", "unfolding entails_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>h.\n       h \\<Turnstile> (A \\<or>\\<^sub>A B) * C \\<longrightarrow>\n       h \\<Turnstile> A * C \\<or>\\<^sub>A B * C\n 2. \\<forall>h.\n       h \\<Turnstile> A * C \\<or>\\<^sub>A B * C \\<longrightarrow>\n       h \\<Turnstile> (A \\<or>\\<^sub>A B) * C", "by (auto simp add: mod_star_conv)"], ["", "lemma star_or_dist2: \n  \"C*(A \\<or>\\<^sub>A B) = (C*A \\<or>\\<^sub>A C*B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C * (A \\<or>\\<^sub>A B) = C * A \\<or>\\<^sub>A C * B", "apply (rule ent_iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. C * (A \\<or>\\<^sub>A B) \\<Longrightarrow>\\<^sub>A\n    C * A \\<or>\\<^sub>A C * B\n 2. C * A \\<or>\\<^sub>A C * B \\<Longrightarrow>\\<^sub>A\n    C * (A \\<or>\\<^sub>A B)", "unfolding entails_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>h.\n       h \\<Turnstile> C * (A \\<or>\\<^sub>A B) \\<longrightarrow>\n       h \\<Turnstile> C * A \\<or>\\<^sub>A C * B\n 2. \\<forall>h.\n       h \\<Turnstile> C * A \\<or>\\<^sub>A C * B \\<longrightarrow>\n       h \\<Turnstile> C * (A \\<or>\\<^sub>A B)", "by (auto simp add: mod_star_conv)"], ["", "lemmas star_or_dist = star_or_dist1 star_or_dist2"], ["", "lemma ent_disjI1': \"A\\<Longrightarrow>\\<^sub>AB \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>AB\\<or>\\<^sub>AC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A B \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>A B \\<or>\\<^sub>A C", "by (auto simp: entails_def star_or_dist)"], ["", "lemma ent_disjI2': \"A\\<Longrightarrow>\\<^sub>AC \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>AB\\<or>\\<^sub>AC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A C \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>A B \\<or>\\<^sub>A C", "by (auto simp: entails_def star_or_dist)"], ["", "lemma triv_exI[simp, intro!]: \"Q x \\<Longrightarrow>\\<^sub>A \\<exists>\\<^sub>Ax. Q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q x \\<Longrightarrow>\\<^sub>A \\<exists>\\<^sub>Ax. Q x", "by (meson ent_ex_postI ent_refl)"], ["", "subsubsection \\<open>Weak Entails\\<close>"], ["", "text \\<open>Weakening of entails to allow arbitrary unspecified memory in conclusion\\<close>"], ["", "definition entailst :: \"assn \\<Rightarrow> assn \\<Rightarrow> bool\" (infix \"\\<Longrightarrow>\\<^sub>t\" 10)\n  where \"entailst A B \\<equiv> A \\<Longrightarrow>\\<^sub>A B * true\""], ["", "lemma enttI: \"A\\<Longrightarrow>\\<^sub>AB*true \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>tB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A B * true \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>t B", "unfolding entailst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A B * true \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>A B * true", "."], ["", "lemma enttD: \"A\\<Longrightarrow>\\<^sub>tB \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>AB*true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>t B \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>A B * true", "unfolding entailst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A B * true \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>A B * true", "."], ["", "lemma entt_trans:\n  \"entailst A B \\<Longrightarrow> entailst B C \\<Longrightarrow> entailst A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>t B;\n     B \\<Longrightarrow>\\<^sub>t C\\<rbrakk>\n    \\<Longrightarrow> A \\<Longrightarrow>\\<^sub>t C", "unfolding entailst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>A B * true;\n     B \\<Longrightarrow>\\<^sub>A C * true\\<rbrakk>\n    \\<Longrightarrow> A \\<Longrightarrow>\\<^sub>A C * true", "apply (erule ent_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<Longrightarrow>\\<^sub>A C * true \\<Longrightarrow>\n    B * true \\<Longrightarrow>\\<^sub>A C * true", "by (metis assn_times_assoc ent_star_mono ent_true merge_true_star)"], ["", "lemma entt_refl[simp, intro!]: \"entailst A A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>t A", "unfolding entailst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A A * true", "by (simp add: entailsI mod_star_trueI)"], ["", "lemma entt_true[simp, intro!]:\n  \"entailst A true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>t true", "unfolding entailst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A true * true", "by simp"], ["", "lemma entt_emp[simp, intro!]:\n  \"entailst A emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>t emp", "unfolding entailst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A emp * true", "by simp"], ["", "lemma entt_star_true_simp[simp]:\n  \"entailst A (B*true) \\<longleftrightarrow> entailst A B\"\n  \"entailst (A*true) B \\<longleftrightarrow> entailst A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<Longrightarrow>\\<^sub>t B * true) =\n    (A \\<Longrightarrow>\\<^sub>t B) &&&\n    (A * true \\<Longrightarrow>\\<^sub>t B) = (A \\<Longrightarrow>\\<^sub>t B)", "unfolding entailst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<Longrightarrow>\\<^sub>A B * true * true) =\n    (A \\<Longrightarrow>\\<^sub>A B * true) &&&\n    (A * true \\<Longrightarrow>\\<^sub>A B * true) =\n    (A \\<Longrightarrow>\\<^sub>A B * true)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<Longrightarrow>\\<^sub>A B * true * true) =\n    (A \\<Longrightarrow>\\<^sub>A B * true)", "by (auto simp: assn_times_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * true \\<Longrightarrow>\\<^sub>A B * true) =\n    (A \\<Longrightarrow>\\<^sub>A B * true)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * true \\<Longrightarrow>\\<^sub>A B * true) =\n    (A \\<Longrightarrow>\\<^sub>A B * true)", "apply (intro iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A * true \\<Longrightarrow>\\<^sub>A B * true \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>A B * true\n 2. A \\<Longrightarrow>\\<^sub>A B * true \\<Longrightarrow>\n    A * true \\<Longrightarrow>\\<^sub>A B * true", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * true \\<Longrightarrow>\\<^sub>A B * true \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>A B * true", "using entails_def mod_star_trueI"], ["proof (prove)\nusing this:\n  ?P \\<Longrightarrow>\\<^sub>A ?Q \\<equiv>\n  \\<forall>h. h \\<Turnstile> ?P \\<longrightarrow> h \\<Turnstile> ?Q\n  ?h \\<Turnstile> ?P \\<Longrightarrow> ?h \\<Turnstile> ?P * true\n\ngoal (1 subgoal):\n 1. A * true \\<Longrightarrow>\\<^sub>A B * true \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>A B * true", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A B * true \\<Longrightarrow>\n    A * true \\<Longrightarrow>\\<^sub>A B * true", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A B * true \\<Longrightarrow>\n    A * true \\<Longrightarrow>\\<^sub>A B * true", "by (metis assn_times_assoc ent_refl ent_star_mono merge_true_star)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma entt_star_mono: \"\\<lbrakk>entailst A B; entailst C D\\<rbrakk> \\<Longrightarrow> entailst (A*C) (B*D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>t B;\n     C \\<Longrightarrow>\\<^sub>t D\\<rbrakk>\n    \\<Longrightarrow> A * C \\<Longrightarrow>\\<^sub>t B * D", "unfolding entailst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>A B * true;\n     C \\<Longrightarrow>\\<^sub>A D * true\\<rbrakk>\n    \\<Longrightarrow> A * C \\<Longrightarrow>\\<^sub>A B * D * true", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>A B * true;\n     C \\<Longrightarrow>\\<^sub>A D * true\\<rbrakk>\n    \\<Longrightarrow> A * C \\<Longrightarrow>\\<^sub>A B * D * true", "assume a1: \"A \\<Longrightarrow>\\<^sub>A B * true\""], ["proof (state)\nthis:\n  A \\<Longrightarrow>\\<^sub>A B * true\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>A B * true;\n     C \\<Longrightarrow>\\<^sub>A D * true\\<rbrakk>\n    \\<Longrightarrow> A * C \\<Longrightarrow>\\<^sub>A B * D * true", "assume \"C \\<Longrightarrow>\\<^sub>A D * true\""], ["proof (state)\nthis:\n  C \\<Longrightarrow>\\<^sub>A D * true\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>A B * true;\n     C \\<Longrightarrow>\\<^sub>A D * true\\<rbrakk>\n    \\<Longrightarrow> A * C \\<Longrightarrow>\\<^sub>A B * D * true", "then"], ["proof (chain)\npicking this:\n  C \\<Longrightarrow>\\<^sub>A D * true", "have \"A * C \\<Longrightarrow>\\<^sub>A true * B * (true * D)\""], ["proof (prove)\nusing this:\n  C \\<Longrightarrow>\\<^sub>A D * true\n\ngoal (1 subgoal):\n 1. A * C \\<Longrightarrow>\\<^sub>A true * B * (true * D)", "using a1 assn_times_comm ent_star_mono"], ["proof (prove)\nusing this:\n  C \\<Longrightarrow>\\<^sub>A D * true\n  A \\<Longrightarrow>\\<^sub>A B * true\n  ?P * ?Q = ?Q * ?P\n  \\<lbrakk>?P \\<Longrightarrow>\\<^sub>A ?P';\n   ?Q \\<Longrightarrow>\\<^sub>A ?Q'\\<rbrakk>\n  \\<Longrightarrow> ?P * ?Q \\<Longrightarrow>\\<^sub>A ?P' * ?Q'\n\ngoal (1 subgoal):\n 1. A * C \\<Longrightarrow>\\<^sub>A true * B * (true * D)", "by force"], ["proof (state)\nthis:\n  A * C \\<Longrightarrow>\\<^sub>A true * B * (true * D)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>A B * true;\n     C \\<Longrightarrow>\\<^sub>A D * true\\<rbrakk>\n    \\<Longrightarrow> A * C \\<Longrightarrow>\\<^sub>A B * D * true", "then"], ["proof (chain)\npicking this:\n  A * C \\<Longrightarrow>\\<^sub>A true * B * (true * D)", "show \"A * C \\<Longrightarrow>\\<^sub>A B * D * true\""], ["proof (prove)\nusing this:\n  A * C \\<Longrightarrow>\\<^sub>A true * B * (true * D)\n\ngoal (1 subgoal):\n 1. A * C \\<Longrightarrow>\\<^sub>A B * D * true", "by (simp add: ab_semigroup_mult_class.mult.left_commute assn_times_comm)"], ["proof (state)\nthis:\n  A * C \\<Longrightarrow>\\<^sub>A B * D * true\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma entt_frame_fwd:\n  assumes \"entailst P Q\"\n  assumes \"entailst A (P*F)\"\n  assumes \"entailst (Q*F) B\"\n  shows \"entailst A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>t B", "using assms"], ["proof (prove)\nusing this:\n  P \\<Longrightarrow>\\<^sub>t Q\n  A \\<Longrightarrow>\\<^sub>t P * F\n  Q * F \\<Longrightarrow>\\<^sub>t B\n\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>t B", "by (metis entt_refl entt_star_mono entt_trans)"], ["", "lemma enttI_true: \"P*true \\<Longrightarrow>\\<^sub>A Q*true \\<Longrightarrow> P\\<Longrightarrow>\\<^sub>tQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * true \\<Longrightarrow>\\<^sub>A Q * true \\<Longrightarrow>\n    P \\<Longrightarrow>\\<^sub>t Q", "by (drule enttI) simp"], ["", "lemma entt_def_true: \"(P\\<Longrightarrow>\\<^sub>tQ) \\<equiv> (P*true \\<Longrightarrow>\\<^sub>A Q*true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>t Q \\<equiv>\n    P * true \\<Longrightarrow>\\<^sub>A Q * true", "unfolding entailst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A Q * true \\<equiv>\n    P * true \\<Longrightarrow>\\<^sub>A Q * true", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow>\\<^sub>A Q * true) =\n    (P * true \\<Longrightarrow>\\<^sub>A Q * true)", "using entailst_def entt_star_true_simp(2)"], ["proof (prove)\nusing this:\n  ?A \\<Longrightarrow>\\<^sub>t ?B \\<equiv>\n  ?A \\<Longrightarrow>\\<^sub>A ?B * true\n  (?A * true \\<Longrightarrow>\\<^sub>t ?B) =\n  (?A \\<Longrightarrow>\\<^sub>t ?B)\n\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow>\\<^sub>A Q * true) =\n    (P * true \\<Longrightarrow>\\<^sub>A Q * true)", "by auto"], ["", "lemma ent_imp_entt: \"P\\<Longrightarrow>\\<^sub>AQ \\<Longrightarrow> P\\<Longrightarrow>\\<^sub>tQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A Q \\<Longrightarrow>\n    P \\<Longrightarrow>\\<^sub>t Q", "apply (rule enttI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>A Q \\<Longrightarrow>\n    P \\<Longrightarrow>\\<^sub>A Q * true", "apply (erule ent_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<Longrightarrow>\\<^sub>A Q * true", "by (simp add: entailsI mod_star_trueI)"], ["", "lemma entt_disjI1_direct[simp]: \"A \\<Longrightarrow>\\<^sub>t A \\<or>\\<^sub>A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>t A \\<or>\\<^sub>A B", "by (rule ent_imp_entt[OF ent_disjI1_direct])"], ["", "lemma entt_disjI2_direct[simp]: \"B \\<Longrightarrow>\\<^sub>t A \\<or>\\<^sub>A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<Longrightarrow>\\<^sub>t A \\<or>\\<^sub>A B", "by (rule ent_imp_entt[OF ent_disjI2_direct])"], ["", "lemma entt_disjI1': \"A\\<Longrightarrow>\\<^sub>tB \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>tB\\<or>\\<^sub>AC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>t B \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>t B \\<or>\\<^sub>A C", "by (auto simp: entailst_def entails_def star_or_dist)"], ["", "lemma entt_disjI2': \"A\\<Longrightarrow>\\<^sub>tC \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>tB\\<or>\\<^sub>AC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>t C \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>t B \\<or>\\<^sub>A C", "by (auto simp: entailst_def entails_def star_or_dist)"], ["", "lemma entt_disjE: \"\\<lbrakk> A\\<Longrightarrow>\\<^sub>tM; B\\<Longrightarrow>\\<^sub>tM \\<rbrakk> \\<Longrightarrow> A\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>t M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>t M;\n     B \\<Longrightarrow>\\<^sub>t M\\<rbrakk>\n    \\<Longrightarrow> A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t M", "using ent_disjE enttD enttI"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<Longrightarrow>\\<^sub>A ?C;\n   ?B \\<Longrightarrow>\\<^sub>A ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<or>\\<^sub>A ?B \\<Longrightarrow>\\<^sub>A ?C\n  ?A \\<Longrightarrow>\\<^sub>t ?B \\<Longrightarrow>\n  ?A \\<Longrightarrow>\\<^sub>A ?B * true\n  ?A \\<Longrightarrow>\\<^sub>A ?B * true \\<Longrightarrow>\n  ?A \\<Longrightarrow>\\<^sub>t ?B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>t M;\n     B \\<Longrightarrow>\\<^sub>t M\\<rbrakk>\n    \\<Longrightarrow> A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t M", "by blast"], ["", "lemma entt_disjD1: \"A\\<or>\\<^sub>AB\\<Longrightarrow>\\<^sub>tC \\<Longrightarrow> A\\<Longrightarrow>\\<^sub>tC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t C \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>t C", "using entt_disjI1_direct entt_trans"], ["proof (prove)\nusing this:\n  ?A \\<Longrightarrow>\\<^sub>t ?A \\<or>\\<^sub>A ?B\n  \\<lbrakk>?A \\<Longrightarrow>\\<^sub>t ?B;\n   ?B \\<Longrightarrow>\\<^sub>t ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<Longrightarrow>\\<^sub>t ?C\n\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t C \\<Longrightarrow>\n    A \\<Longrightarrow>\\<^sub>t C", "by blast"], ["", "lemma entt_disjD2: \"A\\<or>\\<^sub>AB\\<Longrightarrow>\\<^sub>tC \\<Longrightarrow> B\\<Longrightarrow>\\<^sub>tC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t C \\<Longrightarrow>\n    B \\<Longrightarrow>\\<^sub>t C", "using entt_disjI2_direct entt_trans"], ["proof (prove)\nusing this:\n  ?B \\<Longrightarrow>\\<^sub>t ?A \\<or>\\<^sub>A ?B\n  \\<lbrakk>?A \\<Longrightarrow>\\<^sub>t ?B;\n   ?B \\<Longrightarrow>\\<^sub>t ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<Longrightarrow>\\<^sub>t ?C\n\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t C \\<Longrightarrow>\n    B \\<Longrightarrow>\\<^sub>t C", "by blast"], ["", "subsection \\<open>Precision\\<close>"], ["", "text \\<open>\n  Precision rules describe that parts of an assertion may depend only on the\n  underlying heap. For example, the data where a pointer points to is the same\n  for the same heap.\n\\<close>"], ["", "text \\<open>Precision rules should have the form: \n  @{text [display] \"\\<forall>x y. (h\\<Turnstile>(P x * F1) \\<and>\\<^sub>A (P y * F2)) \\<longrightarrow> x=y\"}\\<close>"], ["", "definition \"precise R \\<equiv> \\<forall>a a' h p F F'. \n  h \\<Turnstile> R a p * F \\<and>\\<^sub>A R a' p * F' \\<longrightarrow> a = a'\""], ["", "lemma preciseI[intro?]: \n  assumes \"\\<And>a a' h p F F'. h \\<Turnstile> R a p * F \\<and>\\<^sub>A R a' p * F' \\<Longrightarrow> a = a'\"\n  shows \"precise R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise R", "using assms"], ["proof (prove)\nusing this:\n  ?h \\<Turnstile>\n  R ?a ?p * ?F \\<and>\\<^sub>A R ?a' ?p * ?F' \\<Longrightarrow>\n  ?a = ?a'\n\ngoal (1 subgoal):\n 1. precise R", "unfolding precise_def"], ["proof (prove)\nusing this:\n  ?h \\<Turnstile>\n  R ?a ?p * ?F \\<and>\\<^sub>A R ?a' ?p * ?F' \\<Longrightarrow>\n  ?a = ?a'\n\ngoal (1 subgoal):\n 1. \\<forall>a a' h p F F'.\n       h \\<Turnstile> R a p * F \\<and>\\<^sub>A R a' p * F' \\<longrightarrow>\n       a = a'", "by blast"], ["", "lemma preciseD:\n  assumes \"precise R\"\n  assumes \"h \\<Turnstile> R a p * F \\<and>\\<^sub>A R a' p * F'\"\n  shows \"a=a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a'", "using assms"], ["proof (prove)\nusing this:\n  precise R\n  h \\<Turnstile> R a p * F \\<and>\\<^sub>A R a' p * F'\n\ngoal (1 subgoal):\n 1. a = a'", "unfolding precise_def"], ["proof (prove)\nusing this:\n  \\<forall>a a' h p F F'.\n     h \\<Turnstile> R a p * F \\<and>\\<^sub>A R a' p * F' \\<longrightarrow>\n     a = a'\n  h \\<Turnstile> R a p * F \\<and>\\<^sub>A R a' p * F'\n\ngoal (1 subgoal):\n 1. a = a'", "by blast"], ["", "lemma preciseD':\n  assumes \"precise R\"\n  assumes \"h \\<Turnstile> R a p * F\" \n  assumes \"h \\<Turnstile> R a' p * F'\"\n  shows \"a=a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a'", "apply (rule preciseD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. precise ?R\n 2. ?h \\<Turnstile> ?R a ?p * ?F \\<and>\\<^sub>A ?R a' ?p * ?F'", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ?h \\<Turnstile> R a ?p * ?F \\<and>\\<^sub>A R a' ?p * ?F'", "apply (simp only: mod_and_dist)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ?h \\<Turnstile> R a ?p * ?F \\<and> ?h \\<Turnstile> R a' ?p * ?F'", "apply (blast intro: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma precise_extr_pure[simp]: \n  \"precise (\\<lambda>x y. \\<up>P * R x y) \\<longleftrightarrow> (P \\<longrightarrow> precise R)\"\n  \"precise (\\<lambda>x y. R x y * \\<up>P) \\<longleftrightarrow> (P \\<longrightarrow> precise R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (\\<lambda>x y. \\<up> P * R x y) =\n    (P \\<longrightarrow> precise R) &&&\n    precise (\\<lambda>x y. R x y * \\<up> P) =\n    (P \\<longrightarrow> precise R)", "apply (cases P, (auto intro!: preciseI) [2])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sngr_prec: \"precise (\\<lambda>x p. p\\<mapsto>\\<^sub>rx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (\\<lambda>x p. p \\<mapsto>\\<^sub>r x)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       p \\<mapsto>\\<^sub>r a * F \\<and>\\<^sub>A\n       p \\<mapsto>\\<^sub>r a' * F' \\<Longrightarrow>\n       a = a'", "apply (clarsimp simp: mod_and_dist)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F'.\n       \\<lbrakk>(aa, b) \\<Turnstile> p \\<mapsto>\\<^sub>r a * F;\n        (aa, b) \\<Turnstile> p \\<mapsto>\\<^sub>r a' * F'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "unfolding sngr_assn_def times_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F'.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                Abs_assn\n                 (times_assn_raw (Rep_assn (Abs_assn (sngr_assn_raw p a)))\n                   (Rep_assn F));\n        (aa, b) \\<Turnstile>\n        Abs_assn\n         (times_assn_raw (Rep_assn (Abs_assn (sngr_assn_raw p a')))\n           (Rep_assn F'))\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F'.\n       \\<lbrakk>\\<exists>as2.\n                   b = insert (addr_of_ref p) as2 \\<and>\n                   addr_of_ref p \\<notin> as2 \\<and>\n                   Ref.get aa p = a \\<and>\n                   addr_of_ref p < lim aa \\<and> (aa, as2) \\<Turnstile> F;\n        \\<exists>as2.\n           b = insert (addr_of_ref p) as2 \\<and>\n           addr_of_ref p \\<notin> as2 \\<and>\n           Ref.get aa p = a' \\<and>\n           addr_of_ref p < lim aa \\<and> (aa, as2) \\<Turnstile> F'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma snga_prec: \"precise (\\<lambda>x p. p\\<mapsto>\\<^sub>ax)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (\\<lambda>x p. p \\<mapsto>\\<^sub>a x)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       p \\<mapsto>\\<^sub>a a * F \\<and>\\<^sub>A\n       p \\<mapsto>\\<^sub>a a' * F' \\<Longrightarrow>\n       a = a'", "apply (clarsimp simp: mod_and_dist)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F'.\n       \\<lbrakk>(aa, b) \\<Turnstile> p \\<mapsto>\\<^sub>a a * F;\n        (aa, b) \\<Turnstile> p \\<mapsto>\\<^sub>a a' * F'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "unfolding snga_assn_def times_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F'.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                Abs_assn\n                 (times_assn_raw (Rep_assn (Abs_assn (snga_assn_raw p a)))\n                   (Rep_assn F));\n        (aa, b) \\<Turnstile>\n        Abs_assn\n         (times_assn_raw (Rep_assn (Abs_assn (snga_assn_raw p a')))\n           (Rep_assn F'))\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply (simp add: Abs_assn_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F'.\n       \\<lbrakk>\\<exists>as2.\n                   b = insert (addr_of_array p) as2 \\<and>\n                   addr_of_array p \\<notin> as2 \\<and>\n                   Array.get aa p = a \\<and>\n                   addr_of_array p < lim aa \\<and> (aa, as2) \\<Turnstile> F;\n        \\<exists>as2.\n           b = insert (addr_of_array p) as2 \\<and>\n           addr_of_array p \\<notin> as2 \\<and>\n           Array.get aa p = a' \\<and>\n           addr_of_array p < lim aa \\<and>\n           (aa, as2) \\<Turnstile> F'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}