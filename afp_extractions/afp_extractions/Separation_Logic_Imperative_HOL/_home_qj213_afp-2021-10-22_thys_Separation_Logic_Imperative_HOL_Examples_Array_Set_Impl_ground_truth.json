{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL/Examples/Array_Set_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Logic_Imperative_HOL", "problem_names": ["lemma [code]: \"ias_memb k a \\<equiv> nth_oo False a k\"", "lemma [code]: \"ias_delete k a \\<equiv> upd_oo (return a) k False a\"", "lemma [code]: \"ias_ins k a \\<equiv> upd_oo (do {\n      l\\<leftarrow>Array.len a;\n      let newsz = max (k+1) (2 * l + 3);\n      a\\<leftarrow>array_grow a newsz False;\n      Array.upd k True a\n    })\n    k True a\"", "lemma precise_ias: \"precise is_ias\"", "lemma ias_new_abs: \"ias_of_list (replicate n False) = {}\"", "lemma ias_new_sz_rule: \"<emp> ias_new_sz n < is_ias {} >\"", "lemma ias_new_rule: \"<emp> ias_new < is_ias {} >\"", "lemma ias_memb_abs1: \"k<length l \\<Longrightarrow> k\\<in>ias_of_list l \\<longleftrightarrow> l!k\"", "lemma ias_memb_abs2: \"\\<not>k<length l \\<Longrightarrow> k\\<notin>ias_of_list l\"", "lemma ias_memb_rule: \"< is_ias m p > \n    ias_memb k p \n    <\\<lambda>r. is_ias m p * \\<up>(r\\<longleftrightarrow>k\\<in>m) >\"", "lemma ias_delete_abs1: \"k<length l \n    \\<Longrightarrow> ias_of_list (l[k := False]) = ias_of_list l - {k}\"", "lemma ias_delete_abs2: \"\\<not>k<length l \n    \\<Longrightarrow> ias_of_list l - {k} = ias_of_list l\"", "lemma ias_delete_rule: \"< is_ias m p >\n    ias_delete k p\n    <\\<lambda>r. is_ias (m-{k}) r>\"", "lemma ias_ins_abs1: \"ias_of_list (l@replicate n False) = ias_of_list l\"", "lemma ias_ins_abs2: \"\\<not> length l \\<le> k \n    \\<Longrightarrow> ias_of_list (l[k := True]) = insert k (ias_of_list l)\"", "lemma ias_ins_rule:\n    \"< is_ias m p > ias_ins k p <\\<lambda>r. is_ias (insert k m) r>\\<^sub>t\"", "lemma ias_set_impl: \"imp_set is_ias\"", "lemma ias_empty_impl: \"imp_set_empty is_ias ias_new\"", "lemma ias_empty_sz_impl: \"imp_set_empty is_ias (ias_new_sz sz)\"", "lemma ias_memb_impl: \"imp_set_memb is_ias ias_memb\"", "lemma ias_delete_impl: \"imp_set_delete is_ias ias_delete\"", "lemma \"imp_set_ins is_ias ias_ins\"", "lemma ias_ins_impl: \"imp_set_ins is_ias ias_ins\""], "translations": [["", "lemma [code]: \"ias_memb k a \\<equiv> nth_oo False a k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ias_memb k a \\<equiv> nth_oo False a k", "unfolding ias_memb_def nth_oo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.len a \\<bind>\n    (\\<lambda>l. if k < l then Array.nth a k else return False) \\<equiv>\n    Array.len a \\<bind>\n    (\\<lambda>l. if k < l then Array.nth a k else return False)", "."], ["", "definition ias_delete\n    :: \"nat \\<Rightarrow> array_set \\<Rightarrow> array_set Heap\"\n  where \"ias_delete k a = do {\n      l\\<leftarrow>Array.len a;\n      if k < l then Array.upd k False a else return a\n    }\""], ["", "lemma [code]: \"ias_delete k a \\<equiv> upd_oo (return a) k False a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ias_delete k a \\<equiv> upd_oo (return a) k False a", "unfolding ias_delete_def upd_oo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.len a \\<bind>\n    (\\<lambda>l. if k < l then Array.upd k False a else return a) \\<equiv>\n    Array.len a \\<bind>\n    (\\<lambda>l. if k < l then Array.upd k False a else return a)", "."], ["", "definition ias_ins\n    :: \"nat \\<Rightarrow> array_set \\<Rightarrow> array_set Heap\"\n    where \"ias_ins k a = do {\n      l\\<leftarrow>Array.len a;\n      a\\<leftarrow>if k>=l then do {\n          let newsz = max (k+1) (2 * l + 3);\n          array_grow a newsz False\n        } else return a;\n\n      Array.upd k True a\n    }\""], ["", "lemma [code]: \"ias_ins k a \\<equiv> upd_oo (do {\n      l\\<leftarrow>Array.len a;\n      let newsz = max (k+1) (2 * l + 3);\n      a\\<leftarrow>array_grow a newsz False;\n      Array.upd k True a\n    })\n    k True a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ias_ins k a \\<equiv>\n    upd_oo\n     (Array.len a \\<bind>\n      (\\<lambda>l.\n          let newsz = max (k + 1) (2 * l + 3)\n          in array_grow a newsz False \\<bind> Array.upd k True))\n     k True a", "unfolding ias_ins_def upd_oo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.len a \\<bind>\n    (\\<lambda>l.\n        (if l \\<le> k\n         then let newsz = max (k + 1) (2 * l + 3)\n              in array_grow a newsz False\n         else return a) \\<bind>\n        Array.upd k True) \\<equiv>\n    Array.len a \\<bind>\n    (\\<lambda>l.\n        if k < l then Array.upd k True a\n        else Array.len a \\<bind>\n             (\\<lambda>l.\n                 let newsz = max (k + 1) (2 * l + 3)\n                 in array_grow a newsz False \\<bind> Array.upd k True))", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.len a \\<bind>\n    (\\<lambda>l.\n        (if l \\<le> k\n         then let newsz = max (k + 1) (2 * l + 3)\n              in array_grow a newsz False\n         else return a) \\<bind>\n        Array.upd k True) =\n    Array.len a \\<bind>\n    (\\<lambda>l.\n        if k < l then Array.upd k True a\n        else Array.len a \\<bind>\n             (\\<lambda>l.\n                 let newsz = max (k + 1) (2 * l + 3)\n                 in array_grow a newsz False \\<bind> Array.upd k True))", "apply (auto simp add: bind_def execute_len execute_return)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma precise_ias: \"precise is_ias\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_ias", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_ias a p * F \\<and>\\<^sub>A is_ias a' p * F' \\<Longrightarrow>\n       a = a'", "by (auto simp add: is_ias_def dest: preciseD[OF snga_prec])"], ["", "lemma ias_new_abs: \"ias_of_list (replicate n False) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ias_of_list (replicate n False) = {}", "unfolding ias_of_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length (replicate n False) \\<and> replicate n False ! i} = {}", "by auto"], ["", "lemma ias_new_sz_rule: \"<emp> ias_new_sz n < is_ias {} >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> ias_new_sz n <is_ias {}>", "unfolding ias_new_sz_def is_ias_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> Array.new n False\n    <\\<lambda>a.\n        \\<exists>\\<^sub>Al.\n           a \\<mapsto>\\<^sub>a l * \\<up> ({} = ias_of_list l)>", "by (sep_auto simp: ias_new_abs)"], ["", "lemma ias_new_rule: \"<emp> ias_new < is_ias {} >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> ias_new <is_ias {}>", "unfolding ias_new_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> ias_new_sz ias_initial_size <is_ias {}>", "by (sep_auto heap: ias_new_sz_rule)"], ["", "lemma ias_memb_abs1: \"k<length l \\<Longrightarrow> k\\<in>ias_of_list l \\<longleftrightarrow> l!k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length l \\<Longrightarrow> (k \\<in> ias_of_list l) = l ! k", "by (simp add: ias_of_list_def)"], ["", "lemma ias_memb_abs2: \"\\<not>k<length l \\<Longrightarrow> k\\<notin>ias_of_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> k < length l \\<Longrightarrow> k \\<notin> ias_of_list l", "by (simp add: ias_of_list_def)"], ["", "lemma ias_memb_rule: \"< is_ias m p > \n    ias_memb k p \n    <\\<lambda>r. is_ias m p * \\<up>(r\\<longleftrightarrow>k\\<in>m) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_ias m p> ias_memb k p\n    <\\<lambda>r. is_ias m p * \\<up> (r = (k \\<in> m))>", "unfolding ias_memb_def is_ias_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al. p \\<mapsto>\\<^sub>a l * \\<up> (m = ias_of_list l)>\n    Array.len p \\<bind>\n    (\\<lambda>l. if k < l then Array.nth p k else return False)\n    <\\<lambda>r.\n        (\\<exists>\\<^sub>Al.\n            p \\<mapsto>\\<^sub>a l * \\<up> (m = ias_of_list l)) *\n        \\<up> (r = (k \\<in> m))>", "by (sep_auto simp: ias_memb_abs1 ias_memb_abs2)"], ["", "lemma ias_delete_abs1: \"k<length l \n    \\<Longrightarrow> ias_of_list (l[k := False]) = ias_of_list l - {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length l \\<Longrightarrow>\n    ias_of_list (l[k := False]) = ias_of_list l - {k}", "unfolding ias_of_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length l \\<Longrightarrow>\n    {i. i < length (l[k := False]) \\<and> l[k := False] ! i} =\n    {i. i < length l \\<and> l ! i} - {k}", "by (auto simp: nth_list_update)"], ["", "lemma ias_delete_abs2: \"\\<not>k<length l \n    \\<Longrightarrow> ias_of_list l - {k} = ias_of_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> k < length l \\<Longrightarrow>\n    ias_of_list l - {k} = ias_of_list l", "unfolding ias_of_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> k < length l \\<Longrightarrow>\n    {i. i < length l \\<and> l ! i} - {k} = {i. i < length l \\<and> l ! i}", "by (auto)"], ["", "lemma ias_delete_rule: \"< is_ias m p >\n    ias_delete k p\n    <\\<lambda>r. is_ias (m-{k}) r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_ias m p> ias_delete k p <is_ias (m - {k})>", "unfolding is_ias_def ias_delete_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al. p \\<mapsto>\\<^sub>a l * \\<up> (m = ias_of_list l)>\n    Array.len p \\<bind>\n    (\\<lambda>l. if k < l then Array.upd k False p else return p)\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           r \\<mapsto>\\<^sub>a l * \\<up> (m - {k} = ias_of_list l)>", "by (sep_auto simp: ias_delete_abs1 ias_delete_abs2)"], ["", "lemma ias_ins_abs1: \"ias_of_list (l@replicate n False) = ias_of_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ias_of_list (l @ replicate n False) = ias_of_list l", "unfolding ias_of_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length (l @ replicate n False) \\<and>\n        (l @ replicate n False) ! i} =\n    {i. i < length l \\<and> l ! i}", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. {i. i < length (l @ replicate n False) \\<and>\n        (l @ replicate n False) ! i}\n    \\<subseteq> {i. i < length l \\<and> l ! i}\n 2. {i. i < length l \\<and> l ! i}\n    \\<subseteq> {i. i < length (l @ replicate n False) \\<and>\n                    (l @ replicate n False) ! i}", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {i. i < length (l @ replicate n False) \\<and>\n                   (l @ replicate n False) ! i} \\<Longrightarrow>\n       x \\<in> {i. i < length l \\<and> l ! i}\n 2. {i. i < length l \\<and> l ! i}\n    \\<subseteq> {i. i < length (l @ replicate n False) \\<and>\n                    (l @ replicate n False) ! i}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x < length l + n \\<and> (l @ replicate n False) ! x \\<Longrightarrow>\n       x < length l \\<and> l ! x\n 2. {i. i < length l \\<and> l ! i}\n    \\<subseteq> {i. i < length (l @ replicate n False) \\<and>\n                    (l @ replicate n False) ! i}", "apply (elim conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x < length l + n; (l @ replicate n False) ! x\\<rbrakk>\n       \\<Longrightarrow> x < length l \\<and> l ! x\n 2. {i. i < length l \\<and> l ! i}\n    \\<subseteq> {i. i < length (l @ replicate n False) \\<and>\n                    (l @ replicate n False) ! i}", "apply (case_tac \"x<length l\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x < length l + n; (l @ replicate n False) ! x;\n        x < length l\\<rbrakk>\n       \\<Longrightarrow> x < length l \\<and> l ! x\n 2. \\<And>x.\n       \\<lbrakk>x < length l + n; (l @ replicate n False) ! x;\n        \\<not> x < length l\\<rbrakk>\n       \\<Longrightarrow> x < length l \\<and> l ! x\n 3. {i. i < length l \\<and> l ! i}\n    \\<subseteq> {i. i < length (l @ replicate n False) \\<and>\n                    (l @ replicate n False) ! i}", "apply (simp_all add: nth_append) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length l \\<and> l ! i}\n    \\<subseteq> {i. i < length (l @ replicate n False) \\<and>\n                    (l @ replicate n False) ! i}", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i. i < length l \\<and> l ! i} \\<Longrightarrow>\n       x \\<in> {i. i < length (l @ replicate n False) \\<and>\n                   (l @ replicate n False) ! i}", "apply (simp add: nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ias_ins_abs2: \"\\<not> length l \\<le> k \n    \\<Longrightarrow> ias_of_list (l[k := True]) = insert k (ias_of_list l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length l \\<le> k \\<Longrightarrow>\n    ias_of_list (l[k := True]) = insert k (ias_of_list l)", "unfolding ias_of_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length l \\<le> k \\<Longrightarrow>\n    {i. i < length (l[k := True]) \\<and> l[k := True] ! i} =\n    insert k {i. i < length l \\<and> l ! i}", "by (auto simp: nth_list_update)"], ["", "lemma ias_ins_rule:\n    \"< is_ias m p > ias_ins k p <\\<lambda>r. is_ias (insert k m) r>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_ias m p> ias_ins k p <is_ias (insert k m)>\\<^sub>t", "unfolding is_ias_def ias_ins_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al.\n        p \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (m =\n          ias_of_list\n           l)> Array.len p \\<bind>\n               (\\<lambda>l.\n                   (if l \\<le> k\n                    then let newsz = max (k + 1) (2 * l + 3)\n                         in array_grow p newsz False\n                    else return p) \\<bind>\n                   Array.upd k\n                    True) <\\<lambda>r.\n                              \\<exists>\\<^sub>Al.\n                                 r \\<mapsto>\\<^sub>a l *\n                                 \\<up> (insert k m = ias_of_list l)>\\<^sub>t", "by (sep_auto \n      decon: decon_if_split \n      simp: ias_ins_abs1 ias_ins_abs2)"], ["", "lemma ias_set_impl: \"imp_set is_ias\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set is_ias", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_ias", "by (rule precise_ias)"], ["", "interpretation ias: imp_set is_ias"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set is_ias", "using ias_set_impl"], ["proof (prove)\nusing this:\n  imp_set is_ias\n\ngoal (1 subgoal):\n 1. imp_set is_ias", "."], ["", "lemma ias_empty_impl: \"imp_set_empty is_ias ias_new\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_empty is_ias ias_new", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> ias_new <is_ias {}>\\<^sub>t", "by (sep_auto heap: ias_new_rule)"], ["", "interpretation ias: imp_set_empty is_ias ias_new"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_empty is_ias ias_new", "using ias_empty_impl"], ["proof (prove)\nusing this:\n  imp_set_empty is_ias ias_new\n\ngoal (1 subgoal):\n 1. imp_set_empty is_ias ias_new", "."], ["", "lemma ias_empty_sz_impl: \"imp_set_empty is_ias (ias_new_sz sz)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_empty is_ias (ias_new_sz sz)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> ias_new_sz sz <is_ias {}>\\<^sub>t", "by (sep_auto heap: ias_new_sz_rule)"], ["", "interpretation ias_sz: imp_set_empty is_ias \"ias_new_sz sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_empty is_ias (ias_new_sz sz)", "using ias_empty_sz_impl"], ["proof (prove)\nusing this:\n  imp_set_empty is_ias (ias_new_sz ?sz)\n\ngoal (1 subgoal):\n 1. imp_set_empty is_ias (ias_new_sz sz)", "."], ["", "lemma ias_memb_impl: \"imp_set_memb is_ias ias_memb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_memb is_ias ias_memb", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p a.\n       <is_ias s\n         p> ias_memb a\n             p <\\<lambda>r. is_ias s p * \\<up> (r = (a \\<in> s))>\\<^sub>t", "by (sep_auto heap: ias_memb_rule)"], ["", "interpretation ias: imp_set_memb is_ias ias_memb"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_memb is_ias ias_memb", "using ias_memb_impl"], ["proof (prove)\nusing this:\n  imp_set_memb is_ias ias_memb\n\ngoal (1 subgoal):\n 1. imp_set_memb is_ias ias_memb", "."], ["", "lemma ias_delete_impl: \"imp_set_delete is_ias ias_delete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_delete is_ias ias_delete", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p a. <is_ias s p> ias_delete a p <is_ias (s - {a})>\\<^sub>t", "by (sep_auto heap: ias_delete_rule)"], ["", "interpretation ias: imp_set_delete is_ias ias_delete"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_delete is_ias ias_delete", "using ias_delete_impl"], ["proof (prove)\nusing this:\n  imp_set_delete is_ias ias_delete\n\ngoal (1 subgoal):\n 1. imp_set_delete is_ias ias_delete", "."], ["", "(* Self - contained proof, for paper *)"], ["", "context begin"], ["", "interpretation ias: imp_set_ins is_ias ias_ins"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_ins is_ias ias_ins", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s p a. <is_ias s p> ias_ins a p <is_ias (insert a s)>\\<^sub>t", "fix s p a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s p a. <is_ias s p> ias_ins a p <is_ias (insert a s)>\\<^sub>t", "show \"<is_ias s p> ias_ins a p <is_ias (insert a s)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_ias s p> ias_ins a p <is_ias (insert a s)>\\<^sub>t", "unfolding is_ias_def ias_ins_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al.\n        p \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (s =\n          ias_of_list\n           l)> Array.len p \\<bind>\n               (\\<lambda>l.\n                   (if l \\<le> a\n                    then let newsz = max (a + 1) (2 * l + 3)\n                         in array_grow p newsz False\n                    else return p) \\<bind>\n                   Array.upd a\n                    True) <\\<lambda>r.\n                              \\<exists>\\<^sub>Al.\n                                 r \\<mapsto>\\<^sub>a l *\n                                 \\<up> (insert a s = ias_of_list l)>\\<^sub>t", "by (sep_auto decon: decon_if_split simp: ias_ins_abs1 ias_ins_abs2)"], ["proof (state)\nthis:\n  <is_ias s p> ias_ins a p <is_ias (insert a s)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma \"imp_set_ins is_ias ias_ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_ins is_ias ias_ins", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p a. <is_ias s p> ias_ins a p <is_ias (insert a s)>\\<^sub>t", "by (sep_auto heap: ias_ins_rule)"], ["", "lemma ias_ins_impl: \"imp_set_ins is_ias ias_ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_ins is_ias ias_ins", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p a. <is_ias s p> ias_ins a p <is_ias (insert a s)>\\<^sub>t", "by (sep_auto heap: ias_ins_rule)"], ["", "interpretation ias: imp_set_ins is_ias ias_ins"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_ins is_ias ias_ins", "using ias_ins_impl"], ["proof (prove)\nusing this:\n  imp_set_ins is_ias ias_ins\n\ngoal (1 subgoal):\n 1. imp_set_ins is_ias ias_ins", "."], ["", "end"]]}