{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Imperative/Arrays_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma array_copy_rule [hoare_triple]:\n  \"n \\<le> length as \\<Longrightarrow> n \\<le> length bs \\<Longrightarrow>\n   <a \\<mapsto>\\<^sub>a as * b \\<mapsto>\\<^sub>a bs>\n    array_copy a b n\n   <\\<lambda>_. a \\<mapsto>\\<^sub>a as * b \\<mapsto>\\<^sub>a Arrays_Ex.array_copy as bs n>\"", "lemma swap_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a xs>\n   swap p i j\n   <\\<lambda>_. p \\<mapsto>\\<^sub>a list_swap xs i j>\"", "lemma rev_to_fun [hoare_triple]:\n  \"j < length xs \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a xs>\n   rev p i j\n   <\\<lambda>_. p \\<mapsto>\\<^sub>a rev_swap xs i j>\"", "theorem rev_is_rev [hoare_triple]:\n  \"xs \\<noteq> [] \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a xs>\n   rev p 0 (length xs - 1)\n   <\\<lambda>_. p \\<mapsto>\\<^sub>a List.rev xs>\""], "translations": [["", "lemma array_copy_rule [hoare_triple]:\n  \"n \\<le> length as \\<Longrightarrow> n \\<le> length bs \\<Longrightarrow>\n   <a \\<mapsto>\\<^sub>a as * b \\<mapsto>\\<^sub>a bs>\n    array_copy a b n\n   <\\<lambda>_. a \\<mapsto>\\<^sub>a as * b \\<mapsto>\\<^sub>a Arrays_Ex.array_copy as bs n>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length as; n \\<le> length bs\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a as * b \\<mapsto>\\<^sub>a bs>\n                      Arrays_Impl.array_copy a b n\n                      <\\<lambda>_.\n                          a \\<mapsto>\\<^sub>a as *\n                          b \\<mapsto>\\<^sub>a Arrays_Ex.array_copy as bs n>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length as; n \\<le> length bs\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a as * b \\<mapsto>\\<^sub>a bs>\n                      Arrays_Impl.array_copy a b n\n                      <\\<lambda>_.\n                          a \\<mapsto>\\<^sub>a as *\n                          b \\<mapsto>\\<^sub>a Arrays_Ex.array_copy as bs n>", "@induct n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length as; n \\<le> length bs\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a as * b \\<mapsto>\\<^sub>a bs>\n                      Arrays_Impl.array_copy a b n\n                      <\\<lambda>_.\n                          a \\<mapsto>\\<^sub>a as *\n                          b \\<mapsto>\\<^sub>a Arrays_Ex.array_copy as bs n>", "@qed"], ["", "subsection \\<open>Swap\\<close>"], ["", "definition swap :: \"'a::heap array \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> unit Heap\" where\n  \"swap a i j = do {\n     x \\<leftarrow> Array.nth a i;\n     y \\<leftarrow> Array.nth a j;\n     Array.upd i y a;\n     Array.upd j x a;\n     return ()\n   }\""], ["", "lemma swap_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a xs>\n   swap p i j\n   <\\<lambda>_. p \\<mapsto>\\<^sub>a list_swap xs i j>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs\\<rbrakk>\n    \\<Longrightarrow> <p \\<mapsto>\\<^sub>a xs> swap p i j\n                      <\\<lambda>_. p \\<mapsto>\\<^sub>a list_swap xs i j>", "by auto2"], ["", "subsection \\<open>Reverse\\<close>"], ["", "fun rev :: \"'a::heap array \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> unit Heap\" where\n  \"rev a i j = (if i < j then do {\n     swap a i j;\n     rev a (i + 1) (j - 1)\n   }\n   else return ())\""], ["", "lemma rev_to_fun [hoare_triple]:\n  \"j < length xs \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a xs>\n   rev p i j\n   <\\<lambda>_. p \\<mapsto>\\<^sub>a rev_swap xs i j>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length xs \\<Longrightarrow>\n    <p \\<mapsto>\\<^sub>a xs> Arrays_Impl.rev p i j\n    <\\<lambda>_. p \\<mapsto>\\<^sub>a rev_swap xs i j>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length xs \\<Longrightarrow>\n    <p \\<mapsto>\\<^sub>a xs> Arrays_Impl.rev p i j\n    <\\<lambda>_. p \\<mapsto>\\<^sub>a rev_swap xs i j>", "@fun_induct \"rev_swap xs i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length xs \\<Longrightarrow>\n    <p \\<mapsto>\\<^sub>a xs> Arrays_Impl.rev p i j\n    <\\<lambda>_. p \\<mapsto>\\<^sub>a rev_swap xs i j>", "@unfold \"rev_swap xs i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length xs \\<Longrightarrow>\n    <p \\<mapsto>\\<^sub>a xs> Arrays_Impl.rev p i j\n    <\\<lambda>_. p \\<mapsto>\\<^sub>a rev_swap xs i j>", "@qed"], ["", "text \\<open>Correctness of imperative reverse.\\<close>"], ["", "theorem rev_is_rev [hoare_triple]:\n  \"xs \\<noteq> [] \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a xs>\n   rev p 0 (length xs - 1)\n   <\\<lambda>_. p \\<mapsto>\\<^sub>a List.rev xs>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    <p \\<mapsto>\\<^sub>a xs> Arrays_Impl.rev p 0 (length xs - 1)\n    <\\<lambda>_. p \\<mapsto>\\<^sub>a List.rev xs>", "by auto2"], ["", "end"]]}