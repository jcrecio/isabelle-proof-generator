{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Functional/Mapping_Str.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma meval_ext: \"\\<forall>x. M\\<langle>x\\<rangle> = N\\<langle>x\\<rangle> \\<Longrightarrow> M = N\"", "lemma map_of_alist_nil [rewrite_back]:\n  \"has_key_alist ys x \\<longleftrightarrow> (map_of_alist ys)\\<langle>x\\<rangle> \\<noteq> None\"", "lemma map_of_alist_some [forward]:\n  \"(map_of_alist xs)\\<langle>k\\<rangle> = Some v \\<Longrightarrow> (k, v) \\<in> set xs\"", "lemma map_of_alist_nil':\n  \"x \\<in> set (map fst ys) \\<longleftrightarrow> (map_of_alist ys)\\<langle>x\\<rangle> \\<noteq> None\"", "lemma unique_keys_setD [forward]: \"unique_keys_set S \\<Longrightarrow> (i, x) \\<in> S \\<Longrightarrow> (i, y) \\<in> S \\<Longrightarrow> x = y\"", "lemma map_of_asetI1 [rewrite]: \"unique_keys_set S \\<Longrightarrow> (a, b) \\<in> S \\<Longrightarrow> (map_of_aset S)\\<langle>a\\<rangle> = Some b\"", "lemma map_of_asetI2 [rewrite]: \"\\<forall>b. (a, b) \\<notin> S \\<Longrightarrow> (map_of_aset S)\\<langle>a\\<rangle> = None\"", "lemma map_of_asetD1 [forward]: \"(map_of_aset S)\\<langle>a\\<rangle> = None \\<Longrightarrow> \\<forall>b. (a, b) \\<notin> S\"", "lemma map_of_asetD2 [forward]:\n  \"unique_keys_set S \\<Longrightarrow> (map_of_aset S)\\<langle>a\\<rangle> = Some b \\<Longrightarrow> (a, b) \\<in> S\"", "lemma map_of_aset_insert [rewrite]:\n  \"unique_keys_set (S \\<union> {(k, v)}) \\<Longrightarrow> map_of_aset (S \\<union> {(k, v)}) = (map_of_aset S) {k \\<rightarrow> v}\"", "lemma map_of_alist_to_aset [rewrite]:\n  \"unique_keys_set (set xs) \\<Longrightarrow> map_of_aset (set xs) = map_of_alist xs\"", "lemma map_of_aset_delete [rewrite]:\n  \"unique_keys_set S \\<Longrightarrow> (k, v) \\<in> S \\<Longrightarrow> map_of_aset (S - {(k, v)}) = delete_map k (map_of_aset S)\"", "lemma map_of_aset_update [rewrite]:\n  \"unique_keys_set S \\<Longrightarrow> (k, v) \\<in> S \\<Longrightarrow>\n   map_of_aset (S - {(k, v)} \\<union> {(k, v')}) = (map_of_aset S) {k \\<rightarrow> v'}\"", "lemma map_of_alist_delete [rewrite]:\n  \"set xs' = set xs - {x} \\<Longrightarrow> unique_keys_set (set xs) \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow>\n   map_of_alist xs' = delete_map (fst x) (map_of_alist xs)\"", "lemma map_of_alist_insert [rewrite]:\n  \"set xs' = set xs \\<union> {x} \\<Longrightarrow> unique_keys_set (set xs') \\<Longrightarrow>\n   map_of_alist xs' = (map_of_alist xs) {fst x \\<rightarrow> snd x}\"", "lemma map_of_alist_update [rewrite]:\n  \"set xs' = set xs - {(k, v)} \\<union> {(k, v')} \\<Longrightarrow> unique_keys_set (set xs) \\<Longrightarrow> (k, v) \\<in> set xs \\<Longrightarrow>\n   map_of_alist xs' = (map_of_alist xs) {k \\<rightarrow> v'}\"", "lemma keys_of_iff [rewrite_bidir]: \"x \\<in> keys_of M \\<longleftrightarrow> M\\<langle>x\\<rangle> \\<noteq> None\"", "lemma keys_of_empty [rewrite]: \"keys_of empty_map = {}\"", "lemma keys_of_delete [rewrite]:\n  \"keys_of (delete_map x M) = keys_of M - {x}\"", "lemma map_constr_eval [rewrite]:\n  \"map_constr S f n = Map (\\<lambda>i. if i < n then if S i then Some (f i) else None else None)\"", "lemma keys_of_map_constr [rewrite]:\n  \"i \\<in> keys_of (map_constr S f n) \\<longleftrightarrow> (S i \\<and> i < n)\"", "lemma map_update_all_impl_ind [rewrite]:\n  \"map_update_all_impl f M n = Map (\\<lambda>i. if i < n then if i \\<in> keys_of M then Some (f i) else None else M\\<langle>i\\<rangle>)\"", "lemma map_update_all_impl_correct [rewrite]:\n  \"\\<forall>i\\<in>keys_of M. i < n \\<Longrightarrow> map_update_all_impl f M n = map_update_all f M\"", "lemma keys_of_map_update_all [rewrite]:\n  \"keys_of (map_update_all f M) = keys_of M\""], "translations": [["", "lemma meval_ext: \"\\<forall>x. M\\<langle>x\\<rangle> = N\\<langle>x\\<rangle> \\<Longrightarrow> M = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       M\\<langle>x\\<rangle> = N\\<langle>x\\<rangle> \\<Longrightarrow>\n    M = N", "apply (cases M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x. M\\<langle>x\\<rangle> = N\\<langle>x\\<rangle>;\n        M = Map x\\<rbrakk>\n       \\<Longrightarrow> M = N", "apply (cases N)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>x. M\\<langle>x\\<rangle> = N\\<langle>x\\<rangle>;\n        M = Map x; N = Map xa\\<rbrakk>\n       \\<Longrightarrow> M = N", "by auto"], ["", "setup \\<open>add_backward_prfstep_cond @{thm meval_ext} [with_filt (order_filter \"M\" \"N\")]\\<close>"], ["", "definition empty_map :: \"('a, 'b) map\" where\n  \"empty_map = Map (\\<lambda>x. None)\""], ["", "setup \\<open>add_rewrite_rule @{thm empty_map_def}\\<close>"], ["", "definition update_map :: \"('a, 'b) map \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> ('a ,'b) map\" (\" _ { _ \\<rightarrow> _ }\" [89,90,90] 90) where\n  \"M {k \\<rightarrow> v} = Map (\\<lambda>x. if x = k then Some v else M\\<langle>x\\<rangle>)\""], ["", "setup \\<open>add_rewrite_rule @{thm update_map_def}\\<close>"], ["", "definition delete_map :: \"'a \\<Rightarrow> ('a, 'b) map \\<Rightarrow> ('a, 'b) map\" where\n  \"delete_map k M = Map (\\<lambda>x. if x = k then None else M\\<langle>x\\<rangle>)\""], ["", "setup \\<open>add_rewrite_rule @{thm delete_map_def}\\<close>"], ["", "subsection \\<open>Map from an AList\\<close>"], ["", "fun map_of_alist :: \"('a \\<times> 'b) list \\<Rightarrow> ('a, 'b) map\" where\n  \"map_of_alist [] = empty_map\"\n| \"map_of_alist (x # xs) = (map_of_alist xs) {fst x \\<rightarrow> snd x}\""], ["", "setup \\<open>fold add_rewrite_rule @{thms map_of_alist.simps}\\<close>"], ["", "definition has_key_alist :: \"('a \\<times> 'b) list \\<Rightarrow> 'a \\<Rightarrow> bool\" where [rewrite]:\n  \"has_key_alist xs a \\<longleftrightarrow> (\\<exists>p\\<in>set xs. fst p = a)\""], ["", "lemma map_of_alist_nil [rewrite_back]:\n  \"has_key_alist ys x \\<longleftrightarrow> (map_of_alist ys)\\<langle>x\\<rangle> \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_key_alist ys x = (map_of_alist ys\\<langle>x\\<rangle> \\<noteq> None)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_key_alist ys x = (map_of_alist ys\\<langle>x\\<rangle> \\<noteq> None)", "@induct ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_key_alist ys x = (map_of_alist ys\\<langle>x\\<rangle> \\<noteq> None)", "@qed"], ["", "setup \\<open>add_rewrite_rule_cond @{thm map_of_alist_nil} [with_term \"(map_of_alist ?ys)\\<langle>?x\\<rangle>\"]\\<close>"], ["", "lemma map_of_alist_some [forward]:\n  \"(map_of_alist xs)\\<langle>k\\<rangle> = Some v \\<Longrightarrow> (k, v) \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_alist xs\\<langle>k\\<rangle> = Some v \\<Longrightarrow>\n    (k, v) \\<in> set xs", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_alist xs\\<langle>k\\<rangle> = Some v \\<Longrightarrow>\n    (k, v) \\<in> set xs", "@induct xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_alist xs\\<langle>k\\<rangle> = Some v \\<Longrightarrow>\n    (k, v) \\<in> set xs", "@qed"], ["", "lemma map_of_alist_nil':\n  \"x \\<in> set (map fst ys) \\<longleftrightarrow> (map_of_alist ys)\\<langle>x\\<rangle> \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (map fst ys)) =\n    (map_of_alist ys\\<langle>x\\<rangle> \\<noteq> None)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (map fst ys)) =\n    (map_of_alist ys\\<langle>x\\<rangle> \\<noteq> None)", "@induct ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (map fst ys)) =\n    (map_of_alist ys\\<langle>x\\<rangle> \\<noteq> None)", "@qed"], ["", "setup \\<open>add_rewrite_rule_cond @{thm map_of_alist_nil'} [with_term \"(map_of_alist ?ys)\\<langle>?x\\<rangle>\"]\\<close>"], ["", "subsection \\<open>Mapping defined by a set of key-value pairs\\<close>"], ["", "definition unique_keys_set :: \"('a \\<times> 'b) set \\<Rightarrow> bool\" where [rewrite]:\n  \"unique_keys_set S = (\\<forall>i x y. (i, x) \\<in> S \\<longrightarrow> (i, y) \\<in> S \\<longrightarrow> x = y)\""], ["", "lemma unique_keys_setD [forward]: \"unique_keys_set S \\<Longrightarrow> (i, x) \\<in> S \\<Longrightarrow> (i, y) \\<in> S \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (i, x) \\<in> S; (i, y) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> x = y", "by auto2"], ["", "setup \\<open>del_prfstep_thm_eqforward @{thm unique_keys_set_def}\\<close>"], ["", "definition map_of_aset :: \"('a \\<times> 'b) set \\<Rightarrow> ('a, 'b) map\" where\n  \"map_of_aset S = Map (\\<lambda>a. if \\<exists>b. (a, b) \\<in> S then Some (THE b. (a, b) \\<in> S) else None)\""], ["", "setup \\<open>add_rewrite_rule @{thm map_of_aset_def}\\<close>"], ["", "setup \\<open>add_prfstep_check_req (\"map_of_aset S\", \"unique_keys_set S\")\\<close>"], ["", "lemma map_of_asetI1 [rewrite]: \"unique_keys_set S \\<Longrightarrow> (a, b) \\<in> S \\<Longrightarrow> (map_of_aset S)\\<langle>a\\<rangle> = Some b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (a, b) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset S\\<langle>a\\<rangle> = Some b", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (a, b) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset S\\<langle>a\\<rangle> = Some b", "@have \"\\<exists>b. (a, b) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (a, b) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset S\\<langle>a\\<rangle> = Some b", "@have \"\\<exists>!b. (a, b) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (a, b) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset S\\<langle>a\\<rangle> = Some b", "@qed"], ["", "lemma map_of_asetI2 [rewrite]: \"\\<forall>b. (a, b) \\<notin> S \\<Longrightarrow> (map_of_aset S)\\<langle>a\\<rangle> = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b. (a, b) \\<notin> S \\<Longrightarrow>\n    map_of_aset S\\<langle>a\\<rangle> = None", "by auto2"], ["", "lemma map_of_asetD1 [forward]: \"(map_of_aset S)\\<langle>a\\<rangle> = None \\<Longrightarrow> \\<forall>b. (a, b) \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of_aset S\\<langle>a\\<rangle> = None \\<Longrightarrow>\n    \\<forall>b. (a, b) \\<notin> S", "by auto2"], ["", "lemma map_of_asetD2 [forward]:\n  \"unique_keys_set S \\<Longrightarrow> (map_of_aset S)\\<langle>a\\<rangle> = Some b \\<Longrightarrow> (a, b) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S;\n     map_of_aset S\\<langle>a\\<rangle> = Some b\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> S", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm map_of_aset_def}\\<close>"], ["", "lemma map_of_aset_insert [rewrite]:\n  \"unique_keys_set (S \\<union> {(k, v)}) \\<Longrightarrow> map_of_aset (S \\<union> {(k, v)}) = (map_of_aset S) {k \\<rightarrow> v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (S \\<union> {(k, v)}) \\<Longrightarrow>\n    map_of_aset (S \\<union> {(k, v)}) =  map_of_aset S { k \\<rightarrow> v }", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (S \\<union> {(k, v)}) \\<Longrightarrow>\n    map_of_aset (S \\<union> {(k, v)}) =  map_of_aset S { k \\<rightarrow> v }", "@let \"M = map_of_aset S\" \"N = map_of_aset (S \\<union> {(k, v)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (S \\<union> {(k, v)}) \\<Longrightarrow>\n    map_of_aset (S \\<union> {(k, v)}) =  map_of_aset S { k \\<rightarrow> v }", "@have (@rule) \"\\<forall>x. N\\<langle>x\\<rangle> = (M {k \\<rightarrow> v}) \\<langle>x\\<rangle>\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (S \\<union> {(k, v)}) \\<Longrightarrow>\n    map_of_aset (S \\<union> {(k, v)}) =  map_of_aset S { k \\<rightarrow> v }", "@case \"M\\<langle>x\\<rangle> = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (S \\<union> {(k, v)}) \\<Longrightarrow>\n    map_of_aset (S \\<union> {(k, v)}) =  map_of_aset S { k \\<rightarrow> v }", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (S \\<union> {(k, v)}) \\<Longrightarrow>\n    map_of_aset (S \\<union> {(k, v)}) =  map_of_aset S { k \\<rightarrow> v }", "@qed"], ["", "lemma map_of_alist_to_aset [rewrite]:\n  \"unique_keys_set (set xs) \\<Longrightarrow> map_of_aset (set xs) = map_of_alist xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (set xs) \\<Longrightarrow>\n    map_of_aset (set xs) = map_of_alist xs", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (set xs) \\<Longrightarrow>\n    map_of_aset (set xs) = map_of_alist xs", "@induct xs @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (set xs) \\<Longrightarrow>\n    map_of_aset (set xs) = map_of_alist xs", "@subgoal \"xs = x # xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (set xs) \\<Longrightarrow>\n    map_of_aset (set xs) = map_of_alist xs", "@have \"set (x # xs') = set xs' \\<union> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (set xs) \\<Longrightarrow>\n    map_of_aset (set xs) = map_of_alist xs", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (set xs) \\<Longrightarrow>\n    map_of_aset (set xs) = map_of_alist xs", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_keys_set (set xs) \\<Longrightarrow>\n    map_of_aset (set xs) = map_of_alist xs", "@qed"], ["", "lemma map_of_aset_delete [rewrite]:\n  \"unique_keys_set S \\<Longrightarrow> (k, v) \\<in> S \\<Longrightarrow> map_of_aset (S - {(k, v)}) = delete_map k (map_of_aset S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (k, v) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset (S - {(k, v)}) =\n                      delete_map k (map_of_aset S)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (k, v) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset (S - {(k, v)}) =\n                      delete_map k (map_of_aset S)", "@let \"T = S - {(k, v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (k, v) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset (S - {(k, v)}) =\n                      delete_map k (map_of_aset S)", "@let \"M = map_of_aset S\" \"N = map_of_aset T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (k, v) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset (S - {(k, v)}) =\n                      delete_map k (map_of_aset S)", "@have (@rule) \"\\<forall>x. N\\<langle>x\\<rangle> = (delete_map k M) \\<langle>x\\<rangle>\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (k, v) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset (S - {(k, v)}) =\n                      delete_map k (map_of_aset S)", "@case \"M\\<langle>x\\<rangle> = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (k, v) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset (S - {(k, v)}) =\n                      delete_map k (map_of_aset S)", "@case \"x = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (k, v) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset (S - {(k, v)}) =\n                      delete_map k (map_of_aset S)", "@obtain y where \"M\\<langle>x\\<rangle> = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (k, v) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset (S - {(k, v)}) =\n                      delete_map k (map_of_aset S)", "@have \"(x, y) \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (k, v) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset (S - {(k, v)}) =\n                      delete_map k (map_of_aset S)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (k, v) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset (S - {(k, v)}) =\n                      delete_map k (map_of_aset S)", "@qed"], ["", "lemma map_of_aset_update [rewrite]:\n  \"unique_keys_set S \\<Longrightarrow> (k, v) \\<in> S \\<Longrightarrow>\n   map_of_aset (S - {(k, v)} \\<union> {(k, v')}) = (map_of_aset S) {k \\<rightarrow> v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_keys_set S; (k, v) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map_of_aset (S - {(k, v)} \\<union> {(k, v')}) =\n                       map_of_aset S { k \\<rightarrow> v' }", "by auto2"], ["", "lemma map_of_alist_delete [rewrite]:\n  \"set xs' = set xs - {x} \\<Longrightarrow> unique_keys_set (set xs) \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow>\n   map_of_alist xs' = delete_map (fst x) (map_of_alist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs' = set xs - {x}; unique_keys_set (set xs);\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> map_of_alist xs' =\n                      delete_map (fst x) (map_of_alist xs)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs' = set xs - {x}; unique_keys_set (set xs);\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> map_of_alist xs' =\n                      delete_map (fst x) (map_of_alist xs)", "@have \"map_of_alist xs' = map_of_aset (set xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs' = set xs - {x}; unique_keys_set (set xs);\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> map_of_alist xs' =\n                      delete_map (fst x) (map_of_alist xs)", "@qed"], ["", "lemma map_of_alist_insert [rewrite]:\n  \"set xs' = set xs \\<union> {x} \\<Longrightarrow> unique_keys_set (set xs') \\<Longrightarrow>\n   map_of_alist xs' = (map_of_alist xs) {fst x \\<rightarrow> snd x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs' = set xs \\<union> {x};\n     unique_keys_set (set xs')\\<rbrakk>\n    \\<Longrightarrow> map_of_alist xs' =\n                       map_of_alist xs { fst x \\<rightarrow> snd x }", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs' = set xs \\<union> {x};\n     unique_keys_set (set xs')\\<rbrakk>\n    \\<Longrightarrow> map_of_alist xs' =\n                       map_of_alist xs { fst x \\<rightarrow> snd x }", "@have \"map_of_alist xs' = map_of_aset (set xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs' = set xs \\<union> {x};\n     unique_keys_set (set xs')\\<rbrakk>\n    \\<Longrightarrow> map_of_alist xs' =\n                       map_of_alist xs { fst x \\<rightarrow> snd x }", "@qed"], ["", "lemma map_of_alist_update [rewrite]:\n  \"set xs' = set xs - {(k, v)} \\<union> {(k, v')} \\<Longrightarrow> unique_keys_set (set xs) \\<Longrightarrow> (k, v) \\<in> set xs \\<Longrightarrow>\n   map_of_alist xs' = (map_of_alist xs) {k \\<rightarrow> v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs' = set xs - {(k, v)} \\<union> {(k, v')};\n     unique_keys_set (set xs); (k, v) \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> map_of_alist xs' =\n                       map_of_alist xs { k \\<rightarrow> v' }", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs' = set xs - {(k, v)} \\<union> {(k, v')};\n     unique_keys_set (set xs); (k, v) \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> map_of_alist xs' =\n                       map_of_alist xs { k \\<rightarrow> v' }", "@have \"map_of_alist xs' = map_of_aset (set xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs' = set xs - {(k, v)} \\<union> {(k, v')};\n     unique_keys_set (set xs); (k, v) \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> map_of_alist xs' =\n                       map_of_alist xs { k \\<rightarrow> v' }", "@qed"], ["", "subsection \\<open>Set of keys of a mapping\\<close>"], ["", "definition keys_of :: \"('a, 'b) map \\<Rightarrow> 'a set\" where [rewrite]:\n  \"keys_of M = {x. M\\<langle>x\\<rangle> \\<noteq> None}\""], ["", "lemma keys_of_iff [rewrite_bidir]: \"x \\<in> keys_of M \\<longleftrightarrow> M\\<langle>x\\<rangle> \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> keys_of M) = (M\\<langle>x\\<rangle> \\<noteq> None)", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm keys_of_def}\\<close>"], ["", "lemma keys_of_empty [rewrite]: \"keys_of empty_map = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys_of empty_map = {}", "by auto2"], ["", "lemma keys_of_delete [rewrite]:\n  \"keys_of (delete_map x M) = keys_of M - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys_of (delete_map x M) = keys_of M - {x}", "by auto2"], ["", "subsection \\<open>Minimum of a mapping, relevant for heaps (priority queues)\\<close>"], ["", "definition is_heap_min :: \"'a \\<Rightarrow> ('a, 'b::linorder) map \\<Rightarrow> bool\" where [rewrite]:\n  \"is_heap_min x M \\<longleftrightarrow> x \\<in> keys_of M \\<and> (\\<forall>k\\<in>keys_of M. the (M\\<langle>x\\<rangle>) \\<le> the (M\\<langle>k\\<rangle>))\""], ["", "subsection \\<open>General construction and update of maps\\<close>"], ["", "fun map_constr :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> nat \\<Rightarrow> (nat, 'a) map\" where\n  \"map_constr S f 0 = empty_map\"\n| \"map_constr S f (Suc k) = (let M = map_constr S f k in if S k then M {k \\<rightarrow> f k} else M)\""], ["", "setup \\<open>fold add_rewrite_rule @{thms map_constr.simps}\\<close>"], ["", "lemma map_constr_eval [rewrite]:\n  \"map_constr S f n = Map (\\<lambda>i. if i < n then if S i then Some (f i) else None else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_constr S f n =\n    Map (\\<lambda>i.\n            if i < n then if S i then Some (f i) else None else None)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_constr S f n =\n    Map (\\<lambda>i.\n            if i < n then if S i then Some (f i) else None else None)", "@induct n"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_constr S f n =\n    Map (\\<lambda>i.\n            if i < n then if S i then Some (f i) else None else None)", "@qed"], ["", "lemma keys_of_map_constr [rewrite]:\n  \"i \\<in> keys_of (map_constr S f n) \\<longleftrightarrow> (S i \\<and> i < n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> keys_of (map_constr S f n)) = (S i \\<and> i < n)", "by auto2"], ["", "definition map_update_all :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> (nat, 'a) map \\<Rightarrow> (nat, 'a) map\" where [rewrite]:\n  \"map_update_all f M = Map (\\<lambda>i. if i \\<in> keys_of M then Some (f i) else M\\<langle>i\\<rangle>)\""], ["", "fun map_update_all_impl :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> (nat, 'a) map \\<Rightarrow> nat \\<Rightarrow> (nat, 'a) map\" where\n  \"map_update_all_impl f M 0 = M\"\n| \"map_update_all_impl f M (Suc k) =\n   (let M' = map_update_all_impl f M k in if k \\<in> keys_of M then M' {k \\<rightarrow> f k} else M')\""], ["", "setup \\<open>fold add_rewrite_rule @{thms map_update_all_impl.simps}\\<close>"], ["", "lemma map_update_all_impl_ind [rewrite]:\n  \"map_update_all_impl f M n = Map (\\<lambda>i. if i < n then if i \\<in> keys_of M then Some (f i) else None else M\\<langle>i\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update_all_impl f M n =\n    Map (\\<lambda>i.\n            if i < n then if i \\<in> keys_of M then Some (f i) else None\n            else M\\<langle>i\\<rangle>)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update_all_impl f M n =\n    Map (\\<lambda>i.\n            if i < n then if i \\<in> keys_of M then Some (f i) else None\n            else M\\<langle>i\\<rangle>)", "@induct n"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update_all_impl f M n =\n    Map (\\<lambda>i.\n            if i < n then if i \\<in> keys_of M then Some (f i) else None\n            else M\\<langle>i\\<rangle>)", "@qed"], ["", "lemma map_update_all_impl_correct [rewrite]:\n  \"\\<forall>i\\<in>keys_of M. i < n \\<Longrightarrow> map_update_all_impl f M n = map_update_all f M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>keys_of M. i < n \\<Longrightarrow>\n    map_update_all_impl f M n = map_update_all f M", "by auto2"], ["", "lemma keys_of_map_update_all [rewrite]:\n  \"keys_of (map_update_all f M) = keys_of M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys_of (map_update_all f M) = keys_of M", "by auto2"], ["", "end"]]}