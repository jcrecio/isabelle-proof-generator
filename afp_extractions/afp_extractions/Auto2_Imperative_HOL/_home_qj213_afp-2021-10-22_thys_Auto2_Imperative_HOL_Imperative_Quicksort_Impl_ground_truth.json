{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Imperative/Quicksort_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma part1_to_fun [hoare_triple]:\n  \"r < length xs \\<Longrightarrow> <p \\<mapsto>\\<^sub>a xs>\n   part1 p l r a\n   <\\<lambda>rs. p \\<mapsto>\\<^sub>a snd (Quicksort.part1 xs l r a) * \\<up>(rs = fst (Quicksort.part1 xs l r a))>\"", "lemma partition_to_fun [hoare_triple]:\n  \"l < r \\<Longrightarrow> r < length xs \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs>\n   partition a l r\n   <\\<lambda>rs. a \\<mapsto>\\<^sub>a snd (Quicksort.partition xs l r) * \\<up>(rs = fst (Quicksort.partition xs l r))>\"", "lemma quicksort_to_fun [hoare_triple]:\n  \"r < length xs \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs>\n   quicksort a l r\n   <\\<lambda>_. a \\<mapsto>\\<^sub>a Quicksort.quicksort xs l r>\"", "theorem quicksort_sorts_basic [hoare_triple]:\n  \"<a \\<mapsto>\\<^sub>a xs>\n   quicksort_all a\n   <\\<lambda>_. a \\<mapsto>\\<^sub>a sort xs>\""], "translations": [["", "lemma part1_to_fun [hoare_triple]:\n  \"r < length xs \\<Longrightarrow> <p \\<mapsto>\\<^sub>a xs>\n   part1 p l r a\n   <\\<lambda>rs. p \\<mapsto>\\<^sub>a snd (Quicksort.part1 xs l r a) * \\<up>(rs = fst (Quicksort.part1 xs l r a))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    <p \\<mapsto>\\<^sub>a xs> Quicksort_Impl.part1 p l r a\n    <\\<lambda>rs.\n        p \\<mapsto>\\<^sub>a snd (Quicksort.part1 xs l r a) *\n        \\<up> (rs = fst (Quicksort.part1 xs l r a))>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    <p \\<mapsto>\\<^sub>a xs> Quicksort_Impl.part1 p l r a\n    <\\<lambda>rs.\n        p \\<mapsto>\\<^sub>a snd (Quicksort.part1 xs l r a) *\n        \\<up> (rs = fst (Quicksort.part1 xs l r a))>", "@fun_induct \"Quicksort.part1 xs l r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    <p \\<mapsto>\\<^sub>a xs> Quicksort_Impl.part1 p l r a\n    <\\<lambda>rs.\n        p \\<mapsto>\\<^sub>a snd (Quicksort.part1 xs l r a) *\n        \\<up> (rs = fst (Quicksort.part1 xs l r a))>", "@unfold \"Quicksort.part1 xs l r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    <p \\<mapsto>\\<^sub>a xs> Quicksort_Impl.part1 p l r a\n    <\\<lambda>rs.\n        p \\<mapsto>\\<^sub>a snd (Quicksort.part1 xs l r a) *\n        \\<up> (rs = fst (Quicksort.part1 xs l r a))>", "@qed"], ["", "text \\<open>Partition function\\<close>"], ["", "definition partition :: \"'a::{heap,linorder} array \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat Heap\" where\n  \"partition a l r = do {\n     p \\<leftarrow> Array.nth a r;\n     m \\<leftarrow> part1 a l (r - 1) p;\n     v \\<leftarrow> Array.nth a m;\n     m' \\<leftarrow> return (if v \\<le> p then m + 1 else m);\n     swap a m' r;\n     return m'\n   }\""], ["", "lemma partition_to_fun [hoare_triple]:\n  \"l < r \\<Longrightarrow> r < length xs \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs>\n   partition a l r\n   <\\<lambda>rs. a \\<mapsto>\\<^sub>a snd (Quicksort.partition xs l r) * \\<up>(rs = fst (Quicksort.partition xs l r))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs>\n                      Quicksort_Impl.partition a l r\n                      <\\<lambda>rs.\n                          a \\<mapsto>\\<^sub>a\n                          snd (Quicksort.partition xs l r) *\n                          \\<up> (rs = fst (Quicksort.partition xs l r))>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs>\n                      Quicksort_Impl.partition a l r\n                      <\\<lambda>rs.\n                          a \\<mapsto>\\<^sub>a\n                          snd (Quicksort.partition xs l r) *\n                          \\<up> (rs = fst (Quicksort.partition xs l r))>", "@unfold \"Quicksort.partition xs l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs>\n                      Quicksort_Impl.partition a l r\n                      <\\<lambda>rs.\n                          a \\<mapsto>\\<^sub>a\n                          snd (Quicksort.partition xs l r) *\n                          \\<up> (rs = fst (Quicksort.partition xs l r))>", "@qed"], ["", "text \\<open>Quicksort function\\<close>"], ["", "partial_function (heap) quicksort :: \"'a::{heap,linorder} array \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> unit Heap\" where\n  \"quicksort a l r = do {\n     len \\<leftarrow> Array.len a;\n     if l \\<ge> r then return ()\n     else if r < len then do {\n       p \\<leftarrow> partition a l r;\n       quicksort a l (p - 1);\n       quicksort a (p + 1) r\n     }\n     else return ()\n   }\""], ["", "lemma quicksort_to_fun [hoare_triple]:\n  \"r < length xs \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs>\n   quicksort a l r\n   <\\<lambda>_. a \\<mapsto>\\<^sub>a Quicksort.quicksort xs l r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    <a \\<mapsto>\\<^sub>a xs> Quicksort_Impl.quicksort a l r\n    <\\<lambda>_. a \\<mapsto>\\<^sub>a Quicksort.quicksort xs l r>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    <a \\<mapsto>\\<^sub>a xs> Quicksort_Impl.quicksort a l r\n    <\\<lambda>_. a \\<mapsto>\\<^sub>a Quicksort.quicksort xs l r>", "@fun_induct \"Quicksort.quicksort xs l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    <a \\<mapsto>\\<^sub>a xs> Quicksort_Impl.quicksort a l r\n    <\\<lambda>_. a \\<mapsto>\\<^sub>a Quicksort.quicksort xs l r>", "@unfold \"Quicksort.quicksort xs l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    <a \\<mapsto>\\<^sub>a xs> Quicksort_Impl.quicksort a l r\n    <\\<lambda>_. a \\<mapsto>\\<^sub>a Quicksort.quicksort xs l r>", "@qed"], ["", "definition quicksort_all :: \"('a::{heap,linorder}) array \\<Rightarrow> unit Heap\" where\n  \"quicksort_all a = do {\n     n \\<leftarrow> Array.len a;\n     if n = 0 then return ()\n     else quicksort a 0 (n - 1)\n   }\""], ["", "text \\<open>Correctness of quicksort.\\<close>"], ["", "theorem quicksort_sorts_basic [hoare_triple]:\n  \"<a \\<mapsto>\\<^sub>a xs>\n   quicksort_all a\n   <\\<lambda>_. a \\<mapsto>\\<^sub>a sort xs>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs> quicksort_all a\n    <\\<lambda>_. a \\<mapsto>\\<^sub>a sort xs>", "by auto2"], ["", "end"]]}