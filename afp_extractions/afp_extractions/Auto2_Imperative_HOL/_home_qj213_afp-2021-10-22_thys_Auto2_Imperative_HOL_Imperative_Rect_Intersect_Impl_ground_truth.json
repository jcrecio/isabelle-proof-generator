{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Imperative/Rect_Intersect_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma rect_inter_init_rule [hoare_triple]:\n  \"<emp> rect_inter_init rects <\\<lambda>p. p \\<mapsto>\\<^sub>a all_ops rects>\"", "lemma op_int_is_interval:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> k < length ops \\<Longrightarrow>\n   is_interval (op_int (ops ! k))\"", "lemma rect_inter_next_rule [hoare_triple]:\n  \"is_rect_list rects \\<Longrightarrow> k < length (all_ops rects) \\<Longrightarrow>\n   <a \\<mapsto>\\<^sub>a all_ops rects * int_tree_set S b>\n   rect_inter_next a b k\n   <\\<lambda>r. a \\<mapsto>\\<^sub>a all_ops rects * int_tree_set (apply_ops_k_next rects S k) r>\\<^sub>t\"", "lemma rect_inter_to_fun_ind [hoare_triple]:\n  \"is_rect_list rects \\<Longrightarrow> k < length (all_ops rects) \\<Longrightarrow>\n   <a \\<mapsto>\\<^sub>a all_ops rects * int_tree_set S b>\n   rect_inter_impl a b k\n   <\\<lambda>r. a \\<mapsto>\\<^sub>a all_ops rects * \\<up>(r \\<longleftrightarrow> rect_inter rects S k)>\\<^sub>t\"", "theorem rect_inter_all_correct:\n  \"is_rect_list rects \\<Longrightarrow>\n   <emp>\n   rect_inter_all rects\n   <\\<lambda>r. \\<up>(r = has_rect_overlap rects)>\\<^sub>t\""], "translations": [["", "lemma rect_inter_init_rule [hoare_triple]:\n  \"<emp> rect_inter_init rects <\\<lambda>p. p \\<mapsto>\\<^sub>a all_ops rects>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> rect_inter_init rects\n    <\\<lambda>p. p \\<mapsto>\\<^sub>a all_ops rects>", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm all_ops_def}\\<close>"], ["", "definition rect_inter_next :: \"nat operation array \\<Rightarrow> int_tree \\<Rightarrow> nat \\<Rightarrow> int_tree Heap\" where\n  \"rect_inter_next a b k = do {\n    oper \\<leftarrow> Array.nth a k;\n    if is_INS oper then\n      IntervalTree_Impl.insert_impl (IdxInterval (op_int oper) (op_idx oper)) b\n    else\n      IntervalTree_Impl.delete_impl (IdxInterval (op_int oper) (op_idx oper)) b }\""], ["", "lemma op_int_is_interval:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> k < length ops \\<Longrightarrow>\n   is_interval (op_int (ops ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     k < length ops\\<rbrakk>\n    \\<Longrightarrow> is_interval (op_int (ops ! k))", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     k < length ops\\<rbrakk>\n    \\<Longrightarrow> is_interval (op_int (ops ! k))", "@have \"ops ! k \\<in> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     k < length ops\\<rbrakk>\n    \\<Longrightarrow> is_interval (op_int (ops ! k))", "@case \"is_INS (ops ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     k < length ops\\<rbrakk>\n    \\<Longrightarrow> is_interval (op_int (ops ! k))", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm op_int_is_interval} [with_term \"op_int (?ops ! ?k)\"]\\<close>"], ["", "lemma rect_inter_next_rule [hoare_triple]:\n  \"is_rect_list rects \\<Longrightarrow> k < length (all_ops rects) \\<Longrightarrow>\n   <a \\<mapsto>\\<^sub>a all_ops rects * int_tree_set S b>\n   rect_inter_next a b k\n   <\\<lambda>r. a \\<mapsto>\\<^sub>a all_ops rects * int_tree_set (apply_ops_k_next rects S k) r>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_next a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  int_tree_set (apply_ops_k_next rects S k)\n                                   r>\\<^sub>t", "by auto2"], ["", "partial_function (heap) rect_inter_impl ::\n  \"nat operation array \\<Rightarrow> int_tree \\<Rightarrow> nat \\<Rightarrow> bool Heap\" where\n  \"rect_inter_impl a b k = do {\n    n \\<leftarrow> Array.len a;\n    (if k \\<ge> n then return False\n     else do {\n       oper \\<leftarrow> Array.nth a k;\n       (if is_INS oper then do {\n          overlap \\<leftarrow> IntervalTree_Impl.search_impl (op_int oper) b;\n          if overlap then return True\n          else if k = n - 1 then return False\n          else do {\n            b' \\<leftarrow> rect_inter_next a b k;\n            rect_inter_impl a b' (k + 1)}}\n        else\n          if k = n - 1 then return False\n          else do {\n            b' \\<leftarrow> rect_inter_next a b k;\n            rect_inter_impl a b' (k + 1)})})}\""], ["", "lemma rect_inter_to_fun_ind [hoare_triple]:\n  \"is_rect_list rects \\<Longrightarrow> k < length (all_ops rects) \\<Longrightarrow>\n   <a \\<mapsto>\\<^sub>a all_ops rects * int_tree_set S b>\n   rect_inter_impl a b k\n   <\\<lambda>r. a \\<mapsto>\\<^sub>a all_ops rects * \\<up>(r \\<longleftrightarrow> rect_inter rects S k)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@let \"d = length (all_ops rects) - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@strong_induct d arbitrary k S b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@case \"k \\<ge> length (all_ops rects)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@unfold \"rect_inter rects S k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@case \"is_INS (all_ops rects ! k)\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@case \"has_overlap S (op_int (all_ops rects ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@case \"k = length (all_ops rects) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@apply_induct_hyp \"length (all_ops rects) - (k + 1)\" \"k + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@have \"length (all_ops rects) - (k + 1) < d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@case \"k = length (all_ops rects) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@apply_induct_hyp \"length (all_ops rects) - (k + 1)\" \"k + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@have \"length (all_ops rects) - (k + 1) < d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; k < length (all_ops rects)\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a all_ops rects *\n                       int_tree_set S\n                        b> rect_inter_impl a b\n                            k <\\<lambda>r.\n                                  a \\<mapsto>\\<^sub>a all_ops rects *\n                                  \\<up> (r = rect_inter rects S k)>\\<^sub>t", "@qed"], ["", "definition rect_inter_all :: \"nat rectangle list \\<Rightarrow> bool Heap\" where\n  \"rect_inter_all rects =\n    (if rects = [] then return False\n     else do {\n       a \\<leftarrow> rect_inter_init rects;\n       b \\<leftarrow> int_tree_empty;\n       rect_inter_impl a b 0 })\""], ["", "text \\<open>Correctness of rectangle intersection algorithm.\\<close>"], ["", "theorem rect_inter_all_correct:\n  \"is_rect_list rects \\<Longrightarrow>\n   <emp>\n   rect_inter_all rects\n   <\\<lambda>r. \\<up>(r = has_rect_overlap rects)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rect_list rects \\<Longrightarrow>\n    <emp> rect_inter_all\n           rects <\\<lambda>r. \\<up> (r = has_rect_overlap rects)>\\<^sub>t", "by auto2"], ["", "end"]]}