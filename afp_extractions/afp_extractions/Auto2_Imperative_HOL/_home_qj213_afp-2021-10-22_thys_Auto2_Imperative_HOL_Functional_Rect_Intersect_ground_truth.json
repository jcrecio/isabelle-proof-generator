{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Functional/Rect_Intersect.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma is_rect_listD: \"is_rect_list rects \\<Longrightarrow> i < length rects \\<Longrightarrow> is_rect (rects ! i)\"", "lemma operation_leD [forward]:\n  \"(a::('a::linorder operation)) \\<le> b \\<Longrightarrow> pos a \\<le> pos b\"", "lemma operation_lessI [backward]:\n  \"p1 \\<le> p2 \\<Longrightarrow> INS p1 n1 i1 < DEL p2 n2 i2\"", "lemma ins_ops_distinct [forward]: \"distinct (ins_ops rects)\"", "lemma del_ops_distinct [forward]: \"distinct (del_ops rects)\"", "lemma set_ins_ops [rewrite]:\n  \"oper \\<in> set (ins_ops rects) \\<longleftrightarrow> op_idx oper < length rects \\<and> oper = ins_op rects (op_idx oper)\"", "lemma set_del_ops [rewrite]:\n  \"oper \\<in> set (del_ops rects) \\<longleftrightarrow> op_idx oper < length rects \\<and> oper = del_op rects (op_idx oper)\"", "lemma all_ops_distinct [forward]: \"distinct (all_ops rects)\"", "lemma set_all_ops_idx [forward]:\n  \"oper \\<in> set (all_ops rects) \\<Longrightarrow> op_idx oper < length rects\"", "lemma set_all_ops_ins [forward]:\n  \"INS p n i \\<in> set (all_ops rects) \\<Longrightarrow> INS p n i = ins_op rects n\"", "lemma set_all_ops_del [forward]:\n  \"DEL p n i \\<in> set (all_ops rects) \\<Longrightarrow> DEL p n i = del_op rects n\"", "lemma ins_in_set_all_ops:\n  \"i < length rects \\<Longrightarrow> ins_op rects i \\<in> set (all_ops rects)\"", "lemma del_in_set_all_ops:\n  \"i < length rects \\<Longrightarrow> del_op rects i \\<in> set (all_ops rects)\"", "lemma all_ops_sorted [forward]: \"sorted (all_ops rects)\"", "lemma all_ops_nonempty [backward]: \"rects \\<noteq> [] \\<Longrightarrow> all_ops rects \\<noteq> []\"", "lemma apply_ops_set_mem [rewrite]:\n  \"ops = all_ops rects \\<Longrightarrow>\n   i \\<in> apply_ops_k rects k \\<longleftrightarrow> (i < length rects \\<and> (\\<exists>j<k. ins_op rects i = ops ! j) \\<and> \\<not>(\\<exists>j<k. del_op rects i = ops ! j))\"", "lemma xints_of_mem [rewrite]:\n  \"IdxInterval it i \\<in> xints_of rect is \\<longleftrightarrow> (i \\<in> is \\<and> xint (rect ! i) = it)\"", "lemma xints_diff [rewrite]:\n  \"xints_of rects (A - B) = xints_of rects A - xints_of rects B\"", "lemma has_overlap_at_k_equiv [forward]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> k < length ops \\<Longrightarrow>\n   has_overlap_at_k rects k \\<Longrightarrow> has_rect_overlap rects\"", "lemma has_overlap_at_k_equiv2 [resolve]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> has_rect_overlap rects \\<Longrightarrow>\n   \\<exists>k<length ops. has_overlap_at_k rects k\"", "lemma has_overlap_equiv [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> has_overlap_lst rects \\<longleftrightarrow> has_rect_overlap rects\"", "lemma apply_ops_k_next1 [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> n < length ops \\<Longrightarrow> is_INS (ops ! n) \\<Longrightarrow>\n   apply_ops_k rects (n + 1) = apply_ops_k rects n \\<union> {op_idx (ops ! n)}\"", "lemma apply_ops_k_next2 [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> n < length ops \\<Longrightarrow> \\<not>is_INS (ops ! n) \\<Longrightarrow>\n   apply_ops_k rects (n + 1) = apply_ops_k rects n - {op_idx (ops ! n)}\"", "lemma apply_ops_k_next_is_correct [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> n < length ops \\<Longrightarrow>\n   S = xints_of rects (apply_ops_k rects n) \\<Longrightarrow>\n   xints_of rects (apply_ops_k rects (n + 1)) = apply_ops_k_next rects S n\"", "lemma rect_inter_correct_ind [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> n < length ops \\<Longrightarrow>\n   rect_inter rects (xints_of rects (apply_ops_k rects n)) n \\<longleftrightarrow>\n   (\\<exists>k<length ops. k \\<ge> n \\<and> has_overlap_at_k rects k)\"", "theorem rect_inter_correct [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> rect_inter rects {} 0 \\<longleftrightarrow> has_rect_overlap rects\""], "translations": [["", "lemma is_rect_listD: \"is_rect_list rects \\<Longrightarrow> i < length rects \\<Longrightarrow> is_rect (rects ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; i < length rects\\<rbrakk>\n    \\<Longrightarrow> is_rect (rects ! i)", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm is_rect_listD} [with_term \"?rects ! ?i\"]\\<close>"], ["", "setup \\<open>del_prfstep_thm_eqforward @{thm is_rect_list_def}\\<close>"], ["", "definition is_rect_overlap :: \"('a::linorder) rectangle \\<Rightarrow> ('a::linorder) rectangle \\<Rightarrow> bool\" where [rewrite]:\n  \"is_rect_overlap A B \\<longleftrightarrow> (is_overlap (xint A) (xint B) \\<and> is_overlap (yint A) (yint B))\""], ["", "definition has_rect_overlap :: \"('a::linorder) rectangle list \\<Rightarrow> bool\" where [rewrite]:\n  \"has_rect_overlap As \\<longleftrightarrow> (\\<exists>i<length As. \\<exists>j<length As. i \\<noteq> j \\<and> is_rect_overlap (As ! i) (As ! j))\""], ["", "subsection \\<open>INS / DEL operations\\<close>"], ["", "datatype 'a operation =\n  INS (pos: 'a) (op_idx: nat) (op_int: \"'a interval\")\n| DEL (pos: 'a) (op_idx: nat) (op_int: \"'a interval\")"], ["", "setup \\<open>fold add_rewrite_rule_back @{thms operation.collapse}\\<close>"], ["", "setup \\<open>fold add_rewrite_rule @{thms operation.sel}\\<close>"], ["", "setup \\<open>fold add_rewrite_rule @{thms operation.case}\\<close>"], ["", "setup \\<open>add_resolve_prfstep @{thm operation.distinct(1)}\\<close>"], ["", "setup \\<open>add_forward_prfstep_cond @{thm operation.disc(1)} [with_term \"INS ?x11.0 ?x12.0 ?x13.0\"]\\<close>"], ["", "setup \\<open>add_forward_prfstep_cond @{thm operation.disc(2)} [with_term \"DEL ?x21.0 ?x22.0 ?x23.0\"]\\<close>"], ["", "instantiation operation :: (linorder) linorder begin"], ["", "definition less: \"(a < b) = (if pos a \\<noteq> pos b then pos a < pos b else\n                             if is_INS a \\<noteq> is_INS b then is_INS a \\<and> \\<not>is_INS b\n                             else if op_idx a \\<noteq> op_idx b then op_idx a < op_idx b else op_int a < op_int b)\""], ["", "definition less_eq: \"(a \\<le> b) = (if pos a \\<noteq> pos b then pos a < pos b else\n                              if is_INS a \\<noteq> is_INS b then is_INS a \\<and> \\<not>is_INS b\n                              else if op_idx a \\<noteq> op_idx b then op_idx a < op_idx b else op_int a \\<le> op_int b)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a operation, linorder_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "fix x y z :: \"'a operation\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "show a: \"(x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by (smt Rect_Intersect.less Rect_Intersect.less_eq leD le_cases3 not_less_iff_gr_or_eq)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "show b: \"x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "by (simp add: local.less_eq)"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "show c: \"x \\<le> y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "by (smt Rect_Intersect.less Rect_Intersect.less_eq a dual_order.trans less_trans)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "show d: \"x \\<le> y \\<Longrightarrow> y \\<le> x \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "by (metis Rect_Intersect.less Rect_Intersect.less_eq a le_imp_less_or_eq operation.expand)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "show e: \"x \\<le> y \\<or> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<or> y \\<le> x", "using local.less_eq"], ["proof (prove)\nusing this:\n  (?a \\<le> ?b) =\n  (if pos ?a \\<noteq> pos ?b then pos ?a < pos ?b\n   else if is_INS ?a \\<noteq> is_INS ?b\n        then is_INS ?a \\<and> \\<not> is_INS ?b\n        else if op_idx ?a \\<noteq> op_idx ?b then op_idx ?a < op_idx ?b\n             else op_int ?a \\<le> op_int ?b)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<or> y \\<le> x", "by fastforce"], ["proof (state)\nthis:\n  x \\<le> y \\<or> y \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "setup \\<open>fold add_rewrite_rule [@{thm less_eq}, @{thm less}]\\<close>"], ["", "lemma operation_leD [forward]:\n  \"(a::('a::linorder operation)) \\<le> b \\<Longrightarrow> pos a \\<le> pos b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> pos a \\<le> pos b", "by auto2"], ["", "lemma operation_lessI [backward]:\n  \"p1 \\<le> p2 \\<Longrightarrow> INS p1 n1 i1 < DEL p2 n2 i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<le> p2 \\<Longrightarrow> INS p1 n1 i1 < DEL p2 n2 i2", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<le> p2 \\<Longrightarrow> INS p1 n1 i1 < DEL p2 n2 i2", "@have \"is_INS (INS p1 n1 i1) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<le> p2 \\<Longrightarrow> INS p1 n1 i1 < DEL p2 n2 i2", "@have \"is_INS (DEL p2 n2 i2) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<le> p2 \\<Longrightarrow> INS p1 n1 i1 < DEL p2 n2 i2", "@qed"], ["", "setup \\<open>fold del_prfstep_thm [@{thm less_eq}, @{thm less}]\\<close>"], ["", "subsection \\<open>Set of operations corresponding to a list of rectangles\\<close>"], ["", "fun ins_op :: \"'a rectangle list \\<Rightarrow> nat \\<Rightarrow> ('a::linorder) operation\" where\n  \"ins_op rects i = INS (low (yint (rects ! i))) i (xint (rects ! i))\""], ["", "setup \\<open>add_rewrite_rule @{thm ins_op.simps}\\<close>"], ["", "fun del_op :: \"'a rectangle list \\<Rightarrow> nat \\<Rightarrow> ('a::linorder) operation\" where\n  \"del_op rects i = DEL (high (yint (rects ! i))) i (xint (rects ! i))\""], ["", "setup \\<open>add_rewrite_rule @{thm del_op.simps}\\<close>"], ["", "definition ins_ops :: \"'a rectangle list \\<Rightarrow> ('a::linorder) operation list\" where [rewrite]:\n  \"ins_ops rects = list (\\<lambda>i. ins_op rects i) (length rects)\""], ["", "definition del_ops :: \"'a rectangle list \\<Rightarrow> ('a::linorder) operation list\" where [rewrite]:\n  \"del_ops rects = list (\\<lambda>i. del_op rects i) (length rects)\""], ["", "lemma ins_ops_distinct [forward]: \"distinct (ins_ops rects)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ins_ops rects)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ins_ops rects)", "@let \"xs = ins_ops rects\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ins_ops rects)", "@have \"\\<forall>i<length xs. \\<forall>j<length xs. i \\<noteq> j \\<longrightarrow> xs ! i \\<noteq> xs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ins_ops rects)", "@qed"], ["", "lemma del_ops_distinct [forward]: \"distinct (del_ops rects)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (del_ops rects)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (del_ops rects)", "@let \"xs = del_ops rects\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (del_ops rects)", "@have \"\\<forall>i<length xs. \\<forall>j<length xs. i \\<noteq> j \\<longrightarrow> xs ! i \\<noteq> xs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (del_ops rects)", "@qed"], ["", "lemma set_ins_ops [rewrite]:\n  \"oper \\<in> set (ins_ops rects) \\<longleftrightarrow> op_idx oper < length rects \\<and> oper = ins_op rects (op_idx oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (ins_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = ins_op rects (op_idx oper))", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (ins_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = ins_op rects (op_idx oper))", "@case \"oper \\<in> set (ins_ops rects)\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (ins_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = ins_op rects (op_idx oper))", "@obtain i where \"i < length rects\" \"ins_ops rects ! i = oper\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (ins_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = ins_op rects (op_idx oper))", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (ins_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = ins_op rects (op_idx oper))", "@case \"op_idx oper < length rects \\<and> oper = ins_op rects (op_idx oper)\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (ins_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = ins_op rects (op_idx oper))", "@have \"oper = (ins_ops rects) ! (op_idx oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (ins_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = ins_op rects (op_idx oper))", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (ins_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = ins_op rects (op_idx oper))", "@qed"], ["", "lemma set_del_ops [rewrite]:\n  \"oper \\<in> set (del_ops rects) \\<longleftrightarrow> op_idx oper < length rects \\<and> oper = del_op rects (op_idx oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (del_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = del_op rects (op_idx oper))", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (del_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = del_op rects (op_idx oper))", "@case \"oper \\<in> set (del_ops rects)\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (del_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = del_op rects (op_idx oper))", "@obtain i where \"i < length rects\" \"del_ops rects ! i = oper\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (del_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = del_op rects (op_idx oper))", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (del_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = del_op rects (op_idx oper))", "@case \"op_idx oper < length rects \\<and> oper = del_op rects (op_idx oper)\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (del_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = del_op rects (op_idx oper))", "@have \"oper = (del_ops rects) ! (op_idx oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (del_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = del_op rects (op_idx oper))", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oper \\<in> set (del_ops rects)) =\n    (op_idx oper < length rects \\<and> oper = del_op rects (op_idx oper))", "@qed"], ["", "definition all_ops :: \"'a rectangle list \\<Rightarrow> ('a::linorder) operation list\" where [rewrite]:\n  \"all_ops rects = sort (ins_ops rects @ del_ops rects)\""], ["", "lemma all_ops_distinct [forward]: \"distinct (all_ops rects)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (all_ops rects)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (all_ops rects)", "@have \"distinct (ins_ops rects @ del_ops rects)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (all_ops rects)", "@qed"], ["", "lemma set_all_ops_idx [forward]:\n  \"oper \\<in> set (all_ops rects) \\<Longrightarrow> op_idx oper < length rects\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oper \\<in> set (all_ops rects) \\<Longrightarrow>\n    op_idx oper < length rects", "by auto2"], ["", "lemma set_all_ops_ins [forward]:\n  \"INS p n i \\<in> set (all_ops rects) \\<Longrightarrow> INS p n i = ins_op rects n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. INS p n i \\<in> set (all_ops rects) \\<Longrightarrow>\n    INS p n i = ins_op rects n", "by auto2"], ["", "lemma set_all_ops_del [forward]:\n  \"DEL p n i \\<in> set (all_ops rects) \\<Longrightarrow> DEL p n i = del_op rects n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DEL p n i \\<in> set (all_ops rects) \\<Longrightarrow>\n    DEL p n i = del_op rects n", "by auto2"], ["", "lemma ins_in_set_all_ops:\n  \"i < length rects \\<Longrightarrow> ins_op rects i \\<in> set (all_ops rects)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length rects \\<Longrightarrow>\n    ins_op rects i \\<in> set (all_ops rects)", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm ins_in_set_all_ops} [with_term \"ins_op ?rects ?i\"]\\<close>"], ["", "lemma del_in_set_all_ops:\n  \"i < length rects \\<Longrightarrow> del_op rects i \\<in> set (all_ops rects)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length rects \\<Longrightarrow>\n    del_op rects i \\<in> set (all_ops rects)", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm del_in_set_all_ops} [with_term \"del_op ?rects ?i\"]\\<close>"], ["", "lemma all_ops_sorted [forward]: \"sorted (all_ops rects)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (all_ops rects)", "by auto2"], ["", "lemma all_ops_nonempty [backward]: \"rects \\<noteq> [] \\<Longrightarrow> all_ops rects \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rects \\<noteq> [] \\<Longrightarrow> all_ops rects \\<noteq> []", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. rects \\<noteq> [] \\<Longrightarrow> all_ops rects \\<noteq> []", "@have \"length (all_ops rects) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rects \\<noteq> [] \\<Longrightarrow> all_ops rects \\<noteq> []", "@qed"], ["", "setup \\<open>del_prfstep_thm @{thm all_ops_def}\\<close>"], ["", "subsection \\<open>Applying a set of operations\\<close>"], ["", "definition apply_ops_k :: \"('a::linorder) rectangle list \\<Rightarrow> nat \\<Rightarrow> nat set\" where [rewrite]:\n  \"apply_ops_k rects k = (let ops = all_ops rects in\n     {i. i < length rects \\<and> (\\<exists>j<k. ins_op rects i = ops ! j) \\<and> \\<not>(\\<exists>j<k. del_op rects i = ops ! j)})\""], ["", "setup \\<open>register_wellform_data (\"apply_ops_k rects k\", [\"k < length (all_ops rects)\"])\\<close>"], ["", "lemma apply_ops_set_mem [rewrite]:\n  \"ops = all_ops rects \\<Longrightarrow>\n   i \\<in> apply_ops_k rects k \\<longleftrightarrow> (i < length rects \\<and> (\\<exists>j<k. ins_op rects i = ops ! j) \\<and> \\<not>(\\<exists>j<k. del_op rects i = ops ! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ops = all_ops rects \\<Longrightarrow>\n    (i \\<in> apply_ops_k rects k) =\n    (i < length rects \\<and>\n     (\\<exists>j<k. ins_op rects i = ops ! j) \\<and>\n     \\<not> (\\<exists>j<k. del_op rects i = ops ! j))", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm apply_ops_k_def}\\<close>"], ["", "definition xints_of :: \"'a rectangle list \\<Rightarrow> nat set \\<Rightarrow> (('a::linorder) idx_interval) set\" where [rewrite]:\n  \"xints_of rect is = (\\<lambda>i. IdxInterval (xint (rect ! i)) i) ` is\""], ["", "lemma xints_of_mem [rewrite]:\n  \"IdxInterval it i \\<in> xints_of rect is \\<longleftrightarrow> (i \\<in> is \\<and> xint (rect ! i) = it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (IdxInterval it i \\<in> xints_of rect is) =\n    (i \\<in> is \\<and> xint (rect ! i) = it)", "using xints_of_def"], ["proof (prove)\nusing this:\n  xints_of ?rect ?is = (\\<lambda>i. IdxInterval (xint (?rect ! i)) i) ` ?is\n\ngoal (1 subgoal):\n 1. (IdxInterval it i \\<in> xints_of rect is) =\n    (i \\<in> is \\<and> xint (rect ! i) = it)", "by auto"], ["", "lemma xints_diff [rewrite]:\n  \"xints_of rects (A - B) = xints_of rects A - xints_of rects B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xints_of rects (A - B) = xints_of rects A - xints_of rects B", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. xints_of rects (A - B) = xints_of rects A - xints_of rects B", "@have \"inj (\\<lambda>i. IdxInterval (xint (rects ! i)) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xints_of rects (A - B) = xints_of rects A - xints_of rects B", "@qed"], ["", "definition has_overlap_at_k :: \"('a::linorder) rectangle list \\<Rightarrow> nat \\<Rightarrow> bool\" where [rewrite]:\n  \"has_overlap_at_k rects k \\<longleftrightarrow> (\n    let S = apply_ops_k rects k; ops = all_ops rects in\n      is_INS (ops ! k) \\<and> has_overlap (xints_of rects S) (op_int (ops ! k)))\""], ["", "setup \\<open>register_wellform_data (\"has_overlap_at_k rects k\", [\"k < length (all_ops rects)\"])\\<close>"], ["", "lemma has_overlap_at_k_equiv [forward]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> k < length ops \\<Longrightarrow>\n   has_overlap_at_k rects k \\<Longrightarrow> has_rect_overlap rects\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@let \"S = apply_ops_k rects k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@have \"has_overlap (xints_of rects S) (op_int (ops ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@obtain \"xs' \\<in> xints_of rects S\" where \"is_overlap (int xs') (op_int (ops ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@let \"xs = int xs'\" \"i = idx xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@let \"j = op_idx (ops ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@have \"ops ! k = ins_op rects j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@have \"i \\<noteq> j\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@contradiction"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@obtain k' where \"k' < k\" \"ops ! k' = ins_op rects i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@have \"ops ! k = ops ! k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@have \"low (yint (rects ! i)) \\<le> pos (ops ! k)\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@obtain k' where \"k' < k\" \"ops ! k' = ins_op rects i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@have \"ops ! k' \\<le> ops ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@have \"high (yint (rects ! i)) \\<ge> pos (ops ! k)\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@obtain k' where \"k' < length ops\" \"ops ! k' = del_op rects i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@have \"ops ! k' \\<ge> ops ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@have \"is_rect_overlap (rects ! i) (rects ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; k < length ops;\n     has_overlap_at_k rects k\\<rbrakk>\n    \\<Longrightarrow> has_rect_overlap rects", "@qed"], ["", "lemma has_overlap_at_k_equiv2 [resolve]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> has_rect_overlap rects \\<Longrightarrow>\n   \\<exists>k<length ops. has_overlap_at_k rects k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@obtain i j where \"i < length rects\" \"j < length rects\" \"i \\<noteq> j\"\n                    \"is_rect_overlap (rects ! i) (rects ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@have \"is_rect_overlap (rects ! j) (rects ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@obtain i1 where \"i1 < length ops\" \"ops ! i1 = ins_op rects i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@obtain j1 where \"j1 < length ops\" \"ops ! j1 = ins_op rects j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@obtain i2 where \"i2 < length ops\" \"ops ! i2 = del_op rects i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@obtain j2 where \"j2 < length ops\" \"ops ! j2 = del_op rects j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@case \"ins_op rects i < ins_op rects j\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@have \"i1 < j1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@have \"j1 < i2\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@have \"ops ! j1 < ops ! i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@have \"is_overlap (int (IdxInterval (xint (rects ! i)) i)) (xint (rects ! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@have \"has_overlap_at_k rects j1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@case \"ins_op rects j < ins_op rects i\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@have \"j1 < i1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@have \"i1 < j2\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@have \"ops ! i1 < ops ! j2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@have \"is_overlap (int (IdxInterval (xint (rects ! j)) j)) (xint (rects ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@have \"has_overlap_at_k rects i1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     has_rect_overlap rects\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length ops. has_overlap_at_k rects k", "@qed"], ["", "definition has_overlap_lst :: \"('a::linorder) rectangle list \\<Rightarrow> bool\" where [rewrite]:\n  \"has_overlap_lst rects = (let ops = all_ops rects in (\\<exists>k<length ops. has_overlap_at_k rects k))\""], ["", "lemma has_overlap_equiv [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> has_overlap_lst rects \\<longleftrightarrow> has_rect_overlap rects\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rect_list rects \\<Longrightarrow>\n    has_overlap_lst rects = has_rect_overlap rects", "by auto2"], ["", "subsection \\<open>Implementation of apply\\_ops\\_k\\<close>"], ["", "lemma apply_ops_k_next1 [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> n < length ops \\<Longrightarrow> is_INS (ops ! n) \\<Longrightarrow>\n   apply_ops_k rects (n + 1) = apply_ops_k rects n \\<union> {op_idx (ops ! n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     is_INS (ops ! n)\\<rbrakk>\n    \\<Longrightarrow> apply_ops_k rects (n + 1) =\n                      apply_ops_k rects n \\<union> {op_idx (ops ! n)}", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     is_INS (ops ! n)\\<rbrakk>\n    \\<Longrightarrow> apply_ops_k rects (n + 1) =\n                      apply_ops_k rects n \\<union> {op_idx (ops ! n)}", "@have \"\\<forall>i. i\\<in>apply_ops_k rects (n + 1) \\<longleftrightarrow> i\\<in>apply_ops_k rects n \\<union> {op_idx (ops ! n)}\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     is_INS (ops ! n)\\<rbrakk>\n    \\<Longrightarrow> apply_ops_k rects (n + 1) =\n                      apply_ops_k rects n \\<union> {op_idx (ops ! n)}", "@case \"i \\<in> apply_ops_k rects n \\<union> {op_idx (ops ! n)}\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     is_INS (ops ! n)\\<rbrakk>\n    \\<Longrightarrow> apply_ops_k rects (n + 1) =\n                      apply_ops_k rects n \\<union> {op_idx (ops ! n)}", "@case \"i = op_idx (ops ! n)\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     is_INS (ops ! n)\\<rbrakk>\n    \\<Longrightarrow> apply_ops_k rects (n + 1) =\n                      apply_ops_k rects n \\<union> {op_idx (ops ! n)}", "@have \"ins_op rects i < del_op rects i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     is_INS (ops ! n)\\<rbrakk>\n    \\<Longrightarrow> apply_ops_k rects (n + 1) =\n                      apply_ops_k rects n \\<union> {op_idx (ops ! n)}", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     is_INS (ops ! n)\\<rbrakk>\n    \\<Longrightarrow> apply_ops_k rects (n + 1) =\n                      apply_ops_k rects n \\<union> {op_idx (ops ! n)}", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     is_INS (ops ! n)\\<rbrakk>\n    \\<Longrightarrow> apply_ops_k rects (n + 1) =\n                      apply_ops_k rects n \\<union> {op_idx (ops ! n)}", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     is_INS (ops ! n)\\<rbrakk>\n    \\<Longrightarrow> apply_ops_k rects (n + 1) =\n                      apply_ops_k rects n \\<union> {op_idx (ops ! n)}", "@qed"], ["", "lemma apply_ops_k_next2 [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> n < length ops \\<Longrightarrow> \\<not>is_INS (ops ! n) \\<Longrightarrow>\n   apply_ops_k rects (n + 1) = apply_ops_k rects n - {op_idx (ops ! n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     \\<not> is_INS (ops ! n)\\<rbrakk>\n    \\<Longrightarrow> apply_ops_k rects (n + 1) =\n                      apply_ops_k rects n - {op_idx (ops ! n)}", "by auto2"], ["", "definition apply_ops_k_next :: \"('a::linorder) rectangle list \\<Rightarrow> 'a idx_interval set \\<Rightarrow> nat \\<Rightarrow> 'a idx_interval set\" where\n  \"apply_ops_k_next rects S k = (let ops = all_ops rects in\n   (case ops ! k of\n      INS p n i \\<Rightarrow> S \\<union> {IdxInterval i n}\n    | DEL p n i \\<Rightarrow> S - {IdxInterval i n}))\""], ["", "setup \\<open>add_rewrite_rule @{thm apply_ops_k_next_def}\\<close>"], ["", "lemma apply_ops_k_next_is_correct [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> n < length ops \\<Longrightarrow>\n   S = xints_of rects (apply_ops_k rects n) \\<Longrightarrow>\n   xints_of rects (apply_ops_k rects (n + 1)) = apply_ops_k_next rects S n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     S = xints_of rects (apply_ops_k rects n)\\<rbrakk>\n    \\<Longrightarrow> xints_of rects (apply_ops_k rects (n + 1)) =\n                      apply_ops_k_next rects S n", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     S = xints_of rects (apply_ops_k rects n)\\<rbrakk>\n    \\<Longrightarrow> xints_of rects (apply_ops_k rects (n + 1)) =\n                      apply_ops_k_next rects S n", "@case \"is_INS (ops ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects; n < length ops;\n     S = xints_of rects (apply_ops_k rects n)\\<rbrakk>\n    \\<Longrightarrow> xints_of rects (apply_ops_k rects (n + 1)) =\n                      apply_ops_k_next rects S n", "@qed"], ["", "function rect_inter :: \"nat rectangle list \\<Rightarrow> nat idx_interval set \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"rect_inter rects S k = (let ops = all_ops rects in\n    if k \\<ge> length ops then False\n    else if is_INS (ops ! k) then\n      if has_overlap S (op_int (ops ! k)) then True\n      else if k = length ops - 1 then False\n      else rect_inter rects (apply_ops_k_next rects S k) (k + 1)\n    else if k = length ops - 1 then False\n      else rect_inter rects (apply_ops_k_next rects S k) (k + 1))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>rects S k.\n           x = (rects, S, k) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>rects S k rectsa Sa ka.\n       (rects, S, k) = (rectsa, Sa, ka) \\<Longrightarrow>\n       (let ops = all_ops rects\n        in if length ops \\<le> k then False\n           else if is_INS (ops ! k)\n                then if has_overlap S (op_int (ops ! k)) then True\n                     else if k = length ops - 1 then False\n                          else rect_inter_sumC\n                                (rects, apply_ops_k_next rects S k, k + 1)\n                else if k = length ops - 1 then False\n                     else rect_inter_sumC\n                           (rects, apply_ops_k_next rects S k, k + 1)) =\n       (let ops = all_ops rectsa\n        in if length ops \\<le> ka then False\n           else if is_INS (ops ! ka)\n                then if has_overlap Sa (op_int (ops ! ka)) then True\n                     else if ka = length ops - 1 then False\n                          else rect_inter_sumC\n                                (rectsa, apply_ops_k_next rectsa Sa ka,\n                                 ka + 1)\n                else if ka = length ops - 1 then False\n                     else rect_inter_sumC\n                           (rectsa, apply_ops_k_next rectsa Sa ka, ka + 1))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All rect_inter_dom", "by (relation \"measure (\\<lambda>(rects,S,k). length (all_ops rects) - k)\") auto"], ["", "lemma rect_inter_correct_ind [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> ops = all_ops rects \\<Longrightarrow> n < length ops \\<Longrightarrow>\n   rect_inter rects (xints_of rects (apply_ops_k rects n)) n \\<longleftrightarrow>\n   (\\<exists>k<length ops. k \\<ge> n \\<and> has_overlap_at_k rects k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     n < length ops\\<rbrakk>\n    \\<Longrightarrow> rect_inter rects\n                       (xints_of rects (apply_ops_k rects n)) n =\n                      (\\<exists>k<length ops.\n                          n \\<le> k \\<and> has_overlap_at_k rects k)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     n < length ops\\<rbrakk>\n    \\<Longrightarrow> rect_inter rects\n                       (xints_of rects (apply_ops_k rects n)) n =\n                      (\\<exists>k<length ops.\n                          n \\<le> k \\<and> has_overlap_at_k rects k)", "@let \"ints = xints_of rects (apply_ops_k rects n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     n < length ops\\<rbrakk>\n    \\<Longrightarrow> rect_inter rects\n                       (xints_of rects (apply_ops_k rects n)) n =\n                      (\\<exists>k<length ops.\n                          n \\<le> k \\<and> has_overlap_at_k rects k)", "@fun_induct \"rect_inter rects ints n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     n < length ops\\<rbrakk>\n    \\<Longrightarrow> rect_inter rects\n                       (xints_of rects (apply_ops_k rects n)) n =\n                      (\\<exists>k<length ops.\n                          n \\<le> k \\<and> has_overlap_at_k rects k)", "@unfold \"rect_inter rects ints n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     n < length ops\\<rbrakk>\n    \\<Longrightarrow> rect_inter rects\n                       (xints_of rects (apply_ops_k rects n)) n =\n                      (\\<exists>k<length ops.\n                          n \\<le> k \\<and> has_overlap_at_k rects k)", "@case \"n \\<ge> length ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     n < length ops\\<rbrakk>\n    \\<Longrightarrow> rect_inter rects\n                       (xints_of rects (apply_ops_k rects n)) n =\n                      (\\<exists>k<length ops.\n                          n \\<le> k \\<and> has_overlap_at_k rects k)", "@case \"is_INS (ops ! n) \\<and> has_overlap ints (op_int (ops ! n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     n < length ops\\<rbrakk>\n    \\<Longrightarrow> rect_inter rects\n                       (xints_of rects (apply_ops_k rects n)) n =\n                      (\\<exists>k<length ops.\n                          n \\<le> k \\<and> has_overlap_at_k rects k)", "@case \"n = length ops - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rect_list rects; ops = all_ops rects;\n     n < length ops\\<rbrakk>\n    \\<Longrightarrow> rect_inter rects\n                       (xints_of rects (apply_ops_k rects n)) n =\n                      (\\<exists>k<length ops.\n                          n \\<le> k \\<and> has_overlap_at_k rects k)", "@qed"], ["", "text \\<open>Correctness of functional algorithm.\\<close>"], ["", "theorem rect_inter_correct [rewrite]:\n  \"is_rect_list rects \\<Longrightarrow> rect_inter rects {} 0 \\<longleftrightarrow> has_rect_overlap rects\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rect_list rects \\<Longrightarrow>\n    rect_inter rects {} 0 = has_rect_overlap rects", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rect_list rects \\<Longrightarrow>\n    rect_inter rects {} 0 = has_rect_overlap rects", "@have \"{} = xints_of rects (apply_ops_k rects 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rect_list rects \\<Longrightarrow>\n    rect_inter rects {} 0 = has_rect_overlap rects", "@have \"rect_inter rects {} 0 = has_overlap_lst rects\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rect_list rects \\<Longrightarrow>\n    rect_inter rects {} 0 = has_rect_overlap rects", "@unfold \"rect_inter rects {} 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rect_list rects \\<Longrightarrow>\n    rect_inter rects {} 0 = has_rect_overlap rects", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rect_list rects \\<Longrightarrow>\n    rect_inter rects {} 0 = has_rect_overlap rects", "@qed"], ["", "end"]]}