{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Functional/RBTree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma not_R [forward]: \"c \\<noteq> R \\<Longrightarrow> c = B\"", "lemma not_B [forward]: \"c \\<noteq> B \\<Longrightarrow> c = R\"", "lemma red_not_leaf [forward]: \"cl t = R \\<Longrightarrow> t \\<noteq> Leaf\"", "lemma cl_invI: \"cl_inv l \\<Longrightarrow> cl_inv r \\<Longrightarrow> cl_inv (Node l B k v r)\"", "lemma bd_invI: \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> black_depth l = black_depth r \\<Longrightarrow> bd_inv (Node l c k v r)\"", "lemma is_rbt_rec [forward]: \"is_rbt (Node l c k v r) \\<Longrightarrow> is_rbt l \\<and> is_rbt r\"", "lemma two_distrib [rewrite]: \"(2::nat) * (a + 1) = 2 * a + 2\"", "theorem rbt_balanced: \"is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1\"", "lemma cl_inv'B [forward, backward1]:\n  \"cl_inv' t \\<Longrightarrow> cl t = B \\<Longrightarrow> cl_inv t\"", "lemma cl_inv'R [forward]:\n  \"cl_inv' (Node l R k v r) \\<Longrightarrow> cl l = B \\<Longrightarrow> cl r = B \\<Longrightarrow> cl_inv (Node l R k v r)\"", "lemma cl_inv_to_cl_inv' [forward]: \"cl_inv t \\<Longrightarrow> cl_inv' t\"", "lemma cl_inv'I [forward_arg]:\n  \"cl_inv l \\<Longrightarrow> cl_inv r \\<Longrightarrow> cl_inv' (Node l c k v r)\"", "lemma rbt_in_traverse_fst [rewrite]: \"map fst (rbt_in_traverse_pairs t) = rbt_in_traverse t\"", "lemma rbt_sorted_lr [forward]:\n  \"rbt_sorted (Node l c k v r) \\<Longrightarrow> rbt_sorted l \\<and> rbt_sorted r\"", "lemma rbt_inorder_preserve_set [rewrite]:\n  \"rbt_set t = set (rbt_in_traverse t)\"", "lemma rbt_inorder_sorted [rewrite]:\n  \"rbt_sorted t \\<longleftrightarrow> strict_sorted (map fst (rbt_in_traverse_pairs t))\"", "lemma balance_non_Leaf [resolve]: \"balance l k v r \\<noteq> Leaf\"", "lemma balance_bdinv [forward_arg]:\n  \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> black_depth l = black_depth r \\<Longrightarrow> bd_inv (balance l k v r)\"", "lemma balance_bd [rewrite]:\n  \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> black_depth l = black_depth r \\<Longrightarrow>\n   black_depth (balance l k v r) = black_depth l + 1\"", "lemma balance_cl1 [forward]:\n  \"cl_inv' l \\<Longrightarrow> cl_inv r \\<Longrightarrow> cl_inv (balance l k v r)\"", "lemma balance_cl2 [forward]:\n  \"cl_inv l \\<Longrightarrow> cl_inv' r \\<Longrightarrow> cl_inv (balance l k v r)\"", "lemma balanceR_inorder_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (balanceR l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r\"", "lemma balance_inorder_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (balance l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r\"", "lemma ins_non_Leaf [resolve]: \"ins x v t \\<noteq> Leaf\"", "lemma cl_inv_ins [forward]:\n  \"cl_inv t \\<Longrightarrow> cl_inv' (ins x v t)\"", "lemma bd_inv_ins:\n  \"bd_inv t \\<Longrightarrow> bd_inv (ins x v t) \\<and> black_depth t = black_depth (ins x v t)\"", "lemma ins_inorder_pairs [rewrite]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_in_traverse_pairs (ins x v t) = ordered_insert_pairs x v (rbt_in_traverse_pairs t)\"", "lemma paint_cl_inv' [forward]: \"cl_inv' t \\<Longrightarrow> cl_inv' (paint c t)\"", "lemma paint_bd_inv [forward]: \"bd_inv t \\<Longrightarrow> bd_inv (paint c t)\"", "lemma paint_bd [rewrite]:\n  \"bd_inv t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> cl t = B \\<Longrightarrow> black_depth (paint R t) = black_depth t - 1\"", "lemma paint_in_traverse_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (paint c t) = rbt_in_traverse_pairs t\"", "theorem insert_is_rbt [forward]:\n  \"is_rbt t \\<Longrightarrow> is_rbt (rbt_insert x v t)\"", "theorem insert_sorted [forward]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_sorted (rbt_insert x v t)\"", "theorem insert_rbt_map [rewrite]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_map (rbt_insert x v t) = (rbt_map t) {x \\<rightarrow> v}\"", "theorem rbt_search_correct [rewrite]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_search t x = (rbt_map t)\\<langle>x\\<rangle>\"", "lemma balL_bd [forward_arg]:\n  \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> cl r = B \\<Longrightarrow> black_depth l + 1 = black_depth r \\<Longrightarrow>\n   bd_inv (balL l k v r) \\<and> black_depth (balL l k v r) = black_depth l + 1\"", "lemma balL_bd' [forward_arg]:\n  \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> cl_inv r \\<Longrightarrow> black_depth l + 1 = black_depth r \\<Longrightarrow>\n   bd_inv (balL l k v r) \\<and> black_depth (balL l k v r) = black_depth l + 1\"", "lemma balL_cl [forward_arg]:\n  \"cl_inv' l \\<Longrightarrow> cl_inv r \\<Longrightarrow> cl r = B \\<Longrightarrow> cl_inv (balL l k v r)\"", "lemma balL_cl' [forward]:\n  \"cl_inv' l \\<Longrightarrow> cl_inv r \\<Longrightarrow> cl_inv' (balL l k v r)\"", "lemma balR_bd [forward_arg]:\n  \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> cl_inv l \\<Longrightarrow> black_depth l = black_depth r + 1 \\<Longrightarrow>\n   bd_inv (balR l k v r) \\<and> black_depth (balR l k v r) = black_depth l\"", "lemma balR_cl [forward_arg]:\n  \"cl_inv l \\<Longrightarrow> cl_inv' r \\<Longrightarrow> cl l = B \\<Longrightarrow> cl_inv (balR l k v r)\"", "lemma balR_cl' [forward]:\n  \"cl_inv l \\<Longrightarrow> cl_inv' r \\<Longrightarrow> cl_inv' (balR l k v r)\"", "lemma balL_in_traverse_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (balL l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r\"", "lemma balR_in_traverse_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (balR l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r\"", "lemma combine_bd [forward_arg]:\n  \"bd_inv lt \\<Longrightarrow> bd_inv rt \\<Longrightarrow> black_depth lt = black_depth rt \\<Longrightarrow>\n   bd_inv (combine lt rt) \\<and> black_depth (combine lt rt) = black_depth lt\"", "lemma combine_cl:\n  \"cl_inv lt \\<Longrightarrow> cl_inv rt \\<Longrightarrow>\n   (cl lt = B \\<longrightarrow> cl rt = B \\<longrightarrow> cl_inv (combine lt rt)) \\<and> cl_inv' (combine lt rt)\"", "lemma combine_in_traverse_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (combine lt rt) = rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt\"", "lemma del_bd [forward_arg]:\n  \"bd_inv t \\<Longrightarrow> cl_inv t \\<Longrightarrow> bd_inv (del x t) \\<and> (\n    if cl t = R then black_depth (del x t) = black_depth t\n    else black_depth (del x t) = black_depth t - 1)\"", "lemma del_cl:\n  \"cl_inv t \\<Longrightarrow> if cl t = R then cl_inv (del x t) else cl_inv' (del x t)\"", "lemma del_in_traverse_pairs [rewrite]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_in_traverse_pairs (del x t) = remove_elt_pairs x (rbt_in_traverse_pairs t)\"", "theorem delete_is_rbt [forward]:\n  \"is_rbt t \\<Longrightarrow> is_rbt (delete x t)\"", "theorem delete_sorted [forward]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_sorted (delete x t)\"", "theorem delete_rbt_map [rewrite]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_map (delete x t) = delete_map x (rbt_map t)\""], "translations": [["", "lemma not_R [forward]: \"c \\<noteq> R \\<Longrightarrow> c = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> R \\<Longrightarrow> c = B", "using color.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = R \\<Longrightarrow> ?P; ?y = B \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. c \\<noteq> R \\<Longrightarrow> c = B", "by blast"], ["", "lemma not_B [forward]: \"c \\<noteq> B \\<Longrightarrow> c = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> B \\<Longrightarrow> c = R", "using color.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = R \\<Longrightarrow> ?P; ?y = B \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. c \\<noteq> B \\<Longrightarrow> c = R", "by blast"], ["", "lemma red_not_leaf [forward]: \"cl t = R \\<Longrightarrow> t \\<noteq> Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl t = R \\<Longrightarrow> t \\<noteq> Leaf", "by auto"], ["", "subsection \\<open>RBT invariants\\<close>"], ["", "fun black_depth :: \"('a, 'b) rbt \\<Rightarrow> nat\" where\n  \"black_depth Leaf = 0\"\n| \"black_depth (Node l R k v r) = black_depth l\"\n| \"black_depth (Node l B k v r) = black_depth l + 1\""], ["", "setup \\<open>fold add_rewrite_rule @{thms black_depth.simps}\\<close>"], ["", "fun cl_inv :: \"('a, 'b) rbt \\<Rightarrow> bool\" where\n  \"cl_inv Leaf = True\"\n| \"cl_inv (Node l R k v r) = (cl_inv l \\<and> cl_inv r \\<and> cl l = B \\<and> cl r = B)\"\n| \"cl_inv (Node l B k v r) = (cl_inv l \\<and> cl_inv r)\""], ["", "setup \\<open>fold add_rewrite_rule @{thms cl_inv.simps}\\<close>"], ["", "fun bd_inv :: \"('a, 'b) rbt \\<Rightarrow> bool\" where\n  \"bd_inv Leaf = True\"\n| \"bd_inv (Node l c k v r) = (bd_inv l \\<and> bd_inv r \\<and> black_depth l = black_depth r)\""], ["", "setup \\<open>fold add_rewrite_rule @{thms bd_inv.simps}\\<close>"], ["", "definition is_rbt :: \"('a, 'b) rbt \\<Rightarrow> bool\" where [rewrite]:\n  \"is_rbt t = (cl_inv t \\<and> bd_inv t)\""], ["", "lemma cl_invI: \"cl_inv l \\<Longrightarrow> cl_inv r \\<Longrightarrow> cl_inv (Node l B k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv l; cl_inv r\\<rbrakk>\n    \\<Longrightarrow> cl_inv (Node l B k v r)", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm cl_invI} [with_term \"Node ?l B ?k ?v ?r\"]\\<close>"], ["", "lemma bd_invI: \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> black_depth l = black_depth r \\<Longrightarrow> bd_inv (Node l c k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv l; bd_inv r; black_depth l = black_depth r\\<rbrakk>\n    \\<Longrightarrow> bd_inv (Node l c k v r)", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm bd_invI} [with_term \"Node ?l ?c ?k ?v ?r\"]\\<close>"], ["", "lemma is_rbt_rec [forward]: \"is_rbt (Node l c k v r) \\<Longrightarrow> is_rbt l \\<and> is_rbt r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt (Node l c k v r) \\<Longrightarrow> is_rbt l \\<and> is_rbt r", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt (Node l c k v r) \\<Longrightarrow> is_rbt l \\<and> is_rbt r", "@case \"c = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt (Node l c k v r) \\<Longrightarrow> is_rbt l \\<and> is_rbt r", "@qed"], ["", "subsection \\<open>Balancedness of RBT\\<close>"], ["", "(* TODO: remove after having general normalization procedure for nats. *)"], ["", "lemma two_distrib [rewrite]: \"(2::nat) * (a + 1) = 2 * a + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (a + 1) = 2 * a + 2", "by simp"], ["", "fun min_depth :: \"('a, 'b) rbt \\<Rightarrow> nat\" where\n  \"min_depth Leaf = 0\"\n| \"min_depth (Node l c k v r) = min (min_depth l) (min_depth r) + 1\""], ["", "setup \\<open>fold add_rewrite_rule @{thms min_depth.simps}\\<close>"], ["", "fun max_depth :: \"('a, 'b) rbt \\<Rightarrow> nat\" where\n  \"max_depth Leaf = 0\"\n| \"max_depth (Node l c k v r) = max (max_depth l) (max_depth r) + 1\""], ["", "setup \\<open>fold add_rewrite_rule @{thms max_depth.simps}\\<close>"], ["", "text \\<open>Balancedness of red-black trees.\\<close>"], ["", "theorem rbt_balanced: \"is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@induct t for \"is_rbt t \\<longrightarrow> black_depth t \\<le> min_depth t\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@subgoal \"t = Node l c k v r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@case \"c = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@induct t for \"is_rbt t \\<longrightarrow> (if cl t = R then max_depth t \\<le> 2 * black_depth t + 1\n                               else max_depth t \\<le> 2 * black_depth t)\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@subgoal \"t = Node l c k v r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@case \"c = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@have \"max_depth t \\<le> 2 * black_depth t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> max_depth t \\<le> 2 * min_depth t + 1", "@qed"], ["", "subsection \\<open>Definition and basic properties of cl\\_inv'\\<close>"], ["", "fun cl_inv' :: \"('a, 'b) rbt \\<Rightarrow> bool\" where\n  \"cl_inv' Leaf = True\"\n| \"cl_inv' (Node l c k v r) = (cl_inv l \\<and> cl_inv r)\""], ["", "setup \\<open>fold add_rewrite_rule @{thms cl_inv'.simps}\\<close>"], ["", "lemma cl_inv'B [forward, backward1]:\n  \"cl_inv' t \\<Longrightarrow> cl t = B \\<Longrightarrow> cl_inv t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv' t; cl t = B\\<rbrakk> \\<Longrightarrow> cl_inv t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv' t; cl t = B\\<rbrakk> \\<Longrightarrow> cl_inv t", "@case \"t = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv' t; cl t = B\\<rbrakk> \\<Longrightarrow> cl_inv t", "@qed"], ["", "lemma cl_inv'R [forward]:\n  \"cl_inv' (Node l R k v r) \\<Longrightarrow> cl l = B \\<Longrightarrow> cl r = B \\<Longrightarrow> cl_inv (Node l R k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv' (Node l R k v r); cl l = B; cl r = B\\<rbrakk>\n    \\<Longrightarrow> cl_inv (Node l R k v r)", "by auto2"], ["", "lemma cl_inv_to_cl_inv' [forward]: \"cl_inv t \\<Longrightarrow> cl_inv' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow> cl_inv' t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow> cl_inv' t", "@case \"t = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow> cl_inv' t", "@case \"cl t = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow> cl_inv' t", "@qed"], ["", "lemma cl_inv'I [forward_arg]:\n  \"cl_inv l \\<Longrightarrow> cl_inv r \\<Longrightarrow> cl_inv' (Node l c k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv l; cl_inv r\\<rbrakk>\n    \\<Longrightarrow> cl_inv' (Node l c k v r)", "by auto"], ["", "subsection \\<open>Set of keys, sortedness\\<close>"], ["", "fun rbt_in_traverse :: \"('a, 'b) rbt \\<Rightarrow> 'a list\" where\n  \"rbt_in_traverse Leaf = []\"\n| \"rbt_in_traverse (Node l c k v r) = rbt_in_traverse l @ k # rbt_in_traverse r\""], ["", "setup \\<open>fold add_rewrite_rule @{thms rbt_in_traverse.simps}\\<close>"], ["", "fun rbt_set :: \"('a, 'b) rbt \\<Rightarrow> 'a set\" where\n  \"rbt_set Leaf = {}\"\n| \"rbt_set (Node l c k v r) = {k} \\<union> rbt_set l \\<union> rbt_set r\""], ["", "setup \\<open>fold add_rewrite_rule @{thms rbt_set.simps}\\<close>"], ["", "fun rbt_in_traverse_pairs :: \"('a, 'b) rbt \\<Rightarrow> ('a \\<times> 'b) list\" where\n  \"rbt_in_traverse_pairs Leaf = []\"\n| \"rbt_in_traverse_pairs (Node l c k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r\""], ["", "setup \\<open>fold add_rewrite_rule @{thms rbt_in_traverse_pairs.simps}\\<close>"], ["", "lemma rbt_in_traverse_fst [rewrite]: \"map fst (rbt_in_traverse_pairs t) = rbt_in_traverse t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (rbt_in_traverse_pairs t) = rbt_in_traverse t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (rbt_in_traverse_pairs t) = rbt_in_traverse t", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (rbt_in_traverse_pairs t) = rbt_in_traverse t", "@qed"], ["", "definition rbt_map :: \"('a, 'b) rbt \\<Rightarrow> ('a, 'b) map\" where\n  \"rbt_map t = map_of_alist (rbt_in_traverse_pairs t)\""], ["", "setup \\<open>add_rewrite_rule @{thm rbt_map_def}\\<close>"], ["", "fun rbt_sorted :: \"('a::linorder, 'b) rbt \\<Rightarrow> bool\" where\n  \"rbt_sorted Leaf = True\"\n| \"rbt_sorted (Node l c k v r) = ((\\<forall>x\\<in>rbt_set l. x < k) \\<and> (\\<forall>x\\<in>rbt_set r. k < x) \\<and> rbt_sorted l \\<and> rbt_sorted r)\""], ["", "setup \\<open>fold add_rewrite_rule @{thms rbt_sorted.simps}\\<close>"], ["", "lemma rbt_sorted_lr [forward]:\n  \"rbt_sorted (Node l c k v r) \\<Longrightarrow> rbt_sorted l \\<and> rbt_sorted r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted (Node l c k v r) \\<Longrightarrow>\n    rbt_sorted l \\<and> rbt_sorted r", "by auto2"], ["", "lemma rbt_inorder_preserve_set [rewrite]:\n  \"rbt_set t = set (rbt_in_traverse t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_set t = set (rbt_in_traverse t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_set t = set (rbt_in_traverse t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_set t = set (rbt_in_traverse t)", "@qed"], ["", "lemma rbt_inorder_sorted [rewrite]:\n  \"rbt_sorted t \\<longleftrightarrow> strict_sorted (map fst (rbt_in_traverse_pairs t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t =\n    Lists_Ex.strict_sorted (map fst (rbt_in_traverse_pairs t))", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t =\n    Lists_Ex.strict_sorted (map fst (rbt_in_traverse_pairs t))", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t =\n    Lists_Ex.strict_sorted (map fst (rbt_in_traverse_pairs t))", "@qed"], ["", "setup \\<open>fold del_prfstep_thm (@{thms rbt_set.simps} @ @{thms rbt_sorted.simps})\\<close>"], ["", "subsection \\<open>Balance function\\<close>"], ["", "definition balanceR :: \"('a, 'b) rbt \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\" where [rewrite]:\n  \"balanceR l k v r =\n   (if cl r = R then\n      let lr = lsub r; rr = rsub r in\n      if cl lr = R then Node (Node l B k v (lsub lr)) R (key lr) (val lr) (Node (rsub lr) B (key r) (val r) rr)\n      else if cl rr = R then Node (Node l B k v lr) R (key r) (val r) (Node (lsub rr) B (key rr) (val rr) (rsub rr))\n      else Node l B k v r\n    else Node l B k v r)\""], ["", "definition balance :: \"('a, 'b) rbt \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\" where [rewrite]:\n  \"balance l k v r =\n   (if cl l = R then\n      let ll = lsub l; rl = rsub l in\n      if cl ll = R then Node (Node (lsub ll) B (key ll) (val ll) (rsub ll)) R (key l) (val l) (Node (rsub l) B k v r)\n      else if cl rl = R then Node (Node (lsub l) B (key l) (val l) (lsub rl)) R (key rl) (val rl) (Node (rsub rl) B k v r)\n      else balanceR l k v r\n    else balanceR l k v r)\""], ["", "setup \\<open>register_wellform_data (\"balance l k v r\", [\"black_depth l = black_depth r\"])\\<close>"], ["", "setup \\<open>add_prfstep_check_req (\"balance l k v r\", \"black_depth l = black_depth r\")\\<close>"], ["", "lemma balance_non_Leaf [resolve]: \"balance l k v r \\<noteq> Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. balance l k v r \\<noteq> Leaf", "by auto2"], ["", "lemma balance_bdinv [forward_arg]:\n  \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> black_depth l = black_depth r \\<Longrightarrow> bd_inv (balance l k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv l; bd_inv r; black_depth l = black_depth r\\<rbrakk>\n    \\<Longrightarrow> bd_inv (balance l k v r)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv l; bd_inv r; black_depth l = black_depth r\\<rbrakk>\n    \\<Longrightarrow> bd_inv (balance l k v r)", "@have \"bd_inv (balanceR l k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv l; bd_inv r; black_depth l = black_depth r\\<rbrakk>\n    \\<Longrightarrow> bd_inv (balance l k v r)", "@qed"], ["", "lemma balance_bd [rewrite]:\n  \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> black_depth l = black_depth r \\<Longrightarrow>\n   black_depth (balance l k v r) = black_depth l + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv l; bd_inv r; black_depth l = black_depth r\\<rbrakk>\n    \\<Longrightarrow> black_depth (balance l k v r) = black_depth l + 1", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv l; bd_inv r; black_depth l = black_depth r\\<rbrakk>\n    \\<Longrightarrow> black_depth (balance l k v r) = black_depth l + 1", "@have \"black_depth (balanceR l k v r) = black_depth l + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv l; bd_inv r; black_depth l = black_depth r\\<rbrakk>\n    \\<Longrightarrow> black_depth (balance l k v r) = black_depth l + 1", "@qed"], ["", "lemma balance_cl1 [forward]:\n  \"cl_inv' l \\<Longrightarrow> cl_inv r \\<Longrightarrow> cl_inv (balance l k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv' l; cl_inv r\\<rbrakk>\n    \\<Longrightarrow> cl_inv (balance l k v r)", "by auto2"], ["", "lemma balance_cl2 [forward]:\n  \"cl_inv l \\<Longrightarrow> cl_inv' r \\<Longrightarrow> cl_inv (balance l k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv l; cl_inv' r\\<rbrakk>\n    \\<Longrightarrow> cl_inv (balance l k v r)", "by auto2"], ["", "lemma balanceR_inorder_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (balanceR l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (balanceR l k v r) =\n    rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r", "by auto2"], ["", "lemma balance_inorder_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (balance l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (balance l k v r) =\n    rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r", "by auto2"], ["", "setup \\<open>fold del_prfstep_thm [@{thm balanceR_def}, @{thm balance_def}]\\<close>"], ["", "subsection \\<open>ins function\\<close>"], ["", "fun ins :: \"'a::order \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\" where\n  \"ins x v Leaf = Node Leaf R x v Leaf\"\n| \"ins x v (Node l c y w r) =\n   (if c = B then\n     (if x = y then Node l B x v r\n      else if x < y then balance (ins x v l) y w r\n      else balance l y w (ins x v r))\n    else\n     (if x = y then Node l R x v r\n      else if x < y then Node (ins x v l) R y w r\n      else Node l R y w (ins x v r)))\""], ["", "setup \\<open>fold add_rewrite_rule @{thms ins.simps}\\<close>"], ["", "lemma ins_non_Leaf [resolve]: \"ins x v t \\<noteq> Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ins x v t \\<noteq> Leaf", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. ins x v t \\<noteq> Leaf", "@case \"t = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ins x v t \\<noteq> Leaf", "@qed"], ["", "lemma cl_inv_ins [forward]:\n  \"cl_inv t \\<Longrightarrow> cl_inv' (ins x v t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow> cl_inv' (ins x v t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow> cl_inv' (ins x v t)", "@induct t for \"cl_inv t \\<longrightarrow> (if cl t = B then cl_inv (ins x v t) else cl_inv' (ins x v t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow> cl_inv' (ins x v t)", "@qed"], ["", "lemma bd_inv_ins:\n  \"bd_inv t \\<Longrightarrow> bd_inv (ins x v t) \\<and> black_depth t = black_depth (ins x v t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bd_inv t \\<Longrightarrow>\n    bd_inv (ins x v t) \\<and> black_depth t = black_depth (ins x v t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. bd_inv t \\<Longrightarrow>\n    bd_inv (ins x v t) \\<and> black_depth t = black_depth (ins x v t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. bd_inv t \\<Longrightarrow>\n    bd_inv (ins x v t) \\<and> black_depth t = black_depth (ins x v t)", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond (conj_left_th @{thm bd_inv_ins}) [with_term \"ins ?x ?v ?t\"]\\<close>"], ["", "lemma ins_inorder_pairs [rewrite]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_in_traverse_pairs (ins x v t) = ordered_insert_pairs x v (rbt_in_traverse_pairs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_in_traverse_pairs (ins x v t) =\n    ordered_insert_pairs x v (rbt_in_traverse_pairs t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_in_traverse_pairs (ins x v t) =\n    ordered_insert_pairs x v (rbt_in_traverse_pairs t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_in_traverse_pairs (ins x v t) =\n    ordered_insert_pairs x v (rbt_in_traverse_pairs t)", "@qed"], ["", "subsection \\<open>Paint function\\<close>"], ["", "fun paint :: \"color \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\" where\n  \"paint c Leaf = Leaf\"\n| \"paint c (Node l c' x v r) = Node l c x v r\""], ["", "setup \\<open>fold add_rewrite_rule @{thms paint.simps}\\<close>"], ["", "setup \\<open>register_wellform_data (\"paint c t\", [\"t \\<noteq> Leaf\"])\\<close>"], ["", "setup \\<open>add_prfstep_check_req (\"paint c t\", \"t \\<noteq> Leaf\")\\<close>"], ["", "lemma paint_cl_inv' [forward]: \"cl_inv' t \\<Longrightarrow> cl_inv' (paint c t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv' t \\<Longrightarrow> cl_inv' (paint c t)", "by auto2"], ["", "lemma paint_bd_inv [forward]: \"bd_inv t \\<Longrightarrow> bd_inv (paint c t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bd_inv t \\<Longrightarrow> bd_inv (paint c t)", "by auto2"], ["", "lemma paint_bd [rewrite]:\n  \"bd_inv t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> cl t = B \\<Longrightarrow> black_depth (paint R t) = black_depth t - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; t \\<noteq> Leaf; cl t = B\\<rbrakk>\n    \\<Longrightarrow> black_depth (paint R t) = black_depth t - 1", "by auto2"], ["", "lemma paint_in_traverse_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (paint c t) = rbt_in_traverse_pairs t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (paint c t) = rbt_in_traverse_pairs t", "by auto2"], ["", "subsection \\<open>Insert function\\<close>"], ["", "definition rbt_insert :: \"'a::order \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\" where [rewrite]:\n  \"rbt_insert x v t = paint B (ins x v t)\""], ["", "text \\<open>Correctness results for insertion.\\<close>"], ["", "theorem insert_is_rbt [forward]:\n  \"is_rbt t \\<Longrightarrow> is_rbt (rbt_insert x v t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> is_rbt (rbt_insert x v t)", "by auto2"], ["", "theorem insert_sorted [forward]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_sorted (rbt_insert x v t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow> rbt_sorted (rbt_insert x v t)", "by auto2"], ["", "theorem insert_rbt_map [rewrite]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_map (rbt_insert x v t) = (rbt_map t) {x \\<rightarrow> v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_map (rbt_insert x v t) =  rbt_map t { x \\<rightarrow> v }", "by auto2"], ["", "subsection \\<open>Search on sorted trees and its correctness\\<close>"], ["", "fun rbt_search :: \"('a::ord, 'b) rbt \\<Rightarrow> 'a \\<Rightarrow> 'b option\" where\n  \"rbt_search Leaf x = None\"\n| \"rbt_search (Node l c y w r) x =\n  (if x = y then Some w\n   else if x < y then rbt_search l x\n   else rbt_search r x)\""], ["", "setup \\<open>fold add_rewrite_rule @{thms rbt_search.simps}\\<close>"], ["", "text \\<open>Correctness of search\\<close>"], ["", "theorem rbt_search_correct [rewrite]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_search t x = (rbt_map t)\\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_search t x = rbt_map t\\<langle>x\\<rangle>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_search t x = rbt_map t\\<langle>x\\<rangle>", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_search t x = rbt_map t\\<langle>x\\<rangle>", "@qed"], ["", "subsection \\<open>balL and balR\\<close>"], ["", "definition balL :: \"('a, 'b) rbt \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\" where [rewrite]:\n  \"balL l k v r = (let lr = lsub r in\n   if cl l = R then Node (Node (lsub l) B (key l) (val l) (rsub l)) R k v r\n   else if r = Leaf then Node l R k v r\n   else if cl r = B then balance l k v (Node (lsub r) R (key r) (val r) (rsub r))\n   else if lr = Leaf then Node l R k v r\n   else if cl lr = B then\n     Node (Node l B k v (lsub lr)) R (key lr) (val lr) (balance (rsub lr) (key r) (val r) (paint R (rsub r)))\n   else Node l R k v r)\""], ["", "setup \\<open>register_wellform_data (\"balL l k v r\", [\"black_depth l + 1 = black_depth r\"])\\<close>"], ["", "setup \\<open>add_prfstep_check_req (\"balL l k v r\", \"black_depth l + 1 = black_depth r\")\\<close>"], ["", "definition balR :: \"('a, 'b) rbt \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\" where [rewrite]:\n  \"balR l k v r = (let rl = rsub l in\n   if cl r = R then Node l R k v (Node (lsub r) B (key r) (val r) (rsub r))\n   else if l = Leaf then Node l R k v r\n   else if cl l = B then balance (Node (lsub l) R (key l) (val l) (rsub l)) k v r\n   else if rl = Leaf then Node l R k v r\n   else if cl rl = B then\n     Node (balance (paint R (lsub l)) (key l) (val l) (lsub rl)) R (key rl) (val rl) (Node (rsub rl) B k v r)\n   else Node l R k v r)\""], ["", "setup \\<open>register_wellform_data (\"balR l k v r\", [\"black_depth l = black_depth r + 1\"])\\<close>"], ["", "setup \\<open>add_prfstep_check_req (\"balR l k v r\", \"black_depth l = black_depth r + 1\")\\<close>"], ["", "lemma balL_bd [forward_arg]:\n  \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> cl r = B \\<Longrightarrow> black_depth l + 1 = black_depth r \\<Longrightarrow>\n   bd_inv (balL l k v r) \\<and> black_depth (balL l k v r) = black_depth l + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv l; bd_inv r; cl r = B;\n     black_depth l + 1 = black_depth r\\<rbrakk>\n    \\<Longrightarrow> bd_inv (balL l k v r) \\<and>\n                      black_depth (balL l k v r) = black_depth l + 1", "by auto2"], ["", "lemma balL_bd' [forward_arg]:\n  \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> cl_inv r \\<Longrightarrow> black_depth l + 1 = black_depth r \\<Longrightarrow>\n   bd_inv (balL l k v r) \\<and> black_depth (balL l k v r) = black_depth l + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv l; bd_inv r; cl_inv r;\n     black_depth l + 1 = black_depth r\\<rbrakk>\n    \\<Longrightarrow> bd_inv (balL l k v r) \\<and>\n                      black_depth (balL l k v r) = black_depth l + 1", "by auto2"], ["", "lemma balL_cl [forward_arg]:\n  \"cl_inv' l \\<Longrightarrow> cl_inv r \\<Longrightarrow> cl r = B \\<Longrightarrow> cl_inv (balL l k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv' l; cl_inv r; cl r = B\\<rbrakk>\n    \\<Longrightarrow> cl_inv (balL l k v r)", "by auto2"], ["", "lemma balL_cl' [forward]:\n  \"cl_inv' l \\<Longrightarrow> cl_inv r \\<Longrightarrow> cl_inv' (balL l k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv' l; cl_inv r\\<rbrakk>\n    \\<Longrightarrow> cl_inv' (balL l k v r)", "by auto2"], ["", "lemma balR_bd [forward_arg]:\n  \"bd_inv l \\<Longrightarrow> bd_inv r \\<Longrightarrow> cl_inv l \\<Longrightarrow> black_depth l = black_depth r + 1 \\<Longrightarrow>\n   bd_inv (balR l k v r) \\<and> black_depth (balR l k v r) = black_depth l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv l; bd_inv r; cl_inv l;\n     black_depth l = black_depth r + 1\\<rbrakk>\n    \\<Longrightarrow> bd_inv (balR l k v r) \\<and>\n                      black_depth (balR l k v r) = black_depth l", "by auto2"], ["", "lemma balR_cl [forward_arg]:\n  \"cl_inv l \\<Longrightarrow> cl_inv' r \\<Longrightarrow> cl l = B \\<Longrightarrow> cl_inv (balR l k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv l; cl_inv' r; cl l = B\\<rbrakk>\n    \\<Longrightarrow> cl_inv (balR l k v r)", "by auto2"], ["", "lemma balR_cl' [forward]:\n  \"cl_inv l \\<Longrightarrow> cl_inv' r \\<Longrightarrow> cl_inv' (balR l k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv l; cl_inv' r\\<rbrakk>\n    \\<Longrightarrow> cl_inv' (balR l k v r)", "by auto2"], ["", "lemma balL_in_traverse_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (balL l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (balL l k v r) =\n    rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r", "by auto2"], ["", "lemma balR_in_traverse_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (balR l k v r) = rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (balR l k v r) =\n    rbt_in_traverse_pairs l @ (k, v) # rbt_in_traverse_pairs r", "by auto2"], ["", "setup \\<open>fold del_prfstep_thm [@{thm balL_def}, @{thm balR_def}]\\<close>"], ["", "subsection \\<open>Combine\\<close>"], ["", "fun combine :: \"('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\" where\n  \"combine Leaf t = t\"\n| \"combine t Leaf = t\"\n| \"combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2) = (\n   if c1 = R then\n     if c2 = R then\n       let tm = combine r1 l2 in\n         if cl tm = R then\n           Node (Node l1 R k1 v1 (lsub tm)) R (key tm) (val tm) (Node (rsub tm) R k2 v2 r2)\n         else\n           Node l1 R k1 v1 (Node tm R k2 v2 r2)\n     else\n       Node l1 R k1 v1 (combine r1 (Node l2 c2 k2 v2 r2))\n   else\n     if c2 = B then\n       let tm = combine r1 l2 in\n         if cl tm = R then\n           Node (Node l1 B k1 v1 (lsub tm)) R (key tm) (val tm) (Node (rsub tm) B k2 v2 r2)\n         else\n           balL l1 k1 v1 (Node tm B k2 v2 r2)\n     else\n       Node (combine (Node l1 c1 k1 v1 r1) l2) R k2 v2 r2)\""], ["", "setup \\<open>fold add_rewrite_rule @{thms combine.simps(1,2)}\\<close>"], ["", "lemma combine_bd [forward_arg]:\n  \"bd_inv lt \\<Longrightarrow> bd_inv rt \\<Longrightarrow> black_depth lt = black_depth rt \\<Longrightarrow>\n   bd_inv (combine lt rt) \\<and> black_depth (combine lt rt) = black_depth lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@fun_induct \"combine lt rt\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@subgoal \"(lt = Node l1 c1 k1 v1 r1, rt = Node l2 c2 k2 v2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@unfold \"combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@case \"c1 = B\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@case \"c2 = B\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@case \"cl (combine r1 l2) = B\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@have \"cl (Node (combine r1 l2) B k2 v2 r2) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv lt; bd_inv rt; black_depth lt = black_depth rt\\<rbrakk>\n    \\<Longrightarrow> bd_inv (combine lt rt) \\<and>\n                      black_depth (combine lt rt) = black_depth lt", "@qed"], ["", "lemma combine_cl:\n  \"cl_inv lt \\<Longrightarrow> cl_inv rt \\<Longrightarrow>\n   (cl lt = B \\<longrightarrow> cl rt = B \\<longrightarrow> cl_inv (combine lt rt)) \\<and> cl_inv' (combine lt rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@fun_induct \"combine lt rt\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@subgoal \"(lt = Node l1 c1 k1 v1 r1, rt = Node l2 c2 k2 v2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@unfold \"combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@case \"c1 = B\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@case \"c2 = B\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@case \"cl (combine r1 l2) = B\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@have \"cl (Node (combine r1 l2) B k2 v2 r2) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl_inv lt; cl_inv rt\\<rbrakk>\n    \\<Longrightarrow> (cl lt = B \\<longrightarrow>\n                       cl rt = B \\<longrightarrow>\n                       cl_inv (combine lt rt)) \\<and>\n                      cl_inv' (combine lt rt)", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm combine_cl} [with_term \"combine ?lt ?rt\"]\\<close>"], ["", "lemma combine_in_traverse_pairs [rewrite]:\n  \"rbt_in_traverse_pairs (combine lt rt) = rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@fun_induct \"combine lt rt\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@subgoal \"(lt = Node l1 c1 k1 v1 r1, rt = Node l2 c2 k2 v2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@unfold \"combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@case \"c1 = R\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@case \"c2 = R\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@case \"cl (combine r1 l2) = R\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@have \"rbt_in_traverse_pairs (combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2)) =\n             rbt_in_traverse_pairs l1 @ (k1, v1) # rbt_in_traverse_pairs (combine r1 l2) @ (k2, v2) # rbt_in_traverse_pairs r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@case \"c1 = B\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@case \"c2 = B\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@case \"cl (combine r1 l2) = R\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@have \"rbt_in_traverse_pairs (combine (Node l1 c1 k1 v1 r1) (Node l2 c2 k2 v2 r2)) =\n             rbt_in_traverse_pairs l1 @ (k1, v1) # rbt_in_traverse_pairs (combine r1 l2) @ (k2, v2) # rbt_in_traverse_pairs r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_in_traverse_pairs (combine lt rt) =\n    rbt_in_traverse_pairs lt @ rbt_in_traverse_pairs rt", "@qed"], ["", "subsection \\<open>Deletion\\<close>"], ["", "fun del :: \"'a::linorder \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\" where\n  \"del x Leaf = Leaf\"\n| \"del x (Node l _ k v r) =\n    (if x = k then combine l r\n     else if x < k then\n       if l = Leaf then Node Leaf R k v r\n       else if cl l = B then balL (del x l) k v r\n       else Node (del x l) R k v r\n     else\n       if r = Leaf then Node l R k v Leaf\n       else if cl r = B then balR l k v (del x r)\n       else Node l R k v (del x r))\""], ["", "setup \\<open>add_rewrite_rule @{thm del.simps(1)}\\<close>"], ["", "lemma del_bd [forward_arg]:\n  \"bd_inv t \\<Longrightarrow> cl_inv t \\<Longrightarrow> bd_inv (del x t) \\<and> (\n    if cl t = R then black_depth (del x t) = black_depth t\n    else black_depth (del x t) = black_depth t - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@induct t @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@subgoal \"t = Node l c k v r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@unfold \"del x (Node l c k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@case \"x = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@case \"x < k\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@case \"l = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@case \"cl l = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@case \"x > k\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@case \"r = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@case \"cl r = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bd_inv t; cl_inv t\\<rbrakk>\n    \\<Longrightarrow> bd_inv (del x t) \\<and>\n                      (if cl t = R\n                       then black_depth (del x t) = black_depth t\n                       else black_depth (del x t) = black_depth t - 1)", "@qed"], ["", "lemma del_cl:\n  \"cl_inv t \\<Longrightarrow> if cl t = R then cl_inv (del x t) else cl_inv' (del x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow>\n    if cl t = R then cl_inv (del x t) else cl_inv' (del x t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow>\n    if cl t = R then cl_inv (del x t) else cl_inv' (del x t)", "@induct t @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow>\n    if cl t = R then cl_inv (del x t) else cl_inv' (del x t)", "@subgoal \"t = Node l c k v r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow>\n    if cl t = R then cl_inv (del x t) else cl_inv' (del x t)", "@unfold \"del x (Node l c k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow>\n    if cl t = R then cl_inv (del x t) else cl_inv' (del x t)", "@case \"x = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow>\n    if cl t = R then cl_inv (del x t) else cl_inv' (del x t)", "@case \"x < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow>\n    if cl t = R then cl_inv (del x t) else cl_inv' (del x t)", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow>\n    if cl t = R then cl_inv (del x t) else cl_inv' (del x t)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv t \\<Longrightarrow>\n    if cl t = R then cl_inv (del x t) else cl_inv' (del x t)", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm del_cl} [with_term \"del ?x ?t\"]\\<close>"], ["", "lemma del_in_traverse_pairs [rewrite]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_in_traverse_pairs (del x t) = remove_elt_pairs x (rbt_in_traverse_pairs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_in_traverse_pairs (del x t) =\n    remove_elt_pairs x (rbt_in_traverse_pairs t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_in_traverse_pairs (del x t) =\n    remove_elt_pairs x (rbt_in_traverse_pairs t)", "@induct t @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_in_traverse_pairs (del x t) =\n    remove_elt_pairs x (rbt_in_traverse_pairs t)", "@subgoal \"t = Node l c k v r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_in_traverse_pairs (del x t) =\n    remove_elt_pairs x (rbt_in_traverse_pairs t)", "@unfold \"del x (Node l c k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_in_traverse_pairs (del x t) =\n    remove_elt_pairs x (rbt_in_traverse_pairs t)", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_in_traverse_pairs (del x t) =\n    remove_elt_pairs x (rbt_in_traverse_pairs t)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_in_traverse_pairs (del x t) =\n    remove_elt_pairs x (rbt_in_traverse_pairs t)", "@qed"], ["", "definition delete :: \"'a::linorder \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\" where [rewrite]:\n  \"delete x t = paint B (del x t)\""], ["", "text \\<open>Correctness results for deletion.\\<close>"], ["", "theorem delete_is_rbt [forward]:\n  \"is_rbt t \\<Longrightarrow> is_rbt (delete x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> is_rbt (delete x t)", "by auto2"], ["", "theorem delete_sorted [forward]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_sorted (delete x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow> rbt_sorted (delete x t)", "by auto2"], ["", "theorem delete_rbt_map [rewrite]:\n  \"rbt_sorted t \\<Longrightarrow> rbt_map (delete x t) = delete_map x (rbt_map t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_map (delete x t) = delete_map x (rbt_map t)", "by auto2"], ["", "setup \\<open>del_prfstep \"RBTree.balance_case\"\\<close>"], ["", "setup \\<open>del_prfstep \"RBTree.balL_case\"\\<close>"], ["", "setup \\<open>del_prfstep \"RBTree.balR_case\"\\<close>"], ["", "setup \\<open>del_prfstep \"RBTree.paint_case\"\\<close>"], ["", "end"]]}