{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Imperative/Union_Find_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["theorem uf_init_rule [hoare_triple]:\n  \"<emp> uf_init n <is_uf n (uf_init_rel n)>\"", "lemma uf_rep_of_rule [hoare_triple]:\n  \"ufa_invar l \\<Longrightarrow> i < length l \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a l>\n   uf_rep_of p i\n   <\\<lambda>r. p \\<mapsto>\\<^sub>a l * \\<up>(r = rep_of l i)>\"", "lemma uf_compress_rule [hoare_triple]:\n  \"ufa_invar l \\<Longrightarrow> i < length l \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a l>\n    uf_compress i (rep_of l i) p\n   <\\<lambda>_. \\<exists>\\<^sub>Al'. p \\<mapsto>\\<^sub>a l' * \\<up>(ufa_invar l' \\<and> length l' = length l \\<and>\n              (\\<forall>i<length l. rep_of l' i = rep_of l i))>\"", "lemma uf_rep_of_c_rule [hoare_triple]:\n  \"ufa_invar l \\<Longrightarrow> i < length l \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a l>\n   uf_rep_of_c p i\n   <\\<lambda>r. \\<exists>\\<^sub>Al'. p \\<mapsto>\\<^sub>a l' * \\<up>(r = rep_of l i \\<and> ufa_invar l' \\<and> length l' = length l \\<and>\n                          (\\<forall>i<length l. rep_of l' i = rep_of l i))>\"", "theorem uf_cmp_rule [hoare_triple]:\n  \"<is_uf n R u>\n   uf_cmp u i j\n   <\\<lambda>r. is_uf n R u * \\<up>(r \\<longleftrightarrow> (i,j)\\<in>R)>\"", "theorem uf_union_rule [hoare_triple]:\n  \"i < n \\<Longrightarrow> j < n \\<Longrightarrow>\n   <is_uf n R u>\n   uf_union u i j\n   <is_uf n (per_union R i j)>\""], "translations": [["", "theorem uf_init_rule [hoare_triple]:\n  \"<emp> uf_init n <is_uf n (uf_init_rel n)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> uf_init n <is_uf n (uf_init_rel n)>", "by auto2"], ["", "partial_function (heap) uf_rep_of :: \"nat array \\<Rightarrow> nat \\<Rightarrow> nat Heap\" where\n  \"uf_rep_of p i = do {\n     n \\<leftarrow> Array.nth p i;\n     if n = i then return i else uf_rep_of p n\n   }\""], ["", "lemma uf_rep_of_rule [hoare_triple]:\n  \"ufa_invar l \\<Longrightarrow> i < length l \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a l>\n   uf_rep_of p i\n   <\\<lambda>r. p \\<mapsto>\\<^sub>a l * \\<up>(r = rep_of l i)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ufa_invar l; i < length l\\<rbrakk>\n    \\<Longrightarrow> <p \\<mapsto>\\<^sub>a l> uf_rep_of p i\n                      <\\<lambda>r.\n                          p \\<mapsto>\\<^sub>a l * \\<up> (r = rep_of l i)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ufa_invar l; i < length l\\<rbrakk>\n    \\<Longrightarrow> <p \\<mapsto>\\<^sub>a l> uf_rep_of p i\n                      <\\<lambda>r.\n                          p \\<mapsto>\\<^sub>a l * \\<up> (r = rep_of l i)>", "@prop_induct \"ufa_invar l \\<and> i < length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ufa_invar l; i < length l\\<rbrakk>\n    \\<Longrightarrow> <p \\<mapsto>\\<^sub>a l> uf_rep_of p i\n                      <\\<lambda>r.\n                          p \\<mapsto>\\<^sub>a l * \\<up> (r = rep_of l i)>", "@qed"], ["", "partial_function (heap) uf_compress :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat array \\<Rightarrow> unit Heap\" where\n  \"uf_compress i ci p = (\n    if i = ci then return ()\n    else do {\n      ni \\<leftarrow> Array.nth p i;\n      uf_compress ni ci p;\n      Array.upd i ci p;\n      return ()\n    })\""], ["", "lemma uf_compress_rule [hoare_triple]:\n  \"ufa_invar l \\<Longrightarrow> i < length l \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a l>\n    uf_compress i (rep_of l i) p\n   <\\<lambda>_. \\<exists>\\<^sub>Al'. p \\<mapsto>\\<^sub>a l' * \\<up>(ufa_invar l' \\<and> length l' = length l \\<and>\n              (\\<forall>i<length l. rep_of l' i = rep_of l i))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ufa_invar l; i < length l\\<rbrakk>\n    \\<Longrightarrow> <p \\<mapsto>\\<^sub>a l> uf_compress i (rep_of l i) p\n                      <\\<lambda>_.\n                          \\<exists>\\<^sub>Al'.\n                             p \\<mapsto>\\<^sub>a l' *\n                             \\<up>\n                              (ufa_invar l' \\<and>\n                               length l' = length l \\<and>\n                               (\\<forall>i<length l.\n                                   rep_of l' i = rep_of l i))>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ufa_invar l; i < length l\\<rbrakk>\n    \\<Longrightarrow> <p \\<mapsto>\\<^sub>a l> uf_compress i (rep_of l i) p\n                      <\\<lambda>_.\n                          \\<exists>\\<^sub>Al'.\n                             p \\<mapsto>\\<^sub>a l' *\n                             \\<up>\n                              (ufa_invar l' \\<and>\n                               length l' = length l \\<and>\n                               (\\<forall>i<length l.\n                                   rep_of l' i = rep_of l i))>", "@prop_induct \"ufa_invar l \\<and> i < length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ufa_invar l; i < length l\\<rbrakk>\n    \\<Longrightarrow> <p \\<mapsto>\\<^sub>a l> uf_compress i (rep_of l i) p\n                      <\\<lambda>_.\n                          \\<exists>\\<^sub>Al'.\n                             p \\<mapsto>\\<^sub>a l' *\n                             \\<up>\n                              (ufa_invar l' \\<and>\n                               length l' = length l \\<and>\n                               (\\<forall>i<length l.\n                                   rep_of l' i = rep_of l i))>", "@qed"], ["", "definition uf_rep_of_c :: \"nat array \\<Rightarrow> nat \\<Rightarrow> nat Heap\" where\n  \"uf_rep_of_c p i = do {\n    ci \\<leftarrow> uf_rep_of p i;\n    uf_compress i ci p;\n    return ci\n  }\""], ["", "lemma uf_rep_of_c_rule [hoare_triple]:\n  \"ufa_invar l \\<Longrightarrow> i < length l \\<Longrightarrow>\n   <p \\<mapsto>\\<^sub>a l>\n   uf_rep_of_c p i\n   <\\<lambda>r. \\<exists>\\<^sub>Al'. p \\<mapsto>\\<^sub>a l' * \\<up>(r = rep_of l i \\<and> ufa_invar l' \\<and> length l' = length l \\<and>\n                          (\\<forall>i<length l. rep_of l' i = rep_of l i))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ufa_invar l; i < length l\\<rbrakk>\n    \\<Longrightarrow> <p \\<mapsto>\\<^sub>a l> uf_rep_of_c p i\n                      <\\<lambda>r.\n                          \\<exists>\\<^sub>Al'.\n                             p \\<mapsto>\\<^sub>a l' *\n                             \\<up>\n                              (r = rep_of l i \\<and>\n                               ufa_invar l' \\<and>\n                               length l' = length l \\<and>\n                               (\\<forall>i<length l.\n                                   rep_of l' i = rep_of l i))>", "by auto2"], ["", "definition uf_cmp :: \"uf \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool Heap\" where\n  \"uf_cmp u i j = do {\n    n \\<leftarrow> Array.len (snd u);\n    if (i\\<ge>n \\<or> j\\<ge>n) then return False\n    else do {\n      ci \\<leftarrow> uf_rep_of_c (snd u) i;\n      cj \\<leftarrow> uf_rep_of_c (snd u) j;\n      return (ci = cj)\n    }\n  }\""], ["", "text \\<open>Correctness of compare.\\<close>"], ["", "theorem uf_cmp_rule [hoare_triple]:\n  \"<is_uf n R u>\n   uf_cmp u i j\n   <\\<lambda>r. is_uf n R u * \\<up>(r \\<longleftrightarrow> (i,j)\\<in>R)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_uf n R u> uf_cmp u i j\n    <\\<lambda>r. is_uf n R u * \\<up> (r = ((i, j) \\<in> R))>", "by auto2"], ["", "definition uf_union :: \"uf \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> uf Heap\" where\n  \"uf_union u i j = do {\n    ci \\<leftarrow> uf_rep_of (snd u) i;\n    cj \\<leftarrow> uf_rep_of (snd u) j;\n    if (ci = cj) then return u\n    else do {\n      si \\<leftarrow> Array.nth (fst u) ci;\n      sj \\<leftarrow> Array.nth (fst u) cj;\n      if si < sj then do {\n        Array.upd ci cj (snd u);\n        Array.upd cj (si+sj) (fst u);\n        return u\n      } else do { \n        Array.upd cj ci (snd u);\n        Array.upd ci (si+sj) (fst u);\n        return u\n      }\n    }\n  }\""], ["", "text \\<open>Correctness of union.\\<close>"], ["", "theorem uf_union_rule [hoare_triple]:\n  \"i < n \\<Longrightarrow> j < n \\<Longrightarrow>\n   <is_uf n R u>\n   uf_union u i j\n   <is_uf n (per_union R i j)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n; j < n\\<rbrakk>\n    \\<Longrightarrow> <is_uf n R u> uf_union u i j\n                      <is_uf n (per_union R i j)>", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm is_uf_def}\\<close>"], ["", "end"]]}