{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Imperative/IntervalTree_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma int_tree_Tip [forward_ent]: \"int_tree Tip p \\<Longrightarrow>\\<^sub>A \\<up>(p = None)\"", "lemma int_tree_Node [forward_ent]:\n  \"int_tree (interval_tree.Node lt v m rt) p \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Alp rp. the p \\<mapsto>\\<^sub>r Node lp v m rp * int_tree lt lp * int_tree rt rp * \\<up>(p \\<noteq> None))\"", "lemma int_tree_none: \"emp \\<Longrightarrow>\\<^sub>A int_tree interval_tree.Tip None\"", "lemma int_tree_constr_ent:\n  \"p \\<mapsto>\\<^sub>r Node lp v m rp * int_tree lt lp * int_tree rt rp \\<Longrightarrow>\\<^sub>A int_tree (interval_tree.Node lt v m rt) (Some p)\"", "lemma int_tree_empty_to_fun [hoare_triple]:\n  \"<emp> int_tree_empty <int_tree Tip>\"", "lemma int_tree_is_empty_rule [hoare_triple]:\n  \"<int_tree t b>\n   int_tree_is_empty b\n   <\\<lambda>r. int_tree t b * \\<up>(r \\<longleftrightarrow> t = Tip)>\"", "lemma get_tmax_rule [hoare_triple]:\n  \"<int_tree t b> get_tmax b <\\<lambda>r. int_tree t b * \\<up>(r = interval_tree.tmax t)>\"", "lemma compute_tmax_rule [hoare_triple]:\n  \"<int_tree t1 b1 * int_tree t2 b2>\n   compute_tmax it b1 b2\n   <\\<lambda>r. int_tree t1 b1 * int_tree t2 b2 * \\<up>(r = max3 it (interval_tree.tmax t1) (interval_tree.tmax t2))>\"", "lemma int_tree_constr_rule [hoare_triple]:\n  \"<int_tree lt lp * int_tree rt rp>\n   int_tree_constr lp v rp\n   <int_tree (interval_tree.Node lt v (max3 v (interval_tree.tmax lt) (interval_tree.tmax rt)) rt)>\"", "lemma int_tree_insert_to_fun [hoare_triple]:\n  \"<int_tree t b>\n    insert_impl v b\n   <int_tree (insert v t)>\"", "lemma int_tree_del_min_to_fun [hoare_triple]:\n  \"<int_tree t b * \\<up>(b \\<noteq> None)>\n   int_tree_del_min b\n   <\\<lambda>r. int_tree (snd (del_min t)) (snd r) * \\<up>(fst(r) = fst (del_min t))>\\<^sub>t\"", "lemma int_tree_del_elt_to_fun [hoare_triple]:\n  \"<int_tree (interval_tree.Node lt v m rt) b>\n   int_tree_del_elt b\n   <int_tree (delete_elt_tree (interval_tree.Node lt v m rt))>\\<^sub>t\"", "lemma int_tree_delete_to_fun [hoare_triple]:\n  \"<int_tree t b>\n    delete_impl x b\n   <int_tree (delete x t)>\\<^sub>t\"", "lemma search_impl_correct [hoare_triple]:\n  \"<int_tree t b>\n    search_impl x b\n   <\\<lambda>r. int_tree t b * \\<up>(r \\<longleftrightarrow> search t x)>\"", "theorem int_tree_empty_rule [hoare_triple]:\n  \"<emp> int_tree_empty <int_tree_set {}>\"", "theorem int_tree_insert_rule [hoare_triple]:\n  \"<int_tree_set S b * \\<up>(is_interval (int x))>\n   insert_impl x b\n   <int_tree_set (S \\<union> {x})>\"", "theorem int_tree_delete_rule [hoare_triple]:\n  \"<int_tree_set S b * \\<up>(is_interval (int x))>\n   delete_impl x b\n   <int_tree_set (S - {x})>\\<^sub>t\"", "theorem int_tree_search_rule [hoare_triple]:\n  \"<int_tree_set S b * \\<up>(is_interval x)>\n   search_impl x b\n   <\\<lambda>r. int_tree_set S b * \\<up>(r \\<longleftrightarrow> has_overlap S x)>\""], "translations": [["", "lemma int_tree_Tip [forward_ent]: \"int_tree Tip p \\<Longrightarrow>\\<^sub>A \\<up>(p = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_tree Tip p \\<Longrightarrow>\\<^sub>A \\<up> (p = None)", "by auto2"], ["", "lemma int_tree_Node [forward_ent]:\n  \"int_tree (interval_tree.Node lt v m rt) p \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Alp rp. the p \\<mapsto>\\<^sub>r Node lp v m rp * int_tree lt lp * int_tree rt rp * \\<up>(p \\<noteq> None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_tree (interval_tree.Node lt v m rt) p \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Alp rp.\n       the p \\<mapsto>\\<^sub>r node.Node lp v m rp * int_tree lt lp *\n       int_tree rt rp *\n       \\<up> (p \\<noteq> None)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_tree (interval_tree.Node lt v m rt) p \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Alp rp.\n       the p \\<mapsto>\\<^sub>r node.Node lp v m rp * int_tree lt lp *\n       int_tree rt rp *\n       \\<up> (p \\<noteq> None)", "@case \"p = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_tree (interval_tree.Node lt v m rt) p \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Alp rp.\n       the p \\<mapsto>\\<^sub>r node.Node lp v m rp * int_tree lt lp *\n       int_tree rt rp *\n       \\<up> (p \\<noteq> None)", "@qed"], ["", "lemma int_tree_none: \"emp \\<Longrightarrow>\\<^sub>A int_tree interval_tree.Tip None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emp \\<Longrightarrow>\\<^sub>A int_tree Tip None", "by auto2"], ["", "lemma int_tree_constr_ent:\n  \"p \\<mapsto>\\<^sub>r Node lp v m rp * int_tree lt lp * int_tree rt rp \\<Longrightarrow>\\<^sub>A int_tree (interval_tree.Node lt v m rt) (Some p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<mapsto>\\<^sub>r node.Node lp v m rp * int_tree lt lp *\n    int_tree rt rp \\<Longrightarrow>\\<^sub>A\n    int_tree (interval_tree.Node lt v m rt) (Some p)", "by auto2"], ["", "setup \\<open>fold add_entail_matcher [@{thm int_tree_none}, @{thm int_tree_constr_ent}]\\<close>"], ["", "setup \\<open>fold del_prfstep_thm @{thms int_tree.simps}\\<close>"], ["", "type_synonym int_tree = \"nat node ref option\""], ["", "subsection \\<open>Operations\\<close>"], ["", "subsubsection \\<open>Basic operation\\<close>"], ["", "definition int_tree_empty :: \"int_tree Heap\" where\n  \"int_tree_empty = return None\""], ["", "lemma int_tree_empty_to_fun [hoare_triple]:\n  \"<emp> int_tree_empty <int_tree Tip>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> int_tree_empty <int_tree Tip>", "by auto2"], ["", "definition int_tree_is_empty :: \"int_tree \\<Rightarrow> bool Heap\" where\n  \"int_tree_is_empty b = return (b = None)\""], ["", "lemma int_tree_is_empty_rule [hoare_triple]:\n  \"<int_tree t b>\n   int_tree_is_empty b\n   <\\<lambda>r. int_tree t b * \\<up>(r \\<longleftrightarrow> t = Tip)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> int_tree_is_empty b\n    <\\<lambda>r. int_tree t b * \\<up> (r = (t = Tip))>", "by auto2"], ["", "definition get_tmax :: \"int_tree \\<Rightarrow> nat Heap\" where\n  \"get_tmax b = (case b of\n     None \\<Rightarrow> return 0\n   | Some p \\<Rightarrow> do {\n      t \\<leftarrow> !p;\n      return (tmax t) })\""], ["", "lemma get_tmax_rule [hoare_triple]:\n  \"<int_tree t b> get_tmax b <\\<lambda>r. int_tree t b * \\<up>(r = interval_tree.tmax t)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> get_tmax b\n    <\\<lambda>r. int_tree t b * \\<up> (r = interval_tree.tmax t)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> get_tmax b\n    <\\<lambda>r. int_tree t b * \\<up> (r = interval_tree.tmax t)>", "@case \"t = Tip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> get_tmax b\n    <\\<lambda>r. int_tree t b * \\<up> (r = interval_tree.tmax t)>", "@qed"], ["", "definition compute_tmax :: \"nat idx_interval \\<Rightarrow> int_tree \\<Rightarrow> int_tree \\<Rightarrow> nat Heap\" where\n  \"compute_tmax it l r = do {\n    lm \\<leftarrow> get_tmax l;\n    rm \\<leftarrow> get_tmax r;\n    return (max3 it lm rm)\n  }\""], ["", "lemma compute_tmax_rule [hoare_triple]:\n  \"<int_tree t1 b1 * int_tree t2 b2>\n   compute_tmax it b1 b2\n   <\\<lambda>r. int_tree t1 b1 * int_tree t2 b2 * \\<up>(r = max3 it (interval_tree.tmax t1) (interval_tree.tmax t2))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t1 b1 * int_tree t2 b2> compute_tmax it b1 b2\n    <\\<lambda>r.\n        int_tree t1 b1 * int_tree t2 b2 *\n        \\<up> (r = max3 it (interval_tree.tmax t1) (interval_tree.tmax t2))>", "by auto2"], ["", "definition int_tree_constr :: \"int_tree \\<Rightarrow> nat idx_interval \\<Rightarrow> int_tree \\<Rightarrow> int_tree Heap\" where\n  \"int_tree_constr lp v rp = do {\n    m \\<leftarrow> compute_tmax v lp rp;\n    p \\<leftarrow> ref (Node lp v m rp);\n    return (Some p) }\""], ["", "lemma int_tree_constr_rule [hoare_triple]:\n  \"<int_tree lt lp * int_tree rt rp>\n   int_tree_constr lp v rp\n   <int_tree (interval_tree.Node lt v (max3 v (interval_tree.tmax lt) (interval_tree.tmax rt)) rt)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree lt lp * int_tree rt rp> int_tree_constr lp v rp\n    <int_tree\n      (interval_tree.Node lt v\n        (max3 v (interval_tree.tmax lt) (interval_tree.tmax rt)) rt)>", "by auto2"], ["", "subsubsection \\<open>Insertion\\<close>"], ["", "partial_function (heap) insert_impl :: \"nat idx_interval \\<Rightarrow> int_tree \\<Rightarrow> int_tree Heap\" where\n  \"insert_impl v b = (case b of\n    None \\<Rightarrow> int_tree_constr None v None\n  | Some p \\<Rightarrow> do {\n    t \\<leftarrow> !p;\n    (if v = val t then do {\n       return (Some p) }\n     else if v < val t then do {\n       q \\<leftarrow> insert_impl v (lsub t);\n       m \\<leftarrow> compute_tmax (val t) q (rsub t);\n       p := Node q (val t) m (rsub t);\n       return (Some p) }\n     else do {\n       q \\<leftarrow> insert_impl v (rsub t);\n       m \\<leftarrow> compute_tmax (val t) (lsub t) q;\n       p := Node (lsub t) (val t) m q;\n       return (Some p) })})\""], ["", "lemma int_tree_insert_to_fun [hoare_triple]:\n  \"<int_tree t b>\n    insert_impl v b\n   <int_tree (insert v t)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> insert_impl v b <int_tree (Interval_Tree.insert v t)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> insert_impl v b <int_tree (Interval_Tree.insert v t)>", "@induct t arbitrary b"], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> insert_impl v b <int_tree (Interval_Tree.insert v t)>", "@qed"], ["", "subsubsection \\<open>Deletion\\<close>"], ["", "partial_function (heap) int_tree_del_min :: \"int_tree \\<Rightarrow> (nat idx_interval \\<times> int_tree) Heap\" where\n  \"int_tree_del_min b = (case b of\n     None \\<Rightarrow> raise STR ''del_min: empty tree''\n   | Some p \\<Rightarrow> do {\n      t \\<leftarrow> !p;\n      (if lsub t = None then\n         return (val t, rsub t)\n       else do {\n         r \\<leftarrow> int_tree_del_min (lsub t);\n         m \\<leftarrow> compute_tmax (val t) (snd r) (rsub t);\n         p := Node (snd r) (val t) m (rsub t);\n         return (fst r, Some p) })})\""], ["", "lemma int_tree_del_min_to_fun [hoare_triple]:\n  \"<int_tree t b * \\<up>(b \\<noteq> None)>\n   int_tree_del_min b\n   <\\<lambda>r. int_tree (snd (del_min t)) (snd r) * \\<up>(fst(r) = fst (del_min t))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b *\n     \\<up>\n      (b \\<noteq>\n       None)> int_tree_del_min\n               b <\\<lambda>r.\n                     int_tree (snd (del_min t)) (snd r) *\n                     \\<up> (fst r = fst (del_min t))>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b *\n     \\<up>\n      (b \\<noteq>\n       None)> int_tree_del_min\n               b <\\<lambda>r.\n                     int_tree (snd (del_min t)) (snd r) *\n                     \\<up> (fst r = fst (del_min t))>\\<^sub>t", "@induct t arbitrary b"], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b *\n     \\<up>\n      (b \\<noteq>\n       None)> int_tree_del_min\n               b <\\<lambda>r.\n                     int_tree (snd (del_min t)) (snd r) *\n                     \\<up> (fst r = fst (del_min t))>\\<^sub>t", "@qed"], ["", "definition int_tree_del_elt :: \"int_tree \\<Rightarrow> int_tree Heap\" where\n  \"int_tree_del_elt b = (case b of\n     None \\<Rightarrow> raise STR ''del_elt: empty tree''\n   | Some p \\<Rightarrow> do {\n       t \\<leftarrow> !p;\n       (if lsub t = None then return (rsub t)\n        else if rsub t = None then return (lsub t)\n        else do {\n          r \\<leftarrow> int_tree_del_min (rsub t);\n          m \\<leftarrow> compute_tmax (fst r) (lsub t) (snd r);\n          p := Node (lsub t) (fst r) m (snd r);\n          return (Some p) }) })\""], ["", "lemma int_tree_del_elt_to_fun [hoare_triple]:\n  \"<int_tree (interval_tree.Node lt v m rt) b>\n   int_tree_del_elt b\n   <int_tree (delete_elt_tree (interval_tree.Node lt v m rt))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree (interval_tree.Node lt v m rt)\n      b> int_tree_del_elt\n          b <int_tree\n              (delete_elt_tree (interval_tree.Node lt v m rt))>\\<^sub>t", "by auto2"], ["", "partial_function (heap) delete_impl :: \"nat idx_interval \\<Rightarrow> int_tree \\<Rightarrow> int_tree Heap\" where\n  \"delete_impl x b = (case b of\n     None \\<Rightarrow> return None\n   | Some p \\<Rightarrow> do {\n      t \\<leftarrow> !p;\n      (if x = val t then do {\n         r \\<leftarrow> int_tree_del_elt b;\n         return r }\n       else if x < val t then do {\n         q \\<leftarrow> delete_impl x (lsub t);\n         m \\<leftarrow> compute_tmax (val t) q (rsub t);\n         p := Node q (val t) m (rsub t);\n         return (Some p) }\n       else do {\n         q \\<leftarrow> delete_impl x (rsub t);\n         m \\<leftarrow> compute_tmax (val t) (lsub t) q;\n         p := Node (lsub t) (val t) m q;\n         return (Some p) })})\""], ["", "lemma int_tree_delete_to_fun [hoare_triple]:\n  \"<int_tree t b>\n    delete_impl x b\n   <int_tree (delete x t)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> delete_impl x b <int_tree (delete x t)>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> delete_impl x b <int_tree (delete x t)>\\<^sub>t", "@induct t arbitrary b"], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> delete_impl x b <int_tree (delete x t)>\\<^sub>t", "@qed"], ["", "subsubsection \\<open>Search\\<close>"], ["", "partial_function (heap) search_impl :: \"nat interval \\<Rightarrow> int_tree \\<Rightarrow> bool Heap\" where\n  \"search_impl x b = (case b of\n     None \\<Rightarrow> return False\n   | Some p \\<Rightarrow> do {\n      t \\<leftarrow> !p;\n      (if is_overlap (int (val t)) x then return True\n       else case lsub t of\n           None \\<Rightarrow> do { b \\<leftarrow> search_impl x (rsub t); return b }\n         | Some lp \\<Rightarrow> do {\n            lt \\<leftarrow> !lp;\n            if tmax lt \\<ge> low x then\n              do { b \\<leftarrow> search_impl x (lsub t); return b }\n            else\n              do { b \\<leftarrow> search_impl x (rsub t); return b }})})\""], ["", "lemma search_impl_correct [hoare_triple]:\n  \"<int_tree t b>\n    search_impl x b\n   <\\<lambda>r. int_tree t b * \\<up>(r \\<longleftrightarrow> search t x)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> search_impl x b\n    <\\<lambda>r. int_tree t b * \\<up> (r = search t x)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> search_impl x b\n    <\\<lambda>r. int_tree t b * \\<up> (r = search t x)>", "@induct t arbitrary b @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> search_impl x b\n    <\\<lambda>r. int_tree t b * \\<up> (r = search t x)>", "@subgoal \"t = interval_tree.Node l v m r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> search_impl x b\n    <\\<lambda>r. int_tree t b * \\<up> (r = search t x)>", "@case \"is_overlap (int v) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> search_impl x b\n    <\\<lambda>r. int_tree t b * \\<up> (r = search t x)>", "@case \"l \\<noteq> Tip \\<and> interval_tree.tmax l \\<ge> low x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> search_impl x b\n    <\\<lambda>r. int_tree t b * \\<up> (r = search t x)>", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> search_impl x b\n    <\\<lambda>r. int_tree t b * \\<up> (r = search t x)>", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree t b> search_impl x b\n    <\\<lambda>r. int_tree t b * \\<up> (r = search t x)>", "@qed"], ["", "subsection \\<open>Outer interface\\<close>"], ["", "text \\<open>Express Hoare triples for operations on interval tree in terms of\n  the set of intervals represented by the tree.\\<close>"], ["", "definition int_tree_set :: \"nat idx_interval set \\<Rightarrow> int_tree \\<Rightarrow> assn\" where\n  \"int_tree_set S p = (\\<exists>\\<^sub>At. int_tree t p * \\<up>(is_interval_tree t) * \\<up>(S = tree_set t))\""], ["", "setup \\<open>add_rewrite_ent_rule @{thm int_tree_set_def}\\<close>"], ["", "theorem int_tree_empty_rule [hoare_triple]:\n  \"<emp> int_tree_empty <int_tree_set {}>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> int_tree_empty <int_tree_set {}>", "by auto2"], ["", "theorem int_tree_insert_rule [hoare_triple]:\n  \"<int_tree_set S b * \\<up>(is_interval (int x))>\n   insert_impl x b\n   <int_tree_set (S \\<union> {x})>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree_set S b * \\<up> (is_interval (idx_interval.int x))>\n    insert_impl x b <int_tree_set (S \\<union> {x})>", "by auto2"], ["", "theorem int_tree_delete_rule [hoare_triple]:\n  \"<int_tree_set S b * \\<up>(is_interval (int x))>\n   delete_impl x b\n   <int_tree_set (S - {x})>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree_set S b *\n     \\<up>\n      (is_interval\n        (idx_interval.int\n          x))> delete_impl x b <int_tree_set (S - {x})>\\<^sub>t", "by auto2"], ["", "theorem int_tree_search_rule [hoare_triple]:\n  \"<int_tree_set S b * \\<up>(is_interval x)>\n   search_impl x b\n   <\\<lambda>r. int_tree_set S b * \\<up>(r \\<longleftrightarrow> has_overlap S x)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <int_tree_set S b * \\<up> (is_interval x)> search_impl x b\n    <\\<lambda>r. int_tree_set S b * \\<up> (r = has_overlap S x)>", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm int_tree_set_def}\\<close>"], ["", "end"]]}