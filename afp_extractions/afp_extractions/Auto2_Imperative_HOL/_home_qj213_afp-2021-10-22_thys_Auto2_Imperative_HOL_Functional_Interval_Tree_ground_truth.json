{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Functional/Interval_Tree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma tree_sorted_lr [forward]:\n  \"tree_sorted (Node l it m r) \\<Longrightarrow> tree_sorted l \\<and> tree_sorted r\"", "lemma tree_sortedD1 [forward]:\n  \"tree_sorted (Node l it m r) \\<Longrightarrow> x \\<in> tree_set l \\<Longrightarrow> x < it\"", "lemma tree_sortedD2 [forward]:\n  \"tree_sorted (Node l it m r) \\<Longrightarrow> x \\<in> tree_set r \\<Longrightarrow> x > it\"", "lemma inorder_preserve_set [rewrite]:\n  \"tree_set t = set (in_traverse t)\"", "lemma inorder_sorted [rewrite]:\n  \"tree_sorted t \\<longleftrightarrow> strict_sorted (in_traverse t)\"", "lemma tree_max_is_max [resolve]:\n  \"tree_max_inv t \\<Longrightarrow> it \\<in> tree_set t \\<Longrightarrow> high (int it) \\<le> tmax t\"", "lemma tmax_exists [backward]:\n  \"tree_max_inv t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> \\<exists>p\\<in>tree_set t. high (int p) = tmax t\"", "lemma max3_insert [rewrite]: \"max3 it 0 0 = high (int it)\"", "lemma is_interval_tree_lr [forward]:\n  \"is_interval_tree (Node l x m r) \\<Longrightarrow> is_interval_tree l \\<and> is_interval_tree r\"", "lemma tree_insert_in_traverse [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> in_traverse (insert x t) = ordered_insert x (in_traverse t)\"", "lemma tree_insert_max_inv [forward]:\n  \"tree_max_inv t \\<Longrightarrow> tree_max_inv (insert x t)\"", "theorem tree_insert_all_inv [forward]:\n  \"is_interval_tree t \\<Longrightarrow> is_interval (int it) \\<Longrightarrow> is_interval_tree (insert it t)\"", "theorem tree_insert_on_set [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> tree_set (insert it t) = {it} \\<union> tree_set t\"", "lemma delete_min_del_hd:\n  \"t \\<noteq> Tip \\<Longrightarrow> fst (del_min t) # in_traverse (snd (del_min t)) = in_traverse t\"", "lemma delete_min_max_inv [forward_arg]:\n  \"tree_max_inv t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> tree_max_inv (snd (del_min t))\"", "lemma delete_min_on_set:\n  \"t \\<noteq> Tip \\<Longrightarrow> {fst (del_min t)} \\<union> tree_set (snd (del_min t)) = tree_set t\"", "lemma delete_min_interval_inv [forward_arg]:\n  \"tree_interval_inv t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> tree_interval_inv (snd (del_min t))\"", "lemma delete_min_all_inv [forward_arg]:\n  \"is_interval_tree t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> is_interval_tree (snd (del_min t))\"", "lemma delete_elt_in_traverse [rewrite]:\n  \"in_traverse (delete_elt_tree (Node lt x m rt)) = in_traverse lt @ in_traverse rt\"", "lemma delete_elt_max_inv [forward_arg]:\n  \"tree_max_inv t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> tree_max_inv (delete_elt_tree t)\"", "lemma delete_elt_on_set [rewrite]:\n  \"t \\<noteq> Tip \\<Longrightarrow> tree_set (delete_elt_tree (Node lt x m rt)) = tree_set lt \\<union> tree_set rt\"", "lemma delete_elt_interval_inv [forward_arg]:\n  \"tree_interval_inv t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> tree_interval_inv (delete_elt_tree t)\"", "lemma delete_elt_all_inv [forward_arg]:\n  \"is_interval_tree t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> is_interval_tree (delete_elt_tree t)\"", "lemma tree_delete_in_traverse [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> in_traverse (delete x t) = remove_elt_list x (in_traverse t)\"", "lemma tree_delete_max_inv [forward]:\n  \"tree_max_inv t \\<Longrightarrow> tree_max_inv (delete x t)\"", "theorem tree_delete_all_inv [forward]:\n  \"is_interval_tree t \\<Longrightarrow> is_interval_tree (delete x t)\"", "theorem tree_delete_on_set [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> tree_set (delete x t) = tree_set t - {x}\"", "theorem search_correct [rewrite]:\n  \"is_interval_tree t \\<Longrightarrow> is_interval x \\<Longrightarrow> search t x \\<longleftrightarrow> has_overlap (tree_set t) x\""], "translations": [["", "lemma tree_sorted_lr [forward]:\n  \"tree_sorted (Node l it m r) \\<Longrightarrow> tree_sorted l \\<and> tree_sorted r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted (Node l it m r) \\<Longrightarrow>\n    tree_sorted l \\<and> tree_sorted r", "by auto2"], ["", "lemma tree_sortedD1 [forward]:\n  \"tree_sorted (Node l it m r) \\<Longrightarrow> x \\<in> tree_set l \\<Longrightarrow> x < it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_sorted (Node l it m r); x \\<in> tree_set l\\<rbrakk>\n    \\<Longrightarrow> x < it", "by auto2"], ["", "lemma tree_sortedD2 [forward]:\n  \"tree_sorted (Node l it m r) \\<Longrightarrow> x \\<in> tree_set r \\<Longrightarrow> x > it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_sorted (Node l it m r); x \\<in> tree_set r\\<rbrakk>\n    \\<Longrightarrow> it < x", "by auto2"], ["", "lemma inorder_preserve_set [rewrite]:\n  \"tree_set t = set (in_traverse t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_set t = set (in_traverse t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_set t = set (in_traverse t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_set t = set (in_traverse t)", "@qed"], ["", "lemma inorder_sorted [rewrite]:\n  \"tree_sorted t \\<longleftrightarrow> strict_sorted (in_traverse t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t = Lists_Ex.strict_sorted (in_traverse t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t = Lists_Ex.strict_sorted (in_traverse t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t = Lists_Ex.strict_sorted (in_traverse t)", "@qed"], ["", "text \\<open>Use definition in terms of in\\_traverse from now on.\\<close>"], ["", "setup \\<open>fold del_prfstep_thm (@{thms tree_set.simps} @ @{thms tree_sorted.simps})\\<close>"], ["", "subsection \\<open>Invariant on the maximum\\<close>"], ["", "definition max3 :: \"nat idx_interval \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where [rewrite]:\n  \"max3 it b c = max (high (int it)) (max b c)\""], ["", "fun tree_max_inv :: \"interval_tree \\<Rightarrow> bool\" where\n  \"tree_max_inv Tip = True\"\n| \"tree_max_inv (Node l it m r) \\<longleftrightarrow> (tree_max_inv l \\<and> tree_max_inv r \\<and> m = max3 it (tmax l) (tmax r))\""], ["", "setup \\<open>fold add_rewrite_rule @{thms tree_max_inv.simps}\\<close>"], ["", "lemma tree_max_is_max [resolve]:\n  \"tree_max_inv t \\<Longrightarrow> it \\<in> tree_set t \\<Longrightarrow> high (int it) \\<le> tmax t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; it \\<in> tree_set t\\<rbrakk>\n    \\<Longrightarrow> high (idx_interval.int it) \\<le> tmax t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; it \\<in> tree_set t\\<rbrakk>\n    \\<Longrightarrow> high (idx_interval.int it) \\<le> tmax t", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; it \\<in> tree_set t\\<rbrakk>\n    \\<Longrightarrow> high (idx_interval.int it) \\<le> tmax t", "@qed"], ["", "lemma tmax_exists [backward]:\n  \"tree_max_inv t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> \\<exists>p\\<in>tree_set t. high (int p) = tmax t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p\\<in>tree_set t.\n                         high (idx_interval.int p) = tmax t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p\\<in>tree_set t.\n                         high (idx_interval.int p) = tmax t", "@induct t @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p\\<in>tree_set t.\n                         high (idx_interval.int p) = tmax t", "@subgoal \"t = Node l it m r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p\\<in>tree_set t.\n                         high (idx_interval.int p) = tmax t", "@case \"l = Tip\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p\\<in>tree_set t.\n                         high (idx_interval.int p) = tmax t", "@case \"r = Tip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p\\<in>tree_set t.\n                         high (idx_interval.int p) = tmax t", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p\\<in>tree_set t.\n                         high (idx_interval.int p) = tmax t", "@case \"r = Tip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p\\<in>tree_set t.\n                         high (idx_interval.int p) = tmax t", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p\\<in>tree_set t.\n                         high (idx_interval.int p) = tmax t", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p\\<in>tree_set t.\n                         high (idx_interval.int p) = tmax t", "@qed"], ["", "text \\<open>For insertion\\<close>"], ["", "lemma max3_insert [rewrite]: \"max3 it 0 0 = high (int it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max3 it 0 0 = high (idx_interval.int it)", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm max3_def}\\<close>"], ["", "subsection \\<open>Condition on the values\\<close>"], ["", "definition tree_interval_inv :: \"interval_tree \\<Rightarrow> bool\" where [rewrite]:\n  \"tree_interval_inv t \\<longleftrightarrow> (\\<forall>p\\<in>tree_set t. is_interval (int p))\""], ["", "definition is_interval_tree :: \"interval_tree \\<Rightarrow> bool\" where [rewrite]:\n  \"is_interval_tree t \\<longleftrightarrow> (tree_sorted t \\<and> tree_max_inv t \\<and> tree_interval_inv t)\""], ["", "lemma is_interval_tree_lr [forward]:\n  \"is_interval_tree (Node l x m r) \\<Longrightarrow> is_interval_tree l \\<and> is_interval_tree r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_interval_tree (Node l x m r) \\<Longrightarrow>\n    is_interval_tree l \\<and> is_interval_tree r", "by auto2"], ["", "subsection \\<open>Insertion on trees\\<close>"], ["", "fun insert :: \"nat idx_interval \\<Rightarrow> interval_tree \\<Rightarrow> interval_tree\" where\n  \"insert x Tip = Node Tip x (high (int x)) Tip\"\n| \"insert x (Node l y m r) =\n    (if x = y then Node l y m r\n     else if x < y then\n       let l' = insert x l in\n           Node l' y (max3 y (tmax l') (tmax r)) r\n     else\n       let r' = insert x r in\n           Node l y (max3 y (tmax l) (tmax r')) r')\""], ["", "setup \\<open>fold add_rewrite_rule @{thms insert.simps}\\<close>"], ["", "lemma tree_insert_in_traverse [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> in_traverse (insert x t) = ordered_insert x (in_traverse t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse (Interval_Tree.insert x t) =\n    ordered_insert x (in_traverse t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse (Interval_Tree.insert x t) =\n    ordered_insert x (in_traverse t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse (Interval_Tree.insert x t) =\n    ordered_insert x (in_traverse t)", "@qed"], ["", "lemma tree_insert_max_inv [forward]:\n  \"tree_max_inv t \\<Longrightarrow> tree_max_inv (insert x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_max_inv t \\<Longrightarrow> tree_max_inv (Interval_Tree.insert x t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_max_inv t \\<Longrightarrow> tree_max_inv (Interval_Tree.insert x t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_max_inv t \\<Longrightarrow> tree_max_inv (Interval_Tree.insert x t)", "@qed"], ["", "text \\<open>Correctness of insertion.\\<close>"], ["", "theorem tree_insert_all_inv [forward]:\n  \"is_interval_tree t \\<Longrightarrow> is_interval (int it) \\<Longrightarrow> is_interval_tree (insert it t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval (idx_interval.int it)\\<rbrakk>\n    \\<Longrightarrow> is_interval_tree (Interval_Tree.insert it t)", "by auto2"], ["", "theorem tree_insert_on_set [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> tree_set (insert it t) = {it} \\<union> tree_set t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    tree_set (Interval_Tree.insert it t) = {it} \\<union> tree_set t", "by auto2"], ["", "subsection \\<open>Deletion on trees\\<close>"], ["", "fun del_min :: \"interval_tree \\<Rightarrow> nat idx_interval \\<times> interval_tree\" where\n  \"del_min Tip = undefined\"\n| \"del_min (Node lt v m rt) =\n   (if lt = Tip then (v, rt) else\n    let lt' = snd (del_min lt) in\n    (fst (del_min lt), Node lt' v (max3 v (tmax lt') (tmax rt)) rt))\""], ["", "setup \\<open>add_rewrite_rule @{thm del_min.simps(2)}\\<close>"], ["", "setup \\<open>register_wellform_data (\"del_min t\", [\"t \\<noteq> Tip\"])\\<close>"], ["", "lemma delete_min_del_hd:\n  \"t \\<noteq> Tip \\<Longrightarrow> fst (del_min t) # in_traverse (snd (del_min t)) = in_traverse t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Tip \\<Longrightarrow>\n    fst (del_min t) # in_traverse (snd (del_min t)) = in_traverse t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Tip \\<Longrightarrow>\n    fst (del_min t) # in_traverse (snd (del_min t)) = in_traverse t", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Tip \\<Longrightarrow>\n    fst (del_min t) # in_traverse (snd (del_min t)) = in_traverse t", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm delete_min_del_hd} [with_term \"in_traverse (snd (del_min ?t))\"]\\<close>"], ["", "lemma delete_min_max_inv [forward_arg]:\n  \"tree_max_inv t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> tree_max_inv (snd (del_min t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> tree_max_inv (snd (del_min t))", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> tree_max_inv (snd (del_min t))", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> tree_max_inv (snd (del_min t))", "@qed"], ["", "lemma delete_min_on_set:\n  \"t \\<noteq> Tip \\<Longrightarrow> {fst (del_min t)} \\<union> tree_set (snd (del_min t)) = tree_set t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Tip \\<Longrightarrow>\n    {fst (del_min t)} \\<union> tree_set (snd (del_min t)) = tree_set t", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm delete_min_on_set} [with_term \"tree_set (snd (del_min ?t))\"]\\<close>"], ["", "lemma delete_min_interval_inv [forward_arg]:\n  \"tree_interval_inv t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> tree_interval_inv (snd (del_min t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_interval_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> tree_interval_inv (snd (del_min t))", "by auto2"], ["", "lemma delete_min_all_inv [forward_arg]:\n  \"is_interval_tree t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> is_interval_tree (snd (del_min t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> is_interval_tree (snd (del_min t))", "by auto2"], ["", "fun delete_elt_tree :: \"interval_tree \\<Rightarrow> interval_tree\" where\n  \"delete_elt_tree Tip = undefined\"\n| \"delete_elt_tree (Node lt x m rt) =\n    (if lt = Tip then rt else if rt = Tip then lt else\n     let x' = fst (del_min rt);\n         rt' = snd (del_min rt);\n         m' = max3 x' (tmax lt) (tmax rt') in\n       Node lt (fst (del_min rt)) m' rt')\""], ["", "setup \\<open>add_rewrite_rule @{thm delete_elt_tree.simps(2)}\\<close>"], ["", "lemma delete_elt_in_traverse [rewrite]:\n  \"in_traverse (delete_elt_tree (Node lt x m rt)) = in_traverse lt @ in_traverse rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_traverse (delete_elt_tree (Node lt x m rt)) =\n    in_traverse lt @ in_traverse rt", "by auto2"], ["", "lemma delete_elt_max_inv [forward_arg]:\n  \"tree_max_inv t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> tree_max_inv (delete_elt_tree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_max_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> tree_max_inv (delete_elt_tree t)", "by auto2"], ["", "lemma delete_elt_on_set [rewrite]:\n  \"t \\<noteq> Tip \\<Longrightarrow> tree_set (delete_elt_tree (Node lt x m rt)) = tree_set lt \\<union> tree_set rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Tip \\<Longrightarrow>\n    tree_set (delete_elt_tree (Node lt x m rt)) =\n    tree_set lt \\<union> tree_set rt", "by auto2"], ["", "lemma delete_elt_interval_inv [forward_arg]:\n  \"tree_interval_inv t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> tree_interval_inv (delete_elt_tree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tree_interval_inv t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> tree_interval_inv (delete_elt_tree t)", "by auto2"], ["", "lemma delete_elt_all_inv [forward_arg]:\n  \"is_interval_tree t \\<Longrightarrow> t \\<noteq> Tip \\<Longrightarrow> is_interval_tree (delete_elt_tree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; t \\<noteq> Tip\\<rbrakk>\n    \\<Longrightarrow> is_interval_tree (delete_elt_tree t)", "by auto2"], ["", "fun delete :: \"nat idx_interval \\<Rightarrow> interval_tree \\<Rightarrow> interval_tree\" where\n  \"delete x Tip = Tip\"\n| \"delete x (Node l y m r) =\n    (if x = y then delete_elt_tree (Node l y m r)\n     else if x < y then\n       let l' = delete x l;\n           m' = max3 y (tmax l') (tmax r) in Node l' y m' r\n     else\n       let r' = delete x r;\n           m' = max3 y (tmax l) (tmax r') in Node l y m' r')\""], ["", "setup \\<open>fold add_rewrite_rule @{thms delete.simps}\\<close>"], ["", "lemma tree_delete_in_traverse [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> in_traverse (delete x t) = remove_elt_list x (in_traverse t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse (delete x t) = remove_elt_list x (in_traverse t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse (delete x t) = remove_elt_list x (in_traverse t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse (delete x t) = remove_elt_list x (in_traverse t)", "@qed"], ["", "lemma tree_delete_max_inv [forward]:\n  \"tree_max_inv t \\<Longrightarrow> tree_max_inv (delete x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_max_inv t \\<Longrightarrow> tree_max_inv (delete x t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_max_inv t \\<Longrightarrow> tree_max_inv (delete x t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_max_inv t \\<Longrightarrow> tree_max_inv (delete x t)", "@qed"], ["", "text \\<open>Correctness of deletion.\\<close>"], ["", "theorem tree_delete_all_inv [forward]:\n  \"is_interval_tree t \\<Longrightarrow> is_interval_tree (delete x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_interval_tree t \\<Longrightarrow> is_interval_tree (delete x t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_interval_tree t \\<Longrightarrow> is_interval_tree (delete x t)", "@have \"tree_set (delete x t) \\<subseteq> tree_set t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_interval_tree t \\<Longrightarrow> is_interval_tree (delete x t)", "@qed"], ["", "theorem tree_delete_on_set [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> tree_set (delete x t) = tree_set t - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow> tree_set (delete x t) = tree_set t - {x}", "by auto2"], ["", "subsection \\<open>Search on interval trees\\<close>"], ["", "fun search :: \"interval_tree \\<Rightarrow> nat interval \\<Rightarrow> bool\" where\n  \"search Tip x = False\"\n| \"search (Node l y m r) x =\n   (if is_overlap (int y) x then True\n    else if l \\<noteq> Tip \\<and> tmax l \\<ge> low x then search l x\n    else search r x)\""], ["", "setup \\<open>fold add_rewrite_rule @{thms search.simps}\\<close>"], ["", "text \\<open>Correctness of search\\<close>"], ["", "theorem search_correct [rewrite]:\n  \"is_interval_tree t \\<Longrightarrow> is_interval x \\<Longrightarrow> search t x \\<longleftrightarrow> has_overlap (tree_set t) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@induct t @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@subgoal \"t = Node l y m r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@let \"t = Node l y m r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@case \"is_overlap (int y) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@case \"l \\<noteq> Tip \\<and> tmax l \\<ge> low x\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@obtain \"p\\<in>tree_set l\" where \"high (int p) = tmax l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@case \"is_overlap (int p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@case \"l = Tip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_interval_tree t; is_interval x\\<rbrakk>\n    \\<Longrightarrow> search t x = has_overlap (tree_set t) x", "@qed"], ["", "end"]]}