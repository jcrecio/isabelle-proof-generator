{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Imperative/DynamicArray.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma dyn_array_new_rule' [hoare_triple]:\n  \"<emp>\n   dyn_array_new\n   <dyn_array_raw (replicate 5 undefined, 0)>\"", "lemma double_length_rule' [hoare_triple]:\n  \"length xs = n \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   double_length p\n   <dyn_array_raw (double_length_fun (xs, n))>\\<^sub>t\"", "lemma push_array_basic_rule' [hoare_triple]:\n  \"n < length xs \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   push_array_basic x p\n   <dyn_array_raw (push_array_basic_fun x (xs, n))>\"", "lemma array_length_rule' [hoare_triple]:\n  \"<dyn_array_raw (xs, n) p>\n   array_length p\n   <\\<lambda>r. dyn_array_raw (xs, n) p * \\<up>(r = n)>\"", "lemma array_max_rule' [hoare_triple]:\n  \"<dyn_array_raw (xs, n) p>\n   array_max p\n   <\\<lambda>r. dyn_array_raw (xs, n) p * \\<up>(r = length xs)>\"", "lemma array_nth_rule' [hoare_triple]:\n  \"i < n \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   array_nth p i\n   <\\<lambda>r. dyn_array_raw (xs, n) p * \\<up>(r = xs ! i)>\"", "lemma array_upd_rule' [hoare_triple]:\n  \"i < n \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   array_upd i x p\n   <\\<lambda>_. dyn_array_raw (list_update xs i x, n) p>\"", "lemma pop_array_rule' [hoare_triple]:\n  \"n > 0 \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   pop_array p\n   <\\<lambda>(x, r). dyn_array_raw (xs, n - 1) r * \\<up>(x = xs ! (n - 1))>\"", "lemma push_array_rule' [hoare_triple]:\n  \"n \\<le> length xs \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   push_array x p\n   <dyn_array_raw (push_array_fun x (xs, n))>\\<^sub>t\"", "lemma double_length_abs [rewrite]:\n  \"length xs = n \\<Longrightarrow> abs_array (double_length_fun (xs, n)) = abs_array (xs, n)\"", "lemma push_array_basic_abs [rewrite]:\n  \"n < length xs \\<Longrightarrow> abs_array (push_array_basic_fun x (xs, n)) = abs_array (xs, n) @ [x]\"", "lemma push_array_fun_abs [rewrite]:\n  \"n \\<le> length xs \\<Longrightarrow> abs_array (push_array_fun x (xs, n)) = abs_array (xs, n) @ [x]\"", "lemma dyn_array_new_rule [hoare_triple]:\n  \"<emp> dyn_array_new <dyn_array []>\"", "lemma array_length_rule [hoare_triple]:\n  \"<dyn_array xs p>\n   array_length p\n   <\\<lambda>r. dyn_array xs p * \\<up>(r = length xs)>\"", "lemma array_nth_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow>\n   <dyn_array xs p>\n    array_nth p i\n   <\\<lambda>r. dyn_array xs p * \\<up>(r = xs ! i)>\"", "lemma array_upd_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow>\n   <dyn_array xs p>\n    array_upd i x p\n   <\\<lambda>_. dyn_array (list_update xs i x) p>\"", "lemma push_array_rule [hoare_triple]:\n  \"<dyn_array xs p>\n    push_array x p\n   <dyn_array (xs @ [x])>\\<^sub>t\"", "lemma pop_array_rule [hoare_triple]:\n  \"xs \\<noteq> [] \\<Longrightarrow>\n   <dyn_array xs p>\n   pop_array p\n   <\\<lambda>(x, r). dyn_array (butlast xs) r * \\<up>(x = last xs)>\"", "lemma array_swap_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow>\n   <dyn_array xs p>\n   array_swap p i j\n   <\\<lambda>_. dyn_array (list_swap xs i j) p>\""], "translations": [["", "lemma dyn_array_new_rule' [hoare_triple]:\n  \"<emp>\n   dyn_array_new\n   <dyn_array_raw (replicate 5 undefined, 0)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> dyn_array_new <dyn_array_raw (replicate 5 undefined, 0)>", "by auto2"], ["", "fun double_length :: \"'a::heap dynamic_array \\<Rightarrow> 'a dynamic_array Heap\" where\n  \"double_length (Dyn_Array al ar) = do {\n      am \\<leftarrow> Array.len ar;\n      p \\<leftarrow> Array.new (2 * am + 1) undefined;\n      array_copy ar p am;\n      return (Dyn_Array am p)\n    }\""], ["", "fun double_length_fun :: \"'a::heap list \\<times> nat \\<Rightarrow> 'a list \\<times> nat\" where\n  \"double_length_fun (xs, n) =\n    (Arrays_Ex.array_copy xs (replicate (2 * n + 1) undefined) n, n)\""], ["", "setup \\<open>add_rewrite_rule @{thm double_length_fun.simps}\\<close>"], ["", "lemma double_length_rule' [hoare_triple]:\n  \"length xs = n \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   double_length p\n   <dyn_array_raw (double_length_fun (xs, n))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow>\n    <dyn_array_raw (xs, n)\n      p> double_length p <dyn_array_raw (double_length_fun (xs, n))>\\<^sub>t", "by auto2"], ["", "fun push_array_basic :: \"'a \\<Rightarrow> 'a::heap dynamic_array \\<Rightarrow> 'a dynamic_array Heap\" where\n  \"push_array_basic x (Dyn_Array al ar) = do {\n    Array.upd al x ar;\n    return (Dyn_Array (al + 1) ar)\n   }\""], ["", "fun push_array_basic_fun :: \"'a \\<Rightarrow> 'a::heap list \\<times> nat \\<Rightarrow> 'a list \\<times> nat\" where\n  \"push_array_basic_fun x (xs, n) = (list_update xs n x, n + 1)\""], ["", "setup \\<open>add_rewrite_rule @{thm push_array_basic_fun.simps}\\<close>"], ["", "lemma push_array_basic_rule' [hoare_triple]:\n  \"n < length xs \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   push_array_basic x p\n   <dyn_array_raw (push_array_basic_fun x (xs, n))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    <dyn_array_raw (xs, n) p> push_array_basic x p\n    <dyn_array_raw (push_array_basic_fun x (xs, n))>", "by auto2"], ["", "definition array_length :: \"'a dynamic_array \\<Rightarrow> nat Heap\" where\n  \"array_length d = return (alen d)\""], ["", "lemma array_length_rule' [hoare_triple]:\n  \"<dyn_array_raw (xs, n) p>\n   array_length p\n   <\\<lambda>r. dyn_array_raw (xs, n) p * \\<up>(r = n)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <dyn_array_raw (xs, n) p> array_length p\n    <\\<lambda>r. dyn_array_raw (xs, n) p * \\<up> (r = n)>", "by auto2"], ["", "definition array_max :: \"'a::heap dynamic_array \\<Rightarrow> nat Heap\" where\n  \"array_max d = Array.len (aref d)\""], ["", "lemma array_max_rule' [hoare_triple]:\n  \"<dyn_array_raw (xs, n) p>\n   array_max p\n   <\\<lambda>r. dyn_array_raw (xs, n) p * \\<up>(r = length xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <dyn_array_raw (xs, n) p> array_max p\n    <\\<lambda>r. dyn_array_raw (xs, n) p * \\<up> (r = length xs)>", "by auto2"], ["", "definition array_nth :: \"'a::heap dynamic_array \\<Rightarrow> nat \\<Rightarrow> 'a Heap\" where\n  \"array_nth d i = Array.nth (aref d) i\""], ["", "lemma array_nth_rule' [hoare_triple]:\n  \"i < n \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   array_nth p i\n   <\\<lambda>r. dyn_array_raw (xs, n) p * \\<up>(r = xs ! i)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n; n \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> <dyn_array_raw (xs, n) p> array_nth p i\n                      <\\<lambda>r.\n                          dyn_array_raw (xs, n) p * \\<up> (r = xs ! i)>", "by auto2"], ["", "definition array_upd :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a::heap dynamic_array \\<Rightarrow> unit Heap\" where\n  \"array_upd i x d = do { Array.upd i x (aref d); return () }\""], ["", "lemma array_upd_rule' [hoare_triple]:\n  \"i < n \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   array_upd i x p\n   <\\<lambda>_. dyn_array_raw (list_update xs i x, n) p>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n; n \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> <dyn_array_raw (xs, n) p> array_upd i x p\n                      <\\<lambda>_. dyn_array_raw (xs[i := x], n) p>", "by auto2"], ["", "definition push_array :: \"'a \\<Rightarrow> 'a::heap dynamic_array \\<Rightarrow> 'a dynamic_array Heap\" where\n  \"push_array x p = do {\n    m \\<leftarrow> array_max p;\n    l \\<leftarrow> array_length p;\n    if l < m then push_array_basic x p\n    else do {\n      u \\<leftarrow> double_length p;\n      push_array_basic x u\n    }\n  }\""], ["", "definition pop_array :: \"'a::heap dynamic_array \\<Rightarrow> ('a \\<times> 'a dynamic_array) Heap\" where\n  \"pop_array d = do {\n    x \\<leftarrow> Array.nth (aref d) (alen d - 1);\n    return (x, Dyn_Array (alen d - 1) (aref d))\n   }\""], ["", "lemma pop_array_rule' [hoare_triple]:\n  \"n > 0 \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   pop_array p\n   <\\<lambda>(x, r). dyn_array_raw (xs, n - 1) r * \\<up>(x = xs ! (n - 1))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> <dyn_array_raw (xs, n) p> pop_array p\n                      <\\<lambda>(x, r).\n                          dyn_array_raw (xs, n - 1) r *\n                          \\<up> (x = xs ! (n - 1))>", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm dyn_array_raw.simps}\\<close>"], ["", "setup \\<open>del_simple_datatype \"dynamic_array\"\\<close>"], ["", "fun push_array_fun :: \"'a \\<Rightarrow> 'a::heap list \\<times> nat \\<Rightarrow> 'a list \\<times> nat\" where\n  \"push_array_fun x (xs, n) = (\n     if n < length xs then push_array_basic_fun x (xs, n)\n     else push_array_basic_fun x (double_length_fun (xs, n)))\""], ["", "setup \\<open>add_rewrite_rule @{thm push_array_fun.simps}\\<close>"], ["", "lemma push_array_rule' [hoare_triple]:\n  \"n \\<le> length xs \\<Longrightarrow>\n   <dyn_array_raw (xs, n) p>\n   push_array x p\n   <dyn_array_raw (push_array_fun x (xs, n))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    <dyn_array_raw (xs, n)\n      p> push_array x p <dyn_array_raw (push_array_fun x (xs, n))>\\<^sub>t", "by auto2"], ["", "subsection \\<open>Abstract assertion\\<close>"], ["", "fun abs_array :: \"'a::heap list \\<times> nat \\<Rightarrow> 'a list\" where\n  \"abs_array (xs, n) = take n xs\""], ["", "setup \\<open>add_rewrite_rule @{thm abs_array.simps}\\<close>"], ["", "lemma double_length_abs [rewrite]:\n  \"length xs = n \\<Longrightarrow> abs_array (double_length_fun (xs, n)) = abs_array (xs, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow>\n    abs_array (double_length_fun (xs, n)) = abs_array (xs, n)", "by auto2"], ["", "lemma push_array_basic_abs [rewrite]:\n  \"n < length xs \\<Longrightarrow> abs_array (push_array_basic_fun x (xs, n)) = abs_array (xs, n) @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    abs_array (push_array_basic_fun x (xs, n)) = abs_array (xs, n) @ [x]", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    abs_array (push_array_basic_fun x (xs, n)) = abs_array (xs, n) @ [x]", "@have \"length (take n xs @ [x]) = n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    abs_array (push_array_basic_fun x (xs, n)) = abs_array (xs, n) @ [x]", "@qed"], ["", "lemma push_array_fun_abs [rewrite]:\n  \"n \\<le> length xs \\<Longrightarrow> abs_array (push_array_fun x (xs, n)) = abs_array (xs, n) @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    abs_array (push_array_fun x (xs, n)) = abs_array (xs, n) @ [x]", "by auto2"], ["", "definition dyn_array :: \"'a::heap list \\<Rightarrow> 'a dynamic_array \\<Rightarrow> assn\" where [rewrite_ent]:\n  \"dyn_array xs a = (\\<exists>\\<^sub>Ap. dyn_array_raw p a * \\<up>(xs = abs_array p) * \\<up>(snd p \\<le> length (fst p)))\""], ["", "lemma dyn_array_new_rule [hoare_triple]:\n  \"<emp> dyn_array_new <dyn_array []>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> dyn_array_new <dyn_array []>", "by auto2"], ["", "lemma array_length_rule [hoare_triple]:\n  \"<dyn_array xs p>\n   array_length p\n   <\\<lambda>r. dyn_array xs p * \\<up>(r = length xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <dyn_array xs p> array_length p\n    <\\<lambda>r. dyn_array xs p * \\<up> (r = length xs)>", "by auto2"], ["", "lemma array_nth_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow>\n   <dyn_array xs p>\n    array_nth p i\n   <\\<lambda>r. dyn_array xs p * \\<up>(r = xs ! i)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    <dyn_array xs p> array_nth p i\n    <\\<lambda>r. dyn_array xs p * \\<up> (r = xs ! i)>", "by auto2"], ["", "lemma array_upd_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow>\n   <dyn_array xs p>\n    array_upd i x p\n   <\\<lambda>_. dyn_array (list_update xs i x) p>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    <dyn_array xs p> array_upd i x p <\\<lambda>_. dyn_array (xs[i := x]) p>", "by auto2"], ["", "lemma push_array_rule [hoare_triple]:\n  \"<dyn_array xs p>\n    push_array x p\n   <dyn_array (xs @ [x])>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <dyn_array xs p> push_array x p <dyn_array (xs @ [x])>\\<^sub>t", "by auto2"], ["", "lemma pop_array_rule [hoare_triple]:\n  \"xs \\<noteq> [] \\<Longrightarrow>\n   <dyn_array xs p>\n   pop_array p\n   <\\<lambda>(x, r). dyn_array (butlast xs) r * \\<up>(x = last xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    <dyn_array xs p> pop_array p\n    <\\<lambda>(x, r). dyn_array (butlast xs) r * \\<up> (x = last xs)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    <dyn_array xs p> pop_array p\n    <\\<lambda>(x, r). dyn_array (butlast xs) r * \\<up> (x = last xs)>", "@have \"last xs = xs ! (length xs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    <dyn_array xs p> pop_array p\n    <\\<lambda>(x, r). dyn_array (butlast xs) r * \\<up> (x = last xs)>", "@qed"], ["", "setup \\<open>del_prfstep_thm @{thm dyn_array_def}\\<close>"], ["", "subsection \\<open>Derived operations\\<close>"], ["", "definition array_swap :: \"'a::heap dynamic_array \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> unit Heap\" where\n  \"array_swap d i j = do {\n    x \\<leftarrow> array_nth d i;\n    y \\<leftarrow> array_nth d j;\n    array_upd i y d;\n    array_upd j x d;\n    return ()\n   }\""], ["", "lemma array_swap_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow>\n   <dyn_array xs p>\n   array_swap p i j\n   <\\<lambda>_. dyn_array (list_swap xs i j) p>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs\\<rbrakk>\n    \\<Longrightarrow> <dyn_array xs p> array_swap p i j\n                      <\\<lambda>_. dyn_array (list_swap xs i j) p>", "by auto2"], ["", "end"]]}