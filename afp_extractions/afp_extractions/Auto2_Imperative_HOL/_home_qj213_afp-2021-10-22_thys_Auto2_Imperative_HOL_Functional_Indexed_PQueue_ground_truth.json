{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Functional/Indexed_PQueue.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma s_inj [forward]:\n  \"s1 m = s1 m' \\<Longrightarrow> m = m'\" \"s2 m = s2 m' \\<Longrightarrow> m = m'\"", "lemma s_neq [resolve]:\n  \"s1 m \\<noteq> s2 m'\" \"s1 m > m\" \"s2 m > m\" \"s2 m > s1 m\"", "lemma eq_pred_parent1 [forward]:\n  \"eq_pred i (s1 k) \\<Longrightarrow> i \\<noteq> s1 k \\<Longrightarrow> eq_pred i k\"", "lemma eq_pred_parent2 [forward]:\n  \"eq_pred i (s2 k) \\<Longrightarrow> i \\<noteq> s2 k \\<Longrightarrow> eq_pred i k\"", "lemma eq_pred_cases:\n  \"eq_pred i j \\<Longrightarrow> eq_pred (s1 i) j \\<or> eq_pred (s2 i) j \\<or> j = i \\<or> j = s1 i \\<or> j = s2 i\"", "lemma eq_pred_le [forward]: \"eq_pred i j \\<Longrightarrow> i \\<le> j\"", "lemma is_heapD:\n  \"is_heap xs \\<Longrightarrow> j < length xs \\<Longrightarrow> eq_pred i j \\<Longrightarrow> snd (xs ! i) \\<le> snd (xs ! j)\"", "lemma bubble_down1:\n  \"s1 k < length xs \\<Longrightarrow> is_heap_partial1 xs k \\<Longrightarrow> snd (xs ! k) > snd (xs ! s1 k) \\<Longrightarrow>\n   snd (xs ! s1 k) \\<le> snd (xs ! s2 k) \\<Longrightarrow> is_heap_partial1 (list_swap xs k (s1 k)) (s1 k)\"", "lemma bubble_down2:\n  \"s1 k < length xs \\<Longrightarrow> is_heap_partial1 xs k \\<Longrightarrow> snd (xs ! k) > snd (xs ! s1 k) \\<Longrightarrow>\n   s2 k \\<ge> length xs \\<Longrightarrow> is_heap_partial1 (list_swap xs k (s1 k)) (s1 k)\"", "lemma bubble_down3:\n  \"s2 k < length xs \\<Longrightarrow> is_heap_partial1 xs k \\<Longrightarrow> snd (xs ! s1 k) > snd (xs ! s2 k) \\<Longrightarrow>\n   snd (xs ! k) > snd (xs ! s2 k) \\<Longrightarrow> xs' = list_swap xs k (s2 k) \\<Longrightarrow> is_heap_partial1 xs' (s2 k)\"", "lemma ps_inverse [rewrite]: \"par (s1 k) = k\" \"par (s2 k) = k\"", "lemma p_basic: \"m \\<noteq> 0 \\<Longrightarrow> par m < m\"", "lemma p_cases: \"m \\<noteq> 0 \\<Longrightarrow> m = s1 (par m) \\<or> m = s2 (par m)\"", "lemma eq_pred_p_next:\n  \"i \\<noteq> 0 \\<Longrightarrow> eq_pred i j \\<Longrightarrow> eq_pred (par i) j\"", "lemma heap_implies_hd_min [resolve]:\n  \"is_heap xs \\<Longrightarrow> i < length xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> snd (hd xs) \\<le> snd (xs ! i)\"", "lemma bubble_up1 [forward]:\n  \"k < length xs \\<Longrightarrow> is_heap_partial2 xs k \\<Longrightarrow> snd (xs ! k) < snd (xs ! par k) \\<Longrightarrow> k \\<noteq> 0 \\<Longrightarrow>\n   is_heap_partial2 (list_swap xs k (par k)) (par k)\"", "lemma bubble_up2 [forward]:\n  \"k < length xs \\<Longrightarrow> is_heap_partial2 xs k \\<Longrightarrow> snd (xs ! k) \\<ge> snd (xs ! par k) \\<Longrightarrow> k \\<noteq> 0 \\<Longrightarrow>\n   is_heap xs\"", "lemma index_of_pqueueD1:\n  \"i < length xs \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   fst (xs ! i) < length m \\<and> m ! (fst (xs ! i)) = Some i\"", "lemma index_of_pqueueD2 [forward]:\n  \"k < length m \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   m ! k = Some i \\<Longrightarrow> i < length xs \\<and> fst (xs ! i) = k\"", "lemma index_of_pqueueD3 [forward]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> p \\<in> set xs \\<Longrightarrow> fst p < length m\"", "lemma has_index_unique_key [forward]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> unique_keys_set (set xs)\"", "lemma has_index_keys_of [rewrite]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> has_key_alist xs k \\<longleftrightarrow> (k < length m \\<and> m ! k \\<noteq> None)\"", "lemma has_index_distinct [forward]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> distinct xs\"", "lemma index_of_pqueue_swap [forward_arg]:\n  \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   index_of_pqueue (idx_pqueue_swap_fun (xs, m) i j)\"", "lemma fst_idx_pqueue_swap [rewrite]:\n  \"fst (idx_pqueue_swap_fun (xs, m) i j) = list_swap xs i j\"", "lemma snd_idx_pqueue_swap [rewrite]:\n  \"length (snd (idx_pqueue_swap_fun (xs, m) i j)) = length m\"", "lemma idx_pqueue_push_correct [forward_arg]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> k < length m \\<Longrightarrow> \\<not>has_key_alist xs k \\<Longrightarrow>\n   r = idx_pqueue_push_fun k v (xs, m) \\<Longrightarrow>\n   index_of_pqueue r \\<and> fst r = xs @ [(k, v)] \\<and> length (snd r) = length m\"", "lemma idx_pqueue_pop_correct [forward_arg]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> r = idx_pqueue_pop_fun (xs, m) \\<Longrightarrow>\n   index_of_pqueue r \\<and> fst r = butlast xs \\<and> length (snd r) = length m\"", "lemma idx_bubble_down_fun_correct:\n  \"r = idx_bubble_down_fun x k \\<Longrightarrow> is_heap_partial1 (fst x) k \\<Longrightarrow>\n   is_heap (fst r) \\<and> mset (fst r) = mset (fst x) \\<and> length (snd r) = length (snd x)\"", "lemma idx_bubble_down_fun_correct2 [forward]:\n  \"index_of_pqueue x \\<Longrightarrow> index_of_pqueue (idx_bubble_down_fun x k)\"", "lemma idx_bubble_up_fun_correct:\n  \"r = idx_bubble_up_fun x k \\<Longrightarrow> is_heap_partial2 (fst x) k \\<Longrightarrow>\n   is_heap (fst r) \\<and> mset (fst r) = mset (fst x) \\<and> length (snd r) = length (snd x)\"", "lemma idx_bubble_up_fun_correct2 [forward]:\n  \"index_of_pqueue x \\<Longrightarrow> index_of_pqueue (idx_bubble_up_fun x k)\"", "lemma delete_min_idx_pqueue_correct:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> res = delete_min_idx_pqueue_fun (xs, m) \\<Longrightarrow>\n   index_of_pqueue (snd res)\"", "lemma hd_last_swap_eval_last [rewrite]:\n  \"xs \\<noteq> [] \\<Longrightarrow> last (list_swap xs 0 (length xs - 1)) = hd xs\"", "theorem delete_min_idx_pqueue_correct2:\n  \"is_heap xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> res = delete_min_idx_pqueue_fun (xs, m) \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   is_heap (fst (snd res)) \\<and> fst res = hd xs \\<and> length (snd (snd res)) = length m \\<and>\n   map_of_alist (fst (snd res)) = delete_map (fst (fst res)) (map_of_alist xs)\"", "lemma insert_idx_pqueue_correct [forward_arg]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> k < length m \\<Longrightarrow> \\<not>has_key_alist xs k \\<Longrightarrow>\n   index_of_pqueue (insert_idx_pqueue_fun k v (xs, m))\"", "theorem insert_idx_pqueue_correct2:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> is_heap xs \\<Longrightarrow> k < length m \\<Longrightarrow> \\<not>has_key_alist xs k \\<Longrightarrow>\n   r = insert_idx_pqueue_fun k v (xs, m) \\<Longrightarrow>\n   is_heap (fst r) \\<and> length (snd r) = length m \\<and>\n   map_of_alist (fst r) = map_of_alist xs { k \\<rightarrow> v }\"", "lemma update_idx_pqueue_correct [forward_arg]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> k < length m \\<Longrightarrow>\n   index_of_pqueue (update_idx_pqueue_fun k v (xs, m))\"", "theorem update_idx_pqueue_correct2:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> is_heap xs \\<Longrightarrow> k < length m \\<Longrightarrow>\n   r = update_idx_pqueue_fun k v (xs, m) \\<Longrightarrow>\n   is_heap (fst r) \\<and> length (snd r) = length m \\<and>\n   map_of_alist (fst r) = map_of_alist xs { k \\<rightarrow> v }\""], "translations": [["", "lemma s_inj [forward]:\n  \"s1 m = s1 m' \\<Longrightarrow> m = m'\" \"s2 m = s2 m' \\<Longrightarrow> m = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s1 m = s1 m' \\<Longrightarrow> m = m') &&&\n    (s2 m = s2 m' \\<Longrightarrow> m = m')", "by auto"], ["", "lemma s_neq [resolve]:\n  \"s1 m \\<noteq> s2 m'\" \"s1 m > m\" \"s2 m > m\" \"s2 m > s1 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s1 m \\<noteq> s2 m' &&& m < s1 m) &&& m < s2 m &&& s1 m < s2 m", "using s1.simps s2.simps"], ["proof (prove)\nusing this:\n  s1 ?m = 2 * ?m + 1\n  s2 ?m = 2 * ?m + 2\n\ngoal (1 subgoal):\n 1. (s1 m \\<noteq> s2 m' &&& m < s1 m) &&& m < s2 m &&& s1 m < s2 m", "by presburger+"], ["", "setup \\<open>add_forward_prfstep_cond @{thm s_neq(2)} [with_term \"s1 ?m\"]\\<close>"], ["", "setup \\<open>add_forward_prfstep_cond @{thm s_neq(3)} [with_term \"s2 ?m\"]\\<close>"], ["", "setup \\<open>add_forward_prfstep_cond @{thm s_neq(4)} [with_term \"s2 ?m\", with_term \"s1 ?m\"]\\<close>"], ["", "inductive eq_pred :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"eq_pred n n\"\n| \"eq_pred n m \\<Longrightarrow> eq_pred n (s1 m)\"\n| \"eq_pred n m \\<Longrightarrow> eq_pred n (s2 m)\""], ["", "setup \\<open>add_case_induct_rule @{thm eq_pred.cases}\\<close>"], ["", "setup \\<open>add_prop_induct_rule @{thm eq_pred.induct}\\<close>"], ["", "setup \\<open>add_resolve_prfstep @{thm eq_pred.intros(1)}\\<close>"], ["", "setup \\<open>fold add_backward_prfstep @{thms eq_pred.intros(2,3)}\\<close>"], ["", "lemma eq_pred_parent1 [forward]:\n  \"eq_pred i (s1 k) \\<Longrightarrow> i \\<noteq> s1 k \\<Longrightarrow> eq_pred i k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_pred i (s1 k); i \\<noteq> s1 k\\<rbrakk>\n    \\<Longrightarrow> eq_pred i k", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_pred i (s1 k); i \\<noteq> s1 k\\<rbrakk>\n    \\<Longrightarrow> eq_pred i k", "@let \"v = s1 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_pred i (s1 k); i \\<noteq> s1 k\\<rbrakk>\n    \\<Longrightarrow> eq_pred i k", "@prop_induct \"eq_pred i v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_pred i (s1 k); i \\<noteq> s1 k\\<rbrakk>\n    \\<Longrightarrow> eq_pred i k", "@qed"], ["", "lemma eq_pred_parent2 [forward]:\n  \"eq_pred i (s2 k) \\<Longrightarrow> i \\<noteq> s2 k \\<Longrightarrow> eq_pred i k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_pred i (s2 k); i \\<noteq> s2 k\\<rbrakk>\n    \\<Longrightarrow> eq_pred i k", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_pred i (s2 k); i \\<noteq> s2 k\\<rbrakk>\n    \\<Longrightarrow> eq_pred i k", "@let \"v = s2 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_pred i (s2 k); i \\<noteq> s2 k\\<rbrakk>\n    \\<Longrightarrow> eq_pred i k", "@prop_induct \"eq_pred i v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_pred i (s2 k); i \\<noteq> s2 k\\<rbrakk>\n    \\<Longrightarrow> eq_pred i k", "@qed"], ["", "lemma eq_pred_cases:\n  \"eq_pred i j \\<Longrightarrow> eq_pred (s1 i) j \\<or> eq_pred (s2 i) j \\<or> j = i \\<or> j = s1 i \\<or> j = s2 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_pred i j \\<Longrightarrow>\n    eq_pred (s1 i) j \\<or>\n    eq_pred (s2 i) j \\<or> j = i \\<or> j = s1 i \\<or> j = s2 i", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_pred i j \\<Longrightarrow>\n    eq_pred (s1 i) j \\<or>\n    eq_pred (s2 i) j \\<or> j = i \\<or> j = s1 i \\<or> j = s2 i", "@prop_induct \"eq_pred i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_pred i j \\<Longrightarrow>\n    eq_pred (s1 i) j \\<or>\n    eq_pred (s2 i) j \\<or> j = i \\<or> j = s1 i \\<or> j = s2 i", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm eq_pred_cases} [with_cond \"?i \\<noteq> s1 ?k\", with_cond \"?i \\<noteq> s2 ?k\"]\\<close>"], ["", "lemma eq_pred_le [forward]: \"eq_pred i j \\<Longrightarrow> i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_pred i j \\<Longrightarrow> i \\<le> j", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_pred i j \\<Longrightarrow> i \\<le> j", "@prop_induct \"eq_pred i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_pred i j \\<Longrightarrow> i \\<le> j", "@qed"], ["", "subsection \\<open>Heap property\\<close>"], ["", "text \\<open>The corresponding tree is a heap\\<close>"], ["", "definition is_heap :: \"('a \\<times> 'b::linorder) list \\<Rightarrow> bool\" where [rewrite]:\n  \"is_heap xs = (\\<forall>i j. eq_pred i j \\<longrightarrow> j < length xs \\<longrightarrow> snd (xs ! i) \\<le> snd (xs ! j))\""], ["", "lemma is_heapD:\n  \"is_heap xs \\<Longrightarrow> j < length xs \\<Longrightarrow> eq_pred i j \\<Longrightarrow> snd (xs ! i) \\<le> snd (xs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; j < length xs; eq_pred i j\\<rbrakk>\n    \\<Longrightarrow> snd (xs ! i) \\<le> snd (xs ! j)", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm is_heapD} [with_term \"?xs ! ?j\"]\\<close>"], ["", "setup \\<open>del_prfstep_thm_eqforward @{thm is_heap_def}\\<close>"], ["", "subsection \\<open>Bubble-down\\<close>"], ["", "text \\<open>The corresponding tree is a heap, except k is not necessarily smaller than its descendents.\\<close>"], ["", "definition is_heap_partial1 :: \"('a \\<times> 'b::linorder) list \\<Rightarrow> nat \\<Rightarrow> bool\" where [rewrite]:\n  \"is_heap_partial1 xs k = (\\<forall>i j. eq_pred i j \\<longrightarrow> i \\<noteq> k \\<longrightarrow> j < length xs \\<longrightarrow> snd (xs ! i) \\<le> snd (xs ! j))\""], ["", "text \\<open>Two cases of switching with s1 k.\\<close>"], ["", "lemma bubble_down1:\n  \"s1 k < length xs \\<Longrightarrow> is_heap_partial1 xs k \\<Longrightarrow> snd (xs ! k) > snd (xs ! s1 k) \\<Longrightarrow>\n   snd (xs ! s1 k) \\<le> snd (xs ! s2 k) \\<Longrightarrow> is_heap_partial1 (list_swap xs k (s1 k)) (s1 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 k < length xs; is_heap_partial1 xs k;\n     snd (xs ! s1 k) < snd (xs ! k);\n     snd (xs ! s1 k) \\<le> snd (xs ! s2 k)\\<rbrakk>\n    \\<Longrightarrow> is_heap_partial1 (list_swap xs k (s1 k)) (s1 k)", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm bubble_down1} [with_term \"list_swap ?xs ?k (s1 ?k)\"]\\<close>"], ["", "lemma bubble_down2:\n  \"s1 k < length xs \\<Longrightarrow> is_heap_partial1 xs k \\<Longrightarrow> snd (xs ! k) > snd (xs ! s1 k) \\<Longrightarrow>\n   s2 k \\<ge> length xs \\<Longrightarrow> is_heap_partial1 (list_swap xs k (s1 k)) (s1 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 k < length xs; is_heap_partial1 xs k;\n     snd (xs ! s1 k) < snd (xs ! k); length xs \\<le> s2 k\\<rbrakk>\n    \\<Longrightarrow> is_heap_partial1 (list_swap xs k (s1 k)) (s1 k)", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm bubble_down2} [with_term \"list_swap ?xs ?k (s1 ?k)\"]\\<close>"], ["", "text \\<open>One case of switching with s2 k.\\<close>"], ["", "lemma bubble_down3:\n  \"s2 k < length xs \\<Longrightarrow> is_heap_partial1 xs k \\<Longrightarrow> snd (xs ! s1 k) > snd (xs ! s2 k) \\<Longrightarrow>\n   snd (xs ! k) > snd (xs ! s2 k) \\<Longrightarrow> xs' = list_swap xs k (s2 k) \\<Longrightarrow> is_heap_partial1 xs' (s2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s2 k < length xs; is_heap_partial1 xs k;\n     snd (xs ! s2 k) < snd (xs ! s1 k); snd (xs ! s2 k) < snd (xs ! k);\n     xs' = list_swap xs k (s2 k)\\<rbrakk>\n    \\<Longrightarrow> is_heap_partial1 xs' (s2 k)", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm bubble_down3} [with_term \"?xs'\"]\\<close>"], ["", "subsection \\<open>Bubble-up\\<close>"], ["", "fun par :: \"nat \\<Rightarrow> nat\" where\n  \"par m = (m - 1) div 2\""], ["", "setup \\<open>register_wellform_data (\"par m\", [\"m \\<noteq> 0\"])\\<close>"], ["", "lemma ps_inverse [rewrite]: \"par (s1 k) = k\" \"par (s2 k) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (s1 k) = k &&& par (s2 k) = k", "by simp+"], ["", "lemma p_basic: \"m \\<noteq> 0 \\<Longrightarrow> par m < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> par m < m", "by auto"], ["", "setup \\<open>add_forward_prfstep_cond @{thm p_basic} [with_term \"par ?m\"]\\<close>"], ["", "lemma p_cases: \"m \\<noteq> 0 \\<Longrightarrow> m = s1 (par m) \\<or> m = s2 (par m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> m = s1 (par m) \\<or> m = s2 (par m)", "by auto"], ["", "setup \\<open>add_forward_prfstep_cond @{thm p_cases} [with_term \"par ?m\"]\\<close>"], ["", "lemma eq_pred_p_next:\n  \"i \\<noteq> 0 \\<Longrightarrow> eq_pred i j \\<Longrightarrow> eq_pred (par i) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> 0; eq_pred i j\\<rbrakk>\n    \\<Longrightarrow> eq_pred (par i) j", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> 0; eq_pred i j\\<rbrakk>\n    \\<Longrightarrow> eq_pred (par i) j", "@prop_induct \"eq_pred i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> 0; eq_pred i j\\<rbrakk>\n    \\<Longrightarrow> eq_pred (par i) j", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm eq_pred_p_next} [with_term \"par ?i\"]\\<close>"], ["", "lemma heap_implies_hd_min [resolve]:\n  \"is_heap xs \\<Longrightarrow> i < length xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> snd (hd xs) \\<le> snd (xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; i < length xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> snd (hd xs) \\<le> snd (xs ! i)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; i < length xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> snd (hd xs) \\<le> snd (xs ! i)", "@strong_induct i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; i < length xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> snd (hd xs) \\<le> snd (xs ! i)", "@case \"i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; i < length xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> snd (hd xs) \\<le> snd (xs ! i)", "@apply_induct_hyp \"par i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; i < length xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> snd (hd xs) \\<le> snd (xs ! i)", "@have \"eq_pred (par i) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; i < length xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> snd (hd xs) \\<le> snd (xs ! i)", "@qed"], ["", "text \\<open>The corresponding tree is a heap, except k is not necessarily greater than its ancestors.\\<close>"], ["", "definition is_heap_partial2 :: \"('a \\<times> 'b::linorder) list \\<Rightarrow> nat \\<Rightarrow> bool\" where [rewrite]:\n  \"is_heap_partial2 xs k = (\\<forall>i j. eq_pred i j \\<longrightarrow> j < length xs \\<longrightarrow> j \\<noteq> k \\<longrightarrow> snd (xs ! i) \\<le> snd (xs ! j))\""], ["", "lemma bubble_up1 [forward]:\n  \"k < length xs \\<Longrightarrow> is_heap_partial2 xs k \\<Longrightarrow> snd (xs ! k) < snd (xs ! par k) \\<Longrightarrow> k \\<noteq> 0 \\<Longrightarrow>\n   is_heap_partial2 (list_swap xs k (par k)) (par k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length xs; is_heap_partial2 xs k;\n     snd (xs ! k) < snd (xs ! par k); k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> is_heap_partial2 (list_swap xs k (par k)) (par k)", "by auto2"], ["", "lemma bubble_up2 [forward]:\n  \"k < length xs \\<Longrightarrow> is_heap_partial2 xs k \\<Longrightarrow> snd (xs ! k) \\<ge> snd (xs ! par k) \\<Longrightarrow> k \\<noteq> 0 \\<Longrightarrow>\n   is_heap xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length xs; is_heap_partial2 xs k;\n     snd (xs ! par k) \\<le> snd (xs ! k); k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> is_heap xs", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm p_cases}\\<close>"], ["", "subsection \\<open>Indexed priority queue\\<close>"], ["", "type_synonym 'a idx_pqueue = \"(nat \\<times> 'a) list \\<times> nat option list\""], ["", "fun index_of_pqueue :: \"'a idx_pqueue \\<Rightarrow> bool\" where\n  \"index_of_pqueue (xs, m) = (\n    (\\<forall>i<length xs. fst (xs ! i) < length m \\<and> m ! (fst (xs ! i)) = Some i) \\<and>\n    (\\<forall>i. \\<forall>k<length m. m ! k = Some i \\<longrightarrow> i < length xs \\<and> fst (xs ! i) = k))\""], ["", "setup \\<open>add_rewrite_rule @{thm index_of_pqueue.simps}\\<close>"], ["", "lemma index_of_pqueueD1:\n  \"i < length xs \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   fst (xs ! i) < length m \\<and> m ! (fst (xs ! i)) = Some i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> fst (xs ! i) < length m \\<and>\n                      m ! fst (xs ! i) = Some i", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm index_of_pqueueD1} [with_term \"?xs ! ?i\"]\\<close>"], ["", "lemma index_of_pqueueD2 [forward]:\n  \"k < length m \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   m ! k = Some i \\<Longrightarrow> i < length xs \\<and> fst (xs ! i) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length m; index_of_pqueue (xs, m); m ! k = Some i\\<rbrakk>\n    \\<Longrightarrow> i < length xs \\<and> fst (xs ! i) = k", "by auto2"], ["", "lemma index_of_pqueueD3 [forward]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> p \\<in> set xs \\<Longrightarrow> fst p < length m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); p \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> fst p < length m", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); p \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> fst p < length m", "@obtain i where \"i < length xs\" \"xs ! i = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); p \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> fst p < length m", "@qed"], ["", "setup \\<open>del_prfstep_thm_eqforward @{thm index_of_pqueue.simps}\\<close>"], ["", "lemma has_index_unique_key [forward]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> unique_keys_set (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow> unique_keys_set (set xs)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow> unique_keys_set (set xs)", "@have \"\\<forall>a x y. (a, x) \\<in> set xs \\<longrightarrow> (a, y) \\<in> set xs \\<longrightarrow> x = y\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow> unique_keys_set (set xs)", "@obtain i where \"i < length xs\" \"xs ! i = (a, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow> unique_keys_set (set xs)", "@obtain j where \"j < length xs\" \"xs ! j = (a, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow> unique_keys_set (set xs)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow> unique_keys_set (set xs)", "@qed"], ["", "lemma has_index_keys_of [rewrite]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> has_key_alist xs k \\<longleftrightarrow> (k < length m \\<and> m ! k \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow>\n    has_key_alist xs k = (k < length m \\<and> m ! k \\<noteq> None)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow>\n    has_key_alist xs k = (k < length m \\<and> m ! k \\<noteq> None)", "@case \"has_key_alist xs k\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow>\n    has_key_alist xs k = (k < length m \\<and> m ! k \\<noteq> None)", "@obtain v' where \"(k, v') \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow>\n    has_key_alist xs k = (k < length m \\<and> m ! k \\<noteq> None)", "@obtain i where \"i < length xs \\<and> xs ! i = (k, v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow>\n    has_key_alist xs k = (k < length m \\<and> m ! k \\<noteq> None)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow>\n    has_key_alist xs k = (k < length m \\<and> m ! k \\<noteq> None)", "@qed"], ["", "lemma has_index_distinct [forward]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow> distinct xs", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow> distinct xs", "@have \"\\<forall>i<length xs. \\<forall>j<length xs. i \\<noteq> j \\<longrightarrow> xs ! i \\<noteq> xs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue (xs, m) \\<Longrightarrow> distinct xs", "@qed"], ["", "subsection \\<open>Basic operations on indexed\\_queue\\<close>"], ["", "fun idx_pqueue_swap_fun :: \"(nat \\<times> 'a) list \\<times> nat option list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> 'a) list \\<times> nat option list\" where\n  \"idx_pqueue_swap_fun (xs, m) i j = (\n    list_swap xs i j, ((m [fst (xs ! i) := Some j]) [fst (xs ! j) := Some i]))\""], ["", "lemma index_of_pqueue_swap [forward_arg]:\n  \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   index_of_pqueue (idx_pqueue_swap_fun (xs, m) i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (idx_pqueue_swap_fun (xs, m) i j)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (idx_pqueue_swap_fun (xs, m) i j)", "@unfold \"idx_pqueue_swap_fun (xs, m) i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (idx_pqueue_swap_fun (xs, m) i j)", "@qed"], ["", "lemma fst_idx_pqueue_swap [rewrite]:\n  \"fst (idx_pqueue_swap_fun (xs, m) i j) = list_swap xs i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (idx_pqueue_swap_fun (xs, m) i j) = list_swap xs i j", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (idx_pqueue_swap_fun (xs, m) i j) = list_swap xs i j", "@unfold \"idx_pqueue_swap_fun (xs, m) i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (idx_pqueue_swap_fun (xs, m) i j) = list_swap xs i j", "@qed"], ["", "lemma snd_idx_pqueue_swap [rewrite]:\n  \"length (snd (idx_pqueue_swap_fun (xs, m) i j)) = length m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (snd (idx_pqueue_swap_fun (xs, m) i j)) = length m", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (snd (idx_pqueue_swap_fun (xs, m) i j)) = length m", "@unfold \"idx_pqueue_swap_fun (xs, m) i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (snd (idx_pqueue_swap_fun (xs, m) i j)) = length m", "@qed"], ["", "fun idx_pqueue_push_fun :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a idx_pqueue \\<Rightarrow> 'a idx_pqueue\" where\n  \"idx_pqueue_push_fun k v (xs, m) = (xs @ [(k, v)], list_update m k (Some (length xs)))\""], ["", "lemma idx_pqueue_push_correct [forward_arg]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> k < length m \\<Longrightarrow> \\<not>has_key_alist xs k \\<Longrightarrow>\n   r = idx_pqueue_push_fun k v (xs, m) \\<Longrightarrow>\n   index_of_pqueue r \\<and> fst r = xs @ [(k, v)] \\<and> length (snd r) = length m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m;\n     \\<not> has_key_alist xs k; r = idx_pqueue_push_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue r \\<and>\n                      fst r = xs @ [(k, v)] \\<and> length (snd r) = length m", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m;\n     \\<not> has_key_alist xs k; r = idx_pqueue_push_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue r \\<and>\n                      fst r = xs @ [(k, v)] \\<and> length (snd r) = length m", "@unfold \"idx_pqueue_push_fun k v (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m;\n     \\<not> has_key_alist xs k; r = idx_pqueue_push_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue r \\<and>\n                      fst r = xs @ [(k, v)] \\<and> length (snd r) = length m", "@qed"], ["", "fun idx_pqueue_pop_fun :: \"'a idx_pqueue \\<Rightarrow> 'a idx_pqueue\" where\n  \"idx_pqueue_pop_fun (xs, m) = (butlast xs, list_update m (fst (last xs)) None)\""], ["", "lemma idx_pqueue_pop_correct [forward_arg]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> r = idx_pqueue_pop_fun (xs, m) \\<Longrightarrow>\n   index_of_pqueue r \\<and> fst r = butlast xs \\<and> length (snd r) = length m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); xs \\<noteq> [];\n     r = idx_pqueue_pop_fun (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue r \\<and>\n                      fst r = butlast xs \\<and> length (snd r) = length m", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); xs \\<noteq> [];\n     r = idx_pqueue_pop_fun (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue r \\<and>\n                      fst r = butlast xs \\<and> length (snd r) = length m", "@unfold \"idx_pqueue_pop_fun (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); xs \\<noteq> [];\n     r = idx_pqueue_pop_fun (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue r \\<and>\n                      fst r = butlast xs \\<and> length (snd r) = length m", "@have \"length xs = length (butlast xs) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); xs \\<noteq> [];\n     r = idx_pqueue_pop_fun (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue r \\<and>\n                      fst r = butlast xs \\<and> length (snd r) = length m", "@have \"fst (xs ! length (butlast xs)) < length m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); xs \\<noteq> [];\n     r = idx_pqueue_pop_fun (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue r \\<and>\n                      fst r = butlast xs \\<and> length (snd r) = length m", "(* TODO: remove? *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); xs \\<noteq> [];\n     r = idx_pqueue_pop_fun (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue r \\<and>\n                      fst r = butlast xs \\<and> length (snd r) = length m", "@qed"], ["", "subsection \\<open>Bubble up and down\\<close>"], ["", "function idx_bubble_down_fun :: \"'a::linorder idx_pqueue \\<Rightarrow> nat \\<Rightarrow> 'a idx_pqueue\" where\n  \"idx_bubble_down_fun (xs, m) k = (\n    if s2 k < length xs then\n      if snd (xs ! s1 k) \\<le> snd (xs ! s2 k) then\n        if snd (xs ! k) > snd (xs ! s1 k) then\n          idx_bubble_down_fun (idx_pqueue_swap_fun (xs, m) k (s1 k)) (s1 k)\n        else (xs, m)\n      else\n        if snd (xs ! k) > snd (xs ! s2 k) then\n          idx_bubble_down_fun (idx_pqueue_swap_fun (xs, m) k (s2 k)) (s2 k)\n        else (xs, m)\n    else if s1 k < length xs then\n      if snd (xs ! k) > snd (xs ! s1 k) then\n        idx_bubble_down_fun (idx_pqueue_swap_fun (xs, m) k (s1 k)) (s1 k)\n      else (xs, m)\n    else (xs, m))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>xs m k.\n           x = ((xs, m), k) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>xs m k xsa ma ka.\n       ((xs, m), k) = ((xsa, ma), ka) \\<Longrightarrow>\n       (if s2 k < length xs\n        then if snd (xs ! s1 k) \\<le> snd (xs ! s2 k)\n             then if snd (xs ! s1 k) < snd (xs ! k)\n                  then idx_bubble_down_fun_sumC\n                        (idx_pqueue_swap_fun (xs, m) k (s1 k), s1 k)\n                  else (xs, m)\n             else if snd (xs ! s2 k) < snd (xs ! k)\n                  then idx_bubble_down_fun_sumC\n                        (idx_pqueue_swap_fun (xs, m) k (s2 k), s2 k)\n                  else (xs, m)\n        else if s1 k < length xs\n             then if snd (xs ! s1 k) < snd (xs ! k)\n                  then idx_bubble_down_fun_sumC\n                        (idx_pqueue_swap_fun (xs, m) k (s1 k), s1 k)\n                  else (xs, m)\n             else (xs, m)) =\n       (if s2 ka < length xsa\n        then if snd (xsa ! s1 ka) \\<le> snd (xsa ! s2 ka)\n             then if snd (xsa ! s1 ka) < snd (xsa ! ka)\n                  then idx_bubble_down_fun_sumC\n                        (idx_pqueue_swap_fun (xsa, ma) ka (s1 ka), s1 ka)\n                  else (xsa, ma)\n             else if snd (xsa ! s2 ka) < snd (xsa ! ka)\n                  then idx_bubble_down_fun_sumC\n                        (idx_pqueue_swap_fun (xsa, ma) ka (s2 ka), s2 ka)\n                  else (xsa, ma)\n        else if s1 ka < length xsa\n             then if snd (xsa ! s1 ka) < snd (xsa ! ka)\n                  then idx_bubble_down_fun_sumC\n                        (idx_pqueue_swap_fun (xsa, ma) ka (s1 ka), s1 ka)\n                  else (xsa, ma)\n             else (xsa, ma))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All idx_bubble_down_fun_dom", "by (relation \"measure (\\<lambda>((xs,_),k). (length xs - k))\") (simp_all, auto2+)"], ["", "lemma idx_bubble_down_fun_correct:\n  \"r = idx_bubble_down_fun x k \\<Longrightarrow> is_heap_partial1 (fst x) k \\<Longrightarrow>\n   is_heap (fst r) \\<and> mset (fst r) = mset (fst x) \\<and> length (snd r) = length (snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_down_fun x k;\n     is_heap_partial1 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_down_fun x k;\n     is_heap_partial1 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@fun_induct \"idx_bubble_down_fun x k\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_down_fun x k;\n     is_heap_partial1 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@subgoal \"(x = (xs, m), k = k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_down_fun x k;\n     is_heap_partial1 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@unfold \"idx_bubble_down_fun (xs, m) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_down_fun x k;\n     is_heap_partial1 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@case \"s2 k < length xs\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_down_fun x k;\n     is_heap_partial1 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@case \"snd (xs ! s1 k) \\<le> snd (xs ! s2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_down_fun x k;\n     is_heap_partial1 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_down_fun x k;\n     is_heap_partial1 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@case \"s1 k < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_down_fun x k;\n     is_heap_partial1 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_down_fun x k;\n     is_heap_partial1 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm idx_bubble_down_fun_correct} [with_term \"?r\"]\\<close>"], ["", "lemma idx_bubble_down_fun_correct2 [forward]:\n  \"index_of_pqueue x \\<Longrightarrow> index_of_pqueue (idx_bubble_down_fun x k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_down_fun x k)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_down_fun x k)", "@fun_induct \"idx_bubble_down_fun x k\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_down_fun x k)", "@subgoal \"(x = (xs, m), k = k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_down_fun x k)", "@unfold \"idx_bubble_down_fun (xs, m) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_down_fun x k)", "@case \"s2 k < length xs\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_down_fun x k)", "@case \"snd (xs ! s1 k) \\<le> snd (xs ! s2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_down_fun x k)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_down_fun x k)", "@case \"s1 k < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_down_fun x k)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_down_fun x k)", "@qed"], ["", "fun idx_bubble_up_fun :: \"'a::linorder idx_pqueue \\<Rightarrow> nat \\<Rightarrow> 'a idx_pqueue\" where\n  \"idx_bubble_up_fun (xs, m) k = (\n    if k = 0 then (xs, m)\n    else if k < length xs then\n      if snd (xs ! k) < snd (xs ! par k) then\n        idx_bubble_up_fun (idx_pqueue_swap_fun (xs, m) k (par k)) (par k)\n      else (xs, m)\n    else (xs, m))\""], ["", "lemma idx_bubble_up_fun_correct:\n  \"r = idx_bubble_up_fun x k \\<Longrightarrow> is_heap_partial2 (fst x) k \\<Longrightarrow>\n   is_heap (fst r) \\<and> mset (fst r) = mset (fst x) \\<and> length (snd r) = length (snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_up_fun x k; is_heap_partial2 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_up_fun x k; is_heap_partial2 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@fun_induct \"idx_bubble_up_fun x k\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_up_fun x k; is_heap_partial2 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@subgoal \"(x = (xs, m), k = k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_up_fun x k; is_heap_partial2 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@unfold \"idx_bubble_up_fun (xs, m) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_up_fun x k; is_heap_partial2 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = idx_bubble_up_fun x k; is_heap_partial2 (fst x) k\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      mset (fst r) = mset (fst x) \\<and>\n                      length (snd r) = length (snd x)", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm idx_bubble_up_fun_correct} [with_term \"?r\"]\\<close>"], ["", "lemma idx_bubble_up_fun_correct2 [forward]:\n  \"index_of_pqueue x \\<Longrightarrow> index_of_pqueue (idx_bubble_up_fun x k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_up_fun x k)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_up_fun x k)", "@fun_induct \"idx_bubble_up_fun x k\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_up_fun x k)", "@subgoal \"(x = (xs, m), k = k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_up_fun x k)", "@unfold \"idx_bubble_up_fun (xs, m) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_up_fun x k)", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    index_of_pqueue (idx_bubble_up_fun x k)", "@qed"], ["", "subsection \\<open>Main operations\\<close>"], ["", "fun delete_min_idx_pqueue_fun :: \"'a::linorder idx_pqueue \\<Rightarrow> (nat \\<times> 'a) \\<times> 'a idx_pqueue\" where\n  \"delete_min_idx_pqueue_fun (xs, m) = (\n    let (xs', m') = idx_pqueue_swap_fun (xs, m) 0 (length xs - 1);\n        a'' = idx_pqueue_pop_fun (xs', m')\n     in (last xs', idx_bubble_down_fun a'' 0))\""], ["", "lemma delete_min_idx_pqueue_correct:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> res = delete_min_idx_pqueue_fun (xs, m) \\<Longrightarrow>\n   index_of_pqueue (snd res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); xs \\<noteq> [];\n     res = delete_min_idx_pqueue_fun (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (snd res)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); xs \\<noteq> [];\n     res = delete_min_idx_pqueue_fun (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (snd res)", "@unfold \"delete_min_idx_pqueue_fun (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); xs \\<noteq> [];\n     res = delete_min_idx_pqueue_fun (xs, m)\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (snd res)", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm delete_min_idx_pqueue_correct} [with_term \"?res\"]\\<close>"], ["", "lemma hd_last_swap_eval_last [rewrite]:\n  \"xs \\<noteq> [] \\<Longrightarrow> last (list_swap xs 0 (length xs - 1)) = hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    last (list_swap xs 0 (length xs - 1)) = hd xs", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    last (list_swap xs 0 (length xs - 1)) = hd xs", "@let \"xs' = list_swap xs 0 (length xs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    last (list_swap xs 0 (length xs - 1)) = hd xs", "@have \"last xs' = xs' ! (length xs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    last (list_swap xs 0 (length xs - 1)) = hd xs", "@qed"], ["", "text \\<open>Correctness of delete-min.\\<close>"], ["", "theorem delete_min_idx_pqueue_correct2:\n  \"is_heap xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> res = delete_min_idx_pqueue_fun (xs, m) \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   is_heap (fst (snd res)) \\<and> fst res = hd xs \\<and> length (snd (snd res)) = length m \\<and>\n   map_of_alist (fst (snd res)) = delete_map (fst (fst res)) (map_of_alist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; xs \\<noteq> [];\n     res = delete_min_idx_pqueue_fun (xs, m);\n     index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst (snd res)) \\<and>\n                      fst res = hd xs \\<and>\n                      length (snd (snd res)) = length m \\<and>\n                      map_of_alist (fst (snd res)) =\n                      delete_map (fst (fst res)) (map_of_alist xs)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; xs \\<noteq> [];\n     res = delete_min_idx_pqueue_fun (xs, m);\n     index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst (snd res)) \\<and>\n                      fst res = hd xs \\<and>\n                      length (snd (snd res)) = length m \\<and>\n                      map_of_alist (fst (snd res)) =\n                      delete_map (fst (fst res)) (map_of_alist xs)", "@unfold \"delete_min_idx_pqueue_fun (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; xs \\<noteq> [];\n     res = delete_min_idx_pqueue_fun (xs, m);\n     index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst (snd res)) \\<and>\n                      fst res = hd xs \\<and>\n                      length (snd (snd res)) = length m \\<and>\n                      map_of_alist (fst (snd res)) =\n                      delete_map (fst (fst res)) (map_of_alist xs)", "@let \"xs' = list_swap xs 0 (length xs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; xs \\<noteq> [];\n     res = delete_min_idx_pqueue_fun (xs, m);\n     index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst (snd res)) \\<and>\n                      fst res = hd xs \\<and>\n                      length (snd (snd res)) = length m \\<and>\n                      map_of_alist (fst (snd res)) =\n                      delete_map (fst (fst res)) (map_of_alist xs)", "@have \"is_heap_partial1 (butlast xs') 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; xs \\<noteq> [];\n     res = delete_min_idx_pqueue_fun (xs, m);\n     index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst (snd res)) \\<and>\n                      fst res = hd xs \\<and>\n                      length (snd (snd res)) = length m \\<and>\n                      map_of_alist (fst (snd res)) =\n                      delete_map (fst (fst res)) (map_of_alist xs)", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm delete_min_idx_pqueue_correct2} [with_term \"?res\"]\\<close>"], ["", "fun insert_idx_pqueue_fun :: \"nat \\<Rightarrow> 'a::linorder \\<Rightarrow> 'a idx_pqueue \\<Rightarrow> 'a idx_pqueue\" where\n  \"insert_idx_pqueue_fun k v x = (\n    let x' = idx_pqueue_push_fun k v x in\n      idx_bubble_up_fun x' (length (fst x') - 1))\""], ["", "lemma insert_idx_pqueue_correct [forward_arg]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> k < length m \\<Longrightarrow> \\<not>has_key_alist xs k \\<Longrightarrow>\n   index_of_pqueue (insert_idx_pqueue_fun k v (xs, m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m;\n     \\<not> has_key_alist xs k\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (insert_idx_pqueue_fun k v (xs, m))", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m;\n     \\<not> has_key_alist xs k\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (insert_idx_pqueue_fun k v (xs, m))", "@unfold \"insert_idx_pqueue_fun k v (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m;\n     \\<not> has_key_alist xs k\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (insert_idx_pqueue_fun k v (xs, m))", "@qed"], ["", "text \\<open>Correctness of insertion.\\<close>"], ["", "theorem insert_idx_pqueue_correct2:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> is_heap xs \\<Longrightarrow> k < length m \\<Longrightarrow> \\<not>has_key_alist xs k \\<Longrightarrow>\n   r = insert_idx_pqueue_fun k v (xs, m) \\<Longrightarrow>\n   is_heap (fst r) \\<and> length (snd r) = length m \\<and>\n   map_of_alist (fst r) = map_of_alist xs { k \\<rightarrow> v }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     \\<not> has_key_alist xs k;\n     r = insert_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     \\<not> has_key_alist xs k;\n     r = insert_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@unfold \"insert_idx_pqueue_fun k v (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     \\<not> has_key_alist xs k;\n     r = insert_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@have \"is_heap_partial2 (xs @ [(k, v)]) (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     \\<not> has_key_alist xs k;\n     r = insert_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm insert_idx_pqueue_correct2} [with_term \"?r\"]\\<close>"], ["", "fun update_idx_pqueue_fun :: \"nat \\<Rightarrow> 'a::linorder \\<Rightarrow> 'a idx_pqueue \\<Rightarrow> 'a idx_pqueue\" where\n  \"update_idx_pqueue_fun k v (xs, m) = (\n    if m ! k = None then\n      insert_idx_pqueue_fun k v (xs, m)\n    else let\n      i = the (m ! k);\n      xs' = list_update xs i (k, v)\n    in\n      if snd (xs ! i) \\<le> v then idx_bubble_down_fun (xs', m) i\n      else idx_bubble_up_fun (xs', m) i)\""], ["", "lemma update_idx_pqueue_correct [forward_arg]:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> k < length m \\<Longrightarrow>\n   index_of_pqueue (update_idx_pqueue_fun k v (xs, m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (update_idx_pqueue_fun k v (xs, m))", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (update_idx_pqueue_fun k v (xs, m))", "@unfold \"update_idx_pqueue_fun k v (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (update_idx_pqueue_fun k v (xs, m))", "@let \"i = the (m ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (update_idx_pqueue_fun k v (xs, m))", "@let \"xs' = list_update xs i (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (update_idx_pqueue_fun k v (xs, m))", "@case \"m ! k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (update_idx_pqueue_fun k v (xs, m))", "@have \"index_of_pqueue (xs', m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); k < length m\\<rbrakk>\n    \\<Longrightarrow> index_of_pqueue (update_idx_pqueue_fun k v (xs, m))", "@qed"], ["", "text \\<open>Correctness of update.\\<close>"], ["", "theorem update_idx_pqueue_correct2:\n  \"index_of_pqueue (xs, m) \\<Longrightarrow> is_heap xs \\<Longrightarrow> k < length m \\<Longrightarrow>\n   r = update_idx_pqueue_fun k v (xs, m) \\<Longrightarrow>\n   is_heap (fst r) \\<and> length (snd r) = length m \\<and>\n   map_of_alist (fst r) = map_of_alist xs { k \\<rightarrow> v }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@unfold \"update_idx_pqueue_fun k v (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@let \"i = the (m ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@let \"xs' = list_update xs i (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@have \"xs' = fst (xs', m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "(* TODO: remove *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@case \"m ! k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@case \"snd (xs ! the (m ! k)) \\<le> v\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@have \"is_heap_partial1 xs' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@have \"is_heap_partial2 xs' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index_of_pqueue (xs, m); is_heap xs; k < length m;\n     r = update_idx_pqueue_fun k v (xs, m)\\<rbrakk>\n    \\<Longrightarrow> is_heap (fst r) \\<and>\n                      length (snd r) = length m \\<and>\n                      map_of_alist (fst r) =\n                       map_of_alist xs { k \\<rightarrow> v }", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm update_idx_pqueue_correct2} [with_term \"?r\"]\\<close>"], ["", "end"]]}