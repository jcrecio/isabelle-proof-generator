{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Imperative/RBTree_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma btree_Leaf [forward_ent]: \"btree Leaf p \\<Longrightarrow>\\<^sub>A \\<up>(p = None)\"", "lemma btree_Node [forward_ent]:\n  \"btree (rbt.Node lt c k v rt) p \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Alp rp. the p \\<mapsto>\\<^sub>r Node lp c k v rp * btree lt lp * btree rt rp * \\<up>(p \\<noteq> None))\"", "lemma btree_none: \"emp \\<Longrightarrow>\\<^sub>A btree Leaf None\"", "lemma btree_constr_ent:\n  \"p \\<mapsto>\\<^sub>r Node lp c k v rp * btree lt lp * btree rt rp \\<Longrightarrow>\\<^sub>A btree (rbt.Node lt c k v rt) (Some p)\"", "lemma tree_empty_rule [hoare_triple]:\n  \"<emp> tree_empty <btree Leaf>\"", "lemma tree_is_empty_rule:\n  \"<btree t b> tree_is_empty b <\\<lambda>r. btree t b * \\<up>(r \\<longleftrightarrow> t = Leaf)>\"", "lemma btree_constr_rule [hoare_triple]:\n  \"<btree lt lp * btree rt rp>\n   btree_constr lp c k v rp\n   <btree (rbt.Node lt c k v rt)>\"", "lemma set_color_rule [hoare_triple]:\n  \"<btree (rbt.Node a c x v b) p>\n   set_color c' p\n   <\\<lambda>_. btree (rbt.Node a c' x v b) p>\"", "lemma get_color_rule [hoare_triple]:\n  \"<btree t p> get_color p <\\<lambda>r. btree t p * \\<up>(r = rbt.cl t)>\"", "lemma paint_rule [hoare_triple]:\n  \"<btree t p>\n   paint c p\n   <\\<lambda>_. btree (RBTree.paint c t) p>\"", "lemma btree_rotate_l_rule [hoare_triple]:\n  \"<btree (rbt.Node a c1 x v (rbt.Node b c2 y w c)) p>\n   btree_rotate_l p\n   <btree (rbt.Node (rbt.Node a c1 x v b) c2 y w c)>\"", "lemma btree_rotate_r_rule [hoare_triple]:\n  \"<btree (rbt.Node (rbt.Node a c1 x v b) c2 y w c) p>\n   btree_rotate_r p\n   <btree (rbt.Node a c1 x v (rbt.Node b c2 y w c))>\"", "lemma balanceR_to_fun [hoare_triple]:\n  \"<btree (rbt.Node l B k v r) p>\n   btree_balanceR p\n   <btree (balanceR l k v r)>\"", "lemma balance_to_fun [hoare_triple]:\n  \"<btree (rbt.Node l B k v r) p>\n   btree_balance p\n   <btree (balance l k v r)>\"", "lemma rbt_ins_to_fun [hoare_triple]:\n  \"<btree t p>\n   rbt_ins k v p\n   <btree (ins k v t)>\"", "lemma rbt_insert_to_fun [hoare_triple]:\n  \"<btree t p>\n   rbt_insert k v p\n   <btree (RBTree.rbt_insert k v t)>\"", "lemma btree_search_correct [hoare_triple]:\n  \"<btree t b * \\<up>(rbt_sorted t)>\n   rbt_search x b\n   <\\<lambda>r. btree t b * \\<up>(r = RBTree.rbt_search t x)>\"", "lemma balL_to_fun [hoare_triple]:\n  \"<btree (rbt.Node l R k v r) p>\n   btree_balL p\n   <btree (balL l k v r)>\"", "lemma balR_to_fun [hoare_triple]:\n  \"<btree (rbt.Node l R k v r) p>\n   btree_balR p\n   <btree (balR l k v r)>\"", "lemma combine_to_fun [hoare_triple]:\n  \"<btree lt lp * btree rt rp>\n   btree_combine lp rp\n   <btree (combine lt rt)>\"", "lemma rbt_del_to_fun [hoare_triple]:\n  \"<btree t p>\n   rbt_del x p\n   <btree (del x t)>\\<^sub>t\"", "lemma rbt_delete_to_fun [hoare_triple]:\n  \"<btree t p>\n   rbt_delete k p\n   <btree (RBTree.delete k t)>\\<^sub>t\"", "theorem rbt_empty_rule [hoare_triple]:\n  \"<emp> tree_empty <rbt_map_assn empty_map>\"", "theorem rbt_insert_rule [hoare_triple]:\n  \"<rbt_map_assn M b> rbt_insert k v b <rbt_map_assn (M {k \\<rightarrow> v})>\"", "theorem rbt_search [hoare_triple]:\n  \"<rbt_map_assn M b> rbt_search x b <\\<lambda>r. rbt_map_assn M b * \\<up>(r = M\\<langle>x\\<rangle>)>\"", "theorem rbt_delete_rule [hoare_triple]:\n  \"<rbt_map_assn M b> rbt_delete k b <rbt_map_assn (delete_map k M)>\\<^sub>t\""], "translations": [["", "lemma btree_Leaf [forward_ent]: \"btree Leaf p \\<Longrightarrow>\\<^sub>A \\<up>(p = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. btree Leaf p \\<Longrightarrow>\\<^sub>A \\<up> (p = None)", "by auto2"], ["", "lemma btree_Node [forward_ent]:\n  \"btree (rbt.Node lt c k v rt) p \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Alp rp. the p \\<mapsto>\\<^sub>r Node lp c k v rp * btree lt lp * btree rt rp * \\<up>(p \\<noteq> None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. btree (rbt.Node lt c k v rt) p \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Alp rp.\n       the p \\<mapsto>\\<^sub>r rbt_node.Node lp c k v rp * btree lt lp *\n       btree rt rp *\n       \\<up> (p \\<noteq> None)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. btree (rbt.Node lt c k v rt) p \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Alp rp.\n       the p \\<mapsto>\\<^sub>r rbt_node.Node lp c k v rp * btree lt lp *\n       btree rt rp *\n       \\<up> (p \\<noteq> None)", "@case \"p = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. btree (rbt.Node lt c k v rt) p \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Alp rp.\n       the p \\<mapsto>\\<^sub>r rbt_node.Node lp c k v rp * btree lt lp *\n       btree rt rp *\n       \\<up> (p \\<noteq> None)", "@qed"], ["", "lemma btree_none: \"emp \\<Longrightarrow>\\<^sub>A btree Leaf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emp \\<Longrightarrow>\\<^sub>A btree Leaf None", "by auto2"], ["", "lemma btree_constr_ent:\n  \"p \\<mapsto>\\<^sub>r Node lp c k v rp * btree lt lp * btree rt rp \\<Longrightarrow>\\<^sub>A btree (rbt.Node lt c k v rt) (Some p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<mapsto>\\<^sub>r rbt_node.Node lp c k v rp * btree lt lp *\n    btree rt rp \\<Longrightarrow>\\<^sub>A\n    btree (rbt.Node lt c k v rt) (Some p)", "by auto2"], ["", "setup \\<open>fold add_entail_matcher [@{thm btree_none}, @{thm btree_constr_ent}]\\<close>"], ["", "setup \\<open>fold del_prfstep_thm @{thms btree.simps}\\<close>"], ["", "type_synonym ('a, 'b) btree = \"('a, 'b) rbt_node ref option\""], ["", "subsection \\<open>Operations\\<close>"], ["", "subsubsection \\<open>Basic operations\\<close>"], ["", "definition tree_empty :: \"('a, 'b) btree Heap\" where\n  \"tree_empty = return None\""], ["", "lemma tree_empty_rule [hoare_triple]:\n  \"<emp> tree_empty <btree Leaf>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> tree_empty <btree Leaf>", "by auto2"], ["", "definition tree_is_empty :: \"('a, 'b) btree \\<Rightarrow> bool Heap\" where\n  \"tree_is_empty b = return (b = None)\""], ["", "lemma tree_is_empty_rule:\n  \"<btree t b> tree_is_empty b <\\<lambda>r. btree t b * \\<up>(r \\<longleftrightarrow> t = Leaf)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b> tree_is_empty b\n    <\\<lambda>r. btree t b * \\<up> (r = (t = Leaf))>", "by auto2"], ["", "definition btree_constr ::\n  \"('a::heap, 'b::heap) btree \\<Rightarrow> color \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_constr lp c k v rp = do { p \\<leftarrow> ref (Node lp c k v rp); return (Some p) }\""], ["", "lemma btree_constr_rule [hoare_triple]:\n  \"<btree lt lp * btree rt rp>\n   btree_constr lp c k v rp\n   <btree (rbt.Node lt c k v rt)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree lt lp * btree rt rp> btree_constr lp c k v rp\n    <btree (rbt.Node lt c k v rt)>", "by auto2"], ["", "definition set_color :: \"color \\<Rightarrow> ('a::heap, 'b::heap) btree \\<Rightarrow> unit Heap\" where\n  \"set_color c p = (case p of\n    None \\<Rightarrow> raise STR ''set_color''\n  | Some pp \\<Rightarrow> do {\n      t \\<leftarrow> !pp;\n      pp := Node (lsub t) c (key t) (val t) (rsub t)\n    })\""], ["", "lemma set_color_rule [hoare_triple]:\n  \"<btree (rbt.Node a c x v b) p>\n   set_color c' p\n   <\\<lambda>_. btree (rbt.Node a c' x v b) p>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node a c x v b) p> set_color c' p\n    <\\<lambda>_. btree (rbt.Node a c' x v b) p>", "by auto2"], ["", "definition get_color :: \"('a::heap, 'b::heap) btree \\<Rightarrow> color Heap\" where\n  \"get_color p = (case p of\n     None \\<Rightarrow> return B\n   | Some pp \\<Rightarrow> do {\n       t \\<leftarrow> !pp;\n       return (cl t)\n     })\""], ["", "lemma get_color_rule [hoare_triple]:\n  \"<btree t p> get_color p <\\<lambda>r. btree t p * \\<up>(r = rbt.cl t)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> get_color p <\\<lambda>r. btree t p * \\<up> (r = rbt.cl t)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> get_color p <\\<lambda>r. btree t p * \\<up> (r = rbt.cl t)>", "@case \"t = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> get_color p <\\<lambda>r. btree t p * \\<up> (r = rbt.cl t)>", "@qed"], ["", "definition paint :: \"color \\<Rightarrow> ('a::heap, 'b::heap) btree \\<Rightarrow> unit Heap\" where\n  \"paint c p = (case p of\n    None \\<Rightarrow> return ()\n  | Some pp \\<Rightarrow> do {\n     t \\<leftarrow> !pp;\n     pp := Node (lsub t) c (key t) (val t) (rsub t)\n   })\""], ["", "lemma paint_rule [hoare_triple]:\n  \"<btree t p>\n   paint c p\n   <\\<lambda>_. btree (RBTree.paint c t) p>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> RBTree_Impl.paint c p\n    <\\<lambda>_. btree (RBTree.paint c t) p>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> RBTree_Impl.paint c p\n    <\\<lambda>_. btree (RBTree.paint c t) p>", "@case \"t = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> RBTree_Impl.paint c p\n    <\\<lambda>_. btree (RBTree.paint c t) p>", "@qed"], ["", "subsubsection \\<open>Rotation\\<close>"], ["", "definition btree_rotate_l :: \"('a::heap, 'b::heap) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_rotate_l p = (case p of\n    None \\<Rightarrow> raise STR ''Empty btree''\n  | Some pp \\<Rightarrow> do {\n     t \\<leftarrow> !pp;\n     (case rsub t of\n        None \\<Rightarrow> raise STR ''Empty rsub''\n      | Some rp \\<Rightarrow> do {\n          rt \\<leftarrow> !rp;\n          pp := Node (lsub t) (cl t) (key t) (val t) (lsub rt);\n          rp := Node p (cl rt) (key rt) (val rt) (rsub rt);\n          return (rsub t) })})\""], ["", "lemma btree_rotate_l_rule [hoare_triple]:\n  \"<btree (rbt.Node a c1 x v (rbt.Node b c2 y w c)) p>\n   btree_rotate_l p\n   <btree (rbt.Node (rbt.Node a c1 x v b) c2 y w c)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node a c1 x v (rbt.Node b c2 y w c)) p> btree_rotate_l p\n    <btree (rbt.Node (rbt.Node a c1 x v b) c2 y w c)>", "by auto2"], ["", "definition btree_rotate_r :: \"('a::heap, 'b::heap) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_rotate_r p = (case p of\n    None \\<Rightarrow> raise STR ''Empty btree''\n  | Some pp \\<Rightarrow> do {\n     t \\<leftarrow> !pp;\n     (case lsub t of\n        None \\<Rightarrow> raise STR ''Empty lsub''\n      | Some lp \\<Rightarrow> do {\n          lt \\<leftarrow> !lp;\n          pp := Node (rsub lt) (cl t) (key t) (val t) (rsub t);\n          lp := Node (lsub lt) (cl lt) (key lt) (val lt) p;\n          return (lsub t) })})\""], ["", "lemma btree_rotate_r_rule [hoare_triple]:\n  \"<btree (rbt.Node (rbt.Node a c1 x v b) c2 y w c) p>\n   btree_rotate_r p\n   <btree (rbt.Node a c1 x v (rbt.Node b c2 y w c))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node (rbt.Node a c1 x v b) c2 y w c) p> btree_rotate_r p\n    <btree (rbt.Node a c1 x v (rbt.Node b c2 y w c))>", "by auto2"], ["", "subsubsection \\<open>Balance\\<close>"], ["", "definition btree_balanceR :: \"('a::heap, 'b::heap) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_balanceR p = (case p of None \\<Rightarrow> return None | Some pp \\<Rightarrow> do {\n     t \\<leftarrow> !pp;\n     cl_r \\<leftarrow> get_color (rsub t);\n     if cl_r = R then do {\n       rt \\<leftarrow> !(the (rsub t));\n       cl_lr \\<leftarrow> get_color (lsub rt);\n       cl_rr \\<leftarrow> get_color (rsub rt);\n       if cl_lr = R then do {\n         rp' \\<leftarrow> btree_rotate_r (rsub t);\n         pp := Node (lsub t) (cl t) (key t) (val t) rp';\n         p' \\<leftarrow> btree_rotate_l p;\n         t' \\<leftarrow> !(the p');\n         set_color B (rsub t');\n         return p'\n       } else if cl_rr = R then do {\n         p' \\<leftarrow> btree_rotate_l p;\n         t' \\<leftarrow> !(the p');\n         set_color B (rsub t');\n         return p'\n        } else return p }\n     else return p})\""], ["", "lemma balanceR_to_fun [hoare_triple]:\n  \"<btree (rbt.Node l B k v r) p>\n   btree_balanceR p\n   <btree (balanceR l k v r)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l B k v r) p> btree_balanceR p\n    <btree (balanceR l k v r)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l B k v r) p> btree_balanceR p\n    <btree (balanceR l k v r)>", "@unfold \"balanceR l k v r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l B k v r) p> btree_balanceR p\n    <btree (balanceR l k v r)>", "@qed"], ["", "definition btree_balance :: \"('a::heap, 'b::heap) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_balance p = (case p of None \\<Rightarrow> return None | Some pp \\<Rightarrow> do {\n     t \\<leftarrow> !pp;\n     cl_l \\<leftarrow> get_color (lsub t);\n     if cl_l = R then do {\n       lt \\<leftarrow> !(the (lsub t));\n       cl_rl \\<leftarrow> get_color (rsub lt);\n       cl_ll \\<leftarrow> get_color (lsub lt);\n       if cl_ll = R then do {\n         p' \\<leftarrow> btree_rotate_r p;\n         t' \\<leftarrow> !(the p');\n         set_color B (lsub t');\n         return p' }\n       else if cl_rl = R then do {\n         lp' \\<leftarrow> btree_rotate_l (lsub t);\n         pp := Node lp' (cl t) (key t) (val t) (rsub t);\n         p' \\<leftarrow> btree_rotate_r p;\n         t' \\<leftarrow> !(the p');\n         set_color B (lsub t');\n         return p'\n       } else btree_balanceR p }\n     else do {\n       p' \\<leftarrow> btree_balanceR p;\n       return p'}})\""], ["", "lemma balance_to_fun [hoare_triple]:\n  \"<btree (rbt.Node l B k v r) p>\n   btree_balance p\n   <btree (balance l k v r)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l B k v r) p> btree_balance p <btree (balance l k v r)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l B k v r) p> btree_balance p <btree (balance l k v r)>", "@unfold \"balance l k v r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l B k v r) p> btree_balance p <btree (balance l k v r)>", "@qed"], ["", "subsubsection \\<open>Insertion\\<close>"], ["", "partial_function (heap) rbt_ins ::\n  \"'a::{heap,ord} \\<Rightarrow> 'b::heap \\<Rightarrow> ('a, 'b) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"rbt_ins k v p = (case p of\n     None \\<Rightarrow> btree_constr None R k v None\n   | Some pp \\<Rightarrow> do {\n      t \\<leftarrow> !pp;\n      (if cl t = B then\n        (if k = key t then do {\n           pp := Node (lsub t) (cl t) k v (rsub t);\n           return (Some pp) }\n         else if k < key t then do {\n           q \\<leftarrow> rbt_ins k v (lsub t);\n           pp := Node q (cl t) (key t) (val t) (rsub t);\n           btree_balance p }\n         else do {\n           q \\<leftarrow> rbt_ins k v (rsub t);\n           pp := Node (lsub t) (cl t) (key t) (val t) q;\n           btree_balance p })\n       else\n        (if k = key t then do {\n           pp := Node (lsub t) (cl t) k v (rsub t);\n           return (Some pp) }\n         else if k < key t then do {\n           q \\<leftarrow> rbt_ins k v (lsub t);\n           pp := Node q (cl t) (key t) (val t) (rsub t);\n           return (Some pp) }\n         else do {\n           q \\<leftarrow> rbt_ins k v (rsub t);\n           pp := Node (lsub t) (cl t) (key t) (val t) q;\n           return (Some pp) }))})\""], ["", "lemma rbt_ins_to_fun [hoare_triple]:\n  \"<btree t p>\n   rbt_ins k v p\n   <btree (ins k v t)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> rbt_ins k v p <btree (ins k v t)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> rbt_ins k v p <btree (ins k v t)>", "@induct t arbitrary p"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> rbt_ins k v p <btree (ins k v t)>", "@qed"], ["", "definition rbt_insert ::\n  \"'a::{heap,ord} \\<Rightarrow> 'b::heap \\<Rightarrow> ('a, 'b) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"rbt_insert k v p = do {\n    p' \\<leftarrow> rbt_ins k v p;\n    paint B p';\n    return p' }\""], ["", "lemma rbt_insert_to_fun [hoare_triple]:\n  \"<btree t p>\n   rbt_insert k v p\n   <btree (RBTree.rbt_insert k v t)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> RBTree_Impl.rbt_insert k v p\n    <btree (RBTree.rbt_insert k v t)>", "by auto2"], ["", "subsubsection \\<open>Search\\<close>"], ["", "partial_function (heap) rbt_search ::\n  \"'a::{heap,linorder} \\<Rightarrow> ('a, 'b::heap) btree \\<Rightarrow> 'b option Heap\" where\n  \"rbt_search x b = (case b of\n     None \\<Rightarrow> return None\n   | Some p \\<Rightarrow> do {\n      t \\<leftarrow> !p;\n      (if x = key t then return (Some (val t))\n       else if x < key t then rbt_search x (lsub t)\n       else rbt_search x (rsub t)) })\""], ["", "lemma btree_search_correct [hoare_triple]:\n  \"<btree t b * \\<up>(rbt_sorted t)>\n   rbt_search x b\n   <\\<lambda>r. btree t b * \\<up>(r = RBTree.rbt_search t x)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b * \\<up> (rbt_sorted t)> RBTree_Impl.rbt_search x b\n    <\\<lambda>r. btree t b * \\<up> (r = RBTree.rbt_search t x)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b * \\<up> (rbt_sorted t)> RBTree_Impl.rbt_search x b\n    <\\<lambda>r. btree t b * \\<up> (r = RBTree.rbt_search t x)>", "@induct t arbitrary b"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b * \\<up> (rbt_sorted t)> RBTree_Impl.rbt_search x b\n    <\\<lambda>r. btree t b * \\<up> (r = RBTree.rbt_search t x)>", "@qed"], ["", "subsubsection \\<open>Delete\\<close>"], ["", "definition btree_balL :: \"('a::heap, 'b::heap) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_balL p = (case p of\n     None \\<Rightarrow> return None\n   | Some pp \\<Rightarrow> do {\n      t \\<leftarrow> !pp;\n      cl_l \\<leftarrow> get_color (lsub t);\n      if cl_l = R then do {\n        set_color B (lsub t);  \\<comment> \\<open>Case 1\\<close>\n        return p}\n      else case rsub t of\n        None \\<Rightarrow> return p  \\<comment> \\<open>Case 2\\<close>\n      | Some rp \\<Rightarrow> do {  \n         rt \\<leftarrow> !rp;\n         if cl rt = B then do {\n           set_color R (rsub t);  \\<comment> \\<open>Case 3\\<close>\n           set_color B p;\n           btree_balance p}\n         else case lsub rt of\n           None \\<Rightarrow> return p  \\<comment> \\<open>Case 4\\<close>\n         | Some lrp \\<Rightarrow> do {\n            lrt \\<leftarrow> !lrp;\n            if cl lrt = B then do {\n              set_color R (lsub rt);  \\<comment> \\<open>Case 5\\<close>\n              paint R (rsub rt);\n              set_color B (rsub t); \n              rp' \\<leftarrow> btree_rotate_r (rsub t);\n              pp := Node (lsub t) (cl t) (key t) (val t) rp';\n              p' \\<leftarrow> btree_rotate_l p;\n              t' \\<leftarrow> !(the p');\n              set_color B (lsub t');\n              rp'' \\<leftarrow> btree_balance (rsub t');\n              the p' := Node (lsub t') (cl t') (key t') (val t') rp'';\n              return p'}\n            else return p}}})\""], ["", "lemma balL_to_fun [hoare_triple]:\n  \"<btree (rbt.Node l R k v r) p>\n   btree_balL p\n   <btree (balL l k v r)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l R k v r) p> btree_balL p <btree (balL l k v r)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l R k v r) p> btree_balL p <btree (balL l k v r)>", "@unfold \"balL l k v r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l R k v r) p> btree_balL p <btree (balL l k v r)>", "@qed"], ["", "definition btree_balR :: \"('a::heap, 'b::heap) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_balR p = (case p of\n     None \\<Rightarrow> return None\n   | Some pp \\<Rightarrow> do {\n      t \\<leftarrow> !pp;\n      cl_r \\<leftarrow> get_color (rsub t);\n      if cl_r = R then do {\n        set_color B (rsub t);  \\<comment> \\<open>Case 1\\<close>\n        return p}\n      else case lsub t of\n        None \\<Rightarrow> return p  \\<comment> \\<open>Case 2\\<close>\n      | Some lp \\<Rightarrow> do {  \n         lt \\<leftarrow> !lp;\n         if cl lt = B then do {\n           set_color R (lsub t);  \\<comment> \\<open>Case 3\\<close>\n           set_color B p;\n           btree_balance p}\n         else case rsub lt of\n           None \\<Rightarrow> return p  \\<comment> \\<open>Case 4\\<close>\n         | Some rlp \\<Rightarrow> do {\n            rlt \\<leftarrow> !rlp;\n            if cl rlt = B then do {\n              set_color R (rsub lt);  \\<comment> \\<open>Case 5\\<close>\n              paint R (lsub lt);\n              set_color B (lsub t); \n              lp' \\<leftarrow> btree_rotate_l (lsub t);\n              pp := Node lp' (cl t) (key t) (val t) (rsub t);\n              p' \\<leftarrow> btree_rotate_r p;\n              t' \\<leftarrow> !(the p');\n              set_color B (rsub t');\n              lp'' \\<leftarrow> btree_balance (lsub t');\n              the p' := Node lp'' (cl t') (key t') (val t') (rsub t');\n              return p'}\n            else return p}}})\""], ["", "lemma balR_to_fun [hoare_triple]:\n  \"<btree (rbt.Node l R k v r) p>\n   btree_balR p\n   <btree (balR l k v r)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l R k v r) p> btree_balR p <btree (balR l k v r)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l R k v r) p> btree_balR p <btree (balR l k v r)>", "@unfold \"balR l k v r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (rbt.Node l R k v r) p> btree_balR p <btree (balR l k v r)>", "@qed"], ["", "partial_function (heap) btree_combine ::\n  \"('a::heap, 'b::heap) btree \\<Rightarrow> ('a, 'b) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_combine lp rp =\n   (if lp = None then return rp\n    else if rp = None then return lp\n    else do {\n      lt \\<leftarrow> !(the lp);\n      rt \\<leftarrow> !(the rp);\n      if cl lt = R then\n        if cl rt = R then do {\n          tmp \\<leftarrow> btree_combine (rsub lt) (lsub rt);\n          cl_tm \\<leftarrow> get_color tmp;\n          if cl_tm = R then do {\n            tmt \\<leftarrow> !(the tmp);\n            the lp := Node (lsub lt) R (key lt) (val lt) (lsub tmt);\n            the rp := Node (rsub tmt) R (key rt) (val rt) (rsub rt);\n            the tmp := Node lp R (key tmt) (val tmt) rp;\n            return tmp}\n          else do {\n            the rp := Node tmp R (key rt) (val rt) (rsub rt);\n            the lp := Node (lsub lt) R (key lt) (val lt) rp;\n            return lp}}\n        else do {\n          tmp \\<leftarrow> btree_combine (rsub lt) rp;\n          the lp := Node (lsub lt) R (key lt) (val lt) tmp;\n          return lp}\n      else if cl rt = B then do {\n        tmp \\<leftarrow> btree_combine (rsub lt) (lsub rt);\n        cl_tm \\<leftarrow> get_color tmp;\n        if cl_tm = R then do {\n          tmt \\<leftarrow> !(the tmp);\n          the lp := Node (lsub lt) B (key lt) (val lt) (lsub tmt);\n          the rp := Node (rsub tmt) B (key rt) (val rt) (rsub rt);\n          the tmp := Node lp R (key tmt) (val tmt) rp;\n          return tmp}\n        else do {\n          the rp := Node tmp B (key rt) (val rt) (rsub rt);\n          the lp := Node (lsub lt) R (key lt) (val lt) rp;\n          btree_balL lp}}\n      else do {\n        tmp \\<leftarrow> btree_combine lp (lsub rt);\n        the rp := Node tmp R (key rt) (val rt) (rsub rt);\n        return rp}})\""], ["", "lemma combine_to_fun [hoare_triple]:\n  \"<btree lt lp * btree rt rp>\n   btree_combine lp rp\n   <btree (combine lt rt)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree lt lp * btree rt rp> btree_combine lp rp <btree (combine lt rt)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree lt lp * btree rt rp> btree_combine lp rp <btree (combine lt rt)>", "@fun_induct \"combine lt rt\" arbitrary lp rp @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree lt lp * btree rt rp> btree_combine lp rp <btree (combine lt rt)>", "@subgoal \"(lt = rbt.Node l1 c1 k1 v1 r1, rt = rbt.Node l2 c2 k2 v2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree lt lp * btree rt rp> btree_combine lp rp <btree (combine lt rt)>", "@unfold \"combine (rbt.Node l1 c1 k1 v1 r1) (rbt.Node l2 c2 k2 v2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree lt lp * btree rt rp> btree_combine lp rp <btree (combine lt rt)>", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree lt lp * btree rt rp> btree_combine lp rp <btree (combine lt rt)>", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree lt lp * btree rt rp> btree_combine lp rp <btree (combine lt rt)>", "@qed"], ["", "partial_function (heap) rbt_del ::\n  \"'a::{heap,linorder} \\<Rightarrow> ('a, 'b::heap) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"rbt_del x p = (case p of\n     None \\<Rightarrow> return None\n   | Some pp \\<Rightarrow> do {\n      t \\<leftarrow> !pp;\n      (if x = key t then btree_combine (lsub t) (rsub t)\n       else if x < key t then case lsub t of\n         None \\<Rightarrow> do {\n           set_color R p;\n           return p}\n       | Some lp \\<Rightarrow> do {\n           lt \\<leftarrow> !lp;\n           if cl lt = B then do {\n             q \\<leftarrow> rbt_del x (lsub t);\n             pp := Node q R (key t) (val t) (rsub t);\n             btree_balL p }\n           else do {\n             q \\<leftarrow> rbt_del x (lsub t);\n             pp := Node q R (key t) (val t) (rsub t);\n             return p }}\n       else case rsub t of\n         None \\<Rightarrow> do {\n           set_color R p;\n           return p}\n       | Some rp \\<Rightarrow> do {\n           rt \\<leftarrow> !rp;\n           if cl rt = B then do {\n             q \\<leftarrow> rbt_del x (rsub t);\n             pp := Node (lsub t) R (key t) (val t) q;\n             btree_balR p }\n           else do {\n             q \\<leftarrow> rbt_del x (rsub t);\n             pp := Node (lsub t) R (key t) (val t) q;\n             return p }})})\""], ["", "lemma rbt_del_to_fun [hoare_triple]:\n  \"<btree t p>\n   rbt_del x p\n   <btree (del x t)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> rbt_del x p <btree (del x t)>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> rbt_del x p <btree (del x t)>\\<^sub>t", "@induct t arbitrary p @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> rbt_del x p <btree (del x t)>\\<^sub>t", "@subgoal \"t = rbt.Node l c k v r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> rbt_del x p <btree (del x t)>\\<^sub>t", "@unfold \"del x (rbt.Node l c k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> rbt_del x p <btree (del x t)>\\<^sub>t", "@endgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> rbt_del x p <btree (del x t)>\\<^sub>t", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> rbt_del x p <btree (del x t)>\\<^sub>t", "@qed"], ["", "definition rbt_delete ::\n  \"'a::{heap,linorder} \\<Rightarrow> ('a, 'b::heap) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"rbt_delete k p = do {\n    p' \\<leftarrow> rbt_del k p;\n    paint B p';\n    return p'}\""], ["", "lemma rbt_delete_to_fun [hoare_triple]:\n  \"<btree t p>\n   rbt_delete k p\n   <btree (RBTree.delete k t)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t p> rbt_delete k p <btree (delete k t)>\\<^sub>t", "by auto2"], ["", "subsection \\<open>Outer interface\\<close>"], ["", "text \\<open>Express Hoare triples for operations on red-black tree in terms of\n  the mapping represented by the tree.\\<close>"], ["", "definition rbt_map_assn :: \"('a, 'b) map \\<Rightarrow> ('a::{heap,linorder}, 'b::heap) rbt_node ref option \\<Rightarrow> assn\" where\n  \"rbt_map_assn M p = (\\<exists>\\<^sub>At. btree t p * \\<up>(is_rbt t) * \\<up>(rbt_sorted t) * \\<up>(M = rbt_map t))\""], ["", "setup \\<open>add_rewrite_ent_rule @{thm rbt_map_assn_def}\\<close>"], ["", "theorem rbt_empty_rule [hoare_triple]:\n  \"<emp> tree_empty <rbt_map_assn empty_map>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> tree_empty <rbt_map_assn empty_map>", "by auto2"], ["", "theorem rbt_insert_rule [hoare_triple]:\n  \"<rbt_map_assn M b> rbt_insert k v b <rbt_map_assn (M {k \\<rightarrow> v})>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <rbt_map_assn M b> RBTree_Impl.rbt_insert k v b\n    <rbt_map_assn ( M { k \\<rightarrow> v })>", "by auto2"], ["", "theorem rbt_search [hoare_triple]:\n  \"<rbt_map_assn M b> rbt_search x b <\\<lambda>r. rbt_map_assn M b * \\<up>(r = M\\<langle>x\\<rangle>)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <rbt_map_assn M b> RBTree_Impl.rbt_search x b\n    <\\<lambda>r. rbt_map_assn M b * \\<up> (r = M\\<langle>x\\<rangle>)>", "by auto2"], ["", "theorem rbt_delete_rule [hoare_triple]:\n  \"<rbt_map_assn M b> rbt_delete k b <rbt_map_assn (delete_map k M)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <rbt_map_assn M\n      b> rbt_delete k b <rbt_map_assn (delete_map k M)>\\<^sub>t", "by auto2"], ["", "end"]]}