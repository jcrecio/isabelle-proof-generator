{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Imperative/Dijkstra_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma dstate_pq_init_to_fun [hoare_triple]:\n  \"k \\<le> size G \\<Longrightarrow>\n   <emp>\n   dstate_pq_init G k\n   <idx_pqueue_map (map_constr (\\<lambda>i. i > 0) (\\<lambda>i. weight G 0 i) k) (size G)>\\<^sub>t\"", "lemma dstate_init_to_fun [hoare_triple]:\n  \"<emp>\n   dstate_init G\n   <dstate (dijkstra_start_state G)>\\<^sub>t\"", "lemma dstate_update_est_ind [hoare_triple]:\n  \"k \\<le> length e \\<Longrightarrow> m < length e \\<Longrightarrow>\n   <a \\<mapsto>\\<^sub>a e * idx_pqueue_map M (length e) pq>\n   dstate_update_est G m k pq a\n   <\\<lambda>r. dstate (State (list_update_set_impl (\\<lambda>i. i \\<in> keys_of M)\n                      (\\<lambda>i. min (e ! m + weight G m i) (e ! i)) e k) M) (Dijkstra_State r pq)>\\<^sub>t\"", "lemma dstate_update_est_to_fun [hoare_triple]:\n  \"<dstate (State e M) (Dijkstra_State a pq) * \\<up>(m < length e)>\n   dstate_update_est G m (length e) pq a\n   <\\<lambda>r. dstate (State (list_update_set (\\<lambda>i. i \\<in> keys_of M)\n               (\\<lambda>i. min (e ! m + weight G m i) (e ! i)) e) M) (Dijkstra_State r pq)>\\<^sub>t\"", "lemma dstate_update_heap_ind [hoare_triple]:\n  \"k \\<le> length e \\<Longrightarrow> m < length e \\<Longrightarrow>\n   <a \\<mapsto>\\<^sub>a e * idx_pqueue_map M (length e) pq>\n   dstate_update_heap G m k a pq\n   <\\<lambda>r. dstate (State e (map_update_all_impl (\\<lambda>i. e ! i) M k)) (Dijkstra_State a r)>\\<^sub>t\"", "lemma dstate_update_heap_to_fun [hoare_triple]:\n  \"m < length e \\<Longrightarrow>\n   \\<forall>i\\<in>keys_of M. i < length e \\<Longrightarrow>\n   <dstate (State e M) (Dijkstra_State a pq)>\n   dstate_update_heap G m (length e) a pq\n   <\\<lambda>r. dstate (State e (map_update_all (\\<lambda>i. e ! i) M)) (Dijkstra_State a r)>\\<^sub>t\"", "lemma dijkstra_extract_min_rule [hoare_triple]:\n  \"M \\<noteq> empty_map \\<Longrightarrow>\n   <dstate (State e M) (Dijkstra_State a pq)>\n   dijkstra_extract_min (Dijkstra_State a pq)\n   <\\<lambda>(m, r). dstate (State e (delete_map m M)) r * \\<up>(m < length e) * \\<up>(is_heap_min m M)>\\<^sub>t\"", "lemma dijkstra_step_impl_to_fun [hoare_triple]:\n  \"heap S \\<noteq> empty_map \\<Longrightarrow> inv G S \\<Longrightarrow>\n   <dstate S (Dijkstra_State a pq)>\n   dijkstra_step_impl G (Dijkstra_State a pq)\n   <\\<lambda>r. \\<exists>\\<^sub>AS'. dstate S' r * \\<up>(is_dijkstra_step G S S')>\\<^sub>t\"", "lemma dijkstra_step_impl_correct [hoare_triple]:\n  \"heap S \\<noteq> empty_map \\<Longrightarrow> inv G S \\<Longrightarrow>\n   <dstate S p>\n   dijkstra_step_impl G p\n   <\\<lambda>r. \\<exists>\\<^sub>AS'. dstate S' r * \\<up>(inv G S') * \\<up>(card (unknown_set S') = card (unknown_set S) - 1)>\\<^sub>t\"", "lemma dijkstra_loop_correct [hoare_triple]:\n  \"<dstate S p * \\<up>(inv G S) * \\<up>(n \\<le> card (unknown_set S))>\n   dijkstra_loop G n p\n   <\\<lambda>r. \\<exists>\\<^sub>AS'. dstate S' r * \\<up>(inv G S') * \\<up>(card (unknown_set S') = card (unknown_set S) - n)>\\<^sub>t\"", "theorem dijkstra_correct [hoare_triple]:\n  \"size G > 0 \\<Longrightarrow>\n   <emp>\n   dijkstra G\n   <\\<lambda>r. \\<exists>\\<^sub>AS. dstate S r * \\<up>(inv G S) * \\<up>(unknown_set S = {}) *\n        \\<up>(\\<forall>i\\<in>verts G. has_dist G 0 i \\<and> est S ! i = dist G 0 i)>\\<^sub>t\""], "translations": [["", "lemma dstate_pq_init_to_fun [hoare_triple]:\n  \"k \\<le> size G \\<Longrightarrow>\n   <emp>\n   dstate_pq_init G k\n   <idx_pqueue_map (map_constr (\\<lambda>i. i > 0) (\\<lambda>i. weight G 0 i) k) (size G)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> Dijkstra.size G \\<Longrightarrow>\n    <emp> dstate_pq_init G\n           k <idx_pqueue_map (map_constr ((<) 0) (weight G 0) k)\n               (Dijkstra.size G)>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> Dijkstra.size G \\<Longrightarrow>\n    <emp> dstate_pq_init G\n           k <idx_pqueue_map (map_constr ((<) 0) (weight G 0) k)\n               (Dijkstra.size G)>\\<^sub>t", "@induct k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> Dijkstra.size G \\<Longrightarrow>\n    <emp> dstate_pq_init G\n           k <idx_pqueue_map (map_constr ((<) 0) (weight G 0) k)\n               (Dijkstra.size G)>\\<^sub>t", "@qed"], ["", "definition dstate_init :: \"graph \\<Rightarrow> dijkstra_state Heap\" where\n  \"dstate_init G = do {\n     a \\<leftarrow> Array.of_list (list (\\<lambda>i. if i = 0 then 0 else weight G 0 i) (size G));\n     pq \\<leftarrow> dstate_pq_init G (size G);\n     return (Dijkstra_State a pq)\n   }\""], ["", "lemma dstate_init_to_fun [hoare_triple]:\n  \"<emp>\n   dstate_init G\n   <dstate (dijkstra_start_state G)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> dstate_init G <dstate (dijkstra_start_state G)>\\<^sub>t", "by auto2"], ["", "fun dstate_update_est :: \"graph \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat indexed_pqueue \\<Rightarrow> nat array \\<Rightarrow> nat array Heap\" where\n  \"dstate_update_est G m 0 pq a = (return a)\"\n| \"dstate_update_est G m (Suc k) pq a = do {\n     b \\<leftarrow> has_key_idx_pqueue k pq;\n     if b then do {\n       ek \\<leftarrow> Array.nth a k;\n       em \\<leftarrow> Array.nth a m;\n       a' \\<leftarrow> dstate_update_est G m k pq a;\n       a'' \\<leftarrow> Array.upd k (min (em + weight G m k) ek) a';\n       return a'' }\n     else dstate_update_est G m k pq a }\""], ["", "lemma dstate_update_est_ind [hoare_triple]:\n  \"k \\<le> length e \\<Longrightarrow> m < length e \\<Longrightarrow>\n   <a \\<mapsto>\\<^sub>a e * idx_pqueue_map M (length e) pq>\n   dstate_update_est G m k pq a\n   <\\<lambda>r. dstate (State (list_update_set_impl (\\<lambda>i. i \\<in> keys_of M)\n                      (\\<lambda>i. min (e ! m + weight G m i) (e ! i)) e k) M) (Dijkstra_State r pq)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> length e; m < length e\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a e *\n                       idx_pqueue_map M (length e)\n                        pq> dstate_update_est G m k pq\n                             a <\\<lambda>r.\n                                   dstate\n                                    (State\n(list_update_set_impl (\\<lambda>i. i \\<in> keys_of M)\n  (\\<lambda>i. min (e ! m + weight G m i) (e ! i)) e k)\nM)\n                                    (Dijkstra_State r pq)>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> length e; m < length e\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a e *\n                       idx_pqueue_map M (length e)\n                        pq> dstate_update_est G m k pq\n                             a <\\<lambda>r.\n                                   dstate\n                                    (State\n(list_update_set_impl (\\<lambda>i. i \\<in> keys_of M)\n  (\\<lambda>i. min (e ! m + weight G m i) (e ! i)) e k)\nM)\n                                    (Dijkstra_State r pq)>\\<^sub>t", "@induct k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> length e; m < length e\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a e *\n                       idx_pqueue_map M (length e)\n                        pq> dstate_update_est G m k pq\n                             a <\\<lambda>r.\n                                   dstate\n                                    (State\n(list_update_set_impl (\\<lambda>i. i \\<in> keys_of M)\n  (\\<lambda>i. min (e ! m + weight G m i) (e ! i)) e k)\nM)\n                                    (Dijkstra_State r pq)>\\<^sub>t", "@qed"], ["", "lemma dstate_update_est_to_fun [hoare_triple]:\n  \"<dstate (State e M) (Dijkstra_State a pq) * \\<up>(m < length e)>\n   dstate_update_est G m (length e) pq a\n   <\\<lambda>r. dstate (State (list_update_set (\\<lambda>i. i \\<in> keys_of M)\n               (\\<lambda>i. min (e ! m + weight G m i) (e ! i)) e) M) (Dijkstra_State r pq)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <dstate (State e M) (Dijkstra_State a pq) *\n     \\<up>\n      (m < length\n            e)> dstate_update_est G m (length e) pq\n                 a <\\<lambda>r.\n                       dstate\n                        (State\n                          (list_update_set (\\<lambda>i. i \\<in> keys_of M)\n                            (\\<lambda>i. min (e ! m + weight G m i) (e ! i))\n                            e)\n                          M)\n                        (Dijkstra_State r pq)>\\<^sub>t", "by auto2"], ["", "fun dstate_update_heap ::\n  \"graph \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat array \\<Rightarrow> nat indexed_pqueue \\<Rightarrow> nat indexed_pqueue Heap\" where\n  \"dstate_update_heap G m 0 a pq = return pq\"\n| \"dstate_update_heap G m (Suc k) a pq = do {\n     b \\<leftarrow> has_key_idx_pqueue k pq;\n     if b then do {\n       ek \\<leftarrow> Array.nth a k;\n       pq' \\<leftarrow> dstate_update_heap G m k a pq;\n       update_idx_pqueue k ek pq' }\n     else dstate_update_heap G m k a pq }\""], ["", "lemma dstate_update_heap_ind [hoare_triple]:\n  \"k \\<le> length e \\<Longrightarrow> m < length e \\<Longrightarrow>\n   <a \\<mapsto>\\<^sub>a e * idx_pqueue_map M (length e) pq>\n   dstate_update_heap G m k a pq\n   <\\<lambda>r. dstate (State e (map_update_all_impl (\\<lambda>i. e ! i) M k)) (Dijkstra_State a r)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> length e; m < length e\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a e *\n                       idx_pqueue_map M (length e)\n                        pq> dstate_update_heap G m k a\n                             pq <\\<lambda>r.\n                                    dstate\n                                     (State e\n (map_update_all_impl ((!) e) M k))\n                                     (Dijkstra_State a r)>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> length e; m < length e\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a e *\n                       idx_pqueue_map M (length e)\n                        pq> dstate_update_heap G m k a\n                             pq <\\<lambda>r.\n                                    dstate\n                                     (State e\n (map_update_all_impl ((!) e) M k))\n                                     (Dijkstra_State a r)>\\<^sub>t", "@induct k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> length e; m < length e\\<rbrakk>\n    \\<Longrightarrow> <a \\<mapsto>\\<^sub>a e *\n                       idx_pqueue_map M (length e)\n                        pq> dstate_update_heap G m k a\n                             pq <\\<lambda>r.\n                                    dstate\n                                     (State e\n (map_update_all_impl ((!) e) M k))\n                                     (Dijkstra_State a r)>\\<^sub>t", "@qed"], ["", "lemma dstate_update_heap_to_fun [hoare_triple]:\n  \"m < length e \\<Longrightarrow>\n   \\<forall>i\\<in>keys_of M. i < length e \\<Longrightarrow>\n   <dstate (State e M) (Dijkstra_State a pq)>\n   dstate_update_heap G m (length e) a pq\n   <\\<lambda>r. dstate (State e (map_update_all (\\<lambda>i. e ! i) M)) (Dijkstra_State a r)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < length e; \\<forall>i\\<in>keys_of M. i < length e\\<rbrakk>\n    \\<Longrightarrow> <dstate (State e M)\n                        (Dijkstra_State a\n                          pq)> dstate_update_heap G m (length e) a\n                                pq <\\<lambda>r.\n dstate (State e (map_update_all ((!) e) M)) (Dijkstra_State a r)>\\<^sub>t", "by auto2"], ["", "fun dijkstra_extract_min :: \"dijkstra_state \\<Rightarrow> (nat \\<times> dijkstra_state) Heap\" where\n  \"dijkstra_extract_min (Dijkstra_State a pq) = do {\n     (x, pq') \\<leftarrow> delete_min_idx_pqueue pq;\n     return (fst x, Dijkstra_State a pq') }\""], ["", "lemma dijkstra_extract_min_rule [hoare_triple]:\n  \"M \\<noteq> empty_map \\<Longrightarrow>\n   <dstate (State e M) (Dijkstra_State a pq)>\n   dijkstra_extract_min (Dijkstra_State a pq)\n   <\\<lambda>(m, r). dstate (State e (delete_map m M)) r * \\<up>(m < length e) * \\<up>(is_heap_min m M)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<noteq> empty_map \\<Longrightarrow>\n    <dstate (State e M)\n      (Dijkstra_State a\n        pq)> dijkstra_extract_min\n              (Dijkstra_State a\n                pq) <\\<lambda>r.\n                        case r of\n                        (m, r) \\<Rightarrow>\n                          dstate (State e (delete_map m M)) r *\n                          \\<up> (m < length e) *\n                          \\<up> (is_heap_min m M)>\\<^sub>t", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm dstate.simps}\\<close>"], ["", "subsection \\<open>Main operations\\<close>"], ["", "fun dijkstra_step_impl :: \"graph \\<Rightarrow> dijkstra_state \\<Rightarrow> dijkstra_state Heap\" where\n  \"dijkstra_step_impl G (Dijkstra_State a pq) = do {\n     (x, S') \\<leftarrow> dijkstra_extract_min (Dijkstra_State a pq);\n     a' \\<leftarrow> dstate_update_est G x (size G) (heap_pq S') (est_a S');\n     pq'' \\<leftarrow> dstate_update_heap G x (size G) a' (heap_pq S');\n     return (Dijkstra_State a' pq'') }\""], ["", "lemma dijkstra_step_impl_to_fun [hoare_triple]:\n  \"heap S \\<noteq> empty_map \\<Longrightarrow> inv G S \\<Longrightarrow>\n   <dstate S (Dijkstra_State a pq)>\n   dijkstra_step_impl G (Dijkstra_State a pq)\n   <\\<lambda>r. \\<exists>\\<^sub>AS'. dstate S' r * \\<up>(is_dijkstra_step G S S')>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap S \\<noteq> empty_map; Dijkstra.inv G S\\<rbrakk>\n    \\<Longrightarrow> <dstate S\n                        (Dijkstra_State a\n                          pq)> dijkstra_step_impl G\n                                (Dijkstra_State a\n                                  pq) <\\<lambda>r.\n    \\<exists>\\<^sub>AS'.\n       dstate S' r * \\<up> (is_dijkstra_step G S S')>\\<^sub>t", "by auto2"], ["", "lemma dijkstra_step_impl_correct [hoare_triple]:\n  \"heap S \\<noteq> empty_map \\<Longrightarrow> inv G S \\<Longrightarrow>\n   <dstate S p>\n   dijkstra_step_impl G p\n   <\\<lambda>r. \\<exists>\\<^sub>AS'. dstate S' r * \\<up>(inv G S') * \\<up>(card (unknown_set S') = card (unknown_set S) - 1)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap S \\<noteq> empty_map; Dijkstra.inv G S\\<rbrakk>\n    \\<Longrightarrow> <dstate S\n                        p> dijkstra_step_impl G\n                            p <\\<lambda>r.\n                                  \\<exists>\\<^sub>AS'.\n                                     dstate S' r *\n                                     \\<up> (Dijkstra.inv G S') *\n                                     \\<up>\n(card (unknown_set S') = card (unknown_set S) - 1)>\\<^sub>t", "by auto2"], ["", "fun dijkstra_loop :: \"graph \\<Rightarrow> nat \\<Rightarrow> dijkstra_state \\<Rightarrow> dijkstra_state Heap\" where\n  \"dijkstra_loop G 0 p = (return p)\"\n| \"dijkstra_loop G (Suc k) p = do {\n    p' \\<leftarrow> dijkstra_step_impl G p;\n    p'' \\<leftarrow> dijkstra_loop G k p';\n    return p'' }\""], ["", "lemma dijkstra_loop_correct [hoare_triple]:\n  \"<dstate S p * \\<up>(inv G S) * \\<up>(n \\<le> card (unknown_set S))>\n   dijkstra_loop G n p\n   <\\<lambda>r. \\<exists>\\<^sub>AS'. dstate S' r * \\<up>(inv G S') * \\<up>(card (unknown_set S') = card (unknown_set S) - n)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <dstate S p * \\<up> (Dijkstra.inv G S) *\n     \\<up>\n      (n \\<le> card\n                (unknown_set\n                  S))> dijkstra_loop G n\n                        p <\\<lambda>r.\n                              \\<exists>\\<^sub>AS'.\n                                 dstate S' r * \\<up> (Dijkstra.inv G S') *\n                                 \\<up>\n                                  (card (unknown_set S') =\n                                   card (unknown_set S) - n)>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <dstate S p * \\<up> (Dijkstra.inv G S) *\n     \\<up>\n      (n \\<le> card\n                (unknown_set\n                  S))> dijkstra_loop G n\n                        p <\\<lambda>r.\n                              \\<exists>\\<^sub>AS'.\n                                 dstate S' r * \\<up> (Dijkstra.inv G S') *\n                                 \\<up>\n                                  (card (unknown_set S') =\n                                   card (unknown_set S) - n)>\\<^sub>t", "@induct n arbitrary S p"], ["proof (prove)\ngoal (1 subgoal):\n 1. <dstate S p * \\<up> (Dijkstra.inv G S) *\n     \\<up>\n      (n \\<le> card\n                (unknown_set\n                  S))> dijkstra_loop G n\n                        p <\\<lambda>r.\n                              \\<exists>\\<^sub>AS'.\n                                 dstate S' r * \\<up> (Dijkstra.inv G S') *\n                                 \\<up>\n                                  (card (unknown_set S') =\n                                   card (unknown_set S) - n)>\\<^sub>t", "@qed"], ["", "definition dijkstra :: \"graph \\<Rightarrow> dijkstra_state Heap\" where\n  \"dijkstra G = do {\n    p \\<leftarrow> dstate_init G;\n    dijkstra_loop G (size G - 1) p }\""], ["", "text \\<open>Correctness of Dijkstra's algorithm.\\<close>"], ["", "theorem dijkstra_correct [hoare_triple]:\n  \"size G > 0 \\<Longrightarrow>\n   <emp>\n   dijkstra G\n   <\\<lambda>r. \\<exists>\\<^sub>AS. dstate S r * \\<up>(inv G S) * \\<up>(unknown_set S = {}) *\n        \\<up>(\\<forall>i\\<in>verts G. has_dist G 0 i \\<and> est S ! i = dist G 0 i)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Dijkstra.size G \\<Longrightarrow>\n    <emp> dijkstra\n           G <\\<lambda>r.\n                 \\<exists>\\<^sub>AS.\n                    dstate S r * \\<up> (Dijkstra.inv G S) *\n                    \\<up> (unknown_set S = {}) *\n                    \\<up>\n                     (\\<forall>i\\<in>verts G.\n                         has_dist G 0 i \\<and>\n                         est S ! i = dist G 0 i)>\\<^sub>t", "by auto2"], ["", "end"]]}