{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Imperative/BST_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma btree_Tip [forward_ent]: \"btree Tip p \\<Longrightarrow>\\<^sub>A \\<up>(p = None)\"", "lemma btree_Node [forward_ent]:\n  \"btree (tree.Node lt k v rt) p \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Alp rp. the p \\<mapsto>\\<^sub>r Node lp k v rp * btree lt lp * btree rt rp * \\<up>(p \\<noteq> None))\"", "lemma btree_none: \"emp \\<Longrightarrow>\\<^sub>A btree tree.Tip None\"", "lemma btree_constr_ent:\n  \"p \\<mapsto>\\<^sub>r Node lp k v rp * btree lt lp * btree rt rp \\<Longrightarrow>\\<^sub>A btree (tree.Node lt k v rt) (Some p)\"", "lemma tree_empty_rule [hoare_triple]:\n  \"<emp> tree_empty <btree Tip>\"", "lemma tree_is_empty_rule:\n  \"<btree t b> tree_is_empty b <\\<lambda>r. btree t b * \\<up>(r \\<longleftrightarrow> t = Tip)>\"", "lemma btree_constr_rule [hoare_triple]:\n  \"<btree lt lp * btree rt rp> btree_constr lp k v rp <btree (tree.Node lt k v rt)>\"", "lemma btree_insert_to_fun [hoare_triple]:\n  \"<btree t b>\n   btree_insert k v b\n   <btree (tree_insert k v t)>\"", "lemma btree_del_min_to_fun [hoare_triple]:\n  \"<btree t b * \\<up>(b \\<noteq> None)>\n   btree_del_min b\n   <\\<lambda>(r,p). btree (snd (del_min t)) p * \\<up>(r = fst (del_min t))>\\<^sub>t\"", "lemma btree_del_elt_to_fun [hoare_triple]:\n  \"<btree (tree.Node lt x v rt) b>\n   btree_del_elt b\n   <btree (delete_elt_tree (tree.Node lt x v rt))>\\<^sub>t\"", "lemma btree_delete_to_fun [hoare_triple]:\n  \"<btree t b>\n   btree_delete x b\n   <btree (tree_delete x t)>\\<^sub>t\"", "lemma btree_search_correct [hoare_triple]:\n  \"<btree t b * \\<up>(tree_sorted t)>\n   btree_search x b\n   <\\<lambda>r. btree t b * \\<up>(r = tree_search t x)>\"", "theorem btree_empty_rule_map [hoare_triple]:\n  \"<emp> tree_empty <btree_map empty_map>\"", "theorem btree_insert_rule_map [hoare_triple]:\n  \"<btree_map M b> btree_insert k v b <btree_map (M {k \\<rightarrow> v})>\"", "theorem btree_delete_rule_map [hoare_triple]:\n  \"<btree_map M b> btree_delete x b <btree_map (delete_map x M)>\\<^sub>t\"", "theorem btree_search_rule_map [hoare_triple]:\n  \"<btree_map M b> btree_search x b <\\<lambda>r. btree_map M b * \\<up>(r = M\\<langle>x\\<rangle>)>\""], "translations": [["", "lemma btree_Tip [forward_ent]: \"btree Tip p \\<Longrightarrow>\\<^sub>A \\<up>(p = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. btree Tip p \\<Longrightarrow>\\<^sub>A \\<up> (p = None)", "by auto2"], ["", "lemma btree_Node [forward_ent]:\n  \"btree (tree.Node lt k v rt) p \\<Longrightarrow>\\<^sub>A (\\<exists>\\<^sub>Alp rp. the p \\<mapsto>\\<^sub>r Node lp k v rp * btree lt lp * btree rt rp * \\<up>(p \\<noteq> None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. btree (tree.Node lt k v rt) p \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Alp rp.\n       the p \\<mapsto>\\<^sub>r node.Node lp k v rp * btree lt lp *\n       btree rt rp *\n       \\<up> (p \\<noteq> None)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. btree (tree.Node lt k v rt) p \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Alp rp.\n       the p \\<mapsto>\\<^sub>r node.Node lp k v rp * btree lt lp *\n       btree rt rp *\n       \\<up> (p \\<noteq> None)", "@case \"p = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. btree (tree.Node lt k v rt) p \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Alp rp.\n       the p \\<mapsto>\\<^sub>r node.Node lp k v rp * btree lt lp *\n       btree rt rp *\n       \\<up> (p \\<noteq> None)", "@qed"], ["", "lemma btree_none: \"emp \\<Longrightarrow>\\<^sub>A btree tree.Tip None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emp \\<Longrightarrow>\\<^sub>A btree Tip None", "by auto2"], ["", "lemma btree_constr_ent:\n  \"p \\<mapsto>\\<^sub>r Node lp k v rp * btree lt lp * btree rt rp \\<Longrightarrow>\\<^sub>A btree (tree.Node lt k v rt) (Some p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<mapsto>\\<^sub>r node.Node lp k v rp * btree lt lp *\n    btree rt rp \\<Longrightarrow>\\<^sub>A\n    btree (tree.Node lt k v rt) (Some p)", "by auto2"], ["", "setup \\<open>fold add_entail_matcher [@{thm btree_none}, @{thm btree_constr_ent}]\\<close>"], ["", "setup \\<open>fold del_prfstep_thm @{thms btree.simps}\\<close>"], ["", "type_synonym ('a, 'b) btree = \"('a, 'b) node ref option\""], ["", "subsection \\<open>Operations\\<close>"], ["", "subsubsection \\<open>Basic operations\\<close>"], ["", "definition tree_empty :: \"('a, 'b) btree Heap\" where\n  \"tree_empty = return None\""], ["", "lemma tree_empty_rule [hoare_triple]:\n  \"<emp> tree_empty <btree Tip>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> tree_empty <btree Tip>", "by auto2"], ["", "definition tree_is_empty :: \"('a, 'b) btree \\<Rightarrow> bool Heap\" where\n  \"tree_is_empty b = return (b = None)\""], ["", "lemma tree_is_empty_rule:\n  \"<btree t b> tree_is_empty b <\\<lambda>r. btree t b * \\<up>(r \\<longleftrightarrow> t = Tip)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b> tree_is_empty b\n    <\\<lambda>r. btree t b * \\<up> (r = (t = Tip))>", "by auto2"], ["", "definition btree_constr ::\n  \"('a::heap, 'b::heap) btree \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_constr lp k v rp = do { p \\<leftarrow> ref (Node lp k v rp); return (Some p) }\""], ["", "lemma btree_constr_rule [hoare_triple]:\n  \"<btree lt lp * btree rt rp> btree_constr lp k v rp <btree (tree.Node lt k v rt)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree lt lp * btree rt rp> btree_constr lp k v rp\n    <btree (tree.Node lt k v rt)>", "by auto2"], ["", "subsubsection \\<open>Insertion\\<close>"], ["", "partial_function (heap) btree_insert ::\n  \"'a::{heap,linorder} \\<Rightarrow> 'b::heap \\<Rightarrow> ('a, 'b) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_insert k v b = (case b of\n     None \\<Rightarrow> btree_constr None k v None\n   | Some p \\<Rightarrow> do {\n      t \\<leftarrow> !p;\n      (if k = key t then do {\n         p := Node (lsub t) k v (rsub t);\n         return (Some p) }\n       else if k < key t then do {\n         q \\<leftarrow> btree_insert k v (lsub t);\n         p := Node q (key t) (val t) (rsub t);\n         return (Some p) }\n       else do {\n         q \\<leftarrow> btree_insert k v (rsub t);\n         p := Node (lsub t) (key t) (val t) q;\n         return (Some p)}) })\""], ["", "lemma btree_insert_to_fun [hoare_triple]:\n  \"<btree t b>\n   btree_insert k v b\n   <btree (tree_insert k v t)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b> btree_insert k v b <btree (tree_insert k v t)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b> btree_insert k v b <btree (tree_insert k v t)>", "@induct t arbitrary b"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b> btree_insert k v b <btree (tree_insert k v t)>", "@qed"], ["", "subsubsection \\<open>Deletion\\<close>"], ["", "partial_function (heap) btree_del_min :: \"('a::heap, 'b::heap) btree \\<Rightarrow> (('a \\<times> 'b) \\<times> ('a, 'b) btree) Heap\" where\n  \"btree_del_min b = (case b of\n     None \\<Rightarrow> raise STR ''del_min: empty tree''\n   | Some p \\<Rightarrow> do {\n      t \\<leftarrow> !p;\n      (if lsub t = None then\n         return ((key t, val t), rsub t)\n       else do {\n         r \\<leftarrow> btree_del_min (lsub t);\n         p := Node (snd r) (key t) (val t) (rsub t);\n         return (fst r, Some p) }) })\""], ["", "lemma btree_del_min_to_fun [hoare_triple]:\n  \"<btree t b * \\<up>(b \\<noteq> None)>\n   btree_del_min b\n   <\\<lambda>(r,p). btree (snd (del_min t)) p * \\<up>(r = fst (del_min t))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b *\n     \\<up>\n      (b \\<noteq>\n       None)> btree_del_min\n               b <\\<lambda>r.\n                     case r of\n                     (r, p) \\<Rightarrow>\n                       btree (snd (del_min t)) p *\n                       \\<up> (r = fst (del_min t))>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b *\n     \\<up>\n      (b \\<noteq>\n       None)> btree_del_min\n               b <\\<lambda>r.\n                     case r of\n                     (r, p) \\<Rightarrow>\n                       btree (snd (del_min t)) p *\n                       \\<up> (r = fst (del_min t))>\\<^sub>t", "@induct t arbitrary b"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b *\n     \\<up>\n      (b \\<noteq>\n       None)> btree_del_min\n               b <\\<lambda>r.\n                     case r of\n                     (r, p) \\<Rightarrow>\n                       btree (snd (del_min t)) p *\n                       \\<up> (r = fst (del_min t))>\\<^sub>t", "@qed"], ["", "definition btree_del_elt :: \"('a::heap, 'b::heap) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_del_elt b = (case b of\n     None \\<Rightarrow> raise STR ''del_elt: empty tree''\n   | Some p \\<Rightarrow> do {\n       t \\<leftarrow> !p;\n       (if lsub t = None then return (rsub t)\n        else if rsub t = None then return (lsub t)\n        else do {\n          r \\<leftarrow> btree_del_min (rsub t);\n          p := Node (lsub t) (fst (fst r)) (snd (fst r)) (snd r);\n          return (Some p) }) })\""], ["", "lemma btree_del_elt_to_fun [hoare_triple]:\n  \"<btree (tree.Node lt x v rt) b>\n   btree_del_elt b\n   <btree (delete_elt_tree (tree.Node lt x v rt))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree (tree.Node lt x v rt)\n      b> btree_del_elt\n          b <btree (delete_elt_tree (tree.Node lt x v rt))>\\<^sub>t", "by auto2"], ["", "partial_function (heap) btree_delete ::\n  \"'a::{heap,linorder} \\<Rightarrow> ('a, 'b::heap) btree \\<Rightarrow> ('a, 'b) btree Heap\" where\n  \"btree_delete x b = (case b of\n     None \\<Rightarrow> return None\n   | Some p \\<Rightarrow> do {\n      t \\<leftarrow> !p;\n      (if x = key t then do {\n         r \\<leftarrow> btree_del_elt b;\n         return r }\n       else if x < key t then do {\n         q \\<leftarrow> btree_delete x (lsub t);\n         p := Node q (key t) (val t) (rsub t);\n         return (Some p) }\n       else do {\n         q \\<leftarrow> btree_delete x (rsub t);\n         p := Node (lsub t) (key t) (val t) q;\n         return (Some p)}) })\""], ["", "lemma btree_delete_to_fun [hoare_triple]:\n  \"<btree t b>\n   btree_delete x b\n   <btree (tree_delete x t)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b> btree_delete x b <btree (tree_delete x t)>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b> btree_delete x b <btree (tree_delete x t)>\\<^sub>t", "@induct t arbitrary b"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b> btree_delete x b <btree (tree_delete x t)>\\<^sub>t", "@qed"], ["", "subsubsection \\<open>Search\\<close>"], ["", "partial_function (heap) btree_search ::\n  \"'a::{heap,linorder} \\<Rightarrow> ('a, 'b::heap) btree \\<Rightarrow> 'b option Heap\" where\n  \"btree_search x b = (case b of\n     None \\<Rightarrow> return None\n   | Some p \\<Rightarrow> do {\n      t \\<leftarrow> !p;\n      (if x = key t then return (Some (val t))\n       else if x < key t then btree_search x (lsub t)\n       else btree_search x (rsub t)) })\""], ["", "lemma btree_search_correct [hoare_triple]:\n  \"<btree t b * \\<up>(tree_sorted t)>\n   btree_search x b\n   <\\<lambda>r. btree t b * \\<up>(r = tree_search t x)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b * \\<up> (tree_sorted t)> btree_search x b\n    <\\<lambda>r. btree t b * \\<up> (r = tree_search t x)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b * \\<up> (tree_sorted t)> btree_search x b\n    <\\<lambda>r. btree t b * \\<up> (r = tree_search t x)>", "@induct t arbitrary b"], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree t b * \\<up> (tree_sorted t)> btree_search x b\n    <\\<lambda>r. btree t b * \\<up> (r = tree_search t x)>", "@qed"], ["", "subsection \\<open>Outer interface\\<close>"], ["", "text \\<open>Express Hoare triples for operations on binary search tree in terms of\n  the mapping represented by the tree.\\<close>"], ["", "definition btree_map :: \"('a, 'b) map \\<Rightarrow> ('a::{heap,linorder}, 'b::heap) node ref option \\<Rightarrow> assn\" where\n  \"btree_map M p = (\\<exists>\\<^sub>At. btree t p * \\<up>(tree_sorted t) * \\<up>(M = tree_map t))\""], ["", "setup \\<open>add_rewrite_ent_rule @{thm btree_map_def}\\<close>"], ["", "theorem btree_empty_rule_map [hoare_triple]:\n  \"<emp> tree_empty <btree_map empty_map>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> tree_empty <btree_map empty_map>", "by auto2"], ["", "theorem btree_insert_rule_map [hoare_triple]:\n  \"<btree_map M b> btree_insert k v b <btree_map (M {k \\<rightarrow> v})>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_map M b> btree_insert k v b\n    <btree_map ( M { k \\<rightarrow> v })>", "by auto2"], ["", "theorem btree_delete_rule_map [hoare_triple]:\n  \"<btree_map M b> btree_delete x b <btree_map (delete_map x M)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_map M b> btree_delete x b <btree_map (delete_map x M)>\\<^sub>t", "by auto2"], ["", "theorem btree_search_rule_map [hoare_triple]:\n  \"<btree_map M b> btree_search x b <\\<lambda>r. btree_map M b * \\<up>(r = M\\<langle>x\\<rangle>)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <btree_map M b> btree_search x b\n    <\\<lambda>r. btree_map M b * \\<up> (r = M\\<langle>x\\<rangle>)>", "by auto2"], ["", "end"]]}