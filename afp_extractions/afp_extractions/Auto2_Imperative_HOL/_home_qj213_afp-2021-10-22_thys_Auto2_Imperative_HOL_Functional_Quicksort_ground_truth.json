{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Functional/Quicksort.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma outer_remains_length [forward]:\n  \"outer_remains xs xs' l r \\<Longrightarrow> length xs = length xs'\"", "lemma outer_remains_eq [rewrite_back]:\n  \"outer_remains xs xs' l r \\<Longrightarrow> i < l \\<Longrightarrow> xs ! i = xs' ! i\"\n  \"outer_remains xs xs' l r \\<Longrightarrow> r < i \\<Longrightarrow> xs ! i = xs' ! i\"", "lemma outer_remains_sublist [backward2]:\n  \"outer_remains xs xs' l r \\<Longrightarrow> i < l \\<Longrightarrow> take i xs = take i xs'\"\n  \"outer_remains xs xs' l r \\<Longrightarrow> r < i \\<Longrightarrow> drop i xs = drop i xs'\"\n  \"i \\<le> j \\<Longrightarrow> j \\<le> length xs \\<Longrightarrow> outer_remains xs xs' l r \\<Longrightarrow> j \\<le> l \\<Longrightarrow> sublist i j xs = sublist i j xs'\"\n  \"i \\<le> j \\<Longrightarrow> j \\<le> length xs \\<Longrightarrow> outer_remains xs xs' l r \\<Longrightarrow> i > r \\<Longrightarrow> sublist i j xs = sublist i j xs'\"", "lemma part1_basic:\n  \"r < length xs \\<Longrightarrow> l \\<le> r \\<Longrightarrow> (rs, xs') = part1 xs l r a \\<Longrightarrow>\n   outer_remains xs xs' l r \\<and> mset xs' = mset xs \\<and> l \\<le> rs \\<and> rs \\<le> r\"", "lemma part1_partitions1 [backward]:\n  \"r < length xs \\<Longrightarrow> (rs, xs') = part1 xs l r a \\<Longrightarrow> l \\<le> i \\<Longrightarrow> i < rs \\<Longrightarrow> xs' ! i \\<le> a\"", "lemma part1_partitions2 [backward]:\n  \"r < length xs \\<Longrightarrow> (rs, xs') = part1 xs l r a \\<Longrightarrow> rs < i \\<Longrightarrow> i \\<le> r \\<Longrightarrow> xs' ! i \\<ge> a\"", "lemma partition_basic:\n  \"l < r \\<Longrightarrow> r < length xs \\<Longrightarrow> (rs, xs') = partition xs l r \\<Longrightarrow>\n   outer_remains xs xs' l r \\<and> mset xs' = mset xs \\<and> l \\<le> rs \\<and> rs \\<le> r\"", "lemma partition_partitions1 [forward]:\n  \"l < r \\<Longrightarrow> r < length xs \\<Longrightarrow> (rs, xs') = partition xs l r \\<Longrightarrow>\n   x \\<in> set (sublist l rs xs') \\<Longrightarrow> x \\<le> xs' ! rs\"", "lemma partition_partitions2 [forward]:\n  \"l < r \\<Longrightarrow> r < length xs \\<Longrightarrow> (rs, xs'') = partition xs l r \\<Longrightarrow>\n   x \\<in> set (sublist (rs + 1) (r + 1) xs'') \\<Longrightarrow> x \\<ge> xs'' ! rs\"", "lemma quicksort_term1:\n  \"\\<not>r \\<le> l \\<Longrightarrow> \\<not> length xs \\<le> r \\<Longrightarrow> x = partition xs l r \\<Longrightarrow> (p, xs1) = x \\<Longrightarrow> p - Suc l < r - l\"", "lemma quicksort_term2:\n  \"\\<not>r \\<le> l \\<Longrightarrow> \\<not> length xs \\<le> r \\<Longrightarrow> x = partition xs l r \\<Longrightarrow> (p, xs2) = x \\<Longrightarrow> r - Suc p < r - l\"", "lemma quicksort_basic [rewrite_arg]:\n  \"mset (quicksort xs l r) = mset xs \\<and> outer_remains xs (quicksort xs l r) l r\"", "lemma quicksort_trivial1 [rewrite]:\n  \"l \\<ge> r \\<Longrightarrow> quicksort xs l r = xs\"", "lemma quicksort_trivial2 [rewrite]:\n  \"r \\<ge> length xs \\<Longrightarrow> quicksort xs l r = xs\"", "lemma quicksort_permutes [resolve]:\n  \"xs' = quicksort xs l r \\<Longrightarrow> set (sublist l (r + 1) xs') = set (sublist l (r + 1) xs)\"", "lemma quicksort_sorts [forward_arg]:\n  \"r < length xs \\<Longrightarrow> sorted (sublist l (r + 1) (quicksort xs l r))\"", "theorem quicksort_sorts_all [rewrite]:\n  \"xs \\<noteq> [] \\<Longrightarrow> quicksort xs 0 (length xs - 1) = sort xs\""], "translations": [["", "lemma outer_remains_length [forward]:\n  \"outer_remains xs xs' l r \\<Longrightarrow> length xs = length xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_remains xs xs' l r \\<Longrightarrow> length xs = length xs'", "by auto2"], ["", "lemma outer_remains_eq [rewrite_back]:\n  \"outer_remains xs xs' l r \\<Longrightarrow> i < l \\<Longrightarrow> xs ! i = xs' ! i\"\n  \"outer_remains xs xs' l r \\<Longrightarrow> r < i \\<Longrightarrow> xs ! i = xs' ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>outer_remains xs xs' l r; i < l\\<rbrakk>\n     \\<Longrightarrow> xs ! i = xs' ! i) &&&\n    (\\<lbrakk>outer_remains xs xs' l r; r < i\\<rbrakk>\n     \\<Longrightarrow> xs ! i = xs' ! i)", "by auto2+"], ["", "lemma outer_remains_sublist [backward2]:\n  \"outer_remains xs xs' l r \\<Longrightarrow> i < l \\<Longrightarrow> take i xs = take i xs'\"\n  \"outer_remains xs xs' l r \\<Longrightarrow> r < i \\<Longrightarrow> drop i xs = drop i xs'\"\n  \"i \\<le> j \\<Longrightarrow> j \\<le> length xs \\<Longrightarrow> outer_remains xs xs' l r \\<Longrightarrow> j \\<le> l \\<Longrightarrow> sublist i j xs = sublist i j xs'\"\n  \"i \\<le> j \\<Longrightarrow> j \\<le> length xs \\<Longrightarrow> outer_remains xs xs' l r \\<Longrightarrow> i > r \\<Longrightarrow> sublist i j xs = sublist i j xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>outer_remains xs xs' l r; i < l\\<rbrakk>\n      \\<Longrightarrow> take i xs = take i xs') &&&\n     (\\<lbrakk>outer_remains xs xs' l r; r < i\\<rbrakk>\n      \\<Longrightarrow> drop i xs = drop i xs')) &&&\n    (\\<lbrakk>i \\<le> j; j \\<le> length xs; outer_remains xs xs' l r;\n      j \\<le> l\\<rbrakk>\n     \\<Longrightarrow> sublist i j xs = sublist i j xs') &&&\n    (\\<lbrakk>i \\<le> j; j \\<le> length xs; outer_remains xs xs' l r;\n      r < i\\<rbrakk>\n     \\<Longrightarrow> sublist i j xs = sublist i j xs')", "by auto2+"], ["", "setup \\<open>del_prfstep_thm_eqforward @{thm outer_remains_def}\\<close>"], ["", "subsection \\<open>part1 function\\<close>"], ["", "function part1 :: \"('a::linorder) list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> (nat \\<times> 'a list)\" where\n  \"part1 xs l r a = (\n     if r \\<le> l then (r, xs)\n     else if xs ! l \\<le> a then part1 xs (l + 1) r a\n     else part1 (list_swap xs l r) l (r - 1) a)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>xs l r a.\n           x = (xs, l, r, a) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>xs l r a xsa la ra aa.\n       (xs, l, r, a) = (xsa, la, ra, aa) \\<Longrightarrow>\n       (if r \\<le> l then (r, xs)\n        else if xs ! l \\<le> a then part1_sumC (xs, l + 1, r, a)\n             else part1_sumC (list_swap xs l r, l, r - 1, a)) =\n       (if ra \\<le> la then (ra, xsa)\n        else if xsa ! la \\<le> aa then part1_sumC (xsa, la + 1, ra, aa)\n             else part1_sumC (list_swap xsa la ra, la, ra - 1, aa))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All part1_dom", "by (relation \"measure (\\<lambda>(_,l,r,_). r - l)\") auto"], ["", "setup \\<open>register_wellform_data (\"part1 xs l r a\", [\"r < length xs\"])\\<close>"], ["", "setup \\<open>add_prfstep_check_req (\"part1 xs l r a\", \"r < length xs\")\\<close>"], ["", "lemma part1_basic:\n  \"r < length xs \\<Longrightarrow> l \\<le> r \\<Longrightarrow> (rs, xs') = part1 xs l r a \\<Longrightarrow>\n   outer_remains xs xs' l r \\<and> mset xs' = mset xs \\<and> l \\<le> rs \\<and> rs \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; l \\<le> r; (rs, xs') = part1 xs l r a\\<rbrakk>\n    \\<Longrightarrow> outer_remains xs xs' l r \\<and>\n                      mset xs' = mset xs \\<and> l \\<le> rs \\<and> rs \\<le> r", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; l \\<le> r; (rs, xs') = part1 xs l r a\\<rbrakk>\n    \\<Longrightarrow> outer_remains xs xs' l r \\<and>\n                      mset xs' = mset xs \\<and> l \\<le> rs \\<and> rs \\<le> r", "@fun_induct \"part1 xs l r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; l \\<le> r; (rs, xs') = part1 xs l r a\\<rbrakk>\n    \\<Longrightarrow> outer_remains xs xs' l r \\<and>\n                      mset xs' = mset xs \\<and> l \\<le> rs \\<and> rs \\<le> r", "@unfold \"part1 xs l r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; l \\<le> r; (rs, xs') = part1 xs l r a\\<rbrakk>\n    \\<Longrightarrow> outer_remains xs xs' l r \\<and>\n                      mset xs' = mset xs \\<and> l \\<le> rs \\<and> rs \\<le> r", "@qed"], ["", "setup \\<open>add_forward_prfstep_cond @{thm part1_basic} [with_term \"part1 ?xs ?l ?r ?a\"]\\<close>"], ["", "lemma part1_partitions1 [backward]:\n  \"r < length xs \\<Longrightarrow> (rs, xs') = part1 xs l r a \\<Longrightarrow> l \\<le> i \\<Longrightarrow> i < rs \\<Longrightarrow> xs' ! i \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; (rs, xs') = part1 xs l r a; l \\<le> i;\n     i < rs\\<rbrakk>\n    \\<Longrightarrow> xs' ! i \\<le> a", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; (rs, xs') = part1 xs l r a; l \\<le> i;\n     i < rs\\<rbrakk>\n    \\<Longrightarrow> xs' ! i \\<le> a", "@fun_induct \"part1 xs l r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; (rs, xs') = part1 xs l r a; l \\<le> i;\n     i < rs\\<rbrakk>\n    \\<Longrightarrow> xs' ! i \\<le> a", "@unfold \"part1 xs l r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; (rs, xs') = part1 xs l r a; l \\<le> i;\n     i < rs\\<rbrakk>\n    \\<Longrightarrow> xs' ! i \\<le> a", "@qed"], ["", "lemma part1_partitions2 [backward]:\n  \"r < length xs \\<Longrightarrow> (rs, xs') = part1 xs l r a \\<Longrightarrow> rs < i \\<Longrightarrow> i \\<le> r \\<Longrightarrow> xs' ! i \\<ge> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; (rs, xs') = part1 xs l r a; rs < i;\n     i \\<le> r\\<rbrakk>\n    \\<Longrightarrow> a \\<le> xs' ! i", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; (rs, xs') = part1 xs l r a; rs < i;\n     i \\<le> r\\<rbrakk>\n    \\<Longrightarrow> a \\<le> xs' ! i", "@fun_induct \"part1 xs l r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; (rs, xs') = part1 xs l r a; rs < i;\n     i \\<le> r\\<rbrakk>\n    \\<Longrightarrow> a \\<le> xs' ! i", "@unfold \"part1 xs l r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length xs; (rs, xs') = part1 xs l r a; rs < i;\n     i \\<le> r\\<rbrakk>\n    \\<Longrightarrow> a \\<le> xs' ! i", "@qed"], ["", "subsection \\<open>Paritition function\\<close>"], ["", "definition partition :: \"('a::linorder list) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> 'a list)\" where [rewrite]:\n  \"partition xs l r = (\n    let p = xs ! r;\n      (m, xs') = part1 xs l (r - 1) p;\n      m' = if xs' ! m \\<le> p then m + 1 else m\n    in\n      (m', list_swap xs' m' r))\""], ["", "setup \\<open>register_wellform_data (\"partition xs l r\", [\"l < r\", \"r < length xs\"])\\<close>"], ["", "lemma partition_basic:\n  \"l < r \\<Longrightarrow> r < length xs \\<Longrightarrow> (rs, xs') = partition xs l r \\<Longrightarrow>\n   outer_remains xs xs' l r \\<and> mset xs' = mset xs \\<and> l \\<le> rs \\<and> rs \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs;\n     (rs, xs') = Quicksort.partition xs l r\\<rbrakk>\n    \\<Longrightarrow> outer_remains xs xs' l r \\<and>\n                      mset xs' = mset xs \\<and> l \\<le> rs \\<and> rs \\<le> r", "by auto2"], ["", "setup \\<open>add_forward_prfstep_cond @{thm partition_basic} [with_term \"partition ?xs ?l ?r\"]\\<close>"], ["", "lemma partition_partitions1 [forward]:\n  \"l < r \\<Longrightarrow> r < length xs \\<Longrightarrow> (rs, xs') = partition xs l r \\<Longrightarrow>\n   x \\<in> set (sublist l rs xs') \\<Longrightarrow> x \\<le> xs' ! rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs; (rs, xs') = Quicksort.partition xs l r;\n     x \\<in> set (sublist l rs xs')\\<rbrakk>\n    \\<Longrightarrow> x \\<le> xs' ! rs", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs; (rs, xs') = Quicksort.partition xs l r;\n     x \\<in> set (sublist l rs xs')\\<rbrakk>\n    \\<Longrightarrow> x \\<le> xs' ! rs", "@obtain i where \"i \\<ge> l\" \"i < rs\" \"x = xs' ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs; (rs, xs') = Quicksort.partition xs l r;\n     x \\<in> set (sublist l rs xs')\\<rbrakk>\n    \\<Longrightarrow> x \\<le> xs' ! rs", "@qed"], ["", "lemma partition_partitions2 [forward]:\n  \"l < r \\<Longrightarrow> r < length xs \\<Longrightarrow> (rs, xs'') = partition xs l r \\<Longrightarrow>\n   x \\<in> set (sublist (rs + 1) (r + 1) xs'') \\<Longrightarrow> x \\<ge> xs'' ! rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs; (rs, xs'') = Quicksort.partition xs l r;\n     x \\<in> set (sublist (rs + 1) (r + 1) xs'')\\<rbrakk>\n    \\<Longrightarrow> xs'' ! rs \\<le> x", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs; (rs, xs'') = Quicksort.partition xs l r;\n     x \\<in> set (sublist (rs + 1) (r + 1) xs'')\\<rbrakk>\n    \\<Longrightarrow> xs'' ! rs \\<le> x", "@obtain i where \"i \\<ge> rs + 1\" \"i < r + 1\" \"x = xs'' ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs; (rs, xs'') = Quicksort.partition xs l r;\n     x \\<in> set (sublist (rs + 1) (r + 1) xs'')\\<rbrakk>\n    \\<Longrightarrow> xs'' ! rs \\<le> x", "@let \"p = xs ! r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs; (rs, xs'') = Quicksort.partition xs l r;\n     x \\<in> set (sublist (rs + 1) (r + 1) xs'')\\<rbrakk>\n    \\<Longrightarrow> xs'' ! rs \\<le> x", "@let \"m = fst (part1 xs l (r - 1) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs; (rs, xs'') = Quicksort.partition xs l r;\n     x \\<in> set (sublist (rs + 1) (r + 1) xs'')\\<rbrakk>\n    \\<Longrightarrow> xs'' ! rs \\<le> x", "@let \"xs' = snd (part1 xs l (r - 1) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs; (rs, xs'') = Quicksort.partition xs l r;\n     x \\<in> set (sublist (rs + 1) (r + 1) xs'')\\<rbrakk>\n    \\<Longrightarrow> xs'' ! rs \\<le> x", "@case \"xs' ! m \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < r; r < length xs; (rs, xs'') = Quicksort.partition xs l r;\n     x \\<in> set (sublist (rs + 1) (r + 1) xs'')\\<rbrakk>\n    \\<Longrightarrow> xs'' ! rs \\<le> x", "@qed"], ["", "setup \\<open>del_prfstep_thm @{thm partition_def}\\<close>"], ["", "lemma quicksort_term1:\n  \"\\<not>r \\<le> l \\<Longrightarrow> \\<not> length xs \\<le> r \\<Longrightarrow> x = partition xs l r \\<Longrightarrow> (p, xs1) = x \\<Longrightarrow> p - Suc l < r - l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> r \\<le> l; \\<not> length xs \\<le> r;\n     x = Quicksort.partition xs l r; (p, xs1) = x\\<rbrakk>\n    \\<Longrightarrow> p - Suc l < r - l", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> r \\<le> l; \\<not> length xs \\<le> r;\n     x = Quicksort.partition xs l r; (p, xs1) = x\\<rbrakk>\n    \\<Longrightarrow> p - Suc l < r - l", "@have \"fst (partition xs l r) - l - 1 < r - l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> r \\<le> l; \\<not> length xs \\<le> r;\n     x = Quicksort.partition xs l r; (p, xs1) = x\\<rbrakk>\n    \\<Longrightarrow> p - Suc l < r - l", "@qed"], ["", "lemma quicksort_term2:\n  \"\\<not>r \\<le> l \\<Longrightarrow> \\<not> length xs \\<le> r \\<Longrightarrow> x = partition xs l r \\<Longrightarrow> (p, xs2) = x \\<Longrightarrow> r - Suc p < r - l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> r \\<le> l; \\<not> length xs \\<le> r;\n     x = Quicksort.partition xs l r; (p, xs2) = x\\<rbrakk>\n    \\<Longrightarrow> r - Suc p < r - l", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> r \\<le> l; \\<not> length xs \\<le> r;\n     x = Quicksort.partition xs l r; (p, xs2) = x\\<rbrakk>\n    \\<Longrightarrow> r - Suc p < r - l", "@have \"r - fst (partition xs l r) - 1 < r - l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> r \\<le> l; \\<not> length xs \\<le> r;\n     x = Quicksort.partition xs l r; (p, xs2) = x\\<rbrakk>\n    \\<Longrightarrow> r - Suc p < r - l", "@qed"], ["", "subsection \\<open>Quicksort function\\<close>"], ["", "function quicksort :: \"('a::linorder) list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list\" where\n  \"quicksort xs l r = (\n    if l \\<ge> r then xs\n    else if r \\<ge> length xs then xs\n    else let\n      (p, xs1) = partition xs l r;\n      xs2 = quicksort xs1 l (p - 1)\n    in\n      quicksort xs2 (p + 1) r)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>xs l r. x = (xs, l, r) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>xs l r xsa la ra.\n       (xs, l, r) = (xsa, la, ra) \\<Longrightarrow>\n       (if r \\<le> l then xs\n        else if length xs \\<le> r then xs\n             else let (p, xs1) = Quicksort.partition xs l r;\n                      xs2 = quicksort_sumC (xs1, l, p - 1)\n                  in quicksort_sumC (xs2, p + 1, r)) =\n       (if ra \\<le> la then xsa\n        else if length xsa \\<le> ra then xsa\n             else let (p, xs1) = Quicksort.partition xsa la ra;\n                      xs2 = quicksort_sumC (xs1, la, p - 1)\n                  in quicksort_sumC (xs2, p + 1, ra))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All quicksort_dom", "apply (relation \"measure (\\<lambda>(a, l, r). (r - l))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (measure (\\<lambda>(a, l, r). r - l))\n 2. \\<And>xs l r x xa y.\n       \\<lbrakk>\\<not> r \\<le> l; \\<not> length xs \\<le> r;\n        x = Quicksort.partition xs l r; (xa, y) = x\\<rbrakk>\n       \\<Longrightarrow> ((y, l, xa - 1), xs, l, r)\n                         \\<in> measure (\\<lambda>(a, l, r). r - l)\n 3. \\<And>xs l r x xa y xb.\n       \\<lbrakk>\\<not> r \\<le> l; \\<not> length xs \\<le> r;\n        x = Quicksort.partition xs l r; (xa, y) = x;\n        xb = quicksort y l (xa - 1); quicksort_dom (y, l, xa - 1)\\<rbrakk>\n       \\<Longrightarrow> ((xb, xa + 1, r), xs, l, r)\n                         \\<in> measure (\\<lambda>(a, l, r). r - l)", "by (auto simp add: quicksort_term1 quicksort_term2)"], ["", "lemma quicksort_basic [rewrite_arg]:\n  \"mset (quicksort xs l r) = mset xs \\<and> outer_remains xs (quicksort xs l r) l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (quicksort xs l r) = mset xs \\<and>\n    outer_remains xs (quicksort xs l r) l r", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (quicksort xs l r) = mset xs \\<and>\n    outer_remains xs (quicksort xs l r) l r", "@fun_induct \"quicksort xs l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (quicksort xs l r) = mset xs \\<and>\n    outer_remains xs (quicksort xs l r) l r", "@unfold \"quicksort xs l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (quicksort xs l r) = mset xs \\<and>\n    outer_remains xs (quicksort xs l r) l r", "@qed"], ["", "lemma quicksort_trivial1 [rewrite]:\n  \"l \\<ge> r \\<Longrightarrow> quicksort xs l r = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> l \\<Longrightarrow> quicksort xs l r = xs", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> l \\<Longrightarrow> quicksort xs l r = xs", "@unfold \"quicksort xs l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> l \\<Longrightarrow> quicksort xs l r = xs", "@qed"], ["", "lemma quicksort_trivial2 [rewrite]:\n  \"r \\<ge> length xs \\<Longrightarrow> quicksort xs l r = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> r \\<Longrightarrow> quicksort xs l r = xs", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> r \\<Longrightarrow> quicksort xs l r = xs", "@unfold \"quicksort xs l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> r \\<Longrightarrow> quicksort xs l r = xs", "@qed"], ["", "lemma quicksort_permutes [resolve]:\n  \"xs' = quicksort xs l r \\<Longrightarrow> set (sublist l (r + 1) xs') = set (sublist l (r + 1) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = quicksort xs l r \\<Longrightarrow>\n    set (sublist l (r + 1) xs') = set (sublist l (r + 1) xs)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = quicksort xs l r \\<Longrightarrow>\n    set (sublist l (r + 1) xs') = set (sublist l (r + 1) xs)", "@case \"l \\<ge> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = quicksort xs l r \\<Longrightarrow>\n    set (sublist l (r + 1) xs') = set (sublist l (r + 1) xs)", "@case \"r \\<ge> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = quicksort xs l r \\<Longrightarrow>\n    set (sublist l (r + 1) xs') = set (sublist l (r + 1) xs)", "@have \"xs = take l xs @ sublist l (r + 1) xs @ drop (r + 1) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = quicksort xs l r \\<Longrightarrow>\n    set (sublist l (r + 1) xs') = set (sublist l (r + 1) xs)", "@have \"xs' = take l xs' @ sublist l (r + 1) xs' @ drop (r + 1) xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = quicksort xs l r \\<Longrightarrow>\n    set (sublist l (r + 1) xs') = set (sublist l (r + 1) xs)", "@have \"take l xs = take l xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = quicksort xs l r \\<Longrightarrow>\n    set (sublist l (r + 1) xs') = set (sublist l (r + 1) xs)", "@have \"drop (r + 1) xs = drop (r + 1) xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = quicksort xs l r \\<Longrightarrow>\n    set (sublist l (r + 1) xs') = set (sublist l (r + 1) xs)", "@qed"], ["", "lemma quicksort_sorts [forward_arg]:\n  \"r < length xs \\<Longrightarrow> sorted (sublist l (r + 1) (quicksort xs l r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@fun_induct \"quicksort xs l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@case \"l \\<ge> r\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@case \"l = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@case \"r \\<ge> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@let \"p = fst (partition xs l r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@let \"xs1 = snd (partition xs l r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@let \"xs2 = quicksort xs1 l (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@let \"xs3 = quicksort xs2 (p + 1) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"sorted (sublist l (r + 1) xs3)\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"l \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"p + 1 \\<le> r + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"r + 1 \\<le> length xs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"sublist l p xs2 = sublist l p xs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"set (sublist l p xs1) = set (sublist l p xs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"sublist (p + 1) (r + 1) xs1 = sublist (p + 1) (r + 1) xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"set (sublist (p + 1) (r + 1) xs2) = set (sublist (p + 1) (r + 1) xs3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"\\<forall>x\\<in>set (sublist l p xs3). x \\<le> xs3 ! p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"\\<forall>x\\<in>set (sublist (p + 1) (r + 1) xs3). x \\<ge> xs3 ! p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"sorted (sublist l p xs3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"sorted (sublist (p + 1) (r + 1) xs3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@have \"sublist l (r + 1) xs3 = sublist l p xs3 @ (xs3 ! p) # sublist (p + 1) (r + 1) xs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@unfold \"quicksort xs l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length xs \\<Longrightarrow>\n    sorted (sublist l (r + 1) (quicksort xs l r))", "@qed"], ["", "text \\<open>Main result: correctness of functional quicksort.\\<close>"], ["", "theorem quicksort_sorts_all [rewrite]:\n  \"xs \\<noteq> [] \\<Longrightarrow> quicksort xs 0 (length xs - 1) = sort xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    quicksort xs 0 (length xs - 1) = sort xs", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    quicksort xs 0 (length xs - 1) = sort xs", "@let \"xs' = quicksort xs 0 (length xs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    quicksort xs 0 (length xs - 1) = sort xs", "@have \"sublist 0 (length xs - 1 + 1) xs' = xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    quicksort xs 0 (length xs - 1) = sort xs", "@qed"], ["", "end"]]}