{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Imperative/Indexed_PQueue_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma idx_pqueue_empty_rule [hoare_triple]:\n  \"<emp>\n   idx_pqueue_empty n\n   <idx_pqueue ([], replicate n None)>\"", "lemma idx_pqueue_nth_rule [hoare_triple]:\n  \"<idx_pqueue (xs, m) p * \\<up>(i < length xs)>\n   idx_pqueue_nth p i\n   <\\<lambda>r. idx_pqueue (xs, m) p * \\<up>(r = xs ! i)>\"", "lemma idx_nth_rule [hoare_triple]:\n  \"<idx_pqueue (xs, m) p * \\<up>(i < length m)>\n   idx_nth p i\n   <\\<lambda>r. idx_pqueue (xs, m) p * \\<up>(r = m ! i)>\"", "lemma idx_pqueue_length_rule [hoare_triple]:\n  \"<idx_pqueue (xs, m) p>\n   idx_pqueue_length p\n   <\\<lambda>r. idx_pqueue (xs, m) p * \\<up>(r = length xs)>\"", "lemma idx_pqueue_swap_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   idx_pqueue_swap p i j\n   <\\<lambda>_. idx_pqueue (idx_pqueue_swap_fun (xs, m) i j) p>\"", "lemma idx_pqueue_push_rule [hoare_triple]:\n  \"k < length m \\<Longrightarrow> \\<not>has_key_alist xs k \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   idx_pqueue_push k v p\n   <idx_pqueue (idx_pqueue_push_fun k v (xs, m))>\\<^sub>t\"", "lemma idx_pqueue_pop_rule [hoare_triple]:\n  \"xs \\<noteq> [] \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   idx_pqueue_pop p\n   <\\<lambda>(x, r). idx_pqueue (idx_pqueue_pop_fun (xs, m)) r * \\<up>(x = last xs)>\"", "lemma array_upd_idx_pqueue_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow> k = fst (xs ! i) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   idx_pqueue_array_upd i (k, v) (pqueue p)\n   <\\<lambda>_. idx_pqueue (list_update xs i (k, v), m) p>\"", "lemma has_key_idx_pqueue_rule [hoare_triple]:\n  \"k < length m \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   has_key_idx_pqueue k p\n   <\\<lambda>r. idx_pqueue (xs, m) p * \\<up>(r \\<longleftrightarrow> has_key_alist xs k)>\"", "lemma idx_bubble_down_rule [hoare_triple]:\n  \"index_of_pqueue x \\<Longrightarrow>\n   <idx_pqueue x a>\n   idx_bubble_down a k\n   <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>\"", "lemma idx_bubble_up_rule [hoare_triple]:\n  \"index_of_pqueue x \\<Longrightarrow>\n   <idx_pqueue x a>\n   idx_bubble_up a k\n   <\\<lambda>_. idx_pqueue (idx_bubble_up_fun x k) a>\"", "lemma delete_min_idx_pqueue_rule [hoare_triple]:\n  \"xs \\<noteq> [] \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   delete_min_idx_pqueue p\n   <\\<lambda>(x, r). idx_pqueue (snd (delete_min_idx_pqueue_fun (xs, m))) r *\n       \\<up>(x = fst (delete_min_idx_pqueue_fun (xs, m)))>\"", "lemma insert_idx_pqueue_rule [hoare_triple]:\n  \"k < length m \\<Longrightarrow> \\<not>has_key_alist xs k \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   insert_idx_pqueue k v p\n   <idx_pqueue (insert_idx_pqueue_fun k v (xs, m))>\\<^sub>t\"", "lemma update_idx_pqueue_rule [hoare_triple]:\n  \"k < length m \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   update_idx_pqueue k v p\n   <idx_pqueue (update_idx_pqueue_fun k v (xs, m))>\\<^sub>t\"", "lemma heap_implies_hd_min2 [resolve]:\n  \"is_heap xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> (map_of_alist xs)\\<langle>k\\<rangle> = Some v \\<Longrightarrow> snd (hd xs) \\<le> v\"", "theorem idx_pqueue_empty_map [hoare_triple]:\n  \"<emp>\n   idx_pqueue_empty n\n   <idx_pqueue_map empty_map n>\"", "theorem delete_min_idx_pqueue_map [hoare_triple]:\n  \"<idx_pqueue_map M n p * \\<up>(M \\<noteq> empty_map)>\n   delete_min_idx_pqueue p\n   <\\<lambda>(x, r). idx_pqueue_map (delete_map (fst x) M) n r * \\<up>(fst x < n) *\n                \\<up>(is_heap_min (fst x) M) * \\<up>(M\\<langle>fst x\\<rangle> = Some (snd x))>\"", "theorem insert_idx_pqueue_map [hoare_triple]:\n  \"k < n \\<Longrightarrow> k \\<notin> keys_of M \\<Longrightarrow>\n   <idx_pqueue_map M n p>\n   insert_idx_pqueue k v p\n   <idx_pqueue_map (M {k \\<rightarrow> v}) n>\\<^sub>t\"", "theorem has_key_idx_pqueue_map [hoare_triple]:\n  \"k < n \\<Longrightarrow>\n   <idx_pqueue_map M n p>\n   has_key_idx_pqueue k p\n   <\\<lambda>r. idx_pqueue_map M n p * \\<up>(r \\<longleftrightarrow> k \\<in> keys_of M)>\"", "theorem update_idx_pqueue_map [hoare_triple]:\n  \"k < n \\<Longrightarrow>\n   <idx_pqueue_map M n p>\n   update_idx_pqueue k v p\n   <idx_pqueue_map (M {k \\<rightarrow> v}) n>\\<^sub>t\""], "translations": [["", "lemma idx_pqueue_empty_rule [hoare_triple]:\n  \"<emp>\n   idx_pqueue_empty n\n   <idx_pqueue ([], replicate n None)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> idx_pqueue_empty n <idx_pqueue ([], replicate n None)>", "by auto2"], ["", "definition idx_pqueue_nth :: \"'a::heap indexed_pqueue \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> 'a) Heap\" where\n  \"idx_pqueue_nth p i = array_nth (pqueue p) i\""], ["", "lemma idx_pqueue_nth_rule [hoare_triple]:\n  \"<idx_pqueue (xs, m) p * \\<up>(i < length xs)>\n   idx_pqueue_nth p i\n   <\\<lambda>r. idx_pqueue (xs, m) p * \\<up>(r = xs ! i)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <idx_pqueue (xs, m) p * \\<up> (i < length xs)> idx_pqueue_nth p i\n    <\\<lambda>r. idx_pqueue (xs, m) p * \\<up> (r = xs ! i)>", "by auto2"], ["", "definition idx_nth :: \"'a::heap indexed_pqueue \\<Rightarrow> nat \\<Rightarrow> nat option Heap\" where\n  \"idx_nth p i = Array.nth (index p) i\""], ["", "lemma idx_nth_rule [hoare_triple]:\n  \"<idx_pqueue (xs, m) p * \\<up>(i < length m)>\n   idx_nth p i\n   <\\<lambda>r. idx_pqueue (xs, m) p * \\<up>(r = m ! i)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <idx_pqueue (xs, m) p * \\<up> (i < length m)> idx_nth p i\n    <\\<lambda>r. idx_pqueue (xs, m) p * \\<up> (r = m ! i)>", "by auto2"], ["", "definition idx_pqueue_length :: \"'a indexed_pqueue \\<Rightarrow> nat Heap\" where\n  \"idx_pqueue_length a = array_length (pqueue a)\""], ["", "lemma idx_pqueue_length_rule [hoare_triple]:\n  \"<idx_pqueue (xs, m) p>\n   idx_pqueue_length p\n   <\\<lambda>r. idx_pqueue (xs, m) p * \\<up>(r = length xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <idx_pqueue (xs, m) p> idx_pqueue_length p\n    <\\<lambda>r. idx_pqueue (xs, m) p * \\<up> (r = length xs)>", "by auto2"], ["", "definition idx_pqueue_swap ::\n  \"'a::{heap,linorder} indexed_pqueue \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> unit Heap\" where\n  \"idx_pqueue_swap p i j = do {\n     pr_i \\<leftarrow> array_nth (pqueue p) i;\n     pr_j \\<leftarrow> array_nth (pqueue p) j;\n     Array.upd (fst pr_i) (Some j) (index p);\n     Array.upd (fst pr_j) (Some i) (index p);\n     array_swap (pqueue p) i j\n   }\""], ["", "lemma idx_pqueue_swap_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   idx_pqueue_swap p i j\n   <\\<lambda>_. idx_pqueue (idx_pqueue_swap_fun (xs, m) i j) p>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m) p> idx_pqueue_swap p i j\n                      <\\<lambda>_.\n                          idx_pqueue (idx_pqueue_swap_fun (xs, m) i j) p>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m) p> idx_pqueue_swap p i j\n                      <\\<lambda>_.\n                          idx_pqueue (idx_pqueue_swap_fun (xs, m) i j) p>", "@unfold \"idx_pqueue_swap_fun (xs, m) i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m) p> idx_pqueue_swap p i j\n                      <\\<lambda>_.\n                          idx_pqueue (idx_pqueue_swap_fun (xs, m) i j) p>", "@qed"], ["", "definition idx_pqueue_push :: \"nat \\<Rightarrow> 'a::heap \\<Rightarrow> 'a indexed_pqueue \\<Rightarrow> 'a indexed_pqueue Heap\" where\n  \"idx_pqueue_push k v p = do {\n     len \\<leftarrow> array_length (pqueue p);\n     d' \\<leftarrow> push_array (k, v) (pqueue p);\n     Array.upd k (Some len) (index p);\n     return (Indexed_PQueue d' (index p))\n   }\""], ["", "lemma idx_pqueue_push_rule [hoare_triple]:\n  \"k < length m \\<Longrightarrow> \\<not>has_key_alist xs k \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   idx_pqueue_push k v p\n   <idx_pqueue (idx_pqueue_push_fun k v (xs, m))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length m; \\<not> has_key_alist xs k\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m)\n                        p> idx_pqueue_push k v\n                            p <idx_pqueue\n                                (idx_pqueue_push_fun k v (xs, m))>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length m; \\<not> has_key_alist xs k\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m)\n                        p> idx_pqueue_push k v\n                            p <idx_pqueue\n                                (idx_pqueue_push_fun k v (xs, m))>\\<^sub>t", "@unfold \"idx_pqueue_push_fun k v (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length m; \\<not> has_key_alist xs k\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m)\n                        p> idx_pqueue_push k v\n                            p <idx_pqueue\n                                (idx_pqueue_push_fun k v (xs, m))>\\<^sub>t", "@qed"], ["", "definition idx_pqueue_pop :: \"'a::heap indexed_pqueue \\<Rightarrow> ((nat \\<times> 'a) \\<times> 'a indexed_pqueue) Heap\" where\n  \"idx_pqueue_pop p = do {\n     (x, d') \\<leftarrow> pop_array (pqueue p);\n     Array.upd (fst x) None (index p);\n     return (x, Indexed_PQueue d' (index p))\n   }\""], ["", "lemma idx_pqueue_pop_rule [hoare_triple]:\n  \"xs \\<noteq> [] \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   idx_pqueue_pop p\n   <\\<lambda>(x, r). idx_pqueue (idx_pqueue_pop_fun (xs, m)) r * \\<up>(x = last xs)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m) p> idx_pqueue_pop p\n                      <\\<lambda>(x, r).\n                          idx_pqueue (idx_pqueue_pop_fun (xs, m)) r *\n                          \\<up> (x = last xs)>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m) p> idx_pqueue_pop p\n                      <\\<lambda>(x, r).\n                          idx_pqueue (idx_pqueue_pop_fun (xs, m)) r *\n                          \\<up> (x = last xs)>", "@unfold \"idx_pqueue_pop_fun (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m) p> idx_pqueue_pop p\n                      <\\<lambda>(x, r).\n                          idx_pqueue (idx_pqueue_pop_fun (xs, m)) r *\n                          \\<up> (x = last xs)>", "@qed"], ["", "definition idx_pqueue_array_upd :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a::heap dynamic_array \\<Rightarrow> unit Heap\" where\n  \"idx_pqueue_array_upd i x d = array_upd i x d\""], ["", "lemma array_upd_idx_pqueue_rule [hoare_triple]:\n  \"i < length xs \\<Longrightarrow> k = fst (xs ! i) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   idx_pqueue_array_upd i (k, v) (pqueue p)\n   <\\<lambda>_. idx_pqueue (list_update xs i (k, v), m) p>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; k = fst (xs ! i)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m) p>\n                      idx_pqueue_array_upd i (k, v) (pqueue p)\n                      <\\<lambda>_. idx_pqueue (xs[i := (k, v)], m) p>", "by auto2"], ["", "definition has_key_idx_pqueue :: \"nat \\<Rightarrow> 'a::{heap,linorder} indexed_pqueue \\<Rightarrow> bool Heap\" where\n  \"has_key_idx_pqueue k p = do {\n    i_opt \\<leftarrow> Array.nth (index p) k;\n    return (i_opt \\<noteq> None) }\""], ["", "lemma has_key_idx_pqueue_rule [hoare_triple]:\n  \"k < length m \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   has_key_idx_pqueue k p\n   <\\<lambda>r. idx_pqueue (xs, m) p * \\<up>(r \\<longleftrightarrow> has_key_alist xs k)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length m; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m) p> has_key_idx_pqueue k p\n                      <\\<lambda>r.\n                          idx_pqueue (xs, m) p *\n                          \\<up> (r = has_key_alist xs k)>", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm idx_pqueue.simps}\\<close>"], ["", "setup \\<open>del_simple_datatype \"indexed_pqueue\"\\<close>"], ["", "subsection \\<open>Bubble up and down\\<close>"], ["", "partial_function (heap) idx_bubble_down :: \"'a::{heap,linorder} indexed_pqueue \\<Rightarrow> nat \\<Rightarrow> unit Heap\" where\n  \"idx_bubble_down a k = do {\n    len \\<leftarrow> idx_pqueue_length a;\n    (if s2 k < len then do {\n      vk \\<leftarrow> idx_pqueue_nth a k;\n      vs1k \\<leftarrow> idx_pqueue_nth a (s1 k);\n      vs2k \\<leftarrow> idx_pqueue_nth a (s2 k);\n      (if snd vs1k \\<le> snd vs2k then\n         if snd vk > snd vs1k then\n           do { idx_pqueue_swap a k (s1 k); idx_bubble_down a (s1 k) }\n         else return ()\n       else\n         if snd vk > snd vs2k then\n           do { idx_pqueue_swap a k (s2 k); idx_bubble_down a (s2 k) }\n         else return ()) }\n     else if s1 k < len then do {\n       vk \\<leftarrow> idx_pqueue_nth a k;\n       vs1k \\<leftarrow> idx_pqueue_nth a (s1 k);\n       (if snd vk > snd vs1k then\n          do { idx_pqueue_swap a k (s1 k); idx_bubble_down a (s1 k) }\n        else return ()) }\n     else return ()) }\""], ["", "lemma idx_bubble_down_rule [hoare_triple]:\n  \"index_of_pqueue x \\<Longrightarrow>\n   <idx_pqueue x a>\n   idx_bubble_down a k\n   <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_down a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_down a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>", "@fun_induct \"idx_bubble_down_fun x k\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_down a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>", "@subgoal \"(x = (xs, m), k = k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_down a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>", "@unfold \"idx_bubble_down_fun (xs, m) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_down a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>", "@case \"s2 k < length xs\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_down a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>", "@case \"snd (xs ! s1 k) \\<le> snd (xs ! s2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_down a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_down a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>", "@case \"s1 k < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_down a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_down a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_down_fun x k) a>", "@qed"], ["", "partial_function (heap) idx_bubble_up :: \"'a::{heap,linorder} indexed_pqueue \\<Rightarrow> nat \\<Rightarrow> unit Heap\" where\n  \"idx_bubble_up a k =\n    (if k = 0 then return () else do {\n       len \\<leftarrow> idx_pqueue_length a;\n       (if k < len then do {\n          vk \\<leftarrow> idx_pqueue_nth a k;\n          vpk \\<leftarrow> idx_pqueue_nth a (par k);\n          (if snd vk < snd vpk then\n             do { idx_pqueue_swap a k (par k); idx_bubble_up a (par k) }\n           else return ()) }\n        else return ())})\""], ["", "lemma idx_bubble_up_rule [hoare_triple]:\n  \"index_of_pqueue x \\<Longrightarrow>\n   <idx_pqueue x a>\n   idx_bubble_up a k\n   <\\<lambda>_. idx_pqueue (idx_bubble_up_fun x k) a>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_up a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_up_fun x k) a>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_up a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_up_fun x k) a>", "@fun_induct \"idx_bubble_up_fun x k\" @with"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_up a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_up_fun x k) a>", "@subgoal \"(x = (xs, m), k = k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_up a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_up_fun x k) a>", "@unfold \"idx_bubble_up_fun (xs, m) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_up a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_up_fun x k) a>", "@end"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_pqueue x \\<Longrightarrow>\n    <idx_pqueue x a> idx_bubble_up a k\n    <\\<lambda>_. idx_pqueue (idx_bubble_up_fun x k) a>", "@qed"], ["", "subsection \\<open>Main operations\\<close>"], ["", "definition delete_min_idx_pqueue :: \"'a::{heap,linorder} indexed_pqueue \\<Rightarrow> ((nat \\<times> 'a) \\<times> 'a indexed_pqueue) Heap\" where\n  \"delete_min_idx_pqueue p = do {\n     len \\<leftarrow> idx_pqueue_length p;\n     if len = 0 then raise STR ''delete_min''\n     else do {\n       idx_pqueue_swap p 0 (len - 1);\n       (x', r) \\<leftarrow> idx_pqueue_pop p;\n       idx_bubble_down r 0;\n       return (x', r)\n     }\n   }\""], ["", "lemma delete_min_idx_pqueue_rule [hoare_triple]:\n  \"xs \\<noteq> [] \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   delete_min_idx_pqueue p\n   <\\<lambda>(x, r). idx_pqueue (snd (delete_min_idx_pqueue_fun (xs, m))) r *\n       \\<up>(x = fst (delete_min_idx_pqueue_fun (xs, m)))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m) p> delete_min_idx_pqueue p\n                      <\\<lambda>(x, r).\n                          idx_pqueue\n                           (snd (delete_min_idx_pqueue_fun (xs, m))) r *\n                          \\<up>\n                           (x = fst (delete_min_idx_pqueue_fun (xs, m)))>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m) p> delete_min_idx_pqueue p\n                      <\\<lambda>(x, r).\n                          idx_pqueue\n                           (snd (delete_min_idx_pqueue_fun (xs, m))) r *\n                          \\<up>\n                           (x = fst (delete_min_idx_pqueue_fun (xs, m)))>", "@unfold \"delete_min_idx_pqueue_fun (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m) p> delete_min_idx_pqueue p\n                      <\\<lambda>(x, r).\n                          idx_pqueue\n                           (snd (delete_min_idx_pqueue_fun (xs, m))) r *\n                          \\<up>\n                           (x = fst (delete_min_idx_pqueue_fun (xs, m)))>", "@qed"], ["", "definition insert_idx_pqueue :: \"nat \\<Rightarrow> 'a::{heap,linorder} \\<Rightarrow> 'a indexed_pqueue \\<Rightarrow> 'a indexed_pqueue Heap\" where\n  \"insert_idx_pqueue k v p = do {\n     p' \\<leftarrow> idx_pqueue_push k v p;\n     len \\<leftarrow> idx_pqueue_length p';\n     idx_bubble_up p' (len - 1);\n     return p'\n   }\""], ["", "lemma insert_idx_pqueue_rule [hoare_triple]:\n  \"k < length m \\<Longrightarrow> \\<not>has_key_alist xs k \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   insert_idx_pqueue k v p\n   <idx_pqueue (insert_idx_pqueue_fun k v (xs, m))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length m; \\<not> has_key_alist xs k;\n     index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m)\n                        p> insert_idx_pqueue k v\n                            p <idx_pqueue\n                                (insert_idx_pqueue_fun k v (xs, m))>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length m; \\<not> has_key_alist xs k;\n     index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m)\n                        p> insert_idx_pqueue k v\n                            p <idx_pqueue\n                                (insert_idx_pqueue_fun k v (xs, m))>\\<^sub>t", "@unfold \"insert_idx_pqueue_fun k v (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length m; \\<not> has_key_alist xs k;\n     index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m)\n                        p> insert_idx_pqueue k v\n                            p <idx_pqueue\n                                (insert_idx_pqueue_fun k v (xs, m))>\\<^sub>t", "@qed"], ["", "definition update_idx_pqueue ::\n  \"nat \\<Rightarrow> 'a::{heap,linorder} \\<Rightarrow> 'a indexed_pqueue \\<Rightarrow> 'a indexed_pqueue Heap\" where\n  \"update_idx_pqueue k v p = do {\n    i_opt \\<leftarrow> idx_nth p k;\n    case i_opt of\n      None \\<Rightarrow> insert_idx_pqueue k v p\n    | Some i \\<Rightarrow> do {\n      x \\<leftarrow> idx_pqueue_nth p i;\n      idx_pqueue_array_upd i (k, v) (pqueue p);\n      (if snd x \\<le> v then do {idx_bubble_down p i; return p}\n       else do {idx_bubble_up p i; return p}) }}\""], ["", "lemma update_idx_pqueue_rule [hoare_triple]:\n  \"k < length m \\<Longrightarrow> index_of_pqueue (xs, m) \\<Longrightarrow>\n   <idx_pqueue (xs, m) p>\n   update_idx_pqueue k v p\n   <idx_pqueue (update_idx_pqueue_fun k v (xs, m))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length m; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m)\n                        p> update_idx_pqueue k v\n                            p <idx_pqueue\n                                (update_idx_pqueue_fun k v (xs, m))>\\<^sub>t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length m; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m)\n                        p> update_idx_pqueue k v\n                            p <idx_pqueue\n                                (update_idx_pqueue_fun k v (xs, m))>\\<^sub>t", "@unfold \"update_idx_pqueue_fun k v (xs, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length m; index_of_pqueue (xs, m)\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue (xs, m)\n                        p> update_idx_pqueue k v\n                            p <idx_pqueue\n                                (update_idx_pqueue_fun k v (xs, m))>\\<^sub>t", "@qed"], ["", "subsection \\<open>Outer interface\\<close>"], ["", "text \\<open>Express Hoare triples for indexed priority queue operations in terms of\n  the mapping represented by the queue.\\<close>"], ["", "definition idx_pqueue_map :: \"(nat, 'a::{heap,linorder}) map \\<Rightarrow> nat \\<Rightarrow> 'a indexed_pqueue \\<Rightarrow> assn\" where\n  \"idx_pqueue_map M n p = (\\<exists>\\<^sub>Axs m. idx_pqueue (xs, m) p *\n      \\<up>(index_of_pqueue (xs, m)) * \\<up>(is_heap xs) * \\<up>(M = map_of_alist xs) * \\<up>(n = length m))\""], ["", "setup \\<open>add_rewrite_ent_rule @{thm idx_pqueue_map_def}\\<close>"], ["", "lemma heap_implies_hd_min2 [resolve]:\n  \"is_heap xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> (map_of_alist xs)\\<langle>k\\<rangle> = Some v \\<Longrightarrow> snd (hd xs) \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; xs \\<noteq> [];\n     map_of_alist xs\\<langle>k\\<rangle> = Some v\\<rbrakk>\n    \\<Longrightarrow> snd (hd xs) \\<le> v", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; xs \\<noteq> [];\n     map_of_alist xs\\<langle>k\\<rangle> = Some v\\<rbrakk>\n    \\<Longrightarrow> snd (hd xs) \\<le> v", "@obtain i where \"i < length xs\" \"xs ! i = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; xs \\<noteq> [];\n     map_of_alist xs\\<langle>k\\<rangle> = Some v\\<rbrakk>\n    \\<Longrightarrow> snd (hd xs) \\<le> v", "@have \"snd (hd xs) \\<le> snd (xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap xs; xs \\<noteq> [];\n     map_of_alist xs\\<langle>k\\<rangle> = Some v\\<rbrakk>\n    \\<Longrightarrow> snd (hd xs) \\<le> v", "@qed"], ["", "theorem idx_pqueue_empty_map [hoare_triple]:\n  \"<emp>\n   idx_pqueue_empty n\n   <idx_pqueue_map empty_map n>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> idx_pqueue_empty n <idx_pqueue_map empty_map n>", "by auto2"], ["", "theorem delete_min_idx_pqueue_map [hoare_triple]:\n  \"<idx_pqueue_map M n p * \\<up>(M \\<noteq> empty_map)>\n   delete_min_idx_pqueue p\n   <\\<lambda>(x, r). idx_pqueue_map (delete_map (fst x) M) n r * \\<up>(fst x < n) *\n                \\<up>(is_heap_min (fst x) M) * \\<up>(M\\<langle>fst x\\<rangle> = Some (snd x))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <idx_pqueue_map M n p * \\<up> (M \\<noteq> empty_map)>\n    delete_min_idx_pqueue p\n    <\\<lambda>(x, r).\n        idx_pqueue_map (delete_map (fst x) M) n r * \\<up> (fst x < n) *\n        \\<up> (is_heap_min (fst x) M) *\n        \\<up> (M\\<langle>fst x\\<rangle> = Some (snd x))>", "by auto2"], ["", "theorem insert_idx_pqueue_map [hoare_triple]:\n  \"k < n \\<Longrightarrow> k \\<notin> keys_of M \\<Longrightarrow>\n   <idx_pqueue_map M n p>\n   insert_idx_pqueue k v p\n   <idx_pqueue_map (M {k \\<rightarrow> v}) n>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < n; k \\<notin> keys_of M\\<rbrakk>\n    \\<Longrightarrow> <idx_pqueue_map M n\n                        p> insert_idx_pqueue k v\n                            p <idx_pqueue_map ( M { k \\<rightarrow> v })\n                                n>\\<^sub>t", "by auto2"], ["", "theorem has_key_idx_pqueue_map [hoare_triple]:\n  \"k < n \\<Longrightarrow>\n   <idx_pqueue_map M n p>\n   has_key_idx_pqueue k p\n   <\\<lambda>r. idx_pqueue_map M n p * \\<up>(r \\<longleftrightarrow> k \\<in> keys_of M)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    <idx_pqueue_map M n p> has_key_idx_pqueue k p\n    <\\<lambda>r. idx_pqueue_map M n p * \\<up> (r = (k \\<in> keys_of M))>", "by auto2"], ["", "theorem update_idx_pqueue_map [hoare_triple]:\n  \"k < n \\<Longrightarrow>\n   <idx_pqueue_map M n p>\n   update_idx_pqueue k v p\n   <idx_pqueue_map (M {k \\<rightarrow> v}) n>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow>\n    <idx_pqueue_map M n\n      p> update_idx_pqueue k v\n          p <idx_pqueue_map ( M { k \\<rightarrow> v }) n>\\<^sub>t", "by auto2"], ["", "setup \\<open>del_prfstep_thm @{thm idx_pqueue_map_def}\\<close>"], ["", "end"]]}