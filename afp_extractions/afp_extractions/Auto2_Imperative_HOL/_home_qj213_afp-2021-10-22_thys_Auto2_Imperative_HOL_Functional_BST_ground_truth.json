{"file_name": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL/Functional/BST.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Auto2_Imperative_HOL", "problem_names": ["lemma in_traverse_fst [rewrite]:\n  \"map fst (in_traverse_pairs t) = in_traverse t\"", "lemma tree_sorted_lr [forward]:\n  \"tree_sorted (Node l k v r) \\<Longrightarrow> tree_sorted l \\<and> tree_sorted r\"", "lemma inorder_preserve_set [rewrite]:\n  \"tree_set t = set (in_traverse t)\"", "lemma inorder_pairs_sorted [rewrite]:\n  \"tree_sorted t \\<longleftrightarrow> strict_sorted (map fst (in_traverse_pairs t))\"", "lemma rotateL_in_trav [rewrite]: \"in_traverse (rotateL t) = in_traverse t\"", "lemma rotateR_in_trav [rewrite]: \"in_traverse (rotateR t) = in_traverse t\"", "lemma rotateL_sorted [forward]: \"tree_sorted t \\<Longrightarrow> tree_sorted (rotateL t)\"", "lemma rotateR_sorted [forward]: \"tree_sorted t \\<Longrightarrow> tree_sorted (rotateR t)\"", "lemma insert_in_traverse_pairs [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> in_traverse_pairs (tree_insert x v t) = ordered_insert_pairs x v (in_traverse_pairs t)\"", "theorem insert_sorted [forward]:\n  \"tree_sorted t \\<Longrightarrow> tree_sorted (tree_insert x v t)\"", "theorem insert_on_map:\n  \"tree_sorted t \\<Longrightarrow> tree_map (tree_insert x v t) = (tree_map t) {x \\<rightarrow> v}\"", "lemma delete_min_del_hd_pairs [rewrite]:\n  \"t \\<noteq> Tip \\<Longrightarrow> fst (del_min t) # in_traverse_pairs (snd (del_min t)) = in_traverse_pairs t\"", "lemma delete_elt_in_traverse_pairs [rewrite]:\n  \"in_traverse_pairs (delete_elt_tree (Node lt x v rt)) = in_traverse_pairs lt @ in_traverse_pairs rt\"", "lemma tree_delete_in_traverse_pairs [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> in_traverse_pairs (tree_delete x t) = remove_elt_pairs x (in_traverse_pairs t)\"", "theorem tree_delete_sorted [forward]:\n  \"tree_sorted t \\<Longrightarrow> tree_sorted (tree_delete x t)\"", "theorem tree_delete_map [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> tree_map (tree_delete x t) = delete_map x (tree_map t)\"", "theorem tree_search_correct [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> tree_search t x = (tree_map t)\\<langle>x\\<rangle>\""], "translations": [["", "lemma in_traverse_fst [rewrite]:\n  \"map fst (in_traverse_pairs t) = in_traverse t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (in_traverse_pairs t) = in_traverse t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (in_traverse_pairs t) = in_traverse t", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (in_traverse_pairs t) = in_traverse t", "@qed"], ["", "definition tree_map :: \"('a, 'b) tree \\<Rightarrow> ('a, 'b) map\" where\n  \"tree_map t = map_of_alist (in_traverse_pairs t)\""], ["", "setup \\<open>add_rewrite_rule @{thm tree_map_def}\\<close>"], ["", "subsection \\<open>Sortedness on trees\\<close>"], ["", "fun tree_sorted :: \"('a::linorder, 'b) tree \\<Rightarrow> bool\" where\n  \"tree_sorted Tip = True\"\n| \"tree_sorted (Node l k v r) = ((\\<forall>x\\<in>tree_set l. x < k) \\<and> (\\<forall>x\\<in>tree_set r. k < x)\n                              \\<and> tree_sorted l \\<and> tree_sorted r)\""], ["", "setup \\<open>fold add_rewrite_rule @{thms tree_sorted.simps}\\<close>"], ["", "lemma tree_sorted_lr [forward]:\n  \"tree_sorted (Node l k v r) \\<Longrightarrow> tree_sorted l \\<and> tree_sorted r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted (Node l k v r) \\<Longrightarrow>\n    tree_sorted l \\<and> tree_sorted r", "by auto2"], ["", "lemma inorder_preserve_set [rewrite]:\n  \"tree_set t = set (in_traverse t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_set t = set (in_traverse t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_set t = set (in_traverse t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_set t = set (in_traverse t)", "@qed"], ["", "lemma inorder_pairs_sorted [rewrite]:\n  \"tree_sorted t \\<longleftrightarrow> strict_sorted (map fst (in_traverse_pairs t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t = Lists_Ex.strict_sorted (map fst (in_traverse_pairs t))", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t = Lists_Ex.strict_sorted (map fst (in_traverse_pairs t))", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t = Lists_Ex.strict_sorted (map fst (in_traverse_pairs t))", "@qed"], ["", "text \\<open>Use definition in terms of in\\_traverse from now on.\\<close>"], ["", "setup \\<open>fold del_prfstep_thm (@{thms tree_set.simps} @ @{thms tree_sorted.simps})\\<close>"], ["", "subsection \\<open>Rotation on trees\\<close>"], ["", "definition rotateL :: \"('a, 'b) tree \\<Rightarrow> ('a, 'b) tree\" where [rewrite]:\n  \"rotateL t = (if t = Tip then t else if rsub t = Tip then t else\n    (let rt = rsub t in\n     Node (Node (lsub t) (key t) (nval t) (lsub rt)) (key rt) (nval rt) (rsub rt)))\""], ["", "definition rotateR :: \"('a, 'b) tree \\<Rightarrow> ('a, 'b) tree\" where [rewrite]:\n  \"rotateR t = (if t = Tip then t else if lsub t = Tip then t else\n    (let lt = lsub t in\n     Node (lsub lt) (key lt) (nval lt) (Node (rsub lt) (key t) (nval t) (rsub t))))\""], ["", "lemma rotateL_in_trav [rewrite]: \"in_traverse (rotateL t) = in_traverse t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_traverse (rotateL t) = in_traverse t", "by auto2"], ["", "lemma rotateR_in_trav [rewrite]: \"in_traverse (rotateR t) = in_traverse t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_traverse (rotateR t) = in_traverse t", "by auto2"], ["", "lemma rotateL_sorted [forward]: \"tree_sorted t \\<Longrightarrow> tree_sorted (rotateL t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow> tree_sorted (rotateL t)", "by auto2"], ["", "lemma rotateR_sorted [forward]: \"tree_sorted t \\<Longrightarrow> tree_sorted (rotateR t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow> tree_sorted (rotateR t)", "by auto2"], ["", "subsection \\<open>Insertion on trees\\<close>"], ["", "fun tree_insert :: \"'a::ord \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) tree \\<Rightarrow> ('a, 'b) tree\" where\n  \"tree_insert x v Tip = Node Tip x v Tip\"\n| \"tree_insert x v (Node l y w r) =\n    (if x = y then Node l x v r\n     else if x < y then Node (tree_insert x v l) y w r\n     else Node l y w (tree_insert x v r))\""], ["", "setup \\<open>fold add_rewrite_rule @{thms tree_insert.simps}\\<close>"], ["", "lemma insert_in_traverse_pairs [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> in_traverse_pairs (tree_insert x v t) = ordered_insert_pairs x v (in_traverse_pairs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse_pairs (tree_insert x v t) =\n    ordered_insert_pairs x v (in_traverse_pairs t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse_pairs (tree_insert x v t) =\n    ordered_insert_pairs x v (in_traverse_pairs t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse_pairs (tree_insert x v t) =\n    ordered_insert_pairs x v (in_traverse_pairs t)", "@qed"], ["", "text \\<open>Correctness results for insertion.\\<close>"], ["", "theorem insert_sorted [forward]:\n  \"tree_sorted t \\<Longrightarrow> tree_sorted (tree_insert x v t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow> tree_sorted (tree_insert x v t)", "by auto2"], ["", "theorem insert_on_map:\n  \"tree_sorted t \\<Longrightarrow> tree_map (tree_insert x v t) = (tree_map t) {x \\<rightarrow> v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    tree_map (tree_insert x v t) =  tree_map t { x \\<rightarrow> v }", "by auto2"], ["", "subsection \\<open>Deletion on trees\\<close>"], ["", "fun del_min :: \"('a, 'b) tree \\<Rightarrow> ('a \\<times> 'b) \\<times> ('a, 'b) tree\" where\n  \"del_min Tip = undefined\"\n| \"del_min (Node lt x v rt) =\n   (if lt = Tip then ((x, v), rt) else\n    (fst (del_min lt), Node (snd (del_min lt)) x v rt))\""], ["", "setup \\<open>add_rewrite_rule @{thm del_min.simps(2)}\\<close>"], ["", "lemma delete_min_del_hd_pairs [rewrite]:\n  \"t \\<noteq> Tip \\<Longrightarrow> fst (del_min t) # in_traverse_pairs (snd (del_min t)) = in_traverse_pairs t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Tip \\<Longrightarrow>\n    fst (del_min t) # in_traverse_pairs (snd (del_min t)) =\n    in_traverse_pairs t", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Tip \\<Longrightarrow>\n    fst (del_min t) # in_traverse_pairs (snd (del_min t)) =\n    in_traverse_pairs t", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Tip \\<Longrightarrow>\n    fst (del_min t) # in_traverse_pairs (snd (del_min t)) =\n    in_traverse_pairs t", "@qed"], ["", "fun delete_elt_tree :: \"('a, 'b) tree \\<Rightarrow> ('a, 'b) tree\" where\n  \"delete_elt_tree Tip = undefined\"\n| \"delete_elt_tree (Node lt x v rt) =\n    (if lt = Tip then rt else if rt = Tip then lt else\n     Node lt (fst (fst (del_min rt))) (snd (fst (del_min rt))) (snd (del_min rt)))\""], ["", "setup \\<open>add_rewrite_rule @{thm delete_elt_tree.simps(2)}\\<close>"], ["", "lemma delete_elt_in_traverse_pairs [rewrite]:\n  \"in_traverse_pairs (delete_elt_tree (Node lt x v rt)) = in_traverse_pairs lt @ in_traverse_pairs rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_traverse_pairs (delete_elt_tree (Node lt x v rt)) =\n    in_traverse_pairs lt @ in_traverse_pairs rt", "by auto2"], ["", "fun tree_delete :: \"'a::ord \\<Rightarrow> ('a, 'b) tree \\<Rightarrow> ('a, 'b) tree\" where\n  \"tree_delete x Tip = Tip\"\n| \"tree_delete x (Node l y w r) =\n    (if x = y then delete_elt_tree (Node l y w r)\n     else if x < y then Node (tree_delete x l) y w r\n     else Node l y w (tree_delete x r))\""], ["", "setup \\<open>fold add_rewrite_rule @{thms tree_delete.simps}\\<close>"], ["", "lemma tree_delete_in_traverse_pairs [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> in_traverse_pairs (tree_delete x t) = remove_elt_pairs x (in_traverse_pairs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse_pairs (tree_delete x t) =\n    remove_elt_pairs x (in_traverse_pairs t)", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse_pairs (tree_delete x t) =\n    remove_elt_pairs x (in_traverse_pairs t)", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    in_traverse_pairs (tree_delete x t) =\n    remove_elt_pairs x (in_traverse_pairs t)", "@qed"], ["", "text \\<open>Correctness results for deletion.\\<close>"], ["", "theorem tree_delete_sorted [forward]:\n  \"tree_sorted t \\<Longrightarrow> tree_sorted (tree_delete x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow> tree_sorted (tree_delete x t)", "by auto2"], ["", "theorem tree_delete_map [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> tree_map (tree_delete x t) = delete_map x (tree_map t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    tree_map (tree_delete x t) = delete_map x (tree_map t)", "by auto2"], ["", "subsection \\<open>Search on sorted trees\\<close>"], ["", "fun tree_search :: \"('a::ord, 'b) tree \\<Rightarrow> 'a \\<Rightarrow> 'b option\" where\n  \"tree_search Tip x = None\"\n| \"tree_search (Node l k v r) x =\n  (if x = k then Some v\n   else if x < k then tree_search l x\n   else tree_search r x)\""], ["", "setup \\<open>fold add_rewrite_rule @{thms tree_search.simps}\\<close>"], ["", "text \\<open>Correctness of search.\\<close>"], ["", "theorem tree_search_correct [rewrite]:\n  \"tree_sorted t \\<Longrightarrow> tree_search t x = (tree_map t)\\<langle>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    tree_search t x = tree_map t\\<langle>x\\<rangle>", "@proof"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    tree_search t x = tree_map t\\<langle>x\\<rangle>", "@induct t"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_sorted t \\<Longrightarrow>\n    tree_search t x = tree_map t\\<langle>x\\<rangle>", "@qed"], ["", "end"]]}