{"file_name": "/home/qj213/afp-2021-10-22/thys/Relational_Minimum_Spanning_Trees/Prim.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Relational_Minimum_Spanning_Trees", "problem_names": ["lemma span_tree_split:\n  assumes \"vector r\"\n    shows \"t \\<le> (component g r)\\<^sup>T * (component g r) \\<sqinter> --g \\<longleftrightarrow> (t \\<le> (component g r)\\<^sup>T \\<and> t \\<le> component g r \\<and> t \\<le> --g)\"", "lemma span_tree_component:\n  assumes \"spanning_tree t g r\"\n    shows \"component g r = component t r\"", "lemma prim_vc_1:\n  assumes \"prim_precondition g r\"\n    shows \"prim_spanning_invariant bot r g r\"", "lemma prim_vc_2:\n  assumes \"prim_spanning_invariant t v g r\"\n      and \"v * -v\\<^sup>T \\<sqinter> g \\<noteq> bot\"\n    shows \"prim_spanning_invariant (t \\<squnion> minarc (v * -v\\<^sup>T \\<sqinter> g)) (v \\<squnion> minarc (v * -v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g r \\<and> card { x . regular x \\<and> x \\<le> component g r \\<and> x \\<le> -(v \\<squnion> minarc (v * -v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T } < card { x . regular x \\<and> x \\<le> component g r \\<and> x \\<le> -v\\<^sup>T }\"", "lemma prim_vc_3:\n  assumes \"prim_spanning_invariant t v g r\"\n      and \"v * -v\\<^sup>T \\<sqinter> g = bot\"\n    shows \"spanning_tree t g r\"", "theorem prim_spanning:\n  \"VARS t v e\n  [ prim_precondition g r ]\n  t := bot;\n  v := r;\n  WHILE v * -v\\<^sup>T \\<sqinter> g \\<noteq> bot\n    INV { prim_spanning_invariant t v g r }\n    VAR { card { x . regular x \\<and> x \\<le> component g r \\<sqinter> -v\\<^sup>T } }\n     DO e := minarc (v * -v\\<^sup>T \\<sqinter> g);\n        t := t \\<squnion> e;\n        v := v \\<squnion> e\\<^sup>T * top\n     OD\n  [ spanning_tree t g r ]\"", "lemma prim_exists_spanning:\n  \"prim_precondition g r \\<Longrightarrow> \\<exists>t . spanning_tree t g r\"", "lemma prim_exists_minimal_spanning:\n  assumes \"prim_precondition g r\"\n    shows \"\\<exists>t . minimum_spanning_tree t g r\"", "theorem prim:\n  \"VARS t v e\n  [ prim_precondition g r \\<and> (\\<exists>w . minimum_spanning_tree w g r) ]\n  t := bot;\n  v := r;\n  WHILE v * -v\\<^sup>T \\<sqinter> g \\<noteq> bot\n    INV { prim_invariant t v g r }\n    VAR { card { x . regular x \\<and> x \\<le> component g r \\<sqinter> -v\\<^sup>T } }\n     DO e := minarc (v * -v\\<^sup>T \\<sqinter> g);\n        t := t \\<squnion> e;\n        v := v \\<squnion> e\\<^sup>T * top\n     OD\n  [ minimum_spanning_tree t g r ]\""], "translations": [["", "lemma span_tree_split:\n  assumes \"vector r\"\n    shows \"t \\<le> (component g r)\\<^sup>T * (component g r) \\<sqinter> --g \\<longleftrightarrow> (t \\<le> (component g r)\\<^sup>T \\<and> t \\<le> component g r \\<and> t \\<le> --g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g) =\n    (t \\<le> component g r\\<^sup>T \\<and>\n     t \\<le> component g r \\<and> t \\<le> - - g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (t \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g) =\n    (t \\<le> component g r\\<^sup>T \\<and>\n     t \\<le> component g r \\<and> t \\<le> - - g)", "have \"(component g r)\\<^sup>T * (component g r) = (component g r)\\<^sup>T \\<sqinter> component g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component g r\\<^sup>T * component g r =\n    component g r\\<^sup>T \\<sqinter> component g r", "by (metis assms conv_involutive covector_mult_closed vector_conv_covector vector_covector)"], ["proof (state)\nthis:\n  component g r\\<^sup>T * component g r =\n  component g r\\<^sup>T \\<sqinter> component g r\n\ngoal (1 subgoal):\n 1. (t \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g) =\n    (t \\<le> component g r\\<^sup>T \\<and>\n     t \\<le> component g r \\<and> t \\<le> - - g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  component g r\\<^sup>T * component g r =\n  component g r\\<^sup>T \\<sqinter> component g r\n\ngoal (1 subgoal):\n 1. (t \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g) =\n    (t \\<le> component g r\\<^sup>T \\<and>\n     t \\<le> component g r \\<and> t \\<le> - - g)", "by simp"], ["proof (state)\nthis:\n  (t \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g) =\n  (t \\<le> component g r\\<^sup>T \\<and>\n   t \\<le> component g r \\<and> t \\<le> - - g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma span_tree_component:\n  assumes \"spanning_tree t g r\"\n    shows \"component g r = component t r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component g r = component t r", "using assms"], ["proof (prove)\nusing this:\n  spanning_tree t g r\n\ngoal (1 subgoal):\n 1. component g r = component t r", "by (simp add: antisym mult_right_isotone star_isotone spanning_tree_def)"], ["", "text \\<open>\nWe first show three verification conditions which are used in both correctness proofs.\n\\<close>"], ["", "lemma prim_vc_1:\n  assumes \"prim_precondition g r\"\n    shows \"prim_spanning_invariant bot r g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_spanning_invariant bot r g r", "proof (unfold prim_spanning_invariant_def, intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. prim_precondition g r\n 2. r\\<^sup>T = r\\<^sup>T * bot\\<^sup>\\<star>\n 3. spanning_tree bot (r * r\\<^sup>T \\<sqinter> g) r", "show \"prim_precondition g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_precondition g r", "using assms"], ["proof (prove)\nusing this:\n  prim_precondition g r\n\ngoal (1 subgoal):\n 1. prim_precondition g r", "by simp"], ["proof (state)\nthis:\n  prim_precondition g r\n\ngoal (2 subgoals):\n 1. r\\<^sup>T = r\\<^sup>T * bot\\<^sup>\\<star>\n 2. spanning_tree bot (r * r\\<^sup>T \\<sqinter> g) r", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. r\\<^sup>T = r\\<^sup>T * bot\\<^sup>\\<star>\n 2. spanning_tree bot (r * r\\<^sup>T \\<sqinter> g) r", "show \"r\\<^sup>T = r\\<^sup>T * bot\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T = r\\<^sup>T * bot\\<^sup>\\<star>", "by (simp add: star_absorb)"], ["proof (state)\nthis:\n  r\\<^sup>T = r\\<^sup>T * bot\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. spanning_tree bot (r * r\\<^sup>T \\<sqinter> g) r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. spanning_tree bot (r * r\\<^sup>T \\<sqinter> g) r", "let ?ss = \"r * r\\<^sup>T \\<sqinter> g\""], ["proof (state)\ngoal (1 subgoal):\n 1. spanning_tree bot (r * r\\<^sup>T \\<sqinter> g) r", "show \"spanning_tree bot ?ss r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spanning_tree bot (r * r\\<^sup>T \\<sqinter> g) r", "proof (unfold spanning_tree_def, intro conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. injective bot\n 2. pd_kleene_allegory_class.acyclic bot\n 3. bot\n    \\<le> component (r * r\\<^sup>T \\<sqinter> g) r\\<^sup>T *\n          component (r * r\\<^sup>T \\<sqinter> g) r \\<sqinter>\n          - - (r * r\\<^sup>T \\<sqinter> g)\n 4. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 5. regular bot", "show \"injective bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective bot", "by simp"], ["proof (state)\nthis:\n  injective bot\n\ngoal (4 subgoals):\n 1. pd_kleene_allegory_class.acyclic bot\n 2. bot\n    \\<le> component (r * r\\<^sup>T \\<sqinter> g) r\\<^sup>T *\n          component (r * r\\<^sup>T \\<sqinter> g) r \\<sqinter>\n          - - (r * r\\<^sup>T \\<sqinter> g)\n 3. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 4. regular bot", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. pd_kleene_allegory_class.acyclic bot\n 2. bot\n    \\<le> component (r * r\\<^sup>T \\<sqinter> g) r\\<^sup>T *\n          component (r * r\\<^sup>T \\<sqinter> g) r \\<sqinter>\n          - - (r * r\\<^sup>T \\<sqinter> g)\n 3. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 4. regular bot", "show \"acyclic bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic bot", "by simp"], ["proof (state)\nthis:\n  pd_kleene_allegory_class.acyclic bot\n\ngoal (3 subgoals):\n 1. bot\n    \\<le> component (r * r\\<^sup>T \\<sqinter> g) r\\<^sup>T *\n          component (r * r\\<^sup>T \\<sqinter> g) r \\<sqinter>\n          - - (r * r\\<^sup>T \\<sqinter> g)\n 2. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 3. regular bot", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. bot\n    \\<le> component (r * r\\<^sup>T \\<sqinter> g) r\\<^sup>T *\n          component (r * r\\<^sup>T \\<sqinter> g) r \\<sqinter>\n          - - (r * r\\<^sup>T \\<sqinter> g)\n 2. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 3. regular bot", "show \"bot \\<le> (component ?ss r)\\<^sup>T * (component ?ss r) \\<sqinter> --?ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot\n    \\<le> component (r * r\\<^sup>T \\<sqinter> g) r\\<^sup>T *\n          component (r * r\\<^sup>T \\<sqinter> g) r \\<sqinter>\n          - - (r * r\\<^sup>T \\<sqinter> g)", "by simp"], ["proof (state)\nthis:\n  bot\n  \\<le> component (r * r\\<^sup>T \\<sqinter> g) r\\<^sup>T *\n        component (r * r\\<^sup>T \\<sqinter> g) r \\<sqinter>\n        - - (r * r\\<^sup>T \\<sqinter> g)\n\ngoal (2 subgoals):\n 1. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 2. regular bot", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 2. regular bot", "have \"component ?ss r \\<le> component (r * r\\<^sup>T) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> component (r * r\\<^sup>T) r", "by (simp add: mult_right_isotone star_isotone)"], ["proof (state)\nthis:\n  component (r * r\\<^sup>T \\<sqinter> g) r \\<le> component (r * r\\<^sup>T) r\n\ngoal (2 subgoals):\n 1. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 2. regular bot", "also"], ["proof (state)\nthis:\n  component (r * r\\<^sup>T \\<sqinter> g) r \\<le> component (r * r\\<^sup>T) r\n\ngoal (2 subgoals):\n 1. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 2. regular bot", "have \"... \\<le> r\\<^sup>T * 1\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component (r * r\\<^sup>T) r \\<le> r\\<^sup>T * (1::'a)\\<^sup>\\<star>", "using assms"], ["proof (prove)\nusing this:\n  prim_precondition g r\n\ngoal (1 subgoal):\n 1. component (r * r\\<^sup>T) r \\<le> r\\<^sup>T * (1::'a)\\<^sup>\\<star>", "by (metis inf.eq_iff p_antitone regular_one_closed star_sub_one prim_precondition_def)"], ["proof (state)\nthis:\n  component (r * r\\<^sup>T) r \\<le> r\\<^sup>T * (1::'a)\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 2. regular bot", "also"], ["proof (state)\nthis:\n  component (r * r\\<^sup>T) r \\<le> r\\<^sup>T * (1::'a)\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 2. regular bot", "have \"... = r\\<^sup>T * bot\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T * (1::'a)\\<^sup>\\<star> = r\\<^sup>T * bot\\<^sup>\\<star>", "by (simp add: star.circ_zero star_one)"], ["proof (state)\nthis:\n  r\\<^sup>T * (1::'a)\\<^sup>\\<star> = r\\<^sup>T * bot\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n 2. regular bot", "finally"], ["proof (chain)\npicking this:\n  component (r * r\\<^sup>T \\<sqinter> g) r\n  \\<le> r\\<^sup>T * bot\\<^sup>\\<star>", "show \"component ?ss r \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  component (r * r\\<^sup>T \\<sqinter> g) r\n  \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. component (r * r\\<^sup>T \\<sqinter> g) r\n    \\<le> r\\<^sup>T * bot\\<^sup>\\<star>", "."], ["proof (state)\nthis:\n  component (r * r\\<^sup>T \\<sqinter> g) r\n  \\<le> r\\<^sup>T * bot\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. regular bot", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. regular bot", "show \"regular bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular bot", "by simp"], ["proof (state)\nthis:\n  regular bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spanning_tree bot (r * r\\<^sup>T \\<sqinter> g) r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prim_vc_2:\n  assumes \"prim_spanning_invariant t v g r\"\n      and \"v * -v\\<^sup>T \\<sqinter> g \\<noteq> bot\"\n    shows \"prim_spanning_invariant (t \\<squnion> minarc (v * -v\\<^sup>T \\<sqinter> g)) (v \\<squnion> minarc (v * -v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g r \\<and> card { x . regular x \\<and> x \\<le> component g r \\<and> x \\<le> -(v \\<squnion> minarc (v * -v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T } < card { x . regular x \\<and> x \\<le> component g r \\<and> x \\<le> -v\\<^sup>T }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "let ?vcv = \"v * -v\\<^sup>T \\<sqinter> g\""], ["proof (state)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "let ?e = \"minarc ?vcv\""], ["proof (state)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "let ?t = \"t \\<squnion> ?e\""], ["proof (state)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "let ?v = \"v \\<squnion> ?e\\<^sup>T * top\""], ["proof (state)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "let ?c = \"component g r\""], ["proof (state)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "let ?g = \"--g\""], ["proof (state)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "let ?n1 = \"card { x . regular x \\<and> x \\<le> ?c \\<and> x \\<le> -v\\<^sup>T }\""], ["proof (state)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "let ?n2 = \"card { x . regular x \\<and> x \\<le> ?c \\<and> x \\<le> -?v\\<^sup>T }\""], ["proof (state)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 1: \"regular v \\<and> regular (v * v\\<^sup>T) \\<and> regular (?v * ?v\\<^sup>T) \\<and> regular (top * ?e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular v \\<and>\n    regular (v * v\\<^sup>T) \\<and>\n    regular\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T) \\<and>\n    regular (top * minarc (v * - v\\<^sup>T \\<sqinter> g))", "using assms(1)"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n\ngoal (1 subgoal):\n 1. regular v \\<and>\n    regular (v * v\\<^sup>T) \\<and>\n    regular\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T) \\<and>\n    regular (top * minarc (v * - v\\<^sup>T \\<sqinter> g))", "by (metis prim_spanning_invariant_def spanning_tree_def prim_precondition_def regular_conv_closed regular_closed_star regular_mult_closed conv_involutive regular_closed_top regular_closed_sup minarc_regular)"], ["proof (state)\nthis:\n  regular v \\<and>\n  regular (v * v\\<^sup>T) \\<and>\n  regular\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T) \\<and>\n  regular (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "hence 2: \"t \\<le> v * v\\<^sup>T \\<sqinter> ?g\""], ["proof (prove)\nusing this:\n  regular v \\<and>\n  regular (v * v\\<^sup>T) \\<and>\n  regular\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T) \\<and>\n  regular (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. t \\<le> v * v\\<^sup>T \\<sqinter> - - g", "using assms(1)"], ["proof (prove)\nusing this:\n  regular v \\<and>\n  regular (v * v\\<^sup>T) \\<and>\n  regular\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T) \\<and>\n  regular (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n  prim_spanning_invariant t v g r\n\ngoal (1 subgoal):\n 1. t \\<le> v * v\\<^sup>T \\<sqinter> - - g", "by (metis prim_spanning_invariant_def spanning_tree_def inf_pp_commute inf.boundedE)"], ["proof (state)\nthis:\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "hence 3: \"t \\<le> v * v\\<^sup>T\""], ["proof (prove)\nusing this:\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. t \\<le> v * v\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  t \\<le> v * v\\<^sup>T\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 4: \"t \\<le> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> - - g", "using 2"], ["proof (prove)\nusing this:\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. t \\<le> - - g", "by simp"], ["proof (state)\nthis:\n  t \\<le> - - g\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 5: \"?e \\<le> v * -v\\<^sup>T \\<sqinter> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> v * - v\\<^sup>T \\<sqinter> - - g", "using 1"], ["proof (prove)\nusing this:\n  regular v \\<and>\n  regular (v * v\\<^sup>T) \\<and>\n  regular\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T) \\<and>\n  regular (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> v * - v\\<^sup>T \\<sqinter> - - g", "by (metis minarc_below pp_dist_inf regular_mult_closed regular_closed_p)"], ["proof (state)\nthis:\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> v * - v\\<^sup>T \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "hence 6: \"?e \\<le> v * -v\\<^sup>T\""], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> v * - v\\<^sup>T \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 7: \"vector v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector v", "using assms(1) prim_spanning_invariant_def prim_precondition_def"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n  prim_precondition ?g ?r \\<equiv>\n  ?g = ?g\\<^sup>T \\<and> injective ?r \\<and> vector ?r \\<and> regular ?r\n\ngoal (1 subgoal):\n 1. vector v", "by (simp add: covector_mult_closed vector_conv_covector)"], ["proof (state)\nthis:\n  vector v\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "hence 8: \"?e \\<le> v\""], ["proof (prove)\nusing this:\n  vector v\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v", "using 6"], ["proof (prove)\nusing this:\n  vector v\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v", "by (metis conv_complement inf.boundedE vector_complement_closed vector_covector)"], ["proof (state)\nthis:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 9: \"?e * t = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) * t = bot", "using 3 6 7 et(1)"], ["proof (prove)\nusing this:\n  t \\<le> v * v\\<^sup>T\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n  vector v\n  \\<lbrakk>vector ?v; ?e \\<le> ?v * - ?v\\<^sup>T;\n   ?t \\<le> ?v * ?v\\<^sup>T\\<rbrakk>\n  \\<Longrightarrow> ?e * ?t = bot\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) * t = bot", "by blast"], ["proof (state)\nthis:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) * t = bot\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 10: \"?e * t\\<^sup>T = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) * t\\<^sup>T = bot", "using 3 6 7 et(2)"], ["proof (prove)\nusing this:\n  t \\<le> v * v\\<^sup>T\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n  vector v\n  \\<lbrakk>vector ?v; ?e \\<le> ?v * - ?v\\<^sup>T;\n   ?t \\<le> ?v * ?v\\<^sup>T\\<rbrakk>\n  \\<Longrightarrow> ?e * ?t\\<^sup>T = bot\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) * t\\<^sup>T = bot", "by simp"], ["proof (state)\nthis:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) * t\\<^sup>T = bot\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 11: \"arc ?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc (minarc (v * - v\\<^sup>T \\<sqinter> g))", "using assms(2) minarc_arc"], ["proof (prove)\nusing this:\n  v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n  ?x \\<noteq> bot \\<longrightarrow> arc (minarc ?x)\n\ngoal (1 subgoal):\n 1. arc (minarc (v * - v\\<^sup>T \\<sqinter> g))", "by simp"], ["proof (state)\nthis:\n  arc (minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have \"r\\<^sup>T \\<le> r\\<^sup>T * t\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T \\<le> r\\<^sup>T * t\\<^sup>\\<star>", "by (metis mult_right_isotone order_refl semiring.mult_not_zero star.circ_separate_mult_1 star_absorb)"], ["proof (state)\nthis:\n  r\\<^sup>T \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "hence 12: \"r\\<^sup>T \\<le> v\\<^sup>T\""], ["proof (prove)\nusing this:\n  r\\<^sup>T \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. r\\<^sup>T \\<le> v\\<^sup>T", "using assms(1)"], ["proof (prove)\nusing this:\n  r\\<^sup>T \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n  prim_spanning_invariant t v g r\n\ngoal (1 subgoal):\n 1. r\\<^sup>T \\<le> v\\<^sup>T", "by (simp add: prim_spanning_invariant_def)"], ["proof (state)\nthis:\n  r\\<^sup>T \\<le> v\\<^sup>T\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 13: \"vector r \\<and> injective r \\<and> v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector r \\<and>\n    injective r \\<and> v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star>", "using assms(1) prim_spanning_invariant_def prim_precondition_def minimum_spanning_tree_def spanning_tree_def reachable_restrict"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n  prim_precondition ?g ?r \\<equiv>\n  ?g = ?g\\<^sup>T \\<and> injective ?r \\<and> vector ?r \\<and> regular ?r\n  minimum_spanning_tree ?t ?g ?r \\<equiv>\n  spanning_tree ?t ?g ?r \\<and>\n  (\\<forall>u.\n      spanning_tree u ?g ?r \\<longrightarrow>\n      sum_class.sum (?t \\<sqinter> ?g)\n      \\<le> sum_class.sum (u \\<sqinter> ?g))\n  spanning_tree ?t ?g ?r \\<equiv>\n  forest ?t \\<and>\n  ?t \\<le> component ?g ?r\\<^sup>T * component ?g ?r \\<sqinter>\n           - - ?g \\<and>\n  component ?g ?r \\<le> ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and> regular ?t\n  vector ?r \\<Longrightarrow>\n  ?r\\<^sup>T * ?g\\<^sup>\\<star> =\n  ?r\\<^sup>T *\n  ((?r\\<^sup>T * ?g\\<^sup>\\<star>)\\<^sup>T *\n   (?r\\<^sup>T * ?g\\<^sup>\\<star>) \\<sqinter>\n   ?g)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. vector r \\<and>\n    injective r \\<and> v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  vector r \\<and> injective r \\<and> v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have \"g = g\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = g\\<^sup>T", "using assms(1) prim_invariant_def prim_spanning_invariant_def prim_precondition_def"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  prim_invariant ?t ?v ?g ?r \\<equiv>\n  prim_spanning_invariant ?t ?v ?g ?r \\<and>\n  (\\<exists>w. minimum_spanning_tree w ?g ?r \\<and> ?t \\<le> w)\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n  prim_precondition ?g ?r \\<equiv>\n  ?g = ?g\\<^sup>T \\<and> injective ?r \\<and> vector ?r \\<and> regular ?r\n\ngoal (1 subgoal):\n 1. g = g\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  g = g\\<^sup>T\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "hence 14: \"?g\\<^sup>T = ?g\""], ["proof (prove)\nusing this:\n  g = g\\<^sup>T\n\ngoal (1 subgoal):\n 1. symmetric (- - g)", "using conv_complement"], ["proof (prove)\nusing this:\n  g = g\\<^sup>T\n  (- ?x)\\<^sup>T = - ?x\\<^sup>T\n\ngoal (1 subgoal):\n 1. symmetric (- - g)", "by simp"], ["proof (state)\nthis:\n  symmetric (- - g)\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "show \"prim_spanning_invariant ?t ?v g r \\<and> ?n2 < ?n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g r\n 2. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "show \"prim_spanning_invariant ?t ?v g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g r", "proof (unfold prim_spanning_invariant_def, intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. prim_precondition g r\n 2. (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T =\n    r\\<^sup>T *\n    (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 3. spanning_tree (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r", "show \"prim_precondition g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_precondition g r", "using assms(1) prim_spanning_invariant_def"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n\ngoal (1 subgoal):\n 1. prim_precondition g r", "by simp"], ["proof (state)\nthis:\n  prim_precondition g r\n\ngoal (2 subgoals):\n 1. (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T =\n    r\\<^sup>T *\n    (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 2. spanning_tree (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T =\n    r\\<^sup>T *\n    (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 2. spanning_tree (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r", "show \"?v\\<^sup>T = r\\<^sup>T * ?t\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T =\n    r\\<^sup>T *\n    (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "using assms(1) 6 7 9"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n  vector v\n  minarc (v * - v\\<^sup>T \\<sqinter> g) * t = bot\n\ngoal (1 subgoal):\n 1. (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T =\n    r\\<^sup>T *\n    (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "by (simp add: reachable_inv prim_spanning_invariant_def prim_precondition_def spanning_tree_def)"], ["proof (state)\nthis:\n  (v \\<squnion>\n   minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T =\n  r\\<^sup>T *\n  (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. spanning_tree (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. spanning_tree (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r", "let ?G = \"?v * ?v\\<^sup>T \\<sqinter> g\""], ["proof (state)\ngoal (1 subgoal):\n 1. spanning_tree (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r", "show \"spanning_tree ?t ?G r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spanning_tree (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r", "proof (unfold spanning_tree_def, intro conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. injective (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n 2. pd_kleene_allegory_class.acyclic\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n 3. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r\\<^sup>T *\n          component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r \\<sqinter>\n          - - ((v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n               (v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                top)\\<^sup>T \\<sqinter>\n               g)\n 4. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 5. regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "show \"injective ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "using assms(1) 10 11"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  minarc (v * - v\\<^sup>T \\<sqinter> g) * t\\<^sup>T = bot\n  arc (minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. injective (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "by (simp add: injective_inv prim_spanning_invariant_def spanning_tree_def)"], ["proof (state)\nthis:\n  injective (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (4 subgoals):\n 1. pd_kleene_allegory_class.acyclic\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n 2. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r\\<^sup>T *\n          component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r \\<sqinter>\n          - - ((v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n               (v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                top)\\<^sup>T \\<sqinter>\n               g)\n 3. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 4. regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. pd_kleene_allegory_class.acyclic\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n 2. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r\\<^sup>T *\n          component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r \\<sqinter>\n          - - ((v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n               (v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                top)\\<^sup>T \\<sqinter>\n               g)\n 3. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 4. regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "show \"acyclic ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "using assms(1) 3 6 7 acyclic_inv prim_spanning_invariant_def spanning_tree_def"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  t \\<le> v * v\\<^sup>T\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n  vector v\n  \\<lbrakk>pd_kleene_allegory_class.acyclic ?t; vector ?v;\n   ?e \\<le> ?v * - ?v\\<^sup>T; ?t \\<le> ?v * ?v\\<^sup>T\\<rbrakk>\n  \\<Longrightarrow> pd_kleene_allegory_class.acyclic (?t \\<squnion> ?e)\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n  spanning_tree ?t ?g ?r \\<equiv>\n  forest ?t \\<and>\n  ?t \\<le> component ?g ?r\\<^sup>T * component ?g ?r \\<sqinter>\n           - - ?g \\<and>\n  component ?g ?r \\<le> ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and> regular ?t\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "by simp"], ["proof (state)\nthis:\n  pd_kleene_allegory_class.acyclic\n   (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (3 subgoals):\n 1. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r\\<^sup>T *\n          component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r \\<sqinter>\n          - - ((v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n               (v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                top)\\<^sup>T \\<sqinter>\n               g)\n 2. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 3. regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r\\<^sup>T *\n          component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r \\<sqinter>\n          - - ((v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n               (v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                top)\\<^sup>T \\<sqinter>\n               g)\n 2. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 3. regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "show \"?t \\<le> (component ?G r)\\<^sup>T * (component ?G r) \\<sqinter> --?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r\\<^sup>T *\n          component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r \\<sqinter>\n          - - ((v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n               (v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                top)\\<^sup>T \\<sqinter>\n               g)", "using 1 2 5 7 13 prim_subgraph_inv inf_pp_commute mst_subgraph_inv_2"], ["proof (prove)\nusing this:\n  regular v \\<and>\n  regular (v * v\\<^sup>T) \\<and>\n  regular\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T) \\<and>\n  regular (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> v * - v\\<^sup>T \\<sqinter> - - g\n  vector v\n  vector r \\<and> injective r \\<and> v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star>\n  \\<lbrakk>?e \\<le> ?v * - ?v\\<^sup>T \\<sqinter> ?g;\n   ?t \\<le> ?v * ?v\\<^sup>T \\<sqinter> ?g\\<rbrakk>\n  \\<Longrightarrow> ?t \\<squnion> ?e\n                    \\<le> (?v \\<squnion> ?e\\<^sup>T * top) *\n                          (?v \\<squnion>\n                           ?e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n                          ?g\n  - - (- - ?x \\<sqinter> ?y) = - - ?x \\<sqinter> - - ?y\n  \\<lbrakk>regular (?v * ?v\\<^sup>T);\n   ?t \\<le> ?v * ?v\\<^sup>T \\<sqinter> - - ?g;\n   ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star>;\n   ?e \\<le> ?v * - ?v\\<^sup>T \\<sqinter> - - ?g; vector ?v;\n   regular\n    ((?v \\<squnion> ?e\\<^sup>T * top) *\n     (?v \\<squnion> ?e\\<^sup>T * top)\\<^sup>T)\\<rbrakk>\n  \\<Longrightarrow> ?t \\<squnion> ?e\n                    \\<le> component\n                           ((?v \\<squnion> ?e\\<^sup>T * top) *\n                            (?v \\<squnion>\n                             ?e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n                            ?g)\n                           ?r\\<^sup>T *\n                          component\n                           ((?v \\<squnion> ?e\\<^sup>T * top) *\n                            (?v \\<squnion>\n                             ?e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n                            ?g)\n                           ?r\n\ngoal (1 subgoal):\n 1. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r\\<^sup>T *\n          component\n           ((v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n            (v \\<squnion>\n             minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n             top)\\<^sup>T \\<sqinter>\n            g)\n           r \\<sqinter>\n          - - ((v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n               (v \\<squnion>\n                minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                top)\\<^sup>T \\<sqinter>\n               g)", "by auto"], ["proof (state)\nthis:\n  t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> component\n         ((v \\<squnion>\n           minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n          (v \\<squnion>\n           minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n           top)\\<^sup>T \\<sqinter>\n          g)\n         r\\<^sup>T *\n        component\n         ((v \\<squnion>\n           minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n          (v \\<squnion>\n           minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n           top)\\<^sup>T \\<sqinter>\n          g)\n         r \\<sqinter>\n        - - ((v \\<squnion>\n              minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n             (v \\<squnion>\n              minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n              top)\\<^sup>T \\<sqinter>\n             g)\n\ngoal (2 subgoals):\n 1. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 2. regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 2. regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "show \"component (?v * ?v\\<^sup>T \\<sqinter> g) r \\<le> r\\<^sup>T * ?t\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "have 15: \"r\\<^sup>T * (v * v\\<^sup>T \\<sqinter> ?g)\\<^sup>\\<star> \\<le> r\\<^sup>T * t\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T * (v * v\\<^sup>T \\<sqinter> - - g)\\<^sup>\\<star>\n    \\<le> r\\<^sup>T * t\\<^sup>\\<star>", "using assms(1) 1"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  regular v \\<and>\n  regular (v * v\\<^sup>T) \\<and>\n  regular\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T) \\<and>\n  regular (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. r\\<^sup>T * (v * v\\<^sup>T \\<sqinter> - - g)\\<^sup>\\<star>\n    \\<le> r\\<^sup>T * t\\<^sup>\\<star>", "by (metis prim_spanning_invariant_def spanning_tree_def inf_pp_commute)"], ["proof (state)\nthis:\n  r\\<^sup>T * (v * v\\<^sup>T \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "have \"component (?v * ?v\\<^sup>T \\<sqinter> g) r = r\\<^sup>T * (?v * ?v\\<^sup>T \\<sqinter> ?g)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r =\n    r\\<^sup>T *\n    ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n     (v \\<squnion>\n      minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n      top)\\<^sup>T \\<sqinter>\n     - - g)\\<^sup>\\<star>", "using 1"], ["proof (prove)\nusing this:\n  regular v \\<and>\n  regular (v * v\\<^sup>T) \\<and>\n  regular\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T) \\<and>\n  regular (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r =\n    r\\<^sup>T *\n    ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n     (v \\<squnion>\n      minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n      top)\\<^sup>T \\<sqinter>\n     - - g)\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  component\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T \\<sqinter>\n    g)\n   r =\n  r\\<^sup>T *\n  ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n   (v \\<squnion>\n    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T \\<sqinter>\n   - - g)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  component\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T \\<sqinter>\n    g)\n   r =\n  r\\<^sup>T *\n  ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n   (v \\<squnion>\n    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T \\<sqinter>\n   - - g)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "have \"... \\<le> r\\<^sup>T * ?t\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T *\n    ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n     (v \\<squnion>\n      minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n      top)\\<^sup>T \\<sqinter>\n     - - g)\\<^sup>\\<star>\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "using 2 6 7 11 12 13 14 15"], ["proof (prove)\nusing this:\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n  vector v\n  arc (minarc (v * - v\\<^sup>T \\<sqinter> g))\n  r\\<^sup>T \\<le> v\\<^sup>T\n  vector r \\<and> injective r \\<and> v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star>\n  symmetric (- - g)\n  r\\<^sup>T * (v * v\\<^sup>T \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. r\\<^sup>T *\n    ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n     (v \\<squnion>\n      minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n      top)\\<^sup>T \\<sqinter>\n     - - g)\\<^sup>\\<star>\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "by (metis span_inv)"], ["proof (state)\nthis:\n  r\\<^sup>T *\n  ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n   (v \\<squnion>\n    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T \\<sqinter>\n   - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T *\n        (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  component\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T \\<sqinter>\n    g)\n   r\n  \\<le> r\\<^sup>T *\n        (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  component\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T \\<sqinter>\n    g)\n   r\n  \\<le> r\\<^sup>T *\n        (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. component\n     ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n      (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n       top)\\<^sup>T \\<sqinter>\n      g)\n     r\n    \\<le> r\\<^sup>T *\n          (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "."], ["proof (state)\nthis:\n  component\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T \\<sqinter>\n    g)\n   r\n  \\<le> r\\<^sup>T *\n        (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  component\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T \\<sqinter>\n    g)\n   r\n  \\<le> r\\<^sup>T *\n        (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "show \"regular ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "using assms(1)"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n\ngoal (1 subgoal):\n 1. regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))", "by (metis prim_spanning_invariant_def spanning_tree_def regular_closed_sup minarc_regular)"], ["proof (state)\nthis:\n  regular (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spanning_tree (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T \\<sqinter>\n    g)\n   r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prim_spanning_invariant\n   (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n   (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g r\n\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 16: \"top * ?e \\<le> ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "have \"top * ?e = top * ?e\\<^sup>T * ?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) =\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n    minarc (v * - v\\<^sup>T \\<sqinter> g)", "using 11"], ["proof (prove)\nusing this:\n  arc (minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) =\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n    minarc (v * - v\\<^sup>T \\<sqinter> g)", "by (metis arc_top_edge mult_assoc)"], ["proof (state)\nthis:\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) =\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "also"], ["proof (state)\nthis:\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) =\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "have \"... \\<le> v\\<^sup>T * ?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n    minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> v\\<^sup>T * minarc (v * - v\\<^sup>T \\<sqinter> g)", "using 7 8"], ["proof (prove)\nusing this:\n  vector v\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n    minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> v\\<^sup>T * minarc (v * - v\\<^sup>T \\<sqinter> g)", "by (metis conv_dist_comp conv_isotone mult_left_isotone symmetric_top_closed)"], ["proof (state)\nthis:\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> v\\<^sup>T * minarc (v * - v\\<^sup>T \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "also"], ["proof (state)\nthis:\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> v\\<^sup>T * minarc (v * - v\\<^sup>T \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "have \"... \\<le> v\\<^sup>T * ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sup>T * minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> v\\<^sup>T * - - g", "using 5 mult_right_isotone"], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> v * - v\\<^sup>T \\<sqinter> - - g\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n\ngoal (1 subgoal):\n 1. v\\<^sup>T * minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> v\\<^sup>T * - - g", "by auto"], ["proof (state)\nthis:\n  v\\<^sup>T * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v\\<^sup>T * - - g\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "also"], ["proof (state)\nthis:\n  v\\<^sup>T * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v\\<^sup>T * - - g\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "have \"... = r\\<^sup>T * t\\<^sup>\\<star> * ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sup>T * - - g = r\\<^sup>T * t\\<^sup>\\<star> * - - g", "using 13"], ["proof (prove)\nusing this:\n  vector r \\<and> injective r \\<and> v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. v\\<^sup>T * - - g = r\\<^sup>T * t\\<^sup>\\<star> * - - g", "by simp"], ["proof (state)\nthis:\n  v\\<^sup>T * - - g = r\\<^sup>T * t\\<^sup>\\<star> * - - g\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "also"], ["proof (state)\nthis:\n  v\\<^sup>T * - - g = r\\<^sup>T * t\\<^sup>\\<star> * - - g\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "have \"... \\<le> r\\<^sup>T * ?g\\<^sup>\\<star> * ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T * t\\<^sup>\\<star> * - - g \\<le> component g r * - - g", "using 4"], ["proof (prove)\nusing this:\n  t \\<le> - - g\n\ngoal (1 subgoal):\n 1. r\\<^sup>T * t\\<^sup>\\<star> * - - g \\<le> component g r * - - g", "by (simp add: mult_left_isotone mult_right_isotone star_isotone)"], ["proof (state)\nthis:\n  r\\<^sup>T * t\\<^sup>\\<star> * - - g \\<le> component g r * - - g\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "also"], ["proof (state)\nthis:\n  r\\<^sup>T * t\\<^sup>\\<star> * - - g \\<le> component g r * - - g\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "have \"... \\<le> ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component g r * - - g \\<le> component g r", "by (simp add: comp_associative mult_right_isotone star.right_plus_below_circ)"], ["proof (state)\nthis:\n  component g r * - - g \\<le> component g r\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "finally"], ["proof (chain)\npicking this:\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "show ?thesis"], ["proof (prove)\nusing this:\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r", "by simp"], ["proof (state)\nthis:\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r\n\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 17: \"top * ?e \\<le> -v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> - v\\<^sup>T", "using 6 7"], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n  vector v\n\ngoal (1 subgoal):\n 1. top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> - v\\<^sup>T", "by (simp add: schroeder_4_p vTeT)"], ["proof (state)\nthis:\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 18: \"\\<not> top * ?e \\<le> -(top * ?e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> top * minarc (v * - v\\<^sup>T \\<sqinter> g)\n           \\<le> - (top * minarc (v * - v\\<^sup>T \\<sqinter> g))", "by (metis assms(2) inf.orderE minarc_bot_iff conv_complement_sub_inf inf_p inf_top.left_neutral p_bot symmetric_top_closed vector_top_closed)"], ["proof (state)\nthis:\n  \\<not> top * minarc (v * - v\\<^sup>T \\<sqinter> g)\n         \\<le> - (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "have 19: \"-?v\\<^sup>T = -v\\<^sup>T \\<sqinter> -(top * ?e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (v \\<squnion>\n       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T =\n    - v\\<^sup>T \\<sqinter> - (top * minarc (v * - v\\<^sup>T \\<sqinter> g))", "by (simp add: conv_dist_comp conv_dist_sup)"], ["proof (state)\nthis:\n  - (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T =\n  - v\\<^sup>T \\<sqinter> - (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "hence 20: \"\\<not> top * ?e \\<le> -?v\\<^sup>T\""], ["proof (prove)\nusing this:\n  - (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T =\n  - v\\<^sup>T \\<sqinter> - (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. \\<not> top * minarc (v * - v\\<^sup>T \\<sqinter> g)\n           \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T", "using 18"], ["proof (prove)\nusing this:\n  - (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T =\n  - v\\<^sup>T \\<sqinter> - (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n  \\<not> top * minarc (v * - v\\<^sup>T \\<sqinter> g)\n         \\<le> - (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. \\<not> top * minarc (v * - v\\<^sup>T \\<sqinter> g)\n           \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  \\<not> top * minarc (v * - v\\<^sup>T \\<sqinter> g)\n         \\<le> - (v \\<squnion>\n                  minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                  top)\\<^sup>T\n\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "show \"?n2 < ?n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "apply (rule psubset_card_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     {x. regular x \\<and> x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. {x. regular x \\<and>\n        x \\<le> component g r \\<and>\n        x \\<le> - (v \\<squnion>\n                   minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                   top)\\<^sup>T}\n    \\<subset> {x. regular x \\<and>\n                  x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "using finite_regular"], ["proof (prove)\nusing this:\n  finite {x. regular x}\n\ngoal (2 subgoals):\n 1. finite\n     {x. regular x \\<and> x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. {x. regular x \\<and>\n        x \\<le> component g r \\<and>\n        x \\<le> - (v \\<squnion>\n                   minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                   top)\\<^sup>T}\n    \\<subset> {x. regular x \\<and>\n                  x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. regular x \\<and>\n        x \\<le> component g r \\<and>\n        x \\<le> - (v \\<squnion>\n                   minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                   top)\\<^sup>T}\n    \\<subset> {x. regular x \\<and>\n                  x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "using 1 16 17 19 20"], ["proof (prove)\nusing this:\n  regular v \\<and>\n  regular (v * v\\<^sup>T) \\<and>\n  regular\n   ((v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) *\n    (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T) \\<and>\n  regular (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> component g r\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> - v\\<^sup>T\n  - (v \\<squnion>\n     minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top)\\<^sup>T =\n  - v\\<^sup>T \\<sqinter> - (top * minarc (v * - v\\<^sup>T \\<sqinter> g))\n  \\<not> top * minarc (v * - v\\<^sup>T \\<sqinter> g)\n         \\<le> - (v \\<squnion>\n                  minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                  top)\\<^sup>T\n\ngoal (1 subgoal):\n 1. {x. regular x \\<and>\n        x \\<le> component g r \\<and>\n        x \\<le> - (v \\<squnion>\n                   minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                   top)\\<^sup>T}\n    \\<subset> {x. regular x \\<and>\n                  x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "by auto"], ["proof (state)\nthis:\n  card\n   {x. regular x \\<and>\n       x \\<le> component g r \\<and>\n       x \\<le> - (v \\<squnion>\n                  minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                  top)\\<^sup>T}\n  < card\n     {x. regular x \\<and> x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prim_spanning_invariant\n   (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n   (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n   r \\<and>\n  card\n   {x. regular x \\<and>\n       x \\<le> component g r \\<and>\n       x \\<le> - (v \\<squnion>\n                  minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                  top)\\<^sup>T}\n  < card\n     {x. regular x \\<and> x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prim_vc_3:\n  assumes \"prim_spanning_invariant t v g r\"\n      and \"v * -v\\<^sup>T \\<sqinter> g = bot\"\n    shows \"spanning_tree t g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spanning_tree t g r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spanning_tree t g r", "let ?g = \"--g\""], ["proof (state)\ngoal (1 subgoal):\n 1. spanning_tree t g r", "have 1: \"regular v \\<and> regular (v * v\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular v \\<and> regular (v * v\\<^sup>T)", "using assms(1)"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n\ngoal (1 subgoal):\n 1. regular v \\<and> regular (v * v\\<^sup>T)", "by (metis prim_spanning_invariant_def spanning_tree_def prim_precondition_def regular_conv_closed regular_closed_star regular_mult_closed conv_involutive)"], ["proof (state)\nthis:\n  regular v \\<and> regular (v * v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. spanning_tree t g r", "have 2: \"v * -v\\<^sup>T \\<sqinter> ?g = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * - v\\<^sup>T \\<sqinter> - - g = bot", "using assms(2) pp_inf_bot_iff pp_pp_inf_bot_iff"], ["proof (prove)\nusing this:\n  v * - v\\<^sup>T \\<sqinter> g = bot\n  (?x \\<sqinter> ?y = bot) = (- - ?x \\<sqinter> ?y = bot)\n  (?x \\<sqinter> ?y = bot) = (- - ?x \\<sqinter> - - ?y = bot)\n\ngoal (1 subgoal):\n 1. v * - v\\<^sup>T \\<sqinter> - - g = bot", "by simp"], ["proof (state)\nthis:\n  v * - v\\<^sup>T \\<sqinter> - - g = bot\n\ngoal (1 subgoal):\n 1. spanning_tree t g r", "have 3: \"v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and> vector v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and> vector v", "using assms(1)"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n\ngoal (1 subgoal):\n 1. v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and> vector v", "by (simp add: covector_mult_closed prim_invariant_def prim_spanning_invariant_def vector_conv_covector prim_precondition_def)"], ["proof (state)\nthis:\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and> vector v\n\ngoal (1 subgoal):\n 1. spanning_tree t g r", "have 4: \"t \\<le> v * v\\<^sup>T \\<sqinter> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> v * v\\<^sup>T \\<sqinter> - - g", "using assms(1) 1"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  regular v \\<and> regular (v * v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. t \\<le> v * v\\<^sup>T \\<sqinter> - - g", "by (metis prim_spanning_invariant_def inf_pp_commute spanning_tree_def inf.boundedE)"], ["proof (state)\nthis:\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. spanning_tree t g r", "have \"r\\<^sup>T * (v * v\\<^sup>T \\<sqinter> ?g)\\<^sup>\\<star> \\<le> r\\<^sup>T * t\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T * (v * v\\<^sup>T \\<sqinter> - - g)\\<^sup>\\<star>\n    \\<le> r\\<^sup>T * t\\<^sup>\\<star>", "using assms(1) 1"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  regular v \\<and> regular (v * v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. r\\<^sup>T * (v * v\\<^sup>T \\<sqinter> - - g)\\<^sup>\\<star>\n    \\<le> r\\<^sup>T * t\\<^sup>\\<star>", "by (metis prim_spanning_invariant_def inf_pp_commute spanning_tree_def)"], ["proof (state)\nthis:\n  r\\<^sup>T * (v * v\\<^sup>T \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. spanning_tree t g r", "hence 5: \"component g r = v\\<^sup>T\""], ["proof (prove)\nusing this:\n  r\\<^sup>T * (v * v\\<^sup>T \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. component g r = v\\<^sup>T", "using 1 2 3 4"], ["proof (prove)\nusing this:\n  r\\<^sup>T * (v * v\\<^sup>T \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n  regular v \\<and> regular (v * v\\<^sup>T)\n  v * - v\\<^sup>T \\<sqinter> - - g = bot\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and> vector v\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. component g r = v\\<^sup>T", "by (metis span_post)"], ["proof (state)\nthis:\n  component g r = v\\<^sup>T\n\ngoal (1 subgoal):\n 1. spanning_tree t g r", "have \"regular (v * v\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (v * v\\<^sup>T)", "using assms(1)"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n\ngoal (1 subgoal):\n 1. regular (v * v\\<^sup>T)", "by (metis prim_spanning_invariant_def spanning_tree_def prim_precondition_def regular_conv_closed regular_closed_star regular_mult_closed conv_involutive)"], ["proof (state)\nthis:\n  regular (v * v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. spanning_tree t g r", "hence 6: \"t \\<le> v * v\\<^sup>T \\<sqinter> ?g\""], ["proof (prove)\nusing this:\n  regular (v * v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. t \\<le> v * v\\<^sup>T \\<sqinter> - - g", "by (metis assms(1) prim_spanning_invariant_def spanning_tree_def inf_pp_commute inf.boundedE)"], ["proof (state)\nthis:\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. spanning_tree t g r", "show \"spanning_tree t g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spanning_tree t g r", "apply (unfold spanning_tree_def, intro conjI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. injective t\n 2. pd_kleene_allegory_class.acyclic t\n 3. t \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n 4. component g r \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n 5. regular t", "using assms(1) prim_spanning_invariant_def spanning_tree_def"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n  spanning_tree ?t ?g ?r \\<equiv>\n  forest ?t \\<and>\n  ?t \\<le> component ?g ?r\\<^sup>T * component ?g ?r \\<sqinter>\n           - - ?g \\<and>\n  component ?g ?r \\<le> ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and> regular ?t\n\ngoal (5 subgoals):\n 1. injective t\n 2. pd_kleene_allegory_class.acyclic t\n 3. t \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n 4. component g r \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n 5. regular t", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. pd_kleene_allegory_class.acyclic t\n 2. t \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n 3. component g r \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n 4. regular t", "using assms(1) prim_spanning_invariant_def spanning_tree_def"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n  spanning_tree ?t ?g ?r \\<equiv>\n  forest ?t \\<and>\n  ?t \\<le> component ?g ?r\\<^sup>T * component ?g ?r \\<sqinter>\n           - - ?g \\<and>\n  component ?g ?r \\<le> ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and> regular ?t\n\ngoal (4 subgoals):\n 1. pd_kleene_allegory_class.acyclic t\n 2. t \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n 3. component g r \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n 4. regular t", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. t \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n 2. component g r \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n 3. regular t", "using 5 6"], ["proof (prove)\nusing this:\n  component g r = v\\<^sup>T\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n\ngoal (3 subgoals):\n 1. t \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n 2. component g r \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n 3. regular t", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. component g r \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n 2. regular t", "using assms(1) 5 prim_spanning_invariant_def"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  component g r = v\\<^sup>T\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n\ngoal (2 subgoals):\n 1. component g r \\<le> r\\<^sup>T * t\\<^sup>\\<star>\n 2. regular t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. regular t", "using assms(1) prim_spanning_invariant_def spanning_tree_def"], ["proof (prove)\nusing this:\n  prim_spanning_invariant t v g r\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n  spanning_tree ?t ?g ?r \\<equiv>\n  forest ?t \\<and>\n  ?t \\<le> component ?g ?r\\<^sup>T * component ?g ?r \\<sqinter>\n           - - ?g \\<and>\n  component ?g ?r \\<le> ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and> regular ?t\n\ngoal (1 subgoal):\n 1. regular t", "by simp"], ["proof (state)\nthis:\n  spanning_tree t g r\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following result shows that Prim's algorithm terminates and constructs a spanning tree.\nWe cannot yet show that this is a minimum spanning tree.\n\\<close>"], ["", "theorem prim_spanning:\n  \"VARS t v e\n  [ prim_precondition g r ]\n  t := bot;\n  v := r;\n  WHILE v * -v\\<^sup>T \\<sqinter> g \\<noteq> bot\n    INV { prim_spanning_invariant t v g r }\n    VAR { card { x . regular x \\<and> x \\<le> component g r \\<sqinter> -v\\<^sup>T } }\n     DO e := minarc (v * -v\\<^sup>T \\<sqinter> g);\n        t := t \\<squnion> e;\n        v := v \\<squnion> e\\<^sup>T * top\n     OD\n  [ spanning_tree t g r ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [prim_precondition g r] \n     t := bot;\n     v := r;\n     WHILE v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n      INV {prim_spanning_invariant t v g r} \n      VAR {\\<lambda>(t, v, e).\n              card\n               {x. regular x \\<and>\n                   x \\<le> component g r \\<sqinter> - v\\<^sup>T}} \n      DO e := minarc (v * - v\\<^sup>T \\<sqinter> g);\n         t := t \\<squnion> e; v := v \\<squnion> e\\<^sup>T * top \n      OD \n     [spanning_tree t g r]", "apply vcg_tc_simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. prim_precondition g r \\<Longrightarrow>\n    prim_spanning_invariant bot r g r\n 2. \\<And>t v.\n       prim_spanning_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_spanning_invariant\n        (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 3. \\<And>t v.\n       prim_spanning_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       spanning_tree t g r", "apply (simp add: prim_vc_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_spanning_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_spanning_invariant\n        (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_spanning_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       spanning_tree t g r", "using prim_vc_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>prim_spanning_invariant ?t ?v ?g ?r;\n   ?v * - ?v\\<^sup>T \\<sqinter> ?g \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> prim_spanning_invariant\n                     (?t \\<squnion>\n                      minarc (?v * - ?v\\<^sup>T \\<sqinter> ?g))\n                     (?v \\<squnion>\n                      minarc (?v * - ?v\\<^sup>T \\<sqinter> ?g)\\<^sup>T *\n                      top)\n                     ?g ?r \\<and>\n                    card\n                     {x. regular x \\<and>\n                         x \\<le> component ?g ?r \\<and>\n                         x \\<le> - (?v \\<squnion>\n                                    minarc\n                                     (?v * - ?v\\<^sup>T \\<sqinter>\n?g)\\<^sup>T *\n                                    top)\\<^sup>T}\n                    < card\n                       {x. regular x \\<and>\n                           x \\<le> component ?g ?r \\<and>\n                           x \\<le> - ?v\\<^sup>T}\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_spanning_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_spanning_invariant\n        (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_spanning_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       spanning_tree t g r", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_spanning_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       spanning_tree t g r", "using prim_vc_3"], ["proof (prove)\nusing this:\n  \\<lbrakk>prim_spanning_invariant ?t ?v ?g ?r;\n   ?v * - ?v\\<^sup>T \\<sqinter> ?g = bot\\<rbrakk>\n  \\<Longrightarrow> spanning_tree ?t ?g ?r\n\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_spanning_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       spanning_tree t g r", "by auto"], ["", "text \\<open>\nBecause we have shown total correctness, we conclude that a spanning tree exists.\n\\<close>"], ["", "lemma prim_exists_spanning:\n  \"prim_precondition g r \\<Longrightarrow> \\<exists>t . spanning_tree t g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_precondition g r \\<Longrightarrow> \\<exists>t. spanning_tree t g r", "using tc_extract_function prim_spanning"], ["proof (prove)\nusing this:\n  [?p] \n   ?c \n   [?q] \\<Longrightarrow>\n  \\<exists>f. \\<forall>s. s \\<in> ?p \\<longrightarrow> f s \\<in> ?q\n  [prim_precondition ?g ?r] \n   t := bot;\n   v := ?r;\n   WHILE v * - v\\<^sup>T \\<sqinter> ?g \\<noteq> bot\n    INV {prim_spanning_invariant t v ?g ?r} \n    VAR {\\<lambda>(t, v, e).\n            card\n             {x. regular x \\<and>\n                 x \\<le> component ?g ?r \\<sqinter> - v\\<^sup>T}} \n    DO e := minarc (v * - v\\<^sup>T \\<sqinter> ?g);\n       t := t \\<squnion> e; v := v \\<squnion> e\\<^sup>T * top \n    OD \n   [spanning_tree t ?g ?r]\n\ngoal (1 subgoal):\n 1. prim_precondition g r \\<Longrightarrow> \\<exists>t. spanning_tree t g r", "by blast"], ["", "text \\<open>\nThis implies that a minimum spanning tree exists, which is used in the subsequent correctness proof.\n\\<close>"], ["", "lemma prim_exists_minimal_spanning:\n  assumes \"prim_precondition g r\"\n    shows \"\\<exists>t . minimum_spanning_tree t g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. minimum_spanning_tree t g r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t. minimum_spanning_tree t g r", "let ?s = \"{ t . spanning_tree t g r }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t. minimum_spanning_tree t g r", "have \"\\<exists>m\\<in>?s . \\<forall>z\\<in>?s . sum (m \\<sqinter> g) \\<le> sum (z \\<sqinter> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>{t. spanning_tree t g r}.\n       \\<forall>z\\<in>{t. spanning_tree t g r}.\n          sum_class.sum (m \\<sqinter> g)\n          \\<le> sum_class.sum (z \\<sqinter> g)", "apply (rule finite_set_minimal)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {t. spanning_tree t g r}\n 2. {t. spanning_tree t g r} \\<noteq> {}\n 3. \\<forall>x\\<in>{t. spanning_tree t g r}.\n       \\<forall>y\\<in>{t. spanning_tree t g r}.\n          sum_class.sum (x \\<sqinter> g)\n          \\<le> sum_class.sum (y \\<sqinter> g) \\<or>\n          sum_class.sum (y \\<sqinter> g)\n          \\<le> sum_class.sum (x \\<sqinter> g)", "using finite_regular spanning_tree_def"], ["proof (prove)\nusing this:\n  finite {x. regular x}\n  spanning_tree ?t ?g ?r \\<equiv>\n  forest ?t \\<and>\n  ?t \\<le> component ?g ?r\\<^sup>T * component ?g ?r \\<sqinter>\n           - - ?g \\<and>\n  component ?g ?r \\<le> ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and> regular ?t\n\ngoal (3 subgoals):\n 1. finite {t. spanning_tree t g r}\n 2. {t. spanning_tree t g r} \\<noteq> {}\n 3. \\<forall>x\\<in>{t. spanning_tree t g r}.\n       \\<forall>y\\<in>{t. spanning_tree t g r}.\n          sum_class.sum (x \\<sqinter> g)\n          \\<le> sum_class.sum (y \\<sqinter> g) \\<or>\n          sum_class.sum (y \\<sqinter> g)\n          \\<le> sum_class.sum (x \\<sqinter> g)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. {t. spanning_tree t g r} \\<noteq> {}\n 2. \\<forall>x\\<in>{t. spanning_tree t g r}.\n       \\<forall>y\\<in>{t. spanning_tree t g r}.\n          sum_class.sum (x \\<sqinter> g)\n          \\<le> sum_class.sum (y \\<sqinter> g) \\<or>\n          sum_class.sum (y \\<sqinter> g)\n          \\<le> sum_class.sum (x \\<sqinter> g)", "using assms prim_exists_spanning"], ["proof (prove)\nusing this:\n  prim_precondition g r\n  prim_precondition ?g ?r \\<Longrightarrow>\n  \\<exists>t. spanning_tree t ?g ?r\n\ngoal (2 subgoals):\n 1. {t. spanning_tree t g r} \\<noteq> {}\n 2. \\<forall>x\\<in>{t. spanning_tree t g r}.\n       \\<forall>y\\<in>{t. spanning_tree t g r}.\n          sum_class.sum (x \\<sqinter> g)\n          \\<le> sum_class.sum (y \\<sqinter> g) \\<or>\n          sum_class.sum (y \\<sqinter> g)\n          \\<le> sum_class.sum (x \\<sqinter> g)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{t. spanning_tree t g r}.\n       \\<forall>y\\<in>{t. spanning_tree t g r}.\n          sum_class.sum (x \\<sqinter> g)\n          \\<le> sum_class.sum (y \\<sqinter> g) \\<or>\n          sum_class.sum (y \\<sqinter> g)\n          \\<le> sum_class.sum (x \\<sqinter> g)", "using sum_linear"], ["proof (prove)\nusing this:\n  sum_class.sum ?x \\<le> sum_class.sum ?y \\<or>\n  sum_class.sum ?y \\<le> sum_class.sum ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{t. spanning_tree t g r}.\n       \\<forall>y\\<in>{t. spanning_tree t g r}.\n          sum_class.sum (x \\<sqinter> g)\n          \\<le> sum_class.sum (y \\<sqinter> g) \\<or>\n          sum_class.sum (y \\<sqinter> g)\n          \\<le> sum_class.sum (x \\<sqinter> g)", "by simp"], ["proof (state)\nthis:\n  \\<exists>m\\<in>{t. spanning_tree t g r}.\n     \\<forall>z\\<in>{t. spanning_tree t g r}.\n        sum_class.sum (m \\<sqinter> g) \\<le> sum_class.sum (z \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. \\<exists>t. minimum_spanning_tree t g r", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>{t. spanning_tree t g r}.\n     \\<forall>z\\<in>{t. spanning_tree t g r}.\n        sum_class.sum (m \\<sqinter> g) \\<le> sum_class.sum (z \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. \\<exists>t. minimum_spanning_tree t g r", "using minimum_spanning_tree_def"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>{t. spanning_tree t g r}.\n     \\<forall>z\\<in>{t. spanning_tree t g r}.\n        sum_class.sum (m \\<sqinter> g) \\<le> sum_class.sum (z \\<sqinter> g)\n  minimum_spanning_tree ?t ?g ?r \\<equiv>\n  spanning_tree ?t ?g ?r \\<and>\n  (\\<forall>u.\n      spanning_tree u ?g ?r \\<longrightarrow>\n      sum_class.sum (?t \\<sqinter> ?g)\n      \\<le> sum_class.sum (u \\<sqinter> ?g))\n\ngoal (1 subgoal):\n 1. \\<exists>t. minimum_spanning_tree t g r", "by simp"], ["proof (state)\nthis:\n  \\<exists>t. minimum_spanning_tree t g r\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nPrim's minimum spanning tree algorithm terminates and is correct.\nThis is the same algorithm that is used in the previous correctness proof, with the same precondition and variant, but with a different invariant and postcondition.\n\\<close>"], ["", "theorem prim:\n  \"VARS t v e\n  [ prim_precondition g r \\<and> (\\<exists>w . minimum_spanning_tree w g r) ]\n  t := bot;\n  v := r;\n  WHILE v * -v\\<^sup>T \\<sqinter> g \\<noteq> bot\n    INV { prim_invariant t v g r }\n    VAR { card { x . regular x \\<and> x \\<le> component g r \\<sqinter> -v\\<^sup>T } }\n     DO e := minarc (v * -v\\<^sup>T \\<sqinter> g);\n        t := t \\<squnion> e;\n        v := v \\<squnion> e\\<^sup>T * top\n     OD\n  [ minimum_spanning_tree t g r ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [prim_precondition g r \\<and>\n     (\\<exists>w. minimum_spanning_tree w g r)] \n     t := bot;\n     v := r;\n     WHILE v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n      INV {prim_invariant t v g r} \n      VAR {\\<lambda>(t, v, e).\n              card\n               {x. regular x \\<and>\n                   x \\<le> component g r \\<sqinter> - v\\<^sup>T}} \n      DO e := minarc (v * - v\\<^sup>T \\<sqinter> g);\n         t := t \\<squnion> e; v := v \\<squnion> e\\<^sup>T * top \n      OD \n     [minimum_spanning_tree t g r]", "proof vcg_tc_simp"], ["proof (state)\ngoal (3 subgoals):\n 1. prim_precondition g r \\<and>\n    (\\<exists>w. minimum_spanning_tree w g r) \\<Longrightarrow>\n    prim_invariant bot r g r\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 3. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "assume \"prim_precondition g r \\<and> (\\<exists>w . minimum_spanning_tree w g r)\""], ["proof (state)\nthis:\n  prim_precondition g r \\<and> (\\<exists>w. minimum_spanning_tree w g r)\n\ngoal (3 subgoals):\n 1. prim_precondition g r \\<and>\n    (\\<exists>w. minimum_spanning_tree w g r) \\<Longrightarrow>\n    prim_invariant bot r g r\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 3. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "thus \"prim_invariant bot r g r\""], ["proof (prove)\nusing this:\n  prim_precondition g r \\<and> (\\<exists>w. minimum_spanning_tree w g r)\n\ngoal (1 subgoal):\n 1. prim_invariant bot r g r", "using prim_invariant_def prim_vc_1"], ["proof (prove)\nusing this:\n  prim_precondition g r \\<and> (\\<exists>w. minimum_spanning_tree w g r)\n  prim_invariant ?t ?v ?g ?r \\<equiv>\n  prim_spanning_invariant ?t ?v ?g ?r \\<and>\n  (\\<exists>w. minimum_spanning_tree w ?g ?r \\<and> ?t \\<le> w)\n  prim_precondition ?g ?r \\<Longrightarrow>\n  prim_spanning_invariant bot ?r ?g ?r\n\ngoal (1 subgoal):\n 1. prim_invariant bot r g r", "by simp"], ["proof (state)\nthis:\n  prim_invariant bot r g r\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "fix t v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "let ?vcv = \"v * -v\\<^sup>T \\<sqinter> g\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "let ?vv = \"v * v\\<^sup>T \\<sqinter> g\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "let ?e = \"minarc ?vcv\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "let ?t = \"t \\<squnion> ?e\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "let ?v = \"v \\<squnion> ?e\\<^sup>T * top\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "let ?c = \"component g r\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "let ?g = \"--g\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "let ?n1 = \"card { x . regular x \\<and> x \\<le> ?c \\<and> x \\<le> -v\\<^sup>T }\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "let ?n2 = \"card { x . regular x \\<and> x \\<le> ?c \\<and> x \\<le> -?v\\<^sup>T }\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "assume 1: \"prim_invariant t v g r \\<and> ?vcv \\<noteq> bot\""], ["proof (state)\nthis:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "hence 2: \"regular v \\<and> regular (v * v\\<^sup>T)\""], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n\ngoal (1 subgoal):\n 1. regular v \\<and> regular (v * v\\<^sup>T)", "by (metis (no_types, hide_lams) prim_invariant_def prim_spanning_invariant_def spanning_tree_def prim_precondition_def regular_conv_closed regular_closed_star regular_mult_closed conv_involutive)"], ["proof (state)\nthis:\n  regular v \\<and> regular (v * v\\<^sup>T)\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "have 3: \"t \\<le> v * v\\<^sup>T \\<sqinter> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> v * v\\<^sup>T \\<sqinter> - - g", "using 1 2"], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n  regular v \\<and> regular (v * v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. t \\<le> v * v\\<^sup>T \\<sqinter> - - g", "by (metis (no_types, hide_lams) prim_invariant_def prim_spanning_invariant_def spanning_tree_def inf_pp_commute inf.boundedE)"], ["proof (state)\nthis:\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "hence 4: \"t \\<le> v * v\\<^sup>T\""], ["proof (prove)\nusing this:\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. t \\<le> v * v\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  t \\<le> v * v\\<^sup>T\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "have 5: \"t \\<le> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> - - g", "using 3"], ["proof (prove)\nusing this:\n  t \\<le> v * v\\<^sup>T \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. t \\<le> - - g", "by simp"], ["proof (state)\nthis:\n  t \\<le> - - g\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "have 6: \"?e \\<le> v * -v\\<^sup>T \\<sqinter> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> v * - v\\<^sup>T \\<sqinter> - - g", "using 2"], ["proof (prove)\nusing this:\n  regular v \\<and> regular (v * v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> v * - v\\<^sup>T \\<sqinter> - - g", "by (metis minarc_below pp_dist_inf regular_mult_closed regular_closed_p)"], ["proof (state)\nthis:\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> v * - v\\<^sup>T \\<sqinter> - - g\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "hence 7: \"?e \\<le> v * -v\\<^sup>T\""], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> v * - v\\<^sup>T \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "have 8: \"vector v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector v", "using 1 prim_invariant_def prim_spanning_invariant_def prim_precondition_def"], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n  prim_invariant ?t ?v ?g ?r \\<equiv>\n  prim_spanning_invariant ?t ?v ?g ?r \\<and>\n  (\\<exists>w. minimum_spanning_tree w ?g ?r \\<and> ?t \\<le> w)\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n  prim_precondition ?g ?r \\<equiv>\n  ?g = ?g\\<^sup>T \\<and> injective ?r \\<and> vector ?r \\<and> regular ?r\n\ngoal (1 subgoal):\n 1. vector v", "by (simp add: covector_mult_closed vector_conv_covector)"], ["proof (state)\nthis:\n  vector v\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "have 9: \"arc ?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc (minarc (v * - v\\<^sup>T \\<sqinter> g))", "using 1 minarc_arc"], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n  ?x \\<noteq> bot \\<longrightarrow> arc (minarc ?x)\n\ngoal (1 subgoal):\n 1. arc (minarc (v * - v\\<^sup>T \\<sqinter> g))", "by simp"], ["proof (state)\nthis:\n  arc (minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "from 1"], ["proof (chain)\npicking this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot", "obtain w where 10: \"minimum_spanning_tree w g r \\<and> t \\<le> w\""], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        minimum_spanning_tree w g r \\<and> t \\<le> w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prim_invariant_def)"], ["proof (state)\nthis:\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "hence 11: \"vector r \\<and> injective r \\<and> v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and> forest w \\<and> t \\<le> w \\<and> w \\<le> ?c\\<^sup>T * ?c \\<sqinter> ?g \\<and> r\\<^sup>T * (?c\\<^sup>T * ?c \\<sqinter> ?g)\\<^sup>\\<star> \\<le> r\\<^sup>T * w\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n\ngoal (1 subgoal):\n 1. vector r \\<and>\n    injective r \\<and>\n    v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n    forest w \\<and>\n    t \\<le> w \\<and>\n    w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n    r\\<^sup>T *\n    (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n    \\<le> r\\<^sup>T * w\\<^sup>\\<star>", "using 1 2 prim_invariant_def prim_spanning_invariant_def prim_precondition_def minimum_spanning_tree_def spanning_tree_def reachable_restrict"], ["proof (prove)\nusing this:\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n  regular v \\<and> regular (v * v\\<^sup>T)\n  prim_invariant ?t ?v ?g ?r \\<equiv>\n  prim_spanning_invariant ?t ?v ?g ?r \\<and>\n  (\\<exists>w. minimum_spanning_tree w ?g ?r \\<and> ?t \\<le> w)\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n  prim_precondition ?g ?r \\<equiv>\n  ?g = ?g\\<^sup>T \\<and> injective ?r \\<and> vector ?r \\<and> regular ?r\n  minimum_spanning_tree ?t ?g ?r \\<equiv>\n  spanning_tree ?t ?g ?r \\<and>\n  (\\<forall>u.\n      spanning_tree u ?g ?r \\<longrightarrow>\n      sum_class.sum (?t \\<sqinter> ?g)\n      \\<le> sum_class.sum (u \\<sqinter> ?g))\n  spanning_tree ?t ?g ?r \\<equiv>\n  forest ?t \\<and>\n  ?t \\<le> component ?g ?r\\<^sup>T * component ?g ?r \\<sqinter>\n           - - ?g \\<and>\n  component ?g ?r \\<le> ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and> regular ?t\n  vector ?r \\<Longrightarrow>\n  ?r\\<^sup>T * ?g\\<^sup>\\<star> =\n  ?r\\<^sup>T *\n  ((?r\\<^sup>T * ?g\\<^sup>\\<star>)\\<^sup>T *\n   (?r\\<^sup>T * ?g\\<^sup>\\<star>) \\<sqinter>\n   ?g)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. vector r \\<and>\n    injective r \\<and>\n    v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n    forest w \\<and>\n    t \\<le> w \\<and>\n    w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n    r\\<^sup>T *\n    (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n    \\<le> r\\<^sup>T * w\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "hence 12: \"w * v \\<le> v\""], ["proof (prove)\nusing this:\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. w * v \\<le> v", "using predecessors_reachable reachable_restrict"], ["proof (prove)\nusing this:\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n  \\<lbrakk>vector ?r; injective ?r;\n   ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star>; forest ?w; ?t \\<le> ?w;\n   ?w \\<le> (?r\\<^sup>T * ?g\\<^sup>\\<star>)\\<^sup>T *\n            (?r\\<^sup>T * ?g\\<^sup>\\<star>) \\<sqinter>\n            ?g;\n   ?r\\<^sup>T * ?g\\<^sup>\\<star>\n   \\<le> ?r\\<^sup>T * ?w\\<^sup>\\<star>\\<rbrakk>\n  \\<Longrightarrow> ?w * ?v \\<le> ?v\n  vector ?r \\<Longrightarrow>\n  ?r\\<^sup>T * ?g\\<^sup>\\<star> =\n  ?r\\<^sup>T *\n  ((?r\\<^sup>T * ?g\\<^sup>\\<star>)\\<^sup>T *\n   (?r\\<^sup>T * ?g\\<^sup>\\<star>) \\<sqinter>\n   ?g)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. w * v \\<le> v", "by auto"], ["proof (state)\nthis:\n  w * v \\<le> v\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "have 13: \"g = g\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = g\\<^sup>T", "using 1 prim_invariant_def prim_spanning_invariant_def prim_precondition_def"], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n  prim_invariant ?t ?v ?g ?r \\<equiv>\n  prim_spanning_invariant ?t ?v ?g ?r \\<and>\n  (\\<exists>w. minimum_spanning_tree w ?g ?r \\<and> ?t \\<le> w)\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n  prim_precondition ?g ?r \\<equiv>\n  ?g = ?g\\<^sup>T \\<and> injective ?r \\<and> vector ?r \\<and> regular ?r\n\ngoal (1 subgoal):\n 1. g = g\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  g = g\\<^sup>T\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "hence 14: \"?g\\<^sup>T = ?g\""], ["proof (prove)\nusing this:\n  g = g\\<^sup>T\n\ngoal (1 subgoal):\n 1. symmetric (- - g)", "using conv_complement"], ["proof (prove)\nusing this:\n  g = g\\<^sup>T\n  (- ?x)\\<^sup>T = - ?x\\<^sup>T\n\ngoal (1 subgoal):\n 1. symmetric (- - g)", "by simp"], ["proof (state)\nthis:\n  symmetric (- - g)\n\ngoal (2 subgoals):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot \\<Longrightarrow>\n       prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n        (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n        r \\<and>\n       card\n        {x. regular x \\<and>\n            x \\<le> component g r \\<and>\n            x \\<le> - (v \\<squnion>\n                       minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                       top)\\<^sup>T}\n       < card\n          {x. regular x \\<and>\n              x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n 2. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "show \"prim_invariant ?t ?v g r \\<and> ?n2 < ?n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n     r \\<and>\n    card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "proof (unfold prim_invariant_def, intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g r\n 2. \\<exists>w.\n       minimum_spanning_tree w g r \\<and>\n       t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> w\n 3. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "show \"prim_spanning_invariant ?t ?v g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g r", "using 1 prim_invariant_def prim_vc_2"], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n  prim_invariant ?t ?v ?g ?r \\<equiv>\n  prim_spanning_invariant ?t ?v ?g ?r \\<and>\n  (\\<exists>w. minimum_spanning_tree w ?g ?r \\<and> ?t \\<le> w)\n  \\<lbrakk>prim_spanning_invariant ?t ?v ?g ?r;\n   ?v * - ?v\\<^sup>T \\<sqinter> ?g \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> prim_spanning_invariant\n                     (?t \\<squnion>\n                      minarc (?v * - ?v\\<^sup>T \\<sqinter> ?g))\n                     (?v \\<squnion>\n                      minarc (?v * - ?v\\<^sup>T \\<sqinter> ?g)\\<^sup>T *\n                      top)\n                     ?g ?r \\<and>\n                    card\n                     {x. regular x \\<and>\n                         x \\<le> component ?g ?r \\<and>\n                         x \\<le> - (?v \\<squnion>\n                                    minarc\n                                     (?v * - ?v\\<^sup>T \\<sqinter>\n?g)\\<^sup>T *\n                                    top)\\<^sup>T}\n                    < card\n                       {x. regular x \\<and>\n                           x \\<le> component ?g ?r \\<and>\n                           x \\<le> - ?v\\<^sup>T}\n\ngoal (1 subgoal):\n 1. prim_spanning_invariant\n     (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n     (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g r", "by blast"], ["proof (state)\nthis:\n  prim_spanning_invariant\n   (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n   (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g r\n\ngoal (2 subgoals):\n 1. \\<exists>w.\n       minimum_spanning_tree w g r \\<and>\n       t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> w\n 2. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>w.\n       minimum_spanning_tree w g r \\<and>\n       t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> w\n 2. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "show \"\\<exists>w . minimum_spanning_tree w g r \\<and> ?t \\<le> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w.\n       minimum_spanning_tree w g r \\<and>\n       t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> w", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. minimum_spanning_tree ?w g r \\<and>\n    t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> ?w", "let ?f = \"w \\<sqinter> v * -v\\<^sup>T \\<sqinter> top * ?e * w\\<^sup>T\\<^sup>\\<star>\""], ["proof (state)\ngoal (1 subgoal):\n 1. minimum_spanning_tree ?w g r \\<and>\n    t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> ?w", "let ?p = \"w \\<sqinter> -v * -v\\<^sup>T \\<sqinter> top * ?e * w\\<^sup>T\\<^sup>\\<star>\""], ["proof (state)\ngoal (1 subgoal):\n 1. minimum_spanning_tree ?w g r \\<and>\n    t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> ?w", "let ?fp = \"w \\<sqinter> -v\\<^sup>T \\<sqinter> top * ?e * w\\<^sup>T\\<^sup>\\<star>\""], ["proof (state)\ngoal (1 subgoal):\n 1. minimum_spanning_tree ?w g r \\<and>\n    t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> ?w", "let ?w = \"(w \\<sqinter> -?fp) \\<squnion> ?p\\<^sup>T \\<squnion> ?e\""], ["proof (state)\ngoal (1 subgoal):\n 1. minimum_spanning_tree ?w g r \\<and>\n    t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> ?w", "have 15: \"regular ?f \\<and> regular ?fp \\<and> regular ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star>) \\<and>\n    regular (prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) \\<and>\n    regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "using 2 10"], ["proof (prove)\nusing this:\n  regular v \\<and> regular (v * v\\<^sup>T)\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n\ngoal (1 subgoal):\n 1. regular\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star>) \\<and>\n    regular (prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) \\<and>\n    regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "by (metis regular_conv_closed regular_closed_star regular_mult_closed regular_closed_top regular_closed_inf regular_closed_sup minarc_regular minimum_spanning_tree_def spanning_tree_def)"], ["proof (state)\nthis:\n  regular\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star>) \\<and>\n  regular (prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) \\<and>\n  regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n\ngoal (1 subgoal):\n 1. minimum_spanning_tree ?w g r \\<and>\n    t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> ?w", "show \"minimum_spanning_tree ?w g r \\<and> ?t \\<le> ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimum_spanning_tree\n     (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) g r \\<and>\n    t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))", "proof (intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. minimum_spanning_tree\n     (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) g r\n 2. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))", "show \"minimum_spanning_tree ?w g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimum_spanning_tree\n     (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) g r", "proof (unfold minimum_spanning_tree_def, intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. spanning_tree (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) g r\n 2. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "show \"spanning_tree ?w g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spanning_tree (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) g r", "proof (unfold spanning_tree_def, intro conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. injective (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n 2. pd_kleene_allegory_class.acyclic\n     (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n 3. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n 4. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 5. regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "show \"injective ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "using 7 8 9 11 exchange_injective"], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n  vector v\n  arc (minarc (v * - v\\<^sup>T \\<sqinter> g))\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n  \\<lbrakk>arc ?e; ?e \\<le> ?v * - ?v\\<^sup>T; forest ?w; vector ?v\\<rbrakk>\n  \\<Longrightarrow> injective (prim_W ?w ?v ?e)\n\ngoal (1 subgoal):\n 1. injective (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "by blast"], ["proof (state)\nthis:\n  injective (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n\ngoal (4 subgoals):\n 1. pd_kleene_allegory_class.acyclic\n     (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n 2. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n 3. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 4. regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. pd_kleene_allegory_class.acyclic\n     (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n 2. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n 3. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 4. regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "show \"acyclic ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic\n     (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "using 7 8 11 12 exchange_acyclic"], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n  vector v\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n  w * v \\<le> v\n  \\<lbrakk>vector ?v; ?e \\<le> ?v * - ?v\\<^sup>T; ?w * ?v \\<le> ?v;\n   pd_kleene_allegory_class.acyclic ?w\\<rbrakk>\n  \\<Longrightarrow> pd_kleene_allegory_class.acyclic (prim_W ?w ?v ?e)\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic\n     (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "by blast"], ["proof (state)\nthis:\n  pd_kleene_allegory_class.acyclic\n   (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n\ngoal (3 subgoals):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n 2. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 3. regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n 2. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 3. regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "show \"?w \\<le> ?c\\<^sup>T * ?c \\<sqinter> --g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "have 16: \"w \\<sqinter> -?fp \\<le> ?c\\<^sup>T * ?c \\<sqinter> --g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<sqinter> - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "using 10"], ["proof (prove)\nusing this:\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n\ngoal (1 subgoal):\n 1. w \\<sqinter> - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "by (simp add: le_infI1 minimum_spanning_tree_def spanning_tree_def)"], ["proof (state)\nthis:\n  w \\<sqinter> - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n  \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "have \"?p\\<^sup>T \\<le> w\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T\n    \\<le> w\\<^sup>T", "by (simp add: conv_isotone inf.sup_monoid.add_assoc)"], ["proof (state)\nthis:\n  prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<le> w\\<^sup>T\n\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "also"], ["proof (state)\nthis:\n  prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<le> w\\<^sup>T\n\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "have \"... \\<le> (?c\\<^sup>T * ?c \\<sqinter> --g)\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w\\<^sup>T\n    \\<le> (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>T", "using 11 conv_order"], ["proof (prove)\nusing this:\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. w\\<^sup>T\n    \\<le> (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  w\\<^sup>T\n  \\<le> (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>T\n\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "also"], ["proof (state)\nthis:\n  w\\<^sup>T\n  \\<le> (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>T\n\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "have \"... = ?c\\<^sup>T * ?c \\<sqinter> --g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric (component g r\\<^sup>T * component g r \\<sqinter> - - g)", "using 2 14 conv_dist_comp conv_dist_inf"], ["proof (prove)\nusing this:\n  regular v \\<and> regular (v * v\\<^sup>T)\n  symmetric (- - g)\n  (?x * ?y)\\<^sup>T = ?y\\<^sup>T * ?x\\<^sup>T\n  (?x \\<sqinter> ?y)\\<^sup>T = ?x\\<^sup>T \\<sqinter> ?y\\<^sup>T\n\ngoal (1 subgoal):\n 1. symmetric (component g r\\<^sup>T * component g r \\<sqinter> - - g)", "by simp"], ["proof (state)\nthis:\n  symmetric (component g r\\<^sup>T * component g r \\<sqinter> - - g)\n\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "finally"], ["proof (chain)\npicking this:\n  prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T\n  \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "have 17: \"?p\\<^sup>T \\<le> ?c\\<^sup>T * ?c \\<sqinter> --g\""], ["proof (prove)\nusing this:\n  prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T\n  \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "."], ["proof (state)\nthis:\n  prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T\n  \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "have \"?e \\<le> ?c\\<^sup>T * ?c \\<sqinter> ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "using 5 6 11 mst_subgraph_inv"], ["proof (prove)\nusing this:\n  t \\<le> - - g\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> v * - v\\<^sup>T \\<sqinter> - - g\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n  \\<lbrakk>?e \\<le> ?v * - ?v\\<^sup>T \\<sqinter> ?g; ?t \\<le> ?g;\n   ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star>\\<rbrakk>\n  \\<Longrightarrow> ?e \\<le> (?r\\<^sup>T * ?g\\<^sup>\\<star>)\\<^sup>T *\n                             (?r\\<^sup>T * ?g\\<^sup>\\<star>) \\<sqinter>\n                             ?g\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "by auto"], ["proof (state)\nthis:\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "thus ?thesis"], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "using 16 17"], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n  w \\<sqinter> - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n  \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n  prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T\n  \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n    \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g", "by simp"], ["proof (state)\nthis:\n  prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n  \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n  \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g\n\ngoal (2 subgoals):\n 1. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 2. regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n 2. regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "show \"?c \\<le> r\\<^sup>T * ?w\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "have \"?c \\<le> r\\<^sup>T * w\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component g r \\<le> r\\<^sup>T * w\\<^sup>\\<star>", "using 10 minimum_spanning_tree_def spanning_tree_def"], ["proof (prove)\nusing this:\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n  minimum_spanning_tree ?t ?g ?r \\<equiv>\n  spanning_tree ?t ?g ?r \\<and>\n  (\\<forall>u.\n      spanning_tree u ?g ?r \\<longrightarrow>\n      sum_class.sum (?t \\<sqinter> ?g)\n      \\<le> sum_class.sum (u \\<sqinter> ?g))\n  spanning_tree ?t ?g ?r \\<equiv>\n  forest ?t \\<and>\n  ?t \\<le> component ?g ?r\\<^sup>T * component ?g ?r \\<sqinter>\n           - - ?g \\<and>\n  component ?g ?r \\<le> ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and> regular ?t\n\ngoal (1 subgoal):\n 1. component g r \\<le> r\\<^sup>T * w\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  component g r \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  component g r \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "have \"... \\<le> r\\<^sup>T * ?w\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>T * w\\<^sup>\\<star>\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "using 4 7 8 10 11 12 15"], ["proof (prove)\nusing this:\n  t \\<le> v * v\\<^sup>T\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n  vector v\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n  w * v \\<le> v\n  regular\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star>) \\<and>\n  regular (prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) \\<and>\n  regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n\ngoal (1 subgoal):\n 1. r\\<^sup>T * w\\<^sup>\\<star>\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "by (metis mst_reachable_inv)"], ["proof (state)\nthis:\n  r\\<^sup>T * w\\<^sup>\\<star>\n  \\<le> r\\<^sup>T *\n        prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  component g r\n  \\<le> r\\<^sup>T *\n        prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  component g r\n  \\<le> r\\<^sup>T *\n        prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. component g r\n    \\<le> r\\<^sup>T *\n          prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>", "."], ["proof (state)\nthis:\n  component g r\n  \\<le> r\\<^sup>T *\n        prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  component g r\n  \\<le> r\\<^sup>T *\n        prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "show \"regular ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "using 15"], ["proof (prove)\nusing this:\n  regular\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star>) \\<and>\n  regular (prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) \\<and>\n  regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n\ngoal (1 subgoal):\n 1. regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "by simp"], ["proof (state)\nthis:\n  regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spanning_tree (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) g r\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "have 18: \"?f \\<squnion> ?p = ?fp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<squnion>\n    prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) =\n    prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))", "using 2 8 epm_1"], ["proof (prove)\nusing this:\n  regular v \\<and> regular (v * v\\<^sup>T)\n  vector v\n  vector ?v \\<Longrightarrow>\n  prim_E ?w ?v ?e \\<squnion> prim_P ?w ?v ?e = prim_EP ?w ?v ?e\n\ngoal (1 subgoal):\n 1. w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<squnion>\n    prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) =\n    prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))", "by fastforce"], ["proof (state)\nthis:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<squnion>\n  prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) =\n  prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "have \"arc (w \\<sqinter> --v * -v\\<^sup>T \\<sqinter> top * ?e * w\\<^sup>T\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc (prim_E w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "using 5 6 8 9 11 12 reachable_restrict arc_edge"], ["proof (prove)\nusing this:\n  t \\<le> - - g\n  minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> v * - v\\<^sup>T \\<sqinter> - - g\n  vector v\n  arc (minarc (v * - v\\<^sup>T \\<sqinter> g))\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n  w * v \\<le> v\n  vector ?r \\<Longrightarrow>\n  ?r\\<^sup>T * ?g\\<^sup>\\<star> =\n  ?r\\<^sup>T *\n  ((?r\\<^sup>T * ?g\\<^sup>\\<star>)\\<^sup>T *\n   (?r\\<^sup>T * ?g\\<^sup>\\<star>) \\<sqinter>\n   ?g)\\<^sup>\\<star>\n  \\<lbrakk>?e \\<le> ?v * - ?v\\<^sup>T \\<sqinter> ?g; vector ?v;\n   ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star>; ?t \\<le> ?g;\n   ?r\\<^sup>T * ?g\\<^sup>\\<star> \\<le> ?r\\<^sup>T * ?w\\<^sup>\\<star>;\n   ?w * ?v \\<le> ?v; injective ?w; arc ?e\\<rbrakk>\n  \\<Longrightarrow> arc (prim_E ?w ?v ?e)\n\ngoal (1 subgoal):\n 1. arc (prim_E w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))", "by auto"], ["proof (state)\nthis:\n  arc (prim_E w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "hence 19: \"arc ?f\""], ["proof (prove)\nusing this:\n  arc (prim_E w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n\ngoal (1 subgoal):\n 1. arc (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n         top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n         w\\<^sup>T\\<^sup>\\<star>)", "using 2"], ["proof (prove)\nusing this:\n  arc (prim_E w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n  regular v \\<and> regular (v * v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. arc (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n         top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n         w\\<^sup>T\\<^sup>\\<star>)", "by simp"], ["proof (state)\nthis:\n  arc (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n       top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n       w\\<^sup>T\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "hence \"?f = bot \\<longrightarrow> top = bot\""], ["proof (prove)\nusing this:\n  arc (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n       top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n       w\\<^sup>T\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) * w\\<^sup>T\\<^sup>\\<star> =\n    bot \\<longrightarrow>\n    top = bot", "by (metis mult_left_zero mult_right_zero)"], ["proof (state)\nthis:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) * w\\<^sup>T\\<^sup>\\<star> =\n  bot \\<longrightarrow>\n  top = bot\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "hence \"?f \\<noteq> bot\""], ["proof (prove)\nusing this:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) * w\\<^sup>T\\<^sup>\\<star> =\n  bot \\<longrightarrow>\n  top = bot\n\ngoal (1 subgoal):\n 1. w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<noteq>\n    bot", "using 1 le_bot"], ["proof (prove)\nusing this:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) * w\\<^sup>T\\<^sup>\\<star> =\n  bot \\<longrightarrow>\n  top = bot\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n  ?a \\<le> bot \\<Longrightarrow> ?a = bot\n\ngoal (1 subgoal):\n 1. w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<noteq>\n    bot", "by auto"], ["proof (state)\nthis:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<noteq>\n  bot\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "hence \"?f \\<sqinter> v * -v\\<^sup>T \\<sqinter> ?g \\<noteq> bot\""], ["proof (prove)\nusing this:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<noteq>\n  bot\n\ngoal (1 subgoal):\n 1. w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    v * - v\\<^sup>T \\<sqinter>\n    - - g \\<noteq>\n    bot", "using 2 11"], ["proof (prove)\nusing this:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<noteq>\n  bot\n  regular v \\<and> regular (v * v\\<^sup>T)\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    v * - v\\<^sup>T \\<sqinter>\n    - - g \\<noteq>\n    bot", "by (simp add: inf.absorb1 le_infI1)"], ["proof (state)\nthis:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  v * - v\\<^sup>T \\<sqinter>\n  - - g \\<noteq>\n  bot\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "hence \"g \\<sqinter> (?f \\<sqinter> v * -v\\<^sup>T) \\<noteq> bot\""], ["proof (prove)\nusing this:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  v * - v\\<^sup>T \\<sqinter>\n  - - g \\<noteq>\n  bot\n\ngoal (1 subgoal):\n 1. g \\<sqinter>\n    (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n     top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n     w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n     v * - v\\<^sup>T) \\<noteq>\n    bot", "using inf_commute pp_inf_bot_iff"], ["proof (prove)\nusing this:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  v * - v\\<^sup>T \\<sqinter>\n  - - g \\<noteq>\n  bot\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n  (?x \\<sqinter> ?y = bot) = (- - ?x \\<sqinter> ?y = bot)\n\ngoal (1 subgoal):\n 1. g \\<sqinter>\n    (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n     top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n     w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n     v * - v\\<^sup>T) \\<noteq>\n    bot", "by simp"], ["proof (state)\nthis:\n  g \\<sqinter>\n  (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n   top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n   w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n   v * - v\\<^sup>T) \\<noteq>\n  bot\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "hence 20: \"?f \\<sqinter> ?vcv \\<noteq> bot\""], ["proof (prove)\nusing this:\n  g \\<sqinter>\n  (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n   top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n   w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n   v * - v\\<^sup>T) \\<noteq>\n  bot\n\ngoal (1 subgoal):\n 1. w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    (v * - v\\<^sup>T \\<sqinter> g) \\<noteq>\n    bot", "by (simp add: inf_assoc inf_commute)"], ["proof (state)\nthis:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  (v * - v\\<^sup>T \\<sqinter> g) \\<noteq>\n  bot\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "hence 21: \"?f \\<sqinter> g = ?f \\<sqinter> ?vcv\""], ["proof (prove)\nusing this:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  (v * - v\\<^sup>T \\<sqinter> g) \\<noteq>\n  bot\n\ngoal (1 subgoal):\n 1. w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g =\n    w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    (v * - v\\<^sup>T \\<sqinter> g)", "using 2"], ["proof (prove)\nusing this:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  (v * - v\\<^sup>T \\<sqinter> g) \\<noteq>\n  bot\n  regular v \\<and> regular (v * v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g =\n    w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    (v * - v\\<^sup>T \\<sqinter> g)", "by (simp add: inf_assoc inf_commute inf_left_commute)"], ["proof (state)\nthis:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  g =\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  (v * - v\\<^sup>T \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "have 22: \"?e \\<sqinter> g = minarc ?vcv \\<sqinter> ?vcv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g =\n    minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter>\n    (v * - v\\<^sup>T \\<sqinter> g)", "using 7"], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g =\n    minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter>\n    (v * - v\\<^sup>T \\<sqinter> g)", "by (simp add: inf.absorb2 inf.assoc inf.commute)"], ["proof (state)\nthis:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g =\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter>\n  (v * - v\\<^sup>T \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "hence 23: \"sum (?e \\<sqinter> g) \\<le> sum (?f \\<sqinter> g)\""], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g =\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter>\n  (v * - v\\<^sup>T \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n    \\<le> sum_class.sum\n           (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n            top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n            w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n            g)", "using 15 19 20 21"], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g =\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter>\n  (v * - v\\<^sup>T \\<sqinter> g)\n  regular\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star>) \\<and>\n  regular (prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) \\<and>\n  regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n  arc (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n       top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n       w\\<^sup>T\\<^sup>\\<star>)\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  (v * - v\\<^sup>T \\<sqinter> g) \\<noteq>\n  bot\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  g =\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  (v * - v\\<^sup>T \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n    \\<le> sum_class.sum\n           (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n            top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n            w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n            g)", "by (simp add: minarc_min)"], ["proof (state)\nthis:\n  sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n  \\<le> sum_class.sum\n         (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n          top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n          w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n          g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "have \"?e \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) \\<noteq> bot", "using 20 comp_inf.semiring.mult_not_zero semiring.mult_not_zero"], ["proof (prove)\nusing this:\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n  (v * - v\\<^sup>T \\<sqinter> g) \\<noteq>\n  bot\n  ?a \\<sqinter> ?b \\<noteq> bot \\<Longrightarrow>\n  ?a \\<noteq> bot \\<and> ?b \\<noteq> bot\n  ?a * ?b \\<noteq> bot \\<Longrightarrow>\n  ?a \\<noteq> bot \\<and> ?b \\<noteq> bot\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) \\<noteq> bot", "by blast"], ["proof (state)\nthis:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "hence 24: \"?e \\<sqinter> g \\<noteq> bot\""], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g \\<noteq> bot", "using 22 minarc_meet_bot"], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<noteq> bot\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g =\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter>\n  (v * - v\\<^sup>T \\<sqinter> g)\n  minarc ?x \\<sqinter> ?x = bot \\<Longrightarrow> minarc ?x = bot\n\ngoal (1 subgoal):\n 1. minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g \\<noteq> bot", "by auto"], ["proof (state)\nthis:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "have \"sum (?w \\<sqinter> g) = sum (w \\<sqinter> -?fp \\<sqinter> g) + sum (?p\\<^sup>T \\<sqinter> g) + sum (?e \\<sqinter> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_class.sum\n     (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) =\n    sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n      g) +\n    sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)", "using 7 8 10"], ["proof (prove)\nusing this:\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> v * - v\\<^sup>T\n  vector v\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n\ngoal (1 subgoal):\n 1. sum_class.sum\n     (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) =\n    sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n      g) +\n    sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)", "by (metis sum_disjoint_3 epm_8 epm_9 epm_10 minimum_spanning_tree_def spanning_tree_def)"], ["proof (state)\nthis:\n  sum_class.sum\n   (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) =\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n    g) +\n  sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "also"], ["proof (state)\nthis:\n  sum_class.sum\n   (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) =\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n    g) +\n  sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "have \"... = sum (((w \\<sqinter> -?fp) \\<squnion> ?p\\<^sup>T) \\<sqinter> g) + sum (?e \\<sqinter> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n      g) +\n    sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g) =\n    sum_class.sum\n     ((w \\<sqinter>\n       - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       prim_P w v\n        (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n      g) +\n    sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)", "using 11"], ["proof (prove)\nusing this:\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n      g) +\n    sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g) =\n    sum_class.sum\n     ((w \\<sqinter>\n       - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       prim_P w v\n        (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n      g) +\n    sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)", "by (metis epm_8 sum_disjoint)"], ["proof (state)\nthis:\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n    g) +\n  sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g) =\n  sum_class.sum\n   ((w \\<sqinter>\n     - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n    g) +\n  sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "also"], ["proof (state)\nthis:\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n    g) +\n  sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g) =\n  sum_class.sum\n   ((w \\<sqinter>\n     - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n    g) +\n  sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "have \"... \\<le> sum (((w \\<sqinter> -?fp) \\<squnion> ?p\\<^sup>T) \\<sqinter> g) + sum (?f \\<sqinter> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_class.sum\n     ((w \\<sqinter>\n       - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       prim_P w v\n        (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n      g) +\n    sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n    \\<le> sum_class.sum\n           ((w \\<sqinter>\n             - prim_EP w v\n                (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n             prim_P w v\n              (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n            g) +\n          sum_class.sum\n           (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n            top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n            w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n            g)", "using 23 24"], ["proof (prove)\nusing this:\n  sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n  \\<le> sum_class.sum\n         (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n          top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n          w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n          g)\n  minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g \\<noteq> bot\n\ngoal (1 subgoal):\n 1. sum_class.sum\n     ((w \\<sqinter>\n       - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       prim_P w v\n        (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n      g) +\n    sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n    \\<le> sum_class.sum\n           ((w \\<sqinter>\n             - prim_EP w v\n                (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n             prim_P w v\n              (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n            g) +\n          sum_class.sum\n           (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n            top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n            w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n            g)", "by (simp add: sum_plus_right_isotone)"], ["proof (state)\nthis:\n  sum_class.sum\n   ((w \\<sqinter>\n     - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n    g) +\n  sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n  \\<le> sum_class.sum\n         ((w \\<sqinter>\n           - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n           prim_P w v\n            (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n          g) +\n        sum_class.sum\n         (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n          top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n          w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n          g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "also"], ["proof (state)\nthis:\n  sum_class.sum\n   ((w \\<sqinter>\n     - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n    g) +\n  sum_class.sum (minarc (v * - v\\<^sup>T \\<sqinter> g) \\<sqinter> g)\n  \\<le> sum_class.sum\n         ((w \\<sqinter>\n           - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n           prim_P w v\n            (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n          g) +\n        sum_class.sum\n         (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n          top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n          w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n          g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "have \"... = sum (w \\<sqinter> -?fp \\<sqinter> g) + sum (?p\\<^sup>T \\<sqinter> g) + sum (?f \\<sqinter> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_class.sum\n     ((w \\<sqinter>\n       - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       prim_P w v\n        (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n      g) +\n    sum_class.sum\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n      g) =\n    sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n      g) +\n    sum_class.sum\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n      g)", "using 11"], ["proof (prove)\nusing this:\n  vector r \\<and>\n  injective r \\<and>\n  v\\<^sup>T = r\\<^sup>T * t\\<^sup>\\<star> \\<and>\n  forest w \\<and>\n  t \\<le> w \\<and>\n  w \\<le> component g r\\<^sup>T * component g r \\<sqinter> - - g \\<and>\n  r\\<^sup>T *\n  (component g r\\<^sup>T * component g r \\<sqinter> - - g)\\<^sup>\\<star>\n  \\<le> r\\<^sup>T * w\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. sum_class.sum\n     ((w \\<sqinter>\n       - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       prim_P w v\n        (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n      g) +\n    sum_class.sum\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n      g) =\n    sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n      g) +\n    sum_class.sum\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n      g)", "by (metis epm_8 sum_disjoint)"], ["proof (state)\nthis:\n  sum_class.sum\n   ((w \\<sqinter>\n     - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n    g) +\n  sum_class.sum\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g) =\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n    g) +\n  sum_class.sum\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "also"], ["proof (state)\nthis:\n  sum_class.sum\n   ((w \\<sqinter>\n     - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T) \\<sqinter>\n    g) +\n  sum_class.sum\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g) =\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n    g) +\n  sum_class.sum\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "have \"... = sum (w \\<sqinter> -?fp \\<sqinter> g) + sum (?p \\<sqinter> g) + sum (?f \\<sqinter> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n      g) +\n    sum_class.sum\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n      g) =\n    sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) +\n    sum_class.sum\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n      g)", "using 13 sum_symmetric"], ["proof (prove)\nusing this:\n  g = g\\<^sup>T\n  ?y = ?y\\<^sup>T \\<Longrightarrow>\n  sum_class.sum (?x\\<^sup>T \\<sqinter> ?y) =\n  sum_class.sum (?x \\<sqinter> ?y)\n\ngoal (1 subgoal):\n 1. sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n      g) +\n    sum_class.sum\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n      g) =\n    sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) +\n    sum_class.sum\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n      g)", "by auto"], ["proof (state)\nthis:\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n    g) +\n  sum_class.sum\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g) =\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) +\n  sum_class.sum\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "also"], ["proof (state)\nthis:\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\\<^sup>T \\<sqinter>\n    g) +\n  sum_class.sum\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g) =\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) +\n  sum_class.sum\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "have \"... = sum (((w \\<sqinter> -?fp) \\<squnion> ?p \\<squnion> ?f) \\<sqinter> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) +\n    sum_class.sum\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n      g) =\n    sum_class.sum\n     ((w \\<sqinter>\n       - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n       top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n       w\\<^sup>T\\<^sup>\\<star>) \\<sqinter>\n      g)", "using 2 8"], ["proof (prove)\nusing this:\n  regular v \\<and> regular (v * v\\<^sup>T)\n  vector v\n\ngoal (1 subgoal):\n 1. sum_class.sum\n     (w \\<sqinter>\n      - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n      g) +\n    sum_class.sum\n     (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) +\n    sum_class.sum\n     (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n      top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n      w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n      g) =\n    sum_class.sum\n     ((w \\<sqinter>\n       - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n       top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n       w\\<^sup>T\\<^sup>\\<star>) \\<sqinter>\n      g)", "by (metis sum_disjoint_3 epm_11 epm_12 epm_13)"], ["proof (state)\nthis:\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) +\n  sum_class.sum\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g) =\n  sum_class.sum\n   ((w \\<sqinter>\n     - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n     top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n     w\\<^sup>T\\<^sup>\\<star>) \\<sqinter>\n    g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "also"], ["proof (state)\nthis:\n  sum_class.sum\n   (w \\<sqinter>\n    - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter>\n    g) +\n  sum_class.sum\n   (prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g) +\n  sum_class.sum\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star> \\<sqinter>\n    g) =\n  sum_class.sum\n   ((w \\<sqinter>\n     - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n     top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n     w\\<^sup>T\\<^sup>\\<star>) \\<sqinter>\n    g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "have \"... = sum (w \\<sqinter> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_class.sum\n     ((w \\<sqinter>\n       - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n       top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n       w\\<^sup>T\\<^sup>\\<star>) \\<sqinter>\n      g) =\n    sum_class.sum (w \\<sqinter> g)", "using 2 8 15 18 epm_2"], ["proof (prove)\nusing this:\n  regular v \\<and> regular (v * v\\<^sup>T)\n  vector v\n  regular\n   (w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n    top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n    w\\<^sup>T\\<^sup>\\<star>) \\<and>\n  regular (prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))) \\<and>\n  regular (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n  w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n  top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n  w\\<^sup>T\\<^sup>\\<star> \\<squnion>\n  prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) =\n  prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n  \\<lbrakk>regular (prim_EP ?w ?v ?e); vector ?v\\<rbrakk>\n  \\<Longrightarrow> ?w \\<sqinter> - prim_EP ?w ?v ?e \\<squnion>\n                    prim_P ?w ?v ?e \\<squnion>\n                    prim_E ?w ?v ?e =\n                    ?w\n\ngoal (1 subgoal):\n 1. sum_class.sum\n     ((w \\<sqinter>\n       - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n       w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n       top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n       w\\<^sup>T\\<^sup>\\<star>) \\<sqinter>\n      g) =\n    sum_class.sum (w \\<sqinter> g)", "by force"], ["proof (state)\nthis:\n  sum_class.sum\n   ((w \\<sqinter>\n     - prim_EP w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     prim_P w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<squnion>\n     w \\<sqinter> v * - v\\<^sup>T \\<sqinter>\n     top * minarc (v * - v\\<^sup>T \\<sqinter> g) *\n     w\\<^sup>T\\<^sup>\\<star>) \\<sqinter>\n    g) =\n  sum_class.sum (w \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "finally"], ["proof (chain)\npicking this:\n  sum_class.sum\n   (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n  \\<le> sum_class.sum (w \\<sqinter> g)", "have \"sum (?w \\<sqinter> g) \\<le> sum (w \\<sqinter> g)\""], ["proof (prove)\nusing this:\n  sum_class.sum\n   (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n  \\<le> sum_class.sum (w \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. sum_class.sum\n     (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n    \\<le> sum_class.sum (w \\<sqinter> g)", "."], ["proof (state)\nthis:\n  sum_class.sum\n   (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n  \\<le> sum_class.sum (w \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "thus \"\\<forall>u . spanning_tree u g r \\<longrightarrow> sum (?w \\<sqinter> g) \\<le> sum (u \\<sqinter> g)\""], ["proof (prove)\nusing this:\n  sum_class.sum\n   (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n  \\<le> sum_class.sum (w \\<sqinter> g)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "using 10 order_lesseq_imp minimum_spanning_tree_def"], ["proof (prove)\nusing this:\n  sum_class.sum\n   (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n  \\<le> sum_class.sum (w \\<sqinter> g)\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  minimum_spanning_tree ?t ?g ?r \\<equiv>\n  spanning_tree ?t ?g ?r \\<and>\n  (\\<forall>u.\n      spanning_tree u ?g ?r \\<longrightarrow>\n      sum_class.sum (?t \\<sqinter> ?g)\n      \\<le> sum_class.sum (u \\<sqinter> ?g))\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       spanning_tree u g r \\<longrightarrow>\n       sum_class.sum\n        (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n       \\<le> sum_class.sum (u \\<sqinter> g)", "by auto"], ["proof (state)\nthis:\n  \\<forall>u.\n     spanning_tree u g r \\<longrightarrow>\n     sum_class.sum\n      (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)) \\<sqinter> g)\n     \\<le> sum_class.sum (u \\<sqinter> g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  minimum_spanning_tree (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n   g r\n\ngoal (1 subgoal):\n 1. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))", "show \"?t \\<le> ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))", "using 4 8 10 mst_extends_new_tree"], ["proof (prove)\nusing this:\n  t \\<le> v * v\\<^sup>T\n  vector v\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n  \\<lbrakk>?t \\<le> ?w; ?t \\<le> ?v * ?v\\<^sup>T; vector ?v\\<rbrakk>\n  \\<Longrightarrow> ?t \\<squnion> ?e \\<le> prim_W ?w ?v ?e\n\ngoal (1 subgoal):\n 1. t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n    \\<le> prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))", "by simp"], ["proof (state)\nthis:\n  t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  minimum_spanning_tree (prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g)))\n   g r \\<and>\n  t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\n  \\<le> prim_W w v (minarc (v * - v\\<^sup>T \\<sqinter> g))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w.\n     minimum_spanning_tree w g r \\<and>\n     t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g) \\<le> w\n\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "show \"?n2 < ?n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "using 1 prim_invariant_def prim_vc_2"], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g \\<noteq> bot\n  prim_invariant ?t ?v ?g ?r \\<equiv>\n  prim_spanning_invariant ?t ?v ?g ?r \\<and>\n  (\\<exists>w. minimum_spanning_tree w ?g ?r \\<and> ?t \\<le> w)\n  \\<lbrakk>prim_spanning_invariant ?t ?v ?g ?r;\n   ?v * - ?v\\<^sup>T \\<sqinter> ?g \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> prim_spanning_invariant\n                     (?t \\<squnion>\n                      minarc (?v * - ?v\\<^sup>T \\<sqinter> ?g))\n                     (?v \\<squnion>\n                      minarc (?v * - ?v\\<^sup>T \\<sqinter> ?g)\\<^sup>T *\n                      top)\n                     ?g ?r \\<and>\n                    card\n                     {x. regular x \\<and>\n                         x \\<le> component ?g ?r \\<and>\n                         x \\<le> - (?v \\<squnion>\n                                    minarc\n                                     (?v * - ?v\\<^sup>T \\<sqinter>\n?g)\\<^sup>T *\n                                    top)\\<^sup>T}\n                    < card\n                       {x. regular x \\<and>\n                           x \\<le> component ?g ?r \\<and>\n                           x \\<le> - ?v\\<^sup>T}\n\ngoal (1 subgoal):\n 1. card\n     {x. regular x \\<and>\n         x \\<le> component g r \\<and>\n         x \\<le> - (v \\<squnion>\n                    minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                    top)\\<^sup>T}\n    < card\n       {x. regular x \\<and>\n           x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}", "by auto"], ["proof (state)\nthis:\n  card\n   {x. regular x \\<and>\n       x \\<le> component g r \\<and>\n       x \\<le> - (v \\<squnion>\n                  minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                  top)\\<^sup>T}\n  < card\n     {x. regular x \\<and> x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prim_invariant (t \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g))\n   (v \\<squnion> minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T * top) g\n   r \\<and>\n  card\n   {x. regular x \\<and>\n       x \\<le> component g r \\<and>\n       x \\<le> - (v \\<squnion>\n                  minarc (v * - v\\<^sup>T \\<sqinter> g)\\<^sup>T *\n                  top)\\<^sup>T}\n  < card\n     {x. regular x \\<and> x \\<le> component g r \\<and> x \\<le> - v\\<^sup>T}\n\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "fix t v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "let ?g = \"--g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "assume 25: \"prim_invariant t v g r \\<and> v * -v\\<^sup>T \\<sqinter> g = bot\""], ["proof (state)\nthis:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g = bot\n\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "hence 26: \"regular v\""], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g = bot\n\ngoal (1 subgoal):\n 1. regular v", "by (metis prim_invariant_def prim_spanning_invariant_def spanning_tree_def prim_precondition_def regular_conv_closed regular_closed_star regular_mult_closed conv_involutive)"], ["proof (state)\nthis:\n  regular v\n\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "from 25"], ["proof (chain)\npicking this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g = bot", "obtain w where 27: \"minimum_spanning_tree w g r \\<and> t \\<le> w\""], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g = bot\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        minimum_spanning_tree w g r \\<and> t \\<le> w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prim_invariant_def)"], ["proof (state)\nthis:\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "have \"spanning_tree t g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spanning_tree t g r", "using 25 prim_invariant_def prim_vc_3"], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g = bot\n  prim_invariant ?t ?v ?g ?r \\<equiv>\n  prim_spanning_invariant ?t ?v ?g ?r \\<and>\n  (\\<exists>w. minimum_spanning_tree w ?g ?r \\<and> ?t \\<le> w)\n  \\<lbrakk>prim_spanning_invariant ?t ?v ?g ?r;\n   ?v * - ?v\\<^sup>T \\<sqinter> ?g = bot\\<rbrakk>\n  \\<Longrightarrow> spanning_tree ?t ?g ?r\n\ngoal (1 subgoal):\n 1. spanning_tree t g r", "by blast"], ["proof (state)\nthis:\n  spanning_tree t g r\n\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "hence \"component g r = v\\<^sup>T\""], ["proof (prove)\nusing this:\n  spanning_tree t g r\n\ngoal (1 subgoal):\n 1. component g r = v\\<^sup>T", "by (metis 25 prim_invariant_def span_tree_component prim_spanning_invariant_def spanning_tree_def)"], ["proof (state)\nthis:\n  component g r = v\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "hence 28: \"w \\<le> v * v\\<^sup>T\""], ["proof (prove)\nusing this:\n  component g r = v\\<^sup>T\n\ngoal (1 subgoal):\n 1. w \\<le> v * v\\<^sup>T", "using 26 27"], ["proof (prove)\nusing this:\n  component g r = v\\<^sup>T\n  regular v\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n\ngoal (1 subgoal):\n 1. w \\<le> v * v\\<^sup>T", "by (simp add: minimum_spanning_tree_def spanning_tree_def inf_pp_commute)"], ["proof (state)\nthis:\n  w \\<le> v * v\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "have \"vector r \\<and> injective r \\<and> forest w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector r \\<and> injective r \\<and> forest w", "using 25 27"], ["proof (prove)\nusing this:\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g = bot\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n\ngoal (1 subgoal):\n 1. vector r \\<and> injective r \\<and> forest w", "by (simp add: prim_invariant_def prim_spanning_invariant_def prim_precondition_def minimum_spanning_tree_def spanning_tree_def)"], ["proof (state)\nthis:\n  vector r \\<and> injective r \\<and> forest w\n\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "hence \"w = t\""], ["proof (prove)\nusing this:\n  vector r \\<and> injective r \\<and> forest w\n\ngoal (1 subgoal):\n 1. w = t", "using 25 27 28 prim_invariant_def prim_spanning_invariant_def mst_post"], ["proof (prove)\nusing this:\n  vector r \\<and> injective r \\<and> forest w\n  prim_invariant t v g r \\<and> v * - v\\<^sup>T \\<sqinter> g = bot\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n  w \\<le> v * v\\<^sup>T\n  prim_invariant ?t ?v ?g ?r \\<equiv>\n  prim_spanning_invariant ?t ?v ?g ?r \\<and>\n  (\\<exists>w. minimum_spanning_tree w ?g ?r \\<and> ?t \\<le> w)\n  prim_spanning_invariant ?t ?v ?g ?r \\<equiv>\n  prim_precondition ?g ?r \\<and>\n  ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star> \\<and>\n  spanning_tree ?t (?v * ?v\\<^sup>T \\<sqinter> ?g) ?r\n  \\<lbrakk>vector ?r; injective ?r;\n   ?v\\<^sup>T = ?r\\<^sup>T * ?t\\<^sup>\\<star>; forest ?w; ?t \\<le> ?w;\n   ?w \\<le> ?v * ?v\\<^sup>T\\<rbrakk>\n  \\<Longrightarrow> ?w = ?t\n\ngoal (1 subgoal):\n 1. w = t", "by blast"], ["proof (state)\nthis:\n  w = t\n\ngoal (1 subgoal):\n 1. \\<And>t v.\n       prim_invariant t v g r \\<and>\n       v * - v\\<^sup>T \\<sqinter> g = bot \\<Longrightarrow>\n       minimum_spanning_tree t g r", "thus \"minimum_spanning_tree t g r\""], ["proof (prove)\nusing this:\n  w = t\n\ngoal (1 subgoal):\n 1. minimum_spanning_tree t g r", "using 27"], ["proof (prove)\nusing this:\n  w = t\n  minimum_spanning_tree w g r \\<and> t \\<le> w\n\ngoal (1 subgoal):\n 1. minimum_spanning_tree t g r", "by simp"], ["proof (state)\nthis:\n  minimum_spanning_tree t g r\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}