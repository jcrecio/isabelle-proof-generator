{"file_name": "/home/qj213/afp-2021-10-22/thys/Grothendieck_Schemes/Topological_Space.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Grothendieck_Schemes", "problem_names": ["lemma open_union' [intro]: \"\\<And>F::('a set) set. (\\<And>x. x \\<in> F \\<Longrightarrow> is_open x) \\<Longrightarrow> is_open (\\<Union>F)\"", "lemma open_preimage_identity [simp]: \"is_open B \\<Longrightarrow> identity S \\<^sup>\\<inverse> S B = B\"", "lemma generated_topology_empty [simp]: \"generated_topology S B {}\"", "lemma generated_topology_subset: \"generated_topology S B U \\<Longrightarrow> U \\<subseteq> S\"", "lemma generated_topology_is_topology:\n  fixes S:: \"'a set\" and B:: \"'a set set\"\n  shows \"topological_space S (generated_topology S B)\"", "lemma\n  assumes \"x \\<in> U\"\n  shows \"\\<exists>i\\<in>index. x \\<in> cover i\"", "lemma cover_of_select_index:\n  assumes \"x \\<in> U\"\n  shows \"x \\<in> cover (select_index x)\"", "lemma select_index_belongs:\n  assumes \"x \\<in> U\"\n  shows \"select_index x \\<in> index\"", "lemma cover_of_select_index_is_open:\n  assumes \"x \\<in> U\"\n  shows \"is_open (C (select_index x))\"", "lemma ind_is_open_S [iff]: \"ind_is_open S\"", "lemma ind_is_open_empty [iff]: \"ind_is_open {}\"", "lemma ind_space_is_top_space:\n  shows \"topological_space S (ind_is_open)\"", "lemma is_open_from_ind_is_open:\n  assumes \"is_open S\" and \"ind_is_open U\"\n  shows \"is_open U\"", "lemma open_cover_from_ind_open_cover:\n  assumes \"is_open S\" and \"open_cover_of_open_subset S ind_is_open U I C\"\n  shows \"open_cover_of_open_subset X is_open U I C\"", "lemma (in topological_space) ind_topology_is_open_self [iff]: \"ind_topology S is_open S\"", "lemma (in topological_space) ind_topology_is_open_empty [iff]: \"ind_topology S is_open {}\"", "lemma (in topological_space) ind_is_open_iff_open:\n  shows \"ind_topology.ind_is_open S is_open S U \\<longleftrightarrow> is_open U \\<and> U \\<subseteq> S\"", "lemma open_cover_of_open_subset_from_target_to_source:\n  assumes \"open_cover_of_open_subset S' is_open' U I C\"\n  shows \"open_cover_of_open_subset S is_open (f\\<^sup>\\<inverse> S U) I (\\<lambda>i. f\\<^sup>\\<inverse> S (C i))\"", "lemma (in topological_space) id_is_homeomorphism:\n  shows \"homeomorphism S is_open S is_open (identity S)\""], "translations": [["", "lemma open_union' [intro]: \"\\<And>F::('a set) set. (\\<And>x. x \\<in> F \\<Longrightarrow> is_open x) \\<Longrightarrow> is_open (\\<Union>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       (\\<And>x. x \\<in> F \\<Longrightarrow> is_open x) \\<Longrightarrow>\n       is_open (\\<Union> F)", "using open_union"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> ?F \\<Longrightarrow> is_open x) \\<Longrightarrow>\n  is_open (\\<Union>x\\<in>?F. x)\n\ngoal (1 subgoal):\n 1. \\<And>F.\n       (\\<And>x. x \\<in> F \\<Longrightarrow> is_open x) \\<Longrightarrow>\n       is_open (\\<Union> F)", "by auto"], ["", "lemma open_preimage_identity [simp]: \"is_open B \\<Longrightarrow> identity S \\<^sup>\\<inverse> S B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_open B \\<Longrightarrow> identity S \\<^sup>\\<inverse> S B = B", "by (metis inf.orderE open_imp_subset preimage_identity_self)"], ["", "definition is_connected:: \"bool\" where\n\"is_connected \\<equiv> \\<not> (\\<exists>U V. is_open U \\<and> is_open V \\<and> (U \\<noteq> {}) \\<and> (V \\<noteq> {}) \\<and> (U \\<inter> V = {}) \\<and> (U \\<union> V = S))\""], ["", "definition is_hausdorff:: \"bool\" where\n\"is_hausdorff \\<equiv>\n\\<forall>x y. (x \\<in> S \\<and> y \\<in> S \\<and> x \\<noteq> y) \\<longrightarrow> (\\<exists>U V. U \\<in> neighborhoods x \\<and> V \\<in> neighborhoods y \\<and> U \\<inter> V = {})\""], ["", "end"], ["", "(* topological_space *)"], ["", "text \\<open>T2 spaces are also known as Hausdorff spaces.\\<close>"], ["", "locale t2_space = topological_space +\n  assumes hausdorff: \"is_hausdorff\""], ["", "subsection \\<open>Topological Basis\\<close>"], ["", "inductive generated_topology :: \"'a set \\<Rightarrow> 'a set set \\<Rightarrow> 'a set \\<Rightarrow> bool\"\n    for S :: \"'a set\" and B :: \"'a set set\"\n  where\n    UNIV: \"generated_topology S B S\"\n  | Int: \"generated_topology S B (U \\<inter> V)\"\n            if \"generated_topology S B U\" and \"generated_topology S B V\"\n  | UN: \"generated_topology S B (\\<Union>K)\" if \"(\\<And>U. U \\<in> K \\<Longrightarrow> generated_topology S B U)\"\n  | Basis: \"generated_topology S B b\" if \"b \\<in> B \\<and> b \\<subseteq> S\""], ["", "lemma generated_topology_empty [simp]: \"generated_topology S B {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generated_topology S B {}", "by (metis UN Union_empty empty_iff)"], ["", "lemma generated_topology_subset: \"generated_topology S B U \\<Longrightarrow> U \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generated_topology S B U \\<Longrightarrow> U \\<subseteq> S", "by (induct rule:generated_topology.induct) auto"], ["", "lemma generated_topology_is_topology:\n  fixes S:: \"'a set\" and B:: \"'a set set\"\n  shows \"topological_space S (generated_topology S B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. topological_space S (generated_topology S B)", "by (simp add: Int UN UNIV generated_topology_subset topological_space_def)"], ["", "subsection \\<open>Covers\\<close>"], ["", "locale cover_of_subset =\n  fixes X:: \"'a set\" and U:: \"'a set\" and index:: \"real set\" and cover:: \"real \\<Rightarrow> 'a set\"\n(* We use real instead of index::\"'b set\" otherwise we get some troubles with locale sheaf_of_rings\nin Comm_Ring_Theory.thy *)\n  assumes is_subset: \"U \\<subseteq> X\" and are_subsets: \"\\<And>i. i \\<in> index \\<Longrightarrow> cover i \\<subseteq> X\"\nand covering: \"U \\<subseteq> (\\<Union>i\\<in>index. cover i)\"\nbegin"], ["", "lemma\n  assumes \"x \\<in> U\"\n  shows \"\\<exists>i\\<in>index. x \\<in> cover i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>index. x \\<in> cover i", "using assms covering"], ["proof (prove)\nusing this:\n  x \\<in> U\n  U \\<subseteq> \\<Union> (cover ` index)\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>index. x \\<in> cover i", "by auto"], ["", "definition select_index:: \"'a \\<Rightarrow> real\"\n  where \"select_index x \\<equiv> SOME i. i \\<in> index \\<and> x \\<in> cover i\""], ["", "lemma cover_of_select_index:\n  assumes \"x \\<in> U\"\n  shows \"x \\<in> cover (select_index x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> cover (select_index x)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. x \\<in> cover (select_index x)", "by (metis (mono_tags, lifting) UN_iff covering select_index_def someI_ex subset_iff)"], ["", "lemma select_index_belongs:\n  assumes \"x \\<in> U\"\n  shows \"select_index x \\<in> index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select_index x \\<in> index", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. select_index x \\<in> index", "by (metis (full_types, lifting) UN_iff covering in_mono select_index_def tfl_some)"], ["", "end"], ["", "(* cover_of_subset *)"], ["", "locale open_cover_of_subset = topological_space X is_open + cover_of_subset X U I C\n  for X and is_open and U and I and C +\n  assumes are_open_subspaces: \"\\<And>i. i\\<in>I \\<Longrightarrow> is_open (C i)\"\nbegin"], ["", "lemma cover_of_select_index_is_open:\n  assumes \"x \\<in> U\"\n  shows \"is_open (C (select_index x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_open (C (select_index x))", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. is_open (C (select_index x))", "by (simp add: are_open_subspaces select_index_belongs)"], ["", "end"], ["", "(* open_cover_of_subset *)"], ["", "locale open_cover_of_open_subset = open_cover_of_subset X is_open U I C\n  for X and is_open and U and I and C +\n  assumes is_open_subset: \"is_open U\""], ["", "subsection \\<open>Induced Topology\\<close>"], ["", "locale ind_topology = topological_space X is_open for X and is_open +\n  fixes S:: \"'a set\"\n  assumes is_subset: \"S \\<subseteq> X\"\nbegin"], ["", "definition ind_is_open:: \"'a set \\<Rightarrow> bool\"\n  where \"ind_is_open U \\<equiv> U \\<subseteq> S \\<and> (\\<exists>V. V \\<subseteq> X \\<and> is_open V \\<and> U = S \\<inter> V)\""], ["", "lemma ind_is_open_S [iff]: \"ind_is_open S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ind_is_open S", "by (metis ind_is_open_def inf.orderE is_subset open_space order_refl)"], ["", "lemma ind_is_open_empty [iff]: \"ind_is_open {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ind_is_open {}", "using ind_is_open_def"], ["proof (prove)\nusing this:\n  ind_is_open ?U \\<equiv>\n  ?U \\<subseteq> S \\<and>\n  (\\<exists>V\\<subseteq>X. is_open V \\<and> ?U = S \\<inter> V)\n\ngoal (1 subgoal):\n 1. ind_is_open {}", "by auto"], ["", "lemma ind_space_is_top_space:\n  shows \"topological_space S (ind_is_open)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. topological_space S ind_is_open", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>U V.\n       \\<lbrakk>ind_is_open U; ind_is_open V\\<rbrakk>\n       \\<Longrightarrow> ind_is_open (U \\<inter> V)\n 5. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "fix U V"], ["proof (state)\ngoal (5 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>U V.\n       \\<lbrakk>ind_is_open U; ind_is_open V\\<rbrakk>\n       \\<Longrightarrow> ind_is_open (U \\<inter> V)\n 5. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "assume \"ind_is_open U\""], ["proof (state)\nthis:\n  ind_is_open U\n\ngoal (5 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>U V.\n       \\<lbrakk>ind_is_open U; ind_is_open V\\<rbrakk>\n       \\<Longrightarrow> ind_is_open (U \\<inter> V)\n 5. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "then"], ["proof (chain)\npicking this:\n  ind_is_open U", "obtain UX where \"UX \\<subseteq> X\" \"is_open UX\" \"U = S \\<inter> UX\""], ["proof (prove)\nusing this:\n  ind_is_open U\n\ngoal (1 subgoal):\n 1. (\\<And>UX.\n        \\<lbrakk>UX \\<subseteq> X; is_open UX; U = S \\<inter> UX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ind_is_open_def"], ["proof (prove)\nusing this:\n  ind_is_open U\n  ind_is_open ?U \\<equiv>\n  ?U \\<subseteq> S \\<and>\n  (\\<exists>V\\<subseteq>X. is_open V \\<and> ?U = S \\<inter> V)\n\ngoal (1 subgoal):\n 1. (\\<And>UX.\n        \\<lbrakk>UX \\<subseteq> X; is_open UX; U = S \\<inter> UX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  UX \\<subseteq> X\n  is_open UX\n  U = S \\<inter> UX\n\ngoal (5 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>U V.\n       \\<lbrakk>ind_is_open U; ind_is_open V\\<rbrakk>\n       \\<Longrightarrow> ind_is_open (U \\<inter> V)\n 5. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "moreover"], ["proof (state)\nthis:\n  UX \\<subseteq> X\n  is_open UX\n  U = S \\<inter> UX\n\ngoal (5 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>U V.\n       \\<lbrakk>ind_is_open U; ind_is_open V\\<rbrakk>\n       \\<Longrightarrow> ind_is_open (U \\<inter> V)\n 5. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "assume \"ind_is_open V\""], ["proof (state)\nthis:\n  ind_is_open V\n\ngoal (5 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>U V.\n       \\<lbrakk>ind_is_open U; ind_is_open V\\<rbrakk>\n       \\<Longrightarrow> ind_is_open (U \\<inter> V)\n 5. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "then"], ["proof (chain)\npicking this:\n  ind_is_open V", "obtain VX where \"VX \\<subseteq> X\" \"is_open VX\" \"V = S \\<inter> VX\""], ["proof (prove)\nusing this:\n  ind_is_open V\n\ngoal (1 subgoal):\n 1. (\\<And>VX.\n        \\<lbrakk>VX \\<subseteq> X; is_open VX; V = S \\<inter> VX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ind_is_open_def"], ["proof (prove)\nusing this:\n  ind_is_open V\n  ind_is_open ?U \\<equiv>\n  ?U \\<subseteq> S \\<and>\n  (\\<exists>V\\<subseteq>X. is_open V \\<and> ?U = S \\<inter> V)\n\ngoal (1 subgoal):\n 1. (\\<And>VX.\n        \\<lbrakk>VX \\<subseteq> X; is_open VX; V = S \\<inter> VX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  VX \\<subseteq> X\n  is_open VX\n  V = S \\<inter> VX\n\ngoal (5 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>U V.\n       \\<lbrakk>ind_is_open U; ind_is_open V\\<rbrakk>\n       \\<Longrightarrow> ind_is_open (U \\<inter> V)\n 5. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "ultimately"], ["proof (chain)\npicking this:\n  UX \\<subseteq> X\n  is_open UX\n  U = S \\<inter> UX\n  VX \\<subseteq> X\n  is_open VX\n  V = S \\<inter> VX", "have \"is_open (UX \\<inter> VX) \\<and> (U \\<inter> V = S \\<inter> (UX \\<inter> VX))\""], ["proof (prove)\nusing this:\n  UX \\<subseteq> X\n  is_open UX\n  U = S \\<inter> UX\n  VX \\<subseteq> X\n  is_open VX\n  V = S \\<inter> VX\n\ngoal (1 subgoal):\n 1. is_open (UX \\<inter> VX) \\<and>\n    U \\<inter> V = S \\<inter> (UX \\<inter> VX)", "using open_inter"], ["proof (prove)\nusing this:\n  UX \\<subseteq> X\n  is_open UX\n  U = S \\<inter> UX\n  VX \\<subseteq> X\n  is_open VX\n  V = S \\<inter> VX\n  \\<lbrakk>is_open ?U; is_open ?V\\<rbrakk>\n  \\<Longrightarrow> is_open (?U \\<inter> ?V)\n\ngoal (1 subgoal):\n 1. is_open (UX \\<inter> VX) \\<and>\n    U \\<inter> V = S \\<inter> (UX \\<inter> VX)", "by auto"], ["proof (state)\nthis:\n  is_open (UX \\<inter> VX) \\<and> U \\<inter> V = S \\<inter> (UX \\<inter> VX)\n\ngoal (5 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>U V.\n       \\<lbrakk>ind_is_open U; ind_is_open V\\<rbrakk>\n       \\<Longrightarrow> ind_is_open (U \\<inter> V)\n 5. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "then"], ["proof (chain)\npicking this:\n  is_open (UX \\<inter> VX) \\<and> U \\<inter> V = S \\<inter> (UX \\<inter> VX)", "show \"ind_is_open (U \\<inter> V)\""], ["proof (prove)\nusing this:\n  is_open (UX \\<inter> VX) \\<and> U \\<inter> V = S \\<inter> (UX \\<inter> VX)\n\ngoal (1 subgoal):\n 1. ind_is_open (U \\<inter> V)", "by (metis \\<open>UX \\<subseteq> X\\<close> ind_is_open_def le_infI1 subset_refl)"], ["proof (state)\nthis:\n  ind_is_open (U \\<inter> V)\n\ngoal (4 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "fix F"], ["proof (state)\ngoal (4 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "assume F: \"\\<And>x. x \\<in> F \\<Longrightarrow> ind_is_open x\""], ["proof (state)\nthis:\n  ?x \\<in> F \\<Longrightarrow> ind_is_open ?x\n\ngoal (4 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "obtain F' where F': \"\\<And>x. x \\<in> F \\<and> ind_is_open x \\<Longrightarrow> is_open (F' x) \\<and> x = S \\<inter> (F' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>F'.\n        (\\<And>x.\n            x \\<in> F \\<and> ind_is_open x \\<Longrightarrow>\n            is_open (F' x) \\<and> x = S \\<inter> F' x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ind_is_open_def"], ["proof (prove)\nusing this:\n  ind_is_open ?U \\<equiv>\n  ?U \\<subseteq> S \\<and>\n  (\\<exists>V\\<subseteq>X. is_open V \\<and> ?U = S \\<inter> V)\n\ngoal (1 subgoal):\n 1. (\\<And>F'.\n        (\\<And>x.\n            x \\<in> F \\<and> ind_is_open x \\<Longrightarrow>\n            is_open (F' x) \\<and> x = S \\<inter> F' x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?x \\<in> F \\<and> ind_is_open ?x \\<Longrightarrow>\n  is_open (F' ?x) \\<and> ?x = S \\<inter> F' ?x\n\ngoal (4 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "have \"is_open (\\<Union> (F' ` F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_open (\\<Union> (F' ` F))", "by (metis (mono_tags, lifting) F F' imageE image_ident open_union)"], ["proof (state)\nthis:\n  is_open (\\<Union> (F' ` F))\n\ngoal (4 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "moreover"], ["proof (state)\nthis:\n  is_open (\\<Union> (F' ` F))\n\ngoal (4 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "have \"(\\<Union>x\\<in>F. x) = S \\<inter> \\<Union> (F' ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>F. x) = S \\<inter> \\<Union> (F' ` F)", "using F' \\<open>\\<And>x. x \\<in> F \\<Longrightarrow> ind_is_open x\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> F \\<and> ind_is_open ?x \\<Longrightarrow>\n  is_open (F' ?x) \\<and> ?x = S \\<inter> F' ?x\n  ?x \\<in> F \\<Longrightarrow> ind_is_open ?x\n\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>F. x) = S \\<inter> \\<Union> (F' ` F)", "by fastforce"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>F. x) = S \\<inter> \\<Union> (F' ` F)\n\ngoal (4 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\n 4. \\<And>F.\n       (\\<And>x.\n           x \\<in> F \\<Longrightarrow> ind_is_open x) \\<Longrightarrow>\n       ind_is_open (\\<Union>x\\<in>F. x)", "ultimately"], ["proof (chain)\npicking this:\n  is_open (\\<Union> (F' ` F))\n  (\\<Union>x\\<in>F. x) = S \\<inter> \\<Union> (F' ` F)", "show \"ind_is_open (\\<Union>x\\<in>F. x)\""], ["proof (prove)\nusing this:\n  is_open (\\<Union> (F' ` F))\n  (\\<Union>x\\<in>F. x) = S \\<inter> \\<Union> (F' ` F)\n\ngoal (1 subgoal):\n 1. ind_is_open (\\<Union>x\\<in>F. x)", "by (metis ind_is_open_def inf_sup_ord(1) open_imp_subset)"], ["proof (state)\nthis:\n  ind_is_open (\\<Union>x\\<in>F. x)\n\ngoal (3 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}\n 3. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S", "show \"\\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>U. ind_is_open U \\<Longrightarrow> U \\<subseteq> S", "by (simp add: ind_is_open_def)"], ["proof (state)\nthis:\n  ind_is_open ?U \\<Longrightarrow> ?U \\<subseteq> S\n\ngoal (2 subgoals):\n 1. ind_is_open S\n 2. ind_is_open {}", "qed auto"], ["", "lemma is_open_from_ind_is_open:\n  assumes \"is_open S\" and \"ind_is_open U\"\n  shows \"is_open U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_open U", "using assms open_inter ind_is_open_def is_subset"], ["proof (prove)\nusing this:\n  is_open S\n  ind_is_open U\n  \\<lbrakk>is_open ?U; is_open ?V\\<rbrakk>\n  \\<Longrightarrow> is_open (?U \\<inter> ?V)\n  ind_is_open ?U \\<equiv>\n  ?U \\<subseteq> S \\<and>\n  (\\<exists>V\\<subseteq>X. is_open V \\<and> ?U = S \\<inter> V)\n  S \\<subseteq> X\n\ngoal (1 subgoal):\n 1. is_open U", "by auto"], ["", "lemma open_cover_from_ind_open_cover:\n  assumes \"is_open S\" and \"open_cover_of_open_subset S ind_is_open U I C\"\n  shows \"open_cover_of_open_subset X is_open U I C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open_cover_of_open_subset X is_open U I C", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. U \\<subseteq> X\n 2. \\<And>i. i \\<in> I \\<Longrightarrow> C i \\<subseteq> X\n 3. U \\<subseteq> \\<Union> (C ` I)\n 4. \\<And>i. i \\<in> I \\<Longrightarrow> is_open (C i)\n 5. is_open U", "show \"is_open U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_open U", "using assms is_open_from_ind_is_open open_cover_of_open_subset.is_open_subset"], ["proof (prove)\nusing this:\n  is_open S\n  open_cover_of_open_subset S ind_is_open U I C\n  \\<lbrakk>is_open S; ind_is_open ?U\\<rbrakk> \\<Longrightarrow> is_open ?U\n  open_cover_of_open_subset ?X ?is_open ?U ?I ?C \\<Longrightarrow>\n  ?is_open ?U\n\ngoal (1 subgoal):\n 1. is_open U", "by blast"], ["proof (state)\nthis:\n  is_open U\n\ngoal (4 subgoals):\n 1. U \\<subseteq> X\n 2. \\<And>i. i \\<in> I \\<Longrightarrow> C i \\<subseteq> X\n 3. U \\<subseteq> \\<Union> (C ` I)\n 4. \\<And>i. i \\<in> I \\<Longrightarrow> is_open (C i)", "show \"\\<And>i. i \\<in> I \\<Longrightarrow> is_open (C i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> is_open (C i)", "using assms is_open_from_ind_is_open open_cover_of_open_subset_def open_cover_of_subset.are_open_subspaces"], ["proof (prove)\nusing this:\n  is_open S\n  open_cover_of_open_subset S ind_is_open U I C\n  \\<lbrakk>is_open S; ind_is_open ?U\\<rbrakk> \\<Longrightarrow> is_open ?U\n  open_cover_of_open_subset ?X ?is_open ?U ?I ?C \\<equiv>\n  open_cover_of_subset ?X ?is_open ?U ?I ?C \\<and>\n  open_cover_of_open_subset_axioms ?is_open ?U\n  \\<lbrakk>open_cover_of_subset ?X ?is_open ?U ?I ?C; ?i \\<in> ?I\\<rbrakk>\n  \\<Longrightarrow> ?is_open (?C ?i)\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> is_open (C i)", "by blast"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow> is_open (C ?i)\n\ngoal (3 subgoals):\n 1. U \\<subseteq> X\n 2. \\<And>i. i \\<in> I \\<Longrightarrow> C i \\<subseteq> X\n 3. U \\<subseteq> \\<Union> (C ` I)", "show \"\\<And>i. i \\<in> I \\<Longrightarrow> C i \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> C i \\<subseteq> X", "using assms(2) is_subset"], ["proof (prove)\nusing this:\n  open_cover_of_open_subset S ind_is_open U I C\n  S \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> C i \\<subseteq> X", "by (meson cover_of_subset_def open_cover_of_open_subset_def open_cover_of_subset_def subset_trans)"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow> C ?i \\<subseteq> X\n\ngoal (2 subgoals):\n 1. U \\<subseteq> X\n 2. U \\<subseteq> \\<Union> (C ` I)", "show \"U \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "by (simp add: \\<open>is_open U\\<close> open_imp_subset)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. U \\<subseteq> \\<Union> (C ` I)", "show \"U \\<subseteq> \\<Union> (C ` I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> \\<Union> (C ` I)", "by (meson assms(2) cover_of_subset_def open_cover_of_open_subset_def open_cover_of_subset_def)"], ["proof (state)\nthis:\n  U \\<subseteq> \\<Union> (C ` I)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* induced topology *)"], ["", "lemma (in topological_space) ind_topology_is_open_self [iff]: \"ind_topology S is_open S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ind_topology S is_open S", "by (simp add: ind_topology_axioms_def ind_topology_def topological_space_axioms)"], ["", "lemma (in topological_space) ind_topology_is_open_empty [iff]: \"ind_topology S is_open {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ind_topology S is_open {}", "by (simp add: ind_topology_axioms_def ind_topology_def topological_space_axioms)"], ["", "lemma (in topological_space) ind_is_open_iff_open:\n  shows \"ind_topology.ind_is_open S is_open S U \\<longleftrightarrow> is_open U \\<and> U \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ind_topology.ind_is_open S is_open S U =\n    (is_open U \\<and> U \\<subseteq> S)", "by (metis ind_topology.ind_is_open_def ind_topology_is_open_self inf.absorb_iff2)"], ["", "subsection \\<open>Continuous Maps\\<close>"], ["", "locale continuous_map = source: topological_space S is_open + target: topological_space S' is_open'\n+ map f S S'\n  for S and is_open and S' and is_open' and f +\n  assumes is_continuous: \"\\<And>U. is_open' U \\<Longrightarrow> is_open (f\\<^sup>\\<inverse> S U)\"\nbegin"], ["", "lemma open_cover_of_open_subset_from_target_to_source:\n  assumes \"open_cover_of_open_subset S' is_open' U I C\"\n  shows \"open_cover_of_open_subset S is_open (f\\<^sup>\\<inverse> S U) I (\\<lambda>i. f\\<^sup>\\<inverse> S (C i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open_cover_of_open_subset S is_open (f \\<^sup>\\<inverse> S U) I\n     (\\<lambda>i. f \\<^sup>\\<inverse> S (C i))", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. f \\<^sup>\\<inverse> S U \\<subseteq> S\n 2. \\<And>i.\n       i \\<in> I \\<Longrightarrow> f \\<^sup>\\<inverse> S (C i) \\<subseteq> S\n 3. f \\<^sup>\\<inverse> S U\n    \\<subseteq> (\\<Union>i\\<in>I. f \\<^sup>\\<inverse> S (C i))\n 4. \\<And>i.\n       i \\<in> I \\<Longrightarrow> is_open (f \\<^sup>\\<inverse> S (C i))\n 5. is_open (f \\<^sup>\\<inverse> S U)", "show \"f \\<^sup>\\<inverse> S U \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<^sup>\\<inverse> S U \\<subseteq> S", "by simp"], ["proof (state)\nthis:\n  f \\<^sup>\\<inverse> S U \\<subseteq> S\n\ngoal (4 subgoals):\n 1. \\<And>i.\n       i \\<in> I \\<Longrightarrow> f \\<^sup>\\<inverse> S (C i) \\<subseteq> S\n 2. f \\<^sup>\\<inverse> S U\n    \\<subseteq> (\\<Union>i\\<in>I. f \\<^sup>\\<inverse> S (C i))\n 3. \\<And>i.\n       i \\<in> I \\<Longrightarrow> is_open (f \\<^sup>\\<inverse> S (C i))\n 4. is_open (f \\<^sup>\\<inverse> S U)", "show \"f \\<^sup>\\<inverse> S (C i) \\<subseteq> S\" if \"i \\<in> I\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<^sup>\\<inverse> S (C i) \\<subseteq> S", "using that"], ["proof (prove)\nusing this:\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. f \\<^sup>\\<inverse> S (C i) \\<subseteq> S", "by simp"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow> f \\<^sup>\\<inverse> S (C ?i) \\<subseteq> S\n\ngoal (3 subgoals):\n 1. f \\<^sup>\\<inverse> S U\n    \\<subseteq> (\\<Union>i\\<in>I. f \\<^sup>\\<inverse> S (C i))\n 2. \\<And>i.\n       i \\<in> I \\<Longrightarrow> is_open (f \\<^sup>\\<inverse> S (C i))\n 3. is_open (f \\<^sup>\\<inverse> S U)", "show \"is_open (f \\<^sup>\\<inverse> S U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_open (f \\<^sup>\\<inverse> S U)", "by (meson assms is_continuous open_cover_of_open_subset.is_open_subset)"], ["proof (state)\nthis:\n  is_open (f \\<^sup>\\<inverse> S U)\n\ngoal (2 subgoals):\n 1. f \\<^sup>\\<inverse> S U\n    \\<subseteq> (\\<Union>i\\<in>I. f \\<^sup>\\<inverse> S (C i))\n 2. \\<And>i.\n       i \\<in> I \\<Longrightarrow> is_open (f \\<^sup>\\<inverse> S (C i))", "show \"\\<And>i. i \\<in> I \\<Longrightarrow> is_open (f \\<^sup>\\<inverse> S (C i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> I \\<Longrightarrow> is_open (f \\<^sup>\\<inverse> S (C i))", "by (meson assms is_continuous open_cover_of_open_subset_def open_cover_of_subset.are_open_subspaces)"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow> is_open (f \\<^sup>\\<inverse> S (C ?i))\n\ngoal (1 subgoal):\n 1. f \\<^sup>\\<inverse> S U\n    \\<subseteq> (\\<Union>i\\<in>I. f \\<^sup>\\<inverse> S (C i))", "show \"f \\<^sup>\\<inverse> S U \\<subseteq> (\\<Union>i\\<in>I. f \\<^sup>\\<inverse> S (C i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<^sup>\\<inverse> S U\n    \\<subseteq> (\\<Union>i\\<in>I. f \\<^sup>\\<inverse> S (C i))", "using assms"], ["proof (prove)\nusing this:\n  open_cover_of_open_subset S' is_open' U I C\n\ngoal (1 subgoal):\n 1. f \\<^sup>\\<inverse> S U\n    \\<subseteq> (\\<Union>i\\<in>I. f \\<^sup>\\<inverse> S (C i))", "unfolding open_cover_of_open_subset_def cover_of_subset_def open_cover_of_subset_def"], ["proof (prove)\nusing this:\n  (topological_space S' is_open' \\<and>\n   (U \\<subseteq> S' \\<and>\n    (\\<forall>i. i \\<in> I \\<longrightarrow> C i \\<subseteq> S') \\<and>\n    U \\<subseteq> \\<Union> (C ` I)) \\<and>\n   open_cover_of_subset_axioms is_open' I C) \\<and>\n  open_cover_of_open_subset_axioms is_open' U\n\ngoal (1 subgoal):\n 1. f \\<^sup>\\<inverse> S U\n    \\<subseteq> (\\<Union>i\\<in>I. f \\<^sup>\\<inverse> S (C i))", "by blast"], ["proof (state)\nthis:\n  f \\<^sup>\\<inverse> S U\n  \\<subseteq> (\\<Union>i\\<in>I. f \\<^sup>\\<inverse> S (C i))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* continuous map *)"], ["", "subsection \\<open>Homeomorphisms\\<close>"], ["", "text \\<open>The topological isomorphisms between topological spaces are called homeomorphisms.\\<close>"], ["", "locale homeomorphism =\n  continuous_map + bijective_map f S S' +\n  continuous_map S' is_open' S is_open \"inverse_map f S S'\""], ["", "lemma (in topological_space) id_is_homeomorphism:\n  shows \"homeomorphism S is_open S is_open (identity S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism S is_open S is_open (identity S)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. identity S \\<in> S \\<rightarrow>\\<^sub>E S\n 2. \\<And>U.\n       is_open U \\<Longrightarrow>\n       is_open (identity S \\<^sup>\\<inverse> S U)\n 3. bij_betw (identity S) S S\n 4. inverse_map (identity S) S S \\<in> S \\<rightarrow>\\<^sub>E S\n 5. \\<And>U.\n       is_open U \\<Longrightarrow>\n       is_open (inverse_map (identity S) S S \\<^sup>\\<inverse> S U)", "show \"inverse_map (identity S) S S \\<in> S \\<rightarrow>\\<^sub>E S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_map (identity S) S S \\<in> S \\<rightarrow>\\<^sub>E S", "by (simp add: inv_into_into inverse_map_def)"], ["proof (state)\nthis:\n  inverse_map (identity S) S S \\<in> S \\<rightarrow>\\<^sub>E S\n\ngoal (4 subgoals):\n 1. identity S \\<in> S \\<rightarrow>\\<^sub>E S\n 2. \\<And>U.\n       is_open U \\<Longrightarrow>\n       is_open (identity S \\<^sup>\\<inverse> S U)\n 3. bij_betw (identity S) S S\n 4. \\<And>U.\n       is_open U \\<Longrightarrow>\n       is_open (inverse_map (identity S) S S \\<^sup>\\<inverse> S U)", "qed (auto simp: open_inter bij_betwI')"], ["", "subsection \\<open>Topological Filters\\<close>"], ["", "(* Imported from HOL.Topological_Spaces *)"], ["", "definition (in topological_space) nhds :: \"'a \\<Rightarrow> 'a filter\"\n  where \"nhds a = (INF S\\<in>{S. is_open S \\<and> a \\<in> S}. principal S)\""], ["", "abbreviation (in topological_space)\n  tendsto :: \"('b \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'b filter \\<Rightarrow> bool\"  (infixr \"\\<longlongrightarrow>\" 55)\n  where \"(f \\<longlongrightarrow> l) F \\<equiv> filterlim f (nhds l) F\""], ["", "definition (in t2_space) Lim :: \"'f filter \\<Rightarrow> ('f \\<Rightarrow> 'a) \\<Rightarrow> 'a\"\n  where \"Lim A f = (THE l. (f \\<longlongrightarrow> l) A)\""], ["", "end"]]}