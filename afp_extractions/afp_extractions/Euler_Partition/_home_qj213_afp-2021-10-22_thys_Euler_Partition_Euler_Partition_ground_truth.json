{"file_name": "/home/qj213/afp-2021-10-22/thys/Euler_Partition/Euler_Partition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Euler_Partition", "problem_names": ["lemma power_div_nat:\n  assumes \"c \\<le> b\"\n  assumes \"a > 0\"\n  shows  \"(a :: nat) ^ b div a ^ c = a ^ (b - c)\"", "lemma sum_div:\n  assumes \"finite A\"\n  assumes \"\\<And>a. a \\<in> A \\<Longrightarrow> (b::'b::euclidean_semiring) dvd f a\"\n  shows \"(\\<Sum>a\\<in>A. f a) div b = (\\<Sum>a\\<in>A. (f a) div b)\"", "lemma sum_mod:\n  assumes \"finite A\"\n  assumes \"\\<And>a. a \\<in> A \\<Longrightarrow> f a mod b = (0::'b::unique_euclidean_semiring)\"\n  shows \"(\\<Sum>a\\<in>A. f a) mod b = 0\"", "lemma finite_exponents:\n  \"finite {i. 2 ^ i \\<le> (n::nat)}\"", "lemma in_bitset_bound:\n  \"b \\<in> bitset n \\<Longrightarrow> 2 ^ b \\<le> n\"", "lemma in_bitset_bound_weak:\n  \"b \\<in> bitset n \\<Longrightarrow> b \\<le> n\"", "lemma finite_bitset:\n  \"finite (bitset n)\"", "lemma bitset_0:\n  \"bitset 0 = {}\"", "lemma bitset_2n: \"bitset (2 * n) = Suc ` (bitset n)\"", "lemma bitset_Suc:\n  assumes \"even n\"\n  shows \"bitset (n + 1) = insert 0 (bitset n)\"", "lemma bitset_2n1:\n  \"bitset (2 * n + 1) = insert 0 (Suc ` (bitset n))\"", "lemma sum_bitset:\n  \"(\\<Sum>i\\<in>bitset n. 2 ^ i) = n\"", "lemma binarysum_div:\n  assumes \"finite B\"\n  shows \"(\\<Sum>i\\<in>B. (2::nat) ^ i) div 2 ^ j = (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))\"\n  (is \"_ = (\\<Sum>i\\<in>_. ?f i)\")", "lemma odd_iff:\n  assumes \"finite B\"\n  shows \"odd (\\<Sum>i\\<in>B. if i < x then (0::nat) else 2 ^ (i - x)) = (x \\<in> B)\" (is \"odd (\\<Sum>i\\<in>_. ?s i) = _\")", "lemma bitset_sum:\n  assumes \"finite B\"\n  shows \"bitset (\\<Sum>i\\<in>B. 2 ^ i) = B\"", "lemma odd_oddpart:\n  \"odd (oddpart n) \\<longleftrightarrow> n \\<noteq> 0\"", "lemma index_oddpart_decomposition:\n  \"n = 2 ^ (index n) * oddpart n\"", "lemma oddpart_leq:\n  \"oddpart n \\<le> n\"", "lemma index_oddpart_unique:\n  assumes \"odd (m :: nat)\" \"odd m'\"\n  shows \"(2 ^ i * m = 2 ^ i' * m') \\<longleftrightarrow> (i = i' \\<and> m = m')\"", "lemma index_oddpart:\n  assumes \"odd m\"\n  shows \"index (2 ^ i * m) = i\" \"oddpart (2 ^ i * m) = m\"", "lemma odd:\n  \"odd_of_distinct p i \\<noteq> 0 \\<Longrightarrow> odd i\"", "lemma distinct_distinct_of_odd:\n  \"distinct_of_odd p i \\<le> 1\"", "lemma odd_of_distinct:\n  assumes \"odd_of_distinct p i \\<noteq> 0\"\n  assumes \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> i \\<le> n\"\n  shows \"1 \\<le> i \\<and> i \\<le> n\"", "lemma distinct_of_odd:\n  assumes \"\\<And>i. p i * i \\<le> n\" \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> odd i\"\n  assumes \"distinct_of_odd p i \\<noteq> 0\"\n  shows \"1 \\<le> i \\<and> i \\<le> n\"", "lemma odd_distinct:\n  assumes \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> odd i\"\n  shows \"odd_of_distinct (distinct_of_odd p) = p\"", "lemma distinct_odd:\n  assumes \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> 1 \\<le> i \\<and> i \\<le> n\" \"\\<And>i. p i \\<le> 1\"\n  shows \"distinct_of_odd (odd_of_distinct p) = p\"", "lemma sum_distinct_of_odd:\n  assumes \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> 1 \\<le> i \\<and> i \\<le> n\"\n  assumes \"\\<And>i. p i * i \\<le> n\"\n  assumes \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> odd i\"\n  shows \"(\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)\"", "lemma leq_n:\n  assumes \"\\<forall>i. 0 < p i \\<longrightarrow> 1 \\<le> i \\<and> i \\<le> (n::nat)\"\n  assumes \"(\\<Sum>i\\<le>n. p i * i) = n\"\n  shows \"p i * i \\<le> n\"", "lemma distinct_of_odd_in_distinct_partitions:\n  assumes \"p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\"\n  shows \"distinct_of_odd p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\"", "lemma odd_of_distinct_in_odd_partitions:\n  assumes \"p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\"\n  shows \"odd_of_distinct p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\"", "theorem Euler_partition_theorem:\n  \"card {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)} = card {p. p partitions n \\<and> (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\"\n  (is \"card ?distinct_partitions = card ?odd_partitions\")"], "translations": [["", "lemma power_div_nat:\n  assumes \"c \\<le> b\"\n  assumes \"a > 0\"\n  shows  \"(a :: nat) ^ b div a ^ c = a ^ (b - c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ^ b div a ^ c = a ^ (b - c)", "by (metis assms nonzero_mult_div_cancel_right le_add_diff_inverse2 less_not_refl2 power_add power_not_zero)"], ["", "subsubsection \\<open>Additions to Groups-Big Theory\\<close>"], ["", "lemma sum_div:\n  assumes \"finite A\"\n  assumes \"\\<And>a. a \\<in> A \\<Longrightarrow> (b::'b::euclidean_semiring) dvd f a\"\n  shows \"(\\<Sum>a\\<in>A. f a) div b = (\\<Sum>a\\<in>A. (f a) div b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f A div b = (\\<Sum>a\\<in>A. f a div b)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  ?a \\<in> A \\<Longrightarrow> b dvd f ?a\n\ngoal (1 subgoal):\n 1. sum f A div b = (\\<Sum>a\\<in>A. f a div b)", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>a. a \\<in> {} \\<Longrightarrow> b dvd f a) \\<Longrightarrow>\n    sum f {} div b = (\\<Sum>a\\<in>{}. f a div b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a. a \\<in> F \\<Longrightarrow> b dvd f a) \\<Longrightarrow>\n        sum f F div b = (\\<Sum>a\\<in>F. f a div b);\n        \\<And>a. a \\<in> insert x F \\<Longrightarrow> b dvd f a\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) div b =\n                         (\\<Sum>a\\<in>insert x F. f a div b)", "case insert"], ["proof (state)\nthis:\n  finite F_\n  x_ \\<notin> F_\n  (\\<And>a. a \\<in> F_ \\<Longrightarrow> b dvd f a) \\<Longrightarrow>\n  sum f F_ div b = (\\<Sum>a\\<in>F_. f a div b)\n  ?a \\<in> insert x_ F_ \\<Longrightarrow> b dvd f ?a\n\ngoal (2 subgoals):\n 1. (\\<And>a. a \\<in> {} \\<Longrightarrow> b dvd f a) \\<Longrightarrow>\n    sum f {} div b = (\\<Sum>a\\<in>{}. f a div b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a. a \\<in> F \\<Longrightarrow> b dvd f a) \\<Longrightarrow>\n        sum f F div b = (\\<Sum>a\\<in>F. f a div b);\n        \\<And>a. a \\<in> insert x F \\<Longrightarrow> b dvd f a\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) div b =\n                         (\\<Sum>a\\<in>insert x F. f a div b)", "from this"], ["proof (chain)\npicking this:\n  finite F_\n  x_ \\<notin> F_\n  (\\<And>a. a \\<in> F_ \\<Longrightarrow> b dvd f a) \\<Longrightarrow>\n  sum f F_ div b = (\\<Sum>a\\<in>F_. f a div b)\n  ?a \\<in> insert x_ F_ \\<Longrightarrow> b dvd f ?a", "show ?case"], ["proof (prove)\nusing this:\n  finite F_\n  x_ \\<notin> F_\n  (\\<And>a. a \\<in> F_ \\<Longrightarrow> b dvd f a) \\<Longrightarrow>\n  sum f F_ div b = (\\<Sum>a\\<in>F_. f a div b)\n  ?a \\<in> insert x_ F_ \\<Longrightarrow> b dvd f ?a\n\ngoal (1 subgoal):\n 1. sum f (insert x_ F_) div b = (\\<Sum>a\\<in>insert x_ F_. f a div b)", "by auto (subst div_add; auto intro!: dvd_sum)"], ["proof (state)\nthis:\n  sum f (insert x_ F_) div b = (\\<Sum>a\\<in>insert x_ F_. f a div b)\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> {} \\<Longrightarrow> b dvd f a) \\<Longrightarrow>\n    sum f {} div b = (\\<Sum>a\\<in>{}. f a div b)", "qed (auto)"], ["", "lemma sum_mod:\n  assumes \"finite A\"\n  assumes \"\\<And>a. a \\<in> A \\<Longrightarrow> f a mod b = (0::'b::unique_euclidean_semiring)\"\n  shows \"(\\<Sum>a\\<in>A. f a) mod b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f A mod b = (0::'b)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  ?a \\<in> A \\<Longrightarrow> f ?a mod b = (0::'b)\n\ngoal (1 subgoal):\n 1. sum f A mod b = (0::'b)", "by induct (auto simp add: mod_add_eq [symmetric])"], ["", "subsubsection \\<open>Additions to Finite-Set Theory\\<close>"], ["", "lemma finite_exponents:\n  \"finite {i. 2 ^ i \\<le> (n::nat)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. 2 ^ i \\<le> n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {i. 2 ^ i \\<le> n}", "have \"{i::nat. 2 ^ i \\<le> n} \\<subseteq> {0..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. 2 ^ i \\<le> n} \\<subseteq> {0..n}", "using dual_order.trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. {i. 2 ^ i \\<le> n} \\<subseteq> {0..n}", "by fastforce"], ["proof (state)\nthis:\n  {i. 2 ^ i \\<le> n} \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. finite {i. 2 ^ i \\<le> n}", "from finite_subset[OF this]"], ["proof (chain)\npicking this:\n  finite {0..n} \\<Longrightarrow> finite {i. 2 ^ i \\<le> n}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {0..n} \\<Longrightarrow> finite {i. 2 ^ i \\<le> n}\n\ngoal (1 subgoal):\n 1. finite {i. 2 ^ i \\<le> n}", "by simp"], ["proof (state)\nthis:\n  finite {i. 2 ^ i \\<le> n}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Binary Encoding of Natural Numbers\\<close>"], ["", "definition bitset :: \"nat \\<Rightarrow> nat set\"\nwhere\n  \"bitset n = {i. odd (n div (2 ^ i))}\""], ["", "lemma in_bitset_bound:\n  \"b \\<in> bitset n \\<Longrightarrow> 2 ^ b \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> bitset n \\<Longrightarrow> 2 ^ b \\<le> n", "unfolding bitset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> {i. odd (n div 2 ^ i)} \\<Longrightarrow> 2 ^ b \\<le> n", "using not_less"], ["proof (prove)\nusing this:\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. b \\<in> {i. odd (n div 2 ^ i)} \\<Longrightarrow> 2 ^ b \\<le> n", "by fastforce"], ["", "lemma in_bitset_bound_weak:\n  \"b \\<in> bitset n \\<Longrightarrow> b \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> bitset n \\<Longrightarrow> b \\<le> n", "by (meson order.trans in_bitset_bound self_le_ge2_pow[OF order_refl])"], ["", "lemma finite_bitset:\n  \"finite (bitset n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (bitset n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bitset n)", "have \"bitset n \\<subseteq> {..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitset n \\<subseteq> {..n}", "by (auto dest: in_bitset_bound_weak)"], ["proof (state)\nthis:\n  bitset n \\<subseteq> {..n}\n\ngoal (1 subgoal):\n 1. finite (bitset n)", "from this"], ["proof (chain)\npicking this:\n  bitset n \\<subseteq> {..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  bitset n \\<subseteq> {..n}\n\ngoal (1 subgoal):\n 1. finite (bitset n)", "using finite_subset"], ["proof (prove)\nusing this:\n  bitset n \\<subseteq> {..n}\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (bitset n)", "by auto"], ["proof (state)\nthis:\n  finite (bitset n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bitset_0:\n  \"bitset 0 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitset 0 = {}", "unfolding bitset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. odd (0 div 2 ^ i)} = {}", "by auto"], ["", "lemma bitset_2n: \"bitset (2 * n) = Suc ` (bitset n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitset (2 * n) = Suc ` bitset n", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> bitset (2 * n)) = (x \\<in> Suc ` bitset n)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> bitset (2 * n)) = (x \\<in> Suc ` bitset n)", "show \"(x \\<in> bitset (2 * n)) = (x \\<in> Suc ` bitset n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> bitset (2 * n)) = (x \\<in> Suc ` bitset n)", "unfolding bitset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {i. odd (2 * n div 2 ^ i)}) =\n    (x \\<in> Suc ` {i. odd (n div 2 ^ i)})", "by (cases x) auto"], ["proof (state)\nthis:\n  (x \\<in> bitset (2 * n)) = (x \\<in> Suc ` bitset n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bitset_Suc:\n  assumes \"even n\"\n  shows \"bitset (n + 1) = insert 0 (bitset n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitset (n + 1) = insert 0 (bitset n)", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> bitset (n + 1)) = (x \\<in> insert 0 (bitset n))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> bitset (n + 1)) = (x \\<in> insert 0 (bitset n))", "from assms"], ["proof (chain)\npicking this:\n  even n", "show \"(x \\<in> bitset (n + 1)) = (x \\<in> insert 0 (bitset n))\""], ["proof (prove)\nusing this:\n  even n\n\ngoal (1 subgoal):\n 1. (x \\<in> bitset (n + 1)) = (x \\<in> insert 0 (bitset n))", "unfolding bitset_def"], ["proof (prove)\nusing this:\n  even n\n\ngoal (1 subgoal):\n 1. (x \\<in> {i. odd ((n + 1) div 2 ^ i)}) =\n    (x \\<in> insert 0 {i. odd (n div 2 ^ i)})", "by (cases x) (auto simp add: Divides.div_mult2_eq)"], ["proof (state)\nthis:\n  (x \\<in> bitset (n + 1)) = (x \\<in> insert 0 (bitset n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bitset_2n1:\n  \"bitset (2 * n + 1) = insert 0 (Suc ` (bitset n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitset (2 * n + 1) = insert 0 (Suc ` bitset n)", "by (subst bitset_Suc) (auto simp add: bitset_2n)"], ["", "lemma sum_bitset:\n  \"(\\<Sum>i\\<in>bitset n. 2 ^ i) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) 2) (bitset n) = n", "proof (induct rule: nat_bit_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. sum ((^) 2) (bitset 0) = 0\n 2. \\<And>n.\n       \\<lbrakk>sum ((^) 2) (bitset n) = n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> sum ((^) 2) (bitset (2 * n)) = 2 * n\n 3. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "case zero"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. sum ((^) 2) (bitset 0) = 0\n 2. \\<And>n.\n       \\<lbrakk>sum ((^) 2) (bitset n) = n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> sum ((^) 2) (bitset (2 * n)) = 2 * n\n 3. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) 2) (bitset 0) = 0", "by (auto simp add: bitset_0)"], ["proof (state)\nthis:\n  sum ((^) 2) (bitset 0) = 0\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>sum ((^) 2) (bitset n) = n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> sum ((^) 2) (bitset (2 * n)) = 2 * n\n 2. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>sum ((^) 2) (bitset n) = n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> sum ((^) 2) (bitset (2 * n)) = 2 * n\n 2. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "case (even n)"], ["proof (state)\nthis:\n  sum ((^) 2) (bitset n) = n\n  0 < n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>sum ((^) 2) (bitset n) = n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> sum ((^) 2) (bitset (2 * n)) = 2 * n\n 2. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "from this"], ["proof (chain)\npicking this:\n  sum ((^) 2) (bitset n) = n\n  0 < n", "show ?case"], ["proof (prove)\nusing this:\n  sum ((^) 2) (bitset n) = n\n  0 < n\n\ngoal (1 subgoal):\n 1. sum ((^) 2) (bitset (2 * n)) = 2 * n", "by (simp add: bitset_2n sum.reindex sum_distrib_left[symmetric])"], ["proof (state)\nthis:\n  sum ((^) 2) (bitset (2 * n)) = 2 * n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "case (odd n)"], ["proof (state)\nthis:\n  sum ((^) 2) (bitset n) = n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "have \"(\\<Sum>i\\<in>bitset (2 * n + 1). 2 ^ i) = (\\<Sum>i\\<in>insert 0 (Suc ` bitset n). 2 ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) (2::'a)) (bitset (2 * n + 1)) =\n    sum ((^) (2::'a)) (insert 0 (Suc ` bitset n))", "by (simp only: bitset_2n1)"], ["proof (state)\nthis:\n  sum ((^) (2::?'a1)) (bitset (2 * n + 1)) =\n  sum ((^) (2::?'a1)) (insert 0 (Suc ` bitset n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "also"], ["proof (state)\nthis:\n  sum ((^) (2::?'a1)) (bitset (2 * n + 1)) =\n  sum ((^) (2::?'a1)) (insert 0 (Suc ` bitset n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "have \"... = 2 ^ 0 + (\\<Sum>i\\<in>Suc ` bitset n. 2 ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) (2::'a)) (insert 0 (Suc ` bitset n)) =\n    (2::'a) ^ 0 + sum ((^) (2::'a)) (Suc ` bitset n)", "by (subst sum.insert) (auto simp add: finite_bitset)"], ["proof (state)\nthis:\n  sum ((^) (2::?'a2)) (insert 0 (Suc ` bitset n)) =\n  (2::?'a2) ^ 0 + sum ((^) (2::?'a2)) (Suc ` bitset n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "also"], ["proof (state)\nthis:\n  sum ((^) (2::?'a2)) (insert 0 (Suc ` bitset n)) =\n  (2::?'a2) ^ 0 + sum ((^) (2::?'a2)) (Suc ` bitset n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "have \"... = 2 * n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ 0 + sum ((^) 2) (Suc ` bitset n) = 2 * n + 1", "using odd"], ["proof (prove)\nusing this:\n  sum ((^) 2) (bitset n) = n\n\ngoal (1 subgoal):\n 1. 2 ^ 0 + sum ((^) 2) (Suc ` bitset n) = 2 * n + 1", "by (simp add: sum.reindex sum_distrib_left[symmetric])"], ["proof (state)\nthis:\n  2 ^ 0 + sum ((^) 2) (Suc ` bitset n) = 2 * n + 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sum ((^) 2) (bitset n) = n \\<Longrightarrow>\n       sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "finally"], ["proof (chain)\npicking this:\n  sum ((^) 2) (bitset (2 * n + 1)) = 2 * n + 1", "show ?case"], ["proof (prove)\nusing this:\n  sum ((^) 2) (bitset (2 * n + 1)) = 2 * n + 1\n\ngoal (1 subgoal):\n 1. sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)", "by simp"], ["proof (state)\nthis:\n  sum ((^) 2) (bitset (Suc (2 * n))) = Suc (2 * n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma binarysum_div:\n  assumes \"finite B\"\n  shows \"(\\<Sum>i\\<in>B. (2::nat) ^ i) div 2 ^ j = (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))\"\n  (is \"_ = (\\<Sum>i\\<in>_. ?f i)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "have split_B: \"B = {i\\<in>B. i < j} \\<union> {i\\<in>B. j \\<le> i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = {i \\<in> B. i < j} \\<union> {i \\<in> B. j \\<le> i}", "by auto"], ["proof (state)\nthis:\n  B = {i \\<in> B. i < j} \\<union> {i \\<in> B. j \\<le> i}\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "have bound: \"(\\<Sum>i | i \\<in> B \\<and> i < j. (2::nat) ^ i) < 2 ^ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) < 2 ^ j", "proof (rule order.strict_trans1)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) \\<le> ?b\n 2. ?b < 2 ^ j", "show \"(\\<Sum>i | i \\<in> B \\<and> i < j. (2::nat) ^ i) \\<le> (\\<Sum>i<j. 2 ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) \\<le> sum ((^) 2) {..<j}", "by (auto intro: sum_mono2)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) \\<le> sum ((^) 2) {..<j}\n\ngoal (1 subgoal):\n 1. sum ((^) 2) {..<j} < 2 ^ j", "show \"... < 2 ^ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) 2) {..<j} < 2 ^ j", "using sum_power2"], ["proof (prove)\nusing this:\n  sum ((^) 2) {0..<?k} = 2 ^ ?k - 1\n\ngoal (1 subgoal):\n 1. sum ((^) 2) {..<j} < 2 ^ j", "by (simp add: atLeast0LessThan)"], ["proof (state)\nthis:\n  sum ((^) 2) {..<j} < 2 ^ j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) < 2 ^ j\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "from this"], ["proof (chain)\npicking this:\n  (\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) < 2 ^ j", "have zero: \"(\\<Sum>i | i \\<in> B \\<and> i < j. (2::nat) ^ i) div (2 ^ j) = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) < 2 ^ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) div 2 ^ j = 0", "by (elim div_less)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) div 2 ^ j = 0\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "from assms"], ["proof (chain)\npicking this:\n  finite B", "have mod0: \"(\\<Sum>i | i \\<in> B \\<and> j \\<le> i. (2::nat) ^ i) mod 2 ^ j = 0\""], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i) mod 2 ^ j = 0", "by (auto intro!: sum_mod simp add: le_imp_power_dvd)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i) mod 2 ^ j = 0\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "from assms"], ["proof (chain)\npicking this:\n  finite B", "have \"(\\<Sum>i\\<in>B. (2::nat) ^ i) div (2 ^ j) = ((\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) + (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i)) div 2 ^ j\""], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    ((\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) +\n     (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i)) div\n    2 ^ j", "by (subst sum.union_disjoint[symmetric]) (auto simp add: split_B[symmetric])"], ["proof (state)\nthis:\n  sum ((^) 2) B div 2 ^ j =\n  ((\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) +\n   (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i)) div\n  2 ^ j\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "also"], ["proof (state)\nthis:\n  sum ((^) 2) B div 2 ^ j =\n  ((\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) +\n   (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i)) div\n  2 ^ j\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "have \"... = (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i) div 2 ^ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) +\n     (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i)) div\n    2 ^ j =\n    (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i) div 2 ^ j", "by (simp add: div_add1_eq zero mod0)"], ["proof (state)\nthis:\n  ((\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) +\n   (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i)) div\n  2 ^ j =\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i) div 2 ^ j\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "also"], ["proof (state)\nthis:\n  ((\\<Sum>i | i \\<in> B \\<and> i < j. 2 ^ i) +\n   (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i)) div\n  2 ^ j =\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i) div 2 ^ j\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "have \"... = (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i div 2 ^ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i) div 2 ^ j =\n    (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i div 2 ^ j)", "using assms"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i) div 2 ^ j =\n    (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i div 2 ^ j)", "by (subst sum_div) (auto simp add: sum_div le_imp_power_dvd)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i) div 2 ^ j =\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i div 2 ^ j)\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i) div 2 ^ j =\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i div 2 ^ j)\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "have \"... = (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ (i - j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i div 2 ^ j) =\n    (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ (i - j))", "by (rule sum.cong[OF refl]) (auto simp add: power_div_nat)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i div 2 ^ j) =\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ (i - j))\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ i div 2 ^ j) =\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ (i - j))\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "have \"... = (\\<Sum>i\\<in>B. ?f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ (i - j)) =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "using assms"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ (i - j)) =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "by (subst split_B; subst sum.union_disjoint) auto"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<in> B \\<and> j \\<le> i. 2 ^ (i - j)) =\n  (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "finally"], ["proof (chain)\npicking this:\n  sum ((^) 2) B div 2 ^ j =\n  (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum ((^) 2) B div 2 ^ j =\n  (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))\n\ngoal (1 subgoal):\n 1. sum ((^) 2) B div 2 ^ j =\n    (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))", "."], ["proof (state)\nthis:\n  sum ((^) 2) B div 2 ^ j =\n  (\\<Sum>i\\<in>B. if i < j then 0 else 2 ^ (i - j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odd_iff:\n  assumes \"finite B\"\n  shows \"odd (\\<Sum>i\\<in>B. if i < x then (0::nat) else 2 ^ (i - x)) = (x \\<in> B)\" (is \"odd (\\<Sum>i\\<in>_. ?s i) = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x)) = (x \\<in> B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x)) = (x \\<in> B)", "from assms"], ["proof (chain)\npicking this:\n  finite B", "have even: \"even (\\<Sum>i\\<in>B - {x}. ?s i)\""], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. even (\\<Sum>i\\<in>B - {x}. if i < x then 0 else 2 ^ (i - x))", "by (subst dvd_sum) auto"], ["proof (state)\nthis:\n  even (\\<Sum>i\\<in>B - {x}. if i < x then 0 else 2 ^ (i - x))\n\ngoal (1 subgoal):\n 1. odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x)) = (x \\<in> B)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x)) = (x \\<in> B)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x)) \\<Longrightarrow>\n    x \\<in> B\n 2. x \\<in> B \\<Longrightarrow>\n    odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x))", "assume \"odd (\\<Sum>i\\<in>B. ?s i)\""], ["proof (state)\nthis:\n  odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x))\n\ngoal (2 subgoals):\n 1. odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x)) \\<Longrightarrow>\n    x \\<in> B\n 2. x \\<in> B \\<Longrightarrow>\n    odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x))", "from this even"], ["proof (chain)\npicking this:\n  odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x))\n  even (\\<Sum>i\\<in>B - {x}. if i < x then 0 else 2 ^ (i - x))", "show \"x \\<in> B\""], ["proof (prove)\nusing this:\n  odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x))\n  even (\\<Sum>i\\<in>B - {x}. if i < x then 0 else 2 ^ (i - x))\n\ngoal (1 subgoal):\n 1. x \\<in> B", "by (cases \"x \\<in> B\") auto"], ["proof (state)\nthis:\n  x \\<in> B\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Longrightarrow>\n    odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> B \\<Longrightarrow>\n    odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x))", "assume \"x \\<in> B\""], ["proof (state)\nthis:\n  x \\<in> B\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Longrightarrow>\n    odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x))", "from assms this"], ["proof (chain)\npicking this:\n  finite B\n  x \\<in> B", "have \"(\\<Sum>i\\<in>B. ?s i) = 1 + (\\<Sum>i\\<in>B-{x}. ?s i)\""], ["proof (prove)\nusing this:\n  finite B\n  x \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x)) =\n    1 + (\\<Sum>i\\<in>B - {x}. if i < x then 0 else 2 ^ (i - x))", "by (auto simp add: sum.remove)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x)) =\n  1 + (\\<Sum>i\\<in>B - {x}. if i < x then 0 else 2 ^ (i - x))\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Longrightarrow>\n    odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x))", "from assms this even"], ["proof (chain)\npicking this:\n  finite B\n  (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x)) =\n  1 + (\\<Sum>i\\<in>B - {x}. if i < x then 0 else 2 ^ (i - x))\n  even (\\<Sum>i\\<in>B - {x}. if i < x then 0 else 2 ^ (i - x))", "show \"odd (\\<Sum>i\\<in>B. ?s i)\""], ["proof (prove)\nusing this:\n  finite B\n  (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x)) =\n  1 + (\\<Sum>i\\<in>B - {x}. if i < x then 0 else 2 ^ (i - x))\n  even (\\<Sum>i\\<in>B - {x}. if i < x then 0 else 2 ^ (i - x))\n\ngoal (1 subgoal):\n 1. odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x))", "by auto"], ["proof (state)\nthis:\n  odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd (\\<Sum>i\\<in>B. if i < x then 0 else 2 ^ (i - x)) = (x \\<in> B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bitset_sum:\n  assumes \"finite B\"\n  shows \"bitset (\\<Sum>i\\<in>B. 2 ^ i) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitset (sum ((^) 2) B) = B", "using assms"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. bitset (sum ((^) 2) B) = B", "unfolding bitset_def"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. {i. odd (sum ((^) 2) B div 2 ^ i)} = B", "by (simp add: binarysum_div odd_iff)"], ["", "subsection \\<open>Decomposition of a Number into a Power of Two and an Odd Number\\<close>"], ["", "function (sequential) index :: \"nat \\<Rightarrow> nat\"\nwhere\n  \"index 0 = 0\"\n| \"index n = (if odd n then 0 else Suc (index (n div 2)))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = 0 \\<Longrightarrow> P;\n        \\<And>v. x = Suc v \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. 0 = 0 \\<Longrightarrow> 0 = 0\n 3. \\<And>v.\n       0 = Suc v \\<Longrightarrow>\n       0 = (if odd (Suc v) then 0 else Suc (index_sumC (Suc v div 2)))\n 4. \\<And>v va.\n       Suc v = Suc va \\<Longrightarrow>\n       (if odd (Suc v) then 0 else Suc (index_sumC (Suc v div 2))) =\n       (if odd (Suc va) then 0 else Suc (index_sumC (Suc va div 2)))", "by (pat_completeness) auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All index_dom", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>v.\n       \\<not> odd (Suc v) \\<Longrightarrow> (Suc v div 2, Suc v) \\<in> ?R", "show \"wf {(x::nat, y). x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(x, y). x < y}", "by (simp add: wf)"], ["proof (state)\nthis:\n  wf {(x, y). x < y}\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<not> odd (Suc v) \\<Longrightarrow>\n       (Suc v div 2, Suc v) \\<in> {(x, y). x < y}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<not> odd (Suc v) \\<Longrightarrow>\n       (Suc v div 2, Suc v) \\<in> {(x, y). x < y}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<not> odd (Suc v) \\<Longrightarrow>\n       (Suc v div 2, Suc v) \\<in> {(x, y). x < y}", "show \"(Suc n div 2, Suc n) \\<in> {(x, y). x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc n div 2, Suc n) \\<in> {(x, y). x < y}", "by simp"], ["proof (state)\nthis:\n  (Suc n div 2, Suc n) \\<in> {(x, y). x < y}\n\ngoal:\nNo subgoals!", "qed"], ["", "function (sequential) oddpart :: \"nat \\<Rightarrow> nat\"\nwhere\n  \"oddpart 0 = 0\"\n| \"oddpart n = (if odd n then n else oddpart (n div 2))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = 0 \\<Longrightarrow> P;\n        \\<And>v. x = Suc v \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. 0 = 0 \\<Longrightarrow> 0 = 0\n 3. \\<And>v.\n       0 = Suc v \\<Longrightarrow>\n       0 = (if odd (Suc v) then Suc v else oddpart_sumC (Suc v div 2))\n 4. \\<And>v va.\n       Suc v = Suc va \\<Longrightarrow>\n       (if odd (Suc v) then Suc v else oddpart_sumC (Suc v div 2)) =\n       (if odd (Suc va) then Suc va else oddpart_sumC (Suc va div 2))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All oddpart_dom", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>v.\n       \\<not> odd (Suc v) \\<Longrightarrow> (Suc v div 2, Suc v) \\<in> ?R", "show \"wf {(x::nat, y). x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(x, y). x < y}", "by (simp add: wf)"], ["proof (state)\nthis:\n  wf {(x, y). x < y}\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<not> odd (Suc v) \\<Longrightarrow>\n       (Suc v div 2, Suc v) \\<in> {(x, y). x < y}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<not> odd (Suc v) \\<Longrightarrow>\n       (Suc v div 2, Suc v) \\<in> {(x, y). x < y}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<not> odd (Suc v) \\<Longrightarrow>\n       (Suc v div 2, Suc v) \\<in> {(x, y). x < y}", "show \"(Suc n div 2, Suc n) \\<in> {(x, y). x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc n div 2, Suc n) \\<in> {(x, y). x < y}", "by simp"], ["proof (state)\nthis:\n  (Suc n div 2, Suc n) \\<in> {(x, y). x < y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odd_oddpart:\n  \"odd (oddpart n) \\<longleftrightarrow> n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (oddpart n) = (n \\<noteq> 0)", "by (induct n rule: index.induct) auto"], ["", "lemma index_oddpart_decomposition:\n  \"n = 2 ^ (index n) * oddpart n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 2 ^ index n * oddpart n", "proof (induct n rule: index.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 = 2 ^ index 0 * oddpart 0\n 2. \\<And>v.\n       (\\<not> odd (Suc v) \\<Longrightarrow>\n        Suc v div 2 =\n        2 ^ index (Suc v div 2) * oddpart (Suc v div 2)) \\<Longrightarrow>\n       Suc v = 2 ^ index (Suc v) * oddpart (Suc v)", "case (2 n)"], ["proof (state)\nthis:\n  \\<not> odd (Suc n) \\<Longrightarrow>\n  Suc n div 2 = 2 ^ index (Suc n div 2) * oddpart (Suc n div 2)\n\ngoal (2 subgoals):\n 1. 0 = 2 ^ index 0 * oddpart 0\n 2. \\<And>v.\n       (\\<not> odd (Suc v) \\<Longrightarrow>\n        Suc v div 2 =\n        2 ^ index (Suc v div 2) * oddpart (Suc v div 2)) \\<Longrightarrow>\n       Suc v = 2 ^ index (Suc v) * oddpart (Suc v)", "from this"], ["proof (chain)\npicking this:\n  \\<not> odd (Suc n) \\<Longrightarrow>\n  Suc n div 2 = 2 ^ index (Suc n div 2) * oddpart (Suc n div 2)", "show \"Suc n = 2 ^ index (Suc n) * oddpart (Suc n)\""], ["proof (prove)\nusing this:\n  \\<not> odd (Suc n) \\<Longrightarrow>\n  Suc n div 2 = 2 ^ index (Suc n div 2) * oddpart (Suc n div 2)\n\ngoal (1 subgoal):\n 1. Suc n = 2 ^ index (Suc n) * oddpart (Suc n)", "by (simp add: mult.assoc)"], ["proof (state)\nthis:\n  Suc n = 2 ^ index (Suc n) * oddpart (Suc n)\n\ngoal (1 subgoal):\n 1. 0 = 2 ^ index 0 * oddpart 0", "qed (simp)"], ["", "lemma oddpart_leq:\n  \"oddpart n \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oddpart n \\<le> n", "by (induct n rule: index.induct) (simp, metis div_le_dividend le_Suc_eq le_trans oddpart.simps(2))"], ["", "lemma index_oddpart_unique:\n  assumes \"odd (m :: nat)\" \"odd m'\"\n  shows \"(2 ^ i * m = 2 ^ i' * m') \\<longleftrightarrow> (i = i' \\<and> m = m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ i * m = 2 ^ i' * m') = (i = i' \\<and> m = m')", "proof (induct i arbitrary: i')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i'. (2 ^ 0 * m = 2 ^ i' * m') = (0 = i' \\<and> m = m')\n 2. \\<And>i i'.\n       (\\<And>i'.\n           (2 ^ i * m = 2 ^ i' * m') =\n           (i = i' \\<and> m = m')) \\<Longrightarrow>\n       (2 ^ Suc i * m = 2 ^ i' * m') = (Suc i = i' \\<and> m = m')", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>i'. (2 ^ 0 * m = 2 ^ i' * m') = (0 = i' \\<and> m = m')\n 2. \\<And>i i'.\n       (\\<And>i'.\n           (2 ^ i * m = 2 ^ i' * m') =\n           (i = i' \\<and> m = m')) \\<Longrightarrow>\n       (2 ^ Suc i * m = 2 ^ i' * m') = (Suc i = i' \\<and> m = m')", "from assms"], ["proof (chain)\npicking this:\n  odd m\n  odd m'", "show ?case"], ["proof (prove)\nusing this:\n  odd m\n  odd m'\n\ngoal (1 subgoal):\n 1. (2 ^ 0 * m = 2 ^ i' * m') = (0 = i' \\<and> m = m')", "by auto"], ["proof (state)\nthis:\n  (2 ^ 0 * m = 2 ^ i' * m') = (0 = i' \\<and> m = m')\n\ngoal (1 subgoal):\n 1. \\<And>i i'.\n       (\\<And>i'.\n           (2 ^ i * m = 2 ^ i' * m') =\n           (i = i' \\<and> m = m')) \\<Longrightarrow>\n       (2 ^ Suc i * m = 2 ^ i' * m') = (Suc i = i' \\<and> m = m')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i i'.\n       (\\<And>i'.\n           (2 ^ i * m = 2 ^ i' * m') =\n           (i = i' \\<and> m = m')) \\<Longrightarrow>\n       (2 ^ Suc i * m = 2 ^ i' * m') = (Suc i = i' \\<and> m = m')", "case (Suc _ i')"], ["proof (state)\nthis:\n  (2 ^ i_ * m = 2 ^ ?i' * m') = (i_ = ?i' \\<and> m = m')\n\ngoal (1 subgoal):\n 1. \\<And>i i'.\n       (\\<And>i'.\n           (2 ^ i * m = 2 ^ i' * m') =\n           (i = i' \\<and> m = m')) \\<Longrightarrow>\n       (2 ^ Suc i * m = 2 ^ i' * m') = (Suc i = i' \\<and> m = m')", "from assms this"], ["proof (chain)\npicking this:\n  odd m\n  odd m'\n  (2 ^ i_ * m = 2 ^ ?i' * m') = (i_ = ?i' \\<and> m = m')", "show ?case"], ["proof (prove)\nusing this:\n  odd m\n  odd m'\n  (2 ^ i_ * m = 2 ^ ?i' * m') = (i_ = ?i' \\<and> m = m')\n\ngoal (1 subgoal):\n 1. (2 ^ Suc i_ * m = 2 ^ i' * m') = (Suc i_ = i' \\<and> m = m')", "by (cases i') auto"], ["proof (state)\nthis:\n  (2 ^ Suc i_ * m = 2 ^ i' * m') = (Suc i_ = i' \\<and> m = m')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_oddpart:\n  assumes \"odd m\"\n  shows \"index (2 ^ i * m) = i\" \"oddpart (2 ^ i * m) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (2 ^ i * m) = i &&& oddpart (2 ^ i * m) = m", "using index_oddpart_unique[where i=i and m=m and m'=\"oddpart (2 ^ i * m)\" and i'=\"index (2 ^ i * m)\"]\n  assms odd_oddpart index_oddpart_decomposition"], ["proof (prove)\nusing this:\n  \\<lbrakk>odd m; odd (oddpart (2 ^ i * m))\\<rbrakk>\n  \\<Longrightarrow> (2 ^ i * m =\n                     2 ^ index (2 ^ i * m) * oddpart (2 ^ i * m)) =\n                    (i = index (2 ^ i * m) \\<and> m = oddpart (2 ^ i * m))\n  odd m\n  odd (oddpart ?n) = (?n \\<noteq> 0)\n  ?n = 2 ^ index ?n * oddpart ?n\n\ngoal (1 subgoal):\n 1. index (2 ^ i * m) = i &&& oddpart (2 ^ i * m) = m", "by force+"], ["", "subsection \\<open>Partitions With Only Distinct and Only Odd Parts\\<close>"], ["", "definition odd_of_distinct :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> nat\"\nwhere\n  \"odd_of_distinct p = (\\<lambda>i. if odd i then (\\<Sum>j | p (2 ^ j * i) = 1. 2 ^ j) else 0)\""], ["", "definition distinct_of_odd :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> nat\"\nwhere\n  \"distinct_of_odd p = (\\<lambda>i. if index i \\<in> bitset (p (oddpart i)) then 1 else 0)\""], ["", "lemma odd:\n  \"odd_of_distinct p i \\<noteq> 0 \\<Longrightarrow> odd i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_of_distinct p i \\<noteq> 0 \\<Longrightarrow> odd i", "unfolding odd_of_distinct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if odd i then sum ((^) 2) {j. p (2 ^ j * i) = 1} else 0) \\<noteq>\n    0 \\<Longrightarrow>\n    odd i", "by auto"], ["", "lemma distinct_distinct_of_odd:\n  \"distinct_of_odd p i \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_of_odd p i \\<le> 1", "unfolding distinct_of_odd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if index i \\<in> bitset (p (oddpart i)) then 1 else 0) \\<le> 1", "by auto"], ["", "lemma odd_of_distinct:\n  assumes \"odd_of_distinct p i \\<noteq> 0\"\n  assumes \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> i \\<le> n\"\n  shows \"1 \\<le> i \\<and> i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> i \\<and> i \\<le> n", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 \\<le> i\n 2. i \\<le> n", "from assms(1) odd"], ["proof (chain)\npicking this:\n  odd_of_distinct p i \\<noteq> 0\n  odd_of_distinct ?p ?i \\<noteq> 0 \\<Longrightarrow> odd ?i", "have \"odd i\""], ["proof (prove)\nusing this:\n  odd_of_distinct p i \\<noteq> 0\n  odd_of_distinct ?p ?i \\<noteq> 0 \\<Longrightarrow> odd ?i\n\ngoal (1 subgoal):\n 1. odd i", "by simp"], ["proof (state)\nthis:\n  odd i\n\ngoal (2 subgoals):\n 1. 1 \\<le> i\n 2. i \\<le> n", "then"], ["proof (chain)\npicking this:\n  odd i", "show \"1 \\<le> i\""], ["proof (prove)\nusing this:\n  odd i\n\ngoal (1 subgoal):\n 1. 1 \\<le> i", "by (auto elim: oddE)"], ["proof (state)\nthis:\n  1 \\<le> i\n\ngoal (1 subgoal):\n 1. i \\<le> n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> n", "from assms(1)"], ["proof (chain)\npicking this:\n  odd_of_distinct p i \\<noteq> 0", "obtain j where \"p (2 ^ j * i) > 0\""], ["proof (prove)\nusing this:\n  odd_of_distinct p i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>j. 0 < p (2 ^ j * i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: odd_of_distinct_def split: if_splits) fastforce"], ["proof (state)\nthis:\n  0 < p (2 ^ j * i)\n\ngoal (1 subgoal):\n 1. i \\<le> n", "with assms(2)"], ["proof (chain)\npicking this:\n  p ?i \\<noteq> 0 \\<Longrightarrow> ?i \\<le> n\n  0 < p (2 ^ j * i)", "have \"i \\<le> 2 ^ j * i\" \"2 ^ j * i \\<le> n\""], ["proof (prove)\nusing this:\n  p ?i \\<noteq> 0 \\<Longrightarrow> ?i \\<le> n\n  0 < p (2 ^ j * i)\n\ngoal (1 subgoal):\n 1. i \\<le> 2 ^ j * i &&& 2 ^ j * i \\<le> n", "by simp_all"], ["proof (state)\nthis:\n  i \\<le> 2 ^ j * i\n  2 ^ j * i \\<le> n\n\ngoal (1 subgoal):\n 1. i \\<le> n", "then"], ["proof (chain)\npicking this:\n  i \\<le> 2 ^ j * i\n  2 ^ j * i \\<le> n", "show \"i \\<le> n\""], ["proof (prove)\nusing this:\n  i \\<le> 2 ^ j * i\n  2 ^ j * i \\<le> n\n\ngoal (1 subgoal):\n 1. i \\<le> n", "by (rule order_trans)"], ["proof (state)\nthis:\n  i \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_of_odd:\n  assumes \"\\<And>i. p i * i \\<le> n\" \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> odd i\"\n  assumes \"distinct_of_odd p i \\<noteq> 0\"\n  shows \"1 \\<le> i \\<and> i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> i \\<and> i \\<le> n", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 \\<le> i\n 2. i \\<le> n", "from assms(3)"], ["proof (chain)\npicking this:\n  distinct_of_odd p i \\<noteq> 0", "have index: \"index i \\<in> bitset (p (oddpart i))\""], ["proof (prove)\nusing this:\n  distinct_of_odd p i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. index i \\<in> bitset (p (oddpart i))", "unfolding distinct_of_odd_def"], ["proof (prove)\nusing this:\n  (if index i \\<in> bitset (p (oddpart i)) then 1 else 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. index i \\<in> bitset (p (oddpart i))", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  index i \\<in> bitset (p (oddpart i))\n\ngoal (2 subgoals):\n 1. 1 \\<le> i\n 2. i \\<le> n", "have \"i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> False", "assume zero: \"i = 0\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> False", "from assms(2)"], ["proof (chain)\npicking this:\n  p ?i \\<noteq> 0 \\<Longrightarrow> odd ?i", "have \"p 0 = 0\""], ["proof (prove)\nusing this:\n  p ?i \\<noteq> 0 \\<Longrightarrow> odd ?i\n\ngoal (1 subgoal):\n 1. p 0 = 0", "by auto"], ["proof (state)\nthis:\n  p 0 = 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> False", "from index zero this"], ["proof (chain)\npicking this:\n  index i \\<in> bitset (p (oddpart i))\n  i = 0\n  p 0 = 0", "show \"False\""], ["proof (prove)\nusing this:\n  index i \\<in> bitset (p (oddpart i))\n  i = 0\n  p 0 = 0\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: bitset_0)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 1 \\<le> i\n 2. i \\<le> n", "from this"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "show \"1 \\<le> i\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> i", "by auto"], ["proof (state)\nthis:\n  1 \\<le> i\n\ngoal (1 subgoal):\n 1. i \\<le> n", "from assms(1)"], ["proof (chain)\npicking this:\n  p ?i * ?i \\<le> n", "have leq_n: \"p (oddpart i) * oddpart i \\<le> n\""], ["proof (prove)\nusing this:\n  p ?i * ?i \\<le> n\n\ngoal (1 subgoal):\n 1. p (oddpart i) * oddpart i \\<le> n", "by auto"], ["proof (state)\nthis:\n  p (oddpart i) * oddpart i \\<le> n\n\ngoal (1 subgoal):\n 1. i \\<le> n", "from index"], ["proof (chain)\npicking this:\n  index i \\<in> bitset (p (oddpart i))", "have \"2 ^ index i \\<le> p (oddpart i)\""], ["proof (prove)\nusing this:\n  index i \\<in> bitset (p (oddpart i))\n\ngoal (1 subgoal):\n 1. 2 ^ index i \\<le> p (oddpart i)", "by (rule in_bitset_bound)"], ["proof (state)\nthis:\n  2 ^ index i \\<le> p (oddpart i)\n\ngoal (1 subgoal):\n 1. i \\<le> n", "from this leq_n"], ["proof (chain)\npicking this:\n  2 ^ index i \\<le> p (oddpart i)\n  p (oddpart i) * oddpart i \\<le> n", "show \"i \\<le> n\""], ["proof (prove)\nusing this:\n  2 ^ index i \\<le> p (oddpart i)\n  p (oddpart i) * oddpart i \\<le> n\n\ngoal (1 subgoal):\n 1. i \\<le> n", "by (subst index_oddpart_decomposition[of i]) (meson dual_order.trans eq_imp_le mult_le_mono)"], ["proof (state)\nthis:\n  i \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odd_distinct:\n  assumes \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> odd i\"\n  shows \"odd_of_distinct (distinct_of_odd p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_of_distinct (distinct_of_odd p) = p", "using assms"], ["proof (prove)\nusing this:\n  p ?i \\<noteq> 0 \\<Longrightarrow> odd ?i\n\ngoal (1 subgoal):\n 1. odd_of_distinct (distinct_of_odd p) = p", "unfolding odd_of_distinct_def distinct_of_odd_def"], ["proof (prove)\nusing this:\n  p ?i \\<noteq> 0 \\<Longrightarrow> odd ?i\n\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        if odd i\n        then sum ((^) 2)\n              {j. (if index (2 ^ j * i)\n                      \\<in> bitset (p (oddpart (2 ^ j * i)))\n                   then 1 else 0) =\n                  1}\n        else 0) =\n    p", "by (auto simp add: fun_eq_iff index_oddpart sum_bitset)"], ["", "lemma distinct_odd:\n  assumes \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> 1 \\<le> i \\<and> i \\<le> n\" \"\\<And>i. p i \\<le> 1\"\n  shows \"distinct_of_odd (odd_of_distinct p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_of_odd (odd_of_distinct p) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct_of_odd (odd_of_distinct p) = p", "from assms"], ["proof (chain)\npicking this:\n  p ?i \\<noteq> 0 \\<Longrightarrow> 1 \\<le> ?i \\<and> ?i \\<le> n\n  p ?i \\<le> 1", "have \"{i. p i = 1} \\<subseteq> {..n}\""], ["proof (prove)\nusing this:\n  p ?i \\<noteq> 0 \\<Longrightarrow> 1 \\<le> ?i \\<and> ?i \\<le> n\n  p ?i \\<le> 1\n\ngoal (1 subgoal):\n 1. {i. p i = 1} \\<subseteq> {..n}", "by auto"], ["proof (state)\nthis:\n  {i. p i = 1} \\<subseteq> {..n}\n\ngoal (1 subgoal):\n 1. distinct_of_odd (odd_of_distinct p) = p", "from this"], ["proof (chain)\npicking this:\n  {i. p i = 1} \\<subseteq> {..n}", "have finite: \"finite {i. p i = 1}\""], ["proof (prove)\nusing this:\n  {i. p i = 1} \\<subseteq> {..n}\n\ngoal (1 subgoal):\n 1. finite {i. p i = 1}", "by (simp add: finite_subset)"], ["proof (state)\nthis:\n  finite {i. p i = 1}\n\ngoal (1 subgoal):\n 1. distinct_of_odd (odd_of_distinct p) = p", "have \"\\<And>x j. x > 0 \\<Longrightarrow> p (2 ^ j * oddpart x) = 1 \\<Longrightarrow>\n    index (2 ^ j * oddpart x) \\<in> index ` {i. p i = 1 \\<and> oddpart x = oddpart i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>0 < x; p (2 ^ j * oddpart x) = 1\\<rbrakk>\n       \\<Longrightarrow> index (2 ^ j * oddpart x)\n                         \\<in> index `\n                               {i. p i = 1 \\<and> oddpart x = oddpart i}", "by (rule imageI) (auto intro: imageI simp add: index_oddpart odd_oddpart)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?x; p (2 ^ ?j * oddpart ?x) = 1\\<rbrakk>\n  \\<Longrightarrow> index (2 ^ ?j * oddpart ?x)\n                    \\<in> index ` {i. p i = 1 \\<and> oddpart ?x = oddpart i}\n\ngoal (1 subgoal):\n 1. distinct_of_odd (odd_of_distinct p) = p", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?x; p (2 ^ ?j * oddpart ?x) = 1\\<rbrakk>\n  \\<Longrightarrow> index (2 ^ ?j * oddpart ?x)\n                    \\<in> index ` {i. p i = 1 \\<and> oddpart ?x = oddpart i}", "have eq: \"\\<And>x. x > 0 \\<Longrightarrow> {j. p (2 ^ j * oddpart x) = 1} = index ` {i. p i = 1 \\<and> oddpart x = oddpart i}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?x; p (2 ^ ?j * oddpart ?x) = 1\\<rbrakk>\n  \\<Longrightarrow> index (2 ^ ?j * oddpart ?x)\n                    \\<in> index ` {i. p i = 1 \\<and> oddpart ?x = oddpart i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < x \\<Longrightarrow>\n       {j. p (2 ^ j * oddpart x) = 1} =\n       index ` {i. p i = 1 \\<and> oddpart x = oddpart i}", "by (auto simp add: index_oddpart odd_oddpart index_oddpart_decomposition[symmetric])"], ["proof (state)\nthis:\n  0 < ?x \\<Longrightarrow>\n  {j. p (2 ^ j * oddpart ?x) = 1} =\n  index ` {i. p i = 1 \\<and> oddpart ?x = oddpart i}\n\ngoal (1 subgoal):\n 1. distinct_of_odd (odd_of_distinct p) = p", "from finite"], ["proof (chain)\npicking this:\n  finite {i. p i = 1}", "have all_finite: \"\\<And>x. x > 0 \\<Longrightarrow> finite {j. p (2 ^ j * oddpart x) = 1}\""], ["proof (prove)\nusing this:\n  finite {i. p i = 1}\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<Longrightarrow> finite {j. p (2 ^ j * oddpart x) = 1}", "unfolding eq"], ["proof (prove)\nusing this:\n  finite {i. p i = 1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < x \\<Longrightarrow>\n       finite (index ` {i. p i = 1 \\<and> oddpart x = oddpart i})", "by auto"], ["proof (state)\nthis:\n  0 < ?x \\<Longrightarrow> finite {j. p (2 ^ j * oddpart ?x) = 1}\n\ngoal (1 subgoal):\n 1. distinct_of_odd (odd_of_distinct p) = p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_of_odd (odd_of_distinct p) = p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. distinct_of_odd (odd_of_distinct p) x = p x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. distinct_of_odd (odd_of_distinct p) x = p x", "from assms(1)"], ["proof (chain)\npicking this:\n  p ?i \\<noteq> 0 \\<Longrightarrow> 1 \\<le> ?i \\<and> ?i \\<le> n", "have p0: \"p 0 = 0\""], ["proof (prove)\nusing this:\n  p ?i \\<noteq> 0 \\<Longrightarrow> 1 \\<le> ?i \\<and> ?i \\<le> n\n\ngoal (1 subgoal):\n 1. p 0 = 0", "by auto"], ["proof (state)\nthis:\n  p 0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. distinct_of_odd (odd_of_distinct p) x = p x", "show \"distinct_of_odd (odd_of_distinct p) x = p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_of_odd (odd_of_distinct p) x = p x", "proof (cases \"x > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> distinct_of_odd (odd_of_distinct p) x = p x\n 2. \\<not> 0 < x \\<Longrightarrow>\n    distinct_of_odd (odd_of_distinct p) x = p x", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < x\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> distinct_of_odd (odd_of_distinct p) x = p x\n 2. \\<not> 0 < x \\<Longrightarrow>\n    distinct_of_odd (odd_of_distinct p) x = p x", "from this p0"], ["proof (chain)\npicking this:\n  \\<not> 0 < x\n  p 0 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 < x\n  p 0 = 0\n\ngoal (1 subgoal):\n 1. distinct_of_odd (odd_of_distinct p) x = p x", "unfolding odd_of_distinct_def distinct_of_odd_def"], ["proof (prove)\nusing this:\n  \\<not> 0 < x\n  p 0 = 0\n\ngoal (1 subgoal):\n 1. (if index x\n        \\<in> bitset\n               (if odd (oddpart x)\n                then sum ((^) 2) {j. p (2 ^ j * oddpart x) = 1} else 0)\n     then 1 else 0) =\n    p x", "by (auto simp add: odd_oddpart bitset_0)"], ["proof (state)\nthis:\n  distinct_of_odd (odd_of_distinct p) x = p x\n\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> distinct_of_odd (odd_of_distinct p) x = p x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> distinct_of_odd (odd_of_distinct p) x = p x", "case True"], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> distinct_of_odd (odd_of_distinct p) x = p x", "from p0 assms(2)[of x] all_finite[OF True]"], ["proof (chain)\npicking this:\n  p 0 = 0\n  p x \\<le> 1\n  finite {j. p (2 ^ j * oddpart x) = 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  p 0 = 0\n  p x \\<le> 1\n  finite {j. p (2 ^ j * oddpart x) = 1}\n\ngoal (1 subgoal):\n 1. distinct_of_odd (odd_of_distinct p) x = p x", "unfolding odd_of_distinct_def distinct_of_odd_def"], ["proof (prove)\nusing this:\n  p 0 = 0\n  p x \\<le> 1\n  finite {j. p (2 ^ j * oddpart x) = 1}\n\ngoal (1 subgoal):\n 1. (if index x\n        \\<in> bitset\n               (if odd (oddpart x)\n                then sum ((^) 2) {j. p (2 ^ j * oddpart x) = 1} else 0)\n     then 1 else 0) =\n    p x", "by (auto simp add: odd_oddpart bitset_0 bitset_sum index_oddpart_decomposition[symmetric])"], ["proof (state)\nthis:\n  distinct_of_odd (odd_of_distinct p) x = p x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct_of_odd (odd_of_distinct p) x = p x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct_of_odd (odd_of_distinct p) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_distinct_of_odd:\n  assumes \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> 1 \\<le> i \\<and> i \\<le> n\"\n  assumes \"\\<And>i. p i * i \\<le> n\"\n  assumes \"\\<And>i. p i \\<noteq> 0 \\<Longrightarrow> odd i\"\n  shows \"(\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "assume odd: \"odd (m :: nat)\""], ["proof (state)\nthis:\n  odd m\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have finite: \"finite {k. 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {k. 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m)}", "by (simp add: finite_bitset)"], ["proof (state)\nthis:\n  finite {k. 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have \"(\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n. distinct_of_odd p i * i) =\n      (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n. if index i \\<in> bitset (p (oddpart i)) then i else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n       distinct_of_odd p i * i) =\n    (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n       if index i \\<in> bitset (p (oddpart i)) then i else 0)", "unfolding distinct_of_odd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n       (if index i \\<in> bitset (p (oddpart i)) then 1 else 0) * i) =\n    (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n       if index i \\<in> bitset (p (oddpart i)) then i else 0)", "by (auto intro: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n     distinct_of_odd p i * i) =\n  (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n     if index i \\<in> bitset (p (oddpart i)) then i else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n     distinct_of_odd p i * i) =\n  (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n     if index i \\<in> bitset (p (oddpart i)) then i else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have \"... = (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> k \\<in> bitset (p m) \\<and> i \\<le> n. i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n       if index i \\<in> bitset (p (oddpart i)) then i else 0) =\n    \\<Sum>\n     {i. \\<exists>k.\n            i = 2 ^ k * m \\<and> k \\<in> bitset (p m) \\<and> i \\<le> n}", "using odd"], ["proof (prove)\nusing this:\n  odd m\n\ngoal (1 subgoal):\n 1. (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n       if index i \\<in> bitset (p (oddpart i)) then i else 0) =\n    \\<Sum>\n     {i. \\<exists>k.\n            i = 2 ^ k * m \\<and> k \\<in> bitset (p m) \\<and> i \\<le> n}", "by (intro sum.mono_neutral_cong_right) (auto simp add: index_oddpart)"], ["proof (state)\nthis:\n  (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n     if index i \\<in> bitset (p (oddpart i)) then i else 0) =\n  \\<Sum>\n   {i. \\<exists>k.\n          i = 2 ^ k * m \\<and> k \\<in> bitset (p m) \\<and> i \\<le> n}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n     if index i \\<in> bitset (p (oddpart i)) then i else 0) =\n  \\<Sum>\n   {i. \\<exists>k.\n          i = 2 ^ k * m \\<and> k \\<in> bitset (p m) \\<and> i \\<le> n}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have \"... = (\\<Sum>k | 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m). 2 ^ k * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\n     {i. \\<exists>k.\n            i = 2 ^ k * m \\<and> k \\<in> bitset (p m) \\<and> i \\<le> n} =\n    (\\<Sum>k | 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m). 2 ^ k * m)", "using odd"], ["proof (prove)\nusing this:\n  odd m\n\ngoal (1 subgoal):\n 1. \\<Sum>\n     {i. \\<exists>k.\n            i = 2 ^ k * m \\<and> k \\<in> bitset (p m) \\<and> i \\<le> n} =\n    (\\<Sum>k | 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m). 2 ^ k * m)", "by (auto intro!: sum.reindex_cong[OF _ _ refl] inj_onI)"], ["proof (state)\nthis:\n  \\<Sum>\n   {i. \\<exists>k.\n          i = 2 ^ k * m \\<and> k \\<in> bitset (p m) \\<and> i \\<le> n} =\n  (\\<Sum>k | 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m). 2 ^ k * m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "also"], ["proof (state)\nthis:\n  \\<Sum>\n   {i. \\<exists>k.\n          i = 2 ^ k * m \\<and> k \\<in> bitset (p m) \\<and> i \\<le> n} =\n  (\\<Sum>k | 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m). 2 ^ k * m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have \"... = (\\<Sum>k\\<in>bitset (p m). 2 ^ k * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k | 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m). 2 ^ k * m) =\n    (\\<Sum>k\\<in>bitset (p m). 2 ^ k * m)", "using assms(2)[of m] finite dual_order.trans in_bitset_bound"], ["proof (prove)\nusing this:\n  p m * m \\<le> n\n  finite {k. 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m)}\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  ?b \\<in> bitset ?n \\<Longrightarrow> 2 ^ ?b \\<le> ?n\n\ngoal (1 subgoal):\n 1. (\\<Sum>k | 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m). 2 ^ k * m) =\n    (\\<Sum>k\\<in>bitset (p m). 2 ^ k * m)", "by (fastforce intro!: sum.mono_neutral_cong_right)"], ["proof (state)\nthis:\n  (\\<Sum>k | 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m). 2 ^ k * m) =\n  (\\<Sum>k\\<in>bitset (p m). 2 ^ k * m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k | 2 ^ k * m \\<le> n \\<and> k \\<in> bitset (p m). 2 ^ k * m) =\n  (\\<Sum>k\\<in>bitset (p m). 2 ^ k * m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have \"... = (\\<Sum>k\\<in>bitset (p m). 2 ^ k) * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>bitset (p m). 2 ^ k * m) = sum ((^) 2) (bitset (p m)) * m", "by (subst sum_distrib_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>bitset (p m). 2 ^ k * m) = sum ((^) 2) (bitset (p m)) * m\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>bitset (p m). 2 ^ k * m) = sum ((^) 2) (bitset (p m)) * m\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have \"... = p m * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) 2) (bitset (p m)) * m = p m * m", "by (auto simp add: sum_bitset)"], ["proof (state)\nthis:\n  sum ((^) 2) (bitset (p m)) * m = p m * m\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n     distinct_of_odd p i * i) =\n  p m * m", "have \"(\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n. distinct_of_odd p i * i) = p m * m\""], ["proof (prove)\nusing this:\n  (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n     distinct_of_odd p i * i) =\n  p m * m\n\ngoal (1 subgoal):\n 1. (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n       distinct_of_odd p i * i) =\n    p m * m", "."], ["proof (state)\nthis:\n  (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n     distinct_of_odd p i * i) =\n  p m * m\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "}"], ["proof (state)\nthis:\n  odd ?m2 \\<Longrightarrow>\n  (\\<Sum>i | \\<exists>k. i = 2 ^ k * ?m2 \\<and> i \\<le> n.\n     distinct_of_odd p i * i) =\n  p ?m2 * ?m2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "note inner_eq = this"], ["proof (state)\nthis:\n  odd ?m2 \\<Longrightarrow>\n  (\\<Sum>i | \\<exists>k. i = 2 ^ k * ?m2 \\<and> i \\<le> n.\n     distinct_of_odd p i * i) =\n  p ?m2 * ?m2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have set_eq: \"{i. 1 \\<le> i \\<and> i \\<le> n} = \\<Union>((\\<lambda>m. {i. \\<exists>k. i = (2 ^ k) * m \\<and> i \\<le> n}) ` {m. m \\<le> n \\<and> odd m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. 1 \\<le> i \\<and> i \\<le> n} =\n    (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n        {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {i. 1 \\<le> i \\<and> i \\<le> n} =\n    (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n        {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {i. 1 \\<le> i \\<and> i \\<le> n} =\n    (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n        {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n})", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. {i. 1 \\<le> i \\<and> i \\<le> n} =\n    (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n        {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n})", "assume \"1 \\<le> x\" \"x \\<le> n\""], ["proof (state)\nthis:\n  1 \\<le> x\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. {i. 1 \\<le> i \\<and> i \\<le> n} =\n    (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n        {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n})", "from this oddpart_leq[of x]"], ["proof (chain)\npicking this:\n  1 \\<le> x\n  x \\<le> n\n  oddpart x \\<le> x", "have \"oddpart x \\<le> n \\<and> odd (oddpart x) \\<and> (\\<exists>k. 2 ^ index x * oddpart x = 2 ^ k * oddpart x)\""], ["proof (prove)\nusing this:\n  1 \\<le> x\n  x \\<le> n\n  oddpart x \\<le> x\n\ngoal (1 subgoal):\n 1. oddpart x \\<le> n \\<and>\n    odd (oddpart x) \\<and>\n    (\\<exists>k. 2 ^ index x * oddpart x = 2 ^ k * oddpart x)", "by (auto simp add: odd_oddpart)"], ["proof (state)\nthis:\n  oddpart x \\<le> n \\<and>\n  odd (oddpart x) \\<and>\n  (\\<exists>k. 2 ^ index x * oddpart x = 2 ^ k * oddpart x)\n\ngoal (1 subgoal):\n 1. {i. 1 \\<le> i \\<and> i \\<le> n} =\n    (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n        {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n})", "from this"], ["proof (chain)\npicking this:\n  oddpart x \\<le> n \\<and>\n  odd (oddpart x) \\<and>\n  (\\<exists>k. 2 ^ index x * oddpart x = 2 ^ k * oddpart x)", "have \"\\<exists>m\\<le>n. odd m \\<and> (\\<exists>k. x = 2 ^ k * m)\""], ["proof (prove)\nusing this:\n  oddpart x \\<le> n \\<and>\n  odd (oddpart x) \\<and>\n  (\\<exists>k. 2 ^ index x * oddpart x = 2 ^ k * oddpart x)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n. odd m \\<and> (\\<exists>k. x = 2 ^ k * m)", "by (auto simp add: index_oddpart_decomposition[symmetric])"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n. odd m \\<and> (\\<exists>k. x = 2 ^ k * m)\n\ngoal (1 subgoal):\n 1. {i. 1 \\<le> i \\<and> i \\<le> n} =\n    (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n        {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>1 \\<le> ?x2; ?x2 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<le>n.\n                       odd m \\<and> (\\<exists>k. ?x2 = 2 ^ k * m)\n\ngoal (1 subgoal):\n 1. {i. 1 \\<le> i \\<and> i \\<le> n} =\n    (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n        {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n})", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 \\<le> ?x2; ?x2 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<le>n.\n                       odd m \\<and> (\\<exists>k. ?x2 = 2 ^ k * m)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> ?x2; ?x2 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<le>n.\n                       odd m \\<and> (\\<exists>k. ?x2 = 2 ^ k * m)\n\ngoal (1 subgoal):\n 1. {i. 1 \\<le> i \\<and> i \\<le> n} =\n    (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n        {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n})", "by (auto simp add: Suc_leI odd_pos)"], ["proof (state)\nthis:\n  {i. 1 \\<le> i \\<and> i \\<le> n} =\n  (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n      {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {i. 1 \\<le> i \\<and> i \\<le> n} =\n  (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n      {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "let ?S = \"(\\<lambda>m. {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n}) ` {m. m \\<le> n \\<and> odd m}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have no_overlap: \"\\<forall>A\\<in>?S. \\<forall>B\\<in>?S. A \\<noteq> B \\<longrightarrow> A \\<inter> B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>(\\<lambda>m.\n                       {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n}) `\n                   {m. m \\<le> n \\<and> odd m}.\n       \\<forall>B\\<in>(\\<lambda>m.\n                          {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n}) `\n                      {m. m \\<le> n \\<and> odd m}.\n          A \\<noteq> B \\<longrightarrow> A \\<inter> B = {}", "by (auto simp add: index_oddpart_unique)"], ["proof (state)\nthis:\n  \\<forall>A\\<in>(\\<lambda>m.\n                     {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n}) `\n                 {m. m \\<le> n \\<and> odd m}.\n     \\<forall>B\\<in>(\\<lambda>m.\n                        {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n}) `\n                    {m. m \\<le> n \\<and> odd m}.\n        A \\<noteq> B \\<longrightarrow> A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have inj: \"inj_on (\\<lambda>m. {i. (\\<exists>k. i = 2 ^ k * m) \\<and> i \\<le> n}) {m. m \\<le> n \\<and> odd m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>m. {i. (\\<exists>k. i = 2 ^ k * m) \\<and> i \\<le> n})\n     {m. m \\<le> n \\<and> odd m}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{m. m \\<le> n \\<and> odd m}.\n       \\<forall>y\\<in>{m. m \\<le> n \\<and> odd m}.\n          {i. (\\<exists>k. i = 2 ^ k * x) \\<and> i \\<le> n} =\n          {i. (\\<exists>k. i = 2 ^ k * y) \\<and>\n              i \\<le> n} \\<longrightarrow>\n          x = y", "by auto (force simp add: index_oddpart_unique)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>m. {i. (\\<exists>k. i = 2 ^ k * m) \\<and> i \\<le> n})\n   {m. m \\<le> n \\<and> odd m}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have reindex: \"\\<And>F. (\\<Sum>i | 1 \\<le> i \\<and> i \\<le> n. F i) = (\\<Sum>m | m \\<le> n \\<and> odd m. (\\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n. F i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       (\\<Sum>i | 1 \\<le> i \\<and> i \\<le> n. F i) =\n       (\\<Sum>m | m \\<le> n \\<and> odd m.\n          \\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n. F i)", "unfolding set_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       sum F\n        (\\<Union>m\\<in>{m. m \\<le> n \\<and> odd m}.\n            {i. \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n}) =\n       (\\<Sum>m | m \\<le> n \\<and> odd m.\n          \\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n. F i)", "by (subst sum.Union_disjoint) (auto simp add: no_overlap intro: sum.reindex_cong[OF inj])"], ["proof (state)\nthis:\n  (\\<Sum>i | 1 \\<le> i \\<and> i \\<le> n. ?F i) =\n  (\\<Sum>m | m \\<le> n \\<and> odd m.\n     \\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n. ?F i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have \"(\\<Sum>i\\<le>n. distinct_of_odd p i * i) =  (\\<Sum>i | 1 \\<le> i \\<and> i \\<le> n. distinct_of_odd p i * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) =\n    (\\<Sum>i | 1 \\<le> i \\<and> i \\<le> n. distinct_of_odd p i * i)", "by (auto intro: sum.mono_neutral_right)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. distinct_of_odd p i * i) =\n  (\\<Sum>i | 1 \\<le> i \\<and> i \\<le> n. distinct_of_odd p i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. distinct_of_odd p i * i) =\n  (\\<Sum>i | 1 \\<le> i \\<and> i \\<le> n. distinct_of_odd p i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have \"... = (\\<Sum>m | m \\<le> n \\<and> odd m. \\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n. distinct_of_odd p i * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | 1 \\<le> i \\<and> i \\<le> n. distinct_of_odd p i * i) =\n    (\\<Sum>m | m \\<le> n \\<and> odd m.\n       \\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n         distinct_of_odd p i * i)", "by (simp only: reindex)"], ["proof (state)\nthis:\n  (\\<Sum>i | 1 \\<le> i \\<and> i \\<le> n. distinct_of_odd p i * i) =\n  (\\<Sum>m | m \\<le> n \\<and> odd m.\n     \\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n       distinct_of_odd p i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | 1 \\<le> i \\<and> i \\<le> n. distinct_of_odd p i * i) =\n  (\\<Sum>m | m \\<le> n \\<and> odd m.\n     \\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n       distinct_of_odd p i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have \"... = (\\<Sum>i | i \\<le> n \\<and> odd i. p i * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<le> n \\<and> odd m.\n       \\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n         distinct_of_odd p i * i) =\n    (\\<Sum>i | i \\<le> n \\<and> odd i. p i * i)", "by (rule sum.cong[OF refl]; subst inner_eq) auto"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<le> n \\<and> odd m.\n     \\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n       distinct_of_odd p i * i) =\n  (\\<Sum>i | i \\<le> n \\<and> odd i. p i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<le> n \\<and> odd m.\n     \\<Sum>i | \\<exists>k. i = 2 ^ k * m \\<and> i \\<le> n.\n       distinct_of_odd p i * i) =\n  (\\<Sum>i | i \\<le> n \\<and> odd i. p i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "have \"... = (\\<Sum>i\\<le>n. p i * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<le> n \\<and> odd i. p i * i) = (\\<Sum>i\\<le>n. p i * i)", "using assms(3)"], ["proof (prove)\nusing this:\n  p ?i \\<noteq> 0 \\<Longrightarrow> odd ?i\n\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<le> n \\<and> odd i. p i * i) = (\\<Sum>i\\<le>n. p i * i)", "by (auto intro: sum.mono_neutral_left)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> n \\<and> odd i. p i * i) = (\\<Sum>i\\<le>n. p i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)", "."], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = (\\<Sum>i\\<le>n. p i * i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leq_n:\n  assumes \"\\<forall>i. 0 < p i \\<longrightarrow> 1 \\<le> i \\<and> i \\<le> (n::nat)\"\n  assumes \"(\\<Sum>i\\<le>n. p i * i) = n\"\n  shows \"p i * i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p i * i \\<le> n", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p i * i \\<le> n \\<Longrightarrow> False", "assume \"\\<not> p i * i \\<le> n\""], ["proof (state)\nthis:\n  \\<not> p i * i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> p i * i \\<le> n \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> p i * i \\<le> n", "have gr_n: \"p i * i > n\""], ["proof (prove)\nusing this:\n  \\<not> p i * i \\<le> n\n\ngoal (1 subgoal):\n 1. n < p i * i", "by auto"], ["proof (state)\nthis:\n  n < p i * i\n\ngoal (1 subgoal):\n 1. \\<not> p i * i \\<le> n \\<Longrightarrow> False", "from this assms(1)"], ["proof (chain)\npicking this:\n  n < p i * i\n  \\<forall>i. 0 < p i \\<longrightarrow> 1 \\<le> i \\<and> i \\<le> n", "have \"1 \\<le> i \\<and> i \\<le> n\""], ["proof (prove)\nusing this:\n  n < p i * i\n  \\<forall>i. 0 < p i \\<longrightarrow> 1 \\<le> i \\<and> i \\<le> n\n\ngoal (1 subgoal):\n 1. 1 \\<le> i \\<and> i \\<le> n", "by force"], ["proof (state)\nthis:\n  1 \\<le> i \\<and> i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> p i * i \\<le> n \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  1 \\<le> i \\<and> i \\<le> n", "have \"(\\<Sum>j\\<le>n. p j * j) = p i * i + (\\<Sum>j | j \\<le> n \\<and> j \\<noteq> i. p j * j)\""], ["proof (prove)\nusing this:\n  1 \\<le> i \\<and> i \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. p j * j) =\n    p i * i + (\\<Sum>j | j \\<le> n \\<and> j \\<noteq> i. p j * j)", "by (subst sum.insert[symmetric]) (auto intro: sum.cong simp del: sum.insert)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>n. p j * j) =\n  p i * i + (\\<Sum>j | j \\<le> n \\<and> j \\<noteq> i. p j * j)\n\ngoal (1 subgoal):\n 1. \\<not> p i * i \\<le> n \\<Longrightarrow> False", "from this gr_n assms(2)"], ["proof (chain)\npicking this:\n  (\\<Sum>j\\<le>n. p j * j) =\n  p i * i + (\\<Sum>j | j \\<le> n \\<and> j \\<noteq> i. p j * j)\n  n < p i * i\n  (\\<Sum>i\\<le>n. p i * i) = n", "show False"], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<le>n. p j * j) =\n  p i * i + (\\<Sum>j | j \\<le> n \\<and> j \\<noteq> i. p j * j)\n  n < p i * i\n  (\\<Sum>i\\<le>n. p i * i) = n\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_of_odd_in_distinct_partitions:\n  assumes \"p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\"\n  shows \"distinct_of_odd p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_of_odd p\n    \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct_of_odd p partitions n \\<and>\n    (\\<forall>i. distinct_of_odd p i \\<le> 1)", "have \"distinct_of_odd p partitions n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_of_odd p partitions n", "proof (rule partitionsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       distinct_of_odd p i \\<noteq> 0 \\<Longrightarrow>\n       1 \\<le> i \\<and> i \\<le> n\n 2. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = n", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       distinct_of_odd p i \\<noteq> 0 \\<Longrightarrow>\n       1 \\<le> i \\<and> i \\<le> n\n 2. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = n", "assume \"distinct_of_odd p i \\<noteq> 0\""], ["proof (state)\nthis:\n  distinct_of_odd p i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       distinct_of_odd p i \\<noteq> 0 \\<Longrightarrow>\n       1 \\<le> i \\<and> i \\<le> n\n 2. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = n", "from this assms"], ["proof (chain)\npicking this:\n  distinct_of_odd p i \\<noteq> 0\n  p \\<in> {p. p partitions n \\<and>\n              (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "show \"1 \\<le> i \\<and> i \\<le> n\""], ["proof (prove)\nusing this:\n  distinct_of_odd p i \\<noteq> 0\n  p \\<in> {p. p partitions n \\<and>\n              (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n\ngoal (1 subgoal):\n 1. 1 \\<le> i \\<and> i \\<le> n", "unfolding partitions_def"], ["proof (prove)\nusing this:\n  distinct_of_odd p i \\<noteq> 0\n  p \\<in> {p. ((\\<forall>i.\n                   p i \\<noteq> 0 \\<longrightarrow>\n                   1 \\<le> i \\<and> i \\<le> n) \\<and>\n               (\\<Sum>i\\<le>n. p i * i) = n) \\<and>\n              (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n\ngoal (1 subgoal):\n 1. 1 \\<le> i \\<and> i \\<le> n", "by (rule_tac distinct_of_odd) (auto simp add: leq_n)"], ["proof (state)\nthis:\n  1 \\<le> i \\<and> i \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = n", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> {p. p partitions n \\<and>\n              (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "show \"(\\<Sum>i\\<le>n. distinct_of_odd p i * i) = n\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p partitions n \\<and>\n              (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = n", "by (subst  sum_distinct_of_odd) (auto simp add: distinct_distinct_of_odd leq_n elim: partitionsE)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. distinct_of_odd p i * i) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct_of_odd p partitions n\n\ngoal (1 subgoal):\n 1. distinct_of_odd p partitions n \\<and>\n    (\\<forall>i. distinct_of_odd p i \\<le> 1)", "moreover"], ["proof (state)\nthis:\n  distinct_of_odd p partitions n\n\ngoal (1 subgoal):\n 1. distinct_of_odd p partitions n \\<and>\n    (\\<forall>i. distinct_of_odd p i \\<le> 1)", "have \"\\<forall>i. distinct_of_odd p i \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. distinct_of_odd p i \\<le> 1", "by (intro allI distinct_distinct_of_odd)"], ["proof (state)\nthis:\n  \\<forall>i. distinct_of_odd p i \\<le> 1\n\ngoal (1 subgoal):\n 1. distinct_of_odd p partitions n \\<and>\n    (\\<forall>i. distinct_of_odd p i \\<le> 1)", "ultimately"], ["proof (chain)\npicking this:\n  distinct_of_odd p partitions n\n  \\<forall>i. distinct_of_odd p i \\<le> 1", "show \"distinct_of_odd p partitions n \\<and> (\\<forall>i. distinct_of_odd p i \\<le> 1)\""], ["proof (prove)\nusing this:\n  distinct_of_odd p partitions n\n  \\<forall>i. distinct_of_odd p i \\<le> 1\n\ngoal (1 subgoal):\n 1. distinct_of_odd p partitions n \\<and>\n    (\\<forall>i. distinct_of_odd p i \\<le> 1)", "by simp"], ["proof (state)\nthis:\n  distinct_of_odd p partitions n \\<and>\n  (\\<forall>i. distinct_of_odd p i \\<le> 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odd_of_distinct_in_odd_partitions:\n  assumes \"p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\"\n  shows \"odd_of_distinct p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_of_distinct p\n    \\<in> {p. p partitions n \\<and>\n              (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}", "have distinct: \"\\<And>i. p i = 0 \\<or> p i = 1\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n\ngoal (1 subgoal):\n 1. \\<And>i. p i = 0 \\<or> p i = 1", "using le_imp_less_Suc less_Suc_eq_0_disj"], ["proof (prove)\nusing this:\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  ?m \\<le> ?n \\<Longrightarrow> ?m < Suc ?n\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n\ngoal (1 subgoal):\n 1. \\<And>i. p i = 0 \\<or> p i = 1", "by fastforce"], ["proof (state)\nthis:\n  p ?i = 0 \\<or> p ?i = 1\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}", "have set_eq: \"{x. p x = 1} = {x \\<in> {..n}. p x = 1}\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n\ngoal (1 subgoal):\n 1. {x. p x = 1} = {x \\<in> {..n}. p x = 1}", "unfolding partitions_def"], ["proof (prove)\nusing this:\n  p \\<in> {p. ((\\<forall>i.\n                   p i \\<noteq> 0 \\<longrightarrow>\n                   1 \\<le> i \\<and> i \\<le> n) \\<and>\n               (\\<Sum>i\\<le>n. p i * i) = n) \\<and>\n              (\\<forall>i. p i \\<le> 1)}\n\ngoal (1 subgoal):\n 1. {x. p x = 1} = {x \\<in> {..n}. p x = 1}", "by auto"], ["proof (state)\nthis:\n  {x. p x = 1} = {x \\<in> {..n}. p x = 1}\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}", "have sum: \"(\\<Sum>i\\<le>n. p i * i) = n\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. p i * i) = n", "unfolding partitions_def"], ["proof (prove)\nusing this:\n  p \\<in> {p. ((\\<forall>i.\n                   p i \\<noteq> 0 \\<longrightarrow>\n                   1 \\<le> i \\<and> i \\<le> n) \\<and>\n               (\\<Sum>i\\<le>n. p i * i) = n) \\<and>\n              (\\<forall>i. p i \\<le> 1)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. p i * i) = n", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. p i * i) = n\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "{"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. p i * i) = n\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "assume i: \"odd (i :: nat)\""], ["proof (state)\nthis:\n  odd i\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "have 3: \"inj_on index {x. p x = 1 \\<and> oddpart x = i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on index {x. p x = 1 \\<and> oddpart x = i}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. p x = 1 \\<and> oddpart x = i}.\n       \\<forall>y\\<in>{x. p x = 1 \\<and> oddpart x = i}.\n          index x = index y \\<longrightarrow> x = y", "by auto (metis index_oddpart_decomposition)"], ["proof (state)\nthis:\n  inj_on index {x. p x = 1 \\<and> oddpart x = i}\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "{"], ["proof (state)\nthis:\n  inj_on index {x. p x = 1 \\<and> oddpart x = i}\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "assume \"p (2 ^ j * i) = 1\""], ["proof (state)\nthis:\n  p (2 ^ j * i) = 1\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "from this i"], ["proof (chain)\npicking this:\n  p (2 ^ j * i) = 1\n  odd i", "have \"j \\<in> index ` {x. p x = 1 \\<and> oddpart x = i}\""], ["proof (prove)\nusing this:\n  p (2 ^ j * i) = 1\n  odd i\n\ngoal (1 subgoal):\n 1. j \\<in> index ` {x. p x = 1 \\<and> oddpart x = i}", "by (auto simp add: index_oddpart(1, 2) intro!: image_eqI[where x=\"2 ^ j * i\"])"], ["proof (state)\nthis:\n  j \\<in> index ` {x. p x = 1 \\<and> oddpart x = i}\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "}"], ["proof (state)\nthis:\n  p (2 ^ ?j2 * i) = 1 \\<Longrightarrow>\n  ?j2 \\<in> index ` {x. p x = 1 \\<and> oddpart x = i}\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "from i this"], ["proof (chain)\npicking this:\n  odd i\n  p (2 ^ ?j2 * i) = 1 \\<Longrightarrow>\n  ?j2 \\<in> index ` {x. p x = 1 \\<and> oddpart x = i}", "have \"{j. p (2 ^ j * i) = 1} = index ` {x. p x = 1 \\<and> oddpart x = i}\""], ["proof (prove)\nusing this:\n  odd i\n  p (2 ^ ?j2 * i) = 1 \\<Longrightarrow>\n  ?j2 \\<in> index ` {x. p x = 1 \\<and> oddpart x = i}\n\ngoal (1 subgoal):\n 1. {j. p (2 ^ j * i) = 1} = index ` {x. p x = 1 \\<and> oddpart x = i}", "by (auto simp add: index_oddpart_decomposition[symmetric])"], ["proof (state)\nthis:\n  {j. p (2 ^ j * i) = 1} = index ` {x. p x = 1 \\<and> oddpart x = i}\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "from 3 this"], ["proof (chain)\npicking this:\n  inj_on index {x. p x = 1 \\<and> oddpart x = i}\n  {j. p (2 ^ j * i) = 1} = index ` {x. p x = 1 \\<and> oddpart x = i}", "have \"(\\<Sum>j | p (2 ^ j * i) = 1. 2 ^ j) * i = (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x) * i\""], ["proof (prove)\nusing this:\n  inj_on index {x. p x = 1 \\<and> oddpart x = i}\n  {j. p (2 ^ j * i) = 1} = index ` {x. p x = 1 \\<and> oddpart x = i}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j | p (2 ^ j * i) = 1. 2 ^ j) * i =\n    (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x) * i", "by (auto intro: sum.reindex_cong[where l = \"index\"])"], ["proof (state)\nthis:\n  (\\<Sum>j | p (2 ^ j * i) = 1. 2 ^ j) * i =\n  (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x) * i\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j | p (2 ^ j * i) = 1. 2 ^ j) * i =\n  (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x) * i\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "have \"... = (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x * oddpart x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x) * i =\n    (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x * oddpart x)", "by (auto simp add: sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x) * i =\n  (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x * oddpart x)\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x) * i =\n  (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x * oddpart x)\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "have \"... = (\\<Sum>x | p x = 1 \\<and> oddpart x = i. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x * oddpart x) =\n    \\<Sum> {x. p x = 1 \\<and> oddpart x = i}", "by (simp only: index_oddpart_decomposition[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x * oddpart x) =\n  \\<Sum> {x. p x = 1 \\<and> oddpart x = i}\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x | p x = 1 \\<and> oddpart x = i. 2 ^ index x * oddpart x) =\n  \\<Sum> {x. p x = 1 \\<and> oddpart x = i}\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "have \"... \\<le> (\\<Sum>x | p x = 1. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum> {x. p x = 1 \\<and> oddpart x = i} \\<le> \\<Sum> {x. p x = 1}", "using set_eq"], ["proof (prove)\nusing this:\n  {x. p x = 1} = {x \\<in> {..n}. p x = 1}\n\ngoal (1 subgoal):\n 1. \\<Sum> {x. p x = 1 \\<and> oddpart x = i} \\<le> \\<Sum> {x. p x = 1}", "by (intro sum_mono2) auto"], ["proof (state)\nthis:\n  \\<Sum> {x. p x = 1 \\<and> oddpart x = i} \\<le> \\<Sum> {x. p x = 1}\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "also"], ["proof (state)\nthis:\n  \\<Sum> {x. p x = 1 \\<and> oddpart x = i} \\<le> \\<Sum> {x. p x = 1}\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "have \"... = (\\<Sum>x\\<le>n. p x * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum> {x. p x = 1} = (\\<Sum>x\\<le>n. p x * x)", "using distinct"], ["proof (prove)\nusing this:\n  p ?i = 0 \\<or> p ?i = 1\n\ngoal (1 subgoal):\n 1. \\<Sum> {x. p x = 1} = (\\<Sum>x\\<le>n. p x * x)", "by (subst set_eq) (force intro!: sum.mono_neutral_cong_left)"], ["proof (state)\nthis:\n  \\<Sum> {x. p x = 1} = (\\<Sum>x\\<le>n. p x * x)\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "also"], ["proof (state)\nthis:\n  \\<Sum> {x. p x = 1} = (\\<Sum>x\\<le>n. p x * x)\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "have \"... = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>n. p x * x) = n", "using sum"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>n. p i * i) = n\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>n. p x * x) = n", "."], ["proof (state)\nthis:\n  (\\<Sum>x\\<le>n. p x * x) = n\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j | p (2 ^ j * i) = 1. 2 ^ j) * i \\<le> n", "have \"(\\<Sum>j | p (2 ^ j * i) = 1. 2 ^ j) * i \\<le> n\""], ["proof (prove)\nusing this:\n  (\\<Sum>j | p (2 ^ j * i) = 1. 2 ^ j) * i \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j | p (2 ^ j * i) = 1. 2 ^ j) * i \\<le> n", "."], ["proof (state)\nthis:\n  (\\<Sum>j | p (2 ^ j * i) = 1. 2 ^ j) * i \\<le> n\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "}"], ["proof (state)\nthis:\n  odd ?i2 \\<Longrightarrow>\n  (\\<Sum>j | p (2 ^ j * ?i2) = 1. 2 ^ j) * ?i2 \\<le> n\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "from this"], ["proof (chain)\npicking this:\n  odd ?i2 \\<Longrightarrow>\n  (\\<Sum>j | p (2 ^ j * ?i2) = 1. 2 ^ j) * ?i2 \\<le> n", "have less_n: \"\\<And>i. odd_of_distinct p i * i \\<le> n\""], ["proof (prove)\nusing this:\n  odd ?i2 \\<Longrightarrow>\n  (\\<Sum>j | p (2 ^ j * ?i2) = 1. 2 ^ j) * ?i2 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i. odd_of_distinct p i * i \\<le> n", "unfolding odd_of_distinct_def"], ["proof (prove)\nusing this:\n  odd ?i2 \\<Longrightarrow>\n  (\\<Sum>j | p (2 ^ j * ?i2) = 1. 2 ^ j) * ?i2 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (if odd i then sum ((^) 2) {j. p (2 ^ j * i) = 1} else 0) * i \\<le> n", "by auto"], ["proof (state)\nthis:\n  odd_of_distinct p ?i * ?i \\<le> n\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "have \"odd_of_distinct p partitions n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n", "proof (rule partitionsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       odd_of_distinct p i \\<noteq> 0 \\<Longrightarrow>\n       1 \\<le> i \\<and> i \\<le> n\n 2. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       odd_of_distinct p i \\<noteq> 0 \\<Longrightarrow>\n       1 \\<le> i \\<and> i \\<le> n\n 2. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "assume \"odd_of_distinct p i \\<noteq> 0\""], ["proof (state)\nthis:\n  odd_of_distinct p i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       odd_of_distinct p i \\<noteq> 0 \\<Longrightarrow>\n       1 \\<le> i \\<and> i \\<le> n\n 2. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "from this assms"], ["proof (chain)\npicking this:\n  odd_of_distinct p i \\<noteq> 0\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}", "show \"1 \\<le> i \\<and> i \\<le> n\""], ["proof (prove)\nusing this:\n  odd_of_distinct p i \\<noteq> 0\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n\ngoal (1 subgoal):\n 1. 1 \\<le> i \\<and> i \\<le> n", "by (elim CollectE conjE partitionsE odd_of_distinct) auto"], ["proof (state)\nthis:\n  1 \\<le> i \\<and> i \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "have \"(\\<Sum>i\\<le>n. odd_of_distinct p i * i) = (\\<Sum>i\\<le>n. distinct_of_odd (odd_of_distinct p) i * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) =\n    (\\<Sum>i\\<le>n. distinct_of_odd (odd_of_distinct p) i * i)", "using assms less_n"], ["proof (prove)\nusing this:\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  odd_of_distinct p ?i * ?i \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) =\n    (\\<Sum>i\\<le>n. distinct_of_odd (odd_of_distinct p) i * i)", "by (subst sum_distinct_of_odd) (auto elim!: partitionsE odd_of_distinct simp only: odd)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. odd_of_distinct p i * i) =\n  (\\<Sum>i\\<le>n. distinct_of_odd (odd_of_distinct p) i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. odd_of_distinct p i * i) =\n  (\\<Sum>i\\<le>n. distinct_of_odd (odd_of_distinct p) i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "have \"... = (\\<Sum>i\\<le>n. p i * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd (odd_of_distinct p) i * i) =\n    (\\<Sum>i\\<le>n. p i * i)", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. distinct_of_odd (odd_of_distinct p) i * i) =\n    (\\<Sum>i\\<le>n. p i * i)", "by (auto elim!: partitionsE simp only:) (subst distinct_odd, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. distinct_of_odd (odd_of_distinct p) i * i) =\n  (\\<Sum>i\\<le>n. p i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. distinct_of_odd (odd_of_distinct p) i * i) =\n  (\\<Sum>i\\<le>n. p i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "with assms"], ["proof (chain)\npicking this:\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  (\\<Sum>i\\<le>n. distinct_of_odd (odd_of_distinct p) i * i) =\n  (\\<Sum>i\\<le>n. p i * i)", "have \"... = n\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  (\\<Sum>i\\<le>n. distinct_of_odd (odd_of_distinct p) i * i) =\n  (\\<Sum>i\\<le>n. p i * i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. p i * i) = n", "by (auto elim: partitionsE)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. p i * i) = n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "show \"(\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n", "."], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. odd_of_distinct p i * i) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd_of_distinct p partitions n\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "moreover"], ["proof (state)\nthis:\n  odd_of_distinct p partitions n\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "have \"\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i", "by (intro allI impI odd)"], ["proof (state)\nthis:\n  \\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "ultimately"], ["proof (chain)\npicking this:\n  odd_of_distinct p partitions n\n  \\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i", "show \"odd_of_distinct p partitions n \\<and> (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)\""], ["proof (prove)\nusing this:\n  odd_of_distinct p partitions n\n  \\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i\n\ngoal (1 subgoal):\n 1. odd_of_distinct p partitions n \\<and>\n    (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)", "by simp"], ["proof (state)\nthis:\n  odd_of_distinct p partitions n \\<and>\n  (\\<forall>i. odd_of_distinct p i \\<noteq> 0 \\<longrightarrow> odd i)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Euler's Partition Theorem\\<close>"], ["", "theorem Euler_partition_theorem:\n  \"card {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)} = card {p. p partitions n \\<and> (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\"\n  (is \"card ?distinct_partitions = card ?odd_partitions\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)} =\n    card\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "proof (rule card_bij_eq)"], ["proof (state)\ngoal (6 subgoals):\n 1. inj_on ?f {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 2. ?f ` {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n    \\<subseteq> {p. p partitions n \\<and>\n                    (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n 3. inj_on ?g\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n 4. ?g `\n    {p. p partitions n \\<and>\n        (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n    \\<subseteq> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 5. finite {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 6. finite\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "from odd_of_distinct_in_odd_partitions"], ["proof (chain)\npicking this:\n  ?p \\<in> {p. p partitions ?n \\<and>\n               (\\<forall>i. p i \\<le> 1)} \\<Longrightarrow>\n  odd_of_distinct ?p\n  \\<in> {p. p partitions ?n \\<and>\n            (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "show\n    \"odd_of_distinct ` ?distinct_partitions \\<subseteq> ?odd_partitions\""], ["proof (prove)\nusing this:\n  ?p \\<in> {p. p partitions ?n \\<and>\n               (\\<forall>i. p i \\<le> 1)} \\<Longrightarrow>\n  odd_of_distinct ?p\n  \\<in> {p. p partitions ?n \\<and>\n            (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n\ngoal (1 subgoal):\n 1. odd_of_distinct ` {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n    \\<subseteq> {p. p partitions n \\<and>\n                    (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "by auto"], ["proof (state)\nthis:\n  odd_of_distinct ` {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  \\<subseteq> {p. p partitions n \\<and>\n                  (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n\ngoal (5 subgoals):\n 1. inj_on odd_of_distinct\n     {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 2. inj_on ?g\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n 3. ?g `\n    {p. p partitions n \\<and>\n        (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n    \\<subseteq> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 4. finite {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 5. finite\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "moreover"], ["proof (state)\nthis:\n  odd_of_distinct ` {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  \\<subseteq> {p. p partitions n \\<and>\n                  (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n\ngoal (5 subgoals):\n 1. inj_on odd_of_distinct\n     {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 2. inj_on ?g\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n 3. ?g `\n    {p. p partitions n \\<and>\n        (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n    \\<subseteq> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 4. finite {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 5. finite\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "from distinct_of_odd_in_distinct_partitions"], ["proof (chain)\npicking this:\n  ?p \\<in> {p. p partitions ?n \\<and>\n               (\\<forall>i.\n                   p i \\<noteq> 0 \\<longrightarrow>\n                   odd i)} \\<Longrightarrow>\n  distinct_of_odd ?p\n  \\<in> {p. p partitions ?n \\<and> (\\<forall>i. p i \\<le> 1)}", "show\n    \"distinct_of_odd ` ?odd_partitions \\<subseteq> ?distinct_partitions\""], ["proof (prove)\nusing this:\n  ?p \\<in> {p. p partitions ?n \\<and>\n               (\\<forall>i.\n                   p i \\<noteq> 0 \\<longrightarrow>\n                   odd i)} \\<Longrightarrow>\n  distinct_of_odd ?p\n  \\<in> {p. p partitions ?n \\<and> (\\<forall>i. p i \\<le> 1)}\n\ngoal (1 subgoal):\n 1. distinct_of_odd `\n    {p. p partitions n \\<and>\n        (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n    \\<subseteq> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}", "by auto"], ["proof (state)\nthis:\n  distinct_of_odd `\n  {p. p partitions n \\<and>\n      (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n  \\<subseteq> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n\ngoal (4 subgoals):\n 1. inj_on odd_of_distinct\n     {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 2. inj_on distinct_of_odd\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n 3. finite {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 4. finite\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "moreover"], ["proof (state)\nthis:\n  distinct_of_odd `\n  {p. p partitions n \\<and>\n      (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n  \\<subseteq> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n\ngoal (4 subgoals):\n 1. inj_on odd_of_distinct\n     {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 2. inj_on distinct_of_odd\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n 3. finite {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 4. finite\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "have \"\\<forall>p\\<in>?distinct_partitions. distinct_of_odd (odd_of_distinct p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>{p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}.\n       distinct_of_odd (odd_of_distinct p) = p", "by auto (subst distinct_odd; auto simp add: partitions_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>{p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}.\n     distinct_of_odd (odd_of_distinct p) = p\n\ngoal (4 subgoals):\n 1. inj_on odd_of_distinct\n     {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 2. inj_on distinct_of_odd\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n 3. finite {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 4. finite\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "moreover"], ["proof (state)\nthis:\n  \\<forall>p\\<in>{p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}.\n     distinct_of_odd (odd_of_distinct p) = p\n\ngoal (4 subgoals):\n 1. inj_on odd_of_distinct\n     {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 2. inj_on distinct_of_odd\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n 3. finite {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 4. finite\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "have \"\\<forall>p\\<in>?odd_partitions. odd_of_distinct (distinct_of_odd p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>{p. p partitions n \\<and>\n                       (\\<forall>i.\n                           p i \\<noteq> 0 \\<longrightarrow> odd i)}.\n       odd_of_distinct (distinct_of_odd p) = p", "by auto (subst odd_distinct; auto simp add: partitions_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>{p. p partitions n \\<and>\n                     (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}.\n     odd_of_distinct (distinct_of_odd p) = p\n\ngoal (4 subgoals):\n 1. inj_on odd_of_distinct\n     {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 2. inj_on distinct_of_odd\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n 3. finite {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 4. finite\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "ultimately"], ["proof (chain)\npicking this:\n  odd_of_distinct ` {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  \\<subseteq> {p. p partitions n \\<and>\n                  (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n  distinct_of_odd `\n  {p. p partitions n \\<and>\n      (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n  \\<subseteq> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  \\<forall>p\\<in>{p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}.\n     distinct_of_odd (odd_of_distinct p) = p\n  \\<forall>p\\<in>{p. p partitions n \\<and>\n                     (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}.\n     odd_of_distinct (distinct_of_odd p) = p", "show \"inj_on odd_of_distinct ?distinct_partitions\"\n    \"inj_on distinct_of_odd ?odd_partitions\""], ["proof (prove)\nusing this:\n  odd_of_distinct ` {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  \\<subseteq> {p. p partitions n \\<and>\n                  (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n  distinct_of_odd `\n  {p. p partitions n \\<and>\n      (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n  \\<subseteq> {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  \\<forall>p\\<in>{p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}.\n     distinct_of_odd (odd_of_distinct p) = p\n  \\<forall>p\\<in>{p. p partitions n \\<and>\n                     (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}.\n     odd_of_distinct (distinct_of_odd p) = p\n\ngoal (1 subgoal):\n 1. inj_on odd_of_distinct\n     {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)} &&&\n    inj_on distinct_of_odd\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "by (intro bij_betw_imp_inj_on bij_betw_byWitness; auto)+"], ["proof (state)\nthis:\n  inj_on odd_of_distinct\n   {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  inj_on distinct_of_odd\n   {p. p partitions n \\<and>\n       (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n\ngoal (2 subgoals):\n 1. finite {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n 2. finite\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "show \"finite ?distinct_partitions\" \"finite ?odd_partitions\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)} &&&\n    finite\n     {p. p partitions n \\<and>\n         (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}", "by (simp add: finite_partitions)+"], ["proof (state)\nthis:\n  finite {p. p partitions n \\<and> (\\<forall>i. p i \\<le> 1)}\n  finite\n   {p. p partitions n \\<and>\n       (\\<forall>i. p i \\<noteq> 0 \\<longrightarrow> odd i)}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}