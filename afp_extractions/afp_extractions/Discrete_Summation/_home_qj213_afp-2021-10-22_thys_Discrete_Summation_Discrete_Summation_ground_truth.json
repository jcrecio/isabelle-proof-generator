{"file_name": "/home/qj213/afp-2021-10-22/thys/Discrete_Summation/Discrete_Summation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Discrete_Summation", "problem_names": ["lemma add_sum_orient:\n  \"sum f {k..<j} + sum f {l..<k} = sum f {l..<k} + sum f {k..<j}\"", "lemma add_sum_int:\n  fixes j k l :: int\n  shows \"j < k \\<Longrightarrow> k < l \\<Longrightarrow>\n    sum f {j..<k} + sum f {k..<l} = sum f {j..<l}\"", "lemma \\<Delta>_shift:\n  \"\\<Delta> (\\<lambda>k. l + f k) = \\<Delta> f\"", "lemma \\<Delta>_same_shift:\n  assumes \"\\<Delta> f = \\<Delta> g\"\n  shows \"\\<exists>l. plus l \\<circ> f \\<circ> of_int = g \\<circ> of_int\"", "lemma \\<Delta>_add:\n  \"\\<Delta> (\\<lambda>k. f k + g k) k = \\<Delta> f k + \\<Delta> g k\"", "lemma \\<Delta>_factor:\n  \"\\<Delta> (\\<lambda>k. c * k) k = c\"", "lemma \\<Sigma>_same [simp]:\n  \"\\<Sigma> f j j = 0\"", "lemma \\<Sigma>_positive:\n  \"j < l \\<Longrightarrow> \\<Sigma> f j l = sum (f \\<circ> of_int) {j..<l}\"", "lemma \\<Sigma>_negative:\n  \"j > l \\<Longrightarrow> \\<Sigma> f j l = - \\<Sigma> f l j\"", "lemma \\<Sigma>_comp_of_int:\n  \"\\<Sigma> (f \\<circ> of_int) = \\<Sigma> f\"", "lemma \\<Sigma>_const:\n  \"\\<Sigma> (\\<lambda>k. c) j l = of_int (l - j) * c\"", "lemma \\<Sigma>_add:\n  \"\\<Sigma> (\\<lambda>k. f k + g k) j l = \\<Sigma> f j l + \\<Sigma> g j l\"", "lemma \\<Sigma>_factor:\n  \"\\<Sigma> (\\<lambda>k. c * f k) j l = (c::'a::ring) * \\<Sigma> (\\<lambda>k. f k) j l\"", "lemma \\<Sigma>_concat:\n  \"\\<Sigma> f j k + \\<Sigma> f k l = \\<Sigma> f j l\"", "lemma \\<Sigma>_incr_upper:\n  \"\\<Sigma> f j (l + 1) = \\<Sigma> f j l + f (of_int l)\"", "lemma \\<Delta>_\\<Sigma>:\n  \"\\<Delta> (\\<Sigma> f j) = f\"", "lemma \\<Sigma>_\\<Delta>:\n  \"\\<Sigma> (\\<Delta> f) j l = f (of_int l) - f (of_int j)\""], "translations": [["", "lemma add_sum_orient:\n  \"sum f {k..<j} + sum f {l..<k} = sum f {l..<k} + sum f {k..<j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {k..<j} + sum f {l..<k} = sum f {l..<k} + sum f {k..<j}", "by (fact add.commute)"], ["", "lemma add_sum_int:\n  fixes j k l :: int\n  shows \"j < k \\<Longrightarrow> k < l \\<Longrightarrow>\n    sum f {j..<k} + sum f {k..<l} = sum f {j..<l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < k; k < l\\<rbrakk>\n    \\<Longrightarrow> sum f {j..<k} + sum f {k..<l} = sum f {j..<l}", "by (simp_all add: sum.union_inter [symmetric] ivl_disj_un)"], ["", "subsection \\<open>The shift operator\\<close>"], ["", "definition \\<Delta> :: \"('b::ring_1 \\<Rightarrow> 'a::ab_group_add) \\<Rightarrow> int \\<Rightarrow> 'a\"\nwhere\n  \"\\<Delta> f k = f (of_int (k + 1)) - f (of_int k)\""], ["", "lemma \\<Delta>_shift:\n  \"\\<Delta> (\\<lambda>k. l + f k) = \\<Delta> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> (\\<lambda>k. l + f k) = \\<Delta> f", "by (simp add: \\<Delta>_def fun_eq_iff)"], ["", "lemma \\<Delta>_same_shift:\n  assumes \"\\<Delta> f = \\<Delta> g\"\n  shows \"\\<exists>l. plus l \\<circ> f \\<circ> of_int = g \\<circ> of_int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "let ?F = \"\\<lambda>k. f (of_int k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "let ?G = \"\\<lambda>k. g (of_int k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "from assms"], ["proof (chain)\npicking this:\n  \\<Delta> f = \\<Delta> g", "have \"\\<And>k. \\<Delta> f (of_int k) = \\<Delta> g (of_int k)\""], ["proof (prove)\nusing this:\n  \\<Delta> f = \\<Delta> g\n\ngoal (1 subgoal):\n 1. \\<And>k. \\<Delta> f (of_int k) = \\<Delta> g (of_int k)", "by simp"], ["proof (state)\nthis:\n  \\<Delta> f (of_int ?k) = \\<Delta> g (of_int ?k)\n\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "then"], ["proof (chain)\npicking this:\n  \\<Delta> f (of_int ?k) = \\<Delta> g (of_int ?k)", "have k_incr: \"\\<And>k. ?F (k + 1) - ?G (k + 1) = ?F k - ?G k\""], ["proof (prove)\nusing this:\n  \\<Delta> f (of_int ?k) = \\<Delta> g (of_int ?k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       f (of_int (k + 1)) - g (of_int (k + 1)) = f (of_int k) - g (of_int k)", "by (simp add: \\<Delta>_def algebra_simps)"], ["proof (state)\nthis:\n  f (of_int (?k + 1)) - g (of_int (?k + 1)) = f (of_int ?k) - g (of_int ?k)\n\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "then"], ["proof (chain)\npicking this:\n  f (of_int (?k + 1)) - g (of_int (?k + 1)) = f (of_int ?k) - g (of_int ?k)", "have \"\\<And>k. ?F ((k - 1) + 1) - ?G ((k - 1) + 1) =\n    ?F (k - 1) - ?G (k - 1)\""], ["proof (prove)\nusing this:\n  f (of_int (?k + 1)) - g (of_int (?k + 1)) = f (of_int ?k) - g (of_int ?k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       f (of_int (k - 1 + 1)) - g (of_int (k - 1 + 1)) =\n       f (of_int (k - 1)) - g (of_int (k - 1))", "by blast"], ["proof (state)\nthis:\n  f (of_int (?k - 1 + 1)) - g (of_int (?k - 1 + 1)) =\n  f (of_int (?k - 1)) - g (of_int (?k - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "then"], ["proof (chain)\npicking this:\n  f (of_int (?k - 1 + 1)) - g (of_int (?k - 1 + 1)) =\n  f (of_int (?k - 1)) - g (of_int (?k - 1))", "have k_decr: \"\\<And>k. ?F (k - 1) - ?G (k - 1) = ?F k - ?G k\""], ["proof (prove)\nusing this:\n  f (of_int (?k - 1 + 1)) - g (of_int (?k - 1 + 1)) =\n  f (of_int (?k - 1)) - g (of_int (?k - 1))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       f (of_int (k - 1)) - g (of_int (k - 1)) = f (of_int k) - g (of_int k)", "by simp"], ["proof (state)\nthis:\n  f (of_int (?k - 1)) - g (of_int (?k - 1)) = f (of_int ?k) - g (of_int ?k)\n\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "have \"\\<And>k. ?F k - ?G k = ?F 0 - ?G 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. f (of_int k) - g (of_int k) = f (of_int 0) - g (of_int 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. f (of_int k) - g (of_int k) = f (of_int 0) - g (of_int 0)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. f (of_int k) - g (of_int k) = f (of_int 0) - g (of_int 0)", "show \"?F k - ?G k = ?F 0 - ?G 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (of_int k) - g (of_int k) = f (of_int 0) - g (of_int 0)", "by (induct k rule: int_induct)\n        (simp_all add: k_incr k_decr del: of_int_add of_int_diff of_int_0)"], ["proof (state)\nthis:\n  f (of_int k) - g (of_int k) = f (of_int 0) - g (of_int 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (of_int ?k) - g (of_int ?k) = f (of_int 0) - g (of_int 0)\n\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "then"], ["proof (chain)\npicking this:\n  f (of_int ?k) - g (of_int ?k) = f (of_int 0) - g (of_int 0)", "have \"\\<And>k. (plus (?G 0 - ?F 0) \\<circ> ?F) k = ?G k\""], ["proof (prove)\nusing this:\n  f (of_int ?k) - g (of_int ?k) = f (of_int 0) - g (of_int 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       ((+) (g (of_int 0) - f (of_int 0)) \\<circ>\n        (\\<lambda>k. f (of_int k)))\n        k =\n       g (of_int k)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  ((+) (g (of_int 0) - f (of_int 0)) \\<circ> (\\<lambda>k. f (of_int k)))\n   ?k =\n  g (of_int ?k)\n\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "then"], ["proof (chain)\npicking this:\n  ((+) (g (of_int 0) - f (of_int 0)) \\<circ> (\\<lambda>k. f (of_int k)))\n   ?k =\n  g (of_int ?k)", "have \"plus (?G 0 - ?F 0) \\<circ> ?F = ?G\""], ["proof (prove)\nusing this:\n  ((+) (g (of_int 0) - f (of_int 0)) \\<circ> (\\<lambda>k. f (of_int k)))\n   ?k =\n  g (of_int ?k)\n\ngoal (1 subgoal):\n 1. (+) (g (of_int 0) - f (of_int 0)) \\<circ> (\\<lambda>k. f (of_int k)) =\n    (\\<lambda>k. g (of_int k))", ".."], ["proof (state)\nthis:\n  (+) (g (of_int 0) - f (of_int 0)) \\<circ> (\\<lambda>k. f (of_int k)) =\n  (\\<lambda>k. g (of_int k))\n\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "then"], ["proof (chain)\npicking this:\n  (+) (g (of_int 0) - f (of_int 0)) \\<circ> (\\<lambda>k. f (of_int k)) =\n  (\\<lambda>k. g (of_int k))", "have \"plus (?G 0 - ?F 0) \\<circ> f \\<circ> of_int = g \\<circ> of_int\""], ["proof (prove)\nusing this:\n  (+) (g (of_int 0) - f (of_int 0)) \\<circ> (\\<lambda>k. f (of_int k)) =\n  (\\<lambda>k. g (of_int k))\n\ngoal (1 subgoal):\n 1. (+) (g (of_int 0) - f (of_int 0)) \\<circ> f \\<circ> of_int =\n    g \\<circ> of_int", "by (simp only: comp_def)"], ["proof (state)\nthis:\n  (+) (g (of_int 0) - f (of_int 0)) \\<circ> f \\<circ> of_int =\n  g \\<circ> of_int\n\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", "then"], ["proof (chain)\npicking this:\n  (+) (g (of_int 0) - f (of_int 0)) \\<circ> f \\<circ> of_int =\n  g \\<circ> of_int", "show ?thesis"], ["proof (prove)\nusing this:\n  (+) (g (of_int 0) - f (of_int 0)) \\<circ> f \\<circ> of_int =\n  g \\<circ> of_int\n\ngoal (1 subgoal):\n 1. \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int", ".."], ["proof (state)\nthis:\n  \\<exists>l. (+) l \\<circ> f \\<circ> of_int = g \\<circ> of_int\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<Delta>_add:\n  \"\\<Delta> (\\<lambda>k. f k + g k) k = \\<Delta> f k + \\<Delta> g k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> (\\<lambda>k. f k + g k) k = \\<Delta> f k + \\<Delta> g k", "by (simp add: \\<Delta>_def)"], ["", "lemma \\<Delta>_factor:\n  \"\\<Delta> (\\<lambda>k. c * k) k = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> ((*) c) k = c", "by (simp add: \\<Delta>_def algebra_simps)"], ["", "subsection \\<open>The formal sum operator\\<close>"], ["", "definition \\<Sigma> :: \"('b::ring_1 \\<Rightarrow> 'a::ab_group_add) \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> 'a\"\nwhere\n  \"\\<Sigma> f j l = (if j < l then sum (f \\<circ> of_int) {j..<l}\n    else if j > l then - sum (f \\<circ> of_int) {l..<j}\n    else 0)\""], ["", "lemma \\<Sigma>_same [simp]:\n  \"\\<Sigma> f j j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> f j j = (0::'a)", "by (simp add: \\<Sigma>_def)"], ["", "lemma \\<Sigma>_positive:\n  \"j < l \\<Longrightarrow> \\<Sigma> f j l = sum (f \\<circ> of_int) {j..<l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < l \\<Longrightarrow> \\<Sigma> f j l = sum (f \\<circ> of_int) {j..<l}", "by (simp add: \\<Sigma>_def)"], ["", "lemma \\<Sigma>_negative:\n  \"j > l \\<Longrightarrow> \\<Sigma> f j l = - \\<Sigma> f l j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < j \\<Longrightarrow> \\<Sigma> f j l = - \\<Sigma> f l j", "by (simp add: \\<Sigma>_def)"], ["", "lemma \\<Sigma>_comp_of_int:\n  \"\\<Sigma> (f \\<circ> of_int) = \\<Sigma> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> (f \\<circ> of_int) = \\<Sigma> f", "by (simp add: \\<Sigma>_def fun_eq_iff)"], ["", "lemma \\<Sigma>_const:\n  \"\\<Sigma> (\\<lambda>k. c) j l = of_int (l - j) * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> (\\<lambda>k. c) j l = of_int (l - j) * c", "by (simp add: \\<Sigma>_def algebra_simps)"], ["", "lemma \\<Sigma>_add:\n  \"\\<Sigma> (\\<lambda>k. f k + g k) j l = \\<Sigma> f j l + \\<Sigma> g j l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> (\\<lambda>k. f k + g k) j l = \\<Sigma> f j l + \\<Sigma> g j l", "by (simp add: \\<Sigma>_def sum.distrib)"], ["", "lemma \\<Sigma>_factor:\n  \"\\<Sigma> (\\<lambda>k. c * f k) j l = (c::'a::ring) * \\<Sigma> (\\<lambda>k. f k) j l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> (\\<lambda>k. c * f k) j l = c * \\<Sigma> f j l", "by (simp add: \\<Sigma>_def sum_distrib_left)"], ["", "lemma \\<Sigma>_concat:\n  \"\\<Sigma> f j k + \\<Sigma> f k l = \\<Sigma> f j l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> f j k + \\<Sigma> f k l = \\<Sigma> f j l", "by (simp add: \\<Sigma>_def algebra_simps add_sum_int)\n    (simp_all add: add_sum_orient [of \"\\<lambda>k. f (of_int k)\" k j l]\n      add_sum_orient [of \"\\<lambda>k. f (of_int k)\" j l k]\n      add_sum_orient [of \"\\<lambda>k. f (of_int k)\" j k l] add_sum_int)"], ["", "lemma \\<Sigma>_incr_upper:\n  \"\\<Sigma> f j (l + 1) = \\<Sigma> f j l + f (of_int l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> f j (l + 1) = \\<Sigma> f j l + f (of_int l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sigma> f j (l + 1) = \\<Sigma> f j l + f (of_int l)", "have \"{l..<l+1} = {l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l..<l + 1} = {l}", "by auto"], ["proof (state)\nthis:\n  {l..<l + 1} = {l}\n\ngoal (1 subgoal):\n 1. \\<Sigma> f j (l + 1) = \\<Sigma> f j l + f (of_int l)", "then"], ["proof (chain)\npicking this:\n  {l..<l + 1} = {l}", "have \"\\<Sigma> f l (l + 1) = f (of_int l)\""], ["proof (prove)\nusing this:\n  {l..<l + 1} = {l}\n\ngoal (1 subgoal):\n 1. \\<Sigma> f l (l + 1) = f (of_int l)", "by (simp add: \\<Sigma>_def)"], ["proof (state)\nthis:\n  \\<Sigma> f l (l + 1) = f (of_int l)\n\ngoal (1 subgoal):\n 1. \\<Sigma> f j (l + 1) = \\<Sigma> f j l + f (of_int l)", "moreover"], ["proof (state)\nthis:\n  \\<Sigma> f l (l + 1) = f (of_int l)\n\ngoal (1 subgoal):\n 1. \\<Sigma> f j (l + 1) = \\<Sigma> f j l + f (of_int l)", "have \"\\<Sigma> f j (l + 1) = \\<Sigma> f j l + \\<Sigma> f l (l + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> f j (l + 1) = \\<Sigma> f j l + \\<Sigma> f l (l + 1)", "by (simp add: \\<Sigma>_concat)"], ["proof (state)\nthis:\n  \\<Sigma> f j (l + 1) = \\<Sigma> f j l + \\<Sigma> f l (l + 1)\n\ngoal (1 subgoal):\n 1. \\<Sigma> f j (l + 1) = \\<Sigma> f j l + f (of_int l)", "ultimately"], ["proof (chain)\npicking this:\n  \\<Sigma> f l (l + 1) = f (of_int l)\n  \\<Sigma> f j (l + 1) = \\<Sigma> f j l + \\<Sigma> f l (l + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sigma> f l (l + 1) = f (of_int l)\n  \\<Sigma> f j (l + 1) = \\<Sigma> f j l + \\<Sigma> f l (l + 1)\n\ngoal (1 subgoal):\n 1. \\<Sigma> f j (l + 1) = \\<Sigma> f j l + f (of_int l)", "by simp"], ["proof (state)\nthis:\n  \\<Sigma> f j (l + 1) = \\<Sigma> f j l + f (of_int l)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Fundamental lemmas: The relation between @{term \\<Delta>} and @{term \\<Sigma>}\\<close>"], ["", "lemma \\<Delta>_\\<Sigma>:\n  \"\\<Delta> (\\<Sigma> f j) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> (\\<Sigma> f j) = f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<Delta> (\\<Sigma> f j) x = f x", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<Delta> (\\<Sigma> f j) x = f x", "show \"\\<Delta> (\\<Sigma> f j) k = f k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> (\\<Sigma> f j) k = f k", "by (simp add: \\<Delta>_def \\<Sigma>_incr_upper)"], ["proof (state)\nthis:\n  \\<Delta> (\\<Sigma> f j) k = f k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<Sigma>_\\<Delta>:\n  \"\\<Sigma> (\\<Delta> f) j l = f (of_int l) - f (of_int j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> (\\<Delta> f) j l = f (of_int l) - f (of_int j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sigma> (\\<Delta> f) j l = f (of_int l) - f (of_int j)", "from \\<Delta>_\\<Sigma>"], ["proof (chain)\npicking this:\n  \\<Delta> (\\<Sigma> ?f ?j) = ?f", "have \"\\<Delta> (\\<Sigma> (\\<Delta> f) j) = \\<Delta> f\""], ["proof (prove)\nusing this:\n  \\<Delta> (\\<Sigma> ?f ?j) = ?f\n\ngoal (1 subgoal):\n 1. \\<Delta> (\\<Sigma> (\\<Delta> f) j) = \\<Delta> f", "."], ["proof (state)\nthis:\n  \\<Delta> (\\<Sigma> (\\<Delta> f) j) = \\<Delta> f\n\ngoal (1 subgoal):\n 1. \\<Sigma> (\\<Delta> f) j l = f (of_int l) - f (of_int j)", "then"], ["proof (chain)\npicking this:\n  \\<Delta> (\\<Sigma> (\\<Delta> f) j) = \\<Delta> f", "obtain k where \"plus k \\<circ> \\<Sigma> (\\<Delta> f) j \\<circ> of_int = f \\<circ> of_int\""], ["proof (prove)\nusing this:\n  \\<Delta> (\\<Sigma> (\\<Delta> f) j) = \\<Delta> f\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        (+) k \\<circ> \\<Sigma> (\\<Delta> f) j \\<circ> of_int =\n        f \\<circ> of_int \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: \\<Delta>_same_shift)"], ["proof (state)\nthis:\n  (+) k \\<circ> \\<Sigma> (\\<Delta> f) j \\<circ> of_int = f \\<circ> of_int\n\ngoal (1 subgoal):\n 1. \\<Sigma> (\\<Delta> f) j l = f (of_int l) - f (of_int j)", "then"], ["proof (chain)\npicking this:\n  (+) k \\<circ> \\<Sigma> (\\<Delta> f) j \\<circ> of_int = f \\<circ> of_int", "have \"\\<And>q. f (of_int q) = k + \\<Sigma> (\\<Delta> f) j q\""], ["proof (prove)\nusing this:\n  (+) k \\<circ> \\<Sigma> (\\<Delta> f) j \\<circ> of_int = f \\<circ> of_int\n\ngoal (1 subgoal):\n 1. \\<And>q. f (of_int q) = k + \\<Sigma> (\\<Delta> f) j q", "by (simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  f (of_int ?q) = k + \\<Sigma> (\\<Delta> f) j ?q\n\ngoal (1 subgoal):\n 1. \\<Sigma> (\\<Delta> f) j l = f (of_int l) - f (of_int j)", "then"], ["proof (chain)\npicking this:\n  f (of_int ?q) = k + \\<Sigma> (\\<Delta> f) j ?q", "show ?thesis"], ["proof (prove)\nusing this:\n  f (of_int ?q) = k + \\<Sigma> (\\<Delta> f) j ?q\n\ngoal (1 subgoal):\n 1. \\<Sigma> (\\<Delta> f) j l = f (of_int l) - f (of_int j)", "by simp"], ["proof (state)\nthis:\n  \\<Sigma> (\\<Delta> f) j l = f (of_int l) - f (of_int j)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}