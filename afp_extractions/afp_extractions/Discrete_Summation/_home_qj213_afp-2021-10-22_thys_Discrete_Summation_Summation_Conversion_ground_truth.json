{"file_name": "/home/qj213/afp-2021-10-22/thys/Discrete_Summation/Summation_Conversion.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Discrete_Summation", "problem_names": ["lemma intervall_simps [summation]:\n  \"(\\<Sum>k::nat = 0..0. f k) = f 0\"\n  \"(\\<Sum>k::nat = 0..Suc n. f k) = f (Suc n) + (\\<Sum>k::nat = 0..n. f k)\"", "lemma \\<Delta>_ffact:\n  \"\\<Delta> (ffact (Suc n)) k = of_nat (Suc n) * ffact n (of_int k :: 'a :: comm_ring_1)\"", "lemma \\<Sigma>_ffact_divide [summation]:\n  \"\\<Sigma> (ffact n) j l =\n    (ffact (Suc n) (of_int l :: 'a :: {idom_divide, semiring_char_0}) - ffact (Suc n) (of_int j)) div of_nat (Suc n)\"", "lemma of_int_coeff:\n  \"(of_int l :: 'a::comm_ring_1) * numeral k = of_int (l * numeral k)\"", "lemmas nat_simps =\n  add_0_left add_0_right add_Suc add_Suc_right\n  mult_Suc mult_Suc_right mult_zero_left mult_zero_right\n  One_nat_def of_nat_simps", "lemmas of_int_pull_out =\n  of_int_add [symmetric] of_int_diff [symmetric] of_int_mult [symmetric]\n  of_int_coeff", "lemma of_nat_coeff:\n  \"(of_nat n :: 'a::comm_semiring_1) * numeral m = of_nat (n * numeral m)\"", "lemmas of_nat_pull_out =\n  of_nat_add [symmetric] of_nat_mult [symmetric] of_nat_coeff", "lemmas nat_pull_in =\n  nat_int_add", "lemmas of_int_pull_in =\n  of_int_pull_out [symmetric] add_divide_distrib diff_divide_distrib of_int_power\n  of_int_numeral of_int_neg_numeral times_divide_eq_left [symmetric]", "lemma \\<Sigma>_pos_id [summation]:\n  \"0 \\<le> k \\<Longrightarrow> 0 \\<le> l \\<Longrightarrow> \\<Sigma> (\\<lambda>r. f (pos_id r)) k l = \\<Sigma> f k l\"", "lemma [summation]:\n  \"(0::int) \\<le> 0\"\n  \"(0::int) \\<le> 1\"\n  \"(0::int) \\<le> numeral m\"\n  \"(0::int) \\<le> int n\"", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. m) = (\\<lambda>k. int m)\"", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. n) = pos_id\"", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. f n + g n) = (\\<lambda>k. lift_nat f k + lift_nat g k)\"", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. m * f n) = (\\<lambda>k. int m * lift_nat f k)\"", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. f n * m) = (\\<lambda>k. lift_nat f k * int m)\"", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. f n ^ m) = (\\<lambda>k. lift_nat f k ^ m)\""], "translations": [["", "lemma intervall_simps [summation]:\n  \"(\\<Sum>k::nat = 0..0. f k) = f 0\"\n  \"(\\<Sum>k::nat = 0..Suc n. f k) = f (Suc n) + (\\<Sum>k::nat = 0..n. f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {0..0} = f 0 &&& sum f {0..Suc n} = f (Suc n) + sum f {0..n}", "by (simp_all add: add.commute)"], ["", "lemma \\<Delta>_ffact:\n  \"\\<Delta> (ffact (Suc n)) k = of_nat (Suc n) * ffact n (of_int k :: 'a :: comm_ring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> (ffact (Suc n)) k = of_nat (Suc n) * ffact n (of_int k)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Delta> (ffact (Suc 0)) k = of_nat (Suc 0) * ffact 0 (of_int k)\n 2. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<Delta> (ffact (Suc 0)) k = of_nat (Suc 0) * ffact 0 (of_int k)\n 2. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> (ffact (Suc 0)) k = of_nat (Suc 0) * ffact 0 (of_int k)", "by (simp add: \\<Delta>_def ffact_Suc)"], ["proof (state)\nthis:\n  \\<Delta> (ffact (Suc 0)) k = of_nat (Suc 0) * ffact 0 (of_int k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<Delta> (ffact (Suc n)) k = of_nat (Suc n) * ffact n (of_int k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "obtain m where \"m = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. m = Suc n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  m = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "have \"\\<Delta> (ffact (Suc m)) k =\n    ffact (Suc m) (of_int (k + 1)) - ffact (Suc m) (of_int k :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta> (ffact (Suc m)) k =\n    ffact (Suc m) (of_int (k + 1)) - ffact (Suc m) (of_int k)", "by (simp add: \\<Delta>_def)"], ["proof (state)\nthis:\n  \\<Delta> (ffact (Suc m)) k =\n  ffact (Suc m) (of_int (k + 1)) - ffact (Suc m) (of_int k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "also"], ["proof (state)\nthis:\n  \\<Delta> (ffact (Suc m)) k =\n  ffact (Suc m) (of_int (k + 1)) - ffact (Suc m) (of_int k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "have \"\\<dots> = of_int (k + 1) * ffact m (of_int k)\n    - (ffact m (of_int k) * (of_int k - of_nat m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffact (Suc m) (of_int (k + 1)) - ffact (Suc m) (of_int k) =\n    of_int (k + 1) * ffact m (of_int k) -\n    ffact m (of_int k) * (of_int k - of_nat m)", "using ffact_Suc_rev [of m \"(of_int k :: 'a :: comm_ring_1)\"]"], ["proof (prove)\nusing this:\n  ffact (Suc m) (of_int k) = (of_int k - of_nat m) * ffact m (of_int k)\n\ngoal (1 subgoal):\n 1. ffact (Suc m) (of_int (k + 1)) - ffact (Suc m) (of_int k) =\n    of_int (k + 1) * ffact m (of_int k) -\n    ffact m (of_int k) * (of_int k - of_nat m)", "by (simp add: ac_simps ffact_Suc)"], ["proof (state)\nthis:\n  ffact (Suc m) (of_int (k + 1)) - ffact (Suc m) (of_int k) =\n  of_int (k + 1) * ffact m (of_int k) -\n  ffact m (of_int k) * (of_int k - of_nat m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "also"], ["proof (state)\nthis:\n  ffact (Suc m) (of_int (k + 1)) - ffact (Suc m) (of_int k) =\n  of_int (k + 1) * ffact m (of_int k) -\n  ffact m (of_int k) * (of_int k - of_nat m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "have \"\\<dots> = (of_int k + 1 - of_int k + of_nat m) * ffact m (of_int k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (k + 1) * ffact m (of_int k) -\n    ffact m (of_int k) * (of_int k - of_nat m) =\n    (of_int k + (1::'a) - of_int k + of_nat m) * ffact m (of_int k)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  of_int (k + 1) * ffact m (of_int k) -\n  ffact m (of_int k) * (of_int k - of_nat m) =\n  (of_int k + (1::'a) - of_int k + of_nat m) * ffact m (of_int k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "also"], ["proof (state)\nthis:\n  of_int (k + 1) * ffact m (of_int k) -\n  ffact m (of_int k) * (of_int k - of_nat m) =\n  (of_int k + (1::'a) - of_int k + of_nat m) * ffact m (of_int k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "have \"\\<dots> = of_nat (Suc m) * ffact m (of_int k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int k + (1::'a) - of_int k + of_nat m) * ffact m (of_int k) =\n    of_nat (Suc m) * ffact m (of_int k)", "by simp"], ["proof (state)\nthis:\n  (of_int k + (1::'a) - of_int k + of_nat m) * ffact m (of_int k) =\n  of_nat (Suc m) * ffact m (of_int k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "also"], ["proof (state)\nthis:\n  (of_int k + (1::'a) - of_int k + of_nat m) * ffact m (of_int k) =\n  of_nat (Suc m) * ffact m (of_int k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "have \"\\<dots> = of_nat (Suc m) * ffact (Suc m - 1) (of_int k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (Suc m) * ffact m (of_int k) =\n    of_nat (Suc m) * ffact (Suc m - 1) (of_int k)", "by simp"], ["proof (state)\nthis:\n  of_nat (Suc m) * ffact m (of_int k) =\n  of_nat (Suc m) * ffact (Suc m - 1) (of_int k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Delta> (ffact (Suc n)) k =\n       of_nat (Suc n) * ffact n (of_int k) \\<Longrightarrow>\n       \\<Delta> (ffact (Suc (Suc n))) k =\n       of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "finally"], ["proof (chain)\npicking this:\n  \\<Delta> (ffact (Suc m)) k = of_nat (Suc m) * ffact (Suc m - 1) (of_int k)", "show ?case"], ["proof (prove)\nusing this:\n  \\<Delta> (ffact (Suc m)) k = of_nat (Suc m) * ffact (Suc m - 1) (of_int k)\n\ngoal (1 subgoal):\n 1. \\<Delta> (ffact (Suc (Suc n))) k =\n    of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)", "by (simp only: \\<open>m = Suc n\\<close> diff_Suc_1)"], ["proof (state)\nthis:\n  \\<Delta> (ffact (Suc (Suc n))) k =\n  of_nat (Suc (Suc n)) * ffact (Suc n) (of_int k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<Sigma>_ffact_divide [summation]:\n  \"\\<Sigma> (ffact n) j l =\n    (ffact (Suc n) (of_int l :: 'a :: {idom_divide, semiring_char_0}) - ffact (Suc n) (of_int j)) div of_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> (ffact n) j l =\n    (ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j)) div of_nat (Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sigma> (ffact n) j l =\n    (ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j)) div of_nat (Suc n)", "have *: \"(of_nat (Suc n) * \\<Sigma> (ffact n) j l) div of_nat (Suc n) = (\\<Sigma> (ffact n) j l :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (Suc n) * \\<Sigma> (ffact n) j l div of_nat (Suc n) =\n    \\<Sigma> (ffact n) j l", "using of_nat_neq_0 [where ?'a = 'a]"], ["proof (prove)\nusing this:\n  of_nat (Suc ?n) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. of_nat (Suc n) * \\<Sigma> (ffact n) j l div of_nat (Suc n) =\n    \\<Sigma> (ffact n) j l", "by simp"], ["proof (state)\nthis:\n  of_nat (Suc n) * \\<Sigma> (ffact n) j l div of_nat (Suc n) =\n  \\<Sigma> (ffact n) j l\n\ngoal (1 subgoal):\n 1. \\<Sigma> (ffact n) j l =\n    (ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j)) div of_nat (Suc n)", "have \"ffact (Suc n) (of_int l :: 'a) - ffact (Suc n) (of_int j) =\n    \\<Sigma> (\\<lambda>k. \\<Delta> (ffact (Suc n)) k) j l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j) =\n    \\<Sigma> (\\<Delta> (ffact (Suc n))) j l", "by (simp add: \\<Sigma>_\\<Delta>)"], ["proof (state)\nthis:\n  ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j) =\n  \\<Sigma> (\\<Delta> (ffact (Suc n))) j l\n\ngoal (1 subgoal):\n 1. \\<Sigma> (ffact n) j l =\n    (ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j)) div of_nat (Suc n)", "also"], ["proof (state)\nthis:\n  ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j) =\n  \\<Sigma> (\\<Delta> (ffact (Suc n))) j l\n\ngoal (1 subgoal):\n 1. \\<Sigma> (ffact n) j l =\n    (ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j)) div of_nat (Suc n)", "have \"\\<dots> = \\<Sigma> (\\<lambda>k. of_nat (Suc n) * ffact n (of_int k)) j l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> (\\<Delta> (ffact (Suc n))) j l =\n    \\<Sigma> (\\<lambda>k. of_nat (Suc n) * ffact n (of_int k)) j l", "by (simp add: \\<Delta>_ffact)"], ["proof (state)\nthis:\n  \\<Sigma> (\\<Delta> (ffact (Suc n))) j l =\n  \\<Sigma> (\\<lambda>k. of_nat (Suc n) * ffact n (of_int k)) j l\n\ngoal (1 subgoal):\n 1. \\<Sigma> (ffact n) j l =\n    (ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j)) div of_nat (Suc n)", "also"], ["proof (state)\nthis:\n  \\<Sigma> (\\<Delta> (ffact (Suc n))) j l =\n  \\<Sigma> (\\<lambda>k. of_nat (Suc n) * ffact n (of_int k)) j l\n\ngoal (1 subgoal):\n 1. \\<Sigma> (ffact n) j l =\n    (ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j)) div of_nat (Suc n)", "have \"\\<dots> = of_nat (Suc n) * \\<Sigma> (ffact n \\<circ> of_int) j l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> (\\<lambda>k. of_nat (Suc n) * ffact n (of_int k)) j l =\n    of_nat (Suc n) * \\<Sigma> (ffact n \\<circ> of_int) j l", "by (simp add: \\<Sigma>_factor comp_def)"], ["proof (state)\nthis:\n  \\<Sigma> (\\<lambda>k. of_nat (Suc n) * ffact n (of_int k)) j l =\n  of_nat (Suc n) * \\<Sigma> (ffact n \\<circ> of_int) j l\n\ngoal (1 subgoal):\n 1. \\<Sigma> (ffact n) j l =\n    (ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j)) div of_nat (Suc n)", "finally"], ["proof (chain)\npicking this:\n  ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j) =\n  of_nat (Suc n) * \\<Sigma> (ffact n \\<circ> of_int) j l", "show ?thesis"], ["proof (prove)\nusing this:\n  ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j) =\n  of_nat (Suc n) * \\<Sigma> (ffact n \\<circ> of_int) j l\n\ngoal (1 subgoal):\n 1. \\<Sigma> (ffact n) j l =\n    (ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j)) div of_nat (Suc n)", "by (simp only: \\<Sigma>_comp_of_int * of_nat_eq_0_iff)"], ["proof (state)\nthis:\n  \\<Sigma> (ffact n) j l =\n  (ffact (Suc n) (of_int l) - ffact (Suc n) (of_int j)) div of_nat (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Various other rules\\<close>"], ["", "lemma of_int_coeff:\n  \"(of_int l :: 'a::comm_ring_1) * numeral k = of_int (l * numeral k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l * numeral k = of_int (l * numeral k)", "by simp"], ["", "lemmas nat_simps =\n  add_0_left add_0_right add_Suc add_Suc_right\n  mult_Suc mult_Suc_right mult_zero_left mult_zero_right\n  One_nat_def of_nat_simps"], ["", "lemmas of_int_pull_out =\n  of_int_add [symmetric] of_int_diff [symmetric] of_int_mult [symmetric]\n  of_int_coeff"], ["", "lemma of_nat_coeff:\n  \"(of_nat n :: 'a::comm_semiring_1) * numeral m = of_nat (n * numeral m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n * numeral m = of_nat (n * numeral m)", "by (induct n) simp_all"], ["", "lemmas of_nat_pull_out =\n  of_nat_add [symmetric] of_nat_mult [symmetric] of_nat_coeff"], ["", "lemmas nat_pull_in =\n  nat_int_add"], ["", "lemmas of_int_pull_in =\n  of_int_pull_out [symmetric] add_divide_distrib diff_divide_distrib of_int_power\n  of_int_numeral of_int_neg_numeral times_divide_eq_left [symmetric]"], ["", "text \\<open>Special for @{typ nat}\\<close>"], ["", "definition lift_nat :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> int \\<Rightarrow> int\"\nwhere\n  \"lift_nat f = int \\<circ> f \\<circ> nat\""], ["", "definition \\<Sigma>_nat :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" (\"\\<Sigma>\\<^sub>\\<nat>\")\nwhere\n  [summation]: \"\\<Sigma>\\<^sub>\\<nat> f m n = nat (\\<Sigma> (lift_nat f) (int m) (int n))\""], ["", "definition pos_id :: \"int \\<Rightarrow> int\"\nwhere\n  \"pos_id k = (if k < 0 then 0 else k)\""], ["", "lemma \\<Sigma>_pos_id [summation]:\n  \"0 \\<le> k \\<Longrightarrow> 0 \\<le> l \\<Longrightarrow> \\<Sigma> (\\<lambda>r. f (pos_id r)) k l = \\<Sigma> f k l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> k; 0 \\<le> l\\<rbrakk>\n    \\<Longrightarrow> \\<Sigma> (\\<lambda>r. f (pos_id r)) k l =\n                      \\<Sigma> f k l", "by (simp add: \\<Sigma>_def pos_id_def)"], ["", "lemma [summation]:\n  \"(0::int) \\<le> 0\"\n  \"(0::int) \\<le> 1\"\n  \"(0::int) \\<le> numeral m\"\n  \"(0::int) \\<le> int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> 0 &&& 0 \\<le> 1) &&& 0 \\<le> numeral m &&& 0 \\<le> int n", "by simp_all"], ["", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. m) = (\\<lambda>k. int m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_nat (\\<lambda>n. m) = (\\<lambda>k. int m)", "by (simp add: lift_nat_def fun_eq_iff)"], ["", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. n) = pos_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_nat (\\<lambda>n. n) = pos_id", "by (simp add: lift_nat_def fun_eq_iff pos_id_def)"], ["", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. f n + g n) = (\\<lambda>k. lift_nat f k + lift_nat g k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_nat (\\<lambda>n. f n + g n) =\n    (\\<lambda>k. lift_nat f k + lift_nat g k)", "by (simp add: lift_nat_def fun_eq_iff)"], ["", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. m * f n) = (\\<lambda>k. int m * lift_nat f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_nat (\\<lambda>n. m * f n) = (\\<lambda>k. int m * lift_nat f k)", "by (simp add: lift_nat_def fun_eq_iff)"], ["", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. f n * m) = (\\<lambda>k. lift_nat f k * int m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_nat (\\<lambda>n. f n * m) = (\\<lambda>k. lift_nat f k * int m)", "by (simp add: lift_nat_def fun_eq_iff)"], ["", "lemma [summation]:\n  \"lift_nat (\\<lambda>n. f n ^ m) = (\\<lambda>k. lift_nat f k ^ m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_nat (\\<lambda>n. f n ^ m) = (\\<lambda>k. lift_nat f k ^ m)", "by (simp add: lift_nat_def fun_eq_iff)"], ["", "text \\<open>Generic conversion\\<close>"], ["", "ML \\<open>\nsignature SUMMATION =\nsig\n  val conv: Proof.context -> conv\nend\n\nstructure Summation : SUMMATION =\nstruct\n\nval simps2 = @{thms Stirling.simps ffact_0 ffact_Suc nat_simps};\nval simpset3 =\n  @{context}\n  |> fold Simplifier.add_simp @{thms field_simps}\n  |> Simplifier.simpset_of;\nval simps4 = @{thms of_int_pull_out of_nat_pull_out nat_pull_in};\nval simps6 = @{thms of_int_pull_in};\n\nfun conv ctxt =\n  let\n    val ctxt1 =\n      ctxt\n      |> put_simpset HOL_basic_ss\n      |> fold Simplifier.add_simp (Named_Theorems.get ctxt @{named_theorems summation})\n    val ctxt2 =\n      ctxt\n      |> put_simpset HOL_basic_ss\n      |> fold Simplifier.add_simp simps2\n    val ctxt3 =\n      ctxt\n      |> put_simpset simpset3\n    val ctxt4 =\n      ctxt\n      |> put_simpset HOL_basic_ss\n      |> fold Simplifier.add_simp simps4\n    val semiring_conv_base = Semiring_Normalizer.semiring_normalize_conv ctxt\n    val semiring_conv = Conv.arg_conv (Conv.arg1_conv (Conv.arg_conv semiring_conv_base))\n      else_conv Conv.arg1_conv (Conv.arg_conv semiring_conv_base)\n      else_conv semiring_conv_base\n    val ctxt6 =\n      ctxt\n      |> put_simpset HOL_basic_ss\n      |> fold Simplifier.add_simp simps6\n  in\n     Simplifier.rewrite ctxt1\n     then_conv Simplifier.rewrite ctxt2\n     then_conv Simplifier.rewrite ctxt3\n     then_conv Simplifier.rewrite ctxt4\n     then_conv semiring_conv\n     then_conv Simplifier.rewrite ctxt6\n  end\n\nend\n\\<close>"], ["", "hide_fact (open) nat_simps of_int_pull_out of_int_pull_in"], ["", "end"]]}