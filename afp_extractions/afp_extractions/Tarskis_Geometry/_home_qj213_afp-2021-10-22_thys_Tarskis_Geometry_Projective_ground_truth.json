{"file_name": "/home/qj213/afp-2021-10-22/thys/Tarskis_Geometry/Projective.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tarskis_Geometry", "problem_names": ["lemma proportionality_refl_on: \"refl_on local.non_zero_vectors local.proportionality\"", "lemma proportionality_sym: \"sym local.proportionality\"", "lemma proportionality_trans: \"trans local.proportionality\"", "theorem proportionality_equiv: \"equiv local.non_zero_vectors local.proportionality\"", "lemma invertible_proportionality_equiv:\n  \"equiv (Collect invertible :: (real^('n::finite)^'n) set)\n  invertible_proportionality\"\n  (is \"equiv ?invs _\")", "lemma proj2_rep_in: \"proj2_rep x \\<in> Rep_proj2 x\"", "lemma proj2_rep_non_zero: \"proj2_rep x \\<noteq> 0\"", "lemma proj2_rep_abs:\n  fixes v :: \"real^3\"\n  assumes \"v \\<in> real_vector.non_zero_vectors\"\n  shows \"(v, proj2_rep (proj2_abs v)) \\<in> real_vector.proportionality\"", "lemma proj2_abs_rep: \"proj2_abs (proj2_rep x) = x\"", "lemma proj2_abs_mult:\n  assumes \"c \\<noteq> 0\"\n  shows \"proj2_abs (c *\\<^sub>R v) = proj2_abs v\"", "lemma proj2_abs_mult_rep:\n  assumes \"c \\<noteq> 0\"\n  shows \"proj2_abs (c *\\<^sub>R proj2_rep x) = x\"", "lemma proj2_rep_inj: \"inj proj2_rep\"", "lemma proj2_rep_abs2:\n  assumes \"v \\<noteq> 0\"\n  shows \"\\<exists> k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v\"", "lemma proj2_abs_abs_mult:\n  assumes \"proj2_abs v = proj2_abs w\" and \"w \\<noteq> 0\"\n  shows \"\\<exists> c. v = c *\\<^sub>R w\"", "lemma dependent_proj2_abs:\n  assumes \"p \\<noteq> 0\" and \"q \\<noteq> 0\" and \"i \\<noteq> 0 \\<or> j \\<noteq> 0\" and \"i *\\<^sub>R p + j *\\<^sub>R q = 0\"\n  shows \"proj2_abs p = proj2_abs q\"", "lemma proj2_rep_dependent:\n  assumes \"i *\\<^sub>R proj2_rep v + j *\\<^sub>R proj2_rep w = 0\"\n  (is \"i *\\<^sub>R ?p + j *\\<^sub>R ?q = 0\")\n  and \"i \\<noteq> 0 \\<or> j \\<noteq> 0\"\n  shows \"v = w\"", "lemma proj2_rep_independent:\n  assumes \"p \\<noteq> q\"\n  shows \"independent {proj2_rep p, proj2_rep q}\"", "lemma proj2_Col_abs:\n  assumes \"p \\<noteq> 0\" and \"q \\<noteq> 0\" and \"r \\<noteq> 0\" and \"i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\"\n  and \"i *\\<^sub>R p + j *\\<^sub>R q + k *\\<^sub>R r = 0\"\n  shows \"proj2_Col (proj2_abs p) (proj2_abs q) (proj2_abs r)\"\n  (is \"proj2_Col ?pp ?pq ?pr\")", "lemma proj2_Col_permute:\n  assumes \"proj2_Col a b c\"\n  shows \"proj2_Col a c b\"\n  and \"proj2_Col b a c\"", "lemma proj2_Col_coincide: \"proj2_Col a a c\"", "lemma proj2_Col_iff:\n  assumes \"a \\<noteq> r\"\n  shows \"proj2_Col a r t \\<longleftrightarrow>\n  t = a \\<or> (\\<exists> i. t = proj2_abs (i *\\<^sub>R (proj2_rep a) + (proj2_rep r)))\"", "lemma proj2_Col_coeff:\n  assumes \"proj2_Col a r t\" and \"a \\<noteq> r\" and \"t \\<noteq> a\"\n  shows \"t = proj2_abs ((proj2_Col_coeff a r t) *\\<^sub>R proj2_rep a + proj2_rep r)\"", "lemma proj2_Col_coeff_unique':\n  assumes \"a \\<noteq> 0\" and \"r \\<noteq> 0\" and \"proj2_abs a \\<noteq> proj2_abs r\"\n  and \"proj2_abs (i *\\<^sub>R a + r) = proj2_abs (j *\\<^sub>R a + r)\"\n  shows \"i = j\"", "lemma proj2_Col_coeff_unique:\n  assumes \"a \\<noteq> r\"\n  and \"proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)\n  = proj2_abs (j *\\<^sub>R proj2_rep a + proj2_rep r)\"\n  shows \"i = j\"", "lemma L2P_P2L [simp]: \"L2P (P2L p) = p\"", "lemma P2L_L2P [simp]: \"P2L (L2P l) = l\"", "lemma L2P_inj [simp]:\n  assumes \"L2P l = L2P m\"\n  shows \"l = m\"", "lemma P2L_to_L2P: \"P2L p = l \\<longleftrightarrow> p = L2P l\"", "lemma proj2_line_rep_abs:\n  assumes \"v \\<noteq> 0\"\n  shows \"\\<exists> k. k \\<noteq> 0 \\<and> proj2_line_rep (proj2_line_abs v) = k *\\<^sub>R v\"", "lemma proj2_line_abs_rep [simp]: \"proj2_line_abs (proj2_line_rep l) = l\"", "lemma proj2_line_rep_non_zero: \"proj2_line_rep l \\<noteq> 0\"", "lemma proj2_line_rep_dependent:\n  assumes \"i *\\<^sub>R proj2_line_rep l + j *\\<^sub>R proj2_line_rep m = 0\"\n  and \"i \\<noteq> 0 \\<or> j \\<noteq> 0\"\n  shows \"l = m\"", "lemma proj2_line_abs_mult:\n  assumes \"k \\<noteq> 0\"\n  shows \"proj2_line_abs (k *\\<^sub>R v) = proj2_line_abs v\"", "lemma proj2_line_abs_abs_mult:\n  assumes \"proj2_line_abs v = proj2_line_abs w\" and \"w \\<noteq> 0\"\n  shows \"\\<exists> k. v = k *\\<^sub>R w\"", "lemma proj2_points_define_line:\n  shows \"\\<exists> l. proj2_incident p l \\<and> proj2_incident q l\"", "lemma proj2_line_through_incident:\n  shows \"proj2_incident p (proj2_line_through p q)\"\n  and \"proj2_incident q (proj2_line_through p q)\"", "lemma proj2_line_through_unique:\n  assumes \"p \\<noteq> q\" and \"proj2_incident p l\" and \"proj2_incident q l\"\n  shows \"l = proj2_line_through p q\"", "lemma proj2_incident_unique:\n  assumes \"proj2_incident p l\"\n  and \"proj2_incident q l\"\n  and \"proj2_incident p m\"\n  and \"proj2_incident q m\"\n  shows \"p = q \\<or> l = m\"", "lemma proj2_lines_define_point: \"\\<exists> p. proj2_incident p l \\<and> proj2_incident p m\"", "lemma proj2_incident_switch:\n  assumes \"proj2_incident p l\"\n  shows \"proj2_incident (L2P l) (P2L p)\"", "lemma proj2_intersection_incident:\n  shows \"proj2_incident (proj2_intersection l m) l\"\n  and \"proj2_incident (proj2_intersection l m) m\"", "lemma proj2_intersection_unique:\n  assumes \"l \\<noteq> m\" and \"proj2_incident p l\" and \"proj2_incident p m\"\n  shows \"p = proj2_intersection l m\"", "lemma proj2_not_self_incident:\n  \"\\<not> (proj2_incident p (P2L p))\"", "lemma proj2_another_point_on_line:\n  \"\\<exists> q. q \\<noteq> p \\<and> proj2_incident q l\"", "lemma proj2_another_line_through_point:\n  \"\\<exists> m. m \\<noteq> l \\<and> proj2_incident p m\"", "lemma proj2_incident_abs:\n  assumes \"v \\<noteq> 0\" and \"w \\<noteq> 0\"\n  shows \"proj2_incident (proj2_abs v) (proj2_line_abs w) \\<longleftrightarrow> v \\<bullet> w = 0\"", "lemma proj2_incident_left_abs:\n  assumes \"v \\<noteq> 0\"\n  shows \"proj2_incident (proj2_abs v) l \\<longleftrightarrow> v \\<bullet> (proj2_line_rep l) = 0\"", "lemma proj2_incident_right_abs:\n  assumes \"v \\<noteq> 0\"\n  shows \"proj2_incident p (proj2_line_abs v) \\<longleftrightarrow> (proj2_rep p) \\<bullet> v = 0\"", "lemma proj2_subset_Col:\n  assumes \"T \\<subseteq> S\" and \"proj2_set_Col S\"\n  shows \"proj2_set_Col T\"", "lemma proj2_Col_iff_not_invertible:\n  \"proj2_Col p q r\n  \\<longleftrightarrow> \\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r] :: real^3^3)\"\n  (is \"_ \\<longleftrightarrow> \\<not> invertible (vector [?u, ?v, ?w])\")", "lemma not_invertible_iff_proj2_set_Col:\n  \"\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r] :: real^3^3)\n  \\<longleftrightarrow> proj2_set_Col {p,q,r}\"\n  (is \"\\<not> invertible ?M \\<longleftrightarrow> _\")", "lemma proj2_Col_iff_set_Col:\n  \"proj2_Col p q r \\<longleftrightarrow> proj2_set_Col {p,q,r}\"", "lemma proj2_incident_Col:\n  assumes \"proj2_incident p l\" and \"proj2_incident q l\" and \"proj2_incident r l\"\n  shows \"proj2_Col p q r\"", "lemma proj2_incident_iff_Col:\n  assumes \"p \\<noteq> q\" and \"proj2_incident p l\" and \"proj2_incident q l\"\n  shows \"proj2_incident r l \\<longleftrightarrow> proj2_Col p q r\"", "lemma proj2_incident_iff:\n  assumes \"p \\<noteq> q\" and \"proj2_incident p l\" and \"proj2_incident q l\"\n  shows \"proj2_incident r l\n  \\<longleftrightarrow> r = p \\<or> (\\<exists> k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q))\"", "lemma not_proj2_set_Col_iff_span:\n  assumes \"card S = 3\"\n  shows \"\\<not> proj2_set_Col S \\<longleftrightarrow> span (proj2_rep ` S) = UNIV\"", "lemma proj2_no_3_Col_span:\n  assumes \"proj2_no_3_Col S\" and \"p \\<in> S\"\n  shows \"span (proj2_rep ` (S - {p})) = UNIV\"", "lemma fourth_proj2_no_3_Col:\n  assumes \"\\<not> proj2_Col p q r\"\n  shows \"\\<exists> s. proj2_no_3_Col {s,r,p,q}\"", "lemma proj2_set_Col_expand:\n  assumes \"proj2_set_Col S\" and \"{p,q,r} \\<subseteq> S\" and \"p \\<noteq> q\" and \"r \\<noteq> p\"\n  shows \"\\<exists> k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\"", "lemma cltn2_rep_in: \"cltn2_rep B \\<in> Rep_cltn2 B\"", "lemma cltn2_rep_invertible: \"invertible (cltn2_rep A)\"", "lemma cltn2_rep_abs:\n  fixes A :: \"real^3^3\"\n  assumes \"invertible A\"\n  shows \"(A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality\"", "lemma cltn2_rep_abs2:\n  assumes \"invertible A\"\n  shows \"\\<exists> k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A\"", "lemma cltn2_abs_rep: \"cltn2_abs (cltn2_rep A) = A\"", "lemma cltn2_abs_mult:\n  assumes \"k \\<noteq> 0\" and \"invertible A\"\n  shows \"cltn2_abs (k *\\<^sub>R A) = cltn2_abs A\"", "lemma cltn2_abs_mult_rep:\n  assumes \"k \\<noteq> 0\"\n  shows \"cltn2_abs (k *\\<^sub>R cltn2_rep A) = A\"", "lemma apply_cltn2_abs:\n  assumes \"x \\<noteq> 0\" and \"invertible A\"\n  shows \"apply_cltn2 (proj2_abs x) (cltn2_abs A) = proj2_abs (x v* A)\"", "lemma apply_cltn2_left_abs:\n  assumes \"v \\<noteq> 0\"\n  shows \"apply_cltn2 (proj2_abs v) C = proj2_abs (v v* cltn2_rep C)\"", "lemma apply_cltn2_right_abs:\n  assumes \"invertible M\"\n  shows \"apply_cltn2 p (cltn2_abs M) = proj2_abs (proj2_rep p v* M)\"", "lemma non_zero_mult_rep_non_zero:\n  assumes \"v \\<noteq> 0\"\n  shows \"v v* cltn2_rep C \\<noteq> 0\"", "lemma rep_mult_rep_non_zero: \"proj2_rep p v* cltn2_rep A \\<noteq> 0\"", "lemma cltn2_compose_abs:\n  assumes \"invertible M\" and \"invertible N\"\n  shows \"cltn2_compose (cltn2_abs M) (cltn2_abs N) = cltn2_abs (M ** N)\"", "lemma cltn2_compose_left_abs:\n  assumes \"invertible M\"\n  shows \"cltn2_compose (cltn2_abs M) A = cltn2_abs (M ** cltn2_rep A)\"", "lemma cltn2_compose_right_abs:\n  assumes \"invertible M\"\n  shows \"cltn2_compose A (cltn2_abs M) = cltn2_abs (cltn2_rep A ** M)\"", "lemma cltn2_abs_rep_abs_mult:\n  assumes \"invertible M\" and \"invertible N\"\n  shows \"cltn2_abs (cltn2_rep (cltn2_abs M) ** N) = cltn2_abs (M ** N)\"", "lemma cltn2_assoc:\n  \"cltn2_compose (cltn2_compose A B) C = cltn2_compose A (cltn2_compose B C)\"", "lemma cltn2_left_id: \"cltn2_compose cltn2_id A = A\"", "lemma cltn2_left_inverse: \"cltn2_compose (cltn2_inverse A) A = cltn2_id\"", "lemma cltn2_left_inverse_ex:\n  \"\\<exists> B. cltn2_compose B A = cltn2_id\"", "lemma cltn2_inverse_inv [simp]:\n  \"inv\\<^bsub>(|carrier = UNIV, mult = cltn2_compose, one = cltn2_id|)\\<^esub> A\n  = cltn2_inverse A\"", "lemmas cltn2_inverse_id [simp] = cltn2.inv_one [simplified]\n  and cltn2_inverse_compose = cltn2.inv_mult_group [simplified]", "lemma apply_cltn2_id [simp]: \"apply_cltn2 p cltn2_id = p\"", "lemma apply_cltn2_compose:\n  \"apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (cltn2_compose A B)\"", "lemma cltn2_transpose_abs:\n  assumes \"invertible M\"\n  shows \"cltn2_transpose (cltn2_abs M) = cltn2_abs (transpose M)\"", "lemma cltn2_transpose_compose:\n  \"cltn2_transpose (cltn2_compose A B)\n  = cltn2_compose (cltn2_transpose B) (cltn2_transpose A)\"", "lemma cltn2_transpose_transpose: \"cltn2_transpose (cltn2_transpose A) = A\"", "lemma cltn2_transpose_id [simp]: \"cltn2_transpose cltn2_id = cltn2_id\"", "lemma apply_cltn2_line_id [simp]: \"apply_cltn2_line l cltn2_id = l\"", "lemma apply_cltn2_line_compose:\n  \"apply_cltn2_line (apply_cltn2_line l A) B\n  = apply_cltn2_line l (cltn2_compose A B)\"", "lemmas apply_cltn2_inv [simp] = cltn2.act_act_inv [simplified]", "lemmas apply_cltn2_line_inv [simp] = cltn2_line.act_act_inv [simplified]", "lemma apply_cltn2_line_alt_def:\n  \"apply_cltn2_line l A\n  = proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\"", "lemma rep_mult_line_rep_non_zero: \"cltn2_rep A *v proj2_line_rep l \\<noteq> 0\"", "lemma apply_cltn2_incident:\n  \"proj2_incident p (apply_cltn2_line l A)\n  \\<longleftrightarrow> proj2_incident (apply_cltn2 p (cltn2_inverse A)) l\"", "lemma apply_cltn2_preserve_incident [iff]:\n  \"proj2_incident (apply_cltn2 p A) (apply_cltn2_line l A)\n  \\<longleftrightarrow> proj2_incident p l\"", "lemma apply_cltn2_preserve_set_Col:\n  assumes \"proj2_set_Col S\"\n  shows \"proj2_set_Col {apply_cltn2 p C | p. p \\<in> S}\"", "lemma apply_cltn2_injective:\n  assumes \"apply_cltn2 p C = apply_cltn2 q C\"\n  shows \"p = q\"", "lemma apply_cltn2_line_injective:\n  assumes \"apply_cltn2_line l C = apply_cltn2_line m C\"\n  shows \"l = m\"", "lemma apply_cltn2_line_unique:\n  assumes \"p \\<noteq> q\" and \"proj2_incident p l\" and \"proj2_incident q l\"\n  and \"proj2_incident (apply_cltn2 p C) m\"\n  and \"proj2_incident (apply_cltn2 q C) m\"\n  shows \"apply_cltn2_line l C = m\"", "lemma apply_cltn2_unique:\n  assumes \"l \\<noteq> m\" and \"proj2_incident p l\" and \"proj2_incident p m\"\n  and \"proj2_incident q (apply_cltn2_line l C)\"\n  and \"proj2_incident q (apply_cltn2_line m C)\"\n  shows \"apply_cltn2 p C = q\"", "lemma statement52_existence:\n  fixes a :: \"proj2^3\" and a3 :: \"proj2\"\n  assumes \"proj2_no_3_Col (insert a3 (range (($) a)))\"\n  shows \"\\<exists> A. apply_cltn2 (proj2_abs (vector [1,1,1])) A = a3 \\<and>\n  (\\<forall> j. apply_cltn2 (proj2_abs (axis j 1)) A = a$j)\"", "lemma statement53_existence:\n  fixes p :: \"proj2^4^2\"\n  assumes \"\\<forall> i. proj2_no_3_Col (range (($) (p$i)))\"\n  shows \"\\<exists> C. \\<forall> j. apply_cltn2 (p$0$j) C = p$1$j\"", "lemma apply_cltn2_linear:\n  assumes \"j *\\<^sub>R v + k *\\<^sub>R w \\<noteq> 0\"\n  shows \"j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) \\<noteq> 0\"\n  (is \"?u \\<noteq> 0\")\n  and \"apply_cltn2 (proj2_abs (j *\\<^sub>R v + k *\\<^sub>R w)) C\n  = proj2_abs (j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C))\"", "lemma apply_cltn2_imp_mult:\n  assumes \"apply_cltn2 p C = q\"\n  shows \"\\<exists> k. k \\<noteq> 0 \\<and> proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q\"", "lemma statement55:\n  assumes \"p \\<noteq> q\"\n  and \"apply_cltn2 p C = q\"\n  and \"apply_cltn2 q C = p\"\n  and \"proj2_incident p l\"\n  and \"proj2_incident q l\"\n  and \"proj2_incident r l\"\n  shows \"apply_cltn2 (apply_cltn2 r C) C = r\"", "lemma proj2_Col_coeff_abs:\n  assumes \"p \\<noteq> q\" and \"j \\<noteq> 0\"\n  shows \"proj2_Col_coeff p q (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q))\n  = i/j\"\n  (is \"proj2_Col_coeff p q ?r = i/j\")", "lemma proj2_set_Col_coeff:\n  assumes \"proj2_set_Col S\" and \"{p,q,r} \\<subseteq> S\" and \"p \\<noteq> q\" and \"r \\<noteq> p\"\n  shows \"r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\"\n  (is \"r = proj2_abs (?i *\\<^sub>R ?u + ?v)\")", "lemma cross_ratio_abs:\n  fixes u v :: \"real^3\" and i j k l :: real\n  assumes \"u \\<noteq> 0\" and \"v \\<noteq> 0\" and \"proj2_abs u \\<noteq> proj2_abs v\"\n  and \"j \\<noteq> 0\" and \"l \\<noteq> 0\"\n  shows \"cross_ratio (proj2_abs u) (proj2_abs v)\n  (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v))\n  (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v))\n  = j * k / (i * l)\"\n  (is \"cross_ratio ?p ?q ?r ?s = _\")", "lemma cross_ratio_abs2:\n  assumes \"p \\<noteq> q\"\n  shows \"cross_ratio p q\n  (proj2_abs (i *\\<^sub>R proj2_rep p + proj2_rep q))\n  (proj2_abs (j *\\<^sub>R proj2_rep p + proj2_rep q))\n  = j/i\"\n  (is \"cross_ratio p q ?r ?s = _\")", "lemma cross_ratio_correct_cltn2:\n  assumes \"cross_ratio_correct p q r s\"\n  shows \"cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n  (apply_cltn2 r C) (apply_cltn2 s C)\"\n  (is \"cross_ratio_correct ?pC ?qC ?rC ?sC\")", "lemma cross_ratio_cltn2:\n  assumes \"proj2_set_Col {p,q,r,s}\" and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"s \\<noteq> p\"\n  shows \"cross_ratio (apply_cltn2 p C) (apply_cltn2 q C)\n  (apply_cltn2 r C) (apply_cltn2 s C)\n  = cross_ratio p q r s\"\n  (is \"cross_ratio ?pC ?qC ?rC ?sC = _\")", "lemma cross_ratio_unique:\n  assumes \"cross_ratio_correct p q r s\" and \"cross_ratio_correct p q r t\"\n  and \"cross_ratio p q r s = cross_ratio p q r t\"\n  shows \"s = t\"", "lemma cltn2_three_point_line:\n  assumes \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"r \\<noteq> q\"\n  and \"proj2_incident p l\" and \"proj2_incident q l\" and \"proj2_incident r l\"\n  and \"apply_cltn2 p C = p\" and \"apply_cltn2 q C = q\" and \"apply_cltn2 r C = r\"\n  and \"proj2_incident s l\"\n  shows \"apply_cltn2 s C = s\" (is \"?sC = s\")", "lemma cross_ratio_equal_cltn2:\n  assumes \"cross_ratio_correct p q r s\"\n  and \"cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n  (apply_cltn2 r C) t\"\n  (is \"cross_ratio_correct ?pC ?qC ?rC t\")\n  and \"cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C) t\n    = cross_ratio p q r s\"\n  shows \"t = apply_cltn2 s C\" (is \"t = ?sC\")", "lemma proj2_Col_distinct_coeff_non_zero:\n  assumes \"proj2_Col p q r\" and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"r \\<noteq> q\"\n  shows \"proj2_Col_coeff p q r \\<noteq> 0\"", "lemma cross_ratio_product:\n  assumes \"proj2_Col p q s\" and \"p \\<noteq> q\" and \"s \\<noteq> p\" and \"s \\<noteq> q\"\n  shows \"cross_ratio p q r s * cross_ratio p q s t = cross_ratio p q r t\"", "lemma cross_ratio_equal_1:\n  assumes \"proj2_Col p q r\" and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"r \\<noteq> q\"\n  shows \"cross_ratio p q r r = 1\"", "lemma cross_ratio_1_equal:\n  assumes \"cross_ratio_correct p q r s\" and \"cross_ratio p q r s = 1\"\n  shows \"r = s\"", "lemma cross_ratio_swap_34:\n  shows \"cross_ratio p q s r = 1 / (cross_ratio p q r s)\"", "lemma cross_ratio_swap_13_24:\n  assumes \"cross_ratio_correct p q r s\" and \"r \\<noteq> s\"\n  shows \"cross_ratio r s p q = cross_ratio p q r s\"", "lemma cross_ratio_swap_12:\n  assumes \"cross_ratio_correct p q r s\" and \"cross_ratio_correct q p r s\"\n  shows \"cross_ratio q p r s = 1 / (cross_ratio p q r s)\"", "lemma vector2_append1_non_zero: \"vector2_append1 v \\<noteq> 0\"", "lemma proj2_pt_scalar:\n  \"\\<exists> c. c \\<noteq> 0 \\<and> proj2_rep (proj2_pt v) = c *\\<^sub>R vector2_append1 v\"", "lemma cart2_append1_z:\n  assumes \"z_non_zero p\"\n  shows \"(cart2_append1 p)$3 = 1\"", "lemma cart2_append1_non_zero:\n  assumes \"z_non_zero p\"\n  shows \"cart2_append1 p \\<noteq> 0\"", "lemma proj2_rep_cart2_append1:\n  assumes \"z_non_zero p\"\n  shows \"proj2_rep p = ((proj2_rep p)$3) *\\<^sub>R cart2_append1 p\"", "lemma proj2_abs_cart2_append1:\n  assumes \"z_non_zero p\"\n  shows \"proj2_abs (cart2_append1 p) = p\"", "lemma cart2_append1_inj:\n  assumes \"z_non_zero p\" and \"cart2_append1 p = cart2_append1 q\"\n  shows \"p = q\"", "lemma cart2_append1:\n  assumes \"z_non_zero p\"\n  shows \"vector2_append1 (cart2_pt p) = cart2_append1 p\"", "lemma cart2_proj2: \"cart2_pt (proj2_pt v) = v\"", "lemma z_non_zero_proj2_pt: \"z_non_zero (proj2_pt v)\"", "lemma cart2_append1_proj2: \"cart2_append1 (proj2_pt v) = vector2_append1 v\"", "lemma proj2_pt_inj: \"inj proj2_pt\"", "lemma proj2_cart2:\n  assumes \"z_non_zero p\"\n  shows \"proj2_pt (cart2_pt p) = p\"", "lemma cart2_injective:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"cart2_pt p = cart2_pt q\"\n  shows \"p = q\"", "lemma proj2_Col_iff_euclid:\n  \"proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<longleftrightarrow> real_euclid.Col a b c\"\n  (is \"proj2_Col ?p ?q ?r \\<longleftrightarrow> _\")", "lemma proj2_Col_iff_euclid_cart2:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\"\n  shows\n  \"proj2_Col p q r \\<longleftrightarrow> real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)\"\n  (is \"_ \\<longleftrightarrow> real_euclid.Col ?a ?b ?c\")", "lemma euclid_Col_cart2_incident:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\" and \"p \\<noteq> q\"\n  and \"proj2_incident p l\" and \"proj2_incident q l\"\n  and \"real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)\"\n  (is \"real_euclid.Col ?cp ?cq ?cr\")\n  shows \"proj2_incident r l\"", "lemma euclid_B_cart2_common_line:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\"\n  and \"B\\<^sub>\\<real> (cart2_pt p) (cart2_pt q) (cart2_pt r)\"\n  (is \"B\\<^sub>\\<real> ?cp ?cq ?cr\")\n  shows \"\\<exists> l. proj2_incident p l \\<and> proj2_incident q l \\<and> proj2_incident r l\"", "lemma cart2_append1_between:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\"\n  shows \"B\\<^sub>\\<real> (cart2_pt p) (cart2_pt q) (cart2_pt r)\n  \\<longleftrightarrow> (\\<exists> k\\<ge>0. k \\<le> 1\n  \\<and> cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)\"", "lemma cart2_append1_between_right_strict:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\"\n  and \"B\\<^sub>\\<real> (cart2_pt p) (cart2_pt q) (cart2_pt r)\" and \"q \\<noteq> r\"\n  shows \"\\<exists> k\\<ge>0. k < 1\n  \\<and> cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\"", "lemma cart2_append1_between_strict:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\"\n  and \"B\\<^sub>\\<real> (cart2_pt p) (cart2_pt q) (cart2_pt r)\" and \"q \\<noteq> p\" and \"q \\<noteq> r\"\n  shows \"\\<exists> k>0. k < 1\n  \\<and> cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\""], "translations": [["", "lemma proportionality_refl_on: \"refl_on local.non_zero_vectors local.proportionality\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on local.non_zero_vectors local.proportionality", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. refl_on local.non_zero_vectors local.proportionality", "have \"local.proportionality \\<subseteq> local.non_zero_vectors \\<times> local.non_zero_vectors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.proportionality\n    \\<subseteq> local.non_zero_vectors \\<times> local.non_zero_vectors", "unfolding proportionality_def non_zero_vectors_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     x \\<noteq> (0::'b) \\<and>\n     y \\<noteq> (0::'b) \\<and> (\\<exists>k. x = k *s y)}\n    \\<subseteq> {x. x \\<noteq> (0::'b)} \\<times> {x. x \\<noteq> (0::'b)}", "by auto"], ["proof (state)\nthis:\n  local.proportionality\n  \\<subseteq> local.non_zero_vectors \\<times> local.non_zero_vectors\n\ngoal (1 subgoal):\n 1. refl_on local.non_zero_vectors local.proportionality", "moreover"], ["proof (state)\nthis:\n  local.proportionality\n  \\<subseteq> local.non_zero_vectors \\<times> local.non_zero_vectors\n\ngoal (1 subgoal):\n 1. refl_on local.non_zero_vectors local.proportionality", "have \"\\<forall>x\\<in>local.non_zero_vectors. (x, x) \\<in> local.proportionality\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>local.non_zero_vectors.\n       (x, x) \\<in> local.proportionality", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.non_zero_vectors \\<Longrightarrow>\n       (x, x) \\<in> local.proportionality", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.non_zero_vectors \\<Longrightarrow>\n       (x, x) \\<in> local.proportionality", "assume \"x \\<in> local.non_zero_vectors\""], ["proof (state)\nthis:\n  x \\<in> local.non_zero_vectors\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.non_zero_vectors \\<Longrightarrow>\n       (x, x) \\<in> local.proportionality", "hence \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> local.non_zero_vectors\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'b)", "unfolding non_zero_vectors_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'b)", ".."], ["proof (state)\nthis:\n  x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.non_zero_vectors \\<Longrightarrow>\n       (x, x) \\<in> local.proportionality", "moreover"], ["proof (state)\nthis:\n  x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.non_zero_vectors \\<Longrightarrow>\n       (x, x) \\<in> local.proportionality", "have \"x = scale 1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (1::'a) *s x", "by simp"], ["proof (state)\nthis:\n  x = (1::'a) *s x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.non_zero_vectors \\<Longrightarrow>\n       (x, x) \\<in> local.proportionality", "ultimately"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'b)\n  x = (1::'a) *s x", "show \"(x, x) \\<in> local.proportionality\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'b)\n  x = (1::'a) *s x\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> local.proportionality", "unfolding proportionality_def"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'b)\n  x = (1::'a) *s x\n\ngoal (1 subgoal):\n 1. (x, x)\n    \\<in> {(x, y).\n           x \\<noteq> (0::'b) \\<and>\n           y \\<noteq> (0::'b) \\<and> (\\<exists>k. x = k *s y)}", "by blast"], ["proof (state)\nthis:\n  (x, x) \\<in> local.proportionality\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>local.non_zero_vectors. (x, x) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. refl_on local.non_zero_vectors local.proportionality", "ultimately"], ["proof (chain)\npicking this:\n  local.proportionality\n  \\<subseteq> local.non_zero_vectors \\<times> local.non_zero_vectors\n  \\<forall>x\\<in>local.non_zero_vectors. (x, x) \\<in> local.proportionality", "show \"refl_on local.non_zero_vectors local.proportionality\""], ["proof (prove)\nusing this:\n  local.proportionality\n  \\<subseteq> local.non_zero_vectors \\<times> local.non_zero_vectors\n  \\<forall>x\\<in>local.non_zero_vectors. (x, x) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. refl_on local.non_zero_vectors local.proportionality", "unfolding refl_on_def"], ["proof (prove)\nusing this:\n  local.proportionality\n  \\<subseteq> local.non_zero_vectors \\<times> local.non_zero_vectors\n  \\<forall>x\\<in>local.non_zero_vectors. (x, x) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. local.proportionality\n    \\<subseteq> local.non_zero_vectors \\<times>\n                local.non_zero_vectors \\<and>\n    (\\<forall>x\\<in>local.non_zero_vectors.\n        (x, x) \\<in> local.proportionality)", ".."], ["proof (state)\nthis:\n  refl_on local.non_zero_vectors local.proportionality\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proportionality_sym: \"sym local.proportionality\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym local.proportionality", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sym local.proportionality", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. sym local.proportionality", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. sym local.proportionality", "assume \"(x, y) \\<in> local.proportionality\""], ["proof (state)\nthis:\n  (x, y) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. sym local.proportionality", "hence \"x \\<noteq> 0\" and \"y \\<noteq> 0\" and \"\\<exists>k. x = scale k y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'b) &&& y \\<noteq> (0::'b) &&& \\<exists>k. x = k *s y", "unfolding proportionality_def"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {(x, y).\n         x \\<noteq> (0::'b) \\<and>\n         y \\<noteq> (0::'b) \\<and> (\\<exists>k. x = k *s y)}\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'b) &&& y \\<noteq> (0::'b) &&& \\<exists>k. x = k *s y", "by simp+"], ["proof (state)\nthis:\n  x \\<noteq> (0::'b)\n  y \\<noteq> (0::'b)\n  \\<exists>k. x = k *s y\n\ngoal (1 subgoal):\n 1. sym local.proportionality", "from \\<open>\\<exists>k. x = scale k y\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>k. x = k *s y", "obtain k where \"x = scale k y\""], ["proof (prove)\nusing this:\n  \\<exists>k. x = k *s y\n\ngoal (1 subgoal):\n 1. (\\<And>k. x = k *s y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x = k *s y\n\ngoal (1 subgoal):\n 1. sym local.proportionality", "with \\<open>x \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'b)\n  x = k *s y", "have \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'b)\n  x = k *s y\n\ngoal (1 subgoal):\n 1. k \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. sym local.proportionality", "with \\<open>x = scale k y\\<close>"], ["proof (chain)\npicking this:\n  x = k *s y\n  k \\<noteq> (0::'a)", "have \"y = scale (1/k) x\""], ["proof (prove)\nusing this:\n  x = k *s y\n  k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. y = ((1::'a) / k) *s x", "by simp"], ["proof (state)\nthis:\n  y = ((1::'a) / k) *s x\n\ngoal (1 subgoal):\n 1. sym local.proportionality", "with \\<open>x \\<noteq> 0\\<close> and \\<open>y \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'b)\n  y \\<noteq> (0::'b)\n  y = ((1::'a) / k) *s x", "have \"(y, x) \\<in> local.proportionality\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'b)\n  y \\<noteq> (0::'b)\n  y = ((1::'a) / k) *s x\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> local.proportionality", "unfolding proportionality_def"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'b)\n  y \\<noteq> (0::'b)\n  y = ((1::'a) / k) *s x\n\ngoal (1 subgoal):\n 1. (y, x)\n    \\<in> {(x, y).\n           x \\<noteq> (0::'b) \\<and>\n           y \\<noteq> (0::'b) \\<and> (\\<exists>k. x = k *s y)}", "by auto"], ["proof (state)\nthis:\n  (y, x) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. sym local.proportionality", "}"], ["proof (state)\nthis:\n  (?x2, ?y2) \\<in> local.proportionality \\<Longrightarrow>\n  (?y2, ?x2) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. sym local.proportionality", "thus \"sym local.proportionality\""], ["proof (prove)\nusing this:\n  (?x2, ?y2) \\<in> local.proportionality \\<Longrightarrow>\n  (?y2, ?x2) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. sym local.proportionality", "unfolding sym_def"], ["proof (prove)\nusing this:\n  (?x2, ?y2) \\<in> local.proportionality \\<Longrightarrow>\n  (?y2, ?x2) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y) \\<in> local.proportionality \\<longrightarrow>\n       (y, x) \\<in> local.proportionality", "by blast"], ["proof (state)\nthis:\n  sym local.proportionality\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proportionality_trans: \"trans local.proportionality\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans local.proportionality", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trans local.proportionality", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. trans local.proportionality", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. trans local.proportionality", "assume \"(x, y) \\<in> local.proportionality\" and \"(y, z) \\<in> local.proportionality\""], ["proof (state)\nthis:\n  (x, y) \\<in> local.proportionality\n  (y, z) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. trans local.proportionality", "hence \"x \\<noteq> 0\" and \"z \\<noteq> 0\" and \"\\<exists>j. x = scale j y\" and \"\\<exists>k. y = scale k z\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> local.proportionality\n  (y, z) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. (x \\<noteq> (0::'b) &&& z \\<noteq> (0::'b)) &&&\n    \\<exists>j. x = j *s y &&& \\<exists>k. y = k *s z", "unfolding proportionality_def"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {(x, y).\n         x \\<noteq> (0::'b) \\<and>\n         y \\<noteq> (0::'b) \\<and> (\\<exists>k. x = k *s y)}\n  (y, z)\n  \\<in> {(x, y).\n         x \\<noteq> (0::'b) \\<and>\n         y \\<noteq> (0::'b) \\<and> (\\<exists>k. x = k *s y)}\n\ngoal (1 subgoal):\n 1. (x \\<noteq> (0::'b) &&& z \\<noteq> (0::'b)) &&&\n    \\<exists>j. x = j *s y &&& \\<exists>k. y = k *s z", "by simp+"], ["proof (state)\nthis:\n  x \\<noteq> (0::'b)\n  z \\<noteq> (0::'b)\n  \\<exists>j. x = j *s y\n  \\<exists>k. y = k *s z\n\ngoal (1 subgoal):\n 1. trans local.proportionality", "from \\<open>\\<exists>j. x = scale j y\\<close> and \\<open>\\<exists>k. y = scale k z\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>j. x = j *s y\n  \\<exists>k. y = k *s z", "obtain j and k where \"x = scale j y\" and \"y = scale k z\""], ["proof (prove)\nusing this:\n  \\<exists>j. x = j *s y\n  \\<exists>k. y = k *s z\n\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        \\<lbrakk>x = j *s y; y = k *s z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto+"], ["proof (state)\nthis:\n  x = j *s y\n  y = k *s z\n\ngoal (1 subgoal):\n 1. trans local.proportionality", "hence \"x = scale (j * k) z\""], ["proof (prove)\nusing this:\n  x = j *s y\n  y = k *s z\n\ngoal (1 subgoal):\n 1. x = (j * k) *s z", "by simp"], ["proof (state)\nthis:\n  x = (j * k) *s z\n\ngoal (1 subgoal):\n 1. trans local.proportionality", "with \\<open>x \\<noteq> 0\\<close> and \\<open>z \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'b)\n  z \\<noteq> (0::'b)\n  x = (j * k) *s z", "have \"(x, z) \\<in> local.proportionality\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'b)\n  z \\<noteq> (0::'b)\n  x = (j * k) *s z\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> local.proportionality", "unfolding proportionality_def"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'b)\n  z \\<noteq> (0::'b)\n  x = (j * k) *s z\n\ngoal (1 subgoal):\n 1. (x, z)\n    \\<in> {(x, y).\n           x \\<noteq> (0::'b) \\<and>\n           y \\<noteq> (0::'b) \\<and> (\\<exists>k. x = k *s y)}", "by auto"], ["proof (state)\nthis:\n  (x, z) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. trans local.proportionality", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?x2, ?y2) \\<in> local.proportionality;\n   (?y2, ?z2) \\<in> local.proportionality\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. trans local.proportionality", "thus \"trans local.proportionality\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x2, ?y2) \\<in> local.proportionality;\n   (?y2, ?z2) \\<in> local.proportionality\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. trans local.proportionality", "unfolding trans_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x2, ?y2) \\<in> local.proportionality;\n   (?y2, ?z2) \\<in> local.proportionality\\<rbrakk>\n  \\<Longrightarrow> (?x2, ?z2) \\<in> local.proportionality\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> local.proportionality \\<longrightarrow>\n       (y, z) \\<in> local.proportionality \\<longrightarrow>\n       (x, z) \\<in> local.proportionality", "by blast"], ["proof (state)\nthis:\n  trans local.proportionality\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem proportionality_equiv: \"equiv local.non_zero_vectors local.proportionality\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv local.non_zero_vectors local.proportionality", "unfolding equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on local.non_zero_vectors local.proportionality \\<and>\n    sym local.proportionality \\<and> trans local.proportionality", "by (simp add:\n      proportionality_refl_on\n      proportionality_sym\n      proportionality_trans)"], ["", "end"], ["", "definition invertible_proportionality ::\n  \"((real^('n::finite)^'n) \\<times> (real^'n^'n)) set\" where\n  \"invertible_proportionality \\<equiv>\n  real_vector.proportionality \\<inter> (Collect invertible \\<times> Collect invertible)\""], ["", "lemma invertible_proportionality_equiv:\n  \"equiv (Collect invertible :: (real^('n::finite)^'n) set)\n  invertible_proportionality\"\n  (is \"equiv ?invs _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv (Collect invertible) invertible_proportionality", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equiv (Collect invertible) invertible_proportionality", "from zero_not_invertible"], ["proof (chain)\npicking this:\n  \\<not> invertible 0", "have \"real_vector.non_zero_vectors \\<inter> ?invs = ?invs\""], ["proof (prove)\nusing this:\n  \\<not> invertible 0\n\ngoal (1 subgoal):\n 1. non_zero_vectors \\<inter> Collect invertible = Collect invertible", "unfolding real_vector.non_zero_vectors_def"], ["proof (prove)\nusing this:\n  \\<not> invertible 0\n\ngoal (1 subgoal):\n 1. {x. x \\<noteq> 0} \\<inter> Collect invertible = Collect invertible", "by auto"], ["proof (state)\nthis:\n  non_zero_vectors \\<inter> Collect invertible = Collect invertible\n\ngoal (1 subgoal):\n 1. equiv (Collect invertible) invertible_proportionality", "from equiv_restrict and real_vector.proportionality_equiv"], ["proof (chain)\npicking this:\n  equiv ?A ?r \\<Longrightarrow> equiv (?A \\<inter> ?B) (Restr ?r ?B)\n  equiv non_zero_vectors proportionality", "have \"equiv (real_vector.non_zero_vectors \\<inter> ?invs) invertible_proportionality\""], ["proof (prove)\nusing this:\n  equiv ?A ?r \\<Longrightarrow> equiv (?A \\<inter> ?B) (Restr ?r ?B)\n  equiv non_zero_vectors proportionality\n\ngoal (1 subgoal):\n 1. equiv (non_zero_vectors \\<inter> Collect invertible)\n     invertible_proportionality", "unfolding invertible_proportionality_def"], ["proof (prove)\nusing this:\n  equiv ?A ?r \\<Longrightarrow> equiv (?A \\<inter> ?B) (Restr ?r ?B)\n  equiv non_zero_vectors proportionality\n\ngoal (1 subgoal):\n 1. equiv (non_zero_vectors \\<inter> Collect invertible)\n     (Restr proportionality (Collect invertible))", "by auto"], ["proof (state)\nthis:\n  equiv (non_zero_vectors \\<inter> Collect invertible)\n   invertible_proportionality\n\ngoal (1 subgoal):\n 1. equiv (Collect invertible) invertible_proportionality", "with \\<open>real_vector.non_zero_vectors \\<inter> ?invs = ?invs\\<close>"], ["proof (chain)\npicking this:\n  non_zero_vectors \\<inter> Collect invertible = Collect invertible\n  equiv (non_zero_vectors \\<inter> Collect invertible)\n   invertible_proportionality", "show \"equiv ?invs invertible_proportionality\""], ["proof (prove)\nusing this:\n  non_zero_vectors \\<inter> Collect invertible = Collect invertible\n  equiv (non_zero_vectors \\<inter> Collect invertible)\n   invertible_proportionality\n\ngoal (1 subgoal):\n 1. equiv (Collect invertible) invertible_proportionality", "by simp"], ["proof (state)\nthis:\n  equiv (Collect invertible) invertible_proportionality\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Points of the real projective plane\""], ["", "typedef proj2 = \"(real_vector.non_zero_vectors :: (real^3) set)//real_vector.proportionality\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> non_zero_vectors // proportionality", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> non_zero_vectors // proportionality", "have \"(axis 1 1 :: real^3) \\<in> real_vector.non_zero_vectors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. axis 1 1 \\<in> non_zero_vectors", "unfolding real_vector.non_zero_vectors_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. axis 1 1 \\<in> {x. x \\<noteq> 0}", "by (simp add: axis_def vec_eq_iff[where 'a=\"real\"])"], ["proof (state)\nthis:\n  axis 1 1 \\<in> non_zero_vectors\n\ngoal (1 subgoal):\n 1. ?x \\<in> non_zero_vectors // proportionality", "thus \"real_vector.proportionality `` {axis 1 1} \\<in> (real_vector.non_zero_vectors :: (real^3) set)//real_vector.proportionality\""], ["proof (prove)\nusing this:\n  axis 1 1 \\<in> non_zero_vectors\n\ngoal (1 subgoal):\n 1. proportionality `` {axis 1 1} \\<in> non_zero_vectors // proportionality", "unfolding quotient_def"], ["proof (prove)\nusing this:\n  axis 1 1 \\<in> non_zero_vectors\n\ngoal (1 subgoal):\n 1. proportionality `` {axis 1 1}\n    \\<in> (\\<Union>x\\<in>non_zero_vectors. {proportionality `` {x}})", "by auto"], ["proof (state)\nthis:\n  proportionality `` {axis 1 1} \\<in> non_zero_vectors // proportionality\n\ngoal:\nNo subgoals!", "qed"], ["", "definition proj2_rep :: \"proj2 \\<Rightarrow> real^3\" where\n  \"proj2_rep x \\<equiv> \\<some> v. v \\<in> Rep_proj2 x\""], ["", "definition proj2_abs :: \"real^3 \\<Rightarrow> proj2\" where\n  \"proj2_abs v \\<equiv> Abs_proj2 (real_vector.proportionality `` {v})\""], ["", "lemma proj2_rep_in: \"proj2_rep x \\<in> Rep_proj2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep x \\<in> Rep_proj2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_rep x \\<in> Rep_proj2 x", "let ?v = \"proj2_rep x\""], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_rep x \\<in> Rep_proj2 x", "from quotient_element_nonempty and\n    real_vector.proportionality_equiv and\n    Rep_proj2 [of x]"], ["proof (chain)\npicking this:\n  \\<lbrakk>equiv ?A ?r; ?X \\<in> ?A // ?r\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> ?X\n  equiv non_zero_vectors proportionality\n  Rep_proj2 x \\<in> non_zero_vectors // proportionality", "have \"\\<exists> w. w \\<in> Rep_proj2 x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>equiv ?A ?r; ?X \\<in> ?A // ?r\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> ?X\n  equiv non_zero_vectors proportionality\n  Rep_proj2 x \\<in> non_zero_vectors // proportionality\n\ngoal (1 subgoal):\n 1. \\<exists>w. w \\<in> Rep_proj2 x", "by auto"], ["proof (state)\nthis:\n  \\<exists>w. w \\<in> Rep_proj2 x\n\ngoal (1 subgoal):\n 1. proj2_rep x \\<in> Rep_proj2 x", "with someI_ex [of \"\\<lambda> z. z \\<in> Rep_proj2 x\"]"], ["proof (chain)\npicking this:\n  \\<exists>xa. xa \\<in> Rep_proj2 x \\<Longrightarrow>\n  (SOME xa. xa \\<in> Rep_proj2 x) \\<in> Rep_proj2 x\n  \\<exists>w. w \\<in> Rep_proj2 x", "show \"?v \\<in> Rep_proj2 x\""], ["proof (prove)\nusing this:\n  \\<exists>xa. xa \\<in> Rep_proj2 x \\<Longrightarrow>\n  (SOME xa. xa \\<in> Rep_proj2 x) \\<in> Rep_proj2 x\n  \\<exists>w. w \\<in> Rep_proj2 x\n\ngoal (1 subgoal):\n 1. proj2_rep x \\<in> Rep_proj2 x", "unfolding proj2_rep_def"], ["proof (prove)\nusing this:\n  \\<exists>xa. xa \\<in> Rep_proj2 x \\<Longrightarrow>\n  (SOME xa. xa \\<in> Rep_proj2 x) \\<in> Rep_proj2 x\n  \\<exists>w. w \\<in> Rep_proj2 x\n\ngoal (1 subgoal):\n 1. (SOME v. v \\<in> Rep_proj2 x) \\<in> Rep_proj2 x", "by simp"], ["proof (state)\nthis:\n  proj2_rep x \\<in> Rep_proj2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_rep_non_zero: \"proj2_rep x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep x \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_rep x \\<noteq> 0", "from\n    Union_quotient [of real_vector.non_zero_vectors real_vector.proportionality]\n    and real_vector.proportionality_equiv\n    and Rep_proj2 [of x] and proj2_rep_in [of x]"], ["proof (chain)\npicking this:\n  equiv non_zero_vectors proportionality \\<Longrightarrow>\n  \\<Union> (non_zero_vectors // proportionality) = non_zero_vectors\n  equiv non_zero_vectors proportionality\n  Rep_proj2 x \\<in> non_zero_vectors // proportionality\n  proj2_rep x \\<in> Rep_proj2 x", "have \"proj2_rep x \\<in> real_vector.non_zero_vectors\""], ["proof (prove)\nusing this:\n  equiv non_zero_vectors proportionality \\<Longrightarrow>\n  \\<Union> (non_zero_vectors // proportionality) = non_zero_vectors\n  equiv non_zero_vectors proportionality\n  Rep_proj2 x \\<in> non_zero_vectors // proportionality\n  proj2_rep x \\<in> Rep_proj2 x\n\ngoal (1 subgoal):\n 1. proj2_rep x \\<in> non_zero_vectors", "unfolding quotient_def"], ["proof (prove)\nusing this:\n  equiv non_zero_vectors proportionality \\<Longrightarrow>\n  \\<Union> (\\<Union>x\\<in>non_zero_vectors. {proportionality `` {x}}) =\n  non_zero_vectors\n  equiv non_zero_vectors proportionality\n  Rep_proj2 x\n  \\<in> (\\<Union>x\\<in>non_zero_vectors. {proportionality `` {x}})\n  proj2_rep x \\<in> Rep_proj2 x\n\ngoal (1 subgoal):\n 1. proj2_rep x \\<in> non_zero_vectors", "by auto"], ["proof (state)\nthis:\n  proj2_rep x \\<in> non_zero_vectors\n\ngoal (1 subgoal):\n 1. proj2_rep x \\<noteq> 0", "thus \"proj2_rep x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  proj2_rep x \\<in> non_zero_vectors\n\ngoal (1 subgoal):\n 1. proj2_rep x \\<noteq> 0", "unfolding real_vector.non_zero_vectors_def"], ["proof (prove)\nusing this:\n  proj2_rep x \\<in> {x. x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. proj2_rep x \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  proj2_rep x \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_rep_abs:\n  fixes v :: \"real^3\"\n  assumes \"v \\<in> real_vector.non_zero_vectors\"\n  shows \"(v, proj2_rep (proj2_abs v)) \\<in> real_vector.proportionality\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, proj2_rep (proj2_abs v)) \\<in> proportionality", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, proj2_rep (proj2_abs v)) \\<in> proportionality", "from \\<open>v \\<in> real_vector.non_zero_vectors\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> non_zero_vectors", "have \"real_vector.proportionality `` {v} \\<in> (real_vector.non_zero_vectors :: (real^3) set)//real_vector.proportionality\""], ["proof (prove)\nusing this:\n  v \\<in> non_zero_vectors\n\ngoal (1 subgoal):\n 1. proportionality `` {v} \\<in> non_zero_vectors // proportionality", "unfolding quotient_def"], ["proof (prove)\nusing this:\n  v \\<in> non_zero_vectors\n\ngoal (1 subgoal):\n 1. proportionality `` {v}\n    \\<in> (\\<Union>x\\<in>non_zero_vectors. {proportionality `` {x}})", "by auto"], ["proof (state)\nthis:\n  proportionality `` {v} \\<in> non_zero_vectors // proportionality\n\ngoal (1 subgoal):\n 1. (v, proj2_rep (proj2_abs v)) \\<in> proportionality", "with Abs_proj2_inverse"], ["proof (chain)\npicking this:\n  ?y \\<in> non_zero_vectors // proportionality \\<Longrightarrow>\n  Rep_proj2 (Abs_proj2 ?y) = ?y\n  proportionality `` {v} \\<in> non_zero_vectors // proportionality", "have \"Rep_proj2 (proj2_abs v) = real_vector.proportionality `` {v}\""], ["proof (prove)\nusing this:\n  ?y \\<in> non_zero_vectors // proportionality \\<Longrightarrow>\n  Rep_proj2 (Abs_proj2 ?y) = ?y\n  proportionality `` {v} \\<in> non_zero_vectors // proportionality\n\ngoal (1 subgoal):\n 1. Rep_proj2 (proj2_abs v) = proportionality `` {v}", "unfolding proj2_abs_def"], ["proof (prove)\nusing this:\n  ?y \\<in> non_zero_vectors // proportionality \\<Longrightarrow>\n  Rep_proj2 (Abs_proj2 ?y) = ?y\n  proportionality `` {v} \\<in> non_zero_vectors // proportionality\n\ngoal (1 subgoal):\n 1. Rep_proj2 (Abs_proj2 (proportionality `` {v})) = proportionality `` {v}", "by simp"], ["proof (state)\nthis:\n  Rep_proj2 (proj2_abs v) = proportionality `` {v}\n\ngoal (1 subgoal):\n 1. (v, proj2_rep (proj2_abs v)) \\<in> proportionality", "with proj2_rep_in"], ["proof (chain)\npicking this:\n  proj2_rep ?x \\<in> Rep_proj2 ?x\n  Rep_proj2 (proj2_abs v) = proportionality `` {v}", "have \"proj2_rep (proj2_abs v) \\<in> real_vector.proportionality `` {v}\""], ["proof (prove)\nusing this:\n  proj2_rep ?x \\<in> Rep_proj2 ?x\n  Rep_proj2 (proj2_abs v) = proportionality `` {v}\n\ngoal (1 subgoal):\n 1. proj2_rep (proj2_abs v) \\<in> proportionality `` {v}", "by auto"], ["proof (state)\nthis:\n  proj2_rep (proj2_abs v) \\<in> proportionality `` {v}\n\ngoal (1 subgoal):\n 1. (v, proj2_rep (proj2_abs v)) \\<in> proportionality", "thus \"(v, proj2_rep (proj2_abs v)) \\<in> real_vector.proportionality\""], ["proof (prove)\nusing this:\n  proj2_rep (proj2_abs v) \\<in> proportionality `` {v}\n\ngoal (1 subgoal):\n 1. (v, proj2_rep (proj2_abs v)) \\<in> proportionality", "by simp"], ["proof (state)\nthis:\n  (v, proj2_rep (proj2_abs v)) \\<in> proportionality\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_abs_rep: \"proj2_abs (proj2_rep x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_abs (proj2_rep x) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_abs (proj2_rep x) = x", "from partition_Image_element\n  [of real_vector.non_zero_vectors\n    real_vector.proportionality\n    \"Rep_proj2 x\"\n    \"proj2_rep x\"]\n    and real_vector.proportionality_equiv\n    and Rep_proj2 [of x] and proj2_rep_in [of x]"], ["proof (chain)\npicking this:\n  \\<lbrakk>equiv non_zero_vectors proportionality;\n   Rep_proj2 x \\<in> non_zero_vectors // proportionality;\n   proj2_rep x \\<in> Rep_proj2 x\\<rbrakk>\n  \\<Longrightarrow> proportionality `` {proj2_rep x} = Rep_proj2 x\n  equiv non_zero_vectors proportionality\n  Rep_proj2 x \\<in> non_zero_vectors // proportionality\n  proj2_rep x \\<in> Rep_proj2 x", "have \"real_vector.proportionality `` {proj2_rep x} = Rep_proj2 x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>equiv non_zero_vectors proportionality;\n   Rep_proj2 x \\<in> non_zero_vectors // proportionality;\n   proj2_rep x \\<in> Rep_proj2 x\\<rbrakk>\n  \\<Longrightarrow> proportionality `` {proj2_rep x} = Rep_proj2 x\n  equiv non_zero_vectors proportionality\n  Rep_proj2 x \\<in> non_zero_vectors // proportionality\n  proj2_rep x \\<in> Rep_proj2 x\n\ngoal (1 subgoal):\n 1. proportionality `` {proj2_rep x} = Rep_proj2 x", "by simp"], ["proof (state)\nthis:\n  proportionality `` {proj2_rep x} = Rep_proj2 x\n\ngoal (1 subgoal):\n 1. proj2_abs (proj2_rep x) = x", "with Rep_proj2_inverse"], ["proof (chain)\npicking this:\n  Abs_proj2 (Rep_proj2 ?x) = ?x\n  proportionality `` {proj2_rep x} = Rep_proj2 x", "show \"proj2_abs (proj2_rep x) = x\""], ["proof (prove)\nusing this:\n  Abs_proj2 (Rep_proj2 ?x) = ?x\n  proportionality `` {proj2_rep x} = Rep_proj2 x\n\ngoal (1 subgoal):\n 1. proj2_abs (proj2_rep x) = x", "unfolding proj2_abs_def"], ["proof (prove)\nusing this:\n  Abs_proj2 (Rep_proj2 ?x) = ?x\n  proportionality `` {proj2_rep x} = Rep_proj2 x\n\ngoal (1 subgoal):\n 1. Abs_proj2 (proportionality `` {proj2_rep x}) = x", "by simp"], ["proof (state)\nthis:\n  proj2_abs (proj2_rep x) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_abs_mult:\n  assumes \"c \\<noteq> 0\"\n  shows \"proj2_abs (c *\\<^sub>R v) = proj2_abs v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_abs (c *\\<^sub>R v) = proj2_abs v", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> proj2_abs (c *\\<^sub>R v) = proj2_abs v\n 2. \\<not> ?P \\<Longrightarrow> proj2_abs (c *\\<^sub>R v) = proj2_abs v", "assume \"v = 0\""], ["proof (state)\nthis:\n  v = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> proj2_abs (c *\\<^sub>R v) = proj2_abs v\n 2. \\<not> ?P \\<Longrightarrow> proj2_abs (c *\\<^sub>R v) = proj2_abs v", "thus \"proj2_abs (c *\\<^sub>R v) = proj2_abs v\""], ["proof (prove)\nusing this:\n  v = 0\n\ngoal (1 subgoal):\n 1. proj2_abs (c *\\<^sub>R v) = proj2_abs v", "by simp"], ["proof (state)\nthis:\n  proj2_abs (c *\\<^sub>R v) = proj2_abs v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> proj2_abs (c *\\<^sub>R v) = proj2_abs v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> proj2_abs (c *\\<^sub>R v) = proj2_abs v", "assume \"v \\<noteq> 0\""], ["proof (state)\nthis:\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> proj2_abs (c *\\<^sub>R v) = proj2_abs v", "with \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> 0\n  v \\<noteq> 0", "have \"(c *\\<^sub>R v, v) \\<in> real_vector.proportionality\"\n    and \"c *\\<^sub>R v \\<in> real_vector.non_zero_vectors\"\n    and \"v \\<in> real_vector.non_zero_vectors\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (c *\\<^sub>R v, v) \\<in> proportionality &&&\n    c *\\<^sub>R v \\<in> non_zero_vectors &&& v \\<in> non_zero_vectors", "unfolding real_vector.proportionality_def\n      and real_vector.non_zero_vectors_def"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (c *\\<^sub>R v, v)\n    \\<in> {(x, y).\n           x \\<noteq> 0 \\<and>\n           y \\<noteq> 0 \\<and> (\\<exists>k. x = k *\\<^sub>R y)} &&&\n    c *\\<^sub>R v \\<in> {x. x \\<noteq> 0} &&& v \\<in> {x. x \\<noteq> 0}", "by simp_all"], ["proof (state)\nthis:\n  (c *\\<^sub>R v, v) \\<in> proportionality\n  c *\\<^sub>R v \\<in> non_zero_vectors\n  v \\<in> non_zero_vectors\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> proj2_abs (c *\\<^sub>R v) = proj2_abs v", "with eq_equiv_class_iff\n  [of real_vector.non_zero_vectors\n    real_vector.proportionality\n    \"c *\\<^sub>R v\"\n    v]\n    and real_vector.proportionality_equiv"], ["proof (chain)\npicking this:\n  \\<lbrakk>equiv non_zero_vectors proportionality;\n   c *\\<^sub>R v \\<in> non_zero_vectors; v \\<in> non_zero_vectors\\<rbrakk>\n  \\<Longrightarrow> (proportionality `` {c *\\<^sub>R v} =\n                     proportionality `` {v}) =\n                    ((c *\\<^sub>R v, v) \\<in> proportionality)\n  equiv non_zero_vectors proportionality\n  (c *\\<^sub>R v, v) \\<in> proportionality\n  c *\\<^sub>R v \\<in> non_zero_vectors\n  v \\<in> non_zero_vectors", "have \"real_vector.proportionality `` {c *\\<^sub>R v} =\n    real_vector.proportionality `` {v}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>equiv non_zero_vectors proportionality;\n   c *\\<^sub>R v \\<in> non_zero_vectors; v \\<in> non_zero_vectors\\<rbrakk>\n  \\<Longrightarrow> (proportionality `` {c *\\<^sub>R v} =\n                     proportionality `` {v}) =\n                    ((c *\\<^sub>R v, v) \\<in> proportionality)\n  equiv non_zero_vectors proportionality\n  (c *\\<^sub>R v, v) \\<in> proportionality\n  c *\\<^sub>R v \\<in> non_zero_vectors\n  v \\<in> non_zero_vectors\n\ngoal (1 subgoal):\n 1. proportionality `` {c *\\<^sub>R v} = proportionality `` {v}", "by simp"], ["proof (state)\nthis:\n  proportionality `` {c *\\<^sub>R v} = proportionality `` {v}\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> proj2_abs (c *\\<^sub>R v) = proj2_abs v", "thus \"proj2_abs (c *\\<^sub>R v) = proj2_abs v\""], ["proof (prove)\nusing this:\n  proportionality `` {c *\\<^sub>R v} = proportionality `` {v}\n\ngoal (1 subgoal):\n 1. proj2_abs (c *\\<^sub>R v) = proj2_abs v", "unfolding proj2_abs_def"], ["proof (prove)\nusing this:\n  proportionality `` {c *\\<^sub>R v} = proportionality `` {v}\n\ngoal (1 subgoal):\n 1. Abs_proj2 (proportionality `` {c *\\<^sub>R v}) =\n    Abs_proj2 (proportionality `` {v})", "by simp"], ["proof (state)\nthis:\n  proj2_abs (c *\\<^sub>R v) = proj2_abs v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_abs_mult_rep:\n  assumes \"c \\<noteq> 0\"\n  shows \"proj2_abs (c *\\<^sub>R proj2_rep x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_abs (c *\\<^sub>R proj2_rep x) = x", "using proj2_abs_mult and proj2_abs_rep and assms"], ["proof (prove)\nusing this:\n  ?c \\<noteq> 0 \\<Longrightarrow> proj2_abs (?c *\\<^sub>R ?v) = proj2_abs ?v\n  proj2_abs (proj2_rep ?x) = ?x\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_abs (c *\\<^sub>R proj2_rep x) = x", "by simp"], ["", "lemma proj2_rep_inj: \"inj proj2_rep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj proj2_rep", "by (simp add: inj_on_inverseI [of UNIV proj2_abs proj2_rep] proj2_abs_rep)"], ["", "lemma proj2_rep_abs2:\n  assumes \"v \\<noteq> 0\"\n  shows \"\\<exists> k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v", "from proj2_rep_abs [of v] and \\<open>v \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> non_zero_vectors \\<Longrightarrow>\n  (v, proj2_rep (proj2_abs v)) \\<in> proportionality\n  v \\<noteq> 0", "have \"(v, proj2_rep (proj2_abs v)) \\<in> real_vector.proportionality\""], ["proof (prove)\nusing this:\n  v \\<in> non_zero_vectors \\<Longrightarrow>\n  (v, proj2_rep (proj2_abs v)) \\<in> proportionality\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (v, proj2_rep (proj2_abs v)) \\<in> proportionality", "unfolding real_vector.non_zero_vectors_def"], ["proof (prove)\nusing this:\n  v \\<in> {x. x \\<noteq> 0} \\<Longrightarrow>\n  (v, proj2_rep (proj2_abs v)) \\<in> proportionality\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (v, proj2_rep (proj2_abs v)) \\<in> proportionality", "by simp"], ["proof (state)\nthis:\n  (v, proj2_rep (proj2_abs v)) \\<in> proportionality\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v", "then"], ["proof (chain)\npicking this:\n  (v, proj2_rep (proj2_abs v)) \\<in> proportionality", "obtain c where \"v = c *\\<^sub>R proj2_rep (proj2_abs v)\""], ["proof (prove)\nusing this:\n  (v, proj2_rep (proj2_abs v)) \\<in> proportionality\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        v = c *\\<^sub>R proj2_rep (proj2_abs v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding real_vector.proportionality_def"], ["proof (prove)\nusing this:\n  (v, proj2_rep (proj2_abs v))\n  \\<in> {(x, y).\n         x \\<noteq> 0 \\<and>\n         y \\<noteq> 0 \\<and> (\\<exists>k. x = k *\\<^sub>R y)}\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        v = c *\\<^sub>R proj2_rep (proj2_abs v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v = c *\\<^sub>R proj2_rep (proj2_abs v)\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v", "with \\<open>v \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\n  v = c *\\<^sub>R proj2_rep (proj2_abs v)", "have \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  v = c *\\<^sub>R proj2_rep (proj2_abs v)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v", "hence \"1/c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 / c \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  1 / c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v", "from \\<open>v = c *\\<^sub>R proj2_rep (proj2_abs v)\\<close>"], ["proof (chain)\npicking this:\n  v = c *\\<^sub>R proj2_rep (proj2_abs v)", "have \"(1/c) *\\<^sub>R v = (1/c) *\\<^sub>R c *\\<^sub>R proj2_rep (proj2_abs v)\""], ["proof (prove)\nusing this:\n  v = c *\\<^sub>R proj2_rep (proj2_abs v)\n\ngoal (1 subgoal):\n 1. (1 / c) *\\<^sub>R v =\n    (1 / c) *\\<^sub>R c *\\<^sub>R proj2_rep (proj2_abs v)", "by simp"], ["proof (state)\nthis:\n  (1 / c) *\\<^sub>R v =\n  (1 / c) *\\<^sub>R c *\\<^sub>R proj2_rep (proj2_abs v)\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v", "with \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> 0\n  (1 / c) *\\<^sub>R v =\n  (1 / c) *\\<^sub>R c *\\<^sub>R proj2_rep (proj2_abs v)", "have \"proj2_rep (proj2_abs v) = (1/c) *\\<^sub>R v\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  (1 / c) *\\<^sub>R v =\n  (1 / c) *\\<^sub>R c *\\<^sub>R proj2_rep (proj2_abs v)\n\ngoal (1 subgoal):\n 1. proj2_rep (proj2_abs v) = (1 / c) *\\<^sub>R v", "by simp"], ["proof (state)\nthis:\n  proj2_rep (proj2_abs v) = (1 / c) *\\<^sub>R v\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v", "with \\<open>1/c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  1 / c \\<noteq> 0\n  proj2_rep (proj2_abs v) = (1 / c) *\\<^sub>R v", "show \"\\<exists> k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v\""], ["proof (prove)\nusing this:\n  1 / c \\<noteq> 0\n  proj2_rep (proj2_abs v) = (1 / c) *\\<^sub>R v\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v", "by blast"], ["proof (state)\nthis:\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_abs_abs_mult:\n  assumes \"proj2_abs v = proj2_abs w\" and \"w \\<noteq> 0\"\n  shows \"\\<exists> c. v = c *\\<^sub>R w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. v = c *\\<^sub>R w", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w", "assume \"v = 0\""], ["proof (state)\nthis:\n  v = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w", "hence \"v = 0 *\\<^sub>R w\""], ["proof (prove)\nusing this:\n  v = 0\n\ngoal (1 subgoal):\n 1. v = 0 *\\<^sub>R w", "by simp"], ["proof (state)\nthis:\n  v = 0 *\\<^sub>R w\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w", "thus \"\\<exists> c. v = c *\\<^sub>R w\""], ["proof (prove)\nusing this:\n  v = 0 *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = c *\\<^sub>R w", ".."], ["proof (state)\nthis:\n  \\<exists>c. v = c *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w", "assume \"v \\<noteq> 0\""], ["proof (state)\nthis:\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w", "from \\<open>proj2_abs v = proj2_abs w\\<close>"], ["proof (chain)\npicking this:\n  proj2_abs v = proj2_abs w", "have \"proj2_rep (proj2_abs v) = proj2_rep (proj2_abs w)\""], ["proof (prove)\nusing this:\n  proj2_abs v = proj2_abs w\n\ngoal (1 subgoal):\n 1. proj2_rep (proj2_abs v) = proj2_rep (proj2_abs w)", "by simp"], ["proof (state)\nthis:\n  proj2_rep (proj2_abs v) = proj2_rep (proj2_abs w)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w", "with proj2_rep_abs2 and \\<open>w \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  w \\<noteq> 0\n  proj2_rep (proj2_abs v) = proj2_rep (proj2_abs w)", "obtain k where \"proj2_rep (proj2_abs v) = k *\\<^sub>R w\""], ["proof (prove)\nusing this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  w \\<noteq> 0\n  proj2_rep (proj2_abs v) = proj2_rep (proj2_abs w)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        proj2_rep (proj2_abs v) = k *\\<^sub>R w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  proj2_rep (proj2_abs v) = k *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w", "with proj2_rep_abs2 [of v] and \\<open>v \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v\n  v \\<noteq> 0\n  proj2_rep (proj2_abs v) = k *\\<^sub>R w", "obtain j where \"j \\<noteq> 0\" and \"j *\\<^sub>R v = k *\\<^sub>R w\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs v) = k *\\<^sub>R v\n  v \\<noteq> 0\n  proj2_rep (proj2_abs v) = k *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<noteq> 0; j *\\<^sub>R v = k *\\<^sub>R w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<noteq> 0\n  j *\\<^sub>R v = k *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w", "hence \"(1/j) *\\<^sub>R j *\\<^sub>R v = (1/j) *\\<^sub>R k *\\<^sub>R w\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  j *\\<^sub>R v = k *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. (1 / j) *\\<^sub>R j *\\<^sub>R v = (1 / j) *\\<^sub>R k *\\<^sub>R w", "by simp"], ["proof (state)\nthis:\n  (1 / j) *\\<^sub>R j *\\<^sub>R v = (1 / j) *\\<^sub>R k *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w", "with \\<open>j \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  j \\<noteq> 0\n  (1 / j) *\\<^sub>R j *\\<^sub>R v = (1 / j) *\\<^sub>R k *\\<^sub>R w", "have \"v = (k/j) *\\<^sub>R w\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  (1 / j) *\\<^sub>R j *\\<^sub>R v = (1 / j) *\\<^sub>R k *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. v = (k / j) *\\<^sub>R w", "by simp"], ["proof (state)\nthis:\n  v = (k / j) *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<Longrightarrow> \\<exists>c. v = c *\\<^sub>R w", "thus \"\\<exists> c. v = c *\\<^sub>R w\""], ["proof (prove)\nusing this:\n  v = (k / j) *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = c *\\<^sub>R w", ".."], ["proof (state)\nthis:\n  \\<exists>c. v = c *\\<^sub>R w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dependent_proj2_abs:\n  assumes \"p \\<noteq> 0\" and \"q \\<noteq> 0\" and \"i \\<noteq> 0 \\<or> j \\<noteq> 0\" and \"i *\\<^sub>R p + j *\\<^sub>R q = 0\"\n  shows \"proj2_abs p = proj2_abs q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_abs p = proj2_abs q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_abs p = proj2_abs q", "have \"i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> False", "assume \"i = 0\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> False", "with \\<open>i \\<noteq> 0 \\<or> j \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> 0 \\<or> j \\<noteq> 0\n  i = 0", "have \"j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<or> j \\<noteq> 0\n  i = 0\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> False", "with \\<open>i *\\<^sub>R p + j *\\<^sub>R q = 0\\<close> and \\<open>q \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  i *\\<^sub>R p + j *\\<^sub>R q = 0\n  q \\<noteq> 0\n  j \\<noteq> 0", "have \"i *\\<^sub>R p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i *\\<^sub>R p + j *\\<^sub>R q = 0\n  q \\<noteq> 0\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i *\\<^sub>R p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  i *\\<^sub>R p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> False", "with \\<open>i = 0\\<close>"], ["proof (chain)\npicking this:\n  i = 0\n  i *\\<^sub>R p \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  i = 0\n  i *\\<^sub>R p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_abs p = proj2_abs q", "with \\<open>p \\<noteq> 0\\<close> and \\<open>i *\\<^sub>R p + j *\\<^sub>R q = 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  i *\\<^sub>R p + j *\\<^sub>R q = 0\n  i \\<noteq> 0", "have \"j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  i *\\<^sub>R p + j *\\<^sub>R q = 0\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_abs p = proj2_abs q", "from \\<open>i \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "have \"proj2_abs p = proj2_abs (i *\\<^sub>R p)\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_abs p = proj2_abs (i *\\<^sub>R p)", "by (rule proj2_abs_mult [symmetric])"], ["proof (state)\nthis:\n  proj2_abs p = proj2_abs (i *\\<^sub>R p)\n\ngoal (1 subgoal):\n 1. proj2_abs p = proj2_abs q", "also"], ["proof (state)\nthis:\n  proj2_abs p = proj2_abs (i *\\<^sub>R p)\n\ngoal (1 subgoal):\n 1. proj2_abs p = proj2_abs q", "from \\<open>i *\\<^sub>R p + j *\\<^sub>R q = 0\\<close> and proj2_abs_mult [of \"-1\" \"j *\\<^sub>R q\"]"], ["proof (chain)\npicking this:\n  i *\\<^sub>R p + j *\\<^sub>R q = 0\n  - 1 \\<noteq> 0 \\<Longrightarrow>\n  proj2_abs (- 1 *\\<^sub>R j *\\<^sub>R q) = proj2_abs (j *\\<^sub>R q)", "have \"\\<dots> = proj2_abs (j *\\<^sub>R q)\""], ["proof (prove)\nusing this:\n  i *\\<^sub>R p + j *\\<^sub>R q = 0\n  - 1 \\<noteq> 0 \\<Longrightarrow>\n  proj2_abs (- 1 *\\<^sub>R j *\\<^sub>R q) = proj2_abs (j *\\<^sub>R q)\n\ngoal (1 subgoal):\n 1. proj2_abs (i *\\<^sub>R p) = proj2_abs (j *\\<^sub>R q)", "by (simp add: algebra_simps [symmetric])"], ["proof (state)\nthis:\n  proj2_abs (i *\\<^sub>R p) = proj2_abs (j *\\<^sub>R q)\n\ngoal (1 subgoal):\n 1. proj2_abs p = proj2_abs q", "also"], ["proof (state)\nthis:\n  proj2_abs (i *\\<^sub>R p) = proj2_abs (j *\\<^sub>R q)\n\ngoal (1 subgoal):\n 1. proj2_abs p = proj2_abs q", "from \\<open>j \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  j \\<noteq> 0", "have \"\\<dots> = proj2_abs q\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_abs (j *\\<^sub>R q) = proj2_abs q", "by (rule proj2_abs_mult)"], ["proof (state)\nthis:\n  proj2_abs (j *\\<^sub>R q) = proj2_abs q\n\ngoal (1 subgoal):\n 1. proj2_abs p = proj2_abs q", "finally"], ["proof (chain)\npicking this:\n  proj2_abs p = proj2_abs q", "show \"proj2_abs p = proj2_abs q\""], ["proof (prove)\nusing this:\n  proj2_abs p = proj2_abs q\n\ngoal (1 subgoal):\n 1. proj2_abs p = proj2_abs q", "."], ["proof (state)\nthis:\n  proj2_abs p = proj2_abs q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_rep_dependent:\n  assumes \"i *\\<^sub>R proj2_rep v + j *\\<^sub>R proj2_rep w = 0\"\n  (is \"i *\\<^sub>R ?p + j *\\<^sub>R ?q = 0\")\n  and \"i \\<noteq> 0 \\<or> j \\<noteq> 0\"\n  shows \"v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "have \"?p \\<noteq> 0\" and \"?q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep v \\<noteq> 0 &&& proj2_rep w \\<noteq> 0", "by (rule proj2_rep_non_zero)+"], ["proof (state)\nthis:\n  proj2_rep v \\<noteq> 0\n  proj2_rep w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v = w", "with \\<open>i \\<noteq> 0 \\<or> j \\<noteq> 0\\<close> and \\<open>i *\\<^sub>R ?p + j *\\<^sub>R ?q = 0\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> 0 \\<or> j \\<noteq> 0\n  i *\\<^sub>R proj2_rep v + j *\\<^sub>R proj2_rep w = 0\n  proj2_rep v \\<noteq> 0\n  proj2_rep w \\<noteq> 0", "have \"proj2_abs ?p = proj2_abs ?q\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<or> j \\<noteq> 0\n  i *\\<^sub>R proj2_rep v + j *\\<^sub>R proj2_rep w = 0\n  proj2_rep v \\<noteq> 0\n  proj2_rep w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_abs (proj2_rep v) = proj2_abs (proj2_rep w)", "by (simp add: dependent_proj2_abs)"], ["proof (state)\nthis:\n  proj2_abs (proj2_rep v) = proj2_abs (proj2_rep w)\n\ngoal (1 subgoal):\n 1. v = w", "thus \"v = w\""], ["proof (prove)\nusing this:\n  proj2_abs (proj2_rep v) = proj2_abs (proj2_rep w)\n\ngoal (1 subgoal):\n 1. v = w", "by (simp add: proj2_abs_rep)"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_rep_independent:\n  assumes \"p \\<noteq> q\"\n  shows \"independent {proj2_rep p, proj2_rep q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. independent {proj2_rep p, proj2_rep q}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. dependent {proj2_rep p, proj2_rep q} \\<Longrightarrow> False", "let ?p' = \"proj2_rep p\""], ["proof (state)\ngoal (1 subgoal):\n 1. dependent {proj2_rep p, proj2_rep q} \\<Longrightarrow> False", "let ?q' = \"proj2_rep q\""], ["proof (state)\ngoal (1 subgoal):\n 1. dependent {proj2_rep p, proj2_rep q} \\<Longrightarrow> False", "let ?S = \"{?p', ?q'}\""], ["proof (state)\ngoal (1 subgoal):\n 1. dependent {proj2_rep p, proj2_rep q} \\<Longrightarrow> False", "assume \"dependent ?S\""], ["proof (state)\nthis:\n  dependent {proj2_rep p, proj2_rep q}\n\ngoal (1 subgoal):\n 1. dependent {proj2_rep p, proj2_rep q} \\<Longrightarrow> False", "from proj2_rep_inj and \\<open>p \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  inj proj2_rep\n  p \\<noteq> q", "have \"?p' \\<noteq> ?q'\""], ["proof (prove)\nusing this:\n  inj proj2_rep\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. proj2_rep p \\<noteq> proj2_rep q", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV. proj2_rep x = proj2_rep y \\<longrightarrow> x = y\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. proj2_rep p \\<noteq> proj2_rep q", "by auto"], ["proof (state)\nthis:\n  proj2_rep p \\<noteq> proj2_rep q\n\ngoal (1 subgoal):\n 1. dependent {proj2_rep p, proj2_rep q} \\<Longrightarrow> False", "with dependent_explicit_2 [of ?p' ?q'] and \\<open>dependent ?S\\<close>"], ["proof (chain)\npicking this:\n  proj2_rep p \\<noteq> proj2_rep q \\<Longrightarrow>\n  dependent {proj2_rep p, proj2_rep q} =\n  (\\<exists>i j.\n      (i \\<noteq> 0 \\<or> j \\<noteq> 0) \\<and>\n      i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q = 0)\n  dependent {proj2_rep p, proj2_rep q}\n  proj2_rep p \\<noteq> proj2_rep q", "obtain i and j where \"i *\\<^sub>R ?p' + j *\\<^sub>R ?q' = 0\" and \"i \\<noteq> 0 \\<or> j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  proj2_rep p \\<noteq> proj2_rep q \\<Longrightarrow>\n  dependent {proj2_rep p, proj2_rep q} =\n  (\\<exists>i j.\n      (i \\<noteq> 0 \\<or> j \\<noteq> 0) \\<and>\n      i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q = 0)\n  dependent {proj2_rep p, proj2_rep q}\n  proj2_rep p \\<noteq> proj2_rep q\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q = 0;\n         i \\<noteq> 0 \\<or> j \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: scalar_equiv) auto"], ["proof (state)\nthis:\n  i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q = 0\n  i \\<noteq> 0 \\<or> j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dependent {proj2_rep p, proj2_rep q} \\<Longrightarrow> False", "with proj2_rep_dependent"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i *\\<^sub>R proj2_rep ?v + ?j *\\<^sub>R proj2_rep ?w = 0;\n   ?i \\<noteq> 0 \\<or> ?j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q = 0\n  i \\<noteq> 0 \\<or> j \\<noteq> 0", "have \"p = q\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i *\\<^sub>R proj2_rep ?v + ?j *\\<^sub>R proj2_rep ?w = 0;\n   ?i \\<noteq> 0 \\<or> ?j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q = 0\n  i \\<noteq> 0 \\<or> j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p = q", "by simp"], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. dependent {proj2_rep p, proj2_rep q} \\<Longrightarrow> False", "with \\<open>p \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  p = q", "show False"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  p = q\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Lines of the real projective plane\""], ["", "definition proj2_Col :: \"[proj2, proj2, proj2] \\<Rightarrow> bool\" where\n  \"proj2_Col p q r \\<equiv>\n  (\\<exists> i j k. i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q + k *\\<^sub>R proj2_rep r = 0\n  \\<and> (i\\<noteq>0 \\<or> j\\<noteq>0 \\<or> k\\<noteq>0))\""], ["", "lemma proj2_Col_abs:\n  assumes \"p \\<noteq> 0\" and \"q \\<noteq> 0\" and \"r \\<noteq> 0\" and \"i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\"\n  and \"i *\\<^sub>R p + j *\\<^sub>R q + k *\\<^sub>R r = 0\"\n  shows \"proj2_Col (proj2_abs p) (proj2_abs q) (proj2_abs r)\"\n  (is \"proj2_Col ?pp ?pq ?pr\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col (proj2_abs p) (proj2_abs q) (proj2_abs r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_Col (proj2_abs p) (proj2_abs q) (proj2_abs r)", "from \\<open>p \\<noteq> 0\\<close> and proj2_rep_abs2"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v", "obtain i' where \"i' \\<noteq> 0\" and \"proj2_rep ?pp = i' *\\<^sub>R p\" (is \"?rp = _\")"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i' \\<noteq> 0;\n         proj2_rep (proj2_abs p) = i' *\\<^sub>R p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i' \\<noteq> 0\n  proj2_rep (proj2_abs p) = i' *\\<^sub>R p\n\ngoal (1 subgoal):\n 1. proj2_Col (proj2_abs p) (proj2_abs q) (proj2_abs r)", "from \\<open>q \\<noteq> 0\\<close> and proj2_rep_abs2"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v", "obtain j' where \"j' \\<noteq> 0\" and \"proj2_rep ?pq = j' *\\<^sub>R q\" (is \"?rq = _\")"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>j' \\<noteq> 0;\n         proj2_rep (proj2_abs q) = j' *\\<^sub>R q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j' \\<noteq> 0\n  proj2_rep (proj2_abs q) = j' *\\<^sub>R q\n\ngoal (1 subgoal):\n 1. proj2_Col (proj2_abs p) (proj2_abs q) (proj2_abs r)", "from \\<open>r \\<noteq> 0\\<close> and proj2_rep_abs2"], ["proof (chain)\npicking this:\n  r \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v", "obtain k' where \"k' \\<noteq> 0\" and \"proj2_rep ?pr = k' *\\<^sub>R r\" (is \"?rr = _\")"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>k' \\<noteq> 0;\n         proj2_rep (proj2_abs r) = k' *\\<^sub>R r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k' \\<noteq> 0\n  proj2_rep (proj2_abs r) = k' *\\<^sub>R r\n\ngoal (1 subgoal):\n 1. proj2_Col (proj2_abs p) (proj2_abs q) (proj2_abs r)", "with \\<open>i *\\<^sub>R p + j *\\<^sub>R q + k *\\<^sub>R r = 0\\<close>\n    and \\<open>i' \\<noteq> 0\\<close> and \\<open>proj2_rep ?pp = i' *\\<^sub>R p\\<close>\n    and \\<open>j' \\<noteq> 0\\<close> and \\<open>proj2_rep ?pq = j' *\\<^sub>R q\\<close>"], ["proof (chain)\npicking this:\n  i *\\<^sub>R p + j *\\<^sub>R q + k *\\<^sub>R r = 0\n  i' \\<noteq> 0\n  proj2_rep (proj2_abs p) = i' *\\<^sub>R p\n  j' \\<noteq> 0\n  proj2_rep (proj2_abs q) = j' *\\<^sub>R q\n  k' \\<noteq> 0\n  proj2_rep (proj2_abs r) = k' *\\<^sub>R r", "have \"(i/i') *\\<^sub>R ?rp + (j/j') *\\<^sub>R ?rq + (k/k') *\\<^sub>R ?rr = 0\""], ["proof (prove)\nusing this:\n  i *\\<^sub>R p + j *\\<^sub>R q + k *\\<^sub>R r = 0\n  i' \\<noteq> 0\n  proj2_rep (proj2_abs p) = i' *\\<^sub>R p\n  j' \\<noteq> 0\n  proj2_rep (proj2_abs q) = j' *\\<^sub>R q\n  k' \\<noteq> 0\n  proj2_rep (proj2_abs r) = k' *\\<^sub>R r\n\ngoal (1 subgoal):\n 1. (i / i') *\\<^sub>R proj2_rep (proj2_abs p) +\n    (j / j') *\\<^sub>R proj2_rep (proj2_abs q) +\n    (k / k') *\\<^sub>R proj2_rep (proj2_abs r) =\n    0", "by simp"], ["proof (state)\nthis:\n  (i / i') *\\<^sub>R proj2_rep (proj2_abs p) +\n  (j / j') *\\<^sub>R proj2_rep (proj2_abs q) +\n  (k / k') *\\<^sub>R proj2_rep (proj2_abs r) =\n  0\n\ngoal (1 subgoal):\n 1. proj2_Col (proj2_abs p) (proj2_abs q) (proj2_abs r)", "from \\<open>i' \\<noteq> 0\\<close> and \\<open>j' \\<noteq> 0\\<close> and \\<open>k' \\<noteq> 0\\<close> and \\<open>i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  i' \\<noteq> 0\n  j' \\<noteq> 0\n  k' \\<noteq> 0\n  i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0", "have \"i/i' \\<noteq> 0 \\<or> j/j' \\<noteq> 0 \\<or> k/k' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i' \\<noteq> 0\n  j' \\<noteq> 0\n  k' \\<noteq> 0\n  i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i / i' \\<noteq> 0 \\<or> j / j' \\<noteq> 0 \\<or> k / k' \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  i / i' \\<noteq> 0 \\<or> j / j' \\<noteq> 0 \\<or> k / k' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_Col (proj2_abs p) (proj2_abs q) (proj2_abs r)", "with \\<open>(i/i') *\\<^sub>R ?rp + (j/j') *\\<^sub>R ?rq + (k/k') *\\<^sub>R ?rr = 0\\<close>"], ["proof (chain)\npicking this:\n  (i / i') *\\<^sub>R proj2_rep (proj2_abs p) +\n  (j / j') *\\<^sub>R proj2_rep (proj2_abs q) +\n  (k / k') *\\<^sub>R proj2_rep (proj2_abs r) =\n  0\n  i / i' \\<noteq> 0 \\<or> j / j' \\<noteq> 0 \\<or> k / k' \\<noteq> 0", "show \"proj2_Col ?pp ?pq ?pr\""], ["proof (prove)\nusing this:\n  (i / i') *\\<^sub>R proj2_rep (proj2_abs p) +\n  (j / j') *\\<^sub>R proj2_rep (proj2_abs q) +\n  (k / k') *\\<^sub>R proj2_rep (proj2_abs r) =\n  0\n  i / i' \\<noteq> 0 \\<or> j / j' \\<noteq> 0 \\<or> k / k' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_Col (proj2_abs p) (proj2_abs q) (proj2_abs r)", "by (unfold proj2_Col_def, best)"], ["proof (state)\nthis:\n  proj2_Col (proj2_abs p) (proj2_abs q) (proj2_abs r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_Col_permute:\n  assumes \"proj2_Col a b c\"\n  shows \"proj2_Col a c b\"\n  and \"proj2_Col b a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col a c b &&& proj2_Col b a c", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col a c b\n 2. proj2_Col b a c", "let ?a' = \"proj2_rep a\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col a c b\n 2. proj2_Col b a c", "let ?b' = \"proj2_rep b\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col a c b\n 2. proj2_Col b a c", "let ?c' = \"proj2_rep c\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col a c b\n 2. proj2_Col b a c", "from \\<open>proj2_Col a b c\\<close>"], ["proof (chain)\npicking this:\n  proj2_Col a b c", "obtain i and j and k where\n    \"i *\\<^sub>R ?a' + j *\\<^sub>R ?b' + k *\\<^sub>R ?c' = 0\"\n    and \"i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  proj2_Col a b c\n\ngoal (1 subgoal):\n 1. (\\<And>i j k.\n        \\<lbrakk>i *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep b +\n                 k *\\<^sub>R proj2_rep c =\n                 0;\n         i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding proj2_Col_def"], ["proof (prove)\nusing this:\n  \\<exists>i j k.\n     i *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep b +\n     k *\\<^sub>R proj2_rep c =\n     0 \\<and>\n     (i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>i j k.\n        \\<lbrakk>i *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep b +\n                 k *\\<^sub>R proj2_rep c =\n                 0;\n         i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep b +\n  k *\\<^sub>R proj2_rep c =\n  0\n  i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. proj2_Col a c b\n 2. proj2_Col b a c", "from \\<open>i *\\<^sub>R ?a' + j *\\<^sub>R ?b' + k *\\<^sub>R ?c' = 0\\<close>"], ["proof (chain)\npicking this:\n  i *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep b +\n  k *\\<^sub>R proj2_rep c =\n  0", "have \"i *\\<^sub>R ?a' + k *\\<^sub>R ?c' + j *\\<^sub>R ?b' = 0\"\n    and \"j *\\<^sub>R ?b' + i *\\<^sub>R ?a' + k *\\<^sub>R ?c' = 0\""], ["proof (prove)\nusing this:\n  i *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep b +\n  k *\\<^sub>R proj2_rep c =\n  0\n\ngoal (1 subgoal):\n 1. i *\\<^sub>R proj2_rep a + k *\\<^sub>R proj2_rep c +\n    j *\\<^sub>R proj2_rep b =\n    0 &&&\n    j *\\<^sub>R proj2_rep b + i *\\<^sub>R proj2_rep a +\n    k *\\<^sub>R proj2_rep c =\n    0", "by (simp_all add: ac_simps)"], ["proof (state)\nthis:\n  i *\\<^sub>R proj2_rep a + k *\\<^sub>R proj2_rep c +\n  j *\\<^sub>R proj2_rep b =\n  0\n  j *\\<^sub>R proj2_rep b + i *\\<^sub>R proj2_rep a +\n  k *\\<^sub>R proj2_rep c =\n  0\n\ngoal (2 subgoals):\n 1. proj2_Col a c b\n 2. proj2_Col b a c", "moreover"], ["proof (state)\nthis:\n  i *\\<^sub>R proj2_rep a + k *\\<^sub>R proj2_rep c +\n  j *\\<^sub>R proj2_rep b =\n  0\n  j *\\<^sub>R proj2_rep b + i *\\<^sub>R proj2_rep a +\n  k *\\<^sub>R proj2_rep c =\n  0\n\ngoal (2 subgoals):\n 1. proj2_Col a c b\n 2. proj2_Col b a c", "from \\<open>i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0", "have \"i \\<noteq> 0 \\<or> k \\<noteq> 0 \\<or> j \\<noteq> 0\" and \"j \\<noteq> 0 \\<or> i \\<noteq> 0 \\<or> k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<or> k \\<noteq> 0 \\<or> j \\<noteq> 0 &&&\n    j \\<noteq> 0 \\<or> i \\<noteq> 0 \\<or> k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> 0 \\<or> k \\<noteq> 0 \\<or> j \\<noteq> 0\n  j \\<noteq> 0 \\<or> i \\<noteq> 0 \\<or> k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. proj2_Col a c b\n 2. proj2_Col b a c", "ultimately"], ["proof (chain)\npicking this:\n  i *\\<^sub>R proj2_rep a + k *\\<^sub>R proj2_rep c +\n  j *\\<^sub>R proj2_rep b =\n  0\n  j *\\<^sub>R proj2_rep b + i *\\<^sub>R proj2_rep a +\n  k *\\<^sub>R proj2_rep c =\n  0\n  i \\<noteq> 0 \\<or> k \\<noteq> 0 \\<or> j \\<noteq> 0\n  j \\<noteq> 0 \\<or> i \\<noteq> 0 \\<or> k \\<noteq> 0", "show \"proj2_Col a c b\" and \"proj2_Col b a c\""], ["proof (prove)\nusing this:\n  i *\\<^sub>R proj2_rep a + k *\\<^sub>R proj2_rep c +\n  j *\\<^sub>R proj2_rep b =\n  0\n  j *\\<^sub>R proj2_rep b + i *\\<^sub>R proj2_rep a +\n  k *\\<^sub>R proj2_rep c =\n  0\n  i \\<noteq> 0 \\<or> k \\<noteq> 0 \\<or> j \\<noteq> 0\n  j \\<noteq> 0 \\<or> i \\<noteq> 0 \\<or> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_Col a c b &&& proj2_Col b a c", "unfolding proj2_Col_def"], ["proof (prove)\nusing this:\n  i *\\<^sub>R proj2_rep a + k *\\<^sub>R proj2_rep c +\n  j *\\<^sub>R proj2_rep b =\n  0\n  j *\\<^sub>R proj2_rep b + i *\\<^sub>R proj2_rep a +\n  k *\\<^sub>R proj2_rep c =\n  0\n  i \\<noteq> 0 \\<or> k \\<noteq> 0 \\<or> j \\<noteq> 0\n  j \\<noteq> 0 \\<or> i \\<noteq> 0 \\<or> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>i j k.\n       i *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep c +\n       k *\\<^sub>R proj2_rep b =\n       0 \\<and>\n       (i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0) &&&\n    \\<exists>i j k.\n       i *\\<^sub>R proj2_rep b + j *\\<^sub>R proj2_rep a +\n       k *\\<^sub>R proj2_rep c =\n       0 \\<and>\n       (i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  proj2_Col a c b\n  proj2_Col b a c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_Col_coincide: \"proj2_Col a a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col a a c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_Col a a c", "have \"1 *\\<^sub>R proj2_rep a + (-1) *\\<^sub>R proj2_rep a + 0 *\\<^sub>R proj2_rep c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>R proj2_rep a + - 1 *\\<^sub>R proj2_rep a +\n    0 *\\<^sub>R proj2_rep c =\n    0", "by simp"], ["proof (state)\nthis:\n  1 *\\<^sub>R proj2_rep a + - 1 *\\<^sub>R proj2_rep a +\n  0 *\\<^sub>R proj2_rep c =\n  0\n\ngoal (1 subgoal):\n 1. proj2_Col a a c", "moreover"], ["proof (state)\nthis:\n  1 *\\<^sub>R proj2_rep a + - 1 *\\<^sub>R proj2_rep a +\n  0 *\\<^sub>R proj2_rep c =\n  0\n\ngoal (1 subgoal):\n 1. proj2_Col a a c", "have \"(1::real) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_Col a a c", "ultimately"], ["proof (chain)\npicking this:\n  1 *\\<^sub>R proj2_rep a + - 1 *\\<^sub>R proj2_rep a +\n  0 *\\<^sub>R proj2_rep c =\n  0\n  1 \\<noteq> 0", "show \"proj2_Col a a c\""], ["proof (prove)\nusing this:\n  1 *\\<^sub>R proj2_rep a + - 1 *\\<^sub>R proj2_rep a +\n  0 *\\<^sub>R proj2_rep c =\n  0\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_Col a a c", "unfolding proj2_Col_def"], ["proof (prove)\nusing this:\n  1 *\\<^sub>R proj2_rep a + - 1 *\\<^sub>R proj2_rep a +\n  0 *\\<^sub>R proj2_rep c =\n  0\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>i j k.\n       i *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep a +\n       k *\\<^sub>R proj2_rep c =\n       0 \\<and>\n       (i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)", "by blast"], ["proof (state)\nthis:\n  proj2_Col a a c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_Col_iff:\n  assumes \"a \\<noteq> r\"\n  shows \"proj2_Col a r t \\<longleftrightarrow>\n  t = a \\<or> (\\<exists> i. t = proj2_abs (i *\\<^sub>R (proj2_rep a) + (proj2_rep r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col a r t =\n    (t = a \\<or>\n     (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col a r t \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n 2. t = a \\<or>\n    (\\<exists>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n    proj2_Col a r t", "let ?a' = \"proj2_rep a\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col a r t \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n 2. t = a \\<or>\n    (\\<exists>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n    proj2_Col a r t", "let ?r' = \"proj2_rep r\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col a r t \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n 2. t = a \\<or>\n    (\\<exists>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n    proj2_Col a r t", "let ?t' = \"proj2_rep t\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col a r t \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n 2. t = a \\<or>\n    (\\<exists>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n    proj2_Col a r t", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col a r t \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n 2. t = a \\<or>\n    (\\<exists>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n    proj2_Col a r t", "assume \"proj2_Col a r t\""], ["proof (state)\nthis:\n  proj2_Col a r t\n\ngoal (2 subgoals):\n 1. proj2_Col a r t \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n 2. t = a \\<or>\n    (\\<exists>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n    proj2_Col a r t", "then"], ["proof (chain)\npicking this:\n  proj2_Col a r t", "obtain h and j and k where\n      \"h *\\<^sub>R ?a' + j *\\<^sub>R ?r' + k *\\<^sub>R ?t' = 0\"\n      and \"h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  proj2_Col a r t\n\ngoal (1 subgoal):\n 1. (\\<And>h j k.\n        \\<lbrakk>h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n                 k *\\<^sub>R proj2_rep t =\n                 0;\n         h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding proj2_Col_def"], ["proof (prove)\nusing this:\n  \\<exists>i j k.\n     i *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n     k *\\<^sub>R proj2_rep t =\n     0 \\<and>\n     (i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>h j k.\n        \\<lbrakk>h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n                 k *\\<^sub>R proj2_rep t =\n                 0;\n         h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  k *\\<^sub>R proj2_rep t =\n  0\n  h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. proj2_Col a r t \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n 2. t = a \\<or>\n    (\\<exists>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n    proj2_Col a r t", "show \"t = a \\<or> (\\<exists> i. t = proj2_abs (i *\\<^sub>R ?a' + ?r'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n 2. \\<not> ?P \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "assume \"j = 0\""], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n 2. \\<not> ?P \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "with \\<open>h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\n  j = 0", "have \"h \\<noteq> 0 \\<or> k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\n  j = 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<or> k \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  h \\<noteq> 0 \\<or> k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n 2. \\<not> ?P \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "with proj2_rep_dependent\n        and \\<open>h *\\<^sub>R ?a' + j *\\<^sub>R ?r' + k *\\<^sub>R ?t' = 0\\<close>\n        and \\<open>j = 0\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i *\\<^sub>R proj2_rep ?v + ?j *\\<^sub>R proj2_rep ?w = 0;\n   ?i \\<noteq> 0 \\<or> ?j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  k *\\<^sub>R proj2_rep t =\n  0\n  j = 0\n  h \\<noteq> 0 \\<or> k \\<noteq> 0", "have \"t = a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i *\\<^sub>R proj2_rep ?v + ?j *\\<^sub>R proj2_rep ?w = 0;\n   ?i \\<noteq> 0 \\<or> ?j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  k *\\<^sub>R proj2_rep t =\n  0\n  j = 0\n  h \\<noteq> 0 \\<or> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t = a", "by auto"], ["proof (state)\nthis:\n  t = a\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n 2. \\<not> ?P \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "thus \"t = a \\<or> (\\<exists> i. t = proj2_abs (i *\\<^sub>R ?a' + ?r'))\""], ["proof (prove)\nusing this:\n  t = a\n\ngoal (1 subgoal):\n 1. t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", ".."], ["proof (state)\nthis:\n  t = a \\<or>\n  (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "assume \"j \\<noteq> 0\""], ["proof (state)\nthis:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "have \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> k \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> k \\<noteq> 0 \\<Longrightarrow> False", "with proj2_rep_dependent\n          and \\<open>h *\\<^sub>R ?a' + j *\\<^sub>R ?r' + k *\\<^sub>R ?t' = 0\\<close>\n          and \\<open>j \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i *\\<^sub>R proj2_rep ?v + ?j *\\<^sub>R proj2_rep ?w = 0;\n   ?i \\<noteq> 0 \\<or> ?j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  k *\\<^sub>R proj2_rep t =\n  0\n  j \\<noteq> 0\n  \\<not> k \\<noteq> 0", "have \"a = r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i *\\<^sub>R proj2_rep ?v + ?j *\\<^sub>R proj2_rep ?w = 0;\n   ?i \\<noteq> 0 \\<or> ?j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  k *\\<^sub>R proj2_rep t =\n  0\n  j \\<noteq> 0\n  \\<not> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a = r", "by simp"], ["proof (state)\nthis:\n  a = r\n\ngoal (1 subgoal):\n 1. \\<not> k \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>a \\<noteq> r\\<close>"], ["proof (chain)\npicking this:\n  a \\<noteq> r\n  a = r", "show False"], ["proof (prove)\nusing this:\n  a \\<noteq> r\n  a = r\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "from \\<open>h *\\<^sub>R ?a' + j *\\<^sub>R ?r' + k *\\<^sub>R ?t' = 0\\<close>"], ["proof (chain)\npicking this:\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  k *\\<^sub>R proj2_rep t =\n  0", "have \"h *\\<^sub>R ?a' + j *\\<^sub>R ?r' + k *\\<^sub>R ?t' - k *\\<^sub>R ?t' = -k *\\<^sub>R ?t'\""], ["proof (prove)\nusing this:\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  k *\\<^sub>R proj2_rep t =\n  0\n\ngoal (1 subgoal):\n 1. h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n    k *\\<^sub>R proj2_rep t -\n    k *\\<^sub>R proj2_rep t =\n    - k *\\<^sub>R proj2_rep t", "by simp"], ["proof (state)\nthis:\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  k *\\<^sub>R proj2_rep t -\n  k *\\<^sub>R proj2_rep t =\n  - k *\\<^sub>R proj2_rep t\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "hence \"h *\\<^sub>R ?a' + j *\\<^sub>R ?r' = -k *\\<^sub>R ?t'\""], ["proof (prove)\nusing this:\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  k *\\<^sub>R proj2_rep t -\n  k *\\<^sub>R proj2_rep t =\n  - k *\\<^sub>R proj2_rep t\n\ngoal (1 subgoal):\n 1. h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r =\n    - k *\\<^sub>R proj2_rep t", "by simp"], ["proof (state)\nthis:\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r =\n  - k *\\<^sub>R proj2_rep t\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "with proj2_abs_mult_rep [of \"-k\"] and \\<open>k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  - k \\<noteq> 0 \\<Longrightarrow>\n  proj2_abs (- k *\\<^sub>R proj2_rep ?x) = ?x\n  k \\<noteq> 0\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r =\n  - k *\\<^sub>R proj2_rep t", "have \"proj2_abs (h *\\<^sub>R ?a' + j *\\<^sub>R ?r') = t\""], ["proof (prove)\nusing this:\n  - k \\<noteq> 0 \\<Longrightarrow>\n  proj2_abs (- k *\\<^sub>R proj2_rep ?x) = ?x\n  k \\<noteq> 0\n  h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r =\n  - k *\\<^sub>R proj2_rep t\n\ngoal (1 subgoal):\n 1. proj2_abs (h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r) = t", "by simp"], ["proof (state)\nthis:\n  proj2_abs (h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r) = t\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "with proj2_abs_mult [of \"1/j\" \"h *\\<^sub>R ?a' + j *\\<^sub>R ?r'\"] and \\<open>j \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  1 / j \\<noteq> 0 \\<Longrightarrow>\n  proj2_abs\n   ((1 / j) *\\<^sub>R (h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r)) =\n  proj2_abs (h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r)\n  j \\<noteq> 0\n  proj2_abs (h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r) = t", "have \"proj2_abs ((h/j) *\\<^sub>R ?a' + ?r') = t\""], ["proof (prove)\nusing this:\n  1 / j \\<noteq> 0 \\<Longrightarrow>\n  proj2_abs\n   ((1 / j) *\\<^sub>R (h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r)) =\n  proj2_abs (h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r)\n  j \\<noteq> 0\n  proj2_abs (h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r) = t\n\ngoal (1 subgoal):\n 1. proj2_abs ((h / j) *\\<^sub>R proj2_rep a + proj2_rep r) = t", "by (simp add: scaleR_right_distrib)"], ["proof (state)\nthis:\n  proj2_abs ((h / j) *\\<^sub>R proj2_rep a + proj2_rep r) = t\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "hence \"\\<exists> i. t = proj2_abs (i *\\<^sub>R ?a' + ?r')\""], ["proof (prove)\nusing this:\n  proj2_abs ((h / j) *\\<^sub>R proj2_rep a + proj2_rep r) = t\n\ngoal (1 subgoal):\n 1. \\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow>\n    t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", "thus \"t = a \\<or> (\\<exists> i. t = proj2_abs (i *\\<^sub>R ?a' + ?r'))\""], ["proof (prove)\nusing this:\n  \\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)\n\ngoal (1 subgoal):\n 1. t = a \\<or>\n    (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))", ".."], ["proof (state)\nthis:\n  t = a \\<or>\n  (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t = a \\<or>\n  (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n\ngoal (1 subgoal):\n 1. t = a \\<or>\n    (\\<exists>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n    proj2_Col a r t", "}"], ["proof (state)\nthis:\n  proj2_Col a r t \\<Longrightarrow>\n  t = a \\<or>\n  (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n\ngoal (1 subgoal):\n 1. t = a \\<or>\n    (\\<exists>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n    proj2_Col a r t", "{"], ["proof (state)\nthis:\n  proj2_Col a r t \\<Longrightarrow>\n  t = a \\<or>\n  (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n\ngoal (1 subgoal):\n 1. t = a \\<or>\n    (\\<exists>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n    proj2_Col a r t", "assume \"t = a \\<or> (\\<exists> i. t = proj2_abs (i *\\<^sub>R ?a' + ?r'))\""], ["proof (state)\nthis:\n  t = a \\<or>\n  (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n\ngoal (1 subgoal):\n 1. t = a \\<or>\n    (\\<exists>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n    proj2_Col a r t", "show \"proj2_Col a r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col a r t", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> proj2_Col a r t\n 2. \\<not> ?P \\<Longrightarrow> proj2_Col a r t", "assume \"t = a\""], ["proof (state)\nthis:\n  t = a\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> proj2_Col a r t\n 2. \\<not> ?P \\<Longrightarrow> proj2_Col a r t", "with proj2_Col_coincide and proj2_Col_permute"], ["proof (chain)\npicking this:\n  proj2_Col ?a ?a ?c\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?a ?c ?b\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?b ?a ?c\n  t = a", "show \"proj2_Col a r t\""], ["proof (prove)\nusing this:\n  proj2_Col ?a ?a ?c\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?a ?c ?b\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?b ?a ?c\n  t = a\n\ngoal (1 subgoal):\n 1. proj2_Col a r t", "by blast"], ["proof (state)\nthis:\n  proj2_Col a r t\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> proj2_Col a r t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> proj2_Col a r t", "assume \"t \\<noteq> a\""], ["proof (state)\nthis:\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> proj2_Col a r t", "with \\<open>t = a \\<or> (\\<exists> i. t = proj2_abs (i *\\<^sub>R ?a' + ?r'))\\<close>"], ["proof (chain)\npicking this:\n  t = a \\<or>\n  (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n  t \\<noteq> a", "obtain i where \"t = proj2_abs (i *\\<^sub>R ?a' + ?r')\""], ["proof (prove)\nusing this:\n  t = a \\<or>\n  (\\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r))\n  t \\<noteq> a\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        t =\n        proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> proj2_Col a r t", "from proj2_rep_dependent [of i a 1 r] and \\<open>a \\<noteq> r\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>i *\\<^sub>R proj2_rep a + 1 *\\<^sub>R proj2_rep r = 0;\n   i \\<noteq> 0 \\<or> 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> a = r\n  a \\<noteq> r", "have \"i *\\<^sub>R ?a' + ?r' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i *\\<^sub>R proj2_rep a + 1 *\\<^sub>R proj2_rep r = 0;\n   i \\<noteq> 0 \\<or> 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> a = r\n  a \\<noteq> r\n\ngoal (1 subgoal):\n 1. i *\\<^sub>R proj2_rep a + proj2_rep r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  i *\\<^sub>R proj2_rep a + proj2_rep r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> proj2_Col a r t", "with proj2_rep_abs2 and \\<open>t = proj2_abs (i *\\<^sub>R ?a' + ?r')\\<close>"], ["proof (chain)\npicking this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)\n  i *\\<^sub>R proj2_rep a + proj2_rep r \\<noteq> 0", "obtain j where \"?t' = j *\\<^sub>R (i *\\<^sub>R ?a' + ?r')\""], ["proof (prove)\nusing this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)\n  i *\\<^sub>R proj2_rep a + proj2_rep r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        proj2_rep t =\n        j *\\<^sub>R\n        (i *\\<^sub>R proj2_rep a + proj2_rep r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  proj2_rep t = j *\\<^sub>R (i *\\<^sub>R proj2_rep a + proj2_rep r)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> proj2_Col a r t", "hence \"?t' - ?t' = (j * i) *\\<^sub>R ?a' + j *\\<^sub>R ?r' + (-1) *\\<^sub>R ?t'\""], ["proof (prove)\nusing this:\n  proj2_rep t = j *\\<^sub>R (i *\\<^sub>R proj2_rep a + proj2_rep r)\n\ngoal (1 subgoal):\n 1. proj2_rep t - proj2_rep t =\n    (j * i) *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n    - 1 *\\<^sub>R proj2_rep t", "by (simp add: scaleR_right_distrib)"], ["proof (state)\nthis:\n  proj2_rep t - proj2_rep t =\n  (j * i) *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  - 1 *\\<^sub>R proj2_rep t\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> proj2_Col a r t", "hence \"(j * i) *\\<^sub>R ?a' + j *\\<^sub>R ?r' + (-1) *\\<^sub>R ?t' = 0\""], ["proof (prove)\nusing this:\n  proj2_rep t - proj2_rep t =\n  (j * i) *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  - 1 *\\<^sub>R proj2_rep t\n\ngoal (1 subgoal):\n 1. (j * i) *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n    - 1 *\\<^sub>R proj2_rep t =\n    0", "by simp"], ["proof (state)\nthis:\n  (j * i) *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  - 1 *\\<^sub>R proj2_rep t =\n  0\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> proj2_Col a r t", "have \"\\<exists> h j k. h *\\<^sub>R ?a' + j *\\<^sub>R ?r' + k *\\<^sub>R ?t' = 0\n        \\<and> (h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h j k.\n       h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n       k *\\<^sub>R proj2_rep t =\n       0 \\<and>\n       (h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)", "proof standard+"], ["proof (state)\ngoal (2 subgoals):\n 1. ?h *\\<^sub>R proj2_rep a + ?j2 *\\<^sub>R proj2_rep r +\n    ?k4 *\\<^sub>R proj2_rep t =\n    0\n 2. ?h \\<noteq> 0 \\<or> ?j2 \\<noteq> 0 \\<or> ?k4 \\<noteq> 0", "from \\<open>(j * i) *\\<^sub>R ?a' + j *\\<^sub>R ?r' + (-1) *\\<^sub>R ?t' = 0\\<close>"], ["proof (chain)\npicking this:\n  (j * i) *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  - 1 *\\<^sub>R proj2_rep t =\n  0", "show \"(j * i) *\\<^sub>R ?a' + j *\\<^sub>R ?r' + (-1) *\\<^sub>R ?t' = 0\""], ["proof (prove)\nusing this:\n  (j * i) *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  - 1 *\\<^sub>R proj2_rep t =\n  0\n\ngoal (1 subgoal):\n 1. (j * i) *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n    - 1 *\\<^sub>R proj2_rep t =\n    0", "."], ["proof (state)\nthis:\n  (j * i) *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n  - 1 *\\<^sub>R proj2_rep t =\n  0\n\ngoal (1 subgoal):\n 1. j * i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> - 1 \\<noteq> 0", "show \"j * i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> (-1::real) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j * i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> - 1 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  j * i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> - 1 \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>h j k.\n     h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n     k *\\<^sub>R proj2_rep t =\n     0 \\<and>\n     (h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. t \\<noteq> a \\<Longrightarrow> proj2_Col a r t", "thus \"proj2_Col a r t\""], ["proof (prove)\nusing this:\n  \\<exists>h j k.\n     h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n     k *\\<^sub>R proj2_rep t =\n     0 \\<and>\n     (h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. proj2_Col a r t", "unfolding proj2_Col_def"], ["proof (prove)\nusing this:\n  \\<exists>h j k.\n     h *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n     k *\\<^sub>R proj2_rep t =\n     0 \\<and>\n     (h \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<exists>i j k.\n       i *\\<^sub>R proj2_rep a + j *\\<^sub>R proj2_rep r +\n       k *\\<^sub>R proj2_rep t =\n       0 \\<and>\n       (i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)", "."], ["proof (state)\nthis:\n  proj2_Col a r t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj2_Col a r t\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  t = a \\<or>\n  (\\<exists>i.\n      t =\n      proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)) \\<Longrightarrow>\n  proj2_Col a r t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition proj2_Col_coeff :: \"proj2 \\<Rightarrow> proj2 \\<Rightarrow> proj2 \\<Rightarrow> real\" where\n  \"proj2_Col_coeff a r t \\<equiv> \\<some> i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)\""], ["", "lemma proj2_Col_coeff:\n  assumes \"proj2_Col a r t\" and \"a \\<noteq> r\" and \"t \\<noteq> a\"\n  shows \"t = proj2_abs ((proj2_Col_coeff a r t) *\\<^sub>R proj2_rep a + proj2_rep r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t =\n    proj2_abs (proj2_Col_coeff a r t *\\<^sub>R proj2_rep a + proj2_rep r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t =\n    proj2_abs (proj2_Col_coeff a r t *\\<^sub>R proj2_rep a + proj2_rep r)", "from \\<open>a \\<noteq> r\\<close> and \\<open>proj2_Col a r t\\<close> and \\<open>t \\<noteq> a\\<close> and proj2_Col_iff"], ["proof (chain)\npicking this:\n  a \\<noteq> r\n  proj2_Col a r t\n  t \\<noteq> a\n  ?a \\<noteq> ?r \\<Longrightarrow>\n  proj2_Col ?a ?r ?t =\n  (?t = ?a \\<or>\n   (\\<exists>i. ?t = proj2_abs (i *\\<^sub>R proj2_rep ?a + proj2_rep ?r)))", "have \"\\<exists> i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)\""], ["proof (prove)\nusing this:\n  a \\<noteq> r\n  proj2_Col a r t\n  t \\<noteq> a\n  ?a \\<noteq> ?r \\<Longrightarrow>\n  proj2_Col ?a ?r ?t =\n  (?t = ?a \\<or>\n   (\\<exists>i. ?t = proj2_abs (i *\\<^sub>R proj2_rep ?a + proj2_rep ?r)))\n\ngoal (1 subgoal):\n 1. \\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)", "by simp"], ["proof (state)\nthis:\n  \\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)\n\ngoal (1 subgoal):\n 1. t =\n    proj2_abs (proj2_Col_coeff a r t *\\<^sub>R proj2_rep a + proj2_rep r)", "thus \"t = proj2_abs ((proj2_Col_coeff a r t) *\\<^sub>R proj2_rep a + proj2_rep r)\""], ["proof (prove)\nusing this:\n  \\<exists>i. t = proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)\n\ngoal (1 subgoal):\n 1. t =\n    proj2_abs (proj2_Col_coeff a r t *\\<^sub>R proj2_rep a + proj2_rep r)", "by (unfold proj2_Col_coeff_def) (rule someI_ex)"], ["proof (state)\nthis:\n  t = proj2_abs (proj2_Col_coeff a r t *\\<^sub>R proj2_rep a + proj2_rep r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_Col_coeff_unique':\n  assumes \"a \\<noteq> 0\" and \"r \\<noteq> 0\" and \"proj2_abs a \\<noteq> proj2_abs r\"\n  and \"proj2_abs (i *\\<^sub>R a + r) = proj2_abs (j *\\<^sub>R a + r)\"\n  shows \"i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i = j", "from \\<open>a \\<noteq> 0\\<close> and \\<open>r \\<noteq> 0\\<close> and \\<open>proj2_abs a \\<noteq> proj2_abs r\\<close>\n    and dependent_proj2_abs [of a r _ 1]"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  r \\<noteq> 0\n  proj2_abs a \\<noteq> proj2_abs r\n  \\<lbrakk>a \\<noteq> 0; r \\<noteq> 0; ?i \\<noteq> 0 \\<or> 1 \\<noteq> 0;\n   ?i *\\<^sub>R a + 1 *\\<^sub>R r = 0\\<rbrakk>\n  \\<Longrightarrow> proj2_abs a = proj2_abs r", "have \"i *\\<^sub>R a + r \\<noteq> 0\" and \"j *\\<^sub>R a + r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  r \\<noteq> 0\n  proj2_abs a \\<noteq> proj2_abs r\n  \\<lbrakk>a \\<noteq> 0; r \\<noteq> 0; ?i \\<noteq> 0 \\<or> 1 \\<noteq> 0;\n   ?i *\\<^sub>R a + 1 *\\<^sub>R r = 0\\<rbrakk>\n  \\<Longrightarrow> proj2_abs a = proj2_abs r\n\ngoal (1 subgoal):\n 1. i *\\<^sub>R a + r \\<noteq> 0 &&& j *\\<^sub>R a + r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  i *\\<^sub>R a + r \\<noteq> 0\n  j *\\<^sub>R a + r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i = j", "with proj2_rep_abs2 [of \"i *\\<^sub>R a + r\"]\n    and proj2_rep_abs2 [of \"j *\\<^sub>R a + r\"]"], ["proof (chain)\npicking this:\n  i *\\<^sub>R a + r \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_rep (proj2_abs (i *\\<^sub>R a + r)) =\n     k *\\<^sub>R (i *\\<^sub>R a + r)\n  j *\\<^sub>R a + r \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_rep (proj2_abs (j *\\<^sub>R a + r)) =\n     k *\\<^sub>R (j *\\<^sub>R a + r)\n  i *\\<^sub>R a + r \\<noteq> 0\n  j *\\<^sub>R a + r \\<noteq> 0", "obtain k and l where \"k \\<noteq> 0\"\n    and \"proj2_rep (proj2_abs (i *\\<^sub>R a + r)) = k *\\<^sub>R (i *\\<^sub>R a + r)\"\n    and \"proj2_rep (proj2_abs (j *\\<^sub>R a + r)) = l *\\<^sub>R (j *\\<^sub>R a + r)\""], ["proof (prove)\nusing this:\n  i *\\<^sub>R a + r \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_rep (proj2_abs (i *\\<^sub>R a + r)) =\n     k *\\<^sub>R (i *\\<^sub>R a + r)\n  j *\\<^sub>R a + r \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_rep (proj2_abs (j *\\<^sub>R a + r)) =\n     k *\\<^sub>R (j *\\<^sub>R a + r)\n  i *\\<^sub>R a + r \\<noteq> 0\n  j *\\<^sub>R a + r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k l.\n        \\<lbrakk>k \\<noteq> 0;\n         proj2_rep (proj2_abs (i *\\<^sub>R a + r)) =\n         k *\\<^sub>R (i *\\<^sub>R a + r);\n         proj2_rep (proj2_abs (j *\\<^sub>R a + r)) =\n         l *\\<^sub>R (j *\\<^sub>R a + r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  proj2_rep (proj2_abs (i *\\<^sub>R a + r)) =\n  k *\\<^sub>R (i *\\<^sub>R a + r)\n  proj2_rep (proj2_abs (j *\\<^sub>R a + r)) =\n  l *\\<^sub>R (j *\\<^sub>R a + r)\n\ngoal (1 subgoal):\n 1. i = j", "with \\<open>proj2_abs (i *\\<^sub>R a + r) = proj2_abs (j *\\<^sub>R a + r)\\<close>"], ["proof (chain)\npicking this:\n  proj2_abs (i *\\<^sub>R a + r) = proj2_abs (j *\\<^sub>R a + r)\n  k \\<noteq> 0\n  proj2_rep (proj2_abs (i *\\<^sub>R a + r)) =\n  k *\\<^sub>R (i *\\<^sub>R a + r)\n  proj2_rep (proj2_abs (j *\\<^sub>R a + r)) =\n  l *\\<^sub>R (j *\\<^sub>R a + r)", "have \"(k * i) *\\<^sub>R a + k *\\<^sub>R r = (l * j) *\\<^sub>R a + l *\\<^sub>R r\""], ["proof (prove)\nusing this:\n  proj2_abs (i *\\<^sub>R a + r) = proj2_abs (j *\\<^sub>R a + r)\n  k \\<noteq> 0\n  proj2_rep (proj2_abs (i *\\<^sub>R a + r)) =\n  k *\\<^sub>R (i *\\<^sub>R a + r)\n  proj2_rep (proj2_abs (j *\\<^sub>R a + r)) =\n  l *\\<^sub>R (j *\\<^sub>R a + r)\n\ngoal (1 subgoal):\n 1. (k * i) *\\<^sub>R a + k *\\<^sub>R r =\n    (l * j) *\\<^sub>R a + l *\\<^sub>R r", "by (simp add: scaleR_right_distrib)"], ["proof (state)\nthis:\n  (k * i) *\\<^sub>R a + k *\\<^sub>R r = (l * j) *\\<^sub>R a + l *\\<^sub>R r\n\ngoal (1 subgoal):\n 1. i = j", "hence \"(k * i - l * j) *\\<^sub>R a + (k - l) *\\<^sub>R r = 0\""], ["proof (prove)\nusing this:\n  (k * i) *\\<^sub>R a + k *\\<^sub>R r = (l * j) *\\<^sub>R a + l *\\<^sub>R r\n\ngoal (1 subgoal):\n 1. (k * i - l * j) *\\<^sub>R a + (k - l) *\\<^sub>R r = 0", "by (simp add: algebra_simps vec_eq_iff)"], ["proof (state)\nthis:\n  (k * i - l * j) *\\<^sub>R a + (k - l) *\\<^sub>R r = 0\n\ngoal (1 subgoal):\n 1. i = j", "with \\<open>a \\<noteq> 0\\<close> and \\<open>r \\<noteq> 0\\<close> and \\<open>proj2_abs a \\<noteq> proj2_abs r\\<close>\n    and dependent_proj2_abs [of a r \"k * i - l * j\" \"k - l\"]"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  r \\<noteq> 0\n  proj2_abs a \\<noteq> proj2_abs r\n  \\<lbrakk>a \\<noteq> 0; r \\<noteq> 0;\n   k * i - l * j \\<noteq> 0 \\<or> k - l \\<noteq> 0;\n   (k * i - l * j) *\\<^sub>R a + (k - l) *\\<^sub>R r = 0\\<rbrakk>\n  \\<Longrightarrow> proj2_abs a = proj2_abs r\n  (k * i - l * j) *\\<^sub>R a + (k - l) *\\<^sub>R r = 0", "have \"k * i - l * j = 0\" and \"k - l = 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  r \\<noteq> 0\n  proj2_abs a \\<noteq> proj2_abs r\n  \\<lbrakk>a \\<noteq> 0; r \\<noteq> 0;\n   k * i - l * j \\<noteq> 0 \\<or> k - l \\<noteq> 0;\n   (k * i - l * j) *\\<^sub>R a + (k - l) *\\<^sub>R r = 0\\<rbrakk>\n  \\<Longrightarrow> proj2_abs a = proj2_abs r\n  (k * i - l * j) *\\<^sub>R a + (k - l) *\\<^sub>R r = 0\n\ngoal (1 subgoal):\n 1. k * i - l * j = 0 &&& k - l = 0", "by auto"], ["proof (state)\nthis:\n  k * i - l * j = 0\n  k - l = 0\n\ngoal (1 subgoal):\n 1. i = j", "from \\<open>k - l = 0\\<close>"], ["proof (chain)\npicking this:\n  k - l = 0", "have \"k = l\""], ["proof (prove)\nusing this:\n  k - l = 0\n\ngoal (1 subgoal):\n 1. k = l", "by simp"], ["proof (state)\nthis:\n  k = l\n\ngoal (1 subgoal):\n 1. i = j", "with \\<open>k * i - l * j = 0\\<close>"], ["proof (chain)\npicking this:\n  k * i - l * j = 0\n  k = l", "have \"k * i = k * j\""], ["proof (prove)\nusing this:\n  k * i - l * j = 0\n  k = l\n\ngoal (1 subgoal):\n 1. k * i = k * j", "by simp"], ["proof (state)\nthis:\n  k * i = k * j\n\ngoal (1 subgoal):\n 1. i = j", "with \\<open>k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  k * i = k * j", "show \"i = j\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k * i = k * j\n\ngoal (1 subgoal):\n 1. i = j", "by simp"], ["proof (state)\nthis:\n  i = j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_Col_coeff_unique:\n  assumes \"a \\<noteq> r\"\n  and \"proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r)\n  = proj2_abs (j *\\<^sub>R proj2_rep a + proj2_rep r)\"\n  shows \"i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i = j", "let ?a' = \"proj2_rep a\""], ["proof (state)\ngoal (1 subgoal):\n 1. i = j", "let ?r' = \"proj2_rep r\""], ["proof (state)\ngoal (1 subgoal):\n 1. i = j", "have \"?a' \\<noteq> 0\" and \"?r' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep a \\<noteq> 0 &&& proj2_rep r \\<noteq> 0", "by (rule proj2_rep_non_zero)+"], ["proof (state)\nthis:\n  proj2_rep a \\<noteq> 0\n  proj2_rep r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i = j", "from \\<open>a \\<noteq> r\\<close>"], ["proof (chain)\npicking this:\n  a \\<noteq> r", "have \"proj2_abs ?a' \\<noteq> proj2_abs ?r'\""], ["proof (prove)\nusing this:\n  a \\<noteq> r\n\ngoal (1 subgoal):\n 1. proj2_abs (proj2_rep a) \\<noteq> proj2_abs (proj2_rep r)", "by (simp add: proj2_abs_rep)"], ["proof (state)\nthis:\n  proj2_abs (proj2_rep a) \\<noteq> proj2_abs (proj2_rep r)\n\ngoal (1 subgoal):\n 1. i = j", "with \\<open>?a' \\<noteq> 0\\<close> and \\<open>?r' \\<noteq> 0\\<close>\n    and \\<open>proj2_abs (i *\\<^sub>R ?a' + ?r') = proj2_abs (j *\\<^sub>R ?a' + ?r')\\<close>\n    and proj2_Col_coeff_unique'"], ["proof (chain)\npicking this:\n  proj2_rep a \\<noteq> 0\n  proj2_rep r \\<noteq> 0\n  proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r) =\n  proj2_abs (j *\\<^sub>R proj2_rep a + proj2_rep r)\n  \\<lbrakk>?a \\<noteq> 0; ?r \\<noteq> 0; proj2_abs ?a \\<noteq> proj2_abs ?r;\n   proj2_abs (?i *\\<^sub>R ?a + ?r) =\n   proj2_abs (?j *\\<^sub>R ?a + ?r)\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j\n  proj2_abs (proj2_rep a) \\<noteq> proj2_abs (proj2_rep r)", "show \"i = j\""], ["proof (prove)\nusing this:\n  proj2_rep a \\<noteq> 0\n  proj2_rep r \\<noteq> 0\n  proj2_abs (i *\\<^sub>R proj2_rep a + proj2_rep r) =\n  proj2_abs (j *\\<^sub>R proj2_rep a + proj2_rep r)\n  \\<lbrakk>?a \\<noteq> 0; ?r \\<noteq> 0; proj2_abs ?a \\<noteq> proj2_abs ?r;\n   proj2_abs (?i *\\<^sub>R ?a + ?r) =\n   proj2_abs (?j *\\<^sub>R ?a + ?r)\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j\n  proj2_abs (proj2_rep a) \\<noteq> proj2_abs (proj2_rep r)\n\ngoal (1 subgoal):\n 1. i = j", "by simp"], ["proof (state)\nthis:\n  i = j\n\ngoal:\nNo subgoals!", "qed"], ["", "datatype proj2_line = P2L proj2"], ["", "definition L2P :: \"proj2_line \\<Rightarrow> proj2\" where\n  \"L2P l \\<equiv> case l of P2L p \\<Rightarrow> p\""], ["", "lemma L2P_P2L [simp]: \"L2P (P2L p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2P (P2L p) = p", "unfolding L2P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case P2L p of P2L p \\<Rightarrow> p) = p", "by simp"], ["", "lemma P2L_L2P [simp]: \"P2L (L2P l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2L (L2P l) = l", "by (induct l) simp"], ["", "lemma L2P_inj [simp]:\n  assumes \"L2P l = L2P m\"\n  shows \"l = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = m", "using P2L_L2P [of l] and assms"], ["proof (prove)\nusing this:\n  P2L (L2P l) = l\n  L2P l = L2P m\n\ngoal (1 subgoal):\n 1. l = m", "by simp"], ["", "lemma P2L_to_L2P: \"P2L p = l \\<longleftrightarrow> p = L2P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P2L p = l) = (p = L2P l)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. P2L p = l \\<Longrightarrow> p = L2P l\n 2. p = L2P l \\<Longrightarrow> P2L p = l", "assume \"P2L p = l\""], ["proof (state)\nthis:\n  P2L p = l\n\ngoal (2 subgoals):\n 1. P2L p = l \\<Longrightarrow> p = L2P l\n 2. p = L2P l \\<Longrightarrow> P2L p = l", "hence \"L2P (P2L p) = L2P l\""], ["proof (prove)\nusing this:\n  P2L p = l\n\ngoal (1 subgoal):\n 1. L2P (P2L p) = L2P l", "by simp"], ["proof (state)\nthis:\n  L2P (P2L p) = L2P l\n\ngoal (2 subgoals):\n 1. P2L p = l \\<Longrightarrow> p = L2P l\n 2. p = L2P l \\<Longrightarrow> P2L p = l", "thus \"p = L2P l\""], ["proof (prove)\nusing this:\n  L2P (P2L p) = L2P l\n\ngoal (1 subgoal):\n 1. p = L2P l", "by simp"], ["proof (state)\nthis:\n  p = L2P l\n\ngoal (1 subgoal):\n 1. p = L2P l \\<Longrightarrow> P2L p = l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = L2P l \\<Longrightarrow> P2L p = l", "assume \"p = L2P l\""], ["proof (state)\nthis:\n  p = L2P l\n\ngoal (1 subgoal):\n 1. p = L2P l \\<Longrightarrow> P2L p = l", "thus \"P2L p = l\""], ["proof (prove)\nusing this:\n  p = L2P l\n\ngoal (1 subgoal):\n 1. P2L p = l", "by simp"], ["proof (state)\nthis:\n  P2L p = l\n\ngoal:\nNo subgoals!", "qed"], ["", "definition proj2_line_abs :: \"real^3 \\<Rightarrow> proj2_line\" where\n  \"proj2_line_abs v \\<equiv> P2L (proj2_abs v)\""], ["", "definition proj2_line_rep :: \"proj2_line \\<Rightarrow> real^3\" where\n  \"proj2_line_rep l \\<equiv> proj2_rep (L2P l)\""], ["", "lemma proj2_line_rep_abs:\n  assumes \"v \\<noteq> 0\"\n  shows \"\\<exists> k. k \\<noteq> 0 \\<and> proj2_line_rep (proj2_line_abs v) = k *\\<^sub>R v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and> proj2_line_rep (proj2_line_abs v) = k *\\<^sub>R v", "unfolding proj2_line_rep_def and proj2_line_abs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       proj2_rep (L2P (P2L (proj2_abs v))) = k *\\<^sub>R v", "using proj2_rep_abs2 and \\<open>v \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       proj2_rep (L2P (P2L (proj2_abs v))) = k *\\<^sub>R v", "by simp"], ["", "lemma proj2_line_abs_rep [simp]: \"proj2_line_abs (proj2_line_rep l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_line_abs (proj2_line_rep l) = l", "unfolding proj2_line_abs_def and proj2_line_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P2L (proj2_abs (proj2_rep (L2P l))) = l", "by (simp add: proj2_abs_rep)"], ["", "lemma proj2_line_rep_non_zero: \"proj2_line_rep l \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_line_rep l \\<noteq> 0", "unfolding proj2_line_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep (L2P l) \\<noteq> 0", "using proj2_rep_non_zero"], ["proof (prove)\nusing this:\n  proj2_rep ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_rep (L2P l) \\<noteq> 0", "by simp"], ["", "lemma proj2_line_rep_dependent:\n  assumes \"i *\\<^sub>R proj2_line_rep l + j *\\<^sub>R proj2_line_rep m = 0\"\n  and \"i \\<noteq> 0 \\<or> j \\<noteq> 0\"\n  shows \"l = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = m", "using proj2_rep_dependent [of i \"L2P l\" j \"L2P m\"] and assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>i *\\<^sub>R proj2_rep (L2P l) + j *\\<^sub>R proj2_rep (L2P m) =\n           0;\n   i \\<noteq> 0 \\<or> j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> L2P l = L2P m\n  i *\\<^sub>R proj2_line_rep l + j *\\<^sub>R proj2_line_rep m = 0\n  i \\<noteq> 0 \\<or> j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. l = m", "unfolding proj2_line_rep_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>i *\\<^sub>R proj2_rep (L2P l) + j *\\<^sub>R proj2_rep (L2P m) =\n           0;\n   i \\<noteq> 0 \\<or> j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> L2P l = L2P m\n  i *\\<^sub>R proj2_rep (L2P l) + j *\\<^sub>R proj2_rep (L2P m) = 0\n  i \\<noteq> 0 \\<or> j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. l = m", "by simp"], ["", "lemma proj2_line_abs_mult:\n  assumes \"k \\<noteq> 0\"\n  shows \"proj2_line_abs (k *\\<^sub>R v) = proj2_line_abs v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_line_abs (k *\\<^sub>R v) = proj2_line_abs v", "unfolding proj2_line_abs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P2L (proj2_abs (k *\\<^sub>R v)) = P2L (proj2_abs v)", "using \\<open>k \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. P2L (proj2_abs (k *\\<^sub>R v)) = P2L (proj2_abs v)", "by (subst proj2_abs_mult) simp_all"], ["", "lemma proj2_line_abs_abs_mult:\n  assumes \"proj2_line_abs v = proj2_line_abs w\" and \"w \\<noteq> 0\"\n  shows \"\\<exists> k. v = k *\\<^sub>R w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. v = k *\\<^sub>R w", "using assms"], ["proof (prove)\nusing this:\n  proj2_line_abs v = proj2_line_abs w\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. v = k *\\<^sub>R w", "by (unfold proj2_line_abs_def) (simp add: proj2_abs_abs_mult)"], ["", "definition proj2_incident :: \"proj2 \\<Rightarrow> proj2_line \\<Rightarrow> bool\" where\n  \"proj2_incident p l \\<equiv> (proj2_rep p) \\<bullet> (proj2_line_rep l) = 0\""], ["", "lemma proj2_points_define_line:\n  shows \"\\<exists> l. proj2_incident p l \\<and> proj2_incident q l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "let ?p' = \"proj2_rep p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "let ?q' = \"proj2_rep q\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "let ?B = \"{?p', ?q'}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "from card_suc_ge_insert [of ?p' \"{?q'}\"]"], ["proof (chain)\npicking this:\n  card {proj2_rep p, proj2_rep q} \\<le> card {proj2_rep q} + 1", "have \"card ?B \\<le> 2\""], ["proof (prove)\nusing this:\n  card {proj2_rep p, proj2_rep q} \\<le> card {proj2_rep q} + 1\n\ngoal (1 subgoal):\n 1. card {proj2_rep p, proj2_rep q} \\<le> 2", "by simp"], ["proof (state)\nthis:\n  card {proj2_rep p, proj2_rep q} \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "with dim_le_card' [of ?B]"], ["proof (chain)\npicking this:\n  finite {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  dim {proj2_rep p, proj2_rep q} \\<le> card {proj2_rep p, proj2_rep q}\n  card {proj2_rep p, proj2_rep q} \\<le> 2", "have \"dim ?B < 3\""], ["proof (prove)\nusing this:\n  finite {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  dim {proj2_rep p, proj2_rep q} \\<le> card {proj2_rep p, proj2_rep q}\n  card {proj2_rep p, proj2_rep q} \\<le> 2\n\ngoal (1 subgoal):\n 1. dim {proj2_rep p, proj2_rep q} < 3", "by simp"], ["proof (state)\nthis:\n  dim {proj2_rep p, proj2_rep q} < 3\n\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "with lowdim_subset_hyperplane [of ?B]"], ["proof (chain)\npicking this:\n  dim {proj2_rep p, proj2_rep q} < DIM((real, 3) vec) \\<Longrightarrow>\n  \\<exists>a.\n     a \\<noteq> 0 \\<and>\n     span {proj2_rep p, proj2_rep q} \\<subseteq> {x. a \\<bullet> x = 0}\n  dim {proj2_rep p, proj2_rep q} < 3", "obtain l' where \"l' \\<noteq> 0\" and \"span ?B \\<subseteq> {x. l' \\<bullet> x = 0}\""], ["proof (prove)\nusing this:\n  dim {proj2_rep p, proj2_rep q} < DIM((real, 3) vec) \\<Longrightarrow>\n  \\<exists>a.\n     a \\<noteq> 0 \\<and>\n     span {proj2_rep p, proj2_rep q} \\<subseteq> {x. a \\<bullet> x = 0}\n  dim {proj2_rep p, proj2_rep q} < 3\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l' \\<noteq> 0;\n         span {proj2_rep p, proj2_rep q}\n         \\<subseteq> {x. l' \\<bullet> x = 0}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l' \\<noteq> 0\n  span {proj2_rep p, proj2_rep q} \\<subseteq> {x. l' \\<bullet> x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "let ?l = \"proj2_line_abs l'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "let ?l'' = \"proj2_line_rep ?l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "from proj2_line_rep_abs and \\<open>l' \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and> proj2_line_rep (proj2_line_abs ?v) = k *\\<^sub>R ?v\n  l' \\<noteq> 0", "obtain k where \"?l'' = k *\\<^sub>R l'\""], ["proof (prove)\nusing this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and> proj2_line_rep (proj2_line_abs ?v) = k *\\<^sub>R ?v\n  l' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        proj2_line_rep (proj2_line_abs l') =\n        k *\\<^sub>R l' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  proj2_line_rep (proj2_line_abs l') = k *\\<^sub>R l'\n\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "have \"?p' \\<in> ?B\" and \"?q' \\<in> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep p \\<in> {proj2_rep p, proj2_rep q} &&&\n    proj2_rep q \\<in> {proj2_rep p, proj2_rep q}", "by simp_all"], ["proof (state)\nthis:\n  proj2_rep p \\<in> {proj2_rep p, proj2_rep q}\n  proj2_rep q \\<in> {proj2_rep p, proj2_rep q}\n\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "with span_superset [of ?B] and \\<open>span ?B \\<subseteq> {x. l' \\<bullet> x = 0}\\<close>"], ["proof (chain)\npicking this:\n  {proj2_rep p, proj2_rep q} \\<subseteq> span {proj2_rep p, proj2_rep q}\n  span {proj2_rep p, proj2_rep q} \\<subseteq> {x. l' \\<bullet> x = 0}\n  proj2_rep p \\<in> {proj2_rep p, proj2_rep q}\n  proj2_rep q \\<in> {proj2_rep p, proj2_rep q}", "have \"l' \\<bullet> ?p' = 0\" and \"l' \\<bullet> ?q' = 0\""], ["proof (prove)\nusing this:\n  {proj2_rep p, proj2_rep q} \\<subseteq> span {proj2_rep p, proj2_rep q}\n  span {proj2_rep p, proj2_rep q} \\<subseteq> {x. l' \\<bullet> x = 0}\n  proj2_rep p \\<in> {proj2_rep p, proj2_rep q}\n  proj2_rep q \\<in> {proj2_rep p, proj2_rep q}\n\ngoal (1 subgoal):\n 1. l' \\<bullet> proj2_rep p = 0 &&& l' \\<bullet> proj2_rep q = 0", "by auto"], ["proof (state)\nthis:\n  l' \\<bullet> proj2_rep p = 0\n  l' \\<bullet> proj2_rep q = 0\n\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "hence \"?p' \\<bullet> l' = 0\" and \"?q' \\<bullet> l' = 0\""], ["proof (prove)\nusing this:\n  l' \\<bullet> proj2_rep p = 0\n  l' \\<bullet> proj2_rep q = 0\n\ngoal (1 subgoal):\n 1. proj2_rep p \\<bullet> l' = 0 &&& proj2_rep q \\<bullet> l' = 0", "by (simp_all add: inner_commute)"], ["proof (state)\nthis:\n  proj2_rep p \\<bullet> l' = 0\n  proj2_rep q \\<bullet> l' = 0\n\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "with dot_scaleR_mult(2) [of _ k l'] and \\<open>?l'' = k *\\<^sub>R l'\\<close>"], ["proof (chain)\npicking this:\n  ?a \\<bullet> k *\\<^sub>R l' = k * (?a \\<bullet> l')\n  proj2_line_rep (proj2_line_abs l') = k *\\<^sub>R l'\n  proj2_rep p \\<bullet> l' = 0\n  proj2_rep q \\<bullet> l' = 0", "have \"proj2_incident p ?l \\<and> proj2_incident q ?l\""], ["proof (prove)\nusing this:\n  ?a \\<bullet> k *\\<^sub>R l' = k * (?a \\<bullet> l')\n  proj2_line_rep (proj2_line_abs l') = k *\\<^sub>R l'\n  proj2_rep p \\<bullet> l' = 0\n  proj2_rep q \\<bullet> l' = 0\n\ngoal (1 subgoal):\n 1. proj2_incident p (proj2_line_abs l') \\<and>\n    proj2_incident q (proj2_line_abs l')", "unfolding proj2_incident_def"], ["proof (prove)\nusing this:\n  ?a \\<bullet> k *\\<^sub>R l' = k * (?a \\<bullet> l')\n  proj2_line_rep (proj2_line_abs l') = k *\\<^sub>R l'\n  proj2_rep p \\<bullet> l' = 0\n  proj2_rep q \\<bullet> l' = 0\n\ngoal (1 subgoal):\n 1. proj2_rep p \\<bullet> proj2_line_rep (proj2_line_abs l') = 0 \\<and>\n    proj2_rep q \\<bullet> proj2_line_rep (proj2_line_abs l') = 0", "by simp"], ["proof (state)\nthis:\n  proj2_incident p (proj2_line_abs l') \\<and>\n  proj2_incident q (proj2_line_abs l')\n\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "thus \"\\<exists> l. proj2_incident p l \\<and> proj2_incident q l\""], ["proof (prove)\nusing this:\n  proj2_incident p (proj2_line_abs l') \\<and>\n  proj2_incident q (proj2_line_abs l')\n\ngoal (1 subgoal):\n 1. \\<exists>l. proj2_incident p l \\<and> proj2_incident q l", "by auto"], ["proof (state)\nthis:\n  \\<exists>l. proj2_incident p l \\<and> proj2_incident q l\n\ngoal:\nNo subgoals!", "qed"], ["", "definition proj2_line_through :: \"proj2 \\<Rightarrow> proj2 \\<Rightarrow> proj2_line\" where\n  \"proj2_line_through p q \\<equiv> \\<some> l. proj2_incident p l \\<and> proj2_incident q l\""], ["", "lemma proj2_line_through_incident:\n  shows \"proj2_incident p (proj2_line_through p q)\"\n  and \"proj2_incident q (proj2_line_through p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident p (proj2_line_through p q) &&&\n    proj2_incident q (proj2_line_through p q)", "unfolding proj2_line_through_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident p\n     (SOME l. proj2_incident p l \\<and> proj2_incident q l) &&&\n    proj2_incident q (SOME l. proj2_incident p l \\<and> proj2_incident q l)", "using proj2_points_define_line\n    and someI_ex [of \"\\<lambda> l. proj2_incident p l \\<and> proj2_incident q l\"]"], ["proof (prove)\nusing this:\n  \\<exists>l. proj2_incident ?p l \\<and> proj2_incident ?q l\n  \\<exists>x. proj2_incident p x \\<and> proj2_incident q x \\<Longrightarrow>\n  proj2_incident p\n   (SOME x. proj2_incident p x \\<and> proj2_incident q x) \\<and>\n  proj2_incident q (SOME x. proj2_incident p x \\<and> proj2_incident q x)\n\ngoal (1 subgoal):\n 1. proj2_incident p\n     (SOME l. proj2_incident p l \\<and> proj2_incident q l) &&&\n    proj2_incident q (SOME l. proj2_incident p l \\<and> proj2_incident q l)", "by simp_all"], ["", "lemma proj2_line_through_unique:\n  assumes \"p \\<noteq> q\" and \"proj2_incident p l\" and \"proj2_incident q l\"\n  shows \"l = proj2_line_through p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "let ?l' = \"proj2_line_rep l\""], ["proof (state)\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "let ?m = \"proj2_line_through p q\""], ["proof (state)\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "let ?m' = \"proj2_line_rep ?m\""], ["proof (state)\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "let ?p' = \"proj2_rep p\""], ["proof (state)\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "let ?q' = \"proj2_rep q\""], ["proof (state)\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "let ?A = \"{?p', ?q'}\""], ["proof (state)\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "let ?B = \"insert ?m' ?A\""], ["proof (state)\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "from proj2_line_through_incident"], ["proof (chain)\npicking this:\n  proj2_incident ?p (proj2_line_through ?p ?q)\n  proj2_incident ?q (proj2_line_through ?p ?q)", "have \"proj2_incident p ?m\" and \"proj2_incident q ?m\""], ["proof (prove)\nusing this:\n  proj2_incident ?p (proj2_line_through ?p ?q)\n  proj2_incident ?q (proj2_line_through ?p ?q)\n\ngoal (1 subgoal):\n 1. proj2_incident p (proj2_line_through p q) &&&\n    proj2_incident q (proj2_line_through p q)", "by simp_all"], ["proof (state)\nthis:\n  proj2_incident p (proj2_line_through p q)\n  proj2_incident q (proj2_line_through p q)\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "with \\<open>proj2_incident p l\\<close> and \\<open>proj2_incident q l\\<close>"], ["proof (chain)\npicking this:\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident p (proj2_line_through p q)\n  proj2_incident q (proj2_line_through p q)", "have ortho: \"\\<And>w. w\\<in>?A \\<Longrightarrow> orthogonal ?m' w\" \"\\<And>w. w\\<in>?A \\<Longrightarrow> orthogonal ?l' w\""], ["proof (prove)\nusing this:\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident p (proj2_line_through p q)\n  proj2_incident q (proj2_line_through p q)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n        orthogonal (proj2_line_rep (proj2_line_through p q)) w) &&&\n    (\\<And>w.\n        w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n        orthogonal (proj2_line_rep l) w)", "unfolding proj2_incident_def and orthogonal_def"], ["proof (prove)\nusing this:\n  proj2_rep p \\<bullet> proj2_line_rep l = 0\n  proj2_rep q \\<bullet> proj2_line_rep l = 0\n  proj2_rep p \\<bullet> proj2_line_rep (proj2_line_through p q) = 0\n  proj2_rep q \\<bullet> proj2_line_rep (proj2_line_through p q) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n        proj2_line_rep (proj2_line_through p q) \\<bullet> w = 0) &&&\n    (\\<And>w.\n        w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n        proj2_line_rep l \\<bullet> w = 0)", "by (metis empty_iff inner_commute insert_iff)+"], ["proof (state)\nthis:\n  ?w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  orthogonal (proj2_line_rep (proj2_line_through p q)) ?w\n  ?w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  orthogonal (proj2_line_rep l) ?w\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "from proj2_rep_independent and \\<open>p \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  ?p \\<noteq> ?q \\<Longrightarrow> independent {proj2_rep ?p, proj2_rep ?q}\n  p \\<noteq> q", "have \"independent ?A\""], ["proof (prove)\nusing this:\n  ?p \\<noteq> ?q \\<Longrightarrow> independent {proj2_rep ?p, proj2_rep ?q}\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. independent {proj2_rep p, proj2_rep q}", "by simp"], ["proof (state)\nthis:\n  independent {proj2_rep p, proj2_rep q}\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "from proj2_line_rep_non_zero"], ["proof (chain)\npicking this:\n  proj2_line_rep ?l \\<noteq> 0", "have \"?m' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  proj2_line_rep ?l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_line_rep (proj2_line_through p q) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  proj2_line_rep (proj2_line_through p q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "with orthogonal_independent \\<open>independent ?A\\<close> ortho"], ["proof (chain)\npicking this:\n  \\<lbrakk>independent ?S; ?v \\<noteq> 0;\n   \\<And>w. w \\<in> ?S \\<Longrightarrow> orthogonal ?v w\\<rbrakk>\n  \\<Longrightarrow> independent (insert ?v ?S)\n  independent {proj2_rep p, proj2_rep q}\n  ?w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  orthogonal (proj2_line_rep (proj2_line_through p q)) ?w\n  ?w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  orthogonal (proj2_line_rep l) ?w\n  proj2_line_rep (proj2_line_through p q) \\<noteq> 0", "have \"independent ?B\""], ["proof (prove)\nusing this:\n  \\<lbrakk>independent ?S; ?v \\<noteq> 0;\n   \\<And>w. w \\<in> ?S \\<Longrightarrow> orthogonal ?v w\\<rbrakk>\n  \\<Longrightarrow> independent (insert ?v ?S)\n  independent {proj2_rep p, proj2_rep q}\n  ?w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  orthogonal (proj2_line_rep (proj2_line_through p q)) ?w\n  ?w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  orthogonal (proj2_line_rep l) ?w\n  proj2_line_rep (proj2_line_through p q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. independent\n     {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q}", "by auto"], ["proof (state)\nthis:\n  independent\n   {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q}\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "from proj2_rep_inj and \\<open>p \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  inj proj2_rep\n  p \\<noteq> q", "have \"?p' \\<noteq> ?q'\""], ["proof (prove)\nusing this:\n  inj proj2_rep\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. proj2_rep p \\<noteq> proj2_rep q", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV. proj2_rep x = proj2_rep y \\<longrightarrow> x = y\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. proj2_rep p \\<noteq> proj2_rep q", "by auto"], ["proof (state)\nthis:\n  proj2_rep p \\<noteq> proj2_rep q\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "hence \"card ?A = 2\""], ["proof (prove)\nusing this:\n  proj2_rep p \\<noteq> proj2_rep q\n\ngoal (1 subgoal):\n 1. card {proj2_rep p, proj2_rep q} = 2", "by simp"], ["proof (state)\nthis:\n  card {proj2_rep p, proj2_rep q} = 2\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "moreover"], ["proof (state)\nthis:\n  card {proj2_rep p, proj2_rep q} = 2\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "have \"?m' \\<notin> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_line_rep (proj2_line_through p q)\n    \\<notin> {proj2_rep p, proj2_rep q}", "using ortho(1) orthogonal_self proj2_line_rep_non_zero"], ["proof (prove)\nusing this:\n  ?w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  orthogonal (proj2_line_rep (proj2_line_through p q)) ?w\n  orthogonal ?x ?x = (?x = (0::?'a))\n  proj2_line_rep ?l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_line_rep (proj2_line_through p q)\n    \\<notin> {proj2_rep p, proj2_rep q}", "by auto"], ["proof (state)\nthis:\n  proj2_line_rep (proj2_line_through p q)\n  \\<notin> {proj2_rep p, proj2_rep q}\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "ultimately"], ["proof (chain)\npicking this:\n  card {proj2_rep p, proj2_rep q} = 2\n  proj2_line_rep (proj2_line_through p q)\n  \\<notin> {proj2_rep p, proj2_rep q}", "have \"card ?B = 3\""], ["proof (prove)\nusing this:\n  card {proj2_rep p, proj2_rep q} = 2\n  proj2_line_rep (proj2_line_through p q)\n  \\<notin> {proj2_rep p, proj2_rep q}\n\ngoal (1 subgoal):\n 1. card\n     {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q} =\n    3", "by simp"], ["proof (state)\nthis:\n  card {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q} =\n  3\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "with independent_is_basis [of ?B] and \\<open>independent ?B\\<close>"], ["proof (chain)\npicking this:\n  (independent\n    {proj2_line_rep (proj2_line_through p q), proj2_rep p,\n     proj2_rep q} \\<and>\n   card\n    {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q} =\n   CARD(3)) =\n  is_basis\n   {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q}\n  independent\n   {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q}\n  card {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q} =\n  3", "have \"is_basis ?B\""], ["proof (prove)\nusing this:\n  (independent\n    {proj2_line_rep (proj2_line_through p q), proj2_rep p,\n     proj2_rep q} \\<and>\n   card\n    {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q} =\n   CARD(3)) =\n  is_basis\n   {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q}\n  independent\n   {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q}\n  card {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q} =\n  3\n\ngoal (1 subgoal):\n 1. is_basis\n     {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q}", "by simp"], ["proof (state)\nthis:\n  is_basis\n   {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q}\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "with basis_expand"], ["proof (chain)\npicking this:\n  is_basis ?B \\<Longrightarrow>\n  \\<exists>c. ?v = (\\<Sum>w\\<in>?B. c w *\\<^sub>R w)\n  is_basis\n   {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q}", "obtain c where \"?l' = (\\<Sum> v\\<in>?B. c v *\\<^sub>R v)\""], ["proof (prove)\nusing this:\n  is_basis ?B \\<Longrightarrow>\n  \\<exists>c. ?v = (\\<Sum>w\\<in>?B. c w *\\<^sub>R w)\n  is_basis\n   {proj2_line_rep (proj2_line_through p q), proj2_rep p, proj2_rep q}\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        proj2_line_rep l =\n        (\\<Sum>v\\<in>{proj2_line_rep (proj2_line_through p q), proj2_rep p,\n                      proj2_rep q}.\n           c v *\\<^sub>R v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  proj2_line_rep l =\n  (\\<Sum>v\\<in>{proj2_line_rep (proj2_line_through p q), proj2_rep p,\n                proj2_rep q}.\n     c v *\\<^sub>R v)\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "let ?l'' = \"?l' - c ?m' *\\<^sub>R ?m'\""], ["proof (state)\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "from \\<open>?l' = (\\<Sum> v\\<in>?B. c v *\\<^sub>R v)\\<close> and \\<open>?m' \\<notin> ?A\\<close>"], ["proof (chain)\npicking this:\n  proj2_line_rep l =\n  (\\<Sum>v\\<in>{proj2_line_rep (proj2_line_through p q), proj2_rep p,\n                proj2_rep q}.\n     c v *\\<^sub>R v)\n  proj2_line_rep (proj2_line_through p q)\n  \\<notin> {proj2_rep p, proj2_rep q}", "have \"?l'' = (\\<Sum> v\\<in>?A. c v *\\<^sub>R v)\""], ["proof (prove)\nusing this:\n  proj2_line_rep l =\n  (\\<Sum>v\\<in>{proj2_line_rep (proj2_line_through p q), proj2_rep p,\n                proj2_rep q}.\n     c v *\\<^sub>R v)\n  proj2_line_rep (proj2_line_through p q)\n  \\<notin> {proj2_rep p, proj2_rep q}\n\ngoal (1 subgoal):\n 1. proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q) =\n    (\\<Sum>v\\<in>{proj2_rep p, proj2_rep q}. c v *\\<^sub>R v)", "by simp"], ["proof (state)\nthis:\n  proj2_line_rep l -\n  c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n  proj2_line_rep (proj2_line_through p q) =\n  (\\<Sum>v\\<in>{proj2_rep p, proj2_rep q}. c v *\\<^sub>R v)\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "with orthogonal_sum [of ?A] ortho"], ["proof (chain)\npicking this:\n  (\\<And>w.\n      w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n      orthogonal ?v w) \\<Longrightarrow>\n  orthogonal ?v (\\<Sum>w\\<in>{proj2_rep p, proj2_rep q}. ?c w *s w)\n  ?w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  orthogonal (proj2_line_rep (proj2_line_through p q)) ?w\n  ?w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  orthogonal (proj2_line_rep l) ?w\n  proj2_line_rep l -\n  c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n  proj2_line_rep (proj2_line_through p q) =\n  (\\<Sum>v\\<in>{proj2_rep p, proj2_rep q}. c v *\\<^sub>R v)", "have \"orthogonal ?l' ?l''\" and \"orthogonal ?m' ?l''\""], ["proof (prove)\nusing this:\n  (\\<And>w.\n      w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n      orthogonal ?v w) \\<Longrightarrow>\n  orthogonal ?v (\\<Sum>w\\<in>{proj2_rep p, proj2_rep q}. ?c w *s w)\n  ?w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  orthogonal (proj2_line_rep (proj2_line_through p q)) ?w\n  ?w \\<in> {proj2_rep p, proj2_rep q} \\<Longrightarrow>\n  orthogonal (proj2_line_rep l) ?w\n  proj2_line_rep l -\n  c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n  proj2_line_rep (proj2_line_through p q) =\n  (\\<Sum>v\\<in>{proj2_rep p, proj2_rep q}. c v *\\<^sub>R v)\n\ngoal (1 subgoal):\n 1. orthogonal (proj2_line_rep l)\n     (proj2_line_rep l -\n      c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n      proj2_line_rep (proj2_line_through p q)) &&&\n    orthogonal (proj2_line_rep (proj2_line_through p q))\n     (proj2_line_rep l -\n      c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n      proj2_line_rep (proj2_line_through p q))", "by (simp_all add: scalar_equiv)"], ["proof (state)\nthis:\n  orthogonal (proj2_line_rep l)\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n  orthogonal (proj2_line_rep (proj2_line_through p q))\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "from \\<open>orthogonal ?m' ?l''\\<close>"], ["proof (chain)\npicking this:\n  orthogonal (proj2_line_rep (proj2_line_through p q))\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))", "have \"orthogonal (c ?m' *\\<^sub>R ?m') ?l''\""], ["proof (prove)\nusing this:\n  orthogonal (proj2_line_rep (proj2_line_through p q))\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n\ngoal (1 subgoal):\n 1. orthogonal\n     (c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n      proj2_line_rep (proj2_line_through p q))\n     (proj2_line_rep l -\n      c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n      proj2_line_rep (proj2_line_through p q))", "by (simp add: orthogonal_clauses)"], ["proof (state)\nthis:\n  orthogonal\n   (c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "with \\<open>orthogonal ?l' ?l''\\<close>"], ["proof (chain)\npicking this:\n  orthogonal (proj2_line_rep l)\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n  orthogonal\n   (c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))", "have \"orthogonal ?l'' ?l''\""], ["proof (prove)\nusing this:\n  orthogonal (proj2_line_rep l)\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n  orthogonal\n   (c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n\ngoal (1 subgoal):\n 1. orthogonal\n     (proj2_line_rep l -\n      c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n      proj2_line_rep (proj2_line_through p q))\n     (proj2_line_rep l -\n      c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n      proj2_line_rep (proj2_line_through p q))", "by (simp add: orthogonal_clauses)"], ["proof (state)\nthis:\n  orthogonal\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "with orthogonal_self_eq_0 [of ?l'']"], ["proof (chain)\npicking this:\n  orthogonal\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q)) \\<Longrightarrow>\n  proj2_line_rep l -\n  c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n  proj2_line_rep (proj2_line_through p q) =\n  0\n  orthogonal\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))", "have \"?l'' = 0\""], ["proof (prove)\nusing this:\n  orthogonal\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q)) \\<Longrightarrow>\n  proj2_line_rep l -\n  c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n  proj2_line_rep (proj2_line_through p q) =\n  0\n  orthogonal\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n   (proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q))\n\ngoal (1 subgoal):\n 1. proj2_line_rep l -\n    c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n    proj2_line_rep (proj2_line_through p q) =\n    0", "by simp"], ["proof (state)\nthis:\n  proj2_line_rep l -\n  c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n  proj2_line_rep (proj2_line_through p q) =\n  0\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "with proj2_line_rep_dependent [of 1 l \"- c ?m'\" ?m]"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 *\\<^sub>R proj2_line_rep l +\n           - c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n           proj2_line_rep (proj2_line_through p q) =\n           0;\n   1 \\<noteq> 0 \\<or>\n   - c (proj2_line_rep (proj2_line_through p q)) \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> l = proj2_line_through p q\n  proj2_line_rep l -\n  c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n  proj2_line_rep (proj2_line_through p q) =\n  0", "show \"l = ?m\""], ["proof (prove)\nusing this:\n  \\<lbrakk>1 *\\<^sub>R proj2_line_rep l +\n           - c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n           proj2_line_rep (proj2_line_through p q) =\n           0;\n   1 \\<noteq> 0 \\<or>\n   - c (proj2_line_rep (proj2_line_through p q)) \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> l = proj2_line_through p q\n  proj2_line_rep l -\n  c (proj2_line_rep (proj2_line_through p q)) *\\<^sub>R\n  proj2_line_rep (proj2_line_through p q) =\n  0\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "by simp"], ["proof (state)\nthis:\n  l = proj2_line_through p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_incident_unique:\n  assumes \"proj2_incident p l\"\n  and \"proj2_incident q l\"\n  and \"proj2_incident p m\"\n  and \"proj2_incident q m\"\n  shows \"p = q \\<or> l = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q \\<or> l = m", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> p = q \\<or> l = m\n 2. \\<not> ?P \\<Longrightarrow> p = q \\<or> l = m", "assume \"p = q\""], ["proof (state)\nthis:\n  p = q\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> p = q \\<or> l = m\n 2. \\<not> ?P \\<Longrightarrow> p = q \\<or> l = m", "thus \"p = q \\<or> l = m\""], ["proof (prove)\nusing this:\n  p = q\n\ngoal (1 subgoal):\n 1. p = q \\<or> l = m", ".."], ["proof (state)\nthis:\n  p = q \\<or> l = m\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> p = q \\<or> l = m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> p = q \\<or> l = m", "assume \"p \\<noteq> q\""], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> p = q \\<or> l = m", "with \\<open>proj2_incident p l\\<close> and \\<open>proj2_incident q l\\<close>\n    and proj2_line_through_unique"], ["proof (chain)\npicking this:\n  proj2_incident p l\n  proj2_incident q l\n  \\<lbrakk>?p \\<noteq> ?q; proj2_incident ?p ?l;\n   proj2_incident ?q ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = proj2_line_through ?p ?q\n  p \\<noteq> q", "have \"l = proj2_line_through p q\""], ["proof (prove)\nusing this:\n  proj2_incident p l\n  proj2_incident q l\n  \\<lbrakk>?p \\<noteq> ?q; proj2_incident ?p ?l;\n   proj2_incident ?q ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = proj2_line_through ?p ?q\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. l = proj2_line_through p q", "by simp"], ["proof (state)\nthis:\n  l = proj2_line_through p q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> p = q \\<or> l = m", "moreover"], ["proof (state)\nthis:\n  l = proj2_line_through p q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> p = q \\<or> l = m", "from \\<open>p \\<noteq> q\\<close> and \\<open>proj2_incident p m\\<close> and \\<open>proj2_incident q m\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  proj2_incident p m\n  proj2_incident q m", "have \"m = proj2_line_through p q\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  proj2_incident p m\n  proj2_incident q m\n\ngoal (1 subgoal):\n 1. m = proj2_line_through p q", "by (rule proj2_line_through_unique)"], ["proof (state)\nthis:\n  m = proj2_line_through p q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> p = q \\<or> l = m", "ultimately"], ["proof (chain)\npicking this:\n  l = proj2_line_through p q\n  m = proj2_line_through p q", "show \"p = q \\<or> l = m\""], ["proof (prove)\nusing this:\n  l = proj2_line_through p q\n  m = proj2_line_through p q\n\ngoal (1 subgoal):\n 1. p = q \\<or> l = m", "by simp"], ["proof (state)\nthis:\n  p = q \\<or> l = m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_lines_define_point: \"\\<exists> p. proj2_incident p l \\<and> proj2_incident p m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. proj2_incident p l \\<and> proj2_incident p m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. proj2_incident p l \\<and> proj2_incident p m", "let ?l' = \"L2P l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. proj2_incident p l \\<and> proj2_incident p m", "let ?m' = \"L2P m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. proj2_incident p l \\<and> proj2_incident p m", "from proj2_points_define_line [of ?l' ?m']"], ["proof (chain)\npicking this:\n  \\<exists>la. proj2_incident (L2P l) la \\<and> proj2_incident (L2P m) la", "obtain p' where \"proj2_incident ?l' p' \\<and> proj2_incident ?m' p'\""], ["proof (prove)\nusing this:\n  \\<exists>la. proj2_incident (L2P l) la \\<and> proj2_incident (L2P m) la\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        proj2_incident (L2P l) p' \\<and>\n        proj2_incident (L2P m) p' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  proj2_incident (L2P l) p' \\<and> proj2_incident (L2P m) p'\n\ngoal (1 subgoal):\n 1. \\<exists>p. proj2_incident p l \\<and> proj2_incident p m", "hence \"proj2_incident (L2P p') l \\<and> proj2_incident (L2P p') m\""], ["proof (prove)\nusing this:\n  proj2_incident (L2P l) p' \\<and> proj2_incident (L2P m) p'\n\ngoal (1 subgoal):\n 1. proj2_incident (L2P p') l \\<and> proj2_incident (L2P p') m", "unfolding proj2_incident_def and proj2_line_rep_def"], ["proof (prove)\nusing this:\n  proj2_rep (L2P l) \\<bullet> proj2_rep (L2P p') = 0 \\<and>\n  proj2_rep (L2P m) \\<bullet> proj2_rep (L2P p') = 0\n\ngoal (1 subgoal):\n 1. proj2_rep (L2P p') \\<bullet> proj2_rep (L2P l) = 0 \\<and>\n    proj2_rep (L2P p') \\<bullet> proj2_rep (L2P m) = 0", "by (simp add: inner_commute)"], ["proof (state)\nthis:\n  proj2_incident (L2P p') l \\<and> proj2_incident (L2P p') m\n\ngoal (1 subgoal):\n 1. \\<exists>p. proj2_incident p l \\<and> proj2_incident p m", "thus \"\\<exists> p. proj2_incident p l \\<and> proj2_incident p m\""], ["proof (prove)\nusing this:\n  proj2_incident (L2P p') l \\<and> proj2_incident (L2P p') m\n\ngoal (1 subgoal):\n 1. \\<exists>p. proj2_incident p l \\<and> proj2_incident p m", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. proj2_incident p l \\<and> proj2_incident p m\n\ngoal:\nNo subgoals!", "qed"], ["", "definition proj2_intersection :: \"proj2_line \\<Rightarrow> proj2_line \\<Rightarrow> proj2\" where\n  \"proj2_intersection l m \\<equiv> L2P (proj2_line_through (L2P l) (L2P m))\""], ["", "lemma proj2_incident_switch:\n  assumes \"proj2_incident p l\"\n  shows \"proj2_incident (L2P l) (P2L p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident (L2P l) (P2L p)", "using assms"], ["proof (prove)\nusing this:\n  proj2_incident p l\n\ngoal (1 subgoal):\n 1. proj2_incident (L2P l) (P2L p)", "unfolding proj2_incident_def and proj2_line_rep_def"], ["proof (prove)\nusing this:\n  proj2_rep p \\<bullet> proj2_rep (L2P l) = 0\n\ngoal (1 subgoal):\n 1. proj2_rep (L2P l) \\<bullet> proj2_rep (L2P (P2L p)) = 0", "by (simp add: inner_commute)"], ["", "lemma proj2_intersection_incident:\n  shows \"proj2_incident (proj2_intersection l m) l\"\n  and \"proj2_incident (proj2_intersection l m) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident (proj2_intersection l m) l &&&\n    proj2_incident (proj2_intersection l m) m", "using proj2_line_through_incident(1) [of \"L2P l\" \"L2P m\"]\n    and proj2_line_through_incident(2) [of \"L2P m\" \"L2P l\"]\n    and proj2_incident_switch [of \"L2P l\"]\n    and proj2_incident_switch [of \"L2P m\"]"], ["proof (prove)\nusing this:\n  proj2_incident (L2P l) (proj2_line_through (L2P l) (L2P m))\n  proj2_incident (L2P m) (proj2_line_through (L2P l) (L2P m))\n  proj2_incident (L2P l) ?l \\<Longrightarrow>\n  proj2_incident (L2P ?l) (P2L (L2P l))\n  proj2_incident (L2P m) ?l \\<Longrightarrow>\n  proj2_incident (L2P ?l) (P2L (L2P m))\n\ngoal (1 subgoal):\n 1. proj2_incident (proj2_intersection l m) l &&&\n    proj2_incident (proj2_intersection l m) m", "unfolding proj2_intersection_def"], ["proof (prove)\nusing this:\n  proj2_incident (L2P l) (proj2_line_through (L2P l) (L2P m))\n  proj2_incident (L2P m) (proj2_line_through (L2P l) (L2P m))\n  proj2_incident (L2P l) ?l \\<Longrightarrow>\n  proj2_incident (L2P ?l) (P2L (L2P l))\n  proj2_incident (L2P m) ?l \\<Longrightarrow>\n  proj2_incident (L2P ?l) (P2L (L2P m))\n\ngoal (1 subgoal):\n 1. proj2_incident (L2P (proj2_line_through (L2P l) (L2P m))) l &&&\n    proj2_incident (L2P (proj2_line_through (L2P l) (L2P m))) m", "by simp_all"], ["", "lemma proj2_intersection_unique:\n  assumes \"l \\<noteq> m\" and \"proj2_incident p l\" and \"proj2_incident p m\"\n  shows \"p = proj2_intersection l m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = proj2_intersection l m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = proj2_intersection l m", "from \\<open>l \\<noteq> m\\<close>"], ["proof (chain)\npicking this:\n  l \\<noteq> m", "have \"L2P l \\<noteq> L2P m\""], ["proof (prove)\nusing this:\n  l \\<noteq> m\n\ngoal (1 subgoal):\n 1. L2P l \\<noteq> L2P m", "by auto"], ["proof (state)\nthis:\n  L2P l \\<noteq> L2P m\n\ngoal (1 subgoal):\n 1. p = proj2_intersection l m", "from \\<open>proj2_incident p l\\<close> and \\<open>proj2_incident p m\\<close>\n    and proj2_incident_switch"], ["proof (chain)\npicking this:\n  proj2_incident p l\n  proj2_incident p m\n  proj2_incident ?p ?l \\<Longrightarrow> proj2_incident (L2P ?l) (P2L ?p)", "have \"proj2_incident (L2P l) (P2L p)\" and \"proj2_incident (L2P m) (P2L p)\""], ["proof (prove)\nusing this:\n  proj2_incident p l\n  proj2_incident p m\n  proj2_incident ?p ?l \\<Longrightarrow> proj2_incident (L2P ?l) (P2L ?p)\n\ngoal (1 subgoal):\n 1. proj2_incident (L2P l) (P2L p) &&& proj2_incident (L2P m) (P2L p)", "by simp_all"], ["proof (state)\nthis:\n  proj2_incident (L2P l) (P2L p)\n  proj2_incident (L2P m) (P2L p)\n\ngoal (1 subgoal):\n 1. p = proj2_intersection l m", "with \\<open>L2P l \\<noteq> L2P m\\<close> and proj2_line_through_unique"], ["proof (chain)\npicking this:\n  L2P l \\<noteq> L2P m\n  \\<lbrakk>?p \\<noteq> ?q; proj2_incident ?p ?l;\n   proj2_incident ?q ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = proj2_line_through ?p ?q\n  proj2_incident (L2P l) (P2L p)\n  proj2_incident (L2P m) (P2L p)", "have \"P2L p = proj2_line_through (L2P l) (L2P m)\""], ["proof (prove)\nusing this:\n  L2P l \\<noteq> L2P m\n  \\<lbrakk>?p \\<noteq> ?q; proj2_incident ?p ?l;\n   proj2_incident ?q ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = proj2_line_through ?p ?q\n  proj2_incident (L2P l) (P2L p)\n  proj2_incident (L2P m) (P2L p)\n\ngoal (1 subgoal):\n 1. P2L p = proj2_line_through (L2P l) (L2P m)", "by simp"], ["proof (state)\nthis:\n  P2L p = proj2_line_through (L2P l) (L2P m)\n\ngoal (1 subgoal):\n 1. p = proj2_intersection l m", "thus \"p = proj2_intersection l m\""], ["proof (prove)\nusing this:\n  P2L p = proj2_line_through (L2P l) (L2P m)\n\ngoal (1 subgoal):\n 1. p = proj2_intersection l m", "unfolding proj2_intersection_def"], ["proof (prove)\nusing this:\n  P2L p = proj2_line_through (L2P l) (L2P m)\n\ngoal (1 subgoal):\n 1. p = L2P (proj2_line_through (L2P l) (L2P m))", "by (simp add: P2L_to_L2P)"], ["proof (state)\nthis:\n  p = proj2_intersection l m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_not_self_incident:\n  \"\\<not> (proj2_incident p (P2L p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> proj2_incident p (P2L p)", "unfolding proj2_incident_def and proj2_line_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep p \\<bullet> proj2_rep (L2P (P2L p)) \\<noteq> 0", "using proj2_rep_non_zero and inner_eq_zero_iff [of \"proj2_rep p\"]"], ["proof (prove)\nusing this:\n  proj2_rep ?x \\<noteq> 0\n  (proj2_rep p \\<bullet> proj2_rep p = 0) = (proj2_rep p = 0)\n\ngoal (1 subgoal):\n 1. proj2_rep p \\<bullet> proj2_rep (L2P (P2L p)) \\<noteq> 0", "by simp"], ["", "lemma proj2_another_point_on_line:\n  \"\\<exists> q. q \\<noteq> p \\<and> proj2_incident q l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. q \\<noteq> p \\<and> proj2_incident q l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q. q \\<noteq> p \\<and> proj2_incident q l", "let ?m = \"P2L p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q. q \\<noteq> p \\<and> proj2_incident q l", "let ?q = \"proj2_intersection l ?m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q. q \\<noteq> p \\<and> proj2_incident q l", "from proj2_intersection_incident"], ["proof (chain)\npicking this:\n  proj2_incident (proj2_intersection ?l ?m) ?l\n  proj2_incident (proj2_intersection ?l ?m) ?m", "have \"proj2_incident ?q l\" and \"proj2_incident ?q ?m\""], ["proof (prove)\nusing this:\n  proj2_incident (proj2_intersection ?l ?m) ?l\n  proj2_incident (proj2_intersection ?l ?m) ?m\n\ngoal (1 subgoal):\n 1. proj2_incident (proj2_intersection l (P2L p)) l &&&\n    proj2_incident (proj2_intersection l (P2L p)) (P2L p)", "by simp_all"], ["proof (state)\nthis:\n  proj2_incident (proj2_intersection l (P2L p)) l\n  proj2_incident (proj2_intersection l (P2L p)) (P2L p)\n\ngoal (1 subgoal):\n 1. \\<exists>q. q \\<noteq> p \\<and> proj2_incident q l", "from \\<open>proj2_incident ?q ?m\\<close> and proj2_not_self_incident"], ["proof (chain)\npicking this:\n  proj2_incident (proj2_intersection l (P2L p)) (P2L p)\n  \\<not> proj2_incident ?p (P2L ?p)", "have \"?q \\<noteq> p\""], ["proof (prove)\nusing this:\n  proj2_incident (proj2_intersection l (P2L p)) (P2L p)\n  \\<not> proj2_incident ?p (P2L ?p)\n\ngoal (1 subgoal):\n 1. proj2_intersection l (P2L p) \\<noteq> p", "by auto"], ["proof (state)\nthis:\n  proj2_intersection l (P2L p) \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<exists>q. q \\<noteq> p \\<and> proj2_incident q l", "with \\<open>proj2_incident ?q l\\<close>"], ["proof (chain)\npicking this:\n  proj2_incident (proj2_intersection l (P2L p)) l\n  proj2_intersection l (P2L p) \\<noteq> p", "show \"\\<exists> q. q \\<noteq> p \\<and> proj2_incident q l\""], ["proof (prove)\nusing this:\n  proj2_incident (proj2_intersection l (P2L p)) l\n  proj2_intersection l (P2L p) \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<exists>q. q \\<noteq> p \\<and> proj2_incident q l", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. q \\<noteq> p \\<and> proj2_incident q l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_another_line_through_point:\n  \"\\<exists> m. m \\<noteq> l \\<and> proj2_incident p m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. m \\<noteq> l \\<and> proj2_incident p m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m. m \\<noteq> l \\<and> proj2_incident p m", "from proj2_another_point_on_line"], ["proof (chain)\npicking this:\n  \\<exists>q. q \\<noteq> ?p \\<and> proj2_incident q ?l", "obtain q where \"q \\<noteq> L2P l \\<and> proj2_incident q (P2L p)\""], ["proof (prove)\nusing this:\n  \\<exists>q. q \\<noteq> ?p \\<and> proj2_incident q ?l\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<noteq> L2P l \\<and> proj2_incident q (P2L p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> L2P l \\<and> proj2_incident q (P2L p)\n\ngoal (1 subgoal):\n 1. \\<exists>m. m \\<noteq> l \\<and> proj2_incident p m", "with proj2_incident_switch [of q \"P2L p\"]"], ["proof (chain)\npicking this:\n  proj2_incident q (P2L p) \\<Longrightarrow>\n  proj2_incident (L2P (P2L p)) (P2L q)\n  q \\<noteq> L2P l \\<and> proj2_incident q (P2L p)", "have \"P2L q \\<noteq> l \\<and> proj2_incident p (P2L q)\""], ["proof (prove)\nusing this:\n  proj2_incident q (P2L p) \\<Longrightarrow>\n  proj2_incident (L2P (P2L p)) (P2L q)\n  q \\<noteq> L2P l \\<and> proj2_incident q (P2L p)\n\ngoal (1 subgoal):\n 1. P2L q \\<noteq> l \\<and> proj2_incident p (P2L q)", "by auto"], ["proof (state)\nthis:\n  P2L q \\<noteq> l \\<and> proj2_incident p (P2L q)\n\ngoal (1 subgoal):\n 1. \\<exists>m. m \\<noteq> l \\<and> proj2_incident p m", "thus \"\\<exists> m. m \\<noteq> l \\<and> proj2_incident p m\""], ["proof (prove)\nusing this:\n  P2L q \\<noteq> l \\<and> proj2_incident p (P2L q)\n\ngoal (1 subgoal):\n 1. \\<exists>m. m \\<noteq> l \\<and> proj2_incident p m", ".."], ["proof (state)\nthis:\n  \\<exists>m. m \\<noteq> l \\<and> proj2_incident p m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_incident_abs:\n  assumes \"v \\<noteq> 0\" and \"w \\<noteq> 0\"\n  shows \"proj2_incident (proj2_abs v) (proj2_line_abs w) \\<longleftrightarrow> v \\<bullet> w = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident (proj2_abs v) (proj2_line_abs w) = (v \\<bullet> w = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_incident (proj2_abs v) (proj2_line_abs w) = (v \\<bullet> w = 0)", "from \\<open>v \\<noteq> 0\\<close> and proj2_rep_abs2"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v", "obtain j where \"j \\<noteq> 0\" and \"proj2_rep (proj2_abs v) = j *\\<^sub>R v\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<noteq> 0;\n         proj2_rep (proj2_abs v) = j *\\<^sub>R v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<noteq> 0\n  proj2_rep (proj2_abs v) = j *\\<^sub>R v\n\ngoal (1 subgoal):\n 1. proj2_incident (proj2_abs v) (proj2_line_abs w) = (v \\<bullet> w = 0)", "from \\<open>w \\<noteq> 0\\<close> and proj2_line_rep_abs"], ["proof (chain)\npicking this:\n  w \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and> proj2_line_rep (proj2_line_abs ?v) = k *\\<^sub>R ?v", "obtain k where \"k \\<noteq> 0\"\n    and \"proj2_line_rep (proj2_line_abs w) = k *\\<^sub>R w\""], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and> proj2_line_rep (proj2_line_abs ?v) = k *\\<^sub>R ?v\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<noteq> 0;\n         proj2_line_rep (proj2_line_abs w) = k *\\<^sub>R w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  proj2_line_rep (proj2_line_abs w) = k *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. proj2_incident (proj2_abs v) (proj2_line_abs w) = (v \\<bullet> w = 0)", "with \\<open>j \\<noteq> 0\\<close> and \\<open>proj2_rep (proj2_abs v) = j *\\<^sub>R v\\<close>"], ["proof (chain)\npicking this:\n  j \\<noteq> 0\n  proj2_rep (proj2_abs v) = j *\\<^sub>R v\n  k \\<noteq> 0\n  proj2_line_rep (proj2_line_abs w) = k *\\<^sub>R w", "show \"proj2_incident (proj2_abs v) (proj2_line_abs w) \\<longleftrightarrow> v \\<bullet> w = 0\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  proj2_rep (proj2_abs v) = j *\\<^sub>R v\n  k \\<noteq> 0\n  proj2_line_rep (proj2_line_abs w) = k *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. proj2_incident (proj2_abs v) (proj2_line_abs w) = (v \\<bullet> w = 0)", "unfolding proj2_incident_def"], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  proj2_rep (proj2_abs v) = j *\\<^sub>R v\n  k \\<noteq> 0\n  proj2_line_rep (proj2_line_abs w) = k *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. (proj2_rep (proj2_abs v) \\<bullet> proj2_line_rep (proj2_line_abs w) =\n     0) =\n    (v \\<bullet> w = 0)", "by (simp add: dot_scaleR_mult)"], ["proof (state)\nthis:\n  proj2_incident (proj2_abs v) (proj2_line_abs w) = (v \\<bullet> w = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_incident_left_abs:\n  assumes \"v \\<noteq> 0\"\n  shows \"proj2_incident (proj2_abs v) l \\<longleftrightarrow> v \\<bullet> (proj2_line_rep l) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident (proj2_abs v) l = (v \\<bullet> proj2_line_rep l = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_incident (proj2_abs v) l = (v \\<bullet> proj2_line_rep l = 0)", "have \"proj2_line_rep l \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_line_rep l \\<noteq> 0", "by (rule proj2_line_rep_non_zero)"], ["proof (state)\nthis:\n  proj2_line_rep l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_incident (proj2_abs v) l = (v \\<bullet> proj2_line_rep l = 0)", "with \\<open>v \\<noteq> 0\\<close> and proj2_incident_abs [of v \"proj2_line_rep l\"]"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\n  \\<lbrakk>v \\<noteq> 0; proj2_line_rep l \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proj2_incident (proj2_abs v)\n                     (proj2_line_abs (proj2_line_rep l)) =\n                    (v \\<bullet> proj2_line_rep l = 0)\n  proj2_line_rep l \\<noteq> 0", "show \"proj2_incident (proj2_abs v) l \\<longleftrightarrow> v \\<bullet> (proj2_line_rep l) = 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  \\<lbrakk>v \\<noteq> 0; proj2_line_rep l \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proj2_incident (proj2_abs v)\n                     (proj2_line_abs (proj2_line_rep l)) =\n                    (v \\<bullet> proj2_line_rep l = 0)\n  proj2_line_rep l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_incident (proj2_abs v) l = (v \\<bullet> proj2_line_rep l = 0)", "by simp"], ["proof (state)\nthis:\n  proj2_incident (proj2_abs v) l = (v \\<bullet> proj2_line_rep l = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_incident_right_abs:\n  assumes \"v \\<noteq> 0\"\n  shows \"proj2_incident p (proj2_line_abs v) \\<longleftrightarrow> (proj2_rep p) \\<bullet> v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident p (proj2_line_abs v) = (proj2_rep p \\<bullet> v = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_incident p (proj2_line_abs v) = (proj2_rep p \\<bullet> v = 0)", "have \"proj2_rep p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep p \\<noteq> 0", "by (rule proj2_rep_non_zero)"], ["proof (state)\nthis:\n  proj2_rep p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_incident p (proj2_line_abs v) = (proj2_rep p \\<bullet> v = 0)", "with \\<open>v \\<noteq> 0\\<close> and proj2_incident_abs [of \"proj2_rep p\" v]"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\n  \\<lbrakk>proj2_rep p \\<noteq> 0; v \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proj2_incident (proj2_abs (proj2_rep p))\n                     (proj2_line_abs v) =\n                    (proj2_rep p \\<bullet> v = 0)\n  proj2_rep p \\<noteq> 0", "show \"proj2_incident p (proj2_line_abs v) \\<longleftrightarrow> (proj2_rep p) \\<bullet> v = 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  \\<lbrakk>proj2_rep p \\<noteq> 0; v \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proj2_incident (proj2_abs (proj2_rep p))\n                     (proj2_line_abs v) =\n                    (proj2_rep p \\<bullet> v = 0)\n  proj2_rep p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_incident p (proj2_line_abs v) = (proj2_rep p \\<bullet> v = 0)", "by (simp add: proj2_abs_rep)"], ["proof (state)\nthis:\n  proj2_incident p (proj2_line_abs v) = (proj2_rep p \\<bullet> v = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition proj2_set_Col :: \"proj2 set \\<Rightarrow> bool\" where\n  \"proj2_set_Col S \\<equiv> \\<exists> l. \\<forall> p\\<in>S. proj2_incident p l\""], ["", "lemma proj2_subset_Col:\n  assumes \"T \\<subseteq> S\" and \"proj2_set_Col S\"\n  shows \"proj2_set_Col T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_set_Col T", "using \\<open>T \\<subseteq> S\\<close> and \\<open>proj2_set_Col S\\<close>"], ["proof (prove)\nusing this:\n  T \\<subseteq> S\n  proj2_set_Col S\n\ngoal (1 subgoal):\n 1. proj2_set_Col T", "by (unfold proj2_set_Col_def) auto"], ["", "definition proj2_no_3_Col :: \"proj2 set \\<Rightarrow> bool\" where\n  \"proj2_no_3_Col S \\<equiv> card S = 4 \\<and> (\\<forall> p\\<in>S. \\<not> proj2_set_Col (S - {p}))\""], ["", "lemma proj2_Col_iff_not_invertible:\n  \"proj2_Col p q r\n  \\<longleftrightarrow> \\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r] :: real^3^3)\"\n  (is \"_ \\<longleftrightarrow> \\<not> invertible (vector [?u, ?v, ?w])\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col p q r =\n    (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_Col p q r =\n    (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))", "let ?M = \"vector [?u,?v,?w] :: real^3^3\""], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_Col p q r =\n    (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))", "have \"proj2_Col p q r \\<longleftrightarrow> (\\<exists> x. x \\<noteq> 0 \\<and> x v* ?M = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col p q r =\n    (\\<exists>x.\n        x \\<noteq> 0 \\<and>\n        x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col p q r \\<Longrightarrow>\n    \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n 2. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "assume \"proj2_Col p q r\""], ["proof (state)\nthis:\n  proj2_Col p q r\n\ngoal (2 subgoals):\n 1. proj2_Col p q r \\<Longrightarrow>\n    \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n 2. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "then"], ["proof (chain)\npicking this:\n  proj2_Col p q r", "obtain i and j and k\n      where \"i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\" and \"i *\\<^sub>R ?u + j *\\<^sub>R ?v + k *\\<^sub>R ?w = 0\""], ["proof (prove)\nusing this:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. (\\<And>i j k.\n        \\<lbrakk>i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0;\n         i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q +\n         k *\\<^sub>R proj2_rep r =\n         0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding proj2_Col_def"], ["proof (prove)\nusing this:\n  \\<exists>i j k.\n     i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q +\n     k *\\<^sub>R proj2_rep r =\n     0 \\<and>\n     (i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>i j k.\n        \\<lbrakk>i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0;\n         i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q +\n         k *\\<^sub>R proj2_rep r =\n         0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\n  i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q +\n  k *\\<^sub>R proj2_rep r =\n  0\n\ngoal (2 subgoals):\n 1. proj2_Col p q r \\<Longrightarrow>\n    \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n 2. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "let ?x = \"vector [i,j,k] :: real^3\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col p q r \\<Longrightarrow>\n    \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n 2. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "from \\<open>i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0", "have \"?x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vector [i, j, k] \\<noteq> 0", "unfolding vector_def"], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vec_lambda\n     (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [i, j, k]\n       (\\<lambda>n x. 0) 1) \\<noteq>\n    0", "by (simp add: vec_eq_iff forall_3)"], ["proof (state)\nthis:\n  vector [i, j, k] \\<noteq> 0\n\ngoal (2 subgoals):\n 1. proj2_Col p q r \\<Longrightarrow>\n    \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n 2. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "moreover"], ["proof (state)\nthis:\n  vector [i, j, k] \\<noteq> 0\n\ngoal (2 subgoals):\n 1. proj2_Col p q r \\<Longrightarrow>\n    \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n 2. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "{"], ["proof (state)\nthis:\n  vector [i, j, k] \\<noteq> 0\n\ngoal (2 subgoals):\n 1. proj2_Col p q r \\<Longrightarrow>\n    \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n 2. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "from \\<open>i *\\<^sub>R ?u + j *\\<^sub>R ?v + k *\\<^sub>R ?w = 0\\<close>"], ["proof (chain)\npicking this:\n  i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q +\n  k *\\<^sub>R proj2_rep r =\n  0", "have \"?x v* ?M = 0\""], ["proof (prove)\nusing this:\n  i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q +\n  k *\\<^sub>R proj2_rep r =\n  0\n\ngoal (1 subgoal):\n 1. vector [i, j, k] v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0", "unfolding vector_def and vector_matrix_mult_def"], ["proof (prove)\nusing this:\n  i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q +\n  k *\\<^sub>R proj2_rep r =\n  0\n\ngoal (1 subgoal):\n 1. (\\<chi>ja.\n        \\<Sum>ia\\<in>UNIV.\n          vec_lambda\n           (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n             [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n          ia $\n          ja *\n          vec_lambda\n           (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [i, j, k]\n             (\\<lambda>n x. 0) 1) $\n          ia) =\n    0", "by (simp add: sum_3 vec_eq_iff algebra_simps)"], ["proof (state)\nthis:\n  vector [i, j, k] v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n\ngoal (2 subgoals):\n 1. proj2_Col p q r \\<Longrightarrow>\n    \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n 2. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "}"], ["proof (state)\nthis:\n  vector [i, j, k] v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n\ngoal (2 subgoals):\n 1. proj2_Col p q r \\<Longrightarrow>\n    \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n 2. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "ultimately"], ["proof (chain)\npicking this:\n  vector [i, j, k] \\<noteq> 0\n  vector [i, j, k] v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0", "show \"\\<exists> x. x \\<noteq> 0 \\<and> x v* ?M = 0\""], ["proof (prove)\nusing this:\n  vector [i, j, k] \\<noteq> 0\n  vector [i, j, k] v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<noteq> 0 \\<and>\n     x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "assume \"\\<exists> x. x \\<noteq> 0 \\<and> x v* ?M = 0\""], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<noteq> 0 \\<and>\n     x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     x \\<noteq> 0 \\<and>\n     x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0", "obtain x where \"x \\<noteq> 0\" and \"x v* ?M = 0\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<noteq> 0 \\<and>\n     x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<noteq> 0;\n         x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 0\n  x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "let ?i = \"x$1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "let ?j = \"x$2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "let ?k = \"x$3\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "from \\<open>x \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "have \"?i \\<noteq> 0 \\<or> ?j \\<noteq> 0 \\<or> ?k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x $ 1 \\<noteq> 0 \\<or> x $ 2 \\<noteq> 0 \\<or> x $ 3 \\<noteq> 0", "by (simp add: vec_eq_iff forall_3)"], ["proof (state)\nthis:\n  x $ 1 \\<noteq> 0 \\<or> x $ 2 \\<noteq> 0 \\<or> x $ 3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "moreover"], ["proof (state)\nthis:\n  x $ 1 \\<noteq> 0 \\<or> x $ 2 \\<noteq> 0 \\<or> x $ 3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "{"], ["proof (state)\nthis:\n  x $ 1 \\<noteq> 0 \\<or> x $ 2 \\<noteq> 0 \\<or> x $ 3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "from \\<open>x v* ?M = 0\\<close>"], ["proof (chain)\npicking this:\n  x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0", "have \"?i *\\<^sub>R ?u + ?j *\\<^sub>R ?v + ?k *\\<^sub>R ?w = 0\""], ["proof (prove)\nusing this:\n  x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0\n\ngoal (1 subgoal):\n 1. x $ 1 *\\<^sub>R proj2_rep p + x $ 2 *\\<^sub>R proj2_rep q +\n    x $ 3 *\\<^sub>R proj2_rep r =\n    0", "unfolding vector_matrix_mult_def and sum_3 and vector_def"], ["proof (prove)\nusing this:\n  (\\<chi>j.\n      vec_lambda\n       (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n         [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n      1 $\n      j *\n      x $ 1 +\n      vec_lambda\n       (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n         [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n      2 $\n      j *\n      x $ 2 +\n      vec_lambda\n       (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n         [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n      3 $\n      j *\n      x $ 3) =\n  0\n\ngoal (1 subgoal):\n 1. x $ 1 *\\<^sub>R proj2_rep p + x $ 2 *\\<^sub>R proj2_rep q +\n    x $ 3 *\\<^sub>R proj2_rep r =\n    0", "by (simp add: vec_eq_iff algebra_simps)"], ["proof (state)\nthis:\n  x $ 1 *\\<^sub>R proj2_rep p + x $ 2 *\\<^sub>R proj2_rep q +\n  x $ 3 *\\<^sub>R proj2_rep r =\n  0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "}"], ["proof (state)\nthis:\n  x $ 1 *\\<^sub>R proj2_rep p + x $ 2 *\\<^sub>R proj2_rep q +\n  x $ 3 *\\<^sub>R proj2_rep r =\n  0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<noteq> 0 \\<and>\n       x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n       0 \\<Longrightarrow>\n    proj2_Col p q r", "ultimately"], ["proof (chain)\npicking this:\n  x $ 1 \\<noteq> 0 \\<or> x $ 2 \\<noteq> 0 \\<or> x $ 3 \\<noteq> 0\n  x $ 1 *\\<^sub>R proj2_rep p + x $ 2 *\\<^sub>R proj2_rep q +\n  x $ 3 *\\<^sub>R proj2_rep r =\n  0", "show \"proj2_Col p q r\""], ["proof (prove)\nusing this:\n  x $ 1 \\<noteq> 0 \\<or> x $ 2 \\<noteq> 0 \\<or> x $ 3 \\<noteq> 0\n  x $ 1 *\\<^sub>R proj2_rep p + x $ 2 *\\<^sub>R proj2_rep q +\n  x $ 3 *\\<^sub>R proj2_rep r =\n  0\n\ngoal (1 subgoal):\n 1. proj2_Col p q r", "unfolding proj2_Col_def"], ["proof (prove)\nusing this:\n  x $ 1 \\<noteq> 0 \\<or> x $ 2 \\<noteq> 0 \\<or> x $ 3 \\<noteq> 0\n  x $ 1 *\\<^sub>R proj2_rep p + x $ 2 *\\<^sub>R proj2_rep q +\n  x $ 3 *\\<^sub>R proj2_rep r =\n  0\n\ngoal (1 subgoal):\n 1. \\<exists>i j k.\n       i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q +\n       k *\\<^sub>R proj2_rep r =\n       0 \\<and>\n       (i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  proj2_Col p q r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj2_Col p q r =\n  (\\<exists>x.\n      x \\<noteq> 0 \\<and>\n      x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0)\n\ngoal (1 subgoal):\n 1. proj2_Col p q r =\n    (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))", "also"], ["proof (state)\nthis:\n  proj2_Col p q r =\n  (\\<exists>x.\n      x \\<noteq> 0 \\<and>\n      x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0)\n\ngoal (1 subgoal):\n 1. proj2_Col p q r =\n    (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))", "from matrix_right_invertible_ker [of ?M]"], ["proof (chain)\npicking this:\n  (\\<exists>M'.\n      vector [proj2_rep p, proj2_rep q, proj2_rep r] ** M' = mat 1) =\n  (\\<forall>x.\n      x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n      0 \\<longrightarrow>\n      x = 0)", "have \"\\<dots> \\<longleftrightarrow> \\<not> (\\<exists> M'. ?M ** M' = mat 1)\""], ["proof (prove)\nusing this:\n  (\\<exists>M'.\n      vector [proj2_rep p, proj2_rep q, proj2_rep r] ** M' = mat 1) =\n  (\\<forall>x.\n      x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] =\n      0 \\<longrightarrow>\n      x = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        x \\<noteq> 0 \\<and>\n        x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0) =\n    (\\<nexists>M'.\n        vector [proj2_rep p, proj2_rep q, proj2_rep r] ** M' = mat 1)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x.\n      x \\<noteq> 0 \\<and>\n      x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0) =\n  (\\<nexists>M'.\n      vector [proj2_rep p, proj2_rep q, proj2_rep r] ** M' = mat 1)\n\ngoal (1 subgoal):\n 1. proj2_Col p q r =\n    (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))", "also"], ["proof (state)\nthis:\n  (\\<exists>x.\n      x \\<noteq> 0 \\<and>\n      x v* vector [proj2_rep p, proj2_rep q, proj2_rep r] = 0) =\n  (\\<nexists>M'.\n      vector [proj2_rep p, proj2_rep q, proj2_rep r] ** M' = mat 1)\n\ngoal (1 subgoal):\n 1. proj2_Col p q r =\n    (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))", "from matrix_left_right_inverse"], ["proof (chain)\npicking this:\n  (?A ** ?A' = mat (1::?'a)) = (?A' ** ?A = mat (1::?'a))", "have \"\\<dots> \\<longleftrightarrow> \\<not> invertible ?M\""], ["proof (prove)\nusing this:\n  (?A ** ?A' = mat (1::?'a)) = (?A' ** ?A = mat (1::?'a))\n\ngoal (1 subgoal):\n 1. (\\<nexists>M'.\n        vector [proj2_rep p, proj2_rep q, proj2_rep r] ** M' = mat 1) =\n    (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))", "unfolding invertible_def"], ["proof (prove)\nusing this:\n  (?A ** ?A' = mat (1::?'a)) = (?A' ** ?A = mat (1::?'a))\n\ngoal (1 subgoal):\n 1. (\\<nexists>M'.\n        vector [proj2_rep p, proj2_rep q, proj2_rep r] ** M' = mat 1) =\n    (\\<nexists>A'.\n        vector [proj2_rep p, proj2_rep q, proj2_rep r] ** A' = mat 1 \\<and>\n        A' ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1)", "by auto"], ["proof (state)\nthis:\n  (\\<nexists>M'.\n      vector [proj2_rep p, proj2_rep q, proj2_rep r] ** M' = mat 1) =\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))\n\ngoal (1 subgoal):\n 1. proj2_Col p q r =\n    (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))", "finally"], ["proof (chain)\npicking this:\n  proj2_Col p q r =\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))", "show \"proj2_Col p q r \\<longleftrightarrow> \\<not> invertible ?M\""], ["proof (prove)\nusing this:\n  proj2_Col p q r =\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))\n\ngoal (1 subgoal):\n 1. proj2_Col p q r =\n    (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))", "."], ["proof (state)\nthis:\n  proj2_Col p q r =\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_invertible_iff_proj2_set_Col:\n  \"\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r] :: real^3^3)\n  \\<longleftrightarrow> proj2_set_Col {p,q,r}\"\n  (is \"\\<not> invertible ?M \\<longleftrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n    proj2_set_Col {p, q, r}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n    proj2_set_Col {p, q, r}", "from left_invertible_iff_invertible"], ["proof (chain)\npicking this:\n  (\\<exists>N. N ** ?M = mat 1) = invertible ?M", "have \"\\<not> invertible ?M  \\<longleftrightarrow> \\<not> (\\<exists> M'. M' ** ?M = mat 1)\""], ["proof (prove)\nusing this:\n  (\\<exists>N. N ** ?M = mat 1) = invertible ?M\n\ngoal (1 subgoal):\n 1. (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n    (\\<nexists>M'.\n        M' ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1)", "by auto"], ["proof (state)\nthis:\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n  (\\<nexists>M'.\n      M' ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1)\n\ngoal (1 subgoal):\n 1. (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n    proj2_set_Col {p, q, r}", "also"], ["proof (state)\nthis:\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n  (\\<nexists>M'.\n      M' ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1)\n\ngoal (1 subgoal):\n 1. (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n    proj2_set_Col {p, q, r}", "from matrix_left_invertible_ker [of ?M]"], ["proof (chain)\npicking this:\n  (\\<exists>B.\n      B ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1) =\n  (\\<forall>x.\n      vector [proj2_rep p, proj2_rep q, proj2_rep r] *v x =\n      0 \\<longrightarrow>\n      x = 0)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists> y. y \\<noteq> 0 \\<and> ?M *v y = 0)\""], ["proof (prove)\nusing this:\n  (\\<exists>B.\n      B ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1) =\n  (\\<forall>x.\n      vector [proj2_rep p, proj2_rep q, proj2_rep r] *v x =\n      0 \\<longrightarrow>\n      x = 0)\n\ngoal (1 subgoal):\n 1. (\\<nexists>M'.\n        M' ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1) =\n    (\\<exists>y.\n        y \\<noteq> 0 \\<and>\n        vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0)", "by auto"], ["proof (state)\nthis:\n  (\\<nexists>M'.\n      M' ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1) =\n  (\\<exists>y.\n      y \\<noteq> 0 \\<and>\n      vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0)\n\ngoal (1 subgoal):\n 1. (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n    proj2_set_Col {p, q, r}", "also"], ["proof (state)\nthis:\n  (\\<nexists>M'.\n      M' ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1) =\n  (\\<exists>y.\n      y \\<noteq> 0 \\<and>\n      vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0)\n\ngoal (1 subgoal):\n 1. (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n    proj2_set_Col {p, q, r}", "have \"\\<dots> \\<longleftrightarrow> (\\<exists> l. \\<forall> s\\<in>{p,q,r}. proj2_incident s l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y.\n        y \\<noteq> 0 \\<and>\n        vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0) =\n    (\\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y =\n       0 \\<Longrightarrow>\n    \\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l\n 2. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "assume \"\\<exists> y. y \\<noteq> 0 \\<and> ?M *v y = 0\""], ["proof (state)\nthis:\n  \\<exists>y.\n     y \\<noteq> 0 \\<and>\n     vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0\n\ngoal (2 subgoals):\n 1. \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y =\n       0 \\<Longrightarrow>\n    \\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l\n 2. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>y.\n     y \\<noteq> 0 \\<and>\n     vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "obtain y where \"y \\<noteq> 0\" and \"?M *v y = 0\""], ["proof (prove)\nusing this:\n  \\<exists>y.\n     y \\<noteq> 0 \\<and>\n     vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<noteq> 0;\n         vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> 0\n  vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0\n\ngoal (2 subgoals):\n 1. \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y =\n       0 \\<Longrightarrow>\n    \\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l\n 2. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "let ?l = \"proj2_line_abs y\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y =\n       0 \\<Longrightarrow>\n    \\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l\n 2. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "from \\<open>?M *v y = 0\\<close>"], ["proof (chain)\npicking this:\n  vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "have \"\\<forall> s\\<in>{p,q,r}. proj2_rep s \\<bullet> y = 0\""], ["proof (prove)\nusing this:\n  vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>{p, q, r}. proj2_rep s \\<bullet> y = 0", "unfolding vector_def\n        and matrix_vector_mult_def\n        and inner_vec_def\n        and sum_3"], ["proof (prove)\nusing this:\n  (\\<chi>i.\n      vec_lambda\n       (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n         [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n      i $\n      1 *\n      y $ 1 +\n      vec_lambda\n       (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n         [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n      i $\n      2 *\n      y $ 2 +\n      vec_lambda\n       (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n         [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n      i $\n      3 *\n      y $ 3) =\n  0\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>{p, q, r}.\n       proj2_rep s $ 1 \\<bullet> y $ 1 + proj2_rep s $ 2 \\<bullet> y $ 2 +\n       proj2_rep s $ 3 \\<bullet> y $ 3 =\n       0", "by (simp add: vec_eq_iff forall_3)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>{p, q, r}. proj2_rep s \\<bullet> y = 0\n\ngoal (2 subgoals):\n 1. \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y =\n       0 \\<Longrightarrow>\n    \\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l\n 2. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "with \\<open>y \\<noteq> 0\\<close> and proj2_incident_right_abs"], ["proof (chain)\npicking this:\n  y \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  proj2_incident ?p (proj2_line_abs ?v) = (proj2_rep ?p \\<bullet> ?v = 0)\n  \\<forall>s\\<in>{p, q, r}. proj2_rep s \\<bullet> y = 0", "have \"\\<forall> s\\<in>{p,q,r}. proj2_incident s ?l\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  proj2_incident ?p (proj2_line_abs ?v) = (proj2_rep ?p \\<bullet> ?v = 0)\n  \\<forall>s\\<in>{p, q, r}. proj2_rep s \\<bullet> y = 0\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>{p, q, r}. proj2_incident s (proj2_line_abs y)", "by simp"], ["proof (state)\nthis:\n  \\<forall>s\\<in>{p, q, r}. proj2_incident s (proj2_line_abs y)\n\ngoal (2 subgoals):\n 1. \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y =\n       0 \\<Longrightarrow>\n    \\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l\n 2. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "thus \"\\<exists> l. \\<forall> s\\<in>{p,q,r}. proj2_incident s l\""], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>{p, q, r}. proj2_incident s (proj2_line_abs y)\n\ngoal (1 subgoal):\n 1. \\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l", ".."], ["proof (state)\nthis:\n  \\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "assume \"\\<exists> l. \\<forall> s\\<in>{p,q,r}. proj2_incident s l\""], ["proof (state)\nthis:\n  \\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l", "obtain l where \"\\<forall> s\\<in>{p,q,r}. proj2_incident s l\""], ["proof (prove)\nusing this:\n  \\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>s\\<in>{p, q, r}. proj2_incident s l\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "let ?y = \"proj2_line_rep l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "have \"?y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_line_rep l \\<noteq> 0", "by (rule proj2_line_rep_non_zero)"], ["proof (state)\nthis:\n  proj2_line_rep l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "moreover"], ["proof (state)\nthis:\n  proj2_line_rep l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "{"], ["proof (state)\nthis:\n  proj2_line_rep l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "from \\<open>\\<forall> s\\<in>{p,q,r}. proj2_incident s l\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>{p, q, r}. proj2_incident s l", "have \"?M *v ?y = 0\""], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>{p, q, r}. proj2_incident s l\n\ngoal (1 subgoal):\n 1. vector [proj2_rep p, proj2_rep q, proj2_rep r] *v proj2_line_rep l = 0", "unfolding vector_def\n          and matrix_vector_mult_def\n          and inner_vec_def\n          and sum_3\n          and proj2_incident_def"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>{p, q, r}.\n     proj2_rep s $ 1 \\<bullet> proj2_line_rep l $ 1 +\n     proj2_rep s $ 2 \\<bullet> proj2_line_rep l $ 2 +\n     proj2_rep s $ 3 \\<bullet> proj2_line_rep l $ 3 =\n     0\n\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        vec_lambda\n         (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n           [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n        i $\n        1 *\n        proj2_line_rep l $ 1 +\n        vec_lambda\n         (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n           [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n        i $\n        2 *\n        proj2_line_rep l $ 2 +\n        vec_lambda\n         (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n           [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n        i $\n        3 *\n        proj2_line_rep l $ 3) =\n    0", "by (simp add: vec_eq_iff)"], ["proof (state)\nthis:\n  vector [proj2_rep p, proj2_rep q, proj2_rep r] *v proj2_line_rep l = 0\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "}"], ["proof (state)\nthis:\n  vector [proj2_rep p, proj2_rep q, proj2_rep r] *v proj2_line_rep l = 0\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       \\<forall>s\\<in>{p, q, r}. proj2_incident s l \\<Longrightarrow>\n    \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "ultimately"], ["proof (chain)\npicking this:\n  proj2_line_rep l \\<noteq> 0\n  vector [proj2_rep p, proj2_rep q, proj2_rep r] *v proj2_line_rep l = 0", "show \"\\<exists> y. y \\<noteq> 0 \\<and> ?M *v y = 0\""], ["proof (prove)\nusing this:\n  proj2_line_rep l \\<noteq> 0\n  vector [proj2_rep p, proj2_rep q, proj2_rep r] *v proj2_line_rep l = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       y \\<noteq> 0 \\<and>\n       vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>y.\n     y \\<noteq> 0 \\<and>\n     vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y.\n      y \\<noteq> 0 \\<and>\n      vector [proj2_rep p, proj2_rep q, proj2_rep r] *v y = 0) =\n  (\\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l)\n\ngoal (1 subgoal):\n 1. (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n    proj2_set_Col {p, q, r}", "finally"], ["proof (chain)\npicking this:\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n  (\\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l)", "show \"\\<not> invertible ?M \\<longleftrightarrow> proj2_set_Col {p,q,r}\""], ["proof (prove)\nusing this:\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n  (\\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l)\n\ngoal (1 subgoal):\n 1. (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n    proj2_set_Col {p, q, r}", "unfolding proj2_set_Col_def"], ["proof (prove)\nusing this:\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n  (\\<exists>l. \\<forall>s\\<in>{p, q, r}. proj2_incident s l)\n\ngoal (1 subgoal):\n 1. (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n    (\\<exists>l. \\<forall>p\\<in>{p, q, r}. proj2_incident p l)", "."], ["proof (state)\nthis:\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n  proj2_set_Col {p, q, r}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_Col_iff_set_Col:\n  \"proj2_Col p q r \\<longleftrightarrow> proj2_set_Col {p,q,r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col p q r = proj2_set_Col {p, q, r}", "by (simp add: proj2_Col_iff_not_invertible\n    not_invertible_iff_proj2_set_Col)"], ["", "lemma proj2_incident_Col:\n  assumes \"proj2_incident p l\" and \"proj2_incident q l\" and \"proj2_incident r l\"\n  shows \"proj2_Col p q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col p q r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_Col p q r", "from \\<open>proj2_incident p l\\<close> and \\<open>proj2_incident q l\\<close> and \\<open>proj2_incident r l\\<close>"], ["proof (chain)\npicking this:\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident r l", "have \"proj2_set_Col {p,q,r}\""], ["proof (prove)\nusing this:\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident r l\n\ngoal (1 subgoal):\n 1. proj2_set_Col {p, q, r}", "by (unfold proj2_set_Col_def) auto"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. proj2_Col p q r", "thus \"proj2_Col p q r\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. proj2_Col p q r", "by (subst proj2_Col_iff_set_Col)"], ["proof (state)\nthis:\n  proj2_Col p q r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_incident_iff_Col:\n  assumes \"p \\<noteq> q\" and \"proj2_incident p l\" and \"proj2_incident q l\"\n  shows \"proj2_incident r l \\<longleftrightarrow> proj2_Col p q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident r l = proj2_Col p q r", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_incident r l \\<Longrightarrow> proj2_Col p q r\n 2. proj2_Col p q r \\<Longrightarrow> proj2_incident r l", "assume \"proj2_incident r l\""], ["proof (state)\nthis:\n  proj2_incident r l\n\ngoal (2 subgoals):\n 1. proj2_incident r l \\<Longrightarrow> proj2_Col p q r\n 2. proj2_Col p q r \\<Longrightarrow> proj2_incident r l", "with \\<open>proj2_incident p l\\<close> and \\<open>proj2_incident q l\\<close>"], ["proof (chain)\npicking this:\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident r l", "show \"proj2_Col p q r\""], ["proof (prove)\nusing this:\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident r l\n\ngoal (1 subgoal):\n 1. proj2_Col p q r", "by (rule proj2_incident_Col)"], ["proof (state)\nthis:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. proj2_Col p q r \\<Longrightarrow> proj2_incident r l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_Col p q r \\<Longrightarrow> proj2_incident r l", "assume \"proj2_Col p q r\""], ["proof (state)\nthis:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. proj2_Col p q r \\<Longrightarrow> proj2_incident r l", "hence \"proj2_set_Col {p,q,r}\""], ["proof (prove)\nusing this:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. proj2_set_Col {p, q, r}", "by (simp add: proj2_Col_iff_set_Col)"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. proj2_Col p q r \\<Longrightarrow> proj2_incident r l", "then"], ["proof (chain)\npicking this:\n  proj2_set_Col {p, q, r}", "obtain m where \"\\<forall> s\\<in>{p,q,r}. proj2_incident s m\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<forall>s\\<in>{p, q, r}. proj2_incident s m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding proj2_set_Col_def"], ["proof (prove)\nusing this:\n  \\<exists>l. \\<forall>p\\<in>{p, q, r}. proj2_incident p l\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<forall>s\\<in>{p, q, r}. proj2_incident s m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>s\\<in>{p, q, r}. proj2_incident s m\n\ngoal (1 subgoal):\n 1. proj2_Col p q r \\<Longrightarrow> proj2_incident r l", "hence \"proj2_incident p m\" and \"proj2_incident q m\" and \"proj2_incident r m\""], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>{p, q, r}. proj2_incident s m\n\ngoal (1 subgoal):\n 1. proj2_incident p m &&& proj2_incident q m &&& proj2_incident r m", "by simp_all"], ["proof (state)\nthis:\n  proj2_incident p m\n  proj2_incident q m\n  proj2_incident r m\n\ngoal (1 subgoal):\n 1. proj2_Col p q r \\<Longrightarrow> proj2_incident r l", "from \\<open>p \\<noteq> q\\<close> and \\<open>proj2_incident p l\\<close> and \\<open>proj2_incident q l\\<close>\n    and \\<open>proj2_incident p m\\<close> and \\<open>proj2_incident q m\\<close>\n    and proj2_incident_unique"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident p m\n  proj2_incident q m\n  \\<lbrakk>proj2_incident ?p ?l; proj2_incident ?q ?l; proj2_incident ?p ?m;\n   proj2_incident ?q ?m\\<rbrakk>\n  \\<Longrightarrow> ?p = ?q \\<or> ?l = ?m", "have \"m = l\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident p m\n  proj2_incident q m\n  \\<lbrakk>proj2_incident ?p ?l; proj2_incident ?q ?l; proj2_incident ?p ?m;\n   proj2_incident ?q ?m\\<rbrakk>\n  \\<Longrightarrow> ?p = ?q \\<or> ?l = ?m\n\ngoal (1 subgoal):\n 1. m = l", "by auto"], ["proof (state)\nthis:\n  m = l\n\ngoal (1 subgoal):\n 1. proj2_Col p q r \\<Longrightarrow> proj2_incident r l", "with \\<open>proj2_incident r m\\<close>"], ["proof (chain)\npicking this:\n  proj2_incident r m\n  m = l", "show \"proj2_incident r l\""], ["proof (prove)\nusing this:\n  proj2_incident r m\n  m = l\n\ngoal (1 subgoal):\n 1. proj2_incident r l", "by simp"], ["proof (state)\nthis:\n  proj2_incident r l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_incident_iff:\n  assumes \"p \\<noteq> q\" and \"proj2_incident p l\" and \"proj2_incident q l\"\n  shows \"proj2_incident r l\n  \\<longleftrightarrow> r = p \\<or> (\\<exists> k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident r l =\n    (r = p \\<or>\n     (\\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_incident r l =\n    (r = p \\<or>\n     (\\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)))", "from \\<open>p \\<noteq> q\\<close> and \\<open>proj2_incident p l\\<close> and \\<open>proj2_incident q l\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  proj2_incident p l\n  proj2_incident q l", "have \"proj2_incident r l \\<longleftrightarrow> proj2_Col p q r\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  proj2_incident p l\n  proj2_incident q l\n\ngoal (1 subgoal):\n 1. proj2_incident r l = proj2_Col p q r", "by (rule proj2_incident_iff_Col)"], ["proof (state)\nthis:\n  proj2_incident r l = proj2_Col p q r\n\ngoal (1 subgoal):\n 1. proj2_incident r l =\n    (r = p \\<or>\n     (\\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)))", "with \\<open>p \\<noteq> q\\<close> and proj2_Col_iff"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  ?a \\<noteq> ?r \\<Longrightarrow>\n  proj2_Col ?a ?r ?t =\n  (?t = ?a \\<or>\n   (\\<exists>i. ?t = proj2_abs (i *\\<^sub>R proj2_rep ?a + proj2_rep ?r)))\n  proj2_incident r l = proj2_Col p q r", "show \"proj2_incident r l\n    \\<longleftrightarrow> r = p \\<or> (\\<exists> k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q))\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  ?a \\<noteq> ?r \\<Longrightarrow>\n  proj2_Col ?a ?r ?t =\n  (?t = ?a \\<or>\n   (\\<exists>i. ?t = proj2_abs (i *\\<^sub>R proj2_rep ?a + proj2_rep ?r)))\n  proj2_incident r l = proj2_Col p q r\n\ngoal (1 subgoal):\n 1. proj2_incident r l =\n    (r = p \\<or>\n     (\\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)))", "by simp"], ["proof (state)\nthis:\n  proj2_incident r l =\n  (r = p \\<or>\n   (\\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_proj2_set_Col_iff_span:\n  assumes \"card S = 3\"\n  shows \"\\<not> proj2_set_Col S \\<longleftrightarrow> span (proj2_rep ` S) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "from \\<open>card S = 3\\<close> and choose_3 [of S]"], ["proof (chain)\npicking this:\n  card S = 3\n  card S = 3 \\<Longrightarrow> \\<exists>x y z. S = {x, y, z}", "obtain p and q and r where \"S = {p,q,r}\""], ["proof (prove)\nusing this:\n  card S = 3\n  card S = 3 \\<Longrightarrow> \\<exists>x y z. S = {x, y, z}\n\ngoal (1 subgoal):\n 1. (\\<And>p q r. S = {p, q, r} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S = {p, q, r}\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "let ?u = \"proj2_rep p\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "let ?v = \"proj2_rep q\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "let ?w = \"proj2_rep r\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "let ?M = \"vector [?u, ?v, ?w] :: real^3^3\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "from \\<open>S = {p,q,r}\\<close> and not_invertible_iff_proj2_set_Col [of p q r]"], ["proof (chain)\npicking this:\n  S = {p, q, r}\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n  proj2_set_Col {p, q, r}", "have \"\\<not> proj2_set_Col S \\<longleftrightarrow> invertible ?M\""], ["proof (prove)\nusing this:\n  S = {p, q, r}\n  (\\<not> invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])) =\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) =\n    invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "by auto"], ["proof (state)\nthis:\n  (\\<not> proj2_set_Col S) =\n  invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "also"], ["proof (state)\nthis:\n  (\\<not> proj2_set_Col S) =\n  invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "from left_invertible_iff_invertible"], ["proof (chain)\npicking this:\n  (\\<exists>N. N ** ?M = mat 1) = invertible ?M", "have \"\\<dots> \\<longleftrightarrow> (\\<exists> N. N ** ?M = mat 1)\""], ["proof (prove)\nusing this:\n  (\\<exists>N. N ** ?M = mat 1) = invertible ?M\n\ngoal (1 subgoal):\n 1. invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]) =\n    (\\<exists>N.\n        N ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1)", ".."], ["proof (state)\nthis:\n  invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]) =\n  (\\<exists>N. N ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1)\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "also"], ["proof (state)\nthis:\n  invertible (vector [proj2_rep p, proj2_rep q, proj2_rep r]) =\n  (\\<exists>N. N ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1)\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "from matrix_left_invertible_span_rows"], ["proof (chain)\npicking this:\n  (\\<exists>B. B ** ?A = mat 1) = (span (rows ?A) = UNIV)", "have \"\\<dots> \\<longleftrightarrow> span (rows ?M) = UNIV\""], ["proof (prove)\nusing this:\n  (\\<exists>B. B ** ?A = mat 1) = (span (rows ?A) = UNIV)\n\ngoal (1 subgoal):\n 1. (\\<exists>N.\n        N ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1) =\n    (span (rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])) = UNIV)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>N.\n      N ** vector [proj2_rep p, proj2_rep q, proj2_rep r] = mat 1) =\n  (span (rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])) = UNIV)\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "finally"], ["proof (chain)\npicking this:\n  (\\<not> proj2_set_Col S) =\n  (span (rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])) = UNIV)", "have \"\\<not> proj2_set_Col S \\<longleftrightarrow> span (rows ?M) = UNIV\""], ["proof (prove)\nusing this:\n  (\\<not> proj2_set_Col S) =\n  (span (rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])) = UNIV)\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) =\n    (span (rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])) = UNIV)", "."], ["proof (state)\nthis:\n  (\\<not> proj2_set_Col S) =\n  (span (rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])) = UNIV)\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "have \"rows ?M = {?u, ?v, ?w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r]) =\n    {proj2_rep p, proj2_rep q, proj2_rep r}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n    \\<subseteq> {proj2_rep p, proj2_rep q, proj2_rep r}\n 2. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n    \\<subseteq> {proj2_rep p, proj2_rep q, proj2_rep r}\n 2. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n    \\<subseteq> {proj2_rep p, proj2_rep q, proj2_rep r}\n 2. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "assume \"x \\<in> rows ?M\""], ["proof (state)\nthis:\n  x \\<in> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n\ngoal (2 subgoals):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n    \\<subseteq> {proj2_rep p, proj2_rep q, proj2_rep r}\n 2. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "then"], ["proof (chain)\npicking this:\n  x \\<in> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "obtain i :: 3  where \"x = ?M $ i\""], ["proof (prove)\nusing this:\n  x \\<in> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        x =\n        vector [proj2_rep p, proj2_rep q, proj2_rep r] $ i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding rows_def and row_def"], ["proof (prove)\nusing this:\n  x \\<in> {vec_lambda\n            (($) (vector [proj2_rep p, proj2_rep q, proj2_rep r] $ i)) |\n           i. i \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        x =\n        vector [proj2_rep p, proj2_rep q, proj2_rep r] $ i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: vec_lambda_beta vec_lambda_eta)"], ["proof (state)\nthis:\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ i\n\ngoal (2 subgoals):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n    \\<subseteq> {proj2_rep p, proj2_rep q, proj2_rep r}\n 2. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "with exhaust_3"], ["proof (chain)\npicking this:\n  ?x = 1 \\<or> ?x = 2 \\<or> ?x = 3\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ i", "have \"x = ?u \\<or> x = ?v \\<or> x = ?w\""], ["proof (prove)\nusing this:\n  ?x = 1 \\<or> ?x = 2 \\<or> ?x = 3\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ i\n\ngoal (1 subgoal):\n 1. x = proj2_rep p \\<or> x = proj2_rep q \\<or> x = proj2_rep r", "unfolding vector_def"], ["proof (prove)\nusing this:\n  ?x = 1 \\<or> ?x = 2 \\<or> ?x = 3\n  x =\n  vec_lambda\n   (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n     [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n  i\n\ngoal (1 subgoal):\n 1. x = proj2_rep p \\<or> x = proj2_rep q \\<or> x = proj2_rep r", "by auto"], ["proof (state)\nthis:\n  x = proj2_rep p \\<or> x = proj2_rep q \\<or> x = proj2_rep r\n\ngoal (2 subgoals):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n    \\<subseteq> {proj2_rep p, proj2_rep q, proj2_rep r}\n 2. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "hence \"x \\<in> {?u, ?v, ?w}\""], ["proof (prove)\nusing this:\n  x = proj2_rep p \\<or> x = proj2_rep q \\<or> x = proj2_rep r\n\ngoal (1 subgoal):\n 1. x \\<in> {proj2_rep p, proj2_rep q, proj2_rep r}", "by simp"], ["proof (state)\nthis:\n  x \\<in> {proj2_rep p, proj2_rep q, proj2_rep r}\n\ngoal (2 subgoals):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n    \\<subseteq> {proj2_rep p, proj2_rep q, proj2_rep r}\n 2. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "}"], ["proof (state)\nthis:\n  ?x2\n  \\<in> rows\n         (vector [proj2_rep p, proj2_rep q, proj2_rep r]) \\<Longrightarrow>\n  ?x2 \\<in> {proj2_rep p, proj2_rep q, proj2_rep r}\n\ngoal (2 subgoals):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n    \\<subseteq> {proj2_rep p, proj2_rep q, proj2_rep r}\n 2. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "thus \"rows ?M \\<subseteq> {?u, ?v, ?w}\""], ["proof (prove)\nusing this:\n  ?x2\n  \\<in> rows\n         (vector [proj2_rep p, proj2_rep q, proj2_rep r]) \\<Longrightarrow>\n  ?x2 \\<in> {proj2_rep p, proj2_rep q, proj2_rep r}\n\ngoal (1 subgoal):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n    \\<subseteq> {proj2_rep p, proj2_rep q, proj2_rep r}", ".."], ["proof (state)\nthis:\n  rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n  \\<subseteq> {proj2_rep p, proj2_rep q, proj2_rep r}\n\ngoal (1 subgoal):\n 1. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "{"], ["proof (state)\nthis:\n  rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n  \\<subseteq> {proj2_rep p, proj2_rep q, proj2_rep r}\n\ngoal (1 subgoal):\n 1. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "assume \"x \\<in> {?u, ?v, ?w}\""], ["proof (state)\nthis:\n  x \\<in> {proj2_rep p, proj2_rep q, proj2_rep r}\n\ngoal (1 subgoal):\n 1. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "hence \"x = ?u \\<or> x = ?v \\<or> x = ?w\""], ["proof (prove)\nusing this:\n  x \\<in> {proj2_rep p, proj2_rep q, proj2_rep r}\n\ngoal (1 subgoal):\n 1. x = proj2_rep p \\<or> x = proj2_rep q \\<or> x = proj2_rep r", "by simp"], ["proof (state)\nthis:\n  x = proj2_rep p \\<or> x = proj2_rep q \\<or> x = proj2_rep r\n\ngoal (1 subgoal):\n 1. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "hence \"x = ?M $ 1 \\<or> x = ?M $ 2 \\<or> x = ?M $ 3\""], ["proof (prove)\nusing this:\n  x = proj2_rep p \\<or> x = proj2_rep q \\<or> x = proj2_rep r\n\ngoal (1 subgoal):\n 1. x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 1 \\<or>\n    x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 2 \\<or>\n    x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 3", "unfolding vector_def"], ["proof (prove)\nusing this:\n  x = proj2_rep p \\<or> x = proj2_rep q \\<or> x = proj2_rep r\n\ngoal (1 subgoal):\n 1. x =\n    vec_lambda\n     (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n       [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n    1 \\<or>\n    x =\n    vec_lambda\n     (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n       [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n    2 \\<or>\n    x =\n    vec_lambda\n     (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n       [proj2_rep p, proj2_rep q, proj2_rep r] (\\<lambda>n x. 0) 1) $\n    3", "by simp"], ["proof (state)\nthis:\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 1 \\<or>\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 2 \\<or>\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 3\n\ngoal (1 subgoal):\n 1. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "hence \"x \\<in> rows ?M\""], ["proof (prove)\nusing this:\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 1 \\<or>\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 2 \\<or>\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 3\n\ngoal (1 subgoal):\n 1. x \\<in> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "unfolding rows_def row_def vec_lambda_eta"], ["proof (prove)\nusing this:\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 1 \\<or>\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 2 \\<or>\n  x = vector [proj2_rep p, proj2_rep q, proj2_rep r] $ 3\n\ngoal (1 subgoal):\n 1. x \\<in> {vector [proj2_rep p, proj2_rep q, proj2_rep r] $ i |i.\n             i \\<in> UNIV}", "by blast"], ["proof (state)\nthis:\n  x \\<in> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n\ngoal (1 subgoal):\n 1. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> {proj2_rep p, proj2_rep q, proj2_rep r} \\<Longrightarrow>\n  ?x2 \\<in> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n\ngoal (1 subgoal):\n 1. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", "thus \"{?u, ?v, ?w} \\<subseteq> rows ?M\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> {proj2_rep p, proj2_rep q, proj2_rep r} \\<Longrightarrow>\n  ?x2 \\<in> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n\ngoal (1 subgoal):\n 1. {proj2_rep p, proj2_rep q, proj2_rep r}\n    \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])", ".."], ["proof (state)\nthis:\n  {proj2_rep p, proj2_rep q, proj2_rep r}\n  \\<subseteq> rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rows (vector [proj2_rep p, proj2_rep q, proj2_rep r]) =\n  {proj2_rep p, proj2_rep q, proj2_rep r}\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "with \\<open>S = {p,q,r}\\<close>"], ["proof (chain)\npicking this:\n  S = {p, q, r}\n  rows (vector [proj2_rep p, proj2_rep q, proj2_rep r]) =\n  {proj2_rep p, proj2_rep q, proj2_rep r}", "have \"rows ?M = proj2_rep ` S\""], ["proof (prove)\nusing this:\n  S = {p, q, r}\n  rows (vector [proj2_rep p, proj2_rep q, proj2_rep r]) =\n  {proj2_rep p, proj2_rep q, proj2_rep r}\n\ngoal (1 subgoal):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r]) = proj2_rep ` S", "unfolding image_def"], ["proof (prove)\nusing this:\n  S = {p, q, r}\n  rows (vector [proj2_rep p, proj2_rep q, proj2_rep r]) =\n  {proj2_rep p, proj2_rep q, proj2_rep r}\n\ngoal (1 subgoal):\n 1. rows (vector [proj2_rep p, proj2_rep q, proj2_rep r]) =\n    {y. \\<exists>x\\<in>S. y = proj2_rep x}", "by auto"], ["proof (state)\nthis:\n  rows (vector [proj2_rep p, proj2_rep q, proj2_rep r]) = proj2_rep ` S\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "with \\<open>\\<not> proj2_set_Col S \\<longleftrightarrow> span (rows ?M) = UNIV\\<close>"], ["proof (chain)\npicking this:\n  (\\<not> proj2_set_Col S) =\n  (span (rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])) = UNIV)\n  rows (vector [proj2_rep p, proj2_rep q, proj2_rep r]) = proj2_rep ` S", "show \"\\<not> proj2_set_Col S \\<longleftrightarrow> span (proj2_rep ` S) = UNIV\""], ["proof (prove)\nusing this:\n  (\\<not> proj2_set_Col S) =\n  (span (rows (vector [proj2_rep p, proj2_rep q, proj2_rep r])) = UNIV)\n  rows (vector [proj2_rep p, proj2_rep q, proj2_rep r]) = proj2_rep ` S\n\ngoal (1 subgoal):\n 1. (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)", "by simp"], ["proof (state)\nthis:\n  (\\<not> proj2_set_Col S) = (span (proj2_rep ` S) = UNIV)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_no_3_Col_span:\n  assumes \"proj2_no_3_Col S\" and \"p \\<in> S\"\n  shows \"span (proj2_rep ` (S - {p})) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (proj2_rep ` (S - {p})) = UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. span (proj2_rep ` (S - {p})) = UNIV", "from \\<open>proj2_no_3_Col S\\<close>"], ["proof (chain)\npicking this:\n  proj2_no_3_Col S", "have \"card S = 4\""], ["proof (prove)\nusing this:\n  proj2_no_3_Col S\n\ngoal (1 subgoal):\n 1. card S = 4", "unfolding proj2_no_3_Col_def"], ["proof (prove)\nusing this:\n  card S = 4 \\<and> (\\<forall>p\\<in>S. \\<not> proj2_set_Col (S - {p}))\n\ngoal (1 subgoal):\n 1. card S = 4", ".."], ["proof (state)\nthis:\n  card S = 4\n\ngoal (1 subgoal):\n 1. span (proj2_rep ` (S - {p})) = UNIV", "with \\<open>p \\<in> S\\<close> and \\<open>card S = 4\\<close> and card_gt_0_diff_singleton [of S p]"], ["proof (chain)\npicking this:\n  p \\<in> S\n  card S = 4\n  \\<lbrakk>0 < card S; p \\<in> S\\<rbrakk>\n  \\<Longrightarrow> card (S - {p}) = card S - 1\n  card S = 4", "have \"card (S - {p}) = 3\""], ["proof (prove)\nusing this:\n  p \\<in> S\n  card S = 4\n  \\<lbrakk>0 < card S; p \\<in> S\\<rbrakk>\n  \\<Longrightarrow> card (S - {p}) = card S - 1\n  card S = 4\n\ngoal (1 subgoal):\n 1. card (S - {p}) = 3", "by simp"], ["proof (state)\nthis:\n  card (S - {p}) = 3\n\ngoal (1 subgoal):\n 1. span (proj2_rep ` (S - {p})) = UNIV", "from \\<open>proj2_no_3_Col S\\<close> and \\<open>p \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  proj2_no_3_Col S\n  p \\<in> S", "have \"\\<not> proj2_set_Col (S - {p})\""], ["proof (prove)\nusing this:\n  proj2_no_3_Col S\n  p \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> proj2_set_Col (S - {p})", "unfolding proj2_no_3_Col_def"], ["proof (prove)\nusing this:\n  card S = 4 \\<and> (\\<forall>p\\<in>S. \\<not> proj2_set_Col (S - {p}))\n  p \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> proj2_set_Col (S - {p})", "by simp"], ["proof (state)\nthis:\n  \\<not> proj2_set_Col (S - {p})\n\ngoal (1 subgoal):\n 1. span (proj2_rep ` (S - {p})) = UNIV", "with \\<open>card (S - {p}) = 3\\<close> and not_proj2_set_Col_iff_span"], ["proof (chain)\npicking this:\n  card (S - {p}) = 3\n  card ?S = 3 \\<Longrightarrow>\n  (\\<not> proj2_set_Col ?S) = (span (proj2_rep ` ?S) = UNIV)\n  \\<not> proj2_set_Col (S - {p})", "show \"span (proj2_rep ` (S - {p})) = UNIV\""], ["proof (prove)\nusing this:\n  card (S - {p}) = 3\n  card ?S = 3 \\<Longrightarrow>\n  (\\<not> proj2_set_Col ?S) = (span (proj2_rep ` ?S) = UNIV)\n  \\<not> proj2_set_Col (S - {p})\n\ngoal (1 subgoal):\n 1. span (proj2_rep ` (S - {p})) = UNIV", "by simp"], ["proof (state)\nthis:\n  span (proj2_rep ` (S - {p})) = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fourth_proj2_no_3_Col:\n  assumes \"\\<not> proj2_Col p q r\"\n  shows \"\\<exists> s. proj2_no_3_Col {s,r,p,q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "from \\<open>\\<not> proj2_Col p q r\\<close> and proj2_Col_coincide"], ["proof (chain)\npicking this:\n  \\<not> proj2_Col p q r\n  proj2_Col ?a ?a ?c", "have \"p \\<noteq> q\""], ["proof (prove)\nusing this:\n  \\<not> proj2_Col p q r\n  proj2_Col ?a ?a ?c\n\ngoal (1 subgoal):\n 1. p \\<noteq> q", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "hence \"card {p,q} = 2\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. card {p, q} = 2", "by simp"], ["proof (state)\nthis:\n  card {p, q} = 2\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "from \\<open>\\<not> proj2_Col p q r\\<close> and proj2_Col_coincide and proj2_Col_permute"], ["proof (chain)\npicking this:\n  \\<not> proj2_Col p q r\n  proj2_Col ?a ?a ?c\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?a ?c ?b\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?b ?a ?c", "have \"r \\<notin> {p,q}\""], ["proof (prove)\nusing this:\n  \\<not> proj2_Col p q r\n  proj2_Col ?a ?a ?c\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?a ?c ?b\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?b ?a ?c\n\ngoal (1 subgoal):\n 1. r \\<notin> {p, q}", "by fast"], ["proof (state)\nthis:\n  r \\<notin> {p, q}\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "with \\<open>card {p,q} = 2\\<close>"], ["proof (chain)\npicking this:\n  card {p, q} = 2\n  r \\<notin> {p, q}", "have \"card {r,p,q} = 3\""], ["proof (prove)\nusing this:\n  card {p, q} = 2\n  r \\<notin> {p, q}\n\ngoal (1 subgoal):\n 1. card {r, p, q} = 3", "by simp"], ["proof (state)\nthis:\n  card {r, p, q} = 3\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "have \"finite {r,p,q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {r, p, q}", "by simp"], ["proof (state)\nthis:\n  finite {r, p, q}\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "let ?s = \"proj2_abs (\\<Sum> t\\<in>{r,p,q}. proj2_rep t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "have \"\\<exists> j. (\\<Sum> t\\<in>{r,p,q}. proj2_rep t) = j *\\<^sub>R proj2_rep ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "assume \"(\\<Sum> t\\<in>{r,p,q}. proj2_rep t) = 0\""], ["proof (state)\nthis:\n  sum proj2_rep {r, p, q} = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "hence \"(\\<Sum> t\\<in>{r,p,q}. proj2_rep t) = 0 *\\<^sub>R proj2_rep ?s\""], ["proof (prove)\nusing this:\n  sum proj2_rep {r, p, q} = 0\n\ngoal (1 subgoal):\n 1. sum proj2_rep {r, p, q} =\n    0 *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "by simp"], ["proof (state)\nthis:\n  sum proj2_rep {r, p, q} =\n  0 *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "thus \"\\<exists> j. (\\<Sum> t\\<in>{r,p,q}. proj2_rep t) = j *\\<^sub>R proj2_rep ?s\""], ["proof (prove)\nusing this:\n  sum proj2_rep {r, p, q} =\n  0 *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", ".."], ["proof (state)\nthis:\n  \\<exists>j.\n     sum proj2_rep {r, p, q} =\n     j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n\ngoal (1 subgoal):\n 1. sum proj2_rep {r, p, q} \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sum proj2_rep {r, p, q} \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "assume \"(\\<Sum> t\\<in>{r,p,q}. proj2_rep t) \\<noteq> 0\""], ["proof (state)\nthis:\n  sum proj2_rep {r, p, q} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sum proj2_rep {r, p, q} \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "with proj2_rep_abs2"], ["proof (chain)\npicking this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  sum proj2_rep {r, p, q} \\<noteq> 0", "obtain k where \"k \\<noteq> 0\"\n      and \"proj2_rep ?s = k *\\<^sub>R (\\<Sum> t\\<in>{r,p,q}. proj2_rep t)\""], ["proof (prove)\nusing this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  sum proj2_rep {r, p, q} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<noteq> 0;\n         proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) =\n         k *\\<^sub>R sum proj2_rep {r, p, q}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) =\n  k *\\<^sub>R sum proj2_rep {r, p, q}\n\ngoal (1 subgoal):\n 1. sum proj2_rep {r, p, q} \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "hence \"(1/k) *\\<^sub>R proj2_rep ?s = (\\<Sum> t\\<in>{r,p,q}. proj2_rep t)\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) =\n  k *\\<^sub>R sum proj2_rep {r, p, q}\n\ngoal (1 subgoal):\n 1. (1 / k) *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) =\n    sum proj2_rep {r, p, q}", "by simp"], ["proof (state)\nthis:\n  (1 / k) *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) =\n  sum proj2_rep {r, p, q}\n\ngoal (1 subgoal):\n 1. sum proj2_rep {r, p, q} \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "from this [symmetric]"], ["proof (chain)\npicking this:\n  sum proj2_rep {r, p, q} =\n  (1 / k) *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "show \"\\<exists> j. (\\<Sum> t\\<in>{r,p,q}. proj2_rep t) = j *\\<^sub>R proj2_rep ?s\""], ["proof (prove)\nusing this:\n  sum proj2_rep {r, p, q} =\n  (1 / k) *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       sum proj2_rep {r, p, q} =\n       j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", ".."], ["proof (state)\nthis:\n  \\<exists>j.\n     sum proj2_rep {r, p, q} =\n     j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j.\n     sum proj2_rep {r, p, q} =\n     j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "then"], ["proof (chain)\npicking this:\n  \\<exists>j.\n     sum proj2_rep {r, p, q} =\n     j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "obtain j where \"(\\<Sum> t\\<in>{r,p,q}. proj2_rep t) = j *\\<^sub>R proj2_rep ?s\""], ["proof (prove)\nusing this:\n  \\<exists>j.\n     sum proj2_rep {r, p, q} =\n     j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        sum proj2_rep {r, p, q} =\n        j *\\<^sub>R\n        proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  sum proj2_rep {r, p, q} =\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "let ?c = \"\\<lambda> t. if t = ?s then 1 - j else 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "from \\<open>p \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> q", "have \"?c p \\<noteq> 0 \\<or> ?c q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) \\<noteq>\n    0 \\<or>\n    (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) \\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) \\<noteq>\n  0 \\<or>\n  (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "let ?d = \"\\<lambda> t. if t = ?s then j else -1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "let ?S = \"{?s,r,p,q}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "have \"?s \\<notin> {r,p,q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "assume \"?s \\<in> {r,p,q}\""], ["proof (state)\nthis:\n  proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q}\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "from \\<open>r \\<notin> {p,q}\\<close> and \\<open>p \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  r \\<notin> {p, q}\n  p \\<noteq> q", "have \"?c r *\\<^sub>R proj2_rep r + ?c p *\\<^sub>R proj2_rep p + ?c q *\\<^sub>R proj2_rep q\n      = (\\<Sum> t\\<in>{r,p,q}. ?c t *\\<^sub>R proj2_rep t)\""], ["proof (prove)\nusing this:\n  r \\<notin> {p, q}\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. (if r = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n    proj2_rep r +\n    (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n    proj2_rep p +\n    (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n    proj2_rep q =\n    (\\<Sum>t\\<in>{r, p, q}.\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n        else 1) *\\<^sub>R\n       proj2_rep t)", "by (simp add: sum.insert [of _ _ \"\\<lambda> t. ?c t *\\<^sub>R proj2_rep t\"])"], ["proof (state)\nthis:\n  (if r = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep r +\n  (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep p +\n  (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep q =\n  (\\<Sum>t\\<in>{r, p, q}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n      else 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (if r = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep r +\n  (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep p +\n  (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep q =\n  (\\<Sum>t\\<in>{r, p, q}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n      else 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "from \\<open>finite {r,p,q}\\<close> and \\<open>?s \\<in> {r,p,q}\\<close>"], ["proof (chain)\npicking this:\n  finite {r, p, q}\n  proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q}", "have \"\\<dots> = ?c ?s *\\<^sub>R proj2_rep ?s + (\\<Sum> t\\<in>{r,p,q}-{?s}. ?c t *\\<^sub>R proj2_rep t)\""], ["proof (prove)\nusing this:\n  finite {r, p, q}\n  proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q}\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>{r, p, q}.\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n        else 1) *\\<^sub>R\n       proj2_rep t) =\n    (if proj2_abs (sum proj2_rep {r, p, q}) =\n        proj2_abs (sum proj2_rep {r, p, q})\n     then 1 - j else 1) *\\<^sub>R\n    proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n    (\\<Sum>t\\<in>{r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})}.\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n        else 1) *\\<^sub>R\n       proj2_rep t)", "by (simp only:\n        sum.remove [of \"{r,p,q}\" ?s \"\\<lambda> t. ?c t *\\<^sub>R proj2_rep t\"])"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>{r, p, q}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n      else 1) *\\<^sub>R\n     proj2_rep t) =\n  (if proj2_abs (sum proj2_rep {r, p, q}) =\n      proj2_abs (sum proj2_rep {r, p, q})\n   then 1 - j else 1) *\\<^sub>R\n  proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (\\<Sum>t\\<in>{r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n      else 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>{r, p, q}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n      else 1) *\\<^sub>R\n     proj2_rep t) =\n  (if proj2_abs (sum proj2_rep {r, p, q}) =\n      proj2_abs (sum proj2_rep {r, p, q})\n   then 1 - j else 1) *\\<^sub>R\n  proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (\\<Sum>t\\<in>{r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n      else 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "have \"\\<dots>\n      = -j *\\<^sub>R proj2_rep ?s + (proj2_rep ?s + (\\<Sum> t\\<in>{r,p,q}-{?s}. proj2_rep t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if proj2_abs (sum proj2_rep {r, p, q}) =\n        proj2_abs (sum proj2_rep {r, p, q})\n     then 1 - j else 1) *\\<^sub>R\n    proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n    (\\<Sum>t\\<in>{r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})}.\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n        else 1) *\\<^sub>R\n       proj2_rep t) =\n    - j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n    (proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n     sum proj2_rep ({r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})}))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (if proj2_abs (sum proj2_rep {r, p, q}) =\n      proj2_abs (sum proj2_rep {r, p, q})\n   then 1 - j else 1) *\\<^sub>R\n  proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (\\<Sum>t\\<in>{r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n      else 1) *\\<^sub>R\n     proj2_rep t) =\n  - j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n   sum proj2_rep ({r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})}))\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (if proj2_abs (sum proj2_rep {r, p, q}) =\n      proj2_abs (sum proj2_rep {r, p, q})\n   then 1 - j else 1) *\\<^sub>R\n  proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (\\<Sum>t\\<in>{r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j\n      else 1) *\\<^sub>R\n     proj2_rep t) =\n  - j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n   sum proj2_rep ({r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})}))\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "from \\<open>finite {r,p,q}\\<close> and \\<open>?s \\<in> {r,p,q}\\<close>"], ["proof (chain)\npicking this:\n  finite {r, p, q}\n  proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q}", "have \"\\<dots> = -j *\\<^sub>R proj2_rep ?s + (\\<Sum> t\\<in>{r,p,q}. proj2_rep t)\""], ["proof (prove)\nusing this:\n  finite {r, p, q}\n  proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q}\n\ngoal (1 subgoal):\n 1. - j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n    (proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n     sum proj2_rep ({r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})})) =\n    - j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n    sum proj2_rep {r, p, q}", "by (simp only:\n        sum.remove [of \"{r,p,q}\" ?s \"\\<lambda> t. proj2_rep t\",symmetric])"], ["proof (state)\nthis:\n  - j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n   sum proj2_rep ({r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})})) =\n  - j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  sum proj2_rep {r, p, q}\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  - j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n   sum proj2_rep ({r, p, q} - {proj2_abs (sum proj2_rep {r, p, q})})) =\n  - j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  sum proj2_rep {r, p, q}\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "from \\<open>(\\<Sum> t\\<in>{r,p,q}. proj2_rep t) = j *\\<^sub>R proj2_rep ?s\\<close>"], ["proof (chain)\npicking this:\n  sum proj2_rep {r, p, q} =\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))", "have \"\\<dots> = 0\""], ["proof (prove)\nusing this:\n  sum proj2_rep {r, p, q} =\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n\ngoal (1 subgoal):\n 1. - j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n    sum proj2_rep {r, p, q} =\n    0", "by simp"], ["proof (state)\nthis:\n  - j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  sum proj2_rep {r, p, q} =\n  0\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  (if r = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep r +\n  (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep p +\n  (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep q =\n  0", "have \"?c r *\\<^sub>R proj2_rep r + ?c p *\\<^sub>R proj2_rep p + ?c q *\\<^sub>R proj2_rep q = 0\""], ["proof (prove)\nusing this:\n  (if r = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep r +\n  (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep p +\n  (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep q =\n  0\n\ngoal (1 subgoal):\n 1. (if r = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n    proj2_rep r +\n    (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n    proj2_rep p +\n    (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n    proj2_rep q =\n    0", "."], ["proof (state)\nthis:\n  (if r = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep r +\n  (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep p +\n  (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep q =\n  0\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "with \\<open>?c p \\<noteq> 0 \\<or> ?c q \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) \\<noteq>\n  0 \\<or>\n  (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) \\<noteq> 0\n  (if r = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep r +\n  (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep p +\n  (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep q =\n  0", "have \"proj2_Col p q r\""], ["proof (prove)\nusing this:\n  (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) \\<noteq>\n  0 \\<or>\n  (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) \\<noteq> 0\n  (if r = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep r +\n  (if p = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep p +\n  (if q = proj2_abs (sum proj2_rep {r, p, q}) then 1 - j else 1) *\\<^sub>R\n  proj2_rep q =\n  0\n\ngoal (1 subgoal):\n 1. proj2_Col p q r", "by (unfold proj2_Col_def) (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<in> {r, p, q} \\<Longrightarrow>\n    False", "with \\<open>\\<not> proj2_Col p q r\\<close>"], ["proof (chain)\npicking this:\n  \\<not> proj2_Col p q r\n  proj2_Col p q r", "show False"], ["proof (prove)\nusing this:\n  \\<not> proj2_Col p q r\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q}\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "with \\<open>card {r,p,q} = 3\\<close>"], ["proof (chain)\npicking this:\n  card {r, p, q} = 3\n  proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q}", "have \"card ?S = 4\""], ["proof (prove)\nusing this:\n  card {r, p, q} = 3\n  proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q}\n\ngoal (1 subgoal):\n 1. card {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} = 4", "by simp"], ["proof (state)\nthis:\n  card {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} = 4\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "from \\<open>\\<not> proj2_Col p q r\\<close> and proj2_Col_permute"], ["proof (chain)\npicking this:\n  \\<not> proj2_Col p q r\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?a ?c ?b\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?b ?a ?c", "have \"\\<not> proj2_Col r p q\""], ["proof (prove)\nusing this:\n  \\<not> proj2_Col p q r\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?a ?c ?b\n  proj2_Col ?a ?b ?c \\<Longrightarrow> proj2_Col ?b ?a ?c\n\ngoal (1 subgoal):\n 1. \\<not> proj2_Col r p q", "by fast"], ["proof (state)\nthis:\n  \\<not> proj2_Col r p q\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "hence \"\\<not> proj2_set_Col {r,p,q}\""], ["proof (prove)\nusing this:\n  \\<not> proj2_Col r p q\n\ngoal (1 subgoal):\n 1. \\<not> proj2_set_Col {r, p, q}", "by (subst proj2_Col_iff_set_Col [symmetric])"], ["proof (state)\nthis:\n  \\<not> proj2_set_Col {r, p, q}\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "have \"\\<forall> u\\<in>?S. \\<not> proj2_set_Col (?S - {u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q}.\n       \\<not> proj2_set_Col\n               ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> {proj2_abs (sum proj2_rep {r, p, q}), r, p,\n                q} \\<Longrightarrow>\n       \\<not> proj2_set_Col\n               ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> {proj2_abs (sum proj2_rep {r, p, q}), r, p,\n                q} \\<Longrightarrow>\n       \\<not> proj2_set_Col\n               ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "assume \"u \\<in> ?S\""], ["proof (state)\nthis:\n  u \\<in> {proj2_abs (sum proj2_rep {r, p, q}), r, p, q}\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> {proj2_abs (sum proj2_rep {r, p, q}), r, p,\n                q} \\<Longrightarrow>\n       \\<not> proj2_set_Col\n               ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "with \\<open>card ?S = 4\\<close>"], ["proof (chain)\npicking this:\n  card {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} = 4\n  u \\<in> {proj2_abs (sum proj2_rep {r, p, q}), r, p, q}", "have \"card (?S - {u}) = 3\""], ["proof (prove)\nusing this:\n  card {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} = 4\n  u \\<in> {proj2_abs (sum proj2_rep {r, p, q}), r, p, q}\n\ngoal (1 subgoal):\n 1. card ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}) = 3", "by simp"], ["proof (state)\nthis:\n  card ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}) = 3\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> {proj2_abs (sum proj2_rep {r, p, q}), r, p,\n                q} \\<Longrightarrow>\n       \\<not> proj2_set_Col\n               ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "show \"\\<not> proj2_set_Col (?S - {u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "assume \"u = ?s\""], ["proof (state)\nthis:\n  u = proj2_abs (sum proj2_rep {r, p, q})\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "with \\<open>?s \\<notin> {r,p,q}\\<close>"], ["proof (chain)\npicking this:\n  proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q}\n  u = proj2_abs (sum proj2_rep {r, p, q})", "have \"?S - {u} = {r,p,q}\""], ["proof (prove)\nusing this:\n  proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q}\n  u = proj2_abs (sum proj2_rep {r, p, q})\n\ngoal (1 subgoal):\n 1. {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u} = {r, p, q}", "by simp"], ["proof (state)\nthis:\n  {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u} = {r, p, q}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "with \\<open>\\<not> proj2_set_Col {r,p,q}\\<close>"], ["proof (chain)\npicking this:\n  \\<not> proj2_set_Col {r, p, q}\n  {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u} = {r, p, q}", "show \"\\<not> proj2_set_Col (?S - {u})\""], ["proof (prove)\nusing this:\n  \\<not> proj2_set_Col {r, p, q}\n  {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u} = {r, p, q}\n\ngoal (1 subgoal):\n 1. \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "by simp"], ["proof (state)\nthis:\n  \\<not> proj2_set_Col\n          ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "assume \"u \\<noteq> ?s\""], ["proof (state)\nthis:\n  u \\<noteq> proj2_abs (sum proj2_rep {r, p, q})\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "hence \"insert ?s ({r,p,q} - {u}) = ?S - {u}\""], ["proof (prove)\nusing this:\n  u \\<noteq> proj2_abs (sum proj2_rep {r, p, q})\n\ngoal (1 subgoal):\n 1. insert (proj2_abs (sum proj2_rep {r, p, q})) ({r, p, q} - {u}) =\n    {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}", "by auto"], ["proof (state)\nthis:\n  insert (proj2_abs (sum proj2_rep {r, p, q})) ({r, p, q} - {u}) =\n  {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "from \\<open>finite {r,p,q}\\<close>"], ["proof (chain)\npicking this:\n  finite {r, p, q}", "have \"finite ({r,p,q} - {u})\""], ["proof (prove)\nusing this:\n  finite {r, p, q}\n\ngoal (1 subgoal):\n 1. finite ({r, p, q} - {u})", "by simp"], ["proof (state)\nthis:\n  finite ({r, p, q} - {u})\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "from \\<open>?s \\<notin> {r,p,q}\\<close>"], ["proof (chain)\npicking this:\n  proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q}", "have \"?s \\<notin> {r,p,q} - {u}\""], ["proof (prove)\nusing this:\n  proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q}\n\ngoal (1 subgoal):\n 1. proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q} - {u}", "by simp"], ["proof (state)\nthis:\n  proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q} - {u}\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "hence \"\\<forall> t\\<in>{r,p,q}-{u}. ?d t = -1\""], ["proof (prove)\nusing this:\n  proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q} - {u}\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{r, p, q} - {u}.\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) = - 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) = - 1\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "from \\<open>u \\<noteq> ?s\\<close> and  \\<open>u \\<in> ?S\\<close>"], ["proof (chain)\npicking this:\n  u \\<noteq> proj2_abs (sum proj2_rep {r, p, q})\n  u \\<in> {proj2_abs (sum proj2_rep {r, p, q}), r, p, q}", "have \"u \\<in> {r,p,q}\""], ["proof (prove)\nusing this:\n  u \\<noteq> proj2_abs (sum proj2_rep {r, p, q})\n  u \\<in> {proj2_abs (sum proj2_rep {r, p, q}), r, p, q}\n\ngoal (1 subgoal):\n 1. u \\<in> {r, p, q}", "by simp"], ["proof (state)\nthis:\n  u \\<in> {r, p, q}\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "hence \"(\\<Sum> t\\<in>{r,p,q}. proj2_rep t)\n        = proj2_rep u + (\\<Sum> t\\<in>{r,p,q}-{u}. proj2_rep t)\""], ["proof (prove)\nusing this:\n  u \\<in> {r, p, q}\n\ngoal (1 subgoal):\n 1. sum proj2_rep {r, p, q} = proj2_rep u + sum proj2_rep ({r, p, q} - {u})", "by (simp add: sum.remove)"], ["proof (state)\nthis:\n  sum proj2_rep {r, p, q} = proj2_rep u + sum proj2_rep ({r, p, q} - {u})\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "with \\<open>(\\<Sum> t\\<in>{r,p,q}. proj2_rep t) = j *\\<^sub>R proj2_rep ?s\\<close>"], ["proof (chain)\npicking this:\n  sum proj2_rep {r, p, q} =\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n  sum proj2_rep {r, p, q} = proj2_rep u + sum proj2_rep ({r, p, q} - {u})", "have \"proj2_rep u\n        = j *\\<^sub>R proj2_rep ?s - (\\<Sum> t\\<in>{r,p,q}-{u}. proj2_rep t)\""], ["proof (prove)\nusing this:\n  sum proj2_rep {r, p, q} =\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q}))\n  sum proj2_rep {r, p, q} = proj2_rep u + sum proj2_rep ({r, p, q} - {u})\n\ngoal (1 subgoal):\n 1. proj2_rep u =\n    j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) -\n    sum proj2_rep ({r, p, q} - {u})", "by simp"], ["proof (state)\nthis:\n  proj2_rep u =\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) -\n  sum proj2_rep ({r, p, q} - {u})\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "also"], ["proof (state)\nthis:\n  proj2_rep u =\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) -\n  sum proj2_rep ({r, p, q} - {u})\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "from \\<open>\\<forall> t\\<in>{r,p,q}-{u}. ?d t = -1\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>{r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) = - 1", "have \"\\<dots> = j *\\<^sub>R proj2_rep ?s + (\\<Sum> t\\<in>{r,p,q}-{u}. ?d t *\\<^sub>R proj2_rep t)\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) = - 1\n\ngoal (1 subgoal):\n 1. j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) -\n    sum proj2_rep ({r, p, q} - {u}) =\n    j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n    (\\<Sum>t\\<in>{r, p, q} - {u}.\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then j\n        else - 1) *\\<^sub>R\n       proj2_rep t)", "by (simp add: sum_negf)"], ["proof (state)\nthis:\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) -\n  sum proj2_rep ({r, p, q} - {u}) =\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (\\<Sum>t\\<in>{r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "also"], ["proof (state)\nthis:\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) -\n  sum proj2_rep ({r, p, q} - {u}) =\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (\\<Sum>t\\<in>{r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "from \\<open>finite ({r,p,q} - {u})\\<close>  and \\<open>?s \\<notin> {r,p,q} - {u}\\<close>"], ["proof (chain)\npicking this:\n  finite ({r, p, q} - {u})\n  proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q} - {u}", "have \"\\<dots> = (\\<Sum> t\\<in>insert ?s ({r,p,q}-{u}). ?d t *\\<^sub>R proj2_rep t)\""], ["proof (prove)\nusing this:\n  finite ({r, p, q} - {u})\n  proj2_abs (sum proj2_rep {r, p, q}) \\<notin> {r, p, q} - {u}\n\ngoal (1 subgoal):\n 1. j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n    (\\<Sum>t\\<in>{r, p, q} - {u}.\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then j\n        else - 1) *\\<^sub>R\n       proj2_rep t) =\n    (\\<Sum>t\\<in>insert (proj2_abs (sum proj2_rep {r, p, q}))\n                  ({r, p, q} - {u}).\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then j\n        else - 1) *\\<^sub>R\n       proj2_rep t)", "by (simp add: sum.insert)"], ["proof (state)\nthis:\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (\\<Sum>t\\<in>{r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t) =\n  (\\<Sum>t\\<in>insert (proj2_abs (sum proj2_rep {r, p, q}))\n                ({r, p, q} - {u}).\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "also"], ["proof (state)\nthis:\n  j *\\<^sub>R proj2_rep (proj2_abs (sum proj2_rep {r, p, q})) +\n  (\\<Sum>t\\<in>{r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t) =\n  (\\<Sum>t\\<in>insert (proj2_abs (sum proj2_rep {r, p, q}))\n                ({r, p, q} - {u}).\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "from \\<open>insert ?s ({r,p,q} - {u}) = ?S - {u}\\<close>"], ["proof (chain)\npicking this:\n  insert (proj2_abs (sum proj2_rep {r, p, q})) ({r, p, q} - {u}) =\n  {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}", "have \"\\<dots> = (\\<Sum> t\\<in>?S-{u}. ?d t *\\<^sub>R proj2_rep t)\""], ["proof (prove)\nusing this:\n  insert (proj2_abs (sum proj2_rep {r, p, q})) ({r, p, q} - {u}) =\n  {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>insert (proj2_abs (sum proj2_rep {r, p, q}))\n                  ({r, p, q} - {u}).\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then j\n        else - 1) *\\<^sub>R\n       proj2_rep t) =\n    (\\<Sum>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then j\n        else - 1) *\\<^sub>R\n       proj2_rep t)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>insert (proj2_abs (sum proj2_rep {r, p, q}))\n                ({r, p, q} - {u}).\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t) =\n  (\\<Sum>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "finally"], ["proof (chain)\npicking this:\n  proj2_rep u =\n  (\\<Sum>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t)", "have \"proj2_rep u = (\\<Sum> t\\<in>?S-{u}. ?d t *\\<^sub>R proj2_rep t)\""], ["proof (prove)\nusing this:\n  proj2_rep u =\n  (\\<Sum>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. proj2_rep u =\n    (\\<Sum>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then j\n        else - 1) *\\<^sub>R\n       proj2_rep t)", "."], ["proof (state)\nthis:\n  proj2_rep u =\n  (\\<Sum>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "moreover"], ["proof (state)\nthis:\n  proj2_rep u =\n  (\\<Sum>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t)\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "have \"\\<forall> t\\<in>?S-{u}. ?d t *\\<^sub>R proj2_rep t \\<in> span (proj2_rep ` (?S - {u}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n       (if t = proj2_abs (sum proj2_rep {r, p, q}) then j\n        else - 1) *\\<^sub>R\n       proj2_rep t\n       \\<in> span\n              (proj2_rep `\n               ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "by (simp add: span_clauses)"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t\n     \\<in> span\n            (proj2_rep `\n             ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "ultimately"], ["proof (chain)\npicking this:\n  proj2_rep u =\n  (\\<Sum>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t)\n  \\<forall>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t\n     \\<in> span\n            (proj2_rep `\n             ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "have \"proj2_rep u \\<in> span (proj2_rep ` (?S - {u}))\""], ["proof (prove)\nusing this:\n  proj2_rep u =\n  (\\<Sum>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t)\n  \\<forall>t\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}.\n     (if t = proj2_abs (sum proj2_rep {r, p, q}) then j else - 1) *\\<^sub>R\n     proj2_rep t\n     \\<in> span\n            (proj2_rep `\n             ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal (1 subgoal):\n 1. proj2_rep u\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "by (metis (no_types, lifting) span_sum)"], ["proof (state)\nthis:\n  proj2_rep u\n  \\<in> span\n         (proj2_rep `\n          ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "have \"\\<forall> t\\<in>{r,p,q}. proj2_rep t \\<in> span (proj2_rep ` (?S - {u}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{r, p, q}.\n       proj2_rep t\n       \\<in> span\n              (proj2_rep `\n               ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {r, p, q} \\<Longrightarrow>\n       proj2_rep t\n       \\<in> span\n              (proj2_rep `\n               ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {r, p, q} \\<Longrightarrow>\n       proj2_rep t\n       \\<in> span\n              (proj2_rep `\n               ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "assume \"t \\<in> {r,p,q}\""], ["proof (state)\nthis:\n  t \\<in> {r, p, q}\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {r, p, q} \\<Longrightarrow>\n       proj2_rep t\n       \\<in> span\n              (proj2_rep `\n               ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "show \"proj2_rep t \\<in> span (proj2_rep ` (?S - {u}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep t\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    proj2_rep t\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n 2. \\<not> ?P \\<Longrightarrow>\n    proj2_rep t\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "assume \"t = u\""], ["proof (state)\nthis:\n  t = u\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    proj2_rep t\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n 2. \\<not> ?P \\<Longrightarrow>\n    proj2_rep t\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "from \\<open>proj2_rep u \\<in> span (image proj2_rep (?S - {u}))\\<close>"], ["proof (chain)\npicking this:\n  proj2_rep u\n  \\<in> span\n         (proj2_rep `\n          ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "show \"proj2_rep t \\<in> span (proj2_rep ` (?S - {u}))\""], ["proof (prove)\nusing this:\n  proj2_rep u\n  \\<in> span\n         (proj2_rep `\n          ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal (1 subgoal):\n 1. proj2_rep t\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "by (subst \\<open>t = u\\<close>)"], ["proof (state)\nthis:\n  proj2_rep t\n  \\<in> span\n         (proj2_rep `\n          ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal (1 subgoal):\n 1. t \\<noteq> u \\<Longrightarrow>\n    proj2_rep t\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> u \\<Longrightarrow>\n    proj2_rep t\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "assume \"t \\<noteq> u\""], ["proof (state)\nthis:\n  t \\<noteq> u\n\ngoal (1 subgoal):\n 1. t \\<noteq> u \\<Longrightarrow>\n    proj2_rep t\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "with \\<open>t \\<in> {r,p,q}\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> {r, p, q}\n  t \\<noteq> u", "have \"proj2_rep t \\<in> proj2_rep ` (?S - {u})\""], ["proof (prove)\nusing this:\n  t \\<in> {r, p, q}\n  t \\<noteq> u\n\ngoal (1 subgoal):\n 1. proj2_rep t\n    \\<in> proj2_rep ` ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "by simp"], ["proof (state)\nthis:\n  proj2_rep t\n  \\<in> proj2_rep ` ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n\ngoal (1 subgoal):\n 1. t \\<noteq> u \\<Longrightarrow>\n    proj2_rep t\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "with span_superset [of \"proj2_rep ` (?S - {u})\"]"], ["proof (chain)\npicking this:\n  proj2_rep ` ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n  \\<subseteq> span\n               (proj2_rep `\n                ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n  proj2_rep t\n  \\<in> proj2_rep ` ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "show \"proj2_rep t \\<in> span (proj2_rep ` (?S - {u}))\""], ["proof (prove)\nusing this:\n  proj2_rep ` ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n  \\<subseteq> span\n               (proj2_rep `\n                ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n  proj2_rep t\n  \\<in> proj2_rep ` ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n\ngoal (1 subgoal):\n 1. proj2_rep t\n    \\<in> span\n           (proj2_rep `\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "by fast"], ["proof (state)\nthis:\n  proj2_rep t\n  \\<in> span\n         (proj2_rep `\n          ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj2_rep t\n  \\<in> span\n         (proj2_rep `\n          ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{r, p, q}.\n     proj2_rep t\n     \\<in> span\n            (proj2_rep `\n             ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "hence \"proj2_rep ` {r,p,q} \\<subseteq> span (proj2_rep ` (?S - {u}))\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{r, p, q}.\n     proj2_rep t\n     \\<in> span\n            (proj2_rep `\n             ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal (1 subgoal):\n 1. proj2_rep ` {r, p, q}\n    \\<subseteq> span\n                 (proj2_rep `\n                  ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "by (simp only: image_subset_iff)"], ["proof (state)\nthis:\n  proj2_rep ` {r, p, q}\n  \\<subseteq> span\n               (proj2_rep `\n                ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "hence\n        \"span (proj2_rep ` {r,p,q}) \\<subseteq> span (span (proj2_rep ` (?S - {u})))\""], ["proof (prove)\nusing this:\n  proj2_rep ` {r, p, q}\n  \\<subseteq> span\n               (proj2_rep `\n                ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal (1 subgoal):\n 1. span (proj2_rep ` {r, p, q})\n    \\<subseteq> span\n                 (span\n                   (proj2_rep `\n                    ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})))", "by (simp only: span_mono)"], ["proof (state)\nthis:\n  span (proj2_rep ` {r, p, q})\n  \\<subseteq> span\n               (span\n                 (proj2_rep `\n                  ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})))\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "hence \"span (proj2_rep ` {r,p,q}) \\<subseteq> span (proj2_rep ` (?S - {u}))\""], ["proof (prove)\nusing this:\n  span (proj2_rep ` {r, p, q})\n  \\<subseteq> span\n               (span\n                 (proj2_rep `\n                  ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})))\n\ngoal (1 subgoal):\n 1. span (proj2_rep ` {r, p, q})\n    \\<subseteq> span\n                 (proj2_rep `\n                  ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))", "by (simp only: span_span)"], ["proof (state)\nthis:\n  span (proj2_rep ` {r, p, q})\n  \\<subseteq> span\n               (proj2_rep `\n                ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "moreover"], ["proof (state)\nthis:\n  span (proj2_rep ` {r, p, q})\n  \\<subseteq> span\n               (proj2_rep `\n                ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "from \\<open>\\<not> proj2_set_Col {r,p,q}\\<close>\n        and \\<open>card {r,p,q} = 3\\<close>\n        and not_proj2_set_Col_iff_span"], ["proof (chain)\npicking this:\n  \\<not> proj2_set_Col {r, p, q}\n  card {r, p, q} = 3\n  card ?S = 3 \\<Longrightarrow>\n  (\\<not> proj2_set_Col ?S) = (span (proj2_rep ` ?S) = UNIV)", "have \"span (proj2_rep ` {r,p,q}) = UNIV\""], ["proof (prove)\nusing this:\n  \\<not> proj2_set_Col {r, p, q}\n  card {r, p, q} = 3\n  card ?S = 3 \\<Longrightarrow>\n  (\\<not> proj2_set_Col ?S) = (span (proj2_rep ` ?S) = UNIV)\n\ngoal (1 subgoal):\n 1. span (proj2_rep ` {r, p, q}) = UNIV", "by simp"], ["proof (state)\nthis:\n  span (proj2_rep ` {r, p, q}) = UNIV\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "ultimately"], ["proof (chain)\npicking this:\n  span (proj2_rep ` {r, p, q})\n  \\<subseteq> span\n               (proj2_rep `\n                ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n  span (proj2_rep ` {r, p, q}) = UNIV", "have \"span (proj2_rep ` (?S - {u})) = UNIV\""], ["proof (prove)\nusing this:\n  span (proj2_rep ` {r, p, q})\n  \\<subseteq> span\n               (proj2_rep `\n                ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}))\n  span (proj2_rep ` {r, p, q}) = UNIV\n\ngoal (1 subgoal):\n 1. span\n     (proj2_rep ` ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})) =\n    UNIV", "by auto"], ["proof (state)\nthis:\n  span\n   (proj2_rep ` ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})) =\n  UNIV\n\ngoal (1 subgoal):\n 1. u \\<noteq> proj2_abs (sum proj2_rep {r, p, q}) \\<Longrightarrow>\n    \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "with \\<open>card (?S - {u}) = 3\\<close> and not_proj2_set_Col_iff_span"], ["proof (chain)\npicking this:\n  card ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}) = 3\n  card ?S = 3 \\<Longrightarrow>\n  (\\<not> proj2_set_Col ?S) = (span (proj2_rep ` ?S) = UNIV)\n  span\n   (proj2_rep ` ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})) =\n  UNIV", "show \"\\<not> proj2_set_Col (?S - {u})\""], ["proof (prove)\nusing this:\n  card ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u}) = 3\n  card ?S = 3 \\<Longrightarrow>\n  (\\<not> proj2_set_Col ?S) = (span (proj2_rep ` ?S) = UNIV)\n  span\n   (proj2_rep ` ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})) =\n  UNIV\n\ngoal (1 subgoal):\n 1. \\<not> proj2_set_Col\n            ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "by simp"], ["proof (state)\nthis:\n  \\<not> proj2_set_Col\n          ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> proj2_set_Col\n          ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q}.\n     \\<not> proj2_set_Col\n             ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "with \\<open>card ?S = 4\\<close>"], ["proof (chain)\npicking this:\n  card {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} = 4\n  \\<forall>u\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q}.\n     \\<not> proj2_set_Col\n             ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})", "have \"proj2_no_3_Col ?S\""], ["proof (prove)\nusing this:\n  card {proj2_abs (sum proj2_rep {r, p, q}), r, p, q} = 4\n  \\<forall>u\\<in>{proj2_abs (sum proj2_rep {r, p, q}), r, p, q}.\n     \\<not> proj2_set_Col\n             ({proj2_abs (sum proj2_rep {r, p, q}), r, p, q} - {u})\n\ngoal (1 subgoal):\n 1. proj2_no_3_Col {proj2_abs (sum proj2_rep {r, p, q}), r, p, q}", "by (unfold proj2_no_3_Col_def) fast"], ["proof (state)\nthis:\n  proj2_no_3_Col {proj2_abs (sum proj2_rep {r, p, q}), r, p, q}\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", "thus \"\\<exists> s. proj2_no_3_Col {s,r,p,q}\""], ["proof (prove)\nusing this:\n  proj2_no_3_Col {proj2_abs (sum proj2_rep {r, p, q}), r, p, q}\n\ngoal (1 subgoal):\n 1. \\<exists>s. proj2_no_3_Col {s, r, p, q}", ".."], ["proof (state)\nthis:\n  \\<exists>s. proj2_no_3_Col {s, r, p, q}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_set_Col_expand:\n  assumes \"proj2_set_Col S\" and \"{p,q,r} \\<subseteq> S\" and \"p \\<noteq> q\" and \"r \\<noteq> p\"\n  shows \"\\<exists> k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)", "from \\<open>proj2_set_Col S\\<close>"], ["proof (chain)\npicking this:\n  proj2_set_Col S", "obtain l where \"\\<forall> t\\<in>S. proj2_incident t l\""], ["proof (prove)\nusing this:\n  proj2_set_Col S\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<forall>t\\<in>S. proj2_incident t l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding proj2_set_Col_def"], ["proof (prove)\nusing this:\n  \\<exists>l. \\<forall>p\\<in>S. proj2_incident p l\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<forall>t\\<in>S. proj2_incident t l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>t\\<in>S. proj2_incident t l\n\ngoal (1 subgoal):\n 1. \\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)", "with \\<open>{p,q,r} \\<subseteq> S\\<close> and \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and proj2_incident_iff [of p q l r]"], ["proof (chain)\npicking this:\n  {p, q, r} \\<subseteq> S\n  p \\<noteq> q\n  r \\<noteq> p\n  \\<lbrakk>p \\<noteq> q; proj2_incident p l; proj2_incident q l\\<rbrakk>\n  \\<Longrightarrow> proj2_incident r l =\n                    (r = p \\<or>\n                     (\\<exists>k.\n                         r =\n                         proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)))\n  \\<forall>t\\<in>S. proj2_incident t l", "show \"\\<exists> k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\""], ["proof (prove)\nusing this:\n  {p, q, r} \\<subseteq> S\n  p \\<noteq> q\n  r \\<noteq> p\n  \\<lbrakk>p \\<noteq> q; proj2_incident p l; proj2_incident q l\\<rbrakk>\n  \\<Longrightarrow> proj2_incident r l =\n                    (r = p \\<or>\n                     (\\<exists>k.\n                         r =\n                         proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)))\n  \\<forall>t\\<in>S. proj2_incident t l\n\ngoal (1 subgoal):\n 1. \\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)", "by simp"], ["proof (state)\nthis:\n  \\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Collineations of the real projective plane\""], ["", "typedef cltn2 =\n  \"(Collect invertible :: (real^3^3) set)//invertible_proportionality\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Collect invertible // invertible_proportionality", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> Collect invertible // invertible_proportionality", "from matrix_id_invertible"], ["proof (chain)\npicking this:\n  invertible (mat (1::?'a))", "have \"(mat 1 :: real^3^3) \\<in> Collect invertible\""], ["proof (prove)\nusing this:\n  invertible (mat (1::?'a))\n\ngoal (1 subgoal):\n 1. mat 1 \\<in> Collect invertible", "by simp"], ["proof (state)\nthis:\n  mat 1 \\<in> Collect invertible\n\ngoal (1 subgoal):\n 1. ?x \\<in> Collect invertible // invertible_proportionality", "thus \"invertible_proportionality `` {mat 1} \\<in>\n    (Collect invertible :: (real^3^3) set)//invertible_proportionality\""], ["proof (prove)\nusing this:\n  mat 1 \\<in> Collect invertible\n\ngoal (1 subgoal):\n 1. invertible_proportionality `` {mat 1}\n    \\<in> Collect invertible // invertible_proportionality", "unfolding quotient_def"], ["proof (prove)\nusing this:\n  mat 1 \\<in> Collect invertible\n\ngoal (1 subgoal):\n 1. invertible_proportionality `` {mat 1}\n    \\<in> (\\<Union>x\\<in>Collect invertible.\n              {invertible_proportionality `` {x}})", "by auto"], ["proof (state)\nthis:\n  invertible_proportionality `` {mat 1}\n  \\<in> Collect invertible // invertible_proportionality\n\ngoal:\nNo subgoals!", "qed"], ["", "definition cltn2_rep :: \"cltn2 \\<Rightarrow> real^3^3\" where\n  \"cltn2_rep A \\<equiv> \\<some> B. B \\<in> Rep_cltn2 A\""], ["", "definition cltn2_abs :: \"real^3^3 \\<Rightarrow> cltn2\" where\n  \"cltn2_abs B \\<equiv> Abs_cltn2 (invertible_proportionality `` {B})\""], ["", "definition cltn2_independent :: \"cltn2 set \\<Rightarrow> bool\" where\n  \"cltn2_independent X \\<equiv> independent {cltn2_rep A | A. A \\<in> X}\""], ["", "definition apply_cltn2 :: \"proj2 \\<Rightarrow> cltn2 \\<Rightarrow> proj2\" where\n  \"apply_cltn2 x A \\<equiv> proj2_abs (proj2_rep x v* cltn2_rep A)\""], ["", "lemma cltn2_rep_in: \"cltn2_rep B \\<in> Rep_cltn2 B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_rep B \\<in> Rep_cltn2 B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_rep B \\<in> Rep_cltn2 B", "let ?A = \"cltn2_rep B\""], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_rep B \\<in> Rep_cltn2 B", "from quotient_element_nonempty and\n    invertible_proportionality_equiv and\n    Rep_cltn2 [of B]"], ["proof (chain)\npicking this:\n  \\<lbrakk>equiv ?A ?r; ?X \\<in> ?A // ?r\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> ?X\n  equiv (Collect invertible) invertible_proportionality\n  Rep_cltn2 B \\<in> Collect invertible // invertible_proportionality", "have \"\\<exists> C. C \\<in> Rep_cltn2 B\""], ["proof (prove)\nusing this:\n  \\<lbrakk>equiv ?A ?r; ?X \\<in> ?A // ?r\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. x \\<in> ?X\n  equiv (Collect invertible) invertible_proportionality\n  Rep_cltn2 B \\<in> Collect invertible // invertible_proportionality\n\ngoal (1 subgoal):\n 1. \\<exists>C. C \\<in> Rep_cltn2 B", "by auto"], ["proof (state)\nthis:\n  \\<exists>C. C \\<in> Rep_cltn2 B\n\ngoal (1 subgoal):\n 1. cltn2_rep B \\<in> Rep_cltn2 B", "with someI_ex [of \"\\<lambda> C. C \\<in> Rep_cltn2 B\"]"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<in> Rep_cltn2 B \\<Longrightarrow>\n  (SOME x. x \\<in> Rep_cltn2 B) \\<in> Rep_cltn2 B\n  \\<exists>C. C \\<in> Rep_cltn2 B", "show \"?A \\<in> Rep_cltn2 B\""], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> Rep_cltn2 B \\<Longrightarrow>\n  (SOME x. x \\<in> Rep_cltn2 B) \\<in> Rep_cltn2 B\n  \\<exists>C. C \\<in> Rep_cltn2 B\n\ngoal (1 subgoal):\n 1. cltn2_rep B \\<in> Rep_cltn2 B", "unfolding cltn2_rep_def"], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> Rep_cltn2 B \\<Longrightarrow>\n  (SOME x. x \\<in> Rep_cltn2 B) \\<in> Rep_cltn2 B\n  \\<exists>C. C \\<in> Rep_cltn2 B\n\ngoal (1 subgoal):\n 1. (SOME Ba. Ba \\<in> Rep_cltn2 B) \\<in> Rep_cltn2 B", "by simp"], ["proof (state)\nthis:\n  cltn2_rep B \\<in> Rep_cltn2 B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_rep_invertible: \"invertible (cltn2_rep A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A)", "from\n    Union_quotient [of \"Collect invertible\" invertible_proportionality]\n    and invertible_proportionality_equiv\n    and Rep_cltn2 [of A] and cltn2_rep_in [of A]"], ["proof (chain)\npicking this:\n  equiv (Collect invertible) invertible_proportionality \\<Longrightarrow>\n  \\<Union> (Collect invertible // invertible_proportionality) =\n  Collect invertible\n  equiv (Collect invertible) invertible_proportionality\n  Rep_cltn2 A \\<in> Collect invertible // invertible_proportionality\n  cltn2_rep A \\<in> Rep_cltn2 A", "have \"cltn2_rep A \\<in> Collect invertible\""], ["proof (prove)\nusing this:\n  equiv (Collect invertible) invertible_proportionality \\<Longrightarrow>\n  \\<Union> (Collect invertible // invertible_proportionality) =\n  Collect invertible\n  equiv (Collect invertible) invertible_proportionality\n  Rep_cltn2 A \\<in> Collect invertible // invertible_proportionality\n  cltn2_rep A \\<in> Rep_cltn2 A\n\ngoal (1 subgoal):\n 1. cltn2_rep A \\<in> Collect invertible", "unfolding quotient_def"], ["proof (prove)\nusing this:\n  equiv (Collect invertible) invertible_proportionality \\<Longrightarrow>\n  \\<Union>\n   (\\<Union>x\\<in>Collect invertible. {invertible_proportionality `` {x}}) =\n  Collect invertible\n  equiv (Collect invertible) invertible_proportionality\n  Rep_cltn2 A\n  \\<in> (\\<Union>x\\<in>Collect invertible.\n            {invertible_proportionality `` {x}})\n  cltn2_rep A \\<in> Rep_cltn2 A\n\ngoal (1 subgoal):\n 1. cltn2_rep A \\<in> Collect invertible", "by auto"], ["proof (state)\nthis:\n  cltn2_rep A \\<in> Collect invertible\n\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A)", "thus \"invertible (cltn2_rep A)\""], ["proof (prove)\nusing this:\n  cltn2_rep A \\<in> Collect invertible\n\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A)", "unfolding invertible_proportionality_def"], ["proof (prove)\nusing this:\n  cltn2_rep A \\<in> Collect invertible\n\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A)", "by simp"], ["proof (state)\nthis:\n  invertible (cltn2_rep A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_rep_abs:\n  fixes A :: \"real^3^3\"\n  assumes \"invertible A\"\n  shows \"(A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality", "from \\<open>invertible A\\<close>"], ["proof (chain)\npicking this:\n  invertible A", "have \"invertible_proportionality `` {A} \\<in> (Collect invertible :: (real^3^3) set)//invertible_proportionality\""], ["proof (prove)\nusing this:\n  invertible A\n\ngoal (1 subgoal):\n 1. invertible_proportionality `` {A}\n    \\<in> Collect invertible // invertible_proportionality", "unfolding quotient_def"], ["proof (prove)\nusing this:\n  invertible A\n\ngoal (1 subgoal):\n 1. invertible_proportionality `` {A}\n    \\<in> (\\<Union>x\\<in>Collect invertible.\n              {invertible_proportionality `` {x}})", "by auto"], ["proof (state)\nthis:\n  invertible_proportionality `` {A}\n  \\<in> Collect invertible // invertible_proportionality\n\ngoal (1 subgoal):\n 1. (A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality", "with Abs_cltn2_inverse"], ["proof (chain)\npicking this:\n  ?y \\<in> Collect invertible //\n           invertible_proportionality \\<Longrightarrow>\n  Rep_cltn2 (Abs_cltn2 ?y) = ?y\n  invertible_proportionality `` {A}\n  \\<in> Collect invertible // invertible_proportionality", "have \"Rep_cltn2 (cltn2_abs A) = invertible_proportionality `` {A}\""], ["proof (prove)\nusing this:\n  ?y \\<in> Collect invertible //\n           invertible_proportionality \\<Longrightarrow>\n  Rep_cltn2 (Abs_cltn2 ?y) = ?y\n  invertible_proportionality `` {A}\n  \\<in> Collect invertible // invertible_proportionality\n\ngoal (1 subgoal):\n 1. Rep_cltn2 (cltn2_abs A) = invertible_proportionality `` {A}", "unfolding cltn2_abs_def"], ["proof (prove)\nusing this:\n  ?y \\<in> Collect invertible //\n           invertible_proportionality \\<Longrightarrow>\n  Rep_cltn2 (Abs_cltn2 ?y) = ?y\n  invertible_proportionality `` {A}\n  \\<in> Collect invertible // invertible_proportionality\n\ngoal (1 subgoal):\n 1. Rep_cltn2 (Abs_cltn2 (invertible_proportionality `` {A})) =\n    invertible_proportionality `` {A}", "by simp"], ["proof (state)\nthis:\n  Rep_cltn2 (cltn2_abs A) = invertible_proportionality `` {A}\n\ngoal (1 subgoal):\n 1. (A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality", "with cltn2_rep_in"], ["proof (chain)\npicking this:\n  cltn2_rep ?B \\<in> Rep_cltn2 ?B\n  Rep_cltn2 (cltn2_abs A) = invertible_proportionality `` {A}", "have \"cltn2_rep (cltn2_abs A) \\<in> invertible_proportionality `` {A}\""], ["proof (prove)\nusing this:\n  cltn2_rep ?B \\<in> Rep_cltn2 ?B\n  Rep_cltn2 (cltn2_abs A) = invertible_proportionality `` {A}\n\ngoal (1 subgoal):\n 1. cltn2_rep (cltn2_abs A) \\<in> invertible_proportionality `` {A}", "by auto"], ["proof (state)\nthis:\n  cltn2_rep (cltn2_abs A) \\<in> invertible_proportionality `` {A}\n\ngoal (1 subgoal):\n 1. (A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality", "thus \"(A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality\""], ["proof (prove)\nusing this:\n  cltn2_rep (cltn2_abs A) \\<in> invertible_proportionality `` {A}\n\ngoal (1 subgoal):\n 1. (A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality", "by simp"], ["proof (state)\nthis:\n  (A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_rep_abs2:\n  assumes \"invertible A\"\n  shows \"\\<exists> k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A", "from \\<open>invertible A\\<close> and cltn2_rep_abs"], ["proof (chain)\npicking this:\n  invertible A\n  invertible ?A \\<Longrightarrow>\n  (?A, cltn2_rep (cltn2_abs ?A)) \\<in> invertible_proportionality", "have \"(A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality\""], ["proof (prove)\nusing this:\n  invertible A\n  invertible ?A \\<Longrightarrow>\n  (?A, cltn2_rep (cltn2_abs ?A)) \\<in> invertible_proportionality\n\ngoal (1 subgoal):\n 1. (A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality", "by simp"], ["proof (state)\nthis:\n  (A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A", "then"], ["proof (chain)\npicking this:\n  (A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality", "obtain c where \"A = c *\\<^sub>R cltn2_rep (cltn2_abs A)\""], ["proof (prove)\nusing this:\n  (A, cltn2_rep (cltn2_abs A)) \\<in> invertible_proportionality\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        A = c *\\<^sub>R cltn2_rep (cltn2_abs A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding invertible_proportionality_def and real_vector.proportionality_def"], ["proof (prove)\nusing this:\n  (A, cltn2_rep (cltn2_abs A))\n  \\<in> Restr\n         {(x, y).\n          x \\<noteq> 0 \\<and>\n          y \\<noteq> 0 \\<and> (\\<exists>k. x = k *\\<^sub>R y)}\n         (Collect invertible)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        A = c *\\<^sub>R cltn2_rep (cltn2_abs A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A = c *\\<^sub>R cltn2_rep (cltn2_abs A)\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A", "with \\<open>invertible A\\<close> and zero_not_invertible"], ["proof (chain)\npicking this:\n  invertible A\n  \\<not> invertible 0\n  A = c *\\<^sub>R cltn2_rep (cltn2_abs A)", "have \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  invertible A\n  \\<not> invertible 0\n  A = c *\\<^sub>R cltn2_rep (cltn2_abs A)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A", "hence \"1/c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 / c \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  1 / c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A", "let ?k = \"1/c\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A", "from \\<open>A = c *\\<^sub>R cltn2_rep (cltn2_abs A)\\<close>"], ["proof (chain)\npicking this:\n  A = c *\\<^sub>R cltn2_rep (cltn2_abs A)", "have \"?k *\\<^sub>R A = ?k *\\<^sub>R c *\\<^sub>R cltn2_rep (cltn2_abs A)\""], ["proof (prove)\nusing this:\n  A = c *\\<^sub>R cltn2_rep (cltn2_abs A)\n\ngoal (1 subgoal):\n 1. (1 / c) *\\<^sub>R A =\n    (1 / c) *\\<^sub>R c *\\<^sub>R cltn2_rep (cltn2_abs A)", "by simp"], ["proof (state)\nthis:\n  (1 / c) *\\<^sub>R A =\n  (1 / c) *\\<^sub>R c *\\<^sub>R cltn2_rep (cltn2_abs A)\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A", "with \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> 0\n  (1 / c) *\\<^sub>R A =\n  (1 / c) *\\<^sub>R c *\\<^sub>R cltn2_rep (cltn2_abs A)", "have \"cltn2_rep (cltn2_abs A) = ?k *\\<^sub>R A\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  (1 / c) *\\<^sub>R A =\n  (1 / c) *\\<^sub>R c *\\<^sub>R cltn2_rep (cltn2_abs A)\n\ngoal (1 subgoal):\n 1. cltn2_rep (cltn2_abs A) = (1 / c) *\\<^sub>R A", "by simp"], ["proof (state)\nthis:\n  cltn2_rep (cltn2_abs A) = (1 / c) *\\<^sub>R A\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A", "with \\<open>?k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  1 / c \\<noteq> 0\n  cltn2_rep (cltn2_abs A) = (1 / c) *\\<^sub>R A", "show \"\\<exists> k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A\""], ["proof (prove)\nusing this:\n  1 / c \\<noteq> 0\n  cltn2_rep (cltn2_abs A) = (1 / c) *\\<^sub>R A\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A", "by blast"], ["proof (state)\nthis:\n  \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs A) = k *\\<^sub>R A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_abs_rep: \"cltn2_abs (cltn2_rep A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep A) = A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep A) = A", "from partition_Image_element\n  [of \"Collect invertible\"\n    invertible_proportionality\n    \"Rep_cltn2 A\"\n    \"cltn2_rep A\"]\n    and invertible_proportionality_equiv\n    and Rep_cltn2 [of A] and cltn2_rep_in [of A]"], ["proof (chain)\npicking this:\n  \\<lbrakk>equiv (Collect invertible) invertible_proportionality;\n   Rep_cltn2 A \\<in> Collect invertible // invertible_proportionality;\n   cltn2_rep A \\<in> Rep_cltn2 A\\<rbrakk>\n  \\<Longrightarrow> invertible_proportionality `` {cltn2_rep A} =\n                    Rep_cltn2 A\n  equiv (Collect invertible) invertible_proportionality\n  Rep_cltn2 A \\<in> Collect invertible // invertible_proportionality\n  cltn2_rep A \\<in> Rep_cltn2 A", "have \"invertible_proportionality `` {cltn2_rep A} = Rep_cltn2 A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>equiv (Collect invertible) invertible_proportionality;\n   Rep_cltn2 A \\<in> Collect invertible // invertible_proportionality;\n   cltn2_rep A \\<in> Rep_cltn2 A\\<rbrakk>\n  \\<Longrightarrow> invertible_proportionality `` {cltn2_rep A} =\n                    Rep_cltn2 A\n  equiv (Collect invertible) invertible_proportionality\n  Rep_cltn2 A \\<in> Collect invertible // invertible_proportionality\n  cltn2_rep A \\<in> Rep_cltn2 A\n\ngoal (1 subgoal):\n 1. invertible_proportionality `` {cltn2_rep A} = Rep_cltn2 A", "by simp"], ["proof (state)\nthis:\n  invertible_proportionality `` {cltn2_rep A} = Rep_cltn2 A\n\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep A) = A", "with Rep_cltn2_inverse"], ["proof (chain)\npicking this:\n  Abs_cltn2 (Rep_cltn2 ?x) = ?x\n  invertible_proportionality `` {cltn2_rep A} = Rep_cltn2 A", "show \"cltn2_abs (cltn2_rep A) = A\""], ["proof (prove)\nusing this:\n  Abs_cltn2 (Rep_cltn2 ?x) = ?x\n  invertible_proportionality `` {cltn2_rep A} = Rep_cltn2 A\n\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep A) = A", "unfolding cltn2_abs_def"], ["proof (prove)\nusing this:\n  Abs_cltn2 (Rep_cltn2 ?x) = ?x\n  invertible_proportionality `` {cltn2_rep A} = Rep_cltn2 A\n\ngoal (1 subgoal):\n 1. Abs_cltn2 (invertible_proportionality `` {cltn2_rep A}) = A", "by simp"], ["proof (state)\nthis:\n  cltn2_abs (cltn2_rep A) = A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_abs_mult:\n  assumes \"k \\<noteq> 0\" and \"invertible A\"\n  shows \"cltn2_abs (k *\\<^sub>R A) = cltn2_abs A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_abs (k *\\<^sub>R A) = cltn2_abs A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_abs (k *\\<^sub>R A) = cltn2_abs A", "from \\<open>k \\<noteq> 0\\<close> and \\<open>invertible A\\<close> and scalar_invertible"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  invertible A\n  \\<lbrakk>?k \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> invertible (?k *\\<^sub>R ?A)", "have \"invertible (k *\\<^sub>R A)\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  invertible A\n  \\<lbrakk>?k \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> invertible (?k *\\<^sub>R ?A)\n\ngoal (1 subgoal):\n 1. invertible (k *\\<^sub>R A)", "by auto"], ["proof (state)\nthis:\n  invertible (k *\\<^sub>R A)\n\ngoal (1 subgoal):\n 1. cltn2_abs (k *\\<^sub>R A) = cltn2_abs A", "with \\<open>invertible A\\<close>"], ["proof (chain)\npicking this:\n  invertible A\n  invertible (k *\\<^sub>R A)", "have \"(k *\\<^sub>R A, A) \\<in> invertible_proportionality\""], ["proof (prove)\nusing this:\n  invertible A\n  invertible (k *\\<^sub>R A)\n\ngoal (1 subgoal):\n 1. (k *\\<^sub>R A, A) \\<in> invertible_proportionality", "unfolding invertible_proportionality_def\n      and real_vector.proportionality_def"], ["proof (prove)\nusing this:\n  invertible A\n  invertible (k *\\<^sub>R A)\n\ngoal (1 subgoal):\n 1. (k *\\<^sub>R A, A)\n    \\<in> Restr\n           {(x, y).\n            x \\<noteq> 0 \\<and>\n            y \\<noteq> 0 \\<and> (\\<exists>k. x = k *\\<^sub>R y)}\n           (Collect invertible)", "by (auto simp add: zero_not_invertible)"], ["proof (state)\nthis:\n  (k *\\<^sub>R A, A) \\<in> invertible_proportionality\n\ngoal (1 subgoal):\n 1. cltn2_abs (k *\\<^sub>R A) = cltn2_abs A", "with eq_equiv_class_iff\n  [of \"Collect invertible\" invertible_proportionality \"k *\\<^sub>R A\" A]\n    and invertible_proportionality_equiv\n    and \\<open>invertible A\\<close> and \\<open>invertible (k *\\<^sub>R A)\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>equiv (Collect invertible) invertible_proportionality;\n   k *\\<^sub>R A \\<in> Collect invertible;\n   A \\<in> Collect invertible\\<rbrakk>\n  \\<Longrightarrow> (invertible_proportionality `` {k *\\<^sub>R A} =\n                     invertible_proportionality `` {A}) =\n                    ((k *\\<^sub>R A, A) \\<in> invertible_proportionality)\n  equiv (Collect invertible) invertible_proportionality\n  invertible A\n  invertible (k *\\<^sub>R A)\n  (k *\\<^sub>R A, A) \\<in> invertible_proportionality", "have \"invertible_proportionality `` {k *\\<^sub>R A}\n    = invertible_proportionality `` {A}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>equiv (Collect invertible) invertible_proportionality;\n   k *\\<^sub>R A \\<in> Collect invertible;\n   A \\<in> Collect invertible\\<rbrakk>\n  \\<Longrightarrow> (invertible_proportionality `` {k *\\<^sub>R A} =\n                     invertible_proportionality `` {A}) =\n                    ((k *\\<^sub>R A, A) \\<in> invertible_proportionality)\n  equiv (Collect invertible) invertible_proportionality\n  invertible A\n  invertible (k *\\<^sub>R A)\n  (k *\\<^sub>R A, A) \\<in> invertible_proportionality\n\ngoal (1 subgoal):\n 1. invertible_proportionality `` {k *\\<^sub>R A} =\n    invertible_proportionality `` {A}", "by simp"], ["proof (state)\nthis:\n  invertible_proportionality `` {k *\\<^sub>R A} =\n  invertible_proportionality `` {A}\n\ngoal (1 subgoal):\n 1. cltn2_abs (k *\\<^sub>R A) = cltn2_abs A", "thus \"cltn2_abs (k *\\<^sub>R A) = cltn2_abs A\""], ["proof (prove)\nusing this:\n  invertible_proportionality `` {k *\\<^sub>R A} =\n  invertible_proportionality `` {A}\n\ngoal (1 subgoal):\n 1. cltn2_abs (k *\\<^sub>R A) = cltn2_abs A", "unfolding cltn2_abs_def"], ["proof (prove)\nusing this:\n  invertible_proportionality `` {k *\\<^sub>R A} =\n  invertible_proportionality `` {A}\n\ngoal (1 subgoal):\n 1. Abs_cltn2 (invertible_proportionality `` {k *\\<^sub>R A}) =\n    Abs_cltn2 (invertible_proportionality `` {A})", "by simp"], ["proof (state)\nthis:\n  cltn2_abs (k *\\<^sub>R A) = cltn2_abs A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_abs_mult_rep:\n  assumes \"k \\<noteq> 0\"\n  shows \"cltn2_abs (k *\\<^sub>R cltn2_rep A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_abs (k *\\<^sub>R cltn2_rep A) = A", "using cltn2_rep_invertible and cltn2_abs_mult and cltn2_abs_rep and assms"], ["proof (prove)\nusing this:\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>?k \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs (?k *\\<^sub>R ?A) = cltn2_abs ?A\n  cltn2_abs (cltn2_rep ?A) = ?A\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cltn2_abs (k *\\<^sub>R cltn2_rep A) = A", "by simp"], ["", "lemma apply_cltn2_abs:\n  assumes \"x \\<noteq> 0\" and \"invertible A\"\n  shows \"apply_cltn2 (proj2_abs x) (cltn2_abs A) = proj2_abs (x v* A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs x) (cltn2_abs A) = proj2_abs (x v* A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs x) (cltn2_abs A) = proj2_abs (x v* A)", "from proj2_rep_abs2 and \\<open>x \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  x \\<noteq> 0", "obtain k where \"k \\<noteq> 0\" and \"proj2_rep (proj2_abs x) = k *\\<^sub>R x\""], ["proof (prove)\nusing this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<noteq> 0;\n         proj2_rep (proj2_abs x) = k *\\<^sub>R x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  proj2_rep (proj2_abs x) = k *\\<^sub>R x\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs x) (cltn2_abs A) = proj2_abs (x v* A)", "from cltn2_rep_abs2 and \\<open>invertible A\\<close>"], ["proof (chain)\npicking this:\n  invertible ?A \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs ?A) = k *\\<^sub>R ?A\n  invertible A", "obtain c where \"c \\<noteq> 0\" and \"cltn2_rep (cltn2_abs A) = c *\\<^sub>R A\""], ["proof (prove)\nusing this:\n  invertible ?A \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs ?A) = k *\\<^sub>R ?A\n  invertible A\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<noteq> 0;\n         cltn2_rep (cltn2_abs A) = c *\\<^sub>R A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  cltn2_rep (cltn2_abs A) = c *\\<^sub>R A\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs x) (cltn2_abs A) = proj2_abs (x v* A)", "from \\<open>k \\<noteq> 0\\<close> and \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  c \\<noteq> 0", "have \"k * c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k * c \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  k * c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs x) (cltn2_abs A) = proj2_abs (x v* A)", "from \\<open>proj2_rep (proj2_abs x) = k *\\<^sub>R x\\<close> and \\<open>cltn2_rep (cltn2_abs A) = c *\\<^sub>R A\\<close>"], ["proof (chain)\npicking this:\n  proj2_rep (proj2_abs x) = k *\\<^sub>R x\n  cltn2_rep (cltn2_abs A) = c *\\<^sub>R A", "have \"proj2_rep (proj2_abs x) v* cltn2_rep (cltn2_abs A) = (k*c) *\\<^sub>R (x v* A)\""], ["proof (prove)\nusing this:\n  proj2_rep (proj2_abs x) = k *\\<^sub>R x\n  cltn2_rep (cltn2_abs A) = c *\\<^sub>R A\n\ngoal (1 subgoal):\n 1. proj2_rep (proj2_abs x) v* cltn2_rep (cltn2_abs A) =\n    (k * c) *\\<^sub>R (x v* A)", "by (simp add: scaleR_vector_matrix_assoc vector_scaleR_matrix_ac)"], ["proof (state)\nthis:\n  proj2_rep (proj2_abs x) v* cltn2_rep (cltn2_abs A) =\n  (k * c) *\\<^sub>R (x v* A)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs x) (cltn2_abs A) = proj2_abs (x v* A)", "with \\<open>k * c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  k * c \\<noteq> 0\n  proj2_rep (proj2_abs x) v* cltn2_rep (cltn2_abs A) =\n  (k * c) *\\<^sub>R (x v* A)", "show \"apply_cltn2 (proj2_abs x) (cltn2_abs A) = proj2_abs (x v* A)\""], ["proof (prove)\nusing this:\n  k * c \\<noteq> 0\n  proj2_rep (proj2_abs x) v* cltn2_rep (cltn2_abs A) =\n  (k * c) *\\<^sub>R (x v* A)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs x) (cltn2_abs A) = proj2_abs (x v* A)", "unfolding apply_cltn2_def"], ["proof (prove)\nusing this:\n  k * c \\<noteq> 0\n  proj2_rep (proj2_abs x) v* cltn2_rep (cltn2_abs A) =\n  (k * c) *\\<^sub>R (x v* A)\n\ngoal (1 subgoal):\n 1. proj2_abs (proj2_rep (proj2_abs x) v* cltn2_rep (cltn2_abs A)) =\n    proj2_abs (x v* A)", "by (simp add: proj2_abs_mult)"], ["proof (state)\nthis:\n  apply_cltn2 (proj2_abs x) (cltn2_abs A) = proj2_abs (x v* A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_cltn2_left_abs:\n  assumes \"v \\<noteq> 0\"\n  shows \"apply_cltn2 (proj2_abs v) C = proj2_abs (v v* cltn2_rep C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs v) C = proj2_abs (v v* cltn2_rep C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs v) C = proj2_abs (v v* cltn2_rep C)", "have \"cltn2_abs (cltn2_rep C) = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep C) = C", "by (rule cltn2_abs_rep)"], ["proof (state)\nthis:\n  cltn2_abs (cltn2_rep C) = C\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs v) C = proj2_abs (v v* cltn2_rep C)", "with \\<open>v \\<noteq> 0\\<close> and cltn2_rep_invertible and apply_cltn2_abs [of v \"cltn2_rep C\"]"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>v \\<noteq> 0; invertible (cltn2_rep C)\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2 (proj2_abs v) (cltn2_abs (cltn2_rep C)) =\n                    proj2_abs (v v* cltn2_rep C)\n  cltn2_abs (cltn2_rep C) = C", "show \"apply_cltn2 (proj2_abs v) C = proj2_abs (v v* cltn2_rep C)\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>v \\<noteq> 0; invertible (cltn2_rep C)\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2 (proj2_abs v) (cltn2_abs (cltn2_rep C)) =\n                    proj2_abs (v v* cltn2_rep C)\n  cltn2_abs (cltn2_rep C) = C\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs v) C = proj2_abs (v v* cltn2_rep C)", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (proj2_abs v) C = proj2_abs (v v* cltn2_rep C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_cltn2_right_abs:\n  assumes \"invertible M\"\n  shows \"apply_cltn2 p (cltn2_abs M) = proj2_abs (proj2_rep p v* M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2 p (cltn2_abs M) = proj2_abs (proj2_rep p v* M)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. apply_cltn2 p (cltn2_abs M) = proj2_abs (proj2_rep p v* M)", "from proj2_rep_non_zero and \\<open>invertible M\\<close> and apply_cltn2_abs"], ["proof (chain)\npicking this:\n  proj2_rep ?x \\<noteq> 0\n  invertible M\n  \\<lbrakk>?x \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2 (proj2_abs ?x) (cltn2_abs ?A) =\n                    proj2_abs (?x v* ?A)", "have \"apply_cltn2 (proj2_abs (proj2_rep p)) (cltn2_abs M)\n    = proj2_abs (proj2_rep p v* M)\""], ["proof (prove)\nusing this:\n  proj2_rep ?x \\<noteq> 0\n  invertible M\n  \\<lbrakk>?x \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2 (proj2_abs ?x) (cltn2_abs ?A) =\n                    proj2_abs (?x v* ?A)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs (proj2_rep p)) (cltn2_abs M) =\n    proj2_abs (proj2_rep p v* M)", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (proj2_abs (proj2_rep p)) (cltn2_abs M) =\n  proj2_abs (proj2_rep p v* M)\n\ngoal (1 subgoal):\n 1. apply_cltn2 p (cltn2_abs M) = proj2_abs (proj2_rep p v* M)", "thus \"apply_cltn2 p (cltn2_abs M) = proj2_abs (proj2_rep p v* M)\""], ["proof (prove)\nusing this:\n  apply_cltn2 (proj2_abs (proj2_rep p)) (cltn2_abs M) =\n  proj2_abs (proj2_rep p v* M)\n\ngoal (1 subgoal):\n 1. apply_cltn2 p (cltn2_abs M) = proj2_abs (proj2_rep p v* M)", "by (simp add: proj2_abs_rep)"], ["proof (state)\nthis:\n  apply_cltn2 p (cltn2_abs M) = proj2_abs (proj2_rep p v* M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_zero_mult_rep_non_zero:\n  assumes \"v \\<noteq> 0\"\n  shows \"v v* cltn2_rep C \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v v* cltn2_rep C \\<noteq> 0", "using \\<open>v \\<noteq> 0\\<close> and cltn2_rep_invertible and times_invertible_eq_zero"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>invertible ?A; ?x v* ?A = 0\\<rbrakk> \\<Longrightarrow> ?x = 0\n\ngoal (1 subgoal):\n 1. v v* cltn2_rep C \\<noteq> 0", "by auto"], ["", "lemma rep_mult_rep_non_zero: \"proj2_rep p v* cltn2_rep A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep p v* cltn2_rep A \\<noteq> 0", "using proj2_rep_non_zero"], ["proof (prove)\nusing this:\n  proj2_rep ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_rep p v* cltn2_rep A \\<noteq> 0", "by (rule non_zero_mult_rep_non_zero)"], ["", "definition cltn2_image :: \"proj2 set \\<Rightarrow> cltn2 \\<Rightarrow> proj2 set\" where\n  \"cltn2_image P A \\<equiv> {apply_cltn2 p A | p. p \\<in> P}\""], ["", "subsubsection \"As a group\""], ["", "definition cltn2_id :: cltn2 where\n  \"cltn2_id \\<equiv> cltn2_abs (mat 1)\""], ["", "definition cltn2_compose :: \"cltn2 \\<Rightarrow> cltn2 \\<Rightarrow> cltn2\" where\n  \"cltn2_compose A B \\<equiv> cltn2_abs (cltn2_rep A ** cltn2_rep B)\""], ["", "definition cltn2_inverse :: \"cltn2 \\<Rightarrow> cltn2\" where\n  \"cltn2_inverse A \\<equiv> cltn2_abs (matrix_inv (cltn2_rep A))\""], ["", "lemma cltn2_compose_abs:\n  assumes \"invertible M\" and \"invertible N\"\n  shows \"cltn2_compose (cltn2_abs M) (cltn2_abs N) = cltn2_abs (M ** N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) (cltn2_abs N) = cltn2_abs (M ** N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) (cltn2_abs N) = cltn2_abs (M ** N)", "from \\<open>invertible M\\<close> and \\<open>invertible N\\<close> and invertible_mult"], ["proof (chain)\npicking this:\n  invertible M\n  invertible N\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)", "have \"invertible (M ** N)\""], ["proof (prove)\nusing this:\n  invertible M\n  invertible N\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n\ngoal (1 subgoal):\n 1. invertible (M ** N)", "by auto"], ["proof (state)\nthis:\n  invertible (M ** N)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) (cltn2_abs N) = cltn2_abs (M ** N)", "from \\<open>invertible M\\<close> and \\<open>invertible N\\<close> and cltn2_rep_abs2"], ["proof (chain)\npicking this:\n  invertible M\n  invertible N\n  invertible ?A \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs ?A) = k *\\<^sub>R ?A", "obtain j and k where \"j \\<noteq> 0\" and \"k \\<noteq> 0\"\n    and \"cltn2_rep (cltn2_abs M) = j *\\<^sub>R M\"\n    and \"cltn2_rep (cltn2_abs N) = k *\\<^sub>R N\""], ["proof (prove)\nusing this:\n  invertible M\n  invertible N\n  invertible ?A \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs ?A) = k *\\<^sub>R ?A\n\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        \\<lbrakk>j \\<noteq> 0; k \\<noteq> 0;\n         cltn2_rep (cltn2_abs M) = j *\\<^sub>R M;\n         cltn2_rep (cltn2_abs N) = k *\\<^sub>R N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j \\<noteq> 0\n  k \\<noteq> 0\n  cltn2_rep (cltn2_abs M) = j *\\<^sub>R M\n  cltn2_rep (cltn2_abs N) = k *\\<^sub>R N\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) (cltn2_abs N) = cltn2_abs (M ** N)", "from \\<open>j \\<noteq> 0\\<close> and \\<open>k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  j \\<noteq> 0\n  k \\<noteq> 0", "have \"j * k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j * k \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  j * k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) (cltn2_abs N) = cltn2_abs (M ** N)", "from \\<open>cltn2_rep (cltn2_abs M) = j *\\<^sub>R M\\<close> and \\<open>cltn2_rep (cltn2_abs N) = k *\\<^sub>R N\\<close>"], ["proof (chain)\npicking this:\n  cltn2_rep (cltn2_abs M) = j *\\<^sub>R M\n  cltn2_rep (cltn2_abs N) = k *\\<^sub>R N", "have \"cltn2_rep (cltn2_abs M) ** cltn2_rep (cltn2_abs N)\n    = (j * k) *\\<^sub>R (M ** N)\""], ["proof (prove)\nusing this:\n  cltn2_rep (cltn2_abs M) = j *\\<^sub>R M\n  cltn2_rep (cltn2_abs N) = k *\\<^sub>R N\n\ngoal (1 subgoal):\n 1. cltn2_rep (cltn2_abs M) ** cltn2_rep (cltn2_abs N) =\n    (j * k) *\\<^sub>R (M ** N)", "by (simp add: matrix_scalar_ac scalar_matrix_assoc [symmetric])"], ["proof (state)\nthis:\n  cltn2_rep (cltn2_abs M) ** cltn2_rep (cltn2_abs N) =\n  (j * k) *\\<^sub>R (M ** N)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) (cltn2_abs N) = cltn2_abs (M ** N)", "with \\<open>j * k \\<noteq> 0\\<close> and \\<open>invertible (M ** N)\\<close>"], ["proof (chain)\npicking this:\n  j * k \\<noteq> 0\n  invertible (M ** N)\n  cltn2_rep (cltn2_abs M) ** cltn2_rep (cltn2_abs N) =\n  (j * k) *\\<^sub>R (M ** N)", "show \"cltn2_compose (cltn2_abs M) (cltn2_abs N) = cltn2_abs (M ** N)\""], ["proof (prove)\nusing this:\n  j * k \\<noteq> 0\n  invertible (M ** N)\n  cltn2_rep (cltn2_abs M) ** cltn2_rep (cltn2_abs N) =\n  (j * k) *\\<^sub>R (M ** N)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) (cltn2_abs N) = cltn2_abs (M ** N)", "unfolding cltn2_compose_def"], ["proof (prove)\nusing this:\n  j * k \\<noteq> 0\n  invertible (M ** N)\n  cltn2_rep (cltn2_abs M) ** cltn2_rep (cltn2_abs N) =\n  (j * k) *\\<^sub>R (M ** N)\n\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep (cltn2_abs M) ** cltn2_rep (cltn2_abs N)) =\n    cltn2_abs (M ** N)", "by (simp add: cltn2_abs_mult)"], ["proof (state)\nthis:\n  cltn2_compose (cltn2_abs M) (cltn2_abs N) = cltn2_abs (M ** N)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_compose_left_abs:\n  assumes \"invertible M\"\n  shows \"cltn2_compose (cltn2_abs M) A = cltn2_abs (M ** cltn2_rep A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) A = cltn2_abs (M ** cltn2_rep A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) A = cltn2_abs (M ** cltn2_rep A)", "from \\<open>invertible M\\<close> and cltn2_rep_invertible and cltn2_compose_abs"], ["proof (chain)\npicking this:\n  invertible M\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_compose (cltn2_abs ?M) (cltn2_abs ?N) =\n                    cltn2_abs (?M ** ?N)", "have \"cltn2_compose (cltn2_abs M) (cltn2_abs (cltn2_rep A))\n    = cltn2_abs (M ** cltn2_rep A)\""], ["proof (prove)\nusing this:\n  invertible M\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_compose (cltn2_abs ?M) (cltn2_abs ?N) =\n                    cltn2_abs (?M ** ?N)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) (cltn2_abs (cltn2_rep A)) =\n    cltn2_abs (M ** cltn2_rep A)", "by simp"], ["proof (state)\nthis:\n  cltn2_compose (cltn2_abs M) (cltn2_abs (cltn2_rep A)) =\n  cltn2_abs (M ** cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) A = cltn2_abs (M ** cltn2_rep A)", "thus \"cltn2_compose (cltn2_abs M) A = cltn2_abs (M ** cltn2_rep A)\""], ["proof (prove)\nusing this:\n  cltn2_compose (cltn2_abs M) (cltn2_abs (cltn2_rep A)) =\n  cltn2_abs (M ** cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs M) A = cltn2_abs (M ** cltn2_rep A)", "by (simp add: cltn2_abs_rep)"], ["proof (state)\nthis:\n  cltn2_compose (cltn2_abs M) A = cltn2_abs (M ** cltn2_rep A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_compose_right_abs:\n  assumes \"invertible M\"\n  shows \"cltn2_compose A (cltn2_abs M) = cltn2_abs (cltn2_rep A ** M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_compose A (cltn2_abs M) = cltn2_abs (cltn2_rep A ** M)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose A (cltn2_abs M) = cltn2_abs (cltn2_rep A ** M)", "from \\<open>invertible M\\<close> and cltn2_rep_invertible and cltn2_compose_abs"], ["proof (chain)\npicking this:\n  invertible M\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_compose (cltn2_abs ?M) (cltn2_abs ?N) =\n                    cltn2_abs (?M ** ?N)", "have \"cltn2_compose (cltn2_abs (cltn2_rep A)) (cltn2_abs M)\n    = cltn2_abs (cltn2_rep A ** M)\""], ["proof (prove)\nusing this:\n  invertible M\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_compose (cltn2_abs ?M) (cltn2_abs ?N) =\n                    cltn2_abs (?M ** ?N)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_abs (cltn2_rep A)) (cltn2_abs M) =\n    cltn2_abs (cltn2_rep A ** M)", "by simp"], ["proof (state)\nthis:\n  cltn2_compose (cltn2_abs (cltn2_rep A)) (cltn2_abs M) =\n  cltn2_abs (cltn2_rep A ** M)\n\ngoal (1 subgoal):\n 1. cltn2_compose A (cltn2_abs M) = cltn2_abs (cltn2_rep A ** M)", "thus \"cltn2_compose A (cltn2_abs M) = cltn2_abs (cltn2_rep A ** M)\""], ["proof (prove)\nusing this:\n  cltn2_compose (cltn2_abs (cltn2_rep A)) (cltn2_abs M) =\n  cltn2_abs (cltn2_rep A ** M)\n\ngoal (1 subgoal):\n 1. cltn2_compose A (cltn2_abs M) = cltn2_abs (cltn2_rep A ** M)", "by (simp add: cltn2_abs_rep)"], ["proof (state)\nthis:\n  cltn2_compose A (cltn2_abs M) = cltn2_abs (cltn2_rep A ** M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_abs_rep_abs_mult:\n  assumes \"invertible M\" and \"invertible N\"\n  shows \"cltn2_abs (cltn2_rep (cltn2_abs M) ** N) = cltn2_abs (M ** N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep (cltn2_abs M) ** N) = cltn2_abs (M ** N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep (cltn2_abs M) ** N) = cltn2_abs (M ** N)", "from \\<open>invertible M\\<close> and \\<open>invertible N\\<close>"], ["proof (chain)\npicking this:\n  invertible M\n  invertible N", "have \"invertible (M ** N)\""], ["proof (prove)\nusing this:\n  invertible M\n  invertible N\n\ngoal (1 subgoal):\n 1. invertible (M ** N)", "by (simp add: invertible_mult)"], ["proof (state)\nthis:\n  invertible (M ** N)\n\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep (cltn2_abs M) ** N) = cltn2_abs (M ** N)", "from \\<open>invertible M\\<close> and cltn2_rep_abs2"], ["proof (chain)\npicking this:\n  invertible M\n  invertible ?A \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs ?A) = k *\\<^sub>R ?A", "obtain k where \"k \\<noteq> 0\" and \"cltn2_rep (cltn2_abs M) = k *\\<^sub>R M\""], ["proof (prove)\nusing this:\n  invertible M\n  invertible ?A \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs ?A) = k *\\<^sub>R ?A\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<noteq> 0;\n         cltn2_rep (cltn2_abs M) = k *\\<^sub>R M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  cltn2_rep (cltn2_abs M) = k *\\<^sub>R M\n\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep (cltn2_abs M) ** N) = cltn2_abs (M ** N)", "from \\<open>cltn2_rep (cltn2_abs M) = k *\\<^sub>R M\\<close>"], ["proof (chain)\npicking this:\n  cltn2_rep (cltn2_abs M) = k *\\<^sub>R M", "have \"cltn2_rep (cltn2_abs M) ** N = k *\\<^sub>R M ** N\""], ["proof (prove)\nusing this:\n  cltn2_rep (cltn2_abs M) = k *\\<^sub>R M\n\ngoal (1 subgoal):\n 1. cltn2_rep (cltn2_abs M) ** N = k *\\<^sub>R M ** N", "by simp"], ["proof (state)\nthis:\n  cltn2_rep (cltn2_abs M) ** N = k *\\<^sub>R M ** N\n\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep (cltn2_abs M) ** N) = cltn2_abs (M ** N)", "with \\<open>k \\<noteq> 0\\<close> and \\<open>invertible (M ** N)\\<close> and cltn2_abs_mult"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  invertible (M ** N)\n  \\<lbrakk>?k \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs (?k *\\<^sub>R ?A) = cltn2_abs ?A\n  cltn2_rep (cltn2_abs M) ** N = k *\\<^sub>R M ** N", "show \"cltn2_abs (cltn2_rep (cltn2_abs M) ** N) = cltn2_abs (M ** N)\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  invertible (M ** N)\n  \\<lbrakk>?k \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs (?k *\\<^sub>R ?A) = cltn2_abs ?A\n  cltn2_rep (cltn2_abs M) ** N = k *\\<^sub>R M ** N\n\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep (cltn2_abs M) ** N) = cltn2_abs (M ** N)", "by (simp add: scalar_matrix_assoc [symmetric])"], ["proof (state)\nthis:\n  cltn2_abs (cltn2_rep (cltn2_abs M) ** N) = cltn2_abs (M ** N)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_assoc:\n  \"cltn2_compose (cltn2_compose A B) C = cltn2_compose A (cltn2_compose B C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "let ?A' = \"cltn2_rep A\""], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "let ?B' = \"cltn2_rep B\""], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "let ?C' = \"cltn2_rep C\""], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "from cltn2_rep_invertible"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep ?A)", "have \"invertible ?A'\" and \"invertible ?B'\" and \"invertible ?C'\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep ?A)\n\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A) &&&\n    invertible (cltn2_rep B) &&& invertible (cltn2_rep C)", "by simp_all"], ["proof (state)\nthis:\n  invertible (cltn2_rep A)\n  invertible (cltn2_rep B)\n  invertible (cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "with invertible_mult"], ["proof (chain)\npicking this:\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n  invertible (cltn2_rep A)\n  invertible (cltn2_rep B)\n  invertible (cltn2_rep C)", "have \"invertible (?A' ** ?B')\" and \"invertible (?B' ** ?C')\"\n    and \"invertible (?A' ** ?B' ** ?C')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n  invertible (cltn2_rep A)\n  invertible (cltn2_rep B)\n  invertible (cltn2_rep C)\n\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A ** cltn2_rep B) &&&\n    invertible (cltn2_rep B ** cltn2_rep C) &&&\n    invertible (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)", "by auto"], ["proof (state)\nthis:\n  invertible (cltn2_rep A ** cltn2_rep B)\n  invertible (cltn2_rep B ** cltn2_rep C)\n  invertible (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "from \\<open>invertible (?A' ** ?B')\\<close> and \\<open>invertible ?C'\\<close> and cltn2_abs_rep_abs_mult"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep A ** cltn2_rep B)\n  invertible (cltn2_rep C)\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs (cltn2_rep (cltn2_abs ?M) ** ?N) =\n                    cltn2_abs (?M ** ?N)", "have \"cltn2_abs (cltn2_rep (cltn2_abs (?A' ** ?B')) ** ?C')\n    = cltn2_abs (?A' ** ?B' ** ?C')\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep A ** cltn2_rep B)\n  invertible (cltn2_rep C)\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs (cltn2_rep (cltn2_abs ?M) ** ?N) =\n                    cltn2_abs (?M ** ?N)\n\ngoal (1 subgoal):\n 1. cltn2_abs\n     (cltn2_rep (cltn2_abs (cltn2_rep A ** cltn2_rep B)) ** cltn2_rep C) =\n    cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)", "by simp"], ["proof (state)\nthis:\n  cltn2_abs\n   (cltn2_rep (cltn2_abs (cltn2_rep A ** cltn2_rep B)) ** cltn2_rep C) =\n  cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "from \\<open>invertible (?B' ** ?C')\\<close> and cltn2_rep_abs2 [of \"?B' ** ?C'\"]"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep B ** cltn2_rep C)\n  invertible (cltn2_rep B ** cltn2_rep C) \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C)) =\n     k *\\<^sub>R (cltn2_rep B ** cltn2_rep C)", "obtain k where \"k \\<noteq> 0\"\n    and \"cltn2_rep (cltn2_abs (?B' ** ?C')) = k *\\<^sub>R (?B' ** ?C')\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep B ** cltn2_rep C)\n  invertible (cltn2_rep B ** cltn2_rep C) \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C)) =\n     k *\\<^sub>R (cltn2_rep B ** cltn2_rep C)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<noteq> 0;\n         cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C)) =\n         k *\\<^sub>R (cltn2_rep B ** cltn2_rep C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C)) =\n  k *\\<^sub>R (cltn2_rep B ** cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "from \\<open>cltn2_rep (cltn2_abs (?B' ** ?C')) = k *\\<^sub>R (?B' ** ?C')\\<close>"], ["proof (chain)\npicking this:\n  cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C)) =\n  k *\\<^sub>R (cltn2_rep B ** cltn2_rep C)", "have \"?A' ** cltn2_rep (cltn2_abs (?B' ** ?C')) = k *\\<^sub>R (?A' ** ?B' ** ?C')\""], ["proof (prove)\nusing this:\n  cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C)) =\n  k *\\<^sub>R (cltn2_rep B ** cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cltn2_rep A ** cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C)) =\n    k *\\<^sub>R (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)", "by (simp add: matrix_scalar_ac matrix_mul_assoc scalar_matrix_assoc)"], ["proof (state)\nthis:\n  cltn2_rep A ** cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C)) =\n  k *\\<^sub>R (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "with \\<open>k \\<noteq> 0\\<close> and \\<open>invertible (?A' ** ?B' ** ?C')\\<close>\n    and cltn2_abs_mult [of k \"?A' ** ?B' ** ?C'\"]"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  invertible (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n  \\<lbrakk>k \\<noteq> 0;\n   invertible (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs\n                     (k *\\<^sub>R\n                      (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)) =\n                    cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n  cltn2_rep A ** cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C)) =\n  k *\\<^sub>R (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)", "have \"cltn2_abs (?A' ** cltn2_rep (cltn2_abs (?B' ** ?C')))\n    = cltn2_abs (?A' ** ?B' ** ?C')\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  invertible (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n  \\<lbrakk>k \\<noteq> 0;\n   invertible (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs\n                     (k *\\<^sub>R\n                      (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)) =\n                    cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n  cltn2_rep A ** cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C)) =\n  k *\\<^sub>R (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cltn2_abs\n     (cltn2_rep A ** cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C))) =\n    cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)", "by simp"], ["proof (state)\nthis:\n  cltn2_abs\n   (cltn2_rep A ** cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C))) =\n  cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "with \\<open>cltn2_abs (cltn2_rep (cltn2_abs (?A' ** ?B')) ** ?C')\n    = cltn2_abs (?A' ** ?B' ** ?C')\\<close>"], ["proof (chain)\npicking this:\n  cltn2_abs\n   (cltn2_rep (cltn2_abs (cltn2_rep A ** cltn2_rep B)) ** cltn2_rep C) =\n  cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n  cltn2_abs\n   (cltn2_rep A ** cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C))) =\n  cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)", "show\n    \"cltn2_compose (cltn2_compose A B) C = cltn2_compose A (cltn2_compose B C)\""], ["proof (prove)\nusing this:\n  cltn2_abs\n   (cltn2_rep (cltn2_abs (cltn2_rep A ** cltn2_rep B)) ** cltn2_rep C) =\n  cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n  cltn2_abs\n   (cltn2_rep A ** cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C))) =\n  cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_compose A B) C =\n    cltn2_compose A (cltn2_compose B C)", "unfolding cltn2_compose_def"], ["proof (prove)\nusing this:\n  cltn2_abs\n   (cltn2_rep (cltn2_abs (cltn2_rep A ** cltn2_rep B)) ** cltn2_rep C) =\n  cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n  cltn2_abs\n   (cltn2_rep A ** cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C))) =\n  cltn2_abs (cltn2_rep A ** cltn2_rep B ** cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cltn2_abs\n     (cltn2_rep (cltn2_abs (cltn2_rep A ** cltn2_rep B)) ** cltn2_rep C) =\n    cltn2_abs\n     (cltn2_rep A ** cltn2_rep (cltn2_abs (cltn2_rep B ** cltn2_rep C)))", "by simp"], ["proof (state)\nthis:\n  cltn2_compose (cltn2_compose A B) C = cltn2_compose A (cltn2_compose B C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_left_id: \"cltn2_compose cltn2_id A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_compose cltn2_id A = A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose cltn2_id A = A", "let ?A' = \"cltn2_rep A\""], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose cltn2_id A = A", "from cltn2_rep_invertible"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep ?A)", "have \"invertible ?A'\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep ?A)\n\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A)", "by simp"], ["proof (state)\nthis:\n  invertible (cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_compose cltn2_id A = A", "with matrix_id_invertible and cltn2_abs_rep_abs_mult [of \"mat 1\" ?A']"], ["proof (chain)\npicking this:\n  invertible (mat (1::?'a))\n  \\<lbrakk>invertible (mat 1); invertible (cltn2_rep A)\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs\n                     (cltn2_rep (cltn2_abs (mat 1)) ** cltn2_rep A) =\n                    cltn2_abs (mat 1 ** cltn2_rep A)\n  invertible (cltn2_rep A)", "have \"cltn2_compose cltn2_id A = cltn2_abs (cltn2_rep A)\""], ["proof (prove)\nusing this:\n  invertible (mat (1::?'a))\n  \\<lbrakk>invertible (mat 1); invertible (cltn2_rep A)\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs\n                     (cltn2_rep (cltn2_abs (mat 1)) ** cltn2_rep A) =\n                    cltn2_abs (mat 1 ** cltn2_rep A)\n  invertible (cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_compose cltn2_id A = cltn2_abs (cltn2_rep A)", "unfolding cltn2_compose_def and cltn2_id_def"], ["proof (prove)\nusing this:\n  invertible (mat (1::?'a))\n  \\<lbrakk>invertible (mat 1); invertible (cltn2_rep A)\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs\n                     (cltn2_rep (cltn2_abs (mat 1)) ** cltn2_rep A) =\n                    cltn2_abs (mat 1 ** cltn2_rep A)\n  invertible (cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_abs (cltn2_rep (cltn2_abs (mat 1)) ** cltn2_rep A) =\n    cltn2_abs (cltn2_rep A)", "by (auto simp add: matrix_mul_lid)"], ["proof (state)\nthis:\n  cltn2_compose cltn2_id A = cltn2_abs (cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_compose cltn2_id A = A", "with cltn2_abs_rep"], ["proof (chain)\npicking this:\n  cltn2_abs (cltn2_rep ?A) = ?A\n  cltn2_compose cltn2_id A = cltn2_abs (cltn2_rep A)", "show \"cltn2_compose cltn2_id A = A\""], ["proof (prove)\nusing this:\n  cltn2_abs (cltn2_rep ?A) = ?A\n  cltn2_compose cltn2_id A = cltn2_abs (cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_compose cltn2_id A = A", "by simp"], ["proof (state)\nthis:\n  cltn2_compose cltn2_id A = A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_left_inverse: \"cltn2_compose (cltn2_inverse A) A = cltn2_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_inverse A) A = cltn2_id", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_inverse A) A = cltn2_id", "let ?M = \"cltn2_rep A\""], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_inverse A) A = cltn2_id", "let ?M' = \"matrix_inv ?M\""], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_inverse A) A = cltn2_id", "from cltn2_rep_invertible"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep ?A)", "have \"invertible ?M\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep ?A)\n\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A)", "by simp"], ["proof (state)\nthis:\n  invertible (cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_inverse A) A = cltn2_id", "with matrix_inv_invertible"], ["proof (chain)\npicking this:\n  invertible ?M \\<Longrightarrow> invertible (matrix_inv ?M)\n  invertible (cltn2_rep A)", "have \"invertible ?M'\""], ["proof (prove)\nusing this:\n  invertible ?M \\<Longrightarrow> invertible (matrix_inv ?M)\n  invertible (cltn2_rep A)\n\ngoal (1 subgoal):\n 1. invertible (matrix_inv (cltn2_rep A))", "by auto"], ["proof (state)\nthis:\n  invertible (matrix_inv (cltn2_rep A))\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_inverse A) A = cltn2_id", "with \\<open>invertible ?M\\<close> and cltn2_abs_rep_abs_mult"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep A)\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs (cltn2_rep (cltn2_abs ?M) ** ?N) =\n                    cltn2_abs (?M ** ?N)\n  invertible (matrix_inv (cltn2_rep A))", "have \"cltn2_compose (cltn2_inverse A) A = cltn2_abs (?M' ** ?M)\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep A)\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs (cltn2_rep (cltn2_abs ?M) ** ?N) =\n                    cltn2_abs (?M ** ?N)\n  invertible (matrix_inv (cltn2_rep A))\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_inverse A) A =\n    cltn2_abs (matrix_inv (cltn2_rep A) ** cltn2_rep A)", "unfolding cltn2_compose_def and cltn2_inverse_def"], ["proof (prove)\nusing this:\n  invertible (cltn2_rep A)\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_abs (cltn2_rep (cltn2_abs ?M) ** ?N) =\n                    cltn2_abs (?M ** ?N)\n  invertible (matrix_inv (cltn2_rep A))\n\ngoal (1 subgoal):\n 1. cltn2_abs\n     (cltn2_rep (cltn2_abs (matrix_inv (cltn2_rep A))) ** cltn2_rep A) =\n    cltn2_abs (matrix_inv (cltn2_rep A) ** cltn2_rep A)", "by simp"], ["proof (state)\nthis:\n  cltn2_compose (cltn2_inverse A) A =\n  cltn2_abs (matrix_inv (cltn2_rep A) ** cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_inverse A) A = cltn2_id", "with \\<open>invertible ?M\\<close>"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep A)\n  cltn2_compose (cltn2_inverse A) A =\n  cltn2_abs (matrix_inv (cltn2_rep A) ** cltn2_rep A)", "show \"cltn2_compose (cltn2_inverse A) A = cltn2_id\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep A)\n  cltn2_compose (cltn2_inverse A) A =\n  cltn2_abs (matrix_inv (cltn2_rep A) ** cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_inverse A) A = cltn2_id", "unfolding cltn2_id_def"], ["proof (prove)\nusing this:\n  invertible (cltn2_rep A)\n  cltn2_compose (cltn2_inverse A) A =\n  cltn2_abs (matrix_inv (cltn2_rep A) ** cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_inverse A) A = cltn2_abs (mat 1)", "by (simp add: matrix_inv)"], ["proof (state)\nthis:\n  cltn2_compose (cltn2_inverse A) A = cltn2_id\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_left_inverse_ex:\n  \"\\<exists> B. cltn2_compose B A = cltn2_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B. cltn2_compose B A = cltn2_id", "using cltn2_left_inverse"], ["proof (prove)\nusing this:\n  cltn2_compose (cltn2_inverse ?A) ?A = cltn2_id\n\ngoal (1 subgoal):\n 1. \\<exists>B. cltn2_compose B A = cltn2_id", ".."], ["", "interpretation cltn2:\n  group \"(|carrier = UNIV, mult = cltn2_compose, one = cltn2_id|)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group\n     \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n        one = cltn2_id\\<rparr>", "using cltn2_assoc and cltn2_left_id and cltn2_left_inverse_ex\n    and groupI [of \"(|carrier = UNIV, mult = cltn2_compose, one = cltn2_id|)\"]"], ["proof (prove)\nusing this:\n  cltn2_compose (cltn2_compose ?A ?B) ?C =\n  cltn2_compose ?A (cltn2_compose ?B ?C)\n  cltn2_compose cltn2_id ?A = ?A\n  \\<exists>B. cltn2_compose B ?A = cltn2_id\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<in> carrier\n                                \\<lparr>carrier = UNIV,\n                                   monoid.mult = cltn2_compose,\n                                   one = cltn2_id\\<rparr>;\n               y \\<in> carrier\n                        \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                           one = cltn2_id\\<rparr>\\<rbrakk>\n              \\<Longrightarrow> x \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n                                y\n                                \\<in> carrier\n \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n    one = cltn2_id\\<rparr>;\n   \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n   \\<in> carrier\n          \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n             one = cltn2_id\\<rparr>;\n   \\<And>x y z.\n      \\<lbrakk>x \\<in> carrier\n                        \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                           one = cltn2_id\\<rparr>;\n       y \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr>;\n       z \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr>\\<rbrakk>\n      \\<Longrightarrow> x \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n                        y \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n                        z =\n                        x \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n                        (y \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n                         z);\n   \\<And>x.\n      x \\<in> carrier\n               \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                  one = cltn2_id\\<rparr> \\<Longrightarrow>\n      \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n      x =\n      x;\n   \\<And>x.\n      x \\<in> carrier\n               \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                  one = cltn2_id\\<rparr> \\<Longrightarrow>\n      \\<exists>y\\<in>carrier\n                      \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                         one = cltn2_id\\<rparr>.\n         y \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         x =\n         \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> Group.group\n                     \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                        one = cltn2_id\\<rparr>\n\ngoal (1 subgoal):\n 1. Group.group\n     \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n        one = cltn2_id\\<rparr>", "by simp_all"], ["", "lemma cltn2_inverse_inv [simp]:\n  \"inv\\<^bsub>(|carrier = UNIV, mult = cltn2_compose, one = cltn2_id|)\\<^esub> A\n  = cltn2_inverse A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> A =\n    cltn2_inverse A", "using cltn2_left_inverse [of A] and cltn2.inv_equality"], ["proof (prove)\nusing this:\n  cltn2_compose (cltn2_inverse A) A = cltn2_id\n  \\<lbrakk>?y \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n           ?x =\n           \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>;\n   ?x \\<in> carrier\n             \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                one = cltn2_id\\<rparr>;\n   ?y \\<in> carrier\n             \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                one = cltn2_id\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> inv\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> ?x =\n                    ?y\n\ngoal (1 subgoal):\n 1. inv\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> A =\n    cltn2_inverse A", "by simp"], ["", "lemmas cltn2_inverse_id [simp] = cltn2.inv_one [simplified]\n  and cltn2_inverse_compose = cltn2.inv_mult_group [simplified]"], ["", "subsubsection \"As a group action\""], ["", "lemma apply_cltn2_id [simp]: \"apply_cltn2 p cltn2_id = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2 p cltn2_id = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. apply_cltn2 p cltn2_id = p", "from matrix_id_invertible and apply_cltn2_right_abs"], ["proof (chain)\npicking this:\n  invertible (mat (1::?'a))\n  invertible ?M \\<Longrightarrow>\n  apply_cltn2 ?p (cltn2_abs ?M) = proj2_abs (proj2_rep ?p v* ?M)", "have \"apply_cltn2 p cltn2_id = proj2_abs (proj2_rep p v* mat 1)\""], ["proof (prove)\nusing this:\n  invertible (mat (1::?'a))\n  invertible ?M \\<Longrightarrow>\n  apply_cltn2 ?p (cltn2_abs ?M) = proj2_abs (proj2_rep ?p v* ?M)\n\ngoal (1 subgoal):\n 1. apply_cltn2 p cltn2_id = proj2_abs (proj2_rep p v* mat 1)", "unfolding cltn2_id_def"], ["proof (prove)\nusing this:\n  invertible (mat (1::?'a))\n  invertible ?M \\<Longrightarrow>\n  apply_cltn2 ?p (cltn2_abs ?M) = proj2_abs (proj2_rep ?p v* ?M)\n\ngoal (1 subgoal):\n 1. apply_cltn2 p (cltn2_abs (mat 1)) = proj2_abs (proj2_rep p v* mat 1)", "by blast"], ["proof (state)\nthis:\n  apply_cltn2 p cltn2_id = proj2_abs (proj2_rep p v* mat 1)\n\ngoal (1 subgoal):\n 1. apply_cltn2 p cltn2_id = p", "thus \"apply_cltn2 p cltn2_id = p\""], ["proof (prove)\nusing this:\n  apply_cltn2 p cltn2_id = proj2_abs (proj2_rep p v* mat 1)\n\ngoal (1 subgoal):\n 1. apply_cltn2 p cltn2_id = p", "by (simp add: proj2_abs_rep)"], ["proof (state)\nthis:\n  apply_cltn2 p cltn2_id = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_cltn2_compose:\n  \"apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (cltn2_compose A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (cltn2_compose A B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (cltn2_compose A B)", "from rep_mult_rep_non_zero and cltn2_rep_invertible and apply_cltn2_abs"], ["proof (chain)\npicking this:\n  proj2_rep ?p v* cltn2_rep ?A \\<noteq> 0\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>?x \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2 (proj2_abs ?x) (cltn2_abs ?A) =\n                    proj2_abs (?x v* ?A)", "have \"apply_cltn2 (apply_cltn2 p A) (cltn2_abs (cltn2_rep B))\n    = proj2_abs ((proj2_rep p v* cltn2_rep A) v* cltn2_rep B)\""], ["proof (prove)\nusing this:\n  proj2_rep ?p v* cltn2_rep ?A \\<noteq> 0\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>?x \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2 (proj2_abs ?x) (cltn2_abs ?A) =\n                    proj2_abs (?x v* ?A)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 p A) (cltn2_abs (cltn2_rep B)) =\n    proj2_abs (proj2_rep p v* cltn2_rep A v* cltn2_rep B)", "unfolding apply_cltn2_def [of p A]"], ["proof (prove)\nusing this:\n  proj2_rep ?p v* cltn2_rep ?A \\<noteq> 0\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>?x \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2 (proj2_abs ?x) (cltn2_abs ?A) =\n                    proj2_abs (?x v* ?A)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs (proj2_rep p v* cltn2_rep A))\n     (cltn2_abs (cltn2_rep B)) =\n    proj2_abs (proj2_rep p v* cltn2_rep A v* cltn2_rep B)", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (apply_cltn2 p A) (cltn2_abs (cltn2_rep B)) =\n  proj2_abs (proj2_rep p v* cltn2_rep A v* cltn2_rep B)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (cltn2_compose A B)", "hence \"apply_cltn2 (apply_cltn2 p A) B\n    = proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))\""], ["proof (prove)\nusing this:\n  apply_cltn2 (apply_cltn2 p A) (cltn2_abs (cltn2_rep B)) =\n  proj2_abs (proj2_rep p v* cltn2_rep A v* cltn2_rep B)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 p A) B =\n    proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))", "by (simp add: cltn2_abs_rep vector_matrix_mul_assoc)"], ["proof (state)\nthis:\n  apply_cltn2 (apply_cltn2 p A) B =\n  proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (cltn2_compose A B)", "from cltn2_rep_invertible and invertible_mult"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)", "have \"invertible (cltn2_rep A ** cltn2_rep B)\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A ** cltn2_rep B)", "by auto"], ["proof (state)\nthis:\n  invertible (cltn2_rep A ** cltn2_rep B)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (cltn2_compose A B)", "with apply_cltn2_right_abs"], ["proof (chain)\npicking this:\n  invertible ?M \\<Longrightarrow>\n  apply_cltn2 ?p (cltn2_abs ?M) = proj2_abs (proj2_rep ?p v* ?M)\n  invertible (cltn2_rep A ** cltn2_rep B)", "have \"apply_cltn2 p (cltn2_compose A B)\n    = proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))\""], ["proof (prove)\nusing this:\n  invertible ?M \\<Longrightarrow>\n  apply_cltn2 ?p (cltn2_abs ?M) = proj2_abs (proj2_rep ?p v* ?M)\n  invertible (cltn2_rep A ** cltn2_rep B)\n\ngoal (1 subgoal):\n 1. apply_cltn2 p (cltn2_compose A B) =\n    proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))", "unfolding cltn2_compose_def"], ["proof (prove)\nusing this:\n  invertible ?M \\<Longrightarrow>\n  apply_cltn2 ?p (cltn2_abs ?M) = proj2_abs (proj2_rep ?p v* ?M)\n  invertible (cltn2_rep A ** cltn2_rep B)\n\ngoal (1 subgoal):\n 1. apply_cltn2 p (cltn2_abs (cltn2_rep A ** cltn2_rep B)) =\n    proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 p (cltn2_compose A B) =\n  proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (cltn2_compose A B)", "with \\<open>apply_cltn2 (apply_cltn2 p A) B\n    = proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))\\<close>"], ["proof (chain)\npicking this:\n  apply_cltn2 (apply_cltn2 p A) B =\n  proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))\n  apply_cltn2 p (cltn2_compose A B) =\n  proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))", "show \"apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (cltn2_compose A B)\""], ["proof (prove)\nusing this:\n  apply_cltn2 (apply_cltn2 p A) B =\n  proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))\n  apply_cltn2 p (cltn2_compose A B) =\n  proj2_abs (proj2_rep p v* (cltn2_rep A ** cltn2_rep B))\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (cltn2_compose A B)", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (cltn2_compose A B)\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation cltn2:\n  action \"(|carrier = UNIV, mult = cltn2_compose, one = cltn2_id|)\" apply_cltn2"], ["proof (prove)\ngoal (1 subgoal):\n 1. action\n     \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n        one = cltn2_id\\<rparr>\n     apply_cltn2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       apply_cltn2 b\n        \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> =\n       b\n 2. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2 (apply_cltn2 b g) h =\n       apply_cltn2 b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "let ?G = \"(|carrier = UNIV, mult = cltn2_compose, one = cltn2_id|)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       apply_cltn2 b\n        \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> =\n       b\n 2. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2 (apply_cltn2 b g) h =\n       apply_cltn2 b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       apply_cltn2 b\n        \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> =\n       b\n 2. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2 (apply_cltn2 b g) h =\n       apply_cltn2 b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "show \"apply_cltn2 p \\<one>\\<^bsub>?G\\<^esub> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2 p\n     \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> =\n    p", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 p\n   \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> =\n  p\n\ngoal (1 subgoal):\n 1. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2 (apply_cltn2 b g) h =\n       apply_cltn2 b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2 (apply_cltn2 b g) h =\n       apply_cltn2 b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "have \"apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (A \\<otimes>\\<^bsub>?G\\<^esub> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 p A) B =\n    apply_cltn2 p\n     (A \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n      B)", "by simp (rule apply_cltn2_compose)"], ["proof (state)\nthis:\n  apply_cltn2 (apply_cltn2 p A) B =\n  apply_cltn2 p\n   (A \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n    B)\n\ngoal (1 subgoal):\n 1. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2 (apply_cltn2 b g) h =\n       apply_cltn2 b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "thus \"A \\<in> carrier ?G \\<and> B \\<in> carrier ?G\n    \\<longrightarrow> apply_cltn2 (apply_cltn2 p A) B = apply_cltn2 p (A \\<otimes>\\<^bsub>?G\\<^esub> B)\""], ["proof (prove)\nusing this:\n  apply_cltn2 (apply_cltn2 p A) B =\n  apply_cltn2 p\n   (A \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n    B)\n\ngoal (1 subgoal):\n 1. A \\<in> carrier\n             \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                one = cltn2_id\\<rparr> \\<and>\n    B \\<in> carrier\n             \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                one = cltn2_id\\<rparr> \\<longrightarrow>\n    apply_cltn2 (apply_cltn2 p A) B =\n    apply_cltn2 p\n     (A \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n      B)", ".."], ["proof (state)\nthis:\n  A \\<in> carrier\n           \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n              one = cltn2_id\\<rparr> \\<and>\n  B \\<in> carrier\n           \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n              one = cltn2_id\\<rparr> \\<longrightarrow>\n  apply_cltn2 (apply_cltn2 p A) B =\n  apply_cltn2 p\n   (A \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n    B)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition cltn2_transpose :: \"cltn2 \\<Rightarrow> cltn2\" where\n  \"cltn2_transpose A \\<equiv> cltn2_abs (transpose (cltn2_rep A))\""], ["", "definition apply_cltn2_line :: \"proj2_line \\<Rightarrow> cltn2 \\<Rightarrow> proj2_line\" where\n  \"apply_cltn2_line l A\n  \\<equiv> P2L (apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A)))\""], ["", "lemma cltn2_transpose_abs:\n  assumes \"invertible M\"\n  shows \"cltn2_transpose (cltn2_abs M) = cltn2_abs (transpose M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_abs M) =\n    cltn2_abs (Finite_Cartesian_Product.transpose M)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_abs M) =\n    cltn2_abs (Finite_Cartesian_Product.transpose M)", "from \\<open>invertible M\\<close> and transpose_invertible"], ["proof (chain)\npicking this:\n  invertible M\n  invertible ?A \\<Longrightarrow>\n  invertible (Finite_Cartesian_Product.transpose ?A)", "have \"invertible (transpose M)\""], ["proof (prove)\nusing this:\n  invertible M\n  invertible ?A \\<Longrightarrow>\n  invertible (Finite_Cartesian_Product.transpose ?A)\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose M)", "by auto"], ["proof (state)\nthis:\n  invertible (Finite_Cartesian_Product.transpose M)\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_abs M) =\n    cltn2_abs (Finite_Cartesian_Product.transpose M)", "from \\<open>invertible M\\<close> and cltn2_rep_abs2"], ["proof (chain)\npicking this:\n  invertible M\n  invertible ?A \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs ?A) = k *\\<^sub>R ?A", "obtain k where \"k \\<noteq> 0\" and \"cltn2_rep (cltn2_abs M) = k *\\<^sub>R M\""], ["proof (prove)\nusing this:\n  invertible M\n  invertible ?A \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> cltn2_rep (cltn2_abs ?A) = k *\\<^sub>R ?A\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<noteq> 0;\n         cltn2_rep (cltn2_abs M) = k *\\<^sub>R M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  cltn2_rep (cltn2_abs M) = k *\\<^sub>R M\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_abs M) =\n    cltn2_abs (Finite_Cartesian_Product.transpose M)", "from \\<open>cltn2_rep (cltn2_abs M) = k *\\<^sub>R M\\<close>"], ["proof (chain)\npicking this:\n  cltn2_rep (cltn2_abs M) = k *\\<^sub>R M", "have \"transpose (cltn2_rep (cltn2_abs M)) = k *\\<^sub>R transpose M\""], ["proof (prove)\nusing this:\n  cltn2_rep (cltn2_abs M) = k *\\<^sub>R M\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_abs M)) =\n    k *\\<^sub>R Finite_Cartesian_Product.transpose M", "by (simp add: transpose_scalar)"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_abs M)) =\n  k *\\<^sub>R Finite_Cartesian_Product.transpose M\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_abs M) =\n    cltn2_abs (Finite_Cartesian_Product.transpose M)", "with \\<open>k \\<noteq> 0\\<close> and \\<open>invertible (transpose M)\\<close>"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  invertible (Finite_Cartesian_Product.transpose M)\n  Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_abs M)) =\n  k *\\<^sub>R Finite_Cartesian_Product.transpose M", "show \"cltn2_transpose (cltn2_abs M) = cltn2_abs (transpose M)\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  invertible (Finite_Cartesian_Product.transpose M)\n  Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_abs M)) =\n  k *\\<^sub>R Finite_Cartesian_Product.transpose M\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_abs M) =\n    cltn2_abs (Finite_Cartesian_Product.transpose M)", "unfolding cltn2_transpose_def"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  invertible (Finite_Cartesian_Product.transpose M)\n  Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_abs M)) =\n  k *\\<^sub>R Finite_Cartesian_Product.transpose M\n\ngoal (1 subgoal):\n 1. cltn2_abs\n     (Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_abs M))) =\n    cltn2_abs (Finite_Cartesian_Product.transpose M)", "by (simp add: cltn2_abs_mult)"], ["proof (state)\nthis:\n  cltn2_transpose (cltn2_abs M) =\n  cltn2_abs (Finite_Cartesian_Product.transpose M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_transpose_compose:\n  \"cltn2_transpose (cltn2_compose A B)\n  = cltn2_compose (cltn2_transpose B) (cltn2_transpose A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "from cltn2_rep_invertible"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep ?A)", "have \"invertible (cltn2_rep A)\" and \"invertible (cltn2_rep B)\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep ?A)\n\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A) &&& invertible (cltn2_rep B)", "by simp_all"], ["proof (state)\nthis:\n  invertible (cltn2_rep A)\n  invertible (cltn2_rep B)\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "with transpose_invertible"], ["proof (chain)\npicking this:\n  invertible ?A \\<Longrightarrow>\n  invertible (Finite_Cartesian_Product.transpose ?A)\n  invertible (cltn2_rep A)\n  invertible (cltn2_rep B)", "have \"invertible (transpose (cltn2_rep A))\"\n    and \"invertible (transpose (cltn2_rep B))\""], ["proof (prove)\nusing this:\n  invertible ?A \\<Longrightarrow>\n  invertible (Finite_Cartesian_Product.transpose ?A)\n  invertible (cltn2_rep A)\n  invertible (cltn2_rep B)\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose (cltn2_rep A)) &&&\n    invertible (Finite_Cartesian_Product.transpose (cltn2_rep B))", "by auto"], ["proof (state)\nthis:\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep A))\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep B))\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "from \\<open>invertible (cltn2_rep A)\\<close> and \\<open>invertible (cltn2_rep B)\\<close>\n    and invertible_mult"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep A)\n  invertible (cltn2_rep B)\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)", "have \"invertible (cltn2_rep A ** cltn2_rep B)\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep A)\n  invertible (cltn2_rep B)\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A ** cltn2_rep B)", "by auto"], ["proof (state)\nthis:\n  invertible (cltn2_rep A ** cltn2_rep B)\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "with \\<open>invertible (cltn2_rep A ** cltn2_rep B)\\<close> and cltn2_transpose_abs"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep A ** cltn2_rep B)\n  invertible ?M \\<Longrightarrow>\n  cltn2_transpose (cltn2_abs ?M) =\n  cltn2_abs (Finite_Cartesian_Product.transpose ?M)\n  invertible (cltn2_rep A ** cltn2_rep B)", "have \"cltn2_transpose (cltn2_compose A B)\n    = cltn2_abs (transpose (cltn2_rep A ** cltn2_rep B))\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep A ** cltn2_rep B)\n  invertible ?M \\<Longrightarrow>\n  cltn2_transpose (cltn2_abs ?M) =\n  cltn2_abs (Finite_Cartesian_Product.transpose ?M)\n  invertible (cltn2_rep A ** cltn2_rep B)\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_abs\n     (Finite_Cartesian_Product.transpose (cltn2_rep A ** cltn2_rep B))", "unfolding cltn2_compose_def"], ["proof (prove)\nusing this:\n  invertible (cltn2_rep A ** cltn2_rep B)\n  invertible ?M \\<Longrightarrow>\n  cltn2_transpose (cltn2_abs ?M) =\n  cltn2_abs (Finite_Cartesian_Product.transpose ?M)\n  invertible (cltn2_rep A ** cltn2_rep B)\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_abs (cltn2_rep A ** cltn2_rep B)) =\n    cltn2_abs\n     (Finite_Cartesian_Product.transpose (cltn2_rep A ** cltn2_rep B))", "by simp"], ["proof (state)\nthis:\n  cltn2_transpose (cltn2_compose A B) =\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose (cltn2_rep A ** cltn2_rep B))\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "also"], ["proof (state)\nthis:\n  cltn2_transpose (cltn2_compose A B) =\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose (cltn2_rep A ** cltn2_rep B))\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "have \"\\<dots> = cltn2_abs (transpose (cltn2_rep B) ** transpose (cltn2_rep A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_abs\n     (Finite_Cartesian_Product.transpose (cltn2_rep A ** cltn2_rep B)) =\n    cltn2_abs\n     (Finite_Cartesian_Product.transpose (cltn2_rep B) **\n      Finite_Cartesian_Product.transpose (cltn2_rep A))", "by (simp add: matrix_transpose_mul)"], ["proof (state)\nthis:\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose (cltn2_rep A ** cltn2_rep B)) =\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose (cltn2_rep B) **\n    Finite_Cartesian_Product.transpose (cltn2_rep A))\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "also"], ["proof (state)\nthis:\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose (cltn2_rep A ** cltn2_rep B)) =\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose (cltn2_rep B) **\n    Finite_Cartesian_Product.transpose (cltn2_rep A))\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "from \\<open>invertible (transpose (cltn2_rep B))\\<close>\n    and \\<open>invertible (transpose (cltn2_rep A))\\<close>\n    and cltn2_compose_abs"], ["proof (chain)\npicking this:\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep B))\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep A))\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_compose (cltn2_abs ?M) (cltn2_abs ?N) =\n                    cltn2_abs (?M ** ?N)", "have \"\\<dots> = cltn2_compose (cltn2_transpose B) (cltn2_transpose A)\""], ["proof (prove)\nusing this:\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep B))\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep A))\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_compose (cltn2_abs ?M) (cltn2_abs ?N) =\n                    cltn2_abs (?M ** ?N)\n\ngoal (1 subgoal):\n 1. cltn2_abs\n     (Finite_Cartesian_Product.transpose (cltn2_rep B) **\n      Finite_Cartesian_Product.transpose (cltn2_rep A)) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "unfolding cltn2_transpose_def"], ["proof (prove)\nusing this:\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep B))\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep A))\n  \\<lbrakk>invertible ?M; invertible ?N\\<rbrakk>\n  \\<Longrightarrow> cltn2_compose (cltn2_abs ?M) (cltn2_abs ?N) =\n                    cltn2_abs (?M ** ?N)\n\ngoal (1 subgoal):\n 1. cltn2_abs\n     (Finite_Cartesian_Product.transpose (cltn2_rep B) **\n      Finite_Cartesian_Product.transpose (cltn2_rep A)) =\n    cltn2_compose\n     (cltn2_abs (Finite_Cartesian_Product.transpose (cltn2_rep B)))\n     (cltn2_abs (Finite_Cartesian_Product.transpose (cltn2_rep A)))", "by simp"], ["proof (state)\nthis:\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose (cltn2_rep B) **\n    Finite_Cartesian_Product.transpose (cltn2_rep A)) =\n  cltn2_compose (cltn2_transpose B) (cltn2_transpose A)\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "finally"], ["proof (chain)\npicking this:\n  cltn2_transpose (cltn2_compose A B) =\n  cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "show \"cltn2_transpose (cltn2_compose A B)\n    = cltn2_compose (cltn2_transpose B) (cltn2_transpose A)\""], ["proof (prove)\nusing this:\n  cltn2_transpose (cltn2_compose A B) =\n  cltn2_compose (cltn2_transpose B) (cltn2_transpose A)\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_compose A B) =\n    cltn2_compose (cltn2_transpose B) (cltn2_transpose A)", "."], ["proof (state)\nthis:\n  cltn2_transpose (cltn2_compose A B) =\n  cltn2_compose (cltn2_transpose B) (cltn2_transpose A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_transpose_transpose: \"cltn2_transpose (cltn2_transpose A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_transpose A) = A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_transpose A) = A", "from cltn2_rep_invertible"], ["proof (chain)\npicking this:\n  invertible (cltn2_rep ?A)", "have \"invertible (cltn2_rep A)\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep ?A)\n\ngoal (1 subgoal):\n 1. invertible (cltn2_rep A)", "by simp"], ["proof (state)\nthis:\n  invertible (cltn2_rep A)\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_transpose A) = A", "with transpose_invertible"], ["proof (chain)\npicking this:\n  invertible ?A \\<Longrightarrow>\n  invertible (Finite_Cartesian_Product.transpose ?A)\n  invertible (cltn2_rep A)", "have \"invertible (transpose (cltn2_rep A))\""], ["proof (prove)\nusing this:\n  invertible ?A \\<Longrightarrow>\n  invertible (Finite_Cartesian_Product.transpose ?A)\n  invertible (cltn2_rep A)\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose (cltn2_rep A))", "by auto"], ["proof (state)\nthis:\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep A))\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_transpose A) = A", "with cltn2_transpose_abs [of \"transpose (cltn2_rep A)\"]"], ["proof (chain)\npicking this:\n  invertible\n   (Finite_Cartesian_Product.transpose (cltn2_rep A)) \\<Longrightarrow>\n  cltn2_transpose\n   (cltn2_abs (Finite_Cartesian_Product.transpose (cltn2_rep A))) =\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose\n     (Finite_Cartesian_Product.transpose (cltn2_rep A)))\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep A))", "have\n    \"cltn2_transpose (cltn2_transpose A) = cltn2_abs (transpose (transpose (cltn2_rep A)))\""], ["proof (prove)\nusing this:\n  invertible\n   (Finite_Cartesian_Product.transpose (cltn2_rep A)) \\<Longrightarrow>\n  cltn2_transpose\n   (cltn2_abs (Finite_Cartesian_Product.transpose (cltn2_rep A))) =\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose\n     (Finite_Cartesian_Product.transpose (cltn2_rep A)))\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep A))\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_transpose A) =\n    cltn2_abs\n     (Finite_Cartesian_Product.transpose\n       (Finite_Cartesian_Product.transpose (cltn2_rep A)))", "unfolding cltn2_transpose_def [of A]"], ["proof (prove)\nusing this:\n  invertible\n   (Finite_Cartesian_Product.transpose (cltn2_rep A)) \\<Longrightarrow>\n  cltn2_transpose\n   (cltn2_abs (Finite_Cartesian_Product.transpose (cltn2_rep A))) =\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose\n     (Finite_Cartesian_Product.transpose (cltn2_rep A)))\n  invertible (Finite_Cartesian_Product.transpose (cltn2_rep A))\n\ngoal (1 subgoal):\n 1. cltn2_transpose\n     (cltn2_abs (Finite_Cartesian_Product.transpose (cltn2_rep A))) =\n    cltn2_abs\n     (Finite_Cartesian_Product.transpose\n       (Finite_Cartesian_Product.transpose (cltn2_rep A)))", "by simp"], ["proof (state)\nthis:\n  cltn2_transpose (cltn2_transpose A) =\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose\n     (Finite_Cartesian_Product.transpose (cltn2_rep A)))\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_transpose A) = A", "with cltn2_abs_rep and transpose_transpose [of \"cltn2_rep A\"]"], ["proof (chain)\npicking this:\n  cltn2_abs (cltn2_rep ?A) = ?A\n  Finite_Cartesian_Product.transpose\n   (Finite_Cartesian_Product.transpose (cltn2_rep A)) =\n  cltn2_rep A\n  cltn2_transpose (cltn2_transpose A) =\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose\n     (Finite_Cartesian_Product.transpose (cltn2_rep A)))", "show \"cltn2_transpose (cltn2_transpose A) = A\""], ["proof (prove)\nusing this:\n  cltn2_abs (cltn2_rep ?A) = ?A\n  Finite_Cartesian_Product.transpose\n   (Finite_Cartesian_Product.transpose (cltn2_rep A)) =\n  cltn2_rep A\n  cltn2_transpose (cltn2_transpose A) =\n  cltn2_abs\n   (Finite_Cartesian_Product.transpose\n     (Finite_Cartesian_Product.transpose (cltn2_rep A)))\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_transpose A) = A", "by simp"], ["proof (state)\nthis:\n  cltn2_transpose (cltn2_transpose A) = A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_transpose_id [simp]: \"cltn2_transpose cltn2_id = cltn2_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_transpose cltn2_id = cltn2_id", "using cltn2_transpose_abs"], ["proof (prove)\nusing this:\n  invertible ?M \\<Longrightarrow>\n  cltn2_transpose (cltn2_abs ?M) =\n  cltn2_abs (Finite_Cartesian_Product.transpose ?M)\n\ngoal (1 subgoal):\n 1. cltn2_transpose cltn2_id = cltn2_id", "unfolding cltn2_id_def"], ["proof (prove)\nusing this:\n  invertible ?M \\<Longrightarrow>\n  cltn2_transpose (cltn2_abs ?M) =\n  cltn2_abs (Finite_Cartesian_Product.transpose ?M)\n\ngoal (1 subgoal):\n 1. cltn2_transpose (cltn2_abs (mat 1)) = cltn2_abs (mat 1)", "by (simp add: transpose_mat matrix_id_invertible)"], ["", "lemma apply_cltn2_line_id [simp]: \"apply_cltn2_line l cltn2_id = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2_line l cltn2_id = l", "unfolding apply_cltn2_line_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P2L (apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse cltn2_id))) = l", "by simp"], ["", "lemma apply_cltn2_line_compose:\n  \"apply_cltn2_line (apply_cltn2_line l A) B\n  = apply_cltn2_line l (cltn2_compose A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2_line (apply_cltn2_line l A) B =\n    apply_cltn2_line l (cltn2_compose A B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. apply_cltn2_line (apply_cltn2_line l A) B =\n    apply_cltn2_line l (cltn2_compose A B)", "have \"cltn2_compose\n    (cltn2_transpose (cltn2_inverse A)) (cltn2_transpose (cltn2_inverse B))\n    = cltn2_transpose (cltn2_inverse (cltn2_compose A B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_compose (cltn2_transpose (cltn2_inverse A))\n     (cltn2_transpose (cltn2_inverse B)) =\n    cltn2_transpose (cltn2_inverse (cltn2_compose A B))", "by (simp add: cltn2_transpose_compose cltn2_inverse_compose)"], ["proof (state)\nthis:\n  cltn2_compose (cltn2_transpose (cltn2_inverse A))\n   (cltn2_transpose (cltn2_inverse B)) =\n  cltn2_transpose (cltn2_inverse (cltn2_compose A B))\n\ngoal (1 subgoal):\n 1. apply_cltn2_line (apply_cltn2_line l A) B =\n    apply_cltn2_line l (cltn2_compose A B)", "thus \"apply_cltn2_line (apply_cltn2_line l A) B\n    = apply_cltn2_line l (cltn2_compose A B)\""], ["proof (prove)\nusing this:\n  cltn2_compose (cltn2_transpose (cltn2_inverse A))\n   (cltn2_transpose (cltn2_inverse B)) =\n  cltn2_transpose (cltn2_inverse (cltn2_compose A B))\n\ngoal (1 subgoal):\n 1. apply_cltn2_line (apply_cltn2_line l A) B =\n    apply_cltn2_line l (cltn2_compose A B)", "unfolding apply_cltn2_line_def"], ["proof (prove)\nusing this:\n  cltn2_compose (cltn2_transpose (cltn2_inverse A))\n   (cltn2_transpose (cltn2_inverse B)) =\n  cltn2_transpose (cltn2_inverse (cltn2_compose A B))\n\ngoal (1 subgoal):\n 1. P2L (apply_cltn2\n          (L2P (P2L (apply_cltn2 (L2P l)\n                      (cltn2_transpose (cltn2_inverse A)))))\n          (cltn2_transpose (cltn2_inverse B))) =\n    P2L (apply_cltn2 (L2P l)\n          (cltn2_transpose (cltn2_inverse (cltn2_compose A B))))", "by (simp add: apply_cltn2_compose)"], ["proof (state)\nthis:\n  apply_cltn2_line (apply_cltn2_line l A) B =\n  apply_cltn2_line l (cltn2_compose A B)\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation cltn2_line:\n  action\n  \"(|carrier = UNIV, mult = cltn2_compose, one = cltn2_id|)\"\n  apply_cltn2_line"], ["proof (prove)\ngoal (1 subgoal):\n 1. action\n     \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n        one = cltn2_id\\<rparr>\n     apply_cltn2_line", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       apply_cltn2_line b\n        \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> =\n       b\n 2. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2_line (apply_cltn2_line b g) h =\n       apply_cltn2_line b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "let ?G = \"(|carrier = UNIV, mult = cltn2_compose, one = cltn2_id|)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       apply_cltn2_line b\n        \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> =\n       b\n 2. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2_line (apply_cltn2_line b g) h =\n       apply_cltn2_line b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "fix l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       apply_cltn2_line b\n        \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> =\n       b\n 2. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2_line (apply_cltn2_line b g) h =\n       apply_cltn2_line b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "show \"apply_cltn2_line l \\<one>\\<^bsub>?G\\<^esub> = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2_line l\n     \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> =\n    l", "by simp"], ["proof (state)\nthis:\n  apply_cltn2_line l\n   \\<one>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> =\n  l\n\ngoal (1 subgoal):\n 1. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2_line (apply_cltn2_line b g) h =\n       apply_cltn2_line b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2_line (apply_cltn2_line b g) h =\n       apply_cltn2_line b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "have \"apply_cltn2_line (apply_cltn2_line l A) B\n    = apply_cltn2_line l (A \\<otimes>\\<^bsub>?G\\<^esub> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2_line (apply_cltn2_line l A) B =\n    apply_cltn2_line l\n     (A \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n      B)", "by simp (rule apply_cltn2_line_compose)"], ["proof (state)\nthis:\n  apply_cltn2_line (apply_cltn2_line l A) B =\n  apply_cltn2_line l\n   (A \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n    B)\n\ngoal (1 subgoal):\n 1. \\<And>g h b.\n       g \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<and>\n       h \\<in> carrier\n                \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                   one = cltn2_id\\<rparr> \\<longrightarrow>\n       apply_cltn2_line (apply_cltn2_line b g) h =\n       apply_cltn2_line b\n        (g \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n         h)", "thus \"A \\<in> carrier ?G \\<and> B \\<in> carrier ?G\n    \\<longrightarrow> apply_cltn2_line (apply_cltn2_line l A) B\n    = apply_cltn2_line l (A \\<otimes>\\<^bsub>?G\\<^esub> B)\""], ["proof (prove)\nusing this:\n  apply_cltn2_line (apply_cltn2_line l A) B =\n  apply_cltn2_line l\n   (A \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n    B)\n\ngoal (1 subgoal):\n 1. A \\<in> carrier\n             \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                one = cltn2_id\\<rparr> \\<and>\n    B \\<in> carrier\n             \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                one = cltn2_id\\<rparr> \\<longrightarrow>\n    apply_cltn2_line (apply_cltn2_line l A) B =\n    apply_cltn2_line l\n     (A \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n      B)", ".."], ["proof (state)\nthis:\n  A \\<in> carrier\n           \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n              one = cltn2_id\\<rparr> \\<and>\n  B \\<in> carrier\n           \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n              one = cltn2_id\\<rparr> \\<longrightarrow>\n  apply_cltn2_line (apply_cltn2_line l A) B =\n  apply_cltn2_line l\n   (A \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n    B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas apply_cltn2_inv [simp] = cltn2.act_act_inv [simplified]"], ["", "lemmas apply_cltn2_line_inv [simp] = cltn2_line.act_act_inv [simplified]"], ["", "lemma apply_cltn2_line_alt_def:\n  \"apply_cltn2_line l A\n  = proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2_line l A =\n    proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. apply_cltn2_line l A =\n    proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)", "have \"invertible (cltn2_rep (cltn2_inverse A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (cltn2_rep (cltn2_inverse A))", "by (rule cltn2_rep_invertible)"], ["proof (state)\nthis:\n  invertible (cltn2_rep (cltn2_inverse A))\n\ngoal (1 subgoal):\n 1. apply_cltn2_line l A =\n    proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)", "hence \"invertible (transpose (cltn2_rep (cltn2_inverse A)))\""], ["proof (prove)\nusing this:\n  invertible (cltn2_rep (cltn2_inverse A))\n\ngoal (1 subgoal):\n 1. invertible\n     (Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_inverse A)))", "by (rule transpose_invertible)"], ["proof (state)\nthis:\n  invertible\n   (Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_inverse A)))\n\ngoal (1 subgoal):\n 1. apply_cltn2_line l A =\n    proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)", "hence\n    \"apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A))\n    = proj2_abs (proj2_rep (L2P l) v* transpose (cltn2_rep (cltn2_inverse A)))\""], ["proof (prove)\nusing this:\n  invertible\n   (Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_inverse A)))\n\ngoal (1 subgoal):\n 1. apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A)) =\n    proj2_abs\n     (proj2_rep (L2P l) v*\n      Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_inverse A)))", "unfolding cltn2_transpose_def"], ["proof (prove)\nusing this:\n  invertible\n   (Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_inverse A)))\n\ngoal (1 subgoal):\n 1. apply_cltn2 (L2P l)\n     (cltn2_abs\n       (Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_inverse A)))) =\n    proj2_abs\n     (proj2_rep (L2P l) v*\n      Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_inverse A)))", "by (rule apply_cltn2_right_abs)"], ["proof (state)\nthis:\n  apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A)) =\n  proj2_abs\n   (proj2_rep (L2P l) v*\n    Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_inverse A)))\n\ngoal (1 subgoal):\n 1. apply_cltn2_line l A =\n    proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)", "hence \"apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A))\n    = proj2_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\""], ["proof (prove)\nusing this:\n  apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A)) =\n  proj2_abs\n   (proj2_rep (L2P l) v*\n    Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_inverse A)))\n\ngoal (1 subgoal):\n 1. apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A)) =\n    proj2_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)", "unfolding proj2_line_rep_def"], ["proof (prove)\nusing this:\n  apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A)) =\n  proj2_abs\n   (proj2_rep (L2P l) v*\n    Finite_Cartesian_Product.transpose (cltn2_rep (cltn2_inverse A)))\n\ngoal (1 subgoal):\n 1. apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A)) =\n    proj2_abs (cltn2_rep (cltn2_inverse A) *v proj2_rep (L2P l))", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A)) =\n  proj2_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\n\ngoal (1 subgoal):\n 1. apply_cltn2_line l A =\n    proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)", "thus \"apply_cltn2_line l A\n    = proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\""], ["proof (prove)\nusing this:\n  apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A)) =\n  proj2_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\n\ngoal (1 subgoal):\n 1. apply_cltn2_line l A =\n    proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)", "unfolding apply_cltn2_line_def and proj2_line_abs_def"], ["proof (prove)\nusing this:\n  apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A)) =\n  proj2_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\n\ngoal (1 subgoal):\n 1. P2L (apply_cltn2 (L2P l) (cltn2_transpose (cltn2_inverse A))) =\n    P2L (proj2_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l))", ".."], ["proof (state)\nthis:\n  apply_cltn2_line l A =\n  proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rep_mult_line_rep_non_zero: \"cltn2_rep A *v proj2_line_rep l \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_rep A *v proj2_line_rep l \\<noteq> 0", "using proj2_line_rep_non_zero and cltn2_rep_invertible\n    and invertible_times_eq_zero"], ["proof (prove)\nusing this:\n  proj2_line_rep ?l \\<noteq> 0\n  invertible (cltn2_rep ?A)\n  \\<lbrakk>invertible ?A; ?A *v ?x = 0\\<rbrakk> \\<Longrightarrow> ?x = 0\n\ngoal (1 subgoal):\n 1. cltn2_rep A *v proj2_line_rep l \\<noteq> 0", "by auto"], ["", "lemma apply_cltn2_incident:\n  \"proj2_incident p (apply_cltn2_line l A)\n  \\<longleftrightarrow> proj2_incident (apply_cltn2 p (cltn2_inverse A)) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "have \"proj2_rep p v* cltn2_rep (cltn2_inverse A) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep p v* cltn2_rep (cltn2_inverse A) \\<noteq> 0", "by (rule rep_mult_rep_non_zero)"], ["proof (state)\nthis:\n  proj2_rep p v* cltn2_rep (cltn2_inverse A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "with proj2_rep_abs2"], ["proof (chain)\npicking this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  proj2_rep p v* cltn2_rep (cltn2_inverse A) \\<noteq> 0", "obtain j where \"j \\<noteq> 0\"\n    and \"proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep (cltn2_inverse A)))\n    = j *\\<^sub>R (proj2_rep p v* cltn2_rep (cltn2_inverse A))\""], ["proof (prove)\nusing this:\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  proj2_rep p v* cltn2_rep (cltn2_inverse A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<noteq> 0;\n         proj2_rep\n          (proj2_abs (proj2_rep p v* cltn2_rep (cltn2_inverse A))) =\n         j *\\<^sub>R (proj2_rep p v* cltn2_rep (cltn2_inverse A))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<noteq> 0\n  proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep (cltn2_inverse A))) =\n  j *\\<^sub>R (proj2_rep p v* cltn2_rep (cltn2_inverse A))\n\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "let ?v = \"cltn2_rep (cltn2_inverse A) *v proj2_line_rep l\""], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "have \"?v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cltn2_rep (cltn2_inverse A) *v proj2_line_rep l \\<noteq> 0", "by (rule rep_mult_line_rep_non_zero)"], ["proof (state)\nthis:\n  cltn2_rep (cltn2_inverse A) *v proj2_line_rep l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "with proj2_line_rep_abs [of ?v]"], ["proof (chain)\npicking this:\n  cltn2_rep (cltn2_inverse A) *v proj2_line_rep l \\<noteq>\n  0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_line_rep\n      (proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)) =\n     k *\\<^sub>R (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\n  cltn2_rep (cltn2_inverse A) *v proj2_line_rep l \\<noteq> 0", "obtain k where \"k \\<noteq> 0\"\n    and \"proj2_line_rep (proj2_line_abs ?v) = k *\\<^sub>R ?v\""], ["proof (prove)\nusing this:\n  cltn2_rep (cltn2_inverse A) *v proj2_line_rep l \\<noteq>\n  0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_line_rep\n      (proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)) =\n     k *\\<^sub>R (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\n  cltn2_rep (cltn2_inverse A) *v proj2_line_rep l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<noteq> 0;\n         proj2_line_rep\n          (proj2_line_abs\n            (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)) =\n         k *\\<^sub>R\n         (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  proj2_line_rep\n   (proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)) =\n  k *\\<^sub>R (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\n\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "hence \"proj2_incident p (apply_cltn2_line l A)\n    \\<longleftrightarrow> proj2_rep p \\<bullet> (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l) = 0\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  proj2_line_rep\n   (proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)) =\n  k *\\<^sub>R (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\n\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    (proj2_rep p \\<bullet>\n     (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l) =\n     0)", "unfolding proj2_incident_def and apply_cltn2_line_alt_def"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  proj2_line_rep\n   (proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)) =\n  k *\\<^sub>R (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)\n\ngoal (1 subgoal):\n 1. (proj2_rep p \\<bullet>\n     proj2_line_rep\n      (proj2_line_abs (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l)) =\n     0) =\n    (proj2_rep p \\<bullet>\n     (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l) =\n     0)", "by (simp add: dot_scaleR_mult)"], ["proof (state)\nthis:\n  proj2_incident p (apply_cltn2_line l A) =\n  (proj2_rep p \\<bullet> (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l) =\n   0)\n\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "also"], ["proof (state)\nthis:\n  proj2_incident p (apply_cltn2_line l A) =\n  (proj2_rep p \\<bullet> (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l) =\n   0)\n\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "from dot_lmul_matrix [of \"proj2_rep p\" \"cltn2_rep (cltn2_inverse A)\"]"], ["proof (chain)\npicking this:\n  (proj2_rep p v* cltn2_rep (cltn2_inverse A)) \\<bullet> ?y =\n  proj2_rep p \\<bullet> (cltn2_rep (cltn2_inverse A) *v ?y)", "have\n    \"\\<dots> \\<longleftrightarrow> (proj2_rep p v* cltn2_rep (cltn2_inverse A)) \\<bullet> proj2_line_rep l = 0\""], ["proof (prove)\nusing this:\n  (proj2_rep p v* cltn2_rep (cltn2_inverse A)) \\<bullet> ?y =\n  proj2_rep p \\<bullet> (cltn2_rep (cltn2_inverse A) *v ?y)\n\ngoal (1 subgoal):\n 1. (proj2_rep p \\<bullet>\n     (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l) =\n     0) =\n    ((proj2_rep p v* cltn2_rep (cltn2_inverse A)) \\<bullet>\n     proj2_line_rep l =\n     0)", "by simp"], ["proof (state)\nthis:\n  (proj2_rep p \\<bullet> (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l) =\n   0) =\n  ((proj2_rep p v* cltn2_rep (cltn2_inverse A)) \\<bullet> proj2_line_rep l =\n   0)\n\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "also"], ["proof (state)\nthis:\n  (proj2_rep p \\<bullet> (cltn2_rep (cltn2_inverse A) *v proj2_line_rep l) =\n   0) =\n  ((proj2_rep p v* cltn2_rep (cltn2_inverse A)) \\<bullet> proj2_line_rep l =\n   0)\n\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "from \\<open>j \\<noteq> 0\\<close>\n    and \\<open>proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep (cltn2_inverse A)))\n    = j *\\<^sub>R (proj2_rep p v* cltn2_rep (cltn2_inverse A))\\<close>"], ["proof (chain)\npicking this:\n  j \\<noteq> 0\n  proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep (cltn2_inverse A))) =\n  j *\\<^sub>R (proj2_rep p v* cltn2_rep (cltn2_inverse A))", "have \"\\<dots> \\<longleftrightarrow> proj2_incident (apply_cltn2 p (cltn2_inverse A)) l\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep (cltn2_inverse A))) =\n  j *\\<^sub>R (proj2_rep p v* cltn2_rep (cltn2_inverse A))\n\ngoal (1 subgoal):\n 1. ((proj2_rep p v* cltn2_rep (cltn2_inverse A)) \\<bullet>\n     proj2_line_rep l =\n     0) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "unfolding proj2_incident_def and apply_cltn2_def"], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep (cltn2_inverse A))) =\n  j *\\<^sub>R (proj2_rep p v* cltn2_rep (cltn2_inverse A))\n\ngoal (1 subgoal):\n 1. ((proj2_rep p v* cltn2_rep (cltn2_inverse A)) \\<bullet>\n     proj2_line_rep l =\n     0) =\n    (proj2_rep\n      (proj2_abs (proj2_rep p v* cltn2_rep (cltn2_inverse A))) \\<bullet>\n     proj2_line_rep l =\n     0)", "by (simp add: dot_scaleR_mult)"], ["proof (state)\nthis:\n  ((proj2_rep p v* cltn2_rep (cltn2_inverse A)) \\<bullet> proj2_line_rep l =\n   0) =\n  proj2_incident (apply_cltn2 p (cltn2_inverse A)) l\n\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "finally"], ["proof (chain)\npicking this:\n  proj2_incident p (apply_cltn2_line l A) =\n  proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "show ?thesis"], ["proof (prove)\nusing this:\n  proj2_incident p (apply_cltn2_line l A) =\n  proj2_incident (apply_cltn2 p (cltn2_inverse A)) l\n\ngoal (1 subgoal):\n 1. proj2_incident p (apply_cltn2_line l A) =\n    proj2_incident (apply_cltn2 p (cltn2_inverse A)) l", "."], ["proof (state)\nthis:\n  proj2_incident p (apply_cltn2_line l A) =\n  proj2_incident (apply_cltn2 p (cltn2_inverse A)) l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_cltn2_preserve_incident [iff]:\n  \"proj2_incident (apply_cltn2 p A) (apply_cltn2_line l A)\n  \\<longleftrightarrow> proj2_incident p l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident (apply_cltn2 p A) (apply_cltn2_line l A) =\n    proj2_incident p l", "by (simp add: apply_cltn2_incident)"], ["", "lemma apply_cltn2_preserve_set_Col:\n  assumes \"proj2_set_Col S\"\n  shows \"proj2_set_Col {apply_cltn2 p C | p. p \\<in> S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_set_Col {apply_cltn2 p C |p. p \\<in> S}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_set_Col {apply_cltn2 p C |p. p \\<in> S}", "from \\<open>proj2_set_Col S\\<close>"], ["proof (chain)\npicking this:\n  proj2_set_Col S", "obtain l where \"\\<forall> p\\<in>S. proj2_incident p l\""], ["proof (prove)\nusing this:\n  proj2_set_Col S\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<forall>p\\<in>S. proj2_incident p l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding proj2_set_Col_def"], ["proof (prove)\nusing this:\n  \\<exists>l. \\<forall>p\\<in>S. proj2_incident p l\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<forall>p\\<in>S. proj2_incident p l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>p\\<in>S. proj2_incident p l\n\ngoal (1 subgoal):\n 1. proj2_set_Col {apply_cltn2 p C |p. p \\<in> S}", "hence \"\\<forall> q \\<in> {apply_cltn2 p C | p. p \\<in> S}.\n    proj2_incident q (apply_cltn2_line l C)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>S. proj2_incident p l\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>{apply_cltn2 p C |p. p \\<in> S}.\n       proj2_incident q (apply_cltn2_line l C)", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>{apply_cltn2 p C |p. p \\<in> S}.\n     proj2_incident q (apply_cltn2_line l C)\n\ngoal (1 subgoal):\n 1. proj2_set_Col {apply_cltn2 p C |p. p \\<in> S}", "thus \"proj2_set_Col {apply_cltn2 p C | p. p \\<in> S}\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>{apply_cltn2 p C |p. p \\<in> S}.\n     proj2_incident q (apply_cltn2_line l C)\n\ngoal (1 subgoal):\n 1. proj2_set_Col {apply_cltn2 p C |p. p \\<in> S}", "unfolding proj2_set_Col_def"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>{apply_cltn2 p C |p. p \\<in> S}.\n     proj2_incident q (apply_cltn2_line l C)\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       \\<forall>p\\<in>{apply_cltn2 p C |p. p \\<in> S}. proj2_incident p l", ".."], ["proof (state)\nthis:\n  proj2_set_Col {apply_cltn2 p C |p. p \\<in> S}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_cltn2_injective:\n  assumes \"apply_cltn2 p C = apply_cltn2 q C\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = q", "from \\<open>apply_cltn2 p C = apply_cltn2 q C\\<close>"], ["proof (chain)\npicking this:\n  apply_cltn2 p C = apply_cltn2 q C", "have \"apply_cltn2 (apply_cltn2 p C) (cltn2_inverse C)\n    = apply_cltn2 (apply_cltn2 q C) (cltn2_inverse C)\""], ["proof (prove)\nusing this:\n  apply_cltn2 p C = apply_cltn2 q C\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 p C) (cltn2_inverse C) =\n    apply_cltn2 (apply_cltn2 q C) (cltn2_inverse C)", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (apply_cltn2 p C) (cltn2_inverse C) =\n  apply_cltn2 (apply_cltn2 q C) (cltn2_inverse C)\n\ngoal (1 subgoal):\n 1. p = q", "thus \"p = q\""], ["proof (prove)\nusing this:\n  apply_cltn2 (apply_cltn2 p C) (cltn2_inverse C) =\n  apply_cltn2 (apply_cltn2 q C) (cltn2_inverse C)\n\ngoal (1 subgoal):\n 1. p = q", "by simp"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_cltn2_line_injective:\n  assumes \"apply_cltn2_line l C = apply_cltn2_line m C\"\n  shows \"l = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l = m", "from \\<open>apply_cltn2_line l C = apply_cltn2_line m C\\<close>"], ["proof (chain)\npicking this:\n  apply_cltn2_line l C = apply_cltn2_line m C", "have \"apply_cltn2_line (apply_cltn2_line l C) (cltn2_inverse C)\n    = apply_cltn2_line (apply_cltn2_line m C) (cltn2_inverse C)\""], ["proof (prove)\nusing this:\n  apply_cltn2_line l C = apply_cltn2_line m C\n\ngoal (1 subgoal):\n 1. apply_cltn2_line (apply_cltn2_line l C) (cltn2_inverse C) =\n    apply_cltn2_line (apply_cltn2_line m C) (cltn2_inverse C)", "by simp"], ["proof (state)\nthis:\n  apply_cltn2_line (apply_cltn2_line l C) (cltn2_inverse C) =\n  apply_cltn2_line (apply_cltn2_line m C) (cltn2_inverse C)\n\ngoal (1 subgoal):\n 1. l = m", "thus \"l = m\""], ["proof (prove)\nusing this:\n  apply_cltn2_line (apply_cltn2_line l C) (cltn2_inverse C) =\n  apply_cltn2_line (apply_cltn2_line m C) (cltn2_inverse C)\n\ngoal (1 subgoal):\n 1. l = m", "by simp"], ["proof (state)\nthis:\n  l = m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_cltn2_line_unique:\n  assumes \"p \\<noteq> q\" and \"proj2_incident p l\" and \"proj2_incident q l\"\n  and \"proj2_incident (apply_cltn2 p C) m\"\n  and \"proj2_incident (apply_cltn2 q C) m\"\n  shows \"apply_cltn2_line l C = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2_line l C = m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. apply_cltn2_line l C = m", "from \\<open>proj2_incident p l\\<close>"], ["proof (chain)\npicking this:\n  proj2_incident p l", "have \"proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)\""], ["proof (prove)\nusing this:\n  proj2_incident p l\n\ngoal (1 subgoal):\n 1. proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)", "by simp"], ["proof (state)\nthis:\n  proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)\n\ngoal (1 subgoal):\n 1. apply_cltn2_line l C = m", "from \\<open>proj2_incident q l\\<close>"], ["proof (chain)\npicking this:\n  proj2_incident q l", "have \"proj2_incident (apply_cltn2 q C) (apply_cltn2_line l C)\""], ["proof (prove)\nusing this:\n  proj2_incident q l\n\ngoal (1 subgoal):\n 1. proj2_incident (apply_cltn2 q C) (apply_cltn2_line l C)", "by simp"], ["proof (state)\nthis:\n  proj2_incident (apply_cltn2 q C) (apply_cltn2_line l C)\n\ngoal (1 subgoal):\n 1. apply_cltn2_line l C = m", "from \\<open>p \\<noteq> q\\<close> and apply_cltn2_injective [of p C q]"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  apply_cltn2 p C = apply_cltn2 q C \\<Longrightarrow> p = q", "have \"apply_cltn2 p C \\<noteq> apply_cltn2 q C\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  apply_cltn2 p C = apply_cltn2 q C \\<Longrightarrow> p = q\n\ngoal (1 subgoal):\n 1. apply_cltn2 p C \\<noteq> apply_cltn2 q C", "by auto"], ["proof (state)\nthis:\n  apply_cltn2 p C \\<noteq> apply_cltn2 q C\n\ngoal (1 subgoal):\n 1. apply_cltn2_line l C = m", "with \\<open>proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)\\<close>\n    and \\<open>proj2_incident (apply_cltn2 q C) (apply_cltn2_line l C)\\<close>\n    and \\<open>proj2_incident (apply_cltn2 p C) m\\<close>\n    and \\<open>proj2_incident (apply_cltn2 q C) m\\<close>\n    and proj2_incident_unique"], ["proof (chain)\npicking this:\n  proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)\n  proj2_incident (apply_cltn2 q C) (apply_cltn2_line l C)\n  proj2_incident (apply_cltn2 p C) m\n  proj2_incident (apply_cltn2 q C) m\n  \\<lbrakk>proj2_incident ?p ?l; proj2_incident ?q ?l; proj2_incident ?p ?m;\n   proj2_incident ?q ?m\\<rbrakk>\n  \\<Longrightarrow> ?p = ?q \\<or> ?l = ?m\n  apply_cltn2 p C \\<noteq> apply_cltn2 q C", "show \"apply_cltn2_line l C = m\""], ["proof (prove)\nusing this:\n  proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)\n  proj2_incident (apply_cltn2 q C) (apply_cltn2_line l C)\n  proj2_incident (apply_cltn2 p C) m\n  proj2_incident (apply_cltn2 q C) m\n  \\<lbrakk>proj2_incident ?p ?l; proj2_incident ?q ?l; proj2_incident ?p ?m;\n   proj2_incident ?q ?m\\<rbrakk>\n  \\<Longrightarrow> ?p = ?q \\<or> ?l = ?m\n  apply_cltn2 p C \\<noteq> apply_cltn2 q C\n\ngoal (1 subgoal):\n 1. apply_cltn2_line l C = m", "by fast"], ["proof (state)\nthis:\n  apply_cltn2_line l C = m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_cltn2_unique:\n  assumes \"l \\<noteq> m\" and \"proj2_incident p l\" and \"proj2_incident p m\"\n  and \"proj2_incident q (apply_cltn2_line l C)\"\n  and \"proj2_incident q (apply_cltn2_line m C)\"\n  shows \"apply_cltn2 p C = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2 p C = q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. apply_cltn2 p C = q", "from \\<open>proj2_incident p l\\<close>"], ["proof (chain)\npicking this:\n  proj2_incident p l", "have \"proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)\""], ["proof (prove)\nusing this:\n  proj2_incident p l\n\ngoal (1 subgoal):\n 1. proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)", "by simp"], ["proof (state)\nthis:\n  proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)\n\ngoal (1 subgoal):\n 1. apply_cltn2 p C = q", "from \\<open>proj2_incident p m\\<close>"], ["proof (chain)\npicking this:\n  proj2_incident p m", "have \"proj2_incident (apply_cltn2 p C) (apply_cltn2_line m C)\""], ["proof (prove)\nusing this:\n  proj2_incident p m\n\ngoal (1 subgoal):\n 1. proj2_incident (apply_cltn2 p C) (apply_cltn2_line m C)", "by simp"], ["proof (state)\nthis:\n  proj2_incident (apply_cltn2 p C) (apply_cltn2_line m C)\n\ngoal (1 subgoal):\n 1. apply_cltn2 p C = q", "from \\<open>l \\<noteq> m\\<close> and apply_cltn2_line_injective [of l C m]"], ["proof (chain)\npicking this:\n  l \\<noteq> m\n  apply_cltn2_line l C = apply_cltn2_line m C \\<Longrightarrow> l = m", "have \"apply_cltn2_line l C \\<noteq> apply_cltn2_line m C\""], ["proof (prove)\nusing this:\n  l \\<noteq> m\n  apply_cltn2_line l C = apply_cltn2_line m C \\<Longrightarrow> l = m\n\ngoal (1 subgoal):\n 1. apply_cltn2_line l C \\<noteq> apply_cltn2_line m C", "by auto"], ["proof (state)\nthis:\n  apply_cltn2_line l C \\<noteq> apply_cltn2_line m C\n\ngoal (1 subgoal):\n 1. apply_cltn2 p C = q", "with \\<open>proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)\\<close>\n    and \\<open>proj2_incident (apply_cltn2 p C) (apply_cltn2_line m C)\\<close>\n    and \\<open>proj2_incident q (apply_cltn2_line l C)\\<close>\n    and \\<open>proj2_incident q (apply_cltn2_line m C)\\<close>\n    and proj2_incident_unique"], ["proof (chain)\npicking this:\n  proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)\n  proj2_incident (apply_cltn2 p C) (apply_cltn2_line m C)\n  proj2_incident q (apply_cltn2_line l C)\n  proj2_incident q (apply_cltn2_line m C)\n  \\<lbrakk>proj2_incident ?p ?l; proj2_incident ?q ?l; proj2_incident ?p ?m;\n   proj2_incident ?q ?m\\<rbrakk>\n  \\<Longrightarrow> ?p = ?q \\<or> ?l = ?m\n  apply_cltn2_line l C \\<noteq> apply_cltn2_line m C", "show \"apply_cltn2 p C = q\""], ["proof (prove)\nusing this:\n  proj2_incident (apply_cltn2 p C) (apply_cltn2_line l C)\n  proj2_incident (apply_cltn2 p C) (apply_cltn2_line m C)\n  proj2_incident q (apply_cltn2_line l C)\n  proj2_incident q (apply_cltn2_line m C)\n  \\<lbrakk>proj2_incident ?p ?l; proj2_incident ?q ?l; proj2_incident ?p ?m;\n   proj2_incident ?q ?m\\<rbrakk>\n  \\<Longrightarrow> ?p = ?q \\<or> ?l = ?m\n  apply_cltn2_line l C \\<noteq> apply_cltn2_line m C\n\ngoal (1 subgoal):\n 1. apply_cltn2 p C = q", "by fast"], ["proof (state)\nthis:\n  apply_cltn2 p C = q\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Parts of some Statements from \\cite{borsuk}\\<close>"], ["", "text \\<open>All theorems with names beginning with \\emph{statement} are based\n  on corresponding theorems in \\cite{borsuk}.\\<close>"], ["", "lemma statement52_existence:\n  fixes a :: \"proj2^3\" and a3 :: \"proj2\"\n  assumes \"proj2_no_3_Col (insert a3 (range (($) a)))\"\n  shows \"\\<exists> A. apply_cltn2 (proj2_abs (vector [1,1,1])) A = a3 \\<and>\n  (\\<forall> j. apply_cltn2 (proj2_abs (axis j 1)) A = a$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "let ?v = \"proj2_rep a3\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "let ?B = \"proj2_rep ` range (($) a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "from \\<open>proj2_no_3_Col (insert a3 (range (($) a)))\\<close>"], ["proof (chain)\npicking this:\n  proj2_no_3_Col (insert a3 (range (($) a)))", "have \"card (insert a3 (range (($) a))) = 4\""], ["proof (prove)\nusing this:\n  proj2_no_3_Col (insert a3 (range (($) a)))\n\ngoal (1 subgoal):\n 1. card (insert a3 (range (($) a))) = 4", "unfolding proj2_no_3_Col_def"], ["proof (prove)\nusing this:\n  card (insert a3 (range (($) a))) = 4 \\<and>\n  (\\<forall>p\\<in>insert a3 (range (($) a)).\n      \\<not> proj2_set_Col (insert a3 (range (($) a)) - {p}))\n\ngoal (1 subgoal):\n 1. card (insert a3 (range (($) a))) = 4", ".."], ["proof (state)\nthis:\n  card (insert a3 (range (($) a))) = 4\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "from card_image_le [of UNIV \"($) a\"]"], ["proof (chain)\npicking this:\n  finite UNIV \\<Longrightarrow> card (range (($) a)) \\<le> CARD(3)", "have \"card (range (($) a)) \\<le> 3\""], ["proof (prove)\nusing this:\n  finite UNIV \\<Longrightarrow> card (range (($) a)) \\<le> CARD(3)\n\ngoal (1 subgoal):\n 1. card (range (($) a)) \\<le> 3", "by simp"], ["proof (state)\nthis:\n  card (range (($) a)) \\<le> 3\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "with card_insert_if [of \"range (($) a)\" a3]\n    and \\<open>card (insert a3 (range (($) a))) = 4\\<close>"], ["proof (chain)\npicking this:\n  finite (range (($) a)) \\<Longrightarrow>\n  card (insert a3 (range (($) a))) =\n  (if a3 \\<in> range (($) a) then card (range (($) a))\n   else Suc (card (range (($) a))))\n  card (insert a3 (range (($) a))) = 4\n  card (range (($) a)) \\<le> 3", "have \"a3 \\<notin> range (($) a)\""], ["proof (prove)\nusing this:\n  finite (range (($) a)) \\<Longrightarrow>\n  card (insert a3 (range (($) a))) =\n  (if a3 \\<in> range (($) a) then card (range (($) a))\n   else Suc (card (range (($) a))))\n  card (insert a3 (range (($) a))) = 4\n  card (range (($) a)) \\<le> 3\n\ngoal (1 subgoal):\n 1. a3 \\<notin> range (($) a)", "by auto"], ["proof (state)\nthis:\n  a3 \\<notin> range (($) a)\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "hence \"(insert a3 (range (($) a))) - {a3} = range (($) a)\""], ["proof (prove)\nusing this:\n  a3 \\<notin> range (($) a)\n\ngoal (1 subgoal):\n 1. insert a3 (range (($) a)) - {a3} = range (($) a)", "by simp"], ["proof (state)\nthis:\n  insert a3 (range (($) a)) - {a3} = range (($) a)\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "with \\<open>proj2_no_3_Col (insert a3 (range (($) a)))\\<close>\n    and proj2_no_3_Col_span [of \"insert a3 (range (($) a))\" a3]"], ["proof (chain)\npicking this:\n  proj2_no_3_Col (insert a3 (range (($) a)))\n  \\<lbrakk>proj2_no_3_Col (insert a3 (range (($) a)));\n   a3 \\<in> insert a3 (range (($) a))\\<rbrakk>\n  \\<Longrightarrow> span (proj2_rep ` (insert a3 (range (($) a)) - {a3})) =\n                    UNIV\n  insert a3 (range (($) a)) - {a3} = range (($) a)", "have \"span ?B = UNIV\""], ["proof (prove)\nusing this:\n  proj2_no_3_Col (insert a3 (range (($) a)))\n  \\<lbrakk>proj2_no_3_Col (insert a3 (range (($) a)));\n   a3 \\<in> insert a3 (range (($) a))\\<rbrakk>\n  \\<Longrightarrow> span (proj2_rep ` (insert a3 (range (($) a)) - {a3})) =\n                    UNIV\n  insert a3 (range (($) a)) - {a3} = range (($) a)\n\ngoal (1 subgoal):\n 1. span (proj2_rep ` range (($) a)) = UNIV", "by simp"], ["proof (state)\nthis:\n  span (proj2_rep ` range (($) a)) = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "from card_suc_ge_insert [of a3 \"range (($) a)\"]\n    and \\<open>card (insert a3 (range (($) a))) = 4\\<close>\n    and \\<open>card (range (($) a)) \\<le> 3\\<close>"], ["proof (chain)\npicking this:\n  card (insert a3 (range (($) a))) \\<le> card (range (($) a)) + 1\n  card (insert a3 (range (($) a))) = 4\n  card (range (($) a)) \\<le> 3", "have \"card (range (($) a)) = 3\""], ["proof (prove)\nusing this:\n  card (insert a3 (range (($) a))) \\<le> card (range (($) a)) + 1\n  card (insert a3 (range (($) a))) = 4\n  card (range (($) a)) \\<le> 3\n\ngoal (1 subgoal):\n 1. card (range (($) a)) = 3", "by simp"], ["proof (state)\nthis:\n  card (range (($) a)) = 3\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "with card_image [of proj2_rep \"range (($) a)\"]\n    and proj2_rep_inj\n    and subset_inj_on"], ["proof (chain)\npicking this:\n  inj_on proj2_rep (range (($) a)) \\<Longrightarrow>\n  card (proj2_rep ` range (($) a)) = card (range (($) a))\n  inj proj2_rep\n  \\<lbrakk>inj_on ?f ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?A\n  card (range (($) a)) = 3", "have \"card ?B = 3\""], ["proof (prove)\nusing this:\n  inj_on proj2_rep (range (($) a)) \\<Longrightarrow>\n  card (proj2_rep ` range (($) a)) = card (range (($) a))\n  inj proj2_rep\n  \\<lbrakk>inj_on ?f ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?A\n  card (range (($) a)) = 3\n\ngoal (1 subgoal):\n 1. card (proj2_rep ` range (($) a)) = 3", "by auto"], ["proof (state)\nthis:\n  card (proj2_rep ` range (($) a)) = 3\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "hence \"finite ?B\""], ["proof (prove)\nusing this:\n  card (proj2_rep ` range (($) a)) = 3\n\ngoal (1 subgoal):\n 1. finite (proj2_rep ` range (($) a))", "by simp"], ["proof (state)\nthis:\n  finite (proj2_rep ` range (($) a))\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "with \\<open>span ?B = UNIV\\<close> and span_finite [of ?B]"], ["proof (chain)\npicking this:\n  span (proj2_rep ` range (($) a)) = UNIV\n  finite (proj2_rep ` range (($) a)) \\<Longrightarrow>\n  span (proj2_rep ` range (($) a)) =\n  range (\\<lambda>u. \\<Sum>v\\<in>proj2_rep ` range (($) a). u v *\\<^sub>R v)\n  finite (proj2_rep ` range (($) a))", "obtain c where \"(\\<Sum> w \\<in> ?B. (c w) *\\<^sub>R w) = ?v\""], ["proof (prove)\nusing this:\n  span (proj2_rep ` range (($) a)) = UNIV\n  finite (proj2_rep ` range (($) a)) \\<Longrightarrow>\n  span (proj2_rep ` range (($) a)) =\n  range (\\<lambda>u. \\<Sum>v\\<in>proj2_rep ` range (($) a). u v *\\<^sub>R v)\n  finite (proj2_rep ` range (($) a))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) =\n        proj2_rep a3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: scalar_equiv) (metis (no_types, lifting) UNIV_I rangeE)"], ["proof (state)\nthis:\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) = proj2_rep a3\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "let ?C = \"\\<chi> i. c (proj2_rep (a$i)) *\\<^sub>R (proj2_rep (a$i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "let ?A = \"cltn2_abs ?C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "from proj2_rep_inj and \\<open>a3 \\<notin> range (($) a)\\<close>"], ["proof (chain)\npicking this:\n  inj proj2_rep\n  a3 \\<notin> range (($) a)", "have \"?v \\<notin> ?B\""], ["proof (prove)\nusing this:\n  inj proj2_rep\n  a3 \\<notin> range (($) a)\n\ngoal (1 subgoal):\n 1. proj2_rep a3 \\<notin> proj2_rep ` range (($) a)", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV. proj2_rep x = proj2_rep y \\<longrightarrow> x = y\n  a3 \\<notin> range (($) a)\n\ngoal (1 subgoal):\n 1. proj2_rep a3 \\<notin> proj2_rep ` range (($) a)", "by auto"], ["proof (state)\nthis:\n  proj2_rep a3 \\<notin> proj2_rep ` range (($) a)\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "have \"\\<forall> i. c (proj2_rep (a$i)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. c (proj2_rep (a $ i)) \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "let ?Bi = \"proj2_rep ` (range (($) a) - {a$i})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "have \"a$i \\<in> insert a3 (range (($) a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a $ i \\<in> insert a3 (range (($) a))", "by simp"], ["proof (state)\nthis:\n  a $ i \\<in> insert a3 (range (($) a))\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "have \"proj2_rep (a$i) \\<in> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep (a $ i) \\<in> proj2_rep ` range (($) a)", "by auto"], ["proof (state)\nthis:\n  proj2_rep (a $ i) \\<in> proj2_rep ` range (($) a)\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "from image_set_diff [of proj2_rep] and proj2_rep_inj"], ["proof (chain)\npicking this:\n  inj proj2_rep \\<Longrightarrow>\n  proj2_rep ` (?A - ?B) = proj2_rep ` ?A - proj2_rep ` ?B\n  inj proj2_rep", "have \"?Bi = ?B - {proj2_rep (a$i)}\""], ["proof (prove)\nusing this:\n  inj proj2_rep \\<Longrightarrow>\n  proj2_rep ` (?A - ?B) = proj2_rep ` ?A - proj2_rep ` ?B\n  inj proj2_rep\n\ngoal (1 subgoal):\n 1. proj2_rep ` (range (($) a) - {a $ i}) =\n    proj2_rep ` range (($) a) - {proj2_rep (a $ i)}", "by simp"], ["proof (state)\nthis:\n  proj2_rep ` (range (($) a) - {a $ i}) =\n  proj2_rep ` range (($) a) - {proj2_rep (a $ i)}\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "with sum_diff1 [of ?B \"\\<lambda> w. (c w) *\\<^sub>R w\"]\n      and \\<open>finite ?B\\<close>\n      and \\<open>proj2_rep (a$i) \\<in> ?B\\<close>"], ["proof (chain)\npicking this:\n  finite (proj2_rep ` range (($) a)) \\<Longrightarrow>\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a) - {?a}. c w *\\<^sub>R w) =\n  (if ?a \\<in> proj2_rep ` range (($) a)\n   then (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) -\n        c ?a *\\<^sub>R ?a\n   else \\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w)\n  finite (proj2_rep ` range (($) a))\n  proj2_rep (a $ i) \\<in> proj2_rep ` range (($) a)\n  proj2_rep ` (range (($) a) - {a $ i}) =\n  proj2_rep ` range (($) a) - {proj2_rep (a $ i)}", "have \"(\\<Sum> w \\<in> ?Bi. (c w) *\\<^sub>R w) =\n      (\\<Sum> w \\<in> ?B. (c w) *\\<^sub>R w) - c (proj2_rep (a$i)) *\\<^sub>R proj2_rep (a$i)\""], ["proof (prove)\nusing this:\n  finite (proj2_rep ` range (($) a)) \\<Longrightarrow>\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a) - {?a}. c w *\\<^sub>R w) =\n  (if ?a \\<in> proj2_rep ` range (($) a)\n   then (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) -\n        c ?a *\\<^sub>R ?a\n   else \\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w)\n  finite (proj2_rep ` range (($) a))\n  proj2_rep (a $ i) \\<in> proj2_rep ` range (($) a)\n  proj2_rep ` (range (($) a) - {a $ i}) =\n  proj2_rep ` range (($) a) - {proj2_rep (a $ i)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>w\\<in>proj2_rep ` (range (($) a) - {a $ i}). c w *\\<^sub>R w) =\n    (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) -\n    c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>w\\<in>proj2_rep ` (range (($) a) - {a $ i}). c w *\\<^sub>R w) =\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) -\n  c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "from \\<open>a3 \\<notin> range (($) a)\\<close>"], ["proof (chain)\npicking this:\n  a3 \\<notin> range (($) a)", "have \"a3 \\<noteq> a$i\""], ["proof (prove)\nusing this:\n  a3 \\<notin> range (($) a)\n\ngoal (1 subgoal):\n 1. a3 \\<noteq> a $ i", "by auto"], ["proof (state)\nthis:\n  a3 \\<noteq> a $ i\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "hence \"insert a3 (range (($) a)) - {a$i} =\n      insert a3 (range (($) a) - {a$i})\""], ["proof (prove)\nusing this:\n  a3 \\<noteq> a $ i\n\ngoal (1 subgoal):\n 1. insert a3 (range (($) a)) - {a $ i} =\n    insert a3 (range (($) a) - {a $ i})", "by auto"], ["proof (state)\nthis:\n  insert a3 (range (($) a)) - {a $ i} = insert a3 (range (($) a) - {a $ i})\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "hence \"proj2_rep ` (insert a3 (range (($) a)) - {a$i}) = insert ?v ?Bi\""], ["proof (prove)\nusing this:\n  insert a3 (range (($) a)) - {a $ i} = insert a3 (range (($) a) - {a $ i})\n\ngoal (1 subgoal):\n 1. proj2_rep ` (insert a3 (range (($) a)) - {a $ i}) =\n    insert (proj2_rep a3) (proj2_rep ` (range (($) a) - {a $ i}))", "by simp"], ["proof (state)\nthis:\n  proj2_rep ` (insert a3 (range (($) a)) - {a $ i}) =\n  insert (proj2_rep a3) (proj2_rep ` (range (($) a) - {a $ i}))\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  proj2_rep ` (insert a3 (range (($) a)) - {a $ i}) =\n  insert (proj2_rep a3) (proj2_rep ` (range (($) a) - {a $ i}))\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "from \\<open>proj2_no_3_Col (insert a3 (range (($) a)))\\<close>\n      and \\<open>a$i \\<in> insert a3 (range (($) a))\\<close>"], ["proof (chain)\npicking this:\n  proj2_no_3_Col (insert a3 (range (($) a)))\n  a $ i \\<in> insert a3 (range (($) a))", "have \"span (proj2_rep ` (insert a3 (range (($) a)) - {a$i})) = UNIV\""], ["proof (prove)\nusing this:\n  proj2_no_3_Col (insert a3 (range (($) a)))\n  a $ i \\<in> insert a3 (range (($) a))\n\ngoal (1 subgoal):\n 1. span (proj2_rep ` (insert a3 (range (($) a)) - {a $ i})) = UNIV", "by (rule proj2_no_3_Col_span)"], ["proof (state)\nthis:\n  span (proj2_rep ` (insert a3 (range (($) a)) - {a $ i})) = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  proj2_rep ` (insert a3 (range (($) a)) - {a $ i}) =\n  insert (proj2_rep a3) (proj2_rep ` (range (($) a) - {a $ i}))\n  span (proj2_rep ` (insert a3 (range (($) a)) - {a $ i})) = UNIV", "have \"span (insert ?v ?Bi) = UNIV\""], ["proof (prove)\nusing this:\n  proj2_rep ` (insert a3 (range (($) a)) - {a $ i}) =\n  insert (proj2_rep a3) (proj2_rep ` (range (($) a) - {a $ i}))\n  span (proj2_rep ` (insert a3 (range (($) a)) - {a $ i})) = UNIV\n\ngoal (1 subgoal):\n 1. span (insert (proj2_rep a3) (proj2_rep ` (range (($) a) - {a $ i}))) =\n    UNIV", "by simp"], ["proof (state)\nthis:\n  span (insert (proj2_rep a3) (proj2_rep ` (range (($) a) - {a $ i}))) =\n  UNIV\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "from \\<open>?Bi = ?B - {proj2_rep (a$i)}\\<close>\n      and \\<open>proj2_rep (a$i) \\<in> ?B\\<close>\n      and \\<open>card ?B = 3\\<close>"], ["proof (chain)\npicking this:\n  proj2_rep ` (range (($) a) - {a $ i}) =\n  proj2_rep ` range (($) a) - {proj2_rep (a $ i)}\n  proj2_rep (a $ i) \\<in> proj2_rep ` range (($) a)\n  card (proj2_rep ` range (($) a)) = 3", "have \"card ?Bi = 2\""], ["proof (prove)\nusing this:\n  proj2_rep ` (range (($) a) - {a $ i}) =\n  proj2_rep ` range (($) a) - {proj2_rep (a $ i)}\n  proj2_rep (a $ i) \\<in> proj2_rep ` range (($) a)\n  card (proj2_rep ` range (($) a)) = 3\n\ngoal (1 subgoal):\n 1. card (proj2_rep ` (range (($) a) - {a $ i})) = 2", "by (simp add: card_gt_0_diff_singleton)"], ["proof (state)\nthis:\n  card (proj2_rep ` (range (($) a) - {a $ i})) = 2\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "hence \"finite ?Bi\""], ["proof (prove)\nusing this:\n  card (proj2_rep ` (range (($) a) - {a $ i})) = 2\n\ngoal (1 subgoal):\n 1. finite (proj2_rep ` (range (($) a) - {a $ i}))", "by simp"], ["proof (state)\nthis:\n  finite (proj2_rep ` (range (($) a) - {a $ i}))\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "with \\<open>card ?Bi = 2\\<close> and dim_le_card' [of ?Bi]"], ["proof (chain)\npicking this:\n  card (proj2_rep ` (range (($) a) - {a $ i})) = 2\n  finite (proj2_rep ` (range (($) a) - {a $ i})) \\<Longrightarrow>\n  dim (proj2_rep ` (range (($) a) - {a $ i}))\n  \\<le> card (proj2_rep ` (range (($) a) - {a $ i}))\n  finite (proj2_rep ` (range (($) a) - {a $ i}))", "have \"dim ?Bi \\<le> 2\""], ["proof (prove)\nusing this:\n  card (proj2_rep ` (range (($) a) - {a $ i})) = 2\n  finite (proj2_rep ` (range (($) a) - {a $ i})) \\<Longrightarrow>\n  dim (proj2_rep ` (range (($) a) - {a $ i}))\n  \\<le> card (proj2_rep ` (range (($) a) - {a $ i}))\n  finite (proj2_rep ` (range (($) a) - {a $ i}))\n\ngoal (1 subgoal):\n 1. dim (proj2_rep ` (range (($) a) - {a $ i})) \\<le> 2", "by simp"], ["proof (state)\nthis:\n  dim (proj2_rep ` (range (($) a) - {a $ i})) \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "hence \"dim (span ?Bi) \\<le> 2\""], ["proof (prove)\nusing this:\n  dim (proj2_rep ` (range (($) a) - {a $ i})) \\<le> 2\n\ngoal (1 subgoal):\n 1. dim (span (proj2_rep ` (range (($) a) - {a $ i}))) \\<le> 2", "by (subst dim_span)"], ["proof (state)\nthis:\n  dim (span (proj2_rep ` (range (($) a) - {a $ i}))) \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  dim (span (proj2_rep ` (range (($) a) - {a $ i}))) \\<le> 2", "have \"span ?Bi \\<noteq> UNIV\""], ["proof (prove)\nusing this:\n  dim (span (proj2_rep ` (range (($) a) - {a $ i}))) \\<le> 2\n\ngoal (1 subgoal):\n 1. span (proj2_rep ` (range (($) a) - {a $ i})) \\<noteq> UNIV", "by clarify (auto simp: dim_UNIV)"], ["proof (state)\nthis:\n  span (proj2_rep ` (range (($) a) - {a $ i})) \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "with \\<open>span (insert ?v ?Bi) = UNIV\\<close> and span_redundant"], ["proof (chain)\npicking this:\n  span (insert (proj2_rep a3) (proj2_rep ` (range (($) a) - {a $ i}))) =\n  UNIV\n  ?x \\<in> span ?S \\<Longrightarrow> span (insert ?x ?S) = span ?S\n  span (proj2_rep ` (range (($) a) - {a $ i})) \\<noteq> UNIV", "have \"?v \\<notin> span ?Bi\""], ["proof (prove)\nusing this:\n  span (insert (proj2_rep a3) (proj2_rep ` (range (($) a) - {a $ i}))) =\n  UNIV\n  ?x \\<in> span ?S \\<Longrightarrow> span (insert ?x ?S) = span ?S\n  span (proj2_rep ` (range (($) a) - {a $ i})) \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. proj2_rep a3 \\<notin> span (proj2_rep ` (range (($) a) - {a $ i}))", "by auto"], ["proof (state)\nthis:\n  proj2_rep a3 \\<notin> span (proj2_rep ` (range (($) a) - {a $ i}))\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "{"], ["proof (state)\nthis:\n  proj2_rep a3 \\<notin> span (proj2_rep ` (range (($) a) - {a $ i}))\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "assume \"c (proj2_rep (a$i)) = 0\""], ["proof (state)\nthis:\n  c (proj2_rep (a $ i)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "with \\<open>(\\<Sum> w \\<in> ?Bi. (c w) *\\<^sub>R w) =\n        (\\<Sum> w \\<in> ?B. (c w) *\\<^sub>R w) - c (proj2_rep (a$i)) *\\<^sub>R proj2_rep (a$i)\\<close>\n        and \\<open>(\\<Sum> w \\<in> ?B. (c w) *\\<^sub>R w) = ?v\\<close>"], ["proof (chain)\npicking this:\n  (\\<Sum>w\\<in>proj2_rep ` (range (($) a) - {a $ i}). c w *\\<^sub>R w) =\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) -\n  c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) = proj2_rep a3\n  c (proj2_rep (a $ i)) = 0", "have \"?v = (\\<Sum> w \\<in> ?Bi. (c w) *\\<^sub>R w)\""], ["proof (prove)\nusing this:\n  (\\<Sum>w\\<in>proj2_rep ` (range (($) a) - {a $ i}). c w *\\<^sub>R w) =\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) -\n  c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) = proj2_rep a3\n  c (proj2_rep (a $ i)) = 0\n\ngoal (1 subgoal):\n 1. proj2_rep a3 =\n    (\\<Sum>w\\<in>proj2_rep ` (range (($) a) - {a $ i}). c w *\\<^sub>R w)", "by simp"], ["proof (state)\nthis:\n  proj2_rep a3 =\n  (\\<Sum>w\\<in>proj2_rep ` (range (($) a) - {a $ i}). c w *\\<^sub>R w)\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "with span_finite [of ?Bi] and \\<open>finite ?Bi\\<close>"], ["proof (chain)\npicking this:\n  finite (proj2_rep ` (range (($) a) - {a $ i})) \\<Longrightarrow>\n  span (proj2_rep ` (range (($) a) - {a $ i})) =\n  range\n   (\\<lambda>u.\n       \\<Sum>v\\<in>proj2_rep ` (range (($) a) - {a $ i}). u v *\\<^sub>R v)\n  finite (proj2_rep ` (range (($) a) - {a $ i}))\n  proj2_rep a3 =\n  (\\<Sum>w\\<in>proj2_rep ` (range (($) a) - {a $ i}). c w *\\<^sub>R w)", "have \"?v \\<in> span ?Bi\""], ["proof (prove)\nusing this:\n  finite (proj2_rep ` (range (($) a) - {a $ i})) \\<Longrightarrow>\n  span (proj2_rep ` (range (($) a) - {a $ i})) =\n  range\n   (\\<lambda>u.\n       \\<Sum>v\\<in>proj2_rep ` (range (($) a) - {a $ i}). u v *\\<^sub>R v)\n  finite (proj2_rep ` (range (($) a) - {a $ i}))\n  proj2_rep a3 =\n  (\\<Sum>w\\<in>proj2_rep ` (range (($) a) - {a $ i}). c w *\\<^sub>R w)\n\ngoal (1 subgoal):\n 1. proj2_rep a3 \\<in> span (proj2_rep ` (range (($) a) - {a $ i}))", "by (simp add: scalar_equiv)"], ["proof (state)\nthis:\n  proj2_rep a3 \\<in> span (proj2_rep ` (range (($) a) - {a $ i}))\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "with \\<open>?v \\<notin> span ?Bi\\<close>"], ["proof (chain)\npicking this:\n  proj2_rep a3 \\<notin> span (proj2_rep ` (range (($) a) - {a $ i}))\n  proj2_rep a3 \\<in> span (proj2_rep ` (range (($) a) - {a $ i}))", "have False"], ["proof (prove)\nusing this:\n  proj2_rep a3 \\<notin> span (proj2_rep ` (range (($) a) - {a $ i}))\n  proj2_rep a3 \\<in> span (proj2_rep ` (range (($) a) - {a $ i}))\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "}"], ["proof (state)\nthis:\n  c (proj2_rep (a $ i)) = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>i. c (proj2_rep (a $ i)) \\<noteq> 0", "thus \"c (proj2_rep (a$i)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  c (proj2_rep (a $ i)) = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. c (proj2_rep (a $ i)) \\<noteq> 0", ".."], ["proof (state)\nthis:\n  c (proj2_rep (a $ i)) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. c (proj2_rep (a $ i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "hence \"\\<forall> w\\<in>?B. c w \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>i. c (proj2_rep (a $ i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>proj2_rep ` range (($) a). c w \\<noteq> 0", "unfolding image_def"], ["proof (prove)\nusing this:\n  \\<forall>i. c (proj2_rep (a $ i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>{y. \\<exists>x\\<in>{y. \\<exists>x\\<in>UNIV. y = a $ x}.\n                          y = proj2_rep x}.\n       c w \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>w\\<in>proj2_rep ` range (($) a). c w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "have \"rows ?C = (\\<lambda> w. (c w) *\\<^sub>R w) ` ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n    (\\<lambda>w. c w *\\<^sub>R w) ` proj2_rep ` range (($) a)", "unfolding rows_def\n      and row_def\n      and image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {vec_lambda\n      (($) ((\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) $\n            i)) |\n     i. i \\<in> UNIV} =\n    {y. \\<exists>x\\<in>{y. \\<exists>x\\<in>{y.\n     \\<exists>x\\<in>UNIV. y = a $ x}.\n                              y = proj2_rep x}.\n           y = c x *\\<^sub>R x}", "by (auto simp: vec_lambda_eta)"], ["proof (state)\nthis:\n  rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<lambda>w. c w *\\<^sub>R w) ` proj2_rep ` range (($) a)\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "have \"\\<forall> x. x \\<in> span (rows ?C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> span\n                (rows\n                  (\\<chi>i.\n                      c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span\n                (rows\n                  (\\<chi>i.\n                      c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "fix x :: \"real^3\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span\n                (rows\n                  (\\<chi>i.\n                      c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "from \\<open>finite ?B\\<close> and span_finite [of ?B] and \\<open>span ?B = UNIV\\<close>"], ["proof (chain)\npicking this:\n  finite (proj2_rep ` range (($) a))\n  finite (proj2_rep ` range (($) a)) \\<Longrightarrow>\n  span (proj2_rep ` range (($) a)) =\n  range (\\<lambda>u. \\<Sum>v\\<in>proj2_rep ` range (($) a). u v *\\<^sub>R v)\n  span (proj2_rep ` range (($) a)) = UNIV", "obtain ub where \"(\\<Sum> w\\<in>?B. (ub w) *\\<^sub>R w) = x\""], ["proof (prove)\nusing this:\n  finite (proj2_rep ` range (($) a))\n  finite (proj2_rep ` range (($) a)) \\<Longrightarrow>\n  span (proj2_rep ` range (($) a)) =\n  range (\\<lambda>u. \\<Sum>v\\<in>proj2_rep ` range (($) a). u v *\\<^sub>R v)\n  span (proj2_rep ` range (($) a)) = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        (\\<Sum>w\\<in>proj2_rep ` range (($) a). ub w *\\<^sub>R w) =\n        x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: scalar_equiv) (metis (no_types, lifting) UNIV_I rangeE)"], ["proof (state)\nthis:\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). ub w *\\<^sub>R w) = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span\n                (rows\n                  (\\<chi>i.\n                      c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "have \"\\<forall> w\\<in>?B. (ub w) *\\<^sub>R w \\<in> span (rows ?C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>proj2_rep ` range (($) a).\n       ub w *\\<^sub>R w\n       \\<in> span\n              (rows\n                (\\<chi>i.\n                    c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> proj2_rep ` range (($) a) \\<Longrightarrow>\n       ub w *\\<^sub>R w\n       \\<in> span\n              (rows\n                (\\<chi>i.\n                    c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> proj2_rep ` range (($) a) \\<Longrightarrow>\n       ub w *\\<^sub>R w\n       \\<in> span\n              (rows\n                (\\<chi>i.\n                    c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "assume \"w \\<in> ?B\""], ["proof (state)\nthis:\n  w \\<in> proj2_rep ` range (($) a)\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> proj2_rep ` range (($) a) \\<Longrightarrow>\n       ub w *\\<^sub>R w\n       \\<in> span\n              (rows\n                (\\<chi>i.\n                    c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "with span_superset [of \"rows ?C\"] and \\<open>rows ?C = image (\\<lambda> w. (c w) *\\<^sub>R w) ?B\\<close>"], ["proof (chain)\npicking this:\n  rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))\n  \\<subseteq> span\n               (rows\n                 (\\<chi>i.\n                     c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n  rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<lambda>w. c w *\\<^sub>R w) ` proj2_rep ` range (($) a)\n  w \\<in> proj2_rep ` range (($) a)", "have \"(c w) *\\<^sub>R w \\<in> span (rows ?C)\""], ["proof (prove)\nusing this:\n  rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))\n  \\<subseteq> span\n               (rows\n                 (\\<chi>i.\n                     c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n  rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<lambda>w. c w *\\<^sub>R w) ` proj2_rep ` range (($) a)\n  w \\<in> proj2_rep ` range (($) a)\n\ngoal (1 subgoal):\n 1. c w *\\<^sub>R w\n    \\<in> span\n           (rows\n             (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "by auto"], ["proof (state)\nthis:\n  c w *\\<^sub>R w\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> proj2_rep ` range (($) a) \\<Longrightarrow>\n       ub w *\\<^sub>R w\n       \\<in> span\n              (rows\n                (\\<chi>i.\n                    c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "with span_mul [of \"(c w) *\\<^sub>R w\" \"rows ?C\" \"(ub w)/(c w)\"]"], ["proof (chain)\npicking this:\n  c w *\\<^sub>R w\n  \\<in> span\n         (rows\n           (\\<chi>i.\n               c (proj2_rep (a $ i)) *\\<^sub>R\n               proj2_rep (a $ i))) \\<Longrightarrow>\n  (ub w / c w) *\\<^sub>R c w *\\<^sub>R w\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n  c w *\\<^sub>R w\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "have \"((ub w)/(c w)) *\\<^sub>R ((c w) *\\<^sub>R w) \\<in> span (rows ?C)\""], ["proof (prove)\nusing this:\n  c w *\\<^sub>R w\n  \\<in> span\n         (rows\n           (\\<chi>i.\n               c (proj2_rep (a $ i)) *\\<^sub>R\n               proj2_rep (a $ i))) \\<Longrightarrow>\n  (ub w / c w) *\\<^sub>R c w *\\<^sub>R w\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n  c w *\\<^sub>R w\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. (ub w / c w) *\\<^sub>R c w *\\<^sub>R w\n    \\<in> span\n           (rows\n             (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "by (simp add: scalar_equiv)"], ["proof (state)\nthis:\n  (ub w / c w) *\\<^sub>R c w *\\<^sub>R w\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> proj2_rep ` range (($) a) \\<Longrightarrow>\n       ub w *\\<^sub>R w\n       \\<in> span\n              (rows\n                (\\<chi>i.\n                    c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "with \\<open>\\<forall> w\\<in>?B. c w \\<noteq> 0\\<close> and \\<open>w \\<in> ?B\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>proj2_rep ` range (($) a). c w \\<noteq> 0\n  w \\<in> proj2_rep ` range (($) a)\n  (ub w / c w) *\\<^sub>R c w *\\<^sub>R w\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "show \"(ub w) *\\<^sub>R w \\<in> span (rows ?C)\""], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>proj2_rep ` range (($) a). c w \\<noteq> 0\n  w \\<in> proj2_rep ` range (($) a)\n  (ub w / c w) *\\<^sub>R c w *\\<^sub>R w\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. ub w *\\<^sub>R w\n    \\<in> span\n           (rows\n             (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "by auto"], ["proof (state)\nthis:\n  ub w *\\<^sub>R w\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>w\\<in>proj2_rep ` range (($) a).\n     ub w *\\<^sub>R w\n     \\<in> span\n            (rows\n              (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span\n                (rows\n                  (\\<chi>i.\n                      c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "with span_sum [of ?B \"\\<lambda> w. (ub w) *\\<^sub>R w\"] and \\<open>finite ?B\\<close>"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> proj2_rep ` range (($) a) \\<Longrightarrow>\n      ub x *\\<^sub>R x \\<in> span ?S) \\<Longrightarrow>\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). ub w *\\<^sub>R w) \\<in> span ?S\n  finite (proj2_rep ` range (($) a))\n  \\<forall>w\\<in>proj2_rep ` range (($) a).\n     ub w *\\<^sub>R w\n     \\<in> span\n            (rows\n              (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "have \"(\\<Sum> w\\<in>?B. (ub w) *\\<^sub>R w) \\<in> span (rows ?C)\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> proj2_rep ` range (($) a) \\<Longrightarrow>\n      ub x *\\<^sub>R x \\<in> span ?S) \\<Longrightarrow>\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). ub w *\\<^sub>R w) \\<in> span ?S\n  finite (proj2_rep ` range (($) a))\n  \\<forall>w\\<in>proj2_rep ` range (($) a).\n     ub w *\\<^sub>R w\n     \\<in> span\n            (rows\n              (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>w\\<in>proj2_rep ` range (($) a). ub w *\\<^sub>R w)\n    \\<in> span\n           (rows\n             (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). ub w *\\<^sub>R w)\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span\n                (rows\n                  (\\<chi>i.\n                      c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "with \\<open>(\\<Sum> w\\<in>?B. (ub w) *\\<^sub>R w) = x\\<close>"], ["proof (chain)\npicking this:\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). ub w *\\<^sub>R w) = x\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). ub w *\\<^sub>R w)\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "show \"x \\<in> span (rows ?C)\""], ["proof (prove)\nusing this:\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). ub w *\\<^sub>R w) = x\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). ub w *\\<^sub>R w)\n  \\<in> span\n         (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. x \\<in> span\n             (rows\n               (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "by simp"], ["proof (state)\nthis:\n  x \\<in> span\n           (rows\n             (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in> span\n              (rows\n                (\\<chi>i.\n                    c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "hence \"span (rows ?C) = UNIV\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> span\n              (rows\n                (\\<chi>i.\n                    c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. span\n     (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n    UNIV", "by auto"], ["proof (state)\nthis:\n  span (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "with matrix_left_invertible_span_rows [of ?C]"], ["proof (chain)\npicking this:\n  (\\<exists>B.\n      B ** (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n      mat 1) =\n  (span\n    (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n   UNIV)\n  span (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  UNIV", "have \"\\<exists> C'. C' ** ?C = mat 1\""], ["proof (prove)\nusing this:\n  (\\<exists>B.\n      B ** (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n      mat 1) =\n  (span\n    (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n   UNIV)\n  span (rows (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       C' ** (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n       mat 1", ".."], ["proof (state)\nthis:\n  \\<exists>C'.\n     C' ** (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n     mat 1\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "with left_invertible_iff_invertible"], ["proof (chain)\npicking this:\n  (\\<exists>N. N ** ?M = mat 1) = invertible ?M\n  \\<exists>C'.\n     C' ** (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n     mat 1", "have \"invertible ?C\""], ["proof (prove)\nusing this:\n  (\\<exists>N. N ** ?M = mat 1) = invertible ?M\n  \\<exists>C'.\n     C' ** (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n     mat 1\n\ngoal (1 subgoal):\n 1. invertible (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))", ".."], ["proof (state)\nthis:\n  invertible (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "have \"(vector [1,1,1] :: real^3) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector [1, 1, 1] \\<noteq> 0", "unfolding vector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_lambda\n     (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [1, 1, 1]\n       (\\<lambda>n x. 0) 1) \\<noteq>\n    0", "by (simp add: vec_eq_iff forall_3)"], ["proof (state)\nthis:\n  vector [1, 1, 1] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "with apply_cltn2_abs and \\<open>invertible ?C\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2 (proj2_abs ?x) (cltn2_abs ?A) =\n                    proj2_abs (?x v* ?A)\n  invertible (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))\n  vector [1, 1, 1] \\<noteq> 0", "have \"apply_cltn2 (proj2_abs (vector [1,1,1])) ?A =\n    proj2_abs (vector [1,1,1] v* ?C)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2 (proj2_abs ?x) (cltn2_abs ?A) =\n                    proj2_abs (?x v* ?A)\n  invertible (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))\n  vector [1, 1, 1] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n     (cltn2_abs\n       (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n    proj2_abs\n     (vector [1, 1, 1] v*\n      (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  proj2_abs\n   (vector [1, 1, 1] v*\n    (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "from inj_on_iff_eq_card [of UNIV \"($) a\"] and \\<open>card (range (($) a)) = 3\\<close>"], ["proof (chain)\npicking this:\n  finite UNIV \\<Longrightarrow>\n  inj (($) a) = (card (range (($) a)) = CARD(3))\n  card (range (($) a)) = 3", "have \"inj (($) a)\""], ["proof (prove)\nusing this:\n  finite UNIV \\<Longrightarrow>\n  inj (($) a) = (card (range (($) a)) = CARD(3))\n  card (range (($) a)) = 3\n\ngoal (1 subgoal):\n 1. inj (($) a)", "by simp"], ["proof (state)\nthis:\n  inj (($) a)\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "from exhaust_3"], ["proof (chain)\npicking this:\n  ?x = 1 \\<or> ?x = 2 \\<or> ?x = 3", "have \"\\<forall> i::3. (vector [1::real,1,1])$i = 1\""], ["proof (prove)\nusing this:\n  ?x = 1 \\<or> ?x = 2 \\<or> ?x = 3\n\ngoal (1 subgoal):\n 1. \\<forall>i. vector [1, 1, 1] $ i = 1", "unfolding vector_def"], ["proof (prove)\nusing this:\n  ?x = 1 \\<or> ?x = 2 \\<or> ?x = 3\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       vec_lambda\n        (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [1, 1, 1]\n          (\\<lambda>n x. 0) 1) $\n       i =\n       1", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. vector [1, 1, 1] $ i = 1\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "with vector_matrix_row [of \"vector [1,1,1]\" ?C]"], ["proof (chain)\npicking this:\n  vector [1, 1, 1] v*\n  (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<Sum>i\\<in>UNIV.\n     vector [1, 1, 1] $ i *s\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) $ i)\n  \\<forall>i. vector [1, 1, 1] $ i = 1", "have \"(vector [1,1,1]) v* ?C =\n    (\\<Sum> i\\<in>UNIV. (c (proj2_rep (a$i))) *\\<^sub>R (proj2_rep (a$i)))\""], ["proof (prove)\nusing this:\n  vector [1, 1, 1] v*\n  (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<Sum>i\\<in>UNIV.\n     vector [1, 1, 1] $ i *s\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) $ i)\n  \\<forall>i. vector [1, 1, 1] $ i = 1\n\ngoal (1 subgoal):\n 1. vector [1, 1, 1] v*\n    (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n    (\\<Sum>i\\<in>UNIV. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))", "by simp"], ["proof (state)\nthis:\n  vector [1, 1, 1] v*\n  (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<Sum>i\\<in>UNIV. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "also"], ["proof (state)\nthis:\n  vector [1, 1, 1] v*\n  (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<Sum>i\\<in>UNIV. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "from sum.reindex\n  [of \"($) a\" UNIV \"\\<lambda> x. (c (proj2_rep x)) *\\<^sub>R (proj2_rep x)\"]\n    and \\<open>inj (($) a)\\<close>"], ["proof (chain)\npicking this:\n  inj (($) a) \\<Longrightarrow>\n  (\\<Sum>x\\<in>range (($) a). c (proj2_rep x) *\\<^sub>R proj2_rep x) =\n  sum ((\\<lambda>x. c (proj2_rep x) *\\<^sub>R proj2_rep x) \\<circ> ($) a)\n   UNIV\n  inj (($) a)", "have \"\\<dots> = (\\<Sum> x\\<in>(range (($) a)). (c (proj2_rep x)) *\\<^sub>R (proj2_rep x))\""], ["proof (prove)\nusing this:\n  inj (($) a) \\<Longrightarrow>\n  (\\<Sum>x\\<in>range (($) a). c (proj2_rep x) *\\<^sub>R proj2_rep x) =\n  sum ((\\<lambda>x. c (proj2_rep x) *\\<^sub>R proj2_rep x) \\<circ> ($) a)\n   UNIV\n  inj (($) a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n    (\\<Sum>x\\<in>range (($) a). c (proj2_rep x) *\\<^sub>R proj2_rep x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<Sum>x\\<in>range (($) a). c (proj2_rep x) *\\<^sub>R proj2_rep x)\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<Sum>x\\<in>range (($) a). c (proj2_rep x) *\\<^sub>R proj2_rep x)\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "from sum.reindex\n  [of proj2_rep \"range (($) a)\" \"\\<lambda> w. (c w) *\\<^sub>R w\"]\n    and proj2_rep_inj and subset_inj_on [of proj2_rep UNIV \"range (($) a)\"]"], ["proof (chain)\npicking this:\n  inj_on proj2_rep (range (($) a)) \\<Longrightarrow>\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) =\n  sum ((\\<lambda>w. c w *\\<^sub>R w) \\<circ> proj2_rep) (range (($) a))\n  inj proj2_rep\n  \\<lbrakk>inj proj2_rep; range (($) a) \\<subseteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> inj_on proj2_rep (range (($) a))", "have \"\\<dots> = (\\<Sum> w\\<in>?B. (c w) *\\<^sub>R w)\""], ["proof (prove)\nusing this:\n  inj_on proj2_rep (range (($) a)) \\<Longrightarrow>\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) =\n  sum ((\\<lambda>w. c w *\\<^sub>R w) \\<circ> proj2_rep) (range (($) a))\n  inj proj2_rep\n  \\<lbrakk>inj proj2_rep; range (($) a) \\<subseteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> inj_on proj2_rep (range (($) a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>range (($) a). c (proj2_rep x) *\\<^sub>R proj2_rep x) =\n    (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>range (($) a). c (proj2_rep x) *\\<^sub>R proj2_rep x) =\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w)\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>range (($) a). c (proj2_rep x) *\\<^sub>R proj2_rep x) =\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w)\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "from \\<open>(\\<Sum> w \\<in> ?B. (c w) *\\<^sub>R w) = ?v\\<close>"], ["proof (chain)\npicking this:\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) = proj2_rep a3", "have \"\\<dots> = ?v\""], ["proof (prove)\nusing this:\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) = proj2_rep a3\n\ngoal (1 subgoal):\n 1. (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) = proj2_rep a3", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>w\\<in>proj2_rep ` range (($) a). c w *\\<^sub>R w) = proj2_rep a3\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "finally"], ["proof (chain)\npicking this:\n  vector [1, 1, 1] v*\n  (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  proj2_rep a3", "have \"(vector [1,1,1]) v* ?C = ?v\""], ["proof (prove)\nusing this:\n  vector [1, 1, 1] v*\n  (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  proj2_rep a3\n\ngoal (1 subgoal):\n 1. vector [1, 1, 1] v*\n    (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n    proj2_rep a3", "."], ["proof (state)\nthis:\n  vector [1, 1, 1] v*\n  (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  proj2_rep a3\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "with \\<open>apply_cltn2 (proj2_abs (vector [1,1,1])) ?A =\n    proj2_abs (vector [1,1,1] v* ?C)\\<close>"], ["proof (chain)\npicking this:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  proj2_abs\n   (vector [1, 1, 1] v*\n    (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n  vector [1, 1, 1] v*\n  (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  proj2_rep a3", "have \"apply_cltn2 (proj2_abs (vector [1,1,1])) ?A = proj2_abs ?v\""], ["proof (prove)\nusing this:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  proj2_abs\n   (vector [1, 1, 1] v*\n    (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n  vector [1, 1, 1] v*\n  (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  proj2_rep a3\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n     (cltn2_abs\n       (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n    proj2_abs (proj2_rep a3)", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  proj2_abs (proj2_rep a3)\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "with proj2_abs_rep"], ["proof (chain)\npicking this:\n  proj2_abs (proj2_rep ?x) = ?x\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  proj2_abs (proj2_rep a3)", "have \"apply_cltn2 (proj2_abs (vector [1,1,1])) ?A = a3\""], ["proof (prove)\nusing this:\n  proj2_abs (proj2_rep ?x) = ?x\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  proj2_abs (proj2_rep a3)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n     (cltn2_abs\n       (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n    a3", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  a3\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "have \"\\<forall> j. apply_cltn2 (proj2_abs (axis j 1)) ?A = a$j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       apply_cltn2 (proj2_abs (axis j 1))\n        (cltn2_abs\n          (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n       a $ j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       apply_cltn2 (proj2_abs (axis j 1))\n        (cltn2_abs\n          (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n       a $ j", "fix j :: \"3\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       apply_cltn2 (proj2_abs (axis j 1))\n        (cltn2_abs\n          (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n       a $ j", "have \"((axis j 1)::real^3) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. axis j 1 \\<noteq> 0", "by (simp add: vec_eq_iff axis_def)"], ["proof (state)\nthis:\n  axis j 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       apply_cltn2 (proj2_abs (axis j 1))\n        (cltn2_abs\n          (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n       a $ j", "with apply_cltn2_abs and \\<open>invertible ?C\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2 (proj2_abs ?x) (cltn2_abs ?A) =\n                    proj2_abs (?x v* ?A)\n  invertible (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))\n  axis j 1 \\<noteq> 0", "have \"apply_cltn2 (proj2_abs (axis j 1)) ?A = proj2_abs (axis j 1 v* ?C)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> 0; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2 (proj2_abs ?x) (cltn2_abs ?A) =\n                    proj2_abs (?x v* ?A)\n  invertible (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))\n  axis j 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs (axis j 1))\n     (cltn2_abs\n       (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n    proj2_abs\n     (axis j 1 v*\n      (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (proj2_abs (axis j 1))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  proj2_abs\n   (axis j 1 v*\n    (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       apply_cltn2 (proj2_abs (axis j 1))\n        (cltn2_abs\n          (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n       a $ j", "have \"\\<forall> i\\<in>(UNIV-{j}).\n      ((axis j 1)$i * c (proj2_rep (a$i))) *\\<^sub>R (proj2_rep (a$i)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>UNIV - {j}.\n       (axis j 1 $ i * c (proj2_rep (a $ i))) *\\<^sub>R proj2_rep (a $ i) =\n       0", "by (simp add: axis_def)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>UNIV - {j}.\n     (axis j 1 $ i * c (proj2_rep (a $ i))) *\\<^sub>R proj2_rep (a $ i) = 0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       apply_cltn2 (proj2_abs (axis j 1))\n        (cltn2_abs\n          (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n       a $ j", "with sum.mono_neutral_left [of UNIV \"{j}\"\n      \"\\<lambda> i. ((axis j 1)$i * c (proj2_rep (a$i))) *\\<^sub>R (proj2_rep (a$i))\"]\n      and vector_matrix_row [of \"axis j 1\" ?C]"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite UNIV; {j} \\<subseteq> UNIV;\n   \\<forall>i\\<in>UNIV - {j}.\n      (axis j 1 $ i * c (proj2_rep (a $ i))) *\\<^sub>R proj2_rep (a $ i) =\n      0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i\\<in>{j}.\n                       (axis j 1 $ i * c (proj2_rep (a $ i))) *\\<^sub>R\n                       proj2_rep (a $ i)) =\n                    (\\<Sum>i\\<in>UNIV.\n                       (axis j 1 $ i * c (proj2_rep (a $ i))) *\\<^sub>R\n                       proj2_rep (a $ i))\n  axis j 1 v* (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<Sum>i\\<in>UNIV.\n     axis j 1 $ i *s\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) $ i)\n  \\<forall>i\\<in>UNIV - {j}.\n     (axis j 1 $ i * c (proj2_rep (a $ i))) *\\<^sub>R proj2_rep (a $ i) = 0", "have \"(axis j 1) v* ?C = ?C$j\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite UNIV; {j} \\<subseteq> UNIV;\n   \\<forall>i\\<in>UNIV - {j}.\n      (axis j 1 $ i * c (proj2_rep (a $ i))) *\\<^sub>R proj2_rep (a $ i) =\n      0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i\\<in>{j}.\n                       (axis j 1 $ i * c (proj2_rep (a $ i))) *\\<^sub>R\n                       proj2_rep (a $ i)) =\n                    (\\<Sum>i\\<in>UNIV.\n                       (axis j 1 $ i * c (proj2_rep (a $ i))) *\\<^sub>R\n                       proj2_rep (a $ i))\n  axis j 1 v* (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<Sum>i\\<in>UNIV.\n     axis j 1 $ i *s\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) $ i)\n  \\<forall>i\\<in>UNIV - {j}.\n     (axis j 1 $ i * c (proj2_rep (a $ i))) *\\<^sub>R proj2_rep (a $ i) = 0\n\ngoal (1 subgoal):\n 1. axis j 1 v*\n    (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n    (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) $ j", "by (simp add: scalar_equiv)"], ["proof (state)\nthis:\n  axis j 1 v* (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       apply_cltn2 (proj2_abs (axis j 1))\n        (cltn2_abs\n          (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n       a $ j", "hence \"(axis j 1) v* ?C = c (proj2_rep (a$j)) *\\<^sub>R (proj2_rep (a$j))\""], ["proof (prove)\nusing this:\n  axis j 1 v* (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) $ j\n\ngoal (1 subgoal):\n 1. axis j 1 v*\n    (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n    c (proj2_rep (a $ j)) *\\<^sub>R proj2_rep (a $ j)", "by simp"], ["proof (state)\nthis:\n  axis j 1 v* (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  c (proj2_rep (a $ j)) *\\<^sub>R proj2_rep (a $ j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       apply_cltn2 (proj2_abs (axis j 1))\n        (cltn2_abs\n          (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n       a $ j", "with proj2_abs_mult_rep and \\<open>\\<forall> i. c (proj2_rep (a$i)) \\<noteq> 0\\<close>\n      and \\<open>apply_cltn2 (proj2_abs (axis j 1)) ?A = proj2_abs (axis j 1 v* ?C)\\<close>"], ["proof (chain)\npicking this:\n  ?c \\<noteq> 0 \\<Longrightarrow> proj2_abs (?c *\\<^sub>R proj2_rep ?x) = ?x\n  \\<forall>i. c (proj2_rep (a $ i)) \\<noteq> 0\n  apply_cltn2 (proj2_abs (axis j 1))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  proj2_abs\n   (axis j 1 v*\n    (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n  axis j 1 v* (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  c (proj2_rep (a $ j)) *\\<^sub>R proj2_rep (a $ j)", "show \"apply_cltn2 (proj2_abs (axis j 1)) ?A = a$j\""], ["proof (prove)\nusing this:\n  ?c \\<noteq> 0 \\<Longrightarrow> proj2_abs (?c *\\<^sub>R proj2_rep ?x) = ?x\n  \\<forall>i. c (proj2_rep (a $ i)) \\<noteq> 0\n  apply_cltn2 (proj2_abs (axis j 1))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  proj2_abs\n   (axis j 1 v*\n    (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)))\n  axis j 1 v* (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i)) =\n  c (proj2_rep (a $ j)) *\\<^sub>R proj2_rep (a $ j)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs (axis j 1))\n     (cltn2_abs\n       (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n    a $ j", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (proj2_abs (axis j 1))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  a $ j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j.\n     apply_cltn2 (proj2_abs (axis j 1))\n      (cltn2_abs\n        (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n     a $ j\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "with \\<open>apply_cltn2 (proj2_abs (vector [1,1,1])) ?A = a3\\<close>"], ["proof (chain)\npicking this:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  a3\n  \\<forall>j.\n     apply_cltn2 (proj2_abs (axis j 1))\n      (cltn2_abs\n        (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n     a $ j", "show \"\\<exists> A. apply_cltn2 (proj2_abs (vector [1,1,1])) A = a3 \\<and>\n    (\\<forall> j. apply_cltn2 (proj2_abs (axis j 1)) A = a$j)\""], ["proof (prove)\nusing this:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   (cltn2_abs\n     (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n  a3\n  \\<forall>j.\n     apply_cltn2 (proj2_abs (axis j 1))\n      (cltn2_abs\n        (\\<chi>i. c (proj2_rep (a $ i)) *\\<^sub>R proj2_rep (a $ i))) =\n     a $ j\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n       (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)", "by auto"], ["proof (state)\nthis:\n  \\<exists>A.\n     apply_cltn2 (proj2_abs (vector [1, 1, 1])) A = a3 \\<and>\n     (\\<forall>j. apply_cltn2 (proj2_abs (axis j 1)) A = a $ j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma statement53_existence:\n  fixes p :: \"proj2^4^2\"\n  assumes \"\\<forall> i. proj2_no_3_Col (range (($) (p$i)))\"\n  shows \"\\<exists> C. \\<forall> j. apply_cltn2 (p$0$j) C = p$1$j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. \\<forall>j. apply_cltn2 (p $ 0 $ j) C = p $ 1 $ j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. \\<forall>j. apply_cltn2 (p $ 0 $ j) C = p $ 1 $ j", "let ?q = \"\\<chi> i. \\<chi> j::3. p$i $ (of_int (Rep_bit1 j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. \\<forall>j. apply_cltn2 (p $ 0 $ j) C = p $ 1 $ j", "let ?D = \"\\<chi> i. \\<some> D. apply_cltn2 (proj2_abs (vector [1,1,1])) D = p$i$3\n    \\<and> (\\<forall> j'. apply_cltn2 (proj2_abs (axis j' 1)) D = ?q$i$j')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. \\<forall>j. apply_cltn2 (p $ 0 $ j) C = p $ 1 $ j", "have \"\\<forall> i. apply_cltn2 (proj2_abs (vector [1,1,1])) (?D$i) = p$i$3\n    \\<and> (\\<forall> j'. apply_cltn2 (proj2_abs (axis j' 1)) (?D$i) = ?q$i$j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         i) =\n       p $ i $ 3 \\<and>\n       (\\<forall>j'.\n           apply_cltn2 (proj2_abs (axis j' 1))\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             i) =\n           (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         i) =\n       p $ i $ 3 \\<and>\n       (\\<forall>j'.\n           apply_cltn2 (proj2_abs (axis j' 1))\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             i) =\n           (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         i) =\n       p $ i $ 3 \\<and>\n       (\\<forall>j'.\n           apply_cltn2 (proj2_abs (axis j' 1))\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             i) =\n           (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')", "have \"range (($) (p$i)) = insert (p$i$3) (range (($) (?q$i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (($) (p $ i)) =\n    insert (p $ i $ 3)\n     (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. range (($) (p $ i))\n    \\<subseteq> insert (p $ i $ 3)\n                 (range\n                   (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))\n 2. insert (p $ i $ 3)\n     (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))\n    \\<subseteq> range (($) (p $ i))", "show \"range (($) (p$i)) \\<supseteq> insert (p$i$3) (range (($) (?q$i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (p $ i $ 3)\n     (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))\n    \\<subseteq> range (($) (p $ i))", "by auto"], ["proof (state)\nthis:\n  insert (p $ i $ 3)\n   (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))\n  \\<subseteq> range (($) (p $ i))\n\ngoal (1 subgoal):\n 1. range (($) (p $ i))\n    \\<subseteq> insert (p $ i $ 3)\n                 (range\n                   (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))", "show \"range (($) (p$i)) \\<subseteq> insert (p$i$3) (range (($) (?q$i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (($) (p $ i))\n    \\<subseteq> insert (p $ i $ 3)\n                 (range\n                   (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range (($) (p $ i)) \\<Longrightarrow>\n       x \\<in> insert (p $ i $ 3)\n                (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range (($) (p $ i)) \\<Longrightarrow>\n       x \\<in> insert (p $ i $ 3)\n                (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))", "assume \"r \\<in> range (($) (p$i))\""], ["proof (state)\nthis:\n  r \\<in> range (($) (p $ i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range (($) (p $ i)) \\<Longrightarrow>\n       x \\<in> insert (p $ i $ 3)\n                (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))", "then"], ["proof (chain)\npicking this:\n  r \\<in> range (($) (p $ i))", "obtain j where \"r = p$i$j\""], ["proof (prove)\nusing this:\n  r \\<in> range (($) (p $ i))\n\ngoal (1 subgoal):\n 1. (\\<And>j. r = p $ i $ j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r = p $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range (($) (p $ i)) \\<Longrightarrow>\n       x \\<in> insert (p $ i $ 3)\n                (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))", "with eq_3_or_of_3 [of j]"], ["proof (chain)\npicking this:\n  j = 3 \\<or> (\\<exists>j'. j = of_int (Rep_bit1 j'))\n  r = p $ i $ j", "show \"r \\<in> insert (p$i$3) (range (($) (?q$i)))\""], ["proof (prove)\nusing this:\n  j = 3 \\<or> (\\<exists>j'. j = of_int (Rep_bit1 j'))\n  r = p $ i $ j\n\ngoal (1 subgoal):\n 1. r \\<in> insert (p $ i $ 3)\n             (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))", "by auto"], ["proof (state)\nthis:\n  r \\<in> insert (p $ i $ 3)\n           (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range (($) (p $ i))\n  \\<subseteq> insert (p $ i $ 3)\n               (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range (($) (p $ i)) =\n  insert (p $ i $ 3)\n   (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         i) =\n       p $ i $ 3 \\<and>\n       (\\<forall>j'.\n           apply_cltn2 (proj2_abs (axis j' 1))\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             i) =\n           (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')", "moreover"], ["proof (state)\nthis:\n  range (($) (p $ i)) =\n  insert (p $ i $ 3)\n   (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         i) =\n       p $ i $ 3 \\<and>\n       (\\<forall>j'.\n           apply_cltn2 (proj2_abs (axis j' 1))\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             i) =\n           (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')", "from \\<open>\\<forall> i. proj2_no_3_Col (range (($) (p$i)))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i. proj2_no_3_Col (range (($) (p $ i)))", "have \"proj2_no_3_Col (range (($) (p$i)))\""], ["proof (prove)\nusing this:\n  \\<forall>i. proj2_no_3_Col (range (($) (p $ i)))\n\ngoal (1 subgoal):\n 1. proj2_no_3_Col (range (($) (p $ i)))", ".."], ["proof (state)\nthis:\n  proj2_no_3_Col (range (($) (p $ i)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         i) =\n       p $ i $ 3 \\<and>\n       (\\<forall>j'.\n           apply_cltn2 (proj2_abs (axis j' 1))\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             i) =\n           (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')", "ultimately"], ["proof (chain)\npicking this:\n  range (($) (p $ i)) =\n  insert (p $ i $ 3)\n   (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))\n  proj2_no_3_Col (range (($) (p $ i)))", "have \"proj2_no_3_Col (insert (p$i$3) (range (($) (?q$i))))\""], ["proof (prove)\nusing this:\n  range (($) (p $ i)) =\n  insert (p $ i $ 3)\n   (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i)))\n  proj2_no_3_Col (range (($) (p $ i)))\n\ngoal (1 subgoal):\n 1. proj2_no_3_Col\n     (insert (p $ i $ 3)\n       (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i))))", "by simp"], ["proof (state)\nthis:\n  proj2_no_3_Col\n   (insert (p $ i $ 3)\n     (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i))))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         i) =\n       p $ i $ 3 \\<and>\n       (\\<forall>j'.\n           apply_cltn2 (proj2_abs (axis j' 1))\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             i) =\n           (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')", "hence \"\\<exists> D. apply_cltn2 (proj2_abs (vector [1,1,1])) D = p$i$3\n      \\<and> (\\<forall> j'. apply_cltn2 (proj2_abs (axis j' 1)) D = ?q$i$j')\""], ["proof (prove)\nusing this:\n  proj2_no_3_Col\n   (insert (p $ i $ 3)\n     (range (($) ((\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i))))\n\ngoal (1 subgoal):\n 1. \\<exists>D.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n       (\\<forall>j'.\n           apply_cltn2 (proj2_abs (axis j' 1)) D =\n           (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')", "by (rule statement52_existence)"], ["proof (state)\nthis:\n  \\<exists>D.\n     apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n     (\\<forall>j'.\n         apply_cltn2 (proj2_abs (axis j' 1)) D =\n         (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         i) =\n       p $ i $ 3 \\<and>\n       (\\<forall>j'.\n           apply_cltn2 (proj2_abs (axis j' 1))\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             i) =\n           (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')", "with someI_ex [of \"\\<lambda> D. apply_cltn2 (proj2_abs (vector [1,1,1])) D = p$i$3\n      \\<and> (\\<forall> j'. apply_cltn2 (proj2_abs (axis j' 1)) D = ?q$i$j')\"]"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     apply_cltn2 (proj2_abs (vector [1, 1, 1])) x = p $ i $ 3 \\<and>\n     (\\<forall>j'.\n         apply_cltn2 (proj2_abs (axis j' 1)) x =\n         (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n         j') \\<Longrightarrow>\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   (SOME x.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) x = p $ i $ 3 \\<and>\n       (\\<forall>j'.\n           apply_cltn2 (proj2_abs (axis j' 1)) x =\n           (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) =\n  p $ i $ 3 \\<and>\n  (\\<forall>j'.\n      apply_cltn2 (proj2_abs (axis j' 1))\n       (SOME x.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) x = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) x =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) =\n      (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')\n  \\<exists>D.\n     apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n     (\\<forall>j'.\n         apply_cltn2 (proj2_abs (axis j' 1)) D =\n         (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')", "show \"apply_cltn2 (proj2_abs (vector [1,1,1])) (?D$i) = p$i$3\n      \\<and> (\\<forall> j'. apply_cltn2 (proj2_abs (axis j' 1)) (?D$i) = ?q$i$j')\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     apply_cltn2 (proj2_abs (vector [1, 1, 1])) x = p $ i $ 3 \\<and>\n     (\\<forall>j'.\n         apply_cltn2 (proj2_abs (axis j' 1)) x =\n         (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n         j') \\<Longrightarrow>\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   (SOME x.\n       apply_cltn2 (proj2_abs (vector [1, 1, 1])) x = p $ i $ 3 \\<and>\n       (\\<forall>j'.\n           apply_cltn2 (proj2_abs (axis j' 1)) x =\n           (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) =\n  p $ i $ 3 \\<and>\n  (\\<forall>j'.\n      apply_cltn2 (proj2_abs (axis j' 1))\n       (SOME x.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) x = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) x =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) =\n      (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')\n  \\<exists>D.\n     apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n     (\\<forall>j'.\n         apply_cltn2 (proj2_abs (axis j' 1)) D =\n         (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      i) =\n    p $ i $ 3 \\<and>\n    (\\<forall>j'.\n        apply_cltn2 (proj2_abs (axis j' 1))\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          i) =\n        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    i) =\n  p $ i $ 3 \\<and>\n  (\\<forall>j'.\n      apply_cltn2 (proj2_abs (axis j' 1))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        i) =\n      (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i.\n     apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n      ((\\<chi>i.\n           SOME D.\n              apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n              p $ i $ 3 \\<and>\n              (\\<forall>j'.\n                  apply_cltn2 (proj2_abs (axis j' 1)) D =\n                  (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n       i) =\n     p $ i $ 3 \\<and>\n     (\\<forall>j'.\n         apply_cltn2 (proj2_abs (axis j' 1))\n          ((\\<chi>i.\n               SOME D.\n                  apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                  p $ i $ 3 \\<and>\n                  (\\<forall>j'.\n                      apply_cltn2 (proj2_abs (axis j' 1)) D =\n                      (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n           i) =\n         (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')\n\ngoal (1 subgoal):\n 1. \\<exists>C. \\<forall>j. apply_cltn2 (p $ 0 $ j) C = p $ 1 $ j", "hence \"apply_cltn2 (proj2_abs (vector [1,1,1])) (?D$0) = p$0$3\"\n    and \"apply_cltn2 (proj2_abs (vector [1,1,1])) (?D$1) = p$1$3\"\n    and \"\\<forall> j'. apply_cltn2 (proj2_abs (axis j' 1)) (?D$0) = ?q$0$j'\"\n    and \"\\<forall> j'. apply_cltn2 (proj2_abs (axis j' 1)) (?D$1) = ?q$1$j'\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n      ((\\<chi>i.\n           SOME D.\n              apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n              p $ i $ 3 \\<and>\n              (\\<forall>j'.\n                  apply_cltn2 (proj2_abs (axis j' 1)) D =\n                  (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n       i) =\n     p $ i $ 3 \\<and>\n     (\\<forall>j'.\n         apply_cltn2 (proj2_abs (axis j' 1))\n          ((\\<chi>i.\n               SOME D.\n                  apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                  p $ i $ 3 \\<and>\n                  (\\<forall>j'.\n                      apply_cltn2 (proj2_abs (axis j' 1)) D =\n                      (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n           i) =\n         (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')\n\ngoal (1 subgoal):\n 1. (apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n      ((\\<chi>i.\n           SOME D.\n              apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n              p $ i $ 3 \\<and>\n              (\\<forall>j'.\n                  apply_cltn2 (proj2_abs (axis j' 1)) D =\n                  (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n       0) =\n     p $ 0 $ 3 &&&\n     apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n      ((\\<chi>i.\n           SOME D.\n              apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n              p $ i $ 3 \\<and>\n              (\\<forall>j'.\n                  apply_cltn2 (proj2_abs (axis j' 1)) D =\n                  (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n       1) =\n     p $ 1 $ 3) &&&\n    \\<forall>j'.\n       apply_cltn2 (proj2_abs (axis j' 1))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         0) =\n       (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ 0 $ j' &&&\n    \\<forall>j'.\n       apply_cltn2 (proj2_abs (axis j' 1))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         1) =\n       (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ 1 $ j'", "by simp_all"], ["proof (state)\nthis:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    0) =\n  p $ 0 $ 3\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    1) =\n  p $ 1 $ 3\n  \\<forall>j'.\n     apply_cltn2 (proj2_abs (axis j' 1))\n      ((\\<chi>i.\n           SOME D.\n              apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n              p $ i $ 3 \\<and>\n              (\\<forall>j'.\n                  apply_cltn2 (proj2_abs (axis j' 1)) D =\n                  (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n       0) =\n     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ 0 $ j'\n  \\<forall>j'.\n     apply_cltn2 (proj2_abs (axis j' 1))\n      ((\\<chi>i.\n           SOME D.\n              apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n              p $ i $ 3 \\<and>\n              (\\<forall>j'.\n                  apply_cltn2 (proj2_abs (axis j' 1)) D =\n                  (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n       1) =\n     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ 1 $ j'\n\ngoal (1 subgoal):\n 1. \\<exists>C. \\<forall>j. apply_cltn2 (p $ 0 $ j) C = p $ 1 $ j", "let ?C = \"cltn2_compose (cltn2_inverse (?D$0)) (?D$1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. \\<forall>j. apply_cltn2 (p $ 0 $ j) C = p $ 1 $ j", "have \"\\<forall> j. apply_cltn2 (p$0$j) ?C = p$1$j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       apply_cltn2 (p $ 0 $ j)\n        (cltn2_compose\n          (cltn2_inverse\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             0))\n          ((\\<chi>i.\n               SOME D.\n                  apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                  p $ i $ 3 \\<and>\n                  (\\<forall>j'.\n                      apply_cltn2 (proj2_abs (axis j' 1)) D =\n                      (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n           1)) =\n       p $ 1 $ j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       apply_cltn2 (p $ 0 $ j)\n        (cltn2_compose\n          (cltn2_inverse\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             0))\n          ((\\<chi>i.\n               SOME D.\n                  apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                  p $ i $ 3 \\<and>\n                  (\\<forall>j'.\n                      apply_cltn2 (proj2_abs (axis j' 1)) D =\n                      (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n           1)) =\n       p $ 1 $ j", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       apply_cltn2 (p $ 0 $ j)\n        (cltn2_compose\n          (cltn2_inverse\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             0))\n          ((\\<chi>i.\n               SOME D.\n                  apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                  p $ i $ 3 \\<and>\n                  (\\<forall>j'.\n                      apply_cltn2 (proj2_abs (axis j' 1)) D =\n                      (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n           1)) =\n       p $ 1 $ j", "show \"apply_cltn2 (p$0$j) ?C = p$1$j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j\n 2. \\<not> ?P \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "assume \"j = 3\""], ["proof (state)\nthis:\n  j = 3\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j\n 2. \\<not> ?P \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "with \\<open>apply_cltn2 (proj2_abs (vector [1,1,1])) (?D$0) = p$0$3\\<close>\n        and  cltn2.act_inv_iff"], ["proof (chain)\npicking this:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    0) =\n  p $ 0 $ 3\n  ?g \\<in> carrier\n            \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n               one = cltn2_id\\<rparr> \\<Longrightarrow>\n  (apply_cltn2 ?b\n    (inv\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> ?g) =\n   ?c) =\n  (?b = apply_cltn2 ?c ?g)\n  j = 3", "have\n        \"apply_cltn2 (p$0$j) (cltn2_inverse (?D$0)) = proj2_abs (vector [1,1,1])\""], ["proof (prove)\nusing this:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    0) =\n  p $ 0 $ 3\n  ?g \\<in> carrier\n            \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n               one = cltn2_id\\<rparr> \\<Longrightarrow>\n  (apply_cltn2 ?b\n    (inv\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> ?g) =\n   ?c) =\n  (?b = apply_cltn2 ?c ?g)\n  j = 3\n\ngoal (1 subgoal):\n 1. apply_cltn2 (p $ 0 $ j)\n     (cltn2_inverse\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        0)) =\n    proj2_abs (vector [1, 1, 1])", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (p $ 0 $ j)\n   (cltn2_inverse\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      0)) =\n  proj2_abs (vector [1, 1, 1])\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j\n 2. \\<not> ?P \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "with \\<open>apply_cltn2 (proj2_abs (vector [1,1,1])) (?D$1) = p$1$3\\<close>\n        and \\<open>j = 3\\<close>\n        and cltn2.act_act [of \"cltn2_inverse (?D$0)\" \"?D$1\" \"p$0$j\"]"], ["proof (chain)\npicking this:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    1) =\n  p $ 1 $ 3\n  j = 3\n  \\<lbrakk>cltn2_inverse\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             0)\n           \\<in> carrier\n                  \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                     one = cltn2_id\\<rparr>;\n   (\\<chi>i.\n       SOME D.\n          apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n          (\\<forall>j'.\n              apply_cltn2 (proj2_abs (axis j' 1)) D =\n              (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n   1\n   \\<in> carrier\n          \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n             one = cltn2_id\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2\n                     (apply_cltn2 (p $ 0 $ j)\n                       (cltn2_inverse\n                         ((\\<chi>i.\n                              SOME D.\n                                 apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n                                  D =\n                                 p $ i $ 3 \\<and>\n                                 (\\<forall>j'.\n                                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                     (\\<chi>i j.\n   p $ i $ of_int (Rep_bit1 j)) $\n                                     i $\n                                     j')) $\n                          0)))\n                     ((\\<chi>i.\n                          SOME D.\n                             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                             p $ i $ 3 \\<and>\n                             (\\<forall>j'.\n                                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $\n                                 i $\n                                 j')) $\n                      1) =\n                    apply_cltn2 (p $ 0 $ j)\n                     (cltn2_inverse\n                       ((\\<chi>i.\n                            SOME D.\n                               apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n                                D =\n                               p $ i $ 3 \\<and>\n                               (\\<forall>j'.\n                                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                   (\\<chi>i j.\n p $ i $ of_int (Rep_bit1 j)) $\n                                   i $\n                                   j')) $\n                        0) \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n                      (\\<chi>i.\n                          SOME D.\n                             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                             p $ i $ 3 \\<and>\n                             (\\<forall>j'.\n                                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $\n                                 i $\n                                 j')) $\n                      1)\n  apply_cltn2 (p $ 0 $ j)\n   (cltn2_inverse\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      0)) =\n  proj2_abs (vector [1, 1, 1])", "show \"apply_cltn2 (p$0$j) ?C = p$1$j\""], ["proof (prove)\nusing this:\n  apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    1) =\n  p $ 1 $ 3\n  j = 3\n  \\<lbrakk>cltn2_inverse\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             0)\n           \\<in> carrier\n                  \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                     one = cltn2_id\\<rparr>;\n   (\\<chi>i.\n       SOME D.\n          apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n          (\\<forall>j'.\n              apply_cltn2 (proj2_abs (axis j' 1)) D =\n              (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n   1\n   \\<in> carrier\n          \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n             one = cltn2_id\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2\n                     (apply_cltn2 (p $ 0 $ j)\n                       (cltn2_inverse\n                         ((\\<chi>i.\n                              SOME D.\n                                 apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n                                  D =\n                                 p $ i $ 3 \\<and>\n                                 (\\<forall>j'.\n                                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                     (\\<chi>i j.\n   p $ i $ of_int (Rep_bit1 j)) $\n                                     i $\n                                     j')) $\n                          0)))\n                     ((\\<chi>i.\n                          SOME D.\n                             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                             p $ i $ 3 \\<and>\n                             (\\<forall>j'.\n                                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $\n                                 i $\n                                 j')) $\n                      1) =\n                    apply_cltn2 (p $ 0 $ j)\n                     (cltn2_inverse\n                       ((\\<chi>i.\n                            SOME D.\n                               apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n                                D =\n                               p $ i $ 3 \\<and>\n                               (\\<forall>j'.\n                                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                   (\\<chi>i j.\n p $ i $ of_int (Rep_bit1 j)) $\n                                   i $\n                                   j')) $\n                        0) \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n                      (\\<chi>i.\n                          SOME D.\n                             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                             p $ i $ 3 \\<and>\n                             (\\<forall>j'.\n                                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $\n                                 i $\n                                 j')) $\n                      1)\n  apply_cltn2 (p $ 0 $ j)\n   (cltn2_inverse\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      0)) =\n  proj2_abs (vector [1, 1, 1])\n\ngoal (1 subgoal):\n 1. apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (p $ 0 $ j)\n   (cltn2_compose\n     (cltn2_inverse\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        0))\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      1)) =\n  p $ 1 $ j\n\ngoal (1 subgoal):\n 1. j \\<noteq> 3 \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> 3 \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "assume \"j \\<noteq> 3\""], ["proof (state)\nthis:\n  j \\<noteq> 3\n\ngoal (1 subgoal):\n 1. j \\<noteq> 3 \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "with eq_3_or_of_3"], ["proof (chain)\npicking this:\n  ?j = 3 \\<or> (\\<exists>j'. ?j = of_int (Rep_bit1 j'))\n  j \\<noteq> 3", "obtain j' :: 3 where \"j = of_int (Rep_bit1 j')\""], ["proof (prove)\nusing this:\n  ?j = 3 \\<or> (\\<exists>j'. ?j = of_int (Rep_bit1 j'))\n  j \\<noteq> 3\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        j = of_int (Rep_bit1 j') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  j = of_int (Rep_bit1 j')\n\ngoal (1 subgoal):\n 1. j \\<noteq> 3 \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "with \\<open>\\<forall> j'. apply_cltn2 (proj2_abs (axis j' 1)) (?D$0) = ?q$0$j'\\<close>\n        and \\<open>\\<forall> j'. apply_cltn2 (proj2_abs (axis j' 1)) (?D$1) = ?q$1$j'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>j'.\n     apply_cltn2 (proj2_abs (axis j' 1))\n      ((\\<chi>i.\n           SOME D.\n              apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n              p $ i $ 3 \\<and>\n              (\\<forall>j'.\n                  apply_cltn2 (proj2_abs (axis j' 1)) D =\n                  (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n       0) =\n     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ 0 $ j'\n  \\<forall>j'.\n     apply_cltn2 (proj2_abs (axis j' 1))\n      ((\\<chi>i.\n           SOME D.\n              apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n              p $ i $ 3 \\<and>\n              (\\<forall>j'.\n                  apply_cltn2 (proj2_abs (axis j' 1)) D =\n                  (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n       1) =\n     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ 1 $ j'\n  j = of_int (Rep_bit1 j')", "have \"p$0$j = apply_cltn2 (proj2_abs (axis j' 1)) (?D$0)\"\n        and \"p$1$j = apply_cltn2 (proj2_abs (axis j' 1)) (?D$1)\""], ["proof (prove)\nusing this:\n  \\<forall>j'.\n     apply_cltn2 (proj2_abs (axis j' 1))\n      ((\\<chi>i.\n           SOME D.\n              apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n              p $ i $ 3 \\<and>\n              (\\<forall>j'.\n                  apply_cltn2 (proj2_abs (axis j' 1)) D =\n                  (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n       0) =\n     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ 0 $ j'\n  \\<forall>j'.\n     apply_cltn2 (proj2_abs (axis j' 1))\n      ((\\<chi>i.\n           SOME D.\n              apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n              p $ i $ 3 \\<and>\n              (\\<forall>j'.\n                  apply_cltn2 (proj2_abs (axis j' 1)) D =\n                  (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n       1) =\n     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ 1 $ j'\n  j = of_int (Rep_bit1 j')\n\ngoal (1 subgoal):\n 1. p $ 0 $ j =\n    apply_cltn2 (proj2_abs (axis j' 1))\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      0) &&&\n    p $ 1 $ j =\n    apply_cltn2 (proj2_abs (axis j' 1))\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      1)", "by simp_all"], ["proof (state)\nthis:\n  p $ 0 $ j =\n  apply_cltn2 (proj2_abs (axis j' 1))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    0)\n  p $ 1 $ j =\n  apply_cltn2 (proj2_abs (axis j' 1))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    1)\n\ngoal (1 subgoal):\n 1. j \\<noteq> 3 \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "from \\<open>p$0$j = apply_cltn2 (proj2_abs (axis j' 1)) (?D$0)\\<close>\n        and cltn2.act_inv_iff"], ["proof (chain)\npicking this:\n  p $ 0 $ j =\n  apply_cltn2 (proj2_abs (axis j' 1))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    0)\n  ?g \\<in> carrier\n            \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n               one = cltn2_id\\<rparr> \\<Longrightarrow>\n  (apply_cltn2 ?b\n    (inv\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> ?g) =\n   ?c) =\n  (?b = apply_cltn2 ?c ?g)", "have \"apply_cltn2 (p$0$j) (cltn2_inverse (?D$0)) = proj2_abs (axis j' 1)\""], ["proof (prove)\nusing this:\n  p $ 0 $ j =\n  apply_cltn2 (proj2_abs (axis j' 1))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    0)\n  ?g \\<in> carrier\n            \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n               one = cltn2_id\\<rparr> \\<Longrightarrow>\n  (apply_cltn2 ?b\n    (inv\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub> ?g) =\n   ?c) =\n  (?b = apply_cltn2 ?c ?g)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (p $ 0 $ j)\n     (cltn2_inverse\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        0)) =\n    proj2_abs (axis j' 1)", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (p $ 0 $ j)\n   (cltn2_inverse\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      0)) =\n  proj2_abs (axis j' 1)\n\ngoal (1 subgoal):\n 1. j \\<noteq> 3 \\<Longrightarrow>\n    apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "with \\<open>p$1$j = apply_cltn2 (proj2_abs (axis j' 1)) (?D$1)\\<close>\n        and cltn2.act_act [of \"cltn2_inverse (?D$0)\" \"?D$1\" \"p$0$j\"]"], ["proof (chain)\npicking this:\n  p $ 1 $ j =\n  apply_cltn2 (proj2_abs (axis j' 1))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    1)\n  \\<lbrakk>cltn2_inverse\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             0)\n           \\<in> carrier\n                  \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                     one = cltn2_id\\<rparr>;\n   (\\<chi>i.\n       SOME D.\n          apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n          (\\<forall>j'.\n              apply_cltn2 (proj2_abs (axis j' 1)) D =\n              (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n   1\n   \\<in> carrier\n          \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n             one = cltn2_id\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2\n                     (apply_cltn2 (p $ 0 $ j)\n                       (cltn2_inverse\n                         ((\\<chi>i.\n                              SOME D.\n                                 apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n                                  D =\n                                 p $ i $ 3 \\<and>\n                                 (\\<forall>j'.\n                                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                     (\\<chi>i j.\n   p $ i $ of_int (Rep_bit1 j)) $\n                                     i $\n                                     j')) $\n                          0)))\n                     ((\\<chi>i.\n                          SOME D.\n                             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                             p $ i $ 3 \\<and>\n                             (\\<forall>j'.\n                                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $\n                                 i $\n                                 j')) $\n                      1) =\n                    apply_cltn2 (p $ 0 $ j)\n                     (cltn2_inverse\n                       ((\\<chi>i.\n                            SOME D.\n                               apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n                                D =\n                               p $ i $ 3 \\<and>\n                               (\\<forall>j'.\n                                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                   (\\<chi>i j.\n p $ i $ of_int (Rep_bit1 j)) $\n                                   i $\n                                   j')) $\n                        0) \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n                      (\\<chi>i.\n                          SOME D.\n                             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                             p $ i $ 3 \\<and>\n                             (\\<forall>j'.\n                                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $\n                                 i $\n                                 j')) $\n                      1)\n  apply_cltn2 (p $ 0 $ j)\n   (cltn2_inverse\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      0)) =\n  proj2_abs (axis j' 1)", "show \"apply_cltn2 (p$0$j) ?C = p$1$j\""], ["proof (prove)\nusing this:\n  p $ 1 $ j =\n  apply_cltn2 (proj2_abs (axis j' 1))\n   ((\\<chi>i.\n        SOME D.\n           apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n           (\\<forall>j'.\n               apply_cltn2 (proj2_abs (axis j' 1)) D =\n               (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n    1)\n  \\<lbrakk>cltn2_inverse\n            ((\\<chi>i.\n                 SOME D.\n                    apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                    p $ i $ 3 \\<and>\n                    (\\<forall>j'.\n                        apply_cltn2 (proj2_abs (axis j' 1)) D =\n                        (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $\n                        j')) $\n             0)\n           \\<in> carrier\n                  \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n                     one = cltn2_id\\<rparr>;\n   (\\<chi>i.\n       SOME D.\n          apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n          (\\<forall>j'.\n              apply_cltn2 (proj2_abs (axis j' 1)) D =\n              (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n   1\n   \\<in> carrier\n          \\<lparr>carrier = UNIV, monoid.mult = cltn2_compose,\n             one = cltn2_id\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> apply_cltn2\n                     (apply_cltn2 (p $ 0 $ j)\n                       (cltn2_inverse\n                         ((\\<chi>i.\n                              SOME D.\n                                 apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n                                  D =\n                                 p $ i $ 3 \\<and>\n                                 (\\<forall>j'.\n                                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                     (\\<chi>i j.\n   p $ i $ of_int (Rep_bit1 j)) $\n                                     i $\n                                     j')) $\n                          0)))\n                     ((\\<chi>i.\n                          SOME D.\n                             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                             p $ i $ 3 \\<and>\n                             (\\<forall>j'.\n                                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $\n                                 i $\n                                 j')) $\n                      1) =\n                    apply_cltn2 (p $ 0 $ j)\n                     (cltn2_inverse\n                       ((\\<chi>i.\n                            SOME D.\n                               apply_cltn2 (proj2_abs (vector [1, 1, 1]))\n                                D =\n                               p $ i $ 3 \\<and>\n                               (\\<forall>j'.\n                                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                   (\\<chi>i j.\n p $ i $ of_int (Rep_bit1 j)) $\n                                   i $\n                                   j')) $\n                        0) \\<otimes>\\<^bsub>\\<lparr>carrier = UNIV, monoid.mult = cltn2_compose, one = cltn2_id\\<rparr>\\<^esub>\n                      (\\<chi>i.\n                          SOME D.\n                             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                             p $ i $ 3 \\<and>\n                             (\\<forall>j'.\n                                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $\n                                 i $\n                                 j')) $\n                      1)\n  apply_cltn2 (p $ 0 $ j)\n   (cltn2_inverse\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      0)) =\n  proj2_abs (axis j' 1)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (p $ 0 $ j)\n     (cltn2_compose\n       (cltn2_inverse\n         ((\\<chi>i.\n              SOME D.\n                 apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                 p $ i $ 3 \\<and>\n                 (\\<forall>j'.\n                     apply_cltn2 (proj2_abs (axis j' 1)) D =\n                     (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n          0))\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        1)) =\n    p $ 1 $ j", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (p $ 0 $ j)\n   (cltn2_compose\n     (cltn2_inverse\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        0))\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      1)) =\n  p $ 1 $ j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  apply_cltn2 (p $ 0 $ j)\n   (cltn2_compose\n     (cltn2_inverse\n       ((\\<chi>i.\n            SOME D.\n               apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n               p $ i $ 3 \\<and>\n               (\\<forall>j'.\n                   apply_cltn2 (proj2_abs (axis j' 1)) D =\n                   (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n        0))\n     ((\\<chi>i.\n          SOME D.\n             apply_cltn2 (proj2_abs (vector [1, 1, 1])) D = p $ i $ 3 \\<and>\n             (\\<forall>j'.\n                 apply_cltn2 (proj2_abs (axis j' 1)) D =\n                 (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n      1)) =\n  p $ 1 $ j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j.\n     apply_cltn2 (p $ 0 $ j)\n      (cltn2_compose\n        (cltn2_inverse\n          ((\\<chi>i.\n               SOME D.\n                  apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                  p $ i $ 3 \\<and>\n                  (\\<forall>j'.\n                      apply_cltn2 (proj2_abs (axis j' 1)) D =\n                      (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n           0))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         1)) =\n     p $ 1 $ j\n\ngoal (1 subgoal):\n 1. \\<exists>C. \\<forall>j. apply_cltn2 (p $ 0 $ j) C = p $ 1 $ j", "thus \"\\<exists> C. \\<forall> j. apply_cltn2 (p$0$j) C = p$1$j\""], ["proof (prove)\nusing this:\n  \\<forall>j.\n     apply_cltn2 (p $ 0 $ j)\n      (cltn2_compose\n        (cltn2_inverse\n          ((\\<chi>i.\n               SOME D.\n                  apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                  p $ i $ 3 \\<and>\n                  (\\<forall>j'.\n                      apply_cltn2 (proj2_abs (axis j' 1)) D =\n                      (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n           0))\n        ((\\<chi>i.\n             SOME D.\n                apply_cltn2 (proj2_abs (vector [1, 1, 1])) D =\n                p $ i $ 3 \\<and>\n                (\\<forall>j'.\n                    apply_cltn2 (proj2_abs (axis j' 1)) D =\n                    (\\<chi>i j. p $ i $ of_int (Rep_bit1 j)) $ i $ j')) $\n         1)) =\n     p $ 1 $ j\n\ngoal (1 subgoal):\n 1. \\<exists>C. \\<forall>j. apply_cltn2 (p $ 0 $ j) C = p $ 1 $ j", "by (rule exI [of _ ?C])"], ["proof (state)\nthis:\n  \\<exists>C. \\<forall>j. apply_cltn2 (p $ 0 $ j) C = p $ 1 $ j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_cltn2_linear:\n  assumes \"j *\\<^sub>R v + k *\\<^sub>R w \\<noteq> 0\"\n  shows \"j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) \\<noteq> 0\"\n  (is \"?u \\<noteq> 0\")\n  and \"apply_cltn2 (proj2_abs (j *\\<^sub>R v + k *\\<^sub>R w)) C\n  = proj2_abs (j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) \\<noteq>\n    0 &&&\n    apply_cltn2 (proj2_abs (j *\\<^sub>R v + k *\\<^sub>R w)) C =\n    proj2_abs\n     (j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) \\<noteq>\n    0\n 2. apply_cltn2 (proj2_abs (j *\\<^sub>R v + k *\\<^sub>R w)) C =\n    proj2_abs\n     (j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C))", "have \"?u = (j *\\<^sub>R v + k *\\<^sub>R w) v* cltn2_rep C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) =\n    (j *\\<^sub>R v + k *\\<^sub>R w) v* cltn2_rep C", "by (simp only: vector_matrix_left_distrib scaleR_vector_matrix_assoc)"], ["proof (state)\nthis:\n  j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) =\n  (j *\\<^sub>R v + k *\\<^sub>R w) v* cltn2_rep C\n\ngoal (2 subgoals):\n 1. j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) \\<noteq>\n    0\n 2. apply_cltn2 (proj2_abs (j *\\<^sub>R v + k *\\<^sub>R w)) C =\n    proj2_abs\n     (j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C))", "with \\<open>j *\\<^sub>R v + k *\\<^sub>R w \\<noteq> 0\\<close> and non_zero_mult_rep_non_zero"], ["proof (chain)\npicking this:\n  j *\\<^sub>R v + k *\\<^sub>R w \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow> ?v v* cltn2_rep ?C \\<noteq> 0\n  j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) =\n  (j *\\<^sub>R v + k *\\<^sub>R w) v* cltn2_rep C", "show \"?u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  j *\\<^sub>R v + k *\\<^sub>R w \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow> ?v v* cltn2_rep ?C \\<noteq> 0\n  j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) =\n  (j *\\<^sub>R v + k *\\<^sub>R w) v* cltn2_rep C\n\ngoal (1 subgoal):\n 1. j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) \\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs (j *\\<^sub>R v + k *\\<^sub>R w)) C =\n    proj2_abs\n     (j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C))", "from \\<open>?u = (j *\\<^sub>R v + k *\\<^sub>R w) v* cltn2_rep C\\<close>\n    and \\<open>j *\\<^sub>R v + k *\\<^sub>R w \\<noteq> 0\\<close>\n    and apply_cltn2_left_abs"], ["proof (chain)\npicking this:\n  j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) =\n  (j *\\<^sub>R v + k *\\<^sub>R w) v* cltn2_rep C\n  j *\\<^sub>R v + k *\\<^sub>R w \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  apply_cltn2 (proj2_abs ?v) ?C = proj2_abs (?v v* cltn2_rep ?C)", "show \"apply_cltn2 (proj2_abs (j *\\<^sub>R v + k *\\<^sub>R w)) C = proj2_abs ?u\""], ["proof (prove)\nusing this:\n  j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C) =\n  (j *\\<^sub>R v + k *\\<^sub>R w) v* cltn2_rep C\n  j *\\<^sub>R v + k *\\<^sub>R w \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  apply_cltn2 (proj2_abs ?v) ?C = proj2_abs (?v v* cltn2_rep ?C)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (proj2_abs (j *\\<^sub>R v + k *\\<^sub>R w)) C =\n    proj2_abs\n     (j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C))", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (proj2_abs (j *\\<^sub>R v + k *\\<^sub>R w)) C =\n  proj2_abs\n   (j *\\<^sub>R (v v* cltn2_rep C) + k *\\<^sub>R (w v* cltn2_rep C))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_cltn2_imp_mult:\n  assumes \"apply_cltn2 p C = q\"\n  shows \"\\<exists> k. k \\<noteq> 0 \\<and> proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q", "have \"proj2_rep p v* cltn2_rep C \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep p v* cltn2_rep C \\<noteq> 0", "by (rule rep_mult_rep_non_zero)"], ["proof (state)\nthis:\n  proj2_rep p v* cltn2_rep C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q", "from \\<open>apply_cltn2 p C = q\\<close>"], ["proof (chain)\npicking this:\n  apply_cltn2 p C = q", "have \"proj2_abs (proj2_rep p v* cltn2_rep C) = q\""], ["proof (prove)\nusing this:\n  apply_cltn2 p C = q\n\ngoal (1 subgoal):\n 1. proj2_abs (proj2_rep p v* cltn2_rep C) = q", "by (unfold apply_cltn2_def)"], ["proof (state)\nthis:\n  proj2_abs (proj2_rep p v* cltn2_rep C) = q\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q", "hence \"proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep C)) = proj2_rep q\""], ["proof (prove)\nusing this:\n  proj2_abs (proj2_rep p v* cltn2_rep C) = q\n\ngoal (1 subgoal):\n 1. proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep C)) = proj2_rep q", "by simp"], ["proof (state)\nthis:\n  proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep C)) = proj2_rep q\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q", "with \\<open>proj2_rep p v* cltn2_rep C \\<noteq> 0\\<close> and proj2_rep_abs2 [of \"proj2_rep p v* cltn2_rep C\"]"], ["proof (chain)\npicking this:\n  proj2_rep p v* cltn2_rep C \\<noteq> 0\n  proj2_rep p v* cltn2_rep C \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep C)) =\n     k *\\<^sub>R (proj2_rep p v* cltn2_rep C)\n  proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep C)) = proj2_rep q", "have \"\\<exists> j. j \\<noteq> 0 \\<and> proj2_rep q = j *\\<^sub>R (proj2_rep p v* cltn2_rep C)\""], ["proof (prove)\nusing this:\n  proj2_rep p v* cltn2_rep C \\<noteq> 0\n  proj2_rep p v* cltn2_rep C \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep C)) =\n     k *\\<^sub>R (proj2_rep p v* cltn2_rep C)\n  proj2_rep (proj2_abs (proj2_rep p v* cltn2_rep C)) = proj2_rep q\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j \\<noteq> 0 \\<and>\n       proj2_rep q = j *\\<^sub>R (proj2_rep p v* cltn2_rep C)", "by simp"], ["proof (state)\nthis:\n  \\<exists>j.\n     j \\<noteq> 0 \\<and>\n     proj2_rep q = j *\\<^sub>R (proj2_rep p v* cltn2_rep C)\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q", "then"], ["proof (chain)\npicking this:\n  \\<exists>j.\n     j \\<noteq> 0 \\<and>\n     proj2_rep q = j *\\<^sub>R (proj2_rep p v* cltn2_rep C)", "obtain j where \"j \\<noteq> 0\"\n    and \"proj2_rep q = j *\\<^sub>R (proj2_rep p v* cltn2_rep C)\""], ["proof (prove)\nusing this:\n  \\<exists>j.\n     j \\<noteq> 0 \\<and>\n     proj2_rep q = j *\\<^sub>R (proj2_rep p v* cltn2_rep C)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<noteq> 0;\n         proj2_rep q = j *\\<^sub>R (proj2_rep p v* cltn2_rep C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<noteq> 0\n  proj2_rep q = j *\\<^sub>R (proj2_rep p v* cltn2_rep C)\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q", "hence \"proj2_rep p v* cltn2_rep C = (1/j) *\\<^sub>R proj2_rep q\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  proj2_rep q = j *\\<^sub>R (proj2_rep p v* cltn2_rep C)\n\ngoal (1 subgoal):\n 1. proj2_rep p v* cltn2_rep C = (1 / j) *\\<^sub>R proj2_rep q", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  proj2_rep p v* cltn2_rep C = (1 / j) *\\<^sub>R proj2_rep q\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q", "with \\<open>j \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  j \\<noteq> 0\n  proj2_rep p v* cltn2_rep C = (1 / j) *\\<^sub>R proj2_rep q", "show \"\\<exists> k. k \\<noteq> 0 \\<and> proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  proj2_rep p v* cltn2_rep C = (1 / j) *\\<^sub>R proj2_rep q\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q", "by (simp add: exI [of _ \"1/j\"])"], ["proof (state)\nthis:\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma statement55:\n  assumes \"p \\<noteq> q\"\n  and \"apply_cltn2 p C = q\"\n  and \"apply_cltn2 q C = p\"\n  and \"proj2_incident p l\"\n  and \"proj2_incident q l\"\n  and \"proj2_incident r l\"\n  shows \"apply_cltn2 (apply_cltn2 r C) C = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 r C) C = r", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r\n 2. \\<not> ?P \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "assume \"r = p\""], ["proof (state)\nthis:\n  r = p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r\n 2. \\<not> ?P \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "with \\<open>apply_cltn2 p C = q\\<close> and \\<open>apply_cltn2 q C = p\\<close>"], ["proof (chain)\npicking this:\n  apply_cltn2 p C = q\n  apply_cltn2 q C = p\n  r = p", "show \"apply_cltn2 (apply_cltn2 r C) C = r\""], ["proof (prove)\nusing this:\n  apply_cltn2 p C = q\n  apply_cltn2 q C = p\n  r = p\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 r C) C = r", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (apply_cltn2 r C) C = r\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "assume \"r \\<noteq> p\""], ["proof (state)\nthis:\n  r \\<noteq> p\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "from \\<open>apply_cltn2 p C = q\\<close> and apply_cltn2_imp_mult [of p C q]"], ["proof (chain)\npicking this:\n  apply_cltn2 p C = q\n  apply_cltn2 p C = q \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q", "obtain i where \"i \\<noteq> 0\" and \"proj2_rep p v* cltn2_rep C = i *\\<^sub>R proj2_rep q\""], ["proof (prove)\nusing this:\n  apply_cltn2 p C = q\n  apply_cltn2 p C = q \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_rep p v* cltn2_rep C = k *\\<^sub>R proj2_rep q\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<noteq> 0;\n         proj2_rep p v* cltn2_rep C = i *\\<^sub>R proj2_rep q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> 0\n  proj2_rep p v* cltn2_rep C = i *\\<^sub>R proj2_rep q\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "from \\<open>apply_cltn2 q C = p\\<close> and apply_cltn2_imp_mult [of q C p]"], ["proof (chain)\npicking this:\n  apply_cltn2 q C = p\n  apply_cltn2 q C = p \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_rep q v* cltn2_rep C = k *\\<^sub>R proj2_rep p", "obtain j where \"j \\<noteq> 0\" and \"proj2_rep q v* cltn2_rep C = j *\\<^sub>R proj2_rep p\""], ["proof (prove)\nusing this:\n  apply_cltn2 q C = p\n  apply_cltn2 q C = p \\<Longrightarrow>\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     proj2_rep q v* cltn2_rep C = k *\\<^sub>R proj2_rep p\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<noteq> 0;\n         proj2_rep q v* cltn2_rep C = j *\\<^sub>R proj2_rep p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<noteq> 0\n  proj2_rep q v* cltn2_rep C = j *\\<^sub>R proj2_rep p\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "from \\<open>p \\<noteq> q\\<close>\n    and \\<open>proj2_incident p l\\<close>\n    and \\<open>proj2_incident q l\\<close>\n    and \\<open>proj2_incident r l\\<close>\n    and proj2_incident_iff"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident r l\n  \\<lbrakk>?p \\<noteq> ?q; proj2_incident ?p ?l;\n   proj2_incident ?q ?l\\<rbrakk>\n  \\<Longrightarrow> proj2_incident ?r ?l =\n                    (?r = ?p \\<or>\n                     (\\<exists>k.\n                         ?r =\n                         proj2_abs\n                          (k *\\<^sub>R proj2_rep ?p + proj2_rep ?q)))", "have \"r = p \\<or> (\\<exists> k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q))\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident r l\n  \\<lbrakk>?p \\<noteq> ?q; proj2_incident ?p ?l;\n   proj2_incident ?q ?l\\<rbrakk>\n  \\<Longrightarrow> proj2_incident ?r ?l =\n                    (?r = ?p \\<or>\n                     (\\<exists>k.\n                         ?r =\n                         proj2_abs\n                          (k *\\<^sub>R proj2_rep ?p + proj2_rep ?q)))\n\ngoal (1 subgoal):\n 1. r = p \\<or>\n    (\\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q))", "by fast"], ["proof (state)\nthis:\n  r = p \\<or>\n  (\\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q))\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "with \\<open>r \\<noteq> p\\<close>"], ["proof (chain)\npicking this:\n  r \\<noteq> p\n  r = p \\<or>\n  (\\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q))", "obtain k where \"r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\""], ["proof (prove)\nusing this:\n  r \\<noteq> p\n  r = p \\<or>\n  (\\<exists>k. r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        r =\n        proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "from \\<open>p \\<noteq> q\\<close> and proj2_rep_dependent [of k p 1 q]"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  \\<lbrakk>k *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q = 0;\n   k \\<noteq> 0 \\<or> 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> p = q", "have \"k *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  \\<lbrakk>k *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q = 0;\n   k \\<noteq> 0 \\<or> 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> p = q\n\ngoal (1 subgoal):\n 1. k *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "with \\<open>r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\\<close>\n    and apply_cltn2_linear [of k \"proj2_rep p\" 1 \"proj2_rep q\"]"], ["proof (chain)\npicking this:\n  r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\n  k *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  k *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n  1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C) \\<noteq>\n  0\n  k *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  apply_cltn2\n   (proj2_abs (k *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q)) ?C =\n  proj2_abs\n   (k *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n    1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C))\n  k *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0", "have \"k *\\<^sub>R (proj2_rep p v* cltn2_rep C) + proj2_rep q v* cltn2_rep C \\<noteq> 0\"\n    and \"apply_cltn2 r C\n    = proj2_abs\n    (k *\\<^sub>R (proj2_rep p v* cltn2_rep C) + proj2_rep q v* cltn2_rep C)\""], ["proof (prove)\nusing this:\n  r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\n  k *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  k *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n  1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C) \\<noteq>\n  0\n  k *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  apply_cltn2\n   (proj2_abs (k *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q)) ?C =\n  proj2_abs\n   (k *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n    1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C))\n  k *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n    proj2_rep q v* cltn2_rep C \\<noteq>\n    0 &&&\n    apply_cltn2 r C =\n    proj2_abs\n     (k *\\<^sub>R (proj2_rep p v* cltn2_rep C) + proj2_rep q v* cltn2_rep C)", "by simp_all"], ["proof (state)\nthis:\n  k *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n  proj2_rep q v* cltn2_rep C \\<noteq>\n  0\n  apply_cltn2 r C =\n  proj2_abs\n   (k *\\<^sub>R (proj2_rep p v* cltn2_rep C) + proj2_rep q v* cltn2_rep C)\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "with \\<open>proj2_rep p v* cltn2_rep C = i *\\<^sub>R proj2_rep q\\<close>\n    and \\<open>proj2_rep q v* cltn2_rep C = j *\\<^sub>R proj2_rep p\\<close>"], ["proof (chain)\npicking this:\n  proj2_rep p v* cltn2_rep C = i *\\<^sub>R proj2_rep q\n  proj2_rep q v* cltn2_rep C = j *\\<^sub>R proj2_rep p\n  k *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n  proj2_rep q v* cltn2_rep C \\<noteq>\n  0\n  apply_cltn2 r C =\n  proj2_abs\n   (k *\\<^sub>R (proj2_rep p v* cltn2_rep C) + proj2_rep q v* cltn2_rep C)", "have \"(k * i) *\\<^sub>R proj2_rep q + j *\\<^sub>R proj2_rep p \\<noteq> 0\"\n    and \"apply_cltn2 r C\n    = proj2_abs ((k * i) *\\<^sub>R proj2_rep q + j *\\<^sub>R proj2_rep p)\""], ["proof (prove)\nusing this:\n  proj2_rep p v* cltn2_rep C = i *\\<^sub>R proj2_rep q\n  proj2_rep q v* cltn2_rep C = j *\\<^sub>R proj2_rep p\n  k *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n  proj2_rep q v* cltn2_rep C \\<noteq>\n  0\n  apply_cltn2 r C =\n  proj2_abs\n   (k *\\<^sub>R (proj2_rep p v* cltn2_rep C) + proj2_rep q v* cltn2_rep C)\n\ngoal (1 subgoal):\n 1. (k * i) *\\<^sub>R proj2_rep q + j *\\<^sub>R proj2_rep p \\<noteq> 0 &&&\n    apply_cltn2 r C =\n    proj2_abs ((k * i) *\\<^sub>R proj2_rep q + j *\\<^sub>R proj2_rep p)", "by simp_all"], ["proof (state)\nthis:\n  (k * i) *\\<^sub>R proj2_rep q + j *\\<^sub>R proj2_rep p \\<noteq> 0\n  apply_cltn2 r C =\n  proj2_abs ((k * i) *\\<^sub>R proj2_rep q + j *\\<^sub>R proj2_rep p)\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "with apply_cltn2_linear"], ["proof (chain)\npicking this:\n  ?j *\\<^sub>R ?v + ?k *\\<^sub>R ?w \\<noteq> 0 \\<Longrightarrow>\n  ?j *\\<^sub>R (?v v* cltn2_rep ?C) +\n  ?k *\\<^sub>R (?w v* cltn2_rep ?C) \\<noteq>\n  0\n  ?j *\\<^sub>R ?v + ?k *\\<^sub>R ?w \\<noteq> 0 \\<Longrightarrow>\n  apply_cltn2 (proj2_abs (?j *\\<^sub>R ?v + ?k *\\<^sub>R ?w)) ?C =\n  proj2_abs\n   (?j *\\<^sub>R (?v v* cltn2_rep ?C) + ?k *\\<^sub>R (?w v* cltn2_rep ?C))\n  (k * i) *\\<^sub>R proj2_rep q + j *\\<^sub>R proj2_rep p \\<noteq> 0\n  apply_cltn2 r C =\n  proj2_abs ((k * i) *\\<^sub>R proj2_rep q + j *\\<^sub>R proj2_rep p)", "have \"apply_cltn2 (apply_cltn2 r C) C\n    = proj2_abs\n    ((k * i) *\\<^sub>R (proj2_rep q v* cltn2_rep C)\n    + j *\\<^sub>R (proj2_rep p v* cltn2_rep C))\""], ["proof (prove)\nusing this:\n  ?j *\\<^sub>R ?v + ?k *\\<^sub>R ?w \\<noteq> 0 \\<Longrightarrow>\n  ?j *\\<^sub>R (?v v* cltn2_rep ?C) +\n  ?k *\\<^sub>R (?w v* cltn2_rep ?C) \\<noteq>\n  0\n  ?j *\\<^sub>R ?v + ?k *\\<^sub>R ?w \\<noteq> 0 \\<Longrightarrow>\n  apply_cltn2 (proj2_abs (?j *\\<^sub>R ?v + ?k *\\<^sub>R ?w)) ?C =\n  proj2_abs\n   (?j *\\<^sub>R (?v v* cltn2_rep ?C) + ?k *\\<^sub>R (?w v* cltn2_rep ?C))\n  (k * i) *\\<^sub>R proj2_rep q + j *\\<^sub>R proj2_rep p \\<noteq> 0\n  apply_cltn2 r C =\n  proj2_abs ((k * i) *\\<^sub>R proj2_rep q + j *\\<^sub>R proj2_rep p)\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 r C) C =\n    proj2_abs\n     ((k * i) *\\<^sub>R (proj2_rep q v* cltn2_rep C) +\n      j *\\<^sub>R (proj2_rep p v* cltn2_rep C))", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (apply_cltn2 r C) C =\n  proj2_abs\n   ((k * i) *\\<^sub>R (proj2_rep q v* cltn2_rep C) +\n    j *\\<^sub>R (proj2_rep p v* cltn2_rep C))\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "with \\<open>proj2_rep p v* cltn2_rep C = i *\\<^sub>R proj2_rep q\\<close>\n    and \\<open>proj2_rep q v* cltn2_rep C = j *\\<^sub>R proj2_rep p\\<close>"], ["proof (chain)\npicking this:\n  proj2_rep p v* cltn2_rep C = i *\\<^sub>R proj2_rep q\n  proj2_rep q v* cltn2_rep C = j *\\<^sub>R proj2_rep p\n  apply_cltn2 (apply_cltn2 r C) C =\n  proj2_abs\n   ((k * i) *\\<^sub>R (proj2_rep q v* cltn2_rep C) +\n    j *\\<^sub>R (proj2_rep p v* cltn2_rep C))", "have \"apply_cltn2 (apply_cltn2 r C) C\n    = proj2_abs ((k * i * j) *\\<^sub>R proj2_rep p + (j * i) *\\<^sub>R proj2_rep q)\""], ["proof (prove)\nusing this:\n  proj2_rep p v* cltn2_rep C = i *\\<^sub>R proj2_rep q\n  proj2_rep q v* cltn2_rep C = j *\\<^sub>R proj2_rep p\n  apply_cltn2 (apply_cltn2 r C) C =\n  proj2_abs\n   ((k * i) *\\<^sub>R (proj2_rep q v* cltn2_rep C) +\n    j *\\<^sub>R (proj2_rep p v* cltn2_rep C))\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 r C) C =\n    proj2_abs\n     ((k * i * j) *\\<^sub>R proj2_rep p + (j * i) *\\<^sub>R proj2_rep q)", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 (apply_cltn2 r C) C =\n  proj2_abs\n   ((k * i * j) *\\<^sub>R proj2_rep p + (j * i) *\\<^sub>R proj2_rep q)\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "also"], ["proof (state)\nthis:\n  apply_cltn2 (apply_cltn2 r C) C =\n  proj2_abs\n   ((k * i * j) *\\<^sub>R proj2_rep p + (j * i) *\\<^sub>R proj2_rep q)\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "have \"\\<dots> = proj2_abs ((i * j) *\\<^sub>R (k *\\<^sub>R proj2_rep p + proj2_rep q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_abs\n     ((k * i * j) *\\<^sub>R proj2_rep p + (j * i) *\\<^sub>R proj2_rep q) =\n    proj2_abs ((i * j) *\\<^sub>R (k *\\<^sub>R proj2_rep p + proj2_rep q))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  proj2_abs\n   ((k * i * j) *\\<^sub>R proj2_rep p + (j * i) *\\<^sub>R proj2_rep q) =\n  proj2_abs ((i * j) *\\<^sub>R (k *\\<^sub>R proj2_rep p + proj2_rep q))\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "also"], ["proof (state)\nthis:\n  proj2_abs\n   ((k * i * j) *\\<^sub>R proj2_rep p + (j * i) *\\<^sub>R proj2_rep q) =\n  proj2_abs ((i * j) *\\<^sub>R (k *\\<^sub>R proj2_rep p + proj2_rep q))\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "from \\<open>i \\<noteq> 0\\<close> and \\<open>j \\<noteq> 0\\<close> and proj2_abs_mult"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  j \\<noteq> 0\n  ?c \\<noteq> 0 \\<Longrightarrow> proj2_abs (?c *\\<^sub>R ?v) = proj2_abs ?v", "have \"\\<dots> = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  j \\<noteq> 0\n  ?c \\<noteq> 0 \\<Longrightarrow> proj2_abs (?c *\\<^sub>R ?v) = proj2_abs ?v\n\ngoal (1 subgoal):\n 1. proj2_abs ((i * j) *\\<^sub>R (k *\\<^sub>R proj2_rep p + proj2_rep q)) =\n    proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)", "by simp"], ["proof (state)\nthis:\n  proj2_abs ((i * j) *\\<^sub>R (k *\\<^sub>R proj2_rep p + proj2_rep q)) =\n  proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "also"], ["proof (state)\nthis:\n  proj2_abs ((i * j) *\\<^sub>R (k *\\<^sub>R proj2_rep p + proj2_rep q)) =\n  proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "from \\<open>r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\\<close>"], ["proof (chain)\npicking this:\n  r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)", "have \"\\<dots> = r\""], ["proof (prove)\nusing this:\n  r = proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q) = r", "by simp"], ["proof (state)\nthis:\n  proj2_abs (k *\\<^sub>R proj2_rep p + proj2_rep q) = r\n\ngoal (1 subgoal):\n 1. r \\<noteq> p \\<Longrightarrow> apply_cltn2 (apply_cltn2 r C) C = r", "finally"], ["proof (chain)\npicking this:\n  apply_cltn2 (apply_cltn2 r C) C = r", "show \"apply_cltn2 (apply_cltn2 r C) C = r\""], ["proof (prove)\nusing this:\n  apply_cltn2 (apply_cltn2 r C) C = r\n\ngoal (1 subgoal):\n 1. apply_cltn2 (apply_cltn2 r C) C = r", "."], ["proof (state)\nthis:\n  apply_cltn2 (apply_cltn2 r C) C = r\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Cross ratios\""], ["", "definition cross_ratio :: \"proj2 \\<Rightarrow> proj2 \\<Rightarrow> proj2 \\<Rightarrow> proj2 \\<Rightarrow> real\" where\n  \"cross_ratio p q r s \\<equiv> proj2_Col_coeff p q s / proj2_Col_coeff p q r\""], ["", "definition cross_ratio_correct :: \"proj2 \\<Rightarrow> proj2 \\<Rightarrow> proj2 \\<Rightarrow> proj2 \\<Rightarrow> bool\" where\n  \"cross_ratio_correct p q r s \\<equiv>\n  proj2_set_Col {p,q,r,s} \\<and> p \\<noteq> q \\<and> r \\<noteq> p \\<and> s \\<noteq> p \\<and> r \\<noteq> q\""], ["", "lemma proj2_Col_coeff_abs:\n  assumes \"p \\<noteq> q\" and \"j \\<noteq> 0\"\n  shows \"proj2_Col_coeff p q (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q))\n  = i/j\"\n  (is \"proj2_Col_coeff p q ?r = i/j\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    i / j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    i / j", "from \\<open>j \\<noteq> 0\\<close>\n    and proj2_abs_mult [of \"1/j\" \"i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q\"]"], ["proof (chain)\npicking this:\n  j \\<noteq> 0\n  1 / j \\<noteq> 0 \\<Longrightarrow>\n  proj2_abs\n   ((1 / j) *\\<^sub>R (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)", "have \"?r = proj2_abs ((i/j) *\\<^sub>R proj2_rep p + proj2_rep q)\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  1 / j \\<noteq> 0 \\<Longrightarrow>\n  proj2_abs\n   ((1 / j) *\\<^sub>R (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)\n\ngoal (1 subgoal):\n 1. proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n    proj2_abs ((i / j) *\\<^sub>R proj2_rep p + proj2_rep q)", "by (simp add: scaleR_right_distrib)"], ["proof (state)\nthis:\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n  proj2_abs ((i / j) *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    i / j", "from \\<open>p \\<noteq> q\\<close> and proj2_rep_dependent [of _ p 1 q]"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  \\<lbrakk>?i *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q = 0;\n   ?i \\<noteq> 0 \\<or> 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> p = q", "have \"(i/j) *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  \\<lbrakk>?i *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q = 0;\n   ?i \\<noteq> 0 \\<or> 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> p = q\n\ngoal (1 subgoal):\n 1. (i / j) *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (i / j) *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    i / j", "with \\<open>?r = proj2_abs ((i/j) *\\<^sub>R proj2_rep p + proj2_rep q)\\<close>\n    and proj2_rep_abs2"], ["proof (chain)\npicking this:\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n  proj2_abs ((i / j) *\\<^sub>R proj2_rep p + proj2_rep q)\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  (i / j) *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0", "obtain k where \"k \\<noteq> 0\"\n    and \"proj2_rep ?r = k *\\<^sub>R ((i/j) *\\<^sub>R proj2_rep p + proj2_rep q)\""], ["proof (prove)\nusing this:\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n  proj2_abs ((i / j) *\\<^sub>R proj2_rep p + proj2_rep q)\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n  (i / j) *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<noteq> 0;\n         proj2_rep\n          (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n         k *\\<^sub>R ((i / j) *\\<^sub>R proj2_rep p + proj2_rep q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  proj2_rep\n   (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n  k *\\<^sub>R ((i / j) *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    i / j", "hence \"(k*i/j) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q - proj2_rep ?r = 0\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  proj2_rep\n   (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n  k *\\<^sub>R ((i / j) *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. (k * i / j) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q -\n    proj2_rep\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    0", "by (simp add: scaleR_right_distrib)"], ["proof (state)\nthis:\n  (k * i / j) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q -\n  proj2_rep\n   (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n  0\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    i / j", "hence \"\\<exists> l. (k*i/j) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q + l *\\<^sub>R proj2_rep ?r = 0\n    \\<and> (k*i/j \\<noteq> 0 \\<or> k \\<noteq> 0 \\<or> l \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  (k * i / j) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q -\n  proj2_rep\n   (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       (k * i / j) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q +\n       l *\\<^sub>R\n       proj2_rep\n        (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n       0 \\<and>\n       (k * i / j \\<noteq> 0 \\<or> k \\<noteq> 0 \\<or> l \\<noteq> 0)", "by (simp add: exI [of _ \"-1\"])"], ["proof (state)\nthis:\n  \\<exists>l.\n     (k * i / j) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q +\n     l *\\<^sub>R\n     proj2_rep\n      (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n     0 \\<and>\n     (k * i / j \\<noteq> 0 \\<or> k \\<noteq> 0 \\<or> l \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    i / j", "hence \"proj2_Col p q ?r\""], ["proof (prove)\nusing this:\n  \\<exists>l.\n     (k * i / j) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q +\n     l *\\<^sub>R\n     proj2_rep\n      (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n     0 \\<and>\n     (k * i / j \\<noteq> 0 \\<or> k \\<noteq> 0 \\<or> l \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. proj2_Col p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q))", "by (unfold proj2_Col_def) auto"], ["proof (state)\nthis:\n  proj2_Col p q\n   (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q))\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    i / j", "have \"?r \\<noteq> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) \\<noteq> p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n    p \\<Longrightarrow>\n    False", "assume \"?r = p\""], ["proof (state)\nthis:\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) = p\n\ngoal (1 subgoal):\n 1. proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n    p \\<Longrightarrow>\n    False", "with \\<open>(k*i/j) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q - proj2_rep ?r = 0\\<close>"], ["proof (chain)\npicking this:\n  (k * i / j) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q -\n  proj2_rep\n   (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n  0\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) = p", "have \"(k*i/j - 1) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q = 0\""], ["proof (prove)\nusing this:\n  (k * i / j) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q -\n  proj2_rep\n   (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n  0\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) = p\n\ngoal (1 subgoal):\n 1. (k * i / j - 1) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q = 0", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (k * i / j - 1) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q = 0\n\ngoal (1 subgoal):\n 1. proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n    p \\<Longrightarrow>\n    False", "with \\<open>k \\<noteq> 0\\<close> and proj2_rep_dependent"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  \\<lbrakk>?i *\\<^sub>R proj2_rep ?v + ?j *\\<^sub>R proj2_rep ?w = 0;\n   ?i \\<noteq> 0 \\<or> ?j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  (k * i / j - 1) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q = 0", "have \"p = q\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  \\<lbrakk>?i *\\<^sub>R proj2_rep ?v + ?j *\\<^sub>R proj2_rep ?w = 0;\n   ?i \\<noteq> 0 \\<or> ?j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  (k * i / j - 1) *\\<^sub>R proj2_rep p + k *\\<^sub>R proj2_rep q = 0\n\ngoal (1 subgoal):\n 1. p = q", "by simp"], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n    p \\<Longrightarrow>\n    False", "with \\<open>p \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  p = q", "show False"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  p = q\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) \\<noteq> p\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    i / j", "with \\<open>proj2_Col p q ?r\\<close> and \\<open>p \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  proj2_Col p q\n   (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q))\n  p \\<noteq> q\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) \\<noteq> p", "have \"?r = proj2_abs (proj2_Col_coeff p q ?r *\\<^sub>R proj2_rep p + proj2_rep q)\""], ["proof (prove)\nusing this:\n  proj2_Col p q\n   (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q))\n  p \\<noteq> q\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) \\<noteq> p\n\ngoal (1 subgoal):\n 1. proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n    proj2_abs\n     (proj2_Col_coeff p q\n       (proj2_abs\n         (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) *\\<^sub>R\n      proj2_rep p +\n      proj2_rep q)", "by (rule proj2_Col_coeff)"], ["proof (state)\nthis:\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n  proj2_abs\n   (proj2_Col_coeff p q\n     (proj2_abs\n       (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) *\\<^sub>R\n    proj2_rep p +\n    proj2_rep q)\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    i / j", "with \\<open>p \\<noteq> q\\<close> and \\<open>?r = proj2_abs ((i/j) *\\<^sub>R proj2_rep p + proj2_rep q)\\<close>\n    and proj2_Col_coeff_unique"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n  proj2_abs ((i / j) *\\<^sub>R proj2_rep p + proj2_rep q)\n  \\<lbrakk>?a \\<noteq> ?r;\n   proj2_abs (?i *\\<^sub>R proj2_rep ?a + proj2_rep ?r) =\n   proj2_abs (?j *\\<^sub>R proj2_rep ?a + proj2_rep ?r)\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n  proj2_abs\n   (proj2_Col_coeff p q\n     (proj2_abs\n       (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) *\\<^sub>R\n    proj2_rep p +\n    proj2_rep q)", "show \"proj2_Col_coeff p q ?r = i/j\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n  proj2_abs ((i / j) *\\<^sub>R proj2_rep p + proj2_rep q)\n  \\<lbrakk>?a \\<noteq> ?r;\n   proj2_abs (?i *\\<^sub>R proj2_rep ?a + proj2_rep ?r) =\n   proj2_abs (?j *\\<^sub>R proj2_rep ?a + proj2_rep ?r)\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j\n  proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q) =\n  proj2_abs\n   (proj2_Col_coeff p q\n     (proj2_abs\n       (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) *\\<^sub>R\n    proj2_rep p +\n    proj2_rep q)\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q\n     (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n    i / j", "by simp"], ["proof (state)\nthis:\n  proj2_Col_coeff p q\n   (proj2_abs (i *\\<^sub>R proj2_rep p + j *\\<^sub>R proj2_rep q)) =\n  i / j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_set_Col_coeff:\n  assumes \"proj2_set_Col S\" and \"{p,q,r} \\<subseteq> S\" and \"p \\<noteq> q\" and \"r \\<noteq> p\"\n  shows \"r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\"\n  (is \"r = proj2_abs (?i *\\<^sub>R ?u + ?v)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. r =\n    proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r =\n    proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)", "from \\<open>{p,q,r} \\<subseteq> S\\<close> and \\<open>proj2_set_Col S\\<close>"], ["proof (chain)\npicking this:\n  {p, q, r} \\<subseteq> S\n  proj2_set_Col S", "have \"proj2_set_Col {p,q,r}\""], ["proof (prove)\nusing this:\n  {p, q, r} \\<subseteq> S\n  proj2_set_Col S\n\ngoal (1 subgoal):\n 1. proj2_set_Col {p, q, r}", "by (rule proj2_subset_Col)"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. r =\n    proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)", "hence \"proj2_Col p q r\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. proj2_Col p q r", "by (subst proj2_Col_iff_set_Col)"], ["proof (state)\nthis:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. r =\n    proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)", "with \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and proj2_Col_coeff"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  r \\<noteq> p\n  \\<lbrakk>proj2_Col ?a ?r ?t; ?a \\<noteq> ?r; ?t \\<noteq> ?a\\<rbrakk>\n  \\<Longrightarrow> ?t =\n                    proj2_abs\n                     (proj2_Col_coeff ?a ?r ?t *\\<^sub>R proj2_rep ?a +\n                      proj2_rep ?r)\n  proj2_Col p q r", "show \"r = proj2_abs (?i *\\<^sub>R ?u + ?v)\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  r \\<noteq> p\n  \\<lbrakk>proj2_Col ?a ?r ?t; ?a \\<noteq> ?r; ?t \\<noteq> ?a\\<rbrakk>\n  \\<Longrightarrow> ?t =\n                    proj2_abs\n                     (proj2_Col_coeff ?a ?r ?t *\\<^sub>R proj2_rep ?a +\n                      proj2_rep ?r)\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. r =\n    proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)", "by simp"], ["proof (state)\nthis:\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_ratio_abs:\n  fixes u v :: \"real^3\" and i j k l :: real\n  assumes \"u \\<noteq> 0\" and \"v \\<noteq> 0\" and \"proj2_abs u \\<noteq> proj2_abs v\"\n  and \"j \\<noteq> 0\" and \"l \\<noteq> 0\"\n  shows \"cross_ratio (proj2_abs u) (proj2_abs v)\n  (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v))\n  (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v))\n  = j * k / (i * l)\"\n  (is \"cross_ratio ?p ?q ?r ?s = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_ratio (proj2_abs u) (proj2_abs v)\n     (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v))\n     (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n    j * k / (i * l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio (proj2_abs u) (proj2_abs v)\n     (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v))\n     (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n    j * k / (i * l)", "from \\<open>u \\<noteq> 0\\<close> and proj2_rep_abs2"], ["proof (chain)\npicking this:\n  u \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v", "obtain g where \"g \\<noteq> 0\" and \"proj2_rep ?p = g *\\<^sub>R u\""], ["proof (prove)\nusing this:\n  u \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<noteq> 0;\n         proj2_rep (proj2_abs u) = g *\\<^sub>R u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n  proj2_rep (proj2_abs u) = g *\\<^sub>R u\n\ngoal (1 subgoal):\n 1. cross_ratio (proj2_abs u) (proj2_abs v)\n     (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v))\n     (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n    j * k / (i * l)", "from \\<open>v \\<noteq> 0\\<close> and proj2_rep_abs2"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v", "obtain h where \"h \\<noteq> 0\" and \"proj2_rep ?q = h *\\<^sub>R v\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  ?v \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>k. k \\<noteq> 0 \\<and> proj2_rep (proj2_abs ?v) = k *\\<^sub>R ?v\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<noteq> 0;\n         proj2_rep (proj2_abs v) = h *\\<^sub>R v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  h \\<noteq> 0\n  proj2_rep (proj2_abs v) = h *\\<^sub>R v\n\ngoal (1 subgoal):\n 1. cross_ratio (proj2_abs u) (proj2_abs v)\n     (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v))\n     (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n    j * k / (i * l)", "with \\<open>g \\<noteq> 0\\<close> and \\<open>proj2_rep ?p = g *\\<^sub>R u\\<close>"], ["proof (chain)\npicking this:\n  g \\<noteq> 0\n  proj2_rep (proj2_abs u) = g *\\<^sub>R u\n  h \\<noteq> 0\n  proj2_rep (proj2_abs v) = h *\\<^sub>R v", "have \"?r = proj2_abs ((i/g) *\\<^sub>R proj2_rep ?p + (j/h) *\\<^sub>R proj2_rep ?q)\"\n    and \"?s = proj2_abs ((k/g) *\\<^sub>R proj2_rep ?p + (l/h) *\\<^sub>R proj2_rep ?q)\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  proj2_rep (proj2_abs u) = g *\\<^sub>R u\n  h \\<noteq> 0\n  proj2_rep (proj2_abs v) = h *\\<^sub>R v\n\ngoal (1 subgoal):\n 1. proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v) =\n    proj2_abs\n     ((i / g) *\\<^sub>R proj2_rep (proj2_abs u) +\n      (j / h) *\\<^sub>R proj2_rep (proj2_abs v)) &&&\n    proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v) =\n    proj2_abs\n     ((k / g) *\\<^sub>R proj2_rep (proj2_abs u) +\n      (l / h) *\\<^sub>R proj2_rep (proj2_abs v))", "by (simp_all add: field_simps)"], ["proof (state)\nthis:\n  proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v) =\n  proj2_abs\n   ((i / g) *\\<^sub>R proj2_rep (proj2_abs u) +\n    (j / h) *\\<^sub>R proj2_rep (proj2_abs v))\n  proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v) =\n  proj2_abs\n   ((k / g) *\\<^sub>R proj2_rep (proj2_abs u) +\n    (l / h) *\\<^sub>R proj2_rep (proj2_abs v))\n\ngoal (1 subgoal):\n 1. cross_ratio (proj2_abs u) (proj2_abs v)\n     (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v))\n     (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n    j * k / (i * l)", "with \\<open>?p \\<noteq> ?q\\<close> and \\<open>h \\<noteq> 0\\<close> and \\<open>j \\<noteq> 0\\<close> and \\<open>l \\<noteq> 0\\<close> and proj2_Col_coeff_abs"], ["proof (chain)\npicking this:\n  proj2_abs u \\<noteq> proj2_abs v\n  h \\<noteq> 0\n  j \\<noteq> 0\n  l \\<noteq> 0\n  \\<lbrakk>?p \\<noteq> ?q; ?j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proj2_Col_coeff ?p ?q\n                     (proj2_abs\n                       (?i *\\<^sub>R proj2_rep ?p +\n                        ?j *\\<^sub>R proj2_rep ?q)) =\n                    ?i / ?j\n  proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v) =\n  proj2_abs\n   ((i / g) *\\<^sub>R proj2_rep (proj2_abs u) +\n    (j / h) *\\<^sub>R proj2_rep (proj2_abs v))\n  proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v) =\n  proj2_abs\n   ((k / g) *\\<^sub>R proj2_rep (proj2_abs u) +\n    (l / h) *\\<^sub>R proj2_rep (proj2_abs v))", "have \"proj2_Col_coeff ?p ?q ?r = h*i/(g*j)\"\n    and \"proj2_Col_coeff ?p ?q ?s = h*k/(g*l)\""], ["proof (prove)\nusing this:\n  proj2_abs u \\<noteq> proj2_abs v\n  h \\<noteq> 0\n  j \\<noteq> 0\n  l \\<noteq> 0\n  \\<lbrakk>?p \\<noteq> ?q; ?j \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proj2_Col_coeff ?p ?q\n                     (proj2_abs\n                       (?i *\\<^sub>R proj2_rep ?p +\n                        ?j *\\<^sub>R proj2_rep ?q)) =\n                    ?i / ?j\n  proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v) =\n  proj2_abs\n   ((i / g) *\\<^sub>R proj2_rep (proj2_abs u) +\n    (j / h) *\\<^sub>R proj2_rep (proj2_abs v))\n  proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v) =\n  proj2_abs\n   ((k / g) *\\<^sub>R proj2_rep (proj2_abs u) +\n    (l / h) *\\<^sub>R proj2_rep (proj2_abs v))\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff (proj2_abs u) (proj2_abs v)\n     (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v)) =\n    h * i / (g * j) &&&\n    proj2_Col_coeff (proj2_abs u) (proj2_abs v)\n     (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n    h * k / (g * l)", "by simp_all"], ["proof (state)\nthis:\n  proj2_Col_coeff (proj2_abs u) (proj2_abs v)\n   (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v)) =\n  h * i / (g * j)\n  proj2_Col_coeff (proj2_abs u) (proj2_abs v)\n   (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n  h * k / (g * l)\n\ngoal (1 subgoal):\n 1. cross_ratio (proj2_abs u) (proj2_abs v)\n     (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v))\n     (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n    j * k / (i * l)", "with \\<open>g \\<noteq> 0\\<close> and \\<open>h \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  g \\<noteq> 0\n  h \\<noteq> 0\n  proj2_Col_coeff (proj2_abs u) (proj2_abs v)\n   (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v)) =\n  h * i / (g * j)\n  proj2_Col_coeff (proj2_abs u) (proj2_abs v)\n   (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n  h * k / (g * l)", "show \"cross_ratio ?p ?q ?r ?s = j*k/(i*l)\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  h \\<noteq> 0\n  proj2_Col_coeff (proj2_abs u) (proj2_abs v)\n   (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v)) =\n  h * i / (g * j)\n  proj2_Col_coeff (proj2_abs u) (proj2_abs v)\n   (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n  h * k / (g * l)\n\ngoal (1 subgoal):\n 1. cross_ratio (proj2_abs u) (proj2_abs v)\n     (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v))\n     (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n    j * k / (i * l)", "by (unfold cross_ratio_def) (simp add: field_simps)"], ["proof (state)\nthis:\n  cross_ratio (proj2_abs u) (proj2_abs v)\n   (proj2_abs (i *\\<^sub>R u + j *\\<^sub>R v))\n   (proj2_abs (k *\\<^sub>R u + l *\\<^sub>R v)) =\n  j * k / (i * l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_ratio_abs2:\n  assumes \"p \\<noteq> q\"\n  shows \"cross_ratio p q\n  (proj2_abs (i *\\<^sub>R proj2_rep p + proj2_rep q))\n  (proj2_abs (j *\\<^sub>R proj2_rep p + proj2_rep q))\n  = j/i\"\n  (is \"cross_ratio p q ?r ?s = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_ratio p q (proj2_abs (i *\\<^sub>R proj2_rep p + proj2_rep q))\n     (proj2_abs (j *\\<^sub>R proj2_rep p + proj2_rep q)) =\n    j / i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio p q (proj2_abs (i *\\<^sub>R proj2_rep p + proj2_rep q))\n     (proj2_abs (j *\\<^sub>R proj2_rep p + proj2_rep q)) =\n    j / i", "let ?u = \"proj2_rep p\""], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio p q (proj2_abs (i *\\<^sub>R proj2_rep p + proj2_rep q))\n     (proj2_abs (j *\\<^sub>R proj2_rep p + proj2_rep q)) =\n    j / i", "let ?v = \"proj2_rep q\""], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio p q (proj2_abs (i *\\<^sub>R proj2_rep p + proj2_rep q))\n     (proj2_abs (j *\\<^sub>R proj2_rep p + proj2_rep q)) =\n    j / i", "have \"?u \\<noteq> 0\" and \"?v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep p \\<noteq> 0 &&& proj2_rep q \\<noteq> 0", "by (rule proj2_rep_non_zero)+"], ["proof (state)\nthis:\n  proj2_rep p \\<noteq> 0\n  proj2_rep q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross_ratio p q (proj2_abs (i *\\<^sub>R proj2_rep p + proj2_rep q))\n     (proj2_abs (j *\\<^sub>R proj2_rep p + proj2_rep q)) =\n    j / i", "have \"proj2_abs ?u = p\" and \"proj2_abs ?v = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_abs (proj2_rep p) = p &&& proj2_abs (proj2_rep q) = q", "by (rule proj2_abs_rep)+"], ["proof (state)\nthis:\n  proj2_abs (proj2_rep p) = p\n  proj2_abs (proj2_rep q) = q\n\ngoal (1 subgoal):\n 1. cross_ratio p q (proj2_abs (i *\\<^sub>R proj2_rep p + proj2_rep q))\n     (proj2_abs (j *\\<^sub>R proj2_rep p + proj2_rep q)) =\n    j / i", "with \\<open>?u \\<noteq> 0\\<close> and \\<open>?v \\<noteq> 0\\<close> and \\<open>p \\<noteq> q\\<close> and cross_ratio_abs [of ?u ?v 1 1 i j]"], ["proof (chain)\npicking this:\n  proj2_rep p \\<noteq> 0\n  proj2_rep q \\<noteq> 0\n  p \\<noteq> q\n  \\<lbrakk>proj2_rep p \\<noteq> 0; proj2_rep q \\<noteq> 0;\n   proj2_abs (proj2_rep p) \\<noteq> proj2_abs (proj2_rep q); 1 \\<noteq> 0;\n   1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cross_ratio (proj2_abs (proj2_rep p))\n                     (proj2_abs (proj2_rep q))\n                     (proj2_abs\n                       (i *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q))\n                     (proj2_abs\n                       (j *\\<^sub>R proj2_rep p +\n                        1 *\\<^sub>R proj2_rep q)) =\n                    1 * j / (i * 1)\n  proj2_abs (proj2_rep p) = p\n  proj2_abs (proj2_rep q) = q", "show \"cross_ratio p q ?r ?s = j/i\""], ["proof (prove)\nusing this:\n  proj2_rep p \\<noteq> 0\n  proj2_rep q \\<noteq> 0\n  p \\<noteq> q\n  \\<lbrakk>proj2_rep p \\<noteq> 0; proj2_rep q \\<noteq> 0;\n   proj2_abs (proj2_rep p) \\<noteq> proj2_abs (proj2_rep q); 1 \\<noteq> 0;\n   1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cross_ratio (proj2_abs (proj2_rep p))\n                     (proj2_abs (proj2_rep q))\n                     (proj2_abs\n                       (i *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q))\n                     (proj2_abs\n                       (j *\\<^sub>R proj2_rep p +\n                        1 *\\<^sub>R proj2_rep q)) =\n                    1 * j / (i * 1)\n  proj2_abs (proj2_rep p) = p\n  proj2_abs (proj2_rep q) = q\n\ngoal (1 subgoal):\n 1. cross_ratio p q (proj2_abs (i *\\<^sub>R proj2_rep p + proj2_rep q))\n     (proj2_abs (j *\\<^sub>R proj2_rep p + proj2_rep q)) =\n    j / i", "by simp"], ["proof (state)\nthis:\n  cross_ratio p q (proj2_abs (i *\\<^sub>R proj2_rep p + proj2_rep q))\n   (proj2_abs (j *\\<^sub>R proj2_rep p + proj2_rep q)) =\n  j / i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_ratio_correct_cltn2:\n  assumes \"cross_ratio_correct p q r s\"\n  shows \"cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n  (apply_cltn2 r C) (apply_cltn2 s C)\"\n  (is \"cross_ratio_correct ?pC ?qC ?rC ?sC\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n     (apply_cltn2 r C) (apply_cltn2 s C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n     (apply_cltn2 r C) (apply_cltn2 s C)", "from \\<open>cross_ratio_correct p q r s\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct p q r s", "have \"proj2_set_Col {p,q,r,s}\"\n    and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"s \\<noteq> p\" and \"r \\<noteq> q\""], ["proof (prove)\nusing this:\n  cross_ratio_correct p q r s\n\ngoal (1 subgoal):\n 1. (proj2_set_Col {p, q, r, s} &&& p \\<noteq> q) &&&\n    r \\<noteq> p &&& s \\<noteq> p &&& r \\<noteq> q", "by (unfold cross_ratio_correct_def) simp_all"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n  r \\<noteq> q\n\ngoal (1 subgoal):\n 1. cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n     (apply_cltn2 r C) (apply_cltn2 s C)", "have \"{apply_cltn2 t C | t. t \\<in> {p,q,r,s}} = {?pC,?qC,?rC,?sC}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {apply_cltn2 t C |t. t \\<in> {p, q, r, s}} =\n    {apply_cltn2 p C, apply_cltn2 q C, apply_cltn2 r C, apply_cltn2 s C}", "by auto"], ["proof (state)\nthis:\n  {apply_cltn2 t C |t. t \\<in> {p, q, r, s}} =\n  {apply_cltn2 p C, apply_cltn2 q C, apply_cltn2 r C, apply_cltn2 s C}\n\ngoal (1 subgoal):\n 1. cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n     (apply_cltn2 r C) (apply_cltn2 s C)", "with \\<open>proj2_set_Col {p,q,r,s}\\<close>\n    and apply_cltn2_preserve_set_Col [of \"{p,q,r,s}\" C]"], ["proof (chain)\npicking this:\n  proj2_set_Col {p, q, r, s}\n  proj2_set_Col {p, q, r, s} \\<Longrightarrow>\n  proj2_set_Col {apply_cltn2 pa C |pa. pa \\<in> {p, q, r, s}}\n  {apply_cltn2 t C |t. t \\<in> {p, q, r, s}} =\n  {apply_cltn2 p C, apply_cltn2 q C, apply_cltn2 r C, apply_cltn2 s C}", "have \"proj2_set_Col {?pC,?qC,?rC,?sC}\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r, s}\n  proj2_set_Col {p, q, r, s} \\<Longrightarrow>\n  proj2_set_Col {apply_cltn2 pa C |pa. pa \\<in> {p, q, r, s}}\n  {apply_cltn2 t C |t. t \\<in> {p, q, r, s}} =\n  {apply_cltn2 p C, apply_cltn2 q C, apply_cltn2 r C, apply_cltn2 s C}\n\ngoal (1 subgoal):\n 1. proj2_set_Col\n     {apply_cltn2 p C, apply_cltn2 q C, apply_cltn2 r C, apply_cltn2 s C}", "by simp"], ["proof (state)\nthis:\n  proj2_set_Col\n   {apply_cltn2 p C, apply_cltn2 q C, apply_cltn2 r C, apply_cltn2 s C}\n\ngoal (1 subgoal):\n 1. cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n     (apply_cltn2 r C) (apply_cltn2 s C)", "from \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and \\<open>s \\<noteq> p\\<close> and \\<open>r \\<noteq> q\\<close> and apply_cltn2_injective"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n  r \\<noteq> q\n  apply_cltn2 ?p ?C = apply_cltn2 ?q ?C \\<Longrightarrow> ?p = ?q", "have \"?pC \\<noteq> ?qC\" and \"?rC \\<noteq> ?pC\" and \"?sC \\<noteq> ?pC\" and \"?rC \\<noteq> ?qC\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n  r \\<noteq> q\n  apply_cltn2 ?p ?C = apply_cltn2 ?q ?C \\<Longrightarrow> ?p = ?q\n\ngoal (1 subgoal):\n 1. (apply_cltn2 p C \\<noteq> apply_cltn2 q C &&&\n     apply_cltn2 r C \\<noteq> apply_cltn2 p C) &&&\n    apply_cltn2 s C \\<noteq> apply_cltn2 p C &&&\n    apply_cltn2 r C \\<noteq> apply_cltn2 q C", "by fast+"], ["proof (state)\nthis:\n  apply_cltn2 p C \\<noteq> apply_cltn2 q C\n  apply_cltn2 r C \\<noteq> apply_cltn2 p C\n  apply_cltn2 s C \\<noteq> apply_cltn2 p C\n  apply_cltn2 r C \\<noteq> apply_cltn2 q C\n\ngoal (1 subgoal):\n 1. cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n     (apply_cltn2 r C) (apply_cltn2 s C)", "with \\<open>proj2_set_Col {?pC,?qC,?rC,?sC}\\<close>"], ["proof (chain)\npicking this:\n  proj2_set_Col\n   {apply_cltn2 p C, apply_cltn2 q C, apply_cltn2 r C, apply_cltn2 s C}\n  apply_cltn2 p C \\<noteq> apply_cltn2 q C\n  apply_cltn2 r C \\<noteq> apply_cltn2 p C\n  apply_cltn2 s C \\<noteq> apply_cltn2 p C\n  apply_cltn2 r C \\<noteq> apply_cltn2 q C", "show \"cross_ratio_correct ?pC ?qC ?rC ?sC\""], ["proof (prove)\nusing this:\n  proj2_set_Col\n   {apply_cltn2 p C, apply_cltn2 q C, apply_cltn2 r C, apply_cltn2 s C}\n  apply_cltn2 p C \\<noteq> apply_cltn2 q C\n  apply_cltn2 r C \\<noteq> apply_cltn2 p C\n  apply_cltn2 s C \\<noteq> apply_cltn2 p C\n  apply_cltn2 r C \\<noteq> apply_cltn2 q C\n\ngoal (1 subgoal):\n 1. cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n     (apply_cltn2 r C) (apply_cltn2 s C)", "by (unfold cross_ratio_correct_def) simp"], ["proof (state)\nthis:\n  cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_ratio_cltn2:\n  assumes \"proj2_set_Col {p,q,r,s}\" and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"s \\<noteq> p\"\n  shows \"cross_ratio (apply_cltn2 p C) (apply_cltn2 q C)\n  (apply_cltn2 r C) (apply_cltn2 s C)\n  = cross_ratio p q r s\"\n  (is \"cross_ratio ?pC ?qC ?rC ?sC = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "let ?u = \"proj2_rep p\""], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "let ?v = \"proj2_rep q\""], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "let ?i = \"proj2_Col_coeff p q r\""], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "let ?j = \"proj2_Col_coeff p q s\""], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "from \\<open>proj2_set_Col {p,q,r,s}\\<close> and \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and \\<open>s \\<noteq> p\\<close>\n    and proj2_set_Col_coeff"], ["proof (chain)\npicking this:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n  \\<lbrakk>proj2_set_Col ?S; {?p, ?q, ?r} \\<subseteq> ?S; ?p \\<noteq> ?q;\n   ?r \\<noteq> ?p\\<rbrakk>\n  \\<Longrightarrow> ?r =\n                    proj2_abs\n                     (proj2_Col_coeff ?p ?q ?r *\\<^sub>R proj2_rep ?p +\n                      proj2_rep ?q)", "have \"r = proj2_abs (?i *\\<^sub>R ?u + ?v)\" and \"s = proj2_abs (?j *\\<^sub>R ?u + ?v)\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n  \\<lbrakk>proj2_set_Col ?S; {?p, ?q, ?r} \\<subseteq> ?S; ?p \\<noteq> ?q;\n   ?r \\<noteq> ?p\\<rbrakk>\n  \\<Longrightarrow> ?r =\n                    proj2_abs\n                     (proj2_Col_coeff ?p ?q ?r *\\<^sub>R proj2_rep ?p +\n                      proj2_rep ?q)\n\ngoal (1 subgoal):\n 1. r =\n    proj2_abs\n     (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) &&&\n    s =\n    proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)", "by simp_all"], ["proof (state)\nthis:\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n  s = proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "let ?uC = \"?u v* cltn2_rep C\""], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "let ?vC = \"?v v* cltn2_rep C\""], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "have \"?uC \\<noteq> 0\" and \"?vC \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep p v* cltn2_rep C \\<noteq> 0 &&&\n    proj2_rep q v* cltn2_rep C \\<noteq> 0", "by (rule rep_mult_rep_non_zero)+"], ["proof (state)\nthis:\n  proj2_rep p v* cltn2_rep C \\<noteq> 0\n  proj2_rep q v* cltn2_rep C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "have \"proj2_abs ?uC = ?pC\" and \"proj2_abs ?vC = ?qC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_abs (proj2_rep p v* cltn2_rep C) = apply_cltn2 p C &&&\n    proj2_abs (proj2_rep q v* cltn2_rep C) = apply_cltn2 q C", "by (unfold apply_cltn2_def) simp_all"], ["proof (state)\nthis:\n  proj2_abs (proj2_rep p v* cltn2_rep C) = apply_cltn2 p C\n  proj2_abs (proj2_rep q v* cltn2_rep C) = apply_cltn2 q C\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "from \\<open>p \\<noteq> q\\<close> and apply_cltn2_injective"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  apply_cltn2 ?p ?C = apply_cltn2 ?q ?C \\<Longrightarrow> ?p = ?q", "have \"?pC \\<noteq> ?qC\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  apply_cltn2 ?p ?C = apply_cltn2 ?q ?C \\<Longrightarrow> ?p = ?q\n\ngoal (1 subgoal):\n 1. apply_cltn2 p C \\<noteq> apply_cltn2 q C", "by fast"], ["proof (state)\nthis:\n  apply_cltn2 p C \\<noteq> apply_cltn2 q C\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "from \\<open>p \\<noteq> q\\<close> and proj2_rep_dependent [of _ p 1 q]"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  \\<lbrakk>?i *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q = 0;\n   ?i \\<noteq> 0 \\<or> 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> p = q", "have \"?i *\\<^sub>R ?u + ?v \\<noteq> 0\" and \"?j *\\<^sub>R ?u + ?v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  \\<lbrakk>?i *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q = 0;\n   ?i \\<noteq> 0 \\<or> 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> p = q\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0 &&&\n    proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n  proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "with \\<open>r = proj2_abs (?i *\\<^sub>R ?u + ?v)\\<close> and \\<open>s = proj2_abs (?j *\\<^sub>R ?u + ?v)\\<close>\n    and apply_cltn2_linear [of ?i ?u 1 ?v]\n    and apply_cltn2_linear [of ?j ?u 1 ?v]"], ["proof (chain)\npicking this:\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n  s = proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n  1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  proj2_Col_coeff p q r *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n  1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C) \\<noteq>\n  0\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n  1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  apply_cltn2\n   (proj2_abs\n     (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n      1 *\\<^sub>R proj2_rep q))\n   ?C =\n  proj2_abs\n   (proj2_Col_coeff p q r *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n    1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C))\n  proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n  1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  proj2_Col_coeff p q s *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n  1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C) \\<noteq>\n  0\n  proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n  1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  apply_cltn2\n   (proj2_abs\n     (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n      1 *\\<^sub>R proj2_rep q))\n   ?C =\n  proj2_abs\n   (proj2_Col_coeff p q s *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n    1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C))\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n  proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0", "have \"?rC = proj2_abs (?i *\\<^sub>R ?uC + ?vC)\"\n    and \"?sC = proj2_abs (?j *\\<^sub>R ?uC + ?vC)\""], ["proof (prove)\nusing this:\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n  s = proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n  1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  proj2_Col_coeff p q r *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n  1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C) \\<noteq>\n  0\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n  1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  apply_cltn2\n   (proj2_abs\n     (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n      1 *\\<^sub>R proj2_rep q))\n   ?C =\n  proj2_abs\n   (proj2_Col_coeff p q r *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n    1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C))\n  proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n  1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  proj2_Col_coeff p q s *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n  1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C) \\<noteq>\n  0\n  proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n  1 *\\<^sub>R proj2_rep q \\<noteq>\n  0 \\<Longrightarrow>\n  apply_cltn2\n   (proj2_abs\n     (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n      1 *\\<^sub>R proj2_rep q))\n   ?C =\n  proj2_abs\n   (proj2_Col_coeff p q s *\\<^sub>R (proj2_rep p v* cltn2_rep ?C) +\n    1 *\\<^sub>R (proj2_rep q v* cltn2_rep ?C))\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n  proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. apply_cltn2 r C =\n    proj2_abs\n     (proj2_Col_coeff p q r *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n      proj2_rep q v* cltn2_rep C) &&&\n    apply_cltn2 s C =\n    proj2_abs\n     (proj2_Col_coeff p q s *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n      proj2_rep q v* cltn2_rep C)", "by simp_all"], ["proof (state)\nthis:\n  apply_cltn2 r C =\n  proj2_abs\n   (proj2_Col_coeff p q r *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n    proj2_rep q v* cltn2_rep C)\n  apply_cltn2 s C =\n  proj2_abs\n   (proj2_Col_coeff p q s *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n    proj2_rep q v* cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "with \\<open>?uC \\<noteq> 0\\<close> and \\<open>?vC \\<noteq> 0\\<close> and \\<open>proj2_abs ?uC = ?pC\\<close>\n    and \\<open>proj2_abs ?vC = ?qC\\<close> and \\<open>?pC \\<noteq> ?qC\\<close>\n    and cross_ratio_abs [of ?uC ?vC 1 1 ?i ?j]"], ["proof (chain)\npicking this:\n  proj2_rep p v* cltn2_rep C \\<noteq> 0\n  proj2_rep q v* cltn2_rep C \\<noteq> 0\n  proj2_abs (proj2_rep p v* cltn2_rep C) = apply_cltn2 p C\n  proj2_abs (proj2_rep q v* cltn2_rep C) = apply_cltn2 q C\n  apply_cltn2 p C \\<noteq> apply_cltn2 q C\n  \\<lbrakk>proj2_rep p v* cltn2_rep C \\<noteq> 0;\n   proj2_rep q v* cltn2_rep C \\<noteq> 0;\n   proj2_abs (proj2_rep p v* cltn2_rep C) \\<noteq>\n   proj2_abs (proj2_rep q v* cltn2_rep C);\n   1 \\<noteq> 0; 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cross_ratio (proj2_abs (proj2_rep p v* cltn2_rep C))\n                     (proj2_abs (proj2_rep q v* cltn2_rep C))\n                     (proj2_abs\n                       (proj2_Col_coeff p q r *\\<^sub>R\n                        (proj2_rep p v* cltn2_rep C) +\n                        1 *\\<^sub>R (proj2_rep q v* cltn2_rep C)))\n                     (proj2_abs\n                       (proj2_Col_coeff p q s *\\<^sub>R\n                        (proj2_rep p v* cltn2_rep C) +\n                        1 *\\<^sub>R (proj2_rep q v* cltn2_rep C))) =\n                    1 * proj2_Col_coeff p q s / (proj2_Col_coeff p q r * 1)\n  apply_cltn2 r C =\n  proj2_abs\n   (proj2_Col_coeff p q r *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n    proj2_rep q v* cltn2_rep C)\n  apply_cltn2 s C =\n  proj2_abs\n   (proj2_Col_coeff p q s *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n    proj2_rep q v* cltn2_rep C)", "have \"cross_ratio ?pC ?qC ?rC ?sC = ?j/?i\""], ["proof (prove)\nusing this:\n  proj2_rep p v* cltn2_rep C \\<noteq> 0\n  proj2_rep q v* cltn2_rep C \\<noteq> 0\n  proj2_abs (proj2_rep p v* cltn2_rep C) = apply_cltn2 p C\n  proj2_abs (proj2_rep q v* cltn2_rep C) = apply_cltn2 q C\n  apply_cltn2 p C \\<noteq> apply_cltn2 q C\n  \\<lbrakk>proj2_rep p v* cltn2_rep C \\<noteq> 0;\n   proj2_rep q v* cltn2_rep C \\<noteq> 0;\n   proj2_abs (proj2_rep p v* cltn2_rep C) \\<noteq>\n   proj2_abs (proj2_rep q v* cltn2_rep C);\n   1 \\<noteq> 0; 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cross_ratio (proj2_abs (proj2_rep p v* cltn2_rep C))\n                     (proj2_abs (proj2_rep q v* cltn2_rep C))\n                     (proj2_abs\n                       (proj2_Col_coeff p q r *\\<^sub>R\n                        (proj2_rep p v* cltn2_rep C) +\n                        1 *\\<^sub>R (proj2_rep q v* cltn2_rep C)))\n                     (proj2_abs\n                       (proj2_Col_coeff p q s *\\<^sub>R\n                        (proj2_rep p v* cltn2_rep C) +\n                        1 *\\<^sub>R (proj2_rep q v* cltn2_rep C))) =\n                    1 * proj2_Col_coeff p q s / (proj2_Col_coeff p q r * 1)\n  apply_cltn2 r C =\n  proj2_abs\n   (proj2_Col_coeff p q r *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n    proj2_rep q v* cltn2_rep C)\n  apply_cltn2 s C =\n  proj2_abs\n   (proj2_Col_coeff p q s *\\<^sub>R (proj2_rep p v* cltn2_rep C) +\n    proj2_rep q v* cltn2_rep C)\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    proj2_Col_coeff p q s / proj2_Col_coeff p q r", "by simp"], ["proof (state)\nthis:\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C) =\n  proj2_Col_coeff p q s / proj2_Col_coeff p q r\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "thus \"cross_ratio ?pC ?qC ?rC ?sC = cross_ratio p q r s\""], ["proof (prove)\nusing this:\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C) =\n  proj2_Col_coeff p q s / proj2_Col_coeff p q r\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "unfolding cross_ratio_def [of p q r s]"], ["proof (prove)\nusing this:\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C) =\n  proj2_Col_coeff p q s / proj2_Col_coeff p q r\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    proj2_Col_coeff p q s / proj2_Col_coeff p q r", "."], ["proof (state)\nthis:\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C) =\n  cross_ratio p q r s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_ratio_unique:\n  assumes \"cross_ratio_correct p q r s\" and \"cross_ratio_correct p q r t\"\n  and \"cross_ratio p q r s = cross_ratio p q r t\"\n  shows \"s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s = t", "from \\<open>cross_ratio_correct p q r s\\<close> and \\<open>cross_ratio_correct p q r t\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct p q r s\n  cross_ratio_correct p q r t", "have \"proj2_set_Col {p,q,r,s}\" and \"proj2_set_Col {p,q,r,t}\"\n    and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"r \\<noteq> q\" and \"s \\<noteq> p\" and \"t \\<noteq> p\""], ["proof (prove)\nusing this:\n  cross_ratio_correct p q r s\n  cross_ratio_correct p q r t\n\ngoal (1 subgoal):\n 1. (proj2_set_Col {p, q, r, s} &&&\n     proj2_set_Col {p, q, r, t} &&& p \\<noteq> q) &&&\n    (r \\<noteq> p &&& r \\<noteq> q) &&& s \\<noteq> p &&& t \\<noteq> p", "by (unfold cross_ratio_correct_def) simp_all"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r, s}\n  proj2_set_Col {p, q, r, t}\n  p \\<noteq> q\n  r \\<noteq> p\n  r \\<noteq> q\n  s \\<noteq> p\n  t \\<noteq> p\n\ngoal (1 subgoal):\n 1. s = t", "let ?u = \"proj2_rep p\""], ["proof (state)\ngoal (1 subgoal):\n 1. s = t", "let ?v = \"proj2_rep q\""], ["proof (state)\ngoal (1 subgoal):\n 1. s = t", "let ?i = \"proj2_Col_coeff p q r\""], ["proof (state)\ngoal (1 subgoal):\n 1. s = t", "let ?j = \"proj2_Col_coeff p q s\""], ["proof (state)\ngoal (1 subgoal):\n 1. s = t", "let ?k = \"proj2_Col_coeff p q t\""], ["proof (state)\ngoal (1 subgoal):\n 1. s = t", "from \\<open>proj2_set_Col {p,q,r,s}\\<close> and \\<open>proj2_set_Col {p,q,r,t}\\<close>\n    and \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and \\<open>s \\<noteq> p\\<close> and \\<open>t \\<noteq> p\\<close> and proj2_set_Col_coeff"], ["proof (chain)\npicking this:\n  proj2_set_Col {p, q, r, s}\n  proj2_set_Col {p, q, r, t}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n  t \\<noteq> p\n  \\<lbrakk>proj2_set_Col ?S; {?p, ?q, ?r} \\<subseteq> ?S; ?p \\<noteq> ?q;\n   ?r \\<noteq> ?p\\<rbrakk>\n  \\<Longrightarrow> ?r =\n                    proj2_abs\n                     (proj2_Col_coeff ?p ?q ?r *\\<^sub>R proj2_rep ?p +\n                      proj2_rep ?q)", "have \"r = proj2_abs (?i *\\<^sub>R ?u + ?v)\"\n    and \"s = proj2_abs (?j *\\<^sub>R ?u + ?v)\"\n    and \"t = proj2_abs (?k *\\<^sub>R ?u + ?v)\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r, s}\n  proj2_set_Col {p, q, r, t}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n  t \\<noteq> p\n  \\<lbrakk>proj2_set_Col ?S; {?p, ?q, ?r} \\<subseteq> ?S; ?p \\<noteq> ?q;\n   ?r \\<noteq> ?p\\<rbrakk>\n  \\<Longrightarrow> ?r =\n                    proj2_abs\n                     (proj2_Col_coeff ?p ?q ?r *\\<^sub>R proj2_rep ?p +\n                      proj2_rep ?q)\n\ngoal (1 subgoal):\n 1. r =\n    proj2_abs\n     (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) &&&\n    s =\n    proj2_abs\n     (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q) &&&\n    t =\n    proj2_abs (proj2_Col_coeff p q t *\\<^sub>R proj2_rep p + proj2_rep q)", "by simp_all"], ["proof (state)\nthis:\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n  s = proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)\n  t = proj2_abs (proj2_Col_coeff p q t *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. s = t", "from \\<open>r \\<noteq> q\\<close> and \\<open>r = proj2_abs (?i *\\<^sub>R ?u + ?v)\\<close>"], ["proof (chain)\npicking this:\n  r \\<noteq> q\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)", "have \"?i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  r \\<noteq> q\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r \\<noteq> 0", "by (auto simp add: proj2_abs_rep)"], ["proof (state)\nthis:\n  proj2_Col_coeff p q r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s = t", "with \\<open>cross_ratio p q r s = cross_ratio p q r t\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio p q r s = cross_ratio p q r t\n  proj2_Col_coeff p q r \\<noteq> 0", "have \"?j = ?k\""], ["proof (prove)\nusing this:\n  cross_ratio p q r s = cross_ratio p q r t\n  proj2_Col_coeff p q r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q s = proj2_Col_coeff p q t", "by (unfold cross_ratio_def) simp"], ["proof (state)\nthis:\n  proj2_Col_coeff p q s = proj2_Col_coeff p q t\n\ngoal (1 subgoal):\n 1. s = t", "with \\<open>s = proj2_abs (?j *\\<^sub>R ?u + ?v)\\<close> and \\<open>t = proj2_abs (?k *\\<^sub>R ?u + ?v)\\<close>"], ["proof (chain)\npicking this:\n  s = proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)\n  t = proj2_abs (proj2_Col_coeff p q t *\\<^sub>R proj2_rep p + proj2_rep q)\n  proj2_Col_coeff p q s = proj2_Col_coeff p q t", "show \"s = t\""], ["proof (prove)\nusing this:\n  s = proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)\n  t = proj2_abs (proj2_Col_coeff p q t *\\<^sub>R proj2_rep p + proj2_rep q)\n  proj2_Col_coeff p q s = proj2_Col_coeff p q t\n\ngoal (1 subgoal):\n 1. s = t", "by simp"], ["proof (state)\nthis:\n  s = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cltn2_three_point_line:\n  assumes \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"r \\<noteq> q\"\n  and \"proj2_incident p l\" and \"proj2_incident q l\" and \"proj2_incident r l\"\n  and \"apply_cltn2 p C = p\" and \"apply_cltn2 q C = q\" and \"apply_cltn2 r C = r\"\n  and \"proj2_incident s l\"\n  shows \"apply_cltn2 s C = s\" (is \"?sC = s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_cltn2 s C = s", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> apply_cltn2 s C = s\n 2. \\<not> ?P \\<Longrightarrow> apply_cltn2 s C = s", "assume \"s = p\""], ["proof (state)\nthis:\n  s = p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> apply_cltn2 s C = s\n 2. \\<not> ?P \\<Longrightarrow> apply_cltn2 s C = s", "with \\<open>apply_cltn2 p C = p\\<close>"], ["proof (chain)\npicking this:\n  apply_cltn2 p C = p\n  s = p", "show \"?sC = s\""], ["proof (prove)\nusing this:\n  apply_cltn2 p C = p\n  s = p\n\ngoal (1 subgoal):\n 1. apply_cltn2 s C = s", "by simp"], ["proof (state)\nthis:\n  apply_cltn2 s C = s\n\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "assume \"s \\<noteq> p\""], ["proof (state)\nthis:\n  s \\<noteq> p\n\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "let ?pC = \"apply_cltn2 p C\""], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "let ?qC = \"apply_cltn2 q C\""], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "let ?rC = \"apply_cltn2 r C\""], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "from \\<open>proj2_incident p l\\<close> and \\<open>proj2_incident q l\\<close> and \\<open>proj2_incident r l\\<close>\n    and \\<open>proj2_incident s l\\<close>"], ["proof (chain)\npicking this:\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident r l\n  proj2_incident s l", "have \"proj2_set_Col {p,q,r,s}\""], ["proof (prove)\nusing this:\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident r l\n  proj2_incident s l\n\ngoal (1 subgoal):\n 1. proj2_set_Col {p, q, r, s}", "by (unfold proj2_set_Col_def) auto"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r, s}\n\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "with \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and \\<open>s \\<noteq> p\\<close> and \\<open>r \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n  r \\<noteq> q\n  proj2_set_Col {p, q, r, s}", "have \"cross_ratio_correct p q r s\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n  r \\<noteq> q\n  proj2_set_Col {p, q, r, s}\n\ngoal (1 subgoal):\n 1. cross_ratio_correct p q r s", "by (unfold cross_ratio_correct_def) simp"], ["proof (state)\nthis:\n  cross_ratio_correct p q r s\n\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "hence \"cross_ratio_correct ?pC ?qC ?rC ?sC\""], ["proof (prove)\nusing this:\n  cross_ratio_correct p q r s\n\ngoal (1 subgoal):\n 1. cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n     (apply_cltn2 r C) (apply_cltn2 s C)", "by (rule cross_ratio_correct_cltn2)"], ["proof (state)\nthis:\n  cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C)\n\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "with \\<open>?pC = p\\<close> and \\<open>?qC = q\\<close> and \\<open>?rC = r\\<close>"], ["proof (chain)\npicking this:\n  apply_cltn2 p C = p\n  apply_cltn2 q C = q\n  apply_cltn2 r C = r\n  cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C)", "have \"cross_ratio_correct p q r ?sC\""], ["proof (prove)\nusing this:\n  apply_cltn2 p C = p\n  apply_cltn2 q C = q\n  apply_cltn2 r C = r\n  cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C)\n\ngoal (1 subgoal):\n 1. cross_ratio_correct p q r (apply_cltn2 s C)", "by simp"], ["proof (state)\nthis:\n  cross_ratio_correct p q r (apply_cltn2 s C)\n\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "from \\<open>proj2_set_Col {p,q,r,s}\\<close> and \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and \\<open>s \\<noteq> p\\<close>"], ["proof (chain)\npicking this:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p", "have \"cross_ratio ?pC ?qC ?rC ?sC = cross_ratio p q r s\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "by (rule cross_ratio_cltn2)"], ["proof (state)\nthis:\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C) =\n  cross_ratio p q r s\n\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "with \\<open>?pC = p\\<close> and \\<open>?qC = q\\<close> and \\<open>?rC = r\\<close>"], ["proof (chain)\npicking this:\n  apply_cltn2 p C = p\n  apply_cltn2 q C = q\n  apply_cltn2 r C = r\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C) =\n  cross_ratio p q r s", "have \"cross_ratio p q r ?sC = cross_ratio p q r s\""], ["proof (prove)\nusing this:\n  apply_cltn2 p C = p\n  apply_cltn2 q C = q\n  apply_cltn2 r C = r\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C) =\n  cross_ratio p q r s\n\ngoal (1 subgoal):\n 1. cross_ratio p q r (apply_cltn2 s C) = cross_ratio p q r s", "by simp"], ["proof (state)\nthis:\n  cross_ratio p q r (apply_cltn2 s C) = cross_ratio p q r s\n\ngoal (1 subgoal):\n 1. s \\<noteq> p \\<Longrightarrow> apply_cltn2 s C = s", "with \\<open>cross_ratio_correct p q r ?sC\\<close> and \\<open>cross_ratio_correct p q r s\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct p q r (apply_cltn2 s C)\n  cross_ratio_correct p q r s\n  cross_ratio p q r (apply_cltn2 s C) = cross_ratio p q r s", "show \"?sC = s\""], ["proof (prove)\nusing this:\n  cross_ratio_correct p q r (apply_cltn2 s C)\n  cross_ratio_correct p q r s\n  cross_ratio p q r (apply_cltn2 s C) = cross_ratio p q r s\n\ngoal (1 subgoal):\n 1. apply_cltn2 s C = s", "by (rule cross_ratio_unique)"], ["proof (state)\nthis:\n  apply_cltn2 s C = s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_ratio_equal_cltn2:\n  assumes \"cross_ratio_correct p q r s\"\n  and \"cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n  (apply_cltn2 r C) t\"\n  (is \"cross_ratio_correct ?pC ?qC ?rC t\")\n  and \"cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C) t\n    = cross_ratio p q r s\"\n  shows \"t = apply_cltn2 s C\" (is \"t = ?sC\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. t = apply_cltn2 s C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t = apply_cltn2 s C", "from \\<open>cross_ratio_correct p q r s\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct p q r s", "have \"cross_ratio_correct ?pC ?qC ?rC ?sC\""], ["proof (prove)\nusing this:\n  cross_ratio_correct p q r s\n\ngoal (1 subgoal):\n 1. cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C)\n     (apply_cltn2 r C) (apply_cltn2 s C)", "by (rule cross_ratio_correct_cltn2)"], ["proof (state)\nthis:\n  cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C)\n\ngoal (1 subgoal):\n 1. t = apply_cltn2 s C", "from \\<open>cross_ratio_correct p q r s\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct p q r s", "have \"proj2_set_Col {p,q,r,s}\" and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"s \\<noteq> p\""], ["proof (prove)\nusing this:\n  cross_ratio_correct p q r s\n\ngoal (1 subgoal):\n 1. (proj2_set_Col {p, q, r, s} &&& p \\<noteq> q) &&&\n    r \\<noteq> p &&& s \\<noteq> p", "by (unfold cross_ratio_correct_def) simp_all"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n\ngoal (1 subgoal):\n 1. t = apply_cltn2 s C", "hence \"cross_ratio ?pC ?qC ?rC ?sC = cross_ratio p q r s\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C) =\n    cross_ratio p q r s", "by (rule cross_ratio_cltn2)"], ["proof (state)\nthis:\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C) =\n  cross_ratio p q r s\n\ngoal (1 subgoal):\n 1. t = apply_cltn2 s C", "with \\<open>cross_ratio ?pC ?qC ?rC t = cross_ratio p q r s\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C) t =\n  cross_ratio p q r s\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C) =\n  cross_ratio p q r s", "have \"cross_ratio ?pC ?qC ?rC t = cross_ratio ?pC ?qC ?rC ?sC\""], ["proof (prove)\nusing this:\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C) t =\n  cross_ratio p q r s\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C) =\n  cross_ratio p q r s\n\ngoal (1 subgoal):\n 1. cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C) t =\n    cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n     (apply_cltn2 s C)", "by simp"], ["proof (state)\nthis:\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C) t =\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C)\n\ngoal (1 subgoal):\n 1. t = apply_cltn2 s C", "with \\<open>cross_ratio_correct ?pC ?qC ?rC t\\<close>\n    and \\<open>cross_ratio_correct ?pC ?qC ?rC ?sC\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   t\n  cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C)\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C) t =\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C)", "show \"t = ?sC\""], ["proof (prove)\nusing this:\n  cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   t\n  cross_ratio_correct (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C)\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C) t =\n  cross_ratio (apply_cltn2 p C) (apply_cltn2 q C) (apply_cltn2 r C)\n   (apply_cltn2 s C)\n\ngoal (1 subgoal):\n 1. t = apply_cltn2 s C", "by (rule cross_ratio_unique)"], ["proof (state)\nthis:\n  t = apply_cltn2 s C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_Col_distinct_coeff_non_zero:\n  assumes \"proj2_Col p q r\" and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"r \\<noteq> q\"\n  shows \"proj2_Col_coeff p q r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r = 0 \\<Longrightarrow> False", "assume \"proj2_Col_coeff p q r = 0\""], ["proof (state)\nthis:\n  proj2_Col_coeff p q r = 0\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r = 0 \\<Longrightarrow> False", "from \\<open>proj2_Col p q r\\<close> and \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close>"], ["proof (chain)\npicking this:\n  proj2_Col p q r\n  p \\<noteq> q\n  r \\<noteq> p", "have \"r = proj2_abs ((proj2_Col_coeff p q r) *\\<^sub>R proj2_rep p + proj2_rep q)\""], ["proof (prove)\nusing this:\n  proj2_Col p q r\n  p \\<noteq> q\n  r \\<noteq> p\n\ngoal (1 subgoal):\n 1. r =\n    proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)", "by (rule proj2_Col_coeff)"], ["proof (state)\nthis:\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r = 0 \\<Longrightarrow> False", "with \\<open>proj2_Col_coeff p q r = 0\\<close>"], ["proof (chain)\npicking this:\n  proj2_Col_coeff p q r = 0\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)", "have \"r = q\""], ["proof (prove)\nusing this:\n  proj2_Col_coeff p q r = 0\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. r = q", "by (simp add: proj2_abs_rep)"], ["proof (state)\nthis:\n  r = q\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r = 0 \\<Longrightarrow> False", "with \\<open>r \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  r \\<noteq> q\n  r = q", "show False"], ["proof (prove)\nusing this:\n  r \\<noteq> q\n  r = q\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_ratio_product:\n  assumes \"proj2_Col p q s\" and \"p \\<noteq> q\" and \"s \\<noteq> p\" and \"s \\<noteq> q\"\n  shows \"cross_ratio p q r s * cross_ratio p q s t = cross_ratio p q r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_ratio p q r s * cross_ratio p q s t = cross_ratio p q r t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio p q r s * cross_ratio p q s t = cross_ratio p q r t", "from \\<open>proj2_Col p q s\\<close> and \\<open>p \\<noteq> q\\<close> and \\<open>s \\<noteq> p\\<close> and \\<open>s \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  proj2_Col p q s\n  p \\<noteq> q\n  s \\<noteq> p\n  s \\<noteq> q", "have \"proj2_Col_coeff p q s \\<noteq> 0\""], ["proof (prove)\nusing this:\n  proj2_Col p q s\n  p \\<noteq> q\n  s \\<noteq> p\n  s \\<noteq> q\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q s \\<noteq> 0", "by (rule proj2_Col_distinct_coeff_non_zero)"], ["proof (state)\nthis:\n  proj2_Col_coeff p q s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross_ratio p q r s * cross_ratio p q s t = cross_ratio p q r t", "thus \"cross_ratio p q r s * cross_ratio p q s t = cross_ratio p q r t\""], ["proof (prove)\nusing this:\n  proj2_Col_coeff p q s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross_ratio p q r s * cross_ratio p q s t = cross_ratio p q r t", "by (unfold cross_ratio_def) simp"], ["proof (state)\nthis:\n  cross_ratio p q r s * cross_ratio p q s t = cross_ratio p q r t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_ratio_equal_1:\n  assumes \"proj2_Col p q r\" and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"r \\<noteq> q\"\n  shows \"cross_ratio p q r r = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_ratio p q r r = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio p q r r = 1", "from \\<open>proj2_Col p q r\\<close> and \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and \\<open>r \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  proj2_Col p q r\n  p \\<noteq> q\n  r \\<noteq> p\n  r \\<noteq> q", "have \"proj2_Col_coeff p q r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  proj2_Col p q r\n  p \\<noteq> q\n  r \\<noteq> p\n  r \\<noteq> q\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r \\<noteq> 0", "by (rule proj2_Col_distinct_coeff_non_zero)"], ["proof (state)\nthis:\n  proj2_Col_coeff p q r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross_ratio p q r r = 1", "thus \"cross_ratio p q r r = 1\""], ["proof (prove)\nusing this:\n  proj2_Col_coeff p q r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross_ratio p q r r = 1", "by (unfold cross_ratio_def) simp"], ["proof (state)\nthis:\n  cross_ratio p q r r = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_ratio_1_equal:\n  assumes \"cross_ratio_correct p q r s\" and \"cross_ratio p q r s = 1\"\n  shows \"r = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r = s", "from \\<open>cross_ratio_correct p q r s\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct p q r s", "have \"proj2_set_Col {p,q,r,s}\" and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"r \\<noteq> q\""], ["proof (prove)\nusing this:\n  cross_ratio_correct p q r s\n\ngoal (1 subgoal):\n 1. (proj2_set_Col {p, q, r, s} &&& p \\<noteq> q) &&&\n    r \\<noteq> p &&& r \\<noteq> q", "by (unfold cross_ratio_correct_def) simp_all"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  r \\<noteq> q\n\ngoal (1 subgoal):\n 1. r = s", "from \\<open>proj2_set_Col {p,q,r,s}\\<close>"], ["proof (chain)\npicking this:\n  proj2_set_Col {p, q, r, s}", "have \"proj2_set_Col {p,q,r}\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r, s}\n\ngoal (1 subgoal):\n 1. proj2_set_Col {p, q, r}", "by (simp add: proj2_subset_Col [of \"{p,q,r}\" \"{p,q,r,s}\"])"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. r = s", "with \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and \\<open>r \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  r \\<noteq> p\n  r \\<noteq> q\n  proj2_set_Col {p, q, r}", "have \"cross_ratio_correct p q r r\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  r \\<noteq> p\n  r \\<noteq> q\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. cross_ratio_correct p q r r", "by (unfold cross_ratio_correct_def) simp"], ["proof (state)\nthis:\n  cross_ratio_correct p q r r\n\ngoal (1 subgoal):\n 1. r = s", "from \\<open>proj2_set_Col {p,q,r}\\<close>"], ["proof (chain)\npicking this:\n  proj2_set_Col {p, q, r}", "have \"proj2_Col p q r\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. proj2_Col p q r", "by (subst proj2_Col_iff_set_Col)"], ["proof (state)\nthis:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. r = s", "with \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and \\<open>r \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  r \\<noteq> p\n  r \\<noteq> q\n  proj2_Col p q r", "have \"cross_ratio p q r r = 1\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  r \\<noteq> p\n  r \\<noteq> q\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. cross_ratio p q r r = 1", "by (simp add: cross_ratio_equal_1)"], ["proof (state)\nthis:\n  cross_ratio p q r r = 1\n\ngoal (1 subgoal):\n 1. r = s", "with \\<open>cross_ratio p q r s = 1\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio p q r s = 1\n  cross_ratio p q r r = 1", "have \"cross_ratio p q r r = cross_ratio p q r s\""], ["proof (prove)\nusing this:\n  cross_ratio p q r s = 1\n  cross_ratio p q r r = 1\n\ngoal (1 subgoal):\n 1. cross_ratio p q r r = cross_ratio p q r s", "by simp"], ["proof (state)\nthis:\n  cross_ratio p q r r = cross_ratio p q r s\n\ngoal (1 subgoal):\n 1. r = s", "with \\<open>cross_ratio_correct p q r r\\<close> and \\<open>cross_ratio_correct p q r s\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct p q r r\n  cross_ratio_correct p q r s\n  cross_ratio p q r r = cross_ratio p q r s", "show \"r = s\""], ["proof (prove)\nusing this:\n  cross_ratio_correct p q r r\n  cross_ratio_correct p q r s\n  cross_ratio p q r r = cross_ratio p q r s\n\ngoal (1 subgoal):\n 1. r = s", "by (rule cross_ratio_unique)"], ["proof (state)\nthis:\n  r = s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_ratio_swap_34:\n  shows \"cross_ratio p q s r = 1 / (cross_ratio p q r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_ratio p q s r = 1 / cross_ratio p q r s", "by (unfold cross_ratio_def) simp"], ["", "lemma cross_ratio_swap_13_24:\n  assumes \"cross_ratio_correct p q r s\" and \"r \\<noteq> s\"\n  shows \"cross_ratio r s p q = cross_ratio p q r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "from \\<open>cross_ratio_correct p q r s\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct p q r s", "have \"proj2_set_Col {p,q,r,s}\" and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"s \\<noteq> p\" and \"r \\<noteq> q\""], ["proof (prove)\nusing this:\n  cross_ratio_correct p q r s\n\ngoal (1 subgoal):\n 1. (proj2_set_Col {p, q, r, s} &&& p \\<noteq> q) &&&\n    r \\<noteq> p &&& s \\<noteq> p &&& r \\<noteq> q", "by (unfold cross_ratio_correct_def, simp_all)"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n  r \\<noteq> q\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "have \"proj2_rep p \\<noteq> 0\" (is \"?u \\<noteq> 0\") and \"proj2_rep q \\<noteq> 0\" (is \"?v \\<noteq> 0\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep p \\<noteq> 0 &&& proj2_rep q \\<noteq> 0", "by (rule proj2_rep_non_zero)+"], ["proof (state)\nthis:\n  proj2_rep p \\<noteq> 0\n  proj2_rep q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "have \"p = proj2_abs ?u\" and \"q = proj2_abs ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = proj2_abs (proj2_rep p) &&& q = proj2_abs (proj2_rep q)", "by (simp_all add: proj2_abs_rep)"], ["proof (state)\nthis:\n  p = proj2_abs (proj2_rep p)\n  q = proj2_abs (proj2_rep q)\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "with \\<open>p \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  p = proj2_abs (proj2_rep p)\n  q = proj2_abs (proj2_rep q)", "have \"proj2_abs ?u \\<noteq> proj2_abs ?v\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  p = proj2_abs (proj2_rep p)\n  q = proj2_abs (proj2_rep q)\n\ngoal (1 subgoal):\n 1. proj2_abs (proj2_rep p) \\<noteq> proj2_abs (proj2_rep q)", "by simp"], ["proof (state)\nthis:\n  proj2_abs (proj2_rep p) \\<noteq> proj2_abs (proj2_rep q)\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "let ?i = \"proj2_Col_coeff p q r\""], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "let ?j = \"proj2_Col_coeff p q s\""], ["proof (state)\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "from \\<open>proj2_set_Col {p,q,r,s}\\<close> and \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and \\<open>s \\<noteq> p\\<close>"], ["proof (chain)\npicking this:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p", "have \"r = proj2_abs (?i *\\<^sub>R ?u + ?v)\" (is \"r = proj2_abs ?w\")\n    and \"s = proj2_abs (?j *\\<^sub>R ?u + ?v)\" (is \"s = proj2_abs ?x\")"], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  s \\<noteq> p\n\ngoal (1 subgoal):\n 1. r =\n    proj2_abs\n     (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) &&&\n    s =\n    proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)", "by (simp_all add: proj2_set_Col_coeff)"], ["proof (state)\nthis:\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n  s = proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "with \\<open>r \\<noteq> s\\<close>"], ["proof (chain)\npicking this:\n  r \\<noteq> s\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n  s = proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)", "have \"?i \\<noteq> ?j\""], ["proof (prove)\nusing this:\n  r \\<noteq> s\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n  s = proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r \\<noteq> proj2_Col_coeff p q s", "by auto"], ["proof (state)\nthis:\n  proj2_Col_coeff p q r \\<noteq> proj2_Col_coeff p q s\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "from \\<open>?u \\<noteq> 0\\<close> and \\<open>?v \\<noteq> 0\\<close> and \\<open>proj2_abs ?u \\<noteq> proj2_abs ?v\\<close>\n    and dependent_proj2_abs [of ?u ?v _ 1]"], ["proof (chain)\npicking this:\n  proj2_rep p \\<noteq> 0\n  proj2_rep q \\<noteq> 0\n  proj2_abs (proj2_rep p) \\<noteq> proj2_abs (proj2_rep q)\n  \\<lbrakk>proj2_rep p \\<noteq> 0; proj2_rep q \\<noteq> 0;\n   ?i \\<noteq> 0 \\<or> 1 \\<noteq> 0;\n   ?i *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q = 0\\<rbrakk>\n  \\<Longrightarrow> proj2_abs (proj2_rep p) = proj2_abs (proj2_rep q)", "have \"?w \\<noteq> 0\" and \"?x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  proj2_rep p \\<noteq> 0\n  proj2_rep q \\<noteq> 0\n  proj2_abs (proj2_rep p) \\<noteq> proj2_abs (proj2_rep q)\n  \\<lbrakk>proj2_rep p \\<noteq> 0; proj2_rep q \\<noteq> 0;\n   ?i \\<noteq> 0 \\<or> 1 \\<noteq> 0;\n   ?i *\\<^sub>R proj2_rep p + 1 *\\<^sub>R proj2_rep q = 0\\<rbrakk>\n  \\<Longrightarrow> proj2_abs (proj2_rep p) = proj2_abs (proj2_rep q)\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0 &&&\n    proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n  proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "from \\<open>r = proj2_abs (?i *\\<^sub>R ?u + ?v)\\<close> and \\<open>r \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n  r \\<noteq> q", "have \"?i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n  r \\<noteq> q\n\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r \\<noteq> 0", "by (auto simp add: proj2_abs_rep)"], ["proof (state)\nthis:\n  proj2_Col_coeff p q r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "have \"?w - ?x = (?i - ?j) *\\<^sub>R ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q -\n    (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q) =\n    (proj2_Col_coeff p q r - proj2_Col_coeff p q s) *\\<^sub>R proj2_rep p", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q -\n  (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q) =\n  (proj2_Col_coeff p q r - proj2_Col_coeff p q s) *\\<^sub>R proj2_rep p\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "with \\<open>?i \\<noteq> ?j\\<close>"], ["proof (chain)\npicking this:\n  proj2_Col_coeff p q r \\<noteq> proj2_Col_coeff p q s\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q -\n  (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q) =\n  (proj2_Col_coeff p q r - proj2_Col_coeff p q s) *\\<^sub>R proj2_rep p", "have \"p = proj2_abs (?w - ?x)\""], ["proof (prove)\nusing this:\n  proj2_Col_coeff p q r \\<noteq> proj2_Col_coeff p q s\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q -\n  (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q) =\n  (proj2_Col_coeff p q r - proj2_Col_coeff p q s) *\\<^sub>R proj2_rep p\n\ngoal (1 subgoal):\n 1. p =\n    proj2_abs\n     (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q -\n      (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q))", "by (simp add: proj2_abs_mult_rep)"], ["proof (state)\nthis:\n  p =\n  proj2_abs\n   (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q -\n    (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q))\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "have \"?j *\\<^sub>R ?w - ?i *\\<^sub>R ?x = (?j - ?i) *\\<^sub>R ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col_coeff p q s *\\<^sub>R\n    (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) -\n    proj2_Col_coeff p q r *\\<^sub>R\n    (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q) =\n    (proj2_Col_coeff p q s - proj2_Col_coeff p q r) *\\<^sub>R proj2_rep q", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  proj2_Col_coeff p q s *\\<^sub>R\n  (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) -\n  proj2_Col_coeff p q r *\\<^sub>R\n  (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q) =\n  (proj2_Col_coeff p q s - proj2_Col_coeff p q r) *\\<^sub>R proj2_rep q\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "with \\<open>?i \\<noteq> ?j\\<close>"], ["proof (chain)\npicking this:\n  proj2_Col_coeff p q r \\<noteq> proj2_Col_coeff p q s\n  proj2_Col_coeff p q s *\\<^sub>R\n  (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) -\n  proj2_Col_coeff p q r *\\<^sub>R\n  (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q) =\n  (proj2_Col_coeff p q s - proj2_Col_coeff p q r) *\\<^sub>R proj2_rep q", "have \"q = proj2_abs (?j *\\<^sub>R ?w - ?i *\\<^sub>R ?x)\""], ["proof (prove)\nusing this:\n  proj2_Col_coeff p q r \\<noteq> proj2_Col_coeff p q s\n  proj2_Col_coeff p q s *\\<^sub>R\n  (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) -\n  proj2_Col_coeff p q r *\\<^sub>R\n  (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q) =\n  (proj2_Col_coeff p q s - proj2_Col_coeff p q r) *\\<^sub>R proj2_rep q\n\ngoal (1 subgoal):\n 1. q =\n    proj2_abs\n     (proj2_Col_coeff p q s *\\<^sub>R\n      (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) -\n      proj2_Col_coeff p q r *\\<^sub>R\n      (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q))", "by (simp add: proj2_abs_mult_rep)"], ["proof (state)\nthis:\n  q =\n  proj2_abs\n   (proj2_Col_coeff p q s *\\<^sub>R\n    (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) -\n    proj2_Col_coeff p q r *\\<^sub>R\n    (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q))\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "with \\<open>?w \\<noteq> 0\\<close> and \\<open>?x \\<noteq> 0\\<close> and \\<open>r \\<noteq> s\\<close> and \\<open>?i \\<noteq> 0\\<close> and \\<open>r = proj2_abs ?w\\<close>\n    and \\<open>s = proj2_abs ?x\\<close> and \\<open>p = proj2_abs (?w - ?x)\\<close>\n    and cross_ratio_abs [of ?w ?x \"-1\" \"-?i\" 1 ?j]"], ["proof (chain)\npicking this:\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n  proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n  r \\<noteq> s\n  proj2_Col_coeff p q r \\<noteq> 0\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n  s = proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)\n  p =\n  proj2_abs\n   (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q -\n    (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q))\n  \\<lbrakk>proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n           proj2_rep q \\<noteq>\n           0;\n   proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0;\n   proj2_abs\n    (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) \\<noteq>\n   proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q);\n   - 1 \\<noteq> 0; - proj2_Col_coeff p q r \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cross_ratio\n                     (proj2_abs\n                       (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n                        proj2_rep q))\n                     (proj2_abs\n                       (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n                        proj2_rep q))\n                     (proj2_abs\n                       (1 *\\<^sub>R\n                        (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n                         proj2_rep q) +\n                        - 1 *\\<^sub>R\n                        (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n                         proj2_rep q)))\n                     (proj2_abs\n                       (proj2_Col_coeff p q s *\\<^sub>R\n                        (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n                         proj2_rep q) +\n                        - proj2_Col_coeff p q r *\\<^sub>R\n                        (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n                         proj2_rep q))) =\n                    - 1 * proj2_Col_coeff p q s /\n                    (1 * - proj2_Col_coeff p q r)\n  q =\n  proj2_abs\n   (proj2_Col_coeff p q s *\\<^sub>R\n    (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) -\n    proj2_Col_coeff p q r *\\<^sub>R\n    (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q))", "have \"cross_ratio r s p q = ?j / ?i\""], ["proof (prove)\nusing this:\n  proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n  proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0\n  r \\<noteq> s\n  proj2_Col_coeff p q r \\<noteq> 0\n  r = proj2_abs (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q)\n  s = proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q)\n  p =\n  proj2_abs\n   (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q -\n    (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q))\n  \\<lbrakk>proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n           proj2_rep q \\<noteq>\n           0;\n   proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q \\<noteq> 0;\n   proj2_abs\n    (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) \\<noteq>\n   proj2_abs (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q);\n   - 1 \\<noteq> 0; - proj2_Col_coeff p q r \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cross_ratio\n                     (proj2_abs\n                       (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n                        proj2_rep q))\n                     (proj2_abs\n                       (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n                        proj2_rep q))\n                     (proj2_abs\n                       (1 *\\<^sub>R\n                        (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n                         proj2_rep q) +\n                        - 1 *\\<^sub>R\n                        (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n                         proj2_rep q)))\n                     (proj2_abs\n                       (proj2_Col_coeff p q s *\\<^sub>R\n                        (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p +\n                         proj2_rep q) +\n                        - proj2_Col_coeff p q r *\\<^sub>R\n                        (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p +\n                         proj2_rep q))) =\n                    - 1 * proj2_Col_coeff p q s /\n                    (1 * - proj2_Col_coeff p q r)\n  q =\n  proj2_abs\n   (proj2_Col_coeff p q s *\\<^sub>R\n    (proj2_Col_coeff p q r *\\<^sub>R proj2_rep p + proj2_rep q) -\n    proj2_Col_coeff p q r *\\<^sub>R\n    (proj2_Col_coeff p q s *\\<^sub>R proj2_rep p + proj2_rep q))\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = proj2_Col_coeff p q s / proj2_Col_coeff p q r", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  cross_ratio r s p q = proj2_Col_coeff p q s / proj2_Col_coeff p q r\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "thus \"cross_ratio r s p q = cross_ratio p q r s\""], ["proof (prove)\nusing this:\n  cross_ratio r s p q = proj2_Col_coeff p q s / proj2_Col_coeff p q r\n\ngoal (1 subgoal):\n 1. cross_ratio r s p q = cross_ratio p q r s", "by (unfold cross_ratio_def [of p q r s], simp)"], ["proof (state)\nthis:\n  cross_ratio r s p q = cross_ratio p q r s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_ratio_swap_12:\n  assumes \"cross_ratio_correct p q r s\" and \"cross_ratio_correct q p r s\"\n  shows \"cross_ratio q p r s = 1 / (cross_ratio p q r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_ratio q p r s = 1 / cross_ratio p q r s", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cross_ratio q p r s = 1 / cross_ratio p q r s\n 2. \\<not> ?P \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "assume \"r = s\""], ["proof (state)\nthis:\n  r = s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cross_ratio q p r s = 1 / cross_ratio p q r s\n 2. \\<not> ?P \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "from \\<open>cross_ratio_correct p q r s\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct p q r s", "have \"proj2_set_Col {p,q,r,s}\" and \"p \\<noteq> q\" and \"r \\<noteq> p\" and \"r \\<noteq> q\""], ["proof (prove)\nusing this:\n  cross_ratio_correct p q r s\n\ngoal (1 subgoal):\n 1. (proj2_set_Col {p, q, r, s} &&& p \\<noteq> q) &&&\n    r \\<noteq> p &&& r \\<noteq> q", "by (unfold cross_ratio_correct_def) simp_all"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r, s}\n  p \\<noteq> q\n  r \\<noteq> p\n  r \\<noteq> q\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cross_ratio q p r s = 1 / cross_ratio p q r s\n 2. \\<not> ?P \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "from \\<open>proj2_set_Col {p,q,r,s}\\<close> and \\<open>r = s\\<close>"], ["proof (chain)\npicking this:\n  proj2_set_Col {p, q, r, s}\n  r = s", "have \"proj2_Col p q r\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r, s}\n  r = s\n\ngoal (1 subgoal):\n 1. proj2_Col p q r", "by (simp_all add: proj2_Col_iff_set_Col)"], ["proof (state)\nthis:\n  proj2_Col p q r\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cross_ratio q p r s = 1 / cross_ratio p q r s\n 2. \\<not> ?P \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "hence \"proj2_Col q p r\""], ["proof (prove)\nusing this:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. proj2_Col q p r", "by (rule proj2_Col_permute)"], ["proof (state)\nthis:\n  proj2_Col q p r\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cross_ratio q p r s = 1 / cross_ratio p q r s\n 2. \\<not> ?P \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "with \\<open>proj2_Col p q r\\<close> and \\<open>p \\<noteq> q\\<close> and \\<open>r \\<noteq> p\\<close> and \\<open>r \\<noteq> q\\<close> and \\<open>r = s\\<close>"], ["proof (chain)\npicking this:\n  proj2_Col p q r\n  p \\<noteq> q\n  r \\<noteq> p\n  r \\<noteq> q\n  r = s\n  proj2_Col q p r", "have \"cross_ratio p q r s = 1\" and \"cross_ratio q p r s = 1\""], ["proof (prove)\nusing this:\n  proj2_Col p q r\n  p \\<noteq> q\n  r \\<noteq> p\n  r \\<noteq> q\n  r = s\n  proj2_Col q p r\n\ngoal (1 subgoal):\n 1. cross_ratio p q r s = 1 &&& cross_ratio q p r s = 1", "by (simp_all add: cross_ratio_equal_1)"], ["proof (state)\nthis:\n  cross_ratio p q r s = 1\n  cross_ratio q p r s = 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cross_ratio q p r s = 1 / cross_ratio p q r s\n 2. \\<not> ?P \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "thus \"cross_ratio q p r s = 1 / (cross_ratio p q r s)\""], ["proof (prove)\nusing this:\n  cross_ratio p q r s = 1\n  cross_ratio q p r s = 1\n\ngoal (1 subgoal):\n 1. cross_ratio q p r s = 1 / cross_ratio p q r s", "by simp"], ["proof (state)\nthis:\n  cross_ratio q p r s = 1 / cross_ratio p q r s\n\ngoal (1 subgoal):\n 1. r \\<noteq> s \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> s \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "assume \"r \\<noteq> s\""], ["proof (state)\nthis:\n  r \\<noteq> s\n\ngoal (1 subgoal):\n 1. r \\<noteq> s \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "with \\<open>cross_ratio_correct q p r s\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct q p r s\n  r \\<noteq> s", "have \"cross_ratio q p r s = cross_ratio r s q p\""], ["proof (prove)\nusing this:\n  cross_ratio_correct q p r s\n  r \\<noteq> s\n\ngoal (1 subgoal):\n 1. cross_ratio q p r s = cross_ratio r s q p", "by (simp add: cross_ratio_swap_13_24)"], ["proof (state)\nthis:\n  cross_ratio q p r s = cross_ratio r s q p\n\ngoal (1 subgoal):\n 1. r \\<noteq> s \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "also"], ["proof (state)\nthis:\n  cross_ratio q p r s = cross_ratio r s q p\n\ngoal (1 subgoal):\n 1. r \\<noteq> s \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "have \"\\<dots> = 1 / (cross_ratio r s p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_ratio r s q p = 1 / cross_ratio r s p q", "by (rule cross_ratio_swap_34)"], ["proof (state)\nthis:\n  cross_ratio r s q p = 1 / cross_ratio r s p q\n\ngoal (1 subgoal):\n 1. r \\<noteq> s \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "also"], ["proof (state)\nthis:\n  cross_ratio r s q p = 1 / cross_ratio r s p q\n\ngoal (1 subgoal):\n 1. r \\<noteq> s \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "from \\<open>cross_ratio_correct p q r s\\<close> and \\<open>r \\<noteq> s\\<close>"], ["proof (chain)\npicking this:\n  cross_ratio_correct p q r s\n  r \\<noteq> s", "have \"\\<dots> = 1 / (cross_ratio p q r s)\""], ["proof (prove)\nusing this:\n  cross_ratio_correct p q r s\n  r \\<noteq> s\n\ngoal (1 subgoal):\n 1. 1 / cross_ratio r s p q = 1 / cross_ratio p q r s", "by (simp add: cross_ratio_swap_13_24)"], ["proof (state)\nthis:\n  1 / cross_ratio r s p q = 1 / cross_ratio p q r s\n\ngoal (1 subgoal):\n 1. r \\<noteq> s \\<Longrightarrow>\n    cross_ratio q p r s = 1 / cross_ratio p q r s", "finally"], ["proof (chain)\npicking this:\n  cross_ratio q p r s = 1 / cross_ratio p q r s", "show \"cross_ratio q p r s = 1 / (cross_ratio p q r s)\""], ["proof (prove)\nusing this:\n  cross_ratio q p r s = 1 / cross_ratio p q r s\n\ngoal (1 subgoal):\n 1. cross_ratio q p r s = 1 / cross_ratio p q r s", "."], ["proof (state)\nthis:\n  cross_ratio q p r s = 1 / cross_ratio p q r s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Cartesian subspace of the real projective plane\""], ["", "definition vector2_append1 :: \"real^2 \\<Rightarrow> real^3\" where\n  \"vector2_append1 v = vector [v$1, v$2, 1]\""], ["", "lemma vector2_append1_non_zero: \"vector2_append1 v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector2_append1 v \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vector2_append1 v \\<noteq> 0", "have \"(vector2_append1 v)$3 \\<noteq> 0$3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector2_append1 v $ 3 \\<noteq> 0 $ (3::'a)", "unfolding vector2_append1_def and vector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_lambda\n     (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [v $ 1, v $ 2, 1]\n       (\\<lambda>n x. 0) 1) $\n    3 \\<noteq>\n    0 $ (3::'a)", "by simp"], ["proof (state)\nthis:\n  vector2_append1 v $ 3 \\<noteq> 0 $ (3::?'a1)\n\ngoal (1 subgoal):\n 1. vector2_append1 v \\<noteq> 0", "thus \"vector2_append1 v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  vector2_append1 v $ 3 \\<noteq> 0 $ (3::?'a1)\n\ngoal (1 subgoal):\n 1. vector2_append1 v \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  vector2_append1 v \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "definition proj2_pt :: \"real^2 \\<Rightarrow> proj2\" where\n  \"proj2_pt v \\<equiv> proj2_abs (vector2_append1 v)\""], ["", "lemma proj2_pt_scalar:\n  \"\\<exists> c. c \\<noteq> 0 \\<and> proj2_rep (proj2_pt v) = c *\\<^sub>R vector2_append1 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       c \\<noteq> 0 \\<and>\n       proj2_rep (proj2_pt v) = c *\\<^sub>R vector2_append1 v", "unfolding proj2_pt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       c \\<noteq> 0 \\<and>\n       proj2_rep (proj2_abs (vector2_append1 v)) =\n       c *\\<^sub>R vector2_append1 v", "by (simp add: proj2_rep_abs2 vector2_append1_non_zero)"], ["", "abbreviation z_non_zero :: \"proj2 \\<Rightarrow> bool\" where\n  \"z_non_zero p \\<equiv> (proj2_rep p)$3 \\<noteq> 0\""], ["", "definition cart2_pt :: \"proj2 \\<Rightarrow> real^2\" where\n  \"cart2_pt p \\<equiv>\n  vector [(proj2_rep p)$1 / (proj2_rep p)$3, (proj2_rep p)$2 / (proj2_rep p)$3]\""], ["", "definition cart2_append1 :: \"proj2 \\<Rightarrow> real^3\" where\n  \"cart2_append1 p \\<equiv>  (1 / ((proj2_rep p)$3)) *\\<^sub>R proj2_rep p\""], ["", "lemma cart2_append1_z:\n  assumes \"z_non_zero p\"\n  shows \"(cart2_append1 p)$3 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cart2_append1 p $ 3 = 1", "using \\<open>z_non_zero p\\<close>"], ["proof (prove)\nusing this:\n  z_non_zero p\n\ngoal (1 subgoal):\n 1. cart2_append1 p $ 3 = 1", "by (unfold cart2_append1_def) simp"], ["", "lemma cart2_append1_non_zero:\n  assumes \"z_non_zero p\"\n  shows \"cart2_append1 p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cart2_append1 p \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cart2_append1 p \\<noteq> 0", "from \\<open>z_non_zero p\\<close>"], ["proof (chain)\npicking this:\n  z_non_zero p", "have \"(cart2_append1 p)$3 = 1\""], ["proof (prove)\nusing this:\n  z_non_zero p\n\ngoal (1 subgoal):\n 1. cart2_append1 p $ 3 = 1", "by (rule cart2_append1_z)"], ["proof (state)\nthis:\n  cart2_append1 p $ 3 = 1\n\ngoal (1 subgoal):\n 1. cart2_append1 p \\<noteq> 0", "thus \"cart2_append1 p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  cart2_append1 p $ 3 = 1\n\ngoal (1 subgoal):\n 1. cart2_append1 p \\<noteq> 0", "by (simp add: vec_eq_iff exI [of _ 3])"], ["proof (state)\nthis:\n  cart2_append1 p \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_rep_cart2_append1:\n  assumes \"z_non_zero p\"\n  shows \"proj2_rep p = ((proj2_rep p)$3) *\\<^sub>R cart2_append1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_rep p = proj2_rep p $ 3 *\\<^sub>R cart2_append1 p", "using \\<open>z_non_zero p\\<close>"], ["proof (prove)\nusing this:\n  z_non_zero p\n\ngoal (1 subgoal):\n 1. proj2_rep p = proj2_rep p $ 3 *\\<^sub>R cart2_append1 p", "by (unfold cart2_append1_def) simp"], ["", "lemma proj2_abs_cart2_append1:\n  assumes \"z_non_zero p\"\n  shows \"proj2_abs (cart2_append1 p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_abs (cart2_append1 p) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_abs (cart2_append1 p) = p", "from \\<open>z_non_zero p\\<close>"], ["proof (chain)\npicking this:\n  z_non_zero p", "have \"proj2_abs (cart2_append1 p) = proj2_abs (proj2_rep p)\""], ["proof (prove)\nusing this:\n  z_non_zero p\n\ngoal (1 subgoal):\n 1. proj2_abs (cart2_append1 p) = proj2_abs (proj2_rep p)", "by (unfold cart2_append1_def) (simp add: proj2_abs_mult)"], ["proof (state)\nthis:\n  proj2_abs (cart2_append1 p) = proj2_abs (proj2_rep p)\n\ngoal (1 subgoal):\n 1. proj2_abs (cart2_append1 p) = p", "thus \"proj2_abs (cart2_append1 p) = p\""], ["proof (prove)\nusing this:\n  proj2_abs (cart2_append1 p) = proj2_abs (proj2_rep p)\n\ngoal (1 subgoal):\n 1. proj2_abs (cart2_append1 p) = p", "by (simp add: proj2_abs_rep)"], ["proof (state)\nthis:\n  proj2_abs (cart2_append1 p) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart2_append1_inj:\n  assumes \"z_non_zero p\" and \"cart2_append1 p = cart2_append1 q\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = q", "from \\<open>z_non_zero p\\<close>"], ["proof (chain)\npicking this:\n  z_non_zero p", "have \"(cart2_append1 p)$3 = 1\""], ["proof (prove)\nusing this:\n  z_non_zero p\n\ngoal (1 subgoal):\n 1. cart2_append1 p $ 3 = 1", "by (rule cart2_append1_z)"], ["proof (state)\nthis:\n  cart2_append1 p $ 3 = 1\n\ngoal (1 subgoal):\n 1. p = q", "with \\<open>cart2_append1 p = cart2_append1 q\\<close>"], ["proof (chain)\npicking this:\n  cart2_append1 p = cart2_append1 q\n  cart2_append1 p $ 3 = 1", "have \"(cart2_append1 q)$3 = 1\""], ["proof (prove)\nusing this:\n  cart2_append1 p = cart2_append1 q\n  cart2_append1 p $ 3 = 1\n\ngoal (1 subgoal):\n 1. cart2_append1 q $ 3 = 1", "by simp"], ["proof (state)\nthis:\n  cart2_append1 q $ 3 = 1\n\ngoal (1 subgoal):\n 1. p = q", "hence \"z_non_zero q\""], ["proof (prove)\nusing this:\n  cart2_append1 q $ 3 = 1\n\ngoal (1 subgoal):\n 1. z_non_zero q", "by (unfold cart2_append1_def) auto"], ["proof (state)\nthis:\n  z_non_zero q\n\ngoal (1 subgoal):\n 1. p = q", "from \\<open>cart2_append1 p = cart2_append1 q\\<close>"], ["proof (chain)\npicking this:\n  cart2_append1 p = cart2_append1 q", "have \"proj2_abs (cart2_append1 p) = proj2_abs (cart2_append1 q)\""], ["proof (prove)\nusing this:\n  cart2_append1 p = cart2_append1 q\n\ngoal (1 subgoal):\n 1. proj2_abs (cart2_append1 p) = proj2_abs (cart2_append1 q)", "by simp"], ["proof (state)\nthis:\n  proj2_abs (cart2_append1 p) = proj2_abs (cart2_append1 q)\n\ngoal (1 subgoal):\n 1. p = q", "with \\<open>z_non_zero p\\<close> and \\<open>z_non_zero q\\<close>"], ["proof (chain)\npicking this:\n  z_non_zero p\n  z_non_zero q\n  proj2_abs (cart2_append1 p) = proj2_abs (cart2_append1 q)", "show \"p = q\""], ["proof (prove)\nusing this:\n  z_non_zero p\n  z_non_zero q\n  proj2_abs (cart2_append1 p) = proj2_abs (cart2_append1 q)\n\ngoal (1 subgoal):\n 1. p = q", "by (simp add: proj2_abs_cart2_append1)"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart2_append1:\n  assumes \"z_non_zero p\"\n  shows \"vector2_append1 (cart2_pt p) = cart2_append1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector2_append1 (cart2_pt p) = cart2_append1 p", "using \\<open>z_non_zero p\\<close>"], ["proof (prove)\nusing this:\n  z_non_zero p\n\ngoal (1 subgoal):\n 1. vector2_append1 (cart2_pt p) = cart2_append1 p", "unfolding vector2_append1_def\n    and cart2_append1_def\n    and cart2_pt_def\n    and vector_def"], ["proof (prove)\nusing this:\n  z_non_zero p\n\ngoal (1 subgoal):\n 1. vec_lambda\n     (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n       [vec_lambda\n         (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n           [proj2_rep p $ 1 / proj2_rep p $ 3,\n            proj2_rep p $ 2 / proj2_rep p $ 3]\n           (\\<lambda>n x. 0) 1) $\n        1,\n        vec_lambda\n         (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n           [proj2_rep p $ 1 / proj2_rep p $ 3,\n            proj2_rep p $ 2 / proj2_rep p $ 3]\n           (\\<lambda>n x. 0) 1) $\n        2,\n        1]\n       (\\<lambda>n x. 0) 1) =\n    (1 / proj2_rep p $ 3) *\\<^sub>R proj2_rep p", "by (simp add: vec_eq_iff forall_3)"], ["", "lemma cart2_proj2: \"cart2_pt (proj2_pt v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cart2_pt (proj2_pt v) = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cart2_pt (proj2_pt v) = v", "let ?v' = \"vector2_append1 v\""], ["proof (state)\ngoal (1 subgoal):\n 1. cart2_pt (proj2_pt v) = v", "let ?p = \"proj2_pt v\""], ["proof (state)\ngoal (1 subgoal):\n 1. cart2_pt (proj2_pt v) = v", "from proj2_pt_scalar"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     c \\<noteq> 0 \\<and>\n     proj2_rep (proj2_pt ?v) = c *\\<^sub>R vector2_append1 ?v", "obtain c where \"c \\<noteq> 0\" and \"proj2_rep ?p = c *\\<^sub>R ?v'\""], ["proof (prove)\nusing this:\n  \\<exists>c.\n     c \\<noteq> 0 \\<and>\n     proj2_rep (proj2_pt ?v) = c *\\<^sub>R vector2_append1 ?v\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<noteq> 0;\n         proj2_rep (proj2_pt v) = c *\\<^sub>R vector2_append1 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  proj2_rep (proj2_pt v) = c *\\<^sub>R vector2_append1 v\n\ngoal (1 subgoal):\n 1. cart2_pt (proj2_pt v) = v", "hence \"(cart2_pt ?p)$1 = v$1\" and \"(cart2_pt ?p)$2 = v$2\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  proj2_rep (proj2_pt v) = c *\\<^sub>R vector2_append1 v\n\ngoal (1 subgoal):\n 1. cart2_pt (proj2_pt v) $ 1 = v $ 1 &&& cart2_pt (proj2_pt v) $ 2 = v $ 2", "unfolding cart2_pt_def and vector2_append1_def and vector_def"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  proj2_rep (proj2_pt v) =\n  c *\\<^sub>R\n  vec_lambda\n   (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [v $ 1, v $ 2, 1]\n     (\\<lambda>n x. 0) 1)\n\ngoal (1 subgoal):\n 1. vec_lambda\n     (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n       [proj2_rep (proj2_pt v) $ 1 / proj2_rep (proj2_pt v) $ 3,\n        proj2_rep (proj2_pt v) $ 2 / proj2_rep (proj2_pt v) $ 3]\n       (\\<lambda>n x. 0) 1) $\n    1 =\n    v $ 1 &&&\n    vec_lambda\n     (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n       [proj2_rep (proj2_pt v) $ 1 / proj2_rep (proj2_pt v) $ 3,\n        proj2_rep (proj2_pt v) $ 2 / proj2_rep (proj2_pt v) $ 3]\n       (\\<lambda>n x. 0) 1) $\n    2 =\n    v $ 2", "by simp+"], ["proof (state)\nthis:\n  cart2_pt (proj2_pt v) $ 1 = v $ 1\n  cart2_pt (proj2_pt v) $ 2 = v $ 2\n\ngoal (1 subgoal):\n 1. cart2_pt (proj2_pt v) = v", "thus \"cart2_pt ?p = v\""], ["proof (prove)\nusing this:\n  cart2_pt (proj2_pt v) $ 1 = v $ 1\n  cart2_pt (proj2_pt v) $ 2 = v $ 2\n\ngoal (1 subgoal):\n 1. cart2_pt (proj2_pt v) = v", "by (simp add: vec_eq_iff forall_2)"], ["proof (state)\nthis:\n  cart2_pt (proj2_pt v) = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma z_non_zero_proj2_pt: \"z_non_zero (proj2_pt v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z_non_zero (proj2_pt v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z_non_zero (proj2_pt v)", "from proj2_pt_scalar"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     c \\<noteq> 0 \\<and>\n     proj2_rep (proj2_pt ?v) = c *\\<^sub>R vector2_append1 ?v", "obtain c where \"c \\<noteq> 0\" and \"proj2_rep (proj2_pt v) = c *\\<^sub>R (vector2_append1 v)\""], ["proof (prove)\nusing this:\n  \\<exists>c.\n     c \\<noteq> 0 \\<and>\n     proj2_rep (proj2_pt ?v) = c *\\<^sub>R vector2_append1 ?v\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<noteq> 0;\n         proj2_rep (proj2_pt v) = c *\\<^sub>R vector2_append1 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  proj2_rep (proj2_pt v) = c *\\<^sub>R vector2_append1 v\n\ngoal (1 subgoal):\n 1. z_non_zero (proj2_pt v)", "from \\<open>proj2_rep (proj2_pt v) = c *\\<^sub>R (vector2_append1 v)\\<close>"], ["proof (chain)\npicking this:\n  proj2_rep (proj2_pt v) = c *\\<^sub>R vector2_append1 v", "have \"(proj2_rep (proj2_pt v))$3 = c\""], ["proof (prove)\nusing this:\n  proj2_rep (proj2_pt v) = c *\\<^sub>R vector2_append1 v\n\ngoal (1 subgoal):\n 1. proj2_rep (proj2_pt v) $ 3 = c", "unfolding vector2_append1_def and vector_def"], ["proof (prove)\nusing this:\n  proj2_rep (proj2_pt v) =\n  c *\\<^sub>R\n  vec_lambda\n   (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [v $ 1, v $ 2, 1]\n     (\\<lambda>n x. 0) 1)\n\ngoal (1 subgoal):\n 1. proj2_rep (proj2_pt v) $ 3 = c", "by simp"], ["proof (state)\nthis:\n  proj2_rep (proj2_pt v) $ 3 = c\n\ngoal (1 subgoal):\n 1. z_non_zero (proj2_pt v)", "with \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> 0\n  proj2_rep (proj2_pt v) $ 3 = c", "show \"z_non_zero (proj2_pt v)\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  proj2_rep (proj2_pt v) $ 3 = c\n\ngoal (1 subgoal):\n 1. z_non_zero (proj2_pt v)", "by simp"], ["proof (state)\nthis:\n  z_non_zero (proj2_pt v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart2_append1_proj2: \"cart2_append1 (proj2_pt v) = vector2_append1 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cart2_append1 (proj2_pt v) = vector2_append1 v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cart2_append1 (proj2_pt v) = vector2_append1 v", "from z_non_zero_proj2_pt"], ["proof (chain)\npicking this:\n  z_non_zero (proj2_pt ?v)", "have \"cart2_append1 (proj2_pt v) = vector2_append1 (cart2_pt (proj2_pt v))\""], ["proof (prove)\nusing this:\n  z_non_zero (proj2_pt ?v)\n\ngoal (1 subgoal):\n 1. cart2_append1 (proj2_pt v) = vector2_append1 (cart2_pt (proj2_pt v))", "by (simp add: cart2_append1)"], ["proof (state)\nthis:\n  cart2_append1 (proj2_pt v) = vector2_append1 (cart2_pt (proj2_pt v))\n\ngoal (1 subgoal):\n 1. cart2_append1 (proj2_pt v) = vector2_append1 v", "thus \"cart2_append1 (proj2_pt v) = vector2_append1 v\""], ["proof (prove)\nusing this:\n  cart2_append1 (proj2_pt v) = vector2_append1 (cart2_pt (proj2_pt v))\n\ngoal (1 subgoal):\n 1. cart2_append1 (proj2_pt v) = vector2_append1 v", "by (simp add: cart2_proj2)"], ["proof (state)\nthis:\n  cart2_append1 (proj2_pt v) = vector2_append1 v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_pt_inj: \"inj proj2_pt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj proj2_pt", "by (simp add: inj_on_inverseI [of UNIV cart2_pt proj2_pt] cart2_proj2)"], ["", "lemma proj2_cart2:\n  assumes \"z_non_zero p\"\n  shows \"proj2_pt (cart2_pt p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_pt (cart2_pt p) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_pt (cart2_pt p) = p", "from \\<open>z_non_zero p\\<close>"], ["proof (chain)\npicking this:\n  z_non_zero p", "have \"(proj2_rep p)$3 *\\<^sub>R vector2_append1 (cart2_pt p) = proj2_rep p\""], ["proof (prove)\nusing this:\n  z_non_zero p\n\ngoal (1 subgoal):\n 1. proj2_rep p $ 3 *\\<^sub>R vector2_append1 (cart2_pt p) = proj2_rep p", "unfolding vector2_append1_def and cart2_pt_def and vector_def"], ["proof (prove)\nusing this:\n  z_non_zero p\n\ngoal (1 subgoal):\n 1. proj2_rep p $ 3 *\\<^sub>R\n    vec_lambda\n     (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n       [vec_lambda\n         (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n           [proj2_rep p $ 1 / proj2_rep p $ 3,\n            proj2_rep p $ 2 / proj2_rep p $ 3]\n           (\\<lambda>n x. 0) 1) $\n        1,\n        vec_lambda\n         (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n           [proj2_rep p $ 1 / proj2_rep p $ 3,\n            proj2_rep p $ 2 / proj2_rep p $ 3]\n           (\\<lambda>n x. 0) 1) $\n        2,\n        1]\n       (\\<lambda>n x. 0) 1) =\n    proj2_rep p", "by (simp add: vec_eq_iff forall_3)"], ["proof (state)\nthis:\n  proj2_rep p $ 3 *\\<^sub>R vector2_append1 (cart2_pt p) = proj2_rep p\n\ngoal (1 subgoal):\n 1. proj2_pt (cart2_pt p) = p", "with \\<open>z_non_zero p\\<close>\n    and proj2_abs_mult [of \"(proj2_rep p)$3\" \"vector2_append1 (cart2_pt p)\"]"], ["proof (chain)\npicking this:\n  z_non_zero p\n  z_non_zero p \\<Longrightarrow>\n  proj2_abs (proj2_rep p $ 3 *\\<^sub>R vector2_append1 (cart2_pt p)) =\n  proj2_abs (vector2_append1 (cart2_pt p))\n  proj2_rep p $ 3 *\\<^sub>R vector2_append1 (cart2_pt p) = proj2_rep p", "have \"proj2_abs (vector2_append1 (cart2_pt p)) = proj2_abs (proj2_rep p)\""], ["proof (prove)\nusing this:\n  z_non_zero p\n  z_non_zero p \\<Longrightarrow>\n  proj2_abs (proj2_rep p $ 3 *\\<^sub>R vector2_append1 (cart2_pt p)) =\n  proj2_abs (vector2_append1 (cart2_pt p))\n  proj2_rep p $ 3 *\\<^sub>R vector2_append1 (cart2_pt p) = proj2_rep p\n\ngoal (1 subgoal):\n 1. proj2_abs (vector2_append1 (cart2_pt p)) = proj2_abs (proj2_rep p)", "by simp"], ["proof (state)\nthis:\n  proj2_abs (vector2_append1 (cart2_pt p)) = proj2_abs (proj2_rep p)\n\ngoal (1 subgoal):\n 1. proj2_pt (cart2_pt p) = p", "thus \"proj2_pt (cart2_pt p) = p\""], ["proof (prove)\nusing this:\n  proj2_abs (vector2_append1 (cart2_pt p)) = proj2_abs (proj2_rep p)\n\ngoal (1 subgoal):\n 1. proj2_pt (cart2_pt p) = p", "by (unfold proj2_pt_def) (simp add: proj2_abs_rep)"], ["proof (state)\nthis:\n  proj2_pt (cart2_pt p) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart2_injective:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"cart2_pt p = cart2_pt q\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = q", "from \\<open>z_non_zero p\\<close> and \\<open>z_non_zero q\\<close>"], ["proof (chain)\npicking this:\n  z_non_zero p\n  z_non_zero q", "have \"proj2_pt (cart2_pt p) = p\" and \"proj2_pt (cart2_pt q) = q\""], ["proof (prove)\nusing this:\n  z_non_zero p\n  z_non_zero q\n\ngoal (1 subgoal):\n 1. proj2_pt (cart2_pt p) = p &&& proj2_pt (cart2_pt q) = q", "by (simp_all add: proj2_cart2)"], ["proof (state)\nthis:\n  proj2_pt (cart2_pt p) = p\n  proj2_pt (cart2_pt q) = q\n\ngoal (1 subgoal):\n 1. p = q", "from \\<open>proj2_pt (cart2_pt p) = p\\<close> and \\<open>cart2_pt p = cart2_pt q\\<close>"], ["proof (chain)\npicking this:\n  proj2_pt (cart2_pt p) = p\n  cart2_pt p = cart2_pt q", "have \"proj2_pt (cart2_pt q) = p\""], ["proof (prove)\nusing this:\n  proj2_pt (cart2_pt p) = p\n  cart2_pt p = cart2_pt q\n\ngoal (1 subgoal):\n 1. proj2_pt (cart2_pt q) = p", "by simp"], ["proof (state)\nthis:\n  proj2_pt (cart2_pt q) = p\n\ngoal (1 subgoal):\n 1. p = q", "with \\<open>proj2_pt (cart2_pt q) = q\\<close>"], ["proof (chain)\npicking this:\n  proj2_pt (cart2_pt q) = q\n  proj2_pt (cart2_pt q) = p", "show \"p = q\""], ["proof (prove)\nusing this:\n  proj2_pt (cart2_pt q) = q\n  proj2_pt (cart2_pt q) = p\n\ngoal (1 subgoal):\n 1. p = q", "by simp"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_Col_iff_euclid:\n  \"proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<longleftrightarrow> real_euclid.Col a b c\"\n  (is \"proj2_Col ?p ?q ?r \\<longleftrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) = real_euclid.Col a b c", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "let ?a' = \"vector2_append1 a\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "let ?b' = \"vector2_append1 b\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "let ?c' = \"vector2_append1 c\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "let ?a'' = \"proj2_rep ?p\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "let ?b'' = \"proj2_rep ?q\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "let ?c'' = \"proj2_rep ?r\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "from proj2_pt_scalar"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     c \\<noteq> 0 \\<and>\n     proj2_rep (proj2_pt ?v) = c *\\<^sub>R vector2_append1 ?v", "obtain i and j and k where\n    \"i \\<noteq> 0\" and \"?a'' = i *\\<^sub>R ?a'\"\n    and \"j \\<noteq> 0\" and \"?b'' = j *\\<^sub>R ?b'\"\n    and \"k \\<noteq> 0\" and \"?c'' = k *\\<^sub>R ?c'\""], ["proof (prove)\nusing this:\n  \\<exists>c.\n     c \\<noteq> 0 \\<and>\n     proj2_rep (proj2_pt ?v) = c *\\<^sub>R vector2_append1 ?v\n\ngoal (1 subgoal):\n 1. (\\<And>i j k.\n        \\<lbrakk>i \\<noteq> 0;\n         proj2_rep (proj2_pt a) = i *\\<^sub>R vector2_append1 a;\n         j \\<noteq> 0;\n         proj2_rep (proj2_pt b) = j *\\<^sub>R vector2_append1 b;\n         k \\<noteq> 0;\n         proj2_rep (proj2_pt c) = k *\\<^sub>R vector2_append1 c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  i \\<noteq> 0\n  proj2_rep (proj2_pt a) = i *\\<^sub>R vector2_append1 a\n  j \\<noteq> 0\n  proj2_rep (proj2_pt b) = j *\\<^sub>R vector2_append1 b\n  k \\<noteq> 0\n  proj2_rep (proj2_pt c) = k *\\<^sub>R vector2_append1 c\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "hence \"?a' = (1/i) *\\<^sub>R ?a''\"\n    and \"?b' = (1/j) *\\<^sub>R ?b''\"\n    and \"?c' = (1/k) *\\<^sub>R ?c''\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  proj2_rep (proj2_pt a) = i *\\<^sub>R vector2_append1 a\n  j \\<noteq> 0\n  proj2_rep (proj2_pt b) = j *\\<^sub>R vector2_append1 b\n  k \\<noteq> 0\n  proj2_rep (proj2_pt c) = k *\\<^sub>R vector2_append1 c\n\ngoal (1 subgoal):\n 1. vector2_append1 a = (1 / i) *\\<^sub>R proj2_rep (proj2_pt a) &&&\n    vector2_append1 b = (1 / j) *\\<^sub>R proj2_rep (proj2_pt b) &&&\n    vector2_append1 c = (1 / k) *\\<^sub>R proj2_rep (proj2_pt c)", "by simp_all"], ["proof (state)\nthis:\n  vector2_append1 a = (1 / i) *\\<^sub>R proj2_rep (proj2_pt a)\n  vector2_append1 b = (1 / j) *\\<^sub>R proj2_rep (proj2_pt b)\n  vector2_append1 c = (1 / k) *\\<^sub>R proj2_rep (proj2_pt c)\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "{"], ["proof (state)\nthis:\n  vector2_append1 a = (1 / i) *\\<^sub>R proj2_rep (proj2_pt a)\n  vector2_append1 b = (1 / j) *\\<^sub>R proj2_rep (proj2_pt b)\n  vector2_append1 c = (1 / k) *\\<^sub>R proj2_rep (proj2_pt c)\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "assume \"proj2_Col ?p ?q ?r\""], ["proof (state)\nthis:\n  proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "then"], ["proof (chain)\npicking this:\n  proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "obtain i' and j' and k' where\n      \"i' *\\<^sub>R ?a'' + j' *\\<^sub>R ?b'' + k' *\\<^sub>R ?c'' = 0\" and \"i'\\<noteq>0 \\<or> j'\\<noteq>0 \\<or> k'\\<noteq>0\""], ["proof (prove)\nusing this:\n  proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)\n\ngoal (1 subgoal):\n 1. (\\<And>i' j' k'.\n        \\<lbrakk>i' *\\<^sub>R proj2_rep (proj2_pt a) +\n                 j' *\\<^sub>R proj2_rep (proj2_pt b) +\n                 k' *\\<^sub>R proj2_rep (proj2_pt c) =\n                 0;\n         i' \\<noteq> 0 \\<or> j' \\<noteq> 0 \\<or> k' \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding proj2_Col_def"], ["proof (prove)\nusing this:\n  \\<exists>i j k.\n     i *\\<^sub>R proj2_rep (proj2_pt a) +\n     j *\\<^sub>R proj2_rep (proj2_pt b) +\n     k *\\<^sub>R proj2_rep (proj2_pt c) =\n     0 \\<and>\n     (i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>i' j' k'.\n        \\<lbrakk>i' *\\<^sub>R proj2_rep (proj2_pt a) +\n                 j' *\\<^sub>R proj2_rep (proj2_pt b) +\n                 k' *\\<^sub>R proj2_rep (proj2_pt c) =\n                 0;\n         i' \\<noteq> 0 \\<or> j' \\<noteq> 0 \\<or> k' \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i' *\\<^sub>R proj2_rep (proj2_pt a) +\n  j' *\\<^sub>R proj2_rep (proj2_pt b) +\n  k' *\\<^sub>R proj2_rep (proj2_pt c) =\n  0\n  i' \\<noteq> 0 \\<or> j' \\<noteq> 0 \\<or> k' \\<noteq> 0\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "let ?i'' = \"i * i'\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "let ?j'' = \"j * j'\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "let ?k'' = \"k * k'\""], ["proof (state)\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "from \\<open>i\\<noteq>0\\<close> and \\<open>j\\<noteq>0\\<close> and \\<open>k\\<noteq>0\\<close> and \\<open>i'\\<noteq>0 \\<or> j'\\<noteq>0 \\<or> k'\\<noteq>0\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  j \\<noteq> 0\n  k \\<noteq> 0\n  i' \\<noteq> 0 \\<or> j' \\<noteq> 0 \\<or> k' \\<noteq> 0", "have \"?i''\\<noteq>0 \\<or> ?j''\\<noteq>0 \\<or> ?k''\\<noteq>0\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  j \\<noteq> 0\n  k \\<noteq> 0\n  i' \\<noteq> 0 \\<or> j' \\<noteq> 0 \\<or> k' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i * i' \\<noteq> 0 \\<or> j * j' \\<noteq> 0 \\<or> k * k' \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  i * i' \\<noteq> 0 \\<or> j * j' \\<noteq> 0 \\<or> k * k' \\<noteq> 0\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "from \\<open>i' *\\<^sub>R ?a'' + j' *\\<^sub>R ?b'' + k' *\\<^sub>R ?c'' = 0\\<close>\n      and \\<open>?a'' = i *\\<^sub>R ?a'\\<close>\n      and \\<open>?b'' = j *\\<^sub>R ?b'\\<close>\n      and \\<open>?c'' = k *\\<^sub>R ?c'\\<close>"], ["proof (chain)\npicking this:\n  i' *\\<^sub>R proj2_rep (proj2_pt a) +\n  j' *\\<^sub>R proj2_rep (proj2_pt b) +\n  k' *\\<^sub>R proj2_rep (proj2_pt c) =\n  0\n  proj2_rep (proj2_pt a) = i *\\<^sub>R vector2_append1 a\n  proj2_rep (proj2_pt b) = j *\\<^sub>R vector2_append1 b\n  proj2_rep (proj2_pt c) = k *\\<^sub>R vector2_append1 c", "have \"?i'' *\\<^sub>R ?a' + ?j'' *\\<^sub>R ?b' + ?k'' *\\<^sub>R ?c' = 0\""], ["proof (prove)\nusing this:\n  i' *\\<^sub>R proj2_rep (proj2_pt a) +\n  j' *\\<^sub>R proj2_rep (proj2_pt b) +\n  k' *\\<^sub>R proj2_rep (proj2_pt c) =\n  0\n  proj2_rep (proj2_pt a) = i *\\<^sub>R vector2_append1 a\n  proj2_rep (proj2_pt b) = j *\\<^sub>R vector2_append1 b\n  proj2_rep (proj2_pt c) = k *\\<^sub>R vector2_append1 c\n\ngoal (1 subgoal):\n 1. (i * i') *\\<^sub>R vector2_append1 a +\n    (j * j') *\\<^sub>R vector2_append1 b +\n    (k * k') *\\<^sub>R vector2_append1 c =\n    0", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (i * i') *\\<^sub>R vector2_append1 a +\n  (j * j') *\\<^sub>R vector2_append1 b +\n  (k * k') *\\<^sub>R vector2_append1 c =\n  0\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "hence \"(?i'' *\\<^sub>R ?a' + ?j'' *\\<^sub>R ?b' + ?k'' *\\<^sub>R ?c')$3 = 0\""], ["proof (prove)\nusing this:\n  (i * i') *\\<^sub>R vector2_append1 a +\n  (j * j') *\\<^sub>R vector2_append1 b +\n  (k * k') *\\<^sub>R vector2_append1 c =\n  0\n\ngoal (1 subgoal):\n 1. ((i * i') *\\<^sub>R vector2_append1 a +\n     (j * j') *\\<^sub>R vector2_append1 b +\n     (k * k') *\\<^sub>R vector2_append1 c) $\n    3 =\n    0", "by simp"], ["proof (state)\nthis:\n  ((i * i') *\\<^sub>R vector2_append1 a +\n   (j * j') *\\<^sub>R vector2_append1 b +\n   (k * k') *\\<^sub>R vector2_append1 c) $\n  3 =\n  0\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "hence \"?i'' + ?j'' + ?k'' = 0\""], ["proof (prove)\nusing this:\n  ((i * i') *\\<^sub>R vector2_append1 a +\n   (j * j') *\\<^sub>R vector2_append1 b +\n   (k * k') *\\<^sub>R vector2_append1 c) $\n  3 =\n  0\n\ngoal (1 subgoal):\n 1. i * i' + j * j' + k * k' = 0", "unfolding vector2_append1_def and vector_def"], ["proof (prove)\nusing this:\n  ((i * i') *\\<^sub>R\n   vec_lambda\n    (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [a $ 1, a $ 2, 1]\n      (\\<lambda>n x. 0) 1) +\n   (j * j') *\\<^sub>R\n   vec_lambda\n    (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [b $ 1, b $ 2, 1]\n      (\\<lambda>n x. 0) 1) +\n   (k * k') *\\<^sub>R\n   vec_lambda\n    (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [c $ 1, c $ 2, 1]\n      (\\<lambda>n x. 0) 1)) $\n  3 =\n  0\n\ngoal (1 subgoal):\n 1. i * i' + j * j' + k * k' = 0", "by simp"], ["proof (state)\nthis:\n  i * i' + j * j' + k * k' = 0\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "have \"(?i'' *\\<^sub>R ?a' + ?j'' *\\<^sub>R ?b' + ?k'' *\\<^sub>R ?c')$1 =\n      (?i'' *\\<^sub>R a + ?j'' *\\<^sub>R b + ?k'' *\\<^sub>R c)$1\"\n      and \"(?i'' *\\<^sub>R ?a' + ?j'' *\\<^sub>R ?b' + ?k'' *\\<^sub>R ?c')$2 =\n      (?i'' *\\<^sub>R a + ?j'' *\\<^sub>R b + ?k'' *\\<^sub>R c)$2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((i * i') *\\<^sub>R vector2_append1 a +\n     (j * j') *\\<^sub>R vector2_append1 b +\n     (k * k') *\\<^sub>R vector2_append1 c) $\n    1 =\n    ((i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c) $\n    1 &&&\n    ((i * i') *\\<^sub>R vector2_append1 a +\n     (j * j') *\\<^sub>R vector2_append1 b +\n     (k * k') *\\<^sub>R vector2_append1 c) $\n    2 =\n    ((i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c) $ 2", "unfolding vector2_append1_def and vector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((i * i') *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [a $ 1, a $ 2, 1]\n        (\\<lambda>n x. 0) 1) +\n     (j * j') *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [b $ 1, b $ 2, 1]\n        (\\<lambda>n x. 0) 1) +\n     (k * k') *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [c $ 1, c $ 2, 1]\n        (\\<lambda>n x. 0) 1)) $\n    1 =\n    ((i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c) $\n    1 &&&\n    ((i * i') *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [a $ 1, a $ 2, 1]\n        (\\<lambda>n x. 0) 1) +\n     (j * j') *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [b $ 1, b $ 2, 1]\n        (\\<lambda>n x. 0) 1) +\n     (k * k') *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [c $ 1, c $ 2, 1]\n        (\\<lambda>n x. 0) 1)) $\n    2 =\n    ((i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c) $ 2", "by simp+"], ["proof (state)\nthis:\n  ((i * i') *\\<^sub>R vector2_append1 a +\n   (j * j') *\\<^sub>R vector2_append1 b +\n   (k * k') *\\<^sub>R vector2_append1 c) $\n  1 =\n  ((i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c) $ 1\n  ((i * i') *\\<^sub>R vector2_append1 a +\n   (j * j') *\\<^sub>R vector2_append1 b +\n   (k * k') *\\<^sub>R vector2_append1 c) $\n  2 =\n  ((i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c) $ 2\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "with \\<open>?i'' *\\<^sub>R ?a' + ?j'' *\\<^sub>R ?b' + ?k'' *\\<^sub>R ?c' = 0\\<close>"], ["proof (chain)\npicking this:\n  (i * i') *\\<^sub>R vector2_append1 a +\n  (j * j') *\\<^sub>R vector2_append1 b +\n  (k * k') *\\<^sub>R vector2_append1 c =\n  0\n  ((i * i') *\\<^sub>R vector2_append1 a +\n   (j * j') *\\<^sub>R vector2_append1 b +\n   (k * k') *\\<^sub>R vector2_append1 c) $\n  1 =\n  ((i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c) $ 1\n  ((i * i') *\\<^sub>R vector2_append1 a +\n   (j * j') *\\<^sub>R vector2_append1 b +\n   (k * k') *\\<^sub>R vector2_append1 c) $\n  2 =\n  ((i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c) $ 2", "have \"?i'' *\\<^sub>R a + ?j'' *\\<^sub>R b + ?k'' *\\<^sub>R c = 0\""], ["proof (prove)\nusing this:\n  (i * i') *\\<^sub>R vector2_append1 a +\n  (j * j') *\\<^sub>R vector2_append1 b +\n  (k * k') *\\<^sub>R vector2_append1 c =\n  0\n  ((i * i') *\\<^sub>R vector2_append1 a +\n   (j * j') *\\<^sub>R vector2_append1 b +\n   (k * k') *\\<^sub>R vector2_append1 c) $\n  1 =\n  ((i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c) $ 1\n  ((i * i') *\\<^sub>R vector2_append1 a +\n   (j * j') *\\<^sub>R vector2_append1 b +\n   (k * k') *\\<^sub>R vector2_append1 c) $\n  2 =\n  ((i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c) $ 2\n\ngoal (1 subgoal):\n 1. (i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c = 0", "by (simp add: vec_eq_iff forall_2)"], ["proof (state)\nthis:\n  (i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c = 0\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "have \"dep2 (b - a) (c - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dep2 (b - a) (c - a)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> dep2 (b - a) (c - a)\n 2. \\<not> ?P \\<Longrightarrow> dep2 (b - a) (c - a)", "assume \"?k'' = 0\""], ["proof (state)\nthis:\n  k * k' = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> dep2 (b - a) (c - a)\n 2. \\<not> ?P \\<Longrightarrow> dep2 (b - a) (c - a)", "with \\<open>?i'' + ?j'' + ?k'' = 0\\<close>"], ["proof (chain)\npicking this:\n  i * i' + j * j' + k * k' = 0\n  k * k' = 0", "have \"?j'' = -?i''\""], ["proof (prove)\nusing this:\n  i * i' + j * j' + k * k' = 0\n  k * k' = 0\n\ngoal (1 subgoal):\n 1. j * j' = - (i * i')", "by simp"], ["proof (state)\nthis:\n  j * j' = - (i * i')\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> dep2 (b - a) (c - a)\n 2. \\<not> ?P \\<Longrightarrow> dep2 (b - a) (c - a)", "with \\<open>?i''\\<noteq>0 \\<or> ?j''\\<noteq>0 \\<or> ?k''\\<noteq>0\\<close> and \\<open>?k'' = 0\\<close>"], ["proof (chain)\npicking this:\n  i * i' \\<noteq> 0 \\<or> j * j' \\<noteq> 0 \\<or> k * k' \\<noteq> 0\n  k * k' = 0\n  j * j' = - (i * i')", "have \"?i'' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i * i' \\<noteq> 0 \\<or> j * j' \\<noteq> 0 \\<or> k * k' \\<noteq> 0\n  k * k' = 0\n  j * j' = - (i * i')\n\ngoal (1 subgoal):\n 1. i * i' \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  i * i' \\<noteq> 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> dep2 (b - a) (c - a)\n 2. \\<not> ?P \\<Longrightarrow> dep2 (b - a) (c - a)", "from \\<open>?i'' *\\<^sub>R a + ?j'' *\\<^sub>R b + ?k'' *\\<^sub>R c = 0\\<close>\n        and \\<open>?k'' = 0\\<close> and \\<open>?j'' = -?i''\\<close>"], ["proof (chain)\npicking this:\n  (i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c = 0\n  k * k' = 0\n  j * j' = - (i * i')", "have \"?i'' *\\<^sub>R a + (-?i'' *\\<^sub>R b) = 0\""], ["proof (prove)\nusing this:\n  (i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c = 0\n  k * k' = 0\n  j * j' = - (i * i')\n\ngoal (1 subgoal):\n 1. (i * i') *\\<^sub>R a + - (i * i') *\\<^sub>R b = 0", "by simp"], ["proof (state)\nthis:\n  (i * i') *\\<^sub>R a + - (i * i') *\\<^sub>R b = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> dep2 (b - a) (c - a)\n 2. \\<not> ?P \\<Longrightarrow> dep2 (b - a) (c - a)", "with \\<open>?i'' \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  i * i' \\<noteq> 0\n  (i * i') *\\<^sub>R a + - (i * i') *\\<^sub>R b = 0", "have \"a = b\""], ["proof (prove)\nusing this:\n  i * i' \\<noteq> 0\n  (i * i') *\\<^sub>R a + - (i * i') *\\<^sub>R b = 0\n\ngoal (1 subgoal):\n 1. a = b", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> dep2 (b - a) (c - a)\n 2. \\<not> ?P \\<Longrightarrow> dep2 (b - a) (c - a)", "hence \"b - a = 0 *\\<^sub>R (c - a)\""], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. b - a = 0 *\\<^sub>R (c - a)", "by simp"], ["proof (state)\nthis:\n  b - a = 0 *\\<^sub>R (c - a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> dep2 (b - a) (c - a)\n 2. \\<not> ?P \\<Longrightarrow> dep2 (b - a) (c - a)", "moreover"], ["proof (state)\nthis:\n  b - a = 0 *\\<^sub>R (c - a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> dep2 (b - a) (c - a)\n 2. \\<not> ?P \\<Longrightarrow> dep2 (b - a) (c - a)", "have \"c - a = 1 *\\<^sub>R (c - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c - a = 1 *\\<^sub>R (c - a)", "by simp"], ["proof (state)\nthis:\n  c - a = 1 *\\<^sub>R (c - a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> dep2 (b - a) (c - a)\n 2. \\<not> ?P \\<Longrightarrow> dep2 (b - a) (c - a)", "ultimately"], ["proof (chain)\npicking this:\n  b - a = 0 *\\<^sub>R (c - a)\n  c - a = 1 *\\<^sub>R (c - a)", "have \"\\<exists> x t s. b - a = t *\\<^sub>R x \\<and> c - a = s *\\<^sub>R x\""], ["proof (prove)\nusing this:\n  b - a = 0 *\\<^sub>R (c - a)\n  c - a = 1 *\\<^sub>R (c - a)\n\ngoal (1 subgoal):\n 1. \\<exists>x t s. b - a = t *\\<^sub>R x \\<and> c - a = s *\\<^sub>R x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x t s. b - a = t *\\<^sub>R x \\<and> c - a = s *\\<^sub>R x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> dep2 (b - a) (c - a)\n 2. \\<not> ?P \\<Longrightarrow> dep2 (b - a) (c - a)", "thus \"dep2 (b - a) (c - a)\""], ["proof (prove)\nusing this:\n  \\<exists>x t s. b - a = t *\\<^sub>R x \\<and> c - a = s *\\<^sub>R x\n\ngoal (1 subgoal):\n 1. dep2 (b - a) (c - a)", "unfolding dep2_def"], ["proof (prove)\nusing this:\n  \\<exists>x t s. b - a = t *\\<^sub>R x \\<and> c - a = s *\\<^sub>R x\n\ngoal (1 subgoal):\n 1. \\<exists>w r s. b - a = r *\\<^sub>R w \\<and> c - a = s *\\<^sub>R w", "."], ["proof (state)\nthis:\n  dep2 (b - a) (c - a)\n\ngoal (1 subgoal):\n 1. k * k' \\<noteq> 0 \\<Longrightarrow> dep2 (b - a) (c - a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k * k' \\<noteq> 0 \\<Longrightarrow> dep2 (b - a) (c - a)", "assume \"?k'' \\<noteq> 0\""], ["proof (state)\nthis:\n  k * k' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k * k' \\<noteq> 0 \\<Longrightarrow> dep2 (b - a) (c - a)", "from \\<open>?i'' + ?j'' + ?k'' = 0\\<close>"], ["proof (chain)\npicking this:\n  i * i' + j * j' + k * k' = 0", "have \"?i'' = -(?j'' + ?k'')\""], ["proof (prove)\nusing this:\n  i * i' + j * j' + k * k' = 0\n\ngoal (1 subgoal):\n 1. i * i' = - (j * j' + k * k')", "by simp"], ["proof (state)\nthis:\n  i * i' = - (j * j' + k * k')\n\ngoal (1 subgoal):\n 1. k * k' \\<noteq> 0 \\<Longrightarrow> dep2 (b - a) (c - a)", "with \\<open>?i'' *\\<^sub>R a + ?j'' *\\<^sub>R b + ?k'' *\\<^sub>R c = 0\\<close>"], ["proof (chain)\npicking this:\n  (i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c = 0\n  i * i' = - (j * j' + k * k')", "have \"-(?j'' + ?k'') *\\<^sub>R a + ?j'' *\\<^sub>R b + ?k'' *\\<^sub>R c = 0\""], ["proof (prove)\nusing this:\n  (i * i') *\\<^sub>R a + (j * j') *\\<^sub>R b + (k * k') *\\<^sub>R c = 0\n  i * i' = - (j * j' + k * k')\n\ngoal (1 subgoal):\n 1. - (j * j' + k * k') *\\<^sub>R a + (j * j') *\\<^sub>R b +\n    (k * k') *\\<^sub>R c =\n    0", "by simp"], ["proof (state)\nthis:\n  - (j * j' + k * k') *\\<^sub>R a + (j * j') *\\<^sub>R b +\n  (k * k') *\\<^sub>R c =\n  0\n\ngoal (1 subgoal):\n 1. k * k' \\<noteq> 0 \\<Longrightarrow> dep2 (b - a) (c - a)", "hence \"?k'' *\\<^sub>R (c - a) = - ?j'' *\\<^sub>R (b - a)\""], ["proof (prove)\nusing this:\n  - (j * j' + k * k') *\\<^sub>R a + (j * j') *\\<^sub>R b +\n  (k * k') *\\<^sub>R c =\n  0\n\ngoal (1 subgoal):\n 1. (k * k') *\\<^sub>R (c - a) = - (j * j') *\\<^sub>R (b - a)", "by (simp add: scaleR_left_distrib\n          scaleR_right_diff_distrib\n          scaleR_left_diff_distrib\n          algebra_simps)"], ["proof (state)\nthis:\n  (k * k') *\\<^sub>R (c - a) = - (j * j') *\\<^sub>R (b - a)\n\ngoal (1 subgoal):\n 1. k * k' \\<noteq> 0 \\<Longrightarrow> dep2 (b - a) (c - a)", "hence \"(1/?k'') *\\<^sub>R ?k'' *\\<^sub>R (c - a) = (-?j'' / ?k'') *\\<^sub>R (b - a)\""], ["proof (prove)\nusing this:\n  (k * k') *\\<^sub>R (c - a) = - (j * j') *\\<^sub>R (b - a)\n\ngoal (1 subgoal):\n 1. (1 / (k * k')) *\\<^sub>R (k * k') *\\<^sub>R (c - a) =\n    (- (j * j') / (k * k')) *\\<^sub>R (b - a)", "by simp"], ["proof (state)\nthis:\n  (1 / (k * k')) *\\<^sub>R (k * k') *\\<^sub>R (c - a) =\n  (- (j * j') / (k * k')) *\\<^sub>R (b - a)\n\ngoal (1 subgoal):\n 1. k * k' \\<noteq> 0 \\<Longrightarrow> dep2 (b - a) (c - a)", "with \\<open>?k'' \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  k * k' \\<noteq> 0\n  (1 / (k * k')) *\\<^sub>R (k * k') *\\<^sub>R (c - a) =\n  (- (j * j') / (k * k')) *\\<^sub>R (b - a)", "have \"c - a = (-?j'' / ?k'') *\\<^sub>R (b - a)\""], ["proof (prove)\nusing this:\n  k * k' \\<noteq> 0\n  (1 / (k * k')) *\\<^sub>R (k * k') *\\<^sub>R (c - a) =\n  (- (j * j') / (k * k')) *\\<^sub>R (b - a)\n\ngoal (1 subgoal):\n 1. c - a = (- (j * j') / (k * k')) *\\<^sub>R (b - a)", "by simp"], ["proof (state)\nthis:\n  c - a = (- (j * j') / (k * k')) *\\<^sub>R (b - a)\n\ngoal (1 subgoal):\n 1. k * k' \\<noteq> 0 \\<Longrightarrow> dep2 (b - a) (c - a)", "moreover"], ["proof (state)\nthis:\n  c - a = (- (j * j') / (k * k')) *\\<^sub>R (b - a)\n\ngoal (1 subgoal):\n 1. k * k' \\<noteq> 0 \\<Longrightarrow> dep2 (b - a) (c - a)", "have \"b - a = 1 *\\<^sub>R (b - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b - a = 1 *\\<^sub>R (b - a)", "by simp"], ["proof (state)\nthis:\n  b - a = 1 *\\<^sub>R (b - a)\n\ngoal (1 subgoal):\n 1. k * k' \\<noteq> 0 \\<Longrightarrow> dep2 (b - a) (c - a)", "ultimately"], ["proof (chain)\npicking this:\n  c - a = (- (j * j') / (k * k')) *\\<^sub>R (b - a)\n  b - a = 1 *\\<^sub>R (b - a)", "have \"\\<exists> x t s. b - a = t *\\<^sub>R x \\<and> c - a = s *\\<^sub>R x\""], ["proof (prove)\nusing this:\n  c - a = (- (j * j') / (k * k')) *\\<^sub>R (b - a)\n  b - a = 1 *\\<^sub>R (b - a)\n\ngoal (1 subgoal):\n 1. \\<exists>x t s. b - a = t *\\<^sub>R x \\<and> c - a = s *\\<^sub>R x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x t s. b - a = t *\\<^sub>R x \\<and> c - a = s *\\<^sub>R x\n\ngoal (1 subgoal):\n 1. k * k' \\<noteq> 0 \\<Longrightarrow> dep2 (b - a) (c - a)", "thus \"dep2 (b - a) (c - a)\""], ["proof (prove)\nusing this:\n  \\<exists>x t s. b - a = t *\\<^sub>R x \\<and> c - a = s *\\<^sub>R x\n\ngoal (1 subgoal):\n 1. dep2 (b - a) (c - a)", "unfolding dep2_def"], ["proof (prove)\nusing this:\n  \\<exists>x t s. b - a = t *\\<^sub>R x \\<and> c - a = s *\\<^sub>R x\n\ngoal (1 subgoal):\n 1. \\<exists>w r s. b - a = r *\\<^sub>R w \\<and> c - a = s *\\<^sub>R w", "."], ["proof (state)\nthis:\n  dep2 (b - a) (c - a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dep2 (b - a) (c - a)\n\ngoal (2 subgoals):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n    real_euclid.Col a b c\n 2. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "with Col_dep2"], ["proof (chain)\npicking this:\n  real_euclid.Col ?a ?b ?c = dep2 (?b - ?a) (?c - ?a)\n  dep2 (b - a) (c - a)", "show \"real_euclid.Col a b c\""], ["proof (prove)\nusing this:\n  real_euclid.Col ?a ?b ?c = dep2 (?b - ?a) (?c - ?a)\n  dep2 (b - a) (c - a)\n\ngoal (1 subgoal):\n 1. real_euclid.Col a b c", "by auto"], ["proof (state)\nthis:\n  real_euclid.Col a b c\n\ngoal (1 subgoal):\n 1. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "}"], ["proof (state)\nthis:\n  proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n  real_euclid.Col a b c\n\ngoal (1 subgoal):\n 1. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "{"], ["proof (state)\nthis:\n  proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c) \\<Longrightarrow>\n  real_euclid.Col a b c\n\ngoal (1 subgoal):\n 1. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "assume \"real_euclid.Col a b c\""], ["proof (state)\nthis:\n  real_euclid.Col a b c\n\ngoal (1 subgoal):\n 1. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "with Col_dep2"], ["proof (chain)\npicking this:\n  real_euclid.Col ?a ?b ?c = dep2 (?b - ?a) (?c - ?a)\n  real_euclid.Col a b c", "have \"dep2 (b - a) (c - a)\""], ["proof (prove)\nusing this:\n  real_euclid.Col ?a ?b ?c = dep2 (?b - ?a) (?c - ?a)\n  real_euclid.Col a b c\n\ngoal (1 subgoal):\n 1. dep2 (b - a) (c - a)", "by auto"], ["proof (state)\nthis:\n  dep2 (b - a) (c - a)\n\ngoal (1 subgoal):\n 1. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "then"], ["proof (chain)\npicking this:\n  dep2 (b - a) (c - a)", "obtain x and t and s where \"b - a = t *\\<^sub>R x\" and \"c - a = s *\\<^sub>R x\""], ["proof (prove)\nusing this:\n  dep2 (b - a) (c - a)\n\ngoal (1 subgoal):\n 1. (\\<And>t x s.\n        \\<lbrakk>b - a = t *\\<^sub>R x; c - a = s *\\<^sub>R x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dep2_def"], ["proof (prove)\nusing this:\n  \\<exists>w r s. b - a = r *\\<^sub>R w \\<and> c - a = s *\\<^sub>R w\n\ngoal (1 subgoal):\n 1. (\\<And>t x s.\n        \\<lbrakk>b - a = t *\\<^sub>R x; c - a = s *\\<^sub>R x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b - a = t *\\<^sub>R x\n  c - a = s *\\<^sub>R x\n\ngoal (1 subgoal):\n 1. real_euclid.Col a b c \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "show \"proj2_Col ?p ?q ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)\n 2. \\<not> ?P \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "assume \"t = 0\""], ["proof (state)\nthis:\n  t = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)\n 2. \\<not> ?P \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "with \\<open>b - a = t *\\<^sub>R x\\<close>"], ["proof (chain)\npicking this:\n  b - a = t *\\<^sub>R x\n  t = 0", "have \"a = b\""], ["proof (prove)\nusing this:\n  b - a = t *\\<^sub>R x\n  t = 0\n\ngoal (1 subgoal):\n 1. a = b", "by simp"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)\n 2. \\<not> ?P \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "with proj2_Col_coincide"], ["proof (chain)\npicking this:\n  proj2_Col ?a ?a ?c\n  a = b", "show \"proj2_Col ?p ?q ?r\""], ["proof (prove)\nusing this:\n  proj2_Col ?a ?a ?c\n  a = b\n\ngoal (1 subgoal):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "by simp"], ["proof (state)\nthis:\n  proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "assume \"t \\<noteq> 0\""], ["proof (state)\nthis:\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "from \\<open>b - a = t *\\<^sub>R x\\<close> and \\<open>c - a = s *\\<^sub>R x\\<close>"], ["proof (chain)\npicking this:\n  b - a = t *\\<^sub>R x\n  c - a = s *\\<^sub>R x", "have \"s *\\<^sub>R (b - a) = t *\\<^sub>R (c - a)\""], ["proof (prove)\nusing this:\n  b - a = t *\\<^sub>R x\n  c - a = s *\\<^sub>R x\n\ngoal (1 subgoal):\n 1. s *\\<^sub>R (b - a) = t *\\<^sub>R (c - a)", "by simp"], ["proof (state)\nthis:\n  s *\\<^sub>R (b - a) = t *\\<^sub>R (c - a)\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "hence \"(s - t) *\\<^sub>R a + (-s) *\\<^sub>R b + t *\\<^sub>R c = 0\""], ["proof (prove)\nusing this:\n  s *\\<^sub>R (b - a) = t *\\<^sub>R (c - a)\n\ngoal (1 subgoal):\n 1. (s - t) *\\<^sub>R a + - s *\\<^sub>R b + t *\\<^sub>R c = 0", "by (simp add: scaleR_right_diff_distrib\n          scaleR_left_diff_distrib\n          algebra_simps)"], ["proof (state)\nthis:\n  (s - t) *\\<^sub>R a + - s *\\<^sub>R b + t *\\<^sub>R c = 0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "hence \"((s - t) *\\<^sub>R ?a' + (-s) *\\<^sub>R ?b' + t *\\<^sub>R ?c')$1 = 0\"\n        and \"((s - t) *\\<^sub>R ?a' + (-s) *\\<^sub>R ?b' + t *\\<^sub>R ?c')$2 = 0\""], ["proof (prove)\nusing this:\n  (s - t) *\\<^sub>R a + - s *\\<^sub>R b + t *\\<^sub>R c = 0\n\ngoal (1 subgoal):\n 1. ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n     t *\\<^sub>R vector2_append1 c) $\n    1 =\n    0 &&&\n    ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n     t *\\<^sub>R vector2_append1 c) $\n    2 =\n    0", "unfolding vector2_append1_def and vector_def"], ["proof (prove)\nusing this:\n  (s - t) *\\<^sub>R a + - s *\\<^sub>R b + t *\\<^sub>R c = 0\n\ngoal (1 subgoal):\n 1. ((s - t) *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [a $ 1, a $ 2, 1]\n        (\\<lambda>n x. 0) 1) +\n     - s *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [b $ 1, b $ 2, 1]\n        (\\<lambda>n x. 0) 1) +\n     t *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [c $ 1, c $ 2, 1]\n        (\\<lambda>n x. 0) 1)) $\n    1 =\n    0 &&&\n    ((s - t) *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [a $ 1, a $ 2, 1]\n        (\\<lambda>n x. 0) 1) +\n     - s *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [b $ 1, b $ 2, 1]\n        (\\<lambda>n x. 0) 1) +\n     t *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [c $ 1, c $ 2, 1]\n        (\\<lambda>n x. 0) 1)) $\n    2 =\n    0", "by (simp_all add: vec_eq_iff)"], ["proof (state)\nthis:\n  ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n   t *\\<^sub>R vector2_append1 c) $\n  1 =\n  0\n  ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n   t *\\<^sub>R vector2_append1 c) $\n  2 =\n  0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "moreover"], ["proof (state)\nthis:\n  ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n   t *\\<^sub>R vector2_append1 c) $\n  1 =\n  0\n  ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n   t *\\<^sub>R vector2_append1 c) $\n  2 =\n  0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "have \"((s - t) *\\<^sub>R ?a' + (-s) *\\<^sub>R ?b' + t *\\<^sub>R ?c')$3 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n     t *\\<^sub>R vector2_append1 c) $\n    3 =\n    0", "unfolding vector2_append1_def and vector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s - t) *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [a $ 1, a $ 2, 1]\n        (\\<lambda>n x. 0) 1) +\n     - s *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [b $ 1, b $ 2, 1]\n        (\\<lambda>n x. 0) 1) +\n     t *\\<^sub>R\n     vec_lambda\n      (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) [c $ 1, c $ 2, 1]\n        (\\<lambda>n x. 0) 1)) $\n    3 =\n    0", "by simp"], ["proof (state)\nthis:\n  ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n   t *\\<^sub>R vector2_append1 c) $\n  3 =\n  0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "ultimately"], ["proof (chain)\npicking this:\n  ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n   t *\\<^sub>R vector2_append1 c) $\n  1 =\n  0\n  ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n   t *\\<^sub>R vector2_append1 c) $\n  2 =\n  0\n  ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n   t *\\<^sub>R vector2_append1 c) $\n  3 =\n  0", "have \"(s - t) *\\<^sub>R ?a' + (-s) *\\<^sub>R ?b' + t *\\<^sub>R ?c' = 0\""], ["proof (prove)\nusing this:\n  ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n   t *\\<^sub>R vector2_append1 c) $\n  1 =\n  0\n  ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n   t *\\<^sub>R vector2_append1 c) $\n  2 =\n  0\n  ((s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n   t *\\<^sub>R vector2_append1 c) $\n  3 =\n  0\n\ngoal (1 subgoal):\n 1. (s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n    t *\\<^sub>R vector2_append1 c =\n    0", "by (simp add: vec_eq_iff forall_3)"], ["proof (state)\nthis:\n  (s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n  t *\\<^sub>R vector2_append1 c =\n  0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "with \\<open>?a' = (1/i) *\\<^sub>R ?a''\\<close>\n        and \\<open>?b' = (1/j) *\\<^sub>R ?b''\\<close>\n        and \\<open>?c' = (1/k) *\\<^sub>R ?c''\\<close>"], ["proof (chain)\npicking this:\n  vector2_append1 a = (1 / i) *\\<^sub>R proj2_rep (proj2_pt a)\n  vector2_append1 b = (1 / j) *\\<^sub>R proj2_rep (proj2_pt b)\n  vector2_append1 c = (1 / k) *\\<^sub>R proj2_rep (proj2_pt c)\n  (s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n  t *\\<^sub>R vector2_append1 c =\n  0", "have \"((s - t)/i) *\\<^sub>R ?a'' + (-s/j) *\\<^sub>R ?b'' + (t/k) *\\<^sub>R ?c'' = 0\""], ["proof (prove)\nusing this:\n  vector2_append1 a = (1 / i) *\\<^sub>R proj2_rep (proj2_pt a)\n  vector2_append1 b = (1 / j) *\\<^sub>R proj2_rep (proj2_pt b)\n  vector2_append1 c = (1 / k) *\\<^sub>R proj2_rep (proj2_pt c)\n  (s - t) *\\<^sub>R vector2_append1 a + - s *\\<^sub>R vector2_append1 b +\n  t *\\<^sub>R vector2_append1 c =\n  0\n\ngoal (1 subgoal):\n 1. ((s - t) / i) *\\<^sub>R proj2_rep (proj2_pt a) +\n    (- s / j) *\\<^sub>R proj2_rep (proj2_pt b) +\n    (t / k) *\\<^sub>R proj2_rep (proj2_pt c) =\n    0", "by simp"], ["proof (state)\nthis:\n  ((s - t) / i) *\\<^sub>R proj2_rep (proj2_pt a) +\n  (- s / j) *\\<^sub>R proj2_rep (proj2_pt b) +\n  (t / k) *\\<^sub>R proj2_rep (proj2_pt c) =\n  0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "moreover"], ["proof (state)\nthis:\n  ((s - t) / i) *\\<^sub>R proj2_rep (proj2_pt a) +\n  (- s / j) *\\<^sub>R proj2_rep (proj2_pt b) +\n  (t / k) *\\<^sub>R proj2_rep (proj2_pt c) =\n  0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "from \\<open>t \\<noteq> 0\\<close> and \\<open>k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  t \\<noteq> 0\n  k \\<noteq> 0", "have \"t/k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<noteq> 0\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t / k \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  t / k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "ultimately"], ["proof (chain)\npicking this:\n  ((s - t) / i) *\\<^sub>R proj2_rep (proj2_pt a) +\n  (- s / j) *\\<^sub>R proj2_rep (proj2_pt b) +\n  (t / k) *\\<^sub>R proj2_rep (proj2_pt c) =\n  0\n  t / k \\<noteq> 0", "show \"proj2_Col ?p ?q ?r\""], ["proof (prove)\nusing this:\n  ((s - t) / i) *\\<^sub>R proj2_rep (proj2_pt a) +\n  (- s / j) *\\<^sub>R proj2_rep (proj2_pt b) +\n  (t / k) *\\<^sub>R proj2_rep (proj2_pt c) =\n  0\n  t / k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)", "unfolding proj2_Col_def"], ["proof (prove)\nusing this:\n  ((s - t) / i) *\\<^sub>R proj2_rep (proj2_pt a) +\n  (- s / j) *\\<^sub>R proj2_rep (proj2_pt b) +\n  (t / k) *\\<^sub>R proj2_rep (proj2_pt c) =\n  0\n  t / k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>i j k.\n       i *\\<^sub>R proj2_rep (proj2_pt a) +\n       j *\\<^sub>R proj2_rep (proj2_pt b) +\n       k *\\<^sub>R proj2_rep (proj2_pt c) =\n       0 \\<and>\n       (i \\<noteq> 0 \\<or> j \\<noteq> 0 \\<or> k \\<noteq> 0)", "by blast"], ["proof (state)\nthis:\n  proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  real_euclid.Col a b c \\<Longrightarrow>\n  proj2_Col (proj2_pt a) (proj2_pt b) (proj2_pt c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj2_Col_iff_euclid_cart2:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\"\n  shows\n  \"proj2_Col p q r \\<longleftrightarrow> real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)\"\n  (is \"_ \\<longleftrightarrow> real_euclid.Col ?a ?b ?c\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_Col p q r = real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_Col p q r = real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)", "from \\<open>z_non_zero p\\<close> and \\<open>z_non_zero q\\<close> and \\<open>z_non_zero r\\<close>"], ["proof (chain)\npicking this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r", "have \"proj2_pt ?a = p\" and \"proj2_pt ?b = q\" and \"proj2_pt ?c = r\""], ["proof (prove)\nusing this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r\n\ngoal (1 subgoal):\n 1. proj2_pt (cart2_pt p) = p &&&\n    proj2_pt (cart2_pt q) = q &&& proj2_pt (cart2_pt r) = r", "by (simp_all add: proj2_cart2)"], ["proof (state)\nthis:\n  proj2_pt (cart2_pt p) = p\n  proj2_pt (cart2_pt q) = q\n  proj2_pt (cart2_pt r) = r\n\ngoal (1 subgoal):\n 1. proj2_Col p q r = real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)", "with proj2_Col_iff_euclid [of ?a ?b ?c]"], ["proof (chain)\npicking this:\n  proj2_Col (proj2_pt (cart2_pt p)) (proj2_pt (cart2_pt q))\n   (proj2_pt (cart2_pt r)) =\n  real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)\n  proj2_pt (cart2_pt p) = p\n  proj2_pt (cart2_pt q) = q\n  proj2_pt (cart2_pt r) = r", "show \"proj2_Col p q r \\<longleftrightarrow> real_euclid.Col ?a ?b ?c\""], ["proof (prove)\nusing this:\n  proj2_Col (proj2_pt (cart2_pt p)) (proj2_pt (cart2_pt q))\n   (proj2_pt (cart2_pt r)) =\n  real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)\n  proj2_pt (cart2_pt p) = p\n  proj2_pt (cart2_pt q) = q\n  proj2_pt (cart2_pt r) = r\n\ngoal (1 subgoal):\n 1. proj2_Col p q r = real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)", "by simp"], ["proof (state)\nthis:\n  proj2_Col p q r = real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma euclid_Col_cart2_incident:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\" and \"p \\<noteq> q\"\n  and \"proj2_incident p l\" and \"proj2_incident q l\"\n  and \"real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)\"\n  (is \"real_euclid.Col ?cp ?cq ?cr\")\n  shows \"proj2_incident r l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj2_incident r l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj2_incident r l", "from \\<open>z_non_zero p\\<close> and \\<open>z_non_zero q\\<close> and \\<open>z_non_zero r\\<close>\n    and \\<open>real_euclid.Col ?cp ?cq ?cr\\<close>"], ["proof (chain)\npicking this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r\n  real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)", "have \"proj2_Col p q r\""], ["proof (prove)\nusing this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r\n  real_euclid.Col (cart2_pt p) (cart2_pt q) (cart2_pt r)\n\ngoal (1 subgoal):\n 1. proj2_Col p q r", "by (subst proj2_Col_iff_euclid_cart2, simp_all)"], ["proof (state)\nthis:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. proj2_incident r l", "hence \"proj2_set_Col {p,q,r}\""], ["proof (prove)\nusing this:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. proj2_set_Col {p, q, r}", "by (simp add: proj2_Col_iff_set_Col)"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. proj2_incident r l", "then"], ["proof (chain)\npicking this:\n  proj2_set_Col {p, q, r}", "obtain m where\n    \"proj2_incident p m\" and \"proj2_incident q m\" and \"proj2_incident r m\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>proj2_incident p m; proj2_incident q m;\n         proj2_incident r m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold proj2_set_Col_def, auto)"], ["proof (state)\nthis:\n  proj2_incident p m\n  proj2_incident q m\n  proj2_incident r m\n\ngoal (1 subgoal):\n 1. proj2_incident r l", "from \\<open>p \\<noteq> q\\<close> and \\<open>proj2_incident p l\\<close> and \\<open>proj2_incident q l\\<close>\n    and \\<open>proj2_incident p m\\<close> and \\<open>proj2_incident q m\\<close> and proj2_incident_unique"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident p m\n  proj2_incident q m\n  \\<lbrakk>proj2_incident ?p ?l; proj2_incident ?q ?l; proj2_incident ?p ?m;\n   proj2_incident ?q ?m\\<rbrakk>\n  \\<Longrightarrow> ?p = ?q \\<or> ?l = ?m", "have \"l = m\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  proj2_incident p l\n  proj2_incident q l\n  proj2_incident p m\n  proj2_incident q m\n  \\<lbrakk>proj2_incident ?p ?l; proj2_incident ?q ?l; proj2_incident ?p ?m;\n   proj2_incident ?q ?m\\<rbrakk>\n  \\<Longrightarrow> ?p = ?q \\<or> ?l = ?m\n\ngoal (1 subgoal):\n 1. l = m", "by auto"], ["proof (state)\nthis:\n  l = m\n\ngoal (1 subgoal):\n 1. proj2_incident r l", "with \\<open>proj2_incident r m\\<close>"], ["proof (chain)\npicking this:\n  proj2_incident r m\n  l = m", "show \"proj2_incident r l\""], ["proof (prove)\nusing this:\n  proj2_incident r m\n  l = m\n\ngoal (1 subgoal):\n 1. proj2_incident r l", "by simp"], ["proof (state)\nthis:\n  proj2_incident r l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma euclid_B_cart2_common_line:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\"\n  and \"B\\<^sub>\\<real> (cart2_pt p) (cart2_pt q) (cart2_pt r)\"\n  (is \"B\\<^sub>\\<real> ?cp ?cq ?cr\")\n  shows \"\\<exists> l. proj2_incident p l \\<and> proj2_incident q l \\<and> proj2_incident r l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       proj2_incident p l \\<and>\n       proj2_incident q l \\<and> proj2_incident r l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       proj2_incident p l \\<and>\n       proj2_incident q l \\<and> proj2_incident r l", "from \\<open>z_non_zero p\\<close> and \\<open>z_non_zero q\\<close> and \\<open>z_non_zero r\\<close>\n    and \\<open>B\\<^sub>\\<real> ?cp ?cq ?cr\\<close> and proj2_Col_iff_euclid_cart2"], ["proof (chain)\npicking this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r\n  B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r\n  \\<lbrakk>z_non_zero ?p; z_non_zero ?q; z_non_zero ?r\\<rbrakk>\n  \\<Longrightarrow> proj2_Col ?p ?q ?r =\n                    real_euclid.Col (cart2_pt ?p) (cart2_pt ?q)\n                     (cart2_pt ?r)", "have \"proj2_Col p q r\""], ["proof (prove)\nusing this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r\n  B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r\n  \\<lbrakk>z_non_zero ?p; z_non_zero ?q; z_non_zero ?r\\<rbrakk>\n  \\<Longrightarrow> proj2_Col ?p ?q ?r =\n                    real_euclid.Col (cart2_pt ?p) (cart2_pt ?q)\n                     (cart2_pt ?r)\n\ngoal (1 subgoal):\n 1. proj2_Col p q r", "by (unfold real_euclid.Col_def) simp"], ["proof (state)\nthis:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       proj2_incident p l \\<and>\n       proj2_incident q l \\<and> proj2_incident r l", "hence \"proj2_set_Col {p,q,r}\""], ["proof (prove)\nusing this:\n  proj2_Col p q r\n\ngoal (1 subgoal):\n 1. proj2_set_Col {p, q, r}", "by (simp add: proj2_Col_iff_set_Col)"], ["proof (state)\nthis:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       proj2_incident p l \\<and>\n       proj2_incident q l \\<and> proj2_incident r l", "thus \"\\<exists> l. proj2_incident p l \\<and> proj2_incident q l \\<and> proj2_incident r l\""], ["proof (prove)\nusing this:\n  proj2_set_Col {p, q, r}\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       proj2_incident p l \\<and>\n       proj2_incident q l \\<and> proj2_incident r l", "by (unfold proj2_set_Col_def) simp"], ["proof (state)\nthis:\n  \\<exists>l.\n     proj2_incident p l \\<and> proj2_incident q l \\<and> proj2_incident r l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart2_append1_between:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\"\n  shows \"B\\<^sub>\\<real> (cart2_pt p) (cart2_pt q) (cart2_pt r)\n  \\<longleftrightarrow> (\\<exists> k\\<ge>0. k \\<le> 1\n  \\<and> cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "let ?cp = \"cart2_pt p\""], ["proof (state)\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "let ?cq = \"cart2_pt q\""], ["proof (state)\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "let ?cr = \"cart2_pt r\""], ["proof (state)\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "let ?cp1 = \"vector2_append1 ?cp\""], ["proof (state)\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "let ?cq1 = \"vector2_append1 ?cq\""], ["proof (state)\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "let ?cr1 = \"vector2_append1 ?cr\""], ["proof (state)\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "from \\<open>z_non_zero p\\<close> and \\<open>z_non_zero q\\<close> and \\<open>z_non_zero r\\<close>"], ["proof (chain)\npicking this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r", "have \"?cp1 = cart2_append1 p\"\n    and \"?cq1 = cart2_append1 q\"\n    and \"?cr1 = cart2_append1 r\""], ["proof (prove)\nusing this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r\n\ngoal (1 subgoal):\n 1. vector2_append1 (cart2_pt p) = cart2_append1 p &&&\n    vector2_append1 (cart2_pt q) = cart2_append1 q &&&\n    vector2_append1 (cart2_pt r) = cart2_append1 r", "by (simp_all add: cart2_append1)"], ["proof (state)\nthis:\n  vector2_append1 (cart2_pt p) = cart2_append1 p\n  vector2_append1 (cart2_pt q) = cart2_append1 q\n  vector2_append1 (cart2_pt r) = cart2_append1 r\n\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "have \"\\<forall> k. ?cq - ?cp = k *\\<^sub>R (?cr - ?cp) \\<longleftrightarrow> ?cq = k *\\<^sub>R ?cr + (1 - k) *\\<^sub>R ?cp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k.\n       (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n       (cart2_pt q = k *\\<^sub>R cart2_pt r + (1 - k) *\\<^sub>R cart2_pt p)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  \\<forall>k.\n     (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n     (cart2_pt q = k *\\<^sub>R cart2_pt r + (1 - k) *\\<^sub>R cart2_pt p)\n\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "hence \"\\<forall> k. ?cq - ?cp = k *\\<^sub>R (?cr - ?cp)\n    \\<longleftrightarrow> ?cq1 = k *\\<^sub>R ?cr1 + (1 - k) *\\<^sub>R ?cp1\""], ["proof (prove)\nusing this:\n  \\<forall>k.\n     (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n     (cart2_pt q = k *\\<^sub>R cart2_pt r + (1 - k) *\\<^sub>R cart2_pt p)\n\ngoal (1 subgoal):\n 1. \\<forall>k.\n       (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n       (vector2_append1 (cart2_pt q) =\n        k *\\<^sub>R vector2_append1 (cart2_pt r) +\n        (1 - k) *\\<^sub>R vector2_append1 (cart2_pt p))", "unfolding vector2_append1_def and vector_def"], ["proof (prove)\nusing this:\n  \\<forall>k.\n     (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n     (cart2_pt q = k *\\<^sub>R cart2_pt r + (1 - k) *\\<^sub>R cart2_pt p)\n\ngoal (1 subgoal):\n 1. \\<forall>k.\n       (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n       (vec_lambda\n         (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n           [cart2_pt q $ 1, cart2_pt q $ 2, 1] (\\<lambda>n x. 0) 1) =\n        k *\\<^sub>R\n        vec_lambda\n         (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n           [cart2_pt r $ 1, cart2_pt r $ 2, 1] (\\<lambda>n x. 0) 1) +\n        (1 - k) *\\<^sub>R\n        vec_lambda\n         (foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n           [cart2_pt p $ 1, cart2_pt p $ 2, 1] (\\<lambda>n x. 0) 1))", "by (simp add: vec_eq_iff forall_2 forall_3)"], ["proof (state)\nthis:\n  \\<forall>k.\n     (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n     (vector2_append1 (cart2_pt q) =\n      k *\\<^sub>R vector2_append1 (cart2_pt r) +\n      (1 - k) *\\<^sub>R vector2_append1 (cart2_pt p))\n\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "with \\<open>?cp1 = cart2_append1 p\\<close>\n    and \\<open>?cq1 = cart2_append1 q\\<close>\n    and \\<open>?cr1 = cart2_append1 r\\<close>"], ["proof (chain)\npicking this:\n  vector2_append1 (cart2_pt p) = cart2_append1 p\n  vector2_append1 (cart2_pt q) = cart2_append1 q\n  vector2_append1 (cart2_pt r) = cart2_append1 r\n  \\<forall>k.\n     (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n     (vector2_append1 (cart2_pt q) =\n      k *\\<^sub>R vector2_append1 (cart2_pt r) +\n      (1 - k) *\\<^sub>R vector2_append1 (cart2_pt p))", "have \"\\<forall> k. ?cq - ?cp = k *\\<^sub>R (?cr - ?cp)\n    \\<longleftrightarrow> cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\""], ["proof (prove)\nusing this:\n  vector2_append1 (cart2_pt p) = cart2_append1 p\n  vector2_append1 (cart2_pt q) = cart2_append1 q\n  vector2_append1 (cart2_pt r) = cart2_append1 r\n  \\<forall>k.\n     (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n     (vector2_append1 (cart2_pt q) =\n      k *\\<^sub>R vector2_append1 (cart2_pt r) +\n      (1 - k) *\\<^sub>R vector2_append1 (cart2_pt p))\n\ngoal (1 subgoal):\n 1. \\<forall>k.\n       (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n       (cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "by simp"], ["proof (state)\nthis:\n  \\<forall>k.\n     (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n     (cart2_append1 q =\n      k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)\n\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "thus \"B\\<^sub>\\<real> (cart2_pt p) (cart2_pt q) (cart2_pt r)\n    \\<longleftrightarrow> (\\<exists> k\\<ge>0. k \\<le> 1\n    \\<and> cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)\""], ["proof (prove)\nusing this:\n  \\<forall>k.\n     (cart2_pt q - cart2_pt p = k *\\<^sub>R (cart2_pt r - cart2_pt p)) =\n     (cart2_append1 q =\n      k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)\n\ngoal (1 subgoal):\n 1. (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n    (\\<exists>k\\<ge>0.\n        k \\<le> 1 \\<and>\n        cart2_append1 q =\n        k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)", "by (unfold real_euclid_B_def) simp"], ["proof (state)\nthis:\n  (B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r) =\n  (\\<exists>k\\<ge>0.\n      k \\<le> 1 \\<and>\n      cart2_append1 q =\n      k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart2_append1_between_right_strict:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\"\n  and \"B\\<^sub>\\<real> (cart2_pt p) (cart2_pt q) (cart2_pt r)\" and \"q \\<noteq> r\"\n  shows \"\\<exists> k\\<ge>0. k < 1\n  \\<and> cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "from \\<open>z_non_zero p\\<close> and \\<open>z_non_zero q\\<close> and \\<open>z_non_zero r\\<close>\n    and \\<open>B\\<^sub>\\<real> (cart2_pt p) (cart2_pt q) (cart2_pt r)\\<close> and cart2_append1_between"], ["proof (chain)\npicking this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r\n  B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r\n  \\<lbrakk>z_non_zero ?p; z_non_zero ?q; z_non_zero ?r\\<rbrakk>\n  \\<Longrightarrow> (B\\<^sub>\\<real> cart2_pt ?p cart2_pt ?q cart2_pt ?r) =\n                    (\\<exists>k\\<ge>0.\n                        k \\<le> 1 \\<and>\n                        cart2_append1 ?q =\n                        k *\\<^sub>R cart2_append1 ?r +\n                        (1 - k) *\\<^sub>R cart2_append1 ?p)", "obtain k where \"k \\<ge> 0\" and \"k \\<le> 1\"\n    and \"cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\""], ["proof (prove)\nusing this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r\n  B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r\n  \\<lbrakk>z_non_zero ?p; z_non_zero ?q; z_non_zero ?r\\<rbrakk>\n  \\<Longrightarrow> (B\\<^sub>\\<real> cart2_pt ?p cart2_pt ?q cart2_pt ?r) =\n                    (\\<exists>k\\<ge>0.\n                        k \\<le> 1 \\<and>\n                        cart2_append1 ?q =\n                        k *\\<^sub>R cart2_append1 ?r +\n                        (1 - k) *\\<^sub>R cart2_append1 ?p)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>0 \\<le> k; k \\<le> 1;\n         cart2_append1 q =\n         k *\\<^sub>R cart2_append1 r +\n         (1 - k) *\\<^sub>R cart2_append1 p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 \\<le> k\n  k \\<le> 1\n  cart2_append1 q =\n  k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "have \"k \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k = 1 \\<Longrightarrow> False", "assume \"k = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (1 subgoal):\n 1. k = 1 \\<Longrightarrow> False", "with \\<open>cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\\<close>"], ["proof (chain)\npicking this:\n  cart2_append1 q =\n  k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n  k = 1", "have \"cart2_append1 q = cart2_append1 r\""], ["proof (prove)\nusing this:\n  cart2_append1 q =\n  k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n  k = 1\n\ngoal (1 subgoal):\n 1. cart2_append1 q = cart2_append1 r", "by simp"], ["proof (state)\nthis:\n  cart2_append1 q = cart2_append1 r\n\ngoal (1 subgoal):\n 1. k = 1 \\<Longrightarrow> False", "with \\<open>z_non_zero q\\<close>"], ["proof (chain)\npicking this:\n  z_non_zero q\n  cart2_append1 q = cart2_append1 r", "have \"q = r\""], ["proof (prove)\nusing this:\n  z_non_zero q\n  cart2_append1 q = cart2_append1 r\n\ngoal (1 subgoal):\n 1. q = r", "by (rule cart2_append1_inj)"], ["proof (state)\nthis:\n  q = r\n\ngoal (1 subgoal):\n 1. k = 1 \\<Longrightarrow> False", "with \\<open>q \\<noteq> r\\<close>"], ["proof (chain)\npicking this:\n  q \\<noteq> r\n  q = r", "show False"], ["proof (prove)\nusing this:\n  q \\<noteq> r\n  q = r\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "with \\<open>k \\<le> 1\\<close>"], ["proof (chain)\npicking this:\n  k \\<le> 1\n  k \\<noteq> 1", "have \"k < 1\""], ["proof (prove)\nusing this:\n  k \\<le> 1\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k < 1", "by simp"], ["proof (state)\nthis:\n  k < 1\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "with \\<open>k \\<ge> 0\\<close>\n    and \\<open>cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> k\n  cart2_append1 q =\n  k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n  k < 1", "show \"\\<exists> k\\<ge>0. k < 1\n    \\<and> cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\""], ["proof (prove)\nusing this:\n  0 \\<le> k\n  cart2_append1 q =\n  k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n  k < 1\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<ge>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "by (simp add: exI [of _ k])"], ["proof (state)\nthis:\n  \\<exists>k\\<ge>0.\n     k < 1 \\<and>\n     cart2_append1 q =\n     k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cart2_append1_between_strict:\n  assumes \"z_non_zero p\" and \"z_non_zero q\" and \"z_non_zero r\"\n  and \"B\\<^sub>\\<real> (cart2_pt p) (cart2_pt q) (cart2_pt r)\" and \"q \\<noteq> p\" and \"q \\<noteq> r\"\n  shows \"\\<exists> k>0. k < 1\n  \\<and> cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "from \\<open>z_non_zero p\\<close> and \\<open>z_non_zero q\\<close> and \\<open>z_non_zero r\\<close>\n    and \\<open>B\\<^sub>\\<real> (cart2_pt p) (cart2_pt q) (cart2_pt r)\\<close> and \\<open>q \\<noteq> r\\<close>\n    and cart2_append1_between_right_strict [of p q r]"], ["proof (chain)\npicking this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r\n  B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r\n  q \\<noteq> r\n  \\<lbrakk>z_non_zero p; z_non_zero q; z_non_zero r;\n   B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r; q \\<noteq> r\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<ge>0.\n                       k < 1 \\<and>\n                       cart2_append1 q =\n                       k *\\<^sub>R cart2_append1 r +\n                       (1 - k) *\\<^sub>R cart2_append1 p", "obtain k where \"k \\<ge> 0\" and \"k < 1\"\n    and \"cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\""], ["proof (prove)\nusing this:\n  z_non_zero p\n  z_non_zero q\n  z_non_zero r\n  B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r\n  q \\<noteq> r\n  \\<lbrakk>z_non_zero p; z_non_zero q; z_non_zero r;\n   B\\<^sub>\\<real> cart2_pt p cart2_pt q cart2_pt r; q \\<noteq> r\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<ge>0.\n                       k < 1 \\<and>\n                       cart2_append1 q =\n                       k *\\<^sub>R cart2_append1 r +\n                       (1 - k) *\\<^sub>R cart2_append1 p\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>0 \\<le> k; k < 1;\n         cart2_append1 q =\n         k *\\<^sub>R cart2_append1 r +\n         (1 - k) *\\<^sub>R cart2_append1 p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 \\<le> k\n  k < 1\n  cart2_append1 q =\n  k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "have \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "assume \"k = 0\""], ["proof (state)\nthis:\n  k = 0\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "with \\<open>cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\\<close>"], ["proof (chain)\npicking this:\n  cart2_append1 q =\n  k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n  k = 0", "have \"cart2_append1 q = cart2_append1 p\""], ["proof (prove)\nusing this:\n  cart2_append1 q =\n  k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n  k = 0\n\ngoal (1 subgoal):\n 1. cart2_append1 q = cart2_append1 p", "by simp"], ["proof (state)\nthis:\n  cart2_append1 q = cart2_append1 p\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "with \\<open>z_non_zero q\\<close>"], ["proof (chain)\npicking this:\n  z_non_zero q\n  cart2_append1 q = cart2_append1 p", "have \"q = p\""], ["proof (prove)\nusing this:\n  z_non_zero q\n  cart2_append1 q = cart2_append1 p\n\ngoal (1 subgoal):\n 1. q = p", "by (rule cart2_append1_inj)"], ["proof (state)\nthis:\n  q = p\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "with \\<open>q \\<noteq> p\\<close>"], ["proof (chain)\npicking this:\n  q \\<noteq> p\n  q = p", "show False"], ["proof (prove)\nusing this:\n  q \\<noteq> p\n  q = p\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "with \\<open>k \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> k\n  k \\<noteq> 0", "have \"k > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> k\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < k", "by simp"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "with \\<open>k < 1\\<close>\n    and \\<open>cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\\<close>"], ["proof (chain)\npicking this:\n  k < 1\n  cart2_append1 q =\n  k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n  0 < k", "show \"\\<exists> k>0. k < 1\n    \\<and> cart2_append1 q = k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\""], ["proof (prove)\nusing this:\n  k < 1\n  cart2_append1 q =\n  k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<exists>k>0.\n       k < 1 \\<and>\n       cart2_append1 q =\n       k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p", "by (simp add: exI [of _ k])"], ["proof (state)\nthis:\n  \\<exists>k>0.\n     k < 1 \\<and>\n     cart2_append1 q =\n     k *\\<^sub>R cart2_append1 r + (1 - k) *\\<^sub>R cart2_append1 p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}