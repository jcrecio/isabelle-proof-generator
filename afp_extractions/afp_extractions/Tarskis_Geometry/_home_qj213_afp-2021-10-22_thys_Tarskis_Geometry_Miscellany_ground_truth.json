{"file_name": "/home/qj213/afp-2021-10-22/thys/Tarskis_Geometry/Miscellany.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tarskis_Geometry", "problem_names": ["lemma unordered_pair_element_equality:\n  assumes \"{p, q} = {r, s}\" and \"p = r\"\n  shows \"q = s\"", "lemma unordered_pair_equality: \"{p, q} = {q, p}\"", "lemma cosine_rule:\n  fixes a b c :: \"real ^ ('n::finite)\"\n  shows \"(norm_dist a c)\\<^sup>2 =\n  (norm_dist a b)\\<^sup>2 + (norm_dist b c)\\<^sup>2 + 2 * ((a - b) \\<bullet> (b - c))\"", "lemma scalar_equiv: \"r *s x = r *\\<^sub>R x\"", "lemma norm_dist_dot: \"(norm_dist x y)\\<^sup>2 = (x - y) \\<bullet> (x - y)\"", "lemma real2_eq:\n  fixes u v :: \"real^2\"\n  assumes \"u$1 = v$1\" and \"u$2 = v$2\"\n  shows \"u = v\"", "lemma rotate2 [simp]:\n  \"(rotate2 x)$1 = -x$2\"\n  \"(rotate2 x)$2 = x$1\"", "lemma rotate2_rotate2 [simp]: \"rotate2 (rotate2 x) = -x\"", "lemma rotate2_dot [simp]: \"(rotate2 u) \\<bullet> (rotate2 v) = u \\<bullet> v\"", "lemma rotate2_scaleR [simp]: \"rotate2 (k *\\<^sub>R x) = k *\\<^sub>R (rotate2 x)\"", "lemma rotate2_uminus [simp]: \"rotate2 (-x) = -(rotate2 x)\"", "lemma rotate2_eq [iff]: \"rotate2 x = rotate2 y \\<longleftrightarrow> x = y\"", "lemma dot2_rearrange_1:\n  fixes u x :: \"real^2\"\n  assumes \"u \\<bullet> x = 0\" and \"x$1 \\<noteq> 0\"\n  shows \"u = (u$2 / x$1) *\\<^sub>R (rotate2 x)\" (is \"u = ?u'\")", "lemma dot2_rearrange_2:\n  fixes u x :: \"real^2\"\n  assumes \"u \\<bullet> x = 0\" and \"x$2 \\<noteq> 0\"\n  shows \"u = -(u$1 / x$2) *\\<^sub>R (rotate2 x)\" (is \"u = ?u'\")", "lemma dot2_rearrange:\n  fixes u x :: \"real^2\"\n  assumes \"u \\<bullet> x = 0\" and \"x \\<noteq> 0\"\n  shows \"\\<exists>k. u = k *\\<^sub>R (rotate2 x)\"", "lemma real2_orthogonal_dep2:\n  fixes u v x :: \"real^2\"\n  assumes \"x \\<noteq> 0\" and \"u \\<bullet> x = 0\" and \"v \\<bullet> x = 0\"\n  shows \"dep2 u v\"", "lemma dot_left_diff_distrib:\n  fixes u v x :: \"real^'n\"\n  shows \"(u - v) \\<bullet> x = (u \\<bullet> x) - (v \\<bullet> x)\"", "lemma dot_right_diff_distrib:\n  fixes u v x :: \"real^'n\"\n  shows \"x \\<bullet> (u - v) = (x \\<bullet> u) - (x \\<bullet> v)\"", "lemma am_gm2:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"sqrt (a * b) \\<le> (a + b) / 2\"\n  and \"sqrt (a * b) = (a + b) / 2 \\<longleftrightarrow> a = b\"", "lemma refl_on_allrel: \"refl_on A (A \\<times> A)\"", "lemma refl_on_restrict:\n  assumes \"refl_on A r\"\n  shows \"refl_on (A \\<inter> B) (r \\<inter> B \\<times> B)\"", "lemma sym_allrel: \"sym (A \\<times> A)\"", "lemma sym_restrict:\n  assumes \"sym r\"\n  shows \"sym (r \\<inter> A \\<times> A)\"", "lemma trans_allrel: \"trans (A \\<times> A)\"", "lemma equiv_Int:\n  assumes \"equiv A r\" and \"equiv B s\"\n  shows \"equiv (A \\<inter> B) (r \\<inter> s)\"", "lemma equiv_allrel: \"equiv A (A \\<times> A)\"", "lemma equiv_restrict:\n  assumes \"equiv A r\"\n  shows \"equiv (A \\<inter> B) (r \\<inter> B \\<times> B)\"", "lemma invertible_times_eq_zero:\n  fixes x :: \"real^'n\" and A :: \"real^'n^'n\"\n  assumes \"invertible A\" and \"A *v x = 0\"\n  shows \"x = 0\"", "lemma times_invertible_eq_zero:\n  fixes x :: \"real^'n\" and A :: \"real^'n^'n\"\n  assumes \"invertible A\" and \"x v* A = 0\"\n  shows \"x = 0\"", "lemma matrix_id_invertible:\n  \"invertible (mat 1 :: ('a::semiring_1)^'n^'n)\"", "lemma Image_refl_on_nonempty:\n  assumes \"refl_on A r\" and \"x \\<in> A\"\n  shows \"x \\<in> r``{x}\"", "lemma quotient_element_nonempty:\n  assumes \"equiv A r\" and \"X \\<in> A//r\"\n  shows \"\\<exists> x. x \\<in> X\"", "lemma zero_3: \"(3::3) = 0\"", "lemma card_suc_ge_insert:\n  fixes A and x\n  shows \"card A + 1 \\<ge> card (insert x A)\"", "lemma card_le_UNIV:\n  fixes A :: \"('n::finite) set\"\n  shows \"card A \\<le> CARD('n)\"", "lemma partition_Image_element:\n  assumes \"equiv A r\" and \"X \\<in> A//r\" and \"x \\<in> X\"\n  shows \"r``{x} = X\"", "lemma card_insert_ge: \"card (insert x A) \\<ge> card A\"", "lemma choose_1:\n  assumes \"card S = 1\"\n  shows \"\\<exists> x. S = {x}\"", "lemma choose_2:\n  assumes \"card S = 2\"\n  shows \"\\<exists> x y. S = {x,y}\"", "lemma choose_3:\n  assumes \"card S = 3\"\n  shows \"\\<exists> x y z. S = {x,y,z}\"", "lemma card_gt_0_diff_singleton:\n  assumes \"card S > 0\" and \"x \\<in> S\"\n  shows \"card (S - {x}) = card S - 1\"", "lemma eq_3_or_of_3:\n  fixes j :: 4\n  shows \"j = 3 \\<or> (\\<exists> j'::3. j = of_int (Rep_bit1 j'))\"", "lemma sgn_plus:\n  fixes x y :: \"'a::linordered_idom\"\n  assumes \"sgn x = sgn y\"\n  shows \"sgn (x + y) = sgn x\"", "lemma sgn_div:\n  fixes x y :: \"'a::linordered_field\"\n  assumes \"y \\<noteq> 0\" and \"sgn x = sgn y\"\n  shows \"x / y > 0\"", "lemma abs_plus:\n  fixes x y :: \"'a::linordered_idom\"\n  assumes \"sgn x = sgn y\"\n  shows \"\\<bar>x + y\\<bar> = \\<bar>x\\<bar> + \\<bar>y\\<bar>\"", "lemma sgn_plus_abs:\n  fixes x y :: \"'a::linordered_idom\"\n  assumes \"\\<bar>x\\<bar> > \\<bar>y\\<bar>\"\n  shows \"sgn (x + y) = sgn x\""], "translations": [["", "lemma unordered_pair_element_equality:\n  assumes \"{p, q} = {r, s}\" and \"p = r\"\n  shows \"q = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = s", "using assms"], ["proof (prove)\nusing this:\n  {p, q} = {r, s}\n  p = r\n\ngoal (1 subgoal):\n 1. q = s", "by (auto simp: doubleton_eq_iff)"], ["", "lemma unordered_pair_equality: \"{p, q} = {q, p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p, q} = {q, p}", "by auto"], ["", "lemma cosine_rule:\n  fixes a b c :: \"real ^ ('n::finite)\"\n  shows \"(norm_dist a c)\\<^sup>2 =\n  (norm_dist a b)\\<^sup>2 + (norm_dist b c)\\<^sup>2 + 2 * ((a - b) \\<bullet> (b - c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm_dist a c)\\<^sup>2 =\n    (norm_dist a b)\\<^sup>2 + (norm_dist b c)\\<^sup>2 +\n    2 * ((a - b) \\<bullet> (b - c))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (norm_dist a c)\\<^sup>2 =\n    (norm_dist a b)\\<^sup>2 + (norm_dist b c)\\<^sup>2 +\n    2 * ((a - b) \\<bullet> (b - c))", "have \"(a - b) + (b - c) = a - c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - b + (b - c) = a - c", "by simp"], ["proof (state)\nthis:\n  a - b + (b - c) = a - c\n\ngoal (1 subgoal):\n 1. (norm_dist a c)\\<^sup>2 =\n    (norm_dist a b)\\<^sup>2 + (norm_dist b c)\\<^sup>2 +\n    2 * ((a - b) \\<bullet> (b - c))", "with dot_norm [of \"a - b\" \"b - c\"]"], ["proof (chain)\npicking this:\n  (a - b) \\<bullet> (b - c) =\n  ((norm (a - b + (b - c)))\\<^sup>2 - (norm (a - b))\\<^sup>2 -\n   (norm (b - c))\\<^sup>2) /\n  2\n  a - b + (b - c) = a - c", "have \"(a - b) \\<bullet> (b - c) =\n        ((norm (a - c))\\<^sup>2 - (norm (a - b))\\<^sup>2 - (norm (b - c))\\<^sup>2) / 2\""], ["proof (prove)\nusing this:\n  (a - b) \\<bullet> (b - c) =\n  ((norm (a - b + (b - c)))\\<^sup>2 - (norm (a - b))\\<^sup>2 -\n   (norm (b - c))\\<^sup>2) /\n  2\n  a - b + (b - c) = a - c\n\ngoal (1 subgoal):\n 1. (a - b) \\<bullet> (b - c) =\n    ((norm (a - c))\\<^sup>2 - (norm (a - b))\\<^sup>2 -\n     (norm (b - c))\\<^sup>2) /\n    2", "by simp"], ["proof (state)\nthis:\n  (a - b) \\<bullet> (b - c) =\n  ((norm (a - c))\\<^sup>2 - (norm (a - b))\\<^sup>2 -\n   (norm (b - c))\\<^sup>2) /\n  2\n\ngoal (1 subgoal):\n 1. (norm_dist a c)\\<^sup>2 =\n    (norm_dist a b)\\<^sup>2 + (norm_dist b c)\\<^sup>2 +\n    2 * ((a - b) \\<bullet> (b - c))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (a - b) \\<bullet> (b - c) =\n  ((norm (a - c))\\<^sup>2 - (norm (a - b))\\<^sup>2 -\n   (norm (b - c))\\<^sup>2) /\n  2\n\ngoal (1 subgoal):\n 1. (norm_dist a c)\\<^sup>2 =\n    (norm_dist a b)\\<^sup>2 + (norm_dist b c)\\<^sup>2 +\n    2 * ((a - b) \\<bullet> (b - c))", "by simp"], ["proof (state)\nthis:\n  (norm_dist a c)\\<^sup>2 =\n  (norm_dist a b)\\<^sup>2 + (norm_dist b c)\\<^sup>2 +\n  2 * ((a - b) \\<bullet> (b - c))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scalar_equiv: \"r *s x = r *\\<^sub>R x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r *s x = r *\\<^sub>R x", "by vector"], ["", "lemma norm_dist_dot: \"(norm_dist x y)\\<^sup>2 = (x - y) \\<bullet> (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm_dist x y)\\<^sup>2 = (x - y) \\<bullet> (x - y)", "by (simp add: power2_norm_eq_inner)"], ["", "definition dep2 :: \"'a::real_vector \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"dep2 u v \\<equiv> \\<exists>w r s. u = r *\\<^sub>R w \\<and> v = s *\\<^sub>R w\""], ["", "lemma real2_eq:\n  fixes u v :: \"real^2\"\n  assumes \"u$1 = v$1\" and \"u$2 = v$2\"\n  shows \"u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "by (simp add: vec_eq_iff [of u v] forall_2 assms)"], ["", "definition rotate2 :: \"real^2 \\<Rightarrow> real^2\" where\n  \"rotate2 x \\<equiv> vector [-x$2, x$1]\""], ["", "declare vector_2 [simp]"], ["", "lemma rotate2 [simp]:\n  \"(rotate2 x)$1 = -x$2\"\n  \"(rotate2 x)$2 = x$1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate2 x $ 1 = - x $ 2 &&& rotate2 x $ 2 = x $ 1", "by (simp add: rotate2_def)+"], ["", "lemma rotate2_rotate2 [simp]: \"rotate2 (rotate2 x) = -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate2 (rotate2 x) = - x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rotate2 (rotate2 x) = - x", "have \"(rotate2 (rotate2 x))$1 = -x$1\" and \"(rotate2 (rotate2 x))$2 = -x$2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate2 (rotate2 x) $ 1 = - x $ 1 &&& rotate2 (rotate2 x) $ 2 = - x $ 2", "by simp+"], ["proof (state)\nthis:\n  rotate2 (rotate2 x) $ 1 = - x $ 1\n  rotate2 (rotate2 x) $ 2 = - x $ 2\n\ngoal (1 subgoal):\n 1. rotate2 (rotate2 x) = - x", "with real2_eq"], ["proof (chain)\npicking this:\n  \\<lbrakk>?u $ 1 = ?v $ 1; ?u $ 2 = ?v $ 2\\<rbrakk>\n  \\<Longrightarrow> ?u = ?v\n  rotate2 (rotate2 x) $ 1 = - x $ 1\n  rotate2 (rotate2 x) $ 2 = - x $ 2", "show \"rotate2 (rotate2 x) = -x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?u $ 1 = ?v $ 1; ?u $ 2 = ?v $ 2\\<rbrakk>\n  \\<Longrightarrow> ?u = ?v\n  rotate2 (rotate2 x) $ 1 = - x $ 1\n  rotate2 (rotate2 x) $ 2 = - x $ 2\n\ngoal (1 subgoal):\n 1. rotate2 (rotate2 x) = - x", "by simp"], ["proof (state)\nthis:\n  rotate2 (rotate2 x) = - x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate2_dot [simp]: \"(rotate2 u) \\<bullet> (rotate2 v) = u \\<bullet> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate2 u \\<bullet> rotate2 v = u \\<bullet> v", "unfolding inner_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. rotate2 u $ i \\<bullet> rotate2 v $ i) =\n    (\\<Sum>i\\<in>UNIV. u $ i \\<bullet> v $ i)", "by (simp add: sum_2)"], ["", "lemma rotate2_scaleR [simp]: \"rotate2 (k *\\<^sub>R x) = k *\\<^sub>R (rotate2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate2 (k *\\<^sub>R x) = k *\\<^sub>R rotate2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rotate2 (k *\\<^sub>R x) = k *\\<^sub>R rotate2 x", "have \"(rotate2 (k *\\<^sub>R x))$1 = (k *\\<^sub>R (rotate2 x))$1\" and\n    \"(rotate2 (k *\\<^sub>R x))$2 = (k *\\<^sub>R (rotate2 x))$2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate2 (k *\\<^sub>R x) $ 1 = (k *\\<^sub>R rotate2 x) $ 1 &&&\n    rotate2 (k *\\<^sub>R x) $ 2 = (k *\\<^sub>R rotate2 x) $ 2", "by simp+"], ["proof (state)\nthis:\n  rotate2 (k *\\<^sub>R x) $ 1 = (k *\\<^sub>R rotate2 x) $ 1\n  rotate2 (k *\\<^sub>R x) $ 2 = (k *\\<^sub>R rotate2 x) $ 2\n\ngoal (1 subgoal):\n 1. rotate2 (k *\\<^sub>R x) = k *\\<^sub>R rotate2 x", "with real2_eq"], ["proof (chain)\npicking this:\n  \\<lbrakk>?u $ 1 = ?v $ 1; ?u $ 2 = ?v $ 2\\<rbrakk>\n  \\<Longrightarrow> ?u = ?v\n  rotate2 (k *\\<^sub>R x) $ 1 = (k *\\<^sub>R rotate2 x) $ 1\n  rotate2 (k *\\<^sub>R x) $ 2 = (k *\\<^sub>R rotate2 x) $ 2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u $ 1 = ?v $ 1; ?u $ 2 = ?v $ 2\\<rbrakk>\n  \\<Longrightarrow> ?u = ?v\n  rotate2 (k *\\<^sub>R x) $ 1 = (k *\\<^sub>R rotate2 x) $ 1\n  rotate2 (k *\\<^sub>R x) $ 2 = (k *\\<^sub>R rotate2 x) $ 2\n\ngoal (1 subgoal):\n 1. rotate2 (k *\\<^sub>R x) = k *\\<^sub>R rotate2 x", "by simp"], ["proof (state)\nthis:\n  rotate2 (k *\\<^sub>R x) = k *\\<^sub>R rotate2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate2_uminus [simp]: \"rotate2 (-x) = -(rotate2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate2 (- x) = - rotate2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rotate2 (- x) = - rotate2 x", "from scaleR_minus_left [of 1]"], ["proof (chain)\npicking this:\n  - 1 *\\<^sub>R ?x = - (1 *\\<^sub>R ?x)", "have\n    \"-1 *\\<^sub>R x = -x\" and \"-1 *\\<^sub>R (rotate2 x) = -(rotate2 x)\""], ["proof (prove)\nusing this:\n  - 1 *\\<^sub>R ?x = - (1 *\\<^sub>R ?x)\n\ngoal (1 subgoal):\n 1. - 1 *\\<^sub>R x = - x &&& - 1 *\\<^sub>R rotate2 x = - rotate2 x", "by auto"], ["proof (state)\nthis:\n  - 1 *\\<^sub>R x = - x\n  - 1 *\\<^sub>R rotate2 x = - rotate2 x\n\ngoal (1 subgoal):\n 1. rotate2 (- x) = - rotate2 x", "with rotate2_scaleR [of \"-1\" x]"], ["proof (chain)\npicking this:\n  rotate2 (- 1 *\\<^sub>R x) = - 1 *\\<^sub>R rotate2 x\n  - 1 *\\<^sub>R x = - x\n  - 1 *\\<^sub>R rotate2 x = - rotate2 x", "show ?thesis"], ["proof (prove)\nusing this:\n  rotate2 (- 1 *\\<^sub>R x) = - 1 *\\<^sub>R rotate2 x\n  - 1 *\\<^sub>R x = - x\n  - 1 *\\<^sub>R rotate2 x = - rotate2 x\n\ngoal (1 subgoal):\n 1. rotate2 (- x) = - rotate2 x", "by simp"], ["proof (state)\nthis:\n  rotate2 (- x) = - rotate2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate2_eq [iff]: \"rotate2 x = rotate2 y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rotate2 x = rotate2 y) = (x = y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rotate2 x = rotate2 y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> rotate2 x = rotate2 y", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. rotate2 x = rotate2 y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> rotate2 x = rotate2 y", "thus \"rotate2 x = rotate2 y\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. rotate2 x = rotate2 y", "by simp"], ["proof (state)\nthis:\n  rotate2 x = rotate2 y\n\ngoal (1 subgoal):\n 1. rotate2 x = rotate2 y \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rotate2 x = rotate2 y \\<Longrightarrow> x = y", "assume \"rotate2 x = rotate2 y\""], ["proof (state)\nthis:\n  rotate2 x = rotate2 y\n\ngoal (1 subgoal):\n 1. rotate2 x = rotate2 y \\<Longrightarrow> x = y", "hence \"rotate2 (rotate2 x) = rotate2 (rotate2 y)\""], ["proof (prove)\nusing this:\n  rotate2 x = rotate2 y\n\ngoal (1 subgoal):\n 1. rotate2 (rotate2 x) = rotate2 (rotate2 y)", "by simp"], ["proof (state)\nthis:\n  rotate2 (rotate2 x) = rotate2 (rotate2 y)\n\ngoal (1 subgoal):\n 1. rotate2 x = rotate2 y \\<Longrightarrow> x = y", "hence \"-(-x) = -(-y)\""], ["proof (prove)\nusing this:\n  rotate2 (rotate2 x) = rotate2 (rotate2 y)\n\ngoal (1 subgoal):\n 1. - (- x) = - (- y)", "by simp"], ["proof (state)\nthis:\n  - (- x) = - (- y)\n\ngoal (1 subgoal):\n 1. rotate2 x = rotate2 y \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  - (- x) = - (- y)\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dot2_rearrange_1:\n  fixes u x :: \"real^2\"\n  assumes \"u \\<bullet> x = 0\" and \"x$1 \\<noteq> 0\"\n  shows \"u = (u$2 / x$1) *\\<^sub>R (rotate2 x)\" (is \"u = ?u'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. u = (u $ 2 / x $ 1) *\\<^sub>R rotate2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u = (u $ 2 / x $ 1) *\\<^sub>R rotate2 x", "from \\<open>u \\<bullet> x = 0\\<close>"], ["proof (chain)\npicking this:\n  u \\<bullet> x = 0", "have \"u$1 * x$1 = -(u$2) * (x$2)\""], ["proof (prove)\nusing this:\n  u \\<bullet> x = 0\n\ngoal (1 subgoal):\n 1. u $ 1 * x $ 1 = - u $ 2 * x $ 2", "unfolding inner_vec_def"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>UNIV. u $ i \\<bullet> x $ i) = 0\n\ngoal (1 subgoal):\n 1. u $ 1 * x $ 1 = - u $ 2 * x $ 2", "by (simp add: sum_2)"], ["proof (state)\nthis:\n  u $ 1 * x $ 1 = - u $ 2 * x $ 2\n\ngoal (1 subgoal):\n 1. u = (u $ 2 / x $ 1) *\\<^sub>R rotate2 x", "hence \"u$1 * x$1 / x$1 = -u$2 / x$1 * x$2\""], ["proof (prove)\nusing this:\n  u $ 1 * x $ 1 = - u $ 2 * x $ 2\n\ngoal (1 subgoal):\n 1. u $ 1 * x $ 1 / x $ 1 = - u $ 2 / x $ 1 * x $ 2", "by simp"], ["proof (state)\nthis:\n  u $ 1 * x $ 1 / x $ 1 = - u $ 2 / x $ 1 * x $ 2\n\ngoal (1 subgoal):\n 1. u = (u $ 2 / x $ 1) *\\<^sub>R rotate2 x", "with \\<open>x$1 \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  x $ 1 \\<noteq> 0\n  u $ 1 * x $ 1 / x $ 1 = - u $ 2 / x $ 1 * x $ 2", "have \"u$1 = ?u'$1\""], ["proof (prove)\nusing this:\n  x $ 1 \\<noteq> 0\n  u $ 1 * x $ 1 / x $ 1 = - u $ 2 / x $ 1 * x $ 2\n\ngoal (1 subgoal):\n 1. u $ 1 = ((u $ 2 / x $ 1) *\\<^sub>R rotate2 x) $ 1", "by simp"], ["proof (state)\nthis:\n  u $ 1 = ((u $ 2 / x $ 1) *\\<^sub>R rotate2 x) $ 1\n\ngoal (1 subgoal):\n 1. u = (u $ 2 / x $ 1) *\\<^sub>R rotate2 x", "from \\<open>x$1 \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  x $ 1 \\<noteq> 0", "have \"u$2 = ?u'$2\""], ["proof (prove)\nusing this:\n  x $ 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u $ 2 = ((u $ 2 / x $ 1) *\\<^sub>R rotate2 x) $ 2", "by simp"], ["proof (state)\nthis:\n  u $ 2 = ((u $ 2 / x $ 1) *\\<^sub>R rotate2 x) $ 2\n\ngoal (1 subgoal):\n 1. u = (u $ 2 / x $ 1) *\\<^sub>R rotate2 x", "with \\<open>u$1 = ?u'$1\\<close> and real2_eq"], ["proof (chain)\npicking this:\n  u $ 1 = ((u $ 2 / x $ 1) *\\<^sub>R rotate2 x) $ 1\n  \\<lbrakk>?u $ 1 = ?v $ 1; ?u $ 2 = ?v $ 2\\<rbrakk>\n  \\<Longrightarrow> ?u = ?v\n  u $ 2 = ((u $ 2 / x $ 1) *\\<^sub>R rotate2 x) $ 2", "show \"u = ?u'\""], ["proof (prove)\nusing this:\n  u $ 1 = ((u $ 2 / x $ 1) *\\<^sub>R rotate2 x) $ 1\n  \\<lbrakk>?u $ 1 = ?v $ 1; ?u $ 2 = ?v $ 2\\<rbrakk>\n  \\<Longrightarrow> ?u = ?v\n  u $ 2 = ((u $ 2 / x $ 1) *\\<^sub>R rotate2 x) $ 2\n\ngoal (1 subgoal):\n 1. u = (u $ 2 / x $ 1) *\\<^sub>R rotate2 x", "by simp"], ["proof (state)\nthis:\n  u = (u $ 2 / x $ 1) *\\<^sub>R rotate2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dot2_rearrange_2:\n  fixes u x :: \"real^2\"\n  assumes \"u \\<bullet> x = 0\" and \"x$2 \\<noteq> 0\"\n  shows \"u = -(u$1 / x$2) *\\<^sub>R (rotate2 x)\" (is \"u = ?u'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. u = - (u $ 1 / x $ 2) *\\<^sub>R rotate2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u = - (u $ 1 / x $ 2) *\\<^sub>R rotate2 x", "from assms and dot2_rearrange_1 [of \"rotate2 u\" \"rotate2 x\"]"], ["proof (chain)\npicking this:\n  u \\<bullet> x = 0\n  x $ 2 \\<noteq> 0\n  \\<lbrakk>rotate2 u \\<bullet> rotate2 x = 0;\n   rotate2 x $ 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> rotate2 u =\n                    (rotate2 u $ 2 / rotate2 x $ 1) *\\<^sub>R\n                    rotate2 (rotate2 x)", "have\n    \"rotate2 u = rotate2 ?u'\""], ["proof (prove)\nusing this:\n  u \\<bullet> x = 0\n  x $ 2 \\<noteq> 0\n  \\<lbrakk>rotate2 u \\<bullet> rotate2 x = 0;\n   rotate2 x $ 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> rotate2 u =\n                    (rotate2 u $ 2 / rotate2 x $ 1) *\\<^sub>R\n                    rotate2 (rotate2 x)\n\ngoal (1 subgoal):\n 1. rotate2 u = rotate2 (- (u $ 1 / x $ 2) *\\<^sub>R rotate2 x)", "by simp"], ["proof (state)\nthis:\n  rotate2 u = rotate2 (- (u $ 1 / x $ 2) *\\<^sub>R rotate2 x)\n\ngoal (1 subgoal):\n 1. u = - (u $ 1 / x $ 2) *\\<^sub>R rotate2 x", "thus \"u = ?u'\""], ["proof (prove)\nusing this:\n  rotate2 u = rotate2 (- (u $ 1 / x $ 2) *\\<^sub>R rotate2 x)\n\ngoal (1 subgoal):\n 1. u = - (u $ 1 / x $ 2) *\\<^sub>R rotate2 x", "by blast"], ["proof (state)\nthis:\n  u = - (u $ 1 / x $ 2) *\\<^sub>R rotate2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dot2_rearrange:\n  fixes u x :: \"real^2\"\n  assumes \"u \\<bullet> x = 0\" and \"x \\<noteq> 0\"\n  shows \"\\<exists>k. u = k *\\<^sub>R (rotate2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. u = k *\\<^sub>R rotate2 x", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>k. u = k *\\<^sub>R rotate2 x\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>k. u = k *\\<^sub>R rotate2 x", "assume \"x$1 = 0\""], ["proof (state)\nthis:\n  x $ 1 = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>k. u = k *\\<^sub>R rotate2 x\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>k. u = k *\\<^sub>R rotate2 x", "with real2_eq [of x 0] and \\<open>x \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>x $ 1 = 0 $ 1; x $ 2 = 0 $ 2\\<rbrakk> \\<Longrightarrow> x = 0\n  x \\<noteq> 0\n  x $ 1 = 0", "have \"x$2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x $ 1 = 0 $ 1; x $ 2 = 0 $ 2\\<rbrakk> \\<Longrightarrow> x = 0\n  x \\<noteq> 0\n  x $ 1 = 0\n\ngoal (1 subgoal):\n 1. x $ 2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  x $ 2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>k. u = k *\\<^sub>R rotate2 x\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>k. u = k *\\<^sub>R rotate2 x", "with dot2_rearrange_2 and \\<open>u \\<bullet> x = 0\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?u \\<bullet> ?x = 0; ?x $ 2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?u = - (?u $ 1 / ?x $ 2) *\\<^sub>R rotate2 ?x\n  u \\<bullet> x = 0\n  x $ 2 \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<bullet> ?x = 0; ?x $ 2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?u = - (?u $ 1 / ?x $ 2) *\\<^sub>R rotate2 ?x\n  u \\<bullet> x = 0\n  x $ 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. u = k *\\<^sub>R rotate2 x", "by blast"], ["proof (state)\nthis:\n  \\<exists>k. u = k *\\<^sub>R rotate2 x\n\ngoal (1 subgoal):\n 1. x $ 1 \\<noteq> 0 \\<Longrightarrow> \\<exists>k. u = k *\\<^sub>R rotate2 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x $ 1 \\<noteq> 0 \\<Longrightarrow> \\<exists>k. u = k *\\<^sub>R rotate2 x", "assume \"x$1 \\<noteq> 0\""], ["proof (state)\nthis:\n  x $ 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x $ 1 \\<noteq> 0 \\<Longrightarrow> \\<exists>k. u = k *\\<^sub>R rotate2 x", "with dot2_rearrange_1 and \\<open>u \\<bullet> x = 0\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?u \\<bullet> ?x = 0; ?x $ 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?u = (?u $ 2 / ?x $ 1) *\\<^sub>R rotate2 ?x\n  u \\<bullet> x = 0\n  x $ 1 \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<bullet> ?x = 0; ?x $ 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?u = (?u $ 2 / ?x $ 1) *\\<^sub>R rotate2 ?x\n  u \\<bullet> x = 0\n  x $ 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. u = k *\\<^sub>R rotate2 x", "by blast"], ["proof (state)\nthis:\n  \\<exists>k. u = k *\\<^sub>R rotate2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma real2_orthogonal_dep2:\n  fixes u v x :: \"real^2\"\n  assumes \"x \\<noteq> 0\" and \"u \\<bullet> x = 0\" and \"v \\<bullet> x = 0\"\n  shows \"dep2 u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dep2 u v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dep2 u v", "let ?w = \"rotate2 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. dep2 u v", "from dot2_rearrange and assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?u \\<bullet> ?x = 0; ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k. ?u = k *\\<^sub>R rotate2 ?x\n  x \\<noteq> 0\n  u \\<bullet> x = 0\n  v \\<bullet> x = 0", "have\n    \"\\<exists>r s. u = r *\\<^sub>R ?w \\<and> v = s *\\<^sub>R ?w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<bullet> ?x = 0; ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k. ?u = k *\\<^sub>R rotate2 ?x\n  x \\<noteq> 0\n  u \\<bullet> x = 0\n  v \\<bullet> x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>r s. u = r *\\<^sub>R rotate2 x \\<and> v = s *\\<^sub>R rotate2 x", "by simp"], ["proof (state)\nthis:\n  \\<exists>r s. u = r *\\<^sub>R rotate2 x \\<and> v = s *\\<^sub>R rotate2 x\n\ngoal (1 subgoal):\n 1. dep2 u v", "with dep2_def"], ["proof (chain)\npicking this:\n  dep2 ?u ?v \\<equiv>\n  \\<exists>w r s. ?u = r *\\<^sub>R w \\<and> ?v = s *\\<^sub>R w\n  \\<exists>r s. u = r *\\<^sub>R rotate2 x \\<and> v = s *\\<^sub>R rotate2 x", "show ?thesis"], ["proof (prove)\nusing this:\n  dep2 ?u ?v \\<equiv>\n  \\<exists>w r s. ?u = r *\\<^sub>R w \\<and> ?v = s *\\<^sub>R w\n  \\<exists>r s. u = r *\\<^sub>R rotate2 x \\<and> v = s *\\<^sub>R rotate2 x\n\ngoal (1 subgoal):\n 1. dep2 u v", "by auto"], ["proof (state)\nthis:\n  dep2 u v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dot_left_diff_distrib:\n  fixes u v x :: \"real^'n\"\n  shows \"(u - v) \\<bullet> x = (u \\<bullet> x) - (v \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", "have \"(u \\<bullet> x) - (v \\<bullet> x) = (\\<Sum>i\\<in>UNIV. u$i * x$i) - (\\<Sum>i\\<in>UNIV. v$i * x$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<bullet> x - v \\<bullet> x =\n    (\\<Sum>i\\<in>UNIV. u $ i * x $ i) - (\\<Sum>i\\<in>UNIV. v $ i * x $ i)", "unfolding inner_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. u $ i \\<bullet> x $ i) -\n    (\\<Sum>i\\<in>UNIV. v $ i \\<bullet> x $ i) =\n    (\\<Sum>i\\<in>UNIV. u $ i * x $ i) - (\\<Sum>i\\<in>UNIV. v $ i * x $ i)", "by simp"], ["proof (state)\nthis:\n  u \\<bullet> x - v \\<bullet> x =\n  (\\<Sum>i\\<in>UNIV. u $ i * x $ i) - (\\<Sum>i\\<in>UNIV. v $ i * x $ i)\n\ngoal (1 subgoal):\n 1. (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", "also"], ["proof (state)\nthis:\n  u \\<bullet> x - v \\<bullet> x =\n  (\\<Sum>i\\<in>UNIV. u $ i * x $ i) - (\\<Sum>i\\<in>UNIV. v $ i * x $ i)\n\ngoal (1 subgoal):\n 1. (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", "from sum_subtractf [of \"\\<lambda> i. u$i * x$i\" \"\\<lambda> i. v$i * x$i\"]"], ["proof (chain)\npicking this:\n  (\\<Sum>xa\\<in>?A. u $ xa * x $ xa - v $ xa * x $ xa) =\n  (\\<Sum>xa\\<in>?A. u $ xa * x $ xa) - (\\<Sum>xa\\<in>?A. v $ xa * x $ xa)", "have\n    \"\\<dots> = (\\<Sum>i\\<in>UNIV. u$i * x$i - v$i * x$i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>xa\\<in>?A. u $ xa * x $ xa - v $ xa * x $ xa) =\n  (\\<Sum>xa\\<in>?A. u $ xa * x $ xa) - (\\<Sum>xa\\<in>?A. v $ xa * x $ xa)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. u $ i * x $ i) - (\\<Sum>i\\<in>UNIV. v $ i * x $ i) =\n    (\\<Sum>i\\<in>UNIV. u $ i * x $ i - v $ i * x $ i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. u $ i * x $ i) - (\\<Sum>i\\<in>UNIV. v $ i * x $ i) =\n  (\\<Sum>i\\<in>UNIV. u $ i * x $ i - v $ i * x $ i)\n\ngoal (1 subgoal):\n 1. (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. u $ i * x $ i) - (\\<Sum>i\\<in>UNIV. v $ i * x $ i) =\n  (\\<Sum>i\\<in>UNIV. u $ i * x $ i - v $ i * x $ i)\n\ngoal (1 subgoal):\n 1. (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", "from left_diff_distrib [where 'a = real]"], ["proof (chain)\npicking this:\n  (?a - ?b) * ?c = ?a * ?c - ?b * ?c", "have\n    \"\\<dots> = (\\<Sum>i\\<in>UNIV. (u$i - v$i) * x$i)\""], ["proof (prove)\nusing this:\n  (?a - ?b) * ?c = ?a * ?c - ?b * ?c\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. u $ i * x $ i - v $ i * x $ i) =\n    (\\<Sum>i\\<in>UNIV. (u $ i - v $ i) * x $ i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. u $ i * x $ i - v $ i * x $ i) =\n  (\\<Sum>i\\<in>UNIV. (u $ i - v $ i) * x $ i)\n\ngoal (1 subgoal):\n 1. (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. u $ i * x $ i - v $ i * x $ i) =\n  (\\<Sum>i\\<in>UNIV. (u $ i - v $ i) * x $ i)\n\ngoal (1 subgoal):\n 1. (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", "have\n    \"\\<dots> = (u - v) \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. (u $ i - v $ i) * x $ i) = (u - v) \\<bullet> x", "unfolding inner_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. (u $ i - v $ i) * x $ i) =\n    (\\<Sum>i\\<in>UNIV. (u - v) $ i \\<bullet> x $ i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. (u $ i - v $ i) * x $ i) = (u - v) \\<bullet> x\n\ngoal (1 subgoal):\n 1. (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", "finally"], ["proof (chain)\npicking this:\n  u \\<bullet> x - v \\<bullet> x = (u - v) \\<bullet> x", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<bullet> x - v \\<bullet> x = (u - v) \\<bullet> x\n\ngoal (1 subgoal):\n 1. (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", ".."], ["proof (state)\nthis:\n  (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dot_right_diff_distrib:\n  fixes u v x :: \"real^'n\"\n  shows \"x \\<bullet> (u - v) = (x \\<bullet> u) - (x \\<bullet> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bullet> (u - v) = x \\<bullet> u - x \\<bullet> v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<bullet> (u - v) = x \\<bullet> u - x \\<bullet> v", "from inner_commute"], ["proof (chain)\npicking this:\n  ?x \\<bullet> ?y = ?y \\<bullet> ?x", "have \"x \\<bullet> (u - v) = (u - v) \\<bullet> x\""], ["proof (prove)\nusing this:\n  ?x \\<bullet> ?y = ?y \\<bullet> ?x\n\ngoal (1 subgoal):\n 1. x \\<bullet> (u - v) = (u - v) \\<bullet> x", "by auto"], ["proof (state)\nthis:\n  x \\<bullet> (u - v) = (u - v) \\<bullet> x\n\ngoal (1 subgoal):\n 1. x \\<bullet> (u - v) = x \\<bullet> u - x \\<bullet> v", "also"], ["proof (state)\nthis:\n  x \\<bullet> (u - v) = (u - v) \\<bullet> x\n\ngoal (1 subgoal):\n 1. x \\<bullet> (u - v) = x \\<bullet> u - x \\<bullet> v", "from dot_left_diff_distrib [of u v x]"], ["proof (chain)\npicking this:\n  (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", "have\n    \"\\<dots> = u \\<bullet> x - v \\<bullet> x\""], ["proof (prove)\nusing this:\n  (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x\n\ngoal (1 subgoal):\n 1. (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x", "."], ["proof (state)\nthis:\n  (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x\n\ngoal (1 subgoal):\n 1. x \\<bullet> (u - v) = x \\<bullet> u - x \\<bullet> v", "also"], ["proof (state)\nthis:\n  (u - v) \\<bullet> x = u \\<bullet> x - v \\<bullet> x\n\ngoal (1 subgoal):\n 1. x \\<bullet> (u - v) = x \\<bullet> u - x \\<bullet> v", "from inner_commute [of x]"], ["proof (chain)\npicking this:\n  x \\<bullet> ?y = ?y \\<bullet> x", "have\n    \"\\<dots> = x \\<bullet> u - x \\<bullet> v\""], ["proof (prove)\nusing this:\n  x \\<bullet> ?y = ?y \\<bullet> x\n\ngoal (1 subgoal):\n 1. u \\<bullet> x - v \\<bullet> x = x \\<bullet> u - x \\<bullet> v", "by simp"], ["proof (state)\nthis:\n  u \\<bullet> x - v \\<bullet> x = x \\<bullet> u - x \\<bullet> v\n\ngoal (1 subgoal):\n 1. x \\<bullet> (u - v) = x \\<bullet> u - x \\<bullet> v", "finally"], ["proof (chain)\npicking this:\n  x \\<bullet> (u - v) = x \\<bullet> u - x \\<bullet> v", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<bullet> (u - v) = x \\<bullet> u - x \\<bullet> v\n\ngoal (1 subgoal):\n 1. x \\<bullet> (u - v) = x \\<bullet> u - x \\<bullet> v", "."], ["proof (state)\nthis:\n  x \\<bullet> (u - v) = x \\<bullet> u - x \\<bullet> v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma am_gm2:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"sqrt (a * b) \\<le> (a + b) / 2\"\n  and \"sqrt (a * b) = (a + b) / 2 \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (a * b) \\<le> (a + b) / 2 &&&\n    (sqrt (a * b) = (a + b) / 2) = (a = b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. sqrt (a * b) \\<le> (a + b) / 2\n 2. (sqrt (a * b) = (a + b) / 2) = (a = b)", "have \"0 \\<le> (a - b) * (a - b)\" and \"0 = (a - b) * (a - b) \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (a - b) * (a - b) &&& (0 = (a - b) * (a - b)) = (a = b)", "by simp+"], ["proof (state)\nthis:\n  0 \\<le> (a - b) * (a - b)\n  (0 = (a - b) * (a - b)) = (a = b)\n\ngoal (2 subgoals):\n 1. sqrt (a * b) \\<le> (a + b) / 2\n 2. (sqrt (a * b) = (a + b) / 2) = (a = b)", "with right_diff_distrib [of \"a - b\" a b] and left_diff_distrib [of a b]"], ["proof (chain)\npicking this:\n  (a - b) * (a - b) = (a - b) * a - (a - b) * b\n  (a - b) * ?c = a * ?c - b * ?c\n  0 \\<le> (a - b) * (a - b)\n  (0 = (a - b) * (a - b)) = (a = b)", "have\n    \"0 \\<le> a * a - 2 * a * b + b * b\"\n    and \"0 = a * a - 2 * a * b + b * b \\<longleftrightarrow> a = b\""], ["proof (prove)\nusing this:\n  (a - b) * (a - b) = (a - b) * a - (a - b) * b\n  (a - b) * ?c = a * ?c - b * ?c\n  0 \\<le> (a - b) * (a - b)\n  (0 = (a - b) * (a - b)) = (a = b)\n\ngoal (1 subgoal):\n 1. 0 \\<le> a * a - 2 * a * b + b * b &&&\n    (0 = a * a - 2 * a * b + b * b) = (a = b)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> a * a - 2 * a * b + b * b\n  (0 = a * a - 2 * a * b + b * b) = (a = b)\n\ngoal (2 subgoals):\n 1. sqrt (a * b) \\<le> (a + b) / 2\n 2. (sqrt (a * b) = (a + b) / 2) = (a = b)", "hence \"4 * a * b \\<le> a * a + 2 * a * b + b * b\"\n    and \"4 * a * b = a * a + 2 * a * b + b * b \\<longleftrightarrow> a = b\""], ["proof (prove)\nusing this:\n  0 \\<le> a * a - 2 * a * b + b * b\n  (0 = a * a - 2 * a * b + b * b) = (a = b)\n\ngoal (1 subgoal):\n 1. 4 * a * b \\<le> a * a + 2 * a * b + b * b &&&\n    (4 * a * b = a * a + 2 * a * b + b * b) = (a = b)", "by auto"], ["proof (state)\nthis:\n  4 * a * b \\<le> a * a + 2 * a * b + b * b\n  (4 * a * b = a * a + 2 * a * b + b * b) = (a = b)\n\ngoal (2 subgoals):\n 1. sqrt (a * b) \\<le> (a + b) / 2\n 2. (sqrt (a * b) = (a + b) / 2) = (a = b)", "with distrib_right [of \"a + b\" a b] and distrib_left [of a b]"], ["proof (chain)\npicking this:\n  (a + b + a) * b = (a + b) * b + a * b\n  a * (b + ?c) = a * b + a * ?c\n  4 * a * b \\<le> a * a + 2 * a * b + b * b\n  (4 * a * b = a * a + 2 * a * b + b * b) = (a = b)", "have\n    \"4 * a * b \\<le> (a + b) * (a + b)\"\n    and \"4 * a * b = (a + b) * (a + b) \\<longleftrightarrow> a = b\""], ["proof (prove)\nusing this:\n  (a + b + a) * b = (a + b) * b + a * b\n  a * (b + ?c) = a * b + a * ?c\n  4 * a * b \\<le> a * a + 2 * a * b + b * b\n  (4 * a * b = a * a + 2 * a * b + b * b) = (a = b)\n\ngoal (1 subgoal):\n 1. 4 * a * b \\<le> (a + b) * (a + b) &&&\n    (4 * a * b = (a + b) * (a + b)) = (a = b)", "by (simp add: field_simps)+"], ["proof (state)\nthis:\n  4 * a * b \\<le> (a + b) * (a + b)\n  (4 * a * b = (a + b) * (a + b)) = (a = b)\n\ngoal (2 subgoals):\n 1. sqrt (a * b) \\<le> (a + b) / 2\n 2. (sqrt (a * b) = (a + b) / 2) = (a = b)", "with real_sqrt_le_mono [of \"4 * a * b\" \"(a + b) * (a + b)\"]\n    and real_sqrt_eq_iff [of \"4 * a * b\" \"(a + b) * (a + b)\"]"], ["proof (chain)\npicking this:\n  4 * a * b \\<le> (a + b) * (a + b) \\<Longrightarrow>\n  sqrt (4 * a * b) \\<le> sqrt ((a + b) * (a + b))\n  (sqrt (4 * a * b) = sqrt ((a + b) * (a + b))) =\n  (4 * a * b = (a + b) * (a + b))\n  4 * a * b \\<le> (a + b) * (a + b)\n  (4 * a * b = (a + b) * (a + b)) = (a = b)", "have\n    \"sqrt (4 * a * b) \\<le> sqrt ((a + b) * (a + b))\"\n    and \"sqrt (4 * a * b) = sqrt ((a + b) * (a + b)) \\<longleftrightarrow> a = b\""], ["proof (prove)\nusing this:\n  4 * a * b \\<le> (a + b) * (a + b) \\<Longrightarrow>\n  sqrt (4 * a * b) \\<le> sqrt ((a + b) * (a + b))\n  (sqrt (4 * a * b) = sqrt ((a + b) * (a + b))) =\n  (4 * a * b = (a + b) * (a + b))\n  4 * a * b \\<le> (a + b) * (a + b)\n  (4 * a * b = (a + b) * (a + b)) = (a = b)\n\ngoal (1 subgoal):\n 1. sqrt (4 * a * b) \\<le> sqrt ((a + b) * (a + b)) &&&\n    (sqrt (4 * a * b) = sqrt ((a + b) * (a + b))) = (a = b)", "by simp+"], ["proof (state)\nthis:\n  sqrt (4 * a * b) \\<le> sqrt ((a + b) * (a + b))\n  (sqrt (4 * a * b) = sqrt ((a + b) * (a + b))) = (a = b)\n\ngoal (2 subgoals):\n 1. sqrt (a * b) \\<le> (a + b) / 2\n 2. (sqrt (a * b) = (a + b) / 2) = (a = b)", "with \\<open>a \\<ge> 0\\<close> and \\<open>b \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> a\n  0 \\<le> b\n  sqrt (4 * a * b) \\<le> sqrt ((a + b) * (a + b))\n  (sqrt (4 * a * b) = sqrt ((a + b) * (a + b))) = (a = b)", "have \"sqrt (4 * a * b) \\<le> a + b\"\n    and \"sqrt (4 * a * b) = a + b \\<longleftrightarrow> a = b\""], ["proof (prove)\nusing this:\n  0 \\<le> a\n  0 \\<le> b\n  sqrt (4 * a * b) \\<le> sqrt ((a + b) * (a + b))\n  (sqrt (4 * a * b) = sqrt ((a + b) * (a + b))) = (a = b)\n\ngoal (1 subgoal):\n 1. sqrt (4 * a * b) \\<le> a + b &&& (sqrt (4 * a * b) = a + b) = (a = b)", "by simp+"], ["proof (state)\nthis:\n  sqrt (4 * a * b) \\<le> a + b\n  (sqrt (4 * a * b) = a + b) = (a = b)\n\ngoal (2 subgoals):\n 1. sqrt (a * b) \\<le> (a + b) / 2\n 2. (sqrt (a * b) = (a + b) / 2) = (a = b)", "with real_sqrt_abs2 [of 2] and real_sqrt_mult [of 4 \"a * b\"]"], ["proof (chain)\npicking this:\n  sqrt (2 * 2) = \\<bar>2\\<bar>\n  sqrt (4 * (a * b)) = sqrt 4 * sqrt (a * b)\n  sqrt (4 * a * b) \\<le> a + b\n  (sqrt (4 * a * b) = a + b) = (a = b)", "show\n    \"sqrt (a * b) \\<le> (a + b) / 2\"\n    and \"sqrt (a * b) = (a + b) / 2 \\<longleftrightarrow> a = b\""], ["proof (prove)\nusing this:\n  sqrt (2 * 2) = \\<bar>2\\<bar>\n  sqrt (4 * (a * b)) = sqrt 4 * sqrt (a * b)\n  sqrt (4 * a * b) \\<le> a + b\n  (sqrt (4 * a * b) = a + b) = (a = b)\n\ngoal (1 subgoal):\n 1. sqrt (a * b) \\<le> (a + b) / 2 &&&\n    (sqrt (a * b) = (a + b) / 2) = (a = b)", "by (simp add: ac_simps)+"], ["proof (state)\nthis:\n  sqrt (a * b) \\<le> (a + b) / 2\n  (sqrt (a * b) = (a + b) / 2) = (a = b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma refl_on_allrel: \"refl_on A (A \\<times> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on A (A \\<times> A)", "unfolding refl_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<times> A \\<subseteq> A \\<times> A \\<and>\n    (\\<forall>x\\<in>A. (x, x) \\<in> A \\<times> A)", "by simp"], ["", "lemma refl_on_restrict:\n  assumes \"refl_on A r\"\n  shows \"refl_on (A \\<inter> B) (r \\<inter> B \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on (A \\<inter> B) (Restr r B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. refl_on (A \\<inter> B) (Restr r B)", "from \\<open>refl_on A r\\<close> and refl_on_allrel [of B] and refl_on_Int"], ["proof (chain)\npicking this:\n  refl_on A r\n  refl_on B (B \\<times> B)\n  \\<lbrakk>refl_on ?A ?r; refl_on ?B ?s\\<rbrakk>\n  \\<Longrightarrow> refl_on (?A \\<inter> ?B) (?r \\<inter> ?s)", "show ?thesis"], ["proof (prove)\nusing this:\n  refl_on A r\n  refl_on B (B \\<times> B)\n  \\<lbrakk>refl_on ?A ?r; refl_on ?B ?s\\<rbrakk>\n  \\<Longrightarrow> refl_on (?A \\<inter> ?B) (?r \\<inter> ?s)\n\ngoal (1 subgoal):\n 1. refl_on (A \\<inter> B) (Restr r B)", "by auto"], ["proof (state)\nthis:\n  refl_on (A \\<inter> B) (Restr r B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sym_allrel: \"sym (A \\<times> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (A \\<times> A)", "unfolding sym_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y) \\<in> A \\<times> A \\<longrightarrow> (y, x) \\<in> A \\<times> A", "by simp"], ["", "lemma sym_restrict:\n  assumes \"sym r\"\n  shows \"sym (r \\<inter> A \\<times> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (Restr r A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sym (Restr r A)", "from \\<open>sym r\\<close> and sym_allrel and sym_Int"], ["proof (chain)\npicking this:\n  sym r\n  sym (?A \\<times> ?A)\n  \\<lbrakk>sym ?r; sym ?s\\<rbrakk> \\<Longrightarrow> sym (?r \\<inter> ?s)", "show ?thesis"], ["proof (prove)\nusing this:\n  sym r\n  sym (?A \\<times> ?A)\n  \\<lbrakk>sym ?r; sym ?s\\<rbrakk> \\<Longrightarrow> sym (?r \\<inter> ?s)\n\ngoal (1 subgoal):\n 1. sym (Restr r A)", "by auto"], ["proof (state)\nthis:\n  sym (Restr r A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trans_allrel: \"trans (A \\<times> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (A \\<times> A)", "unfolding trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> A \\<times> A \\<longrightarrow>\n       (y, z) \\<in> A \\<times> A \\<longrightarrow> (x, z) \\<in> A \\<times> A", "by simp"], ["", "lemma equiv_Int:\n  assumes \"equiv A r\" and \"equiv B s\"\n  shows \"equiv (A \\<inter> B) (r \\<inter> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv (A \\<inter> B) (r \\<inter> s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equiv (A \\<inter> B) (r \\<inter> s)", "from assms and refl_on_Int [of A r B s] and sym_Int and trans_Int"], ["proof (chain)\npicking this:\n  equiv A r\n  equiv B s\n  \\<lbrakk>refl_on A r; refl_on B s\\<rbrakk>\n  \\<Longrightarrow> refl_on (A \\<inter> B) (r \\<inter> s)\n  \\<lbrakk>sym ?r; sym ?s\\<rbrakk> \\<Longrightarrow> sym (?r \\<inter> ?s)\n  \\<lbrakk>trans ?r; trans ?s\\<rbrakk>\n  \\<Longrightarrow> trans (?r \\<inter> ?s)", "show ?thesis"], ["proof (prove)\nusing this:\n  equiv A r\n  equiv B s\n  \\<lbrakk>refl_on A r; refl_on B s\\<rbrakk>\n  \\<Longrightarrow> refl_on (A \\<inter> B) (r \\<inter> s)\n  \\<lbrakk>sym ?r; sym ?s\\<rbrakk> \\<Longrightarrow> sym (?r \\<inter> ?s)\n  \\<lbrakk>trans ?r; trans ?s\\<rbrakk>\n  \\<Longrightarrow> trans (?r \\<inter> ?s)\n\ngoal (1 subgoal):\n 1. equiv (A \\<inter> B) (r \\<inter> s)", "unfolding equiv_def"], ["proof (prove)\nusing this:\n  refl_on A r \\<and> sym r \\<and> trans r\n  refl_on B s \\<and> sym s \\<and> trans s\n  \\<lbrakk>refl_on A r; refl_on B s\\<rbrakk>\n  \\<Longrightarrow> refl_on (A \\<inter> B) (r \\<inter> s)\n  \\<lbrakk>sym ?r; sym ?s\\<rbrakk> \\<Longrightarrow> sym (?r \\<inter> ?s)\n  \\<lbrakk>trans ?r; trans ?s\\<rbrakk>\n  \\<Longrightarrow> trans (?r \\<inter> ?s)\n\ngoal (1 subgoal):\n 1. refl_on (A \\<inter> B) (r \\<inter> s) \\<and>\n    sym (r \\<inter> s) \\<and> trans (r \\<inter> s)", "by auto"], ["proof (state)\nthis:\n  equiv (A \\<inter> B) (r \\<inter> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma equiv_allrel: \"equiv A (A \\<times> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv A (A \\<times> A)", "unfolding equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on A (A \\<times> A) \\<and>\n    sym (A \\<times> A) \\<and> trans (A \\<times> A)", "by (simp add: refl_on_allrel sym_allrel trans_allrel)"], ["", "lemma equiv_restrict:\n  assumes \"equiv A r\"\n  shows \"equiv (A \\<inter> B) (r \\<inter> B \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv (A \\<inter> B) (Restr r B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equiv (A \\<inter> B) (Restr r B)", "from \\<open>equiv A r\\<close> and equiv_allrel [of B] and equiv_Int"], ["proof (chain)\npicking this:\n  equiv A r\n  equiv B (B \\<times> B)\n  \\<lbrakk>equiv ?A ?r; equiv ?B ?s\\<rbrakk>\n  \\<Longrightarrow> equiv (?A \\<inter> ?B) (?r \\<inter> ?s)", "show ?thesis"], ["proof (prove)\nusing this:\n  equiv A r\n  equiv B (B \\<times> B)\n  \\<lbrakk>equiv ?A ?r; equiv ?B ?s\\<rbrakk>\n  \\<Longrightarrow> equiv (?A \\<inter> ?B) (?r \\<inter> ?s)\n\ngoal (1 subgoal):\n 1. equiv (A \\<inter> B) (Restr r B)", "by auto"], ["proof (state)\nthis:\n  equiv (A \\<inter> B) (Restr r B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_times_eq_zero:\n  fixes x :: \"real^'n\" and A :: \"real^'n^'n\"\n  assumes \"invertible A\" and \"A *v x = 0\"\n  shows \"x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0", "using assms invertible_def matrix_left_invertible_ker"], ["proof (prove)\nusing this:\n  invertible A\n  A *v x = 0\n  invertible ?A =\n  (\\<exists>A'. ?A ** A' = mat (1::?'a) \\<and> A' ** ?A = mat (1::?'a))\n  (\\<exists>B. B ** ?A = mat (1::?'a)) =\n  (\\<forall>x. ?A *v x = 0 \\<longrightarrow> x = 0)\n\ngoal (1 subgoal):\n 1. x = 0", "by blast"], ["", "lemma times_invertible_eq_zero:\n  fixes x :: \"real^'n\" and A :: \"real^'n^'n\"\n  assumes \"invertible A\" and \"x v* A = 0\"\n  shows \"x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0", "using transpose_invertible assms invertible_times_eq_zero"], ["proof (prove)\nusing this:\n  invertible ?A \\<Longrightarrow>\n  invertible (Finite_Cartesian_Product.transpose ?A)\n  invertible A\n  x v* A = 0\n  \\<lbrakk>invertible ?A; ?A *v ?x = 0\\<rbrakk> \\<Longrightarrow> ?x = 0\n\ngoal (1 subgoal):\n 1. x = 0", "by fastforce"], ["", "lemma matrix_id_invertible:\n  \"invertible (mat 1 :: ('a::semiring_1)^'n^'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (mat (1::'a))", "by (simp add: invertible_def)"], ["", "lemma Image_refl_on_nonempty:\n  assumes \"refl_on A r\" and \"x \\<in> A\"\n  shows \"x \\<in> r``{x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> r `` {x}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, x) \\<in> r", "from \\<open>refl_on A r\\<close> and \\<open>x \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  refl_on A r\n  x \\<in> A", "show \"(x, x) \\<in> r\""], ["proof (prove)\nusing this:\n  refl_on A r\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> r", "unfolding refl_on_def"], ["proof (prove)\nusing this:\n  r \\<subseteq> A \\<times> A \\<and> (\\<forall>x\\<in>A. (x, x) \\<in> r)\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> r", "by simp"], ["proof (state)\nthis:\n  (x, x) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quotient_element_nonempty:\n  assumes \"equiv A r\" and \"X \\<in> A//r\"\n  shows \"\\<exists> x. x \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> X", "using assms in_quotient_imp_non_empty"], ["proof (prove)\nusing this:\n  equiv A r\n  X \\<in> A // r\n  \\<lbrakk>equiv ?A ?r; ?X \\<in> ?A // ?r\\<rbrakk>\n  \\<Longrightarrow> ?X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> X", "by fastforce"], ["", "lemma zero_3: \"(3::3) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 = 0", "by simp"], ["", "lemma card_suc_ge_insert:\n  fixes A and x\n  shows \"card A + 1 \\<ge> card (insert x A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert x A) \\<le> card A + 1", "using card_insert_le_m1"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?n; card ?y \\<le> ?n - 1\\<rbrakk>\n  \\<Longrightarrow> card (insert ?x ?y) \\<le> ?n\n\ngoal (1 subgoal):\n 1. card (insert x A) \\<le> card A + 1", "by fastforce"], ["", "lemma card_le_UNIV:\n  fixes A :: \"('n::finite) set\"\n  shows \"card A \\<le> CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A \\<le> CARD('n)", "by (simp add: card_mono)"], ["", "lemma partition_Image_element:\n  assumes \"equiv A r\" and \"X \\<in> A//r\" and \"x \\<in> X\"\n  shows \"r``{x} = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r `` {x} = X", "by (metis Image_singleton_iff assms equiv_class_eq_iff quotientE)"], ["", "lemma card_insert_ge: \"card (insert x A) \\<ge> card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A \\<le> card (insert x A)", "by (metis card.infinite card_insert_le zero_le)"], ["", "lemma choose_1:\n  assumes \"card S = 1\"\n  shows \"\\<exists> x. S = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. S = {x}", "using \\<open>card S = 1\\<close> and card_eq_SucD [of S 0]"], ["proof (prove)\nusing this:\n  card S = 1\n  card S = Suc 0 \\<Longrightarrow>\n  \\<exists>b B.\n     S = insert b B \\<and>\n     b \\<notin> B \\<and> card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {})\n\ngoal (1 subgoal):\n 1. \\<exists>x. S = {x}", "by simp"], ["", "lemma choose_2:\n  assumes \"card S = 2\"\n  shows \"\\<exists> x y. S = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x y. S = {x, y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x y. S = {x, y}", "from \\<open>card S = 2\\<close> and card_eq_SucD [of S 1]"], ["proof (chain)\npicking this:\n  card S = 2\n  card S = Suc 1 \\<Longrightarrow>\n  \\<exists>b B.\n     S = insert b B \\<and>\n     b \\<notin> B \\<and> card B = 1 \\<and> (1 = 0 \\<longrightarrow> B = {})", "obtain x and T where \"S = insert x T\" and \"card T = 1\""], ["proof (prove)\nusing this:\n  card S = 2\n  card S = Suc 1 \\<Longrightarrow>\n  \\<exists>b B.\n     S = insert b B \\<and>\n     b \\<notin> B \\<and> card B = 1 \\<and> (1 = 0 \\<longrightarrow> B = {})\n\ngoal (1 subgoal):\n 1. (\\<And>x T.\n        \\<lbrakk>S = insert x T; card T = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S = insert x T\n  card T = 1\n\ngoal (1 subgoal):\n 1. \\<exists>x y. S = {x, y}", "from \\<open>card T = 1\\<close> and choose_1"], ["proof (chain)\npicking this:\n  card T = 1\n  card ?S = 1 \\<Longrightarrow> \\<exists>x. ?S = {x}", "obtain y where \"T = {y}\""], ["proof (prove)\nusing this:\n  card T = 1\n  card ?S = 1 \\<Longrightarrow> \\<exists>x. ?S = {x}\n\ngoal (1 subgoal):\n 1. (\\<And>y. T = {y} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  T = {y}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. S = {x, y}", "with \\<open>S = insert x T\\<close>"], ["proof (chain)\npicking this:\n  S = insert x T\n  T = {y}", "have \"S = {x,y}\""], ["proof (prove)\nusing this:\n  S = insert x T\n  T = {y}\n\ngoal (1 subgoal):\n 1. S = {x, y}", "by simp"], ["proof (state)\nthis:\n  S = {x, y}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. S = {x, y}", "thus \"\\<exists> x y. S = {x,y}\""], ["proof (prove)\nusing this:\n  S = {x, y}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. S = {x, y}", "by auto"], ["proof (state)\nthis:\n  \\<exists>x y. S = {x, y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma choose_3:\n  assumes \"card S = 3\"\n  shows \"\\<exists> x y z. S = {x,y,z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x y z. S = {x, y, z}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x y z. S = {x, y, z}", "from \\<open>card S = 3\\<close> and card_eq_SucD [of S 2]"], ["proof (chain)\npicking this:\n  card S = 3\n  card S = Suc 2 \\<Longrightarrow>\n  \\<exists>b B.\n     S = insert b B \\<and>\n     b \\<notin> B \\<and> card B = 2 \\<and> (2 = 0 \\<longrightarrow> B = {})", "obtain x and T where \"S = insert x T\" and \"card T = 2\""], ["proof (prove)\nusing this:\n  card S = 3\n  card S = Suc 2 \\<Longrightarrow>\n  \\<exists>b B.\n     S = insert b B \\<and>\n     b \\<notin> B \\<and> card B = 2 \\<and> (2 = 0 \\<longrightarrow> B = {})\n\ngoal (1 subgoal):\n 1. (\\<And>x T.\n        \\<lbrakk>S = insert x T; card T = 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S = insert x T\n  card T = 2\n\ngoal (1 subgoal):\n 1. \\<exists>x y z. S = {x, y, z}", "from \\<open>card T = 2\\<close> and choose_2 [of T]"], ["proof (chain)\npicking this:\n  card T = 2\n  card T = 2 \\<Longrightarrow> \\<exists>x y. T = {x, y}", "obtain y and z where \"T = {y,z}\""], ["proof (prove)\nusing this:\n  card T = 2\n  card T = 2 \\<Longrightarrow> \\<exists>x y. T = {x, y}\n\ngoal (1 subgoal):\n 1. (\\<And>y z. T = {y, z} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T = {y, z}\n\ngoal (1 subgoal):\n 1. \\<exists>x y z. S = {x, y, z}", "with \\<open>S = insert x T\\<close>"], ["proof (chain)\npicking this:\n  S = insert x T\n  T = {y, z}", "have \"S = {x,y,z}\""], ["proof (prove)\nusing this:\n  S = insert x T\n  T = {y, z}\n\ngoal (1 subgoal):\n 1. S = {x, y, z}", "by simp"], ["proof (state)\nthis:\n  S = {x, y, z}\n\ngoal (1 subgoal):\n 1. \\<exists>x y z. S = {x, y, z}", "thus \"\\<exists> x y z. S = {x,y,z}\""], ["proof (prove)\nusing this:\n  S = {x, y, z}\n\ngoal (1 subgoal):\n 1. \\<exists>x y z. S = {x, y, z}", "by auto"], ["proof (state)\nthis:\n  \\<exists>x y z. S = {x, y, z}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_gt_0_diff_singleton:\n  assumes \"card S > 0\" and \"x \\<in> S\"\n  shows \"card (S - {x}) = card S - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (S - {x}) = card S - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (S - {x}) = card S - 1", "from \\<open>card S > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < card S", "have \"finite S\""], ["proof (prove)\nusing this:\n  0 < card S\n\ngoal (1 subgoal):\n 1. finite S", "by (rule card_ge_0_finite)"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. card (S - {x}) = card S - 1", "with \\<open>x \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S\n  finite S", "show \"card (S - {x}) = card S - 1\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  finite S\n\ngoal (1 subgoal):\n 1. card (S - {x}) = card S - 1", "by (simp add: card_Diff_singleton)"], ["proof (state)\nthis:\n  card (S - {x}) = card S - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_3_or_of_3:\n  fixes j :: 4\n  shows \"j = 3 \\<or> (\\<exists> j'::3. j = of_int (Rep_bit1 j'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = 3 \\<or> (\\<exists>j'. j = of_int (Rep_bit1 j'))", "proof (induct j)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 \\<le> z; z < int CARD(4)\\<rbrakk>\n       \\<Longrightarrow> of_int z = 3 \\<or>\n                         (\\<exists>j'. of_int z = of_int (Rep_bit1 j'))", "fix j_int :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 \\<le> z; z < int CARD(4)\\<rbrakk>\n       \\<Longrightarrow> of_int z = 3 \\<or>\n                         (\\<exists>j'. of_int z = of_int (Rep_bit1 j'))", "assume \"0 \\<le> j_int\""], ["proof (state)\nthis:\n  0 \\<le> j_int\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 \\<le> z; z < int CARD(4)\\<rbrakk>\n       \\<Longrightarrow> of_int z = 3 \\<or>\n                         (\\<exists>j'. of_int z = of_int (Rep_bit1 j'))", "assume \"j_int < int CARD(4)\""], ["proof (state)\nthis:\n  j_int < int CARD(4)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 \\<le> z; z < int CARD(4)\\<rbrakk>\n       \\<Longrightarrow> of_int z = 3 \\<or>\n                         (\\<exists>j'. of_int z = of_int (Rep_bit1 j'))", "hence \"j_int \\<le> 3\""], ["proof (prove)\nusing this:\n  j_int < int CARD(4)\n\ngoal (1 subgoal):\n 1. j_int \\<le> 3", "by simp"], ["proof (state)\nthis:\n  j_int \\<le> 3\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 \\<le> z; z < int CARD(4)\\<rbrakk>\n       \\<Longrightarrow> of_int z = 3 \\<or>\n                         (\\<exists>j'. of_int z = of_int (Rep_bit1 j'))", "show \"of_int j_int = (3::4) \\<or> (\\<exists> j'::3. of_int j_int = of_int (Rep_bit1 j'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))\n 2. \\<not> ?P \\<Longrightarrow>\n    of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "assume \"j_int = 3\""], ["proof (state)\nthis:\n  j_int = 3\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))\n 2. \\<not> ?P \\<Longrightarrow>\n    of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "thus\n      \"of_int j_int = (3::4) \\<or> (\\<exists> j'::3. of_int j_int = of_int (Rep_bit1 j'))\""], ["proof (prove)\nusing this:\n  j_int = 3\n\ngoal (1 subgoal):\n 1. of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "by simp"], ["proof (state)\nthis:\n  of_int j_int = 3 \\<or> (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))\n\ngoal (1 subgoal):\n 1. j_int \\<noteq> 3 \\<Longrightarrow>\n    of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j_int \\<noteq> 3 \\<Longrightarrow>\n    of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "assume \"j_int \\<noteq> 3\""], ["proof (state)\nthis:\n  j_int \\<noteq> 3\n\ngoal (1 subgoal):\n 1. j_int \\<noteq> 3 \\<Longrightarrow>\n    of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "with \\<open>j_int \\<le> 3\\<close>"], ["proof (chain)\npicking this:\n  j_int \\<le> 3\n  j_int \\<noteq> 3", "have \"j_int < 3\""], ["proof (prove)\nusing this:\n  j_int \\<le> 3\n  j_int \\<noteq> 3\n\ngoal (1 subgoal):\n 1. j_int < 3", "by simp"], ["proof (state)\nthis:\n  j_int < 3\n\ngoal (1 subgoal):\n 1. j_int \\<noteq> 3 \\<Longrightarrow>\n    of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "with \\<open>0 \\<le> j_int\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> j_int\n  j_int < 3", "have \"j_int \\<in> {0..<3}\""], ["proof (prove)\nusing this:\n  0 \\<le> j_int\n  j_int < 3\n\ngoal (1 subgoal):\n 1. j_int \\<in> {0..<3}", "by simp"], ["proof (state)\nthis:\n  j_int \\<in> {0..<3}\n\ngoal (1 subgoal):\n 1. j_int \\<noteq> 3 \\<Longrightarrow>\n    of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "hence \"Rep_bit1 (Abs_bit1 j_int :: 3) = j_int\""], ["proof (prove)\nusing this:\n  j_int \\<in> {0..<3}\n\ngoal (1 subgoal):\n 1. Rep_bit1 (Abs_bit1 j_int) = j_int", "by (simp add: bit1.Abs_inverse)"], ["proof (state)\nthis:\n  Rep_bit1 (Abs_bit1 j_int) = j_int\n\ngoal (1 subgoal):\n 1. j_int \\<noteq> 3 \\<Longrightarrow>\n    of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "hence \"of_int j_int = of_int (Rep_bit1 (Abs_bit1 j_int :: 3))\""], ["proof (prove)\nusing this:\n  Rep_bit1 (Abs_bit1 j_int) = j_int\n\ngoal (1 subgoal):\n 1. of_int j_int = of_int (Rep_bit1 (Abs_bit1 j_int))", "by simp"], ["proof (state)\nthis:\n  of_int j_int = of_int (Rep_bit1 (Abs_bit1 j_int))\n\ngoal (1 subgoal):\n 1. j_int \\<noteq> 3 \\<Longrightarrow>\n    of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "thus\n      \"of_int j_int = (3::4) \\<or> (\\<exists> j'::3. of_int j_int = of_int (Rep_bit1 j'))\""], ["proof (prove)\nusing this:\n  of_int j_int = of_int (Rep_bit1 (Abs_bit1 j_int))\n\ngoal (1 subgoal):\n 1. of_int j_int = 3 \\<or>\n    (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))", "by auto"], ["proof (state)\nthis:\n  of_int j_int = 3 \\<or> (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_int j_int = 3 \\<or> (\\<exists>j'. of_int j_int = of_int (Rep_bit1 j'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sgn_plus:\n  fixes x y :: \"'a::linordered_idom\"\n  assumes \"sgn x = sgn y\"\n  shows \"sgn (x + y) = sgn x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (x + y) = sgn x", "by (simp add: assms same_sgn_sgn_add)"], ["", "lemma sgn_div:\n  fixes x y :: \"'a::linordered_field\"\n  assumes \"y \\<noteq> 0\" and \"sgn x = sgn y\"\n  shows \"x / y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < x / y", "using assms sgn_1_pos sgn_eq_0_iff"], ["proof (prove)\nusing this:\n  y \\<noteq> (0::'a)\n  sgn x = sgn y\n  (sgn ?a = (1::?'a)) = ((0::?'a) < ?a)\n  (sgn ?a = (0::?'a)) = (?a = (0::?'a))\n\ngoal (1 subgoal):\n 1. (0::'a) < x / y", "by fastforce"], ["", "lemma abs_plus:\n  fixes x y :: \"'a::linordered_idom\"\n  assumes \"sgn x = sgn y\"\n  shows \"\\<bar>x + y\\<bar> = \\<bar>x\\<bar> + \\<bar>y\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x + y\\<bar> = \\<bar>x\\<bar> + \\<bar>y\\<bar>", "by (simp add: assms same_sgn_abs_add)"], ["", "lemma sgn_plus_abs:\n  fixes x y :: \"'a::linordered_idom\"\n  assumes \"\\<bar>x\\<bar> > \\<bar>y\\<bar>\"\n  shows \"sgn (x + y) = sgn x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (x + y) = sgn x", "by (cases \"x > 0\") (use assms in auto)"], ["", "end"]]}