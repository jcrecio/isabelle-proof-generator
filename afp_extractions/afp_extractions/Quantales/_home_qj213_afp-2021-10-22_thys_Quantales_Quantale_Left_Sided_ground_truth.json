{"file_name": "/home/qj213/afp-2021-10-22/thys/Quantales/Quantale_Left_Sided.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Quantales", "problem_names": ["lemma lsided_bres: \"(lsd x) = (x \\<le> \\<top> \\<rightarrow> x)\"", "lemma lsided_fres: \"(lsd x) = (\\<top> \\<le> x \\<leftarrow> x)\"", "lemma lsided_fres_eq: \"(lsd x) = (x \\<leftarrow> x = \\<top>)\"", "lemma lsided_slsided: \"lsd x \\<Longrightarrow> x \\<cdot> x = x \\<Longrightarrow> slsd x\"", "lemma lsided_prop: \"lsd x \\<Longrightarrow> y \\<cdot> x \\<le> x\"", "lemma rsided_fres: \"(rsd x) = (x \\<le> x \\<leftarrow> \\<top>)\"", "lemma rsided_bres: \"(rsd x) = (\\<top> \\<le> x \\<rightarrow> x)\"", "lemma rsided_bres_eq: \"(rsd x) = (x \\<rightarrow> x = \\<top>)\"", "lemma rsided_srsided: \"rsd x \\<Longrightarrow> x \\<cdot> x = x \\<Longrightarrow> srsd x\"", "lemma rsided_prop: \"rsd x \\<Longrightarrow> x \\<cdot> y \\<le> x\"", "lemma lsided_top: \"lsd \\<top>\"", "lemma lsided_bot: \"lsd \\<bottom>\"", "lemma rsided_top: \"rsd \\<top>\"", "lemma rsided_bot: \"rsd \\<bottom>\"", "lemma ls_galois: \"\\<nu> \\<stileturn> \\<nu>\\<^sup>\\<natural>\"", "lemma lsl_iso: \"mono \\<nu>\"", "lemma lsl_iso_var: \"x \\<le> y \\<Longrightarrow> \\<nu> x \\<le> \\<nu> y\"", "lemma lsu_iso: \"mono \\<nu>\\<^sup>\\<natural>\"", "lemma lsu_iso_var: \"x \\<le> y \\<Longrightarrow> \\<nu>\\<^sup>\\<natural> x \\<le> \\<nu>\\<^sup>\\<natural> y\"", "lemma lsl_bot [simp]: \"\\<nu> \\<bottom> = \\<bottom>\"", "lemma lsu_top [simp]: \"\\<nu>\\<^sup>\\<natural> \\<top> = \\<top>\"", "lemma lsu_Inf_pres: \"Inf_pres \\<nu>\\<^sup>\\<natural>\"", "lemma lsl_Sup_pres: \"Sup_pres (\\<nu>::'a::quantale \\<Rightarrow> 'a)\"", "lemma lsu_Inf_closed: \"Inf_closed_set (range \\<nu>\\<^sup>\\<natural>)\"", "lemma lsl_Sup_closed: \"Sup_closed_set (range (\\<nu>::'a::quantale \\<Rightarrow> 'a))\"", "lemma lsl_lsu_canc1: \"\\<nu> \\<circ> \\<nu>\\<^sup>\\<natural> \\<le> id\"", "lemma lsl_lsu_canc2: \"id \\<le> \\<nu>\\<^sup>\\<natural> \\<circ> \\<nu>\"", "lemma clop_lsu_lsl: \"clop (\\<nu>\\<^sup>\\<natural> \\<circ> \\<nu>)\"", "lemma coclop_lsl_lsu: \"coclop (\\<nu> \\<circ> \\<nu>\\<^sup>\\<natural>)\"", "lemma dang1: \"\\<nu> (\\<nu> x \\<sqinter> y) \\<le> \\<nu> x\"", "lemma lsl_trans: \"\\<nu> \\<circ> \\<nu> \\<le> \\<nu>\"", "lemma lsl_lsu_prop: \"\\<nu> \\<circ> \\<nu>\\<^sup>\\<natural> \\<le> \\<nu>\\<^sup>\\<natural>\"", "lemma lsu_lsl_prop: \"\\<nu> \\<le> \\<nu>\\<^sup>\\<natural> \\<circ> \\<nu>\"", "lemma lsided_eq: \"lsd = slsd\"", "lemma lsided_eq_var1:  \"(x \\<le> \\<top> \\<rightarrow> x) = (x = \\<top> \\<rightarrow> x)\"", "lemma lsided_eq_var2: \"lsd x = (x = \\<top> \\<rightarrow> x)\"", "lemma lsided_def3: \"(\\<nu> (x::'a::unital_quantale) = x) = (\\<nu>\\<^sup>\\<natural> x = x)\"", "lemma Fix_lsl_lsu: \"Fix (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a) = Fix \\<nu>\\<^sup>\\<natural>\"", "lemma Fix_lsl_left_slsided: \"Fix \\<nu> = {(x::'a::unital_quantale). lsd x}\"", "lemma Fix_lsl_iff [simp]: \"(x \\<in> Fix \\<nu>) = (\\<nu> x = x)\"", "lemma Fix_lsu_iff [simp]: \"(x \\<in> Fix \\<nu>\\<^sup>\\<natural>) = (\\<nu>\\<^sup>\\<natural> x = x)\"", "lemma lsl_lsu_prop_eq [simp]: \"(\\<nu>::'a::unital_quantale \\<Rightarrow> 'a) \\<circ> \\<nu>\\<^sup>\\<natural> = \\<nu>\\<^sup>\\<natural>\"", "lemma lsu_lsl_prop_eq [simp]: \"\\<nu>\\<^sup>\\<natural> \\<circ> \\<nu> = (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a)\"", "lemma lsl_clop: \"clop (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a)\"", "lemma lsu_coclop: \"coclop (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a)\"", "lemma lsl_range_fix: \"range (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a) = Fix \\<nu>\"", "lemma lsu_range_fix: \"range (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a) = Fix \\<nu>\\<^sup>\\<natural>\"", "lemma range_lsl_iff [simp]: \"((x::'a::unital_quantale) \\<in> range \\<nu>) = (\\<nu> x = x)\"", "lemma range_lsu_iff [simp]: \"((x::'a::unital_quantale) \\<in> range \\<nu>\\<^sup>\\<natural>) = (\\<nu>\\<^sup>\\<natural> x = x)\"", "lemma lsu_Sup_closed: \"Sup_closed_set (Fix (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a))\"", "lemma lsl_Inf_closed: \"Inf_closed_set (Fix (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a))\"", "lemma lsu_lax: \"\\<nu>\\<^sup>\\<natural> (x::'a::unital_quantale) \\<cdot> \\<nu>\\<^sup>\\<natural> y \\<le> \\<nu>\\<^sup>\\<natural> (x \\<cdot> y)\"", "lemma lsu_one: \"\\<nu>\\<^sup>\\<natural> 1 \\<le> (1::'a::unital_quantale)\"", "lemma lsl_one: \"1 \\<le> \\<nu> (1::'a::unital_quantale)\"", "lemma lsu_conuc: \"conucleus (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a)\"", "lemma lsu_comp_closed_var [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<cdot> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> x \\<cdot> \\<nu>\\<^sup>\\<natural> (y::'a::unital_quantale)\"", "lemma lsu_comp_closed: \"comp_closed_set (Fix (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a))\"", "lemma \"\\<nu> x \\<cdot> \\<nu> y \\<le> \\<nu> (x \\<cdot> (y::'a::unital_quantale))\"", "lemma lsl_comp_closed: \"comp_closed_set (Fix (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a))\"", "lemma lsl_comp_closed_var [simp]: \"\\<nu> (\\<nu> x \\<cdot> \\<nu> (y::'a::unital_quantale)) = \\<nu> x \\<cdot> \\<nu> y\"", "lemma lsl_lsu_ran: \"range \\<nu>\\<^sup>\\<natural> = range (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a)\"", "lemma lsl_top [simp]: \"\\<nu> \\<top> = (\\<top>::'a::unital_quantale)\"", "lemma lsu_bot [simp]: \"\\<nu>\\<^sup>\\<natural> \\<bottom> = (\\<bottom>::'a::unital_quantale)\"", "lemma lsu_inj_on: \"inj_on \\<nu>\\<^sup>\\<natural> (Fix (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a))\"", "lemma lsl_inj_on: \"inj_on \\<nu> (Fix (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a))\"", "lemma lsl_Inf_closed_var [simp]: \"\\<nu> (\\<Sqinter>x \\<in> X. \\<nu> x) = (\\<Sqinter>x \\<in> X.  \\<nu> (x::'a::unital_quantale))\"", "lemma lsl_Sup_closed_var [simp]: \"\\<nu> (\\<Squnion>x \\<in> X. \\<nu> x) = (\\<Squnion>x \\<in> X. \\<nu> (x::'a::unital_quantale))\"", "lemma lsu_Inf_closed_var [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<Sqinter>x \\<in> X. \\<nu>\\<^sup>\\<natural> x) = (\\<Sqinter>x \\<in> X. \\<nu>\\<^sup>\\<natural> (x::'a::unital_quantale))\"", "lemma lsu_Sup_closed_var [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<Squnion>x \\<in> X. \\<nu>\\<^sup>\\<natural> x) = (\\<Squnion>x \\<in> X. \\<nu>\\<^sup>\\<natural> (x::'a::unital_quantale))\"", "lemma lsl_inf_closed_var [simp]: \"\\<nu> (\\<nu> x \\<sqinter> \\<nu> y) = \\<nu> (x::'a::unital_quantale) \\<sqinter> \\<nu> y\"", "lemma lsl_sup_closed_var [simp]: \"\\<nu> (\\<nu> x \\<squnion> \\<nu> y) = \\<nu> (x::'a::unital_quantale) \\<squnion> \\<nu> y\"", "lemma lsu_inf_closed_var [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<sqinter> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> (x::'a::unital_quantale) \\<sqinter> \\<nu>\\<^sup>\\<natural> y\"", "lemma lsu_sup_closed_var [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> (x::'a::unital_quantale) \\<squnion> \\<nu>\\<^sup>\\<natural> y\"", "lemma lsu_fres_closed [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<leftarrow> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> x \\<leftarrow> \\<nu>\\<^sup>\\<natural> (y::'a::unital_quantale)\"", "lemma lsl_fres_closed [simp]: \"\\<nu> (\\<nu> x \\<leftarrow> \\<nu> y) = \\<nu> x \\<leftarrow> \\<nu> (y::'a::unital_quantale)\"", "lemma lsl_almost_lax: \"x \\<cdot> \\<nu> y \\<le> \\<nu> (y::'a::unital_quantale)\"", "lemma \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> (y::'a::unital_quantale)\"", "lemma \"\\<nu> (\\<nu> x \\<rightarrow> \\<nu> y) = \\<nu> x \\<rightarrow> \\<nu> (y::'a::unital_quantale)\"", "lemma lsided_times_top: \"lsd (\\<top> \\<cdot> x)\"", "lemma lsided_le2: \"lsd x \\<Longrightarrow> x \\<cdot> y \\<le> x \\<sqinter> (y \\<cdot> \\<top>)\"", "lemma lsided_le3: \"lsd x \\<Longrightarrow> (x \\<sqinter> y) \\<cdot> z \\<le> x\"", "lemma lsided_le4: \"lsd x \\<Longrightarrow> (x \\<sqinter> y) \\<cdot> z \\<le> x \\<sqinter> (y \\<cdot> z)\"", "lemma lsided_times_le_inf: \"lsd x \\<Longrightarrow> lsd y \\<Longrightarrow> x \\<cdot> y \\<le> x \\<sqinter> y\"", "lemma lsl_lax: \"\\<nu> x \\<cdot> \\<nu> y \\<le> \\<nu> (x \\<cdot> (y::'aa::ab_unital_quantale))\"", "lemma lsl_nuc: \"nucleus (\\<nu>::'a::ab_unital_quantale \\<Rightarrow> 'a)\"", "lemma lsl_comp_pres: \"\\<nu> (x \\<cdot> y) = \\<nu> x \\<cdot> \\<nu> (y::'a::ab_unital_quantale)\"", "lemma lsl_bres_closed [simp]: \"\\<nu> (\\<nu> x \\<rightarrow> \\<nu> y) = \\<nu> x \\<rightarrow> \\<nu> (y::'a::ab_unital_quantale)\"", "lemma lsu_bres_pres [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> (y::'a::ab_unital_quantale)\"", "lemma lsl_prelocalic_var: \"\\<nu> x \\<cdot> y \\<le> \\<nu> x \\<sqinter> \\<nu> (y::'a::ab_unital_quantale)\"", "lemma dang3: \"(\\<nu> x \\<sqinter> y) \\<cdot> z \\<le> \\<nu> x \\<sqinter> (y \\<cdot> (z::'a::ab_unital_quantale))\"", "lemma lsl_prelocalic: \"\\<nu> x \\<cdot> \\<nu> y \\<le> \\<nu> x \\<sqinter> \\<nu> (y::'a::ab_unital_quantale)\"", "lemma lsl_local: \"x \\<cdot> \\<nu> y \\<le> \\<nu> (x \\<cdot> (y::'a::ab_unital_quantale))\"", "lemma lsl_local_eq: \"x \\<cdot> \\<nu> y = \\<nu> (x \\<cdot> (y::'a::ab_unital_quantale))\"", "lemma lsl_rpc [simp]: \"\\<nu> (rpc x y) = rpc x y\"", "lemma lsu_rpc [simp]: \"\\<nu>\\<^sup>\\<natural> (rpc x y) = rpc x y\"", "lemma lsl_rpc_galois: \"(x \\<sqinter> \\<nu> z \\<le> y) = (z \\<le> rpc x (y::'a::bool_unital_quantale))\"", "lemma lsl_rpc_galois_var: \"x \\<sqinter> \\<nu> z \\<le> y \\<longleftrightarrow> \\<nu> z \\<le> rpc x y\"", "lemma rpc_expl_aux: \"\\<Squnion>{z. x \\<sqinter> \\<nu> z \\<le> y} = \\<Squnion>{z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = (z::'a::bool_unital_quantale)}\"", "lemma rpc_expl: \"rpc x y = \\<Squnion>{z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = (z::'a::bool_unital_quantale)}\"", "lemma \"\\<nu>\\<^sup>\\<natural> (x \\<cdot> y) = \\<nu>\\<^sup>\\<natural> x \\<cdot> \\<nu>\\<^sup>\\<natural> y\"", "lemma \"\\<nu> 1 = 1\"", "lemma \"\\<nu>\\<^sup>\\<natural> x = \\<nu> x\"", "lemma \"\\<nu>\\<^sup>\\<natural> (\\<Squnion> P) = \\<Squnion>{\\<nu>\\<^sup>\\<natural> p |p. p \\<in> P}\"", "lemma \"rpc (\\<nu>\\<^sup>\\<natural> x) (\\<nu>\\<^sup>\\<natural> y) = -(\\<nu>\\<^sup>\\<natural> x) \\<squnion> (\\<nu>\\<^sup>\\<natural> y)\"", "lemma \"rpc (\\<nu> x) (\\<nu> y) = -(\\<nu> x) \\<squnion> (\\<nu> y)\"", "lemma \"\\<nu> (-(\\<nu>\\<^sup>\\<natural> x) \\<squnion> (\\<nu>\\<^sup>\\<natural> y)) = -(\\<nu>\\<^sup>\\<natural> x) \\<squnion> (\\<nu>\\<^sup>\\<natural> y)\"", "lemma \"\\<nu> (-(\\<nu> x) \\<squnion> (\\<nu> y)) = -(\\<nu> x) \\<squnion> (\\<nu> y)\"", "lemma  \"\\<nu> x \\<cdot> \\<nu> y = \\<nu> x \\<sqinter> \\<nu> y\"", "lemma \"\\<nu> (- (\\<nu> x)) = - (\\<nu> x)\"", "lemma \"\\<nu>\\<^sup>\\<natural> (- (\\<nu>\\<^sup>\\<natural> x)) = - (\\<nu>\\<^sup>\\<natural> x)\"", "lemma \"\\<nu> (- (\\<nu> x) \\<squnion> (\\<nu> y)) = - (\\<nu> x) \\<squnion> (\\<nu> y)\"", "lemma \"\\<nu>\\<^sup>\\<natural> (- (\\<nu>\\<^sup>\\<natural> x) \\<squnion> (\\<nu>\\<^sup>\\<natural> y)) = - (\\<nu>\\<^sup>\\<natural> x) \\<squnion> (\\<nu>\\<^sup>\\<natural> y)\""], "translations": [["", "lemma lsided_bres: \"(lsd x) = (x \\<le> \\<top> \\<rightarrow> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd x = (x \\<le> \\<top> \\<rightarrow> x)", "by (simp add: bres_galois lsd_def)"], ["", "lemma lsided_fres: \"(lsd x) = (\\<top> \\<le> x \\<leftarrow> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd x = (\\<top> \\<le> x \\<leftarrow> x)", "by (simp add: fres_galois lsd_def)"], ["", "lemma lsided_fres_eq: \"(lsd x) = (x \\<leftarrow> x = \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd x = (x \\<leftarrow> x = \\<top>)", "using fres_galois top_le lsd_def"], ["proof (prove)\nusing this:\n  (?x \\<cdot> ?y \\<le> ?z) = (?x \\<le> ?z \\<leftarrow> ?y)\n  \\<top> \\<le> ?a \\<Longrightarrow> ?a = \\<top>\n  lsd ?x = (\\<top> \\<cdot> ?x \\<le> ?x)\n\ngoal (1 subgoal):\n 1. lsd x = (x \\<leftarrow> x = \\<top>)", "by force"], ["", "lemma lsided_slsided: \"lsd x \\<Longrightarrow> x \\<cdot> x = x \\<Longrightarrow> slsd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lsd x; x \\<cdot> x = x\\<rbrakk> \\<Longrightarrow> slsd x", "using fres_sol lsided_fres_eq slsd_def"], ["proof (prove)\nusing this:\n  ((?y \\<leftarrow> ?x) \\<cdot> ?x = ?y) = (\\<exists>z. z \\<cdot> ?x = ?y)\n  lsd ?x = (?x \\<leftarrow> ?x = \\<top>)\n  slsd ?x = (\\<top> \\<cdot> ?x = ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lsd x; x \\<cdot> x = x\\<rbrakk> \\<Longrightarrow> slsd x", "by force"], ["", "lemma lsided_prop: \"lsd x \\<Longrightarrow> y \\<cdot> x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd x \\<Longrightarrow> y \\<cdot> x \\<le> x", "by (simp add: fres_galois lsided_fres_eq)"], ["", "lemma rsided_fres: \"(rsd x) = (x \\<le> x \\<leftarrow> \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsd x = (x \\<le> x \\<leftarrow> \\<top>)", "by (simp add: fres_galois rsd_def)"], ["", "lemma rsided_bres: \"(rsd x) = (\\<top> \\<le> x \\<rightarrow> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsd x = (\\<top> \\<le> x \\<rightarrow> x)", "by (simp add: bres_galois rsd_def)"], ["", "lemma rsided_bres_eq: \"(rsd x) = (x \\<rightarrow> x = \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsd x = (x \\<rightarrow> x = \\<top>)", "using top_le rsided_bres"], ["proof (prove)\nusing this:\n  \\<top> \\<le> ?a \\<Longrightarrow> ?a = \\<top>\n  rsd ?x = (\\<top> \\<le> ?x \\<rightarrow> ?x)\n\ngoal (1 subgoal):\n 1. rsd x = (x \\<rightarrow> x = \\<top>)", "by blast"], ["", "lemma rsided_srsided: \"rsd x \\<Longrightarrow> x \\<cdot> x = x \\<Longrightarrow> srsd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rsd x; x \\<cdot> x = x\\<rbrakk> \\<Longrightarrow> srsd x", "using bres_sol rsided_bres_eq srsd_def"], ["proof (prove)\nusing this:\n  (?x \\<cdot> (?x \\<rightarrow> ?y) = ?y) = (\\<exists>z. ?x \\<cdot> z = ?y)\n  rsd ?x = (?x \\<rightarrow> ?x = \\<top>)\n  srsd ?x = (?x \\<cdot> \\<top> = ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rsd x; x \\<cdot> x = x\\<rbrakk> \\<Longrightarrow> srsd x", "by auto"], ["", "lemma rsided_prop: \"rsd x \\<Longrightarrow> x \\<cdot> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsd x \\<Longrightarrow> x \\<cdot> y \\<le> x", "by (simp add: bres_galois rsided_bres_eq)"], ["", "lemma lsided_top: \"lsd \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd \\<top>", "by (simp add: lsd_def)"], ["", "lemma lsided_bot: \"lsd \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd \\<bottom>", "by (simp add: lsd_def)"], ["", "lemma rsided_top: \"rsd \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsd \\<top>", "by (simp add: rsd_def)"], ["", "lemma rsided_bot: \"rsd \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsd \\<bottom>", "by (simp add: rsd_def)"], ["", "end"], ["", "text \\<open>Right-sided elements are henceforth not considered. Their properties arise by opposition\nduality, which is not formalised.\\<close>"], ["", "text \\<open>The following functions have left-sided elements as fixpoints.\\<close>"], ["", "definition lsl:: \"'a::quantale \\<Rightarrow> 'a\" (\"\\<nu>\") where \n  \"\\<nu> x = \\<top> \\<cdot> x\""], ["", "definition lsu :: \"'a::quantale \\<Rightarrow> 'a\" (\"\\<nu>\\<^sup>\\<natural>\") where \n  \"\\<nu>\\<^sup>\\<natural> x = \\<top> \\<rightarrow> x\""], ["", "text \\<open>These functions are adjoints.\\<close>"], ["", "lemma ls_galois: \"\\<nu> \\<stileturn> \\<nu>\\<^sup>\\<natural>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<stileturn> \\<nu>\\<^sup>\\<natural>", "by (simp add: adj_def bres_galois lsl_def lsu_def)"], ["", "text \\<open>Due to this, the following properties hold.\\<close>"], ["", "lemma lsl_iso: \"mono \\<nu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<nu>", "using adj_iso1 ls_galois"], ["proof (prove)\nusing this:\n  ?f \\<stileturn> ?g \\<Longrightarrow> mono ?f\n  \\<nu> \\<stileturn> \\<nu>\\<^sup>\\<natural>\n\ngoal (1 subgoal):\n 1. mono \\<nu>", "by blast"], ["", "lemma lsl_iso_var: \"x \\<le> y \\<Longrightarrow> \\<nu> x \\<le> \\<nu> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> \\<nu> x \\<le> \\<nu> y", "by (simp add: lsl_iso monoD)"], ["", "lemma lsu_iso: \"mono \\<nu>\\<^sup>\\<natural>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<nu>\\<^sup>\\<natural>", "using adj_iso2 ls_galois"], ["proof (prove)\nusing this:\n  ?f \\<stileturn> ?g \\<Longrightarrow> mono ?g\n  \\<nu> \\<stileturn> \\<nu>\\<^sup>\\<natural>\n\ngoal (1 subgoal):\n 1. mono \\<nu>\\<^sup>\\<natural>", "by blast"], ["", "lemma lsu_iso_var: \"x \\<le> y \\<Longrightarrow> \\<nu>\\<^sup>\\<natural> x \\<le> \\<nu>\\<^sup>\\<natural> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    \\<nu>\\<^sup>\\<natural> x \\<le> \\<nu>\\<^sup>\\<natural> y", "by (simp add: lsu_iso monoD)"], ["", "lemma lsl_bot [simp]: \"\\<nu> \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot_pres \\<nu>", "by (simp add: lsl_def)"], ["", "lemma lsu_top [simp]: \"\\<nu>\\<^sup>\\<natural> \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres \\<nu>\\<^sup>\\<natural>", "by (simp add: lsu_def bres_galois_imp top_le)"], ["", "lemma lsu_Inf_pres: \"Inf_pres \\<nu>\\<^sup>\\<natural>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres \\<nu>\\<^sup>\\<natural>", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<nu>\\<^sup>\\<natural> \\<circ> Inf) x =\n       (Inf \\<circ> (`) \\<nu>\\<^sup>\\<natural>) x", "by (metis ls_galois radj_Inf_pres)"], ["", "lemma lsl_Sup_pres: \"Sup_pres (\\<nu>::'a::quantale \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres \\<nu>", "by (simp add: fun_eq_iff, metis SUP_cong Sup_distl lsl_def)"], ["", "lemma lsu_Inf_closed: \"Inf_closed_set (range \\<nu>\\<^sup>\\<natural>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_closed_set (range \\<nu>\\<^sup>\\<natural>)", "by (simp add: Inf_pres_Inf_closed lsu_Inf_pres)"], ["", "lemma lsl_Sup_closed: \"Sup_closed_set (range (\\<nu>::'a::quantale \\<Rightarrow> 'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_closed_set (range \\<nu>)", "by (simp add: Sup_pres_Sup_closed lsl_Sup_pres)"], ["", "lemma lsl_lsu_canc1: \"\\<nu> \\<circ> \\<nu>\\<^sup>\\<natural> \\<le> id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<circ> \\<nu>\\<^sup>\\<natural> \\<le> id", "by (simp add: adj_cancel1 ls_galois)"], ["", "lemma lsl_lsu_canc2: \"id \\<le> \\<nu>\\<^sup>\\<natural> \\<circ> \\<nu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<le> \\<nu>\\<^sup>\\<natural> \\<circ> \\<nu>", "by (simp add: adj_cancel2 ls_galois)"], ["", "lemma clop_lsu_lsl: \"clop (\\<nu>\\<^sup>\\<natural> \\<circ> \\<nu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop (\\<nu>\\<^sup>\\<natural> \\<circ> \\<nu>)", "by (simp add: clop_adj ls_galois)"], ["", "lemma coclop_lsl_lsu: \"coclop (\\<nu> \\<circ> \\<nu>\\<^sup>\\<natural>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop (\\<nu> \\<circ> \\<nu>\\<^sup>\\<natural>)", "by (simp add: coclop_adj ls_galois)"], ["", "lemma dang1: \"\\<nu> (\\<nu> x \\<sqinter> y) \\<le> \\<nu> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (\\<nu> x \\<sqinter> y) \\<le> \\<nu> x", "unfolding lsl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<cdot> (\\<top> \\<cdot> x \\<sqinter> y) \\<le> \\<top> \\<cdot> x", "by (metis bres_galois bres_interchange bres_top_top inf.coboundedI1)"], ["", "lemma lsl_trans: \"\\<nu> \\<circ> \\<nu> \\<le> \\<nu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<circ> \\<nu> \\<le> \\<nu>", "unfolding lsl_def fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<top> \\<cdot> (\\<top> \\<cdot> x)) \\<le> (\\<cdot>) \\<top>", "by (metis (no_types, lifting) bres_galois bres_interchange bres_top_top le_funI)"], ["", "lemma lsl_lsu_prop: \"\\<nu> \\<circ> \\<nu>\\<^sup>\\<natural> \\<le> \\<nu>\\<^sup>\\<natural>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<circ> \\<nu>\\<^sup>\\<natural> \\<le> \\<nu>\\<^sup>\\<natural>", "unfolding le_fun_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<nu> (\\<nu>\\<^sup>\\<natural> x) \\<le> \\<nu>\\<^sup>\\<natural> x", "by (metis adj_def dang1 dual_order.trans le_iff_inf ls_galois order_refl top_greatest)"], ["", "lemma lsu_lsl_prop: \"\\<nu> \\<le> \\<nu>\\<^sup>\\<natural> \\<circ> \\<nu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<le> \\<nu>\\<^sup>\\<natural> \\<circ> \\<nu>", "unfolding le_fun_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<nu> x \\<le> \\<nu>\\<^sup>\\<natural> (\\<nu> x)", "by (metis adj_def comp_def le_fun_def ls_galois lsl_trans)"], ["", "context unital_quantale\nbegin"], ["", "text \\<open>Left-sidedness and strict left-sidedness now coincide.\\<close>"], ["", "lemma lsided_eq: \"lsd = slsd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd = slsd", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. lsd x = slsd x", "by (simp add: eq_iff le_top lsd_def slsd_def)"], ["", "lemma lsided_eq_var1:  \"(x \\<le> \\<top> \\<rightarrow> x) = (x = \\<top> \\<rightarrow> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> \\<top> \\<rightarrow> x) = (x = \\<top> \\<rightarrow> x)", "using bres_galois dual_order.trans eq_iff le_top"], ["proof (prove)\nusing this:\n  (?x \\<cdot> ?y \\<le> ?z) = (?y \\<le> ?x \\<rightarrow> ?z)\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n  ?x \\<le> \\<top> \\<cdot> ?x\n\ngoal (1 subgoal):\n 1. (x \\<le> \\<top> \\<rightarrow> x) = (x = \\<top> \\<rightarrow> x)", "by blast"], ["", "lemma lsided_eq_var2: \"lsd x = (x = \\<top> \\<rightarrow> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd x = (x = \\<top> \\<rightarrow> x)", "using bres_galois lsided_eq lsided_eq_var1 lsd_def"], ["proof (prove)\nusing this:\n  (?x \\<cdot> ?y \\<le> ?z) = (?y \\<le> ?x \\<rightarrow> ?z)\n  lsd = slsd\n  (?x \\<le> \\<top> \\<rightarrow> ?x) = (?x = \\<top> \\<rightarrow> ?x)\n  lsd ?x = (\\<top> \\<cdot> ?x \\<le> ?x)\n\ngoal (1 subgoal):\n 1. lsd x = (x = \\<top> \\<rightarrow> x)", "by simp"], ["", "end"], ["", "lemma lsided_def3: \"(\\<nu> (x::'a::unital_quantale) = x) = (\\<nu>\\<^sup>\\<natural> x = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nu> x = x) = (\\<nu>\\<^sup>\\<natural> x = x)", "unfolding lsl_def lsu_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<top> \\<cdot> x = x) = (\\<top> \\<rightarrow> x = x)", "by (metis lsided_eq lsided_eq_var2 slsd_def)"], ["", "lemma Fix_lsl_lsu: \"Fix (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a) = Fix \\<nu>\\<^sup>\\<natural>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fix \\<nu> = Fix \\<nu>\\<^sup>\\<natural>", "unfolding Fix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<nu> x = x} = {x. \\<nu>\\<^sup>\\<natural> x = x}", "by (simp add: lsided_def3)"], ["", "lemma Fix_lsl_left_slsided: \"Fix \\<nu> = {(x::'a::unital_quantale). lsd x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fix \\<nu> = {x. lsd x}", "unfolding Fix_def lsl_def lsd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<top> \\<cdot> x = x} = {x. \\<top> \\<cdot> x \\<le> x}", "using eq_iff le_top"], ["proof (prove)\nusing this:\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n  ?x \\<le> \\<top> \\<cdot> ?x\n\ngoal (1 subgoal):\n 1. {x. \\<top> \\<cdot> x = x} = {x. \\<top> \\<cdot> x \\<le> x}", "by blast"], ["", "lemma Fix_lsl_iff [simp]: \"(x \\<in> Fix \\<nu>) = (\\<nu> x = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> Fix \\<nu>) = (\\<nu> x = x)", "by (simp add: Fix_def)"], ["", "lemma Fix_lsu_iff [simp]: \"(x \\<in> Fix \\<nu>\\<^sup>\\<natural>) = (\\<nu>\\<^sup>\\<natural> x = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> Fix \\<nu>\\<^sup>\\<natural>) = (\\<nu>\\<^sup>\\<natural> x = x)", "by (simp add: Fix_def)"], ["", "lemma lsl_lsu_prop_eq [simp]: \"(\\<nu>::'a::unital_quantale \\<Rightarrow> 'a) \\<circ> \\<nu>\\<^sup>\\<natural> = \\<nu>\\<^sup>\\<natural>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<circ> \\<nu>\\<^sup>\\<natural> = \\<nu>\\<^sup>\\<natural>", "by (smt antisym clop_extensive_var clop_lsu_lsl comp_apply le_fun_def lsided_eq_var1 lsl_lsu_prop lsu_def lsu_lsl_prop)"], ["", "lemma lsu_lsl_prop_eq [simp]: \"\\<nu>\\<^sup>\\<natural> \\<circ> \\<nu> = (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> \\<circ> \\<nu> = \\<nu>", "by (metis adj_cancel_eq1 ls_galois lsl_lsu_prop_eq)"], ["", "subsection \\<open>Connection with Closure and Coclosure Operators, Nuclei and Conuclei\\<close>"], ["", "text \\<open>lsl is therefore a closure operator, lsu a cocolosure operator.\\<close>"], ["", "lemma lsl_clop: \"clop (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop \\<nu>", "by (metis clop_lsu_lsl lsu_lsl_prop_eq)"], ["", "lemma lsu_coclop: \"coclop (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop \\<nu>\\<^sup>\\<natural>", "by (metis coclop_lsl_lsu lsl_lsu_prop_eq)"], ["", "lemma lsl_range_fix: \"range (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a) = Fix \\<nu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range \\<nu> = Fix \\<nu>", "by (simp add: clop_closure_set lsl_clop)"], ["", "lemma lsu_range_fix: \"range (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a) = Fix \\<nu>\\<^sup>\\<natural>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range \\<nu>\\<^sup>\\<natural> = Fix \\<nu>\\<^sup>\\<natural>", "by (simp add: coclop_coclosure_set lsu_coclop)"], ["", "lemma range_lsl_iff [simp]: \"((x::'a::unital_quantale) \\<in> range \\<nu>) = (\\<nu> x = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> range \\<nu>) = (\\<nu> x = x)", "by (simp add: lsl_range_fix)"], ["", "lemma range_lsu_iff [simp]: \"((x::'a::unital_quantale) \\<in> range \\<nu>\\<^sup>\\<natural>) = (\\<nu>\\<^sup>\\<natural> x = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> range \\<nu>\\<^sup>\\<natural>) = (\\<nu>\\<^sup>\\<natural> x = x)", "by (simp add: lsu_range_fix)"], ["", "text \\<open>lsl and lsu are therefore both Sup and Inf closed.\\<close>"], ["", "lemma lsu_Sup_closed: \"Sup_closed_set (Fix (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_closed_set (Fix \\<nu>\\<^sup>\\<natural>)", "by (metis Fix_lsl_lsu lsl_Sup_closed lsl_range_fix)"], ["", "lemma lsl_Inf_closed: \"Inf_closed_set (Fix (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_closed_set (Fix \\<nu>)", "by (metis Fix_lsl_lsu lsu_Inf_closed lsu_range_fix)"], ["", "text \\<open>lsl is even a quantic conucleus.\\<close>"], ["", "lemma lsu_lax: \"\\<nu>\\<^sup>\\<natural> (x::'a::unital_quantale) \\<cdot> \\<nu>\\<^sup>\\<natural> y \\<le> \\<nu>\\<^sup>\\<natural> (x \\<cdot> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> x \\<cdot> \\<nu>\\<^sup>\\<natural> y\n    \\<le> \\<nu>\\<^sup>\\<natural> (x \\<cdot> y)", "unfolding lsu_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<top> \\<rightarrow> x) \\<cdot> (\\<top> \\<rightarrow> y)\n    \\<le> \\<top> \\<rightarrow> x \\<cdot> y", "by (meson bres_canc1 bres_galois bres_interchange le_top order_trans)"], ["", "lemma lsu_one: \"\\<nu>\\<^sup>\\<natural> 1 \\<le> (1::'a::unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> (1::'a) \\<le> (1::'a)", "unfolding lsu_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<rightarrow> (1::'a) \\<le> (1::'a)", "using bres_canc1 dual_order.trans le_top"], ["proof (prove)\nusing this:\n  ?x \\<cdot> (?x \\<rightarrow> ?y) \\<le> ?y\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  ?x \\<le> \\<top> \\<cdot> ?x\n\ngoal (1 subgoal):\n 1. \\<top> \\<rightarrow> (1::'a) \\<le> (1::'a)", "by blast"], ["", "lemma lsl_one: \"1 \\<le> \\<nu> (1::'a::unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> \\<nu> (1::'a)", "unfolding lsl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> \\<top> \\<cdot> (1::'a)", "by simp"], ["", "lemma lsu_conuc: \"conucleus (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conucleus \\<nu>\\<^sup>\\<natural>", "by (simp add: lsu_coclop conucleus_def lsu_lax)"], ["", "text \\<open>It is therefore closed under composition.\\<close>"], ["", "lemma lsu_comp_closed_var [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<cdot> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> x \\<cdot> \\<nu>\\<^sup>\\<natural> (y::'a::unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural>\n     (\\<nu>\\<^sup>\\<natural> x \\<cdot> \\<nu>\\<^sup>\\<natural> y) =\n    \\<nu>\\<^sup>\\<natural> x \\<cdot> \\<nu>\\<^sup>\\<natural> y", "by (simp add: conuc_comp_closed lsu_conuc)"], ["", "lemma lsu_comp_closed: \"comp_closed_set (Fix (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_closed_set (Fix \\<nu>\\<^sup>\\<natural>)", "by (simp add: conuc_Sup_qclosed lsu_conuc)"], ["", "text \\<open>lsl is not a quantic nucleus unless composition is commutative.\\<close>"], ["", "lemma \"\\<nu> x \\<cdot> \\<nu> y \\<le> \\<nu> (x \\<cdot> (y::'a::unital_quantale))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> x \\<cdot> \\<nu> y \\<le> \\<nu> (x \\<cdot> y)", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> x \\<cdot> \\<nu> y \\<le> \\<nu> (x \\<cdot> y)", "oops"], ["", "text \\<open>Yet it is closed under composition (because the set of fixpoints are the same).\\<close>"], ["", "lemma lsl_comp_closed: \"comp_closed_set (Fix (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_closed_set (Fix \\<nu>)", "by (simp add: Fix_lsl_lsu lsu_comp_closed)"], ["", "lemma lsl_comp_closed_var [simp]: \"\\<nu> (\\<nu> x \\<cdot> \\<nu> (y::'a::unital_quantale)) = \\<nu> x \\<cdot> \\<nu> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (\\<nu> x \\<cdot> \\<nu> y) = \\<nu> x \\<cdot> \\<nu> y", "by (metis Fix_lsl_iff lsl_def lsl_range_fix mult.assoc rangeI)"], ["", "text \\<open>The following simple properties go beyond nuclei and conuclei.\\<close>"], ["", "lemma lsl_lsu_ran: \"range \\<nu>\\<^sup>\\<natural> = range (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range \\<nu>\\<^sup>\\<natural> = range \\<nu>", "by (simp add: Fix_lsl_lsu lsl_range_fix lsu_range_fix)"], ["", "lemma lsl_top [simp]: \"\\<nu> \\<top> = (\\<top>::'a::unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres \\<nu>", "by (simp add: clop_top lsl_clop)"], ["", "lemma lsu_bot [simp]: \"\\<nu>\\<^sup>\\<natural> \\<bottom> = (\\<bottom>::'a::unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot_pres \\<nu>\\<^sup>\\<natural>", "using lsided_def3 lsl_bot"], ["proof (prove)\nusing this:\n  (\\<nu> ?x = ?x) = (\\<nu>\\<^sup>\\<natural> ?x = ?x)\n  bot_pres \\<nu>\n\ngoal (1 subgoal):\n 1. bot_pres \\<nu>\\<^sup>\\<natural>", "by blast"], ["", "lemma lsu_inj_on: \"inj_on \\<nu>\\<^sup>\\<natural> (Fix (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<nu>\\<^sup>\\<natural> (Fix \\<nu>\\<^sup>\\<natural>)", "by (metis coclop_coclosure inj_onI lsu_coclop lsu_range_fix)"], ["", "lemma lsl_inj_on: \"inj_on \\<nu> (Fix (\\<nu>::'a::unital_quantale \\<Rightarrow> 'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<nu> (Fix \\<nu>)", "by (metis clop_closure inj_onI lsl_clop lsl_range_fix)"], ["", "text \\<open>Additional preservation properties of lsl and lsu are useful in proofs.\\<close>"], ["", "lemma lsl_Inf_closed_var [simp]: \"\\<nu> (\\<Sqinter>x \\<in> X. \\<nu> x) = (\\<Sqinter>x \\<in> X.  \\<nu> (x::'a::unital_quantale))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (\\<Sqinter> (\\<nu> ` X)) = \\<Sqinter> (\\<nu> ` X)", "by (metis (no_types, hide_lams) INF_image lsided_def3 lsu_Inf_pres lsu_lsl_prop_eq o_apply)"], ["", "lemma lsl_Sup_closed_var [simp]: \"\\<nu> (\\<Squnion>x \\<in> X. \\<nu> x) = (\\<Squnion>x \\<in> X. \\<nu> (x::'a::unital_quantale))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (\\<Squnion> (\\<nu> ` X)) = \\<Squnion> (\\<nu> ` X)", "unfolding lsl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<cdot> \\<Squnion> ((\\<cdot>) \\<top> ` X) =\n    \\<Squnion> ((\\<cdot>) \\<top> ` X)", "by (metis Sup_distl mult.assoc top_times_top)"], ["", "lemma lsu_Inf_closed_var [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<Sqinter>x \\<in> X. \\<nu>\\<^sup>\\<natural> x) = (\\<Sqinter>x \\<in> X. \\<nu>\\<^sup>\\<natural> (x::'a::unital_quantale))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> (\\<Sqinter> (\\<nu>\\<^sup>\\<natural> ` X)) =\n    \\<Sqinter> (\\<nu>\\<^sup>\\<natural> ` X)", "by (metis INF_image lsided_def3 lsl_Inf_closed_var lsl_lsu_prop_eq)"], ["", "lemma lsu_Sup_closed_var [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<Squnion>x \\<in> X. \\<nu>\\<^sup>\\<natural> x) = (\\<Squnion>x \\<in> X. \\<nu>\\<^sup>\\<natural> (x::'a::unital_quantale))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> (\\<Squnion> (\\<nu>\\<^sup>\\<natural> ` X)) =\n    \\<Squnion> (\\<nu>\\<^sup>\\<natural> ` X)", "by (metis SUP_image lsided_def3 lsl_Sup_closed_var lsl_lsu_prop_eq)"], ["", "lemma lsl_inf_closed_var [simp]: \"\\<nu> (\\<nu> x \\<sqinter> \\<nu> y) = \\<nu> (x::'a::unital_quantale) \\<sqinter> \\<nu> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) = \\<nu> x \\<sqinter> \\<nu> y", "by (smt antisym clop_extensive_var dang1 inf_sup_aci(1) le_inf_iff lsl_clop)"], ["", "lemma lsl_sup_closed_var [simp]: \"\\<nu> (\\<nu> x \\<squnion> \\<nu> y) = \\<nu> (x::'a::unital_quantale) \\<squnion> \\<nu> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (\\<nu> x \\<squnion> \\<nu> y) = \\<nu> x \\<squnion> \\<nu> y", "by (meson Sup_sup_closed lsl_Sup_closed range_eqI range_lsl_iff sup_closed_set_def)"], ["", "lemma lsu_inf_closed_var [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<sqinter> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> (x::'a::unital_quantale) \\<sqinter> \\<nu>\\<^sup>\\<natural> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural>\n     (\\<nu>\\<^sup>\\<natural> x \\<sqinter> \\<nu>\\<^sup>\\<natural> y) =\n    \\<nu>\\<^sup>\\<natural> x \\<sqinter> \\<nu>\\<^sup>\\<natural> y", "by (metis (no_types, lifting) lsided_def3 lsl_inf_closed_var lsl_lsu_prop_eq o_apply)"], ["", "lemma lsu_sup_closed_var [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> (x::'a::unital_quantale) \\<squnion> \\<nu>\\<^sup>\\<natural> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural>\n     (\\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y) =\n    \\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y", "by (metis (no_types, lifting) lsided_def3 lsl_lsu_prop_eq lsl_sup_closed_var o_def)"], ["", "lemma lsu_fres_closed [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<leftarrow> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> x \\<leftarrow> \\<nu>\\<^sup>\\<natural> (y::'a::unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural>\n     (\\<nu>\\<^sup>\\<natural> x \\<leftarrow> \\<nu>\\<^sup>\\<natural> y) =\n    \\<nu>\\<^sup>\\<natural> x \\<leftarrow> \\<nu>\\<^sup>\\<natural> y", "unfolding lsu_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<rightarrow>\n    \\<top> \\<rightarrow> x \\<leftarrow> (\\<top> \\<rightarrow> y) =\n    \\<top> \\<rightarrow> x \\<leftarrow> (\\<top> \\<rightarrow> y)", "by (simp add: bres_curry fres_bres)"], ["", "lemma lsl_fres_closed [simp]: \"\\<nu> (\\<nu> x \\<leftarrow> \\<nu> y) = \\<nu> x \\<leftarrow> \\<nu> (y::'a::unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (\\<nu> x \\<leftarrow> \\<nu> y) = \\<nu> x \\<leftarrow> \\<nu> y", "unfolding lsl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<cdot> (\\<top> \\<cdot> x \\<leftarrow> \\<top> \\<cdot> y) =\n    \\<top> \\<cdot> x \\<leftarrow> \\<top> \\<cdot> y", "by (metis fres_interchange lsd_def lsided_eq mult.assoc slsd_def top_times_top)"], ["", "lemma lsl_almost_lax: \"x \\<cdot> \\<nu> y \\<le> \\<nu> (y::'a::unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> \\<nu> y \\<le> \\<nu> y", "by (metis inf_top.right_neutral lsided_eq lsided_prop lsl_def lsl_inf_closed_var mult.right_neutral slsd_def)"], ["", "text \\<open>Finally, here are two counterexamples.\\<close>"], ["", "lemma \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> (y::'a::unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural>\n     (\\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> y) =\n    \\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural>\n     (\\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> y) =\n    \\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> y", "oops"], ["", "lemma \"\\<nu> (\\<nu> x \\<rightarrow> \\<nu> y) = \\<nu> x \\<rightarrow> \\<nu> (y::'a::unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (\\<nu> x \\<rightarrow> \\<nu> y) = \\<nu> x \\<rightarrow> \\<nu> y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (\\<nu> x \\<rightarrow> \\<nu> y) = \\<nu> x \\<rightarrow> \\<nu> y", "oops"], ["", "context ab_quantale\nbegin"], ["", "lemma lsided_times_top: \"lsd (\\<top> \\<cdot> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd (\\<top> \\<cdot> x)", "by (metis lsd_def mult_isor top_greatest mult_assoc)"], ["", "lemma lsided_le2: \"lsd x \\<Longrightarrow> x \\<cdot> y \\<le> x \\<sqinter> (y \\<cdot> \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd x \\<Longrightarrow>\n    x \\<cdot> y \\<le> x \\<sqinter> (y \\<cdot> \\<top>)", "using lsided_prop psrpq.mult_isol mult_commute"], ["proof (prove)\nusing this:\n  lsd ?x \\<Longrightarrow> ?y \\<cdot> ?x \\<le> ?x\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<cdot> ?x \\<le> ?z \\<cdot> ?y\n  ?a \\<cdot> ?b = ?b \\<cdot> ?a\n\ngoal (1 subgoal):\n 1. lsd x \\<Longrightarrow>\n    x \\<cdot> y \\<le> x \\<sqinter> (y \\<cdot> \\<top>)", "by auto"], ["", "lemma lsided_le3: \"lsd x \\<Longrightarrow> (x \\<sqinter> y) \\<cdot> z \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd x \\<Longrightarrow> x \\<sqinter> y \\<cdot> z \\<le> x", "by (metis inf_le1 lsided_prop mult_isol order_trans mult_commute)"], ["", "lemma lsided_le4: \"lsd x \\<Longrightarrow> (x \\<sqinter> y) \\<cdot> z \\<le> x \\<sqinter> (y \\<cdot> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsd x \\<Longrightarrow>\n    x \\<sqinter> y \\<cdot> z \\<le> x \\<sqinter> (y \\<cdot> z)", "by (simp add: mult_isor lsided_le3)"], ["", "lemma lsided_times_le_inf: \"lsd x \\<Longrightarrow> lsd y \\<Longrightarrow> x \\<cdot> y \\<le> x \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lsd x; lsd y\\<rbrakk>\n    \\<Longrightarrow> x \\<cdot> y \\<le> x \\<sqinter> y", "using lsided_prop lsided_le2"], ["proof (prove)\nusing this:\n  lsd ?x \\<Longrightarrow> ?y \\<cdot> ?x \\<le> ?x\n  lsd ?x \\<Longrightarrow>\n  ?x \\<cdot> ?y \\<le> ?x \\<sqinter> (?y \\<cdot> \\<top>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lsd x; lsd y\\<rbrakk>\n    \\<Longrightarrow> x \\<cdot> y \\<le> x \\<sqinter> y", "by force"], ["", "end"], ["", "text \\<open>Now lsl is a quantic nucleus.\\<close>"], ["", "lemma lsl_lax: \"\\<nu> x \\<cdot> \\<nu> y \\<le> \\<nu> (x \\<cdot> (y::'aa::ab_unital_quantale))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> x \\<cdot> \\<nu> y \\<le> \\<nu> (x \\<cdot> y)", "by (metis (no_types, hide_lams) lsl_almost_lax lsl_def mult.commute mult.left_commute)"], ["", "lemma lsl_nuc: \"nucleus (\\<nu>::'a::ab_unital_quantale \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nucleus \\<nu>", "by (simp add: lsl_clop nucleus_def lsl_lax)"], ["", "text \\<open>The following properties go beyond nuclei.\\<close>"], ["", "lemma lsl_comp_pres: \"\\<nu> (x \\<cdot> y) = \\<nu> x \\<cdot> \\<nu> (y::'a::ab_unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (x \\<cdot> y) = \\<nu> x \\<cdot> \\<nu> y", "by (metis (no_types, lifting) lsl_comp_closed_var lsl_nuc nuc_prop1 nuc_prop2)"], ["", "lemma lsl_bres_closed [simp]: \"\\<nu> (\\<nu> x \\<rightarrow> \\<nu> y) = \\<nu> x \\<rightarrow> \\<nu> (y::'a::ab_unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (\\<nu> x \\<rightarrow> \\<nu> y) = \\<nu> x \\<rightarrow> \\<nu> y", "by (simp add: lsl_nuc nuc_bres_closed)"], ["", "lemma lsu_bres_pres [simp]: \"\\<nu>\\<^sup>\\<natural> (\\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> y) = \\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> (y::'a::ab_unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural>\n     (\\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> y) =\n    \\<nu>\\<^sup>\\<natural> x \\<rightarrow> \\<nu>\\<^sup>\\<natural> y", "by (simp add: bres_fres_eq)"], ["", "lemma lsl_prelocalic_var: \"\\<nu> x \\<cdot> y \\<le> \\<nu> x \\<sqinter> \\<nu> (y::'a::ab_unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> x \\<cdot> y \\<le> \\<nu> x \\<sqinter> \\<nu> y", "by (metis inf_top.right_neutral lsided_le4 lsided_times_top lsl_def)"], ["", "lemma dang3: \"(\\<nu> x \\<sqinter> y) \\<cdot> z \\<le> \\<nu> x \\<sqinter> (y \\<cdot> (z::'a::ab_unital_quantale))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> x \\<sqinter> y \\<cdot> z \\<le> \\<nu> x \\<sqinter> (y \\<cdot> z)", "by (metis lsided_le4 lsided_times_top lsl_def)"], ["", "lemma lsl_prelocalic: \"\\<nu> x \\<cdot> \\<nu> y \\<le> \\<nu> x \\<sqinter> \\<nu> (y::'a::ab_unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> x \\<cdot> \\<nu> y \\<le> \\<nu> x \\<sqinter> \\<nu> y", "by (metis lsided_times_le_inf lsided_times_top lsl_def)"], ["", "lemma lsl_local: \"x \\<cdot> \\<nu> y \\<le> \\<nu> (x \\<cdot> (y::'a::ab_unital_quantale))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> \\<nu> y \\<le> \\<nu> (x \\<cdot> y)", "by (simp add: lsl_def mult.left_commute)"], ["", "lemma lsl_local_eq: \"x \\<cdot> \\<nu> y = \\<nu> (x \\<cdot> (y::'a::ab_unital_quantale))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> \\<nu> y = \\<nu> (x \\<cdot> y)", "by (simp add: lsl_def mult.left_commute)"], ["", "text \\<open>Relative pseudocomplementation can be defined on the subquantale induced by lsu.\\<close>"], ["", "definition \"rpc x y = \\<nu>\\<^sup>\\<natural> (-x \\<squnion> (y::'a::bool_unital_quantale))\""], ["", "lemma lsl_rpc [simp]: \"\\<nu> (rpc x y) = rpc x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (rpc x y) = rpc x y", "by (metis lsl_lsu_prop_eq o_apply rpc_def)"], ["", "lemma lsu_rpc [simp]: \"\\<nu>\\<^sup>\\<natural> (rpc x y) = rpc x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> (rpc x y) = rpc x y", "using lsided_def3 lsl_rpc"], ["proof (prove)\nusing this:\n  (\\<nu> ?x = ?x) = (\\<nu>\\<^sup>\\<natural> ?x = ?x)\n  \\<nu> (rpc ?x ?y) = rpc ?x ?y\n\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> (rpc x y) = rpc x y", "by blast"], ["", "lemma lsl_rpc_galois: \"(x \\<sqinter> \\<nu> z \\<le> y) = (z \\<le> rpc x (y::'a::bool_unital_quantale))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> \\<nu> z \\<le> y) = (z \\<le> rpc x y)", "unfolding rpc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> \\<nu> z \\<le> y) =\n    (z \\<le> \\<nu>\\<^sup>\\<natural> (- x \\<squnion> y))", "by (metis adj_def inf_commute ls_galois shunt1)"], ["", "lemma lsl_rpc_galois_var: \"x \\<sqinter> \\<nu> z \\<le> y \\<longleftrightarrow> \\<nu> z \\<le> rpc x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> \\<nu> z \\<le> y) = (\\<nu> z \\<le> rpc x y)", "by (metis adj_def ls_galois lsl_rpc_galois lsu_rpc)"], ["", "lemma rpc_expl_aux: \"\\<Squnion>{z. x \\<sqinter> \\<nu> z \\<le> y} = \\<Squnion>{z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = (z::'a::bool_unital_quantale)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y} =\n    \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}\n    \\<le> \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}\n 2. \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}\n    \\<le> \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}", "show \"\\<Squnion>{z. x \\<sqinter> \\<nu> z \\<le> y} \\<le> \\<Squnion>{z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}\n    \\<le> \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}", "apply (rule Sup_mono, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       x \\<sqinter> \\<nu> a \\<le> y \\<Longrightarrow>\n       \\<exists>b\\<in>{z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}.\n          a \\<le> b", "by (smt lsided_eq lsided_prop lsl_def lsl_lsu_prop_eq lsl_rpc_galois mem_Collect_eq o_apply rpc_def slsd_def)"], ["proof (state)\nthis:\n  \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}\n  \\<le> \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}\n\ngoal (1 subgoal):\n 1. \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}\n    \\<le> \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}", "show \" \\<Squnion>{z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z} \\<le> \\<Squnion>{z. x \\<sqinter> \\<nu> z \\<le> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}\n    \\<le> \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}", "by (simp add: Collect_mono_iff Sup_subset_mono)"], ["proof (state)\nthis:\n  \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}\n  \\<le> \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rpc_expl: \"rpc x y = \\<Squnion>{z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = (z::'a::bool_unital_quantale)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpc x y = \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rpc x y = \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}", "have \"rpc x y = \\<Squnion>{z. z \\<le> rpc x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpc x y = \\<Squnion> {z. z \\<le> rpc x y}", "using Sup_atMost atMost_def"], ["proof (prove)\nusing this:\n  \\<Squnion> {..?y} = ?y\n  {..?u} \\<equiv> {x. x \\<le> ?u}\n\ngoal (1 subgoal):\n 1. rpc x y = \\<Squnion> {z. z \\<le> rpc x y}", "by metis"], ["proof (state)\nthis:\n  rpc x y = \\<Squnion> {z. z \\<le> rpc x y}\n\ngoal (1 subgoal):\n 1. rpc x y = \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}", "also"], ["proof (state)\nthis:\n  rpc x y = \\<Squnion> {z. z \\<le> rpc x y}\n\ngoal (1 subgoal):\n 1. rpc x y = \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}", "have \"... = \\<Squnion>{z. x \\<sqinter> \\<nu> z \\<le> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {z. z \\<le> rpc x y} =\n    \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}", "using lsl_rpc_galois"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> \\<nu> ?z \\<le> ?y) = (?z \\<le> rpc ?x ?y)\n\ngoal (1 subgoal):\n 1. \\<Squnion> {z. z \\<le> rpc x y} =\n    \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}", "by metis"], ["proof (state)\nthis:\n  \\<Squnion> {z. z \\<le> rpc x y} =\n  \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}\n\ngoal (1 subgoal):\n 1. rpc x y = \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}", "finally"], ["proof (chain)\npicking this:\n  rpc x y = \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}", "show ?thesis"], ["proof (prove)\nusing this:\n  rpc x y = \\<Squnion> {z. x \\<sqinter> \\<nu> z \\<le> y}\n\ngoal (1 subgoal):\n 1. rpc x y = \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}", "by (simp add: rpc_expl_aux)"], ["proof (state)\nthis:\n  rpc x y = \\<Squnion> {z. x \\<sqinter> z \\<le> y \\<and> \\<nu> z = z}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Non-Preservation and Lack of Closure\\<close>"], ["", "context bool_ab_unital_quantale\nbegin"], ["", "text \\<open>A few counterexamples deal in particular with lack of closure with respect to boolean complementation.\\<close>"], ["", "lemma \"\\<nu>\\<^sup>\\<natural> (x \\<cdot> y) = \\<nu>\\<^sup>\\<natural> x \\<cdot> \\<nu>\\<^sup>\\<natural> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> (x \\<cdot> y) =\n    \\<nu>\\<^sup>\\<natural> x \\<cdot> \\<nu>\\<^sup>\\<natural> y", "(*nitpick    *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> (x \\<cdot> y) =\n    \\<nu>\\<^sup>\\<natural> x \\<cdot> \\<nu>\\<^sup>\\<natural> y", "oops"], ["", "lemma \"\\<nu> 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. un_pres \\<nu>", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. un_pres \\<nu>", "oops"], ["", "lemma \"\\<nu>\\<^sup>\\<natural> x = \\<nu> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> x = \\<nu> x", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> x = \\<nu> x", "oops"], ["", "lemma \"\\<nu>\\<^sup>\\<natural> (\\<Squnion> P) = \\<Squnion>{\\<nu>\\<^sup>\\<natural> p |p. p \\<in> P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> (\\<Squnion> P) =\n    \\<Squnion> {\\<nu>\\<^sup>\\<natural> p |p. p \\<in> P}", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> (\\<Squnion> P) =\n    \\<Squnion> {\\<nu>\\<^sup>\\<natural> p |p. p \\<in> P}", "oops"], ["", "lemma \"rpc (\\<nu>\\<^sup>\\<natural> x) (\\<nu>\\<^sup>\\<natural> y) = -(\\<nu>\\<^sup>\\<natural> x) \\<squnion> (\\<nu>\\<^sup>\\<natural> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpc (\\<nu>\\<^sup>\\<natural> x) (\\<nu>\\<^sup>\\<natural> y) =\n    - \\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rpc (\\<nu>\\<^sup>\\<natural> x) (\\<nu>\\<^sup>\\<natural> y) =\n    - \\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y", "oops"], ["", "lemma \"rpc (\\<nu> x) (\\<nu> y) = -(\\<nu> x) \\<squnion> (\\<nu> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpc (\\<nu> x) (\\<nu> y) = - \\<nu> x \\<squnion> \\<nu> y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rpc (\\<nu> x) (\\<nu> y) = - \\<nu> x \\<squnion> \\<nu> y", "oops"], ["", "lemma \"\\<nu> (-(\\<nu>\\<^sup>\\<natural> x) \\<squnion> (\\<nu>\\<^sup>\\<natural> y)) = -(\\<nu>\\<^sup>\\<natural> x) \\<squnion> (\\<nu>\\<^sup>\\<natural> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (- \\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y) =\n    - \\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (- \\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y) =\n    - \\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y", "oops"], ["", "lemma \"\\<nu> (-(\\<nu> x) \\<squnion> (\\<nu> y)) = -(\\<nu> x) \\<squnion> (\\<nu> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (- \\<nu> x \\<squnion> \\<nu> y) = - \\<nu> x \\<squnion> \\<nu> y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (- \\<nu> x \\<squnion> \\<nu> y) = - \\<nu> x \\<squnion> \\<nu> y", "oops"], ["", "lemma  \"\\<nu> x \\<cdot> \\<nu> y = \\<nu> x \\<sqinter> \\<nu> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> x \\<cdot> \\<nu> y = \\<nu> x \\<sqinter> \\<nu> y", "(*nitpick this rules out localic nuclei.*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> x \\<cdot> \\<nu> y = \\<nu> x \\<sqinter> \\<nu> y", "oops"], ["", "lemma \"\\<nu> (- (\\<nu> x)) = - (\\<nu> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (- \\<nu> x) = - \\<nu> x", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (- \\<nu> x) = - \\<nu> x", "oops"], ["", "lemma \"\\<nu>\\<^sup>\\<natural> (- (\\<nu>\\<^sup>\\<natural> x)) = - (\\<nu>\\<^sup>\\<natural> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> (- \\<nu>\\<^sup>\\<natural> x) =\n    - \\<nu>\\<^sup>\\<natural> x", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural> (- \\<nu>\\<^sup>\\<natural> x) =\n    - \\<nu>\\<^sup>\\<natural> x", "oops"], ["", "lemma \"\\<nu> (- (\\<nu> x) \\<squnion> (\\<nu> y)) = - (\\<nu> x) \\<squnion> (\\<nu> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (- \\<nu> x \\<squnion> \\<nu> y) = - \\<nu> x \\<squnion> \\<nu> y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (- \\<nu> x \\<squnion> \\<nu> y) = - \\<nu> x \\<squnion> \\<nu> y", "oops"], ["", "lemma \"\\<nu>\\<^sup>\\<natural> (- (\\<nu>\\<^sup>\\<natural> x) \\<squnion> (\\<nu>\\<^sup>\\<natural> y)) = - (\\<nu>\\<^sup>\\<natural> x) \\<squnion> (\\<nu>\\<^sup>\\<natural> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural>\n     (- \\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y) =\n    - \\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu>\\<^sup>\\<natural>\n     (- \\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y) =\n    - \\<nu>\\<^sup>\\<natural> x \\<squnion> \\<nu>\\<^sup>\\<natural> y", "oops"], ["", "end"], ["", "subsection \\<open>Properties of Quotient Algebras and Subalgebras\\<close>"], ["", "text \\<open>Finally I replay Rosenthal's quotient and subalgebra proofs for nuclei and conuclei in the concrete setting of left-sided elements. Ideally\nit should be sufficient to show that lsl is a (quantale with) nucleus and then pick up the quotient algebra proof from the nucleus section. But there is no\nway of achieving this, apart from creating a type class for quantales with the lsl operation. This seems bizarre, since lsl is just a definition.\nOn the other hand, an approach in which interpretations are used instead of instantiations might do the job.\\<close>"], ["", "text \\<open>The first proof shows that lsu, as a conucleus, yields a subalgebra.\\<close>"], ["", "typedef (overloaded) 'a lsu_set = \"Fix (\\<nu>\\<^sup>\\<natural>::'a::unital_quantale \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Fix \\<nu>\\<^sup>\\<natural>", "using Fix_lsu_iff lsu_bot"], ["proof (prove)\nusing this:\n  (?x \\<in> Fix \\<nu>\\<^sup>\\<natural>) = (\\<nu>\\<^sup>\\<natural> ?x = ?x)\n  bot_pres \\<nu>\\<^sup>\\<natural>\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Fix \\<nu>\\<^sup>\\<natural>", "by blast"], ["", "setup_lifting type_definition_lsu_set"], ["", "instantiation lsu_set :: (unital_quantale) quantale\nbegin"], ["", "lift_definition times_lsu_set :: \"'a lsu_set \\<Rightarrow> 'a lsu_set \\<Rightarrow> 'a lsu_set\" is times"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> Fix \\<nu>\\<^sup>\\<natural>;\n        a2 \\<in> Fix \\<nu>\\<^sup>\\<natural>\\<rbrakk>\n       \\<Longrightarrow> a1 \\<cdot> a2 \\<in> Fix \\<nu>\\<^sup>\\<natural>", "using comp_closed_set_def lsu_comp_closed"], ["proof (prove)\nusing this:\n  comp_closed_set ?X =\n  (\\<forall>x\\<in>?X. \\<forall>y\\<in>?X. x \\<cdot> y \\<in> ?X)\n  comp_closed_set (Fix \\<nu>\\<^sup>\\<natural>)\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> Fix \\<nu>\\<^sup>\\<natural>;\n        a2 \\<in> Fix \\<nu>\\<^sup>\\<natural>\\<rbrakk>\n       \\<Longrightarrow> a1 \\<cdot> a2 \\<in> Fix \\<nu>\\<^sup>\\<natural>", "by blast"], ["", "lift_definition Inf_lsu_set :: \"'a lsu_set set \\<Rightarrow> 'a lsu_set\" is Inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           x \\<in> Fix \\<nu>\\<^sup>\\<natural>) \\<Longrightarrow>\n       \\<Sqinter> set \\<in> Fix \\<nu>\\<^sup>\\<natural>", "by (metis Fix_lsl_lsu Inf_closed_set_def lsl_Inf_closed subset_eq)"], ["", "lift_definition  Sup_lsu_set :: \"'a lsu_set set \\<Rightarrow> 'a lsu_set\" is Sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           x \\<in> Fix \\<nu>\\<^sup>\\<natural>) \\<Longrightarrow>\n       \\<Squnion> set \\<in> Fix \\<nu>\\<^sup>\\<natural>", "using Sup_closed_set_def lsu_Sup_closed subsetI"], ["proof (prove)\nusing this:\n  Sup_closed_set ?X = (\\<forall>Y\\<subseteq>?X. \\<Squnion> Y \\<in> ?X)\n  Sup_closed_set (Fix \\<nu>\\<^sup>\\<natural>)\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<in> ?B) \\<Longrightarrow>\n  ?A \\<subseteq> ?B\n\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           x \\<in> Fix \\<nu>\\<^sup>\\<natural>) \\<Longrightarrow>\n       \\<Squnion> set \\<in> Fix \\<nu>\\<^sup>\\<natural>", "by blast"], ["", "lift_definition  bot_lsu_set ::  \"'a lsu_set\" is \"\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<in> Fix \\<nu>\\<^sup>\\<natural>", "by simp"], ["", "lift_definition sup_lsu_set :: \"'a lsu_set \\<Rightarrow> 'a lsu_set \\<Rightarrow> 'a lsu_set\" is sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> Fix \\<nu>\\<^sup>\\<natural>;\n        a2 \\<in> Fix \\<nu>\\<^sup>\\<natural>\\<rbrakk>\n       \\<Longrightarrow> a1 \\<squnion> a2 \\<in> Fix \\<nu>\\<^sup>\\<natural>", "by (metis Fix_lsu_iff lsu_sup_closed_var)"], ["", "lift_definition top_lsu_set ::  \"'a lsu_set\" is \"\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<in> Fix \\<nu>\\<^sup>\\<natural>", "by simp"], ["", "lift_definition inf_lsu_set :: \"'a lsu_set \\<Rightarrow> 'a lsu_set \\<Rightarrow> 'a lsu_set\" is inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> Fix \\<nu>\\<^sup>\\<natural>;\n        a2 \\<in> Fix \\<nu>\\<^sup>\\<natural>\\<rbrakk>\n       \\<Longrightarrow> a1 \\<sqinter> a2 \\<in> Fix \\<nu>\\<^sup>\\<natural>", "by (metis Fix_lsu_iff lsu_inf_closed_var)"], ["", "lift_definition less_eq_lsu_set :: \"'a lsu_set \\<Rightarrow> 'a lsu_set \\<Rightarrow> bool\" is less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition  less_lsu_set :: \"'a lsu_set \\<Rightarrow> 'a lsu_set \\<Rightarrow> bool\" is less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lsu_set, quantale_class)", "by (intro_classes; transfer, simp_all add: mult.assoc Inf_lower Inf_greatest Sup_upper Sup_least less_le_not_le Sup_distr Sup_distl)"], ["", "end"], ["", "text \\<open>This proof checks simply closure conditions, as one would expect for establishing a subalgebra.\\<close>"], ["", "instance lsu_set :: (bool_ab_unital_quantale) distrib_ab_quantale"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lsu_set, distrib_ab_quantale_class)", "apply (intro_classes; transfer)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Fix \\<nu>\\<^sup>\\<natural>;\n        b \\<in> Fix \\<nu>\\<^sup>\\<natural>\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot> b = b \\<cdot> a\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> Fix \\<nu>\\<^sup>\\<natural>;\n        y \\<in> Fix \\<nu>\\<^sup>\\<natural>;\n        z \\<in> Fix \\<nu>\\<^sup>\\<natural>\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z =\n                         (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (simp add: mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<in> Fix \\<nu>\\<^sup>\\<natural>;\n        y \\<in> Fix \\<nu>\\<^sup>\\<natural>;\n        z \\<in> Fix \\<nu>\\<^sup>\\<natural>\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z =\n                         (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "using sup_inf_distrib1"], ["proof (prove)\nusing this:\n  ?x \\<squnion> ?y \\<sqinter> ?z =\n  (?x \\<squnion> ?y) \\<sqinter> (?x \\<squnion> ?z)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<in> Fix \\<nu>\\<^sup>\\<natural>;\n        y \\<in> Fix \\<nu>\\<^sup>\\<natural>;\n        z \\<in> Fix \\<nu>\\<^sup>\\<natural>\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z =\n                         (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "by blast"], ["", "typedef (overloaded) 'a lsl_set = \"range (\\<nu>::'a:: unital_quantale \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> range \\<nu>", "by blast"], ["", "setup_lifting type_definition_lsl_set"], ["", "text \\<open>The final statement shows that lsu, as a nucleus, yields a quotient algebra.\\<close>"], ["", "instantiation lsl_set :: (ab_unital_quantale) ab_unital_quantale\nbegin"], ["", "lift_definition one_lsl_set :: \"'a::ab_unital_quantale lsl_set\" is \"\\<nu> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> (1::'a) \\<in> range \\<nu>", "by blast"], ["", "lift_definition Inf_lsl_set :: \"'a lsl_set set \\<Rightarrow> 'a lsl_set\" is \"\\<lambda>X. \\<nu> (\\<Sqinter>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           x \\<in> range \\<nu>) \\<Longrightarrow>\n       \\<nu> (\\<Sqinter> set) \\<in> range \\<nu>", "by blast"], ["", "lift_definition Sup_lsl_set :: \"'a lsl_set set \\<Rightarrow> 'a lsl_set\" is \"\\<lambda>X. \\<nu> (\\<Squnion>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           x \\<in> range \\<nu>) \\<Longrightarrow>\n       \\<nu> (\\<Squnion> set) \\<in> range \\<nu>", "by blast"], ["", "lift_definition bot_lsl_set :: \"'a lsl_set\" is \"\\<nu> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<bottom> \\<in> range \\<nu>", "by blast"], ["", "lift_definition sup_lsl_set :: \"'a lsl_set \\<Rightarrow> 'a lsl_set \\<Rightarrow> 'a lsl_set\" is \"\\<lambda>x y. \\<nu> x \\<squnion> \\<nu> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> range \\<nu>; a2 \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> a1 \\<squnion> \\<nu> a2 \\<in> range \\<nu>", "by auto (metis lsl_sup_closed_var)"], ["", "lift_definition   top_lsl_set :: \"'a lsl_set\" is \"\\<nu> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<top> \\<in> range \\<nu>", "by blast"], ["", "lift_definition  inf_lsl_set :: \"'a lsl_set \\<Rightarrow> 'a lsl_set \\<Rightarrow> 'a lsl_set\" is \"\\<lambda>x y. \\<nu> x \\<sqinter> \\<nu> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> range \\<nu>; a2 \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> a1 \\<sqinter> \\<nu> a2 \\<in> range \\<nu>", "by (meson lsl_inf_closed_var range_lsl_iff)"], ["", "lift_definition less_eq_lsl_set :: \"'a lsl_set \\<Rightarrow> 'a lsl_set \\<Rightarrow> bool\" is \"\\<lambda>x y . \\<nu> x \\<le> \\<nu> y\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_lsl_set :: \"'a lsl_set \\<Rightarrow> 'a lsl_set \\<Rightarrow> bool\" is \"\\<lambda>x y. \\<nu> x \\<le> \\<nu> y \\<and> x \\<noteq> y\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition   times_lsl_set :: \"'a lsl_set \\<Rightarrow> 'a lsl_set \\<Rightarrow> 'a lsl_set\" is \"\\<lambda> x y. \\<nu> (x \\<cdot> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> range \\<nu>; a2 \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (a1 \\<cdot> a2) \\<in> range \\<nu>", "by blast"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lsl_set, ab_unital_quantale_class)", "apply (standard; transfer)"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> range \\<nu>; b \\<in> range \\<nu>;\n        c \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (a \\<cdot> b) \\<cdot> c) =\n                         \\<nu> (a \\<cdot> \\<nu> (b \\<cdot> c))\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> range \\<nu>; b \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (a \\<cdot> b) = \\<nu> (b \\<cdot> a)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> (\\<nu> x \\<le> \\<nu> y \\<and> x \\<noteq> y) =\n                         (\\<nu> x \\<le> \\<nu> y \\<and>\n                          \\<not> \\<nu> y \\<le> \\<nu> x)\n 4. \\<And>x. x \\<in> range \\<nu> \\<Longrightarrow> \\<nu> x \\<le> \\<nu> x\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> x \\<le> \\<nu> y;\n        \\<nu> y \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> z\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        \\<nu> x \\<le> \\<nu> y; \\<nu> y \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 7. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> x\n 8. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> y\n 9. \\<And>x y z.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> x \\<le> \\<nu> y;\n        \\<nu> x \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> y \\<sqinter> \\<nu> z)\n 10. \\<And>x y.\n        \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> x \\<squnion> \\<nu> y)\nA total of 22 subgoals...", "apply (simp add: lsl_local_eq mult.commute mult.left_commute)"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> range \\<nu>; b \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (a \\<cdot> b) = \\<nu> (b \\<cdot> a)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> (\\<nu> x \\<le> \\<nu> y \\<and> x \\<noteq> y) =\n                         (\\<nu> x \\<le> \\<nu> y \\<and>\n                          \\<not> \\<nu> y \\<le> \\<nu> x)\n 3. \\<And>x. x \\<in> range \\<nu> \\<Longrightarrow> \\<nu> x \\<le> \\<nu> x\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> x \\<le> \\<nu> y;\n        \\<nu> y \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> z\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        \\<nu> x \\<le> \\<nu> y; \\<nu> y \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> x\n 7. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> y\n 8. \\<And>x y z.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> x \\<le> \\<nu> y;\n        \\<nu> x \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> y \\<sqinter> \\<nu> z)\n 9. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> x \\<squnion> \\<nu> y)\n 10. \\<And>y x.\n        \\<lbrakk>y \\<in> range \\<nu>; x \\<in> range \\<nu>\\<rbrakk>\n        \\<Longrightarrow> \\<nu> y \\<le> \\<nu> (\\<nu> x \\<squnion> \\<nu> y)\nA total of 21 subgoals...", "apply (simp add: mult.commute)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> (\\<nu> x \\<le> \\<nu> y \\<and> x \\<noteq> y) =\n                         (\\<nu> x \\<le> \\<nu> y \\<and>\n                          \\<not> \\<nu> y \\<le> \\<nu> x)\n 2. \\<And>x. x \\<in> range \\<nu> \\<Longrightarrow> \\<nu> x \\<le> \\<nu> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> x \\<le> \\<nu> y;\n        \\<nu> y \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        \\<nu> x \\<le> \\<nu> y; \\<nu> y \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> x \\<le> \\<nu> y;\n        \\<nu> x \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> y \\<sqinter> \\<nu> z)\n 8. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> x \\<squnion> \\<nu> y)\n 9. \\<And>y x.\n       \\<lbrakk>y \\<in> range \\<nu>; x \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> y \\<le> \\<nu> (\\<nu> x \\<squnion> \\<nu> y)\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<in> range \\<nu>; x \\<in> range \\<nu>;\n         z \\<in> range \\<nu>; \\<nu> y \\<le> \\<nu> x;\n         \\<nu> z \\<le> \\<nu> x\\<rbrakk>\n        \\<Longrightarrow> \\<nu> (\\<nu> y \\<squnion> \\<nu> z) \\<le> \\<nu> x\nA total of 20 subgoals...", "apply auto[1]"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>x. x \\<in> range \\<nu> \\<Longrightarrow> \\<nu> x \\<le> \\<nu> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> x \\<le> \\<nu> y;\n        \\<nu> y \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        \\<nu> x \\<le> \\<nu> y; \\<nu> y \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> x\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> x \\<le> \\<nu> y;\n        \\<nu> x \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> y \\<sqinter> \\<nu> z)\n 7. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> x \\<squnion> \\<nu> y)\n 8. \\<And>y x.\n       \\<lbrakk>y \\<in> range \\<nu>; x \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> y \\<le> \\<nu> (\\<nu> x \\<squnion> \\<nu> y)\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<in> range \\<nu>; x \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> y \\<le> \\<nu> x;\n        \\<nu> z \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> y \\<squnion> \\<nu> z) \\<le> \\<nu> x\n 10. \\<And>x A.\n        \\<lbrakk>x \\<in> range \\<nu>; \\<forall>x\\<in>A. x \\<in> range \\<nu>;\n         x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> \\<nu> (\\<nu> (\\<Sqinter> A)) \\<le> \\<nu> x\nA total of 19 subgoals...", "apply fastforce+"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        \\<nu> x \\<le> \\<nu> y; \\<nu> y \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> x\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> x \\<le> \\<nu> y;\n        \\<nu> x \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> y \\<sqinter> \\<nu> z)\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> x \\<squnion> \\<nu> y)\n 6. \\<And>y x.\n       \\<lbrakk>y \\<in> range \\<nu>; x \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> y \\<le> \\<nu> (\\<nu> x \\<squnion> \\<nu> y)\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<in> range \\<nu>; x \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> y \\<le> \\<nu> x;\n        \\<nu> z \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> y \\<squnion> \\<nu> z) \\<le> \\<nu> x\n 8. \\<And>x A.\n       \\<lbrakk>x \\<in> range \\<nu>; \\<forall>x\\<in>A. x \\<in> range \\<nu>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Sqinter> A)) \\<le> \\<nu> x\n 9. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range \\<nu>; z \\<in> range \\<nu>;\n        \\<And>x.\n           \\<lbrakk>x \\<in> range \\<nu>; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> \\<nu> z \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> \\<nu> z \\<le> \\<nu> (\\<nu> (\\<Sqinter> A))\n 10. \\<And>x A.\n        \\<lbrakk>x \\<in> range \\<nu>; \\<forall>x\\<in>A. x \\<in> range \\<nu>;\n         x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> (\\<Squnion> A))\nA total of 17 subgoals...", "apply auto[1]"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> x\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> x \\<sqinter> \\<nu> y) \\<le> \\<nu> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> x \\<le> \\<nu> y;\n        \\<nu> x \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> y \\<sqinter> \\<nu> z)\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<nu>; y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> x \\<squnion> \\<nu> y)\n 5. \\<And>y x.\n       \\<lbrakk>y \\<in> range \\<nu>; x \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> y \\<le> \\<nu> (\\<nu> x \\<squnion> \\<nu> y)\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<in> range \\<nu>; x \\<in> range \\<nu>;\n        z \\<in> range \\<nu>; \\<nu> y \\<le> \\<nu> x;\n        \\<nu> z \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> y \\<squnion> \\<nu> z) \\<le> \\<nu> x\n 7. \\<And>x A.\n       \\<lbrakk>x \\<in> range \\<nu>; \\<forall>x\\<in>A. x \\<in> range \\<nu>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Sqinter> A)) \\<le> \\<nu> x\n 8. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range \\<nu>; z \\<in> range \\<nu>;\n        \\<And>x.\n           \\<lbrakk>x \\<in> range \\<nu>; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> \\<nu> z \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> \\<nu> z \\<le> \\<nu> (\\<nu> (\\<Sqinter> A))\n 9. \\<And>x A.\n       \\<lbrakk>x \\<in> range \\<nu>; \\<forall>x\\<in>A. x \\<in> range \\<nu>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> (\\<Squnion> A))\n 10. \\<And>A z.\n        \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range \\<nu>; z \\<in> range \\<nu>;\n         \\<And>x.\n            \\<lbrakk>x \\<in> range \\<nu>; x \\<in> A\\<rbrakk>\n            \\<Longrightarrow> \\<nu> x \\<le> \\<nu> z\\<rbrakk>\n        \\<Longrightarrow> \\<nu> (\\<nu> (\\<Squnion> A)) \\<le> \\<nu> z\nA total of 16 subgoals...", "apply fastforce+"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>x \\<in> range \\<nu>; \\<forall>x\\<in>A. x \\<in> range \\<nu>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Sqinter> A)) \\<le> \\<nu> x\n 2. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range \\<nu>; z \\<in> range \\<nu>;\n        \\<And>x.\n           \\<lbrakk>x \\<in> range \\<nu>; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> \\<nu> z \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> \\<nu> z \\<le> \\<nu> (\\<nu> (\\<Sqinter> A))\n 3. \\<And>x A.\n       \\<lbrakk>x \\<in> range \\<nu>; \\<forall>x\\<in>A. x \\<in> range \\<nu>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> (\\<Squnion> A))\n 4. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range \\<nu>; z \\<in> range \\<nu>;\n        \\<And>x.\n           \\<lbrakk>x \\<in> range \\<nu>; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> \\<nu> x \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Squnion> A)) \\<le> \\<nu> z\n 5. \\<nu> (\\<Sqinter> {}) = \\<nu> \\<top>\n 6. \\<nu> (\\<Squnion> {}) = \\<nu> \\<bottom>\n 7. \\<And>X y.\n       \\<lbrakk>\\<forall>x\\<in>X. x \\<in> range \\<nu>;\n        y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Squnion> X) \\<cdot> y) =\n                         \\<nu> (\\<Squnion>x\\<in>X. \\<nu> (x \\<cdot> y))\n 8. \\<And>x Y.\n       \\<lbrakk>x \\<in> range \\<nu>;\n        \\<forall>x\\<in>Y. x \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (x \\<cdot> \\<nu> (\\<Squnion> Y)) =\n                         \\<nu> (\\<Squnion>y\\<in>Y. \\<nu> (x \\<cdot> y))\n 9. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (\\<nu> (1::'a) \\<cdot> a) = a\n 10. \\<And>a.\n        a \\<in> range \\<nu> \\<Longrightarrow>\n        \\<nu> (a \\<cdot> \\<nu> (1::'a)) = a", "apply (metis Inf_lower lsl_iso_var range_lsl_iff)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range \\<nu>; z \\<in> range \\<nu>;\n        \\<And>x.\n           \\<lbrakk>x \\<in> range \\<nu>; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> \\<nu> z \\<le> \\<nu> x\\<rbrakk>\n       \\<Longrightarrow> \\<nu> z \\<le> \\<nu> (\\<nu> (\\<Sqinter> A))\n 2. \\<And>x A.\n       \\<lbrakk>x \\<in> range \\<nu>; \\<forall>x\\<in>A. x \\<in> range \\<nu>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> (\\<Squnion> A))\n 3. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range \\<nu>; z \\<in> range \\<nu>;\n        \\<And>x.\n           \\<lbrakk>x \\<in> range \\<nu>; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> \\<nu> x \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Squnion> A)) \\<le> \\<nu> z\n 4. \\<nu> (\\<Sqinter> {}) = \\<nu> \\<top>\n 5. \\<nu> (\\<Squnion> {}) = \\<nu> \\<bottom>\n 6. \\<And>X y.\n       \\<lbrakk>\\<forall>x\\<in>X. x \\<in> range \\<nu>;\n        y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Squnion> X) \\<cdot> y) =\n                         \\<nu> (\\<Squnion>x\\<in>X. \\<nu> (x \\<cdot> y))\n 7. \\<And>x Y.\n       \\<lbrakk>x \\<in> range \\<nu>;\n        \\<forall>x\\<in>Y. x \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (x \\<cdot> \\<nu> (\\<Squnion> Y)) =\n                         \\<nu> (\\<Squnion>y\\<in>Y. \\<nu> (x \\<cdot> y))\n 8. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (\\<nu> (1::'a) \\<cdot> a) = a\n 9. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (a \\<cdot> \\<nu> (1::'a)) = a", "apply (metis Inf_greatest lsl_iso_var range_lsl_iff)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>x \\<in> range \\<nu>; \\<forall>x\\<in>A. x \\<in> range \\<nu>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<nu> x \\<le> \\<nu> (\\<nu> (\\<Squnion> A))\n 2. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range \\<nu>; z \\<in> range \\<nu>;\n        \\<And>x.\n           \\<lbrakk>x \\<in> range \\<nu>; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> \\<nu> x \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Squnion> A)) \\<le> \\<nu> z\n 3. \\<nu> (\\<Sqinter> {}) = \\<nu> \\<top>\n 4. \\<nu> (\\<Squnion> {}) = \\<nu> \\<bottom>\n 5. \\<And>X y.\n       \\<lbrakk>\\<forall>x\\<in>X. x \\<in> range \\<nu>;\n        y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Squnion> X) \\<cdot> y) =\n                         \\<nu> (\\<Squnion>x\\<in>X. \\<nu> (x \\<cdot> y))\n 6. \\<And>x Y.\n       \\<lbrakk>x \\<in> range \\<nu>;\n        \\<forall>x\\<in>Y. x \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (x \\<cdot> \\<nu> (\\<Squnion> Y)) =\n                         \\<nu> (\\<Squnion>y\\<in>Y. \\<nu> (x \\<cdot> y))\n 7. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (\\<nu> (1::'a) \\<cdot> a) = a\n 8. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (a \\<cdot> \\<nu> (1::'a)) = a", "apply (metis Sup_upper lsl_iso_var range_lsl_iff)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range \\<nu>; z \\<in> range \\<nu>;\n        \\<And>x.\n           \\<lbrakk>x \\<in> range \\<nu>; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> \\<nu> x \\<le> \\<nu> z\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Squnion> A)) \\<le> \\<nu> z\n 2. \\<nu> (\\<Sqinter> {}) = \\<nu> \\<top>\n 3. \\<nu> (\\<Squnion> {}) = \\<nu> \\<bottom>\n 4. \\<And>X y.\n       \\<lbrakk>\\<forall>x\\<in>X. x \\<in> range \\<nu>;\n        y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Squnion> X) \\<cdot> y) =\n                         \\<nu> (\\<Squnion>x\\<in>X. \\<nu> (x \\<cdot> y))\n 5. \\<And>x Y.\n       \\<lbrakk>x \\<in> range \\<nu>;\n        \\<forall>x\\<in>Y. x \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (x \\<cdot> \\<nu> (\\<Squnion> Y)) =\n                         \\<nu> (\\<Squnion>y\\<in>Y. \\<nu> (x \\<cdot> y))\n 6. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (\\<nu> (1::'a) \\<cdot> a) = a\n 7. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (a \\<cdot> \\<nu> (1::'a)) = a", "apply (metis Sup_least lsl_iso_var range_lsl_iff)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<nu> (\\<Sqinter> {}) = \\<nu> \\<top>\n 2. \\<nu> (\\<Squnion> {}) = \\<nu> \\<bottom>\n 3. \\<And>X y.\n       \\<lbrakk>\\<forall>x\\<in>X. x \\<in> range \\<nu>;\n        y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Squnion> X) \\<cdot> y) =\n                         \\<nu> (\\<Squnion>x\\<in>X. \\<nu> (x \\<cdot> y))\n 4. \\<And>x Y.\n       \\<lbrakk>x \\<in> range \\<nu>;\n        \\<forall>x\\<in>Y. x \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (x \\<cdot> \\<nu> (\\<Squnion> Y)) =\n                         \\<nu> (\\<Squnion>y\\<in>Y. \\<nu> (x \\<cdot> y))\n 5. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (\\<nu> (1::'a) \\<cdot> a) = a\n 6. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (a \\<cdot> \\<nu> (1::'a)) = a", "apply fastforce+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>X y.\n       \\<lbrakk>\\<forall>x\\<in>X. x \\<in> range \\<nu>;\n        y \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (\\<nu> (\\<Squnion> X) \\<cdot> y) =\n                         \\<nu> (\\<Squnion>x\\<in>X. \\<nu> (x \\<cdot> y))\n 2. \\<And>x Y.\n       \\<lbrakk>x \\<in> range \\<nu>;\n        \\<forall>x\\<in>Y. x \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (x \\<cdot> \\<nu> (\\<Squnion> Y)) =\n                         \\<nu> (\\<Squnion>y\\<in>Y. \\<nu> (x \\<cdot> y))\n 3. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (\\<nu> (1::'a) \\<cdot> a) = a\n 4. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (a \\<cdot> \\<nu> (1::'a)) = a", "apply (smt Sup_distl image_cong lsl_local_eq mult.commute)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x Y.\n       \\<lbrakk>x \\<in> range \\<nu>;\n        \\<forall>x\\<in>Y. x \\<in> range \\<nu>\\<rbrakk>\n       \\<Longrightarrow> \\<nu> (x \\<cdot> \\<nu> (\\<Squnion> Y)) =\n                         \\<nu> (\\<Squnion>y\\<in>Y. \\<nu> (x \\<cdot> y))\n 2. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (\\<nu> (1::'a) \\<cdot> a) = a\n 3. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (a \\<cdot> \\<nu> (1::'a)) = a", "apply (smt Sup_distl image_cong lsl_local_eq mult.commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (\\<nu> (1::'a) \\<cdot> a) = a\n 2. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (a \\<cdot> \\<nu> (1::'a)) = a", "apply (simp add: lsl_def cong del: image_cong_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> range \\<nu> \\<Longrightarrow>\n       \\<nu> (a \\<cdot> \\<nu> (1::'a)) = a", "apply (simp add: lsl_local_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>This proof checks preservation properties instead of closure ones.\\<close>"], ["", "end"]]}