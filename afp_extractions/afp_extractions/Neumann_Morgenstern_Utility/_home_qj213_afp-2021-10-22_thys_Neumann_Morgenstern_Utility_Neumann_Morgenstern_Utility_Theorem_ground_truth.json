{"file_name": "/home/qj213/afp-2021-10-22/thys/Neumann_Morgenstern_Utility/Neumann_Morgenstern_Utility_Theorem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Neumann_Morgenstern_Utility", "problem_names": ["lemma independent_vnmI1:\n  assumes \"(\\<forall>p \\<in> C. \\<forall>q \\<in> C. \\<forall>r \\<in> C. \\<forall>\\<alpha> \\<in> {0<..1}. p \\<succeq>[P] q \\<longleftrightarrow> mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r)\"\n  shows \"independent_vnm C P\"", "lemma independent_vnmI2:\n  assumes \"\\<And>p q r \\<alpha>. p \\<in> C \\<Longrightarrow> q \\<in> C \\<Longrightarrow> r \\<in> C \\<Longrightarrow> \\<alpha> \\<in> {0<..1} \\<Longrightarrow> p \\<succeq>[P] q \\<longleftrightarrow> mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\"\n  shows \"independent_vnm C P\"", "lemma independent_vnm_alt_def:\n  shows \"independent_vnm C P \\<longleftrightarrow> (\\<forall>p \\<in> C. \\<forall>q \\<in> C. \\<forall>r \\<in> C. \\<forall>\\<alpha> \\<in> {0<..<1}. \n  p \\<succeq>[P] q \\<longleftrightarrow> mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r)\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma independece_dest_alt: \n  assumes \"independent_vnm C P\"\n  shows \"(\\<forall>p \\<in> C. \\<forall>q \\<in> C. \\<forall>r \\<in> C. \\<forall>(\\<alpha>::real) \\<in> {0<..1}. p \\<succeq>[P] q \\<longleftrightarrow> mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r)\"", "lemma independent_vnmD1:\n  assumes \"independent_vnm C P\"\n  shows \"(\\<forall>p \\<in> C. \\<forall>q \\<in> C. \\<forall>r \\<in> C. \\<forall>\\<alpha> \\<in> {0<..1}. p \\<succeq>[P] q \\<longleftrightarrow> mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r)\"", "lemma independent_vnmD2:\n  fixes p q r \\<alpha>\n  assumes \"\\<alpha> \\<in> {0<..1}\"\n    and \"p \\<in> C\"\n    and \"q \\<in> C\"\n    and \"r \\<in> C\"\n  assumes \"independent_vnm C P\"\n  assumes \"p \\<succeq>[P] q\"\n  shows \"mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\"", "lemma independent_vnmD3:\n  fixes p q r \\<alpha>\n  assumes \"\\<alpha> \\<in> {0<..1}\"\n    and \"p \\<in> C\"\n    and \"q \\<in> C\"\n    and \"r \\<in> C\"\n  assumes \"independent_vnm C P\" \n  assumes \"mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\"\n  shows \"p \\<succeq>[P] q\"", "lemma independent_vnmD4:\n  assumes \"independent_vnm C P\"\n  assumes \"refl_on C P\"\n  assumes \"p \\<in> C\" \n    and \"q \\<in> C\" \n    and \"r \\<in> C\"\n    and \"\\<alpha> \\<in> {0..1}\" \n    and \"p \\<succeq>[P] q\" \n  shows \"mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\"", "lemma approx_indep_ge:\n  assumes \"x \\<approx>[\\<R>] y\"\n  assumes \"\\<alpha> \\<in> {0..(1::real)}\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n    and ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  shows \"\\<forall>r \\<in> lotteries_on outcomes. (mix_pmf \\<alpha> y r) \\<succeq>[\\<R>] (mix_pmf \\<alpha> x r)\"", "lemma approx_imp_approx_ind:\n  assumes \"x \\<approx>[\\<R>] y\"\n  assumes \"\\<alpha> \\<in> {0..(1::real)}\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n    and ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  shows \"\\<forall>r \\<in> lotteries_on outcomes. (mix_pmf \\<alpha> y r) \\<approx>[\\<R>] (mix_pmf \\<alpha> x r)\"", "lemma geq_imp_mix_geq_right:\n  assumes \"x \\<succeq>[\\<R>] y\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n  assumes ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  assumes \"\\<alpha> \\<in> {0..(1::real)}\"\n  shows \"(mix_pmf \\<alpha> x y) \\<succeq>[\\<R>] y\"", "lemma geq_imp_mix_geq_left:\n  assumes \"x \\<succeq>[\\<R>] y\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n  assumes ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  assumes \"\\<alpha> \\<in> {0..(1::real)}\"\n  shows \"(mix_pmf \\<alpha> y x) \\<succeq>[\\<R>] y\"", "lemma sg_imp_mix_sg:\n  assumes \"x \\<succ>[\\<R>] y\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n  assumes ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  assumes \"\\<alpha> \\<in> {0<..(1::real)}\"\n  shows \"(mix_pmf \\<alpha> x y) \\<succ>[\\<R>] y\"", "lemma continuous_vnmD:\n  assumes \"continuous_vnm C P\"\n  shows \"(\\<forall>p \\<in> C. \\<forall>q \\<in> C. \\<forall>r \\<in> C. p \\<succeq>[P] q \\<and> q \\<succeq>[P] r \\<longrightarrow>\n    (\\<exists>\\<alpha> \\<in> {0..1}. (mix_pmf \\<alpha> p r) \\<approx>[P] q))\"", "lemma continuous_vnmI:\n  assumes \"\\<And>p q r. p \\<in> C \\<Longrightarrow> q \\<in> C \\<Longrightarrow> r \\<in> C \\<Longrightarrow> p \\<succeq>[P] q \\<and> q \\<succeq>[P] r \\<Longrightarrow> \n    \\<exists>\\<alpha> \\<in> {0..1}. (mix_pmf \\<alpha> p r) \\<approx>[P] q\"\n  shows \"continuous_vnm C P\"", "lemma mix_in_lot:\n  assumes \"x \\<in> lotteries_on outcomes\"\n    and \"y \\<in> lotteries_on outcomes\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  shows \"(mix_pmf \\<alpha> x y) \\<in> lotteries_on outcomes\"", "lemma non_unique_continuous_unfolding:\n  assumes cnt: \"continuous_vnm (lotteries_on outcomes) \\<R>\"\n  assumes \"rational_preference (lotteries_on outcomes) \\<R>\"\n  assumes \"p \\<succeq>[\\<R>] q\"\n    and \"q \\<succeq>[\\<R>] r\"\n    and \"p \\<succ>[\\<R>] r\"\n  shows \"\\<exists>\\<alpha> \\<in> {0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\"", "lemma relation_in_carrier:\n  \"x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> \\<P> \\<and> y \\<in> \\<P>\"", "lemma mix_pmf_preferred_independence:\n  assumes \"r \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  assumes \"p \\<succeq>[\\<R>] q\"\n  shows \"mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\"", "lemma mix_pmf_strict_preferred_independence:\n  assumes \"r \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0<..1}\"\n  assumes \"p \\<succ>[\\<R>] q\"\n  shows \"mix_pmf \\<alpha> p r \\<succ>[\\<R>] mix_pmf \\<alpha> q r\"", "lemma mix_pmf_preferred_independence_rev:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n    and \"r \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0<..1}\"\n  assumes \"mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\"\n  shows \"p \\<succeq>[\\<R>] q\"", "lemma x_sg_y_sg_mpmf_right:\n  assumes \"x \\<succ>[\\<R>] y\"\n  assumes \"b \\<in> {0<..(1::real)}\"\n  shows \"x \\<succ>[\\<R>] mix_pmf b y x\"", "lemma neumann_3B_b:\n  assumes \"u \\<succ>[\\<R>] v\"\n  assumes \"\\<alpha> \\<in> {0<..<1}\"\n  shows \"u \\<succ>[\\<R>] mix_pmf \\<alpha> u v\"", "lemma neumann_3B_b_non_strict:\n  assumes \"u \\<succeq>[\\<R>] v\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n  shows \"u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v\"", "lemma greater_mix_pmf_greater_step_1_aux: \n  assumes \"v \\<succ>[\\<R>] u\"\n  assumes \"\\<alpha> \\<in> {0<..<(1::real)}\"\n    and \"\\<beta> \\<in> {0<..<(1::real)}\"\n  assumes \"\\<beta> > \\<alpha>\"\n  shows \"(mix_pmf \\<beta> v u) \\<succ>[\\<R>] (mix_pmf \\<alpha> v u)\"", "lemma step_1_most_general:\n  assumes \"x \\<succ>[\\<R>] y\"\n  assumes \"\\<alpha> \\<in> {0..(1::real)}\"\n    and \"\\<beta> \\<in> {0..(1::real)}\"\n  assumes \"\\<alpha> > \\<beta>\"\n  shows \"(mix_pmf \\<alpha> x y) \\<succ>[\\<R>] (mix_pmf \\<beta> x y)\"", "lemma approx_remains_after_same_comp:\n  assumes \"p \\<approx>[\\<R>] q\"\n    and \"r \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  shows \"mix_pmf \\<alpha> p r \\<approx>[\\<R>] mix_pmf \\<alpha> q r\"", "lemma approx_remains_after_same_comp_left:\n  assumes \"p \\<approx>[\\<R>] q\"\n    and \"r \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  shows \"mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q\"", "lemma mix_of_preferred_is_preferred:\n  assumes \"p \\<succeq>[\\<R>] w\"\n  assumes \"q \\<succeq>[\\<R>] w\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n  shows \"mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w\"", "lemma mix_of_not_preferred_is_not_preferred:\n  assumes \"w \\<succeq>[\\<R>] p\"\n  assumes \"w \\<succeq>[\\<R>] q\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n  shows \"w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\"", "lemma degenerate_total: \n  \"\\<forall>e \\<in> degenerate_lotteries. \\<forall>m \\<in> \\<P>. e \\<succeq>[\\<R>] m \\<or> m \\<succeq>[\\<R>] e\"", "lemma degen_outcome_cardinalities:\n  \"card degenerate_lotteries = card outcomes\"", "lemma degenerate_lots_subset_all: \"degenerate_lotteries \\<subseteq> \\<P>\"", "lemma alt_definition_of_degenerate_lotteries[iff]:\n  \"{return_pmf x |x. x\\<in> outcomes} = degenerate_lotteries\"", "lemma best_indifferent:\n  \"\\<forall>x \\<in> best. \\<forall>y \\<in> best. x \\<approx>[\\<R>] y\"", "lemma worst_indifferent:\n  \"\\<forall>x \\<in> worst. \\<forall>y \\<in> worst. x \\<approx>[\\<R>] y\"", "lemma best_worst_indiff_all_indiff:\n  assumes \"b \\<in> best\"\n    and \"w \\<in> worst\"\n    and \"b \\<approx>[\\<R>] w\"\n  shows \"\\<forall>e \\<in> \\<P>. e \\<approx>[\\<R>] w\" \"\\<forall>e \\<in> \\<P>. e \\<approx>[\\<R>] b\"", "lemma mix_pmf_pref_iff_more_likely [iff]: \n  assumes \"b \\<succ>[\\<R>] w\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"\\<beta> \\<in> {0..1}\"\n  shows \"\\<alpha> > \\<beta> \\<longleftrightarrow> mix_pmf \\<alpha> b w \\<succ>[\\<R>] mix_pmf \\<beta> b w\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma better_worse_good_mix_preferred[iff]: \n  assumes \"b \\<succeq>[\\<R>] w\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"\\<beta> \\<in> {0..1}\"\n  assumes \"\\<alpha> \\<ge> \\<beta>\" \n  shows \"mix_pmf \\<alpha> b w \\<succeq>[\\<R>] mix_pmf \\<beta> b w\"", "lemma finite_degenerate_lotteries: \n  \"finite degenerate_lotteries\"", "lemma degenerate_has_max_preferred:\n  \"{x \\<in> degenerate_lotteries. (\\<forall>y \\<in> degenerate_lotteries. x \\<succeq>[\\<R>] y)} \\<noteq> {}\" (is \"?l \\<noteq> {}\")", "lemma degenerate_has_min_preferred:\n  \"{x \\<in> degenerate_lotteries. (\\<forall>y \\<in> degenerate_lotteries. y \\<succeq>[\\<R>] x)} \\<noteq> {}\" (is \"?l \\<noteq> {}\")", "lemma exists_best_degenerate:\n  \"\\<exists>x \\<in> degenerate_lotteries. \\<forall>y \\<in> degenerate_lotteries. x \\<succeq>[\\<R>] y\"", "lemma exists_worst_degenerate:\n  \"\\<exists>x \\<in> degenerate_lotteries. \\<forall>y \\<in> degenerate_lotteries. y \\<succeq>[\\<R>] x\"", "lemma best_degenerate_in_best_overall: \n  \"\\<exists>x \\<in> degenerate_lotteries. \\<forall>y \\<in> \\<P>. x \\<succeq>[\\<R>] y\"", "lemma worst_degenerate_in_worst_overall: \n  \"\\<exists>x \\<in> degenerate_lotteries. \\<forall>y \\<in> \\<P>. y \\<succeq>[\\<R>] x\"", "lemma overall_best_nonempty:\n  \"best \\<noteq> {}\"", "lemma overall_worst_nonempty:\n  \"worst \\<noteq> {}\"", "lemma trans_approx:\n  assumes \"x\\<approx>[\\<R>] y\" \n    and \" y \\<approx>[\\<R>] z\" \n  shows \"x \\<approx>[\\<R>] z\"", "lemma exists_best_and_degenerate: \"degenerate_lotteries \\<inter> best \\<noteq> {}\"", "lemma exists_worst_and_degenerate: \"degenerate_lotteries \\<inter> worst \\<noteq> {}\"", "lemma some_best_in_best: \"some_best \\<in> best\"", "lemma some_worst_in_worst: \"some_worst \\<in> worst\"", "lemma best_always_at_least_as_good_mix:\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"p \\<in> \\<P>\"\n  shows \"mix_pmf \\<alpha> some_best p \\<succeq>[\\<R>] p\"", "lemma geq_mix_imp_weak_pref:\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"\\<beta> \\<in> {0..1}\"\n  assumes \"\\<alpha> \\<ge> \\<beta>\"\n  shows \"mix_pmf \\<alpha> some_best some_worst \\<succeq>[\\<R>] mix_pmf \\<beta> some_best some_worst\"", "lemma gamma_inverse:\n  assumes \"\\<alpha> \\<in> {0<..<1}\"\n    and \"\\<beta> \\<in> {0<..<1}\"\n  shows \"(1::real) - (\\<alpha> - \\<beta>) / (1 - \\<beta>) = (1 - \\<alpha>) / (1 - \\<beta>)\"", "lemma all_mix_pmf_indiff_indiff_best_worst:\n  assumes \"l \\<in> \\<P>\"\n  assumes \"b \\<in> best\"\n  assumes \"w \\<in> worst\"\n  assumes \"b \\<approx>[\\<R>] w\"\n  shows \"\\<forall>\\<alpha> \\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\"", "lemma indiff_imp_same_utility_value:\n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n  assumes \"\\<beta> \\<in> {0..1}\"\n  assumes \"mix_pmf \\<beta> some_best some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best some_worst\"\n  shows \"\\<beta> = \\<alpha>\"", "lemma leq_mix_imp_weak_inferior:\n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"\\<beta> \\<in> {0..1}\"\n  assumes \"mix_pmf \\<beta> some_best some_worst \\<succeq>[\\<R>] mix_pmf \\<alpha> some_best some_worst\"\n  shows \"\\<beta> \\<ge> \\<alpha>\"", "lemma ge_mix_pmf_preferred:\n  assumes \"x \\<succ>[\\<R>] y\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"\\<beta> \\<in> {0..1}\"\n  assumes \"\\<alpha> \\<ge> \\<beta>\"\n  shows \"(mix_pmf \\<alpha> x y) \\<succeq>[\\<R>] (mix_pmf \\<beta> x y)\"", "lemma step_2_unique_continuous_unfolding:\n  assumes \"p \\<succeq>[\\<R>] q\"\n    and \"q \\<succeq>[\\<R>] r\"\n    and \"p \\<succ>[\\<R>] r\"\n  shows \"\\<exists>!\\<alpha> \\<in> {0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\"", "lemma create_unique_indiff_using_distinct_best_worst:\n  assumes \"l \\<in> \\<P>\"\n  assumes \"b \\<in> best\"\n  assumes \"w \\<in> worst\"\n  assumes \"b \\<succ>[\\<R>] w\"\n  shows \"\\<exists>!\\<alpha> \\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\"", "lemma exists_element_bw_mix_is_approx:\n  assumes \"l \\<in> \\<P>\"\n  assumes \"b \\<in> best\"\n  assumes \"w \\<in> worst\"\n  shows \"\\<exists>\\<alpha> \\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\"", "lemma my_U_is_defined:\n  assumes \"p \\<in> \\<P>\"\n  shows \"my_U p \\<in> {0..1}\" \"p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst\"", "lemma weak_pref_mix_with_my_U_weak_pref:\n  assumes \"p \\<succeq>[\\<R>] q\"\n  shows \"mix_pmf (my_U p) some_best some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst\"", "lemma preferred_greater_my_U: \n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n  assumes \"mix_pmf (my_U p) some_best some_worst \\<succ>[\\<R>] mix_pmf (my_U q) some_best some_worst\"\n  shows \"my_U p > my_U q\"", "lemma geq_my_U_imp_weak_preference:\n  assumes \"p \\<in> \\<P>\" \n    and \"q \\<in> \\<P>\" \n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  assumes \"my_U p \\<ge> my_U q\"\n  shows \"p \\<succeq>[\\<R>] q\"", "lemma my_U_represents_pref:\n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  assumes \"p \\<in> \\<P>\" \n    and \"q \\<in> \\<P>\" \n  shows \"p \\<succeq>[\\<R>] q \\<longleftrightarrow> my_U p \\<ge> my_U q\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma first_iff_u_greater_strict_preff:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  shows \"my_U p > my_U q \\<longleftrightarrow> mix_pmf (my_U p) some_best some_worst \\<succ>[\\<R>] mix_pmf (my_U q) some_best some_worst\"", "lemma second_iff_calib_mix_pref_strict_pref:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  shows \"mix_pmf (my_U p) some_best some_worst \\<succ>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<longleftrightarrow> p \\<succ>[\\<R>] q\"", "lemma my_U_is_linear_function:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  assumes \"some_best \\<succ>[\\<R>] some_worst\" \n  shows \"my_U (mix_pmf \\<alpha> p q) = \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q\"", "lemma general_U_is_linear_function:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  shows \"general_U (mix_pmf \\<alpha> p q) = \\<alpha> * (general_U p) + (1 - \\<alpha>) * (general_U q)\"", "lemma general_U_ordinal_Utility:\n  shows \"ordinal_utility \\<P> \\<R> general_U\"", "theorem is_linear:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  shows \"\\<exists>u. u (mix_pmf \\<alpha> p q) = \\<alpha> * (u p) + (1-\\<alpha>) * (u q)\"", "lemma geral_U_is_expected_value_of_ocU:\n  assumes \"set_pmf p \\<subseteq> outcomes\"\n  shows \"general_U p = measure_pmf.expectation p ocU\"", "lemma ordinal_utility_expected_value:\n  \"ordinal_utility \\<P> \\<R> (\\<lambda>x. measure_pmf.expectation x ocU)\"", "lemma ordinal_utility_expected_value':\n  \"\\<exists>u. ordinal_utility \\<P> \\<R> (\\<lambda>x. measure_pmf.expectation x u)\"", "lemma ocU_is_expected_utility_bernoulli:\n  shows \"\\<forall>x \\<in> \\<P>. \\<forall>y \\<in> \\<P>. x \\<succeq>[\\<R>] y \\<longleftrightarrow> \n  measure_pmf.expectation x ocU \\<ge> measure_pmf.expectation y ocU\"", "lemma expected_value_is_utility_function:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  assumes \"x \\<in> lotteries_on outcomes\" and \"y \\<in> lotteries_on outcomes\"\n  assumes \"ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\"\n  shows \"measure_pmf.expectation x u \\<ge> measure_pmf.expectation y u \\<longleftrightarrow> x \\<succeq>[\\<R>] y\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma system_U_implies_vNM_utility:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n  assumes ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  assumes cnt: \"continuous_vnm (lotteries_on outcomes) \\<R>\"\n  shows \"\\<exists>u. ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\"", "lemma vNM_utility_implies_rationality:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  assumes \"\\<exists>u. ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\"\n  shows \"rational_preference (lotteries_on outcomes) \\<R>\"", "theorem vNM_utility_implies_independence:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  assumes \"\\<exists>u. ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\"\n  shows \"independent_vnm (lotteries_on outcomes) \\<R>\"", "lemma exists_weight_for_equality:\n  assumes \"a > c\" and \"a \\<ge> b\" and \"b \\<ge> c\"\n  shows   \"\\<exists>(e::real) \\<in> {0..1}. (1-e) * a + e * c = b\"", "lemma vNM_utilty_implies_continuity:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  assumes \"\\<exists>u. ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\"\n  shows \"continuous_vnm (lotteries_on outcomes) \\<R>\"", "theorem Von_Neumann_Morgenstern_Utility_Theorem:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  shows \"rational_preference (lotteries_on outcomes) \\<R> \\<and> \n         independent_vnm (lotteries_on outcomes) \\<R> \\<and> \n         continuous_vnm (lotteries_on outcomes) \\<R> \\<longleftrightarrow> \n   (\\<exists>u. ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u))\""], "translations": [["", "lemma independent_vnmI1:\n  assumes \"(\\<forall>p \\<in> C. \\<forall>q \\<in> C. \\<forall>r \\<in> C. \\<forall>\\<alpha> \\<in> {0<..1}. p \\<succeq>[P] q \\<longleftrightarrow> mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r)\"\n  shows \"independent_vnm C P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. independent_vnm C P", "using assms independent_vnm_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>C.\n     \\<forall>q\\<in>C.\n        \\<forall>r\\<in>C.\n           \\<forall>\\<alpha>\\<in>{0<..1}.\n              p \\<succeq>[P] q =\n              mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\n  independent_vnm ?C ?P =\n  (\\<forall>p\\<in>?C.\n      \\<forall>q\\<in>?C.\n         \\<forall>r\\<in>?C.\n            \\<forall>\\<alpha>\\<in>{0<..1}.\n               p \\<succeq>[?P] q =\n               mix_pmf \\<alpha> p r \\<succeq>[?P] mix_pmf \\<alpha> q r)\n\ngoal (1 subgoal):\n 1. independent_vnm C P", "by blast"], ["", "lemma independent_vnmI2:\n  assumes \"\\<And>p q r \\<alpha>. p \\<in> C \\<Longrightarrow> q \\<in> C \\<Longrightarrow> r \\<in> C \\<Longrightarrow> \\<alpha> \\<in> {0<..1} \\<Longrightarrow> p \\<succeq>[P] q \\<longleftrightarrow> mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\"\n  shows \"independent_vnm C P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. independent_vnm C P", "by (rule independent_vnmI1, standard, standard, standard, \n      standard, simp add: assms) (meson assms greaterThanAtMost_iff)"], ["", "lemma independent_vnm_alt_def:\n  shows \"independent_vnm C P \\<longleftrightarrow> (\\<forall>p \\<in> C. \\<forall>q \\<in> C. \\<forall>r \\<in> C. \\<forall>\\<alpha> \\<in> {0<..<1}. \n  p \\<succeq>[P] q \\<longleftrightarrow> mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r)\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. independent_vnm C P =\n    (\\<forall>p\\<in>C.\n        \\<forall>q\\<in>C.\n           \\<forall>r\\<in>C.\n              \\<forall>\\<alpha>\\<in>{0<..<1}.\n                 p \\<succeq>[P] q =\n                 mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. independent_vnm C P \\<Longrightarrow>\n    \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             \\<forall>\\<alpha>\\<in>{0<..<1}.\n                p \\<succeq>[P] q =\n                mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\n 2. \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             \\<forall>\\<alpha>\\<in>{0<..<1}.\n                p \\<succeq>[P] q =\n                mix_pmf \\<alpha> p\n                 r \\<succeq>[P] mix_pmf \\<alpha> q r \\<Longrightarrow>\n    independent_vnm C P", "assume a: \"?R\""], ["proof (state)\nthis:\n  \\<forall>p\\<in>C.\n     \\<forall>q\\<in>C.\n        \\<forall>r\\<in>C.\n           \\<forall>\\<alpha>\\<in>{0<..<1}.\n              p \\<succeq>[P] q =\n              mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\n\ngoal (2 subgoals):\n 1. independent_vnm C P \\<Longrightarrow>\n    \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             \\<forall>\\<alpha>\\<in>{0<..<1}.\n                p \\<succeq>[P] q =\n                mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\n 2. \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             \\<forall>\\<alpha>\\<in>{0<..<1}.\n                p \\<succeq>[P] q =\n                mix_pmf \\<alpha> p\n                 r \\<succeq>[P] mix_pmf \\<alpha> q r \\<Longrightarrow>\n    independent_vnm C P", "have \"independent_vnm C P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. independent_vnm C P", "by(rule independent_vnmI2, simp add: a) (metis a greaterThanLessThan_iff \n        linorder_neqE_linordered_idom not_le pmf_mix_1)"], ["proof (state)\nthis:\n  independent_vnm C P\n\ngoal (2 subgoals):\n 1. independent_vnm C P \\<Longrightarrow>\n    \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             \\<forall>\\<alpha>\\<in>{0<..<1}.\n                p \\<succeq>[P] q =\n                mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\n 2. \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             \\<forall>\\<alpha>\\<in>{0<..<1}.\n                p \\<succeq>[P] q =\n                mix_pmf \\<alpha> p\n                 r \\<succeq>[P] mix_pmf \\<alpha> q r \\<Longrightarrow>\n    independent_vnm C P", "then"], ["proof (chain)\npicking this:\n  independent_vnm C P", "show \"?L\""], ["proof (prove)\nusing this:\n  independent_vnm C P\n\ngoal (1 subgoal):\n 1. independent_vnm C P", "by auto"], ["proof (state)\nthis:\n  independent_vnm C P\n\ngoal (1 subgoal):\n 1. independent_vnm C P \\<Longrightarrow>\n    \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             \\<forall>\\<alpha>\\<in>{0<..<1}.\n                p \\<succeq>[P] q =\n                mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r", "qed (simp add: independent_vnm_def)"], ["", "lemma independece_dest_alt: \n  assumes \"independent_vnm C P\"\n  shows \"(\\<forall>p \\<in> C. \\<forall>q \\<in> C. \\<forall>r \\<in> C. \\<forall>(\\<alpha>::real) \\<in> {0<..1}. p \\<succeq>[P] q \\<longleftrightarrow> mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             \\<forall>\\<alpha>\\<in>{0<..1}.\n                p \\<succeq>[P] q =\n                mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r", "proof (standard, standard, standard, standard)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> C; q \\<in> C; r \\<in> C;\n        \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[P] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[P] mix_pmf \\<alpha> q r", "fix p q r \\<alpha>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> C; q \\<in> C; r \\<in> C;\n        \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[P] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[P] mix_pmf \\<alpha> q r", "assume as1: \"p \\<in> C\""], ["proof (state)\nthis:\n  p \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> C; q \\<in> C; r \\<in> C;\n        \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[P] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[P] mix_pmf \\<alpha> q r", "assume as2: \"q \\<in> C\""], ["proof (state)\nthis:\n  q \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> C; q \\<in> C; r \\<in> C;\n        \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[P] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[P] mix_pmf \\<alpha> q r", "assume as3: \"r \\<in> C\""], ["proof (state)\nthis:\n  r \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> C; q \\<in> C; r \\<in> C;\n        \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[P] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[P] mix_pmf \\<alpha> q r", "assume as4: \"(\\<alpha>::real) \\<in> {0<..1}\""], ["proof (state)\nthis:\n  \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> C; q \\<in> C; r \\<in> C;\n        \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[P] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[P] mix_pmf \\<alpha> q r", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> {0<..1}", "show \"p \\<succeq>[P] q = mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. p \\<succeq>[P] q =\n    mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r", "using as1 as2 as3 assms(1) independent_vnm_def"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0<..1}\n  p \\<in> C\n  q \\<in> C\n  r \\<in> C\n  independent_vnm C P\n  independent_vnm ?C ?P =\n  (\\<forall>p\\<in>?C.\n      \\<forall>q\\<in>?C.\n         \\<forall>r\\<in>?C.\n            \\<forall>\\<alpha>\\<in>{0<..1}.\n               p \\<succeq>[?P] q =\n               mix_pmf \\<alpha> p r \\<succeq>[?P] mix_pmf \\<alpha> q r)\n\ngoal (1 subgoal):\n 1. p \\<succeq>[P] q =\n    mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r", "by blast"], ["proof (state)\nthis:\n  p \\<succeq>[P] q = mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma independent_vnmD1:\n  assumes \"independent_vnm C P\"\n  shows \"(\\<forall>p \\<in> C. \\<forall>q \\<in> C. \\<forall>r \\<in> C. \\<forall>\\<alpha> \\<in> {0<..1}. p \\<succeq>[P] q \\<longleftrightarrow> mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             \\<forall>\\<alpha>\\<in>{0<..1}.\n                p \\<succeq>[P] q =\n                mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r", "using assms independent_vnm_def"], ["proof (prove)\nusing this:\n  independent_vnm C P\n  independent_vnm ?C ?P =\n  (\\<forall>p\\<in>?C.\n      \\<forall>q\\<in>?C.\n         \\<forall>r\\<in>?C.\n            \\<forall>\\<alpha>\\<in>{0<..1}.\n               p \\<succeq>[?P] q =\n               mix_pmf \\<alpha> p r \\<succeq>[?P] mix_pmf \\<alpha> q r)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             \\<forall>\\<alpha>\\<in>{0<..1}.\n                p \\<succeq>[P] q =\n                mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r", "by blast"], ["", "lemma independent_vnmD2:\n  fixes p q r \\<alpha>\n  assumes \"\\<alpha> \\<in> {0<..1}\"\n    and \"p \\<in> C\"\n    and \"q \\<in> C\"\n    and \"r \\<in> C\"\n  assumes \"independent_vnm C P\"\n  assumes \"p \\<succeq>[P] q\"\n  shows \"mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r", "using assms independece_dest_alt"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0<..1}\n  p \\<in> C\n  q \\<in> C\n  r \\<in> C\n  independent_vnm C P\n  p \\<succeq>[P] q\n  independent_vnm ?C ?P \\<Longrightarrow>\n  \\<forall>p\\<in>?C.\n     \\<forall>q\\<in>?C.\n        \\<forall>r\\<in>?C.\n           \\<forall>\\<alpha>\\<in>{0<..1}.\n              p \\<succeq>[?P] q =\n              mix_pmf \\<alpha> p r \\<succeq>[?P] mix_pmf \\<alpha> q r\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r", "by blast"], ["", "lemma independent_vnmD3:\n  fixes p q r \\<alpha>\n  assumes \"\\<alpha> \\<in> {0<..1}\"\n    and \"p \\<in> C\"\n    and \"q \\<in> C\"\n    and \"r \\<in> C\"\n  assumes \"independent_vnm C P\" \n  assumes \"mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\"\n  shows \"p \\<succeq>[P] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<succeq>[P] q", "using assms independece_dest_alt"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0<..1}\n  p \\<in> C\n  q \\<in> C\n  r \\<in> C\n  independent_vnm C P\n  mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\n  independent_vnm ?C ?P \\<Longrightarrow>\n  \\<forall>p\\<in>?C.\n     \\<forall>q\\<in>?C.\n        \\<forall>r\\<in>?C.\n           \\<forall>\\<alpha>\\<in>{0<..1}.\n              p \\<succeq>[?P] q =\n              mix_pmf \\<alpha> p r \\<succeq>[?P] mix_pmf \\<alpha> q r\n\ngoal (1 subgoal):\n 1. p \\<succeq>[P] q", "by blast"], ["", "lemma independent_vnmD4:\n  assumes \"independent_vnm C P\"\n  assumes \"refl_on C P\"\n  assumes \"p \\<in> C\" \n    and \"q \\<in> C\" \n    and \"r \\<in> C\"\n    and \"\\<alpha> \\<in> {0..1}\" \n    and \"p \\<succeq>[P] q\" \n  shows \"mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r", "using assms"], ["proof (prove)\nusing this:\n  independent_vnm C P\n  refl_on C P\n  p \\<in> C\n  q \\<in> C\n  r \\<in> C\n  \\<alpha> \\<in> {0..1}\n  p \\<succeq>[P] q\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<succeq>[P] mix_pmf \\<alpha> q r", "by (cases \"\\<alpha> = 0 \\<or> \\<alpha> \\<in> {0<..1}\",metis assms(1,2,3,4) \n      independece_dest_alt pmf_mix_0 refl_onD, auto)"], ["", "lemma approx_indep_ge:\n  assumes \"x \\<approx>[\\<R>] y\"\n  assumes \"\\<alpha> \\<in> {0..(1::real)}\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n    and ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  shows \"\\<forall>r \\<in> lotteries_on outcomes. (mix_pmf \\<alpha> y r) \\<succeq>[\\<R>] (mix_pmf \\<alpha> x r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>lotteries_on outcomes.\n       mix_pmf \\<alpha> y r \\<succeq>[\\<R>] mix_pmf \\<alpha> x r", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> lotteries_on outcomes \\<Longrightarrow>\n       mix_pmf \\<alpha> y r \\<succeq>[\\<R>] mix_pmf \\<alpha> x r", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> lotteries_on outcomes \\<Longrightarrow>\n       mix_pmf \\<alpha> y r \\<succeq>[\\<R>] mix_pmf \\<alpha> x r", "assume a: \"r \\<in> lotteries_on outcomes\" (is \"r \\<in> ?lo\")"], ["proof (state)\nthis:\n  r \\<in> lotteries_on outcomes\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> lotteries_on outcomes \\<Longrightarrow>\n       mix_pmf \\<alpha> y r \\<succeq>[\\<R>] mix_pmf \\<alpha> x r", "have clct: \"y \\<succeq>[\\<R>] x \\<and> independent_vnm ?lo \\<R> \\<and> y \\<in> ?lo \\<and> x \\<in> ?lo \\<and> r \\<in> ?lo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<succeq>[\\<R>] x \\<and>\n    independent_vnm (lotteries_on outcomes) \\<R> \\<and>\n    y \\<in> lotteries_on outcomes \\<and>\n    x \\<in> lotteries_on outcomes \\<and> r \\<in> lotteries_on outcomes", "by (meson  a assms(1) assms(2) atLeastAtMost_iff greaterThanAtMost_iff \n        ind preference_def rational_preference_def rpr)"], ["proof (state)\nthis:\n  y \\<succeq>[\\<R>] x \\<and>\n  independent_vnm (lotteries_on outcomes) \\<R> \\<and>\n  y \\<in> lotteries_on outcomes \\<and>\n  x \\<in> lotteries_on outcomes \\<and> r \\<in> lotteries_on outcomes\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> lotteries_on outcomes \\<Longrightarrow>\n       mix_pmf \\<alpha> y r \\<succeq>[\\<R>] mix_pmf \\<alpha> x r", "then"], ["proof (chain)\npicking this:\n  y \\<succeq>[\\<R>] x \\<and>\n  independent_vnm (lotteries_on outcomes) \\<R> \\<and>\n  y \\<in> lotteries_on outcomes \\<and>\n  x \\<in> lotteries_on outcomes \\<and> r \\<in> lotteries_on outcomes", "have in_lo: \"mix_pmf \\<alpha> y r \\<in> ?lo\" \"(mix_pmf \\<alpha> x r) \\<in> ?lo\""], ["proof (prove)\nusing this:\n  y \\<succeq>[\\<R>] x \\<and>\n  independent_vnm (lotteries_on outcomes) \\<R> \\<and>\n  y \\<in> lotteries_on outcomes \\<and>\n  x \\<in> lotteries_on outcomes \\<and> r \\<in> lotteries_on outcomes\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> y r \\<in> lotteries_on outcomes &&&\n    mix_pmf \\<alpha> x r \\<in> lotteries_on outcomes", "by (metis  assms(2) atLeastAtMost_iff greaterThanLessThan_iff\n        less_eq_real_def mix_pmf_in_lotteries pmf_mix_0 pmf_mix_1 a)+"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> y r \\<in> lotteries_on outcomes\n  mix_pmf \\<alpha> x r \\<in> lotteries_on outcomes\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> lotteries_on outcomes \\<Longrightarrow>\n       mix_pmf \\<alpha> y r \\<succeq>[\\<R>] mix_pmf \\<alpha> x r", "have \"0 = \\<alpha> \\<or> 0 < \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = \\<alpha> \\<or> 0 < \\<alpha>", "using assms"], ["proof (prove)\nusing this:\n  x \\<approx>[\\<R>] y\n  \\<alpha> \\<in> {0..1}\n  rational_preference (lotteries_on outcomes) \\<R>\n  independent_vnm (lotteries_on outcomes) \\<R>\n\ngoal (1 subgoal):\n 1. 0 = \\<alpha> \\<or> 0 < \\<alpha>", "by auto"], ["proof (state)\nthis:\n  0 = \\<alpha> \\<or> 0 < \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> lotteries_on outcomes \\<Longrightarrow>\n       mix_pmf \\<alpha> y r \\<succeq>[\\<R>] mix_pmf \\<alpha> x r", "then"], ["proof (chain)\npicking this:\n  0 = \\<alpha> \\<or> 0 < \\<alpha>", "show \"mix_pmf \\<alpha> y r \\<succeq>[\\<R>] mix_pmf \\<alpha> x r\""], ["proof (prove)\nusing this:\n  0 = \\<alpha> \\<or> 0 < \\<alpha>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> y r \\<succeq>[\\<R>] mix_pmf \\<alpha> x r", "using in_lo(2) rational_preference.compl rpr"], ["proof (prove)\nusing this:\n  0 = \\<alpha> \\<or> 0 < \\<alpha>\n  mix_pmf \\<alpha> x r \\<in> lotteries_on outcomes\n  rational_preference ?carrier ?relation \\<Longrightarrow>\n  \\<forall>x\\<in>?carrier.\n     \\<forall>y\\<in>?carrier.\n        x \\<succeq>[?relation] y \\<or> y \\<succeq>[?relation] x\n  rational_preference (lotteries_on outcomes) \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> y r \\<succeq>[\\<R>] mix_pmf \\<alpha> x r", "by (auto,blast) (meson assms(2) atLeastAtMost_iff clct\n        greaterThanAtMost_iff independent_vnmD2)"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> y r \\<succeq>[\\<R>] mix_pmf \\<alpha> x r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma approx_imp_approx_ind:\n  assumes \"x \\<approx>[\\<R>] y\"\n  assumes \"\\<alpha> \\<in> {0..(1::real)}\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n    and ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  shows \"\\<forall>r \\<in> lotteries_on outcomes. (mix_pmf \\<alpha> y r) \\<approx>[\\<R>] (mix_pmf \\<alpha> x r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>lotteries_on outcomes.\n       mix_pmf \\<alpha> y r \\<approx>[\\<R>] mix_pmf \\<alpha> x r", "using approx_indep_ge assms(1) assms(2) ind rpr"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<approx>[?\\<R>] ?y; ?\\<alpha> \\<in> {0..1};\n   rational_preference (lotteries_on ?outcomes) ?\\<R>;\n   independent_vnm (lotteries_on ?outcomes) ?\\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>r\\<in>lotteries_on ?outcomes.\n                       mix_pmf ?\\<alpha> ?y\n                        r \\<succeq>[?\\<R>] mix_pmf ?\\<alpha> ?x r\n  x \\<approx>[\\<R>] y\n  \\<alpha> \\<in> {0..1}\n  independent_vnm (lotteries_on outcomes) \\<R>\n  rational_preference (lotteries_on outcomes) \\<R>\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>lotteries_on outcomes.\n       mix_pmf \\<alpha> y r \\<approx>[\\<R>] mix_pmf \\<alpha> x r", "by blast"], ["", "lemma geq_imp_mix_geq_right:\n  assumes \"x \\<succeq>[\\<R>] y\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n  assumes ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  assumes \"\\<alpha> \\<in> {0..(1::real)}\"\n  shows \"(mix_pmf \\<alpha> x y) \\<succeq>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y", "have xy_p: \"x \\<in> (lotteries_on outcomes)\" \"y \\<in> (lotteries_on outcomes)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lotteries_on outcomes &&& y \\<in> lotteries_on outcomes", "by (meson assms(1) preference.not_outside rational_preference_def rpr)\n      (meson assms(1) preference_def rational_preference_def rpr)"], ["proof (state)\nthis:\n  x \\<in> lotteries_on outcomes\n  y \\<in> lotteries_on outcomes\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y", "have \"(mix_pmf \\<alpha> x y) \\<in> (lotteries_on outcomes)\" (is \"?mpf \\<in> ?lot\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes", "using mix_pmf_in_lotteries [of x outcomes y \\<alpha>] xy_p assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> lotteries_on outcomes; y \\<in> lotteries_on outcomes;\n   \\<alpha> \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes\n  x \\<in> lotteries_on outcomes\n  y \\<in> lotteries_on outcomes\n  rational_preference (lotteries_on outcomes) \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes", "by (meson approx_indep_ge assms(4) ind preference.not_outside \n        rational_preference.compl rational_preference_def)"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y", "have all: \"\\<forall>r \\<in> ?lot. (mix_pmf \\<alpha> x r) \\<succeq>[\\<R>] (mix_pmf \\<alpha> y r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>lotteries_on outcomes.\n       mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r", "by (metis assms assms(2) atLeastAtMost_iff greaterThanAtMost_iff independece_dest_alt \n        less_eq_real_def pmf_mix_0 rational_preference.compl rpr ind xy_p)"], ["proof (state)\nthis:\n  \\<forall>r\\<in>lotteries_on outcomes.\n     mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>lotteries_on outcomes.\n     mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y", "by (metis all assms(4) set_pmf_mix_eq xy_p(2))"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma geq_imp_mix_geq_left:\n  assumes \"x \\<succeq>[\\<R>] y\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n  assumes ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  assumes \"\\<alpha> \\<in> {0..(1::real)}\"\n  shows \"(mix_pmf \\<alpha> y x) \\<succeq>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> y x \\<succeq>[\\<R>] y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> y x \\<succeq>[\\<R>] y", "define \\<beta> where\n    b: \"\\<beta> = 1 - \\<alpha>\""], ["proof (state)\nthis:\n  \\<beta> = 1 - \\<alpha>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> y x \\<succeq>[\\<R>] y", "have \"\\<beta> \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> \\<in> {0..1}", "using assms(4) b"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0..1}\n  \\<beta> = 1 - \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<in> {0..1}", "by auto"], ["proof (state)\nthis:\n  \\<beta> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> y x \\<succeq>[\\<R>] y", "then"], ["proof (chain)\npicking this:\n  \\<beta> \\<in> {0..1}", "have \"mix_pmf \\<beta> x y \\<succeq>[\\<R>] y\""], ["proof (prove)\nusing this:\n  \\<beta> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> x y \\<succeq>[\\<R>] y", "using geq_imp_mix_geq_right[OF assms] assms(1) geq_imp_mix_geq_right ind rpr"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> {0..1}\n  mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y\n  x \\<succeq>[\\<R>] y\n  \\<lbrakk>?x \\<succeq>[?\\<R>] ?y;\n   rational_preference (lotteries_on ?outcomes) ?\\<R>;\n   independent_vnm (lotteries_on ?outcomes) ?\\<R>;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y \\<succeq>[?\\<R>] ?y\n  independent_vnm (lotteries_on outcomes) \\<R>\n  rational_preference (lotteries_on outcomes) \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> x y \\<succeq>[\\<R>] y", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<beta> x y \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> y x \\<succeq>[\\<R>] y", "moreover"], ["proof (state)\nthis:\n  mix_pmf \\<beta> x y \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> y x \\<succeq>[\\<R>] y", "have \"mix_pmf \\<beta> x y = mix_pmf \\<alpha> y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> x y = mix_pmf \\<alpha> y x", "by (metis assms(4) b pmf_inverse_switch_eqals)"], ["proof (state)\nthis:\n  mix_pmf \\<beta> x y = mix_pmf \\<alpha> y x\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> y x \\<succeq>[\\<R>] y", "ultimately"], ["proof (chain)\npicking this:\n  mix_pmf \\<beta> x y \\<succeq>[\\<R>] y\n  mix_pmf \\<beta> x y = mix_pmf \\<alpha> y x", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf \\<beta> x y \\<succeq>[\\<R>] y\n  mix_pmf \\<beta> x y = mix_pmf \\<alpha> y x\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> y x \\<succeq>[\\<R>] y", "by simp"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> y x \\<succeq>[\\<R>] y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sg_imp_mix_sg:\n  assumes \"x \\<succ>[\\<R>] y\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n  assumes ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  assumes \"\\<alpha> \\<in> {0<..(1::real)}\"\n  shows \"(mix_pmf \\<alpha> x y) \\<succ>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "have xy_p: \"x \\<in> (lotteries_on outcomes)\" \"y \\<in> (lotteries_on outcomes)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lotteries_on outcomes &&& y \\<in> lotteries_on outcomes", "by (meson assms(1) preference.not_outside rational_preference_def rpr)\n      (meson assms(1) preference_def rational_preference_def rpr)"], ["proof (state)\nthis:\n  x \\<in> lotteries_on outcomes\n  y \\<in> lotteries_on outcomes\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "have \"(mix_pmf \\<alpha> x y) \\<in> (lotteries_on outcomes)\" (is \"?mpf \\<in> ?lot\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes", "using mix_pmf_in_lotteries [of x outcomes y \\<alpha>] xy_p assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> lotteries_on outcomes; y \\<in> lotteries_on outcomes;\n   \\<alpha> \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes\n  x \\<in> lotteries_on outcomes\n  y \\<in> lotteries_on outcomes\n  rational_preference (lotteries_on outcomes) \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes", "using assms(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> lotteries_on outcomes; y \\<in> lotteries_on outcomes;\n   \\<alpha> \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes\n  x \\<in> lotteries_on outcomes\n  y \\<in> lotteries_on outcomes\n  rational_preference (lotteries_on outcomes) \\<R>\n  \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes", "by fastforce"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "have all: \"\\<forall>r \\<in> ?lot. (mix_pmf \\<alpha> x r) \\<succeq>[\\<R>] (mix_pmf \\<alpha> y r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>lotteries_on outcomes.\n       mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r", "by (metis assms(1,3,4)  independece_dest_alt ind xy_p)"], ["proof (state)\nthis:\n  \\<forall>r\\<in>lotteries_on outcomes.\n     mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "have \"(mix_pmf \\<alpha> x y) \\<succeq>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y", "by (metis all assms(4) atLeastAtMost_iff greaterThanAtMost_iff \n        less_eq_real_def set_pmf_mix_eq xy_p(2))"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "have all2: \"\\<forall>r \\<in> ?lot. (mix_pmf \\<alpha> x r) \\<succ>[\\<R>] (mix_pmf \\<alpha> y r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>lotteries_on outcomes.\n       mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r \\<and>\n       (mix_pmf \\<alpha> y r, mix_pmf \\<alpha> x r) \\<notin> \\<R>", "using assms(1) assms(4) ind independece_dest_alt xy_p(1) xy_p(2)"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y \\<and> (y, x) \\<notin> \\<R>\n  \\<alpha> \\<in> {0<..1}\n  independent_vnm (lotteries_on outcomes) \\<R>\n  independent_vnm ?C ?P \\<Longrightarrow>\n  \\<forall>p\\<in>?C.\n     \\<forall>q\\<in>?C.\n        \\<forall>r\\<in>?C.\n           \\<forall>\\<alpha>\\<in>{0<..1}.\n              p \\<succeq>[?P] q =\n              mix_pmf \\<alpha> p r \\<succeq>[?P] mix_pmf \\<alpha> q r\n  x \\<in> lotteries_on outcomes\n  y \\<in> lotteries_on outcomes\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>lotteries_on outcomes.\n       mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r \\<and>\n       (mix_pmf \\<alpha> y r, mix_pmf \\<alpha> x r) \\<notin> \\<R>", "by blast"], ["proof (state)\nthis:\n  \\<forall>r\\<in>lotteries_on outcomes.\n     mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r \\<and>\n     (mix_pmf \\<alpha> y r, mix_pmf \\<alpha> x r) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>lotteries_on outcomes.\n     mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r \\<and>\n     (mix_pmf \\<alpha> y r, mix_pmf \\<alpha> x r) \\<notin> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>lotteries_on outcomes.\n     mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r \\<and>\n     (mix_pmf \\<alpha> y r, mix_pmf \\<alpha> x r) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "by (metis assms(4) atLeastAtMost_iff greaterThanAtMost_iff \n        less_eq_real_def set_pmf_mix_eq xy_p(2))"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n  (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Continuity \\<close>"], ["", "text \\<open> Continuity is sometimes called Archimedean Axiom\\<close>"], ["", "definition continuous_vnm\n  where\n    \"continuous_vnm C P = (\\<forall>p \\<in> C. \\<forall>q \\<in> C. \\<forall>r \\<in> C. p \\<succeq>[P] q \\<and> q \\<succeq>[P] r \\<longrightarrow> \n    (\\<exists>\\<alpha> \\<in> {0..1}. (mix_pmf \\<alpha> p r) \\<approx>[P] q))\""], ["", "lemma continuous_vnmD:\n  assumes \"continuous_vnm C P\"\n  shows \"(\\<forall>p \\<in> C. \\<forall>q \\<in> C. \\<forall>r \\<in> C. p \\<succeq>[P] q \\<and> q \\<succeq>[P] r \\<longrightarrow>\n    (\\<exists>\\<alpha> \\<in> {0..1}. (mix_pmf \\<alpha> p r) \\<approx>[P] q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             p \\<succeq>[P] q \\<and> q \\<succeq>[P] r \\<longrightarrow>\n             (\\<exists>\\<alpha>\\<in>{0..1}.\n                 mix_pmf \\<alpha> p r \\<approx>[P] q)", "using continuous_vnm_def assms"], ["proof (prove)\nusing this:\n  continuous_vnm ?C ?P =\n  (\\<forall>p\\<in>?C.\n      \\<forall>q\\<in>?C.\n         \\<forall>r\\<in>?C.\n            p \\<succeq>[?P] q \\<and> q \\<succeq>[?P] r \\<longrightarrow>\n            (\\<exists>\\<alpha>\\<in>{0..1}.\n                mix_pmf \\<alpha> p r \\<approx>[?P] q))\n  continuous_vnm C P\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>C.\n       \\<forall>q\\<in>C.\n          \\<forall>r\\<in>C.\n             p \\<succeq>[P] q \\<and> q \\<succeq>[P] r \\<longrightarrow>\n             (\\<exists>\\<alpha>\\<in>{0..1}.\n                 mix_pmf \\<alpha> p r \\<approx>[P] q)", "by blast"], ["", "lemma continuous_vnmI:\n  assumes \"\\<And>p q r. p \\<in> C \\<Longrightarrow> q \\<in> C \\<Longrightarrow> r \\<in> C \\<Longrightarrow> p \\<succeq>[P] q \\<and> q \\<succeq>[P] r \\<Longrightarrow> \n    \\<exists>\\<alpha> \\<in> {0..1}. (mix_pmf \\<alpha> p r) \\<approx>[P] q\"\n  shows \"continuous_vnm C P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_vnm C P", "by (simp add: assms continuous_vnm_def)"], ["", "lemma mix_in_lot:\n  assumes \"x \\<in> lotteries_on outcomes\"\n    and \"y \\<in> lotteries_on outcomes\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  shows \"(mix_pmf \\<alpha> x y) \\<in> lotteries_on outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes", "using assms(1) assms(2) assms(3) less_eq_real_def mix_pmf_in_lotteries"], ["proof (prove)\nusing this:\n  x \\<in> lotteries_on outcomes\n  y \\<in> lotteries_on outcomes\n  \\<alpha> \\<in> {0..1}\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n  \\<lbrakk>?p \\<in> lotteries_on ?A; ?q \\<in> lotteries_on ?A;\n   ?a \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?a ?p ?q \\<in> lotteries_on ?A\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<in> lotteries_on outcomes", "by fastforce"], ["", "lemma non_unique_continuous_unfolding:\n  assumes cnt: \"continuous_vnm (lotteries_on outcomes) \\<R>\"\n  assumes \"rational_preference (lotteries_on outcomes) \\<R>\"\n  assumes \"p \\<succeq>[\\<R>] q\"\n    and \"q \\<succeq>[\\<R>] r\"\n    and \"p \\<succ>[\\<R>] r\"\n  shows \"\\<exists>\\<alpha> \\<in> {0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r", "using assms(1) assms(2) cnt continuous_vnmD assms"], ["proof (prove)\nusing this:\n  continuous_vnm (lotteries_on outcomes) \\<R>\n  rational_preference (lotteries_on outcomes) \\<R>\n  continuous_vnm (lotteries_on outcomes) \\<R>\n  continuous_vnm ?C ?P \\<Longrightarrow>\n  \\<forall>p\\<in>?C.\n     \\<forall>q\\<in>?C.\n        \\<forall>r\\<in>?C.\n           p \\<succeq>[?P] q \\<and> q \\<succeq>[?P] r \\<longrightarrow>\n           (\\<exists>\\<alpha>\\<in>{0..1}.\n               mix_pmf \\<alpha> p r \\<approx>[?P] q)\n  continuous_vnm (lotteries_on outcomes) \\<R>\n  rational_preference (lotteries_on outcomes) \\<R>\n  p \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] r\n  p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>continuous_vnm (lotteries_on outcomes) \\<R>;\n     rational_preference (lotteries_on outcomes) \\<R>;\n     continuous_vnm (lotteries_on outcomes) \\<R>;\n     \\<And>C P.\n        continuous_vnm C P \\<Longrightarrow>\n        \\<forall>p\\<in>C.\n           \\<forall>q\\<in>C.\n              \\<forall>r\\<in>C.\n                 p \\<succeq>[P] q \\<and> q \\<succeq>[P] r \\<longrightarrow>\n                 (\\<exists>\\<alpha>\\<in>{0..1}.\n                     mix_pmf \\<alpha> p r \\<approx>[P] q);\n     continuous_vnm (lotteries_on outcomes) \\<R>;\n     rational_preference (lotteries_on outcomes) \\<R>; p \\<succeq>[\\<R>] q;\n     q \\<succeq>[\\<R>] r;\n     p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                         q \\<approx>[\\<R>] mix_pmf \\<alpha> p r", "have \"\\<forall>p q. p\\<in> (lotteries_on outcomes) \\<and> q \\<in> (lotteries_on outcomes) \\<longleftrightarrow> p \\<succeq>[\\<R>] q \\<or> q \\<succeq>[\\<R>] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p q.\n       (p \\<in> lotteries_on outcomes \\<and>\n        q \\<in> lotteries_on outcomes) =\n       (p \\<succeq>[\\<R>] q \\<or> q \\<succeq>[\\<R>] p)", "using assms rational_preference.compl[of \"lotteries_on outcomes\" \\<R>]"], ["proof (prove)\nusing this:\n  continuous_vnm (lotteries_on outcomes) \\<R>\n  rational_preference (lotteries_on outcomes) \\<R>\n  p \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] r\n  p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\n  rational_preference (lotteries_on outcomes) \\<R> \\<Longrightarrow>\n  \\<forall>x\\<in>lotteries_on outcomes.\n     \\<forall>y\\<in>lotteries_on outcomes.\n        x \\<succeq>[\\<R>] y \\<or> y \\<succeq>[\\<R>] x\n\ngoal (1 subgoal):\n 1. \\<forall>p q.\n       (p \\<in> lotteries_on outcomes \\<and>\n        q \\<in> lotteries_on outcomes) =\n       (p \\<succeq>[\\<R>] q \\<or> q \\<succeq>[\\<R>] p)", "by (metis (no_types, hide_lams) preference_def rational_preference_def)"], ["proof (state)\nthis:\n  \\<forall>p q.\n     (p \\<in> lotteries_on outcomes \\<and> q \\<in> lotteries_on outcomes) =\n     (p \\<succeq>[\\<R>] q \\<or> q \\<succeq>[\\<R>] p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>continuous_vnm (lotteries_on outcomes) \\<R>;\n     rational_preference (lotteries_on outcomes) \\<R>;\n     continuous_vnm (lotteries_on outcomes) \\<R>;\n     \\<And>C P.\n        continuous_vnm C P \\<Longrightarrow>\n        \\<forall>p\\<in>C.\n           \\<forall>q\\<in>C.\n              \\<forall>r\\<in>C.\n                 p \\<succeq>[P] q \\<and> q \\<succeq>[P] r \\<longrightarrow>\n                 (\\<exists>\\<alpha>\\<in>{0..1}.\n                     mix_pmf \\<alpha> p r \\<approx>[P] q);\n     continuous_vnm (lotteries_on outcomes) \\<R>;\n     rational_preference (lotteries_on outcomes) \\<R>; p \\<succeq>[\\<R>] q;\n     q \\<succeq>[\\<R>] r;\n     p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                         q \\<approx>[\\<R>] mix_pmf \\<alpha> p r", "then"], ["proof (chain)\npicking this:\n  \\<forall>p q.\n     (p \\<in> lotteries_on outcomes \\<and> q \\<in> lotteries_on outcomes) =\n     (p \\<succeq>[\\<R>] q \\<or> q \\<succeq>[\\<R>] p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>p q.\n     (p \\<in> lotteries_on outcomes \\<and> q \\<in> lotteries_on outcomes) =\n     (p \\<succeq>[\\<R>] q \\<or> q \\<succeq>[\\<R>] p)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r", "using continuous_vnmD[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<forall>p q.\n     (p \\<in> lotteries_on outcomes \\<and> q \\<in> lotteries_on outcomes) =\n     (p \\<succeq>[\\<R>] q \\<or> q \\<succeq>[\\<R>] p)\n  \\<forall>p\\<in>lotteries_on outcomes.\n     \\<forall>q\\<in>lotteries_on outcomes.\n        \\<forall>r\\<in>lotteries_on outcomes.\n           p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r \\<longrightarrow>\n           (\\<exists>\\<alpha>\\<in>{0..1}.\n               mix_pmf \\<alpha> p r \\<approx>[\\<R>] q)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r", "by (metis assms(3) assms(4))"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>\\<in>{0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open> System U start, as per vNM\\<close>"], ["", "text \\<open> These are the first two assumptions which we use to derive the first results.\n       We assume rationality and independence. In this system U the von-Neumann-Morgenstern \n        Utility Theorem is proven. \\<close>"], ["", "context\n  fixes outcomes :: \"'a set\"\n  fixes \\<R>\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n  assumes ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\nbegin"], ["", "abbreviation \"\\<P> \\<equiv> lotteries_on outcomes\""], ["", "lemma relation_in_carrier:\n  \"x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> \\<P> \\<and> y \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y \\<Longrightarrow>\n    x \\<in> local.\\<P> \\<and> y \\<in> local.\\<P>", "by (meson preference_def rational_preference_def rpr)"], ["", "lemma mix_pmf_preferred_independence:\n  assumes \"r \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  assumes \"p \\<succeq>[\\<R>] q\"\n  shows \"mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "using ind"], ["proof (prove)\nusing this:\n  independent_vnm local.\\<P> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "by (metis relation_in_carrier antisym_conv1 assms atLeastAtMost_iff \n      greaterThanAtMost_iff independece_dest_alt pmf_mix_0 \n      rational_preference.no_better_thansubset_rel rpr subsetI)"], ["", "lemma mix_pmf_strict_preferred_independence:\n  assumes \"r \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0<..1}\"\n  assumes \"p \\<succ>[\\<R>] q\"\n  shows \"mix_pmf \\<alpha> p r \\<succ>[\\<R>] mix_pmf \\<alpha> q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r \\<and>\n    (mix_pmf \\<alpha> q r, mix_pmf \\<alpha> p r) \\<notin> \\<R>", "by (meson assms(1) assms(2) assms(3) ind independent_vnmD2 \n      independent_vnmD3 relation_in_carrier)"], ["", "lemma mix_pmf_preferred_independence_rev:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n    and \"r \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0<..1}\"\n  assumes \"mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\"\n  shows \"p \\<succeq>[\\<R>] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "have \"mix_pmf \\<alpha> p r \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<in> local.\\<P>", "using assms mix_in_lot relation_in_carrier"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  r \\<in> local.\\<P>\n  \\<alpha> \\<in> {0<..1}\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n  \\<lbrakk>?x \\<in> Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes;\n   ?y \\<in> Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y\n                    \\<in> Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes\n  ?x \\<succeq>[\\<R>] ?y \\<Longrightarrow>\n  ?x \\<in> local.\\<P> \\<and> ?y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<in> local.\\<P>", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p r \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "moreover"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p r \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "have \"mix_pmf \\<alpha> q r \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> q r \\<in> local.\\<P>", "using assms mix_in_lot assms(2) relation_in_carrier"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  r \\<in> local.\\<P>\n  \\<alpha> \\<in> {0<..1}\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n  \\<lbrakk>?x \\<in> Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes;\n   ?y \\<in> Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y\n                    \\<in> Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes\n  q \\<in> local.\\<P>\n  ?x \\<succeq>[\\<R>] ?y \\<Longrightarrow>\n  ?x \\<in> local.\\<P> \\<and> ?y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> q r \\<in> local.\\<P>", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> q r \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "ultimately"], ["proof (chain)\npicking this:\n  mix_pmf \\<alpha> p r \\<in> local.\\<P>\n  mix_pmf \\<alpha> q r \\<in> local.\\<P>", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> p r \\<in> local.\\<P>\n  mix_pmf \\<alpha> q r \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "using ind independent_vnmD3[of \\<alpha> p \\<P> q r \\<R>] assms"], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> p r \\<in> local.\\<P>\n  mix_pmf \\<alpha> q r \\<in> local.\\<P>\n  independent_vnm local.\\<P> \\<R>\n  \\<lbrakk>\\<alpha> \\<in> {0<..1}; p \\<in> local.\\<P>; q \\<in> local.\\<P>;\n   r \\<in> local.\\<P>; independent_vnm local.\\<P> \\<R>;\n   mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\\<rbrakk>\n  \\<Longrightarrow> p \\<succeq>[\\<R>] q\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  r \\<in> local.\\<P>\n  \\<alpha> \\<in> {0<..1}\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "by blast"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma x_sg_y_sg_mpmf_right:\n  assumes \"x \\<succ>[\\<R>] y\"\n  assumes \"b \\<in> {0<..(1::real)}\"\n  shows \"x \\<succ>[\\<R>] mix_pmf b y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "consider \"b = 1\" | \"b \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = 1 \\<Longrightarrow> thesis;\n     b \\<noteq> 1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>b = 1 \\<Longrightarrow> ?thesis;\n   b \\<noteq> 1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>b = 1 \\<Longrightarrow> ?thesis;\n   b \\<noteq> 1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>b = 1 \\<Longrightarrow> ?thesis;\n   b \\<noteq> 1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. b = 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>\n 2. b \\<noteq> 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "case 2"], ["proof (state)\nthis:\n  b \\<noteq> 1\n\ngoal (2 subgoals):\n 1. b = 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>\n 2. b \\<noteq> 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "have sg: \"(mix_pmf b x y) \\<succ>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf b x y \\<succeq>[\\<R>] y \\<and> (y, mix_pmf b x y) \\<notin> \\<R>", "using assms(1) assms(2) assms ind rpr sg_imp_mix_sg \"2\""], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y \\<and> (y, x) \\<notin> \\<R>\n  b \\<in> {0<..1}\n  x \\<succeq>[\\<R>] y \\<and> (y, x) \\<notin> \\<R>\n  b \\<in> {0<..1}\n  independent_vnm local.\\<P> \\<R>\n  rational_preference local.\\<P> \\<R>\n  \\<lbrakk>?x \\<succeq>[?\\<R>] ?y \\<and> (?y, ?x) \\<notin> ?\\<R>;\n   rational_preference (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   independent_vnm (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   ?\\<alpha> \\<in> {0<..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y \\<succeq>[?\\<R>] ?y \\<and>\n                    (?y, mix_pmf ?\\<alpha> ?x ?y) \\<notin> ?\\<R>\n  b \\<noteq> 1\n\ngoal (1 subgoal):\n 1. mix_pmf b x y \\<succeq>[\\<R>] y \\<and> (y, mix_pmf b x y) \\<notin> \\<R>", "by fastforce"], ["proof (state)\nthis:\n  mix_pmf b x y \\<succeq>[\\<R>] y \\<and> (y, mix_pmf b x y) \\<notin> \\<R>\n\ngoal (2 subgoals):\n 1. b = 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>\n 2. b \\<noteq> 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "have \"mix_pmf b x y \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf b x y \\<in> local.\\<P>", "by (meson sg preference_def rational_preference_def rpr)"], ["proof (state)\nthis:\n  mix_pmf b x y \\<in> local.\\<P>\n\ngoal (2 subgoals):\n 1. b = 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>\n 2. b \\<noteq> 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "have \"mix_pmf b x x \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf b x x \\<in> local.\\<P>", "using relation_in_carrier assms(2) mix_in_lot assms"], ["proof (prove)\nusing this:\n  ?x \\<succeq>[\\<R>] ?y \\<Longrightarrow>\n  ?x \\<in> local.\\<P> \\<and> ?y \\<in> local.\\<P>\n  b \\<in> {0<..1}\n  \\<lbrakk>?x \\<in> Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes;\n   ?y \\<in> Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y\n                    \\<in> Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes\n  x \\<succeq>[\\<R>] y \\<and> (y, x) \\<notin> \\<R>\n  b \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. mix_pmf b x x \\<in> local.\\<P>", "by fastforce"], ["proof (state)\nthis:\n  mix_pmf b x x \\<in> local.\\<P>\n\ngoal (2 subgoals):\n 1. b = 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>\n 2. b \\<noteq> 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "have \"b \\<in> {0<..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> {0<..<1}", "using \"2\" assms(2)"], ["proof (prove)\nusing this:\n  b \\<noteq> 1\n  b \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. b \\<in> {0<..<1}", "by auto"], ["proof (state)\nthis:\n  b \\<in> {0<..<1}\n\ngoal (2 subgoals):\n 1. b = 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>\n 2. b \\<noteq> 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "have \"mix_pmf b x x \\<succ>[\\<R>] mix_pmf b y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf b x x \\<succeq>[\\<R>] mix_pmf b y x \\<and>\n    (mix_pmf b y x, mix_pmf b x x) \\<notin> \\<R>", "using mix_pmf_preferred_independence[of x b] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> local.\\<P>; b \\<in> {0..1};\n   ?p \\<succeq>[\\<R>] ?q\\<rbrakk>\n  \\<Longrightarrow> mix_pmf b ?p x \\<succeq>[\\<R>] mix_pmf b ?q x\n  x \\<succeq>[\\<R>] y \\<and> (y, x) \\<notin> \\<R>\n  b \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. mix_pmf b x x \\<succeq>[\\<R>] mix_pmf b y x \\<and>\n    (mix_pmf b y x, mix_pmf b x x) \\<notin> \\<R>", "by (meson \\<open>b \\<in> {0<..<1}\\<close> greaterThanAtMost_iff greaterThanLessThan_iff ind \n          independece_dest_alt less_eq_real_def preference_def \n          rational_preference.axioms(1) relation_in_carrier rpr)"], ["proof (state)\nthis:\n  mix_pmf b x x \\<succeq>[\\<R>] mix_pmf b y x \\<and>\n  (mix_pmf b y x, mix_pmf b x x) \\<notin> \\<R>\n\ngoal (2 subgoals):\n 1. b = 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>\n 2. b \\<noteq> 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  mix_pmf b x x \\<succeq>[\\<R>] mix_pmf b y x \\<and>\n  (mix_pmf b y x, mix_pmf b x x) \\<notin> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf b x x \\<succeq>[\\<R>] mix_pmf b y x \\<and>\n  (mix_pmf b y x, mix_pmf b x x) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "using mix_pmf_preferred_independence"], ["proof (prove)\nusing this:\n  mix_pmf b x x \\<succeq>[\\<R>] mix_pmf b y x \\<and>\n  (mix_pmf b y x, mix_pmf b x x) \\<notin> \\<R>\n  \\<lbrakk>?r \\<in> local.\\<P>; ?\\<alpha> \\<in> {0..1};\n   ?p \\<succeq>[\\<R>] ?q\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?p\n                     ?r \\<succeq>[\\<R>] mix_pmf ?\\<alpha> ?q ?r\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "by (metis assms(2) atLeastAtMost_iff greaterThanAtMost_iff less_eq_real_def set_pmf_mix_eq)"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. b = 1 \\<Longrightarrow>\n    x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>", "qed (simp add: assms(1))"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] mix_pmf b y x \\<and> (mix_pmf b y x, x) \\<notin> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma neumann_3B_b:\n  assumes \"u \\<succ>[\\<R>] v\"\n  assumes \"\\<alpha> \\<in> {0<..<1}\"\n  shows \"u \\<succ>[\\<R>] mix_pmf \\<alpha> u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v \\<and>\n    (mix_pmf \\<alpha> u v, u) \\<notin> \\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v \\<and>\n    (mix_pmf \\<alpha> u v, u) \\<notin> \\<R>", "have *: \"preorder_on \\<P> \\<R> \\<and> rational_preference_axioms \\<P> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_on local.\\<P> \\<R> \\<and>\n    rational_preference_axioms local.\\<P> \\<R>", "by (metis (no_types) preference_def rational_preference_def rpr)"], ["proof (state)\nthis:\n  preorder_on local.\\<P> \\<R> \\<and>\n  rational_preference_axioms local.\\<P> \\<R>\n\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v \\<and>\n    (mix_pmf \\<alpha> u v, u) \\<notin> \\<R>", "have \"1 - \\<alpha> \\<in> {0<..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - \\<alpha> \\<in> {0<..1}", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 1 - \\<alpha> \\<in> {0<..1}", "by auto"], ["proof (state)\nthis:\n  1 - \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v \\<and>\n    (mix_pmf \\<alpha> u v, u) \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  1 - \\<alpha> \\<in> {0<..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  1 - \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v \\<and>\n    (mix_pmf \\<alpha> u v, u) \\<notin> \\<R>", "using * assms"], ["proof (prove)\nusing this:\n  1 - \\<alpha> \\<in> {0<..1}\n  preorder_on local.\\<P> \\<R> \\<and>\n  rational_preference_axioms local.\\<P> \\<R>\n  u \\<succeq>[\\<R>] v \\<and> (v, u) \\<notin> \\<R>\n  \\<alpha> \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v \\<and>\n    (mix_pmf \\<alpha> u v, u) \\<notin> \\<R>", "by (metis atLeastAtMost_iff greaterThanLessThan_iff \n        less_eq_real_def pmf_inverse_switch_eqals x_sg_y_sg_mpmf_right)"], ["proof (state)\nthis:\n  u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v \\<and>\n  (mix_pmf \\<alpha> u v, u) \\<notin> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma neumann_3B_b_non_strict:\n  assumes \"u \\<succeq>[\\<R>] v\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n  shows \"u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v", "have f2: \"mix_pmf \\<alpha> (u::'a pmf) v = mix_pmf (1 - \\<alpha>) v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> u v = mix_pmf (1 - \\<alpha>) v u", "using pmf_inverse_switch_eqals assms(2)"], ["proof (prove)\nusing this:\n  ?a \\<in> {0..1} \\<Longrightarrow>\n  mix_pmf ?a ?p ?q = mix_pmf (1 - ?a) ?q ?p\n  \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> u v = mix_pmf (1 - \\<alpha>) v u", "by auto"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> u v = mix_pmf (1 - \\<alpha>) v u\n\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v", "have \"1 - \\<alpha> \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - \\<alpha> \\<in> {0..1}", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. 1 - \\<alpha> \\<in> {0..1}", "by force"], ["proof (state)\nthis:\n  1 - \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v", "then"], ["proof (chain)\npicking this:\n  1 - \\<alpha> \\<in> {0..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  1 - \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v", "using f2 relation_in_carrier"], ["proof (prove)\nusing this:\n  1 - \\<alpha> \\<in> {0..1}\n  mix_pmf \\<alpha> u v = mix_pmf (1 - \\<alpha>) v u\n  ?x \\<succeq>[\\<R>] ?y \\<Longrightarrow>\n  ?x \\<in> local.\\<P> \\<and> ?y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v", "by (metis (no_types) assms(1) mix_pmf_preferred_independence set_pmf_mix_eq)"], ["proof (state)\nthis:\n  u \\<succeq>[\\<R>] mix_pmf \\<alpha> u v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma greater_mix_pmf_greater_step_1_aux: \n  assumes \"v \\<succ>[\\<R>] u\"\n  assumes \"\\<alpha> \\<in> {0<..<(1::real)}\"\n    and \"\\<beta> \\<in> {0<..<(1::real)}\"\n  assumes \"\\<beta> > \\<alpha>\"\n  shows \"(mix_pmf \\<beta> v u) \\<succ>[\\<R>] (mix_pmf \\<alpha> v u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "define t where\n    t: \"t = mix_pmf \\<beta> v u\""], ["proof (state)\nthis:\n  t = mix_pmf \\<beta> v u\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "obtain \\<gamma> where\n    g: \"\\<alpha> = \\<beta> * \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>.\n        \\<alpha> = \\<beta> * \\<gamma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(2) assms(4) greaterThanLessThan_iff \n        mult.commute nonzero_eq_divide_eq not_less_iff_gr_or_eq)"], ["proof (state)\nthis:\n  \\<alpha> = \\<beta> * \\<gamma>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "have g1: \"\\<gamma> > 0 \\<and> \\<gamma> < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<gamma> \\<and> \\<gamma> < 1", "by (metis (full_types) assms(2) assms(4) g greaterThanLessThan_iff \n        less_trans mult.right_neutral mult_less_cancel_left_pos not_le \n        sgn_le_0_iff sgn_pos zero_le_one zero_le_sgn_iff zero_less_mult_iff)"], ["proof (state)\nthis:\n  0 < \\<gamma> \\<and> \\<gamma> < 1\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "have t_in: \"mix_pmf \\<beta> v u \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<in> local.\\<P>", "by (meson assms(1) assms(3) mix_pmf_in_lotteries preference_def rational_preference_def rpr)"], ["proof (state)\nthis:\n  mix_pmf \\<beta> v u \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "have \"v \\<succ>[\\<R>] mix_pmf (1 - \\<beta>) v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<succeq>[\\<R>] mix_pmf (1 - \\<beta>) v u \\<and>\n    (mix_pmf (1 - \\<beta>) v u, v) \\<notin> \\<R>", "using x_sg_y_sg_mpmf_right[of u v \"1-\\<beta>\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<succeq>[\\<R>] v \\<and> (v, u) \\<notin> \\<R>;\n   1 - \\<beta> \\<in> {0<..1}\\<rbrakk>\n  \\<Longrightarrow> u \\<succeq>[\\<R>] mix_pmf (1 - \\<beta>) v u \\<and>\n                    (mix_pmf (1 - \\<beta>) v u, u) \\<notin> \\<R>\n  v \\<succeq>[\\<R>] u \\<and> (u, v) \\<notin> \\<R>\n  \\<alpha> \\<in> {0<..<1}\n  \\<beta> \\<in> {0<..<1}\n  \\<alpha> < \\<beta>\n\ngoal (1 subgoal):\n 1. v \\<succeq>[\\<R>] mix_pmf (1 - \\<beta>) v u \\<and>\n    (mix_pmf (1 - \\<beta>) v u, v) \\<notin> \\<R>", "by (metis atLeastAtMost_iff greaterThanAtMost_iff greaterThanLessThan_iff \n        less_eq_real_def pmf_inverse_switch_eqals x_sg_y_sg_mpmf_right)"], ["proof (state)\nthis:\n  v \\<succeq>[\\<R>] mix_pmf (1 - \\<beta>) v u \\<and>\n  (mix_pmf (1 - \\<beta>) v u, v) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "have \"t \\<succ>[\\<R>] u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<succeq>[\\<R>] u \\<and> (u, t) \\<notin> \\<R>", "using assms(1) assms(3) ind rpr sg_imp_mix_sg t"], ["proof (prove)\nusing this:\n  v \\<succeq>[\\<R>] u \\<and> (u, v) \\<notin> \\<R>\n  \\<beta> \\<in> {0<..<1}\n  independent_vnm local.\\<P> \\<R>\n  rational_preference local.\\<P> \\<R>\n  \\<lbrakk>?x \\<succeq>[?\\<R>] ?y \\<and> (?y, ?x) \\<notin> ?\\<R>;\n   rational_preference (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   independent_vnm (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   ?\\<alpha> \\<in> {0<..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y \\<succeq>[?\\<R>] ?y \\<and>\n                    (?y, mix_pmf ?\\<alpha> ?x ?y) \\<notin> ?\\<R>\n  t = mix_pmf \\<beta> v u\n\ngoal (1 subgoal):\n 1. t \\<succeq>[\\<R>] u \\<and> (u, t) \\<notin> \\<R>", "by fastforce"], ["proof (state)\nthis:\n  t \\<succeq>[\\<R>] u \\<and> (u, t) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "hence t_s: \"t \\<succ>[\\<R>] (mix_pmf \\<gamma> t u)\""], ["proof (prove)\nusing this:\n  t \\<succeq>[\\<R>] u \\<and> (u, t) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. t \\<succeq>[\\<R>] mix_pmf \\<gamma> t u \\<and>\n    (mix_pmf \\<gamma> t u, t) \\<notin> \\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<succeq>[\\<R>] u \\<and> (u, t) \\<notin> \\<R> \\<Longrightarrow>\n    t \\<succeq>[\\<R>] mix_pmf \\<gamma> t u \\<and>\n    (mix_pmf \\<gamma> t u, t) \\<notin> \\<R>", "have \"(mix_pmf \\<gamma> t u) \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<gamma> t u \\<in> local.\\<P>", "by (metis assms(1) assms(3) atLeastAtMost_iff g1 mix_in_lot mix_pmf_in_lotteries \n          not_less order.asym preference_def rational_preference_def rpr t)"], ["proof (state)\nthis:\n  mix_pmf \\<gamma> t u \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. t \\<succeq>[\\<R>] u \\<and> (u, t) \\<notin> \\<R> \\<Longrightarrow>\n    t \\<succeq>[\\<R>] mix_pmf \\<gamma> t u \\<and>\n    (mix_pmf \\<gamma> t u, t) \\<notin> \\<R>", "have \"t \\<succ>[\\<R>] mix_pmf \\<gamma> (mix_pmf \\<beta> v u) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<succeq>[\\<R>] mix_pmf \\<gamma> (mix_pmf \\<beta> v u) u \\<and>\n    (mix_pmf \\<gamma> (mix_pmf \\<beta> v u) u, t) \\<notin> \\<R>", "using neumann_3B_b[of t u \\<gamma>] assms t g1"], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<succeq>[\\<R>] u \\<and> (u, t) \\<notin> \\<R>;\n   \\<gamma> \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> t \\<succeq>[\\<R>] mix_pmf \\<gamma> t u \\<and>\n                    (mix_pmf \\<gamma> t u, t) \\<notin> \\<R>\n  v \\<succeq>[\\<R>] u \\<and> (u, v) \\<notin> \\<R>\n  \\<alpha> \\<in> {0<..<1}\n  \\<beta> \\<in> {0<..<1}\n  \\<alpha> < \\<beta>\n  t = mix_pmf \\<beta> v u\n  0 < \\<gamma> \\<and> \\<gamma> < 1\n\ngoal (1 subgoal):\n 1. t \\<succeq>[\\<R>] mix_pmf \\<gamma> (mix_pmf \\<beta> v u) u \\<and>\n    (mix_pmf \\<gamma> (mix_pmf \\<beta> v u) u, t) \\<notin> \\<R>", "by (meson greaterThanAtMost_iff greaterThanLessThan_iff \n          ind less_eq_real_def rpr sg_imp_mix_sg)"], ["proof (state)\nthis:\n  t \\<succeq>[\\<R>] mix_pmf \\<gamma> (mix_pmf \\<beta> v u) u \\<and>\n  (mix_pmf \\<gamma> (mix_pmf \\<beta> v u) u, t) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. t \\<succeq>[\\<R>] u \\<and> (u, t) \\<notin> \\<R> \\<Longrightarrow>\n    t \\<succeq>[\\<R>] mix_pmf \\<gamma> t u \\<and>\n    (mix_pmf \\<gamma> t u, t) \\<notin> \\<R>", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<succeq>[\\<R>] mix_pmf \\<gamma> (mix_pmf \\<beta> v u) u \\<and>\n  (mix_pmf \\<gamma> (mix_pmf \\<beta> v u) u, t) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. t \\<succeq>[\\<R>] mix_pmf \\<gamma> t u \\<and>\n    (mix_pmf \\<gamma> t u, t) \\<notin> \\<R>", "using t"], ["proof (prove)\nusing this:\n  t \\<succeq>[\\<R>] mix_pmf \\<gamma> (mix_pmf \\<beta> v u) u \\<and>\n  (mix_pmf \\<gamma> (mix_pmf \\<beta> v u) u, t) \\<notin> \\<R>\n  t = mix_pmf \\<beta> v u\n\ngoal (1 subgoal):\n 1. t \\<succeq>[\\<R>] mix_pmf \\<gamma> t u \\<and>\n    (mix_pmf \\<gamma> t u, t) \\<notin> \\<R>", "by blast"], ["proof (state)\nthis:\n  t \\<succeq>[\\<R>] mix_pmf \\<gamma> t u \\<and>\n  (mix_pmf \\<gamma> t u, t) \\<notin> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<succeq>[\\<R>] mix_pmf \\<gamma> t u \\<and>\n  (mix_pmf \\<gamma> t u, t) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "from product_mix_pmf_prob_distrib[of _ \\<beta> v u] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> {0..1}; \\<beta> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?a (mix_pmf \\<beta> v u) u =\n                    mix_pmf (?a * \\<beta>) v u\n  v \\<succeq>[\\<R>] u \\<and> (u, v) \\<notin> \\<R>\n  \\<alpha> \\<in> {0<..<1}\n  \\<beta> \\<in> {0<..<1}\n  \\<alpha> < \\<beta>", "have \"mix_pmf \\<beta> v u \\<succ>[\\<R>] mix_pmf \\<alpha> v u\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> {0..1}; \\<beta> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?a (mix_pmf \\<beta> v u) u =\n                    mix_pmf (?a * \\<beta>) v u\n  v \\<succeq>[\\<R>] u \\<and> (u, v) \\<notin> \\<R>\n  \\<alpha> \\<in> {0<..<1}\n  \\<beta> \\<in> {0<..<1}\n  \\<alpha> < \\<beta>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "by (metis t_s atLeastAtMost_iff g g1 greaterThanLessThan_iff less_eq_real_def mult.commute t)"], ["proof (state)\nthis:\n  mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n  (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n  (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n  (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n    (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<beta> v u \\<succeq>[\\<R>] mix_pmf \\<alpha> v u \\<and>\n  (mix_pmf \\<alpha> v u, mix_pmf \\<beta> v u) \\<notin> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open> This lemma is in called step 1 in literature. \nIn Von Neumann and Morgenstern's book this is A:A (albeit more general) \\<close>"], ["", "lemma step_1_most_general:\n  assumes \"x \\<succ>[\\<R>] y\"\n  assumes \"\\<alpha> \\<in> {0..(1::real)}\"\n    and \"\\<beta> \\<in> {0..(1::real)}\"\n  assumes \"\\<alpha> > \\<beta>\"\n  shows \"(mix_pmf \\<alpha> x y) \\<succ>[\\<R>] (mix_pmf \\<beta> x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "consider (ex) \"\\<alpha> = 1 \\<and> \\<beta> = 0\" | (m) \"\\<alpha> \\<noteq> 1 \\<or> \\<beta> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> = 1 \\<and> \\<beta> = 0 \\<Longrightarrow> thesis;\n     \\<alpha> \\<noteq> 1 \\<or> \\<beta> \\<noteq> 0 \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<alpha> = 1 \\<and> \\<beta> = 0 \\<Longrightarrow> ?thesis;\n   \\<alpha> \\<noteq> 1 \\<or> \\<beta> \\<noteq> 0 \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<alpha> = 1 \\<and> \\<beta> = 0 \\<Longrightarrow> ?thesis;\n   \\<alpha> \\<noteq> 1 \\<or> \\<beta> \\<noteq> 0 \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<alpha> = 1 \\<and> \\<beta> = 0 \\<Longrightarrow> ?thesis;\n   \\<alpha> \\<noteq> 1 \\<or> \\<beta> \\<noteq> 0 \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> = 1 \\<and> \\<beta> = 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n 2. \\<alpha> \\<noteq> 1 \\<or> \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "case m"], ["proof (state)\nthis:\n  \\<alpha> \\<noteq> 1 \\<or> \\<beta> \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<alpha> = 1 \\<and> \\<beta> = 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n 2. \\<alpha> \\<noteq> 1 \\<or> \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "consider  \"\\<beta> = 0\" |  \"\\<beta> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta> = 0 \\<Longrightarrow> thesis;\n     \\<beta> \\<noteq> 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<beta> = 0 \\<Longrightarrow> ?thesis;\n   \\<beta> \\<noteq> 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<alpha> = 1 \\<and> \\<beta> = 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n 2. \\<alpha> \\<noteq> 1 \\<or> \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<beta> = 0 \\<Longrightarrow> ?thesis;\n   \\<beta> \\<noteq> 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<beta> = 0 \\<Longrightarrow> ?thesis;\n   \\<beta> \\<noteq> 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<beta> = 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n 2. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "case 1"], ["proof (state)\nthis:\n  \\<beta> = 0\n\ngoal (2 subgoals):\n 1. \\<beta> = 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n 2. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  \\<beta> = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> = 0\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "using assms(1) assms(2) assms(4) ind rpr sg_imp_mix_sg"], ["proof (prove)\nusing this:\n  \\<beta> = 0\n  x \\<succeq>[\\<R>] y \\<and> (y, x) \\<notin> \\<R>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> < \\<alpha>\n  independent_vnm local.\\<P> \\<R>\n  rational_preference local.\\<P> \\<R>\n  \\<lbrakk>?x \\<succeq>[?\\<R>] ?y \\<and> (?y, ?x) \\<notin> ?\\<R>;\n   rational_preference (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   independent_vnm (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   ?\\<alpha> \\<in> {0<..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y \\<succeq>[?\\<R>] ?y \\<and>\n                    (?y, mix_pmf ?\\<alpha> ?x ?y) \\<notin> ?\\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "by fastforce"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n  (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "case 2"], ["proof (state)\nthis:\n  \\<beta> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "let ?d = \"(\\<beta>/\\<alpha>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "have sg: \"(mix_pmf \\<alpha> x y) \\<succ>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "using assms(1) assms(2) assms(3) assms(4) ind rpr sg_imp_mix_sg"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y \\<and> (y, x) \\<notin> \\<R>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n  \\<beta> < \\<alpha>\n  independent_vnm local.\\<P> \\<R>\n  rational_preference local.\\<P> \\<R>\n  \\<lbrakk>?x \\<succeq>[?\\<R>] ?y \\<and> (?y, ?x) \\<notin> ?\\<R>;\n   rational_preference (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   independent_vnm (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   ?\\<alpha> \\<in> {0<..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y \\<succeq>[?\\<R>] ?y \\<and>\n                    (?y, mix_pmf ?\\<alpha> ?x ?y) \\<notin> ?\\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "by fastforce"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n  (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "have a: \"\\<alpha> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<alpha>", "using assms(3) assms(4)"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> {0..1}\n  \\<beta> < \\<alpha>\n\ngoal (1 subgoal):\n 1. 0 < \\<alpha>", "by auto"], ["proof (state)\nthis:\n  0 < \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  0 < \\<alpha>", "have div_in: \"?d \\<in> {0<..1}\""], ["proof (prove)\nusing this:\n  0 < \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<beta> / \\<alpha> \\<in> {0<..1}", "using assms(3) assms(4) 2"], ["proof (prove)\nusing this:\n  0 < \\<alpha>\n  \\<beta> \\<in> {0..1}\n  \\<beta> < \\<alpha>\n  \\<beta> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<beta> / \\<alpha> \\<in> {0<..1}", "by auto"], ["proof (state)\nthis:\n  \\<beta> / \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "have mx_p: \"(mix_pmf \\<alpha> x y) \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<in> local.\\<P>", "by (meson sg preference_def rational_preference_def rpr)"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> x y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "have y_P: \"y \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> local.\\<P>", "by (meson assms(1) preference_def rational_preference_def rpr)"], ["proof (state)\nthis:\n  y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "hence \"(mix_pmf ?d (mix_pmf \\<alpha> x y) y) \\<in> \\<P>\""], ["proof (prove)\nusing this:\n  y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. mix_pmf (\\<beta> / \\<alpha>) (mix_pmf \\<alpha> x y) y \\<in> local.\\<P>", "using div_in mx_p"], ["proof (prove)\nusing this:\n  y \\<in> local.\\<P>\n  \\<beta> / \\<alpha> \\<in> {0<..1}\n  mix_pmf \\<alpha> x y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. mix_pmf (\\<beta> / \\<alpha>) (mix_pmf \\<alpha> x y) y \\<in> local.\\<P>", "by (simp add: mix_in_lot)"], ["proof (state)\nthis:\n  mix_pmf (\\<beta> / \\<alpha>) (mix_pmf \\<alpha> x y) y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "have \" mix_pmf \\<beta> (mix_pmf \\<alpha> x y) y \\<succ>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> (mix_pmf \\<alpha> x y) y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<beta> (mix_pmf \\<alpha> x y) y) \\<notin> \\<R>", "using sg_imp_mix_sg[of \"(mix_pmf \\<alpha> x y)\" y \\<R> outcomes \\<beta>] sg div_in rpr ind\n          a assms(2) \"2\" assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n           (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>;\n   rational_preference local.\\<P> \\<R>; independent_vnm local.\\<P> \\<R>;\n   \\<beta> \\<in> {0<..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<beta> (mix_pmf \\<alpha> x y)\n                     y \\<succeq>[\\<R>] y \\<and>\n                    (y, mix_pmf \\<beta> (mix_pmf \\<alpha> x y) y)\n                    \\<notin> \\<R>\n  mix_pmf \\<alpha> x y \\<succeq>[\\<R>] y \\<and>\n  (y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n  \\<beta> / \\<alpha> \\<in> {0<..1}\n  rational_preference local.\\<P> \\<R>\n  independent_vnm local.\\<P> \\<R>\n  0 < \\<alpha>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<noteq> 0\n  \\<beta> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> (mix_pmf \\<alpha> x y) y \\<succeq>[\\<R>] y \\<and>\n    (y, mix_pmf \\<beta> (mix_pmf \\<alpha> x y) y) \\<notin> \\<R>", "by auto"], ["proof (state)\nthis:\n  mix_pmf \\<beta> (mix_pmf \\<alpha> x y) y \\<succeq>[\\<R>] y \\<and>\n  (y, mix_pmf \\<beta> (mix_pmf \\<alpha> x y) y) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "have al1: \"\\<forall>r \\<in> \\<P>. (mix_pmf \\<alpha> x r) \\<succ>[\\<R>] (mix_pmf \\<alpha> y r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>local.\\<P>.\n       mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r \\<and>\n       (mix_pmf \\<alpha> y r, mix_pmf \\<alpha> x r) \\<notin> \\<R>", "by (meson a assms(1) assms(2) atLeastAtMost_iff greaterThanAtMost_iff ind \n            independece_dest_alt preference.not_outside rational_preference_def rpr y_P)"], ["proof (state)\nthis:\n  \\<forall>r\\<in>local.\\<P>.\n     mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r \\<and>\n     (mix_pmf \\<alpha> y r, mix_pmf \\<alpha> x r) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>local.\\<P>.\n     mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r \\<and>\n     (mix_pmf \\<alpha> y r, mix_pmf \\<alpha> x r) \\<notin> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>local.\\<P>.\n     mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r \\<and>\n     (mix_pmf \\<alpha> y r, mix_pmf \\<alpha> x r) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "using greater_mix_pmf_greater_step_1_aux assms"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>local.\\<P>.\n     mix_pmf \\<alpha> x r \\<succeq>[\\<R>] mix_pmf \\<alpha> y r \\<and>\n     (mix_pmf \\<alpha> y r, mix_pmf \\<alpha> x r) \\<notin> \\<R>\n  \\<lbrakk>?v \\<succeq>[\\<R>] ?u \\<and> (?u, ?v) \\<notin> \\<R>;\n   ?\\<alpha> \\<in> {0<..<1}; ?\\<beta> \\<in> {0<..<1};\n   ?\\<alpha> < ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<beta> ?v\n                     ?u \\<succeq>[\\<R>] mix_pmf ?\\<alpha> ?v ?u \\<and>\n                    (mix_pmf ?\\<alpha> ?v ?u, mix_pmf ?\\<beta> ?v ?u)\n                    \\<notin> \\<R>\n  x \\<succeq>[\\<R>] y \\<and> (y, x) \\<notin> \\<R>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n  \\<beta> < \\<alpha>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "by (metis a div_in divide_less_eq_1_pos greaterThanAtMost_iff \n            greaterThanLessThan_iff mix_pmf_comp_with_dif_equiv neumann_3B_b sg)"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n  (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n  (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. \\<alpha> = 1 \\<and> \\<beta> = 0 \\<Longrightarrow>\n    mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n    (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>", "qed (simp add: assms(1))"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y \\<and>\n  (mix_pmf \\<beta> x y, mix_pmf \\<alpha> x y) \\<notin> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Kreps refers to this lemma as 5.6 c. \n       The lemma after that is also significant.\\<close>"], ["", "lemma approx_remains_after_same_comp:\n  assumes \"p \\<approx>[\\<R>] q\"\n    and \"r \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  shows \"mix_pmf \\<alpha> p r \\<approx>[\\<R>] mix_pmf \\<alpha> q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<approx>[\\<R>] mix_pmf \\<alpha> q r", "using approx_indep_ge assms(1) assms(2) assms(3) ind rpr"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<approx>[?\\<R>] ?y; ?\\<alpha> \\<in> {0..1};\n   rational_preference (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   independent_vnm (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>r\\<in>Neumann_Morgenstern_Utility_Theorem.\\<P>\n                                    ?outcomes.\n                       mix_pmf ?\\<alpha> ?y\n                        r \\<succeq>[?\\<R>] mix_pmf ?\\<alpha> ?x r\n  p \\<approx>[\\<R>] q\n  r \\<in> local.\\<P>\n  \\<alpha> \\<in> {0..1}\n  independent_vnm local.\\<P> \\<R>\n  rational_preference local.\\<P> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<approx>[\\<R>] mix_pmf \\<alpha> q r", "by blast"], ["", "text \\<open> This lemma is the symmetric version of the previous lemma. \n       This lemma is never mentioned in literature anywhere. \n       Even though it looks trivial now, due to the asymmetric nature of the \n       independence axiom, it is not so trivial, and definitely worth mentioning. \\<close>"], ["", "lemma approx_remains_after_same_comp_left:\n  assumes \"p \\<approx>[\\<R>] q\"\n    and \"r \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  shows \"mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q", "have 1: \"\\<alpha> \\<le> 1 \\<and> \\<alpha> \\<ge> 0\" \"1 - \\<alpha> \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> 1 \\<and> 0 \\<le> \\<alpha> &&& 1 - \\<alpha> \\<in> {0..1}", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> 1 \\<and> 0 \\<le> \\<alpha> &&& 1 - \\<alpha> \\<in> {0..1}", "by auto+"], ["proof (state)\nthis:\n  \\<alpha> \\<le> 1 \\<and> 0 \\<le> \\<alpha>\n  1 - \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q", "have fst: \"mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf (1-\\<alpha>) p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf (1 - \\<alpha>) p r", "using assms"], ["proof (prove)\nusing this:\n  p \\<approx>[\\<R>] q\n  r \\<in> local.\\<P>\n  \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf (1 - \\<alpha>) p r", "by (metis mix_in_lot pmf_inverse_switch_eqals \n    rational_preference.compl relation_in_carrier rpr)"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf (1 - \\<alpha>) p r\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q", "moreover"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf (1 - \\<alpha>) p r\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q", "have \"mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q", "using approx_remains_after_same_comp[of _ _ _ \\<alpha>] pmf_inverse_switch_eqals[of \\<alpha> p q] 1 \n      pmf_inverse_switch_eqals rpr mix_pmf_preferred_independence[of _ \\<alpha> _ _]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<approx>[\\<R>] ?q; ?r \\<in> local.\\<P>;\n   \\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<alpha> ?p\n                     ?r \\<approx>[\\<R>] mix_pmf \\<alpha> ?q ?r\n  \\<alpha> \\<in> {0..1} \\<Longrightarrow>\n  mix_pmf \\<alpha> p q = mix_pmf (1 - \\<alpha>) q p\n  \\<alpha> \\<le> 1 \\<and> 0 \\<le> \\<alpha>\n  1 - \\<alpha> \\<in> {0..1}\n  ?a \\<in> {0..1} \\<Longrightarrow>\n  mix_pmf ?a ?p ?q = mix_pmf (1 - ?a) ?q ?p\n  rational_preference local.\\<P> \\<R>\n  \\<lbrakk>?r \\<in> local.\\<P>; \\<alpha> \\<in> {0..1};\n   ?p \\<succeq>[\\<R>] ?q\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<alpha> ?p\n                     ?r \\<succeq>[\\<R>] mix_pmf \\<alpha> ?q ?r\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q", "by (metis assms(1) assms(2) assms(3) mix_pmf_preferred_independence)"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q", "thus ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> r p \\<approx>[\\<R>] mix_pmf \\<alpha> r q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mix_of_preferred_is_preferred:\n  assumes \"p \\<succeq>[\\<R>] w\"\n  assumes \"q \\<succeq>[\\<R>] w\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n  shows \"mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "consider \"p \\<succeq>[\\<R>] q\" | \"q \\<succeq>[\\<R>] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<succeq>[\\<R>] q \\<Longrightarrow> thesis;\n     q \\<succeq>[\\<R>] p \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using rpr assms(1) assms(2) rational_preference.compl relation_in_carrier"], ["proof (prove)\nusing this:\n  rational_preference local.\\<P> \\<R>\n  p \\<succeq>[\\<R>] w\n  q \\<succeq>[\\<R>] w\n  rational_preference ?carrier ?relation \\<Longrightarrow>\n  \\<forall>x\\<in>?carrier.\n     \\<forall>y\\<in>?carrier.\n        x \\<succeq>[?relation] y \\<or> y \\<succeq>[?relation] x\n  ?x \\<succeq>[\\<R>] ?y \\<Longrightarrow>\n  ?x \\<in> local.\\<P> \\<and> ?y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<succeq>[\\<R>] q \\<Longrightarrow> thesis;\n     q \\<succeq>[\\<R>] p \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<succeq>[\\<R>] q \\<Longrightarrow> ?thesis;\n   q \\<succeq>[\\<R>] p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<succeq>[\\<R>] q \\<Longrightarrow> ?thesis;\n   q \\<succeq>[\\<R>] p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<succeq>[\\<R>] q \\<Longrightarrow> ?thesis;\n   q \\<succeq>[\\<R>] p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w\n 2. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "case 1"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w\n 2. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "have \"mix_pmf \\<alpha> p q \\<succeq>[\\<R>] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] q", "using \"1\" assms(3) geq_imp_mix_geq_right ind rpr"], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] q\n  \\<alpha> \\<in> {0..1}\n  \\<lbrakk>?x \\<succeq>[?\\<R>] ?y;\n   rational_preference (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   independent_vnm (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y \\<succeq>[?\\<R>] ?y\n  independent_vnm local.\\<P> \\<R>\n  rational_preference local.\\<P> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] q", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] q\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w\n 2. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "moreover"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] q\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w\n 2. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "have \"q \\<succeq>[\\<R>] w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] w", "using assms"], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] w\n  q \\<succeq>[\\<R>] w\n  \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] w", "by auto"], ["proof (state)\nthis:\n  q \\<succeq>[\\<R>] w\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w\n 2. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "ultimately"], ["proof (chain)\npicking this:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] w", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] w\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "using rpr preference.transitivity[of \\<P> \\<R>]"], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] w\n  rational_preference local.\\<P> \\<R>\n  preference local.\\<P> \\<R> \\<Longrightarrow> trans \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "by (meson rational_preference_def transE)"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "case 2"], ["proof (state)\nthis:\n  q \\<succeq>[\\<R>] p\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "have \"mix_pmf \\<alpha> p q \\<succeq>[\\<R>] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] p", "using \"2\" assms geq_imp_mix_geq_left ind rpr"], ["proof (prove)\nusing this:\n  q \\<succeq>[\\<R>] p\n  p \\<succeq>[\\<R>] w\n  q \\<succeq>[\\<R>] w\n  \\<alpha> \\<in> {0..1}\n  \\<lbrakk>?x \\<succeq>[?\\<R>] ?y;\n   rational_preference (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   independent_vnm (Neumann_Morgenstern_Utility_Theorem.\\<P> ?outcomes)\n    ?\\<R>;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?y ?x \\<succeq>[?\\<R>] ?y\n  independent_vnm local.\\<P> \\<R>\n  rational_preference local.\\<P> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] p", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] p\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "moreover"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] p\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "have \"p \\<succeq>[\\<R>] w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] w", "using assms"], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] w\n  q \\<succeq>[\\<R>] w\n  \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] w", "by auto"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] w\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "ultimately"], ["proof (chain)\npicking this:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] p\n  p \\<succeq>[\\<R>] w", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] p\n  p \\<succeq>[\\<R>] w\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "using rpr preference.transitivity[of \\<P> \\<R>]"], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] p\n  p \\<succeq>[\\<R>] w\n  rational_preference local.\\<P> \\<R>\n  preference local.\\<P> \\<R> \\<Longrightarrow> trans \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w", "by (meson rational_preference_def transE)"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p q \\<succeq>[\\<R>] w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mix_of_not_preferred_is_not_preferred:\n  assumes \"w \\<succeq>[\\<R>] p\"\n  assumes \"w \\<succeq>[\\<R>] q\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n  shows \"w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "consider \"p \\<succeq>[\\<R>] q\" | \"q \\<succeq>[\\<R>] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<succeq>[\\<R>] q \\<Longrightarrow> thesis;\n     q \\<succeq>[\\<R>] p \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using rpr assms(1) assms(2) rational_preference.compl relation_in_carrier"], ["proof (prove)\nusing this:\n  rational_preference local.\\<P> \\<R>\n  w \\<succeq>[\\<R>] p\n  w \\<succeq>[\\<R>] q\n  rational_preference ?carrier ?relation \\<Longrightarrow>\n  \\<forall>x\\<in>?carrier.\n     \\<forall>y\\<in>?carrier.\n        x \\<succeq>[?relation] y \\<or> y \\<succeq>[?relation] x\n  ?x \\<succeq>[\\<R>] ?y \\<Longrightarrow>\n  ?x \\<in> local.\\<P> \\<and> ?y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<succeq>[\\<R>] q \\<Longrightarrow> thesis;\n     q \\<succeq>[\\<R>] p \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<succeq>[\\<R>] q \\<Longrightarrow> ?thesis;\n   q \\<succeq>[\\<R>] p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<succeq>[\\<R>] q \\<Longrightarrow> ?thesis;\n   q \\<succeq>[\\<R>] p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<succeq>[\\<R>] q \\<Longrightarrow> ?thesis;\n   q \\<succeq>[\\<R>] p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n 2. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "case 1"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n 2. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "moreover"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n 2. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "have \"p \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "using assms(3) neumann_3B_b_non_strict calculation"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0..1}\n  \\<lbrakk>?u \\<succeq>[\\<R>] ?v; ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> ?u \\<succeq>[\\<R>] mix_pmf ?\\<alpha> ?u ?v\n  p \\<succeq>[\\<R>] q\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "by blast"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n 2. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "moreover"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n 2. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "using rpr preference.transitivity[of \\<P> \\<R>]"], ["proof (prove)\nusing this:\n  rational_preference local.\\<P> \\<R>\n  preference local.\\<P> \\<R> \\<Longrightarrow> trans \\<R>\n\ngoal (1 subgoal):\n 1. w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "by (meson assms(1) calculation(2) rational_preference_def transE)"], ["proof (state)\nthis:\n  w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "case 2"], ["proof (state)\nthis:\n  q \\<succeq>[\\<R>] p\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "moreover"], ["proof (state)\nthis:\n  q \\<succeq>[\\<R>] p\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "have \"q \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "using assms(3) neumann_3B_b_non_strict calculation"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0..1}\n  \\<lbrakk>?u \\<succeq>[\\<R>] ?v; ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> ?u \\<succeq>[\\<R>] mix_pmf ?\\<alpha> ?u ?v\n  q \\<succeq>[\\<R>] p\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "by (metis mix_pmf_preferred_independence relation_in_carrier set_pmf_mix_eq)"], ["proof (state)\nthis:\n  q \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "moreover"], ["proof (state)\nthis:\n  q \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n\ngoal (1 subgoal):\n 1. q \\<succeq>[\\<R>] p \\<Longrightarrow>\n    w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "using rpr preference.transitivity[of \\<P> \\<R>]"], ["proof (prove)\nusing this:\n  rational_preference local.\\<P> \\<R>\n  preference local.\\<P> \\<R> \\<Longrightarrow> trans \\<R>\n\ngoal (1 subgoal):\n 1. w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q", "by (meson assms(2) calculation(2) rational_preference_def transE)"], ["proof (state)\nthis:\n  w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w \\<succeq>[\\<R>] mix_pmf \\<alpha> p q\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "definition degenerate_lotteries where\n  \"degenerate_lotteries = {x \\<in> \\<P>. card (set_pmf x) = 1}\""], ["", "private"], ["", "definition best where\n  \"best = {x \\<in> \\<P>. (\\<forall>y \\<in> \\<P>. x \\<succeq>[\\<R>] y)}\""], ["", "private"], ["", "definition worst where\n  \"worst = {x \\<in> \\<P>. (\\<forall>y \\<in> \\<P>. y \\<succeq>[\\<R>] x)}\""], ["", "lemma degenerate_total: \n  \"\\<forall>e \\<in> degenerate_lotteries. \\<forall>m \\<in> \\<P>. e \\<succeq>[\\<R>] m \\<or> m \\<succeq>[\\<R>] e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>degenerate_lotteries.\n       \\<forall>m\\<in>local.\\<P>.\n          e \\<succeq>[\\<R>] m \\<or> m \\<succeq>[\\<R>] e", "using degenerate_lotteries_def rational_preference.compl rpr"], ["proof (prove)\nusing this:\n  degenerate_lotteries = {x \\<in> local.\\<P>. card (set_pmf x) = 1}\n  rational_preference ?carrier ?relation \\<Longrightarrow>\n  \\<forall>x\\<in>?carrier.\n     \\<forall>y\\<in>?carrier.\n        x \\<succeq>[?relation] y \\<or> y \\<succeq>[?relation] x\n  rational_preference local.\\<P> \\<R>\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>degenerate_lotteries.\n       \\<forall>m\\<in>local.\\<P>.\n          e \\<succeq>[\\<R>] m \\<or> m \\<succeq>[\\<R>] e", "by fastforce"], ["", "lemma degen_outcome_cardinalities:\n  \"card degenerate_lotteries = card outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card degenerate_lotteries = card outcomes", "using card_degen_lotteries_equals_outcomes degenerate_lotteries_def"], ["proof (prove)\nusing this:\n  card\n   {x \\<in> Neumann_Morgenstern_Utility_Theorem.\\<P> ?out.\n    card (set_pmf x) = 1} =\n  card ?out\n  degenerate_lotteries = {x \\<in> local.\\<P>. card (set_pmf x) = 1}\n\ngoal (1 subgoal):\n 1. card degenerate_lotteries = card outcomes", "by auto"], ["", "lemma degenerate_lots_subset_all: \"degenerate_lotteries \\<subseteq> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degenerate_lotteries \\<subseteq> local.\\<P>", "by (simp add: degenerate_lotteries_def)"], ["", "lemma alt_definition_of_degenerate_lotteries[iff]:\n  \"{return_pmf x |x. x\\<in> outcomes} = degenerate_lotteries\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {return_pmf x |x. x \\<in> outcomes} = degenerate_lotteries", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {return_pmf x |x. x \\<in> outcomes} \\<subseteq> degenerate_lotteries\n 2. degenerate_lotteries \\<subseteq> {return_pmf x |x. x \\<in> outcomes}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {return_pmf x |x. x \\<in> outcomes} \\<subseteq> degenerate_lotteries\n 2. degenerate_lotteries \\<subseteq> {return_pmf x |x. x \\<in> outcomes}", "have \"\\<forall>x \\<in> {return_pmf x |x. x \\<in> outcomes}. x \\<in> degenerate_lotteries\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{return_pmf x |x. x \\<in> outcomes}.\n       x \\<in> degenerate_lotteries", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {return_pmf x |x. x \\<in> outcomes} \\<Longrightarrow>\n       x \\<in> degenerate_lotteries", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {return_pmf x |x. x \\<in> outcomes} \\<Longrightarrow>\n       x \\<in> degenerate_lotteries", "assume a: \"x \\<in> {return_pmf x |x. x \\<in> outcomes}\""], ["proof (state)\nthis:\n  x \\<in> {return_pmf x |x. x \\<in> outcomes}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {return_pmf x |x. x \\<in> outcomes} \\<Longrightarrow>\n       x \\<in> degenerate_lotteries", "then"], ["proof (chain)\npicking this:\n  x \\<in> {return_pmf x |x. x \\<in> outcomes}", "have \"card (set_pmf x) = 1\""], ["proof (prove)\nusing this:\n  x \\<in> {return_pmf x |x. x \\<in> outcomes}\n\ngoal (1 subgoal):\n 1. card (set_pmf x) = 1", "by auto"], ["proof (state)\nthis:\n  card (set_pmf x) = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {return_pmf x |x. x \\<in> outcomes} \\<Longrightarrow>\n       x \\<in> degenerate_lotteries", "moreover"], ["proof (state)\nthis:\n  card (set_pmf x) = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {return_pmf x |x. x \\<in> outcomes} \\<Longrightarrow>\n       x \\<in> degenerate_lotteries", "have \"set_pmf x \\<subseteq> outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf x \\<subseteq> outcomes", "using a set_pmf_subset_singleton"], ["proof (prove)\nusing this:\n  x \\<in> {return_pmf x |x. x \\<in> outcomes}\n  (set_pmf ?p \\<subseteq> {?x}) = (?p = return_pmf ?x)\n\ngoal (1 subgoal):\n 1. set_pmf x \\<subseteq> outcomes", "by auto"], ["proof (state)\nthis:\n  set_pmf x \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {return_pmf x |x. x \\<in> outcomes} \\<Longrightarrow>\n       x \\<in> degenerate_lotteries", "moreover"], ["proof (state)\nthis:\n  set_pmf x \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {return_pmf x |x. x \\<in> outcomes} \\<Longrightarrow>\n       x \\<in> degenerate_lotteries", "have \"x \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> local.\\<P>", "by (simp add: lotteries_on_def calculation)"], ["proof (state)\nthis:\n  x \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {return_pmf x |x. x \\<in> outcomes} \\<Longrightarrow>\n       x \\<in> degenerate_lotteries", "ultimately"], ["proof (chain)\npicking this:\n  card (set_pmf x) = 1\n  set_pmf x \\<subseteq> outcomes\n  x \\<in> local.\\<P>", "show \"x \\<in> degenerate_lotteries\""], ["proof (prove)\nusing this:\n  card (set_pmf x) = 1\n  set_pmf x \\<subseteq> outcomes\n  x \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. x \\<in> degenerate_lotteries", "by (simp add: degenerate_lotteries_def)"], ["proof (state)\nthis:\n  x \\<in> degenerate_lotteries\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{return_pmf x |x. x \\<in> outcomes}.\n     x \\<in> degenerate_lotteries\n\ngoal (2 subgoals):\n 1. {return_pmf x |x. x \\<in> outcomes} \\<subseteq> degenerate_lotteries\n 2. degenerate_lotteries \\<subseteq> {return_pmf x |x. x \\<in> outcomes}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{return_pmf x |x. x \\<in> outcomes}.\n     x \\<in> degenerate_lotteries", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{return_pmf x |x. x \\<in> outcomes}.\n     x \\<in> degenerate_lotteries\n\ngoal (1 subgoal):\n 1. {return_pmf x |x. x \\<in> outcomes} \\<subseteq> degenerate_lotteries", "by blast"], ["proof (state)\nthis:\n  {return_pmf x |x. x \\<in> outcomes} \\<subseteq> degenerate_lotteries\n\ngoal (1 subgoal):\n 1. degenerate_lotteries \\<subseteq> {return_pmf x |x. x \\<in> outcomes}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degenerate_lotteries \\<subseteq> {return_pmf x |x. x \\<in> outcomes}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. degenerate_lotteries \\<subseteq> {return_pmf x |x. x \\<in> outcomes}", "have \"\\<forall>x \\<in> degenerate_lotteries. x \\<in> {return_pmf x |x. x \\<in> outcomes}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>degenerate_lotteries.\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "assume a: \"x \\<in> degenerate_lotteries\""], ["proof (state)\nthis:\n  x \\<in> degenerate_lotteries\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "hence \"card (set_pmf x) = 1\""], ["proof (prove)\nusing this:\n  x \\<in> degenerate_lotteries\n\ngoal (1 subgoal):\n 1. card (set_pmf x) = 1", "using degenerate_lotteries_def"], ["proof (prove)\nusing this:\n  x \\<in> degenerate_lotteries\n  degenerate_lotteries = {x \\<in> local.\\<P>. card (set_pmf x) = 1}\n\ngoal (1 subgoal):\n 1. card (set_pmf x) = 1", "by blast"], ["proof (state)\nthis:\n  card (set_pmf x) = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "moreover"], ["proof (state)\nthis:\n  card (set_pmf x) = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "have \"set_pmf x \\<subseteq> outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf x \\<subseteq> outcomes", "by (meson a degenerate_lots_subset_all subset_iff support_in_outcomes)"], ["proof (state)\nthis:\n  set_pmf x \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "moreover"], ["proof (state)\nthis:\n  set_pmf x \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "obtain e where \"{e} = set_pmf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e. {e} = set_pmf x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  card (set_pmf x) = 1\n  set_pmf x \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. (\\<And>e. {e} = set_pmf x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis card_1_singletonE)"], ["proof (state)\nthis:\n  {e} = set_pmf x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "moreover"], ["proof (state)\nthis:\n  {e} = set_pmf x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "have \"e \\<in> outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> outcomes", "using calculation(2) calculation(3)"], ["proof (prove)\nusing this:\n  set_pmf x \\<subseteq> outcomes\n  {e} = set_pmf x\n\ngoal (1 subgoal):\n 1. e \\<in> outcomes", "by blast"], ["proof (state)\nthis:\n  e \\<in> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "moreover"], ["proof (state)\nthis:\n  e \\<in> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "have \"x = return_pmf e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = return_pmf e", "using calculation(3) set_pmf_subset_singleton"], ["proof (prove)\nusing this:\n  {e} = set_pmf x\n  (set_pmf ?p \\<subseteq> {?x}) = (?p = return_pmf ?x)\n\ngoal (1 subgoal):\n 1. x = return_pmf e", "by fast"], ["proof (state)\nthis:\n  x = return_pmf e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> degenerate_lotteries \\<Longrightarrow>\n       x \\<in> {return_pmf x |x. x \\<in> outcomes}", "ultimately"], ["proof (chain)\npicking this:\n  card (set_pmf x) = 1\n  set_pmf x \\<subseteq> outcomes\n  {e} = set_pmf x\n  e \\<in> outcomes\n  x = return_pmf e", "show \"x \\<in> {return_pmf x |x. x \\<in> outcomes}\""], ["proof (prove)\nusing this:\n  card (set_pmf x) = 1\n  set_pmf x \\<subseteq> outcomes\n  {e} = set_pmf x\n  e \\<in> outcomes\n  x = return_pmf e\n\ngoal (1 subgoal):\n 1. x \\<in> {return_pmf x |x. x \\<in> outcomes}", "by blast"], ["proof (state)\nthis:\n  x \\<in> {return_pmf x |x. x \\<in> outcomes}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>degenerate_lotteries.\n     x \\<in> {return_pmf x |x. x \\<in> outcomes}\n\ngoal (1 subgoal):\n 1. degenerate_lotteries \\<subseteq> {return_pmf x |x. x \\<in> outcomes}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>degenerate_lotteries.\n     x \\<in> {return_pmf x |x. x \\<in> outcomes}", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>degenerate_lotteries.\n     x \\<in> {return_pmf x |x. x \\<in> outcomes}\n\ngoal (1 subgoal):\n 1. degenerate_lotteries \\<subseteq> {return_pmf x |x. x \\<in> outcomes}", "by blast"], ["proof (state)\nthis:\n  degenerate_lotteries \\<subseteq> {return_pmf x |x. x \\<in> outcomes}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma best_indifferent:\n  \"\\<forall>x \\<in> best. \\<forall>y \\<in> best. x \\<approx>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>best. \\<forall>y\\<in>best. x \\<approx>[\\<R>] y", "by (simp add: best_def)"], ["", "lemma worst_indifferent:\n  \"\\<forall>x \\<in> worst. \\<forall>y \\<in> worst. x \\<approx>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>worst. \\<forall>y\\<in>worst. x \\<approx>[\\<R>] y", "by (simp add: worst_def)"], ["", "lemma best_worst_indiff_all_indiff:\n  assumes \"b \\<in> best\"\n    and \"w \\<in> worst\"\n    and \"b \\<approx>[\\<R>] w\"\n  shows \"\\<forall>e \\<in> \\<P>. e \\<approx>[\\<R>] w\" \"\\<forall>e \\<in> \\<P>. e \\<approx>[\\<R>] b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] w &&&\n    \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] b", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] w\n 2. \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] b", "show \"\\<forall>e \\<in> \\<P>. e \\<approx>[\\<R>] w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] w", "proof (standard)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e. e \\<in> local.\\<P> \\<Longrightarrow> e \\<approx>[\\<R>] w", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e. e \\<in> local.\\<P> \\<Longrightarrow> e \\<approx>[\\<R>] w", "assume a: \"e \\<in> \\<P>\""], ["proof (state)\nthis:\n  e \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<in> local.\\<P> \\<Longrightarrow> e \\<approx>[\\<R>] w", "then"], ["proof (chain)\npicking this:\n  e \\<in> local.\\<P>", "have \"b \\<succeq>[\\<R>] e\""], ["proof (prove)\nusing this:\n  e \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. b \\<succeq>[\\<R>] e", "using a best_def assms"], ["proof (prove)\nusing this:\n  e \\<in> local.\\<P>\n  e \\<in> local.\\<P>\n  best =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y}\n  b \\<in> best\n  w \\<in> worst\n  b \\<approx>[\\<R>] w\n\ngoal (1 subgoal):\n 1. b \\<succeq>[\\<R>] e", "by blast"], ["proof (state)\nthis:\n  b \\<succeq>[\\<R>] e\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<in> local.\\<P> \\<Longrightarrow> e \\<approx>[\\<R>] w", "moreover"], ["proof (state)\nthis:\n  b \\<succeq>[\\<R>] e\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<in> local.\\<P> \\<Longrightarrow> e \\<approx>[\\<R>] w", "have \"e \\<succeq>[\\<R>] w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<succeq>[\\<R>] w", "using a assms worst_def"], ["proof (prove)\nusing this:\n  e \\<in> local.\\<P>\n  b \\<in> best\n  w \\<in> worst\n  b \\<approx>[\\<R>] w\n  worst =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x}\n\ngoal (1 subgoal):\n 1. e \\<succeq>[\\<R>] w", "by auto"], ["proof (state)\nthis:\n  e \\<succeq>[\\<R>] w\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<in> local.\\<P> \\<Longrightarrow> e \\<approx>[\\<R>] w", "moreover"], ["proof (state)\nthis:\n  e \\<succeq>[\\<R>] w\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<in> local.\\<P> \\<Longrightarrow> e \\<approx>[\\<R>] w", "have \"b \\<succeq>[\\<R>] e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<succeq>[\\<R>] e", "by (simp add: calculation(1))"], ["proof (state)\nthis:\n  b \\<succeq>[\\<R>] e\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<in> local.\\<P> \\<Longrightarrow> e \\<approx>[\\<R>] w", "moreover"], ["proof (state)\nthis:\n  b \\<succeq>[\\<R>] e\n\ngoal (1 subgoal):\n 1. \\<And>e. e \\<in> local.\\<P> \\<Longrightarrow> e \\<approx>[\\<R>] w", "show \"e \\<approx>[\\<R>] w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<approx>[\\<R>] w", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> e \\<approx>[\\<R>] w \\<Longrightarrow> False", "assume \"\\<not> e \\<approx>[\\<R>] w\""], ["proof (state)\nthis:\n  \\<not> e \\<approx>[\\<R>] w\n\ngoal (1 subgoal):\n 1. \\<not> e \\<approx>[\\<R>] w \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> e \\<approx>[\\<R>] w", "consider \"e \\<succ>[\\<R>] w\" | \"w \\<succ>[\\<R>] e\""], ["proof (prove)\nusing this:\n  \\<not> e \\<approx>[\\<R>] w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<succeq>[\\<R>] w \\<and>\n             (w, e) \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     w \\<succeq>[\\<R>] e \\<and> (e, w) \\<notin> \\<R> \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (simp add: calculation(2))"], ["proof (state)\nthis:\n  \\<lbrakk>e \\<succeq>[\\<R>] w \\<and> (w, e) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   w \\<succeq>[\\<R>] e \\<and> (e, w) \\<notin> \\<R> \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> e \\<approx>[\\<R>] w \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>e \\<succeq>[\\<R>] w \\<and> (w, e) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   w \\<succeq>[\\<R>] e \\<and> (e, w) \\<notin> \\<R> \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>e \\<succeq>[\\<R>] w \\<and> (w, e) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   w \\<succeq>[\\<R>] e \\<and> (e, w) \\<notin> \\<R> \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. e \\<succeq>[\\<R>] w \\<and> (w, e) \\<notin> \\<R> \\<Longrightarrow> False\n 2. w \\<succeq>[\\<R>] e \\<and> (e, w) \\<notin> \\<R> \\<Longrightarrow> False", "case 2"], ["proof (state)\nthis:\n  w \\<succeq>[\\<R>] e \\<and> (e, w) \\<notin> \\<R>\n\ngoal (2 subgoals):\n 1. e \\<succeq>[\\<R>] w \\<and> (w, e) \\<notin> \\<R> \\<Longrightarrow> False\n 2. w \\<succeq>[\\<R>] e \\<and> (e, w) \\<notin> \\<R> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  w \\<succeq>[\\<R>] e \\<and> (e, w) \\<notin> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<succeq>[\\<R>] e \\<and> (e, w) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. False", "using calculation(2)"], ["proof (prove)\nusing this:\n  w \\<succeq>[\\<R>] e \\<and> (e, w) \\<notin> \\<R>\n  e \\<succeq>[\\<R>] w\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. e \\<succeq>[\\<R>] w \\<and> (w, e) \\<notin> \\<R> \\<Longrightarrow> False", "qed (meson assms(3) calculation(1) \n          rational_preference.strict_is_neg_transitive relation_in_carrier rpr)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e \\<approx>[\\<R>] w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] w\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] b", "then"], ["proof (chain)\npicking this:\n  \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] w", "show \"\\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] b\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] w\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] b", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] w\n  b \\<in> best\n  w \\<in> worst\n  b \\<approx>[\\<R>] w\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] b", "by (meson rational_preference.compl \n        rational_preference.strict_is_neg_transitive relation_in_carrier rpr)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>local.\\<P>. e \\<approx>[\\<R>] b\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Like Step 1 most general but with IFF. \\<close>"], ["", "lemma mix_pmf_pref_iff_more_likely [iff]: \n  assumes \"b \\<succ>[\\<R>] w\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"\\<beta> \\<in> {0..1}\"\n  shows \"\\<alpha> > \\<beta> \\<longleftrightarrow> mix_pmf \\<alpha> b w \\<succ>[\\<R>] mix_pmf \\<beta> b w\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<beta> < \\<alpha>) =\n    (mix_pmf \\<alpha> b w \\<succeq>[\\<R>] mix_pmf \\<beta> b w \\<and>\n     (mix_pmf \\<beta> b w, mix_pmf \\<alpha> b w) \\<notin> \\<R>)", "using assms step_1_most_general[of b w \\<alpha> \\<beta>]"], ["proof (prove)\nusing this:\n  b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n  \\<lbrakk>b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R>;\n   \\<alpha> \\<in> {0..1}; \\<beta> \\<in> {0..1}; \\<beta> < \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<alpha> b\n                     w \\<succeq>[\\<R>] mix_pmf \\<beta> b w \\<and>\n                    (mix_pmf \\<beta> b w, mix_pmf \\<alpha> b w)\n                    \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<beta> < \\<alpha>) =\n    (mix_pmf \\<alpha> b w \\<succeq>[\\<R>] mix_pmf \\<beta> b w \\<and>\n     (mix_pmf \\<beta> b w, mix_pmf \\<alpha> b w) \\<notin> \\<R>)", "by (metis linorder_neqE_linordered_idom step_1_most_general)"], ["", "lemma better_worse_good_mix_preferred[iff]: \n  assumes \"b \\<succeq>[\\<R>] w\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"\\<beta> \\<in> {0..1}\"\n  assumes \"\\<alpha> \\<ge> \\<beta>\" \n  shows \"mix_pmf \\<alpha> b w \\<succeq>[\\<R>] mix_pmf \\<beta> b w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> b w \\<succeq>[\\<R>] mix_pmf \\<beta> b w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> b w \\<succeq>[\\<R>] mix_pmf \\<beta> b w", "have \"(0::real) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1", "by simp"], ["proof (state)\nthis:\n  0 \\<le> 1\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> b w \\<succeq>[\\<R>] mix_pmf \\<beta> b w", "then"], ["proof (chain)\npicking this:\n  0 \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> 1\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> b w \\<succeq>[\\<R>] mix_pmf \\<beta> b w", "by (metis (no_types) assms assms(1) assms(2) assms(3) atLeastAtMost_iff \n        less_eq_real_def mix_of_not_preferred_is_not_preferred \n        mix_of_preferred_is_preferred mix_pmf_preferred_independence \n        pmf_mix_0 relation_in_carrier step_1_most_general)"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> b w \\<succeq>[\\<R>] mix_pmf \\<beta> b w\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Add finiteness and non emptyness of outcomes \\<close>"], ["", "context\n  assumes fnt: \"finite outcomes\"\n  assumes nempty: \"outcomes \\<noteq> {}\"\nbegin"], ["", "lemma finite_degenerate_lotteries: \n  \"finite degenerate_lotteries\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite degenerate_lotteries", "using degen_outcome_cardinalities fnt nempty"], ["proof (prove)\nusing this:\n  card degenerate_lotteries = card outcomes\n  finite outcomes\n  outcomes \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite degenerate_lotteries", "by fastforce"], ["", "lemma degenerate_has_max_preferred:\n  \"{x \\<in> degenerate_lotteries. (\\<forall>y \\<in> degenerate_lotteries. x \\<succeq>[\\<R>] y)} \\<noteq> {}\" (is \"?l \\<noteq> {}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y} \\<noteq>\n    {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y} =\n    {} \\<Longrightarrow>\n    False", "assume a: \"?l = {}\""], ["proof (state)\nthis:\n  {x \\<in> degenerate_lotteries.\n   \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y} =\n  {}\n\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y} =\n    {} \\<Longrightarrow>\n    False", "let ?DG = \"degenerate_lotteries\""], ["proof (state)\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y} =\n    {} \\<Longrightarrow>\n    False", "obtain R where\n    R: \"rational_preference ?DG R\" \"R \\<subseteq> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>rational_preference degenerate_lotteries R;\n         R \\<subseteq> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using degenerate_lots_subset_all rational_preference.all_carrier_ex_sub_rel rpr"], ["proof (prove)\nusing this:\n  degenerate_lotteries \\<subseteq> local.\\<P>\n  rational_preference ?carrier ?relation \\<Longrightarrow>\n  \\<forall>c\\<subseteq>?carrier.\n     \\<exists>r\\<subseteq>?relation. rational_preference c r\n  rational_preference local.\\<P> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>rational_preference degenerate_lotteries R;\n         R \\<subseteq> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rational_preference degenerate_lotteries R\n  R \\<subseteq> \\<R>\n\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y} =\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  rational_preference degenerate_lotteries R\n  R \\<subseteq> \\<R>", "have \"\\<exists>e \\<in> ?DG. \\<forall>e' \\<in> ?DG. e \\<succeq>[\\<R>] e'\""], ["proof (prove)\nusing this:\n  rational_preference degenerate_lotteries R\n  R \\<subseteq> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>degenerate_lotteries.\n       \\<forall>e'\\<in>degenerate_lotteries. e \\<succeq>[\\<R>] e'", "by (metis R(1) R(2) card_0_eq degen_outcome_cardinalities \n        finite_degenerate_lotteries fnt nempty subset_eq\n        rational_preference.finite_nonempty_carrier_has_maximum )"], ["proof (state)\nthis:\n  \\<exists>e\\<in>degenerate_lotteries.\n     \\<forall>e'\\<in>degenerate_lotteries. e \\<succeq>[\\<R>] e'\n\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y} =\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>e\\<in>degenerate_lotteries.\n     \\<forall>e'\\<in>degenerate_lotteries. e \\<succeq>[\\<R>] e'", "show False"], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>degenerate_lotteries.\n     \\<forall>e'\\<in>degenerate_lotteries. e \\<succeq>[\\<R>] e'\n\ngoal (1 subgoal):\n 1. False", "using a"], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>degenerate_lotteries.\n     \\<forall>e'\\<in>degenerate_lotteries. e \\<succeq>[\\<R>] e'\n  {x \\<in> degenerate_lotteries.\n   \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y} =\n  {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degenerate_has_min_preferred:\n  \"{x \\<in> degenerate_lotteries. (\\<forall>y \\<in> degenerate_lotteries. y \\<succeq>[\\<R>] x)} \\<noteq> {}\" (is \"?l \\<noteq> {}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x} \\<noteq>\n    {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x} =\n    {} \\<Longrightarrow>\n    False", "assume a: \"?l = {}\""], ["proof (state)\nthis:\n  {x \\<in> degenerate_lotteries.\n   \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x} =\n  {}\n\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x} =\n    {} \\<Longrightarrow>\n    False", "let ?DG = \"degenerate_lotteries\""], ["proof (state)\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x} =\n    {} \\<Longrightarrow>\n    False", "obtain R where\n    R: \"rational_preference ?DG R\" \"R \\<subseteq> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>rational_preference degenerate_lotteries R;\n         R \\<subseteq> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using degenerate_lots_subset_all rational_preference.all_carrier_ex_sub_rel rpr"], ["proof (prove)\nusing this:\n  degenerate_lotteries \\<subseteq> local.\\<P>\n  rational_preference ?carrier ?relation \\<Longrightarrow>\n  \\<forall>c\\<subseteq>?carrier.\n     \\<exists>r\\<subseteq>?relation. rational_preference c r\n  rational_preference local.\\<P> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>rational_preference degenerate_lotteries R;\n         R \\<subseteq> \\<R>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rational_preference degenerate_lotteries R\n  R \\<subseteq> \\<R>\n\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x} =\n    {} \\<Longrightarrow>\n    False", "have \"\\<exists>e \\<in> ?DG. \\<forall>e' \\<in> ?DG. e' \\<succeq>[\\<R>] e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>degenerate_lotteries.\n       \\<forall>e'\\<in>degenerate_lotteries. e' \\<succeq>[\\<R>] e", "by (metis R(1) R(2) card_0_eq degen_outcome_cardinalities \n        finite_degenerate_lotteries fnt nempty subset_eq\n        rational_preference.finite_nonempty_carrier_has_minimum )"], ["proof (state)\nthis:\n  \\<exists>e\\<in>degenerate_lotteries.\n     \\<forall>e'\\<in>degenerate_lotteries. e' \\<succeq>[\\<R>] e\n\ngoal (1 subgoal):\n 1. {x \\<in> degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x} =\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>e\\<in>degenerate_lotteries.\n     \\<forall>e'\\<in>degenerate_lotteries. e' \\<succeq>[\\<R>] e", "show False"], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>degenerate_lotteries.\n     \\<forall>e'\\<in>degenerate_lotteries. e' \\<succeq>[\\<R>] e\n\ngoal (1 subgoal):\n 1. False", "using a"], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>degenerate_lotteries.\n     \\<forall>e'\\<in>degenerate_lotteries. e' \\<succeq>[\\<R>] e\n  {x \\<in> degenerate_lotteries.\n   \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x} =\n  {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_best_degenerate:\n  \"\\<exists>x \\<in> degenerate_lotteries. \\<forall>y \\<in> degenerate_lotteries. x \\<succeq>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y", "using degenerate_has_max_preferred"], ["proof (prove)\nusing this:\n  {x \\<in> degenerate_lotteries.\n   \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y", "by blast"], ["", "lemma exists_worst_degenerate:\n  \"\\<exists>x \\<in> degenerate_lotteries. \\<forall>y \\<in> degenerate_lotteries. y \\<succeq>[\\<R>] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x", "using degenerate_has_min_preferred"], ["proof (prove)\nusing this:\n  {x \\<in> degenerate_lotteries.\n   \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x", "by blast"], ["", "lemma best_degenerate_in_best_overall: \n  \"\\<exists>x \\<in> degenerate_lotteries. \\<forall>y \\<in> \\<P>. x \\<succeq>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "obtain b where\n    b: \"b \\<in> degenerate_lotteries\" \"\\<forall>y \\<in> degenerate_lotteries. b \\<succeq>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> degenerate_lotteries;\n         \\<forall>y\\<in>degenerate_lotteries. b \\<succeq>[\\<R>] y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using exists_best_degenerate"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. x \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> degenerate_lotteries;\n         \\<forall>y\\<in>degenerate_lotteries. b \\<succeq>[\\<R>] y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b \\<in> degenerate_lotteries\n  \\<forall>y\\<in>degenerate_lotteries. b \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "have asm: \"finite outcomes\" \"set_pmf b \\<subseteq> outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite outcomes &&& set_pmf b \\<subseteq> outcomes", "by (simp add: fnt) (meson b(1) degenerate_lots_subset_all subset_iff support_in_outcomes)"], ["proof (state)\nthis:\n  finite outcomes\n  set_pmf b \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "obtain B where B: \"set_pmf b = {B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B. set_pmf b = {B} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b card_1_singletonE degenerate_lotteries_def"], ["proof (prove)\nusing this:\n  b \\<in> degenerate_lotteries\n  \\<forall>y\\<in>degenerate_lotteries. b \\<succeq>[\\<R>] y\n  \\<lbrakk>card ?A = 1; \\<And>x. ?A = {x} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  degenerate_lotteries = {x \\<in> local.\\<P>. card (set_pmf x) = 1}\n\ngoal (1 subgoal):\n 1. (\\<And>B. set_pmf b = {B} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set_pmf b = {B}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "have deg: \"\\<forall>d\\<in>outcomes. b \\<succeq>[\\<R>] return_pmf d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>outcomes. b \\<succeq>[\\<R>] return_pmf d", "using alt_definition_of_degenerate_lotteries b(2)"], ["proof (prove)\nusing this:\n  {return_pmf x |x. x \\<in> outcomes} = degenerate_lotteries\n  \\<forall>y\\<in>degenerate_lotteries. b \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>outcomes. b \\<succeq>[\\<R>] return_pmf d", "by blast"], ["proof (state)\nthis:\n  \\<forall>d\\<in>outcomes. b \\<succeq>[\\<R>] return_pmf d\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "define P where\n    \"P = (\\<lambda>p. p \\<in> \\<P> \\<longrightarrow> return_pmf B \\<succeq>[\\<R>] p)\""], ["proof (state)\nthis:\n  P =\n  (\\<lambda>p.\n      p \\<in> local.\\<P> \\<longrightarrow> return_pmf B \\<succeq>[\\<R>] p)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "have \"P p\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P p", "consider \"set_pmf p \\<subseteq> outcomes\" | \"\\<not>set_pmf p \\<subseteq> outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_pmf p \\<subseteq> outcomes \\<Longrightarrow> thesis;\n     \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis;\n   \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P p", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis;\n   \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis;\n   \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P p", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p\n 2. \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p", "case 1"], ["proof (state)\nthis:\n  set_pmf p \\<subseteq> outcomes\n\ngoal (2 subgoals):\n 1. set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p\n 2. \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p", "have \"finite outcomes\" \"set_pmf p \\<subseteq> outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite outcomes &&& set_pmf p \\<subseteq> outcomes", "by (auto simp: 1 asm)"], ["proof (state)\nthis:\n  finite outcomes\n  set_pmf p \\<subseteq> outcomes\n\ngoal (2 subgoals):\n 1. set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p\n 2. \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  finite outcomes\n  set_pmf p \\<subseteq> outcomes", "show ?thesis"], ["proof (prove)\nusing this:\n  finite outcomes\n  set_pmf p \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. P p", "proof (induct  rule: pmf_mix_induct')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> outcomes \\<Longrightarrow> P (return_pmf x)\n 2. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1}; P p; P q\\<rbrakk>\n       \\<Longrightarrow> P (mix_pmf a p q)", "case (degenerate x)"], ["proof (state)\nthis:\n  x \\<in> outcomes\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> outcomes \\<Longrightarrow> P (return_pmf x)\n 2. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1}; P p; P q\\<rbrakk>\n       \\<Longrightarrow> P (mix_pmf a p q)", "then"], ["proof (chain)\npicking this:\n  x \\<in> outcomes", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> outcomes\n\ngoal (1 subgoal):\n 1. P (return_pmf x)", "using B P_def deg set_pmf_subset_singleton"], ["proof (prove)\nusing this:\n  x \\<in> outcomes\n  set_pmf b = {B}\n  P =\n  (\\<lambda>p.\n      p \\<in> local.\\<P> \\<longrightarrow> return_pmf B \\<succeq>[\\<R>] p)\n  \\<forall>d\\<in>outcomes. b \\<succeq>[\\<R>] return_pmf d\n  (set_pmf ?p \\<subseteq> {?x}) = (?p = return_pmf ?x)\n\ngoal (1 subgoal):\n 1. P (return_pmf x)", "by fastforce"], ["proof (state)\nthis:\n  P (return_pmf x)\n\ngoal (1 subgoal):\n 1. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1}; P p; P q\\<rbrakk>\n       \\<Longrightarrow> P (mix_pmf a p q)", "qed (simp add: P_def lotteries_on_def mix_of_not_preferred_is_not_preferred\n               mix_of_not_preferred_is_not_preferred[of b p q a])"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p", "qed  (simp add: lotteries_on_def P_def)"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P ?p\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "moreover"], ["proof (state)\nthis:\n  P ?p\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "have \"\\<forall>e \\<in> \\<P>. b \\<succeq>[\\<R>] e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>local.\\<P>. b \\<succeq>[\\<R>] e", "using calculation B P_def set_pmf_subset_singleton"], ["proof (prove)\nusing this:\n  P ?p\n  set_pmf b = {B}\n  P =\n  (\\<lambda>p.\n      p \\<in> local.\\<P> \\<longrightarrow> return_pmf B \\<succeq>[\\<R>] p)\n  (set_pmf ?p \\<subseteq> {?x}) = (?p = return_pmf ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>local.\\<P>. b \\<succeq>[\\<R>] e", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>e\\<in>local.\\<P>. b \\<succeq>[\\<R>] e\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "ultimately"], ["proof (chain)\npicking this:\n  P ?p\n  \\<forall>e\\<in>local.\\<P>. b \\<succeq>[\\<R>] e", "show ?thesis"], ["proof (prove)\nusing this:\n  P ?p\n  \\<forall>e\\<in>local.\\<P>. b \\<succeq>[\\<R>] e\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "using b degenerate_lots_subset_all"], ["proof (prove)\nusing this:\n  P ?p\n  \\<forall>e\\<in>local.\\<P>. b \\<succeq>[\\<R>] e\n  b \\<in> degenerate_lotteries\n  \\<forall>y\\<in>degenerate_lotteries. b \\<succeq>[\\<R>] y\n  degenerate_lotteries \\<subseteq> local.\\<P>\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x\\<in>degenerate_lotteries.\n     \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma worst_degenerate_in_worst_overall: \n  \"\\<exists>x \\<in> degenerate_lotteries. \\<forall>y \\<in> \\<P>. y \\<succeq>[\\<R>] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "obtain b where\n    b: \"b \\<in> degenerate_lotteries\" \"\\<forall>y \\<in> degenerate_lotteries. y \\<succeq>[\\<R>] b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> degenerate_lotteries;\n         \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using exists_worst_degenerate"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>degenerate_lotteries.\n     \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] x\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> degenerate_lotteries;\n         \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b \\<in> degenerate_lotteries\n  \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] b\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "have asm: \"finite outcomes\" \"set_pmf b \\<subseteq> outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite outcomes &&& set_pmf b \\<subseteq> outcomes", "by (simp add: fnt) (meson b(1) degenerate_lots_subset_all subset_iff support_in_outcomes)"], ["proof (state)\nthis:\n  finite outcomes\n  set_pmf b \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "obtain B where B: \"set_pmf b = {B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B. set_pmf b = {B} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b card_1_singletonE degenerate_lotteries_def"], ["proof (prove)\nusing this:\n  b \\<in> degenerate_lotteries\n  \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] b\n  \\<lbrakk>card ?A = 1; \\<And>x. ?A = {x} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  degenerate_lotteries = {x \\<in> local.\\<P>. card (set_pmf x) = 1}\n\ngoal (1 subgoal):\n 1. (\\<And>B. set_pmf b = {B} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set_pmf b = {B}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "have deg: \"\\<forall>d\\<in>outcomes. return_pmf d \\<succeq>[\\<R>] b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>outcomes. return_pmf d \\<succeq>[\\<R>] b", "using alt_definition_of_degenerate_lotteries b(2)"], ["proof (prove)\nusing this:\n  {return_pmf x |x. x \\<in> outcomes} = degenerate_lotteries\n  \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] b\n\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>outcomes. return_pmf d \\<succeq>[\\<R>] b", "by blast"], ["proof (state)\nthis:\n  \\<forall>d\\<in>outcomes. return_pmf d \\<succeq>[\\<R>] b\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "define P where\n    \"P = (\\<lambda>p. p \\<in> \\<P> \\<longrightarrow> p \\<succeq>[\\<R>] return_pmf B)\""], ["proof (state)\nthis:\n  P =\n  (\\<lambda>p.\n      p \\<in> local.\\<P> \\<longrightarrow> p \\<succeq>[\\<R>] return_pmf B)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "have \"P p\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P p", "consider \"set_pmf p \\<subseteq> outcomes\" | \"\\<not>set_pmf p \\<subseteq> outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_pmf p \\<subseteq> outcomes \\<Longrightarrow> thesis;\n     \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis;\n   \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P p", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis;\n   \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis;\n   \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P p", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p\n 2. \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p", "case 1"], ["proof (state)\nthis:\n  set_pmf p \\<subseteq> outcomes\n\ngoal (2 subgoals):\n 1. set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p\n 2. \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p", "have \"finite outcomes\" \"set_pmf p \\<subseteq> outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite outcomes &&& set_pmf p \\<subseteq> outcomes", "by (auto simp: 1 asm)"], ["proof (state)\nthis:\n  finite outcomes\n  set_pmf p \\<subseteq> outcomes\n\ngoal (2 subgoals):\n 1. set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p\n 2. \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  finite outcomes\n  set_pmf p \\<subseteq> outcomes", "show ?thesis"], ["proof (prove)\nusing this:\n  finite outcomes\n  set_pmf p \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. P p", "proof (induct rule: pmf_mix_induct')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> outcomes \\<Longrightarrow> P (return_pmf x)\n 2. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1}; P p; P q\\<rbrakk>\n       \\<Longrightarrow> P (mix_pmf a p q)", "case (degenerate x)"], ["proof (state)\nthis:\n  x \\<in> outcomes\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> outcomes \\<Longrightarrow> P (return_pmf x)\n 2. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1}; P p; P q\\<rbrakk>\n       \\<Longrightarrow> P (mix_pmf a p q)", "then"], ["proof (chain)\npicking this:\n  x \\<in> outcomes", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> outcomes\n\ngoal (1 subgoal):\n 1. P (return_pmf x)", "using B P_def deg set_pmf_subset_singleton"], ["proof (prove)\nusing this:\n  x \\<in> outcomes\n  set_pmf b = {B}\n  P =\n  (\\<lambda>p.\n      p \\<in> local.\\<P> \\<longrightarrow> p \\<succeq>[\\<R>] return_pmf B)\n  \\<forall>d\\<in>outcomes. return_pmf d \\<succeq>[\\<R>] b\n  (set_pmf ?p \\<subseteq> {?x}) = (?p = return_pmf ?x)\n\ngoal (1 subgoal):\n 1. P (return_pmf x)", "by fastforce"], ["proof (state)\nthis:\n  P (return_pmf x)\n\ngoal (1 subgoal):\n 1. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1}; P p; P q\\<rbrakk>\n       \\<Longrightarrow> P (mix_pmf a p q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1}; P p; P q\\<rbrakk>\n       \\<Longrightarrow> P (mix_pmf a p q)", "qed (simp add: P_def lotteries_on_def mix_of_preferred_is_preferred\n          mix_of_not_preferred_is_not_preferred[of b p])"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. \\<not> set_pmf p \\<subseteq> outcomes \\<Longrightarrow> P p", "qed (simp add: lotteries_on_def P_def)"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P ?p\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "moreover"], ["proof (state)\nthis:\n  P ?p\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "have \"\\<forall>e \\<in> \\<P>. e \\<succeq>[\\<R>] b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>local.\\<P>. e \\<succeq>[\\<R>] b", "using calculation B P_def set_pmf_subset_singleton"], ["proof (prove)\nusing this:\n  P ?p\n  set_pmf b = {B}\n  P =\n  (\\<lambda>p.\n      p \\<in> local.\\<P> \\<longrightarrow> p \\<succeq>[\\<R>] return_pmf B)\n  (set_pmf ?p \\<subseteq> {?x}) = (?p = return_pmf ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>local.\\<P>. e \\<succeq>[\\<R>] b", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>e\\<in>local.\\<P>. e \\<succeq>[\\<R>] b\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "ultimately"], ["proof (chain)\npicking this:\n  P ?p\n  \\<forall>e\\<in>local.\\<P>. e \\<succeq>[\\<R>] b", "show ?thesis"], ["proof (prove)\nusing this:\n  P ?p\n  \\<forall>e\\<in>local.\\<P>. e \\<succeq>[\\<R>] b\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "using b degenerate_lots_subset_all"], ["proof (prove)\nusing this:\n  P ?p\n  \\<forall>e\\<in>local.\\<P>. e \\<succeq>[\\<R>] b\n  b \\<in> degenerate_lotteries\n  \\<forall>y\\<in>degenerate_lotteries. y \\<succeq>[\\<R>] b\n  degenerate_lotteries \\<subseteq> local.\\<P>\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>degenerate_lotteries.\n       \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x\\<in>degenerate_lotteries.\n     \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma overall_best_nonempty:\n  \"best \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. best \\<noteq> {}", "using best_def best_degenerate_in_best_overall degenerate_lots_subset_all"], ["proof (prove)\nusing this:\n  best =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y}\n  \\<exists>x\\<in>degenerate_lotteries.\n     \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y\n  degenerate_lotteries \\<subseteq> local.\\<P>\n\ngoal (1 subgoal):\n 1. best \\<noteq> {}", "by blast"], ["", "lemma overall_worst_nonempty:\n  \"worst \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. worst \\<noteq> {}", "using degenerate_lots_subset_all worst_def worst_degenerate_in_worst_overall"], ["proof (prove)\nusing this:\n  degenerate_lotteries \\<subseteq> local.\\<P>\n  worst =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x}\n  \\<exists>x\\<in>degenerate_lotteries.\n     \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x\n\ngoal (1 subgoal):\n 1. worst \\<noteq> {}", "by auto"], ["", "lemma trans_approx:\n  assumes \"x\\<approx>[\\<R>] y\" \n    and \" y \\<approx>[\\<R>] z\" \n  shows \"x \\<approx>[\\<R>] z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<approx>[\\<R>] z", "using preference.indiff_trans[of \\<P> \\<R> x y z] assms rpr rational_preference_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>preference local.\\<P> \\<R>; x \\<approx>[\\<R>] y;\n   y \\<approx>[\\<R>] z\\<rbrakk>\n  \\<Longrightarrow> x \\<approx>[\\<R>] z\n  x \\<approx>[\\<R>] y\n  y \\<approx>[\\<R>] z\n  rational_preference local.\\<P> \\<R>\n  rational_preference ?carrier ?relation \\<equiv>\n  preference ?carrier ?relation \\<and>\n  rational_preference_axioms ?carrier ?relation\n\ngoal (1 subgoal):\n 1. x \\<approx>[\\<R>] z", "by blast"], ["", "text \\<open> First EXPLICIT use of the axiom of choice \\<close>"], ["", "private"], ["", "definition some_best where\n  \"some_best = (SOME x. x \\<in> degenerate_lotteries \\<and> x \\<in> best)\""], ["", "private"], ["", "definition some_worst where\n  \"some_worst = (SOME x. x \\<in> degenerate_lotteries \\<and> x \\<in> worst)\""], ["", "private"], ["", "definition my_U :: \"'a pmf \\<Rightarrow> real\"\n  where\n    \"my_U p = (SOME \\<alpha>. \\<alpha>\\<in>{0..1} \\<and> p \\<approx>[\\<R>] mix_pmf \\<alpha> some_best some_worst)\""], ["", "lemma exists_best_and_degenerate: \"degenerate_lotteries \\<inter> best \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degenerate_lotteries \\<inter> best \\<noteq> {}", "using best_def best_degenerate_in_best_overall degenerate_lots_subset_all"], ["proof (prove)\nusing this:\n  best =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y}\n  \\<exists>x\\<in>degenerate_lotteries.\n     \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y\n  degenerate_lotteries \\<subseteq> local.\\<P>\n\ngoal (1 subgoal):\n 1. degenerate_lotteries \\<inter> best \\<noteq> {}", "by blast"], ["", "lemma exists_worst_and_degenerate: \"degenerate_lotteries \\<inter> worst \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degenerate_lotteries \\<inter> worst \\<noteq> {}", "using worst_def worst_degenerate_in_worst_overall degenerate_lots_subset_all"], ["proof (prove)\nusing this:\n  worst =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x}\n  \\<exists>x\\<in>degenerate_lotteries.\n     \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x\n  degenerate_lotteries \\<subseteq> local.\\<P>\n\ngoal (1 subgoal):\n 1. degenerate_lotteries \\<inter> worst \\<noteq> {}", "by blast"], ["", "lemma some_best_in_best: \"some_best \\<in> best\""], ["proof (prove)\ngoal (1 subgoal):\n 1. some_best \\<in> best", "using exists_best_and_degenerate some_best_def"], ["proof (prove)\nusing this:\n  degenerate_lotteries \\<inter> best \\<noteq> {}\n  some_best = (SOME x. x \\<in> degenerate_lotteries \\<and> x \\<in> best)\n\ngoal (1 subgoal):\n 1. some_best \\<in> best", "by (metis (mono_tags, lifting) Int_emptyI some_eq_ex)"], ["", "lemma some_worst_in_worst: \"some_worst \\<in> worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. some_worst \\<in> worst", "using exists_worst_and_degenerate some_worst_def"], ["proof (prove)\nusing this:\n  degenerate_lotteries \\<inter> worst \\<noteq> {}\n  some_worst = (SOME x. x \\<in> degenerate_lotteries \\<and> x \\<in> worst)\n\ngoal (1 subgoal):\n 1. some_worst \\<in> worst", "by (metis (mono_tags, lifting) Int_emptyI some_eq_ex)"], ["", "lemma best_always_at_least_as_good_mix:\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"p \\<in> \\<P>\"\n  shows \"mix_pmf \\<alpha> some_best p \\<succeq>[\\<R>] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> some_best p \\<succeq>[\\<R>] p", "using assms(1) assms(2) best_def mix_of_preferred_is_preferred \n    rational_preference.compl rpr some_best_in_best"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0..1}\n  p \\<in> local.\\<P>\n  best =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y}\n  \\<lbrakk>?p \\<succeq>[\\<R>] ?w; ?q \\<succeq>[\\<R>] ?w;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?p ?q \\<succeq>[\\<R>] ?w\n  rational_preference ?carrier ?relation \\<Longrightarrow>\n  \\<forall>x\\<in>?carrier.\n     \\<forall>y\\<in>?carrier.\n        x \\<succeq>[?relation] y \\<or> y \\<succeq>[?relation] x\n  rational_preference local.\\<P> \\<R>\n  some_best \\<in> best\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> some_best p \\<succeq>[\\<R>] p", "by fastforce"], ["", "lemma geq_mix_imp_weak_pref:\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"\\<beta> \\<in> {0..1}\"\n  assumes \"\\<alpha> \\<ge> \\<beta>\"\n  shows \"mix_pmf \\<alpha> some_best some_worst \\<succeq>[\\<R>] mix_pmf \\<beta> some_best some_worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf \\<beta> some_best some_worst", "using assms(1) assms(2) assms(3) best_def some_best_in_best some_worst_in_worst worst_def"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n  \\<beta> \\<le> \\<alpha>\n  best =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y}\n  some_best \\<in> best\n  some_worst \\<in> worst\n  worst =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x}\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf \\<beta> some_best some_worst", "by auto"], ["", "lemma gamma_inverse:\n  assumes \"\\<alpha> \\<in> {0<..<1}\"\n    and \"\\<beta> \\<in> {0<..<1}\"\n  shows \"(1::real) - (\\<alpha> - \\<beta>) / (1 - \\<beta>) = (1 - \\<alpha>) / (1 - \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n    (1 - \\<alpha>) / (1 - \\<beta>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n    (1 - \\<alpha>) / (1 - \\<beta>)", "have \"1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =  (1 - \\<beta>)/(1 - \\<beta>) - (\\<alpha> - \\<beta>) / (1 - \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n    (1 - \\<beta>) / (1 - \\<beta>) - (\\<alpha> - \\<beta>) / (1 - \\<beta>)", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n    (1 - \\<beta>) / (1 - \\<beta>) - (\\<alpha> - \\<beta>) / (1 - \\<beta>)", "by auto"], ["proof (state)\nthis:\n  1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n  (1 - \\<beta>) / (1 - \\<beta>) - (\\<alpha> - \\<beta>) / (1 - \\<beta>)\n\ngoal (1 subgoal):\n 1. 1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n    (1 - \\<alpha>) / (1 - \\<beta>)", "also"], ["proof (state)\nthis:\n  1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n  (1 - \\<beta>) / (1 - \\<beta>) - (\\<alpha> - \\<beta>) / (1 - \\<beta>)\n\ngoal (1 subgoal):\n 1. 1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n    (1 - \\<alpha>) / (1 - \\<beta>)", "have \"... = (1 - \\<beta> - (\\<alpha> - \\<beta>)) / (1 - \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - \\<beta>) / (1 - \\<beta>) - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n    (1 - \\<beta> - (\\<alpha> - \\<beta>)) / (1 - \\<beta>)", "by (metis diff_divide_distrib)"], ["proof (state)\nthis:\n  (1 - \\<beta>) / (1 - \\<beta>) - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n  (1 - \\<beta> - (\\<alpha> - \\<beta>)) / (1 - \\<beta>)\n\ngoal (1 subgoal):\n 1. 1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n    (1 - \\<alpha>) / (1 - \\<beta>)", "also"], ["proof (state)\nthis:\n  (1 - \\<beta>) / (1 - \\<beta>) - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n  (1 - \\<beta> - (\\<alpha> - \\<beta>)) / (1 - \\<beta>)\n\ngoal (1 subgoal):\n 1. 1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n    (1 - \\<alpha>) / (1 - \\<beta>)", "have \"... = (1 - \\<alpha>) / (1 - \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - \\<beta> - (\\<alpha> - \\<beta>)) / (1 - \\<beta>) =\n    (1 - \\<alpha>) / (1 - \\<beta>)", "by simp"], ["proof (state)\nthis:\n  (1 - \\<beta> - (\\<alpha> - \\<beta>)) / (1 - \\<beta>) =\n  (1 - \\<alpha>) / (1 - \\<beta>)\n\ngoal (1 subgoal):\n 1. 1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n    (1 - \\<alpha>) / (1 - \\<beta>)", "finally"], ["proof (chain)\npicking this:\n  1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) = (1 - \\<alpha>) / (1 - \\<beta>)", "show ?thesis"], ["proof (prove)\nusing this:\n  1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) = (1 - \\<alpha>) / (1 - \\<beta>)\n\ngoal (1 subgoal):\n 1. 1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) =\n    (1 - \\<alpha>) / (1 - \\<beta>)", "."], ["proof (state)\nthis:\n  1 - (\\<alpha> - \\<beta>) / (1 - \\<beta>) = (1 - \\<alpha>) / (1 - \\<beta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_mix_pmf_indiff_indiff_best_worst:\n  assumes \"l \\<in> \\<P>\"\n  assumes \"b \\<in> best\"\n  assumes \"w \\<in> worst\"\n  assumes \"b \\<approx>[\\<R>] w\"\n  shows \"\\<forall>\\<alpha> \\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "by (meson assms best_worst_indiff_all_indiff(1) mix_of_preferred_is_preferred\n      best_worst_indiff_all_indiff(2) mix_of_not_preferred_is_not_preferred)"], ["", "lemma indiff_imp_same_utility_value:\n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n  assumes \"\\<beta> \\<in> {0..1}\"\n  assumes \"mix_pmf \\<beta> some_best some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best some_worst\"\n  shows \"\\<beta> = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> = \\<alpha>", "using assms(1) assms(2) assms(3) assms(4) linorder_neqE_linordered_idom"], ["proof (prove)\nusing this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n  mix_pmf \\<beta> some_best\n   some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best some_worst\n  \\<lbrakk>?x \\<noteq> ?y; ?x < ?y \\<Longrightarrow> ?thesis;\n   ?y < ?x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<beta> = \\<alpha>", "by blast"], ["", "lemma leq_mix_imp_weak_inferior:\n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"\\<beta> \\<in> {0..1}\"\n  assumes \"mix_pmf \\<beta> some_best some_worst \\<succeq>[\\<R>] mix_pmf \\<alpha> some_best some_worst\"\n  shows \"\\<beta> \\<ge> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "have *: \"mix_pmf \\<beta> some_best some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best some_worst \\<Longrightarrow> \\<alpha> \\<le> \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> some_best\n     some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best\n                                 some_worst \\<Longrightarrow>\n    \\<alpha> \\<le> \\<beta>", "using assms(1) assms(2) assms(3) indiff_imp_same_utility_value"], ["proof (prove)\nusing this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R>;\n   ?\\<alpha> \\<in> {0..1}; ?\\<beta> \\<in> {0..1};\n   mix_pmf ?\\<beta> some_best\n    some_worst \\<approx>[\\<R>] mix_pmf ?\\<alpha> some_best\n                                some_worst\\<rbrakk>\n  \\<Longrightarrow> ?\\<beta> = ?\\<alpha>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> some_best\n     some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best\n                                 some_worst \\<Longrightarrow>\n    \\<alpha> \\<le> \\<beta>", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<beta> some_best\n   some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best\n                               some_worst \\<Longrightarrow>\n  \\<alpha> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "consider \"mix_pmf \\<beta> some_best some_worst \\<succ>[\\<R>] mix_pmf \\<alpha> some_best some_worst\" |\n    \"mix_pmf \\<beta> some_best some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best some_worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mix_pmf \\<beta> some_best\n              some_worst \\<succeq>[\\<R>] mix_pmf \\<alpha> some_best\n    some_worst \\<and>\n             (mix_pmf \\<alpha> some_best some_worst,\n              mix_pmf \\<beta> some_best some_worst)\n             \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     mix_pmf \\<beta> some_best\n      some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best\n                                  some_worst \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(4)"], ["proof (prove)\nusing this:\n  mix_pmf \\<beta> some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf \\<alpha> some_best some_worst\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mix_pmf \\<beta> some_best\n              some_worst \\<succeq>[\\<R>] mix_pmf \\<alpha> some_best\n    some_worst \\<and>\n             (mix_pmf \\<alpha> some_best some_worst,\n              mix_pmf \\<beta> some_best some_worst)\n             \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     mix_pmf \\<beta> some_best\n      some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best\n                                  some_worst \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>mix_pmf \\<beta> some_best\n            some_worst \\<succeq>[\\<R>] mix_pmf \\<alpha> some_best\n  some_worst \\<and>\n           (mix_pmf \\<alpha> some_best some_worst,\n            mix_pmf \\<beta> some_best some_worst)\n           \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   mix_pmf \\<beta> some_best\n    some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best\n                                some_worst \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>mix_pmf \\<beta> some_best\n            some_worst \\<succeq>[\\<R>] mix_pmf \\<alpha> some_best\n  some_worst \\<and>\n           (mix_pmf \\<alpha> some_best some_worst,\n            mix_pmf \\<beta> some_best some_worst)\n           \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   mix_pmf \\<beta> some_best\n    some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best\n                                some_worst \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>mix_pmf \\<beta> some_best\n            some_worst \\<succeq>[\\<R>] mix_pmf \\<alpha> some_best\n  some_worst \\<and>\n           (mix_pmf \\<alpha> some_best some_worst,\n            mix_pmf \\<beta> some_best some_worst)\n           \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   mix_pmf \\<beta> some_best\n    some_worst \\<approx>[\\<R>] mix_pmf \\<alpha> some_best\n                                some_worst \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "by(cases) (meson assms(2) assms(3) geq_mix_imp_weak_pref le_cases *)+"], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ge_mix_pmf_preferred:\n  assumes \"x \\<succ>[\\<R>] y\"\n  assumes \"\\<alpha> \\<in> {0..1}\"\n    and \"\\<beta> \\<in> {0..1}\"\n  assumes \"\\<alpha> \\<ge> \\<beta>\"\n  shows \"(mix_pmf \\<alpha> x y) \\<succeq>[\\<R>] (mix_pmf \\<beta> x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y", "using assms(1) assms(2) assms(3) assms(4)"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y \\<and> (y, x) \\<notin> \\<R>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n  \\<beta> \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> x y \\<succeq>[\\<R>] mix_pmf \\<beta> x y", "by blast"], ["", "subsection \\<open> Add continuity to assumptions \\<close>"], ["", "context\n  assumes cnt: \"continuous_vnm (lotteries_on outcomes) \\<R>\"\nbegin"], ["", "text \\<open> In Literature this is referred to as step 2. \\<close>"], ["", "lemma step_2_unique_continuous_unfolding:\n  assumes \"p \\<succeq>[\\<R>] q\"\n    and \"q \\<succeq>[\\<R>] r\"\n    and \"p \\<succ>[\\<R>] r\"\n  shows \"\\<exists>!\\<alpha> \\<in> {0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and> q \\<approx>[\\<R>] mix_pmf \\<alpha> p r", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and>\n       q \\<approx>[\\<R>] mix_pmf \\<alpha> p r \\<Longrightarrow>\n    False", "assume neg_a: \"\\<nexists>!\\<alpha>. \\<alpha> \\<in> {0..1} \\<and> q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\""], ["proof (state)\nthis:\n  \\<nexists>!\\<alpha>.\n     \\<alpha> \\<in> {0..1} \\<and> q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\n\ngoal (1 subgoal):\n 1. \\<nexists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and>\n       q \\<approx>[\\<R>] mix_pmf \\<alpha> p r \\<Longrightarrow>\n    False", "have \"\\<exists>\\<alpha> \\<in> {0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r", "using non_unique_continuous_unfolding[of outcomes \\<R> p q r] \n      assms cnt rpr"], ["proof (prove)\nusing this:\n  \\<lbrakk>continuous_vnm local.\\<P> \\<R>;\n   rational_preference local.\\<P> \\<R>; p \\<succeq>[\\<R>] q;\n   q \\<succeq>[\\<R>] r;\n   p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                       q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\n  p \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] r\n  p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\n  continuous_vnm local.\\<P> \\<R>\n  rational_preference local.\\<P> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>\\<in>{0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\n\ngoal (1 subgoal):\n 1. \\<nexists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and>\n       q \\<approx>[\\<R>] mix_pmf \\<alpha> p r \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha>\\<in>{0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r", "obtain \\<alpha> \\<beta> :: real where\n    a_b: \"\\<alpha>\\<in>{0..1}\" \"\\<beta> \\<in>{0..1}\" \"q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\" \"q \\<approx>[\\<R>] mix_pmf \\<beta> p r\" \"\\<alpha> \\<noteq> \\<beta>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>\\<in>{0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> \\<beta>.\n        \\<lbrakk>\\<alpha> \\<in> {0..1}; \\<beta> \\<in> {0..1};\n         q \\<approx>[\\<R>] mix_pmf \\<alpha> p r;\n         q \\<approx>[\\<R>] mix_pmf \\<beta> p r;\n         \\<alpha> \\<noteq> \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using neg_a"], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>\\<in>{0..1}. q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\n  \\<nexists>!\\<alpha>.\n     \\<alpha> \\<in> {0..1} \\<and> q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> \\<beta>.\n        \\<lbrakk>\\<alpha> \\<in> {0..1}; \\<beta> \\<in> {0..1};\n         q \\<approx>[\\<R>] mix_pmf \\<alpha> p r;\n         q \\<approx>[\\<R>] mix_pmf \\<beta> p r;\n         \\<alpha> \\<noteq> \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n  q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\n  q \\<approx>[\\<R>] mix_pmf \\<beta> p r\n  \\<alpha> \\<noteq> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<nexists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and>\n       q \\<approx>[\\<R>] mix_pmf \\<alpha> p r \\<Longrightarrow>\n    False", "consider \"\\<alpha> > \\<beta>\" | \"\\<beta> > \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta> < \\<alpha> \\<Longrightarrow> thesis;\n     \\<alpha> < \\<beta> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using a_b"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n  q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\n  q \\<approx>[\\<R>] mix_pmf \\<beta> p r\n  \\<alpha> \\<noteq> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta> < \\<alpha> \\<Longrightarrow> thesis;\n     \\<alpha> < \\<beta> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>\\<beta> < \\<alpha> \\<Longrightarrow> ?thesis;\n   \\<alpha> < \\<beta> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<nexists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and>\n       q \\<approx>[\\<R>] mix_pmf \\<alpha> p r \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<beta> < \\<alpha> \\<Longrightarrow> ?thesis;\n   \\<alpha> < \\<beta> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<beta> < \\<alpha> \\<Longrightarrow> ?thesis;\n   \\<alpha> < \\<beta> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<beta> < \\<alpha> \\<Longrightarrow> False\n 2. \\<alpha> < \\<beta> \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  \\<beta> < \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<beta> < \\<alpha> \\<Longrightarrow> False\n 2. \\<alpha> < \\<beta> \\<Longrightarrow> False", "with step_1_most_general[of p r \\<alpha> \\<beta>] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>;\n   \\<alpha> \\<in> {0..1}; \\<beta> \\<in> {0..1}; \\<beta> < \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<alpha> p\n                     r \\<succeq>[\\<R>] mix_pmf \\<beta> p r \\<and>\n                    (mix_pmf \\<beta> p r, mix_pmf \\<alpha> p r)\n                    \\<notin> \\<R>\n  p \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] r\n  p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\n  \\<beta> < \\<alpha>", "have \"mix_pmf \\<alpha> p r \\<succ>[\\<R>] mix_pmf \\<beta> p r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>;\n   \\<alpha> \\<in> {0..1}; \\<beta> \\<in> {0..1}; \\<beta> < \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<alpha> p\n                     r \\<succeq>[\\<R>] mix_pmf \\<beta> p r \\<and>\n                    (mix_pmf \\<beta> p r, mix_pmf \\<alpha> p r)\n                    \\<notin> \\<R>\n  p \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] r\n  p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\n  \\<beta> < \\<alpha>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<beta> p r \\<and>\n    (mix_pmf \\<beta> p r, mix_pmf \\<alpha> p r) \\<notin> \\<R>", "using a_b(1) a_b(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>;\n   \\<alpha> \\<in> {0..1}; \\<beta> \\<in> {0..1}; \\<beta> < \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<alpha> p\n                     r \\<succeq>[\\<R>] mix_pmf \\<beta> p r \\<and>\n                    (mix_pmf \\<beta> p r, mix_pmf \\<alpha> p r)\n                    \\<notin> \\<R>\n  p \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] r\n  p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\n  \\<beta> < \\<alpha>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<beta> p r \\<and>\n    (mix_pmf \\<beta> p r, mix_pmf \\<alpha> p r) \\<notin> \\<R>", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<beta> p r \\<and>\n  (mix_pmf \\<beta> p r, mix_pmf \\<alpha> p r) \\<notin> \\<R>\n\ngoal (2 subgoals):\n 1. \\<beta> < \\<alpha> \\<Longrightarrow> False\n 2. \\<alpha> < \\<beta> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<beta> p r \\<and>\n  (mix_pmf \\<beta> p r, mix_pmf \\<alpha> p r) \\<notin> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<beta> p r \\<and>\n  (mix_pmf \\<beta> p r, mix_pmf \\<alpha> p r) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. False", "using a_b"], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<beta> p r \\<and>\n  (mix_pmf \\<beta> p r, mix_pmf \\<alpha> p r) \\<notin> \\<R>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n  q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\n  q \\<approx>[\\<R>] mix_pmf \\<beta> p r\n  \\<alpha> \\<noteq> \\<beta>\n\ngoal (1 subgoal):\n 1. False", "by (meson rational_preference.strict_is_neg_transitive relation_in_carrier rpr)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta> \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta> \\<Longrightarrow> False", "case 2"], ["proof (state)\nthis:\n  \\<alpha> < \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta> \\<Longrightarrow> False", "with step_1_most_general[of p r \\<beta> \\<alpha>] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>;\n   \\<beta> \\<in> {0..1}; \\<alpha> \\<in> {0..1}; \\<alpha> < \\<beta>\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<beta> p\n                     r \\<succeq>[\\<R>] mix_pmf \\<alpha> p r \\<and>\n                    (mix_pmf \\<alpha> p r, mix_pmf \\<beta> p r)\n                    \\<notin> \\<R>\n  p \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] r\n  p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\n  \\<alpha> < \\<beta>", "have \"mix_pmf \\<beta> p r \\<succ>[\\<R>]mix_pmf \\<alpha> p r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>;\n   \\<beta> \\<in> {0..1}; \\<alpha> \\<in> {0..1}; \\<alpha> < \\<beta>\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<beta> p\n                     r \\<succeq>[\\<R>] mix_pmf \\<alpha> p r \\<and>\n                    (mix_pmf \\<alpha> p r, mix_pmf \\<beta> p r)\n                    \\<notin> \\<R>\n  p \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] r\n  p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\n  \\<alpha> < \\<beta>\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> p r \\<and>\n    (mix_pmf \\<alpha> p r, mix_pmf \\<beta> p r) \\<notin> \\<R>", "using a_b(1) a_b(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>;\n   \\<beta> \\<in> {0..1}; \\<alpha> \\<in> {0..1}; \\<alpha> < \\<beta>\\<rbrakk>\n  \\<Longrightarrow> mix_pmf \\<beta> p\n                     r \\<succeq>[\\<R>] mix_pmf \\<alpha> p r \\<and>\n                    (mix_pmf \\<alpha> p r, mix_pmf \\<beta> p r)\n                    \\<notin> \\<R>\n  p \\<succeq>[\\<R>] q\n  q \\<succeq>[\\<R>] r\n  p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\n  \\<alpha> < \\<beta>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf \\<beta> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> p r \\<and>\n    (mix_pmf \\<alpha> p r, mix_pmf \\<beta> p r) \\<notin> \\<R>", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<beta> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> p r \\<and>\n  (mix_pmf \\<alpha> p r, mix_pmf \\<beta> p r) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  mix_pmf \\<beta> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> p r \\<and>\n  (mix_pmf \\<alpha> p r, mix_pmf \\<beta> p r) \\<notin> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf \\<beta> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> p r \\<and>\n  (mix_pmf \\<alpha> p r, mix_pmf \\<beta> p r) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. False", "using a_b"], ["proof (prove)\nusing this:\n  mix_pmf \\<beta> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> p r \\<and>\n  (mix_pmf \\<alpha> p r, mix_pmf \\<beta> p r) \\<notin> \\<R>\n  \\<alpha> \\<in> {0..1}\n  \\<beta> \\<in> {0..1}\n  q \\<approx>[\\<R>] mix_pmf \\<alpha> p r\n  q \\<approx>[\\<R>] mix_pmf \\<beta> p r\n  \\<alpha> \\<noteq> \\<beta>\n\ngoal (1 subgoal):\n 1. False", "by (meson rational_preference.strict_is_neg_transitive relation_in_carrier rpr)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> These folowing two lemmas are referred to sometimes called step 2. \\<close>"], ["", "lemma create_unique_indiff_using_distinct_best_worst:\n  assumes \"l \\<in> \\<P>\"\n  assumes \"b \\<in> best\"\n  assumes \"w \\<in> worst\"\n  assumes \"b \\<succ>[\\<R>] w\"\n  shows \"\\<exists>!\\<alpha> \\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and> l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and> l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "have \"b \\<succeq>[\\<R>] l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<succeq>[\\<R>] l", "using best_def"], ["proof (prove)\nusing this:\n  best =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y}\n\ngoal (1 subgoal):\n 1. b \\<succeq>[\\<R>] l", "using assms"], ["proof (prove)\nusing this:\n  best =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y}\n  l \\<in> local.\\<P>\n  b \\<in> best\n  w \\<in> worst\n  b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. b \\<succeq>[\\<R>] l", "by blast"], ["proof (state)\nthis:\n  b \\<succeq>[\\<R>] l\n\ngoal (1 subgoal):\n 1. \\<exists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and> l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "moreover"], ["proof (state)\nthis:\n  b \\<succeq>[\\<R>] l\n\ngoal (1 subgoal):\n 1. \\<exists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and> l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "have \"l \\<succeq>[\\<R>] w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<succeq>[\\<R>] w", "using worst_def assms"], ["proof (prove)\nusing this:\n  worst =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x}\n  l \\<in> local.\\<P>\n  b \\<in> best\n  w \\<in> worst\n  b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. l \\<succeq>[\\<R>] w", "by blast"], ["proof (state)\nthis:\n  l \\<succeq>[\\<R>] w\n\ngoal (1 subgoal):\n 1. \\<exists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and> l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "ultimately"], ["proof (chain)\npicking this:\n  b \\<succeq>[\\<R>] l\n  l \\<succeq>[\\<R>] w", "show \"\\<exists>!\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\""], ["proof (prove)\nusing this:\n  b \\<succeq>[\\<R>] l\n  l \\<succeq>[\\<R>] w\n\ngoal (1 subgoal):\n 1. \\<exists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and> l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "using step_2_unique_continuous_unfolding[of b l w] assms"], ["proof (prove)\nusing this:\n  b \\<succeq>[\\<R>] l\n  l \\<succeq>[\\<R>] w\n  \\<lbrakk>b \\<succeq>[\\<R>] l; l \\<succeq>[\\<R>] w;\n   b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!\\<alpha>.\n                       \\<alpha> \\<in> {0..1} \\<and>\n                       l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\n  l \\<in> local.\\<P>\n  b \\<in> best\n  w \\<in> worst\n  b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>!\\<alpha>.\n       \\<alpha> \\<in> {0..1} \\<and> l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "by linarith"], ["proof (state)\nthis:\n  \\<exists>!\\<alpha>.\n     \\<alpha> \\<in> {0..1} \\<and> l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_element_bw_mix_is_approx:\n  assumes \"l \\<in> \\<P>\"\n  assumes \"b \\<in> best\"\n  assumes \"w \\<in> worst\"\n  shows \"\\<exists>\\<alpha> \\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "consider \"b \\<succ>[\\<R>] w\" | \"b \\<approx>[\\<R>] w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<succeq>[\\<R>] w \\<and>\n             (w, b) \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     b \\<approx>[\\<R>] w \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(2) assms(3) best_def worst_def"], ["proof (prove)\nusing this:\n  b \\<in> best\n  w \\<in> worst\n  best =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y}\n  worst =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<succeq>[\\<R>] w \\<and>\n             (w, b) \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     b \\<approx>[\\<R>] w \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   b \\<approx>[\\<R>] w \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   b \\<approx>[\\<R>] w \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   b \\<approx>[\\<R>] w \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\n 2. b \\<approx>[\\<R>] w \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "case 1"], ["proof (state)\nthis:\n  b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R>\n\ngoal (2 subgoals):\n 1. b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\n 2. b \\<approx>[\\<R>] w \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "then"], ["proof (chain)\npicking this:\n  b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "using create_unique_indiff_using_distinct_best_worst assms"], ["proof (prove)\nusing this:\n  b \\<succeq>[\\<R>] w \\<and> (w, b) \\<notin> \\<R>\n  \\<lbrakk>?l \\<in> local.\\<P>; ?b \\<in> best; ?w \\<in> worst;\n   ?b \\<succeq>[\\<R>] ?w \\<and> (?w, ?b) \\<notin> \\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!\\<alpha>.\n                       \\<alpha> \\<in> {0..1} \\<and>\n                       ?l \\<approx>[\\<R>] mix_pmf \\<alpha> ?b ?w\n  l \\<in> local.\\<P>\n  b \\<in> best\n  w \\<in> worst\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\n\ngoal (1 subgoal):\n 1. b \\<approx>[\\<R>] w \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w", "qed (auto simp: all_mix_pmf_indiff_indiff_best_worst assms)"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>\\<in>{0..1}. l \\<approx>[\\<R>] mix_pmf \\<alpha> b w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma my_U_is_defined:\n  assumes \"p \\<in> \\<P>\"\n  shows \"my_U p \\<in> {0..1}\" \"p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&&\n    p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. my_U p \\<in> {0..1}\n 2. p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst", "have \"some_best \\<in> best\""], ["proof (prove)\ngoal (1 subgoal):\n 1. some_best \\<in> best", "by (simp add: some_best_in_best)"], ["proof (state)\nthis:\n  some_best \\<in> best\n\ngoal (2 subgoals):\n 1. my_U p \\<in> {0..1}\n 2. p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst", "moreover"], ["proof (state)\nthis:\n  some_best \\<in> best\n\ngoal (2 subgoals):\n 1. my_U p \\<in> {0..1}\n 2. p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst", "have \"some_worst \\<in> worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. some_worst \\<in> worst", "by (simp add: some_worst_in_worst)"], ["proof (state)\nthis:\n  some_worst \\<in> worst\n\ngoal (2 subgoals):\n 1. my_U p \\<in> {0..1}\n 2. p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst", "with exists_element_bw_mix_is_approx[of p \"some_best\" \"some_worst\"] calculation assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<in> local.\\<P>; some_best \\<in> best;\n   some_worst \\<in> worst\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                       p \\<approx>[\\<R>] mix_pmf \\<alpha> some_best\n    some_worst\n  some_best \\<in> best\n  p \\<in> local.\\<P>\n  some_worst \\<in> worst", "have e: \"\\<exists>\\<alpha>\\<in>{0..1}. p \\<approx>[\\<R>] mix_pmf \\<alpha> some_best some_worst\""], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<in> local.\\<P>; some_best \\<in> best;\n   some_worst \\<in> worst\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                       p \\<approx>[\\<R>] mix_pmf \\<alpha> some_best\n    some_worst\n  some_best \\<in> best\n  p \\<in> local.\\<P>\n  some_worst \\<in> worst\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}.\n       p \\<approx>[\\<R>] mix_pmf \\<alpha> some_best some_worst", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>\\<in>{0..1}.\n     p \\<approx>[\\<R>] mix_pmf \\<alpha> some_best some_worst\n\ngoal (2 subgoals):\n 1. my_U p \\<in> {0..1}\n 2. p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha>\\<in>{0..1}.\n     p \\<approx>[\\<R>] mix_pmf \\<alpha> some_best some_worst", "show \"my_U p \\<in> {0..1}\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>\\<in>{0..1}.\n     p \\<approx>[\\<R>] mix_pmf \\<alpha> some_best some_worst\n\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1}", "by (metis (mono_tags, lifting) my_U_def someI_ex)"], ["proof (state)\nthis:\n  my_U p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst", "show \"p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst", "by (metis (mono_tags, lifting) e my_U_def someI_ex)"], ["proof (state)\nthis:\n  p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma weak_pref_mix_with_my_U_weak_pref:\n  assumes \"p \\<succeq>[\\<R>] q\"\n  shows \"mix_pmf (my_U p) some_best some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst", "by (meson assms my_U_is_defined(2) relation_in_carrier rpr \n      rational_preference.weak_is_transitive)"], ["", "lemma preferred_greater_my_U: \n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n  assumes \"mix_pmf (my_U p) some_best some_worst \\<succ>[\\<R>] mix_pmf (my_U q) some_best some_worst\"\n  shows \"my_U p > my_U q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_U q < my_U p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> my_U q < my_U p \\<Longrightarrow> False", "assume \"\\<not> my_U p > my_U q\""], ["proof (state)\nthis:\n  \\<not> my_U q < my_U p\n\ngoal (1 subgoal):\n 1. \\<not> my_U q < my_U p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> my_U q < my_U p", "consider \"my_U p = my_U q\" | \"my_U p < my_U q\""], ["proof (prove)\nusing this:\n  \\<not> my_U q < my_U p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>my_U p = my_U q \\<Longrightarrow> thesis;\n     my_U p < my_U q \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>my_U p = my_U q \\<Longrightarrow> ?thesis;\n   my_U p < my_U q \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> my_U q < my_U p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>my_U p = my_U q \\<Longrightarrow> ?thesis;\n   my_U p < my_U q \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>my_U p = my_U q \\<Longrightarrow> ?thesis;\n   my_U p < my_U q \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. my_U p = my_U q \\<Longrightarrow> False\n 2. my_U p < my_U q \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  my_U p = my_U q\n\ngoal (2 subgoals):\n 1. my_U p = my_U q \\<Longrightarrow> False\n 2. my_U p < my_U q \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  my_U p = my_U q", "have \"mix_pmf (my_U p) some_best some_worst \\<approx>[\\<R>] mix_pmf (my_U q) some_best some_worst\""], ["proof (prove)\nusing this:\n  my_U p = my_U q\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<approx>[\\<R>] mix_pmf (my_U q) some_best some_worst", "using assms"], ["proof (prove)\nusing this:\n  my_U p = my_U q\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n  (mix_pmf (my_U q) some_best some_worst,\n   mix_pmf (my_U p) some_best some_worst)\n  \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<approx>[\\<R>] mix_pmf (my_U q) some_best some_worst", "by auto"], ["proof (state)\nthis:\n  mix_pmf (my_U p) some_best\n   some_worst \\<approx>[\\<R>] mix_pmf (my_U q) some_best some_worst\n\ngoal (2 subgoals):\n 1. my_U p = my_U q \\<Longrightarrow> False\n 2. my_U p < my_U q \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  mix_pmf (my_U p) some_best\n   some_worst \\<approx>[\\<R>] mix_pmf (my_U q) some_best some_worst", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf (my_U p) some_best\n   some_worst \\<approx>[\\<R>] mix_pmf (my_U q) some_best some_worst\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  mix_pmf (my_U p) some_best\n   some_worst \\<approx>[\\<R>] mix_pmf (my_U q) some_best some_worst\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n  (mix_pmf (my_U q) some_best some_worst,\n   mix_pmf (my_U p) some_best some_worst)\n  \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. my_U p < my_U q \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. my_U p < my_U q \\<Longrightarrow> False", "case 2"], ["proof (state)\nthis:\n  my_U p < my_U q\n\ngoal (1 subgoal):\n 1. my_U p < my_U q \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  my_U p < my_U q\n\ngoal (1 subgoal):\n 1. my_U p < my_U q \\<Longrightarrow> False", "have \"my_U q \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_U q \\<in> {0..1}", "using assms(2) my_U_is_defined(1)"], ["proof (prove)\nusing this:\n  q \\<in> local.\\<P>\n  ?p \\<in> local.\\<P> \\<Longrightarrow> my_U ?p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U q \\<in> {0..1}", "by blast"], ["proof (state)\nthis:\n  my_U q \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U p < my_U q \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  my_U q \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U p < my_U q \\<Longrightarrow> False", "have \"my_U p \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1}", "using assms(1) my_U_is_defined(1)"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  ?p \\<in> local.\\<P> \\<Longrightarrow> my_U ?p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1}", "by blast"], ["proof (state)\nthis:\n  my_U p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U p < my_U q \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  my_U p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U p < my_U q \\<Longrightarrow> False", "have \"mix_pmf (my_U q) some_best some_worst \\<succeq>[\\<R>] mix_pmf (my_U p) some_best some_worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf (my_U q) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U p) some_best some_worst", "using calculation geq_mix_imp_weak_pref"], ["proof (prove)\nusing this:\n  my_U p < my_U q\n  my_U q \\<in> {0..1}\n  my_U p \\<in> {0..1}\n  \\<lbrakk>?\\<alpha> \\<in> {0..1}; ?\\<beta> \\<in> {0..1};\n   ?\\<beta> \\<le> ?\\<alpha>\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> some_best\n                     some_worst \\<succeq>[\\<R>] mix_pmf ?\\<beta> some_best\n           some_worst\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U q) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U p) some_best some_worst", "by auto"], ["proof (state)\nthis:\n  mix_pmf (my_U q) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U p) some_best some_worst\n\ngoal (1 subgoal):\n 1. my_U p < my_U q \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  mix_pmf (my_U q) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U p) some_best some_worst", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf (my_U q) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U p) some_best some_worst\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  mix_pmf (my_U q) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U p) some_best some_worst\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n  (mix_pmf (my_U q) some_best some_worst,\n   mix_pmf (my_U p) some_best some_worst)\n  \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma geq_my_U_imp_weak_preference:\n  assumes \"p \\<in> \\<P>\" \n    and \"q \\<in> \\<P>\" \n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  assumes \"my_U p \\<ge> my_U q\"\n  shows \"p \\<succeq>[\\<R>] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "have p_q: \"my_U p \\<in> {0..1}\" \"my_U q \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "using assms my_U_is_defined(1)"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  my_U q \\<le> my_U p\n  ?p \\<in> local.\\<P> \\<Longrightarrow> my_U ?p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "by blast+"], ["proof (state)\nthis:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "with ge_mix_pmf_preferred[of \"some_best\" \"some_worst\" \"my_U p\" \"my_U q\"] \n    p_q assms(1) assms(3) assms(4)"], ["proof (chain)\npicking this:\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R>;\n   my_U p \\<in> {0..1}; my_U q \\<in> {0..1}; my_U q \\<le> my_U p\\<rbrakk>\n  \\<Longrightarrow> mix_pmf (my_U p) some_best\n                     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best\n           some_worst\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n  p \\<in> local.\\<P>\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  my_U q \\<le> my_U p\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}", "have \"mix_pmf (my_U p) some_best some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst\""], ["proof (prove)\nusing this:\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R>;\n   my_U p \\<in> {0..1}; my_U q \\<in> {0..1}; my_U q \\<le> my_U p\\<rbrakk>\n  \\<Longrightarrow> mix_pmf (my_U p) some_best\n                     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best\n           some_worst\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n  p \\<in> local.\\<P>\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  my_U q \\<le> my_U p\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst", "by blast"], ["proof (state)\nthis:\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "consider \"my_U p = my_U q\" | \"my_U p > my_U q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>my_U p = my_U q \\<Longrightarrow> thesis;\n     my_U q < my_U p \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  my_U q \\<le> my_U p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>my_U p = my_U q \\<Longrightarrow> thesis;\n     my_U q < my_U p \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>my_U p = my_U q \\<Longrightarrow> ?thesis;\n   my_U q < my_U p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>my_U p = my_U q \\<Longrightarrow> ?thesis;\n   my_U q < my_U p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>my_U p = my_U q \\<Longrightarrow> ?thesis;\n   my_U q < my_U p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. my_U p = my_U q \\<Longrightarrow> p \\<succeq>[\\<R>] q\n 2. my_U q < my_U p \\<Longrightarrow> p \\<succeq>[\\<R>] q", "case 2"], ["proof (state)\nthis:\n  my_U q < my_U p\n\ngoal (2 subgoals):\n 1. my_U p = my_U q \\<Longrightarrow> p \\<succeq>[\\<R>] q\n 2. my_U q < my_U p \\<Longrightarrow> p \\<succeq>[\\<R>] q", "then"], ["proof (chain)\npicking this:\n  my_U q < my_U p", "show ?thesis"], ["proof (prove)\nusing this:\n  my_U q < my_U p\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "by (meson assms(1) assms(2) assms(3) p_q(1) p_q(2) rational_preference.compl \n          rpr step_1_most_general weak_pref_mix_with_my_U_weak_pref)"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q\n\ngoal (1 subgoal):\n 1. my_U p = my_U q \\<Longrightarrow> p \\<succeq>[\\<R>] q", "qed (metis assms(1) assms(2) my_U_is_defined(2) trans_approx)"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma my_U_represents_pref:\n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  assumes \"p \\<in> \\<P>\" \n    and \"q \\<in> \\<P>\" \n  shows \"p \\<succeq>[\\<R>] q \\<longleftrightarrow> my_U p \\<ge> my_U q\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q = (my_U q \\<le> my_U p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q = (my_U q \\<le> my_U p)", "have p_def: \"my_U p\\<in> {0..1}\" \"my_U q \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "using assms my_U_is_defined"], ["proof (prove)\nusing this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  ?p \\<in> local.\\<P> \\<Longrightarrow> my_U ?p \\<in> {0..1}\n  ?p \\<in> local.\\<P> \\<Longrightarrow>\n  ?p \\<approx>[\\<R>] mix_pmf (my_U ?p) some_best some_worst\n\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "by blast+"], ["proof (state)\nthis:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q = (my_U q \\<le> my_U p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q = (my_U q \\<le> my_U p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow> my_U q \\<le> my_U p\n 2. my_U q \\<le> my_U p \\<Longrightarrow> p \\<succeq>[\\<R>] q", "assume a: ?L"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow> my_U q \\<le> my_U p\n 2. my_U q \\<le> my_U p \\<Longrightarrow> p \\<succeq>[\\<R>] q", "hence \"mix_pmf (my_U p) some_best some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst\""], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] q\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst", "using weak_pref_mix_with_my_U_weak_pref"], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] q\n  ?p \\<succeq>[\\<R>] ?q \\<Longrightarrow>\n  mix_pmf (my_U ?p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U ?q) some_best some_worst\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst", "by auto"], ["proof (state)\nthis:\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow> my_U q \\<le> my_U p\n 2. my_U q \\<le> my_U p \\<Longrightarrow> p \\<succeq>[\\<R>] q", "then"], ["proof (chain)\npicking this:\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst", "show ?R"], ["proof (prove)\nusing this:\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst\n\ngoal (1 subgoal):\n 1. my_U q \\<le> my_U p", "using leq_mix_imp_weak_inferior[of \"my_U p\" \"my_U q\"] p_def a\n        assms(1) leq_mix_imp_weak_inferior"], ["proof (prove)\nusing this:\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R>;\n   my_U p \\<in> {0..1}; my_U q \\<in> {0..1};\n   mix_pmf (my_U q) some_best\n    some_worst \\<succeq>[\\<R>] mix_pmf (my_U p) some_best\n                                some_worst\\<rbrakk>\n  \\<Longrightarrow> my_U p \\<le> my_U q\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n  p \\<succeq>[\\<R>] q\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R>;\n   ?\\<alpha> \\<in> {0..1}; ?\\<beta> \\<in> {0..1};\n   mix_pmf ?\\<beta> some_best\n    some_worst \\<succeq>[\\<R>] mix_pmf ?\\<alpha> some_best\n                                some_worst\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> \\<le> ?\\<beta>\n\ngoal (1 subgoal):\n 1. my_U q \\<le> my_U p", "by blast"], ["proof (state)\nthis:\n  my_U q \\<le> my_U p\n\ngoal (1 subgoal):\n 1. my_U q \\<le> my_U p \\<Longrightarrow> p \\<succeq>[\\<R>] q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. my_U q \\<le> my_U p \\<Longrightarrow> p \\<succeq>[\\<R>] q", "assume ?R"], ["proof (state)\nthis:\n  my_U q \\<le> my_U p\n\ngoal (1 subgoal):\n 1. my_U q \\<le> my_U p \\<Longrightarrow> p \\<succeq>[\\<R>] q", "then"], ["proof (chain)\npicking this:\n  my_U q \\<le> my_U p", "show ?L"], ["proof (prove)\nusing this:\n  my_U q \\<le> my_U p\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "using geq_my_U_imp_weak_preference"], ["proof (prove)\nusing this:\n  my_U q \\<le> my_U p\n  \\<lbrakk>?p \\<in> local.\\<P>; ?q \\<in> local.\\<P>;\n   some_best \\<succeq>[\\<R>] some_worst \\<and>\n   (some_worst, some_best) \\<notin> \\<R>;\n   my_U ?q \\<le> my_U ?p\\<rbrakk>\n  \\<Longrightarrow> ?p \\<succeq>[\\<R>] ?q\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "using assms(1) assms(2) assms(3)"], ["proof (prove)\nusing this:\n  my_U q \\<le> my_U p\n  \\<lbrakk>?p \\<in> local.\\<P>; ?q \\<in> local.\\<P>;\n   some_best \\<succeq>[\\<R>] some_worst \\<and>\n   (some_worst, some_best) \\<notin> \\<R>;\n   my_U ?q \\<le> my_U ?p\\<rbrakk>\n  \\<Longrightarrow> ?p \\<succeq>[\\<R>] ?q\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "by blast"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q = (my_U q \\<le> my_U p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma first_iff_u_greater_strict_preff:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  shows \"my_U p > my_U q \\<longleftrightarrow> mix_pmf (my_U p) some_best some_worst \\<succ>[\\<R>] mix_pmf (my_U q) some_best some_worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (my_U q < my_U p) =\n    (mix_pmf (my_U p) some_best\n      some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best\n                                  some_worst \\<and>\n     (mix_pmf (my_U q) some_best some_worst,\n      mix_pmf (my_U p) some_best some_worst)\n     \\<notin> \\<R>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. my_U q < my_U p \\<Longrightarrow>\n    mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>\n 2. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R> \\<Longrightarrow>\n    my_U q < my_U p", "assume a: \"my_U p > my_U q\""], ["proof (state)\nthis:\n  my_U q < my_U p\n\ngoal (2 subgoals):\n 1. my_U q < my_U p \\<Longrightarrow>\n    mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>\n 2. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R> \\<Longrightarrow>\n    my_U q < my_U p", "have \"my_U p \\<in> {0..1}\" \"my_U q \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "using assms my_U_is_defined(1)"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  ?p \\<in> local.\\<P> \\<Longrightarrow> my_U ?p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "by blast+"], ["proof (state)\nthis:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n\ngoal (2 subgoals):\n 1. my_U q < my_U p \\<Longrightarrow>\n    mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>\n 2. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R> \\<Longrightarrow>\n    my_U q < my_U p", "then"], ["proof (chain)\npicking this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}", "show \"mix_pmf (my_U p) some_best some_worst \\<succ>[\\<R>] mix_pmf (my_U q) some_best some_worst\""], ["proof (prove)\nusing this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>", "using a assms(3)"], ["proof (prove)\nusing this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n  my_U q < my_U p\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>", "by blast"], ["proof (state)\nthis:\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n  (mix_pmf (my_U q) some_best some_worst,\n   mix_pmf (my_U p) some_best some_worst)\n  \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R> \\<Longrightarrow>\n    my_U q < my_U p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R> \\<Longrightarrow>\n    my_U q < my_U p", "assume a: \"mix_pmf (my_U p) some_best some_worst \\<succ>[\\<R>] mix_pmf (my_U q) some_best some_worst\""], ["proof (state)\nthis:\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n  (mix_pmf (my_U q) some_best some_worst,\n   mix_pmf (my_U p) some_best some_worst)\n  \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R> \\<Longrightarrow>\n    my_U q < my_U p", "have \"my_U p \\<in> {0..1}\" \"my_U q \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "using assms my_U_is_defined(1)"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  ?p \\<in> local.\\<P> \\<Longrightarrow> my_U ?p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "by blast+"], ["proof (state)\nthis:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R> \\<Longrightarrow>\n    my_U q < my_U p", "then"], ["proof (chain)\npicking this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}", "show \"my_U p > my_U q \""], ["proof (prove)\nusing this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U q < my_U p", "using preferred_greater_my_U[of p q] assms a"], ["proof (prove)\nusing this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n  \\<lbrakk>p \\<in> local.\\<P>; q \\<in> local.\\<P>;\n   mix_pmf (my_U p) some_best\n    some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n   (mix_pmf (my_U q) some_best some_worst,\n    mix_pmf (my_U p) some_best some_worst)\n   \\<notin> \\<R>\\<rbrakk>\n  \\<Longrightarrow> my_U q < my_U p\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n  (mix_pmf (my_U q) some_best some_worst,\n   mix_pmf (my_U p) some_best some_worst)\n  \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. my_U q < my_U p", "by blast"], ["proof (state)\nthis:\n  my_U q < my_U p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma second_iff_calib_mix_pref_strict_pref:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n  assumes \"some_best \\<succ>[\\<R>] some_worst\"\n  shows \"mix_pmf (my_U p) some_best some_worst \\<succ>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<longleftrightarrow> p \\<succ>[\\<R>] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mix_pmf (my_U p) some_best\n      some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best\n                                  some_worst \\<and>\n     (mix_pmf (my_U q) some_best some_worst,\n      mix_pmf (my_U p) some_best some_worst)\n     \\<notin> \\<R>) =\n    (p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R> \\<Longrightarrow>\n    p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R>\n 2. p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R> \\<Longrightarrow>\n    mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>", "assume a: \"mix_pmf (my_U p) some_best some_worst \\<succ>[\\<R>] mix_pmf (my_U q) some_best some_worst\""], ["proof (state)\nthis:\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n  (mix_pmf (my_U q) some_best some_worst,\n   mix_pmf (my_U p) some_best some_worst)\n  \\<notin> \\<R>\n\ngoal (2 subgoals):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R> \\<Longrightarrow>\n    p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R>\n 2. p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R> \\<Longrightarrow>\n    mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>", "have \"my_U p \\<in> {0..1}\" \"my_U q \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "using assms my_U_is_defined(1)"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  ?p \\<in> local.\\<P> \\<Longrightarrow> my_U ?p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "by blast+"], ["proof (state)\nthis:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n\ngoal (2 subgoals):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R> \\<Longrightarrow>\n    p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R>\n 2. p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R> \\<Longrightarrow>\n    mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}", "show \"p \\<succ>[\\<R>] q\""], ["proof (prove)\nusing this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R>", "using a assms(3) assms(1) assms(2) geq_my_U_imp_weak_preference \n      leq_mix_imp_weak_inferior weak_pref_mix_with_my_U_weak_pref"], ["proof (prove)\nusing this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n  (mix_pmf (my_U q) some_best some_worst,\n   mix_pmf (my_U p) some_best some_worst)\n  \\<notin> \\<R>\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  \\<lbrakk>?p \\<in> local.\\<P>; ?q \\<in> local.\\<P>;\n   some_best \\<succeq>[\\<R>] some_worst \\<and>\n   (some_worst, some_best) \\<notin> \\<R>;\n   my_U ?q \\<le> my_U ?p\\<rbrakk>\n  \\<Longrightarrow> ?p \\<succeq>[\\<R>] ?q\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R>;\n   ?\\<alpha> \\<in> {0..1}; ?\\<beta> \\<in> {0..1};\n   mix_pmf ?\\<beta> some_best\n    some_worst \\<succeq>[\\<R>] mix_pmf ?\\<alpha> some_best\n                                some_worst\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> \\<le> ?\\<beta>\n  ?p \\<succeq>[\\<R>] ?q \\<Longrightarrow>\n  mix_pmf (my_U ?p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U ?q) some_best some_worst\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R>", "by blast"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R> \\<Longrightarrow>\n    mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R> \\<Longrightarrow>\n    mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>", "assume a: \"p \\<succ>[\\<R>] q\""], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R> \\<Longrightarrow>\n    mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>", "have \"my_U p \\<in> {0..1}\" \"my_U q \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "using assms my_U_is_defined(1)"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  ?p \\<in> local.\\<P> \\<Longrightarrow> my_U ?p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U p \\<in> {0..1} &&& my_U q \\<in> {0..1}", "by blast+"], ["proof (state)\nthis:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R> \\<Longrightarrow>\n    mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>", "then"], ["proof (chain)\npicking this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}", "show \"mix_pmf (my_U p) some_best some_worst \\<succ>[\\<R>] mix_pmf (my_U q) some_best some_worst\""], ["proof (prove)\nusing this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>", "using a assms(1) assms(2) assms(3) leq_mix_imp_weak_inferior my_U_represents_pref"], ["proof (prove)\nusing this:\n  my_U p \\<in> {0..1}\n  my_U q \\<in> {0..1}\n  p \\<succeq>[\\<R>] q \\<and> (q, p) \\<notin> \\<R>\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R>;\n   ?\\<alpha> \\<in> {0..1}; ?\\<beta> \\<in> {0..1};\n   mix_pmf ?\\<beta> some_best\n    some_worst \\<succeq>[\\<R>] mix_pmf ?\\<alpha> some_best\n                                some_worst\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> \\<le> ?\\<beta>\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R>;\n   ?p \\<in> local.\\<P>; ?q \\<in> local.\\<P>\\<rbrakk>\n  \\<Longrightarrow> ?p \\<succeq>[\\<R>] ?q = (my_U ?q \\<le> my_U ?p)\n\ngoal (1 subgoal):\n 1. mix_pmf (my_U p) some_best\n     some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n    (mix_pmf (my_U q) some_best some_worst,\n     mix_pmf (my_U p) some_best some_worst)\n    \\<notin> \\<R>", "by blast"], ["proof (state)\nthis:\n  mix_pmf (my_U p) some_best\n   some_worst \\<succeq>[\\<R>] mix_pmf (my_U q) some_best some_worst \\<and>\n  (mix_pmf (my_U q) some_best some_worst,\n   mix_pmf (my_U p) some_best some_worst)\n  \\<notin> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma my_U_is_linear_function:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  assumes \"some_best \\<succ>[\\<R>] some_worst\" \n  shows \"my_U (mix_pmf \\<alpha> p q) = \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "define B where B: \"B = some_best\""], ["proof (state)\nthis:\n  B = some_best\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "define W where W:\"W = some_worst\""], ["proof (state)\nthis:\n  W = some_worst\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "define Up where Up: \"Up = my_U p\""], ["proof (state)\nthis:\n  Up = my_U p\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "define Uq where Uq: \"Uq = my_U q\""], ["proof (state)\nthis:\n  Uq = my_U q\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "have long_in: \"(\\<alpha> * Up + (1 - \\<alpha>) * Uq) \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "have \"Up \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Up \\<in> {0..1}", "using assms Up my_U_is_defined(1)"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  \\<alpha> \\<in> {0..1}\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  Up = my_U p\n  ?p \\<in> local.\\<P> \\<Longrightarrow> my_U ?p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. Up \\<in> {0..1}", "by blast"], ["proof (state)\nthis:\n  Up \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "moreover"], ["proof (state)\nthis:\n  Up \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "have \"Uq \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Uq \\<in> {0..1}", "using assms Uq my_U_is_defined(1)"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  \\<alpha> \\<in> {0..1}\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  Uq = my_U q\n  ?p \\<in> local.\\<P> \\<Longrightarrow> my_U ?p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. Uq \\<in> {0..1}", "by blast"], ["proof (state)\nthis:\n  Uq \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "moreover"], ["proof (state)\nthis:\n  Uq \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "have \"\\<alpha> * Up \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> * Up \\<in> {0..1}", "using \\<open>Up \\<in> {0..1}\\<close> assms(3) mult_le_one"], ["proof (prove)\nusing this:\n  Up \\<in> {0..1}\n  \\<alpha> \\<in> {0..1}\n  \\<lbrakk>?a \\<le> (1::?'a); (0::?'a) \\<le> ?b; ?b \\<le> (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?a * ?b \\<le> (1::?'a)\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up \\<in> {0..1}", "by auto"], ["proof (state)\nthis:\n  \\<alpha> * Up \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "moreover"], ["proof (state)\nthis:\n  \\<alpha> * Up \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "have \"1-\\<alpha> \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - \\<alpha> \\<in> {0..1}", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. 1 - \\<alpha> \\<in> {0..1}", "by auto"], ["proof (state)\nthis:\n  1 - \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "moreover"], ["proof (state)\nthis:\n  1 - \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "have \"(1 - \\<alpha>) * Uq \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - \\<alpha>) * Uq \\<in> {0..1}", "using mult_le_one[of \"1-\\<alpha>\" Uq] calculation(2) calculation(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 - \\<alpha> \\<le> 1; 0 \\<le> Uq; Uq \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> (1 - \\<alpha>) * Uq \\<le> 1\n  Uq \\<in> {0..1}\n  1 - \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. (1 - \\<alpha>) * Uq \\<in> {0..1}", "by auto"], ["proof (state)\nthis:\n  (1 - \\<alpha>) * Uq \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "ultimately"], ["proof (chain)\npicking this:\n  Up \\<in> {0..1}\n  Uq \\<in> {0..1}\n  \\<alpha> * Up \\<in> {0..1}\n  1 - \\<alpha> \\<in> {0..1}\n  (1 - \\<alpha>) * Uq \\<in> {0..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  Up \\<in> {0..1}\n  Uq \\<in> {0..1}\n  \\<alpha> * Up \\<in> {0..1}\n  1 - \\<alpha> \\<in> {0..1}\n  (1 - \\<alpha>) * Uq \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "using add_nonneg_nonneg[of \"\\<alpha> * Up\" \"(1 - \\<alpha>) * Uq\"] \n        convex_bound_le[of Up 1 Uq \\<alpha> \"1-\\<alpha>\"]"], ["proof (prove)\nusing this:\n  Up \\<in> {0..1}\n  Uq \\<in> {0..1}\n  \\<alpha> * Up \\<in> {0..1}\n  1 - \\<alpha> \\<in> {0..1}\n  (1 - \\<alpha>) * Uq \\<in> {0..1}\n  \\<lbrakk>0 \\<le> \\<alpha> * Up; 0 \\<le> (1 - \\<alpha>) * Uq\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> \\<alpha> * Up + (1 - \\<alpha>) * Uq\n  \\<lbrakk>Up \\<le> 1; Uq \\<le> 1; 0 \\<le> \\<alpha>; 0 \\<le> 1 - \\<alpha>;\n   \\<alpha> + (1 - \\<alpha>) = 1\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}", "by simp"], ["proof (state)\nthis:\n  \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "have fst: \"p \\<approx>[\\<R>] (mix_pmf Up B W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<approx>[\\<R>] mix_pmf Up B W", "using assms my_U_is_defined[of p] B W Up"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  \\<alpha> \\<in> {0..1}\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  p \\<in> local.\\<P> \\<Longrightarrow> my_U p \\<in> {0..1}\n  p \\<in> local.\\<P> \\<Longrightarrow>\n  p \\<approx>[\\<R>] mix_pmf (my_U p) some_best some_worst\n  B = some_best\n  W = some_worst\n  Up = my_U p\n\ngoal (1 subgoal):\n 1. p \\<approx>[\\<R>] mix_pmf Up B W", "by simp"], ["proof (state)\nthis:\n  p \\<approx>[\\<R>] mix_pmf Up B W\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "have snd: \"q \\<approx>[\\<R>] (mix_pmf Uq B W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<approx>[\\<R>] mix_pmf Uq B W", "using assms my_U_is_defined[of q] B W Uq"], ["proof (prove)\nusing this:\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  \\<alpha> \\<in> {0..1}\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  q \\<in> local.\\<P> \\<Longrightarrow> my_U q \\<in> {0..1}\n  q \\<in> local.\\<P> \\<Longrightarrow>\n  q \\<approx>[\\<R>] mix_pmf (my_U q) some_best some_worst\n  B = some_best\n  W = some_worst\n  Uq = my_U q\n\ngoal (1 subgoal):\n 1. q \\<approx>[\\<R>] mix_pmf Uq B W", "by simp"], ["proof (state)\nthis:\n  q \\<approx>[\\<R>] mix_pmf Uq B W\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "have mp_in: \"(mix_pmf Up B W) \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf Up B W \\<in> local.\\<P>", "using fst relation_in_carrier"], ["proof (prove)\nusing this:\n  p \\<approx>[\\<R>] mix_pmf Up B W\n  ?x \\<succeq>[\\<R>] ?y \\<Longrightarrow>\n  ?x \\<in> local.\\<P> \\<and> ?y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. mix_pmf Up B W \\<in> local.\\<P>", "by blast"], ["proof (state)\nthis:\n  mix_pmf Up B W \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "have f2: \"mix_pmf \\<alpha> p q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf Up B W) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf Up B W) q", "using fst assms(2) assms(3) mix_pmf_preferred_independence"], ["proof (prove)\nusing this:\n  p \\<approx>[\\<R>] mix_pmf Up B W\n  q \\<in> local.\\<P>\n  \\<alpha> \\<in> {0..1}\n  \\<lbrakk>?r \\<in> local.\\<P>; ?\\<alpha> \\<in> {0..1};\n   ?p \\<succeq>[\\<R>] ?q\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?p\n                     ?r \\<succeq>[\\<R>] mix_pmf ?\\<alpha> ?q ?r\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf Up B W) q", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf Up B W) q\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "have **: \"mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W) = \n            mix_pmf (\\<alpha> * Up + (1-\\<alpha>) * Uq) B W\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W) =\n    mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W) =\n    mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W", "let ?mixPQ = \"(mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W)\""], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W) =\n    mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W", "have \"\\<forall>e\\<in>set_pmf ?L. pmf (?L) e = pmf ?mixPQ e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set_pmf\n                    (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)).\n       pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n       pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> set_pmf\n                (mix_pmf \\<alpha> (mix_pmf Up B W)\n                  (mix_pmf Uq B W)) \\<Longrightarrow>\n       pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n       pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> set_pmf\n                (mix_pmf \\<alpha> (mix_pmf Up B W)\n                  (mix_pmf Uq B W)) \\<Longrightarrow>\n       pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n       pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e", "assume asm: \"e \\<in> set_pmf ?L\""], ["proof (state)\nthis:\n  e \\<in> set_pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W))\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> set_pmf\n                (mix_pmf \\<alpha> (mix_pmf Up B W)\n                  (mix_pmf Uq B W)) \\<Longrightarrow>\n       pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n       pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e", "have i1: \"pmf (?L) e = \\<alpha> * pmf (mix_pmf Up B W) e + \n        pmf (mix_pmf Uq B W) e - \\<alpha> * pmf (mix_pmf Uq B W) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n    \\<alpha> * pmf (mix_pmf Up B W) e + pmf (mix_pmf Uq B W) e -\n    \\<alpha> * pmf (mix_pmf Uq B W) e", "using pmf_mix_deeper[of \\<alpha> \"mix_pmf Up B W\" \"(mix_pmf Uq B W)\" e] assms(3)"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {0..1} \\<Longrightarrow>\n  pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n  \\<alpha> * pmf (mix_pmf Up B W) e + pmf (mix_pmf Uq B W) e -\n  \\<alpha> * pmf (mix_pmf Uq B W) e\n  \\<alpha> \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n    \\<alpha> * pmf (mix_pmf Up B W) e + pmf (mix_pmf Uq B W) e -\n    \\<alpha> * pmf (mix_pmf Uq B W) e", "by blast"], ["proof (state)\nthis:\n  pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n  \\<alpha> * pmf (mix_pmf Up B W) e + pmf (mix_pmf Uq B W) e -\n  \\<alpha> * pmf (mix_pmf Uq B W) e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> set_pmf\n                (mix_pmf \\<alpha> (mix_pmf Up B W)\n                  (mix_pmf Uq B W)) \\<Longrightarrow>\n       pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n       pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e", "have i3: \"... = \\<alpha> * Up * pmf B e + \\<alpha> * pmf W e - \\<alpha> * Up * pmf W e + Uq * pmf B e + \n        pmf W e - Uq * pmf W e - \\<alpha> * Uq * pmf B e - \\<alpha> * pmf W e + \\<alpha> * Uq * pmf W e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> * pmf (mix_pmf Up B W) e + pmf (mix_pmf Uq B W) e -\n    \\<alpha> * pmf (mix_pmf Uq B W) e =\n    \\<alpha> * Up * pmf B e + \\<alpha> * pmf W e - \\<alpha> * Up * pmf W e +\n    Uq * pmf B e +\n    pmf W e -\n    Uq * pmf W e -\n    \\<alpha> * Uq * pmf B e -\n    \\<alpha> * pmf W e +\n    \\<alpha> * Uq * pmf W e", "using left_diff_distrib' pmf_mix_deeper[of Up B W e] pmf_mix_deeper[of Uq B W e]\n          assms Up Uq my_U_is_defined(1)"], ["proof (prove)\nusing this:\n  (?b - ?c) * ?a = ?b * ?a - ?c * ?a\n  Up \\<in> {0..1} \\<Longrightarrow>\n  pmf (mix_pmf Up B W) e = Up * pmf B e + pmf W e - Up * pmf W e\n  Uq \\<in> {0..1} \\<Longrightarrow>\n  pmf (mix_pmf Uq B W) e = Uq * pmf B e + pmf W e - Uq * pmf W e\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  \\<alpha> \\<in> {0..1}\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  Up = my_U p\n  Uq = my_U q\n  ?p \\<in> local.\\<P> \\<Longrightarrow> my_U ?p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<alpha> * pmf (mix_pmf Up B W) e + pmf (mix_pmf Uq B W) e -\n    \\<alpha> * pmf (mix_pmf Uq B W) e =\n    \\<alpha> * Up * pmf B e + \\<alpha> * pmf W e - \\<alpha> * Up * pmf W e +\n    Uq * pmf B e +\n    pmf W e -\n    Uq * pmf W e -\n    \\<alpha> * Uq * pmf B e -\n    \\<alpha> * pmf W e +\n    \\<alpha> * Uq * pmf W e", "by (simp add: distrib_left right_diff_distrib)"], ["proof (state)\nthis:\n  \\<alpha> * pmf (mix_pmf Up B W) e + pmf (mix_pmf Uq B W) e -\n  \\<alpha> * pmf (mix_pmf Uq B W) e =\n  \\<alpha> * Up * pmf B e + \\<alpha> * pmf W e - \\<alpha> * Up * pmf W e +\n  Uq * pmf B e +\n  pmf W e -\n  Uq * pmf W e -\n  \\<alpha> * Uq * pmf B e -\n  \\<alpha> * pmf W e +\n  \\<alpha> * Uq * pmf W e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> set_pmf\n                (mix_pmf \\<alpha> (mix_pmf Up B W)\n                  (mix_pmf Uq B W)) \\<Longrightarrow>\n       pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n       pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e", "have j4: \"pmf ?mixPQ e = (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf B e + \n        pmf W e - (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf W e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e =\n    (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf B e + pmf W e -\n    (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf W e", "using pmf_mix_deeper[of \"(\\<alpha> * Up + (1 - \\<alpha>) * Uq)\" B W e] long_in"], ["proof (prove)\nusing this:\n  \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1} \\<Longrightarrow>\n  pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e =\n  (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf B e + pmf W e -\n  (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf W e\n  \\<alpha> * Up + (1 - \\<alpha>) * Uq \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e =\n    (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf B e + pmf W e -\n    (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf W e", "by blast"], ["proof (state)\nthis:\n  pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e =\n  (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf B e + pmf W e -\n  (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf W e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       e \\<in> set_pmf\n                (mix_pmf \\<alpha> (mix_pmf Up B W)\n                  (mix_pmf Uq B W)) \\<Longrightarrow>\n       pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n       pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e", "then"], ["proof (chain)\npicking this:\n  pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e =\n  (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf B e + pmf W e -\n  (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf W e", "show \"pmf (?L) e = pmf ?mixPQ e\""], ["proof (prove)\nusing this:\n  pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e =\n  (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf B e + pmf W e -\n  (\\<alpha> * Up + (1 - \\<alpha>) * Uq) * pmf W e\n\ngoal (1 subgoal):\n 1. pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n    pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e", "by (simp add: i1 i3 mult.commute right_diff_distrib' ring_class.ring_distribs(1))"], ["proof (state)\nthis:\n  pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n  pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>e\\<in>set_pmf\n                  (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)).\n     pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n     pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W) =\n    mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W", "then"], ["proof (chain)\npicking this:\n  \\<forall>e\\<in>set_pmf\n                  (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)).\n     pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n     pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>set_pmf\n                  (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)).\n     pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n     pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W) =\n    mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W", "using pmf_equiv_intro1"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>set_pmf\n                  (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)).\n     pmf (mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)) e =\n     pmf (mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W) e\n  (\\<And>e.\n      e \\<in> set_pmf ?p \\<Longrightarrow>\n      pmf ?p e = pmf ?q e) \\<Longrightarrow>\n  ?p = ?q\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W) =\n    mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W) =\n  mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W) =\n  mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "have \"mix_pmf \\<alpha> (mix_pmf Up B W) q \\<approx>[\\<R>] ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> (mix_pmf Up B W)\n     q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)", "using approx_remains_after_same_comp_left assms(3) mp_in snd"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<approx>[\\<R>] ?q; ?r \\<in> local.\\<P>;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?r\n                     ?p \\<approx>[\\<R>] mix_pmf ?\\<alpha> ?r ?q\n  \\<alpha> \\<in> {0..1}\n  mix_pmf Up B W \\<in> local.\\<P>\n  q \\<approx>[\\<R>] mix_pmf Uq B W\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> (mix_pmf Up B W)\n     q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> (mix_pmf Up B W)\n   q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "hence *: \"mix_pmf \\<alpha> p q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf (my_U p) B W) (mix_pmf (my_U q) B W)\""], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> (mix_pmf Up B W)\n   q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p\n     q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf (my_U p) B W)\n                        (mix_pmf (my_U q) B W)", "using Up Uq f2 trans_approx"], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> (mix_pmf Up B W)\n   q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W)\n  Up = my_U p\n  Uq = my_U q\n  mix_pmf \\<alpha> p q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf Up B W) q\n  \\<lbrakk>?x \\<approx>[\\<R>] ?y; ?y \\<approx>[\\<R>] ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<approx>[\\<R>] ?z\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p\n     q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf (my_U p) B W)\n                        (mix_pmf (my_U q) B W)", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p\n   q \\<approx>[\\<R>] mix_pmf \\<alpha> (mix_pmf (my_U p) B W)\n                      (mix_pmf (my_U q) B W)\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "have \"mix_pmf \\<alpha> (mix_pmf (my_U p) B W) (mix_pmf (my_U q) B W) = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> (mix_pmf (my_U p) B W) (mix_pmf (my_U q) B W) =\n    mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W", "using Up Uq **"], ["proof (prove)\nusing this:\n  Up = my_U p\n  Uq = my_U q\n  mix_pmf \\<alpha> (mix_pmf Up B W) (mix_pmf Uq B W) =\n  mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> (mix_pmf (my_U p) B W) (mix_pmf (my_U q) B W) =\n    mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W", "by blast"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> (mix_pmf (my_U p) B W) (mix_pmf (my_U q) B W) =\n  mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "hence \"my_U (mix_pmf \\<alpha> p q) = \\<alpha> * Up + (1-\\<alpha>) * Uq\""], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> (mix_pmf (my_U p) B W) (mix_pmf (my_U q) B W) =\n  mix_pmf (\\<alpha> * Up + (1 - \\<alpha>) * Uq) B W\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) = \\<alpha> * Up + (1 - \\<alpha>) * Uq", "by (metis * B W assms(4) indiff_imp_same_utility_value long_in \n        my_U_is_defined(1) my_U_is_defined(2) my_U_represents_pref relation_in_carrier)"], ["proof (state)\nthis:\n  my_U (mix_pmf \\<alpha> p q) = \\<alpha> * Up + (1 - \\<alpha>) * Uq\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "then"], ["proof (chain)\npicking this:\n  my_U (mix_pmf \\<alpha> p q) = \\<alpha> * Up + (1 - \\<alpha>) * Uq", "show ?thesis"], ["proof (prove)\nusing this:\n  my_U (mix_pmf \\<alpha> p q) = \\<alpha> * Up + (1 - \\<alpha>) * Uq\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "using Up Uq"], ["proof (prove)\nusing this:\n  my_U (mix_pmf \\<alpha> p q) = \\<alpha> * Up + (1 - \\<alpha>) * Uq\n  Up = my_U p\n  Uq = my_U q\n\ngoal (1 subgoal):\n 1. my_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q", "by blast"], ["proof (state)\nthis:\n  my_U (mix_pmf \\<alpha> p q) = \\<alpha> * my_U p + (1 - \\<alpha>) * my_U q\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Now we define a more general Utility \n       function that also takes the degenerate case into account \\<close>"], ["", "private"], ["", "definition general_U \n  where\n    \"general_U p = (if some_best \\<approx>[\\<R>] some_worst then 1 else my_U p)\""], ["", "lemma general_U_is_linear_function:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  shows \"general_U (mix_pmf \\<alpha> p q) = \\<alpha> * (general_U p) + (1 - \\<alpha>) * (general_U q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "consider \"some_best \\<succ>[\\<R>] some_worst\" | \"some_best \\<approx>[\\<R>] some_worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n             (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using best_def some_best_in_best some_worst_in_worst worst_def"], ["proof (prove)\nusing this:\n  best =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y}\n  some_best \\<in> best\n  some_worst \\<in> worst\n  worst =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n             (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "proof (cases, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. some_best \\<succeq>[\\<R>] some_worst \\<and>\n    (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q\n 2. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "case 1"], ["proof (state)\nthis:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n\ngoal (2 subgoals):\n 1. some_best \\<succeq>[\\<R>] some_worst \\<and>\n    (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q\n 2. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "then"], ["proof (chain)\npicking this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>", "show ?case"], ["proof (prove)\nusing this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "using assms(1) assms(2) assms(3) general_U_def my_U_is_linear_function"], ["proof (prove)\nusing this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  \\<alpha> \\<in> {0..1}\n  general_U ?p =\n  (if some_best \\<approx>[\\<R>] some_worst then 1 else my_U ?p)\n  \\<lbrakk>?p \\<in> local.\\<P>; ?q \\<in> local.\\<P>; ?\\<alpha> \\<in> {0..1};\n   some_best \\<succeq>[\\<R>] some_worst \\<and>\n   (some_worst, some_best) \\<notin> \\<R>\\<rbrakk>\n  \\<Longrightarrow> my_U (mix_pmf ?\\<alpha> ?p ?q) =\n                    ?\\<alpha> * my_U ?p + (1 - ?\\<alpha>) * my_U ?q\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "by auto"], ["proof (state)\nthis:\n  general_U (mix_pmf \\<alpha> p q) =\n  \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q\n\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "case 2"], ["proof (state)\nthis:\n  some_best \\<approx>[\\<R>] some_worst\n\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "then"], ["proof (chain)\npicking this:\n  some_best \\<approx>[\\<R>] some_worst", "show ?case"], ["proof (prove)\nusing this:\n  some_best \\<approx>[\\<R>] some_worst\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "using assms(1) assms(2) assms(3) general_U_def"], ["proof (prove)\nusing this:\n  some_best \\<approx>[\\<R>] some_worst\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  \\<alpha> \\<in> {0..1}\n  general_U ?p =\n  (if some_best \\<approx>[\\<R>] some_worst then 1 else my_U ?p)\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "by auto"], ["proof (state)\nthis:\n  general_U (mix_pmf \\<alpha> p q) =\n  \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  general_U (mix_pmf \\<alpha> p q) =\n  \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma general_U_ordinal_Utility:\n  shows \"ordinal_utility \\<P> \\<R> general_U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordinal_utility local.\\<P> \\<R> general_U", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> local.\\<P>; y \\<in> local.\\<P>\\<rbrakk>\n       \\<Longrightarrow> x \\<succeq>[\\<R>] y =\n                         (general_U y \\<le> general_U x)\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 3. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "case (1 x y)"], ["proof (state)\nthis:\n  x \\<in> local.\\<P>\n  y \\<in> local.\\<P>\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> local.\\<P>; y \\<in> local.\\<P>\\<rbrakk>\n       \\<Longrightarrow> x \\<succeq>[\\<R>] y =\n                         (general_U y \\<le> general_U x)\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 3. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "consider (a) \"some_best \\<succ>[\\<R>] some_worst\" | (b) \"some_best \\<approx>[\\<R>] some_worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n             (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using best_def some_best_in_best some_worst_in_worst worst_def"], ["proof (prove)\nusing this:\n  best =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y}\n  some_best \\<in> best\n  some_worst \\<in> worst\n  worst =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n             (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> local.\\<P>; y \\<in> local.\\<P>\\<rbrakk>\n       \\<Longrightarrow> x \\<succeq>[\\<R>] y =\n                         (general_U y \\<le> general_U x)\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 3. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "proof (cases, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. some_best \\<succeq>[\\<R>] some_worst \\<and>\n    (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)\n 2. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "case a"], ["proof (state)\nthis:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n\ngoal (2 subgoals):\n 1. some_best \\<succeq>[\\<R>] some_worst \\<and>\n    (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)\n 2. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "have \"some_best \\<succ>[\\<R>] some_worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. some_best \\<succeq>[\\<R>] some_worst \\<and>\n    (some_worst, some_best) \\<notin> \\<R>", "using a"], ["proof (prove)\nusing this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. some_best \\<succeq>[\\<R>] some_worst \\<and>\n    (some_worst, some_best) \\<notin> \\<R>", "by auto"], ["proof (state)\nthis:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n\ngoal (2 subgoals):\n 1. some_best \\<succeq>[\\<R>] some_worst \\<and>\n    (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)\n 2. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "then"], ["proof (chain)\npicking this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>", "show \"x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)\""], ["proof (prove)\nusing this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "using 1 my_U_represents_pref[of x y] general_U_def"], ["proof (prove)\nusing this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  x \\<in> local.\\<P>\n  y \\<in> local.\\<P>\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R>;\n   x \\<in> local.\\<P>; y \\<in> local.\\<P>\\<rbrakk>\n  \\<Longrightarrow> x \\<succeq>[\\<R>] y = (my_U y \\<le> my_U x)\n  general_U ?p =\n  (if some_best \\<approx>[\\<R>] some_worst then 1 else my_U ?p)\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "by simp"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)\n\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "case b"], ["proof (state)\nthis:\n  some_best \\<approx>[\\<R>] some_worst\n\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "have \"general_U x = 1\" \"general_U y = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. general_U x = 1 &&& general_U y = 1", "by (simp add: b general_U_def)+"], ["proof (state)\nthis:\n  general_U x = 1\n  general_U y = 1\n\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "moreover"], ["proof (state)\nthis:\n  general_U x = 1\n  general_U y = 1\n\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "have \"x \\<approx>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<approx>[\\<R>] y", "using b"], ["proof (prove)\nusing this:\n  some_best \\<approx>[\\<R>] some_worst\n\ngoal (1 subgoal):\n 1. x \\<approx>[\\<R>] y", "by (meson \"1\"(1) \"1\"(2) best_worst_indiff_all_indiff(1) \n          some_best_in_best some_worst_in_worst trans_approx)"], ["proof (state)\nthis:\n  x \\<approx>[\\<R>] y\n\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "ultimately"], ["proof (chain)\npicking this:\n  general_U x = 1\n  general_U y = 1\n  x \\<approx>[\\<R>] y", "show \"x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)\""], ["proof (prove)\nusing this:\n  general_U x = 1\n  general_U y = 1\n  x \\<approx>[\\<R>] y\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "using general_U_def"], ["proof (prove)\nusing this:\n  general_U x = 1\n  general_U y = 1\n  x \\<approx>[\\<R>] y\n  general_U ?p =\n  (if some_best \\<approx>[\\<R>] some_worst then 1 else my_U ?p)\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)", "by linarith"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y = (general_U y \\<le> general_U x)\n\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "case (2 x y)"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y\n\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "then"], ["proof (chain)\npicking this:\n  x \\<succeq>[\\<R>] y", "show ?case"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. x \\<in> local.\\<P>", "using relation_in_carrier"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y\n  ?x \\<succeq>[\\<R>] ?y \\<Longrightarrow>\n  ?x \\<in> local.\\<P> \\<and> ?y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. x \\<in> local.\\<P>", "by blast"], ["proof (state)\nthis:\n  x \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "case (3 x y)"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "then"], ["proof (chain)\npicking this:\n  x \\<succeq>[\\<R>] y", "show ?case"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. y \\<in> local.\\<P>", "using relation_in_carrier"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y\n  ?x \\<succeq>[\\<R>] ?y \\<Longrightarrow>\n  ?x \\<in> local.\\<P> \\<and> ?y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. y \\<in> local.\\<P>", "by blast"], ["proof (state)\nthis:\n  y \\<in> local.\\<P>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>  Proof of the linearity of general-U. \n        If we consider the definition of expected utility \n        functions from Maschler, Solan, Zamir we are done. \\<close>"], ["", "theorem is_linear:\n  assumes \"p \\<in> \\<P>\"\n    and \"q \\<in> \\<P>\"\n    and \"\\<alpha> \\<in> {0..1}\"\n  shows \"\\<exists>u. u (mix_pmf \\<alpha> p q) = \\<alpha> * (u p) + (1-\\<alpha>) * (u q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u (mix_pmf \\<alpha> p q) = \\<alpha> * u p + (1 - \\<alpha>) * u q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?u (mix_pmf \\<alpha> p q) = \\<alpha> * ?u p + (1 - \\<alpha>) * ?u q", "let ?u = \"general_U\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?u (mix_pmf \\<alpha> p q) = \\<alpha> * ?u p + (1 - \\<alpha>) * ?u q", "consider \"some_best \\<succ>[\\<R>] some_worst\" | \"some_best \\<approx>[\\<R>] some_worst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n             (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using best_def some_best_in_best some_worst_in_worst worst_def"], ["proof (prove)\nusing this:\n  best =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. x \\<succeq>[\\<R>] y}\n  some_best \\<in> best\n  some_worst \\<in> worst\n  worst =\n  {x \\<in> local.\\<P>. \\<forall>y\\<in>local.\\<P>. y \\<succeq>[\\<R>] x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n             (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. ?u (mix_pmf \\<alpha> p q) = \\<alpha> * ?u p + (1 - \\<alpha>) * ?u q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"?u (mix_pmf \\<alpha> p q) = \\<alpha> * ?u p + (1 - \\<alpha>) * ?u q\""], ["proof (prove)\nusing this:\n  \\<lbrakk>some_best \\<succeq>[\\<R>] some_worst \\<and>\n           (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. some_best \\<succeq>[\\<R>] some_worst \\<and>\n    (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q\n 2. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "case 1"], ["proof (state)\nthis:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n\ngoal (2 subgoals):\n 1. some_best \\<succeq>[\\<R>] some_worst \\<and>\n    (some_worst, some_best) \\<notin> \\<R> \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q\n 2. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "then"], ["proof (chain)\npicking this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "using assms(1) assms(2) assms(3) general_U_def my_U_is_linear_function"], ["proof (prove)\nusing this:\n  some_best \\<succeq>[\\<R>] some_worst \\<and>\n  (some_worst, some_best) \\<notin> \\<R>\n  p \\<in> local.\\<P>\n  q \\<in> local.\\<P>\n  \\<alpha> \\<in> {0..1}\n  general_U ?p =\n  (if some_best \\<approx>[\\<R>] some_worst then 1 else my_U ?p)\n  \\<lbrakk>?p \\<in> local.\\<P>; ?q \\<in> local.\\<P>; ?\\<alpha> \\<in> {0..1};\n   some_best \\<succeq>[\\<R>] some_worst \\<and>\n   (some_worst, some_best) \\<notin> \\<R>\\<rbrakk>\n  \\<Longrightarrow> my_U (mix_pmf ?\\<alpha> ?p ?q) =\n                    ?\\<alpha> * my_U ?p + (1 - ?\\<alpha>) * my_U ?q\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "by auto"], ["proof (state)\nthis:\n  general_U (mix_pmf \\<alpha> p q) =\n  \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q\n\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "case 2"], ["proof (state)\nthis:\n  some_best \\<approx>[\\<R>] some_worst\n\ngoal (1 subgoal):\n 1. some_best \\<approx>[\\<R>] some_worst \\<Longrightarrow>\n    general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "then"], ["proof (chain)\npicking this:\n  some_best \\<approx>[\\<R>] some_worst", "show ?thesis"], ["proof (prove)\nusing this:\n  some_best \\<approx>[\\<R>] some_worst\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf \\<alpha> p q) =\n    \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q", "by (simp add: general_U_def)"], ["proof (state)\nthis:\n  general_U (mix_pmf \\<alpha> p q) =\n  \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  general_U (mix_pmf \\<alpha> p q) =\n  \\<alpha> * general_U p + (1 - \\<alpha>) * general_U q\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Now I define a Utility function that assigns a utility to all outcomes. \n       These are only finitely many \\<close>"], ["", "private"], ["", "definition ocU \n  where\n    \"ocU p = general_U (return_pmf p)\""], ["", "lemma geral_U_is_expected_value_of_ocU:\n  assumes \"set_pmf p \\<subseteq> outcomes\"\n  shows \"general_U p = measure_pmf.expectation p ocU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. general_U p = measure_pmf.expectation p ocU", "using fnt assms"], ["proof (prove)\nusing this:\n  finite outcomes\n  set_pmf p \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. general_U p = measure_pmf.expectation p ocU", "proof (induct rule: pmf_mix_induct')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> outcomes \\<Longrightarrow>\n       general_U (return_pmf x) = measure_pmf.expectation (return_pmf x) ocU\n 2. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1};\n        general_U p = measure_pmf.expectation p ocU;\n        general_U q = measure_pmf.expectation q ocU\\<rbrakk>\n       \\<Longrightarrow> general_U (mix_pmf a p q) =\n                         measure_pmf.expectation (mix_pmf a p q) ocU", "case (mix p q a)"], ["proof (state)\nthis:\n  set_pmf p \\<subseteq> outcomes\n  set_pmf q \\<subseteq> outcomes\n  a \\<in> {0<..<1}\n  general_U p = measure_pmf.expectation p ocU\n  general_U q = measure_pmf.expectation q ocU\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> outcomes \\<Longrightarrow>\n       general_U (return_pmf x) = measure_pmf.expectation (return_pmf x) ocU\n 2. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1};\n        general_U p = measure_pmf.expectation p ocU;\n        general_U q = measure_pmf.expectation q ocU\\<rbrakk>\n       \\<Longrightarrow> general_U (mix_pmf a p q) =\n                         measure_pmf.expectation (mix_pmf a p q) ocU", "hence \"general_U (mix_pmf a p q) = a * general_U p + (1-a) * general_U q\""], ["proof (prove)\nusing this:\n  set_pmf p \\<subseteq> outcomes\n  set_pmf q \\<subseteq> outcomes\n  a \\<in> {0<..<1}\n  general_U p = measure_pmf.expectation p ocU\n  general_U q = measure_pmf.expectation q ocU\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf a p q) = a * general_U p + (1 - a) * general_U q", "using general_U_is_linear_function[of p q a] mix.hyps assms lotteries_on_def mix.hyps"], ["proof (prove)\nusing this:\n  set_pmf p \\<subseteq> outcomes\n  set_pmf q \\<subseteq> outcomes\n  a \\<in> {0<..<1}\n  general_U p = measure_pmf.expectation p ocU\n  general_U q = measure_pmf.expectation q ocU\n  \\<lbrakk>p \\<in> local.\\<P>; q \\<in> local.\\<P>; a \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> general_U (mix_pmf a p q) =\n                    a * general_U p + (1 - a) * general_U q\n  set_pmf p \\<subseteq> outcomes\n  set_pmf q \\<subseteq> outcomes\n  a \\<in> {0<..<1}\n  general_U p = measure_pmf.expectation p ocU\n  general_U q = measure_pmf.expectation q ocU\n  set_pmf p \\<subseteq> outcomes\n  Neumann_Morgenstern_Utility_Theorem.\\<P> ?Oc =\n  {p. set_pmf p \\<subseteq> ?Oc}\n  set_pmf p \\<subseteq> outcomes\n  set_pmf q \\<subseteq> outcomes\n  a \\<in> {0<..<1}\n  general_U p = measure_pmf.expectation p ocU\n  general_U q = measure_pmf.expectation q ocU\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf a p q) = a * general_U p + (1 - a) * general_U q", "by auto"], ["proof (state)\nthis:\n  general_U (mix_pmf a p q) = a * general_U p + (1 - a) * general_U q\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> outcomes \\<Longrightarrow>\n       general_U (return_pmf x) = measure_pmf.expectation (return_pmf x) ocU\n 2. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1};\n        general_U p = measure_pmf.expectation p ocU;\n        general_U q = measure_pmf.expectation q ocU\\<rbrakk>\n       \\<Longrightarrow> general_U (mix_pmf a p q) =\n                         measure_pmf.expectation (mix_pmf a p q) ocU", "also"], ["proof (state)\nthis:\n  general_U (mix_pmf a p q) = a * general_U p + (1 - a) * general_U q\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> outcomes \\<Longrightarrow>\n       general_U (return_pmf x) = measure_pmf.expectation (return_pmf x) ocU\n 2. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1};\n        general_U p = measure_pmf.expectation p ocU;\n        general_U q = measure_pmf.expectation q ocU\\<rbrakk>\n       \\<Longrightarrow> general_U (mix_pmf a p q) =\n                         measure_pmf.expectation (mix_pmf a p q) ocU", "have \"... = a * measure_pmf.expectation p ocU + (1-a) * measure_pmf.expectation q ocU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * general_U p + (1 - a) * general_U q =\n    a * measure_pmf.expectation p ocU +\n    (1 - a) * measure_pmf.expectation q ocU", "by (simp add: mix.hyps(4) mix.hyps(5))"], ["proof (state)\nthis:\n  a * general_U p + (1 - a) * general_U q =\n  a * measure_pmf.expectation p ocU +\n  (1 - a) * measure_pmf.expectation q ocU\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> outcomes \\<Longrightarrow>\n       general_U (return_pmf x) = measure_pmf.expectation (return_pmf x) ocU\n 2. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1};\n        general_U p = measure_pmf.expectation p ocU;\n        general_U q = measure_pmf.expectation q ocU\\<rbrakk>\n       \\<Longrightarrow> general_U (mix_pmf a p q) =\n                         measure_pmf.expectation (mix_pmf a p q) ocU", "also"], ["proof (state)\nthis:\n  a * general_U p + (1 - a) * general_U q =\n  a * measure_pmf.expectation p ocU +\n  (1 - a) * measure_pmf.expectation q ocU\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> outcomes \\<Longrightarrow>\n       general_U (return_pmf x) = measure_pmf.expectation (return_pmf x) ocU\n 2. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1};\n        general_U p = measure_pmf.expectation p ocU;\n        general_U q = measure_pmf.expectation q ocU\\<rbrakk>\n       \\<Longrightarrow> general_U (mix_pmf a p q) =\n                         measure_pmf.expectation (mix_pmf a p q) ocU", "have \"... = measure_pmf.expectation (mix_pmf a p q) ocU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * measure_pmf.expectation p ocU +\n    (1 - a) * measure_pmf.expectation q ocU =\n    measure_pmf.expectation (mix_pmf a p q) ocU", "using general_U_is_linear_function expected_value_mix_pmf_distrib fnt infinite_super mix.hyps(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> local.\\<P>; ?q \\<in> local.\\<P>;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> general_U (mix_pmf ?\\<alpha> ?p ?q) =\n                    ?\\<alpha> * general_U ?p +\n                    (1 - ?\\<alpha>) * general_U ?q\n  \\<lbrakk>finite (set_pmf ?p); finite (set_pmf ?q);\n   ?a \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.expectation (mix_pmf ?a ?p ?q) ?f =\n                    ?a * measure_pmf.expectation ?p ?f +\n                    (1 - ?a) * measure_pmf.expectation ?q ?f\n  finite outcomes\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n  set_pmf p \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. a * measure_pmf.expectation p ocU +\n    (1 - a) * measure_pmf.expectation q ocU =\n    measure_pmf.expectation (mix_pmf a p q) ocU", "by (metis fnt mix.hyps(2) mix.hyps(3))"], ["proof (state)\nthis:\n  a * measure_pmf.expectation p ocU +\n  (1 - a) * measure_pmf.expectation q ocU =\n  measure_pmf.expectation (mix_pmf a p q) ocU\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> outcomes \\<Longrightarrow>\n       general_U (return_pmf x) = measure_pmf.expectation (return_pmf x) ocU\n 2. \\<And>p q a.\n       \\<lbrakk>set_pmf p \\<subseteq> outcomes;\n        set_pmf q \\<subseteq> outcomes; a \\<in> {0<..<1};\n        general_U p = measure_pmf.expectation p ocU;\n        general_U q = measure_pmf.expectation q ocU\\<rbrakk>\n       \\<Longrightarrow> general_U (mix_pmf a p q) =\n                         measure_pmf.expectation (mix_pmf a p q) ocU", "finally"], ["proof (chain)\npicking this:\n  general_U (mix_pmf a p q) = measure_pmf.expectation (mix_pmf a p q) ocU", "show ?case"], ["proof (prove)\nusing this:\n  general_U (mix_pmf a p q) = measure_pmf.expectation (mix_pmf a p q) ocU\n\ngoal (1 subgoal):\n 1. general_U (mix_pmf a p q) = measure_pmf.expectation (mix_pmf a p q) ocU", "."], ["proof (state)\nthis:\n  general_U (mix_pmf a p q) = measure_pmf.expectation (mix_pmf a p q) ocU\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> outcomes \\<Longrightarrow>\n       general_U (return_pmf x) = measure_pmf.expectation (return_pmf x) ocU", "qed (auto simp: support_in_outcomes assms fnt integral_measure_pmf_real ocU_def)"], ["", "lemma ordinal_utility_expected_value:\n  \"ordinal_utility \\<P> \\<R> (\\<lambda>x. measure_pmf.expectation x ocU)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordinal_utility local.\\<P> \\<R>\n     (\\<lambda>x. measure_pmf.expectation x ocU)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> local.\\<P>; y \\<in> local.\\<P>\\<rbrakk>\n       \\<Longrightarrow> x \\<succeq>[\\<R>] y =\n                         (measure_pmf.expectation y ocU\n                          \\<le> measure_pmf.expectation x ocU)\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 3. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "case (1 x y)"], ["proof (state)\nthis:\n  x \\<in> local.\\<P>\n  y \\<in> local.\\<P>\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> local.\\<P>; y \\<in> local.\\<P>\\<rbrakk>\n       \\<Longrightarrow> x \\<succeq>[\\<R>] y =\n                         (measure_pmf.expectation y ocU\n                          \\<le> measure_pmf.expectation x ocU)\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 3. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "have ocs: \"set_pmf x \\<subseteq> outcomes\" \"set_pmf y \\<subseteq> outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf x \\<subseteq> outcomes &&& set_pmf y \\<subseteq> outcomes", "by (meson \"1\" subsetI support_in_outcomes)+"], ["proof (state)\nthis:\n  set_pmf x \\<subseteq> outcomes\n  set_pmf y \\<subseteq> outcomes\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> local.\\<P>; y \\<in> local.\\<P>\\<rbrakk>\n       \\<Longrightarrow> x \\<succeq>[\\<R>] y =\n                         (measure_pmf.expectation y ocU\n                          \\<le> measure_pmf.expectation x ocU)\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 3. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "have \"x \\<succeq>[\\<R>] y \\<Longrightarrow> (measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y \\<Longrightarrow>\n    measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y \\<Longrightarrow>\n    measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU", "assume \"x \\<succeq>[\\<R>] y\""], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y \\<Longrightarrow>\n    measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU", "have \"general_U x \\<ge> general_U y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. general_U y \\<le> general_U x", "by (meson \\<open>x \\<succeq>[\\<R>] y\\<close> general_U_ordinal_Utility ordinal_utility_def)"], ["proof (state)\nthis:\n  general_U y \\<le> general_U x\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y \\<Longrightarrow>\n    measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU", "then"], ["proof (chain)\npicking this:\n  general_U y \\<le> general_U x", "show \"(measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU)\""], ["proof (prove)\nusing this:\n  general_U y \\<le> general_U x\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU", "using geral_U_is_expected_value_of_ocU ocs"], ["proof (prove)\nusing this:\n  general_U y \\<le> general_U x\n  set_pmf ?p \\<subseteq> outcomes \\<Longrightarrow>\n  general_U ?p = measure_pmf.expectation ?p ocU\n  set_pmf x \\<subseteq> outcomes\n  set_pmf y \\<subseteq> outcomes\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU", "by auto"], ["proof (state)\nthis:\n  measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y \\<Longrightarrow>\n  measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> local.\\<P>; y \\<in> local.\\<P>\\<rbrakk>\n       \\<Longrightarrow> x \\<succeq>[\\<R>] y =\n                         (measure_pmf.expectation y ocU\n                          \\<le> measure_pmf.expectation x ocU)\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 3. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "moreover"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y \\<Longrightarrow>\n  measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> local.\\<P>; y \\<in> local.\\<P>\\<rbrakk>\n       \\<Longrightarrow> x \\<succeq>[\\<R>] y =\n                         (measure_pmf.expectation y ocU\n                          \\<le> measure_pmf.expectation x ocU)\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 3. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "have \"(measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU) \\<Longrightarrow> x \\<succeq>[\\<R>] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation y ocU\n    \\<le> measure_pmf.expectation x ocU \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.expectation y ocU\n    \\<le> measure_pmf.expectation x ocU \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y", "assume \"(measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU)\""], ["proof (state)\nthis:\n  measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation y ocU\n    \\<le> measure_pmf.expectation x ocU \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y", "then"], ["proof (chain)\npicking this:\n  measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU", "have \"general_U x \\<ge> general_U y\""], ["proof (prove)\nusing this:\n  measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU\n\ngoal (1 subgoal):\n 1. general_U y \\<le> general_U x", "by (simp add:  geral_U_is_expected_value_of_ocU ocs(1) ocs(2))"], ["proof (state)\nthis:\n  general_U y \\<le> general_U x\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation y ocU\n    \\<le> measure_pmf.expectation x ocU \\<Longrightarrow>\n    x \\<succeq>[\\<R>] y", "then"], ["proof (chain)\npicking this:\n  general_U y \\<le> general_U x", "show \"x \\<succeq>[\\<R>] y\""], ["proof (prove)\nusing this:\n  general_U y \\<le> general_U x\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y", "by (meson \"1\"(1) \"1\"(2) general_U_ordinal_Utility ordinal_utility.util_def)"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  measure_pmf.expectation y ocU\n  \\<le> measure_pmf.expectation x ocU \\<Longrightarrow>\n  x \\<succeq>[\\<R>] y\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> local.\\<P>; y \\<in> local.\\<P>\\<rbrakk>\n       \\<Longrightarrow> x \\<succeq>[\\<R>] y =\n                         (measure_pmf.expectation y ocU\n                          \\<le> measure_pmf.expectation x ocU)\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 3. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "ultimately"], ["proof (chain)\npicking this:\n  x \\<succeq>[\\<R>] y \\<Longrightarrow>\n  measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU\n  measure_pmf.expectation y ocU\n  \\<le> measure_pmf.expectation x ocU \\<Longrightarrow>\n  x \\<succeq>[\\<R>] y", "show ?case"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y \\<Longrightarrow>\n  measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU\n  measure_pmf.expectation y ocU\n  \\<le> measure_pmf.expectation x ocU \\<Longrightarrow>\n  x \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. x \\<succeq>[\\<R>] y =\n    (measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU)", "by blast"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y =\n  (measure_pmf.expectation y ocU \\<le> measure_pmf.expectation x ocU)\n\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "case (2 x y)"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y\n\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> x \\<in> local.\\<P>\n 2. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "then"], ["proof (chain)\npicking this:\n  x \\<succeq>[\\<R>] y", "show ?case"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. x \\<in> local.\\<P>", "using relation_in_carrier"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y\n  ?x \\<succeq>[\\<R>] ?y \\<Longrightarrow>\n  ?x \\<in> local.\\<P> \\<and> ?y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. x \\<in> local.\\<P>", "by blast"], ["proof (state)\nthis:\n  x \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "case (3 x y)"], ["proof (state)\nthis:\n  x \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<succeq>[\\<R>] y \\<Longrightarrow> y \\<in> local.\\<P>", "then"], ["proof (chain)\npicking this:\n  x \\<succeq>[\\<R>] y", "show ?case"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y\n\ngoal (1 subgoal):\n 1. y \\<in> local.\\<P>", "using relation_in_carrier"], ["proof (prove)\nusing this:\n  x \\<succeq>[\\<R>] y\n  ?x \\<succeq>[\\<R>] ?y \\<Longrightarrow>\n  ?x \\<in> local.\\<P> \\<and> ?y \\<in> local.\\<P>\n\ngoal (1 subgoal):\n 1. y \\<in> local.\\<P>", "by auto"], ["proof (state)\nthis:\n  y \\<in> local.\\<P>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordinal_utility_expected_value':\n  \"\\<exists>u. ordinal_utility \\<P> \\<R> (\\<lambda>x. measure_pmf.expectation x u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       ordinal_utility local.\\<P> \\<R>\n        (\\<lambda>x. measure_pmf.expectation x u)", "using ordinal_utility_expected_value"], ["proof (prove)\nusing this:\n  ordinal_utility local.\\<P> \\<R>\n   (\\<lambda>x. measure_pmf.expectation x ocU)\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       ordinal_utility local.\\<P> \\<R>\n        (\\<lambda>x. measure_pmf.expectation x u)", "by blast"], ["", "lemma ocU_is_expected_utility_bernoulli:\n  shows \"\\<forall>x \\<in> \\<P>. \\<forall>y \\<in> \\<P>. x \\<succeq>[\\<R>] y \\<longleftrightarrow> \n  measure_pmf.expectation x ocU \\<ge> measure_pmf.expectation y ocU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>local.\\<P>.\n       \\<forall>y\\<in>local.\\<P>.\n          x \\<succeq>[\\<R>] y =\n          (measure_pmf.expectation y ocU\n           \\<le> measure_pmf.expectation x ocU)", "using ordinal_utility_expected_value"], ["proof (prove)\nusing this:\n  ordinal_utility local.\\<P> \\<R>\n   (\\<lambda>x. measure_pmf.expectation x ocU)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>local.\\<P>.\n       \\<forall>y\\<in>local.\\<P>.\n          x \\<succeq>[\\<R>] y =\n          (measure_pmf.expectation y ocU\n           \\<le> measure_pmf.expectation x ocU)", "by (meson ordinal_utility.util_def)"], ["", "end"], ["", "(* continuous *)"], ["", "end"], ["", "(* finite outcomes *)"], ["", "end"], ["", "(* system U *)"], ["", "lemma expected_value_is_utility_function:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  assumes \"x \\<in> lotteries_on outcomes\" and \"y \\<in> lotteries_on outcomes\"\n  assumes \"ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\"\n  shows \"measure_pmf.expectation x u \\<ge> measure_pmf.expectation y u \\<longleftrightarrow> x \\<succeq>[\\<R>] y\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (measure_pmf.expectation y u \\<le> measure_pmf.expectation x u) =\n    x \\<succeq>[\\<R>] y", "using assms(3) assms(4) assms(5) ordinal_utility.util_def_conf \n    ordinal_utility.ordinal_utility_left iffI"], ["proof (prove)\nusing this:\n  x \\<in> \\<P> outcomes\n  y \\<in> \\<P> outcomes\n  ordinal_utility (\\<P> outcomes) \\<R>\n   (\\<lambda>x. measure_pmf.expectation x u)\n  \\<lbrakk>ordinal_utility ?carrier ?relation ?u; ?x \\<in> ?carrier;\n   ?y \\<in> ?carrier\\<rbrakk>\n  \\<Longrightarrow> (?u ?y \\<le> ?u ?x) = ?x \\<succeq>[?relation] ?y\n  \\<lbrakk>ordinal_utility ?carrier ?relation ?u;\n   ?x \\<succeq>[?relation] ?y\\<rbrakk>\n  \\<Longrightarrow> ?u ?y \\<le> ?u ?x\n  \\<lbrakk>?P \\<Longrightarrow> ?Q; ?Q \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P = ?Q\n\ngoal (1 subgoal):\n 1. (measure_pmf.expectation y u \\<le> measure_pmf.expectation x u) =\n    x \\<succeq>[\\<R>] y", "by (metis (no_types, lifting))"], ["", "lemma system_U_implies_vNM_utility:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  assumes rpr: \"rational_preference (lotteries_on outcomes) \\<R>\"\n  assumes ind: \"independent_vnm (lotteries_on outcomes) \\<R>\"\n  assumes cnt: \"continuous_vnm (lotteries_on outcomes) \\<R>\"\n  shows \"\\<exists>u. ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       ordinal_utility (\\<P> outcomes) \\<R>\n        (\\<lambda>x. measure_pmf.expectation x u)", "using ordinal_utility_expected_value'[of outcomes \\<R>] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>rational_preference (\\<P> outcomes) \\<R>;\n   independent_vnm (\\<P> outcomes) \\<R>; finite outcomes;\n   outcomes \\<noteq> {}; continuous_vnm (\\<P> outcomes) \\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u.\n                       ordinal_utility (\\<P> outcomes) \\<R>\n                        (\\<lambda>x. measure_pmf.expectation x u)\n  finite outcomes\n  outcomes \\<noteq> {}\n  rational_preference (\\<P> outcomes) \\<R>\n  independent_vnm (\\<P> outcomes) \\<R>\n  continuous_vnm (\\<P> outcomes) \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       ordinal_utility (\\<P> outcomes) \\<R>\n        (\\<lambda>x. measure_pmf.expectation x u)", "by blast"], ["", "lemma vNM_utility_implies_rationality:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  assumes \"\\<exists>u. ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\"\n  shows \"rational_preference (lotteries_on outcomes) \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rational_preference (\\<P> outcomes) \\<R>", "using assms(3) ordinal_util_imp_rat_prefs"], ["proof (prove)\nusing this:\n  \\<exists>u.\n     ordinal_utility (\\<P> outcomes) \\<R>\n      (\\<lambda>x. measure_pmf.expectation x u)\n  ordinal_utility ?carrier ?relation ?u \\<Longrightarrow>\n  rational_preference ?carrier ?relation\n\ngoal (1 subgoal):\n 1. rational_preference (\\<P> outcomes) \\<R>", "by blast"], ["", "theorem vNM_utility_implies_independence:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  assumes \"\\<exists>u. ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\"\n  shows \"independent_vnm (lotteries_on outcomes) \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. independent_vnm (\\<P> outcomes) \\<R>", "proof (rule independent_vnmI2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "fix p  q r \n    and \\<alpha>::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "assume a1: \"p \\<in> \\<P> outcomes\""], ["proof (state)\nthis:\n  p \\<in> \\<P> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "assume a2: \"q \\<in> \\<P> outcomes\""], ["proof (state)\nthis:\n  q \\<in> \\<P> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "assume a3: \"r \\<in> \\<P> outcomes\""], ["proof (state)\nthis:\n  r \\<in> \\<P> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "assume a4: \"\\<alpha> \\<in> {0<..1}\""], ["proof (state)\nthis:\n  \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "have in_lots: \"mix_pmf \\<alpha> p r \\<in> lotteries_on outcomes\" \"mix_pmf \\<alpha> q r \\<in> lotteries_on outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<in> \\<P> outcomes &&&\n    mix_pmf \\<alpha> q r \\<in> \\<P> outcomes", "using a1 a3 a4 mix_in_lot"], ["proof (prove)\nusing this:\n  p \\<in> \\<P> outcomes\n  r \\<in> \\<P> outcomes\n  \\<alpha> \\<in> {0<..1}\n  \\<lbrakk>?x \\<in> \\<P> ?outcomes; ?y \\<in> \\<P> ?outcomes;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y \\<in> \\<P> ?outcomes\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<in> \\<P> outcomes &&&\n    mix_pmf \\<alpha> q r \\<in> \\<P> outcomes", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> q r \\<in> \\<P> outcomes", "using a2 a3 a4 mix_in_lot"], ["proof (prove)\nusing this:\n  q \\<in> \\<P> outcomes\n  r \\<in> \\<P> outcomes\n  \\<alpha> \\<in> {0<..1}\n  \\<lbrakk>?x \\<in> \\<P> ?outcomes; ?y \\<in> \\<P> ?outcomes;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y \\<in> \\<P> ?outcomes\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> q r \\<in> \\<P> outcomes", "by fastforce"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p r \\<in> \\<P> outcomes\n  mix_pmf \\<alpha> q r \\<in> \\<P> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "have fnts: \"finite (set_pmf p)\" \"finite (set_pmf q)\" \"finite (set_pmf r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf p) &&& finite (set_pmf q) &&& finite (set_pmf r)", "using a1 a2 a3 fnt infinite_super lotteries_on_def"], ["proof (prove)\nusing this:\n  p \\<in> \\<P> outcomes\n  q \\<in> \\<P> outcomes\n  r \\<in> \\<P> outcomes\n  finite outcomes\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n  \\<P> ?Oc = {p. set_pmf p \\<subseteq> ?Oc}\n\ngoal (1 subgoal):\n 1. finite (set_pmf p) &&& finite (set_pmf q) &&& finite (set_pmf r)", "by blast+"], ["proof (state)\nthis:\n  finite (set_pmf p)\n  finite (set_pmf q)\n  finite (set_pmf r)\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "obtain u where\n    u: \"ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        ordinal_utility (\\<P> outcomes) \\<R>\n         (\\<lambda>x. measure_pmf.expectation x u) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  finite outcomes\n  outcomes \\<noteq> {}\n  \\<exists>u.\n     ordinal_utility (\\<P> outcomes) \\<R>\n      (\\<lambda>x. measure_pmf.expectation x u)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        ordinal_utility (\\<P> outcomes) \\<R>\n         (\\<lambda>x. measure_pmf.expectation x u) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ordinal_utility (\\<P> outcomes) \\<R>\n   (\\<lambda>x. measure_pmf.expectation x u)\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "have \"p \\<succeq>[\\<R>] q \\<Longrightarrow> mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "assume \"p \\<succeq>[\\<R>] q\""], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "hence f: \"measure_pmf.expectation p u \\<ge> measure_pmf.expectation q u\""], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] q\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "using u a1 a2 ordinal_utility.util_def"], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] q\n  ordinal_utility (\\<P> outcomes) \\<R>\n   (\\<lambda>x. measure_pmf.expectation x u)\n  p \\<in> \\<P> outcomes\n  q \\<in> \\<P> outcomes\n  \\<lbrakk>ordinal_utility ?carrier ?relation ?u; ?x \\<in> ?carrier;\n   ?y \\<in> ?carrier\\<rbrakk>\n  \\<Longrightarrow> ?x \\<succeq>[?relation] ?y = (?u ?y \\<le> ?u ?x)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "by fastforce"], ["proof (state)\nthis:\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "have \"measure_pmf.expectation (mix_pmf \\<alpha> p r) u \\<ge> measure_pmf.expectation (mix_pmf \\<alpha> q r) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u", "have \"measure_pmf.expectation (mix_pmf \\<alpha> p r) u = \n        \\<alpha> * measure_pmf.expectation p u + (1 - \\<alpha>) * measure_pmf.expectation r u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n    \\<alpha> * measure_pmf.expectation p u +\n    (1 - \\<alpha>) * measure_pmf.expectation r u", "using expected_value_mix_pmf_distrib[of p r \\<alpha> u] assms fnts a4"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (set_pmf p); finite (set_pmf r);\n   \\<alpha> \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n                    \\<alpha> * measure_pmf.expectation p u +\n                    (1 - \\<alpha>) * measure_pmf.expectation r u\n  finite outcomes\n  outcomes \\<noteq> {}\n  \\<exists>u.\n     ordinal_utility (\\<P> outcomes) \\<R>\n      (\\<lambda>x. measure_pmf.expectation x u)\n  finite (set_pmf p)\n  finite (set_pmf q)\n  finite (set_pmf r)\n  \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n    \\<alpha> * measure_pmf.expectation p u +\n    (1 - \\<alpha>) * measure_pmf.expectation r u", "by fastforce"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u", "moreover"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u", "have \"measure_pmf.expectation (mix_pmf \\<alpha> q r) u = \n        \\<alpha> * measure_pmf.expectation q u + (1 - \\<alpha>) * measure_pmf.expectation r u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n    \\<alpha> * measure_pmf.expectation q u +\n    (1 - \\<alpha>) * measure_pmf.expectation r u", "using expected_value_mix_pmf_distrib[of q r \\<alpha> u] assms fnts a4"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (set_pmf q); finite (set_pmf r);\n   \\<alpha> \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n                    \\<alpha> * measure_pmf.expectation q u +\n                    (1 - \\<alpha>) * measure_pmf.expectation r u\n  finite outcomes\n  outcomes \\<noteq> {}\n  \\<exists>u.\n     ordinal_utility (\\<P> outcomes) \\<R>\n      (\\<lambda>x. measure_pmf.expectation x u)\n  finite (set_pmf p)\n  finite (set_pmf q)\n  finite (set_pmf r)\n  \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n    \\<alpha> * measure_pmf.expectation q u +\n    (1 - \\<alpha>) * measure_pmf.expectation r u", "by fastforce"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n  \\<alpha> * measure_pmf.expectation q u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u", "ultimately"], ["proof (chain)\npicking this:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n  \\<alpha> * measure_pmf.expectation q u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u", "show ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n  \\<alpha> * measure_pmf.expectation q u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u", "using f"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n  \\<alpha> * measure_pmf.expectation q u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u", "using a4"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n  \\<alpha> * measure_pmf.expectation q u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n  \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u", "by auto"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n  \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n  \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q \\<Longrightarrow>\n    mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "then"], ["proof (chain)\npicking this:\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n  \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u", "show \"mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\""], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n  \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "using u ordinal_utility_expected_value' ocU_is_expected_utility_bernoulli in_lots"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n  \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u\n  ordinal_utility (\\<P> outcomes) \\<R>\n   (\\<lambda>x. measure_pmf.expectation x u)\n  \\<lbrakk>rational_preference (\\<P> ?outcomes) ?\\<R>;\n   independent_vnm (\\<P> ?outcomes) ?\\<R>; finite ?outcomes;\n   ?outcomes \\<noteq> {}; continuous_vnm (\\<P> ?outcomes) ?\\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u.\n                       ordinal_utility (\\<P> ?outcomes) ?\\<R>\n                        (\\<lambda>x. measure_pmf.expectation x u)\n  \\<lbrakk>rational_preference (\\<P> ?outcomes) ?\\<R>;\n   independent_vnm (\\<P> ?outcomes) ?\\<R>; finite ?outcomes;\n   ?outcomes \\<noteq> {}; continuous_vnm (\\<P> ?outcomes) ?\\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>\\<P> ?outcomes.\n                       \\<forall>y\\<in>\\<P> ?outcomes.\n                          x \\<succeq>[?\\<R>] y =\n                          (measure_pmf.expectation y\n                            (??.Neumann_Morgenstern_Utility_Theorem.ocU\n                              ?outcomes ?\\<R>)\n                           \\<le> measure_pmf.expectation x\n                                  (??.Neumann_Morgenstern_Utility_Theorem.ocU\n                                    ?outcomes ?\\<R>))\n  mix_pmf \\<alpha> p r \\<in> \\<P> outcomes\n  mix_pmf \\<alpha> q r \\<in> \\<P> outcomes\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "by (simp add: in_lots ordinal_utility_def)"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q \\<Longrightarrow>\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "moreover"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q \\<Longrightarrow>\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "have \"mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r \\<Longrightarrow> p \\<succeq>[\\<R>] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p\n     r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r \\<Longrightarrow>\n    p \\<succeq>[\\<R>] q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p\n     r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r \\<Longrightarrow>\n    p \\<succeq>[\\<R>] q", "assume \"mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\""], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p\n     r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r \\<Longrightarrow>\n    p \\<succeq>[\\<R>] q", "hence f:\"measure_pmf.expectation (mix_pmf \\<alpha> p r) u \\<ge> measure_pmf.expectation (mix_pmf \\<alpha> q r) u\""], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u", "using ordinal_utility.ordinal_utility_left u"], ["proof (prove)\nusing this:\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n  \\<lbrakk>ordinal_utility ?carrier ?relation ?u;\n   ?x \\<succeq>[?relation] ?y\\<rbrakk>\n  \\<Longrightarrow> ?u ?y \\<le> ?u ?x\n  ordinal_utility (\\<P> outcomes) \\<R>\n   (\\<lambda>x. measure_pmf.expectation x u)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u", "by fastforce"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n  \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p\n     r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r \\<Longrightarrow>\n    p \\<succeq>[\\<R>] q", "hence \"measure_pmf.expectation p u \\<ge> measure_pmf.expectation q u\""], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n  \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u \\<Longrightarrow>\n    measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "have \"measure_pmf.expectation (mix_pmf \\<alpha> p r) u = \n        \\<alpha> * measure_pmf.expectation p u + (1 - \\<alpha>) * measure_pmf.expectation r u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n    \\<alpha> * measure_pmf.expectation p u +\n    (1 - \\<alpha>) * measure_pmf.expectation r u", "using expected_value_mix_pmf_distrib[of p r \\<alpha> u] assms fnts a4"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (set_pmf p); finite (set_pmf r);\n   \\<alpha> \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n                    \\<alpha> * measure_pmf.expectation p u +\n                    (1 - \\<alpha>) * measure_pmf.expectation r u\n  finite outcomes\n  outcomes \\<noteq> {}\n  \\<exists>u.\n     ordinal_utility (\\<P> outcomes) \\<R>\n      (\\<lambda>x. measure_pmf.expectation x u)\n  finite (set_pmf p)\n  finite (set_pmf q)\n  finite (set_pmf r)\n  \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n    \\<alpha> * measure_pmf.expectation p u +\n    (1 - \\<alpha>) * measure_pmf.expectation r u", "by fastforce"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u \\<Longrightarrow>\n    measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "moreover"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u \\<Longrightarrow>\n    measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "have \"measure_pmf.expectation (mix_pmf \\<alpha> q r) u = \n        \\<alpha> * measure_pmf.expectation q u + (1 - \\<alpha>) * measure_pmf.expectation r u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n    \\<alpha> * measure_pmf.expectation q u +\n    (1 - \\<alpha>) * measure_pmf.expectation r u", "using expected_value_mix_pmf_distrib[of q r \\<alpha> u] assms fnts a4"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (set_pmf q); finite (set_pmf r);\n   \\<alpha> \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n                    \\<alpha> * measure_pmf.expectation q u +\n                    (1 - \\<alpha>) * measure_pmf.expectation r u\n  finite outcomes\n  outcomes \\<noteq> {}\n  \\<exists>u.\n     ordinal_utility (\\<P> outcomes) \\<R>\n      (\\<lambda>x. measure_pmf.expectation x u)\n  finite (set_pmf p)\n  finite (set_pmf q)\n  finite (set_pmf r)\n  \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n    \\<alpha> * measure_pmf.expectation q u +\n    (1 - \\<alpha>) * measure_pmf.expectation r u", "by fastforce"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n  \\<alpha> * measure_pmf.expectation q u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n    \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u \\<Longrightarrow>\n    measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "ultimately"], ["proof (chain)\npicking this:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n  \\<alpha> * measure_pmf.expectation q u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u", "show ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n  \\<alpha> * measure_pmf.expectation q u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "using f"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n  \\<alpha> * measure_pmf.expectation q u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n  \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "using a4"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf \\<alpha> p r) u =\n  \\<alpha> * measure_pmf.expectation p u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u =\n  \\<alpha> * measure_pmf.expectation q u +\n  (1 - \\<alpha>) * measure_pmf.expectation r u\n  measure_pmf.expectation (mix_pmf \\<alpha> q r) u\n  \\<le> measure_pmf.expectation (mix_pmf \\<alpha> p r) u\n  \\<alpha> \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "by auto"], ["proof (state)\nthis:\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n\ngoal (1 subgoal):\n 1. mix_pmf \\<alpha> p\n     r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r \\<Longrightarrow>\n    p \\<succeq>[\\<R>] q", "then"], ["proof (chain)\npicking this:\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "show \"p \\<succeq>[\\<R>] q\""], ["proof (prove)\nusing this:\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "using a1 a2 ordinal_utility.util_def_conf u"], ["proof (prove)\nusing this:\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n  p \\<in> \\<P> outcomes\n  q \\<in> \\<P> outcomes\n  \\<lbrakk>ordinal_utility ?carrier ?relation ?u; ?x \\<in> ?carrier;\n   ?y \\<in> ?carrier\\<rbrakk>\n  \\<Longrightarrow> (?u ?y \\<le> ?u ?x) = ?x \\<succeq>[?relation] ?y\n  ordinal_utility (\\<P> outcomes) \\<R>\n   (\\<lambda>x. measure_pmf.expectation x u)\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q", "by fastforce"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mix_pmf \\<alpha> p\n   r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r \\<Longrightarrow>\n  p \\<succeq>[\\<R>] q\n\ngoal (1 subgoal):\n 1. \\<And>p q r \\<alpha>.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes; \\<alpha> \\<in> {0<..1}\\<rbrakk>\n       \\<Longrightarrow> p \\<succeq>[\\<R>] q =\n                         mix_pmf \\<alpha> p\n                          r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "ultimately"], ["proof (chain)\npicking this:\n  p \\<succeq>[\\<R>] q \\<Longrightarrow>\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n  mix_pmf \\<alpha> p\n   r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r \\<Longrightarrow>\n  p \\<succeq>[\\<R>] q", "show \"p \\<succeq>[\\<R>] q = mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\""], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] q \\<Longrightarrow>\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n  mix_pmf \\<alpha> p\n   r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r \\<Longrightarrow>\n  p \\<succeq>[\\<R>] q\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] q =\n    mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r", "by blast"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q =\n  mix_pmf \\<alpha> p r \\<succeq>[\\<R>] mix_pmf \\<alpha> q r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_weight_for_equality:\n  assumes \"a > c\" and \"a \\<ge> b\" and \"b \\<ge> c\"\n  shows   \"\\<exists>(e::real) \\<in> {0..1}. (1-e) * a + e * c = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>{0..1}. (1 - e) * a + e * c = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>{0..1}. (1 - e) * a + e * c = b", "from assms"], ["proof (chain)\npicking this:\n  c < a\n  b \\<le> a\n  c \\<le> b", "have \"b \\<in> closed_segment a c\""], ["proof (prove)\nusing this:\n  c < a\n  b \\<le> a\n  c \\<le> b\n\ngoal (1 subgoal):\n 1. b \\<in> closed_segment a c", "by (simp add: closed_segment_eq_real_ivl)"], ["proof (state)\nthis:\n  b \\<in> closed_segment a c\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>{0..1}. (1 - e) * a + e * c = b", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> closed_segment a c\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>{0..1}. (1 - e) * a + e * c = b", "by (auto simp: closed_segment_def)"], ["proof (state)\nthis:\n  \\<exists>e\\<in>{0..1}. (1 - e) * a + e * c = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vNM_utilty_implies_continuity:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  assumes \"\\<exists>u. ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\"\n  shows \"continuous_vnm (lotteries_on outcomes) \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_vnm (\\<P> outcomes) \\<R>", "proof (rule continuous_vnmI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes;\n        p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                            mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "fix p q r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes;\n        p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                            mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "assume a1: \"p \\<in> \\<P> outcomes\""], ["proof (state)\nthis:\n  p \\<in> \\<P> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>p q r.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes;\n        p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                            mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "assume a2: \"q \\<in> \\<P> outcomes\""], ["proof (state)\nthis:\n  q \\<in> \\<P> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>p q r.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes;\n        p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                            mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "assume a3: \"r \\<in> \\<P> outcomes \""], ["proof (state)\nthis:\n  r \\<in> \\<P> outcomes\n\ngoal (1 subgoal):\n 1. \\<And>p q r.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes;\n        p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                            mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "assume a4: \"p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\""], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\n\ngoal (1 subgoal):\n 1. \\<And>p q r.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes;\n        p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                            mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "then"], ["proof (chain)\npicking this:\n  p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r", "have g: \"p \\<succeq>[\\<R>] r\""], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\n\ngoal (1 subgoal):\n 1. p \\<succeq>[\\<R>] r", "by (meson assms(3) ordinal_utility.util_imp_trans transD)"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] r\n\ngoal (1 subgoal):\n 1. \\<And>p q r.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes;\n        p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                            mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "obtain u where \n    u: \"ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        ordinal_utility (\\<P> outcomes) \\<R>\n         (\\<lambda>x. measure_pmf.expectation x u) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  finite outcomes\n  outcomes \\<noteq> {}\n  \\<exists>u.\n     ordinal_utility (\\<P> outcomes) \\<R>\n      (\\<lambda>x. measure_pmf.expectation x u)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        ordinal_utility (\\<P> outcomes) \\<R>\n         (\\<lambda>x. measure_pmf.expectation x u) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ordinal_utility (\\<P> outcomes) \\<R>\n   (\\<lambda>x. measure_pmf.expectation x u)\n\ngoal (1 subgoal):\n 1. \\<And>p q r.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes;\n        p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                            mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "have geqa: \"measure_pmf.expectation p u \\<ge> measure_pmf.expectation q u\" \n    \"measure_pmf.expectation q u \\<ge> measure_pmf.expectation r u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation q u \\<le> measure_pmf.expectation p u &&&\n    measure_pmf.expectation r u \\<le> measure_pmf.expectation q u", "using a4 u"], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\n  ordinal_utility (\\<P> outcomes) \\<R>\n   (\\<lambda>x. measure_pmf.expectation x u)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation q u \\<le> measure_pmf.expectation p u &&&\n    measure_pmf.expectation r u \\<le> measure_pmf.expectation q u", "by (meson ordinal_utility.ordinal_utility_left)+"], ["proof (state)\nthis:\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n  measure_pmf.expectation r u \\<le> measure_pmf.expectation q u\n\ngoal (1 subgoal):\n 1. \\<And>p q r.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes;\n        p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                            mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "have fnts: \"finite p\" \"finite q\" \"finite r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf p) &&& finite (set_pmf q) &&& finite (set_pmf r)", "using a1 a2 a3 fnt infinite_super lotteries_on_def"], ["proof (prove)\nusing this:\n  p \\<in> \\<P> outcomes\n  q \\<in> \\<P> outcomes\n  r \\<in> \\<P> outcomes\n  finite outcomes\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n  \\<P> ?Oc = {p. set_pmf p \\<subseteq> ?Oc}\n\ngoal (1 subgoal):\n 1. finite (set_pmf p) &&& finite (set_pmf q) &&& finite (set_pmf r)", "by auto+"], ["proof (state)\nthis:\n  finite (set_pmf p)\n  finite (set_pmf q)\n  finite (set_pmf r)\n\ngoal (1 subgoal):\n 1. \\<And>p q r.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes;\n        p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                            mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "consider \"p \\<succ>[\\<R>] r\" | \"p \\<approx>[\\<R>] r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<succeq>[\\<R>] r \\<and>\n             (r, p) \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     p \\<approx>[\\<R>] r \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using g"], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<succeq>[\\<R>] r \\<and>\n             (r, p) \\<notin> \\<R> \\<Longrightarrow>\n             thesis;\n     p \\<approx>[\\<R>] r \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   p \\<approx>[\\<R>] r \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>p q r.\n       \\<lbrakk>p \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n        r \\<in> \\<P> outcomes;\n        p \\<succeq>[\\<R>] q \\<and> q \\<succeq>[\\<R>] r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<alpha>\\<in>{0..1}.\n                            mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   p \\<approx>[\\<R>] r \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"\\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\""], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n           ?thesis;\n   p \\<approx>[\\<R>] r \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "case 1"], ["proof (state)\nthis:\n  p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "define a where a: \"a = measure_pmf.expectation p u\""], ["proof (state)\nthis:\n  a = measure_pmf.expectation p u\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "define b where b: \"b = measure_pmf.expectation r u\""], ["proof (state)\nthis:\n  b = measure_pmf.expectation r u\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "define c where c: \"c = measure_pmf.expectation q u\""], ["proof (state)\nthis:\n  c = measure_pmf.expectation q u\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "have \"a > b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a", "using \"1\" a1 a2 a3 a b ordinal_utility.util_def_conf u"], ["proof (prove)\nusing this:\n  p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R>\n  p \\<in> \\<P> outcomes\n  q \\<in> \\<P> outcomes\n  r \\<in> \\<P> outcomes\n  a = measure_pmf.expectation p u\n  b = measure_pmf.expectation r u\n  \\<lbrakk>ordinal_utility ?carrier ?relation ?u; ?x \\<in> ?carrier;\n   ?y \\<in> ?carrier\\<rbrakk>\n  \\<Longrightarrow> (?u ?y \\<le> ?u ?x) = ?x \\<succeq>[?relation] ?y\n  ordinal_utility (\\<P> outcomes) \\<R>\n   (\\<lambda>x. measure_pmf.expectation x u)\n\ngoal (1 subgoal):\n 1. b < a", "by force"], ["proof (state)\nthis:\n  b < a\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "have \"c \\<le> a\" \"b \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> a &&& b \\<le> c", "using geqa a b c"], ["proof (prove)\nusing this:\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n  measure_pmf.expectation r u \\<le> measure_pmf.expectation q u\n  a = measure_pmf.expectation p u\n  b = measure_pmf.expectation r u\n  c = measure_pmf.expectation q u\n\ngoal (1 subgoal):\n 1. c \\<le> a &&& b \\<le> c", "by blast+"], ["proof (state)\nthis:\n  c \\<le> a\n  b \\<le> c\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "then"], ["proof (chain)\npicking this:\n  c \\<le> a\n  b \\<le> c", "obtain e ::real where\n      e: \"e \\<in> {0..1}\" \"(1-e) * a + e * b = c\""], ["proof (prove)\nusing this:\n  c \\<le> a\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> {0..1}; (1 - e) * a + e * b = c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using exists_weight_for_equality[of b a c] \\<open>b < a\\<close>"], ["proof (prove)\nusing this:\n  c \\<le> a\n  b \\<le> c\n  \\<lbrakk>b < a; c \\<le> a; b \\<le> c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e\\<in>{0..1}. (1 - e) * a + e * b = c\n  b < a\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> {0..1}; (1 - e) * a + e * b = c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e \\<in> {0..1}\n  (1 - e) * a + e * b = c\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "have *:\"1-e \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - e \\<in> {0..1}", "using e(1)"], ["proof (prove)\nusing this:\n  e \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. 1 - e \\<in> {0..1}", "by auto"], ["proof (state)\nthis:\n  1 - e \\<in> {0..1}\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "hence \"measure_pmf.expectation (mix_pmf (1-e) p r) u = \n     (1-e) * measure_pmf.expectation p u + e * measure_pmf.expectation r u\""], ["proof (prove)\nusing this:\n  1 - e \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n    (1 - e) * measure_pmf.expectation p u + e * measure_pmf.expectation r u", "using expected_value_mix_pmf_distrib[of p r \"1-e\" u] fnts"], ["proof (prove)\nusing this:\n  1 - e \\<in> {0..1}\n  \\<lbrakk>finite (set_pmf p); finite (set_pmf r);\n   1 - e \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n                    (1 - e) * measure_pmf.expectation p u +\n                    (1 - (1 - e)) * measure_pmf.expectation r u\n  finite (set_pmf p)\n  finite (set_pmf q)\n  finite (set_pmf r)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n    (1 - e) * measure_pmf.expectation p u + e * measure_pmf.expectation r u", "by fastforce"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n  (1 - e) * measure_pmf.expectation p u + e * measure_pmf.expectation r u\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n  (1 - e) * measure_pmf.expectation p u + e * measure_pmf.expectation r u\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "have \"... = (1-e) * a + e * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - e) * measure_pmf.expectation p u +\n    e * measure_pmf.expectation r u =\n    (1 - e) * a + e * b", "using a b"], ["proof (prove)\nusing this:\n  a = measure_pmf.expectation p u\n  b = measure_pmf.expectation r u\n\ngoal (1 subgoal):\n 1. (1 - e) * measure_pmf.expectation p u +\n    e * measure_pmf.expectation r u =\n    (1 - e) * a + e * b", "by auto"], ["proof (state)\nthis:\n  (1 - e) * measure_pmf.expectation p u + e * measure_pmf.expectation r u =\n  (1 - e) * a + e * b\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "also"], ["proof (state)\nthis:\n  (1 - e) * measure_pmf.expectation p u + e * measure_pmf.expectation r u =\n  (1 - e) * a + e * b\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "have \"... = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - e) * a + e * b = c", "using c e"], ["proof (prove)\nusing this:\n  c = measure_pmf.expectation q u\n  e \\<in> {0..1}\n  (1 - e) * a + e * b = c\n\ngoal (1 subgoal):\n 1. (1 - e) * a + e * b = c", "by auto"], ["proof (state)\nthis:\n  (1 - e) * a + e * b = c\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.expectation (mix_pmf (1 - e) p r) u = c", "have f: \"measure_pmf.expectation (mix_pmf (1-e) p r) u =  measure_pmf.expectation q u\""], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf (1 - e) p r) u = c\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n    measure_pmf.expectation q u", "using c"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf (1 - e) p r) u = c\n  c = measure_pmf.expectation q u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n    measure_pmf.expectation q u", "by blast"], ["proof (state)\nthis:\n  measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n  measure_pmf.expectation q u\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "hence \"mix_pmf (1-e) p r \\<approx>[\\<R>] q\""], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n  measure_pmf.expectation q u\n\ngoal (1 subgoal):\n 1. mix_pmf (1 - e) p r \\<approx>[\\<R>] q", "using expected_value_is_utility_function[of outcomes \"mix_pmf (1-e) p r\" q \\<R> u] *"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n  measure_pmf.expectation q u\n  \\<lbrakk>finite outcomes; outcomes \\<noteq> {};\n   mix_pmf (1 - e) p r \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n   ordinal_utility (\\<P> outcomes) \\<R>\n    (\\<lambda>x. measure_pmf.expectation x u)\\<rbrakk>\n  \\<Longrightarrow> (measure_pmf.expectation q u\n                     \\<le> measure_pmf.expectation (mix_pmf (1 - e) p r)\n                            u) =\n                    mix_pmf (1 - e) p r \\<succeq>[\\<R>] q\n  1 - e \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. mix_pmf (1 - e) p r \\<approx>[\\<R>] q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n             measure_pmf.expectation q u;\n     \\<lbrakk>finite outcomes; outcomes \\<noteq> {};\n      mix_pmf (1 - e) p r \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n      ordinal_utility (\\<P> outcomes) \\<R>\n       (\\<lambda>x. measure_pmf.expectation x u)\\<rbrakk>\n     \\<Longrightarrow> (measure_pmf.expectation q u\n                        \\<le> measure_pmf.expectation (mix_pmf (1 - e) p r)\n                               u) =\n                       mix_pmf (1 - e) p r \\<succeq>[\\<R>] q;\n     1 - e \\<in> {0..1}\\<rbrakk>\n    \\<Longrightarrow> mix_pmf (1 - e) p r \\<approx>[\\<R>] q", "have \"mix_pmf (1 - e) p r \\<in> \\<P> outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf (1 - e) p r \\<in> \\<P> outcomes", "using \\<open>1 - e \\<in> {0..1}\\<close> a1 a3 mix_in_lot"], ["proof (prove)\nusing this:\n  1 - e \\<in> {0..1}\n  p \\<in> \\<P> outcomes\n  r \\<in> \\<P> outcomes\n  \\<lbrakk>?x \\<in> \\<P> ?outcomes; ?y \\<in> \\<P> ?outcomes;\n   ?\\<alpha> \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> mix_pmf ?\\<alpha> ?x ?y \\<in> \\<P> ?outcomes\n\ngoal (1 subgoal):\n 1. mix_pmf (1 - e) p r \\<in> \\<P> outcomes", "by blast"], ["proof (state)\nthis:\n  mix_pmf (1 - e) p r \\<in> \\<P> outcomes\n\ngoal (1 subgoal):\n 1. \\<lbrakk>measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n             measure_pmf.expectation q u;\n     \\<lbrakk>finite outcomes; outcomes \\<noteq> {};\n      mix_pmf (1 - e) p r \\<in> \\<P> outcomes; q \\<in> \\<P> outcomes;\n      ordinal_utility (\\<P> outcomes) \\<R>\n       (\\<lambda>x. measure_pmf.expectation x u)\\<rbrakk>\n     \\<Longrightarrow> (measure_pmf.expectation q u\n                        \\<le> measure_pmf.expectation (mix_pmf (1 - e) p r)\n                               u) =\n                       mix_pmf (1 - e) p r \\<succeq>[\\<R>] q;\n     1 - e \\<in> {0..1}\\<rbrakk>\n    \\<Longrightarrow> mix_pmf (1 - e) p r \\<approx>[\\<R>] q", "then"], ["proof (chain)\npicking this:\n  mix_pmf (1 - e) p r \\<in> \\<P> outcomes", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf (1 - e) p r \\<in> \\<P> outcomes\n\ngoal (1 subgoal):\n 1. mix_pmf (1 - e) p r \\<approx>[\\<R>] q", "using f a2 ordinal_utility.util_def u"], ["proof (prove)\nusing this:\n  mix_pmf (1 - e) p r \\<in> \\<P> outcomes\n  measure_pmf.expectation (mix_pmf (1 - e) p r) u =\n  measure_pmf.expectation q u\n  q \\<in> \\<P> outcomes\n  \\<lbrakk>ordinal_utility ?carrier ?relation ?u; ?x \\<in> ?carrier;\n   ?y \\<in> ?carrier\\<rbrakk>\n  \\<Longrightarrow> ?x \\<succeq>[?relation] ?y = (?u ?y \\<le> ?u ?x)\n  ordinal_utility (\\<P> outcomes) \\<R>\n   (\\<lambda>x. measure_pmf.expectation x u)\n\ngoal (1 subgoal):\n 1. mix_pmf (1 - e) p r \\<approx>[\\<R>] q", "by fastforce"], ["proof (state)\nthis:\n  mix_pmf (1 - e) p r \\<approx>[\\<R>] q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mix_pmf (1 - e) p r \\<approx>[\\<R>] q\n\ngoal (2 subgoals):\n 1. p \\<succeq>[\\<R>] r \\<and> (r, p) \\<notin> \\<R> \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n 2. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "then"], ["proof (chain)\npicking this:\n  mix_pmf (1 - e) p r \\<approx>[\\<R>] q", "show ?thesis"], ["proof (prove)\nusing this:\n  mix_pmf (1 - e) p r \\<approx>[\\<R>] q\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "using exists_weight_for_equality expected_value_mix_pmf_distrib *"], ["proof (prove)\nusing this:\n  mix_pmf (1 - e) p r \\<approx>[\\<R>] q\n  \\<lbrakk>?c < ?a; ?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e\\<in>{0..1}. (1 - e) * ?a + e * ?c = ?b\n  \\<lbrakk>finite (set_pmf ?p); finite (set_pmf ?q);\n   ?a \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.expectation (mix_pmf ?a ?p ?q) ?f =\n                    ?a * measure_pmf.expectation ?p ?f +\n                    (1 - ?a) * measure_pmf.expectation ?q ?f\n  1 - e \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n\ngoal (1 subgoal):\n 1. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "case 2"], ["proof (state)\nthis:\n  p \\<approx>[\\<R>] r\n\ngoal (1 subgoal):\n 1. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "have \"r \\<approx>[\\<R>] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<approx>[\\<R>] q", "by (meson \"2\" a4 assms(3) ordinal_utility.util_imp_trans transD)"], ["proof (state)\nthis:\n  r \\<approx>[\\<R>] q\n\ngoal (1 subgoal):\n 1. p \\<approx>[\\<R>] r \\<Longrightarrow>\n    \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "then"], ["proof (chain)\npicking this:\n  r \\<approx>[\\<R>] q", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<approx>[\\<R>] q\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q", "by force"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>\\<in>{0..1}. mix_pmf \\<alpha> p r \\<approx>[\\<R>] q\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem Von_Neumann_Morgenstern_Utility_Theorem:\n  assumes fnt: \"finite outcomes\" and \"outcomes \\<noteq> {}\"\n  shows \"rational_preference (lotteries_on outcomes) \\<R> \\<and> \n         independent_vnm (lotteries_on outcomes) \\<R> \\<and> \n         continuous_vnm (lotteries_on outcomes) \\<R> \\<longleftrightarrow> \n   (\\<exists>u. ordinal_utility (lotteries_on outcomes) \\<R> (\\<lambda>x. measure_pmf.expectation x u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rational_preference (\\<P> outcomes) \\<R> \\<and>\n     independent_vnm (\\<P> outcomes) \\<R> \\<and>\n     continuous_vnm (\\<P> outcomes) \\<R>) =\n    (\\<exists>u.\n        ordinal_utility (\\<P> outcomes) \\<R>\n         (\\<lambda>x. measure_pmf.expectation x u))", "using vNM_utility_implies_independence[OF assms, of \\<R>] \n    system_U_implies_vNM_utility[OF assms, of \\<R>]\n    vNM_utilty_implies_continuity[OF assms, of \\<R>]\n    ordinal_util_imp_rat_prefs[of \"lotteries_on outcomes\" \\<R>]"], ["proof (prove)\nusing this:\n  \\<exists>u.\n     ordinal_utility (\\<P> outcomes) \\<R>\n      (\\<lambda>x. measure_pmf.expectation x u) \\<Longrightarrow>\n  independent_vnm (\\<P> outcomes) \\<R>\n  \\<lbrakk>rational_preference (\\<P> outcomes) \\<R>;\n   independent_vnm (\\<P> outcomes) \\<R>;\n   continuous_vnm (\\<P> outcomes) \\<R>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u.\n                       ordinal_utility (\\<P> outcomes) \\<R>\n                        (\\<lambda>x. measure_pmf.expectation x u)\n  \\<exists>u.\n     ordinal_utility (\\<P> outcomes) \\<R>\n      (\\<lambda>x. measure_pmf.expectation x u) \\<Longrightarrow>\n  continuous_vnm (\\<P> outcomes) \\<R>\n  ordinal_utility (\\<P> outcomes) \\<R> ?u \\<Longrightarrow>\n  rational_preference (\\<P> outcomes) \\<R>\n\ngoal (1 subgoal):\n 1. (rational_preference (\\<P> outcomes) \\<R> \\<and>\n     independent_vnm (\\<P> outcomes) \\<R> \\<and>\n     continuous_vnm (\\<P> outcomes) \\<R>) =\n    (\\<exists>u.\n        ordinal_utility (\\<P> outcomes) \\<R>\n         (\\<lambda>x. measure_pmf.expectation x u))", "by auto"], ["", "end"]]}