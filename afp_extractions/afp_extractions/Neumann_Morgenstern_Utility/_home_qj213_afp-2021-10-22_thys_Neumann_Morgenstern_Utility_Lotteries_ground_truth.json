{"file_name": "/home/qj213/afp-2021-10-22/thys/Neumann_Morgenstern_Utility/Lotteries.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Neumann_Morgenstern_Utility", "problem_names": ["lemma lotteries_on_subset:\n  assumes \"A \\<subseteq> B\"\n  shows \"lotteries_on A \\<subseteq> lotteries_on B\"", "lemma support_in_outcomes:\n  \"\\<forall>oc. \\<forall>p \\<in> lotteries_on oc. \\<forall>a \\<in> set_pmf p. a \\<in> oc\"", "lemma lotteries_on_nonempty:\n  assumes \"outcomes \\<noteq> {}\" \n  shows \"lotteries_on outcomes \\<noteq> {}\"", "lemma finite_support_one_oc:\n  assumes \"card outcomes = 1\"\n  shows \"\\<forall>l \\<in> lotteries_on outcomes. finite (set_pmf l)\"", "lemma one_outcome_card_support_1:\n  assumes \"card outcomes = 1\"\n  shows \"\\<forall>l \\<in> lotteries_on outcomes. card (set_pmf l) = 1\"", "lemma finite_nempty_ex_degernate_in_lotteries:\n  assumes \"out \\<noteq> {}\"\n  assumes \"finite out\"\n  shows \"\\<exists>e \\<in> lotteries_on out. \\<exists>x \\<in> out. pmf e x = 1\"", "lemma card_support_1_probability_1:\n  assumes \"card (set_pmf p) = 1\"\n  shows \"\\<forall>e \\<in> set_pmf p. pmf p e = 1\"", "lemma one_outcome_card_lotteries_1:\n  assumes \"card outcomes = 1\"\n  shows \"card (lotteries_on outcomes) = 1\"", "lemma return_pmf_card_equals_set:\n  shows \"card {return_pmf x |x. x \\<in> S} = card S\"", "lemma mix_pmf_in_lotteries:\n  assumes \"p \\<in> lotteries_on A\"\n    and \"q \\<in> lotteries_on A\"\n    and \"a \\<in> {0<..<1}\"\n  shows \"(mix_pmf a p q) \\<in> lotteries_on A\"", "lemma card_degen_lotteries_equals_outcomes:\n  shows \"card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\""], "translations": [["", "lemma lotteries_on_subset:\n  assumes \"A \\<subseteq> B\"\n  shows \"lotteries_on A \\<subseteq> lotteries_on B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lotteries_on A \\<subseteq> lotteries_on B", "by (metis (no_types, lifting) Collect_mono assms gfp.leq_trans lotteries_on_def)"], ["", "lemma support_in_outcomes:\n  \"\\<forall>oc. \\<forall>p \\<in> lotteries_on oc. \\<forall>a \\<in> set_pmf p. a \\<in> oc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>oc.\n       \\<forall>p\\<in>lotteries_on oc. \\<forall>a\\<in>set_pmf p. a \\<in> oc", "by (simp add: lotteries_on_def subsetD)"], ["", "lemma lotteries_on_nonempty:\n  assumes \"outcomes \\<noteq> {}\" \n  shows \"lotteries_on outcomes \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lotteries_on outcomes \\<noteq> {}", "by (auto simp: lotteries_on_def) (metis (full_types) assms \n      empty_subsetI ex_in_conv insert_subset set_return_pmf)"], ["", "lemma finite_support_one_oc:\n  assumes \"card outcomes = 1\"\n  shows \"\\<forall>l \\<in> lotteries_on outcomes. finite (set_pmf l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l\\<in>lotteries_on outcomes. finite (set_pmf l)", "by (metis assms card.infinite finite_subset lotteries_on_def mem_Collect_eq zero_neq_one)"], ["", "lemma one_outcome_card_support_1:\n  assumes \"card outcomes = 1\"\n  shows \"\\<forall>l \\<in> lotteries_on outcomes. card (set_pmf l) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l\\<in>lotteries_on outcomes. card (set_pmf l) = 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       l \\<in> lotteries_on outcomes \\<Longrightarrow> card (set_pmf l) = 1", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       l \\<in> lotteries_on outcomes \\<Longrightarrow> card (set_pmf l) = 1", "assume \"l \\<in> lotteries_on outcomes\""], ["proof (state)\nthis:\n  l \\<in> lotteries_on outcomes\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       l \\<in> lotteries_on outcomes \\<Longrightarrow> card (set_pmf l) = 1", "have \"finite outcomes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite outcomes", "using assms card.infinite"], ["proof (prove)\nusing this:\n  card outcomes = 1\n  infinite ?A \\<Longrightarrow> card ?A = 0\n\ngoal (1 subgoal):\n 1. finite outcomes", "by force"], ["proof (state)\nthis:\n  finite outcomes\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       l \\<in> lotteries_on outcomes \\<Longrightarrow> card (set_pmf l) = 1", "then"], ["proof (chain)\npicking this:\n  finite outcomes", "have \"l \\<in> lotteries_on outcomes \\<longrightarrow> 1 = card (set_pmf l)\""], ["proof (prove)\nusing this:\n  finite outcomes\n\ngoal (1 subgoal):\n 1. l \\<in> lotteries_on outcomes \\<longrightarrow> 1 = card (set_pmf l)", "by (metis assms card_eq_0_iff card_mono finite_support_one_oc le_neq_implies_less \n        less_one lotteries_on_def mem_Collect_eq set_pmf_not_empty)"], ["proof (state)\nthis:\n  l \\<in> lotteries_on outcomes \\<longrightarrow> 1 = card (set_pmf l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       l \\<in> lotteries_on outcomes \\<Longrightarrow> card (set_pmf l) = 1", "then"], ["proof (chain)\npicking this:\n  l \\<in> lotteries_on outcomes \\<longrightarrow> 1 = card (set_pmf l)", "show \"card (set_pmf l) = 1\""], ["proof (prove)\nusing this:\n  l \\<in> lotteries_on outcomes \\<longrightarrow> 1 = card (set_pmf l)\n\ngoal (1 subgoal):\n 1. card (set_pmf l) = 1", "by (simp add: \\<open>l \\<in> lotteries_on outcomes\\<close>)"], ["proof (state)\nthis:\n  card (set_pmf l) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_nempty_ex_degernate_in_lotteries:\n  assumes \"out \\<noteq> {}\"\n  assumes \"finite out\"\n  shows \"\\<exists>e \\<in> lotteries_on out. \\<exists>x \\<in> out. pmf e x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>lotteries_on out. \\<exists>x\\<in>out. pmf e x = 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>e\\<in>lotteries_on out.\n               \\<exists>x\\<in>out. pmf e x = 1) \\<Longrightarrow>\n    False", "assume a: \"\\<not> (\\<exists>e\\<in>lotteries_on out. \\<exists>x\\<in>out. pmf e x = 1)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>e\\<in>lotteries_on out. \\<exists>x\\<in>out. pmf e x = 1)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>e\\<in>lotteries_on out.\n               \\<exists>x\\<in>out. pmf e x = 1) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>e\\<in>lotteries_on out. \\<exists>x\\<in>out. pmf e x = 1)", "have subset: \"\\<forall>e \\<in> lotteries_on out. set_pmf e \\<subseteq> out\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>e\\<in>lotteries_on out. \\<exists>x\\<in>out. pmf e x = 1)\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>lotteries_on out. set_pmf e \\<subseteq> out", "using lotteries_on_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>e\\<in>lotteries_on out. \\<exists>x\\<in>out. pmf e x = 1)\n  lotteries_on ?Oc = {p. set_pmf p \\<subseteq> ?Oc}\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>lotteries_on out. set_pmf e \\<subseteq> out", "by (simp add: lotteries_on_def)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>lotteries_on out. set_pmf e \\<subseteq> out\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>e\\<in>lotteries_on out.\n               \\<exists>x\\<in>out. pmf e x = 1) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>e\\<in>lotteries_on out. set_pmf e \\<subseteq> out", "have \"\\<forall>e. e \\<in> lotteries_on out \\<longrightarrow> ((\\<Sum>i\\<in>set_pmf e. pmf e i) = 1)\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>lotteries_on out. set_pmf e \\<subseteq> out\n\ngoal (1 subgoal):\n 1. \\<forall>e.\n       e \\<in> lotteries_on out \\<longrightarrow>\n       sum (pmf e) (set_pmf e) = 1", "using sum_pmf_eq_1"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>lotteries_on out. set_pmf e \\<subseteq> out\n  \\<lbrakk>finite ?A; set_pmf ?p \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> sum (pmf ?p) ?A = 1\n\ngoal (1 subgoal):\n 1. \\<forall>e.\n       e \\<in> lotteries_on out \\<longrightarrow>\n       sum (pmf e) (set_pmf e) = 1", "by (metis subset  assms(2) finite_subset order_refl)"], ["proof (state)\nthis:\n  \\<forall>e.\n     e \\<in> lotteries_on out \\<longrightarrow> sum (pmf e) (set_pmf e) = 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>e\\<in>lotteries_on out.\n               \\<exists>x\\<in>out. pmf e x = 1) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>e.\n     e \\<in> lotteries_on out \\<longrightarrow> sum (pmf e) (set_pmf e) = 1", "show False"], ["proof (prove)\nusing this:\n  \\<forall>e.\n     e \\<in> lotteries_on out \\<longrightarrow> sum (pmf e) (set_pmf e) = 1\n\ngoal (1 subgoal):\n 1. False", "by (metis (no_types, lifting) a assms(1) assms(2) card.empty card_gt_0_iff card_seteq \n        empty_subsetI finite.emptyI finite_insert insert_subset lotteries_on_def subsetI\n        measure_measure_pmf_finite mem_Collect_eq nat_less_le pmf.rep_eq set_pmf_of_set )"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_support_1_probability_1:\n  assumes \"card (set_pmf p) = 1\"\n  shows \"\\<forall>e \\<in> set_pmf p. pmf p e = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set_pmf p. pmf p e = 1", "by(auto) (metis assms card_1_singletonE card_ge_0_finite \n      card_subset_eq ex_card le_numeral_extra(4) measure_measure_pmf_finite \n      pmf.rep_eq singletonD sum_pmf_eq_1 zero_less_one)"], ["", "lemma one_outcome_card_lotteries_1:\n  assumes \"card outcomes = 1\"\n  shows \"card (lotteries_on outcomes) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (lotteries_on outcomes) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (lotteries_on outcomes) = 1", "obtain x :: 'a where\n    x: \"outcomes = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. outcomes = {x} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms card_1_singletonE"], ["proof (prove)\nusing this:\n  card outcomes = 1\n  \\<lbrakk>card ?A = 1; \\<And>x. ?A = {x} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x. outcomes = {x} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  outcomes = {x}\n\ngoal (1 subgoal):\n 1. card (lotteries_on outcomes) = 1", "have exl: \"\\<exists>l \\<in> lotteries_on outcomes. pmf l x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>lotteries_on outcomes. pmf l x = 1", "by (metis x assms card.infinite empty_iff \n        finite_nempty_ex_degernate_in_lotteries insert_iff zero_neq_one)"], ["proof (state)\nthis:\n  \\<exists>l\\<in>lotteries_on outcomes. pmf l x = 1\n\ngoal (1 subgoal):\n 1. card (lotteries_on outcomes) = 1", "have pmfs: \"\\<forall>l \\<in> lotteries_on outcomes. set_pmf l = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l\\<in>lotteries_on outcomes. set_pmf l = {x}", "by (simp add: lotteries_on_def set_pmf_subset_singleton x)"], ["proof (state)\nthis:\n  \\<forall>l\\<in>lotteries_on outcomes. set_pmf l = {x}\n\ngoal (1 subgoal):\n 1. card (lotteries_on outcomes) = 1", "have \"\\<forall>l \\<in> lotteries_on outcomes. pmf l x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l\\<in>lotteries_on outcomes. pmf l x = 1", "by (simp add: lotteries_on_def set_pmf_subset_singleton x)"], ["proof (state)\nthis:\n  \\<forall>l\\<in>lotteries_on outcomes. pmf l x = 1\n\ngoal (1 subgoal):\n 1. card (lotteries_on outcomes) = 1", "then"], ["proof (chain)\npicking this:\n  \\<forall>l\\<in>lotteries_on outcomes. pmf l x = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>l\\<in>lotteries_on outcomes. pmf l x = 1\n\ngoal (1 subgoal):\n 1. card (lotteries_on outcomes) = 1", "by (metis exl empty_iff is_singletonI' is_singleton_altdef\n        order_refl pmfs set_pmf_subset_singleton)"], ["proof (state)\nthis:\n  card (lotteries_on outcomes) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma return_pmf_card_equals_set:\n  shows \"card {return_pmf x |x. x \\<in> S} = card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {return_pmf x |x. x \\<in> S} = card S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. card {return_pmf x |x. x \\<in> S} = card S", "have \"{return_pmf x |x. x \\<in> S} = return_pmf ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {return_pmf x |x. x \\<in> S} = return_pmf ` S", "by blast"], ["proof (state)\nthis:\n  {return_pmf x |x. x \\<in> S} = return_pmf ` S\n\ngoal (1 subgoal):\n 1. card {return_pmf x |x. x \\<in> S} = card S", "also"], ["proof (state)\nthis:\n  {return_pmf x |x. x \\<in> S} = return_pmf ` S\n\ngoal (1 subgoal):\n 1. card {return_pmf x |x. x \\<in> S} = card S", "have \"card \\<dots> = card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (return_pmf ` S) = card S", "by (intro card_image) (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  card (return_pmf ` S) = card S\n\ngoal (1 subgoal):\n 1. card {return_pmf x |x. x \\<in> S} = card S", "finally"], ["proof (chain)\npicking this:\n  card {return_pmf x |x. x \\<in> S} = card S", "show \"card {return_pmf x |x. x \\<in> S} = card S\""], ["proof (prove)\nusing this:\n  card {return_pmf x |x. x \\<in> S} = card S\n\ngoal (1 subgoal):\n 1. card {return_pmf x |x. x \\<in> S} = card S", "."], ["proof (state)\nthis:\n  card {return_pmf x |x. x \\<in> S} = card S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mix_pmf_in_lotteries:\n  assumes \"p \\<in> lotteries_on A\"\n    and \"q \\<in> lotteries_on A\"\n    and \"a \\<in> {0<..<1}\"\n  shows \"(mix_pmf a p q) \\<in> lotteries_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mix_pmf a p q \\<in> lotteries_on A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mix_pmf a p q \\<in> lotteries_on A", "have \"set_pmf (mix_pmf a p q) = set_pmf p \\<union> set_pmf q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (mix_pmf a p q) = set_pmf p \\<union> set_pmf q", "by (meson assms(3) set_pmf_mix)"], ["proof (state)\nthis:\n  set_pmf (mix_pmf a p q) = set_pmf p \\<union> set_pmf q\n\ngoal (1 subgoal):\n 1. mix_pmf a p q \\<in> lotteries_on A", "then"], ["proof (chain)\npicking this:\n  set_pmf (mix_pmf a p q) = set_pmf p \\<union> set_pmf q", "show ?thesis"], ["proof (prove)\nusing this:\n  set_pmf (mix_pmf a p q) = set_pmf p \\<union> set_pmf q\n\ngoal (1 subgoal):\n 1. mix_pmf a p q \\<in> lotteries_on A", "by (metis Un_subset_iff assms(1) assms(2) lotteries_on_def mem_Collect_eq)"], ["proof (state)\nthis:\n  mix_pmf a p q \\<in> lotteries_on A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_degen_lotteries_equals_outcomes:\n  shows \"card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "consider (empty) \"out = {}\" | (not_empty) \"out \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>out = {} \\<Longrightarrow> thesis;\n     out \\<noteq> {} \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>out = {} \\<Longrightarrow> ?thesis;\n   out \\<noteq> {} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>out = {} \\<Longrightarrow> ?thesis;\n   out \\<noteq> {} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>out = {} \\<Longrightarrow> ?thesis;\n   out \\<noteq> {} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. out = {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\n 2. out \\<noteq> {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "case not_empty"], ["proof (state)\nthis:\n  out \\<noteq> {}\n\ngoal (2 subgoals):\n 1. out = {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\n 2. out \\<noteq> {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "define DG where\n      DG: \"DG = {x \\<in> lotteries_on out. card (set_pmf x) = 1}\""], ["proof (state)\nthis:\n  DG = {x \\<in> lotteries_on out. card (set_pmf x) = 1}\n\ngoal (2 subgoals):\n 1. out = {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\n 2. out \\<noteq> {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "define AP where\n      AP: \"AP = {return_pmf x |x. x \\<in> out}\""], ["proof (state)\nthis:\n  AP = {return_pmf x |x. x \\<in> out}\n\ngoal (2 subgoals):\n 1. out = {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\n 2. out \\<noteq> {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "have **: \"card AP = card out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card AP = card out", "using AP return_pmf_card_equals_set"], ["proof (prove)\nusing this:\n  AP = {return_pmf x |x. x \\<in> out}\n  card {return_pmf x |x. x \\<in> ?S} = card ?S\n\ngoal (1 subgoal):\n 1. card AP = card out", "by blast"], ["proof (state)\nthis:\n  card AP = card out\n\ngoal (2 subgoals):\n 1. out = {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\n 2. out \\<noteq> {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "have *: \"\\<forall>d \\<in> DG. d \\<in> AP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>DG. d \\<in> AP", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d. d \\<in> DG \\<Longrightarrow> d \\<in> AP", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d. d \\<in> DG \\<Longrightarrow> d \\<in> AP", "assume \"l \\<in> DG\""], ["proof (state)\nthis:\n  l \\<in> DG\n\ngoal (1 subgoal):\n 1. \\<And>d. d \\<in> DG \\<Longrightarrow> d \\<in> AP", "then"], ["proof (chain)\npicking this:\n  l \\<in> DG", "have \"l \\<in> lotteries_on out \\<and> 1 = card (set_pmf l)\""], ["proof (prove)\nusing this:\n  l \\<in> DG\n\ngoal (1 subgoal):\n 1. l \\<in> lotteries_on out \\<and> 1 = card (set_pmf l)", "using DG"], ["proof (prove)\nusing this:\n  l \\<in> DG\n  DG = {x \\<in> lotteries_on out. card (set_pmf x) = 1}\n\ngoal (1 subgoal):\n 1. l \\<in> lotteries_on out \\<and> 1 = card (set_pmf l)", "by force"], ["proof (state)\nthis:\n  l \\<in> lotteries_on out \\<and> 1 = card (set_pmf l)\n\ngoal (1 subgoal):\n 1. \\<And>d. d \\<in> DG \\<Longrightarrow> d \\<in> AP", "then"], ["proof (chain)\npicking this:\n  l \\<in> lotteries_on out \\<and> 1 = card (set_pmf l)", "obtain x where\n        x: \"x \\<in> out\" \"set_pmf l = {x}\""], ["proof (prove)\nusing this:\n  l \\<in> lotteries_on out \\<and> 1 = card (set_pmf l)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> out; set_pmf l = {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types) card_1_singletonE singletonI support_in_outcomes)"], ["proof (state)\nthis:\n  x \\<in> out\n  set_pmf l = {x}\n\ngoal (1 subgoal):\n 1. \\<And>d. d \\<in> DG \\<Longrightarrow> d \\<in> AP", "have \"return_pmf x = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf x = l", "using set_pmf_subset_singleton x(2)"], ["proof (prove)\nusing this:\n  (set_pmf ?p \\<subseteq> {?x}) = (?p = return_pmf ?x)\n  set_pmf l = {x}\n\ngoal (1 subgoal):\n 1. return_pmf x = l", "by fastforce"], ["proof (state)\nthis:\n  return_pmf x = l\n\ngoal (1 subgoal):\n 1. \\<And>d. d \\<in> DG \\<Longrightarrow> d \\<in> AP", "then"], ["proof (chain)\npicking this:\n  return_pmf x = l", "show \"l \\<in> AP\""], ["proof (prove)\nusing this:\n  return_pmf x = l\n\ngoal (1 subgoal):\n 1. l \\<in> AP", "using AP x(1)"], ["proof (prove)\nusing this:\n  return_pmf x = l\n  AP = {return_pmf x |x. x \\<in> out}\n  x \\<in> out\n\ngoal (1 subgoal):\n 1. l \\<in> AP", "by blast"], ["proof (state)\nthis:\n  l \\<in> AP\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>d\\<in>DG. d \\<in> AP\n\ngoal (2 subgoals):\n 1. out = {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\n 2. out \\<noteq> {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "moreover"], ["proof (state)\nthis:\n  \\<forall>d\\<in>DG. d \\<in> AP\n\ngoal (2 subgoals):\n 1. out = {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\n 2. out \\<noteq> {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "have \"AP = DG\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AP = DG", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. AP \\<subseteq> DG\n 2. DG \\<subseteq> AP", "have \"\\<forall>e \\<in> AP. e \\<in> lotteries_on out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>AP. e \\<in> lotteries_on out", "by(auto simp: lotteries_on_def AP)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>AP. e \\<in> lotteries_on out\n\ngoal (2 subgoals):\n 1. AP \\<subseteq> DG\n 2. DG \\<subseteq> AP", "then"], ["proof (chain)\npicking this:\n  \\<forall>e\\<in>AP. e \\<in> lotteries_on out", "show \"AP \\<subseteq> DG\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>AP. e \\<in> lotteries_on out\n\ngoal (1 subgoal):\n 1. AP \\<subseteq> DG", "using DG AP"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>AP. e \\<in> lotteries_on out\n  DG = {x \\<in> lotteries_on out. card (set_pmf x) = 1}\n  AP = {return_pmf x |x. x \\<in> out}\n\ngoal (1 subgoal):\n 1. AP \\<subseteq> DG", "by force"], ["proof (state)\nthis:\n  AP \\<subseteq> DG\n\ngoal (1 subgoal):\n 1. DG \\<subseteq> AP", "qed (auto simp: *)"], ["proof (state)\nthis:\n  AP = DG\n\ngoal (2 subgoals):\n 1. out = {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\n 2. out \\<noteq> {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>d\\<in>DG. d \\<in> AP\n  AP = DG", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>DG. d \\<in> AP\n  AP = DG\n\ngoal (1 subgoal):\n 1. card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "using DG **"], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>DG. d \\<in> AP\n  AP = DG\n  DG = {x \\<in> lotteries_on out. card (set_pmf x) = 1}\n  card AP = card out\n\ngoal (1 subgoal):\n 1. card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "by blast"], ["proof (state)\nthis:\n  card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\n\ngoal (1 subgoal):\n 1. out = {} \\<Longrightarrow>\n    card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out", "qed (simp add: lotteries_on_def set_pmf_not_empty)"], ["proof (state)\nthis:\n  card {x \\<in> lotteries_on out. card (set_pmf x) = 1} = card out\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}