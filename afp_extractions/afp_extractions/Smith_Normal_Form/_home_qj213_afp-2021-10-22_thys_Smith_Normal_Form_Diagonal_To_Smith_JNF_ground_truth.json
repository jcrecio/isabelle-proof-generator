{"file_name": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form/Diagonal_To_Smith_JNF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form", "problem_names": ["lemma HMA_diagonal_step[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _) \n    ===> (=) ===> (=) ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A. diagonal_step_JNF A i j) (\\<lambda>B. diagonal_step B i j)\"", "lemma HMA_diagonal_step_PQ[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: bezout_ring ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _) \n    ===> (=) ===> rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M) \n    (\\<lambda>A bezout. diagonal_step_PQ_JNF A i k bezout) (\\<lambda>A bezout. diagonal_step_PQ A i k bezout)\"", "lemma HMA_diagonal_to_Smith_i_PQ_aux: \"HMA_M3 (P,A,Q)  \n  (P' :: 'a :: bezout_ring ^ 'nr :: mod_type ^ 'nr :: mod_type,\n   A' :: 'a :: bezout_ring ^ 'nc :: mod_type ^ 'nr :: mod_type,\n   Q' :: 'a :: bezout_ring ^ 'nc :: mod_type ^ 'nc :: mod_type)\n  \\<Longrightarrow> HMA_M3 (diagonal_to_Smith_i_PQ_JNF xs i bezout (P,A,Q)) \n             (diagonal_to_Smith_i_PQ xs i bezout (P',A',Q'))\"", "lemma HMA_diagonal_to_Smith_i_PQ[transfer_rule]: \n  \"((=) \n  ===> (HMA_M3 :: (_ \\<Rightarrow> (_\\<times>('a :: bezout_ring ^ 'nc :: mod_type ^ 'nr :: mod_type) \\<times> _) \\<Rightarrow>_)) \n  ===> HMA_M3) (diagonal_to_Smith_i_PQ_JNF xs i) (diagonal_to_Smith_i_PQ xs i)\"", "lemmas Diagonal_to_Smith_row_i_PQ_JNF_def = Diagonal_to_Smith_row_i_PQ_JNF.simps", "lemma HMA_Diagonal_to_Smith_row_i_PQ[transfer_rule]:\n  \"((=) ===> (HMA_M3 :: (_ \\<Rightarrow> (_ \\<times> ('a::bezout_ring^'nc::mod_type^'nr::mod_type) \\<times> _) \\<Rightarrow> _)) ===> HMA_M3) \n  (Diagonal_to_Smith_row_i_PQ_JNF i) (Diagonal_to_Smith_row_i_PQ i)\"", "lemma HMA_diagonal_to_Smith_aux_PQ_JNF[transfer_rule]:\n  \"((=) ===> (HMA_M3 :: (_ \\<Rightarrow> (_ \\<times> ('a::bezout_ring^'nc::mod_type^'nr::mod_type) \\<times> _) \\<Rightarrow> _)) ===> HMA_M3) \n  (diagonal_to_Smith_aux_PQ_JNF xs) (diagonal_to_Smith_aux_PQ xs)\"", "lemmas diagonal_to_Smith_PQ_JNF_def = diagonal_to_Smith_PQ_JNF.simps", "lemma diagonal_step_PQ_JNF_dim:\n  assumes A: \"A \\<in> carrier_mat m n\"\n    and d: \"diagonal_step_PQ_JNF A i j bezout = (P,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> Q \\<in> carrier_mat n n\"", "lemma diagonal_step_JNF_dim:\n  assumes A: \"A \\<in> carrier_mat m n\"\n  shows \"diagonal_step_JNF A i j d v \\<in> carrier_mat m n\"", "lemma diagonal_to_Smith_i_PQ_JNF_dim:\n  assumes \"P' \\<in> carrier_mat m m \\<and> A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\"\n    and \"diagonal_to_Smith_i_PQ_JNF xs i bezout (P',A',Q') = (P,A,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\"", "lemma Diagonal_to_Smith_row_i_PQ_JNF_dim:\n  assumes \"P' \\<in> carrier_mat m m \\<and> A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\"\n    and \"Diagonal_to_Smith_row_i_PQ_JNF i bezout (P',A',Q') = (P,A,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\"", "lemma diagonal_to_Smith_aux_PQ_JNF_dim:\n  assumes \"P' \\<in> carrier_mat m m \\<and> A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\"\n    and \"diagonal_to_Smith_aux_PQ_JNF xs bezout (P',A',Q') = (P,A,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\"", "lemma diagonal_to_Smith_PQ_JNF_dim:\n  assumes \"A \\<in> carrier_mat m n\" \n    and PSQ: \"diagonal_to_Smith_PQ_JNF A bezout = (P,S,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\"", "lemma HMA_diagonal_to_Smith_PQ_JNF[transfer_rule]:\n \"((Mod_Type_Connect.HMA_M) ===> (=) ===> HMA_M3) (diagonal_to_Smith_PQ_JNF) (diagonal_to_Smith_PQ)\"", "lemma diagonal_to_Smith_PQ_JNF_with_types:\n  assumes A: \"A \\<in> carrier_mat CARD('nr::mod_type) CARD('nc::mod_type)\"\n  and S: \"S \\<in> carrier_mat CARD('nr) CARD('nc)\"\n  and P: \"P \\<in> carrier_mat CARD('nr) CARD('nr)\"\n  and Q: \"Q \\<in> carrier_mat CARD('nc) CARD('nc)\"\n  and PSQ: \"diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q)\"\n  and d:\"isDiagonal_mat A\" and ib: \"is_bezout_ext bezout\"\nshows \"S = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\"", "lemma diagonal_to_Smith_PQ_JNF_mod_ring_with_types:\n  assumes A: \"A \\<in> carrier_mat CARD('nr::nontriv mod_ring) CARD('nc::nontriv mod_ring)\"\n  and S: \"S \\<in> carrier_mat CARD('nr mod_ring) CARD('nc mod_ring)\"\n  and P: \"P \\<in> carrier_mat CARD('nr mod_ring) CARD('nr mod_ring)\"\n  and Q: \"Q \\<in> carrier_mat CARD('nc mod_ring) CARD('nc mod_ring)\"\n  and PSQ: \"diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q)\"\n  and d:\"isDiagonal_mat A\" and ib: \"is_bezout_ext bezout\"\nshows \"S = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\"", "lemma diagonal_to_Smith_PQ_JNF_internalized_first:\n  \"class.nontriv TYPE('a::type) \\<Longrightarrow>\n  A \\<in> carrier_mat CARD('a) CARD('nc::nontriv) \\<Longrightarrow>\n  S \\<in> carrier_mat CARD('a) CARD('nc) \\<Longrightarrow>\n  P \\<in> carrier_mat CARD('a) CARD('a) \\<Longrightarrow>\n  Q \\<in> carrier_mat CARD('nc) CARD('nc) \\<Longrightarrow>\n  diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q) \\<Longrightarrow>\n  isDiagonal_mat A \\<Longrightarrow> is_bezout_ext bezout \\<Longrightarrow> \n  S = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\"", "lemma diagonal_to_Smith_PQ_JNF_internalized:\n  \"class.nontriv TYPE('c::type) \\<Longrightarrow>\n  class.nontriv TYPE('a::type) \\<Longrightarrow>\n  A \\<in> carrier_mat CARD('a) CARD('c) \\<Longrightarrow>\n  S \\<in> carrier_mat CARD('a) CARD('c) \\<Longrightarrow>\n  P \\<in> carrier_mat CARD('a) CARD('a) \\<Longrightarrow>\n  Q \\<in> carrier_mat CARD('c) CARD('c) \\<Longrightarrow>\n  diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q) \\<Longrightarrow>\n  isDiagonal_mat A \\<Longrightarrow> is_bezout_ext bezout \\<Longrightarrow> \nS = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\"", "lemma type_to_set1:\n  shows \"class.nontriv TYPE('b)\" (is ?a) and \"m=CARD('b)\" (is ?b)", "lemma type_to_set2:\n  shows \"class.nontriv TYPE('c)\" (is ?a) and \"n=CARD('c)\" (is ?b)", "lemma diagonal_to_Smith_PQ_JNF_local_typedef:  \n  assumes A: \"isDiagonal_mat A\" and ib: \"is_bezout_ext bezout\"\n  and A_dim: \"A \\<in> carrier_mat m n\"\n  assumes PSQ: \"(P,S,Q) = diagonal_to_Smith_PQ_JNF A bezout\"\n  shows \"S = P*A*Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\n  \\<and> P \\<in> carrier_mat m m \\<and> S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\"", "lemma diagonal_to_Smith_PQ_JNF_canceled_first:\n  \"\\<exists>Rep Abs. type_definition Rep Abs {0..<int n} \\<Longrightarrow> {0..<int m} \\<noteq> {} \\<Longrightarrow>\n  1 < m \\<Longrightarrow> 1 < n \\<Longrightarrow> isDiagonal_mat A \\<Longrightarrow> is_bezout_ext bezout \\<Longrightarrow>\n  A \\<in> carrier_mat m n \\<Longrightarrow> (P, S, Q) = diagonal_to_Smith_PQ_JNF A bezout \\<Longrightarrow>\n  S = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S \n  \\<and> P \\<in> carrier_mat m m \\<and> S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\"", "lemma diagonal_to_Smith_PQ_JNF_canceled_both:\n  \"{0..<int n} \\<noteq> {} \\<Longrightarrow> {0..<int m} \\<noteq> {} \\<Longrightarrow> 1 < m \\<Longrightarrow> 1 < n \\<Longrightarrow>\n  isDiagonal_mat A \\<Longrightarrow> is_bezout_ext bezout \\<Longrightarrow> A \\<in> carrier_mat m n \\<Longrightarrow>\n  (P, S, Q) = diagonal_to_Smith_PQ_JNF A bezout \\<Longrightarrow> S = P * A * Q \\<and>\n  invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S \n  \\<and> P \\<in> carrier_mat m m \\<and> S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\"", "lemma diagonal_to_Smith_PQ_JNF:  \n  assumes A: \"isDiagonal_mat A\" and ib: \"is_bezout_ext bezout\"\n  and \"A \\<in> carrier_mat m n\" \n  and PBQ: \"(P,S,Q) = diagonal_to_Smith_PQ_JNF A bezout\" \n(*The following two assumptions appear since mod_type requires 1<CARD. \nThose cases could be treated separately.*)\n  and n: \"n>1\" and m: \"m>1\" \n  shows \"S = P*A*Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\n  \\<and> P \\<in> carrier_mat m m \\<and> S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\""], "translations": [["", "lemma HMA_diagonal_step[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _) \n    ===> (=) ===> (=) ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A. diagonal_step_JNF A i j) (\\<lambda>B. diagonal_step B i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=) ===> (=) ===> Mod_Type_Connect.HMA_M)\n     (\\<lambda>A. diagonal_step_JNF A i j) (\\<lambda>B. diagonal_step B i j)", "by (intro rel_funI, goal_cases, auto simp add: Mod_Type_Connect.HMA_M_def \n      diagonal_step_JNF_def diagonal_step_def)\n (rule eq_matI, auto simp add: Mod_Type_Connect.from_hma\\<^sub>m_def, insert from_nat_eq_imp_eq i j, auto)"], ["", "end"], ["", "definition diagonal_step_PQ_JNF :: \n  \"'a::{bezout_ring} mat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a bezout \\<Rightarrow> ('a mat \\<times> ('a mat))\"\n  where \"diagonal_step_PQ_JNF A i k bezout = \n  (let  m = dim_row A; n = dim_col A;\n        (p, q, u, v, d) = bezout (A $$ (i,i)) (A $$ (k,k));\n        P = addrow (-v) k i (swaprows i k (addrow p k i (1\\<^sub>m m)));\n        Q = multcol k (-1) (addcol u k i (addcol q i k (1\\<^sub>m n)))\n        in (P,Q)\n        )\""], ["", "context\n  includes lifting_syntax\n  fixes i and k::nat\n  assumes i: \"i < min (CARD('nr::mod_type)) (CARD('nc::mod_type))\"\n  and k: \"k < min (CARD('nr::mod_type)) (CARD('nc::mod_type))\"\nbegin"], ["", "lemma HMA_diagonal_step_PQ[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: bezout_ring ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _) \n    ===> (=) ===> rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M) \n    (\\<lambda>A bezout. diagonal_step_PQ_JNF A i k bezout) (\\<lambda>A bezout. diagonal_step_PQ A i k bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     (=) ===> rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M)\n     (\\<lambda>A. diagonal_step_PQ_JNF A i k)\n     (\\<lambda>A. diagonal_step_PQ A i k)", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "case (1 A A' bezout bezout')"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n  bezout = bezout'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "note HMA_M_AA'[transfer_rule] = 1(1)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "let ?d_JNF = \"(diagonal_step_PQ_JNF A i k bezout)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "let ?d_HA = \"(diagonal_step_PQ A' i k bezout)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I k (from_nat k::'nc)\"\n    and [transfer_rule]: \"Mod_Type_Connect.HMA_I k (from_nat k::'nr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I k (from_nat k) &&&\n    Mod_Type_Connect.HMA_I k (from_nat k)", "by (metis Mod_Type_Connect.HMA_I_def k min.strict_boundedE to_nat_from_nat_id)+"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I k (from_nat k)\n  Mod_Type_Connect.HMA_I k (from_nat k)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I i (from_nat i::'nc)\"\n    and [transfer_rule]: \"Mod_Type_Connect.HMA_I i (from_nat i::'nr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I i (from_nat i) &&&\n    Mod_Type_Connect.HMA_I i (from_nat i)", "by (metis Mod_Type_Connect.HMA_I_def i min.strict_boundedE to_nat_from_nat_id)+"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I i (from_nat i)\n  Mod_Type_Connect.HMA_I i (from_nat i)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "have [transfer_rule]: \"A $$ (i,i) = A' $h from_nat i $h from_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "have \"A $$ (i,i) = index_hma A' (from_nat i) (from_nat i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, i) = index_hma A' (from_nat i) (from_nat i)", "by (transfer, simp)"], ["proof (state)\nthis:\n  A $$ (i, i) = index_hma A' (from_nat i) (from_nat i)\n\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "also"], ["proof (state)\nthis:\n  A $$ (i, i) = index_hma A' (from_nat i) (from_nat i)\n\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "have \"... = A' $h from_nat i $h from_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' (from_nat i) (from_nat i) = A' $h from_nat i $h from_nat i", "unfolding index_hma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h from_nat i $h from_nat i = A' $h from_nat i $h from_nat i", "by auto"], ["proof (state)\nthis:\n  index_hma A' (from_nat i) (from_nat i) = A' $h from_nat i $h from_nat i\n\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "finally"], ["proof (chain)\npicking this:\n  A $$ (i, i) = A' $h from_nat i $h from_nat i", "show ?thesis"], ["proof (prove)\nusing this:\n  A $$ (i, i) = A' $h from_nat i $h from_nat i\n\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "."], ["proof (state)\nthis:\n  A $$ (i, i) = A' $h from_nat i $h from_nat i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $$ (i, i) = A' $h from_nat i $h from_nat i\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "have [transfer_rule]: \"A $$ (k,k) = A' $h from_nat k $h from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (k, k) = A' $h from_nat k $h from_nat k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (k, k) = A' $h from_nat k $h from_nat k", "have \"A $$ (k,k) = index_hma A' (from_nat k) (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (k, k) = index_hma A' (from_nat k) (from_nat k)", "by (transfer, simp)"], ["proof (state)\nthis:\n  A $$ (k, k) = index_hma A' (from_nat k) (from_nat k)\n\ngoal (1 subgoal):\n 1. A $$ (k, k) = A' $h from_nat k $h from_nat k", "also"], ["proof (state)\nthis:\n  A $$ (k, k) = index_hma A' (from_nat k) (from_nat k)\n\ngoal (1 subgoal):\n 1. A $$ (k, k) = A' $h from_nat k $h from_nat k", "have \"... = A' $h from_nat k $h from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' (from_nat k) (from_nat k) = A' $h from_nat k $h from_nat k", "unfolding index_hma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h from_nat k $h from_nat k = A' $h from_nat k $h from_nat k", "by auto"], ["proof (state)\nthis:\n  index_hma A' (from_nat k) (from_nat k) = A' $h from_nat k $h from_nat k\n\ngoal (1 subgoal):\n 1. A $$ (k, k) = A' $h from_nat k $h from_nat k", "finally"], ["proof (chain)\npicking this:\n  A $$ (k, k) = A' $h from_nat k $h from_nat k", "show ?thesis"], ["proof (prove)\nusing this:\n  A $$ (k, k) = A' $h from_nat k $h from_nat k\n\ngoal (1 subgoal):\n 1. A $$ (k, k) = A' $h from_nat k $h from_nat k", "."], ["proof (state)\nthis:\n  A $$ (k, k) = A' $h from_nat k $h from_nat k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $$ (k, k) = A' $h from_nat k $h from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "have dim_row_CARD: \"dim_row A = CARD('nr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A = CARD('nr)", "using HMA_M_AA' Mod_Type_Connect.dim_row_transfer_rule"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n\ngoal (1 subgoal):\n 1. dim_row A = CARD('nr)", "by blast"], ["proof (state)\nthis:\n  dim_row A = CARD('nr)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "have dim_col_CARD: \"dim_col A = CARD('nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col A = CARD('nc)", "using HMA_M_AA' Mod_Type_Connect.dim_col_transfer_rule"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n\ngoal (1 subgoal):\n 1. dim_col A = CARD('nc)", "by blast"], ["proof (state)\nthis:\n  dim_col A = CARD('nc)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "let ?p = \"fst (bezout (A' $h from_nat i $h from_nat i) (A' $h from_nat k $h from_nat k))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "let ?v = \"fst (snd (snd (snd (bezout (A $$ (i, i)) (A $$ (k, k))))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "have \"Mod_Type_Connect.HMA_M (fst ?d_JNF) (fst ?d_HA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (fst (diagonal_step_PQ_JNF A i k bezout))\n     (fst (diagonal_step_PQ A' i k bezout))", "unfolding diagonal_step_PQ_JNF_def diagonal_step_PQ_def Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (let m = dim_row A; n = dim_col A;\n             (p, q, u, v, d) = bezout (A $$ (i, i)) (A $$ (k, k));\n             P = addrow (- v) k i\n                  (swaprows i k (addrow p k i (1\\<^sub>m m)))\n         in Let (multcol k (- (1::'a))\n                  (addcol u k i (addcol q i k (1\\<^sub>m n))))\n             (Pair P)) =\n    Mod_Type_Connect.from_hma\\<^sub>m\n     (fst (let i_row = from_nat i; k_row = from_nat k; i_col = from_nat i;\n               k_col = from_nat k;\n               (p, q, u, v, d) =\n                 bezout (A' $h i_row $h from_nat i)\n                  (A' $h k_row $h from_nat k);\n               P = row_add\n                    (interchange_rows (row_add (mat (1::'a)) k_row i_row p)\n                      i_row k_row)\n                    k_row i_row (- v)\n           in Let (mult_column\n                    (column_add (column_add (mat (1::'a)) i_col k_col q)\n                      k_col i_col u)\n                    k_col (- (1::'a)))\n               (Pair P)))", "unfolding Let_def split_beta dim_row_CARD"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (addrow\n          (- fst (snd (snd (snd (bezout (A $$ (i, i)) (A $$ (k, k))))))) k i\n          (swaprows i k\n            (addrow (fst (bezout (A $$ (i, i)) (A $$ (k, k)))) k i\n              (1\\<^sub>m CARD('nr)))),\n         multcol k (- (1::'a))\n          (addcol (fst (snd (snd (bezout (A $$ (i, i)) (A $$ (k, k)))))) k i\n            (addcol (fst (snd (bezout (A $$ (i, i)) (A $$ (k, k))))) i k\n              (1\\<^sub>m (dim_col A))))) =\n    Mod_Type_Connect.from_hma\\<^sub>m\n     (fst (row_add\n            (interchange_rows\n              (row_add (mat (1::'a)) (from_nat k) (from_nat i)\n                (fst (bezout (A' $h from_nat i $h from_nat i)\n                       (A' $h from_nat k $h from_nat k))))\n              (from_nat i) (from_nat k))\n            (from_nat k) (from_nat i)\n            (- fst (snd (snd (snd (bezout (A' $h from_nat i $h from_nat i)\n                                    (A' $h from_nat k $h from_nat k)))))),\n           mult_column\n            (column_add\n              (column_add (mat (1::'a)) (from_nat i) (from_nat k)\n                (fst (snd (bezout (A' $h from_nat i $h from_nat i)\n                            (A' $h from_nat k $h from_nat k)))))\n              (from_nat k) (from_nat i)\n              (fst (snd (snd (bezout (A' $h from_nat i $h from_nat i)\n                               (A' $h from_nat k $h from_nat k))))))\n            (from_nat k) (- (1::'a))))", "by (auto, transfer, auto simp add: Mod_Type_Connect.HMA_M_def Rel_def rel_funI)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (fst (diagonal_step_PQ_JNF A i k bezout))\n   (fst (diagonal_step_PQ A' i k bezout))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "moreover"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (fst (diagonal_step_PQ_JNF A i k bezout))\n   (fst (diagonal_step_PQ A' i k bezout))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "have \"Mod_Type_Connect.HMA_M (snd ?d_JNF) (snd ?d_HA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (snd (diagonal_step_PQ_JNF A i k bezout))\n     (snd (diagonal_step_PQ A' i k bezout))", "unfolding diagonal_step_PQ_JNF_def diagonal_step_PQ_def Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (let m = dim_row A; n = dim_col A;\n             (p, q, u, v, d) = bezout (A $$ (i, i)) (A $$ (k, k));\n             P = addrow (- v) k i\n                  (swaprows i k (addrow p k i (1\\<^sub>m m)))\n         in Let (multcol k (- (1::'a))\n                  (addcol u k i (addcol q i k (1\\<^sub>m n))))\n             (Pair P)) =\n    Mod_Type_Connect.from_hma\\<^sub>m\n     (snd (let i_row = from_nat i; k_row = from_nat k; i_col = from_nat i;\n               k_col = from_nat k;\n               (p, q, u, v, d) =\n                 bezout (A' $h i_row $h from_nat i)\n                  (A' $h k_row $h from_nat k);\n               P = row_add\n                    (interchange_rows (row_add (mat (1::'a)) k_row i_row p)\n                      i_row k_row)\n                    k_row i_row (- v)\n           in Let (mult_column\n                    (column_add (column_add (mat (1::'a)) i_col k_col q)\n                      k_col i_col u)\n                    k_col (- (1::'a)))\n               (Pair P)))", "unfolding Let_def split_beta dim_col_CARD"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (addrow\n          (- fst (snd (snd (snd (bezout (A $$ (i, i)) (A $$ (k, k))))))) k i\n          (swaprows i k\n            (addrow (fst (bezout (A $$ (i, i)) (A $$ (k, k)))) k i\n              (1\\<^sub>m (dim_row A)))),\n         multcol k (- (1::'a))\n          (addcol (fst (snd (snd (bezout (A $$ (i, i)) (A $$ (k, k)))))) k i\n            (addcol (fst (snd (bezout (A $$ (i, i)) (A $$ (k, k))))) i k\n              (1\\<^sub>m CARD('nc))))) =\n    Mod_Type_Connect.from_hma\\<^sub>m\n     (snd (row_add\n            (interchange_rows\n              (row_add (mat (1::'a)) (from_nat k) (from_nat i)\n                (fst (bezout (A' $h from_nat i $h from_nat i)\n                       (A' $h from_nat k $h from_nat k))))\n              (from_nat i) (from_nat k))\n            (from_nat k) (from_nat i)\n            (- fst (snd (snd (snd (bezout (A' $h from_nat i $h from_nat i)\n                                    (A' $h from_nat k $h from_nat k)))))),\n           mult_column\n            (column_add\n              (column_add (mat (1::'a)) (from_nat i) (from_nat k)\n                (fst (snd (bezout (A' $h from_nat i $h from_nat i)\n                            (A' $h from_nat k $h from_nat k)))))\n              (from_nat k) (from_nat i)\n              (fst (snd (snd (bezout (A' $h from_nat i $h from_nat i)\n                               (A' $h from_nat k $h from_nat k))))))\n            (from_nat k) (- (1::'a))))", "by (auto, transfer, auto simp add: Mod_Type_Connect.HMA_M_def Rel_def rel_funI)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (snd (diagonal_step_PQ_JNF A i k bezout))\n   (snd (diagonal_step_PQ A' i k bezout))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_M x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod Mod_Type_Connect.HMA_M\n                          Mod_Type_Connect.HMA_M\n                          (diagonal_step_PQ_JNF x i k xa)\n                          (diagonal_step_PQ y i k ya)", "ultimately"], ["proof (chain)\npicking this:\n  Mod_Type_Connect.HMA_M (fst (diagonal_step_PQ_JNF A i k bezout))\n   (fst (diagonal_step_PQ A' i k bezout))\n  Mod_Type_Connect.HMA_M (snd (diagonal_step_PQ_JNF A i k bezout))\n   (snd (diagonal_step_PQ A' i k bezout))", "show ?case"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M (fst (diagonal_step_PQ_JNF A i k bezout))\n   (fst (diagonal_step_PQ A' i k bezout))\n  Mod_Type_Connect.HMA_M (snd (diagonal_step_PQ_JNF A i k bezout))\n   (snd (diagonal_step_PQ A' i k bezout))\n\ngoal (1 subgoal):\n 1. rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M\n     (diagonal_step_PQ_JNF A i k bezout) (diagonal_step_PQ A' i k bezout')", "unfolding rel_prod_conv"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M (fst (diagonal_step_PQ_JNF A i k bezout))\n   (fst (diagonal_step_PQ A' i k bezout))\n  Mod_Type_Connect.HMA_M (snd (diagonal_step_PQ_JNF A i k bezout))\n   (snd (diagonal_step_PQ A' i k bezout))\n\ngoal (1 subgoal):\n 1. (case diagonal_step_PQ_JNF A i k bezout of\n     (a, b) \\<Rightarrow>\n       \\<lambda>(c, d).\n          Mod_Type_Connect.HMA_M a c \\<and> Mod_Type_Connect.HMA_M b d)\n     (diagonal_step_PQ A' i k bezout')", "using 1"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M (fst (diagonal_step_PQ_JNF A i k bezout))\n   (fst (diagonal_step_PQ A' i k bezout))\n  Mod_Type_Connect.HMA_M (snd (diagonal_step_PQ_JNF A i k bezout))\n   (snd (diagonal_step_PQ A' i k bezout))\n  Mod_Type_Connect.HMA_M A A'\n  bezout = bezout'\n\ngoal (1 subgoal):\n 1. (case diagonal_step_PQ_JNF A i k bezout of\n     (a, b) \\<Rightarrow>\n       \\<lambda>(c, d).\n          Mod_Type_Connect.HMA_M a c \\<and> Mod_Type_Connect.HMA_M b d)\n     (diagonal_step_PQ A' i k bezout')", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M\n   (diagonal_step_PQ_JNF A i k bezout) (diagonal_step_PQ A' i k bezout')\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun diagonal_to_Smith_i_PQ_JNF :: \n  \"nat list \\<Rightarrow> nat \\<Rightarrow> ('a::{bezout_ring} bezout) \n  \\<Rightarrow> ('a mat \\<times> 'a mat \\<times> 'a mat) \\<Rightarrow> ('a mat \\<times> 'a mat \\<times> 'a mat)\"\n where\n\"diagonal_to_Smith_i_PQ_JNF [] i bezout (P,A,Q) = (P,A,Q)\" |\n\"diagonal_to_Smith_i_PQ_JNF (j#xs) i bezout (P,A,Q) = (\n  if A $$ (i,i) dvd A $$ (j,j) \n     then diagonal_to_Smith_i_PQ_JNF xs i bezout (P,A,Q)\n  else let (p, q, u, v, d) = bezout (A $$ (i,i)) (A $$ (j,j)); \n           A' = diagonal_step_JNF A i j d v;\n          (P',Q') = diagonal_step_PQ_JNF A i j bezout\n      in diagonal_to_Smith_i_PQ_JNF xs i bezout (P'*P,A',Q*Q') \\<comment> \\<open>Apply the step\\<close>\n  )\n  \""], ["", "context\n  includes lifting_syntax\n  fixes i and xs\n  assumes i: \"i < min (CARD('nr::mod_type)) (CARD('nc::mod_type))\"\n  and xs: \"\\<forall>j\\<in>set xs. j < min (CARD('nr::mod_type)) (CARD('nc::mod_type))\"\nbegin"], ["", "declare diagonal_step_PQ.simps[simp del]"], ["", "lemma HMA_diagonal_to_Smith_i_PQ_aux: \"HMA_M3 (P,A,Q)  \n  (P' :: 'a :: bezout_ring ^ 'nr :: mod_type ^ 'nr :: mod_type,\n   A' :: 'a :: bezout_ring ^ 'nc :: mod_type ^ 'nr :: mod_type,\n   Q' :: 'a :: bezout_ring ^ 'nc :: mod_type ^ 'nc :: mod_type)\n  \\<Longrightarrow> HMA_M3 (diagonal_to_Smith_i_PQ_JNF xs i bezout (P,A,Q)) \n             (diagonal_to_Smith_i_PQ xs i bezout (P',A',Q'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M3 (P, A, Q) (P', A', Q') \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF xs i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ xs i bezout (P', A', Q'))", "using i xs"], ["proof (prove)\nusing this:\n  i < min CARD('nr) CARD('nc)\n  \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. HMA_M3 (P, A, Q) (P', A', Q') \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF xs i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ xs i bezout (P', A', Q'))", "proof (induct xs i bezout \"(P',A',Q')\" arbitrary: P' A' Q' P A Q rule: diagonal_to_Smith_i_PQ.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set []. j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF [] i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ [] i bezout (P, A, Q))\n 2. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "case (1 i bezout P' A' Q')"], ["proof (state)\nthis:\n  HMA_M3 (P, A, Q) (P', A', Q')\n  i < min CARD('nr) CARD('nc)\n  \\<forall>j\\<in>set []. j < min CARD('nr) CARD('nc)\n\ngoal (2 subgoals):\n 1. \\<And>i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set []. j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF [] i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ [] i bezout (P, A, Q))\n 2. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "then"], ["proof (chain)\npicking this:\n  HMA_M3 (P, A, Q) (P', A', Q')\n  i < min CARD('nr) CARD('nc)\n  \\<forall>j\\<in>set []. j < min CARD('nr) CARD('nc)", "show ?case"], ["proof (prove)\nusing this:\n  HMA_M3 (P, A, Q) (P', A', Q')\n  i < min CARD('nr) CARD('nc)\n  \\<forall>j\\<in>set []. j < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_i_PQ_JNF [] i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ [] i bezout (P', A', Q'))", "by auto"], ["proof (state)\nthis:\n  HMA_M3 (diagonal_to_Smith_i_PQ_JNF [] i bezout (P, A, Q))\n   (diagonal_to_Smith_i_PQ [] i bezout (P', A', Q'))\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "case (2 j xs i bezout P' A' Q')"], ["proof (state)\nthis:\n  \\<lbrakk>A' $h from_nat i $h from_nat i dvd\n           A' $h from_nat j $h from_nat j;\n   HMA_M3 (?P, ?A, ?Q) (P', A', Q'); i < min CARD('nr) CARD('nc);\n   \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> HMA_M3\n                     (diagonal_to_Smith_i_PQ_JNF xs i bezout (?P, ?A, ?Q))\n                     (diagonal_to_Smith_i_PQ xs i bezout (P', A', Q'))\n  \\<lbrakk>\\<not> A' $h from_nat i $h from_nat i dvd\n                  A' $h from_nat j $h from_nat j;\n   ?x =\n   bezout (A' $h from_nat i $h from_nat i) (A' $h from_nat j $h from_nat j);\n   (?xa, ?y) = ?x; (?xb, ?ya) = ?y; (?xc, ?yb) = ?ya; (?xd, ?yc) = ?yb;\n   ?xe = diagonal_step A' i j ?yc ?xd; ?xf = diagonal_step_PQ A' i j bezout;\n   (?xg, ?yd) = ?xf; HMA_M3 (?P, ?A, ?Q) (?xg ** P', ?xe, Q' ** ?yd);\n   i < min CARD('nr) CARD('nc);\n   \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> HMA_M3\n                     (diagonal_to_Smith_i_PQ_JNF xs i bezout (?P, ?A, ?Q))\n                     (diagonal_to_Smith_i_PQ xs i bezout\n                       (?xg ** P', ?xe, Q' ** ?yd))\n  HMA_M3 (P, A, Q) (P', A', Q')\n  i < min CARD('nr) CARD('nc)\n  \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "note HMA_M3[transfer_rule] = \"2.prems\"(1)"], ["proof (state)\nthis:\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "note i = 2(4)"], ["proof (state)\nthis:\n  i < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "note j = 2(5)"], ["proof (state)\nthis:\n  \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "note IH1=\"2.hyps\"(1)"], ["proof (state)\nthis:\n  \\<lbrakk>A' $h from_nat i $h from_nat i dvd\n           A' $h from_nat j $h from_nat j;\n   HMA_M3 (?P, ?A, ?Q) (P', A', Q'); i < min CARD('nr) CARD('nc);\n   \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> HMA_M3\n                     (diagonal_to_Smith_i_PQ_JNF xs i bezout (?P, ?A, ?Q))\n                     (diagonal_to_Smith_i_PQ xs i bezout (P', A', Q'))\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "note IH2=\"2.hyps\"(2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> A' $h from_nat i $h from_nat i dvd\n                  A' $h from_nat j $h from_nat j;\n   ?x =\n   bezout (A' $h from_nat i $h from_nat i) (A' $h from_nat j $h from_nat j);\n   (?xa, ?y) = ?x; (?xb, ?ya) = ?y; (?xc, ?yb) = ?ya; (?xd, ?yc) = ?yb;\n   ?xe = diagonal_step A' i j ?yc ?xd; ?xf = diagonal_step_PQ A' i j bezout;\n   (?xg, ?yd) = ?xf; HMA_M3 (?P, ?A, ?Q) (?xg ** P', ?xe, Q' ** ?yd);\n   i < min CARD('nr) CARD('nc);\n   \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> HMA_M3\n                     (diagonal_to_Smith_i_PQ_JNF xs i bezout (?P, ?A, ?Q))\n                     (diagonal_to_Smith_i_PQ xs i bezout\n                       (?xg ** P', ?xe, Q' ** ?yd))\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "have j_min: \"j < min CARD('nr) CARD('nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < min CARD('nr) CARD('nc)", "using j"], ["proof (prove)\nusing this:\n  \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. j < min CARD('nr) CARD('nc)", "by auto"], ["proof (state)\nthis:\n  j < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "have HMA_M_AA'[transfer_rule]: \"Mod_Type_Connect.HMA_M A A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A A'", "using HMA_M3"], ["proof (prove)\nusing this:\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A A'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I j (from_nat j::'nc)\"  \n    and [transfer_rule]: \"Mod_Type_Connect.HMA_I j (from_nat j::'nr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I j (from_nat j) &&&\n    Mod_Type_Connect.HMA_I j (from_nat j)", "by (metis Mod_Type_Connect.HMA_I_def j_min min.strict_boundedE to_nat_from_nat_id)+"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I j (from_nat j)\n  Mod_Type_Connect.HMA_I j (from_nat j)\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I i (from_nat i::'nc)\"\n    and [transfer_rule]: \"Mod_Type_Connect.HMA_I i (from_nat i::'nr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I i (from_nat i) &&&\n    Mod_Type_Connect.HMA_I i (from_nat i)", "by (metis Mod_Type_Connect.HMA_I_def i min.strict_boundedE to_nat_from_nat_id)+"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I i (from_nat i)\n  Mod_Type_Connect.HMA_I i (from_nat i)\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "have [transfer_rule]: \"A $$ (i, i) = A' $h from_nat i $h from_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "have \"A $$ (i,i) = index_hma A' (from_nat i) (from_nat i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, i) = index_hma A' (from_nat i) (from_nat i)", "by (transfer, simp)"], ["proof (state)\nthis:\n  A $$ (i, i) = index_hma A' (from_nat i) (from_nat i)\n\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "also"], ["proof (state)\nthis:\n  A $$ (i, i) = index_hma A' (from_nat i) (from_nat i)\n\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "have \"... = A' $h from_nat i $h from_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' (from_nat i) (from_nat i) = A' $h from_nat i $h from_nat i", "unfolding index_hma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h from_nat i $h from_nat i = A' $h from_nat i $h from_nat i", "by auto"], ["proof (state)\nthis:\n  index_hma A' (from_nat i) (from_nat i) = A' $h from_nat i $h from_nat i\n\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "finally"], ["proof (chain)\npicking this:\n  A $$ (i, i) = A' $h from_nat i $h from_nat i", "show ?thesis"], ["proof (prove)\nusing this:\n  A $$ (i, i) = A' $h from_nat i $h from_nat i\n\ngoal (1 subgoal):\n 1. A $$ (i, i) = A' $h from_nat i $h from_nat i", "."], ["proof (state)\nthis:\n  A $$ (i, i) = A' $h from_nat i $h from_nat i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $$ (i, i) = A' $h from_nat i $h from_nat i\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "have [transfer_rule]: \"A $$ (j, j) = A' $h from_nat j $h from_nat j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (j, j) = A' $h from_nat j $h from_nat j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (j, j) = A' $h from_nat j $h from_nat j", "have \"A $$ (j,j) = index_hma A' (from_nat j) (from_nat j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (j, j) = index_hma A' (from_nat j) (from_nat j)", "by (transfer, simp)"], ["proof (state)\nthis:\n  A $$ (j, j) = index_hma A' (from_nat j) (from_nat j)\n\ngoal (1 subgoal):\n 1. A $$ (j, j) = A' $h from_nat j $h from_nat j", "also"], ["proof (state)\nthis:\n  A $$ (j, j) = index_hma A' (from_nat j) (from_nat j)\n\ngoal (1 subgoal):\n 1. A $$ (j, j) = A' $h from_nat j $h from_nat j", "have \"... = A' $h from_nat j $h from_nat j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' (from_nat j) (from_nat j) = A' $h from_nat j $h from_nat j", "unfolding index_hma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h from_nat j $h from_nat j = A' $h from_nat j $h from_nat j", "by auto"], ["proof (state)\nthis:\n  index_hma A' (from_nat j) (from_nat j) = A' $h from_nat j $h from_nat j\n\ngoal (1 subgoal):\n 1. A $$ (j, j) = A' $h from_nat j $h from_nat j", "finally"], ["proof (chain)\npicking this:\n  A $$ (j, j) = A' $h from_nat j $h from_nat j", "show ?thesis"], ["proof (prove)\nusing this:\n  A $$ (j, j) = A' $h from_nat j $h from_nat j\n\ngoal (1 subgoal):\n 1. A $$ (j, j) = A' $h from_nat j $h from_nat j", "."], ["proof (state)\nthis:\n  A $$ (j, j) = A' $h from_nat j $h from_nat j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $$ (j, j) = A' $h from_nat j $h from_nat j\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $h from_nat i $h from_nat i dvd\n                            A $h from_nat j $h from_nat j;\n                    HMA_M3 (Pa, Aa, Qa) (P, A, Q);\n                    i < min CARD('nr) CARD('nc);\n                    \\<forall>j\\<in>set xs.\n                       j < min CARD('nr) CARD('nc)\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_i_PQ_JNF xs i bezout (Pa, Aa, Qa))\n(diagonal_to_Smith_i_PQ xs i bezout (P, A, Q));\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $h from_nat i $h from_nat i dvd\n                           A $h from_nat j $h from_nat j;\n            x =\n            bezout (A $h from_nat i $h from_nat i)\n             (A $h from_nat j $h from_nat j);\n            (xa, y) = x; (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step A i j yc xd;\n            xf = diagonal_step_PQ A i j bezout; (xg, yd) = xf;\n            HMA_M3 (Pa, Aa, Qa) (xg ** P, xe, Q ** yd);\n            i < min CARD('nr) CARD('nc);\n            \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n           \\<Longrightarrow> HMA_M3\n                              (diagonal_to_Smith_i_PQ_JNF xs i bezout\n                                (Pa, Aa, Qa))\n                              (diagonal_to_Smith_i_PQ xs i bezout\n                                (xg ** P, xe, Q ** yd));\n        HMA_M3 (Pa, Aa, Qa) (P, A, Q); i < min CARD('nr) CARD('nc);\n        \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout\n                            (Pa, Aa, Qa))\n                          (diagonal_to_Smith_i_PQ (j # xs) i bezout\n                            (P, A, Q))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "proof (cases \"A $$ (i, i) dvd A $$ (j, j)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))\n 2. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "case True"], ["proof (state)\nthis:\n  A $$ (i, i) dvd A $$ (j, j)\n\ngoal (2 subgoals):\n 1. A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))\n 2. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "hence \"A' $h from_nat i $h from_nat i dvd A' $h from_nat j $h from_nat j\""], ["proof (prove)\nusing this:\n  A $$ (i, i) dvd A $$ (j, j)\n\ngoal (1 subgoal):\n 1. A' $h from_nat i $h from_nat i dvd A' $h from_nat j $h from_nat j", "by transfer"], ["proof (state)\nthis:\n  A' $h from_nat i $h from_nat i dvd A' $h from_nat j $h from_nat j\n\ngoal (2 subgoals):\n 1. A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))\n 2. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "then"], ["proof (chain)\npicking this:\n  A' $h from_nat i $h from_nat i dvd A' $h from_nat j $h from_nat j", "show ?thesis"], ["proof (prove)\nusing this:\n  A' $h from_nat i $h from_nat i dvd A' $h from_nat j $h from_nat j\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "using True IH1 HMA_M3 i j"], ["proof (prove)\nusing this:\n  A' $h from_nat i $h from_nat i dvd A' $h from_nat j $h from_nat j\n  A $$ (i, i) dvd A $$ (j, j)\n  \\<lbrakk>A' $h from_nat i $h from_nat i dvd\n           A' $h from_nat j $h from_nat j;\n   HMA_M3 (?P, ?A, ?Q) (P', A', Q'); i < min CARD('nr) CARD('nc);\n   \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> HMA_M3\n                     (diagonal_to_Smith_i_PQ_JNF xs i bezout (?P, ?A, ?Q))\n                     (diagonal_to_Smith_i_PQ xs i bezout (P', A', Q'))\n  HMA_M3 (P, A, Q) (P', A', Q')\n  i < min CARD('nr) CARD('nc)\n  \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "by auto"], ["proof (state)\nthis:\n  HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n   (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))\n\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "case False"], ["proof (state)\nthis:\n  \\<not> A $$ (i, i) dvd A $$ (j, j)\n\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "obtain p q u v d where b: \"(p, q, u, v, d) = bezout (A $$ (i,i)) (A $$ (j,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q u v d.\n        (p, q, u, v, d) =\n        bezout (A $$ (i, i)) (A $$ (j, j)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases5)"], ["proof (state)\nthis:\n  (p, q, u, v, d) = bezout (A $$ (i, i)) (A $$ (j, j))\n\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "let ?A'_JNF = \"diagonal_step_JNF A i j d v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "obtain P''_JNF Q''_JNF where P''Q''_JNF: \"(P''_JNF,Q''_JNF) = diagonal_step_PQ_JNF A i j bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P''_JNF Q''_JNF.\n        (P''_JNF, Q''_JNF) =\n        diagonal_step_PQ_JNF A i j bezout \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surjective_pairing)"], ["proof (state)\nthis:\n  (P''_JNF, Q''_JNF) = diagonal_step_PQ_JNF A i j bezout\n\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "have not_dvd: \"\\<not> A' $h from_nat i $h from_nat i dvd A' $h from_nat j $h from_nat j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> A' $h from_nat i $h from_nat i dvd A' $h from_nat j $h from_nat j", "using False"], ["proof (prove)\nusing this:\n  \\<not> A $$ (i, i) dvd A $$ (j, j)\n\ngoal (1 subgoal):\n 1. \\<not> A' $h from_nat i $h from_nat i dvd A' $h from_nat j $h from_nat j", "by transfer"], ["proof (state)\nthis:\n  \\<not> A' $h from_nat i $h from_nat i dvd A' $h from_nat j $h from_nat j\n\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "let ?A' = \"diagonal_step A' i j d v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "obtain P'' Q'' where P''Q'': \"(P'',Q'') = diagonal_step_PQ A' i j bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P'' Q''.\n        (P'', Q'') = diagonal_step_PQ A' i j bezout \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surjective_pairing)"], ["proof (state)\nthis:\n  (P'', Q'') = diagonal_step_PQ A' i j bezout\n\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "have b2: \"(p, q, u, v, d) = bezout (A' $h from_nat i $h from_nat i) (A' $h from_nat j $h from_nat j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p, q, u, v, d) =\n    bezout (A' $h from_nat i $h from_nat i) (A' $h from_nat j $h from_nat j)", "using b"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = bezout (A $$ (i, i)) (A $$ (j, j))\n\ngoal (1 subgoal):\n 1. (p, q, u, v, d) =\n    bezout (A' $h from_nat i $h from_nat i) (A' $h from_nat j $h from_nat j)", "by (transfer,auto)"], ["proof (state)\nthis:\n  (p, q, u, v, d) =\n  bezout (A' $h from_nat i $h from_nat i) (A' $h from_nat j $h from_nat j)\n\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "let ?D_HA = \"diagonal_to_Smith_i_PQ xs i bezout (P''**P',?A',Q'**Q'')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "let ?D_JNF = \"diagonal_to_Smith_i_PQ_JNF xs i bezout (P''_JNF*P,?A'_JNF,Q*Q''_JNF)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "have rw_1: \"diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q) = ?D_JNF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q) =\n    diagonal_to_Smith_i_PQ_JNF xs i bezout\n     (P''_JNF * P, diagonal_step_JNF A i j d v, Q * Q''_JNF)", "using False b P''Q''_JNF"], ["proof (prove)\nusing this:\n  \\<not> A $$ (i, i) dvd A $$ (j, j)\n  (p, q, u, v, d) = bezout (A $$ (i, i)) (A $$ (j, j))\n  (P''_JNF, Q''_JNF) = diagonal_step_PQ_JNF A i j bezout\n\ngoal (1 subgoal):\n 1. diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q) =\n    diagonal_to_Smith_i_PQ_JNF xs i bezout\n     (P''_JNF * P, diagonal_step_JNF A i j d v, Q * Q''_JNF)", "by (auto, unfold split_beta, metis fst_conv snd_conv)"], ["proof (state)\nthis:\n  diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q) =\n  diagonal_to_Smith_i_PQ_JNF xs i bezout\n   (P''_JNF * P, diagonal_step_JNF A i j d v, Q * Q''_JNF)\n\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "have rw_2: \"diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q') = ?D_HA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q') =\n    diagonal_to_Smith_i_PQ xs i bezout\n     (P'' ** P', diagonal_step A' i j d v, Q' ** Q'')", "using not_dvd b2 P''Q''"], ["proof (prove)\nusing this:\n  \\<not> A' $h from_nat i $h from_nat i dvd A' $h from_nat j $h from_nat j\n  (p, q, u, v, d) =\n  bezout (A' $h from_nat i $h from_nat i) (A' $h from_nat j $h from_nat j)\n  (P'', Q'') = diagonal_step_PQ A' i j bezout\n\ngoal (1 subgoal):\n 1. diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q') =\n    diagonal_to_Smith_i_PQ xs i bezout\n     (P'' ** P', diagonal_step A' i j d v, Q' ** Q'')", "by (auto, unfold split_beta, metis fst_conv snd_conv)"], ["proof (state)\nthis:\n  diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q') =\n  diagonal_to_Smith_i_PQ xs i bezout\n   (P'' ** P', diagonal_step A' i j d v, Q' ** Q'')\n\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "have \"HMA_M3 ?D_JNF ?D_HA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M3\n     (diagonal_to_Smith_i_PQ_JNF xs i bezout\n       (P''_JNF * P, diagonal_step_JNF A i j d v, Q * Q''_JNF))\n     (diagonal_to_Smith_i_PQ xs i bezout\n       (P'' ** P', diagonal_step A' i j d v, Q' ** Q''))", "proof (rule IH2[OF not_dvd b2], auto)"], ["proof (state)\ngoal (8 subgoals):\n 1. (P'', Q'') = diagonal_step_PQ A' i j bezout\n 2. Mod_Type_Connect.HMA_M (P''_JNF * P) (P'' ** P')\n 3. Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v)\n     (diagonal_step A' i j d v)\n 4. Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')\n 5. i < CARD('nr)\n 6. i < CARD('nc)\n 7. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nr)\n 8. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nc)", "have j: \"j < min CARD('nr) CARD('nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < min CARD('nr) CARD('nc)", "using j"], ["proof (prove)\nusing this:\n  \\<forall>j\\<in>set (j # xs). j < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. j < min CARD('nr) CARD('nc)", "by auto"], ["proof (state)\nthis:\n  j < min CARD('nr) CARD('nc)\n\ngoal (8 subgoals):\n 1. (P'', Q'') = diagonal_step_PQ A' i j bezout\n 2. Mod_Type_Connect.HMA_M (P''_JNF * P) (P'' ** P')\n 3. Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v)\n     (diagonal_step A' i j d v)\n 4. Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')\n 5. i < CARD('nr)\n 6. i < CARD('nc)\n 7. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nr)\n 8. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nc)", "have [transfer_rule]: \"rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M \n       (diagonal_step_PQ_JNF A i j bezout) (diagonal_step_PQ A' i j bezout)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M\n     (diagonal_step_PQ_JNF A i j bezout) (diagonal_step_PQ A' i j bezout)", "using HMA_diagonal_step_PQ[OF i j] HMA_M_AA'"], ["proof (prove)\nusing this:\n  (Mod_Type_Connect.HMA_M ===>\n   (=) ===> rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M)\n   (\\<lambda>A. diagonal_step_PQ_JNF A i j)\n   (\\<lambda>A. diagonal_step_PQ A i j)\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M\n     (diagonal_step_PQ_JNF A i j bezout) (diagonal_step_PQ A' i j bezout)", "unfolding rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     Mod_Type_Connect.HMA_M x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         xa = ya \\<longrightarrow>\n         rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M\n          (diagonal_step_PQ_JNF x i j xa) (diagonal_step_PQ y i j ya))\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M\n     (diagonal_step_PQ_JNF A i j bezout) (diagonal_step_PQ A' i j bezout)", "by auto"], ["proof (state)\nthis:\n  rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M\n   (diagonal_step_PQ_JNF A i j bezout) (diagonal_step_PQ A' i j bezout)\n\ngoal (8 subgoals):\n 1. (P'', Q'') = diagonal_step_PQ A' i j bezout\n 2. Mod_Type_Connect.HMA_M (P''_JNF * P) (P'' ** P')\n 3. Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v)\n     (diagonal_step A' i j d v)\n 4. Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')\n 5. i < CARD('nr)\n 6. i < CARD('nc)\n 7. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nr)\n 8. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nc)", "hence [transfer_rule]: \"Mod_Type_Connect.HMA_M P''_JNF P''\" \n        and [transfer_rule]: \"Mod_Type_Connect.HMA_M Q''_JNF Q''\""], ["proof (prove)\nusing this:\n  rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M\n   (diagonal_step_PQ_JNF A i j bezout) (diagonal_step_PQ A' i j bezout)\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M P''_JNF P'' &&&\n    Mod_Type_Connect.HMA_M Q''_JNF Q''", "using P''Q'' P''Q''_JNF"], ["proof (prove)\nusing this:\n  rel_prod Mod_Type_Connect.HMA_M Mod_Type_Connect.HMA_M\n   (diagonal_step_PQ_JNF A i j bezout) (diagonal_step_PQ A' i j bezout)\n  (P'', Q'') = diagonal_step_PQ A' i j bezout\n  (P''_JNF, Q''_JNF) = diagonal_step_PQ_JNF A i j bezout\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M P''_JNF P'' &&&\n    Mod_Type_Connect.HMA_M Q''_JNF Q''", "unfolding rel_prod_conv split_beta"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M (fst (diagonal_step_PQ_JNF A i j bezout))\n   (fst (diagonal_step_PQ A' i j bezout)) \\<and>\n  Mod_Type_Connect.HMA_M (snd (diagonal_step_PQ_JNF A i j bezout))\n   (snd (diagonal_step_PQ A' i j bezout))\n  (P'', Q'') = diagonal_step_PQ A' i j bezout\n  (P''_JNF, Q''_JNF) = diagonal_step_PQ_JNF A i j bezout\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M P''_JNF P'' &&&\n    Mod_Type_Connect.HMA_M Q''_JNF Q''", "by (metis fst_conv, metis snd_conv)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M P''_JNF P''\n  Mod_Type_Connect.HMA_M Q''_JNF Q''\n\ngoal (8 subgoals):\n 1. (P'', Q'') = diagonal_step_PQ A' i j bezout\n 2. Mod_Type_Connect.HMA_M (P''_JNF * P) (P'' ** P')\n 3. Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v)\n     (diagonal_step A' i j d v)\n 4. Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')\n 5. i < CARD('nr)\n 6. i < CARD('nc)\n 7. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nr)\n 8. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nc)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M P P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M P P'", "using HMA_M3"], ["proof (prove)\nusing this:\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M P P'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M P P'\n\ngoal (8 subgoals):\n 1. (P'', Q'') = diagonal_step_PQ A' i j bezout\n 2. Mod_Type_Connect.HMA_M (P''_JNF * P) (P'' ** P')\n 3. Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v)\n     (diagonal_step A' i j d v)\n 4. Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')\n 5. i < CARD('nr)\n 6. i < CARD('nc)\n 7. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nr)\n 8. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nc)", "show \"Mod_Type_Connect.HMA_M (P''_JNF * P) (P'' ** P')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (P''_JNF * P) (P'' ** P')", "(* apply (transfer, auto) does not finish the goal*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (P''_JNF * P) (P'' ** P')", "by (transfer_prover_start, transfer_step+, auto)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (P''_JNF * P) (P'' ** P')\n\ngoal (7 subgoals):\n 1. (P'', Q'') = diagonal_step_PQ A' i j bezout\n 2. Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v)\n     (diagonal_step A' i j d v)\n 3. Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')\n 4. i < CARD('nr)\n 5. i < CARD('nc)\n 6. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nr)\n 7. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nc)", "(* note HMA_diagonal_step[OF i j,transfer_rule]*)            \n     (*transfer does not work for the following goal*)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (P''_JNF * P) (P'' ** P')\n\ngoal (7 subgoals):\n 1. (P'', Q'') = diagonal_step_PQ A' i j bezout\n 2. Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v)\n     (diagonal_step A' i j d v)\n 3. Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')\n 4. i < CARD('nr)\n 5. i < CARD('nc)\n 6. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nr)\n 7. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nc)", "show \"Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v) (diagonal_step A' i j d v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v)\n     (diagonal_step A' i j d v)", "using HMA_diagonal_step[OF i j] HMA_M_AA'"], ["proof (prove)\nusing this:\n  (Mod_Type_Connect.HMA_M ===> (=) ===> (=) ===> Mod_Type_Connect.HMA_M)\n   (\\<lambda>A. diagonal_step_JNF A i j) (\\<lambda>B. diagonal_step B i j)\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v)\n     (diagonal_step A' i j d v)", "unfolding rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     Mod_Type_Connect.HMA_M x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         xa = ya \\<longrightarrow>\n         (\\<forall>xb yb.\n             xb = yb \\<longrightarrow>\n             Mod_Type_Connect.HMA_M (diagonal_step_JNF x i j xa xb)\n              (diagonal_step y i j ya yb)))\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v)\n     (diagonal_step A' i j d v)", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (diagonal_step_JNF A i j d v)\n   (diagonal_step A' i j d v)\n\ngoal (6 subgoals):\n 1. (P'', Q'') = diagonal_step_PQ A' i j bezout\n 2. Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')\n 3. i < CARD('nr)\n 4. i < CARD('nc)\n 5. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nr)\n 6. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nc)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M Q Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M Q Q'", "using HMA_M3"], ["proof (prove)\nusing this:\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M Q Q'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M Q Q'\n\ngoal (6 subgoals):\n 1. (P'', Q'') = diagonal_step_PQ A' i j bezout\n 2. Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')\n 3. i < CARD('nr)\n 4. i < CARD('nc)\n 5. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nr)\n 6. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nc)", "show \"Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')", "by (transfer_prover_start, transfer_step+, auto)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (Q * Q''_JNF) (Q' ** Q'')\n\ngoal (5 subgoals):\n 1. (P'', Q'') = diagonal_step_PQ A' i j bezout\n 2. i < CARD('nr)\n 3. i < CARD('nc)\n 4. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nr)\n 5. \\<And>j. j \\<in> set xs \\<Longrightarrow> j < CARD('nc)", "qed (insert i j P''Q'', auto)"], ["proof (state)\nthis:\n  HMA_M3\n   (diagonal_to_Smith_i_PQ_JNF xs i bezout\n     (P''_JNF * P, diagonal_step_JNF A i j d v, Q * Q''_JNF))\n   (diagonal_to_Smith_i_PQ xs i bezout\n     (P'' ** P', diagonal_step A' i j d v, Q' ** Q''))\n\ngoal (1 subgoal):\n 1. \\<not> A $$ (i, i) dvd A $$ (j, j) \\<Longrightarrow>\n    HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "then"], ["proof (chain)\npicking this:\n  HMA_M3\n   (diagonal_to_Smith_i_PQ_JNF xs i bezout\n     (P''_JNF * P, diagonal_step_JNF A i j d v, Q * Q''_JNF))\n   (diagonal_to_Smith_i_PQ xs i bezout\n     (P'' ** P', diagonal_step A' i j d v, Q' ** Q''))", "show ?thesis"], ["proof (prove)\nusing this:\n  HMA_M3\n   (diagonal_to_Smith_i_PQ_JNF xs i bezout\n     (P''_JNF * P, diagonal_step_JNF A i j d v, Q * Q''_JNF))\n   (diagonal_to_Smith_i_PQ xs i bezout\n     (P'' ** P', diagonal_step A' i j d v, Q' ** Q''))\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "using rw_1 rw_2"], ["proof (prove)\nusing this:\n  HMA_M3\n   (diagonal_to_Smith_i_PQ_JNF xs i bezout\n     (P''_JNF * P, diagonal_step_JNF A i j d v, Q * Q''_JNF))\n   (diagonal_to_Smith_i_PQ xs i bezout\n     (P'' ** P', diagonal_step A' i j d v, Q' ** Q''))\n  diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q) =\n  diagonal_to_Smith_i_PQ_JNF xs i bezout\n   (P''_JNF * P, diagonal_step_JNF A i j d v, Q * Q''_JNF)\n  diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q') =\n  diagonal_to_Smith_i_PQ xs i bezout\n   (P'' ** P', diagonal_step A' i j d v, Q' ** Q'')\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))", "by auto"], ["proof (state)\nthis:\n  HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n   (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  HMA_M3 (diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q))\n   (diagonal_to_Smith_i_PQ (j # xs) i bezout (P', A', Q'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_diagonal_to_Smith_i_PQ[transfer_rule]: \n  \"((=) \n  ===> (HMA_M3 :: (_ \\<Rightarrow> (_\\<times>('a :: bezout_ring ^ 'nc :: mod_type ^ 'nr :: mod_type) \\<times> _) \\<Rightarrow>_)) \n  ===> HMA_M3) (diagonal_to_Smith_i_PQ_JNF xs i) (diagonal_to_Smith_i_PQ xs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> HMA_M3 ===> HMA_M3) (diagonal_to_Smith_i_PQ_JNF xs i)\n     (diagonal_to_Smith_i_PQ xs i)", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; HMA_M3 xa ya\\<rbrakk>\n       \\<Longrightarrow> HMA_M3 (diagonal_to_Smith_i_PQ_JNF xs i x xa)\n                          (diagonal_to_Smith_i_PQ xs i y ya)", "case (1 x y bezout bezout')"], ["proof (state)\nthis:\n  x = y\n  HMA_M3 bezout bezout'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; HMA_M3 xa ya\\<rbrakk>\n       \\<Longrightarrow> HMA_M3 (diagonal_to_Smith_i_PQ_JNF xs i x xa)\n                          (diagonal_to_Smith_i_PQ xs i y ya)", "then"], ["proof (chain)\npicking this:\n  x = y\n  HMA_M3 bezout bezout'", "show ?case"], ["proof (prove)\nusing this:\n  x = y\n  HMA_M3 bezout bezout'\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_i_PQ_JNF xs i x bezout)\n     (diagonal_to_Smith_i_PQ xs i y bezout')", "using HMA_diagonal_to_Smith_i_PQ_aux"], ["proof (prove)\nusing this:\n  x = y\n  HMA_M3 bezout bezout'\n  HMA_M3 (?P, ?A, ?Q) (?P', ?A', ?Q') \\<Longrightarrow>\n  HMA_M3 (diagonal_to_Smith_i_PQ_JNF xs i ?bezout (?P, ?A, ?Q))\n   (diagonal_to_Smith_i_PQ xs i ?bezout (?P', ?A', ?Q'))\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_i_PQ_JNF xs i x bezout)\n     (diagonal_to_Smith_i_PQ xs i y bezout')", "by (auto, smt HMA_M3.elims(2))"], ["proof (state)\nthis:\n  HMA_M3 (diagonal_to_Smith_i_PQ_JNF xs i x bezout)\n   (diagonal_to_Smith_i_PQ xs i y bezout')\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun Diagonal_to_Smith_row_i_PQ_JNF\n  where \"Diagonal_to_Smith_row_i_PQ_JNF i bezout (P,A,Q) \n  = diagonal_to_Smith_i_PQ_JNF [i + 1..<min (dim_row A) (dim_col A)] i bezout (P,A,Q)\""], ["", "declare Diagonal_to_Smith_row_i_PQ_JNF.simps[simp del]"], ["", "lemmas Diagonal_to_Smith_row_i_PQ_JNF_def = Diagonal_to_Smith_row_i_PQ_JNF.simps"], ["", "context \n  includes lifting_syntax\n  fixes i\n  assumes i: \"i < min (CARD('nr::mod_type)) (CARD('nc::mod_type))\"\nbegin"], ["", "lemma HMA_Diagonal_to_Smith_row_i_PQ[transfer_rule]:\n  \"((=) ===> (HMA_M3 :: (_ \\<Rightarrow> (_ \\<times> ('a::bezout_ring^'nc::mod_type^'nr::mod_type) \\<times> _) \\<Rightarrow> _)) ===> HMA_M3) \n  (Diagonal_to_Smith_row_i_PQ_JNF i) (Diagonal_to_Smith_row_i_PQ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> HMA_M3 ===> HMA_M3) (Diagonal_to_Smith_row_i_PQ_JNF i)\n     (Diagonal_to_Smith_row_i_PQ i)", "proof (intro rel_funI, clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y a aa b ab ac ba.\n       HMA_M3 (a, aa, b) (ab, ac, ba) \\<Longrightarrow>\n       HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i y (a, aa, b))\n        (Diagonal_to_Smith_row_i_PQ i y (ab, ac, ba))", "case (1 _ bezout P A Q P' A' Q')"], ["proof (state)\nthis:\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. \\<And>x y a aa b ab ac ba.\n       HMA_M3 (a, aa, b) (ab, ac, ba) \\<Longrightarrow>\n       HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i y (a, aa, b))\n        (Diagonal_to_Smith_row_i_PQ i y (ab, ac, ba))", "note HMA_M3[transfer_rule] = 1"], ["proof (state)\nthis:\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. \\<And>x y a aa b ab ac ba.\n       HMA_M3 (a, aa, b) (ab, ac, ba) \\<Longrightarrow>\n       HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i y (a, aa, b))\n        (Diagonal_to_Smith_row_i_PQ i y (ab, ac, ba))", "let ?xs1=\"[i + 1..<min (dim_row A) (dim_col A)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y a aa b ab ac ba.\n       HMA_M3 (a, aa, b) (ab, ac, ba) \\<Longrightarrow>\n       HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i y (a, aa, b))\n        (Diagonal_to_Smith_row_i_PQ i y (ab, ac, ba))", "let ?xs2=\"[i + 1..<min (nrows A') (ncols A')]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y a aa b ab ac ba.\n       HMA_M3 (a, aa, b) (ab, ac, ba) \\<Longrightarrow>\n       HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i y (a, aa, b))\n        (Diagonal_to_Smith_row_i_PQ i y (ab, ac, ba))", "have xs_eq[transfer_rule]: \"?xs1 = ?xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i + 1..<min (dim_row A) (dim_col A)] =\n    [i + 1..<min (nrows A') (ncols A')]", "using HMA_M3"], ["proof (prove)\nusing this:\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. [i + 1..<min (dim_row A) (dim_col A)] =\n    [i + 1..<min (nrows A') (ncols A')]", "by (auto intro: arg_cong2[where f = upt]\n        simp: Mod_Type_Connect.dim_col_transfer_rule Mod_Type_Connect.dim_row_transfer_rule\n        nrows_def ncols_def)"], ["proof (state)\nthis:\n  [i + 1..<min (dim_row A) (dim_col A)] =\n  [i + 1..<min (nrows A') (ncols A')]\n\ngoal (1 subgoal):\n 1. \\<And>x y a aa b ab ac ba.\n       HMA_M3 (a, aa, b) (ab, ac, ba) \\<Longrightarrow>\n       HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i y (a, aa, b))\n        (Diagonal_to_Smith_row_i_PQ i y (ab, ac, ba))", "have j_xs: \"\\<forall>j\\<in>set ?xs1. j < min CARD('nr) CARD('nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>set [i + 1..<min (dim_row A) (dim_col A)].\n       j < min CARD('nr) CARD('nc)", "using i"], ["proof (prove)\nusing this:\n  i < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>set [i + 1..<min (dim_row A) (dim_col A)].\n       j < min CARD('nr) CARD('nc)", "by (metis atLeastLessThan_iff ncols_def nrows_def set_upt xs_eq)"], ["proof (state)\nthis:\n  \\<forall>j\\<in>set [i + 1..<min (dim_row A) (dim_col A)].\n     j < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. \\<And>x y a aa b ab ac ba.\n       HMA_M3 (a, aa, b) (ab, ac, ba) \\<Longrightarrow>\n       HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i y (a, aa, b))\n        (Diagonal_to_Smith_row_i_PQ i y (ab, ac, ba))", "have rel: \"HMA_M3 (diagonal_to_Smith_i_PQ_JNF ?xs1 i bezout (P,A,Q)) \n            (diagonal_to_Smith_i_PQ ?xs1 i bezout (P',A',Q'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M3\n     (diagonal_to_Smith_i_PQ_JNF [i + 1..<min (dim_row A) (dim_col A)] i\n       bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ [i + 1..<min (dim_row A) (dim_col A)] i bezout\n       (P', A', Q'))", "using HMA_diagonal_to_Smith_i_PQ[OF i j_xs] HMA_M3"], ["proof (prove)\nusing this:\n  ((=) ===> HMA_M3 ===> HMA_M3)\n   (diagonal_to_Smith_i_PQ_JNF [i + 1..<min (dim_row A) (dim_col A)] i)\n   (diagonal_to_Smith_i_PQ [i + 1..<min (dim_row A) (dim_col A)] i)\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. HMA_M3\n     (diagonal_to_Smith_i_PQ_JNF [i + 1..<min (dim_row A) (dim_col A)] i\n       bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ [i + 1..<min (dim_row A) (dim_col A)] i bezout\n       (P', A', Q'))", "unfolding rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     x = y \\<longrightarrow>\n     (\\<forall>xa ya.\n         HMA_M3 xa ya \\<longrightarrow>\n         HMA_M3\n          (diagonal_to_Smith_i_PQ_JNF [i + 1..<min (dim_row A) (dim_col A)]\n            i x xa)\n          (diagonal_to_Smith_i_PQ [i + 1..<min (dim_row A) (dim_col A)] i y\n            ya))\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. HMA_M3\n     (diagonal_to_Smith_i_PQ_JNF [i + 1..<min (dim_row A) (dim_col A)] i\n       bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ [i + 1..<min (dim_row A) (dim_col A)] i bezout\n       (P', A', Q'))", "by blast"], ["proof (state)\nthis:\n  HMA_M3\n   (diagonal_to_Smith_i_PQ_JNF [i + 1..<min (dim_row A) (dim_col A)] i\n     bezout (P, A, Q))\n   (diagonal_to_Smith_i_PQ [i + 1..<min (dim_row A) (dim_col A)] i bezout\n     (P', A', Q'))\n\ngoal (1 subgoal):\n 1. \\<And>x y a aa b ab ac ba.\n       HMA_M3 (a, aa, b) (ab, ac, ba) \\<Longrightarrow>\n       HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i y (a, aa, b))\n        (Diagonal_to_Smith_row_i_PQ i y (ab, ac, ba))", "then"], ["proof (chain)\npicking this:\n  HMA_M3\n   (diagonal_to_Smith_i_PQ_JNF [i + 1..<min (dim_row A) (dim_col A)] i\n     bezout (P, A, Q))\n   (diagonal_to_Smith_i_PQ [i + 1..<min (dim_row A) (dim_col A)] i bezout\n     (P', A', Q'))", "show ?case"], ["proof (prove)\nusing this:\n  HMA_M3\n   (diagonal_to_Smith_i_PQ_JNF [i + 1..<min (dim_row A) (dim_col A)] i\n     bezout (P, A, Q))\n   (diagonal_to_Smith_i_PQ [i + 1..<min (dim_row A) (dim_col A)] i bezout\n     (P', A', Q'))\n\ngoal (1 subgoal):\n 1. HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P, A, Q))\n     (Diagonal_to_Smith_row_i_PQ i bezout (P', A', Q'))", "unfolding Diagonal_to_Smith_row_i_PQ_JNF_def Diagonal_to_Smith_row_i_PQ_def"], ["proof (prove)\nusing this:\n  HMA_M3\n   (diagonal_to_Smith_i_PQ_JNF [i + 1..<min (dim_row A) (dim_col A)] i\n     bezout (P, A, Q))\n   (diagonal_to_Smith_i_PQ [i + 1..<min (dim_row A) (dim_col A)] i bezout\n     (P', A', Q'))\n\ngoal (1 subgoal):\n 1. HMA_M3\n     (diagonal_to_Smith_i_PQ_JNF [i + 1..<min (dim_row A) (dim_col A)] i\n       bezout (P, A, Q))\n     (diagonal_to_Smith_i_PQ [i + 1..<min (nrows A') (ncols A')] i bezout\n       (P', A', Q'))", "by (metis Suc_eq_plus1 xs_eq)"], ["proof (state)\nthis:\n  HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P, A, Q))\n   (Diagonal_to_Smith_row_i_PQ i bezout (P', A', Q'))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun diagonal_to_Smith_aux_PQ_JNF \n  where\n  \"diagonal_to_Smith_aux_PQ_JNF [] bezout (P,A,Q) = (P,A,Q)\" |\n  \"diagonal_to_Smith_aux_PQ_JNF (i#xs) bezout (P,A,Q) \n      = diagonal_to_Smith_aux_PQ_JNF xs bezout (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P,A,Q))\""], ["", "context\n  includes lifting_syntax\n  fixes xs\n  assumes xs: \"\\<forall>j\\<in>set xs. j < min (CARD('nr::mod_type)) (CARD('nc::mod_type))\"\nbegin"], ["", "lemma HMA_diagonal_to_Smith_aux_PQ_JNF[transfer_rule]:\n  \"((=) ===> (HMA_M3 :: (_ \\<Rightarrow> (_ \\<times> ('a::bezout_ring^'nc::mod_type^'nr::mod_type) \\<times> _) \\<Rightarrow> _)) ===> HMA_M3) \n  (diagonal_to_Smith_aux_PQ_JNF xs) (diagonal_to_Smith_aux_PQ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> HMA_M3 ===> HMA_M3) (diagonal_to_Smith_aux_PQ_JNF xs)\n     (diagonal_to_Smith_aux_PQ xs)", "proof (intro rel_funI, clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y a aa b ab ac ba.\n       HMA_M3 (a, aa, b) (ab, ac, ba) \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_aux_PQ_JNF xs y (a, aa, b))\n        (diagonal_to_Smith_aux_PQ xs y (ab, ac, ba))", "case (1 _ bezout P A Q P' A' Q')"], ["proof (state)\nthis:\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. \\<And>x y a aa b ab ac ba.\n       HMA_M3 (a, aa, b) (ab, ac, ba) \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_aux_PQ_JNF xs y (a, aa, b))\n        (diagonal_to_Smith_aux_PQ xs y (ab, ac, ba))", "note HMA_M3[transfer_rule] = 1"], ["proof (state)\nthis:\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. \\<And>x y a aa b ab ac ba.\n       HMA_M3 (a, aa, b) (ab, ac, ba) \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_aux_PQ_JNF xs y (a, aa, b))\n        (diagonal_to_Smith_aux_PQ xs y (ab, ac, ba))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n     (diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'))", "using xs HMA_M3"], ["proof (prove)\nusing this:\n  \\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc)\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n     (diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'))", "proof (induct xs arbitrary: P' A' Q' P A Q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P' A' Q' P A Q.\n       \\<lbrakk>\\<forall>j\\<in>set []. j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF [] bezout (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ [] bezout (P', A', Q'))\n 2. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "case Nil"], ["proof (state)\nthis:\n  \\<forall>j\\<in>set []. j < min CARD('nr) CARD('nc)\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (2 subgoals):\n 1. \\<And>P' A' Q' P A Q.\n       \\<lbrakk>\\<forall>j\\<in>set []. j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF [] bezout (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ [] bezout (P', A', Q'))\n 2. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "then"], ["proof (chain)\npicking this:\n  \\<forall>j\\<in>set []. j < min CARD('nr) CARD('nc)\n  HMA_M3 (P, A, Q) (P', A', Q')", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>j\\<in>set []. j < min CARD('nr) CARD('nc)\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_aux_PQ_JNF [] bezout (P, A, Q))\n     (diagonal_to_Smith_aux_PQ [] bezout (P', A', Q'))", "by auto"], ["proof (state)\nthis:\n  HMA_M3 (diagonal_to_Smith_aux_PQ_JNF [] bezout (P, A, Q))\n   (diagonal_to_Smith_aux_PQ [] bezout (P', A', Q'))\n\ngoal (1 subgoal):\n 1. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "case (Cons i xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc);\n   HMA_M3 (?P, ?A, ?Q) (?P', ?A', ?Q')\\<rbrakk>\n  \\<Longrightarrow> HMA_M3\n                     (diagonal_to_Smith_aux_PQ_JNF xs bezout (?P, ?A, ?Q))\n                     (diagonal_to_Smith_aux_PQ xs bezout (?P', ?A', ?Q'))\n  \\<forall>j\\<in>set (i # xs). j < min CARD('nr) CARD('nc)\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "note IH = Cons(1)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>j\\<in>set xs. j < min CARD('nr) CARD('nc);\n   HMA_M3 (?P, ?A, ?Q) (?P', ?A', ?Q')\\<rbrakk>\n  \\<Longrightarrow> HMA_M3\n                     (diagonal_to_Smith_aux_PQ_JNF xs bezout (?P, ?A, ?Q))\n                     (diagonal_to_Smith_aux_PQ xs bezout (?P', ?A', ?Q'))\n\ngoal (1 subgoal):\n 1. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "note HMA_M3 = Cons.prems(2)"], ["proof (state)\nthis:\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "have i: \"i < min CARD('nr) CARD('nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < min CARD('nr) CARD('nc)", "using Cons.prems"], ["proof (prove)\nusing this:\n  \\<forall>j\\<in>set (i # xs). j < min CARD('nr) CARD('nc)\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. i < min CARD('nr) CARD('nc)", "by auto"], ["proof (state)\nthis:\n  i < min CARD('nr) CARD('nc)\n\ngoal (1 subgoal):\n 1. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "let ?D_JNF = \"(Diagonal_to_Smith_row_i_PQ_JNF i bezout (P, A, Q))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "let ?D_HA = \"(Diagonal_to_Smith_row_i_PQ i bezout (P', A', Q'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "have rw_1: \"diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) \n        = diagonal_to_Smith_aux_PQ_JNF xs bezout ?D_JNF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n    diagonal_to_Smith_aux_PQ_JNF xs bezout\n     (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P, A, Q))", "by auto"], ["proof (state)\nthis:\n  diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n  diagonal_to_Smith_aux_PQ_JNF xs bezout\n   (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P, A, Q))\n\ngoal (1 subgoal):\n 1. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "have rw_2: \"diagonal_to_Smith_aux_PQ (i # xs) bezout (P', A', Q') \n        = diagonal_to_Smith_aux_PQ xs bezout ?D_HA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_to_Smith_aux_PQ (i # xs) bezout (P', A', Q') =\n    diagonal_to_Smith_aux_PQ xs bezout\n     (Diagonal_to_Smith_row_i_PQ i bezout (P', A', Q'))", "by auto"], ["proof (state)\nthis:\n  diagonal_to_Smith_aux_PQ (i # xs) bezout (P', A', Q') =\n  diagonal_to_Smith_aux_PQ xs bezout\n   (Diagonal_to_Smith_row_i_PQ i bezout (P', A', Q'))\n\ngoal (1 subgoal):\n 1. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "have \"HMA_M3 ?D_JNF ?D_HA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P, A, Q))\n     (Diagonal_to_Smith_row_i_PQ i bezout (P', A', Q'))", "using HMA_Diagonal_to_Smith_row_i_PQ[OF i] HMA_M3"], ["proof (prove)\nusing this:\n  ((=) ===> HMA_M3 ===> HMA_M3) (Diagonal_to_Smith_row_i_PQ_JNF i)\n   (Diagonal_to_Smith_row_i_PQ i)\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P, A, Q))\n     (Diagonal_to_Smith_row_i_PQ i bezout (P', A', Q'))", "unfolding rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     x = y \\<longrightarrow>\n     (\\<forall>xa ya.\n         HMA_M3 xa ya \\<longrightarrow>\n         HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i x xa)\n          (Diagonal_to_Smith_row_i_PQ i y ya))\n  HMA_M3 (P, A, Q) (P', A', Q')\n\ngoal (1 subgoal):\n 1. HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P, A, Q))\n     (Diagonal_to_Smith_row_i_PQ i bezout (P', A', Q'))", "by blast"], ["proof (state)\nthis:\n  HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P, A, Q))\n   (Diagonal_to_Smith_row_i_PQ i bezout (P', A', Q'))\n\ngoal (1 subgoal):\n 1. \\<And>a xs P' A' Q' P A Q.\n       \\<lbrakk>\\<And>P' A' Q' P A Q.\n                   \\<lbrakk>\\<forall>j\\<in>set xs.\n                               j < min CARD('nr) CARD('nc);\n                    HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n                   \\<Longrightarrow> HMA_M3\n(diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n(diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'));\n        \\<forall>j\\<in>set (a # xs). j < min CARD('nr) CARD('nc);\n        HMA_M3 (P, A, Q) (P', A', Q')\\<rbrakk>\n       \\<Longrightarrow> HMA_M3\n                          (diagonal_to_Smith_aux_PQ_JNF (a # xs) bezout\n                            (P, A, Q))\n                          (diagonal_to_Smith_aux_PQ (a # xs) bezout\n                            (P', A', Q'))", "then"], ["proof (chain)\npicking this:\n  HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P, A, Q))\n   (Diagonal_to_Smith_row_i_PQ i bezout (P', A', Q'))", "show ?case"], ["proof (prove)\nusing this:\n  HMA_M3 (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P, A, Q))\n   (Diagonal_to_Smith_row_i_PQ i bezout (P', A', Q'))\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q))\n     (diagonal_to_Smith_aux_PQ (i # xs) bezout (P', A', Q'))", "by (auto, smt Cons.hyps HMA_M3.elims(2) list.set_intros(2) local.Cons(2))"], ["proof (state)\nthis:\n  HMA_M3 (diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q))\n   (diagonal_to_Smith_aux_PQ (i # xs) bezout (P', A', Q'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  HMA_M3 (diagonal_to_Smith_aux_PQ_JNF xs bezout (P, A, Q))\n   (diagonal_to_Smith_aux_PQ xs bezout (P', A', Q'))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun diagonal_to_Smith_PQ_JNF\n  where \"diagonal_to_Smith_PQ_JNF A bezout \n  = diagonal_to_Smith_aux_PQ_JNF [0..<min (dim_row A) (dim_col A) - 1] \n    bezout (1\\<^sub>m (dim_row A),A,1\\<^sub>m (dim_col A))\""], ["", "declare diagonal_to_Smith_PQ_JNF.simps[simp del]"], ["", "lemmas diagonal_to_Smith_PQ_JNF_def = diagonal_to_Smith_PQ_JNF.simps"], ["", "lemma diagonal_step_PQ_JNF_dim:\n  assumes A: \"A \\<in> carrier_mat m n\"\n    and d: \"diagonal_step_PQ_JNF A i j bezout = (P,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and> Q \\<in> carrier_mat n n", "using A d"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m n\n  diagonal_step_PQ_JNF A i j bezout = (P, Q)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and> Q \\<in> carrier_mat n n", "unfolding diagonal_step_PQ_JNF_def split_beta Let_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m n\n  (addrow (- fst (snd (snd (snd (bezout (A $$ (i, i)) (A $$ (j, j))))))) j i\n    (swaprows i j\n      (addrow (fst (bezout (A $$ (i, i)) (A $$ (j, j)))) j i\n        (1\\<^sub>m (dim_row A)))),\n   multcol j (- (1::'a))\n    (addcol (fst (snd (snd (bezout (A $$ (i, i)) (A $$ (j, j)))))) j i\n      (addcol (fst (snd (bezout (A $$ (i, i)) (A $$ (j, j))))) i j\n        (1\\<^sub>m (dim_col A))))) =\n  (P, Q)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and> Q \\<in> carrier_mat n n", "by auto"], ["", "lemma diagonal_step_JNF_dim:\n  assumes A: \"A \\<in> carrier_mat m n\"\n  shows \"diagonal_step_JNF A i j d v \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_step_JNF A i j d v \\<in> carrier_mat m n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. diagonal_step_JNF A i j d v \\<in> carrier_mat m n", "unfolding diagonal_step_JNF_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. Matrix.mat (dim_row A) (dim_col A)\n     (\\<lambda>(a, b).\n         if a = i \\<and> b = i then d\n         else if a = j \\<and> b = j then v * A $$ (j, j) else A $$ (a, b))\n    \\<in> carrier_mat m n", "by auto"], ["", "lemma diagonal_to_Smith_i_PQ_JNF_dim:\n  assumes \"P' \\<in> carrier_mat m m \\<and> A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\"\n    and \"diagonal_to_Smith_i_PQ_JNF xs i bezout (P',A',Q') = (P,A,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "using assms"], ["proof (prove)\nusing this:\n  P' \\<in> carrier_mat m m \\<and>\n  A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\n  diagonal_to_Smith_i_PQ_JNF xs i bezout (P', A', Q') = (P, A, Q)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "proof (induct xs i bezout \"(P',A',Q')\" arbitrary: P A Q P' A' Q' rule: diagonal_to_Smith_i_PQ_JNF.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>P \\<in> carrier_mat m m \\<and>\n                A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_i_PQ_JNF [] i bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n\n 2. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $$ (i, i) dvd A $$ (j, j);\n                    P \\<in> carrier_mat m m \\<and>\n                    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n                    diagonal_to_Smith_i_PQ_JNF xs i bezout (P, A, Q) =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $$ (i, i) dvd A $$ (j, j);\n            x = bezout (A $$ (i, i)) (A $$ (j, j)); (xa, y) = x;\n            (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step_JNF A i j yc xd;\n            xf = diagonal_step_PQ_JNF A i j bezout; (xg, yd) = xf;\n            xg * P \\<in> carrier_mat m m \\<and>\n            xe \\<in> carrier_mat m n \\<and> Q * yd \\<in> carrier_mat n n;\n            diagonal_to_Smith_i_PQ_JNF xs i bezout (xg * P, xe, Q * yd) =\n            (Pa, Aa, Qa)\\<rbrakk>\n           \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                             Aa \\<in> carrier_mat m n \\<and>\n                             Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "case (1 i bezout P A Q)"], ["proof (state)\nthis:\n  Pa__ \\<in> carrier_mat m m \\<and>\n  Aa__ \\<in> carrier_mat m n \\<and> Qa__ \\<in> carrier_mat n n\n  diagonal_to_Smith_i_PQ_JNF [] i bezout (Pa__, Aa__, Qa__) = (P, A, Q)\n\ngoal (2 subgoals):\n 1. \\<And>i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>P \\<in> carrier_mat m m \\<and>\n                A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_i_PQ_JNF [] i bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n\n 2. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $$ (i, i) dvd A $$ (j, j);\n                    P \\<in> carrier_mat m m \\<and>\n                    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n                    diagonal_to_Smith_i_PQ_JNF xs i bezout (P, A, Q) =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $$ (i, i) dvd A $$ (j, j);\n            x = bezout (A $$ (i, i)) (A $$ (j, j)); (xa, y) = x;\n            (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step_JNF A i j yc xd;\n            xf = diagonal_step_PQ_JNF A i j bezout; (xg, yd) = xf;\n            xg * P \\<in> carrier_mat m m \\<and>\n            xe \\<in> carrier_mat m n \\<and> Q * yd \\<in> carrier_mat n n;\n            diagonal_to_Smith_i_PQ_JNF xs i bezout (xg * P, xe, Q * yd) =\n            (Pa, Aa, Qa)\\<rbrakk>\n           \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                             Aa \\<in> carrier_mat m n \\<and>\n                             Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "then"], ["proof (chain)\npicking this:\n  Pa__ \\<in> carrier_mat m m \\<and>\n  Aa__ \\<in> carrier_mat m n \\<and> Qa__ \\<in> carrier_mat n n\n  diagonal_to_Smith_i_PQ_JNF [] i bezout (Pa__, Aa__, Qa__) = (P, A, Q)", "show ?case"], ["proof (prove)\nusing this:\n  Pa__ \\<in> carrier_mat m m \\<and>\n  Aa__ \\<in> carrier_mat m n \\<and> Qa__ \\<in> carrier_mat n n\n  diagonal_to_Smith_i_PQ_JNF [] i bezout (Pa__, Aa__, Qa__) = (P, A, Q)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat m m \\<and>\n  A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $$ (i, i) dvd A $$ (j, j);\n                    P \\<in> carrier_mat m m \\<and>\n                    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n                    diagonal_to_Smith_i_PQ_JNF xs i bezout (P, A, Q) =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $$ (i, i) dvd A $$ (j, j);\n            x = bezout (A $$ (i, i)) (A $$ (j, j)); (xa, y) = x;\n            (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step_JNF A i j yc xd;\n            xf = diagonal_step_PQ_JNF A i j bezout; (xg, yd) = xf;\n            xg * P \\<in> carrier_mat m m \\<and>\n            xe \\<in> carrier_mat m n \\<and> Q * yd \\<in> carrier_mat n n;\n            diagonal_to_Smith_i_PQ_JNF xs i bezout (xg * P, xe, Q * yd) =\n            (Pa, Aa, Qa)\\<rbrakk>\n           \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                             Aa \\<in> carrier_mat m n \\<and>\n                             Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $$ (i, i) dvd A $$ (j, j);\n                    P \\<in> carrier_mat m m \\<and>\n                    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n                    diagonal_to_Smith_i_PQ_JNF xs i bezout (P, A, Q) =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $$ (i, i) dvd A $$ (j, j);\n            x = bezout (A $$ (i, i)) (A $$ (j, j)); (xa, y) = x;\n            (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step_JNF A i j yc xd;\n            xf = diagonal_step_PQ_JNF A i j bezout; (xg, yd) = xf;\n            xg * P \\<in> carrier_mat m m \\<and>\n            xe \\<in> carrier_mat m n \\<and> Q * yd \\<in> carrier_mat n n;\n            diagonal_to_Smith_i_PQ_JNF xs i bezout (xg * P, xe, Q * yd) =\n            (Pa, Aa, Qa)\\<rbrakk>\n           \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                             Aa \\<in> carrier_mat m n \\<and>\n                             Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "case (2 j xs i bezout P' A' Q')"], ["proof (state)\nthis:\n  \\<lbrakk>A' $$ (i, i) dvd A' $$ (j, j);\n   P' \\<in> carrier_mat m m \\<and>\n   A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n;\n   diagonal_to_Smith_i_PQ_JNF xs i bezout (P', A', Q') =\n   (?P, ?A, ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?P \\<in> carrier_mat m m \\<and>\n                    ?A \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n  \\<lbrakk>\\<not> A' $$ (i, i) dvd A' $$ (j, j);\n   ?x = bezout (A' $$ (i, i)) (A' $$ (j, j)); (?xa, ?y) = ?x;\n   (?xb, ?ya) = ?y; (?xc, ?yb) = ?ya; (?xd, ?yc) = ?yb;\n   ?xe = diagonal_step_JNF A' i j ?yc ?xd;\n   ?xf = diagonal_step_PQ_JNF A' i j bezout; (?xg, ?yd) = ?xf;\n   ?xg * P' \\<in> carrier_mat m m \\<and>\n   ?xe \\<in> carrier_mat m n \\<and> Q' * ?yd \\<in> carrier_mat n n;\n   diagonal_to_Smith_i_PQ_JNF xs i bezout (?xg * P', ?xe, Q' * ?yd) =\n   (?P, ?A, ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?P \\<in> carrier_mat m m \\<and>\n                    ?A \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n  P' \\<in> carrier_mat m m \\<and>\n  A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\n  diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P', A', Q') = (P, A, Q)\n\ngoal (1 subgoal):\n 1. \\<And>j xs i bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>Pa Aa Qa.\n                   \\<lbrakk>A $$ (i, i) dvd A $$ (j, j);\n                    P \\<in> carrier_mat m m \\<and>\n                    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n                    diagonal_to_Smith_i_PQ_JNF xs i bezout (P, A, Q) =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        \\<And>x xa y xb ya xc yb xd yc xe xf xg yd Pa Aa Qa.\n           \\<lbrakk>\\<not> A $$ (i, i) dvd A $$ (j, j);\n            x = bezout (A $$ (i, i)) (A $$ (j, j)); (xa, y) = x;\n            (xb, ya) = y; (xc, yb) = ya; (xd, yc) = yb;\n            xe = diagonal_step_JNF A i j yc xd;\n            xf = diagonal_step_PQ_JNF A i j bezout; (xg, yd) = xf;\n            xg * P \\<in> carrier_mat m m \\<and>\n            xe \\<in> carrier_mat m n \\<and> Q * yd \\<in> carrier_mat n n;\n            diagonal_to_Smith_i_PQ_JNF xs i bezout (xg * P, xe, Q * yd) =\n            (Pa, Aa, Qa)\\<rbrakk>\n           \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                             Aa \\<in> carrier_mat m n \\<and>\n                             Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "proof (cases \"A' $$ (i, i) dvd A' $$ (j, j)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\n 2. \\<not> A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "case True"], ["proof (state)\nthis:\n  A' $$ (i, i) dvd A' $$ (j, j)\n\ngoal (2 subgoals):\n 1. A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\n 2. \\<not> A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "then"], ["proof (chain)\npicking this:\n  A' $$ (i, i) dvd A' $$ (j, j)", "show ?thesis"], ["proof (prove)\nusing this:\n  A' $$ (i, i) dvd A' $$ (j, j)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "using 2"], ["proof (prove)\nusing this:\n  A' $$ (i, i) dvd A' $$ (j, j)\n  \\<lbrakk>A' $$ (i, i) dvd A' $$ (j, j);\n   P' \\<in> carrier_mat m m \\<and>\n   A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n;\n   diagonal_to_Smith_i_PQ_JNF xs i bezout (P', A', Q') =\n   (?P, ?A, ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?P \\<in> carrier_mat m m \\<and>\n                    ?A \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n  \\<lbrakk>\\<not> A' $$ (i, i) dvd A' $$ (j, j);\n   ?x = bezout (A' $$ (i, i)) (A' $$ (j, j)); (?xa, ?y) = ?x;\n   (?xb, ?ya) = ?y; (?xc, ?yb) = ?ya; (?xd, ?yc) = ?yb;\n   ?xe = diagonal_step_JNF A' i j ?yc ?xd;\n   ?xf = diagonal_step_PQ_JNF A' i j bezout; (?xg, ?yd) = ?xf;\n   ?xg * P' \\<in> carrier_mat m m \\<and>\n   ?xe \\<in> carrier_mat m n \\<and> Q' * ?yd \\<in> carrier_mat n n;\n   diagonal_to_Smith_i_PQ_JNF xs i bezout (?xg * P', ?xe, Q' * ?yd) =\n   (?P, ?A, ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?P \\<in> carrier_mat m m \\<and>\n                    ?A \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n  P' \\<in> carrier_mat m m \\<and>\n  A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\n  diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P', A', Q') = (P, A, Q)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat m m \\<and>\n  A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<not> A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "case False"], ["proof (state)\nthis:\n  \\<not> A' $$ (i, i) dvd A' $$ (j, j)\n\ngoal (1 subgoal):\n 1. \\<not> A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "obtain p q u v d where b: \"(p, q, u, v, d) = bezout (A' $$ (i,i)) (A' $$ (j,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q u v d.\n        (p, q, u, v, d) =\n        bezout (A' $$ (i, i)) (A' $$ (j, j)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases5)"], ["proof (state)\nthis:\n  (p, q, u, v, d) = bezout (A' $$ (i, i)) (A' $$ (j, j))\n\ngoal (1 subgoal):\n 1. \\<not> A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "let ?A' = \"diagonal_step_JNF A' i j d v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "obtain P'' Q'' where P''Q'': \"(P'',Q'') = diagonal_step_PQ_JNF A' i j bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P'' Q''.\n        (P'', Q'') = diagonal_step_PQ_JNF A' i j bezout \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surjective_pairing)"], ["proof (state)\nthis:\n  (P'', Q'') = diagonal_step_PQ_JNF A' i j bezout\n\ngoal (1 subgoal):\n 1. \\<not> A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "let ?A' = \"diagonal_step_JNF A' i j d v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "let ?D_JNF = \"diagonal_to_Smith_i_PQ_JNF xs i bezout (P''*P',?A',Q'*Q'')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "have rw_1: \"diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P', A', Q') = ?D_JNF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P', A', Q') =\n    diagonal_to_Smith_i_PQ_JNF xs i bezout\n     (P'' * P', diagonal_step_JNF A' i j d v, Q' * Q'')", "using False b P''Q''"], ["proof (prove)\nusing this:\n  \\<not> A' $$ (i, i) dvd A' $$ (j, j)\n  (p, q, u, v, d) = bezout (A' $$ (i, i)) (A' $$ (j, j))\n  (P'', Q'') = diagonal_step_PQ_JNF A' i j bezout\n\ngoal (1 subgoal):\n 1. diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P', A', Q') =\n    diagonal_to_Smith_i_PQ_JNF xs i bezout\n     (P'' * P', diagonal_step_JNF A' i j d v, Q' * Q'')", "by (auto, unfold split_beta, metis fst_conv snd_conv)"], ["proof (state)\nthis:\n  diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P', A', Q') =\n  diagonal_to_Smith_i_PQ_JNF xs i bezout\n   (P'' * P', diagonal_step_JNF A' i j d v, Q' * Q'')\n\ngoal (1 subgoal):\n 1. \\<not> A' $$ (i, i) dvd A' $$ (j, j) \\<Longrightarrow>\n    P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "proof (rule \"2.hyps\"(2)[OF False b])"], ["proof (state)\ngoal (9 subgoals):\n 1. (?xa, ?y) = (p, q, u, v, d)\n 2. (?xb, ?ya) = ?y\n 3. (?xc, ?yb) = ?ya\n 4. (?xd, ?yc) = ?yb\n 5. ?xe = diagonal_step_JNF A' i j ?yc ?xd\n 6. ?xf = diagonal_step_PQ_JNF A' i j bezout\n 7. (?xg, ?yd) = ?xf\n 8. ?xg * P' \\<in> carrier_mat m m \\<and>\n    ?xe \\<in> carrier_mat m n \\<and> Q' * ?yd \\<in> carrier_mat n n\n 9. diagonal_to_Smith_i_PQ_JNF xs i bezout (?xg * P', ?xe, Q' * ?yd) =\n    (P, A, Q)", "show \"?D_JNF = (P,A,Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_to_Smith_i_PQ_JNF xs i bezout\n     (P'' * P', diagonal_step_JNF A' i j d v, Q' * Q'') =\n    (P, A, Q)", "using rw_1 2"], ["proof (prove)\nusing this:\n  diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P', A', Q') =\n  diagonal_to_Smith_i_PQ_JNF xs i bezout\n   (P'' * P', diagonal_step_JNF A' i j d v, Q' * Q'')\n  \\<lbrakk>A' $$ (i, i) dvd A' $$ (j, j);\n   P' \\<in> carrier_mat m m \\<and>\n   A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n;\n   diagonal_to_Smith_i_PQ_JNF xs i bezout (P', A', Q') =\n   (?P, ?A, ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?P \\<in> carrier_mat m m \\<and>\n                    ?A \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n  \\<lbrakk>\\<not> A' $$ (i, i) dvd A' $$ (j, j);\n   ?x = bezout (A' $$ (i, i)) (A' $$ (j, j)); (?xa, ?y) = ?x;\n   (?xb, ?ya) = ?y; (?xc, ?yb) = ?ya; (?xd, ?yc) = ?yb;\n   ?xe = diagonal_step_JNF A' i j ?yc ?xd;\n   ?xf = diagonal_step_PQ_JNF A' i j bezout; (?xg, ?yd) = ?xf;\n   ?xg * P' \\<in> carrier_mat m m \\<and>\n   ?xe \\<in> carrier_mat m n \\<and> Q' * ?yd \\<in> carrier_mat n n;\n   diagonal_to_Smith_i_PQ_JNF xs i bezout (?xg * P', ?xe, Q' * ?yd) =\n   (?P, ?A, ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?P \\<in> carrier_mat m m \\<and>\n                    ?A \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n  P' \\<in> carrier_mat m m \\<and>\n  A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\n  diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P', A', Q') = (P, A, Q)\n\ngoal (1 subgoal):\n 1. diagonal_to_Smith_i_PQ_JNF xs i bezout\n     (P'' * P', diagonal_step_JNF A' i j d v, Q' * Q'') =\n    (P, A, Q)", "by auto"], ["proof (state)\nthis:\n  diagonal_to_Smith_i_PQ_JNF xs i bezout\n   (P'' * P', diagonal_step_JNF A' i j d v, Q' * Q'') =\n  (P, A, Q)\n\ngoal (8 subgoals):\n 1. (?xa, ?y) = (p, q, u, v, d)\n 2. (?xb, ?ya) = ?y\n 3. (?xc, ?yb) = ?ya\n 4. (?xd, ?yc) = ?yb\n 5. diagonal_step_JNF A' i j d v = diagonal_step_JNF A' i j ?yc ?xd\n 6. ?xf = diagonal_step_PQ_JNF A' i j bezout\n 7. (P'', Q'') = ?xf\n 8. P'' * P' \\<in> carrier_mat m m \\<and>\n    diagonal_step_JNF A' i j d v \\<in> carrier_mat m n \\<and>\n    Q' * Q'' \\<in> carrier_mat n n", "have \"P'' \\<in> carrier_mat m m\" and \"Q'' \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P'' \\<in> carrier_mat m m &&& Q'' \\<in> carrier_mat n n", "using diagonal_step_PQ_JNF_dim[OF _ P''Q''[symmetric]] \"2.prems\""], ["proof (prove)\nusing this:\n  A' \\<in> carrier_mat ?m ?n \\<Longrightarrow>\n  P'' \\<in> carrier_mat ?m ?m \\<and> Q'' \\<in> carrier_mat ?n ?n\n  P' \\<in> carrier_mat m m \\<and>\n  A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\n  diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P', A', Q') = (P, A, Q)\n\ngoal (1 subgoal):\n 1. P'' \\<in> carrier_mat m m &&& Q'' \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  P'' \\<in> carrier_mat m m\n  Q'' \\<in> carrier_mat n n\n\ngoal (8 subgoals):\n 1. (?xa, ?y) = (p, q, u, v, d)\n 2. (?xb, ?ya) = ?y\n 3. (?xc, ?yb) = ?ya\n 4. (?xd, ?yc) = ?yb\n 5. diagonal_step_JNF A' i j d v = diagonal_step_JNF A' i j ?yc ?xd\n 6. ?xf = diagonal_step_PQ_JNF A' i j bezout\n 7. (P'', Q'') = ?xf\n 8. P'' * P' \\<in> carrier_mat m m \\<and>\n    diagonal_step_JNF A' i j d v \\<in> carrier_mat m n \\<and>\n    Q' * Q'' \\<in> carrier_mat n n", "thus \"P'' * P' \\<in> carrier_mat m m \\<and> ?A' \\<in> carrier_mat m n \\<and> Q' * Q'' \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  P'' \\<in> carrier_mat m m\n  Q'' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P'' * P' \\<in> carrier_mat m m \\<and>\n    diagonal_step_JNF A' i j d v \\<in> carrier_mat m n \\<and>\n    Q' * Q'' \\<in> carrier_mat n n", "using diagonal_step_JNF_dim 2"], ["proof (prove)\nusing this:\n  P'' \\<in> carrier_mat m m\n  Q'' \\<in> carrier_mat n n\n  ?A \\<in> carrier_mat ?m ?n \\<Longrightarrow>\n  diagonal_step_JNF ?A ?i ?j ?d ?v \\<in> carrier_mat ?m ?n\n  \\<lbrakk>A' $$ (i, i) dvd A' $$ (j, j);\n   P' \\<in> carrier_mat m m \\<and>\n   A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n;\n   diagonal_to_Smith_i_PQ_JNF xs i bezout (P', A', Q') =\n   (?P, ?A, ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?P \\<in> carrier_mat m m \\<and>\n                    ?A \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n  \\<lbrakk>\\<not> A' $$ (i, i) dvd A' $$ (j, j);\n   ?x = bezout (A' $$ (i, i)) (A' $$ (j, j)); (?xa, ?y) = ?x;\n   (?xb, ?ya) = ?y; (?xc, ?yb) = ?ya; (?xd, ?yc) = ?yb;\n   ?xe = diagonal_step_JNF A' i j ?yc ?xd;\n   ?xf = diagonal_step_PQ_JNF A' i j bezout; (?xg, ?yd) = ?xf;\n   ?xg * P' \\<in> carrier_mat m m \\<and>\n   ?xe \\<in> carrier_mat m n \\<and> Q' * ?yd \\<in> carrier_mat n n;\n   diagonal_to_Smith_i_PQ_JNF xs i bezout (?xg * P', ?xe, Q' * ?yd) =\n   (?P, ?A, ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?P \\<in> carrier_mat m m \\<and>\n                    ?A \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n  P' \\<in> carrier_mat m m \\<and>\n  A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\n  diagonal_to_Smith_i_PQ_JNF (j # xs) i bezout (P', A', Q') = (P, A, Q)\n\ngoal (1 subgoal):\n 1. P'' * P' \\<in> carrier_mat m m \\<and>\n    diagonal_step_JNF A' i j d v \\<in> carrier_mat m n \\<and>\n    Q' * Q'' \\<in> carrier_mat n n", "by (metis mult_carrier_mat)"], ["proof (state)\nthis:\n  P'' * P' \\<in> carrier_mat m m \\<and>\n  diagonal_step_JNF A' i j d v \\<in> carrier_mat m n \\<and>\n  Q' * Q'' \\<in> carrier_mat n n\n\ngoal (7 subgoals):\n 1. (?xa, ?y) = (p, q, u, v, d)\n 2. (?xb, ?ya) = ?y\n 3. (?xc, ?yb) = ?ya\n 4. (?xd, ?yc) = ?yb\n 5. diagonal_step_JNF A' i j d v = diagonal_step_JNF A' i j ?yc ?xd\n 6. ?xf = diagonal_step_PQ_JNF A' i j bezout\n 7. (P'', Q'') = ?xf", "qed (insert P''Q'', auto)"], ["proof (state)\nthis:\n  P \\<in> carrier_mat m m \\<and>\n  A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<in> carrier_mat m m \\<and>\n  A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Diagonal_to_Smith_row_i_PQ_JNF_dim:\n  assumes \"P' \\<in> carrier_mat m m \\<and> A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\"\n    and \"Diagonal_to_Smith_row_i_PQ_JNF i bezout (P',A',Q') = (P,A,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "by (rule diagonal_to_Smith_i_PQ_JNF_dim, insert assms, \n      auto simp add: Diagonal_to_Smith_row_i_PQ_JNF_def)"], ["", "lemma diagonal_to_Smith_aux_PQ_JNF_dim:\n  assumes \"P' \\<in> carrier_mat m m \\<and> A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\"\n    and \"diagonal_to_Smith_aux_PQ_JNF xs bezout (P',A',Q') = (P,A,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "using assms"], ["proof (prove)\nusing this:\n  P' \\<in> carrier_mat m m \\<and>\n  A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\n  diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') = (P, A, Q)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "proof (induct xs bezout \"(P',A',Q')\" arbitrary: P A Q P' A' Q' rule: diagonal_to_Smith_aux_PQ_JNF.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bezout P A Q Pa Aa Qa.\n       \\<lbrakk>P \\<in> carrier_mat m m \\<and>\n                A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF [] bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n\n 2. \\<And>i xs bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>P' A' Q' Pa Aa Qa.\n                   \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout\n                             (P, A, Q) =\n                            (P', A', Q');\n                    P' \\<in> carrier_mat m m \\<and>\n                    A' \\<in> carrier_mat m n \\<and>\n                    Q' \\<in> carrier_mat n n;\n                    diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "case (1 bezout P A Q)"], ["proof (state)\nthis:\n  Pa__ \\<in> carrier_mat m m \\<and>\n  Aa__ \\<in> carrier_mat m n \\<and> Qa__ \\<in> carrier_mat n n\n  diagonal_to_Smith_aux_PQ_JNF [] bezout (Pa__, Aa__, Qa__) = (P, A, Q)\n\ngoal (2 subgoals):\n 1. \\<And>bezout P A Q Pa Aa Qa.\n       \\<lbrakk>P \\<in> carrier_mat m m \\<and>\n                A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF [] bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n\n 2. \\<And>i xs bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>P' A' Q' Pa Aa Qa.\n                   \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout\n                             (P, A, Q) =\n                            (P', A', Q');\n                    P' \\<in> carrier_mat m m \\<and>\n                    A' \\<in> carrier_mat m n \\<and>\n                    Q' \\<in> carrier_mat n n;\n                    diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "then"], ["proof (chain)\npicking this:\n  Pa__ \\<in> carrier_mat m m \\<and>\n  Aa__ \\<in> carrier_mat m n \\<and> Qa__ \\<in> carrier_mat n n\n  diagonal_to_Smith_aux_PQ_JNF [] bezout (Pa__, Aa__, Qa__) = (P, A, Q)", "show ?case"], ["proof (prove)\nusing this:\n  Pa__ \\<in> carrier_mat m m \\<and>\n  Aa__ \\<in> carrier_mat m n \\<and> Qa__ \\<in> carrier_mat n n\n  diagonal_to_Smith_aux_PQ_JNF [] bezout (Pa__, Aa__, Qa__) = (P, A, Q)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "by simp"], ["proof (state)\nthis:\n  P \\<in> carrier_mat m m \\<and>\n  A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>i xs bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>P' A' Q' Pa Aa Qa.\n                   \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout\n                             (P, A, Q) =\n                            (P', A', Q');\n                    P' \\<in> carrier_mat m m \\<and>\n                    A' \\<in> carrier_mat m n \\<and>\n                    Q' \\<in> carrier_mat n n;\n                    diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>P' A' Q' Pa Aa Qa.\n                   \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout\n                             (P, A, Q) =\n                            (P', A', Q');\n                    P' \\<in> carrier_mat m m \\<and>\n                    A' \\<in> carrier_mat m n \\<and>\n                    Q' \\<in> carrier_mat n n;\n                    diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "case (2 i xs bezout P' A' Q')"], ["proof (state)\nthis:\n  \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q') =\n           (?P', ?A', ?Q');\n   ?P' \\<in> carrier_mat m m \\<and>\n   ?A' \\<in> carrier_mat m n \\<and> ?Q' \\<in> carrier_mat n n;\n   diagonal_to_Smith_aux_PQ_JNF xs bezout (?P', ?A', ?Q') =\n   (?P, ?A, ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?P \\<in> carrier_mat m m \\<and>\n                    ?A \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n  P' \\<in> carrier_mat m m \\<and>\n  A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\n  diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P', A', Q') = (P, A, Q)\n\ngoal (1 subgoal):\n 1. \\<And>i xs bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>P' A' Q' Pa Aa Qa.\n                   \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout\n                             (P, A, Q) =\n                            (P', A', Q');\n                    P' \\<in> carrier_mat m m \\<and>\n                    A' \\<in> carrier_mat m n \\<and>\n                    Q' \\<in> carrier_mat n n;\n                    diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "let ?D=\"(Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>P' A' Q' Pa Aa Qa.\n                   \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout\n                             (P, A, Q) =\n                            (P', A', Q');\n                    P' \\<in> carrier_mat m m \\<and>\n                    A' \\<in> carrier_mat m n \\<and>\n                    Q' \\<in> carrier_mat n n;\n                    diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "have \"diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P', A', Q') = \n      diagonal_to_Smith_aux_PQ_JNF xs bezout ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P', A', Q') =\n    diagonal_to_Smith_aux_PQ_JNF xs bezout\n     (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))", "by auto"], ["proof (state)\nthis:\n  diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P', A', Q') =\n  diagonal_to_Smith_aux_PQ_JNF xs bezout\n   (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))\n\ngoal (1 subgoal):\n 1. \\<And>i xs bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>P' A' Q' Pa Aa Qa.\n                   \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout\n                             (P, A, Q) =\n                            (P', A', Q');\n                    P' \\<in> carrier_mat m m \\<and>\n                    A' \\<in> carrier_mat m n \\<and>\n                    Q' \\<in> carrier_mat n n;\n                    diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "hence *: \"... = (P,A,Q)\""], ["proof (prove)\nusing this:\n  diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P', A', Q') =\n  diagonal_to_Smith_aux_PQ_JNF xs bezout\n   (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))\n\ngoal (1 subgoal):\n 1. diagonal_to_Smith_aux_PQ_JNF xs bezout\n     (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')) =\n    (P, A, Q)", "using 2"], ["proof (prove)\nusing this:\n  diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P', A', Q') =\n  diagonal_to_Smith_aux_PQ_JNF xs bezout\n   (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))\n  \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q') =\n           (?P', ?A', ?Q');\n   ?P' \\<in> carrier_mat m m \\<and>\n   ?A' \\<in> carrier_mat m n \\<and> ?Q' \\<in> carrier_mat n n;\n   diagonal_to_Smith_aux_PQ_JNF xs bezout (?P', ?A', ?Q') =\n   (?P, ?A, ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?P \\<in> carrier_mat m m \\<and>\n                    ?A \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n  P' \\<in> carrier_mat m m \\<and>\n  A' \\<in> carrier_mat m n \\<and> Q' \\<in> carrier_mat n n\n  diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P', A', Q') = (P, A, Q)\n\ngoal (1 subgoal):\n 1. diagonal_to_Smith_aux_PQ_JNF xs bezout\n     (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')) =\n    (P, A, Q)", "by auto"], ["proof (state)\nthis:\n  diagonal_to_Smith_aux_PQ_JNF xs bezout\n   (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')) =\n  (P, A, Q)\n\ngoal (1 subgoal):\n 1. \\<And>i xs bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>P' A' Q' Pa Aa Qa.\n                   \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout\n                             (P, A, Q) =\n                            (P', A', Q');\n                    P' \\<in> carrier_mat m m \\<and>\n                    A' \\<in> carrier_mat m n \\<and>\n                    Q' \\<in> carrier_mat n n;\n                    diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "let ?P=\"fst ?D\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>P' A' Q' Pa Aa Qa.\n                   \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout\n                             (P, A, Q) =\n                            (P', A', Q');\n                    P' \\<in> carrier_mat m m \\<and>\n                    A' \\<in> carrier_mat m n \\<and>\n                    Q' \\<in> carrier_mat n n;\n                    diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "let ?S=\"fst (snd ?D)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>P' A' Q' Pa Aa Qa.\n                   \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout\n                             (P, A, Q) =\n                            (P', A', Q');\n                    P' \\<in> carrier_mat m m \\<and>\n                    A' \\<in> carrier_mat m n \\<and>\n                    Q' \\<in> carrier_mat n n;\n                    diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "let ?Q=\"snd (snd ?D)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs bezout P A Q Pa Aa Qa.\n       \\<lbrakk>\\<And>P' A' Q' Pa Aa Qa.\n                   \\<lbrakk>Diagonal_to_Smith_row_i_PQ_JNF i bezout\n                             (P, A, Q) =\n                            (P', A', Q');\n                    P' \\<in> carrier_mat m m \\<and>\n                    A' \\<in> carrier_mat m n \\<and>\n                    Q' \\<in> carrier_mat n n;\n                    diagonal_to_Smith_aux_PQ_JNF xs bezout (P', A', Q') =\n                    (Pa, Aa, Qa)\\<rbrakk>\n                   \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                                     Aa \\<in> carrier_mat m n \\<and>\n                                     Qa \\<in> carrier_mat n n;\n        P \\<in> carrier_mat m m \\<and>\n        A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n;\n        diagonal_to_Smith_aux_PQ_JNF (i # xs) bezout (P, A, Q) =\n        (Pa, Aa, Qa)\\<rbrakk>\n       \\<Longrightarrow> Pa \\<in> carrier_mat m m \\<and>\n                         Aa \\<in> carrier_mat m n \\<and>\n                         Qa \\<in> carrier_mat n n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "proof (rule \"2.hyps\")"], ["proof (state)\ngoal (3 subgoals):\n 1. Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q') = (?P', ?A', ?Q')\n 2. ?P' \\<in> carrier_mat m m \\<and>\n    ?A' \\<in> carrier_mat m n \\<and> ?Q' \\<in> carrier_mat n n\n 3. diagonal_to_Smith_aux_PQ_JNF xs bezout (?P', ?A', ?Q') = (P, A, Q)", "show \"Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q') = (?P,?S,?Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q') =\n    (fst (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')),\n     fst (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))),\n     snd (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))))", "by auto"], ["proof (state)\nthis:\n  Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q') =\n  (fst (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')),\n   fst (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))),\n   snd (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))))\n\ngoal (2 subgoals):\n 1. fst (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))\n    \\<in> carrier_mat m m \\<and>\n    fst (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))\n    \\<in> carrier_mat m n \\<and>\n    snd (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))\n    \\<in> carrier_mat n n\n 2. diagonal_to_Smith_aux_PQ_JNF xs bezout\n     (fst (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')),\n      fst (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))),\n      snd (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))) =\n    (P, A, Q)", "show \"diagonal_to_Smith_aux_PQ_JNF xs bezout (?P, ?S, ?Q) = (P, A, Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_to_Smith_aux_PQ_JNF xs bezout\n     (fst (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')),\n      fst (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))),\n      snd (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))) =\n    (P, A, Q)", "using *"], ["proof (prove)\nusing this:\n  diagonal_to_Smith_aux_PQ_JNF xs bezout\n   (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')) =\n  (P, A, Q)\n\ngoal (1 subgoal):\n 1. diagonal_to_Smith_aux_PQ_JNF xs bezout\n     (fst (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')),\n      fst (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))),\n      snd (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))) =\n    (P, A, Q)", "by simp"], ["proof (state)\nthis:\n  diagonal_to_Smith_aux_PQ_JNF xs bezout\n   (fst (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')),\n    fst (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))),\n    snd (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))) =\n  (P, A, Q)\n\ngoal (1 subgoal):\n 1. fst (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))\n    \\<in> carrier_mat m m \\<and>\n    fst (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))\n    \\<in> carrier_mat m n \\<and>\n    snd (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))\n    \\<in> carrier_mat n n", "show \"?P \\<in> carrier_mat m m \\<and> ?S \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))\n    \\<in> carrier_mat m m \\<and>\n    fst (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))\n    \\<in> carrier_mat m n \\<and>\n    snd (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))\n    \\<in> carrier_mat n n", "by (rule Diagonal_to_Smith_row_i_PQ_JNF_dim, insert 2, auto)"], ["proof (state)\nthis:\n  fst (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q'))\n  \\<in> carrier_mat m m \\<and>\n  fst (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))\n  \\<in> carrier_mat m n \\<and>\n  snd (snd (Diagonal_to_Smith_row_i_PQ_JNF i bezout (P', A', Q')))\n  \\<in> carrier_mat n n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<in> carrier_mat m m \\<and>\n  A \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diagonal_to_Smith_PQ_JNF_dim:\n  assumes \"A \\<in> carrier_mat m n\" \n    and PSQ: \"diagonal_to_Smith_PQ_JNF A bezout = (P,S,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "by (rule diagonal_to_Smith_aux_PQ_JNF_dim, insert assms, \n      auto simp add: diagonal_to_Smith_PQ_JNF_def)"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma HMA_diagonal_to_Smith_PQ_JNF[transfer_rule]:\n \"((Mod_Type_Connect.HMA_M) ===> (=) ===> HMA_M3) (diagonal_to_Smith_PQ_JNF) (diagonal_to_Smith_PQ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=) ===> HMA_M3) diagonal_to_Smith_PQ_JNF\n     diagonal_to_Smith_PQ", "proof (intro rel_funI, clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "case (1 A A' _ bezout)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "let ?xs1 = \"[0..<min (dim_row A) (dim_col A) - 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "let ?xs2 = \"[0..<min (nrows A') (ncols A') - 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "let ?PAQ=\"(1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "have dr: \"dim_row A = CARD('c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A = CARD('c)", "using 1 Mod_Type_Connect.dim_row_transfer_rule"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n\ngoal (1 subgoal):\n 1. dim_row A = CARD('c)", "by blast"], ["proof (state)\nthis:\n  dim_row A = CARD('c)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "have dc: \"dim_col A = CARD('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col A = CARD('b)", "using 1 Mod_Type_Connect.dim_col_transfer_rule"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n\ngoal (1 subgoal):\n 1. dim_col A = CARD('b)", "by blast"], ["proof (state)\nthis:\n  dim_col A = CARD('b)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "have xs_eq: \"?xs1 = ?xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<min (dim_row A) (dim_col A) - 1] =\n    [0..<min (nrows A') (ncols A') - 1]", "by (simp add: dc dr ncols_def nrows_def)"], ["proof (state)\nthis:\n  [0..<min (dim_row A) (dim_col A) - 1] =\n  [0..<min (nrows A') (ncols A') - 1]\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "have j_xs: \"\\<forall>j\\<in>set ?xs1. j < min CARD('c) CARD('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>set [0..<min (dim_row A) (dim_col A) - 1].\n       j < min CARD('c) CARD('b)", "using dc dr less_imp_diff_less"], ["proof (prove)\nusing this:\n  dim_col A = CARD('b)\n  dim_row A = CARD('c)\n  ?j < ?k \\<Longrightarrow> ?j - ?n < ?k\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>set [0..<min (dim_row A) (dim_col A) - 1].\n       j < min CARD('c) CARD('b)", "by auto"], ["proof (state)\nthis:\n  \\<forall>j\\<in>set [0..<min (dim_row A) (dim_col A) - 1].\n     j < min CARD('c) CARD('b)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "let ?D_JNF = \"diagonal_to_Smith_aux_PQ_JNF ?xs1 bezout ?PAQ\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "let ?D_HA = \"diagonal_to_Smith_aux_PQ ?xs1 bezout (mat 1, A', mat 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "have mat_rel_init: \"HMA_M3 ?PAQ (mat 1, A', mat 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M3 (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\n     (mat (1::'a), A', mat (1::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. HMA_M3 (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\n     (mat (1::'a), A', mat (1::'a))", "have \"Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_row A)) (mat 1::'a^'c::mod_type^'c::mod_type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_row A)) (mat (1::'a))", "unfolding dr"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (1\\<^sub>m CARD('c)) (mat (1::'a))", "by (transfer_prover_start,transfer_step, auto)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_row A)) (mat (1::'a))\n\ngoal (1 subgoal):\n 1. HMA_M3 (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\n     (mat (1::'a), A', mat (1::'a))", "moreover"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_row A)) (mat (1::'a))\n\ngoal (1 subgoal):\n 1. HMA_M3 (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\n     (mat (1::'a), A', mat (1::'a))", "have \"Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_col A)) (mat 1::'a^'b::mod_type^'b::mod_type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_col A)) (mat (1::'a))", "unfolding dc"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (1\\<^sub>m CARD('b)) (mat (1::'a))", "by (transfer_prover_start,transfer_step, auto)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_col A)) (mat (1::'a))\n\ngoal (1 subgoal):\n 1. HMA_M3 (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\n     (mat (1::'a), A', mat (1::'a))", "ultimately"], ["proof (chain)\npicking this:\n  Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_row A)) (mat (1::'a))\n  Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_col A)) (mat (1::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_row A)) (mat (1::'a))\n  Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_col A)) (mat (1::'a))\n\ngoal (1 subgoal):\n 1. HMA_M3 (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\n     (mat (1::'a), A', mat (1::'a))", "using 1"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_row A)) (mat (1::'a))\n  Mod_Type_Connect.HMA_M (1\\<^sub>m (dim_col A)) (mat (1::'a))\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. HMA_M3 (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\n     (mat (1::'a), A', mat (1::'a))", "by auto"], ["proof (state)\nthis:\n  HMA_M3 (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\n   (mat (1::'a), A', mat (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  HMA_M3 (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\n   (mat (1::'a), A', mat (1::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "have \"HMA_M3 ?D_JNF ?D_HA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M3\n     (diagonal_to_Smith_aux_PQ_JNF [0..<min (dim_row A) (dim_col A) - 1]\n       bezout (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A)))\n     (diagonal_to_Smith_aux_PQ [0..<min (dim_row A) (dim_col A) - 1] bezout\n       (mat (1::'a), A', mat (1::'a)))", "using HMA_diagonal_to_Smith_aux_PQ_JNF[OF j_xs] mat_rel_init"], ["proof (prove)\nusing this:\n  ((=) ===> HMA_M3 ===> HMA_M3)\n   (diagonal_to_Smith_aux_PQ_JNF [0..<min (dim_row A) (dim_col A) - 1])\n   (diagonal_to_Smith_aux_PQ [0..<min (dim_row A) (dim_col A) - 1])\n  HMA_M3 (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\n   (mat (1::'a), A', mat (1::'a))\n\ngoal (1 subgoal):\n 1. HMA_M3\n     (diagonal_to_Smith_aux_PQ_JNF [0..<min (dim_row A) (dim_col A) - 1]\n       bezout (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A)))\n     (diagonal_to_Smith_aux_PQ [0..<min (dim_row A) (dim_col A) - 1] bezout\n       (mat (1::'a), A', mat (1::'a)))", "unfolding rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     x = y \\<longrightarrow>\n     (\\<forall>xa ya.\n         HMA_M3 xa ya \\<longrightarrow>\n         HMA_M3\n          (diagonal_to_Smith_aux_PQ_JNF\n            [0..<min (dim_row A) (dim_col A) - 1] x xa)\n          (diagonal_to_Smith_aux_PQ [0..<min (dim_row A) (dim_col A) - 1] y\n            ya))\n  HMA_M3 (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A))\n   (mat (1::'a), A', mat (1::'a))\n\ngoal (1 subgoal):\n 1. HMA_M3\n     (diagonal_to_Smith_aux_PQ_JNF [0..<min (dim_row A) (dim_col A) - 1]\n       bezout (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A)))\n     (diagonal_to_Smith_aux_PQ [0..<min (dim_row A) (dim_col A) - 1] bezout\n       (mat (1::'a), A', mat (1::'a)))", "by blast"], ["proof (state)\nthis:\n  HMA_M3\n   (diagonal_to_Smith_aux_PQ_JNF [0..<min (dim_row A) (dim_col A) - 1]\n     bezout (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A)))\n   (diagonal_to_Smith_aux_PQ [0..<min (dim_row A) (dim_col A) - 1] bezout\n     (mat (1::'a), A', mat (1::'a)))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       HMA_M3 (diagonal_to_Smith_PQ_JNF x ya) (diagonal_to_Smith_PQ y ya)", "then"], ["proof (chain)\npicking this:\n  HMA_M3\n   (diagonal_to_Smith_aux_PQ_JNF [0..<min (dim_row A) (dim_col A) - 1]\n     bezout (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A)))\n   (diagonal_to_Smith_aux_PQ [0..<min (dim_row A) (dim_col A) - 1] bezout\n     (mat (1::'a), A', mat (1::'a)))", "show ?case"], ["proof (prove)\nusing this:\n  HMA_M3\n   (diagonal_to_Smith_aux_PQ_JNF [0..<min (dim_row A) (dim_col A) - 1]\n     bezout (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A)))\n   (diagonal_to_Smith_aux_PQ [0..<min (dim_row A) (dim_col A) - 1] bezout\n     (mat (1::'a), A', mat (1::'a)))\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_PQ_JNF A bezout)\n     (diagonal_to_Smith_PQ A' bezout)", "using xs_eq"], ["proof (prove)\nusing this:\n  HMA_M3\n   (diagonal_to_Smith_aux_PQ_JNF [0..<min (dim_row A) (dim_col A) - 1]\n     bezout (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A)))\n   (diagonal_to_Smith_aux_PQ [0..<min (dim_row A) (dim_col A) - 1] bezout\n     (mat (1::'a), A', mat (1::'a)))\n  [0..<min (dim_row A) (dim_col A) - 1] =\n  [0..<min (nrows A') (ncols A') - 1]\n\ngoal (1 subgoal):\n 1. HMA_M3 (diagonal_to_Smith_PQ_JNF A bezout)\n     (diagonal_to_Smith_PQ A' bezout)", "unfolding diagonal_to_Smith_PQ_JNF_def diagonal_to_Smith_PQ_def"], ["proof (prove)\nusing this:\n  HMA_M3\n   (diagonal_to_Smith_aux_PQ_JNF [0..<min (dim_row A) (dim_col A) - 1]\n     bezout (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A)))\n   (diagonal_to_Smith_aux_PQ [0..<min (dim_row A) (dim_col A) - 1] bezout\n     (mat (1::'a), A', mat (1::'a)))\n  [0..<min (dim_row A) (dim_col A) - 1] =\n  [0..<min (nrows A') (ncols A') - 1]\n\ngoal (1 subgoal):\n 1. HMA_M3\n     (diagonal_to_Smith_aux_PQ_JNF [0..<min (dim_row A) (dim_col A) - 1]\n       bezout (1\\<^sub>m (dim_row A), A, 1\\<^sub>m (dim_col A)))\n     (diagonal_to_Smith_aux_PQ [0..<min (nrows A') (ncols A') - 1] bezout\n       (mat (1::'a), A', mat (1::'a)))", "by auto"], ["proof (state)\nthis:\n  HMA_M3 (diagonal_to_Smith_PQ_JNF A bezout)\n   (diagonal_to_Smith_PQ A' bezout)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Applying local type definitions\\<close>"], ["", "text \\<open>Now we get the soundness lemma in JNF, via the one in HOL Analysis. I need transfer rules \nand local type definitions.\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "private"], ["", "lemma diagonal_to_Smith_PQ_JNF_with_types:\n  assumes A: \"A \\<in> carrier_mat CARD('nr::mod_type) CARD('nc::mod_type)\"\n  and S: \"S \\<in> carrier_mat CARD('nr) CARD('nc)\"\n  and P: \"P \\<in> carrier_mat CARD('nr) CARD('nr)\"\n  and Q: \"Q \\<in> carrier_mat CARD('nc) CARD('nc)\"\n  and PSQ: \"diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q)\"\n  and d:\"isDiagonal_mat A\" and ib: \"is_bezout_ext bezout\"\nshows \"S = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "let ?P = \"Mod_Type_Connect.to_hma\\<^sub>m P::'a^'nr::mod_type^'nr::mod_type\""], ["proof (state)\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "let ?A = \"Mod_Type_Connect.to_hma\\<^sub>m A::'a^'nc::mod_type^'nr::mod_type\""], ["proof (state)\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "let ?Q = \"Mod_Type_Connect.to_hma\\<^sub>m Q::'a^'nc::mod_type^'nc::mod_type\""], ["proof (state)\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "let ?S = \"Mod_Type_Connect.to_hma\\<^sub>m S::'a^'nc::mod_type^'nr::mod_type\""], ["proof (state)\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M A ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A (Mod_Type_Connect.to_hma\\<^sub>m A)", "by (simp add: Mod_Type_Connect.HMA_M_def A)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A (Mod_Type_Connect.to_hma\\<^sub>m A)\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "moreover"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A (Mod_Type_Connect.to_hma\\<^sub>m A)\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M P ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M P (Mod_Type_Connect.to_hma\\<^sub>m P)", "by (simp add: Mod_Type_Connect.HMA_M_def P)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M P (Mod_Type_Connect.to_hma\\<^sub>m P)\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "moreover"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M P (Mod_Type_Connect.to_hma\\<^sub>m P)\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M Q ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M Q (Mod_Type_Connect.to_hma\\<^sub>m Q)", "by (simp add: Mod_Type_Connect.HMA_M_def Q)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M Q (Mod_Type_Connect.to_hma\\<^sub>m Q)\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "moreover"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M Q (Mod_Type_Connect.to_hma\\<^sub>m Q)\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M S ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M S (Mod_Type_Connect.to_hma\\<^sub>m S)", "by (simp add: Mod_Type_Connect.HMA_M_def S)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M S (Mod_Type_Connect.to_hma\\<^sub>m S)\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "ultimately"], ["proof (chain)\npicking this:\n  Mod_Type_Connect.HMA_M A (Mod_Type_Connect.to_hma\\<^sub>m A)\n  Mod_Type_Connect.HMA_M P (Mod_Type_Connect.to_hma\\<^sub>m P)\n  Mod_Type_Connect.HMA_M Q (Mod_Type_Connect.to_hma\\<^sub>m Q)\n  Mod_Type_Connect.HMA_M S (Mod_Type_Connect.to_hma\\<^sub>m S)", "have [transfer_rule]: \"HMA_M3 (P,S,Q) (?P,?S,?Q)\""], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M A (Mod_Type_Connect.to_hma\\<^sub>m A)\n  Mod_Type_Connect.HMA_M P (Mod_Type_Connect.to_hma\\<^sub>m P)\n  Mod_Type_Connect.HMA_M Q (Mod_Type_Connect.to_hma\\<^sub>m Q)\n  Mod_Type_Connect.HMA_M S (Mod_Type_Connect.to_hma\\<^sub>m S)\n\ngoal (1 subgoal):\n 1. HMA_M3 (P, S, Q)\n     (Mod_Type_Connect.to_hma\\<^sub>m P, Mod_Type_Connect.to_hma\\<^sub>m S,\n      Mod_Type_Connect.to_hma\\<^sub>m Q)", "by simp"], ["proof (state)\nthis:\n  HMA_M3 (P, S, Q)\n   (Mod_Type_Connect.to_hma\\<^sub>m P, Mod_Type_Connect.to_hma\\<^sub>m S,\n    Mod_Type_Connect.to_hma\\<^sub>m Q)\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "have [transfer_rule]: \"bezout = bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout = bezout", ".."], ["proof (state)\nthis:\n  bezout = bezout\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "have PSQ2: \"(?P,?S,?Q) = diagonal_to_Smith_PQ ?A bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.to_hma\\<^sub>m P, Mod_Type_Connect.to_hma\\<^sub>m S,\n     Mod_Type_Connect.to_hma\\<^sub>m Q) =\n    diagonal_to_Smith_PQ (Mod_Type_Connect.to_hma\\<^sub>m A) bezout", "by (transfer, insert PSQ, auto)"], ["proof (state)\nthis:\n  (Mod_Type_Connect.to_hma\\<^sub>m P, Mod_Type_Connect.to_hma\\<^sub>m S,\n   Mod_Type_Connect.to_hma\\<^sub>m Q) =\n  diagonal_to_Smith_PQ (Mod_Type_Connect.to_hma\\<^sub>m A) bezout\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "have \"?S = ?P**?A**?Q \\<and> invertible ?P \\<and> invertible ?Q \\<and> Smith_normal_form ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m S =\n    Mod_Type_Connect.to_hma\\<^sub>m P **\n    Mod_Type_Connect.to_hma\\<^sub>m A **\n    Mod_Type_Connect.to_hma\\<^sub>m Q \\<and>\n    invertible (Mod_Type_Connect.to_hma\\<^sub>m P) \\<and>\n    invertible (Mod_Type_Connect.to_hma\\<^sub>m Q) \\<and>\n    Smith_normal_form (Mod_Type_Connect.to_hma\\<^sub>m S)", "by (rule diagonal_to_Smith_PQ'[OF _ ib PSQ2], transfer, auto simp add: d)"], ["proof (state)\nthis:\n  Mod_Type_Connect.to_hma\\<^sub>m S =\n  Mod_Type_Connect.to_hma\\<^sub>m P ** Mod_Type_Connect.to_hma\\<^sub>m A **\n  Mod_Type_Connect.to_hma\\<^sub>m Q \\<and>\n  invertible (Mod_Type_Connect.to_hma\\<^sub>m P) \\<and>\n  invertible (Mod_Type_Connect.to_hma\\<^sub>m Q) \\<and>\n  Smith_normal_form (Mod_Type_Connect.to_hma\\<^sub>m S)\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "with this[untransferred]"], ["proof (chain)\npicking this:\n  S = P * A * Q \\<and>\n  invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\n  Mod_Type_Connect.to_hma\\<^sub>m S =\n  Mod_Type_Connect.to_hma\\<^sub>m P ** Mod_Type_Connect.to_hma\\<^sub>m A **\n  Mod_Type_Connect.to_hma\\<^sub>m Q \\<and>\n  invertible (Mod_Type_Connect.to_hma\\<^sub>m P) \\<and>\n  invertible (Mod_Type_Connect.to_hma\\<^sub>m Q) \\<and>\n  Smith_normal_form (Mod_Type_Connect.to_hma\\<^sub>m S)", "show ?thesis"], ["proof (prove)\nusing this:\n  S = P * A * Q \\<and>\n  invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\n  Mod_Type_Connect.to_hma\\<^sub>m S =\n  Mod_Type_Connect.to_hma\\<^sub>m P ** Mod_Type_Connect.to_hma\\<^sub>m A **\n  Mod_Type_Connect.to_hma\\<^sub>m Q \\<and>\n  invertible (Mod_Type_Connect.to_hma\\<^sub>m P) \\<and>\n  invertible (Mod_Type_Connect.to_hma\\<^sub>m Q) \\<and>\n  Smith_normal_form (Mod_Type_Connect.to_hma\\<^sub>m S)\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "by auto"], ["proof (state)\nthis:\n  S = P * A * Q \\<and>\n  invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma diagonal_to_Smith_PQ_JNF_mod_ring_with_types:\n  assumes A: \"A \\<in> carrier_mat CARD('nr::nontriv mod_ring) CARD('nc::nontriv mod_ring)\"\n  and S: \"S \\<in> carrier_mat CARD('nr mod_ring) CARD('nc mod_ring)\"\n  and P: \"P \\<in> carrier_mat CARD('nr mod_ring) CARD('nr mod_ring)\"\n  and Q: \"Q \\<in> carrier_mat CARD('nc mod_ring) CARD('nc mod_ring)\"\n  and PSQ: \"diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q)\"\n  and d:\"isDiagonal_mat A\" and ib: \"is_bezout_ext bezout\"\nshows \"S = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S", "by (rule diagonal_to_Smith_PQ_JNF_with_types[OF assms])"], ["", "(*I don't know how to internalize the sort constraint of 'nr and 'nc at once,\nso I do it in two steps.*)"], ["", "thm diagonal_to_Smith_PQ_JNF_mod_ring_with_types[unfolded CARD_mod_ring, \n      internalize_sort \"'nr::nontriv\"]"], ["", "private"], ["", "lemma diagonal_to_Smith_PQ_JNF_internalized_first:\n  \"class.nontriv TYPE('a::type) \\<Longrightarrow>\n  A \\<in> carrier_mat CARD('a) CARD('nc::nontriv) \\<Longrightarrow>\n  S \\<in> carrier_mat CARD('a) CARD('nc) \\<Longrightarrow>\n  P \\<in> carrier_mat CARD('a) CARD('a) \\<Longrightarrow>\n  Q \\<in> carrier_mat CARD('nc) CARD('nc) \\<Longrightarrow>\n  diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q) \\<Longrightarrow>\n  isDiagonal_mat A \\<Longrightarrow> is_bezout_ext bezout \\<Longrightarrow> \n  S = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class.nontriv TYPE('a); A \\<in> carrier_mat CARD('a) CARD('nc);\n     S \\<in> carrier_mat CARD('a) CARD('nc);\n     P \\<in> carrier_mat CARD('a) CARD('a);\n     Q \\<in> carrier_mat CARD('nc) CARD('nc);\n     diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q); isDiagonal_mat A;\n     is_bezout_ext bezout\\<rbrakk>\n    \\<Longrightarrow> S = P * A * Q \\<and>\n                      invertible_mat P \\<and>\n                      invertible_mat Q \\<and> Smith_normal_form_mat S", "using diagonal_to_Smith_PQ_JNF_mod_ring_with_types[unfolded CARD_mod_ring, \n      internalize_sort \"'nr::nontriv\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>class.nontriv TYPE(?'a);\n   ?A \\<in> carrier_mat CARD(?'a) CARD(?'c);\n   ?S \\<in> carrier_mat CARD(?'a) CARD(?'c);\n   ?P \\<in> carrier_mat CARD(?'a) CARD(?'a);\n   ?Q \\<in> carrier_mat CARD(?'c) CARD(?'c);\n   diagonal_to_Smith_PQ_JNF ?A ?bezout = (?P, ?S, ?Q); isDiagonal_mat ?A;\n   is_bezout_ext ?bezout\\<rbrakk>\n  \\<Longrightarrow> ?S = ?P * ?A * ?Q \\<and>\n                    invertible_mat ?P \\<and>\n                    invertible_mat ?Q \\<and> Smith_normal_form_mat ?S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>class.nontriv TYPE('a); A \\<in> carrier_mat CARD('a) CARD('nc);\n     S \\<in> carrier_mat CARD('a) CARD('nc);\n     P \\<in> carrier_mat CARD('a) CARD('a);\n     Q \\<in> carrier_mat CARD('nc) CARD('nc);\n     diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q); isDiagonal_mat A;\n     is_bezout_ext bezout\\<rbrakk>\n    \\<Longrightarrow> S = P * A * Q \\<and>\n                      invertible_mat P \\<and>\n                      invertible_mat Q \\<and> Smith_normal_form_mat S", "by blast"], ["", "private"], ["", "lemma diagonal_to_Smith_PQ_JNF_internalized:\n  \"class.nontriv TYPE('c::type) \\<Longrightarrow>\n  class.nontriv TYPE('a::type) \\<Longrightarrow>\n  A \\<in> carrier_mat CARD('a) CARD('c) \\<Longrightarrow>\n  S \\<in> carrier_mat CARD('a) CARD('c) \\<Longrightarrow>\n  P \\<in> carrier_mat CARD('a) CARD('a) \\<Longrightarrow>\n  Q \\<in> carrier_mat CARD('c) CARD('c) \\<Longrightarrow>\n  diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q) \\<Longrightarrow>\n  isDiagonal_mat A \\<Longrightarrow> is_bezout_ext bezout \\<Longrightarrow> \nS = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class.nontriv TYPE('c); class.nontriv TYPE('a);\n     A \\<in> carrier_mat CARD('a) CARD('c);\n     S \\<in> carrier_mat CARD('a) CARD('c);\n     P \\<in> carrier_mat CARD('a) CARD('a);\n     Q \\<in> carrier_mat CARD('c) CARD('c);\n     diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q); isDiagonal_mat A;\n     is_bezout_ext bezout\\<rbrakk>\n    \\<Longrightarrow> S = P * A * Q \\<and>\n                      invertible_mat P \\<and>\n                      invertible_mat Q \\<and> Smith_normal_form_mat S", "using diagonal_to_Smith_PQ_JNF_internalized_first[internalize_sort \"'nc::nontriv\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>class.nontriv TYPE(?'a); class.nontriv TYPE(?'aa);\n   ?A \\<in> carrier_mat CARD(?'aa) CARD(?'a);\n   ?S \\<in> carrier_mat CARD(?'aa) CARD(?'a);\n   ?P \\<in> carrier_mat CARD(?'aa) CARD(?'aa);\n   ?Q \\<in> carrier_mat CARD(?'a) CARD(?'a);\n   diagonal_to_Smith_PQ_JNF ?A ?bezout = (?P, ?S, ?Q); isDiagonal_mat ?A;\n   is_bezout_ext ?bezout\\<rbrakk>\n  \\<Longrightarrow> ?S = ?P * ?A * ?Q \\<and>\n                    invertible_mat ?P \\<and>\n                    invertible_mat ?Q \\<and> Smith_normal_form_mat ?S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>class.nontriv TYPE('c); class.nontriv TYPE('a);\n     A \\<in> carrier_mat CARD('a) CARD('c);\n     S \\<in> carrier_mat CARD('a) CARD('c);\n     P \\<in> carrier_mat CARD('a) CARD('a);\n     Q \\<in> carrier_mat CARD('c) CARD('c);\n     diagonal_to_Smith_PQ_JNF A bezout = (P, S, Q); isDiagonal_mat A;\n     is_bezout_ext bezout\\<rbrakk>\n    \\<Longrightarrow> S = P * A * Q \\<and>\n                      invertible_mat P \\<and>\n                      invertible_mat Q \\<and> Smith_normal_form_mat S", "by blast"], ["", "context\n  fixes m::nat and n::nat\n  assumes local_typedef1: \"\\<exists>(Rep :: ('b \\<Rightarrow> int)) Abs. type_definition Rep Abs {0..<m :: int}\"\n  assumes local_typedef2: \"\\<exists>(Rep :: ('c \\<Rightarrow> int)) Abs. type_definition Rep Abs {0..<n :: int}\"\n  and m: \"m>1\"\n  and n: \"n>1\"\nbegin"], ["", "lemma type_to_set1:\n  shows \"class.nontriv TYPE('b)\" (is ?a) and \"m=CARD('b)\" (is ?b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b) &&& m = CARD('b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. m = CARD('b)", "from local_typedef1"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<int m}", "obtain Rep::\"('b \\<Rightarrow> int)\" and Abs \n    where t: \"type_definition Rep Abs {0..<m :: int}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<int m}\n\ngoal (1 subgoal):\n 1. (\\<And>Rep Abs.\n        type_definition Rep Abs {0..<int m} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  type_definition Rep Abs {0..<int m}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. m = CARD('b)", "have \"card (UNIV :: 'b set) = card {0..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<m}", "using t type_definition.card"], ["proof (prove)\nusing this:\n  type_definition Rep Abs {0..<int m}\n  type_definition ?Rep ?Abs ?A \\<Longrightarrow> CARD(?'b) = card ?A\n\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<m}", "by fastforce"], ["proof (state)\nthis:\n  CARD('b) = card {0..<m}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. m = CARD('b)", "also"], ["proof (state)\nthis:\n  CARD('b) = card {0..<m}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. m = CARD('b)", "have \"... = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<m} = m", "by auto"], ["proof (state)\nthis:\n  card {0..<m} = m\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. m = CARD('b)", "finally"], ["proof (chain)\npicking this:\n  CARD('b) = m", "show ?b"], ["proof (prove)\nusing this:\n  CARD('b) = m\n\ngoal (1 subgoal):\n 1. m = CARD('b)", ".."], ["proof (state)\nthis:\n  m = CARD('b)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b)", "then"], ["proof (chain)\npicking this:\n  m = CARD('b)", "show ?a"], ["proof (prove)\nusing this:\n  m = CARD('b)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b)", "unfolding class.nontriv_def"], ["proof (prove)\nusing this:\n  m = CARD('b)\n\ngoal (1 subgoal):\n 1. 1 < CARD('b)", "using m"], ["proof (prove)\nusing this:\n  m = CARD('b)\n  1 < m\n\ngoal (1 subgoal):\n 1. 1 < CARD('b)", "by auto"], ["proof (state)\nthis:\n  class.nontriv TYPE('b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_to_set2:\n  shows \"class.nontriv TYPE('c)\" (is ?a) and \"n=CARD('c)\" (is ?b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.nontriv TYPE('c) &&& n = CARD('c)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. class.nontriv TYPE('c)\n 2. n = CARD('c)", "from local_typedef2"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<int n}", "obtain Rep::\"('c \\<Rightarrow> int)\" and Abs \n    where t: \"type_definition Rep Abs {0..<n :: int}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<int n}\n\ngoal (1 subgoal):\n 1. (\\<And>Rep Abs.\n        type_definition Rep Abs {0..<int n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  type_definition Rep Abs {0..<int n}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('c)\n 2. n = CARD('c)", "have \"card (UNIV :: 'c set) = card {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('c) = card {0..<n}", "using t type_definition.card"], ["proof (prove)\nusing this:\n  type_definition Rep Abs {0..<int n}\n  type_definition ?Rep ?Abs ?A \\<Longrightarrow> CARD(?'b) = card ?A\n\ngoal (1 subgoal):\n 1. CARD('c) = card {0..<n}", "by force"], ["proof (state)\nthis:\n  CARD('c) = card {0..<n}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('c)\n 2. n = CARD('c)", "also"], ["proof (state)\nthis:\n  CARD('c) = card {0..<n}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('c)\n 2. n = CARD('c)", "have \"... = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<n} = n", "by auto"], ["proof (state)\nthis:\n  card {0..<n} = n\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('c)\n 2. n = CARD('c)", "finally"], ["proof (chain)\npicking this:\n  CARD('c) = n", "show ?b"], ["proof (prove)\nusing this:\n  CARD('c) = n\n\ngoal (1 subgoal):\n 1. n = CARD('c)", ".."], ["proof (state)\nthis:\n  n = CARD('c)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('c)", "then"], ["proof (chain)\npicking this:\n  n = CARD('c)", "show ?a"], ["proof (prove)\nusing this:\n  n = CARD('c)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('c)", "unfolding class.nontriv_def"], ["proof (prove)\nusing this:\n  n = CARD('c)\n\ngoal (1 subgoal):\n 1. 1 < CARD('c)", "using n"], ["proof (prove)\nusing this:\n  n = CARD('c)\n  1 < n\n\ngoal (1 subgoal):\n 1. 1 < CARD('c)", "by auto"], ["proof (state)\nthis:\n  class.nontriv TYPE('c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diagonal_to_Smith_PQ_JNF_local_typedef:  \n  assumes A: \"isDiagonal_mat A\" and ib: \"is_bezout_ext bezout\"\n  and A_dim: \"A \\<in> carrier_mat m n\"\n  assumes PSQ: \"(P,S,Q) = diagonal_to_Smith_PQ_JNF A bezout\"\n  shows \"S = P*A*Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\n  \\<and> P \\<in> carrier_mat m m \\<and> S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    Smith_normal_form_mat S \\<and>\n    P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    Smith_normal_form_mat S \\<and>\n    P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "have dim_matrices: \"P \\<in> carrier_mat m m \\<and> S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "by (rule diagonal_to_Smith_PQ_JNF_dim[OF A_dim PSQ[symmetric]])"], ["proof (state)\nthis:\n  P \\<in> carrier_mat m m \\<and>\n  S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    Smith_normal_form_mat S \\<and>\n    P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    Smith_normal_form_mat S \\<and>\n    P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "using diagonal_to_Smith_PQ_JNF_internalized[where ?'c='c, where ?'a='b, \n      OF type_to_set2(1) type_to_set(1), of m A S P Q]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>Rep Abs. type_definition Rep Abs {0..<int m}; 1 < m;\n   A \\<in> carrier_mat CARD('b) CARD('c);\n   S \\<in> carrier_mat CARD('b) CARD('c);\n   P \\<in> carrier_mat CARD('b) CARD('b);\n   Q \\<in> carrier_mat CARD('c) CARD('c);\n   diagonal_to_Smith_PQ_JNF A ?bezout = (P, S, Q); isDiagonal_mat A;\n   is_bezout_ext ?bezout\\<rbrakk>\n  \\<Longrightarrow> S = P * A * Q \\<and>\n                    invertible_mat P \\<and>\n                    invertible_mat Q \\<and> Smith_normal_form_mat S\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    Smith_normal_form_mat S \\<and>\n    P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "unfolding type_to_set1(2)[symmetric] type_to_set2(2)[symmetric]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>Rep Abs. type_definition Rep Abs {0..<int m}; 1 < m;\n   A \\<in> carrier_mat m n; S \\<in> carrier_mat m n;\n   P \\<in> carrier_mat m m; Q \\<in> carrier_mat n n;\n   diagonal_to_Smith_PQ_JNF A ?bezout = (P, S, Q); isDiagonal_mat A;\n   is_bezout_ext ?bezout\\<rbrakk>\n  \\<Longrightarrow> S = P * A * Q \\<and>\n                    invertible_mat P \\<and>\n                    invertible_mat Q \\<and> Smith_normal_form_mat S\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    Smith_normal_form_mat S \\<and>\n    P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "using assms m dim_matrices local_typedef1"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>Rep Abs. type_definition Rep Abs {0..<int m}; 1 < m;\n   A \\<in> carrier_mat m n; S \\<in> carrier_mat m n;\n   P \\<in> carrier_mat m m; Q \\<in> carrier_mat n n;\n   diagonal_to_Smith_PQ_JNF A ?bezout = (P, S, Q); isDiagonal_mat A;\n   is_bezout_ext ?bezout\\<rbrakk>\n  \\<Longrightarrow> S = P * A * Q \\<and>\n                    invertible_mat P \\<and>\n                    invertible_mat Q \\<and> Smith_normal_form_mat S\n  isDiagonal_mat A\n  is_bezout_ext bezout\n  A \\<in> carrier_mat m n\n  (P, S, Q) = diagonal_to_Smith_PQ_JNF A bezout\n  1 < m\n  P \\<in> carrier_mat m m \\<and>\n  S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<int m}\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    Smith_normal_form_mat S \\<and>\n    P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  S = P * A * Q \\<and>\n  invertible_mat P \\<and>\n  invertible_mat Q \\<and>\n  Smith_normal_form_mat S \\<and>\n  P \\<in> carrier_mat m m \\<and>\n  S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "(*Canceling the first local type definitions (I was not able to cancel both in one step)*)"], ["", "context\nbegin"], ["", "private"], ["", "lemma diagonal_to_Smith_PQ_JNF_canceled_first:\n  \"\\<exists>Rep Abs. type_definition Rep Abs {0..<int n} \\<Longrightarrow> {0..<int m} \\<noteq> {} \\<Longrightarrow>\n  1 < m \\<Longrightarrow> 1 < n \\<Longrightarrow> isDiagonal_mat A \\<Longrightarrow> is_bezout_ext bezout \\<Longrightarrow>\n  A \\<in> carrier_mat m n \\<Longrightarrow> (P, S, Q) = diagonal_to_Smith_PQ_JNF A bezout \\<Longrightarrow>\n  S = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S \n  \\<and> P \\<in> carrier_mat m m \\<and> S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>Rep Abs. type_definition Rep Abs {0..<int n};\n     {0..<int m} \\<noteq> {}; 1 < m; 1 < n; isDiagonal_mat A;\n     is_bezout_ext bezout; A \\<in> carrier_mat m n;\n     (P, S, Q) = diagonal_to_Smith_PQ_JNF A bezout\\<rbrakk>\n    \\<Longrightarrow> S = P * A * Q \\<and>\n                      invertible_mat P \\<and>\n                      invertible_mat Q \\<and>\n                      Smith_normal_form_mat S \\<and>\n                      P \\<in> carrier_mat m m \\<and>\n                      S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "using diagonal_to_Smith_PQ_JNF_local_typedef[cancel_type_definition]"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<int ?m} \\<noteq> {};\n   \\<exists>Rep Abs. type_definition Rep Abs {0..<int ?n}; 1 < ?m; 1 < ?n;\n   isDiagonal_mat ?A; is_bezout_ext ?bezout; ?A \\<in> carrier_mat ?m ?n;\n   (?P, ?S, ?Q) = diagonal_to_Smith_PQ_JNF ?A ?bezout\\<rbrakk>\n  \\<Longrightarrow> ?S = ?P * ?A * ?Q \\<and>\n                    invertible_mat ?P \\<and>\n                    invertible_mat ?Q \\<and>\n                    Smith_normal_form_mat ?S \\<and>\n                    ?P \\<in> carrier_mat ?m ?m \\<and>\n                    ?S \\<in> carrier_mat ?m ?n \\<and>\n                    ?Q \\<in> carrier_mat ?n ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>Rep Abs. type_definition Rep Abs {0..<int n};\n     {0..<int m} \\<noteq> {}; 1 < m; 1 < n; isDiagonal_mat A;\n     is_bezout_ext bezout; A \\<in> carrier_mat m n;\n     (P, S, Q) = diagonal_to_Smith_PQ_JNF A bezout\\<rbrakk>\n    \\<Longrightarrow> S = P * A * Q \\<and>\n                      invertible_mat P \\<and>\n                      invertible_mat Q \\<and>\n                      Smith_normal_form_mat S \\<and>\n                      P \\<in> carrier_mat m m \\<and>\n                      S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "by blast"], ["", "(*Canceling the second*)\nprivate"], ["", "lemma diagonal_to_Smith_PQ_JNF_canceled_both:\n  \"{0..<int n} \\<noteq> {} \\<Longrightarrow> {0..<int m} \\<noteq> {} \\<Longrightarrow> 1 < m \\<Longrightarrow> 1 < n \\<Longrightarrow>\n  isDiagonal_mat A \\<Longrightarrow> is_bezout_ext bezout \\<Longrightarrow> A \\<in> carrier_mat m n \\<Longrightarrow>\n  (P, S, Q) = diagonal_to_Smith_PQ_JNF A bezout \\<Longrightarrow> S = P * A * Q \\<and>\n  invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S \n  \\<and> P \\<in> carrier_mat m m \\<and> S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{0..<int n} \\<noteq> {}; {0..<int m} \\<noteq> {}; 1 < m; 1 < n;\n     isDiagonal_mat A; is_bezout_ext bezout; A \\<in> carrier_mat m n;\n     (P, S, Q) = diagonal_to_Smith_PQ_JNF A bezout\\<rbrakk>\n    \\<Longrightarrow> S = P * A * Q \\<and>\n                      invertible_mat P \\<and>\n                      invertible_mat Q \\<and>\n                      Smith_normal_form_mat S \\<and>\n                      P \\<in> carrier_mat m m \\<and>\n                      S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "using diagonal_to_Smith_PQ_JNF_canceled_first[cancel_type_definition]"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<int ?n} \\<noteq> {}; {0..<int ?m} \\<noteq> {}; 1 < ?m;\n   1 < ?n; isDiagonal_mat ?A; is_bezout_ext ?bezout;\n   ?A \\<in> carrier_mat ?m ?n;\n   (?P, ?S, ?Q) = diagonal_to_Smith_PQ_JNF ?A ?bezout\\<rbrakk>\n  \\<Longrightarrow> ?S = ?P * ?A * ?Q \\<and>\n                    invertible_mat ?P \\<and>\n                    invertible_mat ?Q \\<and>\n                    Smith_normal_form_mat ?S \\<and>\n                    ?P \\<in> carrier_mat ?m ?m \\<and>\n                    ?S \\<in> carrier_mat ?m ?n \\<and>\n                    ?Q \\<in> carrier_mat ?n ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{0..<int n} \\<noteq> {}; {0..<int m} \\<noteq> {}; 1 < m; 1 < n;\n     isDiagonal_mat A; is_bezout_ext bezout; A \\<in> carrier_mat m n;\n     (P, S, Q) = diagonal_to_Smith_PQ_JNF A bezout\\<rbrakk>\n    \\<Longrightarrow> S = P * A * Q \\<and>\n                      invertible_mat P \\<and>\n                      invertible_mat Q \\<and>\n                      Smith_normal_form_mat S \\<and>\n                      P \\<in> carrier_mat m m \\<and>\n                      S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "by blast"], ["", "subsection \\<open>The final result\\<close>"], ["", "lemma diagonal_to_Smith_PQ_JNF:  \n  assumes A: \"isDiagonal_mat A\" and ib: \"is_bezout_ext bezout\"\n  and \"A \\<in> carrier_mat m n\" \n  and PBQ: \"(P,S,Q) = diagonal_to_Smith_PQ_JNF A bezout\" \n(*The following two assumptions appear since mod_type requires 1<CARD. \nThose cases could be treated separately.*)\n  and n: \"n>1\" and m: \"m>1\" \n  shows \"S = P*A*Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat S\n  \\<and> P \\<in> carrier_mat m m \\<and> S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    Smith_normal_form_mat S \\<and>\n    P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "using diagonal_to_Smith_PQ_JNF_canceled_both[OF _ _ m n]"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<int n} \\<noteq> {}; {0..<int m} \\<noteq> {};\n   isDiagonal_mat ?A; is_bezout_ext ?bezout; ?A \\<in> carrier_mat m n;\n   (?P, ?S, ?Q) = diagonal_to_Smith_PQ_JNF ?A ?bezout\\<rbrakk>\n  \\<Longrightarrow> ?S = ?P * ?A * ?Q \\<and>\n                    invertible_mat ?P \\<and>\n                    invertible_mat ?Q \\<and>\n                    Smith_normal_form_mat ?S \\<and>\n                    ?P \\<in> carrier_mat m m \\<and>\n                    ?S \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    Smith_normal_form_mat S \\<and>\n    P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<int n} \\<noteq> {}; {0..<int m} \\<noteq> {};\n   isDiagonal_mat ?A; is_bezout_ext ?bezout; ?A \\<in> carrier_mat m n;\n   (?P, ?S, ?Q) = diagonal_to_Smith_PQ_JNF ?A ?bezout\\<rbrakk>\n  \\<Longrightarrow> ?S = ?P * ?A * ?Q \\<and>\n                    invertible_mat ?P \\<and>\n                    invertible_mat ?Q \\<and>\n                    Smith_normal_form_mat ?S \\<and>\n                    ?P \\<in> carrier_mat m m \\<and>\n                    ?S \\<in> carrier_mat m n \\<and> ?Q \\<in> carrier_mat n n\n  isDiagonal_mat A\n  is_bezout_ext bezout\n  A \\<in> carrier_mat m n\n  (P, S, Q) = diagonal_to_Smith_PQ_JNF A bezout\n  1 < n\n  1 < m\n\ngoal (1 subgoal):\n 1. S = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    Smith_normal_form_mat S \\<and>\n    P \\<in> carrier_mat m m \\<and>\n    S \\<in> carrier_mat m n \\<and> Q \\<in> carrier_mat n n", "by force"], ["", "end"], ["", "end"]]}