{"file_name": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form/Finite_Field_Mod_Type_Connection.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form", "problem_names": ["lemma strict_mono_to_int_mod_ring: \"strict_mono to_int_mod_ring\""], "translations": [["", "lemma strict_mono_to_int_mod_ring: \"strict_mono to_int_mod_ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono to_int_mod_ring", "unfolding strict_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x < y \\<longrightarrow> to_int_mod_ring x < to_int_mod_ring y", "unfolding less_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       to_int_mod_ring x < to_int_mod_ring y \\<longrightarrow>\n       to_int_mod_ring x < to_int_mod_ring y", "by auto"], ["", "instantiation mod_ring :: (nontriv) mod_type\nbegin"], ["", "definition Rep_mod_ring :: \"'a mod_ring \\<Rightarrow> int\"\n  where \"Rep_mod_ring x = to_int_mod_ring x\""], ["", "definition Abs_mod_ring :: \"int \\<Rightarrow> 'a mod_ring\"\n  where \"Abs_mod_ring x = of_int_mod_ring x\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mod_ring, mod_type_class)", "proof (intro_classes)"], ["proof (state)\ngoal (9 subgoals):\n 1. type_definition Rep Abs {0..<int CARD('a mod_ring)}\n 2. 1 < int CARD('a mod_ring)\n 3. 0 = Abs 0\n 4. 1 = Abs 1\n 5. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a mod_ring))\n 6. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a mod_ring))\n 7. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))\n 8. \\<And>x. - x = Abs (- Rep x mod int CARD('a mod_ring))\n 9. strict_mono Rep", "show \"type_definition (Rep::'a mod_ring \\<Rightarrow> int) Abs {0..<int CARD('a mod_ring)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition Rep Abs {0..<int CARD('a mod_ring)}", "unfolding Rep_mod_ring_def Abs_mod_ring_def type_definition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. to_int_mod_ring x \\<in> {0..<int CARD('a mod_ring)}) \\<and>\n    (\\<forall>x. of_int_mod_ring (to_int_mod_ring x) = x) \\<and>\n    (\\<forall>y.\n        y \\<in> {0..<int CARD('a mod_ring)} \\<longrightarrow>\n        to_int_mod_ring (of_int_mod_ring y) = y)", "by (transfer, auto)"], ["proof (state)\nthis:\n  type_definition Rep Abs {0..<int CARD('a mod_ring)}\n\ngoal (8 subgoals):\n 1. 1 < int CARD('a mod_ring)\n 2. 0 = Abs 0\n 3. 1 = Abs 1\n 4. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a mod_ring))\n 5. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a mod_ring))\n 6. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))\n 7. \\<And>x. - x = Abs (- Rep x mod int CARD('a mod_ring))\n 8. strict_mono Rep", "show \"1 < int CARD('a mod_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < int CARD('a mod_ring)", "using less_imp_of_nat_less nontriv"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> of_nat ?m < of_nat ?n\n  1 < CARD(?'a)\n\ngoal (1 subgoal):\n 1. 1 < int CARD('a mod_ring)", "by fastforce"], ["proof (state)\nthis:\n  1 < int CARD('a mod_ring)\n\ngoal (7 subgoals):\n 1. 0 = Abs 0\n 2. 1 = Abs 1\n 3. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a mod_ring))\n 4. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a mod_ring))\n 5. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))\n 6. \\<And>x. - x = Abs (- Rep x mod int CARD('a mod_ring))\n 7. strict_mono Rep", "show \"0 = (Abs::int \\<Rightarrow> 'a mod_ring) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = Abs 0", "by (simp add: Abs_mod_ring_def)"], ["proof (state)\nthis:\n  0 = Abs 0\n\ngoal (6 subgoals):\n 1. 1 = Abs 1\n 2. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a mod_ring))\n 3. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a mod_ring))\n 4. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))\n 5. \\<And>x. - x = Abs (- Rep x mod int CARD('a mod_ring))\n 6. strict_mono Rep", "show \"1 = (Abs::int \\<Rightarrow> 'a mod_ring) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = Abs 1", "by (metis (mono_tags, hide_lams) Abs_mod_ring_def of_int_hom.hom_one of_int_of_int_mod_ring)"], ["proof (state)\nthis:\n  1 = Abs 1\n\ngoal (5 subgoals):\n 1. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a mod_ring))\n 2. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a mod_ring))\n 3. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))\n 4. \\<And>x. - x = Abs (- Rep x mod int CARD('a mod_ring))\n 5. strict_mono Rep", "fix x y::\"'a mod_ring\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. x + y = Abs ((Rep x + Rep y) mod int CARD('a mod_ring))\n 2. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a mod_ring))\n 3. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))\n 4. \\<And>x. - x = Abs (- Rep x mod int CARD('a mod_ring))\n 5. strict_mono Rep", "show \"x + y = Abs ((Rep x + Rep y) mod int CARD('a mod_ring))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = Abs ((Rep x + Rep y) mod int CARD('a mod_ring))", "unfolding Abs_mod_ring_def Rep_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y =\n    of_int_mod_ring\n     ((to_int_mod_ring x + to_int_mod_ring y) mod int CARD('a mod_ring))", "by (transfer, auto)"], ["proof (state)\nthis:\n  x + y = Abs ((Rep x + Rep y) mod int CARD('a mod_ring))\n\ngoal (4 subgoals):\n 1. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a mod_ring))\n 2. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))\n 3. \\<And>x. - x = Abs (- Rep x mod int CARD('a mod_ring))\n 4. strict_mono Rep", "show \"- x = Abs (- Rep x mod int CARD('a mod_ring))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x = Abs (- Rep x mod int CARD('a mod_ring))", "unfolding Abs_mod_ring_def Rep_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - x = of_int_mod_ring (- to_int_mod_ring x mod int CARD('a mod_ring))", "by (transfer, auto simp add: zmod_zminus1_eq_if)"], ["proof (state)\nthis:\n  - x = Abs (- Rep x mod int CARD('a mod_ring))\n\ngoal (3 subgoals):\n 1. \\<And>x y. x * y = Abs (Rep x * Rep y mod int CARD('a mod_ring))\n 2. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))\n 3. strict_mono Rep", "show \"x * y = Abs (Rep x * Rep y mod int CARD('a mod_ring))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = Abs (Rep x * Rep y mod int CARD('a mod_ring))", "unfolding Abs_mod_ring_def Rep_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y =\n    of_int_mod_ring\n     (to_int_mod_ring x * to_int_mod_ring y mod int CARD('a mod_ring))", "by (transfer, auto)"], ["proof (state)\nthis:\n  x * y = Abs (Rep x * Rep y mod int CARD('a mod_ring))\n\ngoal (2 subgoals):\n 1. \\<And>x y. x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))\n 2. strict_mono Rep", "show \"x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))", "unfolding Abs_mod_ring_def Rep_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y =\n    of_int_mod_ring\n     ((to_int_mod_ring x - to_int_mod_ring y) mod int CARD('a mod_ring))", "by (transfer, auto)"], ["proof (state)\nthis:\n  x - y = Abs ((Rep x - Rep y) mod int CARD('a mod_ring))\n\ngoal (1 subgoal):\n 1. strict_mono Rep", "show \"strict_mono (Rep::'a mod_ring \\<Rightarrow> int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono Rep", "unfolding Rep_mod_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono to_int_mod_ring", "by (rule strict_mono_to_int_mod_ring)"], ["proof (state)\nthis:\n  strict_mono Rep\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}