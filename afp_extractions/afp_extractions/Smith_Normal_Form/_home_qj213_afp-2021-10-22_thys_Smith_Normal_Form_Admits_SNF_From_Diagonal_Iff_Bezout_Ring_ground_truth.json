{"file_name": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form/Admits_SNF_From_Diagonal_Iff_Bezout_Ring.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form", "problem_names": ["lemma exists_f_PAQ_Aii':\n  fixes A::\"'a::{comm_ring_1}^'n::{mod_type}^'n::{mod_type}\"\n  assumes diag_A: \"isDiagonal A\"\n  shows \"\\<exists>f. (P**A**Q) $h i $h i = (\\<Sum>i\\<in>(UNIV::'n set). f i * A $h i $h i)\"", "lemmas diagonal_to_Smith_PQ_exists_internalize_sort \n  = diagonal_to_Smith_PQ_exists[internalize_sort \"'a :: bezout_ring\"]", "lemma bezout_ring_imp_diagonal_admits_SNF:\n  assumes of: \"OFCLASS('a::comm_ring_1, bezout_ring_class)\"\n  shows \"\\<forall>A::'a^'n::{mod_type}^'n::{mod_type}. isDiagonal A \n    \\<longrightarrow> (\\<exists>P Q. \n        invertible (P::'a^'n::mod_type^'n::mod_type) \\<and> \n        invertible (Q::'a^'n::mod_type^'n::mod_type) \\<and> \n        Smith_normal_form (P**A**Q))\"", "lemma\n  assumes \"\\<forall>A::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type}. admits_SNF_HA A\"\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class)\"", "lemma exists_f_PAQ_Aii:\n  assumes diag_A: \"isDiagonal_mat (A::'a:: comm_ring_1 mat)\" \n    and P: \"P \\<in> carrier_mat n n\" \n    and A: \"A \\<in> carrier_mat n n\" \n    and Q: \"Q \\<in> carrier_mat n n\" \n    and i: \"i < n\" \n  (*  and d: \"distinct (diag_mat A)\" (*With some work, this assumption can be removed.*)*)\n  shows \"\\<exists>f. (P*A*Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)\"", "lemma diagonal_admits_SNF_imp_bezout_ring_JNF:\n  assumes admits_SNF: \"\\<forall>A n. (A::'a mat) \\<in> carrier_mat n n \\<and> isDiagonal_mat A\n  \\<longrightarrow> (\\<exists>P Q. P \\<in> carrier_mat n n \\<and> Q \\<in> carrier_mat n n \\<and> invertible_mat P \\<and> invertible_mat Q \n      \\<and> Smith_normal_form_mat (P*A*Q))\"\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class)\"", "lemma to_nat_mod_type_Bij_Nat:\n  fixes a::\"'n::mod_type\"\n  obtains b::'n where \"mod_type_class.to_nat a = Bij_Nat.to_nat b\"", "lemma inj_on_Bij_nat_from_nat: \"inj_on (Bij_Nat.from_nat::nat \\<Rightarrow> 'a) {0..<CARD('a::finite)}\"", "lemma Bij_Nat_to_nat_neq:\n  fixes a b ::\"'n::mod_type\"\n  assumes \"to_nat a \\<noteq> to_nat b\"\n  shows \"Bij_Nat.to_nat a \\<noteq> Bij_Nat.to_nat b\"", "lemma HMA_isDiagonal[transfer_rule]: \"(HMA_M ===> (=)) \n  isDiagonal_mat (isDiagonal::('a::{zero}^'n::{mod_type}^'n::{mod_type} => bool))\"", "lemma HMA_isDiagonal_Mod_Type[transfer_rule]: \"(Mod_Type_Connect.HMA_M ===> (=)) \n  isDiagonal_mat (isDiagonal::('a::{zero}^'n::{mod_type}^'m::{mod_type} => bool))\"", "lemma HMA_SNF[transfer_rule]: \"(Mod_Type_Connect.HMA_M ===> (=)) Smith_normal_form_mat \n(Smith_normal_form::'a::{comm_ring_1}^'n::{mod_type}^'m::{mod_type}\\<Rightarrow>bool)\"", "lemma HMA_admits_SNF [transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n::{mod_type} ^ 'n::{mod_type} \\<Rightarrow> _) ===> (=)) \n  admits_SNF_JNF admits_SNF_HA\"", "lemma diagonal_admits_SNF_imp_bezout_ring:\n  assumes admits_SNF: \"\\<forall>A::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type}. isDiagonal A \n    \\<longrightarrow> (\\<exists>P Q. invertible (P::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type}) \n        \\<and> invertible (Q::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type}) \n        \\<and> Smith_normal_form (P**A**Q))\"\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class)\"", "lemma bezout_ring_imp_diagonal_admits_SNF_mod_ring:\n  assumes of: \"OFCLASS('a::comm_ring_1, bezout_ring_class)\"\n  shows \"\\<forall>A::'a^'n::nontriv mod_ring^'n::nontriv mod_ring. isDiagonal A \n    \\<longrightarrow> (\\<exists>P Q. \n        invertible (P::'a^'n::nontriv mod_ring^'n::nontriv mod_ring) \\<and> \n        invertible (Q::'a^'n::nontriv mod_ring^'n::nontriv mod_ring) \\<and> \n        Smith_normal_form (P**A**Q))\"", "lemma bezout_ring_imp_diagonal_admits_SNF_mod_ring_admits: \n  assumes of: \"class.bezout_ring (*) (1::'a::comm_ring_1) (+) 0 (-) uminus\" (*It is equivalent to the statement based on OFCLASS*)\n  shows \"\\<forall>A::'a^'n::nontriv mod_ring^'n::nontriv mod_ring. admits_SNF_HA A\"", "lemma type_to_set:\n  shows \"class.nontriv TYPE('b)\" (is ?a) and \"p=CARD('b)\" (is ?b)", "lemma bezout_ring_imp_diagonal_admits_SNF_mod_ring_admits_aux:\n  assumes \"class.bezout_ring (*) (1::'a::comm_ring_1) (+) 0 (-) uminus\"\n  shows \"Ball {A::'a::comm_ring_1 mat. A \\<in> carrier_mat p p} admits_SNF_JNF\"", "lemma bezout_ring_imp_diagonal_admits_SNF_mod_ring_admits_aux2:\n  assumes of: \"class.bezout_ring (*) (1::'a::comm_ring_1) (+) 0 (-) uminus\"\n  shows \"\\<forall>(A::'a mat)\\<in>carrier_mat n n. admits_SNF_JNF A\"", "lemma bezout_ring_imp_diagonal_admits_SNF_JNF:\n  assumes of: \"class.bezout_ring (*) (1::'a::comm_ring_1) (+) 0 (-) uminus\"\n  shows \"\\<forall>A::'a mat. admits_SNF_JNF A\"", "lemma admits_SNF_JNF_alt_def:\n  \"(\\<forall>A::'a::comm_ring_1 mat. admits_SNF_JNF A) \n  = (\\<forall>A n. (A::'a mat) \\<in> carrier_mat n n \\<and> isDiagonal_mat A\n  \\<longrightarrow> (\\<exists>P Q. P \\<in> carrier_mat n n \\<and> Q \\<in> carrier_mat n n \\<and> invertible_mat P \\<and> invertible_mat Q \n      \\<and> Smith_normal_form_mat (P*A*Q)))\" (is \"?a = ?b\")", "theorem diagonal_admits_SNF_iff_bezout_ring:\n  shows \"class.bezout_ring (*) (1::'a::comm_ring_1) (+) 0 (-) uminus \n  \\<longleftrightarrow> (\\<forall>A::'a mat. admits_SNF_JNF A)\" (is \"?a \\<longleftrightarrow> ?b\")", "theorem diagonal_admits_SNF_iff_bezout_ring':\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class) \\<equiv> (\\<And>A::'a mat. admits_SNF_JNF A)\""], "translations": [["", "lemma exists_f_PAQ_Aii':\n  fixes A::\"'a::{comm_ring_1}^'n::{mod_type}^'n::{mod_type}\"\n  assumes diag_A: \"isDiagonal A\"\n  shows \"\\<exists>f. (P**A**Q) $h i $h i = (\\<Sum>i\\<in>(UNIV::'n set). f i * A $h i $h i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P ** A ** Q) $h i $h i = (\\<Sum>i\\<in>UNIV. f i * A $h i $h i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P ** A ** Q) $h i $h i = (\\<Sum>i\\<in>UNIV. f i * A $h i $h i)", "have rw: \"(\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) = P $h i $h k * A $h k $h k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n    P $h i $h k * A $h k $h k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n    P $h i $h k * A $h k $h k", "have \"(\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) = (\\<Sum>ka\\<in>{k}. P $h i $h ka * A $h ka $h k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n    (\\<Sum>ka\\<in>{k}. P $h i $h ka * A $h ka $h k)", "proof (rule sum.mono_neutral_right, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       P $h i $h ia * A $h ia $h k \\<noteq> (0::'a) \\<Longrightarrow> ia = k", "fix ia"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       P $h i $h ia * A $h ia $h k \\<noteq> (0::'a) \\<Longrightarrow> ia = k", "assume \"P $h i $h ia * A $h ia $h k \\<noteq> 0\""], ["proof (state)\nthis:\n  P $h i $h ia * A $h ia $h k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       P $h i $h ia * A $h ia $h k \\<noteq> (0::'a) \\<Longrightarrow> ia = k", "hence \"A $h ia $h k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  P $h i $h ia * A $h ia $h k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $h ia $h k \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $h ia $h k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       P $h i $h ia * A $h ia $h k \\<noteq> (0::'a) \\<Longrightarrow> ia = k", "thus\" ia = k\""], ["proof (prove)\nusing this:\n  A $h ia $h k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. ia = k", "using diag_A"], ["proof (prove)\nusing this:\n  A $h ia $h k \\<noteq> (0::'a)\n  isDiagonal A\n\ngoal (1 subgoal):\n 1. ia = k", "unfolding isDiagonal_def"], ["proof (prove)\nusing this:\n  A $h ia $h k \\<noteq> (0::'a)\n  \\<forall>a b.\n     to_nat a \\<noteq> to_nat b \\<longrightarrow> A $h a $h b = (0::'a)\n\ngoal (1 subgoal):\n 1. ia = k", "by auto"], ["proof (state)\nthis:\n  ia = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n  (\\<Sum>ka\\<in>{k}. P $h i $h ka * A $h ka $h k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n    P $h i $h k * A $h k $h k", "also"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n  (\\<Sum>ka\\<in>{k}. P $h i $h ka * A $h ka $h k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n    P $h i $h k * A $h k $h k", "have \"... = P $h i $h k * A $h k $h k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>{k}. P $h i $h ka * A $h ka $h k) =\n    P $h i $h k * A $h k $h k", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>{k}. P $h i $h ka * A $h ka $h k) =\n  P $h i $h k * A $h k $h k\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n    P $h i $h k * A $h k $h k", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n  P $h i $h k * A $h k $h k", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n  P $h i $h k * A $h k $h k\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n    P $h i $h k * A $h k $h k", "."], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) =\n  P $h i $h k * A $h k $h k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h ?k) =\n  P $h i $h ?k * A $h ?k $h ?k\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P ** A ** Q) $h i $h i = (\\<Sum>i\\<in>UNIV. f i * A $h i $h i)", "let ?f = \"\\<lambda>k. (\\<Sum>ka\\<in>UNIV. P $h i $h ka) * Q $h k $h i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P ** A ** Q) $h i $h i = (\\<Sum>i\\<in>UNIV. f i * A $h i $h i)", "have \"(P**A**Q) $h i $h i = (\\<Sum>k\\<in>UNIV. (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) * Q $h k $h i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P ** A ** Q) $h i $h i =\n    (\\<Sum>k\\<in>UNIV.\n       (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) * Q $h k $h i)", "unfolding matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j.\n        \\<Sum>k\\<in>UNIV.\n          (\\<chi>i j. \\<Sum>k\\<in>UNIV. P $h i $h k * A $h k $h j) $h i $h\n          k *\n          Q $h k $h j) $h\n    i $h\n    i =\n    (\\<Sum>k\\<in>UNIV.\n       (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) * Q $h k $h i)", "by auto"], ["proof (state)\nthis:\n  (P ** A ** Q) $h i $h i =\n  (\\<Sum>k\\<in>UNIV.\n     (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) * Q $h k $h i)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P ** A ** Q) $h i $h i = (\\<Sum>i\\<in>UNIV. f i * A $h i $h i)", "also"], ["proof (state)\nthis:\n  (P ** A ** Q) $h i $h i =\n  (\\<Sum>k\\<in>UNIV.\n     (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) * Q $h k $h i)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P ** A ** Q) $h i $h i = (\\<Sum>i\\<in>UNIV. f i * A $h i $h i)", "have \"... = (\\<Sum>k\\<in>UNIV.  P $h i $h k * Q $h k $h i * A $h k $h k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) * Q $h k $h i) =\n    (\\<Sum>k\\<in>UNIV. P $h i $h k * Q $h k $h i * A $h k $h k)", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. P $h i $h k * A $h k $h k * Q $h k $h i) =\n    (\\<Sum>k\\<in>UNIV. P $h i $h k * Q $h k $h i * A $h k $h k)", "by (meson semiring_normalization_rules(16))"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV.\n     (\\<Sum>ka\\<in>UNIV. P $h i $h ka * A $h ka $h k) * Q $h k $h i) =\n  (\\<Sum>k\\<in>UNIV. P $h i $h k * Q $h k $h i * A $h k $h k)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P ** A ** Q) $h i $h i = (\\<Sum>i\\<in>UNIV. f i * A $h i $h i)", "finally"], ["proof (chain)\npicking this:\n  (P ** A ** Q) $h i $h i =\n  (\\<Sum>k\\<in>UNIV. P $h i $h k * Q $h k $h i * A $h k $h k)", "show ?thesis"], ["proof (prove)\nusing this:\n  (P ** A ** Q) $h i $h i =\n  (\\<Sum>k\\<in>UNIV. P $h i $h k * Q $h k $h i * A $h k $h k)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P ** A ** Q) $h i $h i = (\\<Sum>i\\<in>UNIV. f i * A $h i $h i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>f.\n     (P ** A ** Q) $h i $h i = (\\<Sum>i\\<in>UNIV. f i * A $h i $h i)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*We would like to have the theorems within contexts:\n\ncontext semiring_1\nbegin\n\nlemma foo1:\n  fixes foo::\"'a::type\\<Rightarrow>'a\\<Rightarrow>'a\"\n  shows \"foo a = c\"\n  sorry\n\nend\n\nwhere 'a has simply type \"type\". This way, we could have \nthm semiring_1.foo\n\nWhich is: class.semiring_1 ?one ?times ?plus ?zero \\<Longrightarrow> ?foo ?a = ?c\n\nHowever, many of them are proven with type restrictions instead of being proved within a context.\nFor example:\n\nlemma foo2:\n  fixes foo::\"'a::semiring_1\\<Rightarrow>'a\\<Rightarrow>'a\"\n  shows \"foo a = c\" sorry\n\nTo convert foo2 to a statement like foo1, we need interalize_sort developed in From Types to Sets.\n\nlemmas foo2 = foo1[internalize_sort \"'a :: semiring_1\"]\n*)"], ["", "text \\<open>We apply @{text \"internalize_sort\"} to the lemma that we need\\<close>"], ["", "lemmas diagonal_to_Smith_PQ_exists_internalize_sort \n  = diagonal_to_Smith_PQ_exists[internalize_sort \"'a :: bezout_ring\"]"], ["", "text \\<open>We get the @{text \"\\<Longleftarrow>\"} implication in HA.\\<close>"], ["", "lemma bezout_ring_imp_diagonal_admits_SNF:\n  assumes of: \"OFCLASS('a::comm_ring_1, bezout_ring_class)\"\n  shows \"\\<forall>A::'a^'n::{mod_type}^'n::{mod_type}. isDiagonal A \n    \\<longrightarrow> (\\<exists>P Q. \n        invertible (P::'a^'n::mod_type^'n::mod_type) \\<and> \n        invertible (Q::'a^'n::mod_type^'n::mod_type) \\<and> \n        Smith_normal_form (P**A**Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       isDiagonal A \\<longrightarrow>\n       (\\<exists>P Q.\n           invertible P \\<and>\n           invertible Q \\<and> Smith_normal_form (P ** A ** Q))", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       isDiagonal A \\<Longrightarrow>\n       \\<exists>P Q.\n          invertible P \\<and>\n          invertible Q \\<and> Smith_normal_form (P ** A ** Q)", "fix A::\"'a^'n::{mod_type}^'n::{mod_type}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       isDiagonal A \\<Longrightarrow>\n       \\<exists>P Q.\n          invertible P \\<and>\n          invertible Q \\<and> Smith_normal_form (P ** A ** Q)", "assume A: \"isDiagonal A\""], ["proof (state)\nthis:\n  isDiagonal A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       isDiagonal A \\<Longrightarrow>\n       \\<exists>P Q.\n          invertible P \\<and>\n          invertible Q \\<and> Smith_normal_form (P ** A ** Q)", "have br: \"class.bezout_ring (*) (1::'a) (+) 0 (-) uminus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "by (rule OFCLASS_bezout_ring_imp_class_bezout_ring[OF of])"], ["proof (state)\nthis:\n  class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       isDiagonal A \\<Longrightarrow>\n       \\<exists>P Q.\n          invertible P \\<and>\n          invertible Q \\<and> Smith_normal_form (P ** A ** Q)", "show \"\\<exists>P Q. \n        invertible (P::'a^'n::mod_type^'n::mod_type) \\<and> \n        invertible (Q::'a^'n::mod_type^'n::mod_type) \\<and> \n        Smith_normal_form (P**A**Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P Q.\n       invertible P \\<and>\n       invertible Q \\<and> Smith_normal_form (P ** A ** Q)", "by (rule diagonal_to_Smith_PQ_exists_internalize_sort[OF br A])"], ["proof (state)\nthis:\n  \\<exists>P Q.\n     invertible P \\<and> invertible Q \\<and> Smith_normal_form (P ** A ** Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Trying to prove the @{text \"\\<Longrightarrow>\"} implication in HA.\\<close>"], ["", "text\\<open>There is a problem: we need to define a matrix with a concrete dimension, which is not \n  possible in HA (the dimension depends on the number of elements on a set, and Isabelle/HOL does\n  not feature dependent types)\\<close>"], ["", "lemma\n  assumes \"\\<forall>A::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type}. admits_SNF_HA A\"\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, bezout_ring_class)", "oops"], ["", "(*\nlemma   \n  assumes \"\\<forall>A::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type}. isDiagonal A \n    \\<longrightarrow> (\\<exists>P Q. invertible P \\<and> invertible Q \\<and> Smith_normal_form (P**A**Q))\"\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class)\"\nproof (rule all_fin_gen_ideals_are_principal_imp_bezout, rule allI, rule impI)\n  fix I::\"'a set\"\n  assume fin: \"finitely_generated_ideal I\"\n  obtain S where ig_S: \"ideal_generated S = I\" and fin_S: \"finite S\" \n    using fin unfolding finitely_generated_ideal_def by auto\n  obtain xs where set_xs: \"set xs = S\" and d: \"distinct xs\" \n    using finite_distinct_list[OF fin_S] by blast\n  hence length_eq_card: \"length xs = card S\" using distinct_card by force\n(*\n  The proof requires:\n  1) Obtain a matrix A whose diagonal entries are the elements of xs\n  2) Transform such a matrix A into its Smith normal form by means of elementary operations\n  3) Put the diagonal entries of the matrix in Smith normal form as a list ys.\n  4) Proof that the first element of ys divides all the other elements of such a list.\n  5) Show that, ideal_generated (set xs) = ideal_generated (set ys) = ideal_generated (ys!0).\n*)\n  show \"principal_ideal I\"\n\nqed\n\n(*Alternative statement (same problems)*)\n\nlemma   \n  assumes \"\\<forall>A::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type}. admits_SNF_HA A\"\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class)\" oops\n*)"], ["", "subsection \\<open>Proof of the  @{text \"\\<Longrightarrow>\"}  implication in JNF.\\<close>"], ["", "lemma exists_f_PAQ_Aii:\n  assumes diag_A: \"isDiagonal_mat (A::'a:: comm_ring_1 mat)\" \n    and P: \"P \\<in> carrier_mat n n\" \n    and A: \"A \\<in> carrier_mat n n\" \n    and Q: \"Q \\<in> carrier_mat n n\" \n    and i: \"i < n\" \n  (*  and d: \"distinct (diag_mat A)\" (*With some work, this assumption can be removed.*)*)\n  shows \"\\<exists>f. (P*A*Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "let ?xs = \"diag_mat A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "let ?n = \"length ?xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "have length_n: \"length (diag_mat A) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (diag_mat A) = n", "by (metis A carrier_matD(1) diag_mat_def diff_zero length_map length_upt)"], ["proof (state)\nthis:\n  length (diag_mat A) = n\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "have xs_index: \"?xs ! i = A $$ (i, i)\" if \"i<n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat A ! i = A $$ (i, i)", "by (metis (no_types, lifting) add.left_neutral diag_mat_def length_map \n        length_n length_upt nth_map_upt that)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> diag_mat A ! ?i = A $$ (?i, ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "have i_length: \"i<length ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (diag_mat A)", "using i length_n"], ["proof (prove)\nusing this:\n  i < n\n  length (diag_mat A) = n\n\ngoal (1 subgoal):\n 1. i < length (diag_mat A)", "by auto"], ["proof (state)\nthis:\n  i < length (diag_mat A)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "have rw: \"(\\<Sum>ka = 0..<?n. P $$ (i, ka) * A $$ (ka, k)) = P $$(i, k) * A $$ (k, k)\" \n    if k: \"k<length ?xs\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n    P $$ (i, k) * A $$ (k, k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n    P $$ (i, k) * A $$ (k, k)", "have \"(\\<Sum>ka= 0..<?n. P $$ (i, ka) * A $$ (ka, k)) = (\\<Sum>ka\\<in>{k}. P $$ (i, ka) * A $$ (ka, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n    (\\<Sum>ka\\<in>{k}. P $$ (i, ka) * A $$ (ka, k))", "by (rule sum.mono_neutral_right, auto simp add: k, \n          insert diag_A A length_n that, unfold isDiagonal_mat_def, fastforce)"], ["proof (state)\nthis:\n  (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n  (\\<Sum>ka\\<in>{k}. P $$ (i, ka) * A $$ (ka, k))\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n    P $$ (i, k) * A $$ (k, k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n  (\\<Sum>ka\\<in>{k}. P $$ (i, ka) * A $$ (ka, k))\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n    P $$ (i, k) * A $$ (k, k)", "have \"... = P $$(i, k) * A $$ (k, k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>{k}. P $$ (i, ka) * A $$ (ka, k)) =\n    P $$ (i, k) * A $$ (k, k)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>ka\\<in>{k}. P $$ (i, ka) * A $$ (ka, k)) =\n  P $$ (i, k) * A $$ (k, k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n    P $$ (i, k) * A $$ (k, k)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n  P $$ (i, k) * A $$ (k, k)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n  P $$ (i, k) * A $$ (k, k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n    P $$ (i, k) * A $$ (k, k)", "."], ["proof (state)\nthis:\n  (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) =\n  P $$ (i, k) * A $$ (k, k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k < length (diag_mat A) \\<Longrightarrow>\n  (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, ?k)) =\n  P $$ (i, ?k) * A $$ (?k, ?k)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "let ?positions_of =\"\\<lambda>x. {i. A$$(i,i) = x \\<and> i<length ?xs}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "let ?T=\"set ?xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "let ?S =\"{0..<?n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "let ?f = \"\\<lambda>x.(\\<Sum>k\\<in>{i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}. P $$ (i, k) * Q $$ (k, i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "let ?g = \"(\\<lambda>k. P $$ (i,k) * Q $$ (k, i) * A $$ (k, k))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "have UNION_positions_of: \"\\<Union>(?positions_of ` ?T) = ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>set (diag_mat A).\n        {i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}) =\n    {0..<length (diag_mat A)}", "unfolding diag_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>set (map (\\<lambda>i. A $$ (i, i)) [0..<dim_row A]).\n        {i. A $$ (i, i) = x \\<and>\n            i < length (map (\\<lambda>i. A $$ (i, i)) [0..<dim_row A])}) =\n    {0..<length (map (\\<lambda>i. A $$ (i, i)) [0..<dim_row A])}", "by auto"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>set (diag_mat A).\n      {i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}) =\n  {0..<length (diag_mat A)}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "have \"(P*A*Q) $$ (i,i) = (\\<Sum>ia = 0..<?n.\n        Matrix.row (Matrix.mat ?n ?n (\\<lambda>(i, j). \\<Sum>ia = 0..<?n. \n        Matrix.row P i $v ia * col A j $v ia)) i $v ia * col Q i $v ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P * A * Q) $$ (i, i) =\n    (\\<Sum>ia = 0..<length (diag_mat A).\n        Matrix.row\n         (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n           (\\<lambda>(i, j).\n               \\<Sum>ia = 0..<length (diag_mat A).\n                  Matrix.row P i $v ia * col A j $v ia))\n         i $v\n        ia *\n        col Q i $v ia)", "unfolding times_mat_def scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat\n     (dim_row\n       (Matrix.mat (dim_row P) (dim_col A)\n         (\\<lambda>(i, j).\n             \\<Sum>ia = 0..<dim_vec (col A j).\n                Matrix.row P i $v ia * col A j $v ia)))\n     (dim_col Q)\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<dim_vec (col Q j).\n            Matrix.row\n             (Matrix.mat (dim_row P) (dim_col A)\n               (\\<lambda>(i, j).\n                   \\<Sum>ia = 0..<dim_vec (col A j).\n                      Matrix.row P i $v ia * col A j $v ia))\n             i $v\n            ia *\n            col Q j $v ia) $$\n    (i, i) =\n    (\\<Sum>ia = 0..<length (diag_mat A).\n        Matrix.row\n         (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n           (\\<lambda>(i, j).\n               \\<Sum>ia = 0..<length (diag_mat A).\n                  Matrix.row P i $v ia * col A j $v ia))\n         i $v\n        ia *\n        col Q i $v ia)", "using P Q i_length length_n A"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  i < length (diag_mat A)\n  length (diag_mat A) = n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. Matrix.mat\n     (dim_row\n       (Matrix.mat (dim_row P) (dim_col A)\n         (\\<lambda>(i, j).\n             \\<Sum>ia = 0..<dim_vec (col A j).\n                Matrix.row P i $v ia * col A j $v ia)))\n     (dim_col Q)\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<dim_vec (col Q j).\n            Matrix.row\n             (Matrix.mat (dim_row P) (dim_col A)\n               (\\<lambda>(i, j).\n                   \\<Sum>ia = 0..<dim_vec (col A j).\n                      Matrix.row P i $v ia * col A j $v ia))\n             i $v\n            ia *\n            col Q j $v ia) $$\n    (i, i) =\n    (\\<Sum>ia = 0..<length (diag_mat A).\n        Matrix.row\n         (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n           (\\<lambda>(i, j).\n               \\<Sum>ia = 0..<length (diag_mat A).\n                  Matrix.row P i $v ia * col A j $v ia))\n         i $v\n        ia *\n        col Q i $v ia)", "by auto"], ["proof (state)\nthis:\n  (P * A * Q) $$ (i, i) =\n  (\\<Sum>ia = 0..<length (diag_mat A).\n      Matrix.row\n       (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n         (\\<lambda>(i, j).\n             \\<Sum>ia = 0..<length (diag_mat A).\n                Matrix.row P i $v ia * col A j $v ia))\n       i $v\n      ia *\n      col Q i $v ia)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "also"], ["proof (state)\nthis:\n  (P * A * Q) $$ (i, i) =\n  (\\<Sum>ia = 0..<length (diag_mat A).\n      Matrix.row\n       (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n         (\\<lambda>(i, j).\n             \\<Sum>ia = 0..<length (diag_mat A).\n                Matrix.row P i $v ia * col A j $v ia))\n       i $v\n      ia *\n      col Q i $v ia)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "have \"... = (\\<Sum>k = 0..<?n. (\\<Sum>ka = 0..<?n. P$$(i,ka) * A$$(ka,k)) * Q $$ (k,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<length (diag_mat A).\n        Matrix.row\n         (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n           (\\<lambda>(i, j).\n               \\<Sum>ia = 0..<length (diag_mat A).\n                  Matrix.row P i $v ia * col A j $v ia))\n         i $v\n        ia *\n        col Q i $v ia) =\n    (\\<Sum>k = 0..<length (diag_mat A).\n        (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) *\n        Q $$ (k, i))", "proof (rule sum.cong, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length (diag_mat A) \\<Longrightarrow>\n       Matrix.row\n        (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n          (\\<lambda>(i, j).\n              \\<Sum>ia = 0..<length (diag_mat A).\n                 Matrix.row P i $v ia * col A j $v ia))\n        i $v\n       x *\n       col Q i $v x =\n       (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, x)) *\n       Q $$ (x, i)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length (diag_mat A) \\<Longrightarrow>\n       Matrix.row\n        (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n          (\\<lambda>(i, j).\n              \\<Sum>ia = 0..<length (diag_mat A).\n                 Matrix.row P i $v ia * col A j $v ia))\n        i $v\n       x *\n       col Q i $v x =\n       (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, x)) *\n       Q $$ (x, i)", "assume x: \"x < length ?xs\""], ["proof (state)\nthis:\n  x < length (diag_mat A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length (diag_mat A) \\<Longrightarrow>\n       Matrix.row\n        (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n          (\\<lambda>(i, j).\n              \\<Sum>ia = 0..<length (diag_mat A).\n                 Matrix.row P i $v ia * col A j $v ia))\n        i $v\n       x *\n       col Q i $v x =\n       (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, x)) *\n       Q $$ (x, i)", "have rw_colQ: \"col Q i $v x = Q $$ (x, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col Q i $v x = Q $$ (x, i)", "using Q i_length x length_n A"], ["proof (prove)\nusing this:\n  Q \\<in> carrier_mat n n\n  i < length (diag_mat A)\n  x < length (diag_mat A)\n  length (diag_mat A) = n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. col Q i $v x = Q $$ (x, i)", "by auto"], ["proof (state)\nthis:\n  col Q i $v x = Q $$ (x, i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length (diag_mat A) \\<Longrightarrow>\n       Matrix.row\n        (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n          (\\<lambda>(i, j).\n              \\<Sum>ia = 0..<length (diag_mat A).\n                 Matrix.row P i $v ia * col A j $v ia))\n        i $v\n       x *\n       col Q i $v x =\n       (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, x)) *\n       Q $$ (x, i)", "have rw2: \" Matrix.row (Matrix.mat ?n ?n\n            (\\<lambda>(i, j). \\<Sum>ia = 0..<length ?xs. Matrix.row P i $v ia * col A j $v ia)) i $v x \n            =(\\<Sum>ia = 0..<length ?xs. Matrix.row P i $v ia * col A x $v ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.row\n     (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n       (\\<lambda>(i, j).\n           \\<Sum>ia = 0..<length (diag_mat A).\n              Matrix.row P i $v ia * col A j $v ia))\n     i $v\n    x =\n    (\\<Sum>ia = 0..<length (diag_mat A).\n        Matrix.row P i $v ia * col A x $v ia)", "unfolding row_mat[OF i_length]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec (length (diag_mat A))\n     (\\<lambda>j.\n         case (i, j) of\n         (i, j) \\<Rightarrow>\n           \\<Sum>ia = 0..<length (diag_mat A).\n              Matrix.row P i $v ia * col A j $v ia) $v\n    x =\n    (\\<Sum>ia = 0..<length (diag_mat A).\n        Matrix.row P i $v ia * col A x $v ia)", "unfolding index_vec[OF x]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (i, x) of\n     (i, j) \\<Rightarrow>\n       \\<Sum>ia = 0..<length (diag_mat A).\n          Matrix.row P i $v ia * col A j $v ia) =\n    (\\<Sum>ia = 0..<length (diag_mat A).\n        Matrix.row P i $v ia * col A x $v ia)", "by auto"], ["proof (state)\nthis:\n  Matrix.row\n   (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<length (diag_mat A).\n            Matrix.row P i $v ia * col A j $v ia))\n   i $v\n  x =\n  (\\<Sum>ia = 0..<length (diag_mat A). Matrix.row P i $v ia * col A x $v ia)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length (diag_mat A) \\<Longrightarrow>\n       Matrix.row\n        (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n          (\\<lambda>(i, j).\n              \\<Sum>ia = 0..<length (diag_mat A).\n                 Matrix.row P i $v ia * col A j $v ia))\n        i $v\n       x *\n       col Q i $v x =\n       (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, x)) *\n       Q $$ (x, i)", "also"], ["proof (state)\nthis:\n  Matrix.row\n   (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<length (diag_mat A).\n            Matrix.row P i $v ia * col A j $v ia))\n   i $v\n  x =\n  (\\<Sum>ia = 0..<length (diag_mat A). Matrix.row P i $v ia * col A x $v ia)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length (diag_mat A) \\<Longrightarrow>\n       Matrix.row\n        (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n          (\\<lambda>(i, j).\n              \\<Sum>ia = 0..<length (diag_mat A).\n                 Matrix.row P i $v ia * col A j $v ia))\n        i $v\n       x *\n       col Q i $v x =\n       (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, x)) *\n       Q $$ (x, i)", "have \"... = (\\<Sum>ia = 0..<length ?xs.  P $$ (i,ia) * A $$ (ia,x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<length (diag_mat A).\n        Matrix.row P i $v ia * col A x $v ia) =\n    (\\<Sum>ia = 0..<length (diag_mat A). P $$ (i, ia) * A $$ (ia, x))", "by (rule sum.cong, insert P i_length x length_n A, auto)"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<length (diag_mat A).\n      Matrix.row P i $v ia * col A x $v ia) =\n  (\\<Sum>ia = 0..<length (diag_mat A). P $$ (i, ia) * A $$ (ia, x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length (diag_mat A) \\<Longrightarrow>\n       Matrix.row\n        (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n          (\\<lambda>(i, j).\n              \\<Sum>ia = 0..<length (diag_mat A).\n                 Matrix.row P i $v ia * col A j $v ia))\n        i $v\n       x *\n       col Q i $v x =\n       (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, x)) *\n       Q $$ (x, i)", "finally"], ["proof (chain)\npicking this:\n  Matrix.row\n   (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<length (diag_mat A).\n            Matrix.row P i $v ia * col A j $v ia))\n   i $v\n  x =\n  (\\<Sum>ia = 0..<length (diag_mat A). P $$ (i, ia) * A $$ (ia, x))", "show \"Matrix.row (Matrix.mat ?n ?n (\\<lambda>(i, j). \\<Sum>ia = 0..<?n. Matrix.row P i $v ia \n            * col A j $v ia)) i $v x * col Q i $v x \n            = (\\<Sum>ka = 0..<?n. P $$ (i, ka) * A $$ (ka, x)) * Q $$ (x, i)\""], ["proof (prove)\nusing this:\n  Matrix.row\n   (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<length (diag_mat A).\n            Matrix.row P i $v ia * col A j $v ia))\n   i $v\n  x =\n  (\\<Sum>ia = 0..<length (diag_mat A). P $$ (i, ia) * A $$ (ia, x))\n\ngoal (1 subgoal):\n 1. Matrix.row\n     (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n       (\\<lambda>(i, j).\n           \\<Sum>ia = 0..<length (diag_mat A).\n              Matrix.row P i $v ia * col A j $v ia))\n     i $v\n    x *\n    col Q i $v x =\n    (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, x)) *\n    Q $$ (x, i)", "unfolding rw_colQ"], ["proof (prove)\nusing this:\n  Matrix.row\n   (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<length (diag_mat A).\n            Matrix.row P i $v ia * col A j $v ia))\n   i $v\n  x =\n  (\\<Sum>ia = 0..<length (diag_mat A). P $$ (i, ia) * A $$ (ia, x))\n\ngoal (1 subgoal):\n 1. Matrix.row\n     (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n       (\\<lambda>(i, j).\n           \\<Sum>ia = 0..<length (diag_mat A).\n              Matrix.row P i $v ia * col A j $v ia))\n     i $v\n    x *\n    Q $$ (x, i) =\n    (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, x)) *\n    Q $$ (x, i)", "by auto"], ["proof (state)\nthis:\n  Matrix.row\n   (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n     (\\<lambda>(i, j).\n         \\<Sum>ia = 0..<length (diag_mat A).\n            Matrix.row P i $v ia * col A j $v ia))\n   i $v\n  x *\n  col Q i $v x =\n  (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, x)) *\n  Q $$ (x, i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<length (diag_mat A).\n      Matrix.row\n       (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n         (\\<lambda>(i, j).\n             \\<Sum>ia = 0..<length (diag_mat A).\n                Matrix.row P i $v ia * col A j $v ia))\n       i $v\n      ia *\n      col Q i $v ia) =\n  (\\<Sum>k = 0..<length (diag_mat A).\n      (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) *\n      Q $$ (k, i))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<length (diag_mat A).\n      Matrix.row\n       (Matrix.mat (length (diag_mat A)) (length (diag_mat A))\n         (\\<lambda>(i, j).\n             \\<Sum>ia = 0..<length (diag_mat A).\n                Matrix.row P i $v ia * col A j $v ia))\n       i $v\n      ia *\n      col Q i $v ia) =\n  (\\<Sum>k = 0..<length (diag_mat A).\n      (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) *\n      Q $$ (k, i))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "have \"... = (\\<Sum>k = 0..<?n. P $$ (i,k) * Q $$ (k, i) * A $$ (k, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<length (diag_mat A).\n        (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) *\n        Q $$ (k, i)) =\n    (\\<Sum>k = 0..<length (diag_mat A).\n        P $$ (i, k) * Q $$ (k, i) * A $$ (k, k))", "by (smt rw semiring_normalization_rules(16) sum.ivl_cong)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length (diag_mat A).\n      (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) *\n      Q $$ (k, i)) =\n  (\\<Sum>k = 0..<length (diag_mat A).\n      P $$ (i, k) * Q $$ (k, i) * A $$ (k, k))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length (diag_mat A).\n      (\\<Sum>ka = 0..<length (diag_mat A). P $$ (i, ka) * A $$ (ka, k)) *\n      Q $$ (k, i)) =\n  (\\<Sum>k = 0..<length (diag_mat A).\n      P $$ (i, k) * Q $$ (k, i) * A $$ (k, k))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "have \"... = sum ?g (\\<Union>(?positions_of ` ?T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<length (diag_mat A).\n        P $$ (i, k) * Q $$ (k, i) * A $$ (k, k)) =\n    (\\<Sum>k\\<in>(\\<Union>x\\<in>set (diag_mat A).\n                     {i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}).\n       P $$ (i, k) * Q $$ (k, i) * A $$ (k, k))", "using UNION_positions_of"], ["proof (prove)\nusing this:\n  (\\<Union>x\\<in>set (diag_mat A).\n      {i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}) =\n  {0..<length (diag_mat A)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<length (diag_mat A).\n        P $$ (i, k) * Q $$ (k, i) * A $$ (k, k)) =\n    (\\<Sum>k\\<in>(\\<Union>x\\<in>set (diag_mat A).\n                     {i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}).\n       P $$ (i, k) * Q $$ (k, i) * A $$ (k, k))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length (diag_mat A).\n      P $$ (i, k) * Q $$ (k, i) * A $$ (k, k)) =\n  (\\<Sum>k\\<in>(\\<Union>x\\<in>set (diag_mat A).\n                   {i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}).\n     P $$ (i, k) * Q $$ (k, i) * A $$ (k, k))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length (diag_mat A).\n      P $$ (i, k) * Q $$ (k, i) * A $$ (k, k)) =\n  (\\<Sum>k\\<in>(\\<Union>x\\<in>set (diag_mat A).\n                   {i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}).\n     P $$ (i, k) * Q $$ (k, i) * A $$ (k, k))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "have \"... = (\\<Sum>x\\<in>?T. sum ?g (?positions_of x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>(\\<Union>x\\<in>set (diag_mat A).\n                     {i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}).\n       P $$ (i, k) * Q $$ (k, i) * A $$ (k, k)) =\n    (\\<Sum>x\\<in>set (diag_mat A).\n       \\<Sum>k\\<in>{i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}.\n         P $$ (i, k) * Q $$ (k, i) * A $$ (k, k))", "by (rule sum.UNION_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>(\\<Union>x\\<in>set (diag_mat A).\n                   {i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}).\n     P $$ (i, k) * Q $$ (k, i) * A $$ (k, k)) =\n  (\\<Sum>x\\<in>set (diag_mat A).\n     \\<Sum>k\\<in>{i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}.\n       P $$ (i, k) * Q $$ (k, i) * A $$ (k, k))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>(\\<Union>x\\<in>set (diag_mat A).\n                   {i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}).\n     P $$ (i, k) * Q $$ (k, i) * A $$ (k, k)) =\n  (\\<Sum>x\\<in>set (diag_mat A).\n     \\<Sum>k\\<in>{i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}.\n       P $$ (i, k) * Q $$ (k, i) * A $$ (k, k))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "have \"... = (\\<Sum>x\\<in>set (diag_mat A). (\\<Sum>k\\<in>{i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}. \n    P $$ (i, k) * Q $$ (k, i)) * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (diag_mat A).\n       \\<Sum>k\\<in>{i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}.\n         P $$ (i, k) * Q $$ (k, i) * A $$ (k, k)) =\n    (\\<Sum>x\\<in>set (diag_mat A).\n       (\\<Sum>k\\<in>{i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}.\n          P $$ (i, k) * Q $$ (k, i)) *\n       x)", "by (rule sum.cong, auto simp add: Groups_Big.sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (diag_mat A).\n     \\<Sum>k\\<in>{i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}.\n       P $$ (i, k) * Q $$ (k, i) * A $$ (k, k)) =\n  (\\<Sum>x\\<in>set (diag_mat A).\n     (\\<Sum>k\\<in>{i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}.\n        P $$ (i, k) * Q $$ (k, i)) *\n     x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "finally"], ["proof (chain)\npicking this:\n  (P * A * Q) $$ (i, i) =\n  (\\<Sum>x\\<in>set (diag_mat A).\n     (\\<Sum>k\\<in>{i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}.\n        P $$ (i, k) * Q $$ (k, i)) *\n     x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (P * A * Q) $$ (i, i) =\n  (\\<Sum>x\\<in>set (diag_mat A).\n     (\\<Sum>k\\<in>{i. A $$ (i, i) = x \\<and> i < length (diag_mat A)}.\n        P $$ (i, k) * Q $$ (k, i)) *\n     x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>f.\n     (P * A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat A). f i * i)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Proof of the @{text \"\\<Longrightarrow>\"} implication in JNF.\\<close>"], ["", "lemma diagonal_admits_SNF_imp_bezout_ring_JNF:\n  assumes admits_SNF: \"\\<forall>A n. (A::'a mat) \\<in> carrier_mat n n \\<and> isDiagonal_mat A\n  \\<longrightarrow> (\\<exists>P Q. P \\<in> carrier_mat n n \\<and> Q \\<in> carrier_mat n n \\<and> invertible_mat P \\<and> invertible_mat Q \n      \\<and> Smith_normal_form_mat (P*A*Q))\"\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, bezout_ring_class)", "proof (rule all_fin_gen_ideals_are_principal_imp_bezout, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I. finitely_generated_ideal I \\<Longrightarrow> principal_ideal I", "fix I::\"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I. finitely_generated_ideal I \\<Longrightarrow> principal_ideal I", "assume fin: \"finitely_generated_ideal I\""], ["proof (state)\nthis:\n  finitely_generated_ideal I\n\ngoal (1 subgoal):\n 1. \\<And>I. finitely_generated_ideal I \\<Longrightarrow> principal_ideal I", "obtain S where ig_S: \"ideal_generated S = I\" and fin_S: \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>ideal_generated S = I; finite S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using fin"], ["proof (prove)\nusing this:\n  finitely_generated_ideal I\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>ideal_generated S = I; finite S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding finitely_generated_ideal_def"], ["proof (prove)\nusing this:\n  ring_class.ideal I \\<and>\n  (\\<exists>S. finite S \\<and> ideal_generated S = I)\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>ideal_generated S = I; finite S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ideal_generated S = I\n  finite S\n\ngoal (1 subgoal):\n 1. \\<And>I. finitely_generated_ideal I \\<Longrightarrow> principal_ideal I", "show \"principal_ideal I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. principal_ideal I", "proof (cases \"S = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. S = {} \\<Longrightarrow> principal_ideal I\n 2. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "case True"], ["proof (state)\nthis:\n  S = {}\n\ngoal (2 subgoals):\n 1. S = {} \\<Longrightarrow> principal_ideal I\n 2. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "then"], ["proof (chain)\npicking this:\n  S = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  S = {}\n\ngoal (1 subgoal):\n 1. principal_ideal I", "by (metis ideal_generated_0 ideal_generated_empty ig_S principal_ideal_def)"], ["proof (state)\nthis:\n  principal_ideal I\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "case False"], ["proof (state)\nthis:\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "obtain xs where set_xs: \"set xs = S\" and d: \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>set xs = S; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_distinct_list[OF fin_S]"], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = S \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>set xs = S; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set xs = S\n  distinct xs\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "hence length_eq_card: \"length xs = card S\""], ["proof (prove)\nusing this:\n  set xs = S\n  distinct xs\n\ngoal (1 subgoal):\n 1. length xs = card S", "using distinct_card"], ["proof (prove)\nusing this:\n  set xs = S\n  distinct xs\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length xs = card S", "by force"], ["proof (state)\nthis:\n  length xs = card S\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "let ?n = \"length xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "let ?A = \"Matrix.mat ?n ?n (\\<lambda>(a,b). if a = b then xs!a else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have A_carrier: \"?A \\<in> carrier_mat ?n ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a))\n    \\<in> carrier_mat (length xs) (length xs)", "by auto"], ["proof (state)\nthis:\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a))\n  \\<in> carrier_mat (length xs) (length xs)\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have diag_A: \"isDiagonal_mat ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isDiagonal_mat\n     (Matrix.mat (length xs) (length xs)\n       (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)))", "unfolding isDiagonal_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i \\<noteq> j \\<and>\n       i < dim_row\n            (Matrix.mat (length xs) (length xs)\n              (\\<lambda>(a, b). if a = b then xs ! a else (0::'a))) \\<and>\n       j < dim_col\n            (Matrix.mat (length xs) (length xs)\n              (\\<lambda>(a, b).\n                  if a = b then xs ! a else (0::'a))) \\<longrightarrow>\n       Matrix.mat (length xs) (length xs)\n        (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n       (i, j) =\n       (0::'a)", "by auto"], ["proof (state)\nthis:\n  isDiagonal_mat\n   (Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)))\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have set_xs_eq: \"set xs = {?A$$(i,i)| i. i<dim_row ?A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs =\n    {Matrix.mat (length xs) (length xs)\n      (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n     (i, i) |\n     i. i < dim_row\n             (Matrix.mat (length xs) (length xs)\n               (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)))}", "by (auto, smt case_prod_conv d distinct_Ex1 index_mat(1))"], ["proof (state)\nthis:\n  set xs =\n  {Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n   (i, i) |\n   i. i < dim_row\n           (Matrix.mat (length xs) (length xs)\n             (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)))}\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have set_xs_diag_mat: \"set xs = set (diag_mat ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs =\n    set (diag_mat\n          (Matrix.mat (length xs) (length xs)\n            (\\<lambda>(a, b). if a = b then xs ! a else (0::'a))))", "using set_xs_eq"], ["proof (prove)\nusing this:\n  set xs =\n  {Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n   (i, i) |\n   i. i < dim_row\n           (Matrix.mat (length xs) (length xs)\n             (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)))}\n\ngoal (1 subgoal):\n 1. set xs =\n    set (diag_mat\n          (Matrix.mat (length xs) (length xs)\n            (\\<lambda>(a, b). if a = b then xs ! a else (0::'a))))", "unfolding diag_mat_def"], ["proof (prove)\nusing this:\n  set xs =\n  {Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n   (i, i) |\n   i. i < dim_row\n           (Matrix.mat (length xs) (length xs)\n             (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)))}\n\ngoal (1 subgoal):\n 1. set xs =\n    set (map (\\<lambda>i.\n                 Matrix.mat (length xs) (length xs)\n                  (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n                 (i, i))\n          [0..<\n           dim_row\n            (Matrix.mat (length xs) (length xs)\n              (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)))])", "by auto"], ["proof (state)\nthis:\n  set xs =\n  set (diag_mat\n        (Matrix.mat (length xs) (length xs)\n          (\\<lambda>(a, b). if a = b then xs ! a else (0::'a))))\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "obtain P Q where P: \"P \\<in> carrier_mat ?n ?n\" \n      and Q: \"Q \\<in> carrier_mat ?n ?n\" and inv_P: \"invertible_mat P\" and inv_Q: \"invertible_mat Q\"\n      and SNF_PAQ: \"Smith_normal_form_mat (P*?A*Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>P \\<in> carrier_mat (length xs) (length xs);\n         Q \\<in> carrier_mat (length xs) (length xs); invertible_mat P;\n         invertible_mat Q;\n         Smith_normal_form_mat\n          (P *\n           Matrix.mat (length xs) (length xs)\n            (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n           Q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using admits_SNF A_carrier diag_A"], ["proof (prove)\nusing this:\n  \\<forall>A n.\n     A \\<in> carrier_mat n n \\<and> isDiagonal_mat A \\<longrightarrow>\n     (\\<exists>P Q.\n         P \\<in> carrier_mat n n \\<and>\n         Q \\<in> carrier_mat n n \\<and>\n         invertible_mat P \\<and>\n         invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a))\n  \\<in> carrier_mat (length xs) (length xs)\n  isDiagonal_mat\n   (Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)))\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>P \\<in> carrier_mat (length xs) (length xs);\n         Q \\<in> carrier_mat (length xs) (length xs); invertible_mat P;\n         invertible_mat Q;\n         Smith_normal_form_mat\n          (P *\n           Matrix.mat (length xs) (length xs)\n            (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n           Q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<in> carrier_mat (length xs) (length xs)\n  Q \\<in> carrier_mat (length xs) (length xs)\n  invertible_mat P\n  invertible_mat Q\n  Smith_normal_form_mat\n   (P *\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n    Q)\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "define ys where ys_def: \"ys = diag_mat (P*?A*Q)\""], ["proof (state)\nthis:\n  ys =\n  diag_mat\n   (P *\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n    Q)\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have ys: \"\\<forall>i<?n. ys ! i = (P*?A*Q) $$ (i,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length xs.\n       ys ! i =\n       (P *\n        Matrix.mat (length xs) (length xs)\n         (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n        Q) $$\n       (i, i)", "using P"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat (length xs) (length xs)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length xs.\n       ys ! i =\n       (P *\n        Matrix.mat (length xs) (length xs)\n         (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n        Q) $$\n       (i, i)", "by (auto simp add: ys_def diag_mat_def)"], ["proof (state)\nthis:\n  \\<forall>i<length xs.\n     ys ! i =\n     (P *\n      Matrix.mat (length xs) (length xs)\n       (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n      Q) $$\n     (i, i)\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have length_ys: \"length ys = ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length xs", "unfolding ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (diag_mat\n       (P *\n        Matrix.mat (length xs) (length xs)\n         (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n        Q)) =\n    length xs", "by (metis (no_types, lifting) P carrier_matD(1) diag_mat_def \n          index_mult_mat(2) length_map map_nth)"], ["proof (state)\nthis:\n  length ys = length xs\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have n0: \"?n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length xs", "using False set_xs"], ["proof (prove)\nusing this:\n  S \\<noteq> {}\n  set xs = S\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by blast"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have set_ys_diag_mat: \"set ys = set (diag_mat (P*?A*Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys =\n    set (diag_mat\n          (P *\n           Matrix.mat (length xs) (length xs)\n            (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n           Q))", "using ys_def"], ["proof (prove)\nusing this:\n  ys =\n  diag_mat\n   (P *\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n    Q)\n\ngoal (1 subgoal):\n 1. set ys =\n    set (diag_mat\n          (P *\n           Matrix.mat (length xs) (length xs)\n            (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n           Q))", "by auto"], ["proof (state)\nthis:\n  set ys =\n  set (diag_mat\n        (P *\n         Matrix.mat (length xs) (length xs)\n          (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n         Q))\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "let ?i = \"ys ! 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have dvd_all: \"\\<forall>a \\<in> set ys. ?i dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set ys. ys ! 0 dvd a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> set ys \\<Longrightarrow> ys ! 0 dvd a", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> set ys \\<Longrightarrow> ys ! 0 dvd a", "assume a: \"a \\<in> set ys\""], ["proof (state)\nthis:\n  a \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> set ys \\<Longrightarrow> ys ! 0 dvd a", "obtain j where ys_j_a: \"ys ! j = a\" and jn: \"j<?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>ys ! j = a; j < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis a in_set_conv_nth length_ys)"], ["proof (state)\nthis:\n  ys ! j = a\n  j < length xs\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> set ys \\<Longrightarrow> ys ! 0 dvd a", "have jP: \"j < dim_row P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < dim_row P", "using jn P"], ["proof (prove)\nusing this:\n  j < length xs\n  P \\<in> carrier_mat (length xs) (length xs)\n\ngoal (1 subgoal):\n 1. j < dim_row P", "by auto"], ["proof (state)\nthis:\n  j < dim_row P\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> set ys \\<Longrightarrow> ys ! 0 dvd a", "have jQ: \"j < dim_col Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < dim_col Q", "using jn Q"], ["proof (prove)\nusing this:\n  j < length xs\n  Q \\<in> carrier_mat (length xs) (length xs)\n\ngoal (1 subgoal):\n 1. j < dim_col Q", "by auto"], ["proof (state)\nthis:\n  j < dim_col Q\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> set ys \\<Longrightarrow> ys ! 0 dvd a", "have \"(P*?A*Q)$$(0,0) dvd (P*?A*Q)$$(j,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P *\n     Matrix.mat (length xs) (length xs)\n      (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n     Q) $$\n    (0, 0) dvd\n    (P *\n     Matrix.mat (length xs) (length xs)\n      (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n     Q) $$\n    (j, j)", "by (rule SNF_first_divides[OF SNF_PAQ], auto simp add: jP jQ)"], ["proof (state)\nthis:\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (0, 0) dvd\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (j, j)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> set ys \\<Longrightarrow> ys ! 0 dvd a", "thus \"ys ! 0 dvd a\""], ["proof (prove)\nusing this:\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (0, 0) dvd\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (j, j)\n\ngoal (1 subgoal):\n 1. ys ! 0 dvd a", "using ys length_ys ys_j_a jn n0"], ["proof (prove)\nusing this:\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (0, 0) dvd\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (j, j)\n  \\<forall>i<length xs.\n     ys ! i =\n     (P *\n      Matrix.mat (length xs) (length xs)\n       (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n      Q) $$\n     (i, i)\n  length ys = length xs\n  ys ! j = a\n  j < length xs\n  0 < length xs\n\ngoal (1 subgoal):\n 1. ys ! 0 dvd a", "by auto"], ["proof (state)\nthis:\n  ys ! 0 dvd a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ys. ys ! 0 dvd a\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have \"ideal_generated S = ideal_generated (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal_generated S = ideal_generated (set xs)", "using set_xs"], ["proof (prove)\nusing this:\n  set xs = S\n\ngoal (1 subgoal):\n 1. ideal_generated S = ideal_generated (set xs)", "by simp"], ["proof (state)\nthis:\n  ideal_generated S = ideal_generated (set xs)\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "also"], ["proof (state)\nthis:\n  ideal_generated S = ideal_generated (set xs)\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have \"... = ideal_generated (set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal_generated (set xs) = ideal_generated (set ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ideal_generated (set xs) \\<subseteq> ideal_generated (set ys)\n 2. ideal_generated (set ys) \\<subseteq> ideal_generated (set xs)", "show \"ideal_generated (set xs) \\<subseteq> ideal_generated (set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal_generated (set xs) \\<subseteq> ideal_generated (set ys)", "proof (rule ideal_generated_subset2, rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "assume b: \"b \\<in> set xs\""], ["proof (state)\nthis:\n  b \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "obtain i where b_A_ii: \"b = ?A $$ (i,i)\" and i_length: \"i<length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>b =\n                 Matrix.mat (length xs) (length xs)\n                  (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n                 (i, i);\n         i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b set_xs_eq"], ["proof (prove)\nusing this:\n  b \\<in> set xs\n  set xs =\n  {Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n   (i, i) |\n   i. i < dim_row\n           (Matrix.mat (length xs) (length xs)\n             (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)))}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>b =\n                 Matrix.mat (length xs) (length xs)\n                  (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n                 (i, i);\n         i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b =\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n  (i, i)\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "obtain P' where inverts_mat_P': \"inverts_mat P P' \\<and> inverts_mat P' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        inverts_mat P P' \\<and> inverts_mat P' P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inv_P"], ["proof (prove)\nusing this:\n  invertible_mat P\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        inverts_mat P P' \\<and> inverts_mat P' P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding invertible_mat_def"], ["proof (prove)\nusing this:\n  square_mat P \\<and> (\\<exists>B. inverts_mat P B \\<and> inverts_mat B P)\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        inverts_mat P P' \\<and> inverts_mat P' P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  inverts_mat P P' \\<and> inverts_mat P' P\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "have P': \"P' \\<in> carrier_mat ?n ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<in> carrier_mat (length xs) (length xs)", "using inverts_mat_P'"], ["proof (prove)\nusing this:\n  inverts_mat P P' \\<and> inverts_mat P' P\n\ngoal (1 subgoal):\n 1. P' \\<in> carrier_mat (length xs) (length xs)", "unfolding carrier_mat_def inverts_mat_def"], ["proof (prove)\nusing this:\n  P * P' = 1\\<^sub>m (dim_row P) \\<and> P' * P = 1\\<^sub>m (dim_row P')\n\ngoal (1 subgoal):\n 1. P' \\<in> {m. dim_row m = length xs \\<and> dim_col m = length xs}", "by (auto,metis P carrier_matD index_mult_mat(3) one_carrier_mat)+"], ["proof (state)\nthis:\n  P' \\<in> carrier_mat (length xs) (length xs)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "obtain Q' where inverts_mat_Q': \"inverts_mat Q Q' \\<and> inverts_mat Q' Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q'.\n        inverts_mat Q Q' \\<and> inverts_mat Q' Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inv_Q"], ["proof (prove)\nusing this:\n  invertible_mat Q\n\ngoal (1 subgoal):\n 1. (\\<And>Q'.\n        inverts_mat Q Q' \\<and> inverts_mat Q' Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding invertible_mat_def"], ["proof (prove)\nusing this:\n  square_mat Q \\<and> (\\<exists>B. inverts_mat Q B \\<and> inverts_mat B Q)\n\ngoal (1 subgoal):\n 1. (\\<And>Q'.\n        inverts_mat Q Q' \\<and> inverts_mat Q' Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  inverts_mat Q Q' \\<and> inverts_mat Q' Q\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "have Q': \"Q' \\<in> carrier_mat ?n ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q' \\<in> carrier_mat (length xs) (length xs)", "using inverts_mat_Q'"], ["proof (prove)\nusing this:\n  inverts_mat Q Q' \\<and> inverts_mat Q' Q\n\ngoal (1 subgoal):\n 1. Q' \\<in> carrier_mat (length xs) (length xs)", "unfolding carrier_mat_def inverts_mat_def"], ["proof (prove)\nusing this:\n  Q * Q' = 1\\<^sub>m (dim_row Q) \\<and> Q' * Q = 1\\<^sub>m (dim_row Q')\n\ngoal (1 subgoal):\n 1. Q' \\<in> {m. dim_row m = length xs \\<and> dim_col m = length xs}", "by (auto,metis Q carrier_matD index_mult_mat(3) one_carrier_mat)+"], ["proof (state)\nthis:\n  Q' \\<in> carrier_mat (length xs) (length xs)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "have rw_PAQ: \"(P'*(P*?A*Q)*Q') $$ (i, i) = ?A $$ (i,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P' *\n     (P *\n      Matrix.mat (length xs) (length xs)\n       (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n      Q) *\n     Q') $$\n    (i, i) =\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n    (i, i)", "using inv_P'PAQQ'[OF A_carrier P _ _ Q P' Q'] inverts_mat_P' inverts_mat_Q'"], ["proof (prove)\nusing this:\n  \\<lbrakk>inverts_mat P' P; inverts_mat Q Q'\\<rbrakk>\n  \\<Longrightarrow> P' *\n                    (P *\n                     Matrix.mat (length xs) (length xs)\n                      (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n                     Q) *\n                    Q' =\n                    Matrix.mat (length xs) (length xs)\n                     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a))\n  inverts_mat P P' \\<and> inverts_mat P' P\n  inverts_mat Q Q' \\<and> inverts_mat Q' Q\n\ngoal (1 subgoal):\n 1. (P' *\n     (P *\n      Matrix.mat (length xs) (length xs)\n       (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n      Q) *\n     Q') $$\n    (i, i) =\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n    (i, i)", "by auto"], ["proof (state)\nthis:\n  (P' *\n   (P *\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n    Q) *\n   Q') $$\n  (i, i) =\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n  (i, i)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "have diag_PAQ: \"isDiagonal_mat (P*?A*Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isDiagonal_mat\n     (P *\n      Matrix.mat (length xs) (length xs)\n       (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n      Q)", "using SNF_PAQ"], ["proof (prove)\nusing this:\n  Smith_normal_form_mat\n   (P *\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n    Q)\n\ngoal (1 subgoal):\n 1. isDiagonal_mat\n     (P *\n      Matrix.mat (length xs) (length xs)\n       (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n      Q)", "unfolding Smith_normal_form_mat_def"], ["proof (prove)\nusing this:\n  (\\<forall>a.\n      a + 1\n      < min (dim_row\n              (P *\n               Matrix.mat (length xs) (length xs)\n                (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n               Q))\n         (dim_col\n           (P *\n            Matrix.mat (length xs) (length xs)\n             (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n            Q)) \\<longrightarrow>\n      (P *\n       Matrix.mat (length xs) (length xs)\n        (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n       Q) $$\n      (a, a) dvd\n      (P *\n       Matrix.mat (length xs) (length xs)\n        (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n       Q) $$\n      (a + 1, a + 1)) \\<and>\n  isDiagonal_mat\n   (P *\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n    Q)\n\ngoal (1 subgoal):\n 1. isDiagonal_mat\n     (P *\n      Matrix.mat (length xs) (length xs)\n       (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n      Q)", "by auto"], ["proof (state)\nthis:\n  isDiagonal_mat\n   (P *\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n    Q)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "have PAQ_carrier: \"(P*?A*Q) \\<in> carrier_mat ?n ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P *\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n    Q\n    \\<in> carrier_mat (length xs) (length xs)", "using P Q"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat (length xs) (length xs)\n  Q \\<in> carrier_mat (length xs) (length xs)\n\ngoal (1 subgoal):\n 1. P *\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n    Q\n    \\<in> carrier_mat (length xs) (length xs)", "by auto"], ["proof (state)\nthis:\n  P *\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n  Q\n  \\<in> carrier_mat (length xs) (length xs)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "obtain f where f: \"(P'*(P*?A*Q)*Q') $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat (P*?A*Q)). f i * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (P' *\n         (P *\n          Matrix.mat (length xs) (length xs)\n           (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n          Q) *\n         Q') $$\n        (i, i) =\n        (\\<Sum>i\\<in>set (diag_mat\n                           (P *\n                            Matrix.mat (length xs) (length xs)\n                             (\\<lambda>(a, b).\n                                 if a = b then xs ! a else (0::'a)) *\n                            Q)).\n           f i * i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using exists_f_PAQ_Aii[OF diag_PAQ P' PAQ_carrier Q' i_length]"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     (P' *\n      (P *\n       Matrix.mat (length xs) (length xs)\n        (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n       Q) *\n      Q') $$\n     (i, i) =\n     (\\<Sum>i\\<in>set (diag_mat\n                        (P *\n                         Matrix.mat (length xs) (length xs)\n                          (\\<lambda>(a, b).\n                              if a = b then xs ! a else (0::'a)) *\n                         Q)).\n        f i * i)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (P' *\n         (P *\n          Matrix.mat (length xs) (length xs)\n           (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n          Q) *\n         Q') $$\n        (i, i) =\n        (\\<Sum>i\\<in>set (diag_mat\n                           (P *\n                            Matrix.mat (length xs) (length xs)\n                             (\\<lambda>(a, b).\n                                 if a = b then xs ! a else (0::'a)) *\n                            Q)).\n           f i * i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (P' *\n   (P *\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n    Q) *\n   Q') $$\n  (i, i) =\n  (\\<Sum>i\\<in>set (diag_mat\n                     (P *\n                      Matrix.mat (length xs) (length xs)\n                       (\\<lambda>(a, b).\n                           if a = b then xs ! a else (0::'a)) *\n                      Q)).\n     f i * i)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "hence \"?A $$ (i,i) = (\\<Sum>i\\<in>set (diag_mat (P*?A*Q)). f i * i)\""], ["proof (prove)\nusing this:\n  (P' *\n   (P *\n    Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n    Q) *\n   Q') $$\n  (i, i) =\n  (\\<Sum>i\\<in>set (diag_mat\n                     (P *\n                      Matrix.mat (length xs) (length xs)\n                       (\\<lambda>(a, b).\n                           if a = b then xs ! a else (0::'a)) *\n                      Q)).\n     f i * i)\n\ngoal (1 subgoal):\n 1. Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n    (i, i) =\n    (\\<Sum>i\\<in>set (diag_mat\n                       (P *\n                        Matrix.mat (length xs) (length xs)\n                         (\\<lambda>(a, b).\n                             if a = b then xs ! a else (0::'a)) *\n                        Q)).\n       f i * i)", "unfolding rw_PAQ"], ["proof (prove)\nusing this:\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n  (i, i) =\n  (\\<Sum>i\\<in>set (diag_mat\n                     (P *\n                      Matrix.mat (length xs) (length xs)\n                       (\\<lambda>(a, b).\n                           if a = b then xs ! a else (0::'a)) *\n                      Q)).\n     f i * i)\n\ngoal (1 subgoal):\n 1. Matrix.mat (length xs) (length xs)\n     (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n    (i, i) =\n    (\\<Sum>i\\<in>set (diag_mat\n                       (P *\n                        Matrix.mat (length xs) (length xs)\n                         (\\<lambda>(a, b).\n                             if a = b then xs ! a else (0::'a)) *\n                        Q)).\n       f i * i)", "."], ["proof (state)\nthis:\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n  (i, i) =\n  (\\<Sum>i\\<in>set (diag_mat\n                     (P *\n                      Matrix.mat (length xs) (length xs)\n                       (\\<lambda>(a, b).\n                           if a = b then xs ! a else (0::'a)) *\n                      Q)).\n     f i * i)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set xs \\<Longrightarrow> b \\<in> ideal_generated (set ys)", "thus \"b\\<in> ideal_generated (set ys)\""], ["proof (prove)\nusing this:\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n  (i, i) =\n  (\\<Sum>i\\<in>set (diag_mat\n                     (P *\n                      Matrix.mat (length xs) (length xs)\n                       (\\<lambda>(a, b).\n                           if a = b then xs ! a else (0::'a)) *\n                      Q)).\n     f i * i)\n\ngoal (1 subgoal):\n 1. b \\<in> ideal_generated (set ys)", "unfolding ideal_explicit"], ["proof (prove)\nusing this:\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n  (i, i) =\n  (\\<Sum>i\\<in>set (diag_mat\n                     (P *\n                      Matrix.mat (length xs) (length xs)\n                       (\\<lambda>(a, b).\n                           if a = b then xs ! a else (0::'a)) *\n                      Q)).\n     f i * i)\n\ngoal (1 subgoal):\n 1. b \\<in> {y. \\<exists>f U.\n                   finite U \\<and>\n                   U \\<subseteq> set ys \\<and> (\\<Sum>i\\<in>U. f i * i) = y}", "using set_ys_diag_mat b_A_ii"], ["proof (prove)\nusing this:\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n  (i, i) =\n  (\\<Sum>i\\<in>set (diag_mat\n                     (P *\n                      Matrix.mat (length xs) (length xs)\n                       (\\<lambda>(a, b).\n                           if a = b then xs ! a else (0::'a)) *\n                      Q)).\n     f i * i)\n  set ys =\n  set (diag_mat\n        (P *\n         Matrix.mat (length xs) (length xs)\n          (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n         Q))\n  b =\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) $$\n  (i, i)\n\ngoal (1 subgoal):\n 1. b \\<in> {y. \\<exists>f U.\n                   finite U \\<and>\n                   U \\<subseteq> set ys \\<and> (\\<Sum>i\\<in>U. f i * i) = y}", "by auto"], ["proof (state)\nthis:\n  b \\<in> ideal_generated (set ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal_generated (set xs) \\<subseteq> ideal_generated (set ys)\n\ngoal (1 subgoal):\n 1. ideal_generated (set ys) \\<subseteq> ideal_generated (set xs)", "show \"ideal_generated (set ys) \\<subseteq> ideal_generated (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal_generated (set ys) \\<subseteq> ideal_generated (set xs)", "proof (rule ideal_generated_subset2, rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set ys \\<Longrightarrow> b \\<in> ideal_generated (set xs)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set ys \\<Longrightarrow> b \\<in> ideal_generated (set xs)", "assume b: \"b \\<in> set ys\""], ["proof (state)\nthis:\n  b \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set ys \\<Longrightarrow> b \\<in> ideal_generated (set xs)", "have d: \"distinct (diag_mat ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (diag_mat\n       (Matrix.mat (length xs) (length xs)\n         (\\<lambda>(a, b). if a = b then xs ! a else (0::'a))))", "by (metis (no_types, lifting) A_carrier card_distinct carrier_matD(1) diag_mat_def \n             length_eq_card length_map map_nth set_xs set_xs_diag_mat)"], ["proof (state)\nthis:\n  distinct\n   (diag_mat\n     (Matrix.mat (length xs) (length xs)\n       (\\<lambda>(a, b). if a = b then xs ! a else (0::'a))))\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set ys \\<Longrightarrow> b \\<in> ideal_generated (set xs)", "obtain i where b_PAQ_ii: \"(P*?A*Q) $$ (i,i) = b\" and i_length: \"i<length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>(P *\n                  Matrix.mat (length xs) (length xs)\n                   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n                  Q) $$\n                 (i, i) =\n                 b;\n         i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b ys"], ["proof (prove)\nusing this:\n  b \\<in> set ys\n  \\<forall>i<length xs.\n     ys ! i =\n     (P *\n      Matrix.mat (length xs) (length xs)\n       (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n      Q) $$\n     (i, i)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>(P *\n                  Matrix.mat (length xs) (length xs)\n                   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n                  Q) $$\n                 (i, i) =\n                 b;\n         i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) in_set_conv_nth length_ys)"], ["proof (state)\nthis:\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (i, i) =\n  b\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set ys \\<Longrightarrow> b \\<in> ideal_generated (set xs)", "obtain f where \"(P * ?A * Q) $$ (i, i) = (\\<Sum>i\\<in>set (diag_mat ?A). f i * i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (P *\n         Matrix.mat (length xs) (length xs)\n          (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n         Q) $$\n        (i, i) =\n        (\\<Sum>i\\<in>set (diag_mat\n                           (Matrix.mat (length xs) (length xs)\n                             (\\<lambda>(a, b).\n                                 if a = b then xs ! a else (0::'a)))).\n           f i * i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using exists_f_PAQ_Aii[OF diag_A P _ Q i_length]"], ["proof (prove)\nusing this:\n  Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a))\n  \\<in> carrier_mat (length xs) (length xs) \\<Longrightarrow>\n  \\<exists>f.\n     (P *\n      Matrix.mat (length xs) (length xs)\n       (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n      Q) $$\n     (i, i) =\n     (\\<Sum>i\\<in>set (diag_mat\n                        (Matrix.mat (length xs) (length xs)\n                          (\\<lambda>(a, b).\n                              if a = b then xs ! a else (0::'a)))).\n        f i * i)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (P *\n         Matrix.mat (length xs) (length xs)\n          (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n         Q) $$\n        (i, i) =\n        (\\<Sum>i\\<in>set (diag_mat\n                           (Matrix.mat (length xs) (length xs)\n                             (\\<lambda>(a, b).\n                                 if a = b then xs ! a else (0::'a)))).\n           f i * i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (i, i) =\n  (\\<Sum>i\\<in>set (diag_mat\n                     (Matrix.mat (length xs) (length xs)\n                       (\\<lambda>(a, b).\n                           if a = b then xs ! a else (0::'a)))).\n     f i * i)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set ys \\<Longrightarrow> b \\<in> ideal_generated (set xs)", "thus \"b \\<in> ideal_generated (set xs)\""], ["proof (prove)\nusing this:\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (i, i) =\n  (\\<Sum>i\\<in>set (diag_mat\n                     (Matrix.mat (length xs) (length xs)\n                       (\\<lambda>(a, b).\n                           if a = b then xs ! a else (0::'a)))).\n     f i * i)\n\ngoal (1 subgoal):\n 1. b \\<in> ideal_generated (set xs)", "using b_PAQ_ii"], ["proof (prove)\nusing this:\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (i, i) =\n  (\\<Sum>i\\<in>set (diag_mat\n                     (Matrix.mat (length xs) (length xs)\n                       (\\<lambda>(a, b).\n                           if a = b then xs ! a else (0::'a)))).\n     f i * i)\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (i, i) =\n  b\n\ngoal (1 subgoal):\n 1. b \\<in> ideal_generated (set xs)", "unfolding set_xs_diag_mat ideal_explicit"], ["proof (prove)\nusing this:\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (i, i) =\n  (\\<Sum>i\\<in>set (diag_mat\n                     (Matrix.mat (length xs) (length xs)\n                       (\\<lambda>(a, b).\n                           if a = b then xs ! a else (0::'a)))).\n     f i * i)\n  (P *\n   Matrix.mat (length xs) (length xs)\n    (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)) *\n   Q) $$\n  (i, i) =\n  b\n\ngoal (1 subgoal):\n 1. b \\<in> {y. \\<exists>f U.\n                   finite U \\<and>\n                   U \\<subseteq> set (diag_mat\n (Matrix.mat (length xs) (length xs)\n   (\\<lambda>(a, b). if a = b then xs ! a else (0::'a)))) \\<and>\n                   (\\<Sum>i\\<in>U. f i * i) = y}", "by auto"], ["proof (state)\nthis:\n  b \\<in> ideal_generated (set xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal_generated (set ys) \\<subseteq> ideal_generated (set xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal_generated (set xs) = ideal_generated (set ys)\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "also"], ["proof (state)\nthis:\n  ideal_generated (set xs) = ideal_generated (set ys)\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have \"... = ideal_generated (set ys - (set ys - {ys!0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal_generated (set ys) =\n    ideal_generated (set ys - (set ys - {ys ! 0}))", "proof (rule ideal_generated_dvd_eq_diff_set)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?i \\<in> set ys\n 2. ?i \\<notin> set ys - {ys ! 0}\n 3. \\<forall>j\\<in>set ys - {ys ! 0}. ?i dvd j\n 4. finite (set ys - {ys ! 0})", "show \"?i \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys ! 0 \\<in> set ys", "using n0"], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. ys ! 0 \\<in> set ys", "by (simp add: length_ys)"], ["proof (state)\nthis:\n  ys ! 0 \\<in> set ys\n\ngoal (3 subgoals):\n 1. ys ! 0 \\<notin> set ys - {ys ! 0}\n 2. \\<forall>j\\<in>set ys - {ys ! 0}. ys ! 0 dvd j\n 3. finite (set ys - {ys ! 0})", "show \"?i \\<notin> set ys - {?i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys ! 0 \\<notin> set ys - {ys ! 0}", "by auto"], ["proof (state)\nthis:\n  ys ! 0 \\<notin> set ys - {ys ! 0}\n\ngoal (2 subgoals):\n 1. \\<forall>j\\<in>set ys - {ys ! 0}. ys ! 0 dvd j\n 2. finite (set ys - {ys ! 0})", "show \"\\<forall>j\\<in>set ys - {?i}. ?i dvd j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>set ys - {ys ! 0}. ys ! 0 dvd j", "using dvd_all"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ys. ys ! 0 dvd a\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>set ys - {ys ! 0}. ys ! 0 dvd j", "by auto"], ["proof (state)\nthis:\n  \\<forall>j\\<in>set ys - {ys ! 0}. ys ! 0 dvd j\n\ngoal (1 subgoal):\n 1. finite (set ys - {ys ! 0})", "show \"finite (set ys - {?i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set ys - {ys ! 0})", "by auto"], ["proof (state)\nthis:\n  finite (set ys - {ys ! 0})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal_generated (set ys) = ideal_generated (set ys - (set ys - {ys ! 0}))\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "also"], ["proof (state)\nthis:\n  ideal_generated (set ys) = ideal_generated (set ys - (set ys - {ys ! 0}))\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "have \"... = ideal_generated {?i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal_generated (set ys - (set ys - {ys ! 0})) =\n    ideal_generated {ys ! 0}", "by (metis Diff_cancel Diff_not_in insert_Diff insert_Diff_if length_ys n0 nth_mem)"], ["proof (state)\nthis:\n  ideal_generated (set ys - (set ys - {ys ! 0})) = ideal_generated {ys ! 0}\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> principal_ideal I", "finally"], ["proof (chain)\npicking this:\n  ideal_generated S = ideal_generated {ys ! 0}", "show \"principal_ideal I\""], ["proof (prove)\nusing this:\n  ideal_generated S = ideal_generated {ys ! 0}\n\ngoal (1 subgoal):\n 1. principal_ideal I", "unfolding principal_ideal_def"], ["proof (prove)\nusing this:\n  ideal_generated S = ideal_generated {ys ! 0}\n\ngoal (1 subgoal):\n 1. \\<exists>a. ideal_generated {a} = I", "using ig_S"], ["proof (prove)\nusing this:\n  ideal_generated S = ideal_generated {ys ! 0}\n  ideal_generated S = I\n\ngoal (1 subgoal):\n 1. \\<exists>a. ideal_generated {a} = I", "by auto"], ["proof (state)\nthis:\n  principal_ideal I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  principal_ideal I\n\ngoal:\nNo subgoals!", "qed"], ["", "(*Alternative statement:*)"], ["", "corollary diagonal_admits_SNF_imp_bezout_ring_JNF_alt:\n  assumes admits_SNF: \"\\<forall>A. square_mat (A::'a mat) \\<and> isDiagonal_mat A \n\\<longrightarrow> (\\<exists>P Q. P \\<in> carrier_mat (dim_row A) (dim_row A) \n  \\<and> Q \\<in> carrier_mat (dim_row A) (dim_row A) \\<and> invertible_mat P \\<and> invertible_mat Q \n  \\<and> Smith_normal_form_mat (P*A*Q))\"\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, bezout_ring_class)", "proof (rule diagonal_admits_SNF_imp_bezout_ring_JNF, rule allI, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A n.\n       A \\<in> carrier_mat n n \\<and> isDiagonal_mat A \\<Longrightarrow>\n       \\<exists>P Q.\n          P \\<in> carrier_mat n n \\<and>\n          Q \\<in> carrier_mat n n \\<and>\n          invertible_mat P \\<and>\n          invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q)", "fix A::\"'a mat\" and n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A n.\n       A \\<in> carrier_mat n n \\<and> isDiagonal_mat A \\<Longrightarrow>\n       \\<exists>P Q.\n          P \\<in> carrier_mat n n \\<and>\n          Q \\<in> carrier_mat n n \\<and>\n          invertible_mat P \\<and>\n          invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q)", "assume A: \"A \\<in> carrier_mat n n \\<and> isDiagonal_mat A\""], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n \\<and> isDiagonal_mat A\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       A \\<in> carrier_mat n n \\<and> isDiagonal_mat A \\<Longrightarrow>\n       \\<exists>P Q.\n          P \\<in> carrier_mat n n \\<and>\n          Q \\<in> carrier_mat n n \\<and>\n          invertible_mat P \\<and>\n          invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q)", "have \"square_mat A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_mat A", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n \\<and> isDiagonal_mat A\n\ngoal (1 subgoal):\n 1. square_mat A", "by auto"], ["proof (state)\nthis:\n  square_mat A\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       A \\<in> carrier_mat n n \\<and> isDiagonal_mat A \\<Longrightarrow>\n       \\<exists>P Q.\n          P \\<in> carrier_mat n n \\<and>\n          Q \\<in> carrier_mat n n \\<and>\n          invertible_mat P \\<and>\n          invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q)", "thus \"\\<exists>P Q. P \\<in> carrier_mat n n \\<and> Q \\<in> carrier_mat n n \n  \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q)\""], ["proof (prove)\nusing this:\n  square_mat A\n\ngoal (1 subgoal):\n 1. \\<exists>P Q.\n       P \\<in> carrier_mat n n \\<and>\n       Q \\<in> carrier_mat n n \\<and>\n       invertible_mat P \\<and>\n       invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q)", "using A admits_SNF"], ["proof (prove)\nusing this:\n  square_mat A\n  A \\<in> carrier_mat n n \\<and> isDiagonal_mat A\n  \\<forall>A.\n     square_mat A \\<and> isDiagonal_mat A \\<longrightarrow>\n     (\\<exists>P Q.\n         P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n         Q \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n         invertible_mat P \\<and>\n         invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))\n\ngoal (1 subgoal):\n 1. \\<exists>P Q.\n       P \\<in> carrier_mat n n \\<and>\n       Q \\<in> carrier_mat n n \\<and>\n       invertible_mat P \\<and>\n       invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q)", "by blast"], ["proof (state)\nthis:\n  \\<exists>P Q.\n     P \\<in> carrier_mat n n \\<and>\n     Q \\<in> carrier_mat n n \\<and>\n     invertible_mat P \\<and>\n     invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Trying to transfer the @{text \"\\<Longrightarrow>\"} implication to HA.\\<close>"], ["", "text \\<open>We first hide some constants defined in @{text \"Mod_Type_Connect\"} in order to use the ones\npresented in @{text \"Perron_Frobenius.HMA_Connect\"} by default.\\<close>"], ["", "context \n  includes lifting_syntax\nbegin"], ["", "lemma to_nat_mod_type_Bij_Nat:\n  fixes a::\"'n::mod_type\"\n  obtains b::'n where \"mod_type_class.to_nat a = Bij_Nat.to_nat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        to_nat a = Bij_Nat.to_nat b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Bij_Nat.to_nat_from_nat_id mod_type_class.to_nat_less_card"], ["proof (prove)\nusing this:\n  ?i < CARD(?'a) \\<Longrightarrow> Bij_Nat.to_nat (Bij_Nat.from_nat ?i) = ?i\n  to_nat ?j < CARD(?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        to_nat a = Bij_Nat.to_nat b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["", "lemma inj_on_Bij_nat_from_nat: \"inj_on (Bij_Nat.from_nat::nat \\<Rightarrow> 'a) {0..<CARD('a::finite)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Bij_Nat.from_nat {0..<CARD('a)}", "by (auto simp add: inj_on_def Bij_Nat.from_nat_def length_univ_list_card \n      nth_eq_iff_index_eq univ_list(1))"], ["", "text \\<open>This lemma only holds if $a$ and $b$ have the same type. Otherwise, \n  it is possible that @{text \"Bij_Nat.to_nat a = Bij_Nat.to_nat b\"}\\<close>"], ["", "lemma Bij_Nat_to_nat_neq:\n  fixes a b ::\"'n::mod_type\"\n  assumes \"to_nat a \\<noteq> to_nat b\"\n  shows \"Bij_Nat.to_nat a \\<noteq> Bij_Nat.to_nat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bij_Nat.to_nat a \\<noteq> Bij_Nat.to_nat b", "using assms to_nat_inj"], ["proof (prove)\nusing this:\n  to_nat a \\<noteq> to_nat b\n  Bij_Nat.to_nat ?a = Bij_Nat.to_nat ?b \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. Bij_Nat.to_nat a \\<noteq> Bij_Nat.to_nat b", "by blast"], ["", "text \\<open>The following proof (a transfer rule for diagonal matrices) \n  is weird, since it does not hold \n  @{text \"Bij_Nat.to_nat a = mod_type_class.to_nat a\"}. \n\n  At first, it seems possible to obtain the element $a'$ that satisfies \n   @{text \"Bij_Nat.to_nat a' = mod_type_class.to_nat a\"} and then continue with the proof, but then\n  we cannot prove @{text \"HMA_I (Bij_Nat.to_nat a') a\"}.\n\n  This means that we must use the previous lemma @{text \"Bij_Nat_to_nat_neq\"}, but this imposes the \n  matrix to be square.\n  \\<close>"], ["", "lemma HMA_isDiagonal[transfer_rule]: \"(HMA_M ===> (=)) \n  isDiagonal_mat (isDiagonal::('a::{zero}^'n::{mod_type}^'n::{mod_type} => bool))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) isDiagonal_mat isDiagonal", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. HMA_M x y \\<Longrightarrow> isDiagonal_mat x = isDiagonal y", "case (1 x y)"], ["proof (state)\nthis:\n  HMA_M x y\n\ngoal (1 subgoal):\n 1. \\<And>x y. HMA_M x y \\<Longrightarrow> isDiagonal_mat x = isDiagonal y", "note rel_xy [transfer_rule] = \"1\""], ["proof (state)\nthis:\n  HMA_M x y\n\ngoal (1 subgoal):\n 1. \\<And>x y. HMA_M x y \\<Longrightarrow> isDiagonal_mat x = isDiagonal y", "have \"y $h a $h b = 0\"\n    if all0: \"\\<forall>i j. i \\<noteq> j \\<and> i < dim_row x \\<and> j < dim_col x \\<longrightarrow> x $$ (i, j) = 0\"\n      and a_noteq_b: \"a \\<noteq> b\" for a::'n and b::'n"], ["proof (prove)\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "have \"to_nat a \\<noteq> to_nat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_nat a \\<noteq> to_nat b", "using a_noteq_b"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. to_nat a \\<noteq> to_nat b", "by auto"], ["proof (state)\nthis:\n  to_nat a \\<noteq> to_nat b\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "hence distinct: \"Bij_Nat.to_nat a \\<noteq> Bij_Nat.to_nat b\""], ["proof (prove)\nusing this:\n  to_nat a \\<noteq> to_nat b\n\ngoal (1 subgoal):\n 1. Bij_Nat.to_nat a \\<noteq> Bij_Nat.to_nat b", "by (rule Bij_Nat_to_nat_neq)"], ["proof (state)\nthis:\n  Bij_Nat.to_nat a \\<noteq> Bij_Nat.to_nat b\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "moreover"], ["proof (state)\nthis:\n  Bij_Nat.to_nat a \\<noteq> Bij_Nat.to_nat b\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "have \"Bij_Nat.to_nat a < dim_row x\" and \"Bij_Nat.to_nat b < dim_col x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bij_Nat.to_nat a < dim_row x &&& Bij_Nat.to_nat b < dim_col x", "using Bij_Nat.to_nat_less_card dim_row_transfer_rule rel_xy dim_col_transfer_rule"], ["proof (prove)\nusing this:\n  Bij_Nat.to_nat ?a < CARD(?'a)\n  HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  HMA_M x y\n  HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n\ngoal (1 subgoal):\n 1. Bij_Nat.to_nat a < dim_row x &&& Bij_Nat.to_nat b < dim_col x", "by fastforce+"], ["proof (state)\nthis:\n  Bij_Nat.to_nat a < dim_row x\n  Bij_Nat.to_nat b < dim_col x\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  Bij_Nat.to_nat a \\<noteq> Bij_Nat.to_nat b\n  Bij_Nat.to_nat a < dim_row x\n  Bij_Nat.to_nat b < dim_col x", "have b: \"x $$ (Bij_Nat.to_nat a, Bij_Nat.to_nat b) = 0\""], ["proof (prove)\nusing this:\n  Bij_Nat.to_nat a \\<noteq> Bij_Nat.to_nat b\n  Bij_Nat.to_nat a < dim_row x\n  Bij_Nat.to_nat b < dim_col x\n\ngoal (1 subgoal):\n 1. x $$ (Bij_Nat.to_nat a, Bij_Nat.to_nat b) = (0::'a)", "using all0"], ["proof (prove)\nusing this:\n  Bij_Nat.to_nat a \\<noteq> Bij_Nat.to_nat b\n  Bij_Nat.to_nat a < dim_row x\n  Bij_Nat.to_nat b < dim_col x\n  \\<forall>i j.\n     i \\<noteq> j \\<and>\n     i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n     x $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. x $$ (Bij_Nat.to_nat a, Bij_Nat.to_nat b) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  x $$ (Bij_Nat.to_nat a, Bij_Nat.to_nat b) = (0::'a)\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "have [transfer_rule]: \"HMA_I (Bij_Nat.to_nat a) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_I (Bij_Nat.to_nat a) a", "by (simp add: HMA_I_def)"], ["proof (state)\nthis:\n  HMA_I (Bij_Nat.to_nat a) a\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "have [transfer_rule]: \"HMA_I (Bij_Nat.to_nat b) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_I (Bij_Nat.to_nat b) b", "by (simp add: HMA_I_def)"], ["proof (state)\nthis:\n  HMA_I (Bij_Nat.to_nat b) b\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "have \"index_hma y a b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma y a b = (0::'a)", "using b"], ["proof (prove)\nusing this:\n  x $$ (Bij_Nat.to_nat a, Bij_Nat.to_nat b) = (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma y a b = (0::'a)", "by (transfer', auto)"], ["proof (state)\nthis:\n  index_hma y a b = (0::'a)\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  index_hma y a b = (0::'a)\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  y $h a $h b = (0::'a)\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "."], ["proof (state)\nthis:\n  y $h a $h b = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i j.\n              i \\<noteq> j \\<and>\n              i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n              x $$ (i, j) = (0::'a);\n   ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y. HMA_M x y \\<Longrightarrow> isDiagonal_mat x = isDiagonal y", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i j.\n              i \\<noteq> j \\<and>\n              i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n              x $$ (i, j) = (0::'a);\n   ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y. HMA_M x y \\<Longrightarrow> isDiagonal_mat x = isDiagonal y", "have \"x $$ (i, j) = 0\" \n    if all0: \"\\<forall>a b. a \\<noteq> b \\<longrightarrow> y $h a $h b = 0\"\n      and ij: \"i \\<noteq> j\" and i: \"i < dim_row x\" and j: \"j < dim_col x\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "have i_n: \"i < CARD('n)\" and j_n: \"j < CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < CARD('n) &&& j < CARD('n)", "using i j rel_xy dim_row_transfer_rule dim_col_transfer_rule"], ["proof (prove)\nusing this:\n  i < dim_row x\n  j < dim_col x\n  HMA_M x y\n  HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n\ngoal (1 subgoal):\n 1. i < CARD('n) &&& j < CARD('n)", "by fastforce+"], ["proof (state)\nthis:\n  i < CARD('n)\n  j < CARD('n)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "let ?i' = \"Bij_Nat.from_nat i::'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "let ?j' = \"Bij_Nat.from_nat j::'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "have i'_neq_j': \"?i' \\<noteq> ?j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bij_Nat.from_nat i \\<noteq> Bij_Nat.from_nat j", "using ij i_n j_n Bij_Nat.from_nat_inj"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i < CARD('n)\n  j < CARD('n)\n  \\<lbrakk>?i < CARD(?'a); ?j < CARD(?'a);\n   Bij_Nat.from_nat ?i = Bij_Nat.from_nat ?j\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j\n\ngoal (1 subgoal):\n 1. Bij_Nat.from_nat i \\<noteq> Bij_Nat.from_nat j", "by blast"], ["proof (state)\nthis:\n  Bij_Nat.from_nat i \\<noteq> Bij_Nat.from_nat j\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "hence y0: \"index_hma y ?i' ?j' = 0\""], ["proof (prove)\nusing this:\n  Bij_Nat.from_nat i \\<noteq> Bij_Nat.from_nat j\n\ngoal (1 subgoal):\n 1. index_hma y (Bij_Nat.from_nat i) (Bij_Nat.from_nat j) = (0::'a)", "using all0"], ["proof (prove)\nusing this:\n  Bij_Nat.from_nat i \\<noteq> Bij_Nat.from_nat j\n  \\<forall>a b. a \\<noteq> b \\<longrightarrow> y $h a $h b = (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma y (Bij_Nat.from_nat i) (Bij_Nat.from_nat j) = (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  Bij_Nat.from_nat i \\<noteq> Bij_Nat.from_nat j\n  \\<forall>a b. a \\<noteq> b \\<longrightarrow> y $h a $h b = (0::'a)\n\ngoal (1 subgoal):\n 1. y $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j = (0::'a)", "by auto"], ["proof (state)\nthis:\n  index_hma y (Bij_Nat.from_nat i) (Bij_Nat.from_nat j) = (0::'a)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "have [transfer_rule]: \"HMA_I i ?i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_I i (Bij_Nat.from_nat i)", "unfolding HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = Bij_Nat.to_nat (Bij_Nat.from_nat i)", "by (simp add: Bij_Nat.to_nat_from_nat_id i_n)"], ["proof (state)\nthis:\n  HMA_I i (Bij_Nat.from_nat i)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "have [transfer_rule]: \"HMA_I j ?j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_I j (Bij_Nat.from_nat j)", "unfolding HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j = Bij_Nat.to_nat (Bij_Nat.from_nat j)", "by (simp add: Bij_Nat.to_nat_from_nat_id j_n)"], ["proof (state)\nthis:\n  HMA_I j (Bij_Nat.from_nat j)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "using y0"], ["proof (prove)\nusing this:\n  index_hma y (Bij_Nat.from_nat i) (Bij_Nat.from_nat j) = (0::'a)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "by (transfer, auto)"], ["proof (state)\nthis:\n  x $$ (i, j) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a b.\n              a \\<noteq> b \\<longrightarrow> y $h a $h b = (0::'a);\n   ?i \\<noteq> ?j; ?i < dim_row x; ?j < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?i, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y. HMA_M x y \\<Longrightarrow> isDiagonal_mat x = isDiagonal y", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<noteq> j \\<and>\n              i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n              x $$ (i, j) = (0::'a);\n   ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b = (0::'a)\n  \\<lbrakk>\\<forall>a b.\n              a \\<noteq> b \\<longrightarrow> y $h a $h b = (0::'a);\n   ?i \\<noteq> ?j; ?i < dim_row x; ?j < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?i, ?j) = (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<noteq> j \\<and>\n              i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n              x $$ (i, j) = (0::'a);\n   ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b = (0::'a)\n  \\<lbrakk>\\<forall>a b.\n              a \\<noteq> b \\<longrightarrow> y $h a $h b = (0::'a);\n   ?i \\<noteq> ?j; ?i < dim_row x; ?j < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?i, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. isDiagonal_mat x = isDiagonal y", "unfolding isDiagonal_mat_def isDiagonal_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<noteq> j \\<and>\n              i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n              x $$ (i, j) = (0::'a);\n   ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b = (0::'a)\n  \\<lbrakk>\\<forall>a b.\n              a \\<noteq> b \\<longrightarrow> y $h a $h b = (0::'a);\n   ?i \\<noteq> ?j; ?i < dim_row x; ?j < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?i, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<forall>i j.\n        i \\<noteq> j \\<and>\n        i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n        x $$ (i, j) = (0::'a)) =\n    (\\<forall>a b.\n        to_nat a \\<noteq> to_nat b \\<longrightarrow> y $h a $h b = (0::'a))", "by auto"], ["proof (state)\nthis:\n  isDiagonal_mat x = isDiagonal y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Indeed, we can prove the transfer rules with the new connection based on the \n  @{text \"mod_type\"} class, which was developed in the  @{text \"Mod_Type_Connect\"} file\\<close>"], ["", "text \\<open>This is the same lemma as the one presented above, but now using the @{text \"to_nat\"} function\n  defined in the  @{text \"mod_type\"} class and then we can prove it for non-square matrices, \n  which is very useful since our algorithms are not restricted to square matrices.\\<close>"], ["", "lemma HMA_isDiagonal_Mod_Type[transfer_rule]: \"(Mod_Type_Connect.HMA_M ===> (=)) \n  isDiagonal_mat (isDiagonal::('a::{zero}^'n::{mod_type}^'m::{mod_type} => bool))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) isDiagonal_mat isDiagonal", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       isDiagonal_mat x = isDiagonal y", "case (1 x y)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       isDiagonal_mat x = isDiagonal y", "note rel_xy [transfer_rule] = \"1\""], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       isDiagonal_mat x = isDiagonal y", "have \"y $h a $h b = 0\"\n    if all0: \"\\<forall>i j. i \\<noteq> j \\<and> i < dim_row x \\<and> j < dim_col x \\<longrightarrow> x $$ (i, j) = 0\"\n      and a_noteq_b: \"to_nat a \\<noteq> to_nat b\" for a::'m and b::'n"], ["proof (prove)\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "have distinct: \"to_nat a \\<noteq> to_nat b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_nat a \\<noteq> to_nat b", "using a_noteq_b"], ["proof (prove)\nusing this:\n  to_nat a \\<noteq> to_nat b\n\ngoal (1 subgoal):\n 1. to_nat a \\<noteq> to_nat b", "by auto"], ["proof (state)\nthis:\n  to_nat a \\<noteq> to_nat b\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "moreover"], ["proof (state)\nthis:\n  to_nat a \\<noteq> to_nat b\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "have \"to_nat a < dim_row x\" and \"to_nat b < dim_col x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_nat a < dim_row x &&& to_nat b < dim_col x", "using to_nat_less_card rel_xy"], ["proof (prove)\nusing this:\n  to_nat ?j < CARD(?'a)\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. to_nat a < dim_row x &&& to_nat b < dim_col x", "using Mod_Type_Connect.dim_row_transfer_rule Mod_Type_Connect.dim_col_transfer_rule"], ["proof (prove)\nusing this:\n  to_nat ?j < CARD(?'a)\n  Mod_Type_Connect.HMA_M x y\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n\ngoal (1 subgoal):\n 1. to_nat a < dim_row x &&& to_nat b < dim_col x", "by fastforce+"], ["proof (state)\nthis:\n  to_nat a < dim_row x\n  to_nat b < dim_col x\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  to_nat a \\<noteq> to_nat b\n  to_nat a < dim_row x\n  to_nat b < dim_col x", "have b: \"x $$ (to_nat a, to_nat b) = 0\""], ["proof (prove)\nusing this:\n  to_nat a \\<noteq> to_nat b\n  to_nat a < dim_row x\n  to_nat b < dim_col x\n\ngoal (1 subgoal):\n 1. x $$ (to_nat a, to_nat b) = (0::'a)", "using all0"], ["proof (prove)\nusing this:\n  to_nat a \\<noteq> to_nat b\n  to_nat a < dim_row x\n  to_nat b < dim_col x\n  \\<forall>i j.\n     i \\<noteq> j \\<and>\n     i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n     x $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. x $$ (to_nat a, to_nat b) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  x $$ (to_nat a, to_nat b) = (0::'a)\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I (to_nat a) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (to_nat a) a", "by (simp add: Mod_Type_Connect.HMA_I_def)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (to_nat a) a\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I (to_nat b) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (to_nat b) b", "by (simp add: Mod_Type_Connect.HMA_I_def)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (to_nat b) b\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "have \"index_hma y a b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma y a b = (0::'a)", "using b"], ["proof (prove)\nusing this:\n  x $$ (to_nat a, to_nat b) = (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma y a b = (0::'a)", "by (transfer', auto)"], ["proof (state)\nthis:\n  index_hma y a b = (0::'a)\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  index_hma y a b = (0::'a)\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  y $h a $h b = (0::'a)\n\ngoal (1 subgoal):\n 1. y $h a $h b = (0::'a)", "."], ["proof (state)\nthis:\n  y $h a $h b = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i j.\n              i \\<noteq> j \\<and>\n              i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n              x $$ (i, j) = (0::'a);\n   to_nat ?a \\<noteq> to_nat ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       isDiagonal_mat x = isDiagonal y", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i j.\n              i \\<noteq> j \\<and>\n              i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n              x $$ (i, j) = (0::'a);\n   to_nat ?a \\<noteq> to_nat ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       isDiagonal_mat x = isDiagonal y", "have \"x $$ (i, j) = 0\" \n    if all0: \"\\<forall>a b. to_nat a \\<noteq> to_nat b \\<longrightarrow> y $h a $h b = 0\"\n      and ij: \"i \\<noteq> j\" and i: \"i < dim_row x\" and j: \"j < dim_col x\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "have i_n: \"i < CARD('m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < CARD('m)", "using i rel_xy"], ["proof (prove)\nusing this:\n  i < dim_row x\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. i < CARD('m)", "by (simp add: Mod_Type_Connect.dim_row_transfer_rule)"], ["proof (state)\nthis:\n  i < CARD('m)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "have j_n: \"j < CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < CARD('n)", "using j rel_xy"], ["proof (prove)\nusing this:\n  j < dim_col x\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. j < CARD('n)", "by (simp add: Mod_Type_Connect.dim_col_transfer_rule)"], ["proof (state)\nthis:\n  j < CARD('n)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "let ?i' = \"from_nat i::'m\""], ["proof (state)\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "let ?j' = \"from_nat j::'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "have \"to_nat ?i' \\<noteq> to_nat ?j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_nat (from_nat i) \\<noteq> to_nat (from_nat j)", "by (simp add: i_n ij j_n mod_type_class.to_nat_from_nat_id)"], ["proof (state)\nthis:\n  to_nat (from_nat i) \\<noteq> to_nat (from_nat j)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "hence y0: \"index_hma y ?i' ?j' = 0\""], ["proof (prove)\nusing this:\n  to_nat (from_nat i) \\<noteq> to_nat (from_nat j)\n\ngoal (1 subgoal):\n 1. index_hma y (from_nat i) (from_nat j) = (0::'a)", "using all0"], ["proof (prove)\nusing this:\n  to_nat (from_nat i) \\<noteq> to_nat (from_nat j)\n  \\<forall>a b.\n     to_nat a \\<noteq> to_nat b \\<longrightarrow> y $h a $h b = (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma y (from_nat i) (from_nat j) = (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  to_nat (from_nat i) \\<noteq> to_nat (from_nat j)\n  \\<forall>a b.\n     to_nat a \\<noteq> to_nat b \\<longrightarrow> y $h a $h b = (0::'a)\n\ngoal (1 subgoal):\n 1. y $h from_nat i $h from_nat j = (0::'a)", "by auto"], ["proof (state)\nthis:\n  index_hma y (from_nat i) (from_nat j) = (0::'a)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I i ?i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I i (from_nat i)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = to_nat (from_nat i)", "by (simp add: to_nat_from_nat_id i_n)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I i (from_nat i)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I j ?j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I j (from_nat j)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j = to_nat (from_nat j)", "by (simp add: to_nat_from_nat_id j_n)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I j (from_nat j)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "using y0"], ["proof (prove)\nusing this:\n  index_hma y (from_nat i) (from_nat j) = (0::'a)\n\ngoal (1 subgoal):\n 1. x $$ (i, j) = (0::'a)", "by (transfer, auto)"], ["proof (state)\nthis:\n  x $$ (i, j) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a b.\n              to_nat a \\<noteq> to_nat b \\<longrightarrow>\n              y $h a $h b = (0::'a);\n   ?i \\<noteq> ?j; ?i < dim_row x; ?j < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?i, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       isDiagonal_mat x = isDiagonal y", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<noteq> j \\<and>\n              i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n              x $$ (i, j) = (0::'a);\n   to_nat ?a \\<noteq> to_nat ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b = (0::'a)\n  \\<lbrakk>\\<forall>a b.\n              to_nat a \\<noteq> to_nat b \\<longrightarrow>\n              y $h a $h b = (0::'a);\n   ?i \\<noteq> ?j; ?i < dim_row x; ?j < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?i, ?j) = (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<noteq> j \\<and>\n              i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n              x $$ (i, j) = (0::'a);\n   to_nat ?a \\<noteq> to_nat ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b = (0::'a)\n  \\<lbrakk>\\<forall>a b.\n              to_nat a \\<noteq> to_nat b \\<longrightarrow>\n              y $h a $h b = (0::'a);\n   ?i \\<noteq> ?j; ?i < dim_row x; ?j < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?i, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. isDiagonal_mat x = isDiagonal y", "unfolding isDiagonal_mat_def isDiagonal_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<noteq> j \\<and>\n              i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n              x $$ (i, j) = (0::'a);\n   to_nat ?a \\<noteq> to_nat ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b = (0::'a)\n  \\<lbrakk>\\<forall>a b.\n              to_nat a \\<noteq> to_nat b \\<longrightarrow>\n              y $h a $h b = (0::'a);\n   ?i \\<noteq> ?j; ?i < dim_row x; ?j < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?i, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<forall>i j.\n        i \\<noteq> j \\<and>\n        i < dim_row x \\<and> j < dim_col x \\<longrightarrow>\n        x $$ (i, j) = (0::'a)) =\n    (\\<forall>a b.\n        to_nat a \\<noteq> to_nat b \\<longrightarrow> y $h a $h b = (0::'a))", "by auto"], ["proof (state)\nthis:\n  isDiagonal_mat x = isDiagonal y\n\ngoal:\nNo subgoals!", "qed"], ["", "(*We cannot state:\n\n lemma HMA_SNF[transfer_rule]: \"(HMA_M ===> (=)) Smith_normal_form_mat\n  (Smith_normal_form::'a::{comm_ring_1}^'n::{mod_type}^'n::{mod_type}\\<Rightarrow>bool)\"\n\nSince we need properties about Suc (Bij_Nat.to_nat a). This means that is mandatory to use\na bridge that relates the JNF representation with the HA one based on indexes with the mod_type\nclass restriction. This is carried out in the file Mod_Type_Connect.\n\nOtherwise, I cannot relate \n\nx $$ (to_nat a, to_nat a) dvd x $$ (to_nat (a + 1), to_nat (a + 1))\n\nwith\n\ny $h a $h a dvd y $h (a + 1) $h (a + 1) \n\nbeing such to_nat the one presented in Mod_Type, which is not the same as Bij_Nat.to_nat \n(mod_type_class.to_nat satisfies more properties that easier the definitions and proofs, \nand indeed are fundamental for defining the Smith normal form).\n*)"], ["", "text\\<open>We state the transfer rule using the relations developed in the new bride of the file\n    @{text \"Mod_Type_Connect\"}.\\<close>"], ["", "lemma HMA_SNF[transfer_rule]: \"(Mod_Type_Connect.HMA_M ===> (=)) Smith_normal_form_mat \n(Smith_normal_form::'a::{comm_ring_1}^'n::{mod_type}^'m::{mod_type}\\<Rightarrow>bool)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Smith_normal_form_mat\n     Smith_normal_form", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Smith_normal_form_mat x = Smith_normal_form y", "case (1 x y)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Smith_normal_form_mat x = Smith_normal_form y", "note rel_xy[transfer_rule] = \"1\""], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Smith_normal_form_mat x = Smith_normal_form y", "have \"y $h a $h b dvd y $h (a + 1) $h (b + 1)\"\n    if SNF_condition: \"\\<forall>a. Suc a < dim_row x \\<and> Suc a < dim_col x \n      \\<longrightarrow> x $$ (a, a) dvd x $$ (Suc a, Suc a)\"\n      and a1: \"Suc (to_nat a) < nrows y\" and a2: \"Suc (to_nat b) < ncols y\"\n      and ab: \"to_nat a = to_nat b\" for a::'m and b::'n"], ["proof (prove)\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I (to_nat a) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (to_nat a) a", "by (simp add: Mod_Type_Connect.HMA_I_def)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (to_nat a) a\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I (to_nat (a+1)) (a+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (to_nat (a + (1::'m))) (a + (1::'m))", "by (simp add: Mod_Type_Connect.HMA_I_def)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (to_nat (a + (1::'m))) (a + (1::'m))\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I (to_nat b) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (to_nat b) b", "by (simp add: Mod_Type_Connect.HMA_I_def)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (to_nat b) b\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I (to_nat (b+1)) (b+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (to_nat (b + (1::'n))) (b + (1::'n))", "by (simp add: Mod_Type_Connect.HMA_I_def)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (to_nat (b + (1::'n))) (b + (1::'n))\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "have \"Suc (to_nat a) < dim_row x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (to_nat a) < dim_row x", "using a1"], ["proof (prove)\nusing this:\n  Suc (to_nat a) < nrows y\n\ngoal (1 subgoal):\n 1. Suc (to_nat a) < dim_row x", "by (metis Mod_Type_Connect.dim_row_transfer_rule nrows_def rel_xy)"], ["proof (state)\nthis:\n  Suc (to_nat a) < dim_row x\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "moreover"], ["proof (state)\nthis:\n  Suc (to_nat a) < dim_row x\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "have \"Suc (to_nat b) < dim_col x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (to_nat b) < dim_col x", "by (metis Mod_Type_Connect.dim_col_transfer_rule a2 ncols_def rel_xy)"], ["proof (state)\nthis:\n  Suc (to_nat b) < dim_col x\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "ultimately"], ["proof (chain)\npicking this:\n  Suc (to_nat a) < dim_row x\n  Suc (to_nat b) < dim_col x", "have \"x $$ (to_nat a, to_nat b) dvd x $$ (Suc (to_nat a), Suc (to_nat b))\""], ["proof (prove)\nusing this:\n  Suc (to_nat a) < dim_row x\n  Suc (to_nat b) < dim_col x\n\ngoal (1 subgoal):\n 1. x $$ (to_nat a, to_nat b) dvd x $$ (Suc (to_nat a), Suc (to_nat b))", "using SNF_condition"], ["proof (prove)\nusing this:\n  Suc (to_nat a) < dim_row x\n  Suc (to_nat b) < dim_col x\n  \\<forall>a.\n     Suc a < dim_row x \\<and> Suc a < dim_col x \\<longrightarrow>\n     x $$ (a, a) dvd x $$ (Suc a, Suc a)\n\ngoal (1 subgoal):\n 1. x $$ (to_nat a, to_nat b) dvd x $$ (Suc (to_nat a), Suc (to_nat b))", "by (simp add: ab)"], ["proof (state)\nthis:\n  x $$ (to_nat a, to_nat b) dvd x $$ (Suc (to_nat a), Suc (to_nat b))\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "also"], ["proof (state)\nthis:\n  x $$ (to_nat a, to_nat b) dvd x $$ (Suc (to_nat a), Suc (to_nat b))\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "have \"... = x $$ (to_nat (a+1), to_nat (b+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $$ (Suc (to_nat a), Suc (to_nat b)) =\n    x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n)))", "by (metis Suc_eq_plus1 a1 a2 nrows_def ncols_def to_nat_suc)"], ["proof (state)\nthis:\n  x $$ (Suc (to_nat a), Suc (to_nat b)) =\n  x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n)))\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "finally"], ["proof (chain)\npicking this:\n  x $$ (to_nat a, to_nat b) dvd\n  x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n)))", "have SNF_cond: \"x $$ (to_nat a, to_nat b) dvd x $$ (to_nat (a + 1), to_nat (b + 1))\""], ["proof (prove)\nusing this:\n  x $$ (to_nat a, to_nat b) dvd\n  x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n)))\n\ngoal (1 subgoal):\n 1. x $$ (to_nat a, to_nat b) dvd\n    x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n)))", "."], ["proof (state)\nthis:\n  x $$ (to_nat a, to_nat b) dvd\n  x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n)))\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "have \"x $$ (to_nat a, to_nat b) = index_hma y a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $$ (to_nat a, to_nat b) = index_hma y a b", "by (transfer, simp)"], ["proof (state)\nthis:\n  x $$ (to_nat a, to_nat b) = index_hma y a b\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "moreover"], ["proof (state)\nthis:\n  x $$ (to_nat a, to_nat b) = index_hma y a b\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "have \"x $$ (to_nat (a + 1), to_nat (b + 1)) = index_hma y (a+1) (b+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n))) =\n    index_hma y (a + (1::'m)) (b + (1::'n))", "by (transfer, simp)"], ["proof (state)\nthis:\n  x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n))) =\n  index_hma y (a + (1::'m)) (b + (1::'n))\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "ultimately"], ["proof (chain)\npicking this:\n  x $$ (to_nat a, to_nat b) = index_hma y a b\n  x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n))) =\n  index_hma y (a + (1::'m)) (b + (1::'n))", "show ?thesis"], ["proof (prove)\nusing this:\n  x $$ (to_nat a, to_nat b) = index_hma y a b\n  x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n))) =\n  index_hma y (a + (1::'m)) (b + (1::'n))\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "using SNF_cond"], ["proof (prove)\nusing this:\n  x $$ (to_nat a, to_nat b) = index_hma y a b\n  x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n))) =\n  index_hma y (a + (1::'m)) (b + (1::'n))\n  x $$ (to_nat a, to_nat b) dvd\n  x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n)))\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  x $$ (to_nat a, to_nat b) = y $h a $h b\n  x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n))) =\n  y $h (a + (1::'m)) $h (b + (1::'n))\n  x $$ (to_nat a, to_nat b) dvd\n  x $$ (to_nat (a + (1::'m)), to_nat (b + (1::'n)))\n\ngoal (1 subgoal):\n 1. y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))", "by auto"], ["proof (state)\nthis:\n  y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a.\n              Suc a < dim_row x \\<and> Suc a < dim_col x \\<longrightarrow>\n              x $$ (a, a) dvd x $$ (Suc a, Suc a);\n   Suc (to_nat ?a) < nrows y; Suc (to_nat ?b) < ncols y;\n   to_nat ?a = to_nat ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b dvd y $h (?a + (1::'m)) $h (?b + (1::'n))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Smith_normal_form_mat x = Smith_normal_form y", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a.\n              Suc a < dim_row x \\<and> Suc a < dim_col x \\<longrightarrow>\n              x $$ (a, a) dvd x $$ (Suc a, Suc a);\n   Suc (to_nat ?a) < nrows y; Suc (to_nat ?b) < ncols y;\n   to_nat ?a = to_nat ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b dvd y $h (?a + (1::'m)) $h (?b + (1::'n))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Smith_normal_form_mat x = Smith_normal_form y", "have  \"x $$ (a, a) dvd x $$ (Suc a, Suc a)\"\n    if SNF: \"\\<forall>a b. to_nat a = to_nat b \\<and> Suc (to_nat a) < nrows y \\<and> Suc (to_nat b) < ncols y\n        \\<longrightarrow> y $h a $h b dvd y $h (a + 1) $h (b + 1)\" \n      and a1: \"Suc a < dim_row x\" and a2: \"Suc a < dim_col x\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have dim_row_CARD: \"dim_row x = CARD('m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row x = CARD('m)", "using Mod_Type_Connect.dim_row_transfer_rule rel_xy"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. dim_row x = CARD('m)", "by blast"], ["proof (state)\nthis:\n  dim_row x = CARD('m)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have dim_col_CARD: \"dim_col x = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col x = CARD('n)", "using Mod_Type_Connect.dim_col_transfer_rule rel_xy"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. dim_col x = CARD('n)", "by blast"], ["proof (state)\nthis:\n  dim_col x = CARD('n)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "let ?a' = \"from_nat a::'m\""], ["proof (state)\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "let ?b' = \"from_nat a::'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have Suc_a_less_CARD: \"a + 1 < CARD('m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 1 < CARD('m)", "using a1 dim_row_CARD"], ["proof (prove)\nusing this:\n  Suc a < dim_row x\n  dim_row x = CARD('m)\n\ngoal (1 subgoal):\n 1. a + 1 < CARD('m)", "by auto"], ["proof (state)\nthis:\n  a + 1 < CARD('m)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have Suc_b_less_CARD: \"a + 1 < CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 1 < CARD('n)", "using a2"], ["proof (prove)\nusing this:\n  Suc a < dim_col x\n\ngoal (1 subgoal):\n 1. a + 1 < CARD('n)", "by (metis Mod_Type_Connect.dim_col_transfer_rule Suc_eq_plus1 rel_xy)"], ["proof (state)\nthis:\n  a + 1 < CARD('n)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have aa'[transfer_rule]: \"Mod_Type_Connect.HMA_I a ?a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I a (from_nat a)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = to_nat (from_nat a)", "by (metis Suc_a_less_CARD add_lessD1 mod_type_class.to_nat_from_nat_id)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I a (from_nat a)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I (a+1) (?a' + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (a + 1) (from_nat a + (1::'m))", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 1 = to_nat (from_nat a + (1::'m))", "unfolding from_nat_suc[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 1 = to_nat (from_nat (a + 1))", "using to_nat_from_nat_id[OF Suc_a_less_CARD]"], ["proof (prove)\nusing this:\n  to_nat (from_nat (a + 1)) = a + 1\n\ngoal (1 subgoal):\n 1. a + 1 = to_nat (from_nat (a + 1))", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (a + 1) (from_nat a + (1::'m))\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have ab'[transfer_rule]: \"Mod_Type_Connect.HMA_I a ?b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I a (from_nat a)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = to_nat (from_nat a)", "by (metis Suc_b_less_CARD add_lessD1 mod_type_class.to_nat_from_nat_id)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I a (from_nat a)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I (a+1) (?b' + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (a + 1) (from_nat a + (1::'n))", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 1 = to_nat (from_nat a + (1::'n))", "unfolding from_nat_suc[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 1 = to_nat (from_nat (a + 1))", "using to_nat_from_nat_id[OF Suc_b_less_CARD]"], ["proof (prove)\nusing this:\n  to_nat (from_nat (a + 1)) = a + 1\n\ngoal (1 subgoal):\n 1. a + 1 = to_nat (from_nat (a + 1))", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (a + 1) (from_nat a + (1::'n))\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have aa'1: \"a = to_nat ?a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = to_nat (from_nat a)", "using aa'"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_I a (from_nat a)\n\ngoal (1 subgoal):\n 1. a = to_nat (from_nat a)", "by (simp add: Mod_Type_Connect.HMA_I_def)"], ["proof (state)\nthis:\n  a = to_nat (from_nat a)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have ab'1: \"a = to_nat ?b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = to_nat (from_nat a)", "using ab'"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_I a (from_nat a)\n\ngoal (1 subgoal):\n 1. a = to_nat (from_nat a)", "by (simp add: Mod_Type_Connect.HMA_I_def)"], ["proof (state)\nthis:\n  a = to_nat (from_nat a)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have \"Suc (to_nat ?a') < nrows y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (to_nat (from_nat a)) < nrows y", "using a1 dim_row_CARD"], ["proof (prove)\nusing this:\n  Suc a < dim_row x\n  dim_row x = CARD('m)\n\ngoal (1 subgoal):\n 1. Suc (to_nat (from_nat a)) < nrows y", "by (simp add: mod_type_class.to_nat_from_nat_id nrows_def)"], ["proof (state)\nthis:\n  Suc (to_nat (from_nat a)) < nrows y\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "moreover"], ["proof (state)\nthis:\n  Suc (to_nat (from_nat a)) < nrows y\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have \"Suc (to_nat ?b') < ncols y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (to_nat (from_nat a)) < ncols y", "using a2 dim_col_CARD"], ["proof (prove)\nusing this:\n  Suc a < dim_col x\n  dim_col x = CARD('n)\n\ngoal (1 subgoal):\n 1. Suc (to_nat (from_nat a)) < ncols y", "by (simp add: mod_type_class.to_nat_from_nat_id ncols_def)"], ["proof (state)\nthis:\n  Suc (to_nat (from_nat a)) < ncols y\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "ultimately"], ["proof (chain)\npicking this:\n  Suc (to_nat (from_nat a)) < nrows y\n  Suc (to_nat (from_nat a)) < ncols y", "have SNF': \"y $h ?a' $h ?b' dvd y $h (?a' + 1) $h (?b' + 1)\""], ["proof (prove)\nusing this:\n  Suc (to_nat (from_nat a)) < nrows y\n  Suc (to_nat (from_nat a)) < ncols y\n\ngoal (1 subgoal):\n 1. y $h from_nat a $h from_nat a dvd\n    y $h (from_nat a + (1::'m)) $h (from_nat a + (1::'n))", "using SNF ab'1 aa'1"], ["proof (prove)\nusing this:\n  Suc (to_nat (from_nat a)) < nrows y\n  Suc (to_nat (from_nat a)) < ncols y\n  \\<forall>a b.\n     to_nat a = to_nat b \\<and>\n     Suc (to_nat a) < nrows y \\<and>\n     Suc (to_nat b) < ncols y \\<longrightarrow>\n     y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))\n  a = to_nat (from_nat a)\n  a = to_nat (from_nat a)\n\ngoal (1 subgoal):\n 1. y $h from_nat a $h from_nat a dvd\n    y $h (from_nat a + (1::'m)) $h (from_nat a + (1::'n))", "by auto"], ["proof (state)\nthis:\n  y $h from_nat a $h from_nat a dvd\n  y $h (from_nat a + (1::'m)) $h (from_nat a + (1::'n))\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have \"index_hma y ?a' ?b' = x $$ (a, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma y (from_nat a) (from_nat a) = x $$ (a, a)", "by (transfer, simp)"], ["proof (state)\nthis:\n  index_hma y (from_nat a) (from_nat a) = x $$ (a, a)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "moreover"], ["proof (state)\nthis:\n  index_hma y (from_nat a) (from_nat a) = x $$ (a, a)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "have \"index_hma y (?a'+1) (?b'+1) = x $$ (a+1, a+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma y (from_nat a + (1::'m)) (from_nat a + (1::'n)) =\n    x $$ (a + 1, a + 1)", "by (transfer, simp)"], ["proof (state)\nthis:\n  index_hma y (from_nat a + (1::'m)) (from_nat a + (1::'n)) =\n  x $$ (a + 1, a + 1)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "ultimately"], ["proof (chain)\npicking this:\n  index_hma y (from_nat a) (from_nat a) = x $$ (a, a)\n  index_hma y (from_nat a + (1::'m)) (from_nat a + (1::'n)) =\n  x $$ (a + 1, a + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  index_hma y (from_nat a) (from_nat a) = x $$ (a, a)\n  index_hma y (from_nat a + (1::'m)) (from_nat a + (1::'n)) =\n  x $$ (a + 1, a + 1)\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "using SNF'"], ["proof (prove)\nusing this:\n  index_hma y (from_nat a) (from_nat a) = x $$ (a, a)\n  index_hma y (from_nat a + (1::'m)) (from_nat a + (1::'n)) =\n  x $$ (a + 1, a + 1)\n  y $h from_nat a $h from_nat a dvd\n  y $h (from_nat a + (1::'m)) $h (from_nat a + (1::'n))\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  y $h from_nat a $h from_nat a = x $$ (a, a)\n  y $h (from_nat a + (1::'m)) $h (from_nat a + (1::'n)) =\n  x $$ (a + 1, a + 1)\n  y $h from_nat a $h from_nat a dvd\n  y $h (from_nat a + (1::'m)) $h (from_nat a + (1::'n))\n\ngoal (1 subgoal):\n 1. x $$ (a, a) dvd x $$ (Suc a, Suc a)", "by auto"], ["proof (state)\nthis:\n  x $$ (a, a) dvd x $$ (Suc a, Suc a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a b.\n              to_nat a = to_nat b \\<and>\n              Suc (to_nat a) < nrows y \\<and>\n              Suc (to_nat b) < ncols y \\<longrightarrow>\n              y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n));\n   Suc ?a < dim_row x; Suc ?a < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?a, ?a) dvd x $$ (Suc ?a, Suc ?a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Smith_normal_form_mat x = Smith_normal_form y", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>a.\n              Suc a < dim_row x \\<and> Suc a < dim_col x \\<longrightarrow>\n              x $$ (a, a) dvd x $$ (Suc a, Suc a);\n   Suc (to_nat ?a) < nrows y; Suc (to_nat ?b) < ncols y;\n   to_nat ?a = to_nat ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b dvd y $h (?a + (1::'m)) $h (?b + (1::'n))\n  \\<lbrakk>\\<forall>a b.\n              to_nat a = to_nat b \\<and>\n              Suc (to_nat a) < nrows y \\<and>\n              Suc (to_nat b) < ncols y \\<longrightarrow>\n              y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n));\n   Suc ?a < dim_row x; Suc ?a < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?a, ?a) dvd x $$ (Suc ?a, Suc ?a)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a.\n              Suc a < dim_row x \\<and> Suc a < dim_col x \\<longrightarrow>\n              x $$ (a, a) dvd x $$ (Suc a, Suc a);\n   Suc (to_nat ?a) < nrows y; Suc (to_nat ?b) < ncols y;\n   to_nat ?a = to_nat ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b dvd y $h (?a + (1::'m)) $h (?b + (1::'n))\n  \\<lbrakk>\\<forall>a b.\n              to_nat a = to_nat b \\<and>\n              Suc (to_nat a) < nrows y \\<and>\n              Suc (to_nat b) < ncols y \\<longrightarrow>\n              y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n));\n   Suc ?a < dim_row x; Suc ?a < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?a, ?a) dvd x $$ (Suc ?a, Suc ?a)\n\ngoal (1 subgoal):\n 1. Smith_normal_form_mat x = Smith_normal_form y", "unfolding Smith_normal_form_mat_def Smith_normal_form_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a.\n              Suc a < dim_row x \\<and> Suc a < dim_col x \\<longrightarrow>\n              x $$ (a, a) dvd x $$ (Suc a, Suc a);\n   Suc (to_nat ?a) < nrows y; Suc (to_nat ?b) < ncols y;\n   to_nat ?a = to_nat ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b dvd y $h (?a + (1::'m)) $h (?b + (1::'n))\n  \\<lbrakk>\\<forall>a b.\n              to_nat a = to_nat b \\<and>\n              Suc (to_nat a) < nrows y \\<and>\n              Suc (to_nat b) < ncols y \\<longrightarrow>\n              y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n));\n   Suc ?a < dim_row x; Suc ?a < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?a, ?a) dvd x $$ (Suc ?a, Suc ?a)\n\ngoal (1 subgoal):\n 1. ((\\<forall>a.\n         a + 1 < min (dim_row x) (dim_col x) \\<longrightarrow>\n         x $$ (a, a) dvd x $$ (a + 1, a + 1)) \\<and>\n     isDiagonal_mat x) =\n    ((\\<forall>a b.\n         to_nat a = to_nat b \\<and>\n         to_nat a + 1 < nrows y \\<and>\n         to_nat b + 1 < ncols y \\<longrightarrow>\n         y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))) \\<and>\n     isDiagonal y)", "using rel_xy"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a.\n              Suc a < dim_row x \\<and> Suc a < dim_col x \\<longrightarrow>\n              x $$ (a, a) dvd x $$ (Suc a, Suc a);\n   Suc (to_nat ?a) < nrows y; Suc (to_nat ?b) < ncols y;\n   to_nat ?a = to_nat ?b\\<rbrakk>\n  \\<Longrightarrow> y $h ?a $h ?b dvd y $h (?a + (1::'m)) $h (?b + (1::'n))\n  \\<lbrakk>\\<forall>a b.\n              to_nat a = to_nat b \\<and>\n              Suc (to_nat a) < nrows y \\<and>\n              Suc (to_nat b) < ncols y \\<longrightarrow>\n              y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n));\n   Suc ?a < dim_row x; Suc ?a < dim_col x\\<rbrakk>\n  \\<Longrightarrow> x $$ (?a, ?a) dvd x $$ (Suc ?a, Suc ?a)\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. ((\\<forall>a.\n         a + 1 < min (dim_row x) (dim_col x) \\<longrightarrow>\n         x $$ (a, a) dvd x $$ (a + 1, a + 1)) \\<and>\n     isDiagonal_mat x) =\n    ((\\<forall>a b.\n         to_nat a = to_nat b \\<and>\n         to_nat a + 1 < nrows y \\<and>\n         to_nat b + 1 < ncols y \\<longrightarrow>\n         y $h a $h b dvd y $h (a + (1::'m)) $h (b + (1::'n))) \\<and>\n     isDiagonal y)", "by (auto) (transfer', auto)+"], ["proof (state)\nthis:\n  Smith_normal_form_mat x = Smith_normal_form y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_admits_SNF [transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n::{mod_type} ^ 'n::{mod_type} \\<Rightarrow> _) ===> (=)) \n  admits_SNF_JNF admits_SNF_HA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) admits_SNF_JNF admits_SNF_HA", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       admits_SNF_JNF x = admits_SNF_HA y", "case (1 x y)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       admits_SNF_JNF x = admits_SNF_HA y", "note [transfer_rule] = this"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       admits_SNF_JNF x = admits_SNF_HA y", "hence id: \"dim_row x = CARD('n)\""], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. dim_row x = CARD('n)", "by (auto simp: Mod_Type_Connect.HMA_M_def)"], ["proof (state)\nthis:\n  dim_row x = CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       admits_SNF_JNF x = admits_SNF_HA y", "then"], ["proof (chain)\npicking this:\n  dim_row x = CARD('n)", "show ?case"], ["proof (prove)\nusing this:\n  dim_row x = CARD('n)\n\ngoal (1 subgoal):\n 1. admits_SNF_JNF x = admits_SNF_HA y", "unfolding admits_SNF_JNF_def admits_SNF_HA_def"], ["proof (prove)\nusing this:\n  dim_row x = CARD('n)\n\ngoal (1 subgoal):\n 1. (square_mat x \\<and> isDiagonal_mat x \\<longrightarrow>\n     (\\<exists>P Q.\n         P \\<in> carrier_mat (dim_row x) (dim_row x) \\<and>\n         Q \\<in> carrier_mat (dim_row x) (dim_row x) \\<and>\n         invertible_mat P \\<and>\n         invertible_mat Q \\<and> Smith_normal_form_mat (P * x * Q))) =\n    (isDiagonal y \\<longrightarrow>\n     (\\<exists>P Q.\n         invertible P \\<and>\n         invertible Q \\<and> Smith_normal_form (P ** y ** Q)))", "by (transfer, auto, metis \"1\" Mod_Type_Connect.dim_col_transfer_rule)"], ["proof (state)\nthis:\n  admits_SNF_JNF x = admits_SNF_HA y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*If the following result holds, then I will get the result.\n  \n  But the theorem is false, since the assumption fixes the type 'n (within the proof is not \n  arbitrary any more). We cannot quantify over type variables in Isabelle/HOL.*)\n\n(*\nlemma diagonal_admits_SNF_imp_bezout_ring_JNF3:\n  assumes admits_SNF: \"\\<forall>A. (A::'a mat) \\<in> carrier_mat (CARD('n)) (CARD('n)) \\<and> isDiagonal_mat A \n\\<longrightarrow> (\\<exists>P Q. P \\<in> carrier_mat (dim_row A) (dim_row A) \n  \\<and> Q \\<in> carrier_mat (dim_row A) (dim_row A) \\<and> invertible_mat P \\<and> invertible_mat Q \n  \\<and> Smith_normal_form_mat (P*A*Q))\"\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class)\" \n  apply (rule diagonal_admits_SNF_imp_bezout_ring_JNF, auto)\n*)"], ["", "text\\<open>Here we have a problem when trying to apply local type definitions\\<close>"], ["", "(*\nOnce the assumption is translated to JNF, we get that it holds for all matrices with \nCARD('n) rows and CARD('n) columns. That is, we do not have the result for any matrix, just \nfor matrices of such dimensions (within the proof, the type 'n is not arbitrary, is fixed).\n*)"], ["", "lemma diagonal_admits_SNF_imp_bezout_ring:\n  assumes admits_SNF: \"\\<forall>A::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type}. isDiagonal A \n    \\<longrightarrow> (\\<exists>P Q. invertible (P::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type}) \n        \\<and> invertible (Q::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type}) \n        \\<and> Smith_normal_form (P**A**Q))\"\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, bezout_ring_class)", "proof (rule diagonal_admits_SNF_imp_bezout_ring_JNF, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A n.\n       \\<lbrakk>A \\<in> carrier_mat n n; isDiagonal_mat A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            P \\<in> carrier_mat n n \\<and>\n                            (\\<exists>Q.\n                                Q \\<in> carrier_mat n n \\<and>\n                                invertible_mat P \\<and>\n                                invertible_mat Q \\<and>\n                                Smith_normal_form_mat (P * A * Q))", "fix A::\"'a mat\" and n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A n.\n       \\<lbrakk>A \\<in> carrier_mat n n; isDiagonal_mat A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            P \\<in> carrier_mat n n \\<and>\n                            (\\<exists>Q.\n                                Q \\<in> carrier_mat n n \\<and>\n                                invertible_mat P \\<and>\n                                invertible_mat Q \\<and>\n                                Smith_normal_form_mat (P * A * Q))", "assume A: \"A \\<in> carrier_mat n n\" and diag_A: \"isDiagonal_mat A\""], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  isDiagonal_mat A\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       \\<lbrakk>A \\<in> carrier_mat n n; isDiagonal_mat A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            P \\<in> carrier_mat n n \\<and>\n                            (\\<exists>Q.\n                                Q \\<in> carrier_mat n n \\<and>\n                                invertible_mat P \\<and>\n                                invertible_mat Q \\<and>\n                                Smith_normal_form_mat (P * A * Q))", "have a: \"\\<forall>A::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type}. admits_SNF_HA A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. admits_SNF_HA A", "using admits_SNF"], ["proof (prove)\nusing this:\n  \\<forall>A.\n     isDiagonal A \\<longrightarrow>\n     (\\<exists>P Q.\n         invertible P \\<and>\n         invertible Q \\<and> Smith_normal_form (P ** A ** Q))\n\ngoal (1 subgoal):\n 1. \\<forall>A. admits_SNF_HA A", "unfolding admits_SNF_HA_def"], ["proof (prove)\nusing this:\n  \\<forall>A.\n     isDiagonal A \\<longrightarrow>\n     (\\<exists>P Q.\n         invertible P \\<and>\n         invertible Q \\<and> Smith_normal_form (P ** A ** Q))\n\ngoal (1 subgoal):\n 1. \\<forall>A.\n       isDiagonal A \\<longrightarrow>\n       (\\<exists>P Q.\n           invertible P \\<and>\n           invertible Q \\<and> Smith_normal_form (P ** A ** Q))", "."], ["proof (state)\nthis:\n  \\<forall>A. admits_SNF_HA A\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       \\<lbrakk>A \\<in> carrier_mat n n; isDiagonal_mat A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            P \\<in> carrier_mat n n \\<and>\n                            (\\<exists>Q.\n                                Q \\<in> carrier_mat n n \\<and>\n                                invertible_mat P \\<and>\n                                invertible_mat Q \\<and>\n                                Smith_normal_form_mat (P * A * Q))", "have JNF: \"\\<forall>(A::'a mat)\\<in> carrier_mat CARD('n) CARD('n). admits_SNF_JNF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat CARD('n) CARD('n). admits_SNF_JNF A", "(*We can get this result, but this does not imply that it holds for any n \\<times> n matrix, just \n    for the concrete case that n = CARD('n). Within this proof, we cannot apply local type \n    definitions, since the 'n is not an schematic variable any more, it is fixed.*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat CARD('n) CARD('n). admits_SNF_JNF A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> carrier_mat CARD('n) CARD('n) \\<Longrightarrow>\n       admits_SNF_JNF A", "fix A::\"'a mat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> carrier_mat CARD('n) CARD('n) \\<Longrightarrow>\n       admits_SNF_JNF A", "assume A: \"A \\<in> carrier_mat CARD('n) CARD('n)\""], ["proof (state)\nthis:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> carrier_mat CARD('n) CARD('n) \\<Longrightarrow>\n       admits_SNF_JNF A", "let ?B = \"(Mod_Type_Connect.to_hma\\<^sub>m  A::'a::comm_ring_1^'n::{mod_type}^'n::{mod_type})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> carrier_mat CARD('n) CARD('n) \\<Longrightarrow>\n       admits_SNF_JNF A", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M A ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A (Mod_Type_Connect.to_hma\\<^sub>m A)", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A (Mod_Type_Connect.to_hma\\<^sub>m A)", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n\ngoal (1 subgoal):\n 1. A =\n    Mod_Type_Connect.from_hma\\<^sub>m (Mod_Type_Connect.to_hma\\<^sub>m A)", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A (Mod_Type_Connect.to_hma\\<^sub>m A)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> carrier_mat CARD('n) CARD('n) \\<Longrightarrow>\n       admits_SNF_JNF A", "have b: \"admits_SNF_HA ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. admits_SNF_HA (Mod_Type_Connect.to_hma\\<^sub>m A)", "using a"], ["proof (prove)\nusing this:\n  \\<forall>A. admits_SNF_HA A\n\ngoal (1 subgoal):\n 1. admits_SNF_HA (Mod_Type_Connect.to_hma\\<^sub>m A)", "by auto"], ["proof (state)\nthis:\n  admits_SNF_HA (Mod_Type_Connect.to_hma\\<^sub>m A)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> carrier_mat CARD('n) CARD('n) \\<Longrightarrow>\n       admits_SNF_JNF A", "show \"admits_SNF_JNF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. admits_SNF_JNF A", "using b"], ["proof (prove)\nusing this:\n  admits_SNF_HA (Mod_Type_Connect.to_hma\\<^sub>m A)\n\ngoal (1 subgoal):\n 1. admits_SNF_JNF A", "by transfer"], ["proof (state)\nthis:\n  admits_SNF_JNF A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>A\\<in>carrier_mat CARD('n) CARD('n). admits_SNF_JNF A\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       \\<lbrakk>A \\<in> carrier_mat n n; isDiagonal_mat A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            P \\<in> carrier_mat n n \\<and>\n                            (\\<exists>Q.\n                                Q \\<in> carrier_mat n n \\<and>\n                                invertible_mat P \\<and>\n                                invertible_mat Q \\<and>\n                                Smith_normal_form_mat (P * A * Q))", "(*Here we cannot apply local type definitions (either cancel_card_constraint or \n  cancel_type_definition) to thm JNF*)"], ["proof (state)\nthis:\n  \\<forall>A\\<in>carrier_mat CARD('n) CARD('n). admits_SNF_JNF A\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       \\<lbrakk>A \\<in> carrier_mat n n; isDiagonal_mat A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            P \\<in> carrier_mat n n \\<and>\n                            (\\<exists>Q.\n                                Q \\<in> carrier_mat n n \\<and>\n                                invertible_mat P \\<and>\n                                invertible_mat Q \\<and>\n                                Smith_normal_form_mat (P * A * Q))", "thus \"\\<exists>P. P \\<in> carrier_mat n n \\<and>\n             (\\<exists>Q. Q \\<in> carrier_mat n n \\<and> invertible_mat P \n        \\<and> invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>carrier_mat CARD('n) CARD('n). admits_SNF_JNF A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> carrier_mat n n \\<and>\n       (\\<exists>Q.\n           Q \\<in> carrier_mat n n \\<and>\n           invertible_mat P \\<and>\n           invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))", "using JNF A diag_A"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>carrier_mat CARD('n) CARD('n). admits_SNF_JNF A\n  \\<forall>A\\<in>carrier_mat CARD('n) CARD('n). admits_SNF_JNF A\n  A \\<in> carrier_mat n n\n  isDiagonal_mat A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> carrier_mat n n \\<and>\n       (\\<exists>Q.\n           Q \\<in> carrier_mat n n \\<and>\n           invertible_mat P \\<and>\n           invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))", "unfolding admits_SNF_JNF_def"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>carrier_mat CARD('n) CARD('n).\n     square_mat A \\<and> isDiagonal_mat A \\<longrightarrow>\n     (\\<exists>P Q.\n         P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n         Q \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n         invertible_mat P \\<and>\n         invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))\n  \\<forall>A\\<in>carrier_mat CARD('n) CARD('n).\n     square_mat A \\<and> isDiagonal_mat A \\<longrightarrow>\n     (\\<exists>P Q.\n         P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n         Q \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n         invertible_mat P \\<and>\n         invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))\n  A \\<in> carrier_mat n n\n  isDiagonal_mat A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> carrier_mat n n \\<and>\n       (\\<exists>Q.\n           Q \\<in> carrier_mat n n \\<and>\n           invertible_mat P \\<and>\n           invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))", "unfolding square_mat.simps"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>carrier_mat CARD('n) CARD('n).\n     dim_col A = dim_row A \\<and> isDiagonal_mat A \\<longrightarrow>\n     (\\<exists>P Q.\n         P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n         Q \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n         invertible_mat P \\<and>\n         invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))\n  \\<forall>A\\<in>carrier_mat CARD('n) CARD('n).\n     dim_col A = dim_row A \\<and> isDiagonal_mat A \\<longrightarrow>\n     (\\<exists>P Q.\n         P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n         Q \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n         invertible_mat P \\<and>\n         invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))\n  A \\<in> carrier_mat n n\n  isDiagonal_mat A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> carrier_mat n n \\<and>\n       (\\<exists>Q.\n           Q \\<in> carrier_mat n n \\<and>\n           invertible_mat P \\<and>\n           invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))", "oops"], ["", "text\\<open>This means that the @{text \"\\<Longrightarrow>\"}  implication cannot be proven in HA, since we cannot quantify\nover type variables in Isabelle/HOL. We then prove both implications in JNF.\\<close>"], ["", "subsection \\<open>Transfering the @{text \"\\<Longleftarrow>\"} implication from HA to JNF using transfer rules \n  and local type definitions\\<close>"], ["", "(*\n  I need to transfer the theorem bezout_ring_imp_diagonal_admits_SNF (stated in HA) to JNF.\n  The first necessary step is to prove transfer rules to connect matrices in HA (when the type\n  of the indexes must be mod_type). The original connection HMA_Connect presented in the \n  Perron--Frobenius development just connects matrices of type 'a^'b::finite^'c::finite with \n  the corresponding ones in JNF, but I need to transfer theorems with matrices of type:\n  'a^'b::mod_type^'c::mod_type.\n\n  The file that allows this bridge is Mod_Type_Connect.  \n\n  Once that step is carried out, I would have to transfer the result by means of the lifting\n  and transfer package and then apply local type definitions to get rid of the type (that is,\n  to change CARD('n) by an arbitrary n).\n\n  The usual approach consists of applying lifting and transfer to the theorem, and then we\n  obtain a fact like \n        \n          A \\<in> carrier_mat (CARD('n::mod_type)) (CARD('n::mod_type))\n\n  When trying to apply local type definitions (to substitute CARD('n::mod_type) by n), then\n  I would have to apply interalize_sort and then proving the restriction class.mod_type (together\n  with the operations associated to that class). Since the mod_type class already introduced\n  several type restrictions (times, neg_numeral_well_order), operations (+,-) and constants (1,0),\n  this means that we have to proceed using dictionary construction. We would have to define\n  a mod_type with explicit operations, to get 'a only of type 'a::type.\n  \n  definition \"mod_type_with n (tms::'a\\<Rightarrow>'a\\<Rightarrow>'a) mns pls zr umns (one'::'a)  \n        (less_eq'::'a\\<Rightarrow>'a\\<Rightarrow>bool) (less'::'a\\<Rightarrow>'a\\<Rightarrow>bool) (Rep_op::'a\\<Rightarrow>int) (Abs_op::int\\<Rightarrow>'a)\n      \\<equiv> (type_definition Rep_op Abs_op {0..<n} \\<and>  1 < n\n      \\<and> (zr = Abs_op 0)\n      \\<and> (one' = Abs_op 1)\n      \\<and> (\\<forall>x y. pls x y = Abs_op (((Rep_op x) + (Rep_op y)) mod (n)))\n      \\<and> (\\<forall>x y. tms x y = Abs_op (((Rep_op x) * (Rep_op y)) mod (n)))\n      \\<and> (\\<forall>x y. mns x y = Abs_op (((Rep_op x) - (Rep_op y)) mod (n)))\n      \\<and> (\\<forall>x. umns x = Abs_op ((- (Rep_op x)) mod (n)))\n      \\<and> (\\<forall>x y. less' x y \\<longrightarrow> (Rep_op x) < (Rep_op y))\n      \\<and> class.neg_numeral mns pls zr umns\n      \\<and> class.wellorder less_eq' less')\"\n\n  Once this is completed, I would have to connect mod_type and mod_type_with, \n  prove new transfer rules and so on. This is the usual approach and has been successfully applied,\n  for instance, by Fabian Immler to transform a (type based) library of linear algebra into another\n  one with explicit carriers.\n\n  Fortunately, in this case there is a shortcut: we can use the type 'a mod_ring from the\n  Berlekamp--Zassenhaus development to express the lemma in HA \n  (thm bezout_ring_imp_diagonal_admits_SNF) using that type (the type 'a mod_ring is an instance\n  of the mod_type class, and then is a particular case).\n\n  This means that any lemma that has a matrix of type 'a^'b::mod_type^'c^'mod_type can be expressed\n  as 'a^'b mod_ring^'c mod_ring, where 'b and 'c must satisfy the nontriv restriction \n  (they must have more than one element).\n\n  This is done in the file Finite_Field_Mod_Type_Connection, which shows that 'a mod_ring is an\n  instance of the mod_type class.\n\n  This type 'a mod_ring has a very useful property: CARD('b mod_ring) = CARD('b)\n  This means that it is very easy to apply local type definitions. The problematic fact\n  would then be transformed to:\n  \n      A \\<in> carrier_mat (CARD('n::nontriv)) (CARD('n::nontriv)). \n\n  It is very easy to apply local type definitions to this fact, since it is very easy to get rid\n  of the nontriv restriction (on the contrary, the mod_type restriction was quite hard).\n\n*)\n\n\n(*\n  In our concrete case: we write the theorem in terms of the mod_ring type thanks to \n  the file Finite_Field_Mod_Type_Connection.\n\n  With this type 'n::nontriv mod_ring I can easily apply local type definitions, since we\n  will get CARD(?'n::nontriv).\n*)"], ["", "lemma bezout_ring_imp_diagonal_admits_SNF_mod_ring:\n  assumes of: \"OFCLASS('a::comm_ring_1, bezout_ring_class)\"\n  shows \"\\<forall>A::'a^'n::nontriv mod_ring^'n::nontriv mod_ring. isDiagonal A \n    \\<longrightarrow> (\\<exists>P Q. \n        invertible (P::'a^'n::nontriv mod_ring^'n::nontriv mod_ring) \\<and> \n        invertible (Q::'a^'n::nontriv mod_ring^'n::nontriv mod_ring) \\<and> \n        Smith_normal_form (P**A**Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       isDiagonal A \\<longrightarrow>\n       (\\<exists>P Q.\n           invertible P \\<and>\n           invertible Q \\<and> Smith_normal_form (P ** A ** Q))", "using bezout_ring_imp_diagonal_admits_SNF[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>A.\n     isDiagonal A \\<longrightarrow>\n     (\\<exists>P Q.\n         invertible P \\<and>\n         invertible Q \\<and> Smith_normal_form (P ** A ** Q))\n\ngoal (1 subgoal):\n 1. \\<forall>A.\n       isDiagonal A \\<longrightarrow>\n       (\\<exists>P Q.\n           invertible P \\<and>\n           invertible Q \\<and> Smith_normal_form (P ** A ** Q))", "by auto"], ["", "lemma bezout_ring_imp_diagonal_admits_SNF_mod_ring_admits: \n  assumes of: \"class.bezout_ring (*) (1::'a::comm_ring_1) (+) 0 (-) uminus\" (*It is equivalent to the statement based on OFCLASS*)\n  shows \"\\<forall>A::'a^'n::nontriv mod_ring^'n::nontriv mod_ring. admits_SNF_HA A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. admits_SNF_HA A", "using bezout_ring_imp_diagonal_admits_SNF\n        [OF Rings2.class.Rings2.bezout_ring.of_class.intro[OF of]]"], ["proof (prove)\nusing this:\n  \\<forall>A.\n     isDiagonal A \\<longrightarrow>\n     (\\<exists>P Q.\n         invertible P \\<and>\n         invertible Q \\<and> Smith_normal_form (P ** A ** Q))\n\ngoal (1 subgoal):\n 1. \\<forall>A. admits_SNF_HA A", "unfolding admits_SNF_HA_def"], ["proof (prove)\nusing this:\n  \\<forall>A.\n     isDiagonal A \\<longrightarrow>\n     (\\<exists>P Q.\n         invertible P \\<and>\n         invertible Q \\<and> Smith_normal_form (P ** A ** Q))\n\ngoal (1 subgoal):\n 1. \\<forall>A.\n       isDiagonal A \\<longrightarrow>\n       (\\<exists>P Q.\n           invertible P \\<and>\n           invertible Q \\<and> Smith_normal_form (P ** A ** Q))", "by auto"], ["", "text\\<open>I start here to apply local type definitions\\<close>"], ["", "context\n  fixes p::nat\n  assumes local_typedef: \"\\<exists>(Rep :: ('b \\<Rightarrow> int)) Abs. type_definition Rep Abs {0..<p :: int}\"\n  and p: \"p>1\"\nbegin"], ["", "lemma type_to_set:\n  shows \"class.nontriv TYPE('b)\" (is ?a) and \"p=CARD('b)\" (is ?b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b) &&& p = CARD('b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. p = CARD('b)", "from local_typedef"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<int p}", "obtain Rep::\"('b \\<Rightarrow> int)\" and Abs \n    where t: \"type_definition Rep Abs {0..<p :: int}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<int p}\n\ngoal (1 subgoal):\n 1. (\\<And>Rep Abs.\n        type_definition Rep Abs {0..<int p} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  type_definition Rep Abs {0..<int p}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. p = CARD('b)", "have \"card (UNIV :: 'b set) = card {0..<p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<p}", "using t type_definition.card"], ["proof (prove)\nusing this:\n  type_definition Rep Abs {0..<int p}\n  type_definition ?Rep ?Abs ?A \\<Longrightarrow> CARD(?'b) = card ?A\n\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<p}", "by fastforce"], ["proof (state)\nthis:\n  CARD('b) = card {0..<p}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. p = CARD('b)", "also"], ["proof (state)\nthis:\n  CARD('b) = card {0..<p}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. p = CARD('b)", "have \"... = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<p} = p", "by auto"], ["proof (state)\nthis:\n  card {0..<p} = p\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. p = CARD('b)", "finally"], ["proof (chain)\npicking this:\n  CARD('b) = p", "show ?b"], ["proof (prove)\nusing this:\n  CARD('b) = p\n\ngoal (1 subgoal):\n 1. p = CARD('b)", ".."], ["proof (state)\nthis:\n  p = CARD('b)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b)", "then"], ["proof (chain)\npicking this:\n  p = CARD('b)", "show ?a"], ["proof (prove)\nusing this:\n  p = CARD('b)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b)", "unfolding class.nontriv_def"], ["proof (prove)\nusing this:\n  p = CARD('b)\n\ngoal (1 subgoal):\n 1. 1 < CARD('b)", "using p"], ["proof (prove)\nusing this:\n  p = CARD('b)\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < CARD('b)", "by auto"], ["proof (state)\nthis:\n  class.nontriv TYPE('b)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>I transfer the lemma from HA to JNF, substituting @{text \"CARD('n)\"} by $p$. \n  I apply @{text \"internalize-sort\"} to @{text \"'n\"} and get rid of \n  the @{text \"nontriv\"} restriction.\\<close>"], ["", "lemma bezout_ring_imp_diagonal_admits_SNF_mod_ring_admits_aux:\n  assumes \"class.bezout_ring (*) (1::'a::comm_ring_1) (+) 0 (-) uminus\"\n  shows \"Ball {A::'a::comm_ring_1 mat. A \\<in> carrier_mat p p} admits_SNF_JNF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball {A. A \\<in> carrier_mat p p} admits_SNF_JNF", "using bezout_ring_imp_diagonal_admits_SNF_mod_ring_admits[untransferred, unfolded CARD_mod_ring, \n      internalize_sort \"'n::nontriv\", where ?'a='b]"], ["proof (prove)\nusing this:\n  \\<lbrakk>class.nontriv TYPE('b);\n   class.bezout_ring (*) (1::?'aa) (+) (0::?'aa) (-) uminus\\<rbrakk>\n  \\<Longrightarrow> Ball {A. A \\<in> carrier_mat CARD('b) CARD('b)}\n                     admits_SNF_JNF\n\ngoal (1 subgoal):\n 1. Ball {A. A \\<in> carrier_mat p p} admits_SNF_JNF", "unfolding type_to_set(2)[symmetric]"], ["proof (prove)\nusing this:\n  \\<lbrakk>class.nontriv TYPE('b);\n   class.bezout_ring (*) (1::?'aa) (+) (0::?'aa) (-) uminus\\<rbrakk>\n  \\<Longrightarrow> Ball {A. A \\<in> carrier_mat p p} admits_SNF_JNF\n\ngoal (1 subgoal):\n 1. Ball {A. A \\<in> carrier_mat p p} admits_SNF_JNF", "using type_to_set(1) assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>class.nontriv TYPE('b);\n   class.bezout_ring (*) (1::?'aa) (+) (0::?'aa) (-) uminus\\<rbrakk>\n  \\<Longrightarrow> Ball {A. A \\<in> carrier_mat p p} admits_SNF_JNF\n  class.nontriv TYPE('b)\n  class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus\n\ngoal (1 subgoal):\n 1. Ball {A. A \\<in> carrier_mat p p} admits_SNF_JNF", "by auto"], ["", "end"], ["", "text\\<open>The @{text \"\\<Longleftarrow>\"} implication in JNF\\<close>"], ["", "text\\<open>Since @{text \"nontriv\"} imposes the type to have more than one element, \n  the cases $n=0$ (@{text \"A \\<in> carrier_mat 0 0\"}) and $n = 1$ (@{text \"A \\<in> carrier_mat 1 1\"})\n  must be treated separately.\\<close>"], ["", "lemma bezout_ring_imp_diagonal_admits_SNF_mod_ring_admits_aux2:\n  assumes of: \"class.bezout_ring (*) (1::'a::comm_ring_1) (+) 0 (-) uminus\"\n  shows \"\\<forall>(A::'a mat)\\<in>carrier_mat n n. admits_SNF_JNF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "by (rule, unfold True admits_SNF_JNF_def isDiagonal_mat_def invertible_mat_def \n        Smith_normal_form_mat_def carrier_mat_def inverts_mat_def, fastforce)"], ["proof (state)\nthis:\n  \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "note not0 = False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "proof (cases \"n=1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow> \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "case True"], ["proof (state)\nthis:\n  n = 1\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow> \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "by (rule, unfold True admits_SNF_JNF_def isDiagonal_mat_def invertible_mat_def \n        Smith_normal_form_mat_def carrier_mat_def inverts_mat_def, auto)\n       (metis dvd_1_left index_one_mat(2) index_one_mat(3) less_Suc0 nat_dvd_not_less \n        right_mult_one_mat' zero_less_Suc)"], ["proof (state)\nthis:\n  \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 1", "have \"n>1\""], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < n", "using not0"], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 < n", "by auto"], ["proof (state)\nthis:\n  1 < n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "then"], ["proof (chain)\npicking this:\n  1 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "(*Here I apply the local type definition rule, to cancel the type*)"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "using bezout_ring_imp_diagonal_admits_SNF_mod_ring_admits_aux[cancel_type_definition, of n] of"], ["proof (prove)\nusing this:\n  1 < n\n  \\<lbrakk>{0..<int n} \\<noteq> {}; 1 < n;\n   class.bezout_ring (*) (1::?'a) (+) (0::?'a) (-) uminus\\<rbrakk>\n  \\<Longrightarrow> Ball {A. A \\<in> carrier_mat n n} admits_SNF_JNF\n  class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A", "by auto"], ["proof (state)\nthis:\n  \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>A\\<in>carrier_mat n n. admits_SNF_JNF A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Alternative statements\\<close>"], ["", "lemma bezout_ring_imp_diagonal_admits_SNF_JNF:\n  assumes of: \"class.bezout_ring (*) (1::'a::comm_ring_1) (+) 0 (-) uminus\"\n  shows \"\\<forall>A::'a mat. admits_SNF_JNF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. admits_SNF_JNF A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. admits_SNF_JNF A", "fix A::\"'a mat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. admits_SNF_JNF A", "have \"A\\<in> carrier_mat (dim_row A) (dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_row A) (dim_col A)", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> {m. dim_row m = dim_row A \\<and> dim_col m = dim_col A}", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat (dim_row A) (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<And>A. admits_SNF_JNF A", "thus \"admits_SNF_JNF A\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat (dim_row A) (dim_col A)\n\ngoal (1 subgoal):\n 1. admits_SNF_JNF A", "using bezout_ring_imp_diagonal_admits_SNF_mod_ring_admits_aux2[OF of]"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat (dim_row A) (dim_col A)\n  \\<forall>A\\<in>carrier_mat ?n ?n. admits_SNF_JNF A\n\ngoal (1 subgoal):\n 1. admits_SNF_JNF A", "by (metis admits_SNF_JNF_def square_mat.elims(2))"], ["proof (state)\nthis:\n  admits_SNF_JNF A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma admits_SNF_JNF_alt_def:\n  \"(\\<forall>A::'a::comm_ring_1 mat. admits_SNF_JNF A) \n  = (\\<forall>A n. (A::'a mat) \\<in> carrier_mat n n \\<and> isDiagonal_mat A\n  \\<longrightarrow> (\\<exists>P Q. P \\<in> carrier_mat n n \\<and> Q \\<in> carrier_mat n n \\<and> invertible_mat P \\<and> invertible_mat Q \n      \\<and> Smith_normal_form_mat (P*A*Q)))\" (is \"?a = ?b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>A. admits_SNF_JNF A) =\n    (\\<forall>A n.\n        A \\<in> carrier_mat n n \\<and> isDiagonal_mat A \\<longrightarrow>\n        (\\<exists>P Q.\n            P \\<in> carrier_mat n n \\<and>\n            Q \\<in> carrier_mat n n \\<and>\n            invertible_mat P \\<and>\n            invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q)))", "by (auto simp add: admits_SNF_JNF_def, metis carrier_matD(1) carrier_matD(2), blast)"], ["", "subsection \\<open>Final theorem in JNF\\<close>"], ["", "text \\<open>Final theorem using @{text \"class.bezout_ring\"}\\<close>"], ["", "theorem diagonal_admits_SNF_iff_bezout_ring:\n  shows \"class.bezout_ring (*) (1::'a::comm_ring_1) (+) 0 (-) uminus \n  \\<longleftrightarrow> (\\<forall>A::'a mat. admits_SNF_JNF A)\" (is \"?a \\<longleftrightarrow> ?b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus =\n    (\\<forall>A. admits_SNF_JNF A)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus \\<Longrightarrow>\n    \\<forall>A. admits_SNF_JNF A\n 2. \\<forall>A. admits_SNF_JNF A \\<Longrightarrow>\n    class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "assume ?a"], ["proof (state)\nthis:\n  class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus\n\ngoal (2 subgoals):\n 1. class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus \\<Longrightarrow>\n    \\<forall>A. admits_SNF_JNF A\n 2. \\<forall>A. admits_SNF_JNF A \\<Longrightarrow>\n    class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "thus ?b"], ["proof (prove)\nusing this:\n  class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus\n\ngoal (1 subgoal):\n 1. \\<forall>A. admits_SNF_JNF A", "using bezout_ring_imp_diagonal_admits_SNF_JNF"], ["proof (prove)\nusing this:\n  class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus\n  class.bezout_ring (*) (1::?'a) (+) (0::?'a) (-) uminus \\<Longrightarrow>\n  \\<forall>A. admits_SNF_JNF A\n\ngoal (1 subgoal):\n 1. \\<forall>A. admits_SNF_JNF A", "by auto"], ["proof (state)\nthis:\n  \\<forall>A. admits_SNF_JNF A\n\ngoal (1 subgoal):\n 1. \\<forall>A. admits_SNF_JNF A \\<Longrightarrow>\n    class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>A. admits_SNF_JNF A \\<Longrightarrow>\n    class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "assume b: ?b"], ["proof (state)\nthis:\n  \\<forall>A. admits_SNF_JNF A\n\ngoal (1 subgoal):\n 1. \\<forall>A. admits_SNF_JNF A \\<Longrightarrow>\n    class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "have rw: \"\\<forall>A n. (A::'a mat) \\<in> carrier_mat n n \\<and> isDiagonal_mat A \\<longrightarrow>\n          (\\<exists>P Q. P \\<in> carrier_mat n n \\<and> Q \\<in> carrier_mat n n \\<and> invertible_mat P \n          \\<and> invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A n.\n       A \\<in> carrier_mat n n \\<and> isDiagonal_mat A \\<longrightarrow>\n       (\\<exists>P Q.\n           P \\<in> carrier_mat n n \\<and>\n           Q \\<in> carrier_mat n n \\<and>\n           invertible_mat P \\<and>\n           invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))", "using admits_SNF_JNF_alt_def b"], ["proof (prove)\nusing this:\n  (\\<forall>A. admits_SNF_JNF A) =\n  (\\<forall>A n.\n      A \\<in> carrier_mat n n \\<and> isDiagonal_mat A \\<longrightarrow>\n      (\\<exists>P Q.\n          P \\<in> carrier_mat n n \\<and>\n          Q \\<in> carrier_mat n n \\<and>\n          invertible_mat P \\<and>\n          invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q)))\n  \\<forall>A. admits_SNF_JNF A\n\ngoal (1 subgoal):\n 1. \\<forall>A n.\n       A \\<in> carrier_mat n n \\<and> isDiagonal_mat A \\<longrightarrow>\n       (\\<exists>P Q.\n           P \\<in> carrier_mat n n \\<and>\n           Q \\<in> carrier_mat n n \\<and>\n           invertible_mat P \\<and>\n           invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))", "by auto"], ["proof (state)\nthis:\n  \\<forall>A n.\n     A \\<in> carrier_mat n n \\<and> isDiagonal_mat A \\<longrightarrow>\n     (\\<exists>P Q.\n         P \\<in> carrier_mat n n \\<and>\n         Q \\<in> carrier_mat n n \\<and>\n         invertible_mat P \\<and>\n         invertible_mat Q \\<and> Smith_normal_form_mat (P * A * Q))\n\ngoal (1 subgoal):\n 1. \\<forall>A. admits_SNF_JNF A \\<Longrightarrow>\n    class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "show ?a"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "using diagonal_admits_SNF_imp_bezout_ring_JNF[OF rw]"], ["proof (prove)\nusing this:\n  OFCLASS('a, bezout_ring_class)\n\ngoal (1 subgoal):\n 1. class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "using OFCLASS_bezout_ring_imp_class_bezout_ring[where ?'a='a]"], ["proof (prove)\nusing this:\n  OFCLASS('a, bezout_ring_class)\n  OFCLASS('a, bezout_ring_class) \\<Longrightarrow>\n  class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus\n\ngoal (1 subgoal):\n 1. class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "by auto"], ["proof (state)\nthis:\n  class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Final theorem using @{text \"OFCLASS\"}\\<close>"], ["", "theorem diagonal_admits_SNF_iff_bezout_ring':\n  shows \"OFCLASS('a::comm_ring_1, bezout_ring_class) \\<equiv> (\\<And>A::'a mat. admits_SNF_JNF A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, bezout_ring_class) \\<equiv> (\\<And>A. admits_SNF_JNF A)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       OFCLASS('a, bezout_ring_class) \\<Longrightarrow> admits_SNF_JNF A\n 2. (\\<And>A. admits_SNF_JNF A) \\<Longrightarrow>\n    OFCLASS('a, bezout_ring_class)", "fix A::\"'a mat\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       OFCLASS('a, bezout_ring_class) \\<Longrightarrow> admits_SNF_JNF A\n 2. (\\<And>A. admits_SNF_JNF A) \\<Longrightarrow>\n    OFCLASS('a, bezout_ring_class)", "assume a: \"OFCLASS('a, bezout_ring_class)\""], ["proof (state)\nthis:\n  OFCLASS('a, bezout_ring_class)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       OFCLASS('a, bezout_ring_class) \\<Longrightarrow> admits_SNF_JNF A\n 2. (\\<And>A. admits_SNF_JNF A) \\<Longrightarrow>\n    OFCLASS('a, bezout_ring_class)", "show \"admits_SNF_JNF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. admits_SNF_JNF A", "using OFCLASS_bezout_ring_imp_class_bezout_ring[OF a] diagonal_admits_SNF_iff_bezout_ring"], ["proof (prove)\nusing this:\n  class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus\n  class.bezout_ring (*) (1::?'a) (+) (0::?'a) (-) uminus =\n  (\\<forall>A. admits_SNF_JNF A)\n\ngoal (1 subgoal):\n 1. admits_SNF_JNF A", "by auto"], ["proof (state)\nthis:\n  admits_SNF_JNF A\n\ngoal (1 subgoal):\n 1. (\\<And>A. admits_SNF_JNF A) \\<Longrightarrow>\n    OFCLASS('a, bezout_ring_class)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A. admits_SNF_JNF A) \\<Longrightarrow>\n    OFCLASS('a, bezout_ring_class)", "assume \"(\\<And>A::'a mat. admits_SNF_JNF A)\""], ["proof (state)\nthis:\n  admits_SNF_JNF ?A\n\ngoal (1 subgoal):\n 1. (\\<And>A. admits_SNF_JNF A) \\<Longrightarrow>\n    OFCLASS('a, bezout_ring_class)", "hence *: \"class.bezout_ring (*) (1::'a) (+) 0 (-) uminus\""], ["proof (prove)\nusing this:\n  admits_SNF_JNF ?A\n\ngoal (1 subgoal):\n 1. class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "using diagonal_admits_SNF_iff_bezout_ring"], ["proof (prove)\nusing this:\n  admits_SNF_JNF ?A\n  class.bezout_ring (*) (1::?'a) (+) (0::?'a) (-) uminus =\n  (\\<forall>A. admits_SNF_JNF A)\n\ngoal (1 subgoal):\n 1. class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus", "by auto"], ["proof (state)\nthis:\n  class.bezout_ring (*) (1::'a) (+) (0::'a) (-) uminus\n\ngoal (1 subgoal):\n 1. (\\<And>A. admits_SNF_JNF A) \\<Longrightarrow>\n    OFCLASS('a, bezout_ring_class)", "show \"OFCLASS('a, bezout_ring_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, bezout_ring_class)", "by (rule Rings2.class.Rings2.bezout_ring.of_class.intro, rule *)"], ["proof (state)\nthis:\n  OFCLASS('a, bezout_ring_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}