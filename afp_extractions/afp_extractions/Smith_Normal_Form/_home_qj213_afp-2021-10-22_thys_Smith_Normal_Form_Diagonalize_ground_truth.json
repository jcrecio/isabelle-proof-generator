{"file_name": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form/Diagonalize.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form", "problem_names": ["lemma soundness_diagonalize_JNF':\n  fixes A::\"'a mat\"\n  assumes \"is_bezout_ext bezout\" and \"A \\<in> carrier_mat m n\"\n  and \"diagonalize_JNF A bezout = (P,S,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> Q \\<in> carrier_mat n n \\<and> S \\<in> carrier_mat m n \n      \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> isDiagonal_mat S \\<and> S = P*A*Q\"", "lemma soundness_diagonalize:\n  assumes b: \"is_bezout_ext bezout\"\n  and d: \"diagonalize A bezout = (P,S,Q)\"\nshows \"invertible P \\<and> invertible Q \\<and> isDiagonal S \\<and> S = P**A**Q\""], "translations": [["", "lemma soundness_diagonalize_JNF':\n  fixes A::\"'a mat\"\n  assumes \"is_bezout_ext bezout\" and \"A \\<in> carrier_mat m n\"\n  and \"diagonalize_JNF A bezout = (P,S,Q)\"\n  shows \"P \\<in> carrier_mat m m \\<and> Q \\<in> carrier_mat n n \\<and> S \\<in> carrier_mat m n \n      \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> isDiagonal_mat S \\<and> S = P*A*Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    Q \\<in> carrier_mat n n \\<and>\n    S \\<in> carrier_mat m n \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and> isDiagonal_mat S \\<and> S = P * A * Q", "using soundness_diagonalize_JNF assms"], ["proof (prove)\nusing this:\n  \\<forall>A bezout.\n     A \\<in> carrier_mat ?m ?n \\<and> is_bezout_ext bezout \\<longrightarrow>\n     (case diagonalize_JNF A bezout of\n      (P, S, Q) \\<Rightarrow>\n        P \\<in> carrier_mat ?m ?m \\<and>\n        Q \\<in> carrier_mat ?n ?n \\<and>\n        S \\<in> carrier_mat ?m ?n \\<and>\n        invertible_mat P \\<and>\n        invertible_mat Q \\<and> isDiagonal_mat S \\<and> S = P * A * Q)\n  is_bezout_ext bezout\n  A \\<in> carrier_mat m n\n  diagonalize_JNF A bezout = (P, S, Q)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    Q \\<in> carrier_mat n n \\<and>\n    S \\<in> carrier_mat m n \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and> isDiagonal_mat S \\<and> S = P * A * Q", "unfolding case_prod_beta"], ["proof (prove)\nusing this:\n  \\<forall>A bezout.\n     A \\<in> carrier_mat ?m ?n \\<and> is_bezout_ext bezout \\<longrightarrow>\n     fst (diagonalize_JNF A bezout) \\<in> carrier_mat ?m ?m \\<and>\n     snd (snd (diagonalize_JNF A bezout)) \\<in> carrier_mat ?n ?n \\<and>\n     fst (snd (diagonalize_JNF A bezout)) \\<in> carrier_mat ?m ?n \\<and>\n     invertible_mat (fst (diagonalize_JNF A bezout)) \\<and>\n     invertible_mat (snd (snd (diagonalize_JNF A bezout))) \\<and>\n     isDiagonal_mat (fst (snd (diagonalize_JNF A bezout))) \\<and>\n     fst (snd (diagonalize_JNF A bezout)) =\n     fst (diagonalize_JNF A bezout) * A *\n     snd (snd (diagonalize_JNF A bezout))\n  is_bezout_ext bezout\n  A \\<in> carrier_mat m n\n  diagonalize_JNF A bezout = (P, S, Q)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat m m \\<and>\n    Q \\<in> carrier_mat n n \\<and>\n    S \\<in> carrier_mat m n \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and> isDiagonal_mat S \\<and> S = P * A * Q", "by (metis fst_conv snd_conv)"], ["", "subsection \\<open>Implementation and soundness result moved to HOL Analysis.\\<close>"], ["", "definition diagonalize :: \"'a::bezout_ring ^ 'nc :: mod_type ^ 'nr :: mod_type\n     \\<Rightarrow> 'a bezout \\<Rightarrow> \n    (('a ^ 'nr :: mod_type ^ 'nr :: mod_type) \n    \\<times> ('a ^ 'nc :: mod_type ^ 'nr :: mod_type) \n    \\<times> ('a ^ 'nc :: mod_type ^ 'nc :: mod_type))\"\n  where \"diagonalize A bezout = (\n    let (P,S,Q) = diagonalize_JNF (Mod_Type_Connect.from_hma\\<^sub>m A) bezout\n    in (Mod_Type_Connect.to_hma\\<^sub>m P,Mod_Type_Connect.to_hma\\<^sub>m S,Mod_Type_Connect.to_hma\\<^sub>m Q)\n  )\""], ["", "lemma soundness_diagonalize:\n  assumes b: \"is_bezout_ext bezout\"\n  and d: \"diagonalize A bezout = (P,S,Q)\"\nshows \"invertible P \\<and> invertible Q \\<and> isDiagonal S \\<and> S = P**A**Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "define A' where \"A' = Mod_Type_Connect.from_hma\\<^sub>m A\""], ["proof (state)\nthis:\n  A' = Mod_Type_Connect.from_hma\\<^sub>m A\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "obtain P' S' Q' where d_JNF: \"(P',S',Q') = diagonalize_JNF A' bezout\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P' S' Q'.\n        (P', S', Q') = diagonalize_JNF A' bezout \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (P', S', Q') = diagonalize_JNF A' bezout\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "define m and n where \"m = dim_row A'\" and \"n = dim_col A'\""], ["proof (state)\nthis:\n  m = dim_row A'\n  n = dim_col A'\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "hence A': \"A' \\<in> carrier_mat m n\""], ["proof (prove)\nusing this:\n  m = dim_row A'\n  n = dim_col A'\n\ngoal (1 subgoal):\n 1. A' \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  A' \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "have res_JNF: \"P' \\<in> carrier_mat m m \\<and> Q' \\<in> carrier_mat n n \\<and> S' \\<in> carrier_mat m n \n      \\<and> invertible_mat P' \\<and> invertible_mat Q' \\<and> isDiagonal_mat S' \\<and> S' = P'*A'*Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<in> carrier_mat m m \\<and>\n    Q' \\<in> carrier_mat n n \\<and>\n    S' \\<in> carrier_mat m n \\<and>\n    invertible_mat P' \\<and>\n    invertible_mat Q' \\<and> isDiagonal_mat S' \\<and> S' = P' * A' * Q'", "by (rule soundness_diagonalize_JNF'[OF b A' d_JNF[symmetric]])"], ["proof (state)\nthis:\n  P' \\<in> carrier_mat m m \\<and>\n  Q' \\<in> carrier_mat n n \\<and>\n  S' \\<in> carrier_mat m n \\<and>\n  invertible_mat P' \\<and>\n  invertible_mat Q' \\<and> isDiagonal_mat S' \\<and> S' = P' * A' * Q'\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "have \"Mod_Type_Connect.to_hma\\<^sub>m P' = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m P' = P", "using d"], ["proof (prove)\nusing this:\n  local.diagonalize A bezout = (P, S, Q)\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m P' = P", "unfolding diagonalize_def Let_def"], ["proof (prove)\nusing this:\n  (case diagonalize_JNF (Mod_Type_Connect.from_hma\\<^sub>m A) bezout of\n   (P, S, Q) \\<Rightarrow>\n     (Mod_Type_Connect.to_hma\\<^sub>m P, Mod_Type_Connect.to_hma\\<^sub>m S,\n      Mod_Type_Connect.to_hma\\<^sub>m Q)) =\n  (P, S, Q)\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m P' = P", "by (metis A'_def d_JNF fst_conv old.prod.case)"], ["proof (state)\nthis:\n  Mod_Type_Connect.to_hma\\<^sub>m P' = P\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "hence \"P' = Mod_Type_Connect.from_hma\\<^sub>m P\""], ["proof (prove)\nusing this:\n  Mod_Type_Connect.to_hma\\<^sub>m P' = P\n\ngoal (1 subgoal):\n 1. P' = Mod_Type_Connect.from_hma\\<^sub>m P", "using A'_def m_def res_JNF"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.to_hma\\<^sub>m P' = P\n  A' = Mod_Type_Connect.from_hma\\<^sub>m A\n  m = dim_row A'\n  P' \\<in> carrier_mat m m \\<and>\n  Q' \\<in> carrier_mat n n \\<and>\n  S' \\<in> carrier_mat m n \\<and>\n  invertible_mat P' \\<and>\n  invertible_mat Q' \\<and> isDiagonal_mat S' \\<and> S' = P' * A' * Q'\n\ngoal (1 subgoal):\n 1. P' = Mod_Type_Connect.from_hma\\<^sub>m P", "by auto"], ["proof (state)\nthis:\n  P' = Mod_Type_Connect.from_hma\\<^sub>m P\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "hence [transfer_rule]: \"Mod_Type_Connect.HMA_M P' P\""], ["proof (prove)\nusing this:\n  P' = Mod_Type_Connect.from_hma\\<^sub>m P\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M P' P", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\nusing this:\n  P' = Mod_Type_Connect.from_hma\\<^sub>m P\n\ngoal (1 subgoal):\n 1. P' = Mod_Type_Connect.from_hma\\<^sub>m P", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M P' P\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "have \"Mod_Type_Connect.to_hma\\<^sub>m Q' = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m Q' = Q", "using d"], ["proof (prove)\nusing this:\n  local.diagonalize A bezout = (P, S, Q)\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m Q' = Q", "unfolding diagonalize_def Let_def"], ["proof (prove)\nusing this:\n  (case diagonalize_JNF (Mod_Type_Connect.from_hma\\<^sub>m A) bezout of\n   (P, S, Q) \\<Rightarrow>\n     (Mod_Type_Connect.to_hma\\<^sub>m P, Mod_Type_Connect.to_hma\\<^sub>m S,\n      Mod_Type_Connect.to_hma\\<^sub>m Q)) =\n  (P, S, Q)\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m Q' = Q", "by (metis A'_def d_JNF snd_conv old.prod.case)"], ["proof (state)\nthis:\n  Mod_Type_Connect.to_hma\\<^sub>m Q' = Q\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "hence \"Q' = Mod_Type_Connect.from_hma\\<^sub>m Q\""], ["proof (prove)\nusing this:\n  Mod_Type_Connect.to_hma\\<^sub>m Q' = Q\n\ngoal (1 subgoal):\n 1. Q' = Mod_Type_Connect.from_hma\\<^sub>m Q", "using A'_def n_def res_JNF"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.to_hma\\<^sub>m Q' = Q\n  A' = Mod_Type_Connect.from_hma\\<^sub>m A\n  n = dim_col A'\n  P' \\<in> carrier_mat m m \\<and>\n  Q' \\<in> carrier_mat n n \\<and>\n  S' \\<in> carrier_mat m n \\<and>\n  invertible_mat P' \\<and>\n  invertible_mat Q' \\<and> isDiagonal_mat S' \\<and> S' = P' * A' * Q'\n\ngoal (1 subgoal):\n 1. Q' = Mod_Type_Connect.from_hma\\<^sub>m Q", "by auto"], ["proof (state)\nthis:\n  Q' = Mod_Type_Connect.from_hma\\<^sub>m Q\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "hence [transfer_rule]: \"Mod_Type_Connect.HMA_M Q' Q\""], ["proof (prove)\nusing this:\n  Q' = Mod_Type_Connect.from_hma\\<^sub>m Q\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M Q' Q", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\nusing this:\n  Q' = Mod_Type_Connect.from_hma\\<^sub>m Q\n\ngoal (1 subgoal):\n 1. Q' = Mod_Type_Connect.from_hma\\<^sub>m Q", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M Q' Q\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "have \"Mod_Type_Connect.to_hma\\<^sub>m S' = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m S' = S", "using d"], ["proof (prove)\nusing this:\n  local.diagonalize A bezout = (P, S, Q)\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m S' = S", "unfolding diagonalize_def Let_def"], ["proof (prove)\nusing this:\n  (case diagonalize_JNF (Mod_Type_Connect.from_hma\\<^sub>m A) bezout of\n   (P, S, Q) \\<Rightarrow>\n     (Mod_Type_Connect.to_hma\\<^sub>m P, Mod_Type_Connect.to_hma\\<^sub>m S,\n      Mod_Type_Connect.to_hma\\<^sub>m Q)) =\n  (P, S, Q)\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m S' = S", "by (metis A'_def d_JNF snd_conv old.prod.case)"], ["proof (state)\nthis:\n  Mod_Type_Connect.to_hma\\<^sub>m S' = S\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "hence \"S' = Mod_Type_Connect.from_hma\\<^sub>m S\""], ["proof (prove)\nusing this:\n  Mod_Type_Connect.to_hma\\<^sub>m S' = S\n\ngoal (1 subgoal):\n 1. S' = Mod_Type_Connect.from_hma\\<^sub>m S", "using A'_def m_def n_def res_JNF"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.to_hma\\<^sub>m S' = S\n  A' = Mod_Type_Connect.from_hma\\<^sub>m A\n  m = dim_row A'\n  n = dim_col A'\n  P' \\<in> carrier_mat m m \\<and>\n  Q' \\<in> carrier_mat n n \\<and>\n  S' \\<in> carrier_mat m n \\<and>\n  invertible_mat P' \\<and>\n  invertible_mat Q' \\<and> isDiagonal_mat S' \\<and> S' = P' * A' * Q'\n\ngoal (1 subgoal):\n 1. S' = Mod_Type_Connect.from_hma\\<^sub>m S", "by auto"], ["proof (state)\nthis:\n  S' = Mod_Type_Connect.from_hma\\<^sub>m S\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "hence [transfer_rule]: \"Mod_Type_Connect.HMA_M S' S\""], ["proof (prove)\nusing this:\n  S' = Mod_Type_Connect.from_hma\\<^sub>m S\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M S' S", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\nusing this:\n  S' = Mod_Type_Connect.from_hma\\<^sub>m S\n\ngoal (1 subgoal):\n 1. S' = Mod_Type_Connect.from_hma\\<^sub>m S", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M S' S\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M A' A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A' A", "using A'_def"], ["proof (prove)\nusing this:\n  A' = Mod_Type_Connect.from_hma\\<^sub>m A\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A' A", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\nusing this:\n  A' = Mod_Type_Connect.from_hma\\<^sub>m A\n\ngoal (1 subgoal):\n 1. A' = Mod_Type_Connect.from_hma\\<^sub>m A", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A' A\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "have \"invertible P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible P", "using res_JNF"], ["proof (prove)\nusing this:\n  P' \\<in> carrier_mat m m \\<and>\n  Q' \\<in> carrier_mat n n \\<and>\n  S' \\<in> carrier_mat m n \\<and>\n  invertible_mat P' \\<and>\n  invertible_mat Q' \\<and> isDiagonal_mat S' \\<and> S' = P' * A' * Q'\n\ngoal (1 subgoal):\n 1. invertible P", "by (transfer, simp)"], ["proof (state)\nthis:\n  invertible P\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "moreover"], ["proof (state)\nthis:\n  invertible P\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "have \"invertible Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible Q", "using res_JNF"], ["proof (prove)\nusing this:\n  P' \\<in> carrier_mat m m \\<and>\n  Q' \\<in> carrier_mat n n \\<and>\n  S' \\<in> carrier_mat m n \\<and>\n  invertible_mat P' \\<and>\n  invertible_mat Q' \\<and> isDiagonal_mat S' \\<and> S' = P' * A' * Q'\n\ngoal (1 subgoal):\n 1. invertible Q", "by (transfer, simp)"], ["proof (state)\nthis:\n  invertible Q\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "moreover"], ["proof (state)\nthis:\n  invertible Q\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "have \"isDiagonal S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isDiagonal S", "using res_JNF"], ["proof (prove)\nusing this:\n  P' \\<in> carrier_mat m m \\<and>\n  Q' \\<in> carrier_mat n n \\<and>\n  S' \\<in> carrier_mat m n \\<and>\n  invertible_mat P' \\<and>\n  invertible_mat Q' \\<and> isDiagonal_mat S' \\<and> S' = P' * A' * Q'\n\ngoal (1 subgoal):\n 1. isDiagonal S", "by (transfer, simp)"], ["proof (state)\nthis:\n  isDiagonal S\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "moreover"], ["proof (state)\nthis:\n  isDiagonal S\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "have \"S = P**A**Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = P ** A ** Q", "using res_JNF"], ["proof (prove)\nusing this:\n  P' \\<in> carrier_mat m m \\<and>\n  Q' \\<in> carrier_mat n n \\<and>\n  S' \\<in> carrier_mat m n \\<and>\n  invertible_mat P' \\<and>\n  invertible_mat Q' \\<and> isDiagonal_mat S' \\<and> S' = P' * A' * Q'\n\ngoal (1 subgoal):\n 1. S = P ** A ** Q", "by (transfer, simp)"], ["proof (state)\nthis:\n  S = P ** A ** Q\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "ultimately"], ["proof (chain)\npicking this:\n  invertible P\n  invertible Q\n  isDiagonal S\n  S = P ** A ** Q", "show ?thesis"], ["proof (prove)\nusing this:\n  invertible P\n  invertible Q\n  isDiagonal S\n  S = P ** A ** Q\n\ngoal (1 subgoal):\n 1. invertible P \\<and>\n    invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q", "by simp"], ["proof (state)\nthis:\n  invertible P \\<and>\n  invertible Q \\<and> isDiagonal S \\<and> S = P ** A ** Q\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}