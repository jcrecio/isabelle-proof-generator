{"file_name": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form/Smith_Normal_Form.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form", "problem_names": ["lemma isDiagonal_intro:\n  fixes A::\"'a::{zero}^'cols::mod_type^'rows::mod_type\"\n  assumes \"\\<And>a::'rows. \\<And>b::'cols. to_nat a = to_nat b\"\n  shows \"isDiagonal A\"", "lemma Smith_normal_form_min: \n  \"Smith_normal_form A = Smith_normal_form_upt_k A (min (nrows A) (ncols A))\"", "lemma Smith_normal_form_upt_k_0[simp]: \"Smith_normal_form_upt_k A 0\"", "lemma Smith_normal_form_upt_k_intro:\n  assumes \"(\\<And>a b. to_nat a = to_nat b \\<and> to_nat a + 1 < k \\<and> to_nat b + 1< k \\<Longrightarrow> A $ a $ b dvd A $ (a+1) $ (b+1))\"\n  and \"(\\<And>a b. (to_nat a \\<noteq> to_nat b \\<and> (to_nat a < k \\<or> (to_nat b < k))) \\<Longrightarrow> A $ a $ b = 0)\"\nshows \"Smith_normal_form_upt_k A k\"", "lemma Smith_normal_form_upt_k_intro_alt:\n  assumes \"(\\<And>a b. to_nat a = to_nat b \\<and> to_nat a + 1 < k \\<and> to_nat b + 1 < k \\<Longrightarrow> A $ a $ b dvd A $ (a+1) $ (b+1))\"\n  and \"isDiagonal_upt_k A k\"\n  shows \"Smith_normal_form_upt_k A k\"", "lemma Smith_normal_form_upt_k_condition1:\n  fixes A::\"'a::{bezout_ring}^'cols::mod_type^'rows::mod_type\"\n  assumes \"Smith_normal_form_upt_k A k\" \n  and \"to_nat a = to_nat b\" and \" to_nat a + 1 < k\" and \"to_nat b + 1 < k \"\n  shows \"A $ a $ b dvd A $ (a+1) $ (b+1)\"", "lemma Smith_normal_form_upt_k_condition2:\n  fixes A::\"'a::{bezout_ring}^'cols::mod_type^'rows::mod_type\"\n  assumes \"Smith_normal_form_upt_k A k\" \n  and \"to_nat a \\<noteq> to_nat b\" and \"(to_nat a < k \\<or> to_nat b < k)\"\n  shows \"((A $ a) $ b) = 0\"", "lemma Smith_normal_form_upt_k1_intro:\n  fixes A::\"'a::{bezout_ring}^'cols::mod_type^'rows::mod_type\"\n  assumes s: \"Smith_normal_form_upt_k A k\" \n  and cond1: \"A $ from_nat (k - 1) $ from_nat (k-1) dvd A $ (from_nat k) $ (from_nat k)\"\n  and cond2a: \"\\<forall>a. to_nat a > k \\<longrightarrow> A $ a $ from_nat k = 0\"\n  and cond2b: \"\\<forall>b. to_nat b > k \\<longrightarrow> A $ from_nat k $ b = 0\"\nshows \"Smith_normal_form_upt_k A (Suc k)\"", "lemma Smith_normal_form_upt_k1_intro_diagonal:\n  fixes A::\"'a::{bezout_ring}^'cols::mod_type^'rows::mod_type\"\n  assumes s: \"Smith_normal_form_upt_k A k\" \n  and d: \"isDiagonal A\"\n  and cond1: \"A $ from_nat (k - 1) $ from_nat (k-1) dvd A $ (from_nat k) $ (from_nat k)\"\nshows \"Smith_normal_form_upt_k A (Suc k)\""], "translations": [["", "lemma isDiagonal_intro:\n  fixes A::\"'a::{zero}^'cols::mod_type^'rows::mod_type\"\n  assumes \"\\<And>a::'rows. \\<And>b::'cols. to_nat a = to_nat b\"\n  shows \"isDiagonal A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isDiagonal A", "using assms"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a = mod_type_class.to_nat ?b\n\ngoal (1 subgoal):\n 1. isDiagonal A", "unfolding isDiagonal_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a = mod_type_class.to_nat ?b\n\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       mod_type_class.to_nat a \\<noteq>\n       mod_type_class.to_nat b \\<longrightarrow>\n       A $ a $ b = (0::'a)", "by auto"], ["", "text\\<open>Definition of Smith normal form up to position k. The element $A_{k-1,k-1}$ \ndoes not need to divide $A_{k,k}$ and $A_{k,k}$ could have non-zero entries above and below.\\<close>"], ["", "definition \"Smith_normal_form_upt_k A k = \n  (\n    (\\<forall>a b. to_nat a = to_nat b \\<and> to_nat a + 1 < k \\<and> to_nat b + 1< k \\<longrightarrow> A $ a $ b dvd A $ (a+1) $ (b+1))\n    \\<and> isDiagonal_upt_k A k\n  )\""], ["", "definition \"Smith_normal_form A = \n  (\n    (\\<forall>a b. to_nat a = to_nat b \\<and> to_nat a + 1 < nrows A \\<and> to_nat b + 1 < ncols A \\<longrightarrow> A $ a $ b dvd A $ (a+1) $ (b+1))\n    \\<and> isDiagonal A    \n  )\""], ["", "subsection \\<open>Basic properties\\<close>"], ["", "lemma Smith_normal_form_min: \n  \"Smith_normal_form A = Smith_normal_form_upt_k A (min (nrows A) (ncols A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Smith_normal_form A =\n    Smith_normal_form_upt_k A (min (nrows A) (ncols A))", "unfolding Smith_normal_form_def Smith_normal_form_upt_k_def nrows_def ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>a b.\n         mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n         mod_type_class.to_nat a + 1 < CARD('c) \\<and>\n         mod_type_class.to_nat b + 1 < CARD('b) \\<longrightarrow>\n         A $ a $ b dvd A $ (a + (1::'c)) $ (b + (1::'b))) \\<and>\n     isDiagonal A) =\n    ((\\<forall>a b.\n         mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n         mod_type_class.to_nat a + 1 < min CARD('c) CARD('b) \\<and>\n         mod_type_class.to_nat b + 1\n         < min CARD('c) CARD('b) \\<longrightarrow>\n         A $ a $ b dvd A $ (a + (1::'c)) $ (b + (1::'b))) \\<and>\n     isDiagonal_upt_k A (min CARD('c) CARD('b)))", "unfolding isDiagonal_upt_k_def isDiagonal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>a b.\n         mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n         mod_type_class.to_nat a + 1 < CARD('c) \\<and>\n         mod_type_class.to_nat b + 1 < CARD('b) \\<longrightarrow>\n         A $ a $ b dvd A $ (a + (1::'c)) $ (b + (1::'b))) \\<and>\n     (\\<forall>a b.\n         mod_type_class.to_nat a \\<noteq>\n         mod_type_class.to_nat b \\<longrightarrow>\n         A $ a $ b = (0::'a))) =\n    ((\\<forall>a b.\n         mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n         mod_type_class.to_nat a + 1 < min CARD('c) CARD('b) \\<and>\n         mod_type_class.to_nat b + 1\n         < min CARD('c) CARD('b) \\<longrightarrow>\n         A $ a $ b dvd A $ (a + (1::'c)) $ (b + (1::'b))) \\<and>\n     (\\<forall>a b.\n         mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n         (mod_type_class.to_nat a < min CARD('c) CARD('b) \\<or>\n          mod_type_class.to_nat b < min CARD('c) CARD('b)) \\<longrightarrow>\n         A $ a $ b = (0::'a)))", "by (auto, smt Suc_le_eq le_trans less_le min.boundedI not_less_eq_eq suc_not_zero \n      to_nat_less_card to_nat_plus_one_less_card')"], ["", "lemma Smith_normal_form_upt_k_0[simp]: \"Smith_normal_form_upt_k A 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Smith_normal_form_upt_k A 0", "unfolding Smith_normal_form_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n        mod_type_class.to_nat a + 1 < 0 \\<and>\n        mod_type_class.to_nat b + 1 < 0 \\<longrightarrow>\n        A $ a $ b dvd A $ (a + (1::'c)) $ (b + (1::'b))) \\<and>\n    isDiagonal_upt_k A 0", "unfolding isDiagonal_upt_k_def isDiagonal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n        mod_type_class.to_nat a + 1 < 0 \\<and>\n        mod_type_class.to_nat b + 1 < 0 \\<longrightarrow>\n        A $ a $ b dvd A $ (a + (1::'c)) $ (b + (1::'b))) \\<and>\n    (\\<forall>a b.\n        mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n        (mod_type_class.to_nat a < 0 \\<or>\n         mod_type_class.to_nat b < 0) \\<longrightarrow>\n        A $ a $ b = (0::'a))", "by auto"], ["", "lemma Smith_normal_form_upt_k_intro:\n  assumes \"(\\<And>a b. to_nat a = to_nat b \\<and> to_nat a + 1 < k \\<and> to_nat b + 1< k \\<Longrightarrow> A $ a $ b dvd A $ (a+1) $ (b+1))\"\n  and \"(\\<And>a b. (to_nat a \\<noteq> to_nat b \\<and> (to_nat a < k \\<or> (to_nat b < k))) \\<Longrightarrow> A $ a $ b = 0)\"\nshows \"Smith_normal_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Smith_normal_form_upt_k A k", "unfolding Smith_normal_form_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n        mod_type_class.to_nat a + 1 < k \\<and>\n        mod_type_class.to_nat b + 1 < k \\<longrightarrow>\n        A $ a $ b dvd A $ (a + (1::'a)) $ (b + (1::'b))) \\<and>\n    isDiagonal_upt_k A k", "unfolding isDiagonal_upt_k_def isDiagonal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n        mod_type_class.to_nat a + 1 < k \\<and>\n        mod_type_class.to_nat b + 1 < k \\<longrightarrow>\n        A $ a $ b dvd A $ (a + (1::'a)) $ (b + (1::'b))) \\<and>\n    (\\<forall>a b.\n        mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n        (mod_type_class.to_nat a < k \\<or>\n         mod_type_class.to_nat b < k) \\<longrightarrow>\n        A $ a $ b = (0::'c))", "using assms"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a = mod_type_class.to_nat ?b \\<and>\n  mod_type_class.to_nat ?a + 1 < k \\<and>\n  mod_type_class.to_nat ?b + 1 < k \\<Longrightarrow>\n  A $ ?a $ ?b dvd A $ (?a + (1::'a)) $ (?b + (1::'b))\n  mod_type_class.to_nat ?a \\<noteq> mod_type_class.to_nat ?b \\<and>\n  (mod_type_class.to_nat ?a < k \\<or>\n   mod_type_class.to_nat ?b < k) \\<Longrightarrow>\n  A $ ?a $ ?b = (0::'c)\n\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n        mod_type_class.to_nat a + 1 < k \\<and>\n        mod_type_class.to_nat b + 1 < k \\<longrightarrow>\n        A $ a $ b dvd A $ (a + (1::'a)) $ (b + (1::'b))) \\<and>\n    (\\<forall>a b.\n        mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n        (mod_type_class.to_nat a < k \\<or>\n         mod_type_class.to_nat b < k) \\<longrightarrow>\n        A $ a $ b = (0::'c))", "by simp"], ["", "lemma Smith_normal_form_upt_k_intro_alt:\n  assumes \"(\\<And>a b. to_nat a = to_nat b \\<and> to_nat a + 1 < k \\<and> to_nat b + 1 < k \\<Longrightarrow> A $ a $ b dvd A $ (a+1) $ (b+1))\"\n  and \"isDiagonal_upt_k A k\"\n  shows \"Smith_normal_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Smith_normal_form_upt_k A k", "using assms"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a = mod_type_class.to_nat ?b \\<and>\n  mod_type_class.to_nat ?a + 1 < k \\<and>\n  mod_type_class.to_nat ?b + 1 < k \\<Longrightarrow>\n  A $ ?a $ ?b dvd A $ (?a + (1::'a)) $ (?b + (1::'b))\n  isDiagonal_upt_k A k\n\ngoal (1 subgoal):\n 1. Smith_normal_form_upt_k A k", "unfolding Smith_normal_form_upt_k_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a = mod_type_class.to_nat ?b \\<and>\n  mod_type_class.to_nat ?a + 1 < k \\<and>\n  mod_type_class.to_nat ?b + 1 < k \\<Longrightarrow>\n  A $ ?a $ ?b dvd A $ (?a + (1::'a)) $ (?b + (1::'b))\n  isDiagonal_upt_k A k\n\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n        mod_type_class.to_nat a + 1 < k \\<and>\n        mod_type_class.to_nat b + 1 < k \\<longrightarrow>\n        A $ a $ b dvd A $ (a + (1::'a)) $ (b + (1::'b))) \\<and>\n    isDiagonal_upt_k A k", "by auto"], ["", "lemma Smith_normal_form_upt_k_condition1:\n  fixes A::\"'a::{bezout_ring}^'cols::mod_type^'rows::mod_type\"\n  assumes \"Smith_normal_form_upt_k A k\" \n  and \"to_nat a = to_nat b\" and \" to_nat a + 1 < k\" and \"to_nat b + 1 < k \"\n  shows \"A $ a $ b dvd A $ (a+1) $ (b+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))", "using assms"], ["proof (prove)\nusing this:\n  Smith_normal_form_upt_k A k\n  mod_type_class.to_nat a = mod_type_class.to_nat b\n  mod_type_class.to_nat a + 1 < k\n  mod_type_class.to_nat b + 1 < k\n\ngoal (1 subgoal):\n 1. A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))", "unfolding Smith_normal_form_upt_k_def"], ["proof (prove)\nusing this:\n  (\\<forall>a b.\n      mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n      mod_type_class.to_nat a + 1 < k \\<and>\n      mod_type_class.to_nat b + 1 < k \\<longrightarrow>\n      A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))) \\<and>\n  isDiagonal_upt_k A k\n  mod_type_class.to_nat a = mod_type_class.to_nat b\n  mod_type_class.to_nat a + 1 < k\n  mod_type_class.to_nat b + 1 < k\n\ngoal (1 subgoal):\n 1. A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))", "by auto"], ["", "lemma Smith_normal_form_upt_k_condition2:\n  fixes A::\"'a::{bezout_ring}^'cols::mod_type^'rows::mod_type\"\n  assumes \"Smith_normal_form_upt_k A k\" \n  and \"to_nat a \\<noteq> to_nat b\" and \"(to_nat a < k \\<or> to_nat b < k)\"\n  shows \"((A $ a) $ b) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  Smith_normal_form_upt_k A k\n  mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b\n  mod_type_class.to_nat a < k \\<or> mod_type_class.to_nat b < k\n\ngoal (1 subgoal):\n 1. A $ a $ b = (0::'a)", "unfolding Smith_normal_form_upt_k_def"], ["proof (prove)\nusing this:\n  (\\<forall>a b.\n      mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n      mod_type_class.to_nat a + 1 < k \\<and>\n      mod_type_class.to_nat b + 1 < k \\<longrightarrow>\n      A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))) \\<and>\n  isDiagonal_upt_k A k\n  mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b\n  mod_type_class.to_nat a < k \\<or> mod_type_class.to_nat b < k\n\ngoal (1 subgoal):\n 1. A $ a $ b = (0::'a)", "unfolding isDiagonal_upt_k_def isDiagonal_def"], ["proof (prove)\nusing this:\n  (\\<forall>a b.\n      mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n      mod_type_class.to_nat a + 1 < k \\<and>\n      mod_type_class.to_nat b + 1 < k \\<longrightarrow>\n      A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))) \\<and>\n  (\\<forall>a b.\n      mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n      (mod_type_class.to_nat a < k \\<or>\n       mod_type_class.to_nat b < k) \\<longrightarrow>\n      A $ a $ b = (0::'a))\n  mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b\n  mod_type_class.to_nat a < k \\<or> mod_type_class.to_nat b < k\n\ngoal (1 subgoal):\n 1. A $ a $ b = (0::'a)", "by auto"], ["", "lemma Smith_normal_form_upt_k1_intro:\n  fixes A::\"'a::{bezout_ring}^'cols::mod_type^'rows::mod_type\"\n  assumes s: \"Smith_normal_form_upt_k A k\" \n  and cond1: \"A $ from_nat (k - 1) $ from_nat (k-1) dvd A $ (from_nat k) $ (from_nat k)\"\n  and cond2a: \"\\<forall>a. to_nat a > k \\<longrightarrow> A $ a $ from_nat k = 0\"\n  and cond2b: \"\\<forall>b. to_nat b > k \\<longrightarrow> A $ from_nat k $ b = 0\"\nshows \"Smith_normal_form_upt_k A (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Smith_normal_form_upt_k A (Suc k)", "proof (rule Smith_normal_form_upt_k_intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n       mod_type_class.to_nat a + 1 < Suc k \\<and>\n       mod_type_class.to_nat b + 1 < Suc k \\<Longrightarrow>\n       A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))\n 2. \\<And>a b.\n       mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n       (mod_type_class.to_nat a < Suc k \\<or>\n        mod_type_class.to_nat b < Suc k) \\<Longrightarrow>\n       A $ a $ b = (0::'a)", "fix a::'rows and b::'cols"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n       mod_type_class.to_nat a + 1 < Suc k \\<and>\n       mod_type_class.to_nat b + 1 < Suc k \\<Longrightarrow>\n       A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))\n 2. \\<And>a b.\n       mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n       (mod_type_class.to_nat a < Suc k \\<or>\n        mod_type_class.to_nat b < Suc k) \\<Longrightarrow>\n       A $ a $ b = (0::'a)", "assume a: \"to_nat a \\<noteq> to_nat b \\<and> (to_nat a < Suc k \\<or> to_nat b < Suc k)\""], ["proof (state)\nthis:\n  mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n  (mod_type_class.to_nat a < Suc k \\<or> mod_type_class.to_nat b < Suc k)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n       mod_type_class.to_nat a + 1 < Suc k \\<and>\n       mod_type_class.to_nat b + 1 < Suc k \\<Longrightarrow>\n       A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))\n 2. \\<And>a b.\n       mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n       (mod_type_class.to_nat a < Suc k \\<or>\n        mod_type_class.to_nat b < Suc k) \\<Longrightarrow>\n       A $ a $ b = (0::'a)", "show \"A $ a $ b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b = (0::'a)", "by (metis Smith_normal_form_upt_k_condition2 a \n        assms(1) cond2a cond2b from_nat_to_nat_id less_SucE nat_neq_iff)"], ["proof (state)\nthis:\n  A $ a $ b = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n       mod_type_class.to_nat a + 1 < Suc k \\<and>\n       mod_type_class.to_nat b + 1 < Suc k \\<Longrightarrow>\n       A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n       mod_type_class.to_nat a + 1 < Suc k \\<and>\n       mod_type_class.to_nat b + 1 < Suc k \\<Longrightarrow>\n       A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))", "fix a::'rows and b::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n       mod_type_class.to_nat a + 1 < Suc k \\<and>\n       mod_type_class.to_nat b + 1 < Suc k \\<Longrightarrow>\n       A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))", "assume a: \"to_nat a = to_nat b \\<and> to_nat a + 1 < Suc k \\<and> to_nat b + 1 < Suc k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n  mod_type_class.to_nat a + 1 < Suc k \\<and>\n  mod_type_class.to_nat b + 1 < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n       mod_type_class.to_nat a + 1 < Suc k \\<and>\n       mod_type_class.to_nat b + 1 < Suc k \\<Longrightarrow>\n       A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))", "show \"A $ a $ b dvd A $ (a + 1) $ (b + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))", "by (metis (mono_tags, lifting) Smith_normal_form_upt_k_condition1 a add_diff_cancel_right' cond1\n        from_nat_suc from_nat_to_nat_id less_SucE s)"], ["proof (state)\nthis:\n  A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Smith_normal_form_upt_k1_intro_diagonal:\n  fixes A::\"'a::{bezout_ring}^'cols::mod_type^'rows::mod_type\"\n  assumes s: \"Smith_normal_form_upt_k A k\" \n  and d: \"isDiagonal A\"\n  and cond1: \"A $ from_nat (k - 1) $ from_nat (k-1) dvd A $ (from_nat k) $ (from_nat k)\"\nshows \"Smith_normal_form_upt_k A (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Smith_normal_form_upt_k A (Suc k)", "proof (rule Smith_normal_form_upt_k_intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n       mod_type_class.to_nat a + 1 < Suc k \\<and>\n       mod_type_class.to_nat b + 1 < Suc k \\<Longrightarrow>\n       A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))\n 2. \\<And>a b.\n       mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n       (mod_type_class.to_nat a < Suc k \\<or>\n        mod_type_class.to_nat b < Suc k) \\<Longrightarrow>\n       A $ a $ b = (0::'a)", "fix a::'rows and b::'cols"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n       mod_type_class.to_nat a + 1 < Suc k \\<and>\n       mod_type_class.to_nat b + 1 < Suc k \\<Longrightarrow>\n       A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))\n 2. \\<And>a b.\n       mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n       (mod_type_class.to_nat a < Suc k \\<or>\n        mod_type_class.to_nat b < Suc k) \\<Longrightarrow>\n       A $ a $ b = (0::'a)", "assume a: \"to_nat a = to_nat b \\<and> to_nat a + 1 < Suc k \\<and> to_nat b + 1 < Suc k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n  mod_type_class.to_nat a + 1 < Suc k \\<and>\n  mod_type_class.to_nat b + 1 < Suc k\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       mod_type_class.to_nat a = mod_type_class.to_nat b \\<and>\n       mod_type_class.to_nat a + 1 < Suc k \\<and>\n       mod_type_class.to_nat b + 1 < Suc k \\<Longrightarrow>\n       A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))\n 2. \\<And>a b.\n       mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n       (mod_type_class.to_nat a < Suc k \\<or>\n        mod_type_class.to_nat b < Suc k) \\<Longrightarrow>\n       A $ a $ b = (0::'a)", "show \"A $ a $ b dvd A $ (a + 1) $ (b + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))", "by (metis (mono_tags, lifting) Smith_normal_form_upt_k_condition1 a \n        add_diff_cancel_right' cond1 from_nat_suc from_nat_to_nat_id less_SucE s)"], ["proof (state)\nthis:\n  A $ a $ b dvd A $ (a + (1::'rows)) $ (b + (1::'cols))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n       (mod_type_class.to_nat a < Suc k \\<or>\n        mod_type_class.to_nat b < Suc k) \\<Longrightarrow>\n       A $ a $ b = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n       (mod_type_class.to_nat a < Suc k \\<or>\n        mod_type_class.to_nat b < Suc k) \\<Longrightarrow>\n       A $ a $ b = (0::'a)", "show \"\\<And>a b. to_nat a \\<noteq> to_nat b \\<and> (to_nat a < Suc k \\<or> to_nat b < Suc k) \\<Longrightarrow> A $ a $ b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n       (mod_type_class.to_nat a < Suc k \\<or>\n        mod_type_class.to_nat b < Suc k) \\<Longrightarrow>\n       A $ a $ b = (0::'a)", "using d isDiagonal_def"], ["proof (prove)\nusing this:\n  isDiagonal A\n  isDiagonal ?A =\n  (\\<forall>a b.\n      mod_type_class.to_nat a \\<noteq>\n      mod_type_class.to_nat b \\<longrightarrow>\n      ?A $ a $ b = (0::?'a))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       mod_type_class.to_nat a \\<noteq> mod_type_class.to_nat b \\<and>\n       (mod_type_class.to_nat a < Suc k \\<or>\n        mod_type_class.to_nat b < Suc k) \\<Longrightarrow>\n       A $ a $ b = (0::'a)", "by blast"], ["proof (state)\nthis:\n  mod_type_class.to_nat ?a \\<noteq> mod_type_class.to_nat ?b \\<and>\n  (mod_type_class.to_nat ?a < Suc k \\<or>\n   mod_type_class.to_nat ?b < Suc k) \\<Longrightarrow>\n  A $ ?a $ ?b = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}