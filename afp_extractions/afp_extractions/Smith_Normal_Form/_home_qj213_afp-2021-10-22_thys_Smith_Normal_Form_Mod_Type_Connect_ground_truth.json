{"file_name": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form/Mod_Type_Connect.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form", "problem_names": ["lemma inj_to_nat: \"inj to_nat\"", "lemmas from_nat_inj = from_nat_eq_imp_eq", "lemma range_to_nat: \"range (to_nat :: 'a :: mod_type \\<Rightarrow> nat) = {0 ..< CARD('a)}\"", "lemma to_hma_from_hma\\<^sub>v[simp]: \"to_hma\\<^sub>v (from_hma\\<^sub>v v) = v\"", "lemma to_hma_from_hma\\<^sub>m[simp]: \"to_hma\\<^sub>m (from_hma\\<^sub>m v) = v\"", "lemma from_hma_to_hma\\<^sub>v[simp]:\n  \"v \\<in> carrier_vec (CARD('n)) \\<Longrightarrow> from_hma\\<^sub>v (to_hma\\<^sub>v v :: 'a ^ 'n :: mod_type) = v\"", "lemma from_hma_to_hma\\<^sub>m[simp]:\n  \"A \\<in> carrier_mat (CARD('nr)) (CARD('nc)) \\<Longrightarrow> from_hma\\<^sub>m (to_hma\\<^sub>m A :: 'a ^ 'nc :: mod_type  ^ 'nr :: mod_type) = A\"", "lemma from_hma\\<^sub>v_inj[simp]: \"from_hma\\<^sub>v x = from_hma\\<^sub>v y \\<longleftrightarrow> x = y\"", "lemma from_hma\\<^sub>m_inj[simp]: \"from_hma\\<^sub>m x = from_hma\\<^sub>m y \\<longleftrightarrow> x = y\"", "lemma Domainp_HMA_V [transfer_domain_rule]: \n  \"Domainp (HMA_V :: 'a Matrix.vec \\<Rightarrow> 'a ^ 'n :: mod_type \\<Rightarrow> bool) = (\\<lambda> v. v \\<in> carrier_vec (CARD('n )))\"", "lemma Domainp_HMA_M [transfer_domain_rule]: \n  \"Domainp (HMA_M :: 'a Matrix.mat \\<Rightarrow> 'a ^ 'nc :: mod_type  ^ 'nr :: mod_type \\<Rightarrow> bool) \n  = (\\<lambda> A. A \\<in> carrier_mat CARD('nr) CARD('nc))\"", "lemma Domainp_HMA_I [transfer_domain_rule]: \n  \"Domainp (HMA_I :: nat \\<Rightarrow> 'n :: mod_type \\<Rightarrow> bool) = (\\<lambda> i. i < CARD('n))\" (is \"?l = ?r\")", "lemma bi_unique_HMA_V [transfer_rule]: \"bi_unique HMA_V\" \"left_unique HMA_V\" \"right_unique HMA_V\"", "lemma bi_unique_HMA_M [transfer_rule]: \"bi_unique HMA_M\" \"left_unique HMA_M\" \"right_unique HMA_M\"", "lemma bi_unique_HMA_I [transfer_rule]: \"bi_unique HMA_I\" \"left_unique HMA_I\" \"right_unique HMA_I\"", "lemma right_total_HMA_V [transfer_rule]: \"right_total HMA_V\"", "lemma right_total_HMA_M [transfer_rule]: \"right_total HMA_M\"", "lemma right_total_HMA_I [transfer_rule]: \"right_total HMA_I\"", "lemma HMA_V_index [transfer_rule]: \"(HMA_V ===> HMA_I ===> (=)) ($v) ($h)\"", "lemma HMA_M_index [transfer_rule]:\n  \"(HMA_M ===> HMA_I ===> HMA_I ===> (=)) (\\<lambda> A i j. A $$ (i,j)) index_hma\"", "lemma HMA_V_0 [transfer_rule]: \"HMA_V (0\\<^sub>v CARD('n)) (0 :: 'a :: zero ^ 'n:: mod_type)\"", "lemma HMA_M_0 [transfer_rule]: \n  \"HMA_M (0\\<^sub>m CARD('nr) CARD('nc)) (0 :: 'a :: zero ^ 'nc:: mod_type  ^ 'nr :: mod_type)\"", "lemma HMA_M_1[transfer_rule]:\n  \"HMA_M (1\\<^sub>m (CARD('n))) (mat 1 :: 'a::{zero,one}^'n:: mod_type^'n:: mod_type)\"", "lemma from_hma\\<^sub>v_add: \"from_hma\\<^sub>v v + from_hma\\<^sub>v w = from_hma\\<^sub>v (v + w)\"", "lemma HMA_V_add [transfer_rule]: \"(HMA_V ===> HMA_V ===> HMA_V) (+) (+) \"", "lemma from_hma\\<^sub>v_diff: \"from_hma\\<^sub>v v - from_hma\\<^sub>v w = from_hma\\<^sub>v (v - w)\"", "lemma HMA_V_diff [transfer_rule]: \"(HMA_V ===> HMA_V ===> HMA_V) (-) (-)\"", "lemma from_hma\\<^sub>m_add: \"from_hma\\<^sub>m a + from_hma\\<^sub>m b = from_hma\\<^sub>m (a + b)\"", "lemma HMA_M_add [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) (+) (+) \"", "lemma from_hma\\<^sub>m_diff: \"from_hma\\<^sub>m a - from_hma\\<^sub>m b = from_hma\\<^sub>m (a - b)\"", "lemma HMA_M_diff [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) (-) (-) \"", "lemma scalar_product: fixes v :: \"'a :: semiring_1 ^ 'n :: mod_type\"\n  shows \"scalar_prod (from_hma\\<^sub>v v) (from_hma\\<^sub>v w) = scalar_product v w\"", "lemma [simp]:\n  \"from_hma\\<^sub>m (y :: 'a ^ 'nc :: mod_type ^ 'nr:: mod_type) \\<in> carrier_mat (CARD('nr)) (CARD('nc))\"\n  \"dim_row (from_hma\\<^sub>m (y :: 'a ^ 'nc:: mod_type  ^ 'nr :: mod_type)) = CARD('nr)\"\n  \"dim_col (from_hma\\<^sub>m (y :: 'a ^ 'nc :: mod_type ^ 'nr:: mod_type )) = CARD('nc)\"", "lemma [simp]:\n  \"from_hma\\<^sub>v (y :: 'a ^ 'n:: mod_type) \\<in> carrier_vec (CARD('n))\"\n  \"dim_vec (from_hma\\<^sub>v (y :: 'a ^ 'n:: mod_type)) = CARD('n)\"", "lemma HMA_scalar_prod [transfer_rule]:\n  \"(HMA_V ===> HMA_V ===> (=)) scalar_prod scalar_product\"", "lemma HMA_row [transfer_rule]: \"(HMA_I ===> HMA_M ===> HMA_V) (\\<lambda> i a. Matrix.row a i) row\"", "lemma HMA_col [transfer_rule]: \"(HMA_I ===> HMA_M ===> HMA_V) (\\<lambda> i a. col a i) column\"", "lemma HMA_M_mk_mat[transfer_rule]: \"((HMA_I ===> HMA_I ===> (=)) ===> HMA_M) \n  (\\<lambda> f. Matrix.mat (CARD('nr)) (CARD('nc)) (\\<lambda> (i,j). f i j)) \n  (mk_mat :: (('nr \\<Rightarrow> 'nc \\<Rightarrow> 'a) \\<Rightarrow> 'a^'nc:: mod_type^'nr:: mod_type))\"", "lemma HMA_M_mk_vec[transfer_rule]: \"((HMA_I ===> (=)) ===> HMA_V) \n  (\\<lambda> f. Matrix.vec (CARD('n)) (\\<lambda> i. f i)) \n  (mk_vec :: (('n \\<Rightarrow> 'a) \\<Rightarrow> 'a^'n:: mod_type))\"", "lemma mat_mult_scalar: \"A ** B = mk_mat (\\<lambda> i j. scalar_product (row i A) (column j B))\"", "lemma mult_mat_vec_scalar: \"A *v v = mk_vec (\\<lambda> i. scalar_product (row i A) v)\"", "lemma dim_row_transfer_rule: \n  \"HMA_M A (A' :: 'a ^ 'nc:: mod_type ^ 'nr:: mod_type) \\<Longrightarrow> (=) (dim_row A) (CARD('nr))\"", "lemma dim_col_transfer_rule: \n  \"HMA_M A (A' :: 'a ^ 'nc:: mod_type ^ 'nr:: mod_type) \\<Longrightarrow> (=) (dim_col A) (CARD('nc))\"", "lemma HMA_M_mult [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) (*) (**)\"", "lemma HMA_V_smult [transfer_rule]: \"((=) ===> HMA_V ===> HMA_V) (\\<cdot>\\<^sub>v) (*s)\"", "lemma HMA_M_mult_vec [transfer_rule]: \"(HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)\"", "lemma HMA_det [transfer_rule]: \"(HMA_M ===> (=)) Determinant.det \n  (det :: 'a :: comm_ring_1 ^ 'n :: mod_type ^ 'n :: mod_type \\<Rightarrow> 'a)\"", "lemma HMA_mat[transfer_rule]: \"((=) ===> HMA_M) (\\<lambda> k. k \\<cdot>\\<^sub>m 1\\<^sub>m CARD('n)) \n  (Finite_Cartesian_Product.mat :: 'a::semiring_1 \\<Rightarrow> 'a^'n :: mod_type^'n :: mod_type)\"", "lemma HMA_mat_minus[transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) \n  (\\<lambda> A B. A + map_mat uminus B) ((-) :: 'a :: group_add ^'nc:: mod_type^'nr:: mod_type \n  \\<Rightarrow> 'a^'nc:: mod_type^'nr:: mod_type \\<Rightarrow> 'a^'nc:: mod_type^'nr:: mod_type)\"", "lemma HMA_transpose_matrix [transfer_rule]: \n  \"(HMA_M ===> HMA_M) transpose_mat transpose\"", "lemma HMA_invertible_matrix_mod_type[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n :: mod_type ^ 'n :: mod_type \n      \\<Rightarrow> _) ===> (=)) invertible_mat invertible\"", "lemma HMA_swaprows[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _)\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nr :: mod_type \\<Rightarrow> _ )\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nr :: mod_type \\<Rightarrow> _ )     \n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A a b. swaprows a b A) interchange_rows\"", "lemma HMA_swapcols[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _)\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nc :: mod_type \\<Rightarrow> _ )\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nc :: mod_type \\<Rightarrow> _ )     \n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A a b. swapcols a b A) interchange_columns\"", "lemma HMA_addrow[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _) \n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nr :: mod_type \\<Rightarrow> _ )\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nr :: mod_type \\<Rightarrow> _ ) \n    ===> (=)\n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A a b q. addrow q a b A) row_add\"", "lemma HMA_addcol[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _) \n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nc :: mod_type \\<Rightarrow> _ )\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nc :: mod_type \\<Rightarrow> _ ) \n    ===> (=)\n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A a b q. addcol q a b A) column_add\"", "lemma HMA_multrow[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _)\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nr :: mod_type \\<Rightarrow> _ )\n    ===> (=)     \n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A i q. multrow i q A) mult_row\"", "lemma HMA_multcol[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _)\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nc :: mod_type \\<Rightarrow> _ )\n    ===> (=)     \n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A i q. multcol i q A) mult_column\"", "lemma HMA_M3_def: \n  \"HMA_M3 A B = (Mod_Type_Connect.HMA_M (fst A) (fst B) \n  \\<and> Mod_Type_Connect.HMA_M (fst (snd A)) (fst (snd B)) \n  \\<and> Mod_Type_Connect.HMA_M (snd (snd A)) (snd (snd B)))\"", "lemma Domainp_HMA_M3 [transfer_domain_rule]: \n \"Domainp (HMA_M3 :: _\\<Rightarrow>(_\\<times>('a::comm_ring_1^'nc::mod_type^'nr::mod_type)\\<times>_)\\<Rightarrow>_) \n = (\\<lambda>(P,A,Q). P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and> A \\<in> carrier_mat CARD('nr) CARD('nc) \n  \\<and> Q \\<in> carrier_mat CARD('nc) CARD('nc))\"", "lemma bi_unique_HMA_M3 [transfer_rule]: \"bi_unique HMA_M3\" \"left_unique HMA_M3\" \"right_unique HMA_M3\"", "lemma right_total_HMA_M3 [transfer_rule]: \"right_total HMA_M3\""], "translations": [["", "lemma inj_to_nat: \"inj to_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj mod_type_class.to_nat", "by (simp add: inj_on_def)"], ["", "lemmas from_nat_inj = from_nat_eq_imp_eq"], ["", "lemma range_to_nat: \"range (to_nat :: 'a :: mod_type \\<Rightarrow> nat) = {0 ..< CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range mod_type_class.to_nat = {0..<CARD('a)}", "by (simp add: bij_betw_imp_surj_on mod_type_class.bij_to_nat)"], ["", "text \\<open>This theory is an adaptation of the one presented in @{text \"Perron_Frobenius.HMA_Connect\"},\n  but for matrices and vectors where indexes have the @{text \"mod_type\"} class restriction.\n\n  It is worth noting that some definitions still use the old abbreviation for HOL Analysis \n  (HMA, from HOL Multivariate Analysis) instead of HA. This is done to be consistent with \n  the existing names in the Perron-Frobenius development\\<close>"], ["", "context includes vec.lifting \nbegin"], ["", "end"], ["", "definition from_hma\\<^sub>v :: \"'a ^ 'n :: mod_type \\<Rightarrow> 'a Matrix.vec\" where\n  \"from_hma\\<^sub>v v = Matrix.vec CARD('n) (\\<lambda> i. v $h from_nat i)\""], ["", "definition from_hma\\<^sub>m :: \"'a ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> 'a Matrix.mat\" where\n  \"from_hma\\<^sub>m a = Matrix.mat CARD('nr) CARD('nc) (\\<lambda> (i,j). a $h from_nat i $h from_nat j)\""], ["", "definition to_hma\\<^sub>v :: \"'a Matrix.vec \\<Rightarrow> 'a ^ 'n :: mod_type\" where\n  \"to_hma\\<^sub>v v = (\\<chi> i. v $v to_nat i)\""], ["", "definition to_hma\\<^sub>m :: \"'a Matrix.mat \\<Rightarrow> 'a ^ 'nc :: mod_type ^ 'nr :: mod_type \" where\n  \"to_hma\\<^sub>m a = (\\<chi> i j. a $$ (to_nat i, to_nat j))\""], ["", "lemma to_hma_from_hma\\<^sub>v[simp]: \"to_hma\\<^sub>v (from_hma\\<^sub>v v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>v (Mod_Type_Connect.from_hma\\<^sub>v v) =\n    v", "by (auto simp: to_hma\\<^sub>v_def from_hma\\<^sub>v_def to_nat_less_card)"], ["", "lemma to_hma_from_hma\\<^sub>m[simp]: \"to_hma\\<^sub>m (from_hma\\<^sub>m v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m (Mod_Type_Connect.from_hma\\<^sub>m v) =\n    v", "by (auto simp: to_hma\\<^sub>m_def from_hma\\<^sub>m_def to_nat_less_card)"], ["", "lemma from_hma_to_hma\\<^sub>v[simp]:\n  \"v \\<in> carrier_vec (CARD('n)) \\<Longrightarrow> from_hma\\<^sub>v (to_hma\\<^sub>v v :: 'a ^ 'n :: mod_type) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec CARD('n) \\<Longrightarrow>\n    Mod_Type_Connect.from_hma\\<^sub>v (Mod_Type_Connect.to_hma\\<^sub>v v) =\n    v", "by (auto simp: to_hma\\<^sub>v_def from_hma\\<^sub>v_def to_nat_from_nat_id)"], ["", "lemma from_hma_to_hma\\<^sub>m[simp]:\n  \"A \\<in> carrier_mat (CARD('nr)) (CARD('nc)) \\<Longrightarrow> from_hma\\<^sub>m (to_hma\\<^sub>m A :: 'a ^ 'nc :: mod_type  ^ 'nr :: mod_type) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat CARD('nr) CARD('nc) \\<Longrightarrow>\n    Mod_Type_Connect.from_hma\\<^sub>m (Mod_Type_Connect.to_hma\\<^sub>m A) =\n    A", "by (auto simp: to_hma\\<^sub>m_def from_hma\\<^sub>m_def to_nat_from_nat_id)"], ["", "lemma from_hma\\<^sub>v_inj[simp]: \"from_hma\\<^sub>v x = from_hma\\<^sub>v y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.from_hma\\<^sub>v x =\n     Mod_Type_Connect.from_hma\\<^sub>v y) =\n    (x = y)", "by (intro iffI, insert to_hma_from_hma\\<^sub>v[of x], auto)"], ["", "lemma from_hma\\<^sub>m_inj[simp]: \"from_hma\\<^sub>m x = from_hma\\<^sub>m y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.from_hma\\<^sub>m x =\n     Mod_Type_Connect.from_hma\\<^sub>m y) =\n    (x = y)", "by(intro iffI, insert to_hma_from_hma\\<^sub>m[of x], auto)"], ["", "definition HMA_V :: \"'a Matrix.vec \\<Rightarrow> 'a ^ 'n :: mod_type \\<Rightarrow> bool\" where \n  \"HMA_V = (\\<lambda> v w. v = from_hma\\<^sub>v w)\""], ["", "definition HMA_M :: \"'a Matrix.mat \\<Rightarrow> 'a ^ 'nc :: mod_type ^ 'nr :: mod_type  \\<Rightarrow> bool\" where \n  \"HMA_M = (\\<lambda> a b. a = from_hma\\<^sub>m b)\""], ["", "definition HMA_I :: \"nat \\<Rightarrow> 'n :: mod_type \\<Rightarrow> bool\" where\n  \"HMA_I = (\\<lambda> i a. i = to_nat a)\""], ["", "context includes lifting_syntax\nbegin"], ["", "lemma Domainp_HMA_V [transfer_domain_rule]: \n  \"Domainp (HMA_V :: 'a Matrix.vec \\<Rightarrow> 'a ^ 'n :: mod_type \\<Rightarrow> bool) = (\\<lambda> v. v \\<in> carrier_vec (CARD('n )))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp Mod_Type_Connect.HMA_V =\n    (\\<lambda>v. v \\<in> carrier_vec CARD('n))", "by(intro ext iffI, insert from_hma_to_hma\\<^sub>v[symmetric], auto simp: from_hma\\<^sub>v_def HMA_V_def)"], ["", "lemma Domainp_HMA_M [transfer_domain_rule]: \n  \"Domainp (HMA_M :: 'a Matrix.mat \\<Rightarrow> 'a ^ 'nc :: mod_type  ^ 'nr :: mod_type \\<Rightarrow> bool) \n  = (\\<lambda> A. A \\<in> carrier_mat CARD('nr) CARD('nc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp Mod_Type_Connect.HMA_M =\n    (\\<lambda>A. A \\<in> carrier_mat CARD('nr) CARD('nc))", "by (intro ext iffI, insert from_hma_to_hma\\<^sub>m[symmetric], auto simp: from_hma\\<^sub>m_def HMA_M_def)"], ["", "lemma Domainp_HMA_I [transfer_domain_rule]: \n  \"Domainp (HMA_I :: nat \\<Rightarrow> 'n :: mod_type \\<Rightarrow> bool) = (\\<lambda> i. i < CARD('n))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp Mod_Type_Connect.HMA_I = (\\<lambda>i. i < CARD('n))", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. Domainp Mod_Type_Connect.HMA_I i = (i < CARD('n))", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. Domainp Mod_Type_Connect.HMA_I i = (i < CARD('n))", "show \"?l i = ?r i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp Mod_Type_Connect.HMA_I i = (i < CARD('n))", "unfolding HMA_I_def Domainp_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a. i = mod_type_class.to_nat a) = (i < CARD('n))", "by (auto intro: exI[of _ \"from_nat i\"] simp: to_nat_from_nat_id to_nat_less_card)"], ["proof (state)\nthis:\n  Domainp Mod_Type_Connect.HMA_I i = (i < CARD('n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bi_unique_HMA_V [transfer_rule]: \"bi_unique HMA_V\" \"left_unique HMA_V\" \"right_unique HMA_V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique Mod_Type_Connect.HMA_V &&&\n    left_unique Mod_Type_Connect.HMA_V &&&\n    right_unique Mod_Type_Connect.HMA_V", "unfolding HMA_V_def bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        x = Mod_Type_Connect.from_hma\\<^sub>v y \\<longrightarrow>\n        x = Mod_Type_Connect.from_hma\\<^sub>v z \\<longrightarrow>\n        y = z) \\<and>\n    (\\<forall>x y z.\n        x = Mod_Type_Connect.from_hma\\<^sub>v z \\<longrightarrow>\n        y = Mod_Type_Connect.from_hma\\<^sub>v z \\<longrightarrow> x = y) &&&\n    \\<forall>x y z.\n       x = Mod_Type_Connect.from_hma\\<^sub>v z \\<longrightarrow>\n       y = Mod_Type_Connect.from_hma\\<^sub>v z \\<longrightarrow> x = y &&&\n    \\<forall>x y z.\n       x = Mod_Type_Connect.from_hma\\<^sub>v y \\<longrightarrow>\n       x = Mod_Type_Connect.from_hma\\<^sub>v z \\<longrightarrow> y = z", "by auto"], ["", "lemma bi_unique_HMA_M [transfer_rule]: \"bi_unique HMA_M\" \"left_unique HMA_M\" \"right_unique HMA_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique Mod_Type_Connect.HMA_M &&&\n    left_unique Mod_Type_Connect.HMA_M &&&\n    right_unique Mod_Type_Connect.HMA_M", "unfolding HMA_M_def bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        x = Mod_Type_Connect.from_hma\\<^sub>m y \\<longrightarrow>\n        x = Mod_Type_Connect.from_hma\\<^sub>m z \\<longrightarrow>\n        y = z) \\<and>\n    (\\<forall>x y z.\n        x = Mod_Type_Connect.from_hma\\<^sub>m z \\<longrightarrow>\n        y = Mod_Type_Connect.from_hma\\<^sub>m z \\<longrightarrow> x = y) &&&\n    \\<forall>x y z.\n       x = Mod_Type_Connect.from_hma\\<^sub>m z \\<longrightarrow>\n       y = Mod_Type_Connect.from_hma\\<^sub>m z \\<longrightarrow> x = y &&&\n    \\<forall>x y z.\n       x = Mod_Type_Connect.from_hma\\<^sub>m y \\<longrightarrow>\n       x = Mod_Type_Connect.from_hma\\<^sub>m z \\<longrightarrow> y = z", "by auto"], ["", "lemma bi_unique_HMA_I [transfer_rule]: \"bi_unique HMA_I\" \"left_unique HMA_I\" \"right_unique HMA_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique Mod_Type_Connect.HMA_I &&&\n    left_unique Mod_Type_Connect.HMA_I &&&\n    right_unique Mod_Type_Connect.HMA_I", "unfolding HMA_I_def bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        x = mod_type_class.to_nat y \\<longrightarrow>\n        x = mod_type_class.to_nat z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x y z.\n        x = mod_type_class.to_nat z \\<longrightarrow>\n        y = mod_type_class.to_nat z \\<longrightarrow> x = y) &&&\n    \\<forall>x y z.\n       x = mod_type_class.to_nat z \\<longrightarrow>\n       y = mod_type_class.to_nat z \\<longrightarrow> x = y &&&\n    \\<forall>x y z.\n       x = mod_type_class.to_nat y \\<longrightarrow>\n       x = mod_type_class.to_nat z \\<longrightarrow> y = z", "by auto"], ["", "lemma right_total_HMA_V [transfer_rule]: \"right_total HMA_V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total Mod_Type_Connect.HMA_V", "unfolding HMA_V_def right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. x = Mod_Type_Connect.from_hma\\<^sub>v y", "by simp"], ["", "lemma right_total_HMA_M [transfer_rule]: \"right_total HMA_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total Mod_Type_Connect.HMA_M", "unfolding HMA_M_def right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. x = Mod_Type_Connect.from_hma\\<^sub>m y", "by simp"], ["", "lemma right_total_HMA_I [transfer_rule]: \"right_total HMA_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total Mod_Type_Connect.HMA_I", "unfolding HMA_I_def right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. x = mod_type_class.to_nat y", "by simp"], ["", "lemma HMA_V_index [transfer_rule]: \"(HMA_V ===> HMA_I ===> (=)) ($v) ($h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_I ===> (=)) ($v) ($h)", "unfolding rel_fun_def HMA_V_def HMA_I_def from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x =\n       Matrix.vec CARD('b)\n        (\\<lambda>i. y $h mod_type_class.from_nat i) \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = mod_type_class.to_nat ya \\<longrightarrow>\n           x $v xa = y $h ya)", "by (auto simp: to_nat_less_card)"], ["", "lemma HMA_M_index [transfer_rule]:\n  \"(HMA_M ===> HMA_I ===> HMA_I ===> (=)) (\\<lambda> A i j. A $$ (i,j)) index_hma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_I ===> (=))\n     (\\<lambda>A i j. A $$ (i, j)) index_hma", "by (intro rel_funI, simp add: index_hma_def to_nat_less_card HMA_M_def HMA_I_def from_hma\\<^sub>m_def)"], ["", "lemma HMA_V_0 [transfer_rule]: \"HMA_V (0\\<^sub>v CARD('n)) (0 :: 'a :: zero ^ 'n:: mod_type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_V (0\\<^sub>v CARD('n)) 0", "unfolding HMA_V_def from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v CARD('n) =\n    Matrix.vec CARD('n) (\\<lambda>i. 0 $h mod_type_class.from_nat i)", "by auto"], ["", "lemma HMA_M_0 [transfer_rule]: \n  \"HMA_M (0\\<^sub>m CARD('nr) CARD('nc)) (0 :: 'a :: zero ^ 'nc:: mod_type  ^ 'nr :: mod_type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (0\\<^sub>m CARD('nr) CARD('nc)) 0", "unfolding HMA_M_def from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m CARD('nr) CARD('nc) =\n    Matrix.mat CARD('nr) CARD('nc)\n     (\\<lambda>(i, j).\n         0 $h mod_type_class.from_nat i $h mod_type_class.from_nat j)", "by auto"], ["", "lemma HMA_M_1[transfer_rule]:\n  \"HMA_M (1\\<^sub>m (CARD('n))) (mat 1 :: 'a::{zero,one}^'n:: mod_type^'n:: mod_type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (1\\<^sub>m CARD('n)) (mat (1::'a))", "unfolding HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m CARD('n) = Mod_Type_Connect.from_hma\\<^sub>m (mat (1::'a))", "by (auto simp add: mat_def from_hma\\<^sub>m_def from_nat_inj)"], ["", "lemma from_hma\\<^sub>v_add: \"from_hma\\<^sub>v v + from_hma\\<^sub>v w = from_hma\\<^sub>v (v + w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.from_hma\\<^sub>v v +\n    Mod_Type_Connect.from_hma\\<^sub>v w =\n    Mod_Type_Connect.from_hma\\<^sub>v (v + w)", "unfolding from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec CARD('b) (\\<lambda>i. v $h mod_type_class.from_nat i) +\n    Matrix.vec CARD('b) (\\<lambda>i. w $h mod_type_class.from_nat i) =\n    Matrix.vec CARD('b) (\\<lambda>i. (v + w) $h mod_type_class.from_nat i)", "by auto"], ["", "lemma HMA_V_add [transfer_rule]: \"(HMA_V ===> HMA_V ===> HMA_V) (+) (+) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_V ===>\n     Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (+) (+)", "unfolding rel_fun_def HMA_V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = Mod_Type_Connect.from_hma\\<^sub>v y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = Mod_Type_Connect.from_hma\\<^sub>v ya \\<longrightarrow>\n           x + xa = Mod_Type_Connect.from_hma\\<^sub>v (y + ya))", "by (auto simp: from_hma\\<^sub>v_add)"], ["", "lemma from_hma\\<^sub>v_diff: \"from_hma\\<^sub>v v - from_hma\\<^sub>v w = from_hma\\<^sub>v (v - w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.from_hma\\<^sub>v v -\n    Mod_Type_Connect.from_hma\\<^sub>v w =\n    Mod_Type_Connect.from_hma\\<^sub>v (v - w)", "unfolding from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec CARD('b) (\\<lambda>i. v $h mod_type_class.from_nat i) -\n    Matrix.vec CARD('b) (\\<lambda>i. w $h mod_type_class.from_nat i) =\n    Matrix.vec CARD('b) (\\<lambda>i. (v - w) $h mod_type_class.from_nat i)", "by auto"], ["", "lemma HMA_V_diff [transfer_rule]: \"(HMA_V ===> HMA_V ===> HMA_V) (-) (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_V ===>\n     Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (-) (-)", "unfolding rel_fun_def HMA_V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = Mod_Type_Connect.from_hma\\<^sub>v y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = Mod_Type_Connect.from_hma\\<^sub>v ya \\<longrightarrow>\n           x - xa = Mod_Type_Connect.from_hma\\<^sub>v (y - ya))", "by (auto simp: from_hma\\<^sub>v_diff)"], ["", "lemma from_hma\\<^sub>m_add: \"from_hma\\<^sub>m a + from_hma\\<^sub>m b = from_hma\\<^sub>m (a + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.from_hma\\<^sub>m a +\n    Mod_Type_Connect.from_hma\\<^sub>m b =\n    Mod_Type_Connect.from_hma\\<^sub>m (a + b)", "unfolding from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j).\n         a $h mod_type_class.from_nat i $h mod_type_class.from_nat j) +\n    Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j).\n         b $h mod_type_class.from_nat i $h mod_type_class.from_nat j) =\n    Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j).\n         (a + b) $h mod_type_class.from_nat i $h mod_type_class.from_nat j)", "by auto"], ["", "lemma HMA_M_add [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) (+) (+) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (+) (+)", "unfolding rel_fun_def HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = Mod_Type_Connect.from_hma\\<^sub>m y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = Mod_Type_Connect.from_hma\\<^sub>m ya \\<longrightarrow>\n           x + xa = Mod_Type_Connect.from_hma\\<^sub>m (y + ya))", "by (auto simp: from_hma\\<^sub>m_add)"], ["", "lemma from_hma\\<^sub>m_diff: \"from_hma\\<^sub>m a - from_hma\\<^sub>m b = from_hma\\<^sub>m (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.from_hma\\<^sub>m a -\n    Mod_Type_Connect.from_hma\\<^sub>m b =\n    Mod_Type_Connect.from_hma\\<^sub>m (a - b)", "unfolding from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j).\n         a $h mod_type_class.from_nat i $h mod_type_class.from_nat j) -\n    Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j).\n         b $h mod_type_class.from_nat i $h mod_type_class.from_nat j) =\n    Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j).\n         (a - b) $h mod_type_class.from_nat i $h mod_type_class.from_nat j)", "by auto"], ["", "lemma HMA_M_diff [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) (-) (-) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (-) (-)", "unfolding rel_fun_def HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = Mod_Type_Connect.from_hma\\<^sub>m y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = Mod_Type_Connect.from_hma\\<^sub>m ya \\<longrightarrow>\n           x - xa = Mod_Type_Connect.from_hma\\<^sub>m (y - ya))", "by (auto simp: from_hma\\<^sub>m_diff)"], ["", "lemma scalar_product: fixes v :: \"'a :: semiring_1 ^ 'n :: mod_type\"\n  shows \"scalar_prod (from_hma\\<^sub>v v) (from_hma\\<^sub>v w) = scalar_product v w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.from_hma\\<^sub>v v \\<bullet>\n    Mod_Type_Connect.from_hma\\<^sub>v w =\n    scalar_product v w", "unfolding scalar_product_def scalar_prod_def from_hma\\<^sub>v_def dim_vec"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<CARD('n).\n        Matrix.vec CARD('n) (\\<lambda>i. v $h mod_type_class.from_nat i) $v\n        i *\n        Matrix.vec CARD('n) (\\<lambda>i. w $h mod_type_class.from_nat i) $v\n        i) =\n    (\\<Sum>i\\<in>UNIV. v $h i * w $h i)", "by (simp add: sum.reindex[OF inj_to_nat, unfolded range_to_nat])"], ["", "lemma [simp]:\n  \"from_hma\\<^sub>m (y :: 'a ^ 'nc :: mod_type ^ 'nr:: mod_type) \\<in> carrier_mat (CARD('nr)) (CARD('nc))\"\n  \"dim_row (from_hma\\<^sub>m (y :: 'a ^ 'nc:: mod_type  ^ 'nr :: mod_type)) = CARD('nr)\"\n  \"dim_col (from_hma\\<^sub>m (y :: 'a ^ 'nc :: mod_type ^ 'nr:: mod_type )) = CARD('nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.from_hma\\<^sub>m y\n    \\<in> carrier_mat CARD('nr) CARD('nc) &&&\n    dim_row (Mod_Type_Connect.from_hma\\<^sub>m y) = CARD('nr) &&&\n    dim_col (Mod_Type_Connect.from_hma\\<^sub>m y) = CARD('nc)", "unfolding from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat CARD('nr) CARD('nc)\n     (\\<lambda>(i, j).\n         y $h mod_type_class.from_nat i $h mod_type_class.from_nat j)\n    \\<in> carrier_mat CARD('nr) CARD('nc) &&&\n    dim_row\n     (Matrix.mat CARD('nr) CARD('nc)\n       (\\<lambda>(i, j).\n           y $h mod_type_class.from_nat i $h mod_type_class.from_nat j)) =\n    CARD('nr) &&&\n    dim_col\n     (Matrix.mat CARD('nr) CARD('nc)\n       (\\<lambda>(i, j).\n           y $h mod_type_class.from_nat i $h mod_type_class.from_nat j)) =\n    CARD('nc)", "by simp_all"], ["", "lemma [simp]:\n  \"from_hma\\<^sub>v (y :: 'a ^ 'n:: mod_type) \\<in> carrier_vec (CARD('n))\"\n  \"dim_vec (from_hma\\<^sub>v (y :: 'a ^ 'n:: mod_type)) = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.from_hma\\<^sub>v y \\<in> carrier_vec CARD('n) &&&\n    dim_vec (Mod_Type_Connect.from_hma\\<^sub>v y) = CARD('n)", "unfolding from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec CARD('n) (\\<lambda>i. y $h mod_type_class.from_nat i)\n    \\<in> carrier_vec CARD('n) &&&\n    dim_vec\n     (Matrix.vec CARD('n) (\\<lambda>i. y $h mod_type_class.from_nat i)) =\n    CARD('n)", "by simp_all"], ["", "lemma HMA_scalar_prod [transfer_rule]:\n  \"(HMA_V ===> HMA_V ===> (=)) scalar_prod scalar_product\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V ===> (=))\n     (\\<bullet>) scalar_product", "by (auto simp: HMA_V_def scalar_product)"], ["", "lemma HMA_row [transfer_rule]: \"(HMA_I ===> HMA_M ===> HMA_V) (\\<lambda> i a. Matrix.row a i) row\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_I ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_V)\n     (\\<lambda>i a. Matrix.row a i) row", "unfolding HMA_M_def HMA_I_def HMA_V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i a. i = mod_type_class.to_nat a) ===>\n     (\\<lambda>a b. a = Mod_Type_Connect.from_hma\\<^sub>m b) ===>\n     (\\<lambda>v w. v = Mod_Type_Connect.from_hma\\<^sub>v w))\n     (\\<lambda>i a. Matrix.row a i) row", "by (auto simp: from_hma\\<^sub>m_def from_hma\\<^sub>v_def to_nat_less_card row_def)"], ["", "lemma HMA_col [transfer_rule]: \"(HMA_I ===> HMA_M ===> HMA_V) (\\<lambda> i a. col a i) column\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_I ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_V)\n     (\\<lambda>i a. col a i) column", "unfolding HMA_M_def HMA_I_def HMA_V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i a. i = mod_type_class.to_nat a) ===>\n     (\\<lambda>a b. a = Mod_Type_Connect.from_hma\\<^sub>m b) ===>\n     (\\<lambda>v w. v = Mod_Type_Connect.from_hma\\<^sub>v w))\n     (\\<lambda>i a. col a i) column", "by (auto simp: from_hma\\<^sub>m_def from_hma\\<^sub>v_def to_nat_less_card column_def)"], ["", "lemma HMA_M_mk_mat[transfer_rule]: \"((HMA_I ===> HMA_I ===> (=)) ===> HMA_M) \n  (\\<lambda> f. Matrix.mat (CARD('nr)) (CARD('nc)) (\\<lambda> (i,j). f i j)) \n  (mk_mat :: (('nr \\<Rightarrow> 'nc \\<Rightarrow> 'a) \\<Rightarrow> 'a^'nc:: mod_type^'nr:: mod_type))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_I ===> (=)) ===>\n     Mod_Type_Connect.HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     HMA_Connect.mk_mat", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_I ===> (=)) ===>\n     Mod_Type_Connect.HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     HMA_Connect.mk_mat", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_I ===> (=)) ===>\n     Mod_Type_Connect.HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     HMA_Connect.mk_mat", "fix x y i j"], ["proof (state)\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_I ===> (=)) ===>\n     Mod_Type_Connect.HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     HMA_Connect.mk_mat", "assume id: \"\\<forall> (ya :: 'nr) (yb :: 'nc). (x (to_nat ya) (to_nat yb) :: 'a) = y ya yb\"\n       and i: \"i < CARD('nr)\" and j: \"j < CARD('nc)\""], ["proof (state)\nthis:\n  \\<forall>ya yb.\n     x (mod_type_class.to_nat ya) (mod_type_class.to_nat yb) = y ya yb\n  i < CARD('nr)\n  j < CARD('nc)\n\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_I ===> (=)) ===>\n     Mod_Type_Connect.HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     HMA_Connect.mk_mat", "from to_nat_from_nat_id[OF i] to_nat_from_nat_id[OF j] id[rule_format, of \"from_nat i\" \"from_nat j\"]"], ["proof (chain)\npicking this:\n  mod_type_class.to_nat (mod_type_class.from_nat i) = i\n  mod_type_class.to_nat (mod_type_class.from_nat j) = j\n  x (mod_type_class.to_nat (mod_type_class.from_nat i))\n   (mod_type_class.to_nat (mod_type_class.from_nat j)) =\n  y (mod_type_class.from_nat i) (mod_type_class.from_nat j)", "have \"x i j = y (from_nat i) (from_nat j)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat i) = i\n  mod_type_class.to_nat (mod_type_class.from_nat j) = j\n  x (mod_type_class.to_nat (mod_type_class.from_nat i))\n   (mod_type_class.to_nat (mod_type_class.from_nat j)) =\n  y (mod_type_class.from_nat i) (mod_type_class.from_nat j)\n\ngoal (1 subgoal):\n 1. x i j = y (mod_type_class.from_nat i) (mod_type_class.from_nat j)", "by auto"], ["proof (state)\nthis:\n  x i j = y (mod_type_class.from_nat i) (mod_type_class.from_nat j)\n\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_I ===> (=)) ===>\n     Mod_Type_Connect.HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     HMA_Connect.mk_mat", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>ya yb.\n              ?x2 (mod_type_class.to_nat ya) (mod_type_class.to_nat yb) =\n              ?y2 ya yb;\n   ?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 ?j2 =\n                    ?y2 (mod_type_class.from_nat ?i2)\n                     (mod_type_class.from_nat ?j2)\n\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_I ===> (=)) ===>\n     Mod_Type_Connect.HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     HMA_Connect.mk_mat", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ya yb.\n              ?x2 (mod_type_class.to_nat ya) (mod_type_class.to_nat yb) =\n              ?y2 ya yb;\n   ?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 ?j2 =\n                    ?y2 (mod_type_class.from_nat ?i2)\n                     (mod_type_class.from_nat ?j2)\n\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_I ===> (=)) ===>\n     Mod_Type_Connect.HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     HMA_Connect.mk_mat", "unfolding rel_fun_def mk_mat_def HMA_M_def HMA_I_def from_hma\\<^sub>m_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ya yb.\n              ?x2 (mod_type_class.to_nat ya) (mod_type_class.to_nat yb) =\n              ?y2 ya yb;\n   ?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 ?j2 =\n                    ?y2 (mod_type_class.from_nat ?i2)\n                     (mod_type_class.from_nat ?j2)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<forall>xa ya.\n           xa = mod_type_class.to_nat ya \\<longrightarrow>\n           (\\<forall>xb yb.\n               xb = mod_type_class.to_nat yb \\<longrightarrow>\n               x xa xb = y ya yb)) \\<longrightarrow>\n       Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(xa, y). x xa y) =\n       Matrix.mat CARD('nr) CARD('nc)\n        (\\<lambda>(i, j).\n            (\\<chi>i. vec_lambda (y i)) $h mod_type_class.from_nat i $h\n            mod_type_class.from_nat j)", "by auto"], ["proof (state)\nthis:\n  ((Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_I ===> (=)) ===>\n   Mod_Type_Connect.HMA_M)\n   (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n   HMA_Connect.mk_mat\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_M_mk_vec[transfer_rule]: \"((HMA_I ===> (=)) ===> HMA_V) \n  (\\<lambda> f. Matrix.vec (CARD('n)) (\\<lambda> i. f i)) \n  (mk_vec :: (('n \\<Rightarrow> 'a) \\<Rightarrow> 'a^'n:: mod_type))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> (=)) ===> Mod_Type_Connect.HMA_V)\n     (Matrix.vec CARD('n)) HMA_Connect.mk_vec", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> (=)) ===> Mod_Type_Connect.HMA_V)\n     (Matrix.vec CARD('n)) HMA_Connect.mk_vec", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> (=)) ===> Mod_Type_Connect.HMA_V)\n     (Matrix.vec CARD('n)) HMA_Connect.mk_vec", "fix x y i"], ["proof (state)\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> (=)) ===> Mod_Type_Connect.HMA_V)\n     (Matrix.vec CARD('n)) HMA_Connect.mk_vec", "assume id: \"\\<forall> (ya :: 'n). (x (to_nat ya) :: 'a) = y ya\"\n       and i: \"i < CARD('n)\""], ["proof (state)\nthis:\n  \\<forall>ya. x (mod_type_class.to_nat ya) = y ya\n  i < CARD('n)\n\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> (=)) ===> Mod_Type_Connect.HMA_V)\n     (Matrix.vec CARD('n)) HMA_Connect.mk_vec", "from to_nat_from_nat_id[OF i] id[rule_format, of \"from_nat i\"]"], ["proof (chain)\npicking this:\n  mod_type_class.to_nat (mod_type_class.from_nat i) = i\n  x (mod_type_class.to_nat (mod_type_class.from_nat i)) =\n  y (mod_type_class.from_nat i)", "have \"x i = y (from_nat i)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat i) = i\n  x (mod_type_class.to_nat (mod_type_class.from_nat i)) =\n  y (mod_type_class.from_nat i)\n\ngoal (1 subgoal):\n 1. x i = y (mod_type_class.from_nat i)", "by auto"], ["proof (state)\nthis:\n  x i = y (mod_type_class.from_nat i)\n\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> (=)) ===> Mod_Type_Connect.HMA_V)\n     (Matrix.vec CARD('n)) HMA_Connect.mk_vec", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>ya. ?x2 (mod_type_class.to_nat ya) = ?y2 ya;\n   ?i2 < CARD('n)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 = ?y2 (mod_type_class.from_nat ?i2)\n\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> (=)) ===> Mod_Type_Connect.HMA_V)\n     (Matrix.vec CARD('n)) HMA_Connect.mk_vec", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ya. ?x2 (mod_type_class.to_nat ya) = ?y2 ya;\n   ?i2 < CARD('n)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 = ?y2 (mod_type_class.from_nat ?i2)\n\ngoal (1 subgoal):\n 1. ((Mod_Type_Connect.HMA_I ===> (=)) ===> Mod_Type_Connect.HMA_V)\n     (Matrix.vec CARD('n)) HMA_Connect.mk_vec", "unfolding rel_fun_def mk_vec_def HMA_V_def HMA_I_def from_hma\\<^sub>v_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ya. ?x2 (mod_type_class.to_nat ya) = ?y2 ya;\n   ?i2 < CARD('n)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 = ?y2 (mod_type_class.from_nat ?i2)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<forall>xa ya.\n           xa = mod_type_class.to_nat ya \\<longrightarrow>\n           x xa = y ya) \\<longrightarrow>\n       Matrix.vec CARD('n) x =\n       Matrix.vec CARD('n)\n        (\\<lambda>i. vec_lambda y $h mod_type_class.from_nat i)", "by auto"], ["proof (state)\nthis:\n  ((Mod_Type_Connect.HMA_I ===> (=)) ===> Mod_Type_Connect.HMA_V)\n   (Matrix.vec CARD('n)) HMA_Connect.mk_vec\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_mult_scalar: \"A ** B = mk_mat (\\<lambda> i j. scalar_product (row i A) (column j B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** B =\n    HMA_Connect.mk_mat (\\<lambda>i j. scalar_product (row i A) (column j B))", "unfolding vec_eq_iff matrix_matrix_mult_def scalar_product_def mk_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $h i $h k * B $h k $h j) $h i $h ia =\n       (\\<chi>i j. \\<Sum>ia\\<in>UNIV. row i A $h ia * column j B $h ia) $h\n       i $h\n       ia", "by (auto simp: row_def column_def)"], ["", "lemma mult_mat_vec_scalar: \"A *v v = mk_vec (\\<lambda> i. scalar_product (row i A) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v v = HMA_Connect.mk_vec (\\<lambda>i. scalar_product (row i A) v)", "unfolding vec_eq_iff matrix_vector_mult_def scalar_product_def mk_mat_def mk_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<chi>i. \\<Sum>j\\<in>UNIV. A $h i $h j * v $h j) $h i =\n       (\\<chi>i. \\<Sum>ia\\<in>UNIV. row i A $h ia * v $h ia) $h i", "by (auto simp: row_def column_def)"], ["", "lemma dim_row_transfer_rule: \n  \"HMA_M A (A' :: 'a ^ 'nc:: mod_type ^ 'nr:: mod_type) \\<Longrightarrow> (=) (dim_row A) (CARD('nr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A A' \\<Longrightarrow> dim_row A = CARD('nr)", "unfolding HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = Mod_Type_Connect.from_hma\\<^sub>m A' \\<Longrightarrow>\n    dim_row A = CARD('nr)", "by auto"], ["", "lemma dim_col_transfer_rule: \n  \"HMA_M A (A' :: 'a ^ 'nc:: mod_type ^ 'nr:: mod_type) \\<Longrightarrow> (=) (dim_col A) (CARD('nc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A A' \\<Longrightarrow> dim_col A = CARD('nc)", "unfolding HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = Mod_Type_Connect.from_hma\\<^sub>m A' \\<Longrightarrow>\n    dim_col A = CARD('nc)", "by auto"], ["", "lemma HMA_M_mult [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) (*) (**)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (*) (**)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (*) (**)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (*) (**)", "fix A B :: \"'a :: semiring_1 mat\" and A' :: \"'a ^ 'n :: mod_type ^ 'nr:: mod_type\" \n      and B' :: \"'a ^ 'nc :: mod_type ^ 'n:: mod_type\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (*) (**)", "assume 1[transfer_rule]: \"HMA_M A A'\" \"HMA_M B B'\""], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M B B'\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (*) (**)", "note [transfer_rule] = dim_row_transfer_rule[OF 1(1)] dim_col_transfer_rule[OF 1(2)]"], ["proof (state)\nthis:\n  dim_row A = CARD('nr)\n  dim_col B = CARD('nc)\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (*) (**)", "have \"HMA_M (A * B) (A' ** B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (A * B) (A' ** B')", "unfolding times_mat_def mat_mult_scalar"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M\n     (Matrix.mat (dim_row A) (dim_col B)\n       (\\<lambda>(i, j). Matrix.row A i \\<bullet> col B j))\n     (HMA_Connect.mk_mat\n       (\\<lambda>i j. scalar_product (row i A') (column j B')))", "by (transfer_prover_start, transfer_step+, transfer, auto)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (A * B) (A' ** B')\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (*) (**)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Mod_Type_Connect.HMA_M ?A2 ?A'2;\n   Mod_Type_Connect.HMA_M ?B2 ?B'2\\<rbrakk>\n  \\<Longrightarrow> Mod_Type_Connect.HMA_M (?A2 * ?B2) (?A'2 ** ?B'2)\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (*) (**)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>Mod_Type_Connect.HMA_M ?A2 ?A'2;\n   Mod_Type_Connect.HMA_M ?B2 ?B'2\\<rbrakk>\n  \\<Longrightarrow> Mod_Type_Connect.HMA_M (?A2 * ?B2) (?A'2 ** ?B'2)\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (*) (**)", "by blast"], ["proof (state)\nthis:\n  (Mod_Type_Connect.HMA_M ===>\n   Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n   (*) (**)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_V_smult [transfer_rule]: \"((=) ===> HMA_V ===> HMA_V) (\\<cdot>\\<^sub>v) (*s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (\\<cdot>\\<^sub>v) (*s)", "unfolding smult_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (\\<lambda>a v. Matrix.vec (dim_vec v) (\\<lambda>i. a * v $v i)) (*s)", "unfolding rel_fun_def HMA_V_def from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa =\n           Matrix.vec CARD('b)\n            (\\<lambda>i. ya $h mod_type_class.from_nat i) \\<longrightarrow>\n           Matrix.vec (dim_vec xa) (\\<lambda>i. x * xa $v i) =\n           Matrix.vec CARD('b)\n            (\\<lambda>i. (y *s ya) $h mod_type_class.from_nat i))", "by auto"], ["", "lemma HMA_M_mult_vec [transfer_rule]: \"(HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (*\\<^sub>v) (*v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (*\\<^sub>v) (*v)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (*\\<^sub>v) (*v)", "fix A :: \"'a :: semiring_1 mat\" and v :: \"'a Matrix.vec\"\n      and A' :: \"'a ^ 'nc :: mod_type ^ 'nr :: mod_type\" and v' :: \"'a ^ 'nc :: mod_type\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (*\\<^sub>v) (*v)", "assume 1[transfer_rule]: \"HMA_M A A'\" \"HMA_V v v'\""], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_V v v'\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (*\\<^sub>v) (*v)", "note [transfer_rule] = dim_row_transfer_rule"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (*\\<^sub>v) (*v)", "have \"HMA_V (A *\\<^sub>v v) (A' *v v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_V (A *\\<^sub>v v) (A' *v v')", "unfolding mult_mat_vec_def mult_mat_vec_scalar"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_V\n     (Matrix.vec (dim_row A) (\\<lambda>i. Matrix.row A i \\<bullet> v))\n     (HMA_Connect.mk_vec (\\<lambda>i. scalar_product (row i A') v'))", "by (transfer_prover_start, transfer_step+, transfer, auto)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_V (A *\\<^sub>v v) (A' *v v')\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (*\\<^sub>v) (*v)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Mod_Type_Connect.HMA_M ?A2 ?A'2;\n   Mod_Type_Connect.HMA_V ?v2 ?v'2\\<rbrakk>\n  \\<Longrightarrow> Mod_Type_Connect.HMA_V (?A2 *\\<^sub>v ?v2)\n                     (?A'2 *v ?v'2)\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (*\\<^sub>v) (*v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>Mod_Type_Connect.HMA_M ?A2 ?A'2;\n   Mod_Type_Connect.HMA_V ?v2 ?v'2\\<rbrakk>\n  \\<Longrightarrow> Mod_Type_Connect.HMA_V (?A2 *\\<^sub>v ?v2)\n                     (?A'2 *v ?v'2)\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n     (*\\<^sub>v) (*v)", "by blast"], ["proof (state)\nthis:\n  (Mod_Type_Connect.HMA_M ===>\n   Mod_Type_Connect.HMA_V ===> Mod_Type_Connect.HMA_V)\n   (*\\<^sub>v) (*v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_det [transfer_rule]: \"(HMA_M ===> (=)) Determinant.det \n  (det :: 'a :: comm_ring_1 ^ 'n :: mod_type ^ 'n :: mod_type \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "fix a :: \"'a ^ 'n :: mod_type^ 'n:: mod_type\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "let ?tn = \"to_nat :: 'n :: mod_type \\<Rightarrow> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "let ?fn = \"from_nat :: nat \\<Rightarrow> 'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "let ?zn = \"{0..< CARD('n)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "let ?U = \"UNIV :: 'n set\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "let ?p1 = \"{p. p permutes ?zn}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "let ?p2 = \"{p. p permutes ?U}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "let ?f= \"\\<lambda> p i. if i \\<in> ?U then ?fn (p (?tn i)) else i\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "let ?g = \"\\<lambda> p i. ?fn (p (?tn i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "have fg: \"\\<And> a b c. (if a \\<in> ?U then b else c) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. (if a \\<in> UNIV then b else c) = b", "by auto"], ["proof (state)\nthis:\n  (if ?a \\<in> UNIV then ?b else ?c) = ?b\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "have \"?p2 = ?f ` ?p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. p permutes UNIV} =\n    (\\<lambda>p i.\n        if i \\<in> UNIV\n        then mod_type_class.from_nat (p (mod_type_class.to_nat i)) else i) `\n    {p. p permutes {0..<CARD('n)}}", "by (rule permutes_bij', auto simp: to_nat_less_card to_nat_from_nat_id)"], ["proof (state)\nthis:\n  {p. p permutes UNIV} =\n  (\\<lambda>p i.\n      if i \\<in> UNIV\n      then mod_type_class.from_nat (p (mod_type_class.to_nat i)) else i) `\n  {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "hence id: \"?p2 = ?g ` ?p1\""], ["proof (prove)\nusing this:\n  {p. p permutes UNIV} =\n  (\\<lambda>p i.\n      if i \\<in> UNIV\n      then mod_type_class.from_nat (p (mod_type_class.to_nat i)) else i) `\n  {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. {p. p permutes UNIV} =\n    (\\<lambda>p i. mod_type_class.from_nat (p (mod_type_class.to_nat i))) `\n    {p. p permutes {0..<CARD('n)}}", "by simp"], ["proof (state)\nthis:\n  {p. p permutes UNIV} =\n  (\\<lambda>p i. mod_type_class.from_nat (p (mod_type_class.to_nat i))) `\n  {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "have inj_g: \"inj_on ?g ?p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (\\<lambda>p i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n     {p. p permutes {0..<CARD('n)}}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{p. p permutes {0..<CARD('n)}}.\n       \\<forall>y\\<in>{p. p permutes {0..<CARD('n)}}.\n          (\\<lambda>i.\n              mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n          (\\<lambda>i.\n              mod_type_class.from_nat\n               (y (mod_type_class.to_nat i))) \\<longrightarrow>\n          x = y", "proof (intro ballI impI ext, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i.\n            mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n        (\\<lambda>i.\n            mod_type_class.from_nat (y (mod_type_class.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "fix p q i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i.\n            mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n        (\\<lambda>i.\n            mod_type_class.from_nat (y (mod_type_class.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "assume p: \"p permutes ?zn\" and q: \"q permutes ?zn\"\n        and id: \"(\\<lambda> i. ?fn (p (?tn i))) = (\\<lambda> i. ?fn (q (?tn i)))\""], ["proof (state)\nthis:\n  p permutes {0..<CARD('n)}\n  q permutes {0..<CARD('n)}\n  (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))) =\n  (\\<lambda>i. mod_type_class.from_nat (q (mod_type_class.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i.\n            mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n        (\\<lambda>i.\n            mod_type_class.from_nat (y (mod_type_class.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "{"], ["proof (state)\nthis:\n  p permutes {0..<CARD('n)}\n  q permutes {0..<CARD('n)}\n  (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))) =\n  (\\<lambda>i. mod_type_class.from_nat (q (mod_type_class.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i.\n            mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n        (\\<lambda>i.\n            mod_type_class.from_nat (y (mod_type_class.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i.\n            mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n        (\\<lambda>i.\n            mod_type_class.from_nat (y (mod_type_class.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "from permutes_in_image[OF p]"], ["proof (chain)\npicking this:\n  (p ?x \\<in> {0..<CARD('n)}) = (?x \\<in> {0..<CARD('n)})", "have pi: \"p (?tn i) < CARD('n)\""], ["proof (prove)\nusing this:\n  (p ?x \\<in> {0..<CARD('n)}) = (?x \\<in> {0..<CARD('n)})\n\ngoal (1 subgoal):\n 1. p (mod_type_class.to_nat i) < CARD('n)", "by (simp add: to_nat_less_card)"], ["proof (state)\nthis:\n  p (mod_type_class.to_nat i) < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i.\n            mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n        (\\<lambda>i.\n            mod_type_class.from_nat (y (mod_type_class.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "from permutes_in_image[OF q]"], ["proof (chain)\npicking this:\n  (q ?x \\<in> {0..<CARD('n)}) = (?x \\<in> {0..<CARD('n)})", "have qi: \"q (?tn i) < CARD('n)\""], ["proof (prove)\nusing this:\n  (q ?x \\<in> {0..<CARD('n)}) = (?x \\<in> {0..<CARD('n)})\n\ngoal (1 subgoal):\n 1. q (mod_type_class.to_nat i) < CARD('n)", "by (simp add: to_nat_less_card)"], ["proof (state)\nthis:\n  q (mod_type_class.to_nat i) < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i.\n            mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n        (\\<lambda>i.\n            mod_type_class.from_nat (y (mod_type_class.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "from fun_cong[OF id]"], ["proof (chain)\npicking this:\n  mod_type_class.from_nat (p (mod_type_class.to_nat ?x)) =\n  mod_type_class.from_nat (q (mod_type_class.to_nat ?x))", "have \"?fn (p (?tn i))  = from_nat (q (?tn i))\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (p (mod_type_class.to_nat ?x)) =\n  mod_type_class.from_nat (q (mod_type_class.to_nat ?x))\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (p (mod_type_class.to_nat i)) =\n    mod_type_class.from_nat (q (mod_type_class.to_nat i))", "."], ["proof (state)\nthis:\n  mod_type_class.from_nat (p (mod_type_class.to_nat i)) =\n  mod_type_class.from_nat (q (mod_type_class.to_nat i))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i.\n            mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n        (\\<lambda>i.\n            mod_type_class.from_nat (y (mod_type_class.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "from arg_cong[OF this, of ?tn]"], ["proof (chain)\npicking this:\n  mod_type_class.to_nat\n   (mod_type_class.from_nat (p (mod_type_class.to_nat i))) =\n  mod_type_class.to_nat\n   (mod_type_class.from_nat (q (mod_type_class.to_nat i)))", "have \"p (?tn i) = q (?tn i)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat\n   (mod_type_class.from_nat (p (mod_type_class.to_nat i))) =\n  mod_type_class.to_nat\n   (mod_type_class.from_nat (q (mod_type_class.to_nat i)))\n\ngoal (1 subgoal):\n 1. p (mod_type_class.to_nat i) = q (mod_type_class.to_nat i)", "by (simp add: to_nat_from_nat_id pi qi)"], ["proof (state)\nthis:\n  p (mod_type_class.to_nat i) = q (mod_type_class.to_nat i)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i.\n            mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n        (\\<lambda>i.\n            mod_type_class.from_nat (y (mod_type_class.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "}"], ["proof (state)\nthis:\n  p (mod_type_class.to_nat ?ia3) = q (mod_type_class.to_nat ?ia3)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i.\n            mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n        (\\<lambda>i.\n            mod_type_class.from_nat (y (mod_type_class.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "note id = this"], ["proof (state)\nthis:\n  p (mod_type_class.to_nat ?ia3) = q (mod_type_class.to_nat ?ia3)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i.\n            mod_type_class.from_nat (x (mod_type_class.to_nat i))) =\n        (\\<lambda>i.\n            mod_type_class.from_nat (y (mod_type_class.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "show \"p i = q i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p i = q i", "proof (cases \"i < CARD('n)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < CARD('n) \\<Longrightarrow> p i = q i\n 2. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "case True"], ["proof (state)\nthis:\n  i < CARD('n)\n\ngoal (2 subgoals):\n 1. i < CARD('n) \\<Longrightarrow> p i = q i\n 2. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "hence \"?tn (?fn i) = i\""], ["proof (prove)\nusing this:\n  i < CARD('n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat i) = i", "by (simp add: to_nat_from_nat_id)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat i) = i\n\ngoal (2 subgoals):\n 1. i < CARD('n) \\<Longrightarrow> p i = q i\n 2. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "from id[of \"?fn i\", unfolded this]"], ["proof (chain)\npicking this:\n  p i = q i", "show ?thesis"], ["proof (prove)\nusing this:\n  p i = q i\n\ngoal (1 subgoal):\n 1. p i = q i", "."], ["proof (state)\nthis:\n  p i = q i\n\ngoal (1 subgoal):\n 1. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "case False"], ["proof (state)\nthis:\n  \\<not> i < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < CARD('n)\n\ngoal (1 subgoal):\n 1. p i = q i", "using p q"], ["proof (prove)\nusing this:\n  \\<not> i < CARD('n)\n  p permutes {0..<CARD('n)}\n  q permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. p i = q i", "unfolding permutes_def"], ["proof (prove)\nusing this:\n  \\<not> i < CARD('n)\n  (\\<forall>x. x \\<notin> {0..<CARD('n)} \\<longrightarrow> p x = x) \\<and>\n  (\\<forall>y. \\<exists>!x. p x = y)\n  (\\<forall>x. x \\<notin> {0..<CARD('n)} \\<longrightarrow> q x = x) \\<and>\n  (\\<forall>y. \\<exists>!x. q x = y)\n\ngoal (1 subgoal):\n 1. p i = q i", "by simp"], ["proof (state)\nthis:\n  p i = q i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p i = q i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>p i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n   {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "have mult_cong: \"\\<And> a b c d. a = b \\<Longrightarrow> c = d \\<Longrightarrow> a * c = b * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a = b; c = d\\<rbrakk> \\<Longrightarrow> a * c = b * d", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?a1 = ?b1; ?c1 = ?d1\\<rbrakk>\n  \\<Longrightarrow> ?a1 * ?c1 = ?b1 * ?d1\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "have \"sum (\\<lambda> p. \n      signof p * (\\<Prod>i\\<in>?zn. a $h ?fn i $h ?fn (p i))) ?p1\n      = sum (\\<lambda> p. of_int (sign p) * (\\<Prod>i\\<in>UNIV. a $h i $h p i)) ?p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<CARD('n)}.\n       signof p *\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (p i))) =\n    (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. a $h i $h p i))", "unfolding id sum.reindex[OF inj_g]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<CARD('n)}.\n       signof p *\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (p i))) =\n    sum ((\\<lambda>p.\n             of_int (sign p) * (\\<Prod>i\\<in>UNIV. a $h i $h p i)) \\<circ>\n         (\\<lambda>p i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     {p. p permutes {0..<CARD('n)}}", "proof (rule sum.cong[OF refl], unfold mem_Collect_eq o_def, rule mult_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int\n        (sign\n          (\\<lambda>i.\n              mod_type_class.from_nat (x (mod_type_class.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h mod_type_class.from_nat (x (mod_type_class.to_nat i)))", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int\n        (sign\n          (\\<lambda>i.\n              mod_type_class.from_nat (x (mod_type_class.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h mod_type_class.from_nat (x (mod_type_class.to_nat i)))", "assume p: \"p permutes ?zn\""], ["proof (state)\nthis:\n  p permutes {0..<CARD('n)}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int\n        (sign\n          (\\<lambda>i.\n              mod_type_class.from_nat (x (mod_type_class.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h mod_type_class.from_nat (x (mod_type_class.to_nat i)))", "let ?q = \"\\<lambda> i. ?fn (p (?tn i))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int\n        (sign\n          (\\<lambda>i.\n              mod_type_class.from_nat (x (mod_type_class.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h mod_type_class.from_nat (x (mod_type_class.to_nat i)))", "from id p"], ["proof (chain)\npicking this:\n  {p. p permutes UNIV} =\n  (\\<lambda>p i. mod_type_class.from_nat (p (mod_type_class.to_nat i))) `\n  {p. p permutes {0..<CARD('n)}}\n  p permutes {0..<CARD('n)}", "have q: \"?q permutes ?U\""], ["proof (prove)\nusing this:\n  {p. p permutes UNIV} =\n  (\\<lambda>p i. mod_type_class.from_nat (p (mod_type_class.to_nat i))) `\n  {p. p permutes {0..<CARD('n)}}\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        mod_type_class.from_nat (p (mod_type_class.to_nat i))) permutes\n    UNIV", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      mod_type_class.from_nat (p (mod_type_class.to_nat i))) permutes\n  UNIV\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int\n        (sign\n          (\\<lambda>i.\n              mod_type_class.from_nat (x (mod_type_class.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h mod_type_class.from_nat (x (mod_type_class.to_nat i)))", "from p"], ["proof (chain)\npicking this:\n  p permutes {0..<CARD('n)}", "have pp: \"permutation p\""], ["proof (prove)\nusing this:\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. permutation p", "unfolding permutation_permutes"], ["proof (prove)\nusing this:\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> p permutes S", "by auto"], ["proof (state)\nthis:\n  permutation p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int\n        (sign\n          (\\<lambda>i.\n              mod_type_class.from_nat (x (mod_type_class.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h mod_type_class.from_nat (x (mod_type_class.to_nat i)))", "let ?ft = \"\\<lambda> p i. ?fn (p (?tn i))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int\n        (sign\n          (\\<lambda>i.\n              mod_type_class.from_nat (x (mod_type_class.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h mod_type_class.from_nat (x (mod_type_class.to_nat i)))", "have fin: \"finite ?zn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0..<CARD('n)}", "by simp"], ["proof (state)\nthis:\n  finite {0..<CARD('n)}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int\n        (sign\n          (\\<lambda>i.\n              mod_type_class.from_nat (x (mod_type_class.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h mod_type_class.from_nat (x (mod_type_class.to_nat i)))", "have \"sign p = sign ?q \\<and> p permutes ?zn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign p =\n    sign\n     (\\<lambda>i.\n         mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n    p permutes {0..<CARD('n)}", "proof (induct rule: permutes_induct[OF fin _ _ p])"], ["proof (state)\ngoal (2 subgoals):\n 1. sign id =\n    sign\n     (\\<lambda>i.\n         mod_type_class.from_nat (id (mod_type_class.to_nat i))) \\<and>\n    id permutes {0..<CARD('n)}\n 2. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sign id =\n    sign\n     (\\<lambda>i.\n         mod_type_class.from_nat (id (mod_type_class.to_nat i))) \\<and>\n    id permutes {0..<CARD('n)}\n 2. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign id =\n    sign\n     (\\<lambda>i.\n         mod_type_class.from_nat (id (mod_type_class.to_nat i))) \\<and>\n    id permutes {0..<CARD('n)}", "by (auto simp: sign_id[unfolded id_def] permutes_id[unfolded id_def])"], ["proof (state)\nthis:\n  sign id =\n  sign\n   (\\<lambda>i.\n       mod_type_class.from_nat (id (mod_type_class.to_nat i))) \\<and>\n  id permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "case (2 a b p)"], ["proof (state)\nthis:\n  a \\<in> {0..<CARD('n)}\n  b \\<in> {0..<CARD('n)}\n  sign p =\n  sign\n   (\\<lambda>i.\n       mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}\n  sign p =\n  sign\n   (\\<lambda>i.\n       mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}\n  permutation p\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "let ?sab = \"Fun.swap a b id\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "let ?sfab = \"Fun.swap (?fn a) (?fn b) id\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "have p_sab: \"permutation ?sab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation (Fun.swap a b id)", "by (rule permutation_swap_id)"], ["proof (state)\nthis:\n  permutation (Fun.swap a b id)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "have p_sfab: \"permutation ?sfab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation\n     (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b) id)", "by (rule permutation_swap_id)"], ["proof (state)\nthis:\n  permutation\n   (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b) id)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "from 2(3)"], ["proof (chain)\npicking this:\n  sign p =\n  sign\n   (\\<lambda>i.\n       mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}", "have IH1: \"p permutes ?zn\" and IH2: \"sign p = sign (?ft p)\""], ["proof (prove)\nusing this:\n  sign p =\n  sign\n   (\\<lambda>i.\n       mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. p permutes {0..<CARD('n)} &&&\n    sign p =\n    sign (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))", "by auto"], ["proof (state)\nthis:\n  p permutes {0..<CARD('n)}\n  sign p =\n  sign (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "have sab_perm: \"?sab permutes ?zn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap a b id permutes {0..<CARD('n)}", "using 2(1-2)"], ["proof (prove)\nusing this:\n  a \\<in> {0..<CARD('n)}\n  b \\<in> {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. Fun.swap a b id permutes {0..<CARD('n)}", "by (rule permutes_swap_id)"], ["proof (state)\nthis:\n  Fun.swap a b id permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "from permutes_compose[OF IH1 this]"], ["proof (chain)\npicking this:\n  Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "have perm1: \"?sab o p permutes ?zn\""], ["proof (prove)\nusing this:\n  Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "."], ["proof (state)\nthis:\n  Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "from IH1"], ["proof (chain)\npicking this:\n  p permutes {0..<CARD('n)}", "have p_p1: \"p \\<in> ?p1\""], ["proof (prove)\nusing this:\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. p \\<in> {p. p permutes {0..<CARD('n)}}", "by simp"], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "hence \"?ft p \\<in> ?ft ` ?p1\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n    \\<in> (\\<lambda>p i.\n              mod_type_class.from_nat (p (mod_type_class.to_nat i))) `\n          {p. p permutes {0..<CARD('n)}}", "by (rule imageI)"], ["proof (state)\nthis:\n  (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n  \\<in> (\\<lambda>p i.\n            mod_type_class.from_nat (p (mod_type_class.to_nat i))) `\n        {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "from this[folded id]"], ["proof (chain)\npicking this:\n  (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n  \\<in> {p. p permutes UNIV}", "have \"?ft p permutes ?U\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n  \\<in> {p. p permutes UNIV}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        mod_type_class.from_nat (p (mod_type_class.to_nat i))) permutes\n    UNIV", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      mod_type_class.from_nat (p (mod_type_class.to_nat i))) permutes\n  UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "hence p_ftp: \"permutation (?ft p)\""], ["proof (prove)\nusing this:\n  (\\<lambda>i.\n      mod_type_class.from_nat (p (mod_type_class.to_nat i))) permutes\n  UNIV\n\ngoal (1 subgoal):\n 1. permutation\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))", "unfolding permutation_permutes"], ["proof (prove)\nusing this:\n  (\\<lambda>i.\n      mod_type_class.from_nat (p (mod_type_class.to_nat i))) permutes\n  UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>i.\n           mod_type_class.from_nat (p (mod_type_class.to_nat i))) permutes\n       S", "by auto"], ["proof (state)\nthis:\n  permutation\n   (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "{"], ["proof (state)\nthis:\n  permutation\n   (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "assume a: \"a \\<in> ?zn\" and b: \"b \\<in> ?zn\""], ["proof (state)\nthis:\n  a \\<in> {0..<CARD('n)}\n  b \\<in> {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "hence \"(?fn a = ?fn b) = (a = b)\""], ["proof (prove)\nusing this:\n  a \\<in> {0..<CARD('n)}\n  b \\<in> {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. (mod_type_class.from_nat a = mod_type_class.from_nat b) = (a = b)", "using 2(1-2)"], ["proof (prove)\nusing this:\n  a \\<in> {0..<CARD('n)}\n  b \\<in> {0..<CARD('n)}\n  aa__ \\<in> {0..<CARD('n)}\n  b__ \\<in> {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. (mod_type_class.from_nat a = mod_type_class.from_nat b) = (a = b)", "by (auto simp add: from_nat_eq_imp_eq)"], ["proof (state)\nthis:\n  (mod_type_class.from_nat a = mod_type_class.from_nat b) = (a = b)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ab4 \\<in> {0..<CARD('n)}; ?ba4 \\<in> {0..<CARD('n)}\\<rbrakk>\n  \\<Longrightarrow> (mod_type_class.from_nat ?ab4 =\n                     mod_type_class.from_nat ?ba4) =\n                    (?ab4 = ?ba4)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "note inj = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ab4 \\<in> {0..<CARD('n)}; ?ba4 \\<in> {0..<CARD('n)}\\<rbrakk>\n  \\<Longrightarrow> (mod_type_class.from_nat ?ab4 =\n                     mod_type_class.from_nat ?ba4) =\n                    (?ab4 = ?ba4)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "from inj[OF 2(1-2)]"], ["proof (chain)\npicking this:\n  (mod_type_class.from_nat a = mod_type_class.from_nat b) = (a = b)", "have id2: \"sign ?sfab = sign ?sab\""], ["proof (prove)\nusing this:\n  (mod_type_class.from_nat a = mod_type_class.from_nat b) = (a = b)\n\ngoal (1 subgoal):\n 1. sign\n     (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b) id) =\n    sign (Fun.swap a b id)", "unfolding sign_swap_id"], ["proof (prove)\nusing this:\n  (mod_type_class.from_nat a = mod_type_class.from_nat b) = (a = b)\n\ngoal (1 subgoal):\n 1. (if mod_type_class.from_nat a = mod_type_class.from_nat b then 1\n     else - 1) =\n    (if a = b then 1 else - 1)", "by simp"], ["proof (state)\nthis:\n  sign\n   (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b) id) =\n  sign (Fun.swap a b id)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "have id: \"?ft (Fun.swap a b id \\<circ> p) = Fun.swap (?fn a) (?fn b) id \\<circ> ?ft p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        mod_type_class.from_nat\n         ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat i))) =\n    Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n     id \\<circ>\n    (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       mod_type_class.from_nat\n        ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat i)) =\n       (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n         id \\<circ>\n        (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n        i", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       mod_type_class.from_nat\n        ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat i)) =\n       (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n         id \\<circ>\n        (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n        i", "show \"?ft (Fun.swap a b id \\<circ> p) c = (Fun.swap (?fn a) (?fn b) id \\<circ> ?ft p) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c", "proof (cases \"p (?tn c) = a \\<or> p (?tn c) = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p (mod_type_class.to_nat c) = a \\<or>\n    p (mod_type_class.to_nat c) = b \\<Longrightarrow>\n    mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c\n 2. \\<not> (p (mod_type_class.to_nat c) = a \\<or>\n            p (mod_type_class.to_nat c) = b) \\<Longrightarrow>\n    mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c", "case True"], ["proof (state)\nthis:\n  p (mod_type_class.to_nat c) = a \\<or> p (mod_type_class.to_nat c) = b\n\ngoal (2 subgoals):\n 1. p (mod_type_class.to_nat c) = a \\<or>\n    p (mod_type_class.to_nat c) = b \\<Longrightarrow>\n    mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c\n 2. \\<not> (p (mod_type_class.to_nat c) = a \\<or>\n            p (mod_type_class.to_nat c) = b) \\<Longrightarrow>\n    mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c", "thus ?thesis"], ["proof (prove)\nusing this:\n  p (mod_type_class.to_nat c) = a \\<or> p (mod_type_class.to_nat c) = b\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c", "by (cases, auto simp add: o_def swap_def)"], ["proof (state)\nthis:\n  mod_type_class.from_nat\n   ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n  (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n    id \\<circ>\n   (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n   c\n\ngoal (1 subgoal):\n 1. \\<not> (p (mod_type_class.to_nat c) = a \\<or>\n            p (mod_type_class.to_nat c) = b) \\<Longrightarrow>\n    mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p (mod_type_class.to_nat c) = a \\<or>\n            p (mod_type_class.to_nat c) = b) \\<Longrightarrow>\n    mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c", "case False"], ["proof (state)\nthis:\n  \\<not> (p (mod_type_class.to_nat c) = a \\<or>\n          p (mod_type_class.to_nat c) = b)\n\ngoal (1 subgoal):\n 1. \\<not> (p (mod_type_class.to_nat c) = a \\<or>\n            p (mod_type_class.to_nat c) = b) \\<Longrightarrow>\n    mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c", "hence neq: \"p (?tn c) \\<noteq> a\" \"p (?tn c) \\<noteq> b\""], ["proof (prove)\nusing this:\n  \\<not> (p (mod_type_class.to_nat c) = a \\<or>\n          p (mod_type_class.to_nat c) = b)\n\ngoal (1 subgoal):\n 1. p (mod_type_class.to_nat c) \\<noteq> a &&&\n    p (mod_type_class.to_nat c) \\<noteq> b", "by auto"], ["proof (state)\nthis:\n  p (mod_type_class.to_nat c) \\<noteq> a\n  p (mod_type_class.to_nat c) \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<not> (p (mod_type_class.to_nat c) = a \\<or>\n            p (mod_type_class.to_nat c) = b) \\<Longrightarrow>\n    mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c", "have pc: \"p (?tn c) \\<in> ?zn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p (mod_type_class.to_nat c) \\<in> {0..<CARD('n)}", "unfolding permutes_in_image[OF IH1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat c \\<in> {0..<CARD('n)}", "by (simp add: to_nat_less_card)"], ["proof (state)\nthis:\n  p (mod_type_class.to_nat c) \\<in> {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<not> (p (mod_type_class.to_nat c) = a \\<or>\n            p (mod_type_class.to_nat c) = b) \\<Longrightarrow>\n    mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c", "from neq[folded inj[OF pc 2(1)] inj[OF pc 2(2)]]"], ["proof (chain)\npicking this:\n  mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n  mod_type_class.from_nat a\n  mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n  mod_type_class.from_nat b", "have \"?fn (p (?tn c)) \\<noteq> ?fn a\" \"?fn (p (?tn c)) \\<noteq> ?fn b\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n  mod_type_class.from_nat a\n  mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n  mod_type_class.from_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n    mod_type_class.from_nat a &&&\n    mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n    mod_type_class.from_nat b", "."], ["proof (state)\nthis:\n  mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n  mod_type_class.from_nat a\n  mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n  mod_type_class.from_nat b\n\ngoal (1 subgoal):\n 1. \\<not> (p (mod_type_class.to_nat c) = a \\<or>\n            p (mod_type_class.to_nat c) = b) \\<Longrightarrow>\n    mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c", "with neq"], ["proof (chain)\npicking this:\n  p (mod_type_class.to_nat c) \\<noteq> a\n  p (mod_type_class.to_nat c) \\<noteq> b\n  mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n  mod_type_class.from_nat a\n  mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n  mod_type_class.from_nat b", "show ?thesis"], ["proof (prove)\nusing this:\n  p (mod_type_class.to_nat c) \\<noteq> a\n  p (mod_type_class.to_nat c) \\<noteq> b\n  mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n  mod_type_class.from_nat a\n  mod_type_class.from_nat (p (mod_type_class.to_nat c)) \\<noteq>\n  mod_type_class.from_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n    (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n      id \\<circ>\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n     c", "by (auto simp: o_def swap_def)"], ["proof (state)\nthis:\n  mod_type_class.from_nat\n   ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n  (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n    id \\<circ>\n   (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n   c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat\n   ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat c)) =\n  (Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n    id \\<circ>\n   (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n   c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      mod_type_class.from_nat\n       ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat i))) =\n  Fun.swap (mod_type_class.from_nat a) (mod_type_class.from_nat b)\n   id \\<circ>\n  (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign\n         (\\<lambda>i.\n             mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              mod_type_class.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (mod_type_class.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (Fun.swap a b id \\<circ> p) =\n    sign\n     (\\<lambda>i.\n         mod_type_class.from_nat\n          ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat i))) \\<and>\n    Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "unfolding IH2 id sign_compose[OF p_sab 2(5)] sign_compose[OF p_sfab p_ftp] id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (Fun.swap a b id) *\n    sign\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))) =\n    sign (Fun.swap a b id) *\n    sign\n     (\\<lambda>i.\n         mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n    Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "by (rule conjI[OF refl perm1])"], ["proof (state)\nthis:\n  sign (Fun.swap a b id \\<circ> p) =\n  sign\n   (\\<lambda>i.\n       mod_type_class.from_nat\n        ((Fun.swap a b id \\<circ> p) (mod_type_class.to_nat i))) \\<and>\n  Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign p =\n  sign\n   (\\<lambda>i.\n       mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int\n        (sign\n          (\\<lambda>i.\n              mod_type_class.from_nat (x (mod_type_class.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h mod_type_class.from_nat (x (mod_type_class.to_nat i)))", "thus \"signof p = of_int (sign ?q)\""], ["proof (prove)\nusing this:\n  sign p =\n  sign\n   (\\<lambda>i.\n       mod_type_class.from_nat (p (mod_type_class.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. signof p =\n    of_int\n     (sign\n       (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))", "unfolding signof_def sign_def"], ["proof (prove)\nusing this:\n  (if evenperm p then 1 else - 1) =\n  (if evenperm\n       (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n   then 1 else - 1) \\<and>\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. (if (if evenperm p then 1 else - 1) = 1 then 1::'b else - (1::'b)) =\n    of_int\n     (if evenperm\n          (\\<lambda>i.\n              mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n      then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  signof p =\n  of_int\n   (sign\n     (\\<lambda>i. mod_type_class.from_nat (p (mod_type_class.to_nat i))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h mod_type_class.from_nat i $h\n           mod_type_class.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h mod_type_class.from_nat (x (mod_type_class.to_nat i)))", "show \"(\\<Prod>i = 0..<CARD('n). a $h ?fn i $h ?fn (p i)) =\n           (\\<Prod>i\\<in>UNIV. a $h i $h ?q i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<CARD('n).\n        a $h mod_type_class.from_nat i $h mod_type_class.from_nat (p i)) =\n    (\\<Prod>i\\<in>UNIV.\n       a $h i $h mod_type_class.from_nat (p (mod_type_class.to_nat i)))", "unfolding \n           range_to_nat[symmetric] prod.reindex[OF inj_to_nat]"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod\n     ((\\<lambda>i.\n          a $h mod_type_class.from_nat i $h\n          mod_type_class.from_nat (p i)) \\<circ>\n      mod_type_class.to_nat)\n     UNIV =\n    (\\<Prod>i\\<in>UNIV.\n       a $h i $h mod_type_class.from_nat (p (mod_type_class.to_nat i)))", "by (rule prod.cong[OF refl], unfold o_def, simp)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<CARD('n).\n      a $h mod_type_class.from_nat i $h mod_type_class.from_nat (p i)) =\n  (\\<Prod>i\\<in>UNIV.\n     a $h i $h mod_type_class.from_nat (p (mod_type_class.to_nat i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<CARD('n)}.\n     signof p *\n     (\\<Prod>i = 0..<CARD('n).\n         a $h mod_type_class.from_nat i $h mod_type_class.from_nat (p i))) =\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. a $h i $h p i))\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "}"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<CARD('n)}.\n     signof p *\n     (\\<Prod>i = 0..<CARD('n).\n         ?a2 $h mod_type_class.from_nat i $h\n         mod_type_class.from_nat (p i))) =\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. ?a2 $h i $h p i))\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>p | p permutes {0..<CARD('n)}.\n     signof p *\n     (\\<Prod>i = 0..<CARD('n).\n         ?a2 $h mod_type_class.from_nat i $h\n         mod_type_class.from_nat (p i))) =\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. ?a2 $h i $h p i))\n\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det", "unfolding HMA_M_def"], ["proof (prove)\nusing this:\n  (\\<Sum>p | p permutes {0..<CARD('n)}.\n     signof p *\n     (\\<Prod>i = 0..<CARD('n).\n         ?a2 $h mod_type_class.from_nat i $h\n         mod_type_class.from_nat (p i))) =\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. ?a2 $h i $h p i))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>a b. a = Mod_Type_Connect.from_hma\\<^sub>m b) ===> (=))\n     Determinant.det det", "by (auto simp: from_hma\\<^sub>m_def Determinant.det_def det_def)"], ["proof (state)\nthis:\n  (Mod_Type_Connect.HMA_M ===> (=)) Determinant.det det\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_mat[transfer_rule]: \"((=) ===> HMA_M) (\\<lambda> k. k \\<cdot>\\<^sub>m 1\\<^sub>m CARD('n)) \n  (Finite_Cartesian_Product.mat :: 'a::semiring_1 \\<Rightarrow> 'a^'n :: mod_type^'n :: mod_type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> Mod_Type_Connect.HMA_M)\n     (\\<lambda>k. k \\<cdot>\\<^sub>m 1\\<^sub>m CARD('n)) mat", "unfolding Finite_Cartesian_Product.mat_def[abs_def] rel_fun_def HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = y \\<longrightarrow>\n       x \\<cdot>\\<^sub>m 1\\<^sub>m CARD('n) =\n       Mod_Type_Connect.from_hma\\<^sub>m\n        (\\<chi>i j. if i = j then y else (0::'a))", "by (auto simp: from_hma\\<^sub>m_def from_nat_inj)"], ["", "lemma HMA_mat_minus[transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) \n  (\\<lambda> A B. A + map_mat uminus B) ((-) :: 'a :: group_add ^'nc:: mod_type^'nr:: mod_type \n  \\<Rightarrow> 'a^'nc:: mod_type^'nr:: mod_type \\<Rightarrow> 'a^'nc:: mod_type^'nr:: mod_type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M)\n     (\\<lambda>A B. A + map_mat uminus B) (-)", "unfolding rel_fun_def HMA_M_def from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x =\n       Matrix.mat CARD('nr) CARD('nc)\n        (\\<lambda>(i, j).\n            y $h mod_type_class.from_nat i $h\n            mod_type_class.from_nat j) \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa =\n           Matrix.mat CARD('nr) CARD('nc)\n            (\\<lambda>(i, j).\n                ya $h mod_type_class.from_nat i $h\n                mod_type_class.from_nat j) \\<longrightarrow>\n           x + map_mat uminus xa =\n           Matrix.mat CARD('nr) CARD('nc)\n            (\\<lambda>(i, j).\n                (y - ya) $h mod_type_class.from_nat i $h\n                mod_type_class.from_nat j))", "by auto"], ["", "lemma HMA_transpose_matrix [transfer_rule]: \n  \"(HMA_M ===> HMA_M) transpose_mat transpose\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M) transpose_mat\n     Finite_Cartesian_Product.transpose", "unfolding transpose_mat_def transpose_def HMA_M_def from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>a b.\n         a =\n         Matrix.mat CARD('c) CARD('b)\n          (\\<lambda>(i, j).\n              b $h mod_type_class.from_nat i $h\n              mod_type_class.from_nat j)) ===>\n     (\\<lambda>a b.\n         a =\n         Matrix.mat CARD('b) CARD('c)\n          (\\<lambda>(i, j).\n              b $h mod_type_class.from_nat i $h mod_type_class.from_nat j)))\n     (\\<lambda>A.\n         Matrix.mat (dim_col A) (dim_row A) (\\<lambda>(i, j). A $$ (j, i)))\n     (\\<lambda>A. \\<chi>i j. A $h j $h i)", "by auto"], ["", "lemma HMA_invertible_matrix_mod_type[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n :: mod_type ^ 'n :: mod_type \n      \\<Rightarrow> _) ===> (=)) invertible_mat invertible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) invertible_mat invertible", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       invertible_mat x = invertible y", "case (1 x y)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       invertible_mat x = invertible y", "note rel_xy[transfer_rule] = \"1\""], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       invertible_mat x = invertible y", "have eq_dim: \"dim_col x = dim_row x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col x = dim_row x", "using Mod_Type_Connect.dim_col_transfer_rule Mod_Type_Connect.dim_row_transfer_rule rel_xy"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. dim_col x = dim_row x", "by fastforce"], ["proof (state)\nthis:\n  dim_col x = dim_row x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       invertible_mat x = invertible y", "moreover"], ["proof (state)\nthis:\n  dim_col x = dim_row x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       invertible_mat x = invertible y", "have \"\\<exists>A'. y ** A' = mat 1 \\<and> A' ** y = mat 1\" \n    if xB: \"x * B = 1\\<^sub>m (dim_row x)\" and Bx: \"B * x = 1\\<^sub>m (dim_row B)\" for B"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)", "let ?A' = \"Mod_Type_Connect.to_hma\\<^sub>m B:: 'a :: comm_ring_1 ^ 'n :: mod_type^ 'n :: mod_type\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)", "have rel_BA[transfer_rule]: \"Mod_Type_Connect.HMA_M B ?A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M B (Mod_Type_Connect.to_hma\\<^sub>m B)", "by (metis (no_types, lifting) Bx Mod_Type_Connect.HMA_M_def eq_dim carrier_mat_triv dim_col_mat(1)\n          Mod_Type_Connect.from_hma\\<^sub>m_def Mod_Type_Connect.from_hma_to_hma\\<^sub>m index_mult_mat(3) \n          index_one_mat(3) rel_xy xB)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M B (Mod_Type_Connect.to_hma\\<^sub>m B)\n\ngoal (1 subgoal):\n 1. \\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)", "have [simp]: \"dim_row B = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row B = CARD('n)", "using Mod_Type_Connect.dim_row_transfer_rule rel_BA"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  Mod_Type_Connect.HMA_M B (Mod_Type_Connect.to_hma\\<^sub>m B)\n\ngoal (1 subgoal):\n 1. dim_row B = CARD('n)", "by blast"], ["proof (state)\nthis:\n  dim_row B = CARD('n)\n\ngoal (1 subgoal):\n 1. \\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)", "have [simp]: \"dim_row x = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row x = CARD('n)", "using Mod_Type_Connect.dim_row_transfer_rule rel_xy"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  Mod_Type_Connect.HMA_M x y\n\ngoal (1 subgoal):\n 1. dim_row x = CARD('n)", "by blast"], ["proof (state)\nthis:\n  dim_row x = CARD('n)\n\ngoal (1 subgoal):\n 1. \\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)", "have \"y ** ?A' = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y ** Mod_Type_Connect.to_hma\\<^sub>m B = mat (1::'a)", "using xB"], ["proof (prove)\nusing this:\n  x * B = 1\\<^sub>m (dim_row x)\n\ngoal (1 subgoal):\n 1. y ** Mod_Type_Connect.to_hma\\<^sub>m B = mat (1::'a)", "by (transfer, simp)"], ["proof (state)\nthis:\n  y ** Mod_Type_Connect.to_hma\\<^sub>m B = mat (1::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)", "moreover"], ["proof (state)\nthis:\n  y ** Mod_Type_Connect.to_hma\\<^sub>m B = mat (1::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)", "have \"?A' ** y  = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m B ** y = mat (1::'a)", "using Bx"], ["proof (prove)\nusing this:\n  B * x = 1\\<^sub>m (dim_row B)\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.to_hma\\<^sub>m B ** y = mat (1::'a)", "by (transfer, simp)"], ["proof (state)\nthis:\n  Mod_Type_Connect.to_hma\\<^sub>m B ** y = mat (1::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)", "ultimately"], ["proof (chain)\npicking this:\n  y ** Mod_Type_Connect.to_hma\\<^sub>m B = mat (1::'a)\n  Mod_Type_Connect.to_hma\\<^sub>m B ** y = mat (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  y ** Mod_Type_Connect.to_hma\\<^sub>m B = mat (1::'a)\n  Mod_Type_Connect.to_hma\\<^sub>m B ** y = mat (1::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)", "by blast"], ["proof (state)\nthis:\n  \\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>x * ?B = 1\\<^sub>m (dim_row x);\n   ?B * x = 1\\<^sub>m (dim_row ?B)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A'.\n                       y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       invertible_mat x = invertible y", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>x * ?B = 1\\<^sub>m (dim_row x);\n   ?B * x = 1\\<^sub>m (dim_row ?B)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A'.\n                       y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       invertible_mat x = invertible y", "have \"\\<exists>B. x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)\"\n    if yA: \"y ** A' = mat 1\" and Ay: \"A' ** y = mat 1\" for A'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B.\n       x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B.\n       x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)", "let ?B = \"(Mod_Type_Connect.from_hma\\<^sub>m A')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B.\n       x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)", "have [simp]: \"dim_row x = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row x = CARD('n)", "using rel_xy Mod_Type_Connect.dim_row_transfer_rule"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M x y\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n\ngoal (1 subgoal):\n 1. dim_row x = CARD('n)", "by blast"], ["proof (state)\nthis:\n  dim_row x = CARD('n)\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M ?B A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M (Mod_Type_Connect.from_hma\\<^sub>m A') A'", "by (simp add: Mod_Type_Connect.HMA_M_def)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M (Mod_Type_Connect.from_hma\\<^sub>m A') A'\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)", "hence [simp]: \"dim_row ?B = CARD('n)\""], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M (Mod_Type_Connect.from_hma\\<^sub>m A') A'\n\ngoal (1 subgoal):\n 1. dim_row (Mod_Type_Connect.from_hma\\<^sub>m A') = CARD('n)", "using dim_row_transfer_rule"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M (Mod_Type_Connect.from_hma\\<^sub>m A') A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n\ngoal (1 subgoal):\n 1. dim_row (Mod_Type_Connect.from_hma\\<^sub>m A') = CARD('n)", "by auto"], ["proof (state)\nthis:\n  dim_row (Mod_Type_Connect.from_hma\\<^sub>m A') = CARD('n)\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)", "have \"x * ?B = 1\\<^sub>m (dim_row x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * Mod_Type_Connect.from_hma\\<^sub>m A' = 1\\<^sub>m (dim_row x)", "using yA"], ["proof (prove)\nusing this:\n  y ** A' = mat (1::'a)\n\ngoal (1 subgoal):\n 1. x * Mod_Type_Connect.from_hma\\<^sub>m A' = 1\\<^sub>m (dim_row x)", "by (transfer', auto)"], ["proof (state)\nthis:\n  x * Mod_Type_Connect.from_hma\\<^sub>m A' = 1\\<^sub>m (dim_row x)\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)", "moreover"], ["proof (state)\nthis:\n  x * Mod_Type_Connect.from_hma\\<^sub>m A' = 1\\<^sub>m (dim_row x)\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)", "have \"?B * x = 1\\<^sub>m (dim_row ?B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.from_hma\\<^sub>m A' * x =\n    1\\<^sub>m (dim_row (Mod_Type_Connect.from_hma\\<^sub>m A'))", "using Ay"], ["proof (prove)\nusing this:\n  A' ** y = mat (1::'a)\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.from_hma\\<^sub>m A' * x =\n    1\\<^sub>m (dim_row (Mod_Type_Connect.from_hma\\<^sub>m A'))", "by (transfer', auto)"], ["proof (state)\nthis:\n  Mod_Type_Connect.from_hma\\<^sub>m A' * x =\n  1\\<^sub>m (dim_row (Mod_Type_Connect.from_hma\\<^sub>m A'))\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)", "ultimately"], ["proof (chain)\npicking this:\n  x * Mod_Type_Connect.from_hma\\<^sub>m A' = 1\\<^sub>m (dim_row x)\n  Mod_Type_Connect.from_hma\\<^sub>m A' * x =\n  1\\<^sub>m (dim_row (Mod_Type_Connect.from_hma\\<^sub>m A'))", "show ?thesis"], ["proof (prove)\nusing this:\n  x * Mod_Type_Connect.from_hma\\<^sub>m A' = 1\\<^sub>m (dim_row x)\n  Mod_Type_Connect.from_hma\\<^sub>m A' * x =\n  1\\<^sub>m (dim_row (Mod_Type_Connect.from_hma\\<^sub>m A'))\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)", "by auto"], ["proof (state)\nthis:\n  \\<exists>B.\n     x * B = 1\\<^sub>m (dim_row x) \\<and> B * x = 1\\<^sub>m (dim_row B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>y ** ?A' = mat (1::'a); ?A' ** y = mat (1::'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B.\n                       x * B = 1\\<^sub>m (dim_row x) \\<and>\n                       B * x = 1\\<^sub>m (dim_row B)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       invertible_mat x = invertible y", "ultimately"], ["proof (chain)\npicking this:\n  dim_col x = dim_row x\n  \\<lbrakk>x * ?B = 1\\<^sub>m (dim_row x);\n   ?B * x = 1\\<^sub>m (dim_row ?B)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A'.\n                       y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)\n  \\<lbrakk>y ** ?A' = mat (1::'a); ?A' ** y = mat (1::'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B.\n                       x * B = 1\\<^sub>m (dim_row x) \\<and>\n                       B * x = 1\\<^sub>m (dim_row B)", "show ?case"], ["proof (prove)\nusing this:\n  dim_col x = dim_row x\n  \\<lbrakk>x * ?B = 1\\<^sub>m (dim_row x);\n   ?B * x = 1\\<^sub>m (dim_row ?B)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A'.\n                       y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)\n  \\<lbrakk>y ** ?A' = mat (1::'a); ?A' ** y = mat (1::'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B.\n                       x * B = 1\\<^sub>m (dim_row x) \\<and>\n                       B * x = 1\\<^sub>m (dim_row B)\n\ngoal (1 subgoal):\n 1. invertible_mat x = invertible y", "unfolding invertible_mat_def invertible_def inverts_mat_def"], ["proof (prove)\nusing this:\n  dim_col x = dim_row x\n  \\<lbrakk>x * ?B = 1\\<^sub>m (dim_row x);\n   ?B * x = 1\\<^sub>m (dim_row ?B)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A'.\n                       y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a)\n  \\<lbrakk>y ** ?A' = mat (1::'a); ?A' ** y = mat (1::'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B.\n                       x * B = 1\\<^sub>m (dim_row x) \\<and>\n                       B * x = 1\\<^sub>m (dim_row B)\n\ngoal (1 subgoal):\n 1. (square_mat x \\<and>\n     (\\<exists>B.\n         x * B = 1\\<^sub>m (dim_row x) \\<and>\n         B * x = 1\\<^sub>m (dim_row B))) =\n    (\\<exists>A'. y ** A' = mat (1::'a) \\<and> A' ** y = mat (1::'a))", "by auto"], ["proof (state)\nthis:\n  invertible_mat x = invertible y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>Some transfer rules for relating the elementary operations are also proved.\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma HMA_swaprows[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _)\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nr :: mod_type \\<Rightarrow> _ )\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nr :: mod_type \\<Rightarrow> _ )     \n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A a b. swaprows a b A) interchange_rows\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_I ===>\n     Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_M)\n     (\\<lambda>A a b. swaprows a b A) interchange_rows", "by (intro rel_funI, goal_cases, auto simp add: Mod_Type_Connect.HMA_M_def interchange_rows_def)\n     (rule eq_matI, auto simp add: Mod_Type_Connect.from_hma\\<^sub>m_def Mod_Type_Connect.HMA_I_def \n      to_nat_less_card to_nat_from_nat_id)"], ["", "lemma HMA_swapcols[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _)\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nc :: mod_type \\<Rightarrow> _ )\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nc :: mod_type \\<Rightarrow> _ )     \n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A a b. swapcols a b A) interchange_columns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_I ===>\n     Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_M)\n     (\\<lambda>A a b. swapcols a b A) interchange_columns", "by (intro rel_funI, goal_cases, auto simp add: Mod_Type_Connect.HMA_M_def interchange_columns_def)\n     (rule eq_matI, auto simp add: Mod_Type_Connect.from_hma\\<^sub>m_def Mod_Type_Connect.HMA_I_def \n      to_nat_less_card to_nat_from_nat_id)"], ["", "lemma HMA_addrow[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _) \n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nr :: mod_type \\<Rightarrow> _ )\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nr :: mod_type \\<Rightarrow> _ ) \n    ===> (=)\n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A a b q. addrow q a b A) row_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_I ===>\n     Mod_Type_Connect.HMA_I ===> (=) ===> Mod_Type_Connect.HMA_M)\n     (\\<lambda>A a b q. addrow q a b A) row_add", "by (intro rel_funI, goal_cases, auto simp add: Mod_Type_Connect.HMA_M_def row_add_def)\n     (rule eq_matI, auto simp add: Mod_Type_Connect.from_hma\\<^sub>m_def Mod_Type_Connect.HMA_I_def \n      to_nat_less_card to_nat_from_nat_id)"], ["", "lemma HMA_addcol[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _) \n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nc :: mod_type \\<Rightarrow> _ )\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nc :: mod_type \\<Rightarrow> _ ) \n    ===> (=)\n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A a b q. addcol q a b A) column_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_I ===>\n     Mod_Type_Connect.HMA_I ===> (=) ===> Mod_Type_Connect.HMA_M)\n     (\\<lambda>A a b q. addcol q a b A) column_add", "by (intro rel_funI, goal_cases, auto simp add: Mod_Type_Connect.HMA_M_def column_add_def)\n     (rule eq_matI, auto simp add: Mod_Type_Connect.from_hma\\<^sub>m_def Mod_Type_Connect.HMA_I_def \n      to_nat_less_card to_nat_from_nat_id)"], ["", "lemma HMA_multrow[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _)\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nr :: mod_type \\<Rightarrow> _ )\n    ===> (=)     \n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A i q. multrow i q A) mult_row\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_I ===> (=) ===> Mod_Type_Connect.HMA_M)\n     (\\<lambda>A i q. multrow i q A) mult_row", "by (intro rel_funI, goal_cases, auto simp add: Mod_Type_Connect.HMA_M_def mult_row_def)\n     (rule eq_matI, auto simp add: Mod_Type_Connect.from_hma\\<^sub>m_def Mod_Type_Connect.HMA_I_def \n      to_nat_less_card to_nat_from_nat_id)"], ["", "lemma HMA_multcol[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'nc :: mod_type ^ 'nr :: mod_type \\<Rightarrow> _)\n    ===> (Mod_Type_Connect.HMA_I :: _ \\<Rightarrow>'nc :: mod_type \\<Rightarrow> _ )\n    ===> (=)     \n    ===> Mod_Type_Connect.HMA_M) \n    (\\<lambda>A i q. multcol i q A) mult_column\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===>\n     Mod_Type_Connect.HMA_I ===> (=) ===> Mod_Type_Connect.HMA_M)\n     (\\<lambda>A i q. multcol i q A) mult_column", "by (intro rel_funI, goal_cases, auto simp add: Mod_Type_Connect.HMA_M_def mult_column_def)\n     (rule eq_matI, auto simp add: Mod_Type_Connect.from_hma\\<^sub>m_def Mod_Type_Connect.HMA_I_def \n      to_nat_less_card to_nat_from_nat_id)"], ["", "end"], ["", "fun HMA_M3 where\n  \"HMA_M3 (P,A,Q) \n  (P' :: 'a :: comm_ring_1 ^ 'nr :: mod_type ^ 'nr :: mod_type,\n   A' :: 'a ^ 'nc :: mod_type ^ 'nr :: mod_type,\n   Q' :: 'a ^ 'nc :: mod_type ^ 'nc :: mod_type) = \n  (Mod_Type_Connect.HMA_M P P' \\<and> Mod_Type_Connect.HMA_M A A' \\<and> Mod_Type_Connect.HMA_M Q Q')\""], ["", "lemma HMA_M3_def: \n  \"HMA_M3 A B = (Mod_Type_Connect.HMA_M (fst A) (fst B) \n  \\<and> Mod_Type_Connect.HMA_M (fst (snd A)) (fst (snd B)) \n  \\<and> Mod_Type_Connect.HMA_M (snd (snd A)) (snd (snd B)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M3 A B =\n    (Mod_Type_Connect.HMA_M (fst A) (fst B) \\<and>\n     Mod_Type_Connect.HMA_M (fst (snd A)) (fst (snd B)) \\<and>\n     Mod_Type_Connect.HMA_M (snd (snd A)) (snd (snd B)))", "by (smt HMA_M3.simps prod.collapse)"], ["", "context \n  includes lifting_syntax\nbegin"], ["", "lemma Domainp_HMA_M3 [transfer_domain_rule]: \n \"Domainp (HMA_M3 :: _\\<Rightarrow>(_\\<times>('a::comm_ring_1^'nc::mod_type^'nr::mod_type)\\<times>_)\\<Rightarrow>_) \n = (\\<lambda>(P,A,Q). P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and> A \\<in> carrier_mat CARD('nr) CARD('nc) \n  \\<and> Q \\<in> carrier_mat CARD('nc) CARD('nc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp HMA_M3 =\n    (\\<lambda>(P, A, Q).\n        P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n        A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n        Q \\<in> carrier_mat CARD('nc) CARD('nc))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp HMA_M3 =\n    (\\<lambda>(P, A, Q).\n        P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n        A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n        Q \\<in> carrier_mat CARD('nc) CARD('nc))", "let ?HMA_M3 = \"HMA_M3::_\\<Rightarrow>(_\\<times>('a::comm_ring_1^'nc::mod_type^'nr::mod_type)\\<times>_)\\<Rightarrow>_\""], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp HMA_M3 =\n    (\\<lambda>(P, A, Q).\n        P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n        A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n        Q \\<in> carrier_mat CARD('nc) CARD('nc))", "have 1: \"P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n         A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and> Q \\<in> carrier_mat CARD('nc) CARD('nc)\"\n    if \"Domainp ?HMA_M3 (P,A,Q)\" for P A Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n    A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n    Q \\<in> carrier_mat CARD('nc) CARD('nc)", "using that"], ["proof (prove)\nusing this:\n  Domainp HMA_M3 (P, A, Q)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n    A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n    Q \\<in> carrier_mat CARD('nc) CARD('nc)", "unfolding Domainp_iff"], ["proof (prove)\nusing this:\n  Ex (HMA_M3 (P, A, Q))\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n    A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n    Q \\<in> carrier_mat CARD('nc) CARD('nc)", "by (auto simp add: Mod_Type_Connect.HMA_M_def)"], ["proof (state)\nthis:\n  Domainp HMA_M3 (?P, ?A, ?Q) \\<Longrightarrow>\n  ?P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n  ?A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n  ?Q \\<in> carrier_mat CARD('nc) CARD('nc)\n\ngoal (1 subgoal):\n 1. Domainp HMA_M3 =\n    (\\<lambda>(P, A, Q).\n        P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n        A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n        Q \\<in> carrier_mat CARD('nc) CARD('nc))", "have 2: \"Domainp ?HMA_M3 (P,A,Q)\" if PAQ: \"P \\<in> carrier_mat CARD('nr) CARD('nr)\n   \\<and> A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>Q \\<in> carrier_mat CARD('nc) CARD('nc)\" for P A Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp HMA_M3 (P, A, Q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp HMA_M3 (P, A, Q)", "let ?P = \"Mod_Type_Connect.to_hma\\<^sub>m P::'a^'nr::mod_type^'nr::mod_type\""], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp HMA_M3 (P, A, Q)", "let ?A = \"Mod_Type_Connect.to_hma\\<^sub>m A::'a^'nc::mod_type^'nr::mod_type\""], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp HMA_M3 (P, A, Q)", "let ?Q = \"Mod_Type_Connect.to_hma\\<^sub>m Q::'a^'nc::mod_type^'nc::mod_type\""], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp HMA_M3 (P, A, Q)", "have \"HMA_M3 (P,A,Q) (?P,?A,?Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M3 (P, A, Q)\n     (Mod_Type_Connect.to_hma\\<^sub>m P, Mod_Type_Connect.to_hma\\<^sub>m A,\n      Mod_Type_Connect.to_hma\\<^sub>m Q)", "by (auto simp add: Mod_Type_Connect.HMA_M_def PAQ)"], ["proof (state)\nthis:\n  HMA_M3 (P, A, Q)\n   (Mod_Type_Connect.to_hma\\<^sub>m P, Mod_Type_Connect.to_hma\\<^sub>m A,\n    Mod_Type_Connect.to_hma\\<^sub>m Q)\n\ngoal (1 subgoal):\n 1. Domainp HMA_M3 (P, A, Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  HMA_M3 (P, A, Q)\n   (Mod_Type_Connect.to_hma\\<^sub>m P, Mod_Type_Connect.to_hma\\<^sub>m A,\n    Mod_Type_Connect.to_hma\\<^sub>m Q)\n\ngoal (1 subgoal):\n 1. Domainp HMA_M3 (P, A, Q)", "unfolding Domainp_iff"], ["proof (prove)\nusing this:\n  HMA_M3 (P, A, Q)\n   (Mod_Type_Connect.to_hma\\<^sub>m P, Mod_Type_Connect.to_hma\\<^sub>m A,\n    Mod_Type_Connect.to_hma\\<^sub>m Q)\n\ngoal (1 subgoal):\n 1. Ex (HMA_M3 (P, A, Q))", "by auto"], ["proof (state)\nthis:\n  Domainp HMA_M3 (P, A, Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n  ?A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n  ?Q \\<in> carrier_mat CARD('nc) CARD('nc) \\<Longrightarrow>\n  Domainp HMA_M3 (?P, ?A, ?Q)\n\ngoal (1 subgoal):\n 1. Domainp HMA_M3 =\n    (\\<lambda>(P, A, Q).\n        P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n        A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n        Q \\<in> carrier_mat CARD('nc) CARD('nc))", "have \"fst x \\<in> carrier_mat CARD('nr) CARD('nr) \\<and> fst (snd x) \\<in> carrier_mat CARD('nr) CARD('nc) \n      \\<and> (snd (snd x)) \\<in> carrier_mat CARD('nc) CARD('nc)\"\n    if \"Domainp ?HMA_M3 x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n    fst (snd x) \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n    snd (snd x) \\<in> carrier_mat CARD('nc) CARD('nc)", "using 1"], ["proof (prove)\nusing this:\n  Domainp HMA_M3 (?P, ?A, ?Q) \\<Longrightarrow>\n  ?P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n  ?A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n  ?Q \\<in> carrier_mat CARD('nc) CARD('nc)\n\ngoal (1 subgoal):\n 1. fst x \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n    fst (snd x) \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n    snd (snd x) \\<in> carrier_mat CARD('nc) CARD('nc)", "by (metis (full_types) surjective_pairing that)"], ["proof (state)\nthis:\n  Domainp HMA_M3 ?x \\<Longrightarrow>\n  fst ?x \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n  fst (snd ?x) \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n  snd (snd ?x) \\<in> carrier_mat CARD('nc) CARD('nc)\n\ngoal (1 subgoal):\n 1. Domainp HMA_M3 =\n    (\\<lambda>(P, A, Q).\n        P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n        A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n        Q \\<in> carrier_mat CARD('nc) CARD('nc))", "moreover"], ["proof (state)\nthis:\n  Domainp HMA_M3 ?x \\<Longrightarrow>\n  fst ?x \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n  fst (snd ?x) \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n  snd (snd ?x) \\<in> carrier_mat CARD('nc) CARD('nc)\n\ngoal (1 subgoal):\n 1. Domainp HMA_M3 =\n    (\\<lambda>(P, A, Q).\n        P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n        A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n        Q \\<in> carrier_mat CARD('nc) CARD('nc))", "have \"Domainp ?HMA_M3 x\" \n    if \"fst x \\<in> carrier_mat CARD('nr) CARD('nr) \\<and> fst (snd x) \\<in> carrier_mat CARD('nr) CARD('nc) \n      \\<and> (snd (snd x)) \\<in> carrier_mat CARD('nc) CARD('nc)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp HMA_M3 x", "using 2"], ["proof (prove)\nusing this:\n  ?P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n  ?A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n  ?Q \\<in> carrier_mat CARD('nc) CARD('nc) \\<Longrightarrow>\n  Domainp HMA_M3 (?P, ?A, ?Q)\n\ngoal (1 subgoal):\n 1. Domainp HMA_M3 x", "by (metis (full_types) surjective_pairing that)"], ["proof (state)\nthis:\n  fst ?x \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n  fst (snd ?x) \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n  snd (snd ?x) \\<in> carrier_mat CARD('nc) CARD('nc) \\<Longrightarrow>\n  Domainp HMA_M3 ?x\n\ngoal (1 subgoal):\n 1. Domainp HMA_M3 =\n    (\\<lambda>(P, A, Q).\n        P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n        A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n        Q \\<in> carrier_mat CARD('nc) CARD('nc))", "ultimately"], ["proof (chain)\npicking this:\n  Domainp HMA_M3 ?x \\<Longrightarrow>\n  fst ?x \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n  fst (snd ?x) \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n  snd (snd ?x) \\<in> carrier_mat CARD('nc) CARD('nc)\n  fst ?x \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n  fst (snd ?x) \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n  snd (snd ?x) \\<in> carrier_mat CARD('nc) CARD('nc) \\<Longrightarrow>\n  Domainp HMA_M3 ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  Domainp HMA_M3 ?x \\<Longrightarrow>\n  fst ?x \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n  fst (snd ?x) \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n  snd (snd ?x) \\<in> carrier_mat CARD('nc) CARD('nc)\n  fst ?x \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n  fst (snd ?x) \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n  snd (snd ?x) \\<in> carrier_mat CARD('nc) CARD('nc) \\<Longrightarrow>\n  Domainp HMA_M3 ?x\n\ngoal (1 subgoal):\n 1. Domainp HMA_M3 =\n    (\\<lambda>(P, A, Q).\n        P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n        A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n        Q \\<in> carrier_mat CARD('nc) CARD('nc))", "by (intro ext iffI, unfold split_beta, metis+)"], ["proof (state)\nthis:\n  Domainp HMA_M3 =\n  (\\<lambda>(P, A, Q).\n      P \\<in> carrier_mat CARD('nr) CARD('nr) \\<and>\n      A \\<in> carrier_mat CARD('nr) CARD('nc) \\<and>\n      Q \\<in> carrier_mat CARD('nc) CARD('nc))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bi_unique_HMA_M3 [transfer_rule]: \"bi_unique HMA_M3\" \"left_unique HMA_M3\" \"right_unique HMA_M3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique HMA_M3 &&& left_unique HMA_M3 &&& right_unique HMA_M3", "unfolding HMA_M3_def bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        Mod_Type_Connect.HMA_M (fst x) (fst y) \\<and>\n        Mod_Type_Connect.HMA_M (fst (snd x)) (fst (snd y)) \\<and>\n        Mod_Type_Connect.HMA_M (snd (snd x)) (snd (snd y)) \\<longrightarrow>\n        Mod_Type_Connect.HMA_M (fst x) (fst z) \\<and>\n        Mod_Type_Connect.HMA_M (fst (snd x)) (fst (snd z)) \\<and>\n        Mod_Type_Connect.HMA_M (snd (snd x)) (snd (snd z)) \\<longrightarrow>\n        y = z) \\<and>\n    (\\<forall>x y z.\n        Mod_Type_Connect.HMA_M (fst x) (fst z) \\<and>\n        Mod_Type_Connect.HMA_M (fst (snd x)) (fst (snd z)) \\<and>\n        Mod_Type_Connect.HMA_M (snd (snd x)) (snd (snd z)) \\<longrightarrow>\n        Mod_Type_Connect.HMA_M (fst y) (fst z) \\<and>\n        Mod_Type_Connect.HMA_M (fst (snd y)) (fst (snd z)) \\<and>\n        Mod_Type_Connect.HMA_M (snd (snd y)) (snd (snd z)) \\<longrightarrow>\n        x = y) &&&\n    \\<forall>x y z.\n       Mod_Type_Connect.HMA_M (fst x) (fst z) \\<and>\n       Mod_Type_Connect.HMA_M (fst (snd x)) (fst (snd z)) \\<and>\n       Mod_Type_Connect.HMA_M (snd (snd x)) (snd (snd z)) \\<longrightarrow>\n       Mod_Type_Connect.HMA_M (fst y) (fst z) \\<and>\n       Mod_Type_Connect.HMA_M (fst (snd y)) (fst (snd z)) \\<and>\n       Mod_Type_Connect.HMA_M (snd (snd y)) (snd (snd z)) \\<longrightarrow>\n       x = y &&&\n    \\<forall>x y z.\n       Mod_Type_Connect.HMA_M (fst x) (fst y) \\<and>\n       Mod_Type_Connect.HMA_M (fst (snd x)) (fst (snd y)) \\<and>\n       Mod_Type_Connect.HMA_M (snd (snd x)) (snd (snd y)) \\<longrightarrow>\n       Mod_Type_Connect.HMA_M (fst x) (fst z) \\<and>\n       Mod_Type_Connect.HMA_M (fst (snd x)) (fst (snd z)) \\<and>\n       Mod_Type_Connect.HMA_M (snd (snd x)) (snd (snd z)) \\<longrightarrow>\n       y = z", "by (auto simp add: Mod_Type_Connect.HMA_M_def)"], ["", "lemma right_total_HMA_M3 [transfer_rule]: \"right_total HMA_M3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total HMA_M3", "unfolding HMA_M_def right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. HMA_M3 x y", "by (simp add: Mod_Type_Connect.HMA_M_def)"], ["", "end"], ["", "(*\n  TODO: add more theorems to connect everything from HA to JNF in this setting.\n*)"], ["", "end"]]}